- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Metaclasses – Making Classes (Not Instances) Smarter
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元类 – 使类（非实例）更智能
- en: The previous chapters have already shown us how to modify classes and functions
    using decorators. But that’s not the only option to modify or extend a class.
    An even more advanced technique for modifying your classes before creation is
    the usage of metaclasses. The name already gives you a hint as to what it could
    be; a metaclass is a class containing meta information about a class.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的章节已经向我们展示了如何使用装饰器修改类和函数。但这并不是修改或扩展类的唯一选项。在创建之前修改你的类的一个更高级的技术是使用元类。名称已经给你一个提示，它可能是什么；元类是一个包含有关类的元信息的类。
- en: The basic premise of a metaclass is a class that generates another class for
    you at definition time, so generally you wouldn’t use it to change the class instances,
    but only the class definitions. By changing the class definitions, it is possible
    to automatically add some properties to a class, validate whether certain properties
    are set, change inheritance, automatically register the class with a manager,
    and many other things.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 元类的基本前提是一个在定义时为你生成另一个类的类，所以通常你不会用它来改变类实例，而只会改变类定义。通过改变类定义，可以自动向类添加一些属性，验证某些属性是否已设置，改变继承，自动将类注册到管理器，以及许多其他事情。
- en: Although metaclasses are generally considered to be a more powerful technique
    than (class) decorators, effectively they don’t differ too much in possibilities.
    The choice usually comes down to either convenience or personal preference.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然元类通常被认为比（类）装饰器更强大的一种技术，但实际上它们在可能性上并没有太大的区别。选择通常取决于便利性或个人偏好。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Basic dynamic class creation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本动态类创建
- en: Metaclasses with arguments
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带参数的元类
- en: Abstract base classes, examples, and inner workings
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象基类、示例和内部工作原理
- en: Automatic plugin systems using metaclasses
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用元类的自动插件系统
- en: Internals of class creation and the order of operations
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类创建的内部和操作顺序
- en: Storing the definition order of class attributes
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储类属性的定义顺序
- en: Dynamically creating classes
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态创建类
- en: Metaclasses are the factories that create new classes in Python. In fact, even
    though you may not be aware of it, Python will always execute the `type` metaclass
    whenever you create a class.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 元类是Python中创建新类的工厂。实际上，即使你可能没有意识到，Python在创建类时总是会执行`type`元类。
- en: A few common examples where metaclasses are used internally are `abc` (abstract
    base classes), `dataclasses`, and the Django framework, which heavily relies on
    metaclasses for the `Model` class.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一些元类内部使用的常见示例包括`abc`（抽象基类）、`dataclasses`和Django框架，该框架严重依赖于元类来创建`Model`类。
- en: 'When creating classes in a procedural way, the `type` metaclass is used as
    a function that takes three arguments: `name`, `bases`, and `dict`.`name` will
    become the `__name__` attribute, `bases` is the list of inherited base classes
    and will be stored in `__bases__`, and `dict` is the namespace dictionary that
    contains all variables and will be stored in `__dict__`.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 以过程式创建类时，使用`type`元类作为一个接受三个参数的函数：`name`、`bases`和`dict`。`name`将变成`__name__`属性，`bases`是继承的基类列表，并将存储在`__bases__`中，`dict`是包含所有变量的命名空间字典，并将存储在`__dict__`中。
- en: It should be noted that the `type()` function has another use as well. Given
    the arguments documented above, it will create a class with those specifications.
    Given a single argument with the instance of a class (for example, `type(spam)`),
    it will return the class object/definition.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，`type()`函数还有另一个用途。给定上述文档化的参数，它将创建一个具有那些规格的类。给定一个类实例的单个参数（例如，`type(spam)`），它将返回类对象/定义。
- en: Your next question might be, what happens if I call `type()` on a class definition
    instead of a class instance? Well, that returns the metaclass for the class, which
    is `type` by default.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你的下一个问题可能是，如果我调用`type()`一个类定义而不是类实例会发生什么？嗯，那返回的是类的元类，默认情况下是`type`。
- en: 'Let’s clarify this using a few examples:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过几个示例来澄清这一点：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The above two definitions of `Spam` are completely identical; they both create
    a class with an instantiated property of `eggs` and `object` as a base. Let’s
    test whether this actually works as you would expect:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的两个`Spam`定义完全相同；它们都创建了一个具有实例属性`eggs`和以`object`为基类的类。让我们测试一下它是否真的像你预期的那样工作：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As expected, the results for the two are the same. When creating a class, Python
    will silently add the `type` metaclass, and custom metaclasses are classes that
    inherit `type`. A simple class definition has a silent metaclass, making a simple
    definition such as:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，两个的结果是相同的。当创建一个类时，Python会默默地添加`type`元类，而自定义元类是继承自`type`的类。一个简单的类定义有一个无声的元类，使得一个简单的定义如下：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'essentially identical to:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上等同于：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This raises the question: if every class is created by a (silent) metaclass,
    what is the metaclass of `type`? This is a recursive definition; the metaclass
    of `type` is `type`. That is the essence of what a custom metaclass is: a class
    that inherits `type` to allow class modification without needing to modify the
    class definition itself.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这引发了以下问题：如果每个类都是由一个（无声的）元类创建的，那么`type`的元类是什么？这是一个递归定义；`type`的元类是`type`。这就是自定义元类的本质：一个继承自`type`的类，允许在不修改类定义本身的情况下修改类。
- en: A basic metaclass
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个基本的元类
- en: 'Since metaclasses can modify any class attribute, you can do absolutely anything
    you wish. Before we continue with more advanced metaclasses, let’s create a metaclass
    that does the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 由于元类可以修改任何类属性，你可以做任何你想做的事情。在我们继续讨论更高级的元类之前，让我们创建一个执行以下操作的元类：
- en: Makes the class inherit `int`
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使类继承`int`
- en: Adds a `lettuce` attribute to the class
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向类添加`lettuce`属性
- en: Changes the name of the class
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 改变类的名称
- en: 'First we create the metaclass. After that, we create a class both with and
    without the metaclass:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建元类。然后，我们创建一个带有和不带有元类的类：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'First, the regular Sandwich:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，普通的三明治：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, the meta-Sandwich:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，元-Sandwich：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, the class with the custom metaclass now inherits `int`, has
    the `lettuce` attribute, and has a different name.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，现在具有自定义元类的类继承了`int`，具有`lettuce`属性，并且具有不同的名称。
- en: With metaclasses, you can modify any aspect of the class definition. That makes
    them a tool that is both very powerful and potentially very confusing. With just
    a few small modifications, you can cause the strangest of bugs in your (or others’)
    code.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用元类，你可以修改类定义的任何方面。这使得它们成为一个既非常强大又可能非常令人困惑的工具。通过一些小的修改，你可以在你的（或他人的）代码中引起最奇怪的bug。
- en: Arguments to metaclasses
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元类的参数
- en: 'The possibility of adding arguments to a metaclass is a little-known feature,
    but very useful nonetheless. In many cases, simply adding attributes or methods
    to a class definition is enough to detect what to do, but there are cases where
    it is useful to be more specific:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 向元类添加参数的可能性是一个鲜为人知的功能，但仍然非常有用。在许多情况下，仅仅向类定义添加属性或方法就足以检测要做什么，但有些情况下，更具体一些是有用的：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This simplistic example may not be useful, but the possibilities are. For example,
    a metaclass that automatically registers a plugin in a plugin registry could use
    this to specify plugin name aliases.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的例子可能没有太大用处，但可能性是存在的。例如，一个自动在插件注册表中注册插件的元类可以使用这个特性来指定插件名称别名。
- en: With this feature, instead of having to include all class-creating parameters
    as attributes and methods on the class, you can pass these arguments without polluting
    your class. The only thing you need to keep in mind is that both the `__new__`
    and `__init__` methods need to be extended in order for this to work because the
    arguments are passed to the metaclass constructor (`__init__`).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个特性，你不需要将所有创建类的参数作为属性和方法包含在类中，你可以传递这些参数而不污染你的类。你需要记住的唯一一点是，为了使这个功能正常工作，`__new__`
    和 `__init__` 方法都需要被扩展，因为参数是传递给元类构造函数（`__init__`）的。
- en: 'Since Python 3.6, however, we have had a simpler alternative to get this effect.
    Python 3.6 introduced the `__init_subclass__` magic method, which allows for similar
    modifications in a slightly easier way:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，从Python 3.6开始，我们已经有了这个效果的更简单替代方案。Python 3.6引入了`__init_subclass__`魔法方法，它以稍微简单一些的方式允许进行类似的修改：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Several of the metaclasses in this chapter could be replaced with the `__init_subclass__`
    method, and it is a very useful option for small modifications. For larger changes,
    I would recommend using a full metaclass instead to make the distinction between
    the regular class and the metaclass slightly more obvious.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的一些元类可以用`__init_subclass__`方法替换，这对于小的修改来说是一个非常实用的选项。对于更大的更改，我建议使用完整的元类，以便使普通类和元类之间的区别更加明显。
- en: Accessing metaclass attributes through classes
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过类访问元类属性
- en: 'When using metaclasses, it might be confusing that the class actually does
    more than simply construct the class; it’s actually inheriting the class during
    the creation. To illustrate:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用元类时，可能会让人困惑的是，类实际上做的不仅仅是简单地构造类；它实际上在创建过程中继承了类。为了说明：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As can be seen in the preceding example, these methods are only available for
    the class objects and not the instances. The `some_property` and `some_method`
    are not accessible through the instance, while they are accessible through the
    class. This can be useful for making some functions class- (as opposed to instance-)
    only, and it keeps your class namespace cleaner.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如前例所示，这些方法仅对类对象可用，而不是实例。`some_property`和`some_method`不能通过实例访问，而可以通过类访问。这可以用于使某些函数仅对类（而不是实例）可用，并使您的类命名空间更干净。
- en: In the general case, however, I suspect this only adds confusion, so I would
    typically recommend against it.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在一般情况下，我怀疑这只会增加混淆，所以我通常会建议反对这样做。
- en: Abstract classes using collections.abc
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用collections.abc的抽象类
- en: The abstract base classes (also known as interface classes) module is one of
    the most useful and most widely used examples of metaclasses in Python, as it
    makes it easy to ensure that a class adheres to a certain interface without a
    lot of manual checks. We have already seen some examples of abstract base classes
    in previous chapters, but now we will also look at their inner workings and some
    more advanced features, such as custom abstract base classes (ABCs).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象基类（也称为接口类）模块是Python中元类最有用和最广泛使用的例子之一，因为它使得确保类遵循特定接口而无需大量手动检查变得容易。我们已经在之前的章节中看到了一些抽象基类的例子，但现在我们还将探讨它们的内部工作原理和一些更高级的功能，例如自定义抽象基类（ABC）。
- en: Internal workings of the abstract classes
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抽象类的内部工作原理
- en: 'First, let’s demonstrate the usage of the regular abstract base class:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们演示常规抽象基类的用法：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you can see, the abstract base class blocks us from instantiating the classes
    until all abstract methods have been inherited. This is really useful when your
    code expects certain properties or methods to be available, but a sane default
    value is not an option. A common example of this is with base classes for plugins
    and data models.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，抽象基类阻止我们实例化类，直到所有抽象方法都被继承。这在您的代码期望某些属性或方法可用，但没有合理的默认值时非常有用。一个常见的例子是与插件和数据模型的基类。
- en: 'In addition to regular methods, `property`, `staticmethod`, and `classmethod`
    are also supported:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 除了常规方法外，还支持`property`、`staticmethod`和`classmethod`：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: So what does Python do internally? You could, of course, read the `abc.py` source
    code, but I think a simple explanation would be better.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 那么Python内部是如何做的呢？当然，您可以阅读`abc.py`源代码，但我认为一个简单的解释会更好。
- en: 'First, the `abc.abstractmethod` sets the `__isabstractmethod__` property on
    the function to `True`. So if you don’t want to use the decorator, you could simply
    emulate the behavior by doing something along the lines of:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`abc.abstractmethod`将函数的`__isabstractmethod__`属性设置为`True`。所以如果您不想使用装饰器，您可以通过以下类似的方式简单地模拟行为：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: After that, the `abc.ABCMeta` metaclass walks through all of the items in the
    `namespace` and looks for objects where the `__isabstractmethod__` attribute evaluates
    to `True`. In addition to that, it will walk through all `bases` and check the
    `__abstractmethods__` set for every base class, in case the class inherits an
    abstract class. All of the items where `__isabstractmethod__` still evaluates
    to `True` will be added to the `__abstractmethods__` set that is stored in the
    class as a `frozenset`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，`abc.ABCMeta`元类遍历`namespace`中的所有项，并查找`__isabstractmethod__`属性评估为`True`的对象。除此之外，它还会遍历所有`bases`，并检查每个基类的`__abstractmethods__`集合，以防类继承自抽象类。所有`__isabstractmethod__`仍然评估为`True`的项都将被添加到存储在类中的`__abstractmethods__`集合中，作为一个`frozenset`。
- en: Note that we don’t use `abc.abstractproperty`, `abc.abstractclassmethod`, and
    `abc.abstractstaticmethod`. Since Python 3.3, these have been deprecated as the
    `classmethod`, `staticmethod`, and `property` decorators are recognized by `abc.abstractmethod`,
    so a simple `property` decorator followed by an `abc.abstractmethod` is recognized
    as well. Take care when ordering the decorators; `abc.abstractmethod` needs to
    be the innermost decorator for this to work properly.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不使用 `abc.abstractproperty`、`abc.abstractclassmethod` 和 `abc.abstractstaticmethod`。从
    Python 3.3 开始，这些已经被弃用，因为 `classmethod`、`staticmethod` 和 `property` 装饰器被 `abc.abstractmethod`
    识别，所以简单的 `property` 装饰器后面跟着 `abc.abstractmethod` 也会被识别。在排序装饰器时要小心；`abc.abstractmethod`
    需要是最内层的装饰器，这样才能正常工作。
- en: 'The next question now is where the actual checks come in, the checks to see
    whether the classes are completely implemented. This actually functions through
    a few Python internals:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的问题是实际检查在哪里，即检查类是否完全实现。这实际上是通过几个 Python 内部机制来实现的：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can easily emulate the same behavior with a metaclass ourselves, but it
    should be noted that `abc.ABCMeta` actually does more, which we will demonstrate
    in the next section. To illustrate the behavior as described above, let’s create
    an abstract base metaclass that mimics `abc.ABCMeta`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以很容易地使用元类自己模拟相同的行为，但应该注意的是，`abc.ABCMeta` 实际上做得更多，我们将在下一节中演示。为了说明上述行为，让我们创建一个模拟
    `abc.ABCMeta` 的抽象基类元类：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now that we have the metaclass and decorator for creating abstract classes,
    let’s see if it works as expected:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了创建抽象类的元类和装饰器，让我们看看它是否按预期工作：
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The actual implementation is much more complicated since it needs to handle
    decorators such as `property`, `classmethod`, and `staticmethod`. It also has
    some caching to features, but this code covers the most useful part of the implementation.
    One of the most important tricks to note here is that the actual check is executed
    by decorating the `__new__` function of the actual class. This method is only
    executed once within a class, so we can avoid the overhead of these checks for
    multiple instantiations.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 实际实现要复杂得多，因为它需要处理如 `property`、`classmethod` 和 `staticmethod` 这样的装饰器。它还有一些缓存特性，但此代码涵盖了实现中最有用的部分。这里需要注意的一个最重要的技巧是，实际的检查是通过装饰实际类的
    `__new__` 函数来执行的。此方法在类中只执行一次，因此我们可以避免多次实例化时的检查开销。
- en: 'The actual implementation of the abstract methods can be found by looking for
    `__isabstractmethod__` in the Python source code in the following files: `Objects/descrobject.c`,
    `Objects/funcobject.c,` and `Objects/object.c`. The Python part of the implementation
    can be found in `Lib/abc.py`.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象方法的实际实现可以通过在以下文件中查找 `__isabstractmethod__` 来找到 Python 源代码：`Objects/descrobject.c`、`Objects/funcobject.c`
    和 `Objects/object.c`。实现中的 Python 部分可以在 `Lib/abc.py` 中找到。
- en: Custom type checks
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义类型检查
- en: 'Defining your own interfaces using abstract base classes is great, of course.
    But it can also be very convenient to tell Python what your class actually resembles
    and what kind of types are similar. For that, `abc.ABCMeta` offers a register
    function that allows you to specify which types are similar. For example, a custom
    `list` that sees the `list` type as similar:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，使用抽象基类定义自己的接口是很好的。但也可以很方便地告诉 Python 你的类实际上类似于什么，以及哪些类型是相似的。为此，`abc.ABCMeta`
    提供了一个注册函数，允许你指定哪些类型是相似的。例如，一个将 `list` 类型视为相似的定制 `list`：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As demonstrated by the last eight lines, this is a one-way relationship. The
    other way around requires inheriting `list`, but due to inheritance cycles, it
    can’t be done both ways. Otherwise, `CustomInheritingList` would inherit `list`
    and `list` would inherit `CustomInheritingList`, which could recurse forever during
    the `issubclass()` call.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如最后八行所示，这是一个单向关系。反过来则需要继承 `list`，但由于继承循环，不能双向进行。否则，`CustomInheritingList` 将继承
    `list`，而 `list` 将继承 `CustomInheritingList`，这可能导致在 `issubclass()` 调用期间无限递归。
- en: 'To be able to handle cases like these, there is another useful feature in `abc.ABCMeta`.
    When subclassing `abc.ABCMeta`, the `__subclasshook__` method can be extended
    to customize the behavior of `issubclass` and with that, `isinstance`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够处理这些情况，`abc.ABCMeta` 中还有一个有用的特性。当子类化 `abc.ABCMeta` 时，可以扩展 `__subclasshook__`
    方法来自定义 `issubclass` 和 `isinstance` 的行为：
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `__subclasshook__` should return `True`, `False`, or `NotImplemented`, which
    results in `issubclass` returning `True`, `False`, or the usual behavior when
    `NotImplemented` is returned.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`__subclasshook__` 应返回 `True`、`False` 或 `NotImplemented`，这将导致 `issubclass`
    返回 `True`、`False` 或在返回 `NotImplemented` 时的常规行为。'
- en: Automatically registering plugin systems
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动注册插件系统
- en: One very useful way to use metaclasses is to have classes automatically register
    themselves as plugins/handlers.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 使用元类的一个非常有用方法是将类自动注册为插件/处理器。
- en: Instead of manually adding a register call after creating the class or by adding
    a decorator, you can make it completely automatic for the user. That means that
    the user of your library or plugin system cannot accidentally forget to add the
    register call.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是在创建类后手动添加注册调用或通过添加装饰器来添加，你可以让它对用户来说完全自动。这意味着你的库或插件系统的用户不会意外忘记添加注册调用。
- en: Note the distinction between registering and importing. While this first example
    shows automatic registering, automatic importing is covered in later sections.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 注意区分注册和导入的区别。虽然这个第一个例子展示了自动注册，但自动导入将在后面的章节中介绍。
- en: Examples of these can be seen in many projects such as web frameworks. The Django
    web framework, for example, uses metaclasses for its database models (effectively
    tables) to automatically generate the table and column names based on the class
    and attribute names.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例可以在许多项目中看到，例如网络框架。例如，Django 网络框架使用元类来处理其数据库模型（实际上是表），根据类和属性名称自动生成表和列名称。
- en: 'The actual code base of projects like these is too extensive to usefully explain
    here though. Hence, we’ll show a simpler example that demonstrates the power of
    metaclasses as a self-registering plugin system:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这些项目的实际代码库过于庞大，无法在此有用地解释，因此我们将展示一个更简单的示例，以展示元类作为自注册插件系统的强大功能：
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This example is a tad simplistic of course, but it’s the basis for many plugin
    systems.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个例子有点简单，但它是许多插件系统的基础。
- en: While metaclasses run at definition time, the module still needs to be **imported**
    to work. There are several options for doing this; loading on-demand through the
    `get` method would have my vote if possible, as that also doesn’t add load time
    if the plugin is not used.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然元类在定义时运行，但模块仍然需要被 **导入** 才能工作。有几种方法可以做到这一点；如果可能的话，通过 `get` 方法按需加载将是我投票的选择，因为这样也不会增加插件未使用时的加载时间。
- en: 'The following examples will use the following file structure to get reproducible
    results. All files will be contained in a `plugins` directory. Note that all the
    code for this book, including this example, can be found on GitHub: [https://github.com/mastering-python/code_2](https://github.com/mastering-python/code_2).'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例将使用以下文件结构来获得可重复的结果。所有文件都将包含在 `plugins` 目录中。请注意，本书的所有代码，包括此示例，都可以在 GitHub
    上找到：[https://github.com/mastering-python/code_2](https://github.com/mastering-python/code_2)。
- en: 'The `__init__.py` file is used to create shortcuts, so a simple `import plugins`
    will result in having `plugins.Plugins` available, instead of requiring the import
    of `plugins.base` explicitly:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init__.py` 文件用于创建快捷方式，所以简单的 `import plugins` 将导致 `plugins.Plugins` 可用，而不是需要显式导入
    `plugins.base`：'
- en: '[PRE19]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here’s the `base.py` file containing the `Plugins` collection and the `Plugin`
    base class:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是包含 `Plugins` 集合和 `Plugin` 基类 的 `base.py` 文件：
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'And two simple plugins, `a.py` and `b.py` (omitted since it’s functionally
    identical to `a.py`):'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以及两个简单的插件，`a.py` 和 `b.py`（由于它与 `a.py` 功能上相同，所以被省略）：
- en: '[PRE21]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now that we have set up the plugins and the automatic registering, we need to
    take care of the loading of `a.py` and `b.py`. While `A` and `B` will automatically
    register within `Plugins`, if you forget to `import` them, they will not be registered.
    To solve this, we have several options; first we will look at on-demand loading.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了插件和自动注册，我们需要注意 `a.py` 和 `b.py` 的加载。虽然 `A` 和 `B` 将在 `Plugins` 中自动注册，但如果忘记导入它们，它们将不会注册。为了解决这个问题，我们有几种选择；首先我们将看看按需加载。
- en: Importing plugins on-demand
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 按需导入插件
- en: The first of the solutions for the import problem is simply taking care of it
    in the `get` method of the `Plugins` metaclass. Whenever the plugin is not found
    in the registry, the `get` method should automatically `import` the module from
    the `plugins` directory.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 解决导入问题的第一个方案是在 `Plugins` 元类的 `get` 方法中处理它。每当插件在注册表中找不到时，`get` 方法应自动从 `plugins`
    目录中 `import` 模块。
- en: The advantages of this approach are that the plugins don’t explicitly need to
    be preloaded, but also that the plugins are only loaded when the need is there.
    Unused plugins won’t be touched, so this method can help in reducing your applications’
    load times.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的优势在于插件不需要显式预加载，同时插件也只有在需要时才会加载。未使用的插件不会被触及，因此这种方法可以帮助减少应用程序的加载时间。
- en: The downsides are that the code will not be run or tested, so it might be completely
    broken and you won’t know about it until it is finally loaded. Solutions for this
    problem will be covered in the chapter on testing, *Chapter 10*. The other problem
    is that if the code self-registers into other parts of an application, then that
    code won’t be executed either, unless you add the required `import` in other parts
    of the code, that is.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 缺点是代码将不会运行或测试，因此它可能完全损坏，而你直到它最终加载时才知道。关于这个问题的解决方案将在第10章“测试”中介绍。另一个问题是，如果代码在应用程序的其他部分自我注册，那么该代码也不会被执行，除非你在代码的其他部分添加所需的`import`，也就是说。
- en: 'Modifying the `Plugins.get` method, we get the following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 修改`Plugins.get`方法，我们得到以下结果：
- en: '[PRE22]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now we run this from a Python file:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们从这个Python文件中运行它：
- en: '[PRE23]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Which results in:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这会导致以下结果：
- en: '[PRE24]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As you can see, this approach only results in running the `import` once; the
    second time, the plugin will be available in the plugins dictionary, so no loading
    will be necessary.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，这种方法只会运行一次`import`；第二次，插件将在插件字典中可用，因此不需要再次加载。
- en: Importing plugins through configuration
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过配置导入插件
- en: While only loading the required plugins is useful because it reduces your initial
    load time and memory overhead, there is something to be said about preloading
    the plugins you will likely need. As dictated by the Zen of Python, explicit is
    better than implicit, so an explicit list of plugins to load is generally a good
    solution. The added advantages of this method are that you are able to make the
    registration a bit more advanced as you are guaranteed it is run, and that you
    can load plugins from multiple packages. The disadvantage is, of course, that
    you need to explicitly define which plugins to load, which could be considered
    a violation of the DRY (Don’t Repeat Yourself) principle.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然只加载所需的插件是有用的，因为它可以减少你的初始加载时间和内存开销，但关于预先加载你可能会需要的插件也有一些话要说。根据Python的禅意，明确优于隐晦，所以一个明确的插件加载列表通常是一个好的解决方案。这种方法的优势在于，你可以确保注册更加高级，因为你可以保证它会运行，并且你可以从多个包中加载插件。当然，缺点是你需要明确定义要加载哪些插件，这可能会被视为违反DRY（不要重复自己）原则。
- en: 'Instead of importing in the `get` method, we will add a `load` method this
    time, which imports all the given module names:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们不再在`get`方法中导入，而是添加一个`load`方法，该方法导入所有给定的模块名称：
- en: '[PRE25]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Which can be called using the following code:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下代码调用：
- en: '[PRE26]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This results in the following output:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这会导致以下输出：
- en: '[PRE27]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: A fairly simple and straightforward system to load the plugins based on settings,
    this could easily be combined with any type of settings system to fill the `load`
    method. An example of this method is `INSTALLED_APPS` in Django.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 一个相当简单直接的系统，根据设置加载插件，这可以很容易地与任何类型的设置系统结合使用，以填充`load`方法。这种方法的一个例子是Django中的`INSTALLED_APPS`。
- en: Importing plugins through the filesystem
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过文件系统导入插件
- en: The most convenient method of loading plugins is one you don’t have to think
    about because it happens automatically. While this is very convenient, very important
    caveats should be considered.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 加载插件最方便的方法是无需思考的方法，因为它会自动发生。虽然这非常方便，但应该考虑一些非常重要的注意事项。
- en: First, they often make debugging much more difficult. Similar automatic import
    systems in Django have caused me a fair share of headaches, as they tend to obfuscate
    errors or even completely hide them, making you debug for hours.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它们往往会使调试变得更加困难。Django中类似的自动导入系统给我带来了不少麻烦，因为它们往往会模糊化错误，甚至完全隐藏它们，让你花费数小时进行调试。
- en: Second, it can be a security risk. If someone has write access to one of your
    plugin directories, they can effectively execute code within your application.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，这可能会带来安全风险。如果有人有权写入你的插件目录之一，他们可以有效地在你的应用程序中执行代码。
- en: Having that said, especially for beginners and/or new users of your framework,
    automatic plugin loading can be very convenient and certainly warrants a demonstration.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，特别是对于初学者和/或你的框架的新用户，自动插件加载可以非常方便，并且确实值得演示。
- en: This time, we inherit the `PluginsThroughConfiguration` class we created in
    the previous example, and add an `autoload` method to detect available plugins.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们继承了在前面示例中创建的`PluginsThroughConfiguration`类，并添加了一个`autoload`方法来检测可用的插件。
- en: '[PRE28]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, let’s give this code a try:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试运行这段代码：
- en: '[PRE29]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This results in:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这会导致：
- en: '[PRE30]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Now every file in the `plugins` directory will automatically be loaded. But
    note that it can obscure certain errors. For example, if one of your plugins imports
    a library that you do not have installed, you will get the `ImportError` from
    the plugin, not the actual library.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`plugins`目录中的每个文件都将自动加载。但请注意，这可能会掩盖某些错误。例如，如果你的某个插件导入了一个你没有安装的库，你将不会从实际库中收到`ImportError`，而是从插件中收到。
- en: To make this system a bit smarter (even importing packages outside of your Python
    path), you can create a plugin loader using the abstract base classes in `importlib.abc`;
    note that you will most likely still need to somehow list the files and/or directories
    though. To improve this, you could also take a look at the loaders in `importlib`.
    Using these loaders, you can load plugins from ZIP files and other sources as
    well.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要使这个系统更智能一些（甚至导入Python路径之外的包），你可以使用`importlib.abc`中的抽象基类创建一个插件加载器；请注意，你很可能仍然需要以某种方式列出文件和/或目录。为了改进这一点，你还可以查看`importlib`中的加载器。使用这些加载器，你可以从ZIP文件和其他来源加载插件。
- en: Now that we are done with plugin systems, it is time to look at how `dataclasses`
    could be implemented using metaclasses instead of decorators.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了插件系统，是时候看看如何使用元类而不是装饰器来实现`dataclasses`了。
- en: Dataclasses
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Dataclasses
- en: In *Chapter 4,* *Pythonic Design Patterns*, we already saw the `dataclasses`
    module, which makes it possible to implement easy type hinting and even enforce
    some structure in your classes.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第4章*，*Pythonic设计模式*中，我们已经看到了`dataclasses`模块，它使得在类中实现简单的类型提示甚至强制某些结构成为可能。
- en: Now let’s look at how we can implement our own version using a metaclass. The
    actual `dataclasses` module mostly relies on a class decorator, but that is no
    issue. Metaclasses can be seen as a more powerful version of a class decorator,
    so they will work fine. With metaclasses, you can use inheritance to reuse them,
    or make the class inherit other classes, but above all, they allow you to modify
    the class object, instead of the instance with decorators.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们如何使用元类实现自己的版本。实际的`dataclasses`模块主要依赖于类装饰器，但这不是问题。元类可以被视为类装饰器的更强大版本，所以它们将正常工作。使用元类，你可以使用继承来重用它们，或者使类继承其他类，但最重要的是，它们允许你修改类对象，而不是使用装饰器修改实例。
- en: 'The `dataclasses` module has several tricks up its sleeve that are non-trivial
    to replicate. Beyond adding documentation and some utility methods, it also generates
    an `__init__` method with a `signature` that matches the fields of the `dataclass`.
    Since the entire `dataclasses` module is roughly 1,300 lines, we will not get
    close with our implementation. So we will implement the `__init__()` method, including
    a generated `signature` and `__annotations__` for type hinting, and a `__repr__`
    method to show the results:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`dataclasses`模块中有几个非平凡的技巧，难以复制。除了添加文档和一些实用方法之外，它还生成一个与`dataclass`字段匹配的`__init__`方法。由于整个`dataclasses`模块大约有1,300行，我们的实现将无法接近。因此，我们将实现`__init__()`方法，包括为类型提示生成的`signature`和`__annotations__`，以及一个`__repr__`方法来显示结果：'
- en: '[PRE31]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'At first glance, this might look complicated, but the general process is actually
    fairly simple:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，这可能会看起来很复杂，但实际上整个过程相当简单：
- en: We generate a signature from the `__annotations__` and defaults in the class.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从类的`__annotations__`和默认值中生成一个签名。
- en: We generate an `__init__` method based on the signature.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们根据签名生成一个`__init__`方法。
- en: We make the `__init__` method use the signature to automatically bind the arguments
    passed to the function and apply those to the instance.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们让`__init__`方法使用签名来自动绑定传递给函数的参数并将它们应用到实例上。
- en: We generate a `__repr__` method, which simply prints the class name and the
    values stored in the instance. Note that this method is rather limited and will
    show anything you’ve added to the class.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们生成一个`__repr__`方法，该方法简单地打印出类的名称和存储在实例中的值。请注意，这个方法相当有限，会显示你添加到类中的任何内容。
- en: Note that as an extra little touch, we have a cast to the annotated type to
    enforce the type correctly.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，作为额外的小细节，我们有一个转换为注解类型的强制转换，以确保类型的正确性。
- en: 'Let’s see if it works as expected by using the `dataclass` example from *Chapter
    4* with a few small additions to test the type conversions:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过使用*第4章*中的`dataclass`示例并添加一些小的修改来测试类型转换，看看它是否按预期工作：
- en: '[PRE32]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: That all functions as expected, with similar output to the original `dataclass`.
    Naturally, it’s far more limited in features, but it shows how you can generate
    your own classes and functions dynamically, and how easy it is to add automatic
    annotation-based type casting to your code.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些按预期工作，输出与原始`dataclass`相似。当然，它的功能要有限得多，但它展示了如何动态生成自己的类和函数，以及如何轻松地将基于自动注解的类型转换添加到代码中。
- en: Next up is a deep dive into the creation and instantiation of classes.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将深入探讨类的创建和实例化。
- en: Order of operations when instantiating classes
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实例化类时的操作顺序
- en: 'The order of operations during class instantiation is very important to keep
    in mind when debugging issues with dynamically created and/or modified classes.
    Assuming an incorrect order can cause difficult-to-trace bugs. The instantiation
    of a class happens in the following order:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试动态创建和/或修改的类的问题时，操作顺序非常重要。假设一个错误的顺序可能会导致难以追踪的bug。类的实例化按照以下顺序进行：
- en: Finding the metaclass
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找元类
- en: Preparing the namespace
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备命名空间
- en: Executing the class body
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行类体
- en: Creating the class object
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建类对象
- en: Executing the class decorators
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行类装饰器
- en: Creating the class instance
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建类实例
- en: We will go through each of these now.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将逐一介绍这些内容。
- en: Finding the metaclass
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查找元类
- en: The metaclass comes from either the explicitly given metaclass on the class
    or `bases`, or by using the default `type` metaclass.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 元类来自类或`bases`中显式给出的元类，或者使用默认的`type`元类。
- en: 'For every class, the class itself and the bases, the first matching of the
    following will be used:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个类，包括类本身和基类，将使用以下匹配中的第一个：
- en: Explicitly given metaclass
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显式给出的元类
- en: Explicit metaclass from `bases`
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`bases`显式地定义元类
- en: '`type()`'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type()`'
- en: Note that if no metaclass is found that is a subtype of all of the candidate
    metaclasses, a `TypeError` will be raised. This scenario is not that likely to
    occur, but is certainly a possibility when using multiple inheritance/mixins with
    metaclasses.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果没有找到所有候选元类的子类型元类，将引发`TypeError`。这种情况不太可能发生，但在使用元类和多重继承/混入时确实有可能发生。
- en: Preparing the namespace
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备命名空间
- en: The class namespace is prepared through the metaclass selected above. If the
    metaclass has a `__prepare__` method, it will be called as `namespace = metaclass.__prepare__(names,
    bases, **kwargs)` where the `**kwargs` originate from the class definition. If
    no `__prepare__` method is available, the result will be `namespace = dict()`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 通过上述选择的元类准备类命名空间。如果元类有一个`__prepare__`方法，它将被调用为`namespace = metaclass.__prepare__(names,
    bases, **kwargs)`，其中`**kwargs`来自类定义。如果没有`__prepare__`方法可用，结果将是`namespace = dict()`。
- en: Note that there are multiple ways of achieving custom namespaces. As we saw
    in the previous section, the `type()` function call also takes a `dict` argument,
    which can be used to alter the namespace as well.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，有多种方法可以实现自定义命名空间。正如我们在上一节中看到的，`type()`函数调用也接受一个`dict`参数，可以用来更改命名空间。
- en: Executing the class body
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行类体
- en: 'The body of the class is executed very similarly to normal code execution with
    one key difference: the separate namespace. Since a class has a separate namespace,
    which shouldn’t pollute the `globals()`/`locals()` namespaces, it is executed
    within that context. The resulting call looks something like this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 类体的执行与正常代码执行非常相似，只有一个关键区别：独立的命名空间。由于类有一个独立的命名空间，不应污染`globals()`/`locals()`命名空间，因此它在那个上下文中执行。生成的调用看起来像这样：
- en: '[PRE33]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: where the `namespace` is the previously produced namespace.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 其中`namespace`是之前生成的命名空间。
- en: Creating the class object (not instance)
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建类对象（不是实例）
- en: Now that we have all components ready, the actual class object can be produced.
    This is done through the `class_ = metaclass(name, bases, namespace, **kwargs)`
    call, which is, as you can see, actually identical to the `type()` call previously
    discussed. The `**kwargs` here are the same as the ones passed to the `__prepare__`
    method earlier.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了所有组件，可以实际生成类对象。这是通过`class_ = metaclass(name, bases, namespace, **kwargs)`调用完成的，如您所见，这实际上与之前讨论的`type()`调用相同。这里的`**kwargs`与之前传递给`__prepare__`方法的相同。
- en: It might be useful to note that this is also the object that will be referenced
    from the `super()` call without arguments.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 可能需要注意，这也是`super()`不带参数引用的对象。
- en: Executing the class decorators
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行类装饰器
- en: Now that the class object is actually done already, the class decorators will
    be executed. Since this is only executed after everything else in the class object
    has already been constructed, it becomes difficult to modify class attributes
    such as which classes are being inherited and the name of the class. By modifying
    the `__class__` object, you can still modify or overwrite these, but it is, at
    the very least, more difficult.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在类对象实际上已经完成，类装饰器将被执行。由于这仅在类对象中的所有其他内容都已构建之后执行，因此修改类属性（如正在继承的类和类的名称）变得困难。通过修改`__class__`对象，你仍然可以修改或覆盖这些属性，但这至少是更困难的。
- en: Creating the class instance
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建类实例
- en: From the class object produced above, we can now finally create the actual instances
    as you normally would with a class. It should be noted that, unlike the steps
    above, this step and the class decorators step, are the only ones that are executed
    every time you instantiate a class. The steps before these two are only executed
    once per class definition.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面产生的类对象，我们现在可以最终创建实际的实例，就像通常使用类一样。需要注意的是，与上面的步骤不同，这一步和类装饰器步骤是每次实例化类时唯一执行的步骤。这两个步骤之前的步骤每个类定义只执行一次。
- en: Example
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例
- en: 'Enough theory – let’s illustrate the creation and instantiation of the class
    objects so we can check the order of operations:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 理论已经足够了——让我们通过展示类对象的创建和实例化来检查操作顺序：
- en: '[PRE34]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'With the created class and decorator, we can now illustrate when methods such
    as `__prepare__` and `__new__` are called:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 使用创建的类和装饰器，我们现在可以说明`__prepare__`和`__new__`等方法的调用时机：
- en: '[PRE35]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The example clearly shows the creation order of the class:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 示例清楚地显示了类的创建顺序：
- en: Preparing the namespace through `__prepare__`
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过`__prepare__`准备命名空间
- en: Creating the class body using `__new__`
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`__new__`创建类体
- en: 'Initializing the metaclass using `__init__` (note: this is not the class `__init__`)'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`__init__`初始化元类（注意：这不是类的`__init__`）
- en: Initializing the class through the class decorator
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过类装饰器初始化类
- en: Initializing the class through the class `__init__` function
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过类`__init__`函数初始化类
- en: One thing we can note from this is that class decorators are executed each and
    every time the class is actually instantiated and not before that. This can be
    both an advantage and a disadvantage, of course, but if you wish to build a register
    of all subclasses, it is definitely more convenient to use a metaclass since the
    decorator will not register until you instantiate the class.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 从这一点我们可以注意到，类装饰器是在类实际实例化时执行，而不是在此之前。这当然既有优点也有缺点，但如果你希望构建所有子类的注册表，使用元类肯定更方便，因为装饰器只有在实例化类之后才会注册。
- en: In addition to this, having the power to modify the namespace before actually
    creating the class object (not the instance) can be very powerful as well. This
    can be convenient for sharing a certain scope between several class objects, for
    example, or to easily ensure that certain items are always available in the scope.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在实际上创建类对象（而不是实例）之前修改命名空间的能力也非常强大。这可以方便地在几个类对象之间共享一定的作用域，例如，或者确保某些项目始终在作用域中可用。
- en: Storing class attributes in definition order
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按定义顺序存储类属性
- en: There are cases where the definition order makes a difference. For example,
    let’s assume we are creating a class that represents a CSV (Comma-Separated Values)
    format. The CSV format expects fields to have a particular order. In some cases,
    this will be indicated by a header, but it’s still useful to have a consistent
    field order. Similar systems are used in ORM systems such as SQLAlchemy to store
    the column order for table definitions, and for the input field order within forms
    in Django.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候定义顺序会起作用。例如，假设我们正在创建一个表示CSV（逗号分隔值）格式的类。CSV格式期望字段有特定的顺序。在某些情况下，这可能会由标题指示，但保持一致的字段顺序仍然很有用。类似系统在ORM系统如SQLAlchemy中用于存储表定义的列顺序，以及在Django表单中的输入字段顺序。
- en: The classic solution without metaclasses
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 没有元类的经典解决方案
- en: 'An easy way to store the order of the fields is by giving the field instances
    a special `__init__` method that increments for every definition, so the fields
    have an incrementing index property. This solution could be considered the classic
    solution, as it would also work in Python 2:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 存储字段顺序的一个简单方法是为字段实例提供一个特殊的`__init__`方法，该方法在每次定义时递增，因此字段具有递增的索引属性。这种解决方案可以被认为是经典解决方案，因为它在Python
    2中也能工作：
- en: '[PRE36]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: For convenience, and to make things prettier, we have added the `FieldsMeta`
    class.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便和使事物看起来更美观，我们添加了`FieldsMeta`类。
- en: It is not strictly required here, but it automatically takes care of filling
    in the `name` if needed, and adds the `fields` list, which contains a sorted list
    of fields.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这里不是严格必需的，但它会自动处理在需要时填充`name`，并添加包含字段排序列表的`fields`列表。
- en: Using metaclasses to get a sorted namespace
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用元类获取排序命名空间
- en: 'The previous solution is a bit more straightforward and supports Python 2 as
    well, but with Python 3 we have more options. As you have seen in the previous
    section, Python 3 gave us the `__prepare__` method, which returns the namespace.
    From *Chapter 4*, you might remember `collections.OrderedDict`, so let’s see what
    happens when we combine them:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的方法更直接一些，也支持Python 2，但使用Python 3我们有更多的选择。正如您在前一节中看到的，Python 3给了我们`__prepare__`方法，它返回命名空间。从*第4章*，您可能还记得`collections.OrderedDict`，那么让我们看看当我们结合它们会发生什么：
- en: '[PRE37]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: As you can see, the fields are indeed in the order we defined them. Spam first,
    eggs after that. Since the class namespace is now a `collections.OrderedDict`
    instance, we know that the order is guaranteed. It should be noted that, since
    Python 3.6, the order of the regular `dict` is also consistent, but the usage
    example of `__prepare__` is still useful. It demonstrates how convenient metaclasses
    can be to extend your classes in a generic way. Another big advantage of metaclasses
    instead of a custom `__init__` method is that users won’t lose the functionality
    if they forget to call the parent `__init__` method. The metaclass will always
    be executed, unless a different metaclass is added, that is.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，字段确实按照我们定义的顺序排列。首先是Spam，然后是鸡蛋。由于类命名空间现在是一个`collections.OrderedDict`实例，我们知道顺序是有保证的。需要注意的是，自Python
    3.6以来，普通`dict`的顺序也是一致的，但`__prepare__`的使用示例仍然有用。它展示了元类如何方便地以通用方式扩展你的类。与自定义`__init__`方法相比，元类的一个重大优势是，如果用户忘记调用父`__init__`方法，他们不会丢失功能。除非添加了不同的元类，否则元类总是会执行。
- en: Exercises
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'The most important point of this chapter is to teach you how metaclasses work
    internally: a metaclass is just a class that creates a class, which, in turn,
    is created by another metaclass (eventually ending up recursively at `type`).
    If you want to challenge yourself, however, there is more you can do with metaclasses:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 本章最重要的要点是教您如何内部工作元类：元类只是一个创建类的类，而这个类反过来又由另一个元类创建（最终递归到`type`）。然而，如果您想挑战自己，您还可以用元类做更多的事情：
- en: Validation is one of the most prominent examples of where metaclasses can be
    useful. You can validate to check if attributes/methods are available, you can
    check if required classes are inherited, and so on. The possibilities are endless.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证是元类可以非常有用的一个最突出的例子。你可以验证属性/方法是否存在，你可以检查是否继承了所需的类，等等。可能性是无限的。
- en: 'Build a metaclass that wraps every method with a decorator (could be useful
    for logging/debugging purposes), something with a signature like this:'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个元类，它将每个方法包装在装饰器中（可能对日志记录/调试目的有用），具有如下签名：
- en: '[PRE38]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Example answers for these exercises can be found on GitHub: [https://github.com/mastering-python/exercises](Chapter_8.xhtml).
    You are encouraged to submit your own solutions and learn about alternative solutions
    from others.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这些练习的示例答案可以在GitHub上找到：[https://github.com/mastering-python/exercises](Chapter_8.xhtml)。我们鼓励您提交自己的解决方案，并从他人的替代方案中学习。
- en: Summary
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The Python metaclass system is something every Python programmer uses all the
    time, perhaps without even knowing about it. Every class is created through some
    (subclass of) `type`, which allows for endless customization and magic.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: Python的元类系统是每个Python程序员都在使用的，也许他们甚至都不知道。每个类都是通过某种（子类）`type`创建的，这允许进行无限定制的魔法。
- en: Instead of statically defining your class, you can now have it created as you
    normally would and dynamically add, modify, or remove attributes from your class
    during definition; very magical but very useful. The magic component, however,
    is also the reason why metaclasses should be used with a lot of caution. While
    they can be used to make your life much easier, they are also among the easiest
    ways of producing completely incomprehensible code.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以像平时一样创建类，并在定义过程中动态地添加、修改或从你的类中删除属性；非常神奇但非常有用。然而，魔法成分也是为什么应该非常谨慎地使用元类的原因。虽然它们可以使你的生活变得更加容易，但它们也是产生完全无法理解的代码的最简单方法之一。
- en: Regardless, there are some great use cases for metaclasses, and many libraries
    such as SQLAlchemy and Django use metaclasses to make your code work much more
    easily and arguably better. Actually comprehending the magic that is used inside
    is generally not needed for the usage of these libraries, which makes the cases
    defendable.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 不论如何，元类有一些非常好的用例，许多库如SQLAlchemy和Django都使用元类来使你的代码工作得更加容易，并且可以说是更好。实际上理解这些库内部使用的魔法通常不是使用这些库所必需的，这使得这些用例有可辩护性。
- en: The question becomes whether a much better experience for beginners is worth
    some dark magic internally, and looking at the success of these libraries, I would
    say *yes* in this case.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 问题变成了是否一个对初学者来说更好的体验值得一些内部的黑暗魔法，并且从这些库的成功来看，我认为在这种情况下答案是肯定的。
- en: 'To conclude, when thinking about using metaclasses, keep in mind what Tim Peters
    once said:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，当考虑使用元类时，请记住蒂姆·彼得斯曾经说过的话：
- en: “Metaclasses are deeper magic than 99% of users should ever worry about.If you
    wonder whether you need them, you don’t.”
  id: totrans-213
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “元类比99%的用户应该关心的任何东西都要深奥。如果你想知道你是否需要它们，那么你就不需要。”
- en: With the introduction of class decorators and methods such as `__init_subclass__`
    and `__set_name__`, the need for metaclasses has dwindled even further. So when
    in doubt, you probably have no real need for them.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 随着类装饰器和`__init_subclass__`、`__set_name__`等方法的引入，对元类的需求进一步减少。所以当你犹豫不决时，你可能真的不需要它们。
- en: Now we will continue with a solution to remove some of the magic that metaclasses
    generate – documentation. The next chapter will show us how your code can be documented,
    how that documentation can be tested, and most importantly, how the documentation
    can be made smarter by annotating types.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将继续介绍一种解决方案来移除元类生成的一些魔法——文档。下一章将展示你的代码如何进行文档化，如何测试这些文档，以及最重要的是，如何通过注释类型使文档变得更加智能。
- en: Join our community on Discord
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的Discord社区
- en: 'Join our community’s Discord space for discussions with the author and other
    readers: [https://discord.gg/QMzJenHuJf](https://discord.gg/QMzJenHuJf)'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的Discord空间，与作者和其他读者进行讨论：[https://discord.gg/QMzJenHuJf](https://discord.gg/QMzJenHuJf)
- en: '![](img/QR_Code156081100001293319171.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![二维码](img/QR_Code156081100001293319171.png)'
