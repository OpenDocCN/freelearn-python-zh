- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Metaclasses – Making Classes (Not Instances) Smarter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous chapters have already shown us how to modify classes and functions
    using decorators. But that’s not the only option to modify or extend a class.
    An even more advanced technique for modifying your classes before creation is
    the usage of metaclasses. The name already gives you a hint as to what it could
    be; a metaclass is a class containing meta information about a class.
  prefs: []
  type: TYPE_NORMAL
- en: The basic premise of a metaclass is a class that generates another class for
    you at definition time, so generally you wouldn’t use it to change the class instances,
    but only the class definitions. By changing the class definitions, it is possible
    to automatically add some properties to a class, validate whether certain properties
    are set, change inheritance, automatically register the class with a manager,
    and many other things.
  prefs: []
  type: TYPE_NORMAL
- en: Although metaclasses are generally considered to be a more powerful technique
    than (class) decorators, effectively they don’t differ too much in possibilities.
    The choice usually comes down to either convenience or personal preference.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Basic dynamic class creation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Metaclasses with arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Abstract base classes, examples, and inner workings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatic plugin systems using metaclasses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Internals of class creation and the order of operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing the definition order of class attributes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamically creating classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Metaclasses are the factories that create new classes in Python. In fact, even
    though you may not be aware of it, Python will always execute the `type` metaclass
    whenever you create a class.
  prefs: []
  type: TYPE_NORMAL
- en: A few common examples where metaclasses are used internally are `abc` (abstract
    base classes), `dataclasses`, and the Django framework, which heavily relies on
    metaclasses for the `Model` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'When creating classes in a procedural way, the `type` metaclass is used as
    a function that takes three arguments: `name`, `bases`, and `dict`.`name` will
    become the `__name__` attribute, `bases` is the list of inherited base classes
    and will be stored in `__bases__`, and `dict` is the namespace dictionary that
    contains all variables and will be stored in `__dict__`.'
  prefs: []
  type: TYPE_NORMAL
- en: It should be noted that the `type()` function has another use as well. Given
    the arguments documented above, it will create a class with those specifications.
    Given a single argument with the instance of a class (for example, `type(spam)`),
    it will return the class object/definition.
  prefs: []
  type: TYPE_NORMAL
- en: Your next question might be, what happens if I call `type()` on a class definition
    instead of a class instance? Well, that returns the metaclass for the class, which
    is `type` by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s clarify this using a few examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The above two definitions of `Spam` are completely identical; they both create
    a class with an instantiated property of `eggs` and `object` as a base. Let’s
    test whether this actually works as you would expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, the results for the two are the same. When creating a class, Python
    will silently add the `type` metaclass, and custom metaclasses are classes that
    inherit `type`. A simple class definition has a silent metaclass, making a simple
    definition such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'essentially identical to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This raises the question: if every class is created by a (silent) metaclass,
    what is the metaclass of `type`? This is a recursive definition; the metaclass
    of `type` is `type`. That is the essence of what a custom metaclass is: a class
    that inherits `type` to allow class modification without needing to modify the
    class definition itself.'
  prefs: []
  type: TYPE_NORMAL
- en: A basic metaclass
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since metaclasses can modify any class attribute, you can do absolutely anything
    you wish. Before we continue with more advanced metaclasses, let’s create a metaclass
    that does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Makes the class inherit `int`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adds a `lettuce` attribute to the class
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Changes the name of the class
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First we create the metaclass. After that, we create a class both with and
    without the metaclass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'First, the regular Sandwich:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the meta-Sandwich:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the class with the custom metaclass now inherits `int`, has
    the `lettuce` attribute, and has a different name.
  prefs: []
  type: TYPE_NORMAL
- en: With metaclasses, you can modify any aspect of the class definition. That makes
    them a tool that is both very powerful and potentially very confusing. With just
    a few small modifications, you can cause the strangest of bugs in your (or others’)
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Arguments to metaclasses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The possibility of adding arguments to a metaclass is a little-known feature,
    but very useful nonetheless. In many cases, simply adding attributes or methods
    to a class definition is enough to detect what to do, but there are cases where
    it is useful to be more specific:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This simplistic example may not be useful, but the possibilities are. For example,
    a metaclass that automatically registers a plugin in a plugin registry could use
    this to specify plugin name aliases.
  prefs: []
  type: TYPE_NORMAL
- en: With this feature, instead of having to include all class-creating parameters
    as attributes and methods on the class, you can pass these arguments without polluting
    your class. The only thing you need to keep in mind is that both the `__new__`
    and `__init__` methods need to be extended in order for this to work because the
    arguments are passed to the metaclass constructor (`__init__`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Since Python 3.6, however, we have had a simpler alternative to get this effect.
    Python 3.6 introduced the `__init_subclass__` magic method, which allows for similar
    modifications in a slightly easier way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Several of the metaclasses in this chapter could be replaced with the `__init_subclass__`
    method, and it is a very useful option for small modifications. For larger changes,
    I would recommend using a full metaclass instead to make the distinction between
    the regular class and the metaclass slightly more obvious.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing metaclass attributes through classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When using metaclasses, it might be confusing that the class actually does
    more than simply construct the class; it’s actually inheriting the class during
    the creation. To illustrate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As can be seen in the preceding example, these methods are only available for
    the class objects and not the instances. The `some_property` and `some_method`
    are not accessible through the instance, while they are accessible through the
    class. This can be useful for making some functions class- (as opposed to instance-)
    only, and it keeps your class namespace cleaner.
  prefs: []
  type: TYPE_NORMAL
- en: In the general case, however, I suspect this only adds confusion, so I would
    typically recommend against it.
  prefs: []
  type: TYPE_NORMAL
- en: Abstract classes using collections.abc
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The abstract base classes (also known as interface classes) module is one of
    the most useful and most widely used examples of metaclasses in Python, as it
    makes it easy to ensure that a class adheres to a certain interface without a
    lot of manual checks. We have already seen some examples of abstract base classes
    in previous chapters, but now we will also look at their inner workings and some
    more advanced features, such as custom abstract base classes (ABCs).
  prefs: []
  type: TYPE_NORMAL
- en: Internal workings of the abstract classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, let’s demonstrate the usage of the regular abstract base class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the abstract base class blocks us from instantiating the classes
    until all abstract methods have been inherited. This is really useful when your
    code expects certain properties or methods to be available, but a sane default
    value is not an option. A common example of this is with base classes for plugins
    and data models.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to regular methods, `property`, `staticmethod`, and `classmethod`
    are also supported:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: So what does Python do internally? You could, of course, read the `abc.py` source
    code, but I think a simple explanation would be better.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the `abc.abstractmethod` sets the `__isabstractmethod__` property on
    the function to `True`. So if you don’t want to use the decorator, you could simply
    emulate the behavior by doing something along the lines of:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: After that, the `abc.ABCMeta` metaclass walks through all of the items in the
    `namespace` and looks for objects where the `__isabstractmethod__` attribute evaluates
    to `True`. In addition to that, it will walk through all `bases` and check the
    `__abstractmethods__` set for every base class, in case the class inherits an
    abstract class. All of the items where `__isabstractmethod__` still evaluates
    to `True` will be added to the `__abstractmethods__` set that is stored in the
    class as a `frozenset`.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we don’t use `abc.abstractproperty`, `abc.abstractclassmethod`, and
    `abc.abstractstaticmethod`. Since Python 3.3, these have been deprecated as the
    `classmethod`, `staticmethod`, and `property` decorators are recognized by `abc.abstractmethod`,
    so a simple `property` decorator followed by an `abc.abstractmethod` is recognized
    as well. Take care when ordering the decorators; `abc.abstractmethod` needs to
    be the innermost decorator for this to work properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next question now is where the actual checks come in, the checks to see
    whether the classes are completely implemented. This actually functions through
    a few Python internals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We can easily emulate the same behavior with a metaclass ourselves, but it
    should be noted that `abc.ABCMeta` actually does more, which we will demonstrate
    in the next section. To illustrate the behavior as described above, let’s create
    an abstract base metaclass that mimics `abc.ABCMeta`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the metaclass and decorator for creating abstract classes,
    let’s see if it works as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The actual implementation is much more complicated since it needs to handle
    decorators such as `property`, `classmethod`, and `staticmethod`. It also has
    some caching to features, but this code covers the most useful part of the implementation.
    One of the most important tricks to note here is that the actual check is executed
    by decorating the `__new__` function of the actual class. This method is only
    executed once within a class, so we can avoid the overhead of these checks for
    multiple instantiations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The actual implementation of the abstract methods can be found by looking for
    `__isabstractmethod__` in the Python source code in the following files: `Objects/descrobject.c`,
    `Objects/funcobject.c,` and `Objects/object.c`. The Python part of the implementation
    can be found in `Lib/abc.py`.'
  prefs: []
  type: TYPE_NORMAL
- en: Custom type checks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Defining your own interfaces using abstract base classes is great, of course.
    But it can also be very convenient to tell Python what your class actually resembles
    and what kind of types are similar. For that, `abc.ABCMeta` offers a register
    function that allows you to specify which types are similar. For example, a custom
    `list` that sees the `list` type as similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As demonstrated by the last eight lines, this is a one-way relationship. The
    other way around requires inheriting `list`, but due to inheritance cycles, it
    can’t be done both ways. Otherwise, `CustomInheritingList` would inherit `list`
    and `list` would inherit `CustomInheritingList`, which could recurse forever during
    the `issubclass()` call.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to handle cases like these, there is another useful feature in `abc.ABCMeta`.
    When subclassing `abc.ABCMeta`, the `__subclasshook__` method can be extended
    to customize the behavior of `issubclass` and with that, `isinstance`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `__subclasshook__` should return `True`, `False`, or `NotImplemented`, which
    results in `issubclass` returning `True`, `False`, or the usual behavior when
    `NotImplemented` is returned.
  prefs: []
  type: TYPE_NORMAL
- en: Automatically registering plugin systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One very useful way to use metaclasses is to have classes automatically register
    themselves as plugins/handlers.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of manually adding a register call after creating the class or by adding
    a decorator, you can make it completely automatic for the user. That means that
    the user of your library or plugin system cannot accidentally forget to add the
    register call.
  prefs: []
  type: TYPE_NORMAL
- en: Note the distinction between registering and importing. While this first example
    shows automatic registering, automatic importing is covered in later sections.
  prefs: []
  type: TYPE_NORMAL
- en: Examples of these can be seen in many projects such as web frameworks. The Django
    web framework, for example, uses metaclasses for its database models (effectively
    tables) to automatically generate the table and column names based on the class
    and attribute names.
  prefs: []
  type: TYPE_NORMAL
- en: 'The actual code base of projects like these is too extensive to usefully explain
    here though. Hence, we’ll show a simpler example that demonstrates the power of
    metaclasses as a self-registering plugin system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This example is a tad simplistic of course, but it’s the basis for many plugin
    systems.
  prefs: []
  type: TYPE_NORMAL
- en: While metaclasses run at definition time, the module still needs to be **imported**
    to work. There are several options for doing this; loading on-demand through the
    `get` method would have my vote if possible, as that also doesn’t add load time
    if the plugin is not used.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following examples will use the following file structure to get reproducible
    results. All files will be contained in a `plugins` directory. Note that all the
    code for this book, including this example, can be found on GitHub: [https://github.com/mastering-python/code_2](https://github.com/mastering-python/code_2).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `__init__.py` file is used to create shortcuts, so a simple `import plugins`
    will result in having `plugins.Plugins` available, instead of requiring the import
    of `plugins.base` explicitly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the `base.py` file containing the `Plugins` collection and the `Plugin`
    base class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'And two simple plugins, `a.py` and `b.py` (omitted since it’s functionally
    identical to `a.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have set up the plugins and the automatic registering, we need to
    take care of the loading of `a.py` and `b.py`. While `A` and `B` will automatically
    register within `Plugins`, if you forget to `import` them, they will not be registered.
    To solve this, we have several options; first we will look at on-demand loading.
  prefs: []
  type: TYPE_NORMAL
- en: Importing plugins on-demand
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first of the solutions for the import problem is simply taking care of it
    in the `get` method of the `Plugins` metaclass. Whenever the plugin is not found
    in the registry, the `get` method should automatically `import` the module from
    the `plugins` directory.
  prefs: []
  type: TYPE_NORMAL
- en: The advantages of this approach are that the plugins don’t explicitly need to
    be preloaded, but also that the plugins are only loaded when the need is there.
    Unused plugins won’t be touched, so this method can help in reducing your applications’
    load times.
  prefs: []
  type: TYPE_NORMAL
- en: The downsides are that the code will not be run or tested, so it might be completely
    broken and you won’t know about it until it is finally loaded. Solutions for this
    problem will be covered in the chapter on testing, *Chapter 10*. The other problem
    is that if the code self-registers into other parts of an application, then that
    code won’t be executed either, unless you add the required `import` in other parts
    of the code, that is.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modifying the `Plugins.get` method, we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we run this from a Python file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Which results in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this approach only results in running the `import` once; the
    second time, the plugin will be available in the plugins dictionary, so no loading
    will be necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Importing plugins through configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While only loading the required plugins is useful because it reduces your initial
    load time and memory overhead, there is something to be said about preloading
    the plugins you will likely need. As dictated by the Zen of Python, explicit is
    better than implicit, so an explicit list of plugins to load is generally a good
    solution. The added advantages of this method are that you are able to make the
    registration a bit more advanced as you are guaranteed it is run, and that you
    can load plugins from multiple packages. The disadvantage is, of course, that
    you need to explicitly define which plugins to load, which could be considered
    a violation of the DRY (Don’t Repeat Yourself) principle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of importing in the `get` method, we will add a `load` method this
    time, which imports all the given module names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Which can be called using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: A fairly simple and straightforward system to load the plugins based on settings,
    this could easily be combined with any type of settings system to fill the `load`
    method. An example of this method is `INSTALLED_APPS` in Django.
  prefs: []
  type: TYPE_NORMAL
- en: Importing plugins through the filesystem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most convenient method of loading plugins is one you don’t have to think
    about because it happens automatically. While this is very convenient, very important
    caveats should be considered.
  prefs: []
  type: TYPE_NORMAL
- en: First, they often make debugging much more difficult. Similar automatic import
    systems in Django have caused me a fair share of headaches, as they tend to obfuscate
    errors or even completely hide them, making you debug for hours.
  prefs: []
  type: TYPE_NORMAL
- en: Second, it can be a security risk. If someone has write access to one of your
    plugin directories, they can effectively execute code within your application.
  prefs: []
  type: TYPE_NORMAL
- en: Having that said, especially for beginners and/or new users of your framework,
    automatic plugin loading can be very convenient and certainly warrants a demonstration.
  prefs: []
  type: TYPE_NORMAL
- en: This time, we inherit the `PluginsThroughConfiguration` class we created in
    the previous example, and add an `autoload` method to detect available plugins.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s give this code a try:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Now every file in the `plugins` directory will automatically be loaded. But
    note that it can obscure certain errors. For example, if one of your plugins imports
    a library that you do not have installed, you will get the `ImportError` from
    the plugin, not the actual library.
  prefs: []
  type: TYPE_NORMAL
- en: To make this system a bit smarter (even importing packages outside of your Python
    path), you can create a plugin loader using the abstract base classes in `importlib.abc`;
    note that you will most likely still need to somehow list the files and/or directories
    though. To improve this, you could also take a look at the loaders in `importlib`.
    Using these loaders, you can load plugins from ZIP files and other sources as
    well.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are done with plugin systems, it is time to look at how `dataclasses`
    could be implemented using metaclasses instead of decorators.
  prefs: []
  type: TYPE_NORMAL
- en: Dataclasses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *Chapter 4,* *Pythonic Design Patterns*, we already saw the `dataclasses`
    module, which makes it possible to implement easy type hinting and even enforce
    some structure in your classes.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s look at how we can implement our own version using a metaclass. The
    actual `dataclasses` module mostly relies on a class decorator, but that is no
    issue. Metaclasses can be seen as a more powerful version of a class decorator,
    so they will work fine. With metaclasses, you can use inheritance to reuse them,
    or make the class inherit other classes, but above all, they allow you to modify
    the class object, instead of the instance with decorators.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `dataclasses` module has several tricks up its sleeve that are non-trivial
    to replicate. Beyond adding documentation and some utility methods, it also generates
    an `__init__` method with a `signature` that matches the fields of the `dataclass`.
    Since the entire `dataclasses` module is roughly 1,300 lines, we will not get
    close with our implementation. So we will implement the `__init__()` method, including
    a generated `signature` and `__annotations__` for type hinting, and a `__repr__`
    method to show the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'At first glance, this might look complicated, but the general process is actually
    fairly simple:'
  prefs: []
  type: TYPE_NORMAL
- en: We generate a signature from the `__annotations__` and defaults in the class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We generate an `__init__` method based on the signature.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We make the `__init__` method use the signature to automatically bind the arguments
    passed to the function and apply those to the instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We generate a `__repr__` method, which simply prints the class name and the
    values stored in the instance. Note that this method is rather limited and will
    show anything you’ve added to the class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that as an extra little touch, we have a cast to the annotated type to
    enforce the type correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see if it works as expected by using the `dataclass` example from *Chapter
    4* with a few small additions to test the type conversions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: That all functions as expected, with similar output to the original `dataclass`.
    Naturally, it’s far more limited in features, but it shows how you can generate
    your own classes and functions dynamically, and how easy it is to add automatic
    annotation-based type casting to your code.
  prefs: []
  type: TYPE_NORMAL
- en: Next up is a deep dive into the creation and instantiation of classes.
  prefs: []
  type: TYPE_NORMAL
- en: Order of operations when instantiating classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The order of operations during class instantiation is very important to keep
    in mind when debugging issues with dynamically created and/or modified classes.
    Assuming an incorrect order can cause difficult-to-trace bugs. The instantiation
    of a class happens in the following order:'
  prefs: []
  type: TYPE_NORMAL
- en: Finding the metaclass
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Preparing the namespace
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Executing the class body
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating the class object
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Executing the class decorators
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating the class instance
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will go through each of these now.
  prefs: []
  type: TYPE_NORMAL
- en: Finding the metaclass
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The metaclass comes from either the explicitly given metaclass on the class
    or `bases`, or by using the default `type` metaclass.
  prefs: []
  type: TYPE_NORMAL
- en: 'For every class, the class itself and the bases, the first matching of the
    following will be used:'
  prefs: []
  type: TYPE_NORMAL
- en: Explicitly given metaclass
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explicit metaclass from `bases`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`type()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that if no metaclass is found that is a subtype of all of the candidate
    metaclasses, a `TypeError` will be raised. This scenario is not that likely to
    occur, but is certainly a possibility when using multiple inheritance/mixins with
    metaclasses.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the namespace
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The class namespace is prepared through the metaclass selected above. If the
    metaclass has a `__prepare__` method, it will be called as `namespace = metaclass.__prepare__(names,
    bases, **kwargs)` where the `**kwargs` originate from the class definition. If
    no `__prepare__` method is available, the result will be `namespace = dict()`.
  prefs: []
  type: TYPE_NORMAL
- en: Note that there are multiple ways of achieving custom namespaces. As we saw
    in the previous section, the `type()` function call also takes a `dict` argument,
    which can be used to alter the namespace as well.
  prefs: []
  type: TYPE_NORMAL
- en: Executing the class body
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The body of the class is executed very similarly to normal code execution with
    one key difference: the separate namespace. Since a class has a separate namespace,
    which shouldn’t pollute the `globals()`/`locals()` namespaces, it is executed
    within that context. The resulting call looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: where the `namespace` is the previously produced namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the class object (not instance)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have all components ready, the actual class object can be produced.
    This is done through the `class_ = metaclass(name, bases, namespace, **kwargs)`
    call, which is, as you can see, actually identical to the `type()` call previously
    discussed. The `**kwargs` here are the same as the ones passed to the `__prepare__`
    method earlier.
  prefs: []
  type: TYPE_NORMAL
- en: It might be useful to note that this is also the object that will be referenced
    from the `super()` call without arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Executing the class decorators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that the class object is actually done already, the class decorators will
    be executed. Since this is only executed after everything else in the class object
    has already been constructed, it becomes difficult to modify class attributes
    such as which classes are being inherited and the name of the class. By modifying
    the `__class__` object, you can still modify or overwrite these, but it is, at
    the very least, more difficult.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the class instance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From the class object produced above, we can now finally create the actual instances
    as you normally would with a class. It should be noted that, unlike the steps
    above, this step and the class decorators step, are the only ones that are executed
    every time you instantiate a class. The steps before these two are only executed
    once per class definition.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Enough theory – let’s illustrate the creation and instantiation of the class
    objects so we can check the order of operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'With the created class and decorator, we can now illustrate when methods such
    as `__prepare__` and `__new__` are called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The example clearly shows the creation order of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the namespace through `__prepare__`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating the class body using `__new__`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Initializing the metaclass using `__init__` (note: this is not the class `__init__`)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Initializing the class through the class decorator
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Initializing the class through the class `__init__` function
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One thing we can note from this is that class decorators are executed each and
    every time the class is actually instantiated and not before that. This can be
    both an advantage and a disadvantage, of course, but if you wish to build a register
    of all subclasses, it is definitely more convenient to use a metaclass since the
    decorator will not register until you instantiate the class.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to this, having the power to modify the namespace before actually
    creating the class object (not the instance) can be very powerful as well. This
    can be convenient for sharing a certain scope between several class objects, for
    example, or to easily ensure that certain items are always available in the scope.
  prefs: []
  type: TYPE_NORMAL
- en: Storing class attributes in definition order
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are cases where the definition order makes a difference. For example,
    let’s assume we are creating a class that represents a CSV (Comma-Separated Values)
    format. The CSV format expects fields to have a particular order. In some cases,
    this will be indicated by a header, but it’s still useful to have a consistent
    field order. Similar systems are used in ORM systems such as SQLAlchemy to store
    the column order for table definitions, and for the input field order within forms
    in Django.
  prefs: []
  type: TYPE_NORMAL
- en: The classic solution without metaclasses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An easy way to store the order of the fields is by giving the field instances
    a special `__init__` method that increments for every definition, so the fields
    have an incrementing index property. This solution could be considered the classic
    solution, as it would also work in Python 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: For convenience, and to make things prettier, we have added the `FieldsMeta`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: It is not strictly required here, but it automatically takes care of filling
    in the `name` if needed, and adds the `fields` list, which contains a sorted list
    of fields.
  prefs: []
  type: TYPE_NORMAL
- en: Using metaclasses to get a sorted namespace
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The previous solution is a bit more straightforward and supports Python 2 as
    well, but with Python 3 we have more options. As you have seen in the previous
    section, Python 3 gave us the `__prepare__` method, which returns the namespace.
    From *Chapter 4*, you might remember `collections.OrderedDict`, so let’s see what
    happens when we combine them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the fields are indeed in the order we defined them. Spam first,
    eggs after that. Since the class namespace is now a `collections.OrderedDict`
    instance, we know that the order is guaranteed. It should be noted that, since
    Python 3.6, the order of the regular `dict` is also consistent, but the usage
    example of `__prepare__` is still useful. It demonstrates how convenient metaclasses
    can be to extend your classes in a generic way. Another big advantage of metaclasses
    instead of a custom `__init__` method is that users won’t lose the functionality
    if they forget to call the parent `__init__` method. The metaclass will always
    be executed, unless a different metaclass is added, that is.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The most important point of this chapter is to teach you how metaclasses work
    internally: a metaclass is just a class that creates a class, which, in turn,
    is created by another metaclass (eventually ending up recursively at `type`).
    If you want to challenge yourself, however, there is more you can do with metaclasses:'
  prefs: []
  type: TYPE_NORMAL
- en: Validation is one of the most prominent examples of where metaclasses can be
    useful. You can validate to check if attributes/methods are available, you can
    check if required classes are inherited, and so on. The possibilities are endless.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Build a metaclass that wraps every method with a decorator (could be useful
    for logging/debugging purposes), something with a signature like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Example answers for these exercises can be found on GitHub: [https://github.com/mastering-python/exercises](Chapter_8.xhtml).
    You are encouraged to submit your own solutions and learn about alternative solutions
    from others.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Python metaclass system is something every Python programmer uses all the
    time, perhaps without even knowing about it. Every class is created through some
    (subclass of) `type`, which allows for endless customization and magic.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of statically defining your class, you can now have it created as you
    normally would and dynamically add, modify, or remove attributes from your class
    during definition; very magical but very useful. The magic component, however,
    is also the reason why metaclasses should be used with a lot of caution. While
    they can be used to make your life much easier, they are also among the easiest
    ways of producing completely incomprehensible code.
  prefs: []
  type: TYPE_NORMAL
- en: Regardless, there are some great use cases for metaclasses, and many libraries
    such as SQLAlchemy and Django use metaclasses to make your code work much more
    easily and arguably better. Actually comprehending the magic that is used inside
    is generally not needed for the usage of these libraries, which makes the cases
    defendable.
  prefs: []
  type: TYPE_NORMAL
- en: The question becomes whether a much better experience for beginners is worth
    some dark magic internally, and looking at the success of these libraries, I would
    say *yes* in this case.
  prefs: []
  type: TYPE_NORMAL
- en: 'To conclude, when thinking about using metaclasses, keep in mind what Tim Peters
    once said:'
  prefs: []
  type: TYPE_NORMAL
- en: “Metaclasses are deeper magic than 99% of users should ever worry about.If you
    wonder whether you need them, you don’t.”
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: With the introduction of class decorators and methods such as `__init_subclass__`
    and `__set_name__`, the need for metaclasses has dwindled even further. So when
    in doubt, you probably have no real need for them.
  prefs: []
  type: TYPE_NORMAL
- en: Now we will continue with a solution to remove some of the magic that metaclasses
    generate – documentation. The next chapter will show us how your code can be documented,
    how that documentation can be tested, and most importantly, how the documentation
    can be made smarter by annotating types.
  prefs: []
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers: [https://discord.gg/QMzJenHuJf](https://discord.gg/QMzJenHuJf)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code156081100001293319171.png)'
  prefs: []
  type: TYPE_IMG
