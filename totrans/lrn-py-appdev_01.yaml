- en: Chapter 1. Developing Simple Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一章：开发简单应用
- en: Python is one of the most widely used dynamic programming languages. It supports
    a rich set of packages, GUI libraries, and web frameworks that enable you to build
    efficient cross-platform applications. It is an ideal language for rapid application
    development. Such fast-paced development often comes with its own baggage that
    could bring down the overall quality, performance, and extensibility of the code.
    This book will show you ways to handle such situations and help you develop better
    Python applications. The key concepts will be explained with the help of command-line
    applications, which will be progressively improved in subsequent chapters.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Python是最广泛使用的动态编程语言之一。它支持丰富的包、GUI库和Web框架，使您能够构建高效的跨平台应用。它是快速应用开发的理想语言。这种快速的开发往往伴随着自己的负担，可能会降低代码的整体质量、性能和可扩展性。本书将向您展示如何处理这种情况，并帮助您开发更好的Python应用。关键概念将通过命令行应用进行解释，这些应用将在后续章节中逐步改进。
- en: This chapter will be an introductory one. It will serve as a refresher to Python
    programming. That being said, it is expected you have some knowledge of Python
    language, as well as **object-oriented programming** (**OOP**) concepts.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将是一个入门章节。它将作为Python编程的复习。话虽如此，我们假设您对Python语言以及**面向对象编程**（**OOP**）概念有所了解。
- en: 'Here is how this chapter is organized:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节的组织结构如下：
- en: We will start with installation prerequisites and set up a proper environment
    for Python development.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将从安装必备条件开始，并为Python开发设置一个合适的环境。
- en: To set the tone right for the rest of the book, the next section will be a brief
    introduction to the *high fantasy theme* of the book.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了为本书的其余部分定下基调，下一节将简要介绍本书的**高幻想主题**。
- en: What follows next is our first program. It is a simple text-based fantasy game,
    presented as a Python script.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来是第一个程序。它是一个简单的基于文本的幻想游戏，以Python脚本的形式呈现。
- en: We will add some complexity to this game and develop an incremental version
    of the game using simple functions.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将向这个游戏添加一些复杂性，并使用简单的函数开发游戏的增量版本。
- en: Moving ahead, we will add more features to the game and redesign the code by
    applying OOP concepts.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在继续前进之前，我们将添加更多功能到游戏中，并通过应用OOP概念重新设计代码。
- en: The last topic will briefly cover **Abstract Base Classes** (**ABCs**) in Python.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一个主题将简要介绍Python中的**抽象基类**（**ABCs**）。
- en: The code explanation will be a bit verbose. More experienced readers can breeze
    past the examples and go to the next chapter, but be sure to understand the theme
    of the book and review the code in the `ch01_ex03.py` file. In the next few chapters,
    you will learn techniques to progressively improve this code.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 代码解释将稍微详细一些。有经验的读者可以快速浏览示例并进入下一章，但请确保理解本书的主题并回顾`ch01_ex03.py`文件中的代码。在接下来的几章中，您将学习逐步改进此代码的技术。
- en: Important housekeeping notes
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重要准备工作笔记
- en: 'Before diving into the rest of the chapter, let''s get some housekeeping out
    of the way. If you haven''t already, you should read the *Preface*, which documents
    most of the following things:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入本章的其余部分之前，让我们先做一些准备工作。如果您还没有做，您应该阅读*前言*，它记录了以下大部分内容：
- en: Every chapter will have its own set of Python source files. Although we will
    talk through most of the code, you should keep the relevant files at hand.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个章节都将有自己的Python源文件集。虽然我们将讨论大部分代码，但您应该手头保留相关文件。
- en: The source code can be downloaded from the Packt Publishing website. Follow
    the instructions mentioned in the *Preface*.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源代码可以从Packt Publishing网站下载。遵循*前言*中提到的说明。
- en: The code illustrated in this book is compatible with Python version 3.5.1\.
    The supporting code bundles also provide files compatible with version 2.7.9.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本书中的代码与Python版本3.5.1兼容。支持代码包还提供了与版本2.7.9兼容的文件。
- en: As noted before, it is assumed that you are familiar with basics of the Python
    language and know OOP concepts.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如前所述，我们假设您熟悉Python语言的基础知识，并且了解OOP概念。
- en: The book uses a fun, text-based game theme as a vehicle to explain various application
    development aspects. However, the book itself is not about developing game applications!
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本书采用有趣、基于文本的游戏主题作为解释各种应用开发方面的载体。然而，本书本身并不是关于开发游戏应用的！
- en: The solutions to the exercises (if any) are generally not provided.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习的解答（如果有）通常不会提供。
- en: The book provides several external links (URLs) for further reading. Over time,
    some of these links might end up being broken. If that ever happens, try searching
    the web with appropriate search terms.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本书提供了几个外部链接（URL）供进一步阅读。随着时间的推移，其中一些链接可能会损坏。如果发生这种情况，请尝试使用适当的搜索词在网络上搜索。
- en: Installation prerequisites
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装先决条件
- en: 'Let''s make sure that we have installed the prerequisites. Here is a table
    that summarizes the basic tools we need for this chapter and beyond; more verbose
    installation instructions follow in the next section:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 确保我们已经安装了先决条件。以下是一个表格，总结了本章及以后所需的基本工具；更详细的安装说明将在下一节中提供：
- en: '| Tool | Notes |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 工具 | 备注 |'
- en: '| --- | --- |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Python 3.5 | The code illustrated in this book is compatible with version
    3.5\. See the next table for available Python distributions. Supporting code bundles
    also provide 2.7.9 compatible files. |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| Python 3.5 | 本书中的代码与版本 3.5 兼容。请参阅下一表以获取可用的 Python 发行版。支持代码捆绑还提供与 2.7.9 兼容的文件。|'
- en: '| **pip** (package manager for Python) | The pip is already available in the
    official distribution for versions 3.5 and 2.7.9. |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| **pip**（Python 的包管理器）| pip 已经在 3.5 和 2.7.9 版本的官方发行版中提供。|'
- en: '| **IPython** | Optional installation. IPython is an enhanced Python interpreter.
    |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| **IPython** | 可选安装。IPython 是一个增强型 Python 解释器。|'
- en: '| **Integrated development environment** (**IDE**) | Use the Python editor
    or any IDE of your choice. Some good IDEs are listed in a table later in this
    chapter. |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| **集成开发环境（IDE**） | 使用 Python 编辑器或您选择的任何 IDE。本章后面将列出一些好的 IDE。|'
- en: In subsequent chapters, we will need to install some additional dependencies.
    The Python package manager (pip) will makes this a trivial task.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在后续章节中，我们需要安装一些额外的依赖项。Python 包管理器（pip）将使这项任务变得简单。
- en: Tip
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Have you already set up the required Python environment or know how to do it?
    Just skip the setup instructions that follow and move on to the *The theme of
    the book* section, where the real action begins!
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经设置了所需的 Python 环境，或者知道如何设置吗？只需跳过下面的设置说明，继续到 *本书主题* 部分，那里才是真正的行动开始的地方！
- en: Installing Python
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 Python
- en: There are two options to install Python. You can either use the official Python
    version or one of the freely available bundled distributions.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Python 有两种选择。您可以使用官方 Python 版本或免费提供的捆绑发行版之一。
- en: Option 1 – official distribution
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选项 1 – 官方发行版
- en: 'For Linux or Mac users, Python is probably already installed on your system.
    If not, you can install it using the package manager of your operating system.
    Windows OS users can install Python 3.5 by downloading the Python installer from
    the official Python website:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Linux 或 Mac 用户，Python 可能已经安装在您的系统上。如果没有，您可以使用操作系统的包管理器进行安装。Windows 操作系统用户可以从官方
    Python 网站下载 Python 安装程序来安装 Python 3.5：
- en: '![Option 1 – official distribution](img/B05034_01_30.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![选项 1 – 官方发行版](img/B05034_01_30.jpg)'
- en: During the installation process, just make sure to select the option that adds
    Python 3.5 to the system environment variable, `PATH`, as shown in the preceding
    screenshot. You can also visit the official Python website, [https://www.python.org/downloads](https://www.python.org/downloads),
    to get the platform-specific distribution.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装过程中，只需确保选择将 Python 3.5 添加到系统环境变量 `PATH` 的选项，如前面的截图所示。您还可以访问官方 Python 网站 [https://www.python.org/downloads](https://www.python.org/downloads)，以获取特定平台的发行版。
- en: Option 2 – bundled distribution
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选项 2 – 捆绑发行版
- en: 'Alternatively, there are several freely available Python distributions that
    bundle together useful Python packages, including pip and IPython. The following
    table summarizes some of the most popular Python distributions, including the
    official one:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，还有几个免费提供的 Python 捆绑发行版，它们将一些有用的 Python 软件包捆绑在一起，包括 pip 和 IPython。以下表格总结了最流行的几个
    Python 发行版，包括官方发行版：
- en: '| Distribution | Supported platforms | Notes |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 发行版 | 支持的平台 | 备注 |'
- en: '| --- | --- | --- |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Official Python distribution[https://www.python.org](https://www.python.org)
    | Windows, Linux, Mac |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 官方 Python 发行版[https://www.python.org](https://www.python.org) | Windows,
    Linux, Mac |'
- en: Freely available
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 免费提供
- en: Versions 2.7.9 and 3.5 include pip by default
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2.7.9 和 3.5 版本默认包含 pip
- en: '|'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Anaconda[http://continuum.io](http://continuum.io) | Windows, Linux, Mac
    |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| Anaconda[http://continuum.io](http://continuum.io) | Windows, Linux, Mac
    |'
- en: Freely available
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 免费提供
- en: Includes pip, IPython and Spyder IDE
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含 pip、IPython 和 Spyder IDE
- en: Bundles packages primarily for science, math, engineering, and data analysis
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主要捆绑科学、数学、工程和数据分析的软件包
- en: '|'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Enthought Canopy Express[https://www.enthought.com/canopy-express/](https://www.enthought.com/canopy-express/)
    | Windows, Linux, Mac |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| Enthought Canopy Express[https://www.enthought.com/canopy-express/](https://www.enthought.com/canopy-express/)
    | Windows, Linux, Mac |'
- en: Freely available
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 免费提供
- en: Includes pip and IPython
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含pip和IPython
- en: Integrates a Python code editor and application development platform
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成Python代码编辑器和应用程序开发平台
- en: '|'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Python(x, y)[https://python-xy.github.io/](https://python-xy.github.io/)
    | Windows |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| Python(x, y)[https://python-xy.github.io/](https://python-xy.github.io/)
    | Windows |'
- en: Freely available
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 免费提供
- en: Includes pip, IPython, and Spyder IDE
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含pip、IPython和Spyder IDE
- en: '|'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Python install location
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Python安装位置
- en: Let's briefly talk about the path where Python is installed, and how to make
    sure `python` is available as a command in your terminal window. Of course, things
    will widely vary, depending on where you install it and which Python distribution
    you choose.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要谈谈Python的安装路径，以及如何确保`python`在你的终端窗口中作为命令可用。当然，具体取决于你安装的位置和选择的Python发行版，情况会有很大差异。
- en: Tip
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'The official Python documentation page has comprehensive information on setting
    up the Python environment on different platforms. Here is a link, in case you
    need further help beyond what we have covered: [https://docs.python.org/3/using/index.html](https://docs.python.org/3/using/index.html).'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 官方Python文档页面提供了在不同平台上设置Python环境的详细信息。以下是一个链接，以防你需要进一步的帮助，超出我们已覆盖的内容：[https://docs.python.org/3/using/index.html](https://docs.python.org/3/using/index.html)。
- en: Unix-like operating systems
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 类Unix操作系统
- en: On a Unix-like operating system such as Linux, the default location is typically
    `/usr/bin/python` or `/usr/local/bin/python`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在类似于Linux的Unix操作系统上，默认位置通常是`/usr/bin/python`或`/usr/local/bin/python`。
- en: 'If you used your operating system''s package manager to install Python, the
    command `python` or `python3` should be available in the terminal window. If it
    isn''t, you need to update the `PATH` system environment variable to include the
    directory path to the Python executable. For example, if you have a **Bash** shell,
    add the following to the `.bashrc` file in your user home directory:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用操作系统的包管理器安装Python，`python`或`python3`命令应该在终端窗口中可用。如果不是，你需要更新`PATH`系统环境变量，包括Python可执行文件的目录路径。例如，如果你有一个**Bash**
    shell，将以下内容添加到你的用户主目录中的`.bashrc`文件：
- en: '[PRE0]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Specify the actual path to your Python installation in place of `/usr/bin`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 用你的Python安装的实际路径替换`/usr/bin`。
- en: Windows OS
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Windows操作系统
- en: 'On Windows OS, the default Python installation path is typically the following
    directory: `C:\Users\name\AppData\Local\Programs\Python\Python35-32\python.exe`.
    Replace `name` with your Windows username. Depending on your installer and system,
    the Python directory can also be `Python35-64`. As mentioned earlier, at the time
    of installation, you should select the option **Add Python 3.5 to PATH** to make
    sure `python` or `python.exe` are automatically recognized as commands. Alternatively,
    you can rerun the installer with just this option checked.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows操作系统上，默认的Python安装路径通常是以下目录：`C:\Users\name\AppData\Local\Programs\Python\Python35-32\python.exe`。将`name`替换为你的Windows用户名。根据你的安装程序和系统，Python目录也可以是`Python35-64`。如前所述，在安装时，你应该选择**将Python
    3.5添加到PATH**选项，以确保`python`或`python.exe`自动被识别为命令。或者，你可以仅选择此选项重新运行安装程序。
- en: Verifying Python installation
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 验证Python安装
- en: 'Open a terminal window (or command prompt on Windows OS) and type the following
    command to verify the Python version. This command will work if Python is installed
    and is available as a command in the terminal window. Otherwise, specify the full
    path to the Python executable. For instance, on Linux you can specify it as `/usr/bin/python`,
    if Python is installed in `/usr/bin`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows操作系统的终端窗口（或命令提示符）中输入以下命令以验证Python版本。如果Python已安装并且作为终端窗口中的命令可用，则此命令将生效。否则，指定Python可执行文件的完整路径。例如，在Linux上，如果Python安装在`/usr/bin`，你可以指定为`/usr/bin/python`：
- en: '[PRE1]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Tip
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Note that the `$` sign in the previous command line belongs to the terminal
    window and is not part of the command itself! Put another way, the actual command
    is just `python -V`. The `$` or `%` sign in the terminal window is a prompt for
    a normal user on Linux. For a root (admin) user, the sign is `#`. Likewise, on
    Windows OS, the corresponding symbol is `>`. You will type the actual command
    after this symbol.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，上一条命令行中的`$`符号属于终端窗口，不是命令本身的一部分！换句话说，实际命令只是`python -V`。在终端窗口中，`$`或`%`符号是Linux上普通用户的提示符。对于root（管理员）用户，符号是`#`。同样，在Windows操作系统上，相应的符号是`>`。你将在该符号之后输入实际命令。
- en: 'The following is just a sample output, if we run the preceding command:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 以下只是示例输出，如果我们运行前面的命令：
- en: '[PRE2]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Installing pip
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装 pip
- en: The pip is a software package manager that makes it trivial to install Python
    packages from the official third party software repository, **PyPI**. The pip
    is already installed for Python-2 version 2.7.9 or higher and Python-3 version
    3.4 or higher. If you are using a different Python version, check out [https://pip.pypa.io/en/stable/installing](https://pip.pypa.io/en/stable/installing)
    for the installation instructions.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: pip 是一个软件包管理器，它使得从官方第三方软件仓库 **PyPI** 安装 Python 软件包变得非常简单。对于 Python-2 版本 2.7.9
    或更高版本和 Python-3 版本 3.4 或更高版本，pip 已经安装。如果你使用的是不同的 Python 版本，请查看[https://pip.pypa.io/en/stable/installing](https://pip.pypa.io/en/stable/installing)
    以获取安装说明。
- en: 'On Linux OS, the default location for the pip is same as that of the Python
    executable. For example, if you have `/usr/bin/python`, then pip should be available
    as `/usr/bin/pip`. On Windows OS, the default `pip.exe` is typically the following:
    `C:\Users\name\AppData\Local\Programs\Python\Python35-32\Scripts\pip.exe`. As
    mentioned earlier, replace `name` with your Windows username. Depending on your
    installer and the system, the Python directory can also be `Python35-64`.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 操作系统上，pip 的默认位置与 Python 可执行文件的默认位置相同。例如，如果你有 `/usr/bin/python`，那么 pip
    应该可用为 `/usr/bin/pip`。在 Windows 操作系统上，默认的 `pip.exe` 通常如下所示：`C:\Users\name\AppData\Local\Programs\Python\Python35-32\Scripts\pip.exe`。如前所述，将
    `name` 替换为你的 Windows 用户名。根据你的安装程序和系统，Python 目录也可以是 `Python35-64`。
- en: Installing IPython
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装 IPython
- en: 'This is an optional installation. IPython is an enhanced version of the Python
    interpreter. If it is not already bundled in your Python distribution, you can
    install it with:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个可选安装。IPython 是 Python 解释器的增强版本。如果它还没有包含在你的 Python 发行版中，你可以使用以下命令安装它：
- en: '[PRE3]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'After the installation, just type `ipython` in the terminal to start the IPython
    interactive shell. Here is a screenshot of the IPython shell using the Anaconda
    Python 3.5 distribution:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，只需在终端中键入 `ipython` 即可启动 IPython 交互式外壳。以下是使用 Anaconda Python 3.5 发行版的 IPython
    外壳的截图：
- en: '![Installing IPython](img/B05034_01_01.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![安装 IPython](img/B05034_01_01.jpg)'
- en: Tip
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'It is often very convenient to use the **Jupyter Notebook** to write and share
    interactive programs. It is a web application that enables an interactive environment
    for writing Python code alongside rich text, images, plots, and so on. For further
    details, check out the project homepage at [http://jupyter.org/](http://jupyter.org/).
    The Jupyter Notebook can be installed with:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 **Jupyter Notebook** 编写和分享交互式程序通常非常方便。它是一个网络应用程序，它允许在丰富的文本、图像、图表等旁边编写 Python
    代码的交互式环境。有关更多详细信息，请查看项目主页[http://jupyter.org/](http://jupyter.org/)。Jupyter Notebook
    可以使用以下命令安装：
- en: '[PRE4]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Choosing an IDE
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择 IDE
- en: 'Using an IDE for development is a matter of personal preference. Simply put,
    an IDE is a tool intended to accelerate application development. It enables developers
    to write efficient code quickly by integrating the most common tools they need.
    The Python installation comes with a program called **IDLE**. It is a basic IDE
    for Python, which should get you started. For advanced development, you can choose
    from a number of freely or commercially available tools. Any good Python IDE has
    the following minimum features:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 IDE 进行开发是个人偏好的问题。简单来说，IDE 是一个旨在加速应用程序开发的工具。它通过集成他们最常用的工具，使开发者能够快速编写高效的代码。Python
    安装附带了一个名为 **IDLE** 的程序。这是一个基本的 Python IDE，应该能帮助你入门。对于高级开发，你可以从许多免费或商业工具中选择。任何好的
    Python IDE 都有以下基本功能：
- en: A source code editor with code completion and syntax highlighting features
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有代码补全和语法高亮功能的源代码编辑器
- en: A code browser to browse through files, projects, functions, and classes
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于浏览文件、项目、函数和类的代码浏览器
- en: A debugger to interactively identify problems
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于交互式识别问题的调试器
- en: A version control system integration such as **Git**
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成版本控制系统，如 **Git**
- en: You can get started by trying out one of the freely available IDEs. Here is
    a partial list of popular IDEs. If you are just interested in a simple source
    code editor, you can check out [https://wiki.python.org/moin/PythonEditors](https://wiki.python.org/moin/PythonEditors),
    for a list of available choices.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过尝试使用一个免费可用的 IDE 来开始。以下是一些流行的 IDE 的部分列表。如果你只对简单的源代码编辑器感兴趣，你可以查看[https://wiki.python.org/moin/PythonEditors](https://wiki.python.org/moin/PythonEditors)，以获取可用的选择列表。
- en: '| Python IDE | Notes |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| Python IDE | 备注 |'
- en: '| --- | --- |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| PyCharm Community Edition[https://www.jetbrains.com/pycharm](https://www.jetbrains.com/pycharm)
    | Has a free community edition. Excellent tool to begin Python development! |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| PyCharm Community Edition[https://www.jetbrains.com/pycharm](https://www.jetbrains.com/pycharm)
    | 提供免费社区版。是开始Python开发的优秀工具！|'
- en: '| Wing IDE 101[http://wingware.com/downloads/wingide-101](http://wingware.com/downloads/wingide-101)
    | Free for non-commercial purposes only. Commercial version available with additional
    features. Another excellent Python IDE. |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| Wing IDE 101[http://wingware.com/downloads/wingide-101](http://wingware.com/downloads/wingide-101)
    | 仅限非商业用途免费。提供额外功能的商业版本。另一个优秀的Python IDE。|'
- en: '| Spyder [https://pythonhosted.org/spyder](https://pythonhosted.org/spyder)
    | Freely available, open source. Also provided in bundled Python distributions
    such as Python(x,y) and Anaconda. |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| Spyder [https://pythonhosted.org/spyder](https://pythonhosted.org/spyder)
    | 免费且开源。也包含在Python(x,y)和Anaconda等捆绑Python发行版中。|'
- en: '| Eclipse PyDev[www.pydev.org](http://www.pydev.org) | Freely available, open
    source. |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| Eclipse PyDev[www.pydev.org](http://www.pydev.org) | 免费且开源。|'
- en: '| Sublime Text 2 or Sublime Text 3 (beta)[http://www.sublimetext.com/2](http://www.sublimetext.com/2)
    | Free for evaluation purposes only. Highly configurable IDE. |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| Sublime Text 2或Sublime Text 3（beta）[http://www.sublimetext.com/2](http://www.sublimetext.com/2)
    | 仅限评估目的免费。高度可配置的IDE。|'
- en: The theme of the book
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本书主题
- en: Have you read high fantasy novels, such as *The Lord of the Rings* or *The Hobbit*
    by J. R. R. Tolkien? Or watched the films based on these novels? Well, here is
    a high fantasy, "Tolkienesque" themed book on Python application development.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你读过J.R.R. Tolkien的高奇幻小说，如《魔戒》或《霍比特人》吗？或者看过基于这些小说的电影？好吧，这里有一本关于Python应用开发的“托尔金式”主题的高奇幻书籍。
- en: Tip
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: To find out more about J.R.R. Tolkien's work, see [https://en.wikipedia.org/wiki/J._R._R._Tolkien](https://en.wikipedia.org/wiki/J._R._R._Tolkien).
    The term *high fantasy* is often used to represent a fantasy theme set in an alternate
    fictional world. Check out [https://en.wikipedia.org/wiki/High_fantasy](https://en.wikipedia.org/wiki/High_fantasy)
    for more information.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于J.R.R. Tolkien的作品，请参阅[https://en.wikipedia.org/wiki/J._R._R._Tolkien](https://en.wikipedia.org/wiki/J._R._R._Tolkien)。术语*高奇幻*常用来表示设定在另一个虚构世界的奇幻主题。更多信息请查看[https://en.wikipedia.org/wiki/High_fantasy](https://en.wikipedia.org/wiki/High_fantasy)。
- en: This book takes you to an imaginary world where you will develop a text game
    based on the aforementioned theme. Yes, you can continue being a developer even
    in this imaginary world! During the course of the book, you will be accompanied
    by many fictional characters. While you learn different aspects of Python development,
    these characters will talk to you, ask questions, request new features, and even
    fight with the enemy.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 本书带你进入一个虚构的世界，在那里你将基于上述主题开发一个文本游戏。是的，你甚至在这个虚构世界中也可以继续作为开发者！在本书的过程中，你将伴随着许多虚构角色。当你学习Python开发的各个方面时，这些角色会与你交谈，提问，要求新功能，甚至与敌人战斗。
- en: It should be noted that this book is not about developing game applications.
    It uses a simple text-based game just as a medium to learn various development
    aspects.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 应注意，本书并非关于开发游戏应用。它使用简单的基于文本的游戏作为学习各种开发方面的媒介。
- en: Tip
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Off topic, if you are interested in playing a high fantasy theme game, there
    are quite a few to choose from. Among the open source ones, *Battle for Wesnoth*
    is one of the most highly rated, free, turn-based strategy games with a high fantasy
    theme. Check out [https://www.wesnoth.org](https://www.wesnoth.org), for more
    details.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 闲话少说，如果你对玩高奇幻主题游戏感兴趣，有很多可供选择。在开源游戏中，*Battle for Wesnoth* 是评分最高的免费、回合制策略游戏之一，具有高奇幻主题。更多信息请查看[https://www.wesnoth.org](https://www.wesnoth.org)。
- en: Meet the characters
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遇见角色
- en: 'Let''s meet the imaginary characters who will accompany you in various chapters:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们遇见将在各个章节中陪伴你的虚构角色：
- en: '| ![Meet the characters](img/B05034_01_31.jpg) | **Sir Foo**A human knight
    who is portrayed as a grand knight guarding the southern plains. He is our main
    character and will be talking to us throughout the book. |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| ![遇见角色](img/B05034_01_31.jpg) | **Sir Foo**一位被描绘为守护南部平原的伟大骑士的人类骑士。他是我们的主角，将在整本书中与我们交谈。|'
- en: '| ![Meet the characters](img/B05034_01_32.jpg) | **Orc Rider**An Orc is a human-like
    imaginary creature. Here, it is portrayed as an enemy soldier. The Orc is seen
    riding a wild boar-like creature. You will see this creature in this chapter.
    |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| ![遇见角色](img/B05034_01_32.jpg) | **Orc Rider**奥克是一种类似人类的人造生物。在这里，它被描绘为敌军士兵。奥克被看到骑在类似野猪的生物上。你将在本章中看到这种生物。|'
- en: '| ![Meet the characters](img/B05034_01_33.jpg) | **Elf Rider**An Elf is a supernatural
    mythical being. The Elf is mounted on an elvish horse. He is portrayed as a friendly.
    You will meet Mr. Elf in [Chapter 6](ch06.html "Chapter 6. Design Patterns"),
    *Design Patterns*. |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| ![遇见角色](img/B05034_01_33.jpg) | **精灵骑士**精灵是一种超自然的神话生物。精灵骑在一匹精灵马上。他被描绘为友好的。你将在[第6章](ch06.html
    "第6章。设计模式")，*设计模式*中遇到Mr. Elf。 |'
- en: '| ![Meet the characters](img/B05034_01_34.jpg) | **Fairy**An intelligent fairy
    with an inherent capability for magic. She will use her magic just once while
    finding her enchanted locket in [Chapter 7](ch07.html "Chapter 7. Performance
    – Identifying Bottlenecks"), *Performance Identifying Bottlenecks*, (See *O(log
    n)*). You will first meet her in [Chapter 6](ch06.html "Chapter 6. Design Patterns"),
    *Design Patterns*. |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| ![遇见角色](img/B05034_01_34.jpg) | **仙女**一位具有内在魔法能力的聪明仙女。当她找到她在[第7章](ch07.html
    "第7章。性能 – 识别瓶颈")，*性能识别瓶颈*中找到的魔法护身符时，她会使用她的魔法一次。（见 *O(log n)*）。你将在[第6章](ch06.html
    "第6章。设计模式")，*设计模式*中第一次遇见她。 |'
- en: '| ![Meet the characters](img/B05034_01_35.jpg) | **Dwarf**A Dwarf is a small
    human-like mythical being. He is portrayed as "The Great Dwarf" of the Foo mountains.
    He asks lots of questions. You will see him in the second half of the book, starting
    with [Chapter 6](ch06.html "Chapter 6. Design Patterns"), *Design Patterns*. |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| ![遇见角色](img/B05034_01_35.jpg) | **矮人**矮人是一种类似人类的小型神话生物。他被描绘为Foo山脉的“伟大的矮人”。他问了很多问题。你将在本书的第二部分看到他，从[第6章](ch06.html
    "第6章。设计模式")开始，*设计模式*。 |'
- en: With this fun theme as a vehicle, let's start our journey with a simple command-line
    application. It will be a text-based game. The complexities added in subsequent
    chapters will challenge you with interesting problems. The book will show you
    how to gracefully handle such situations.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 以这个有趣的主题为载体，让我们从简单的命令行应用程序开始我们的旅程。这将是一个基于文本的游戏。后续章节中添加的复杂性将挑战你面对有趣的问题。本书将向你展示如何优雅地处理这种情况。
- en: Simple script – Attack of the Orcs v0.0.1
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单脚本 – 兽人攻击 v0.0.1
- en: We have the required tools and the environment set up. It is now time to write
    our first Python program. It will be a simple game of chance, developed as a command-line
    application. As we advance further, we will add more complexity to the game and
    learn new techniques to develop efficient applications. So, get ready for action!
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好了所需的工具和环境。现在是时候编写我们的第一个Python程序了。它将是一个简单的机会游戏，作为一个命令行应用程序开发。随着我们进一步深入，我们将为游戏添加更多复杂性，并学习新的技术来开发高效的应用程序。所以，准备好行动吧！
- en: The game – Attack of the Orcs v0.0.1
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏 – 兽人攻击 v0.0.1
- en: '| *The war between humans and their arch enemies, the Orcs, was in the offing.
    A huge army of Orcs was heading toward the human establishments. They were virtually
    destroying everything in their way. The great kings of the human race joined hands
    to defeat their worst enemy for the great battle of their time. Men were summoned
    to join the rest of the army. Sir Foo, one of the brave knights guarding the southern
    plains, began a long journey toward the east, through an unknown dense forest.
    For two days and two nights, he moved cautiously through the thick woods. On his
    way, he spotted a small isolated settlement. Tired and hoping to replenish his
    food stock, he decided to take a detour. As he approached the village, he saw
    five huts. There was no one to be seen around. Hesitantly, he decided to enter
    a hut...* |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| *人类与其宿敌，兽人之间的战争即将爆发。一支庞大的兽人军队正向人类定居点进发。他们几乎摧毁了他们所经过的一切。人类种族的伟大国王们携手合作，为了他们时代的伟大战役，击败他们最凶恶的敌人。人们被召集加入军队。Foo爵士，一位勇敢的骑士，负责守卫南部的平原，开始了一段漫长的东行之旅，穿过一片未知的茂密森林。在两天两夜的谨慎行进中，他穿过茂密的树林。在路上，他发现了一个小型的孤立定居点。疲惫不堪，希望补充他的食物储备，他决定绕道而行。当他接近村庄时，他看到了五座小屋。周围看不到任何人。犹豫不决，他决定进入一座小屋...*
    |'
- en: '![The game – Attack of the Orcs v0.0.1](img/B05034_01_02.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![游戏 – 兽人攻击 v0.0.1](img/B05034_01_02.jpg)'
- en: Problem statement
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题陈述
- en: You are designing a simple game in which the player is required to choose a
    hut for Sir Foo. The huts are randomly occupied either by a friend or an enemy.
    It is also possible that some huts remain unoccupied. If the chosen one turns
    out to be an enemy hut, the player loses. In the other two scenarios, the player
    wins.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在设计一个简单的游戏，玩家需要为Foo爵士选择一座小屋。小屋可能被朋友或敌人随机占据，也可能有些小屋是空的。如果选中的是敌人的小屋，玩家就会失败。在其他两种情况下，玩家获胜。
- en: Pseudo code – version 0.0.1
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟代码 – 版本 0.0.1
- en: Now that the goal is clear, open your favorite editor and note down the main
    steps. This is sometimes referred to as a pseudo code.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 既然目标已经明确，打开您最喜欢的编辑器并记下主要步骤。这有时被称为伪代码。
- en: 'While the user wishes to keep playing the game:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户希望继续玩游戏时：
- en: Print the game mission
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印游戏任务
- en: Create a `huts` list
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个`huts`列表
- en: Randomly place `'enemy'` or `'friend'` or `'unoccupied'` in 5 huts
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随机放置`'enemy'`、`'friend'`或`'unoccupied'`在5个小屋中
- en: Prompt the player to select a hut number
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提示玩家选择小屋编号
- en: '`if enemy`: print `"you lose"`'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if enemy`: print `"you lose"`'
- en: '`else`: print `"you win"`'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`else`: print `"you win"`'
- en: 'As you will notice, the key piece of the code is to randomly occupy the five
    huts with either enemy or friend and keep the remaining ones unoccupied. How do
    we do this? Let''s quickly work this out using the Python interpreter. If you
    have installed IPython, start the IPython interpreter. Otherwise, just use the
    default Python interpreter by typing the command `python` in a terminal window.
    First, we need a Python list to hold all the occupant types. Next, we will use
    the built-in `random` module and call `random.choice` to pick one element randomly
    from this list. This code is shown in the following screen capture:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所注意到的，代码的关键部分是随机占用五个小屋，要么是敌人，要么是朋友，其余的保持空置。我们如何做到这一点？让我们快速使用Python解释器来解决这个问题。如果您已安装IPython，请启动IPython解释器。否则，只需在终端窗口中键入命令`python`即可使用默认的Python解释器。首先，我们需要一个Python列表来存储所有占用者类型。接下来，我们将使用内置的`random`模块并调用`random.choice`从该列表中随机选择一个元素。此代码在以下屏幕截图中显示：
- en: '![Pseudo code – version 0.0.1](img/B05034_01_03.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![伪代码 – 版本0.0.1](img/B05034_01_03.jpg)'
- en: Now, we just need to write the surrounding code. Let's review it next.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要编写周围的代码。让我们接下来回顾它。
- en: Reviewing the code
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查代码
- en: Download the source code, `ch01_ex01.py`, from the supplementary code bundle
    provided for this chapter. The file extension, `.py`, indicates that it is a Python
    file. Open it in a Python editor or an IDE of your choice. It is recommended that
    you keep this file handy while reading the following discussion. It is often easier
    to glance at the full code to understand it better. Observe the following code
    snippet. It is just a small portion of the code inside the `if __name__ == '__main__'`
    condition block in the aforementioned file.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 从本章提供的补充代码包中下载源代码，`ch01_ex01.py`。文件扩展名，`.py`，表示这是一个Python文件。在您选择的Python编辑器或IDE中打开它。建议您在阅读以下讨论时保留此文件。通常，浏览完整代码更容易理解。观察以下代码片段。这只是上述文件中`if
    __name__ == '__main__'`条件块内的一小部分代码。
- en: Tip
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you have Python 2.7.9 installed, there is a separate Python 2.7.9 compatible
    source provided in the supporting code bundle.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已安装Python 2.7.9，支持代码包中提供了一个单独的Python 2.7.9兼容源。
- en: '![Reviewing the code](img/B05034_01_04.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![检查代码](img/B05034_01_04.jpg)'
- en: 'Let''s review the code snippet in the preceding screenshot:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下前面截图中的代码片段：
- en: The first two lines import two built-in modules to gain access to the functionality
    provided within these modules. The `textwrap` module essentially provides features
    to nicely format the messages printed on the command line.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前两行导入两个内置模块以访问这些模块内提供的功能。`textwrap`模块本质上提供了格式化在命令行上打印的消息的功能。
- en: The `if` condition block, `if __name__ == '__main__'`, is invoked only when
    the file is run as a standalone script. In other words, the code inside this condition
    block won't be executed if you import this file in some other file.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if`条件块`if __name__ == ''__main__''`仅在文件作为独立脚本运行时调用。换句话说，如果您在其他文件中导入此文件，则此条件块内的代码不会执行。'
- en: Now, let's look at the code in this condition block. First, we will initialize
    a few variables. As demonstrated earlier, the list `occupants` stores the potential
    occupant types for the hut.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，让我们看看这个条件块中的代码。首先，我们将初始化一些变量。如前所述，列表`occupants`存储小屋的潜在占用者类型。
- en: The last few lines are just to format the text printed in the terminal window.
    The `dotted_line` is a string that will show a 72-character long line with hyphen
    symbols.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后几行只是为了格式化在终端窗口中打印的文本。`dotted_line`是一个字符串，将显示一个由连字符符号组成的72个字符长的行。
- en: The ASCII escape sequence is used to print the text in bold. The sequence `"\033[1m"`
    is to make bold text, and `"\033[0m"` is to go back to normal printing style.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ASCII转义序列来打印粗体文本。序列`"\033[1m"`用于使文本加粗，而`"\033[0m"`用于返回正常打印样式。
- en: 'The next few lines essentially print further information about the game in
    the console:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几行代码在控制台中打印有关游戏的更多信息：
- en: '![Reviewing the code](img/B05034_01_05.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![审查代码](img/B05034_01_05.jpg)'
- en: 'Let''s have a look at the code from the preceding screenshot:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看前面截图中的代码：
- en: The variable `msg` is a very long string. This is where the `textwrap` module
    is used.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量 `msg` 是一个非常长的字符串。这就是使用 `textwrap` 模块的地方。
- en: The `textwrap.fill` function wraps the message in such a way that each line
    is 72 characters long, as specified by the `width` in our code.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`textwrap.fill` 函数将消息包装成每行72个字符，正如我们在代码中指定的 `width`。'
- en: Now, let's review the following `while` loop.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回顾以下 `while` 循环。
- en: Tip
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'For Python 2.7.9, the only change required in the first example is to replace
    all the calls to the built-in function `input` with `raw_input`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Python 2.7.9，在第一个例子中需要做的唯一更改是将所有对内置函数 `input` 的调用替换为 `raw_input`：
- en: '[PRE5]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '![Reviewing the code](img/B05034_01_06.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![审查代码](img/B05034_01_06.jpg)'
- en: This top-level loop gives the player an option to play the game again.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个顶层循环给玩家提供了再次玩游戏的选择。
- en: Using `random.choice`, we randomly pick an occupant from the list of `occupants`
    and add it to the `huts` list. This was illustrated earlier.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `random.choice`，我们从 `occupants` 列表中的居住者中随机选择一个并添加到 `huts` 列表中。这已经在前面说明了。
- en: The built-in `input` function accepts a hut number of the user's choice as an
    integer. The `idx` variable stores a number.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置的 `input` 函数接受用户选择的棚屋编号作为整数。`idx` 变量存储一个数字。
- en: Next, it reveals the occupants by printing related information. Finally, it
    determines the winner by checking the list item corresponding to the hut number.
    Note that the `huts` list index starts at 0\. Therefore, to retrieve the list
    element for a given hut number, `idx`, we need to check the list index at `idx-1`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，它通过打印相关信息来揭示居住者。最后，通过检查与棚屋编号相对应的列表项来确定获胜者。请注意，`huts` 列表索引从 0 开始。因此，为了检索给定棚屋编号的列表元素
    `idx`，我们需要检查 `idx-1` 的列表索引。
- en: Running Attack of the Orcs v0.0.1
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行奥克之攻 v0.0.1
- en: 'Assuming you already have Python in your system environment variable, `PATH`
    (available as either `python` or `python3`), run the program from the command
    line as:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经在系统环境变量中安装了 Python，`PATH`（可用作 `python` 或 `python3`），从命令行运行程序如下：
- en: '[PRE6]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'That''s all! Just play the game and try to save Sir Foo by choosing the right
    hut! The following snapshot of a Linux terminal window shows our game in action:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些！只需玩游戏，并尝试通过选择正确的棚屋来救出Sir Foo！以下是一个Linux终端窗口的快照，显示了我们的游戏正在运行：
- en: '![Running Attack of the Orcs v0.0.1](img/B05034_01_07.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![运行奥克之攻 v0.0.1](img/B05034_01_07.jpg)'
- en: Using functions – Attack of the Orcs v0.0.5
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用函数 – 奥克之攻 v0.0.5
- en: In the last section, you wrote a quick set of instructions to create a nice
    little command-line game. You asked your friends to try it out and they kind of
    liked it (perhaps they were just trying to be nice!). You received the first feature
    request for the game.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一节中，你编写了一套快速指令来创建一个不错的命令行游戏。你让朋友们试玩，他们似乎很喜欢（也许他们只是想表现得友好！）。你收到了第一个关于游戏的特性请求。
- en: '| *"I think this game has good potential to grow. How about including combat
    in the next version of the game? When Sir Foo encounters an enemy, he should not
    just give up that easily. Fight with the enemy! Let the combat decide the winner.
    "-your friend* |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| *"我认为这个游戏有很大的发展潜力。关于在游戏的下一个版本中加入战斗怎么样？当Sir Foo遇到敌人时，他不应该那么轻易放弃。与敌人战斗！让战斗决定胜负。"-你的朋友*
    |'
- en: '![Using functions – Attack of the Orcs v0.0.5](img/B05034_01_08.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![使用函数 – 奥克之攻 v0.0.5](img/B05034_01_08.jpg)'
- en: You liked the idea and decided to add this capability to the code in the next
    version. Additionally, you also want to make it more interactive.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 你喜欢这个想法，并决定在下一个版本中添加这个功能。此外，你还想让它更具交互性。
- en: The script you wrote for the first program was small. However, as we go on adding
    new features, it will soon become a maintenance headache. As a step further, we
    will wrap the existing code into small functions so that the code is easier to
    manage. In functional programming, the focus is typically on function arrangement
    and their composition. For example, you can build complicated logic using a simple
    set of reusable functions.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你为第一个程序编写的脚本很小。然而，随着我们继续添加新功能，它很快就会变成一个维护难题。作为进一步的操作，我们将现有代码封装成小的函数，以便更容易管理。在函数式编程中，通常关注的是函数的排列和它们的组合。例如，你可以使用一组可重用的简单函数构建复杂的逻辑。
- en: Revisiting the previous version
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回顾上一个版本
- en: 'Before adding any new features, let''s revisit the script that you wrote in
    the previous version (version 0.0.1). We will identify the blocks of code that
    can be wrapped into functions. Such code chunks are marked in the two code snippets
    that follow:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加任何新功能之前，让我们回顾一下您在上一版本（版本 0.0.1）中编写的脚本。我们将识别可以封装成函数的代码块。以下两个代码片段中标记了这样的代码块：
- en: '![Revisiting the previous version](img/B05034_01_09.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![回顾上一个版本](img/B05034_01_09.jpg)'
- en: 'We will wrap most of the highlighted code into individual functions, as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把大部分高亮显示的代码封装成单独的函数，如下所示：
- en: '[PRE7]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![Revisiting the previous version](img/B05034_01_10.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![回顾上一个版本](img/B05034_01_10.jpg)'
- en: 'In addition to these six blocks of code, we can also create a few top-level
    functions to handle all this logic. In Python, the function is created using the
    `def` keyword, followed by the function name and arguments in parentheses. For
    example, the `reveal_occupants` function requires the information about the `huts`
    list. We also need to optionally pass the `dotted_line` string if we do not want
    to recreate it in the function. So, we will pass the hut number `idx`, the `huts`
    list, and the `dotted_line` string as function arguments. This function can be
    written as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这六个代码块之外，我们还可以创建一些顶级函数来处理所有这些逻辑。在Python中，使用 `def` 关键字创建函数，后跟括号内的函数名和参数。例如，`reveal_occupants`
    函数需要 `huts` 列表的信息。我们还需要可选地传递 `dotted_line` 字符串，如果我们不想在函数中重新创建它。因此，我们将小屋编号 `idx`、`huts`
    列表和 `dotted_line` 字符串作为函数参数传递。这个函数可以写成如下所示：
- en: '![Revisiting the previous version](img/B05034_01_11.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![回顾上一个版本](img/B05034_01_11.jpg)'
- en: 'After this initial work, the original script can be rewritten as:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这项初步工作之后，原始脚本可以被重写为：
- en: '![Revisiting the previous version](img/B05034_01_12.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![回顾上一个版本](img/B05034_01_12.jpg)'
- en: This is much easier to read now. What we just did is also referred to as **refactoring**;
    more on various refactoring techniques in a later chapter. It makes it easier
    to do changes to the individual methods. For example, if you want to customize
    the mission statement or scenario description, you do not need to open the main
    function, `run_application`. Similarly, `occupy_huts` can be expanded further
    without any clutter in the main code.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在阅读起来容易多了。我们刚才所做的也被称为**重构**；关于各种重构技术的更多内容将在后面的章节中介绍。这使得对单个方法的更改变得更加容易。例如，如果您想自定义任务声明或场景描述，您不需要打开主函数
    `run_application`。同样，`occupy_huts` 可以进一步扩展，而不会在主代码中造成混乱。
- en: Tip
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The initial refactored version of the code is not perfect. There is plenty of
    room for improvement. Can you reduce the burden of passing the `dotted_line` parameter
    or think of some other way to handle the printing of bold text?
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的初始重构版本并不完美。还有很多改进的空间。你能减少传递 `dotted_line` 参数的负担，或者想出其他处理打印粗体文本的方法吗？
- en: Pseudo code with attack feature – Version 0.0.5
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带有攻击功能的伪代码 – 版本 0.0.5
- en: In the previous section, we wrapped the game logic into individual functions.
    This not only improved the code readability, but also made it easier to maintain.
    Let's move on and include the new `attack()` function in the game. The following
    steps show the logic of the game with the attack feature included.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们将游戏逻辑封装到单独的函数中。这不仅提高了代码的可读性，还使得维护变得更加容易。让我们继续前进，并将新的 `attack()` 函数包含到游戏中。以下步骤展示了包含攻击功能的游戏逻辑。
- en: 'While the user wishes to keep playing the game:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户希望继续玩游戏时：
- en: Print game mission
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印游戏任务
- en: Create a `huts` list
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个 `huts` 列表
- en: Randomly place `'enemy'`, `'friend',` or `'unoccupied'` in 5 huts
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在5个小屋中随机放置 `'enemy'`、`'friend'` 或 `'unoccupied'`
- en: Prompt the player to select a hut number
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提示玩家选择小屋编号
- en: '`if` the hut has an enemy, do the following:'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if` 小屋里有敌人，执行以下操作：'
- en: '`while` the user wishes to continue the attack, use the `attack()` method on
    the enemy'
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`while` 用户希望继续攻击，使用 `attack()` 方法对敌人进行攻击'
- en: After each attack, update and show the health of Sir Foo, and of the enemy too;
    `if enemy health <= 0:` print `"You Win".`
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每次攻击后，更新并显示Sir Foo和敌人的健康状态；`if enemy health <= 0:` 打印 `"You Win".`
- en: But, `if Sir Foo health <= 0:` print `"You Lose".`
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 但是，`if Sir Foo health <= 0:` 打印 `"You Lose".`
- en: '`else` (hut has a friend or is unoccupied) print `"you win"`'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`else`（小屋里有朋友或为空）打印 `"you win"`'
- en: 'Initially, Sir Foo and the Orc will have full health. To quantify health, let''s
    assign hit points to each of these characters (or the game units). So, when we
    say the character has full health, it means it has the maximum possible hit points.
    Depending on the character, the default number of hit points will vary. The following
    image shows Sir Foo and the Orc with the default number of hit points, indicated
    by the **Health** label:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，弗鲁爵士和兽人将拥有满血量。为了量化血量，让我们给这些角色（或游戏单位）分配生命值。所以当我们说角色拥有满血量时，意味着它拥有最大可能的生命值。根据角色不同，默认的生命值数量会有所不同。以下图片显示了弗鲁爵士和兽人默认的生命值，由**生命值**标签指示：
- en: '![Pseudo code with attack feature – Version 0.0.5](img/B05034_01_36.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![带有攻击功能的伪代码 – 版本 0.0.5](img/B05034_01_36.jpg)'
- en: 'The bar above the **Health** label in the image represents a health meter.
    Essentially, it keeps track of the *hit points*. In the discussion that follows,
    we will use the terms hit points and health meter interchangeably. During the
    combat, either the player or the enemy will get injured. For now, neglect the
    third possibility where both escape unhurt. An injury will reduce the number of
    available hit points for the injured unit. In the game, we will assume that in
    a single attack turn only one of the characters is hit. The following image will
    help you imagine one such attack turn:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图像中**生命值**标签上方的条形图代表生命值。本质上，它跟踪的是*生命值*。在接下来的讨论中，我们将交替使用生命值和生命值表这两个术语。在战斗中，玩家或敌人可能会受伤。目前，忽略双方都毫发无损逃走的第三种可能性。伤害将减少受伤单位可用的生命值数量。在游戏中，我们将假设在单个攻击回合中只有一个角色被击中。以下图片将帮助您想象这样的攻击回合：
- en: '![Pseudo code with attack feature – Version 0.0.5](img/B05034_01_37.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![带有攻击功能的伪代码 – 版本 0.0.5](img/B05034_01_37.jpg)'
- en: Here, Sir Foo's health meter is shown as the maximum and the Orc has sustained
    injuries!
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，弗鲁爵士的生命值显示为最大值，而兽人则受到了伤害！
- en: '![Pseudo code with attack feature – Version 0.0.5](img/B05034_01_39.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![带有攻击功能的伪代码 – 版本 0.0.5](img/B05034_01_39.jpg)'
- en: '| *Hmm, the Orc thinks he can defeat Sir Foo! This is interesting. Let''s develop
    the game first and then see who has a better chance of winning!* |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| 嗯，兽人认为他能打败弗鲁爵士！这很有趣。我们先开发游戏，然后再看看谁有更大的胜算！ |'
- en: With this understanding of the problem, let's review the code that implements
    this feature.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在理解了这个问题之后，让我们回顾实现这个功能的代码。
- en: Reviewing the code
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 审查代码
- en: 'Download the source file, `ch01_ex02.py`, from the chapter''s code bundle and
    skim through the code. The key logic will be in the `attack()` function. We will
    also need a data structure to keep the health record of Sir Foo and the enemy.
    Let''s start by introducing the following utility functions that take care of
    some print business:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 从章节代码包中下载源文件`ch01_ex02.py`，并浏览代码。关键逻辑将在`attack()`函数中。我们还需要一个数据结构来保存弗鲁爵士和敌人的生命记录。让我们先介绍以下一些处理打印业务的实用函数：
- en: '![Reviewing the code](img/B05034_01_13.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![审查代码](img/B05034_01_13.jpg)'
- en: 'Now, look at the main function, `run_application`, and the supporting function,
    `reset_health_meter`. In addition to introducing the dictionary `health_meter`,
    we have also encapsulated the game logic in `play_game`:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，看看主函数`run_application`和辅助函数`reset_health_meter`。除了引入`health_meter`字典外，我们还将游戏逻辑封装在`play_game`中：
- en: '![Reviewing the code](img/B05034_01_14.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![审查代码](img/B05034_01_14.jpg)'
- en: 'At the start of a new game, the values of the `health_meter` dictionary are
    set back to the initial ones by calling `reset_health_meter`:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在新游戏开始时，通过调用`reset_health_meter`将`health_meter`字典的值重置为初始值：
- en: '![Reviewing the code](img/B05034_01_15.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![审查代码](img/B05034_01_15.jpg)'
- en: 'Next, let''s review the `play_game` function. If the hut has the enemy, the
    player will be asked if the attack should be continued (the start of the `while`
    loop). Based on the user input, the code calls the `attack` function or exits
    the current game:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们回顾一下`play_game`函数。如果小屋里有敌人，玩家将被询问是否继续攻击（`while`循环的开始）。根据用户输入，代码将调用`attack`函数或退出当前游戏：
- en: '![Reviewing the code](img/B05034_01_16.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![审查代码](img/B05034_01_16.jpg)'
- en: 'The enemy is attacked repetitively using the interactive `while` loop, which
    accepts user input. Execution of the `attack` function may result in injury to
    Sir Foo, or the enemy, or both. It is also possible that no one gets hurt. For
    simplicity, we will only consider two possibilities: a single attack that will
    injure either the enemy or Sir Foo. In the previous section, we used the built-in
    random number generator to randomly determine the occupants of the huts. We can
    use the same technique to determine who gets hurt:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 敌人通过交互式的`while`循环反复受到攻击，该循环接受用户输入。执行`attack`函数可能会导致Sir Foo或敌人受伤，或者两者都受伤。也有可能没有人受伤。为了简单起见，我们只考虑两种可能性：一次攻击可能会伤害敌人或Sir
    Foo。在前一节中，我们使用了内置的随机数生成器来随机确定棚屋的居住者。我们可以使用同样的技术来确定谁会受伤：
- en: '[PRE8]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '| *But hold on a minute. Sir Foo has something to say:* |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| *但是等等。Sir Foo有话要说：* |'
- en: '![Reviewing the code](img/B05034_01_17.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![审查代码](img/B05034_01_17.jpg)'
- en: We should take into account the chance of an injury to the player and to the
    enemy. In the `attack` function shown next, we will assume that for about *60%*
    of the time, the enemy will get hit and for the remaining *40%*, it is Sir Foo
    who is on the receiving end.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该考虑玩家和敌人受伤的可能性。在下面的`attack`函数中，我们将假设大约*60%*的时间敌人会被击中，而剩下的*40%*，Sir Foo将成为受害者。
- en: 'The simplest way is to create a list with 10 elements. This list should have
    six entries of `''enemy''` and four entries of `''player''`. Then, let `random.choice`
    select an element from this list. You can always introduce a difficulty level
    in the game and change this distribution:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的方法是创建一个包含10个元素的列表。这个列表应该有六个条目为`'enemy'`和四个条目为`'player'`。然后，让`random.choice`从这个列表中选择一个元素。你总是可以在游戏中引入一个难度级别并改变这种分布：
- en: '![Reviewing the code](img/B05034_01_18.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![审查代码](img/B05034_01_18.jpg)'
- en: Once the `injured_unit` is selected randomly, the `injury` is determined by
    picking a random number between `10` and `15`, inclusive. Here, we use the `random.randint`
    function. The final important step is to update the `health_meter` dictionary
    for the injured unit by reducing its number of hit points.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦随机选择`injured_unit`，伤害将通过在`10`和`15`之间选择一个随机数字来确定，包括`10`和`15`。在这里，我们使用`random.randint`函数。最后重要的一步是更新受伤单位的`health_meter`字典，减少其生命值。
- en: Running Attack of the Orcs v0.0.5
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 魔兽攻击v0.0.5
- en: 'We have discussed the most important functions in this game. Review the other
    supporting functions from the downloaded file. The following screenshot shows
    the game in action:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了这款游戏中最重要的功能。请回顾从下载的文件中获取的其他辅助功能。以下截图显示了游戏的实际运行情况：
- en: '![Running Attack of the Orcs v0.0.5](img/B05034_01_19.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![魔兽攻击v0.0.5](img/B05034_01_19.jpg)'
- en: Using OOP – Attack of the Orcs v1.0.0
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用面向对象编程 – 魔兽攻击v1.0.0
- en: The attack feature that you added in the previous game has made it a lot more
    interesting. You can see some friends coming back again and again to play the
    game. The new feature requests have started pouring in.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 你在上一款游戏中添加的攻击功能使游戏变得更加有趣。你可以看到一些朋友一次又一次地回来玩游戏。新的功能请求已经开始涌入。
- en: 'Here is a partial list of the requested features:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是请求的功能的部分列表：
- en: New mission to acquire all the huts and defeat all the enemies. This also means
    the hut occupants should be revealed right at the beginning of the game.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 新任务：占领所有棚屋并击败所有敌人。这也意味着游戏开始时就应该揭示棚屋的居住者。
- en: Ability to get healed in a friendly or unoccupied hut.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在友好的或未被占用的棚屋中恢复健康的能力。
- en: Ability to abandon combat (or run away from the enemy). This is a strategic
    move to run away, get healed in a friendly hut, and resume combat.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 放弃战斗（或从敌人那里逃跑）的能力。这是一个逃跑、在友好的棚屋中恢复健康并继续战斗的战略举措。
- en: Introduce one or more horse riders to assist Sir Foo. They can take turns to
    acquire huts. Ideally, a user-configurable option.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 引入一个或多个骑手来协助Sir Foo。他们可以轮流获得棚屋。理想情况下，这是一个用户可配置的选项。
- en: Ability to configure the maximum hit points for each enemy unit and each of
    the horse riders.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可配置每个敌人单位和每个骑手的最大生命值。
- en: Configurable total number of huts; for example, increase it to 10.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可配置的总棚屋数量；例如，增加到10个。
- en: Each hut can have either some gold or a weapon inside that Sir Foo and his friends
    can pick up.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个棚屋都可以有一些金币或武器，Sir Foo和他的朋友们可以捡起。
- en: Have an elf rider join Sir Foo. His abilities give him a very high chance of
    winning with fewer attacks.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让一个精灵骑手加入Sir Foo。他的能力使他有很高的几率在更少的攻击中获胜。
- en: 'This is quite a long list. You are preparing a plan. Here is a partial list
    of things you will need to add to the existing code to implement some of these
    features:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当长的列表。你正在制定一个计划。以下是你需要添加到现有代码中以实现一些这些功能的部分列表：
- en: Keeping track of the hit points of multiple enemy units occupying various huts
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪占据各个小屋的多个敌方单位的生命值
- en: Maintaining the health record of Sir Foo and all accompanying horse riders
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维护爵士福及其所有伴随骑手的健康记录
- en: Monitoring how many huts are acquired by Sir Foo's army
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控爵士福的军队占领了多少个小屋
- en: Another dictionary or list to keep track of the gold in each hut, and another
    one for weapons; additionally, what if someone wants to put armor in the hut?
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个字典或列表用于跟踪每个小屋中的金币，还有一个用于武器；此外，如果有人想在小屋中放置盔甲怎么办？
- en: Not to forget, yet another list of dictionary for each unit that accepts any
    of these goodies
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要忘记，还有另一个列表，为每个单位接受这些好东西的字典
- en: Ah! So they want an elf rider with its own traits and abilities...nice...thanks
    for the additional trouble!
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 啊！他们想要一个具有自己特性和能力的精灵骑手...不错...感谢你带来的额外麻烦！
- en: That is already a long list. While you could still continue to use the functional
    programming approach, in such scenarios it will get tougher as the game evolves
    and new features get added.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经是一个很长的列表了。虽然你仍然可以使用函数式编程方法，但随着游戏的演变和新功能的添加，在这种情况下将会变得更加困难。
- en: Thankfully, object-oriented programming comes to the rescue. How about making
    Sir Foo an instance of a `Knight` `class`? With this, it should be easy to manage
    parameters relevant to Sir Foo. For example, an attribute, `hitpoints`, can be
    used to keep track of Sir Foo's health instead of using the `health_meter` dictionary
    in the earlier example. Similarly, the other attributes in the class can keep
    track of the amount of gold or weapons collected while acquiring the huts (another
    requested feature).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，面向对象编程来拯救我们。我们是否可以让爵士福成为一个`Knight`类的实例？有了这个，应该很容易管理与爵士福相关的参数。例如，一个属性`hitpoints`可以用来跟踪爵士福的健康状况，而不是使用早期示例中的`health_meter`字典。同样，类中的其他属性可以跟踪在占领小屋时收集的金币或武器数量（另一个请求的功能）。
- en: There is a lot more beyond this bookkeeping. The various methods of the class
    would enable a specific implementation of behaviors, such as attack, run, heal,
    and so on. The horse riders accompanying Sir Foo can also be instances of the
    class `Knight`. Alternatively, you can create a new class called `HorseRider`
    for all these units that accept commands from Sir Foo.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书籍之外还有很多内容。这个类中的各种方法可以实现对行为的具体实现，例如攻击、奔跑、治疗等等。伴随爵士福的骑手也可以是这个类`Knight`的实例。或者，你可以创建一个新的类`HorseRider`，用于所有这些接受爵士福命令的单位。
- en: Prioritize the feature requests
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优先处理功能请求
- en: 'For this new version, let''s hand pick a few requested features from the earlier
    list. In fact, Sir Foo should be the one who makes this call:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个新版本，让我们从早期的列表中挑选一些请求的功能。实际上，爵士福应该是做出这个决定的人：
- en: '![Prioritize the feature requests](img/B05034_01_20.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![优先处理功能请求](img/B05034_01_20.jpg)'
- en: '| *As you wish, Sir Foo...we will only add the new heal feature in this version.*
    |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| *如您所愿，爵士福...我们只会在这个版本中添加新的治疗功能。* |'
- en: Problem statement
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题陈述
- en: It is now time to clearly define the targets for this release. You are not just
    adding new features to your application, but also making some fundamental changes
    to the code to accommodate future requests.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是明确定义这次发布目标的时候了。你不仅是在你的应用程序中添加新功能，还在对代码进行一些基本的更改，以适应未来的请求。
- en: In this version, the mission is to acquire all of the five huts. Here, you will
    implement a new `heal` feature to regain all the hit points for Sir Foo. You will
    also implement some strategic controls, such as running away from combat, getting
    healed in a friendly hut, and then returning rejuvenated to defeat the enemy.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个版本中，任务是占领所有五个小屋。在这里，你将实现一个新的`治疗`功能，以恢复爵士福的全部生命值。你还将实现一些战略控制，例如逃离战斗、在友好的小屋中治疗，然后焕然一新地返回击败敌人。
- en: Redesigning the code
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新设计代码
- en: We already discussed how creating a `Knight` class will help simplify the handling
    of data and all other things related to Sir Foo, be it the hit points or the way
    he attacks enemies.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论过创建`Knight`类将如何帮助简化与爵士福相关的数据处理和其他所有事情，无论是生命值还是他攻击敌人的方式。
- en: 'What other classes can be carved out? How about having the enemy as an object?
    The enemy could occupy multiple huts. Remember that we need to defeat all the
    enemies. Imagine the following scenario: Sir Foo injures an enemy in hut number
    2, thereby reducing its hit points. Then, he moves on to another hut occupied
    by another enemy. Now, we need to maintain two separate hit point counters for
    each of these enemy units.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以划分出哪些其他类？如何将敌人作为一个对象？敌人可以占据多个小屋。记住，我们需要击败所有敌人。想象以下场景：Sir Foo在编号2的小屋中伤害了一个敌人，从而减少了其生命值。然后，他移动到另一个由另一个敌人占据的小屋。现在，我们需要为每个这些敌人单位维护两个独立的生命值计数器。
- en: In a future version, you can expect users to ask for different enemy types with
    the ability to attack or heal, just like how we have it for Sir Foo. So, at this
    point, it makes sense to have a separate class, instances of which represent the
    enemy units. We will name this class `OrcRider`. It will have similar attributes
    to the `Knight` class. However, for simplicity, we will not give the enemy capabilities
    such as healing, changing huts, and so on.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在未来的版本中，你可以期待用户请求不同的敌人类型，具有攻击或治愈的能力，就像我们对Sir Foo所做的那样。因此，在这个阶段，有一个单独的类，其实例代表敌人单位是有意义的。我们将把这个类命名为`OrcRider`。它将具有与`Knight`类相似的属性。然而，为了简单起见，我们不会给敌人提供诸如治愈、改变小屋等能力。
- en: '| *Sir Foo says he is delighted to read that the enemy has been denied some
    important capabilities. (But you can''t see his happy face behind the helm.)*
    |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| *Sir Foo说他很高兴看到敌人被剥夺了一些重要能力。（但你无法看到他头盔后面的笑脸。)* |'
- en: There is something else we should consider. So far, `huts` was just a simple
    Python `list` object holding information about the occupant types as strings.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该考虑其他事情。到目前为止，`huts`只是一个简单的Python `list`对象，包含有关占用类型的信息作为字符串。
- en: Looking at the requested features list, we also need bookkeeping for the amount
    of gold and armor in the hut and to update its occupant, depending on the result
    of the fight. In a future version, you may also want to show some statistics,
    such as a historic record of the occupants, changes in the amount of gold, and
    so on. For all this and more, we will create a class, `Hut`.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 看到请求的功能列表，我们还需要记录小屋中金币和盔甲的数量，并根据战斗结果更新其居住者。在未来的版本中，你可能还希望显示一些统计数据，例如居住者的历史记录、金币数量的变化等。为此以及更多，我们将创建一个类，`Hut`。
- en: Painting the big picture
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 描绘整体画面
- en: Take a pen and paper and write down the important attributes we need for each
    class discussed so far. At this point, do not worry about classifying whether
    it is an instance variable or a class method that encapsulates instructions to
    perform specific tasks. Just write down what you think belongs to each class.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 拿起笔和纸，写下到目前为止讨论的每个类所需的重要属性。在这个阶段，不要担心将它们分类为实例变量或封装执行特定任务指令的类方法。只需写下你认为属于每个类的属性即可。
- en: 'The following schematic shows a list of potential attributes for the `Knight`,
    `Hut`, and `OrcRider` classes. The attribute names in strikethrough text indicate
    the potential attributes that won''t be implemented in this illustration. But,
    it is always good to think ahead and keep it at the back of your mind during the
    design phase of the application:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示意图显示了`Knight`、`Hut`和`OrcRider`类可能具有的属性列表。斜体字中的属性名称表示在本示例中不会实现的潜在属性。但是，在设计阶段始终考虑未来并牢记于心总是好的：
- en: '![Painting the big picture](img/B05034_01_21.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![描绘整体画面](img/B05034_01_21.jpg)'
- en: This is not a complete specification, but we have a good starting point now.
    When Sir Foo enters an enemy hut, we have a choice to call the `attack` method
    of the `Knight` class. As before, the `attack` method will randomly pick who gets
    injured and deduct the hit points for that character. In the `Knight` class, it
    is convenient to have a new attribute, `enemy,` that will represent the active
    opponent. In this example, `enemy` will be an instance of the `OrcRider` class.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个完整的规范，但现在我们有一个良好的起点。当Sir Foo进入敌人的小屋时，我们可以选择调用`Knight`类的`attack`方法。和以前一样，`attack`方法将随机选择谁会受到伤害，并扣除该角色的生命值。在`Knight`类中，有一个新的属性`enemy`将代表活跃的对手。在这个例子中，`enemy`将是一个`OrcRider`类的实例。
- en: Let's develop this design further. Did you notice that the `Knight` and `OrcRider`
    classes have several things in common? We will use the **inheritance** principle
    to create a superclass for these classes, and call it `GameUnit`. We will move
    the common code to the superclass, and let the subclasses override the things
    they want to implement differently. In the next section, we will represent these
    classes with a **Unified Modeling Language** (**UML**)-like diagram.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步开发这个设计。你注意到`Knight`和`OrcRider`类有几个共同点吗？我们将使用**继承**原则为这些类创建一个超类，并将其命名为`GameUnit`。我们将把共同代码移动到超类中，并让子类覆盖它们想要不同实现的部分。在下一节中，我们将用类似**统一建模语言**（**UML**）的图来表示这些类。
- en: Pseudo UML representation
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 伪UML表示
- en: 'The following diagram will help develop a basic understanding of how the various
    components talk to each other:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图将有助于了解各种组件之间是如何相互通信的：
- en: '![Pseudo UML representation](img/B05034_01_22.jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![伪UML表示](img/B05034_01_22.jpg)'
- en: The preceding diagram is similar to a UML representation. It helps create a
    visual representation of a software design. In this book, we will loosely follow
    the UML representations. Let's call the diagrams used here pseudo UML diagrams
    (or UML-like diagrams).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图类似于UML表示。它有助于创建软件设计的视觉表示。在这本书中，我们将松散地遵循UML表示。让我们称这里使用的图为伪UML图（或类似UML图）。
- en: Understanding the pseudo UML diagram
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解伪UML图
- en: 'An explanation is in order for the UML-like convention used here. We will represent
    each class in the schematics as a rounded rectangle. It shows the class name followed
    by its attributes. The plus sign (**+**) before the attribute indicates that it
    is public. A protected or private method is generally represented with a negative
    sign (**-**). All the attributes shown in this diagram are public attributes.
    So, optionally, you could add a plus sign next to each attribute. In later chapters,
    we will follow this convention. For ease of illustration, only a few relevant
    public attributes will be listed. Observe that we are using different types of
    connectors in this diagram:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这里使用的类似UML的约定，需要加以解释。我们将用圆角矩形表示图中的每个类。它显示了类名后跟其属性。属性前的加号（**+**）表示它是公共的。受保护的或私有方法通常用负号（**-**）表示。此图中显示的所有属性都是公共属性。因此，你可以选择在每个属性旁边添加一个加号。在后面的章节中，我们将遵循此约定。为了便于说明，只列出了几个相关的公共属性。请注意，我们在此图中使用了不同类型的连接器：
- en: The arrowhead with an empty triangle symbol represents inheritance; for example,
    the `Knight` class inherits from the `GameUnit` class
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有空三角符号的箭头表示继承；例如，`Knight`类继承自`GameUnit`类
- en: The arrowhead with a filled diamond symbol represents **object composition**,
    for example, a `Hut` instance has an object of the `GameUnit` class (or its subclasses)
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有实心菱形符号的箭头表示**对象组合**，例如，一个`Hut`实例拥有`GameUnit`类（或其子类）的对象
- en: The arrowhead with an empty diamond symbol represents **object aggregation**
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有空菱形符号的箭头表示**对象聚合**
- en: Now, let's talk about the individual components of the diagram presented earlier.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来讨论之前展示的图中的各个组成部分。
- en: The `Knight` and `OrcRider` classes inherit from `GameUnit`. The `Knight` class,
    in this case, will override default methods, such as `attack`, `heal`, and `run_away`.
    The `OrcRider` class will not have such overridden methods, as we will not give
    these capabilities to the enemy.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`Knight`和`OrcRider`类继承自`GameUnit`。在这种情况下，`Knight`类将覆盖默认方法，如`attack`、`heal`和`run_away`。`OrcRider`类将不会有这样的覆盖方法，因为我们不会赋予敌人这些能力。'
- en: The `Hut` class will have an occupant. The occupant can either be an instance
    of the `Knight` or the `OrcRider`, or the `None` type if the hut is unoccupied.
    The filled diamond connector in the diagram indicates composition.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '`Hut`类将有一个居住者。居住者可以是`Knight`或`OrcRider`的实例，或者如果小屋未被占用，则是`None`类型。图中的实心菱形连接器表示组合。'
- en: Tip
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Object composition**'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '**对象组合**'
- en: It is an important OOP principle. It implies a has-a relationship. In this case,
    `Hut` contains, or is composed of, some other object that is to be used to perform
    specific tasks. Just say it out loud; a `Hut` has-a `Knight`, a `Hut` has-an `OrcRider`,
    and so on.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个重要的面向对象编程原则。它意味着一种“拥有”关系。在这种情况下，`Hut`包含，或由，一些其他对象组成，这些对象将被用来执行特定任务。大声说出来；一个`Hut`有一个`Knight`，一个`Hut`有一个`OrcRider`，等等。
- en: In addition to the four classes discussed, we will introduce another one to
    encapsulate the top-level code. Let's call it `AttackOfTheOrcs`. As there are
    five huts, a class method in `AttackOfTheOrcs` creates that number of `Hut` instances.
    This is object aggregation, shown by the empty diamond shaped arrow in the preceding
    diagram.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前面讨论的四个类，我们还将引入另一个类来封装顶层代码。让我们称它为 `AttackOfTheOrcs`。由于有五个小屋，`AttackOfTheOrcs`
    类中的一个类方法创建了相应数量的 `Hut` 实例。这是对象聚合，如前图中空菱形箭头所示。
- en: Have you noticed another has-a relationship in `AttackOfTheOrcs`? The `player`
    attribute in this class is an instance of the `Knight` class, but in the future,
    this could change. This relationship is indicated by the filled diamond-head connector
    joining the `Knight` and `AttackOfTheOrcs` boxes.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否注意到了 `AttackOfTheOrcs` 中的另一个“有”关系？这个类中的 `player` 属性是 `Knight` 类的一个实例，但将来这可能会改变。这种关系由连接
    `Knight` 和 `AttackOfTheOrcs` 方框的实心菱形头连接器表示。
- en: Reviewing the code
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查代码
- en: With this high-level understanding, let's begin developing the code. Download
    the Python source file, `ch01_ex03.py`. We will review only a few important methods
    in the code. Refer to this source file for the complete code.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在有了这个高级理解之后，让我们开始编写代码。下载 Python 源文件 `ch01_ex03.py`。我们将在代码中仅审查几个重要方法。请参考此源文件以获取完整代码。
- en: Tip
  id: totrans-286
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The code for this example, `ch01_ex03.py`, is all squished inside a single file.
    Is it good practice? Certainly not! As we go along, you will learn about best
    practices. Later in the book, we will discuss some important building blocks of
    application development, namely refactoring, coding standards, and design patterns.
    As an exercise, try to split the code into smaller modules and add code documentation.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例的代码 `ch01_ex03.py` 全部压缩在一个文件中。这是否是良好的实践？当然不是！随着我们的进行，你将了解最佳实践。本书的后面部分，我们将讨论应用开发的一些重要构建块，即重构、编码标准和设计模式。作为练习，尝试将代码拆分成更小的模块，并添加代码文档。
- en: 'The main execution code is shown here, along with some details of the `AttackOfTheOrcs`
    class. In the `__init__` method, we will initialize some instance variables and
    later update the values they hold. For example, `self.player` represents the instance
    of the `Knight` class when the game begins:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 主要执行代码在此处展示，以及 `AttackOfTheOrcs` 类的一些细节。在 `__init__` 方法中，我们将初始化一些实例变量，稍后更新它们所持有的值。例如，`self.player`
    代表游戏开始时 `Knight` 类的实例：
- en: '![Reviewing the code](img/B05034_01_23.jpg)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![检查代码](img/B05034_01_23.jpg)'
- en: Tip
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Just as a refresher, the `__init__` method is somewhat similar to a constructor
    in languages such as C++; however, keep in mind some differences. For example,
    you cannot overload `__init__` as you might do in these languages. Instead, you
    can easily accomplish this using optional arguments or the `classmethod` decorator.
    We will cover some aspects later in the book.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 作为复习，`__init__` 方法在类似于 C++ 这样的语言中类似于构造函数；然而，请注意一些差异。例如，你不能像在这些语言中那样重载 `__init__`。相反，你可以通过使用可选参数或
    `classmethod` 装饰器轻松地完成这个任务。我们将在本书的后面部分介绍一些方面。
- en: 'Let''s quickly review the `play` and `_occupy_huts` methods:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速回顾 `play` 和 `_occupy_huts` 方法：
- en: '![Reviewing the code](img/B05034_01_24.jpg)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![检查代码](img/B05034_01_24.jpg)'
- en: The `self.player` is an instance of the `Knight` class. We will call the `acquire_hut`
    method of this instance where most of the high-level action happens. After this,
    the program simply looks for the health parameters of the player and the enemy.
    It also queries the `Hut` instance to see if it is acquired.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '`self.player` 是 `Knight` 类的一个实例。我们将调用此实例的 `acquire_hut` 方法，其中大部分高级动作发生。之后，程序简单地查找玩家的健康参数和敌人的健康参数。它还会查询
    `Hut` 实例以查看是否已获取。'
- en: 'Moving ahead, in the `_occupy_hut` method, the objects of `Hut` are created
    and appended to the `self.huts` list. This method is shown in the following figure:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `_occupy_hut` 方法中，`Hut` 对象被创建并附加到 `self.huts` 列表中。此方法在以下图中展示：
- en: '![Reviewing the code](img/B05034_01_25.jpg)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![检查代码](img/B05034_01_25.jpg)'
- en: Note
  id: totrans-297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Public, protected, and private in Python**'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python 中的公共、受保护和私有**'
- en: You will notice that some methods of the `AttackOfTheOrcs` class start with
    an underscore, for example, `_process_user_choice()`. That is a way to say that
    this method is not meant for public use. It is intended to be used from within
    the class. Languages such as C++ define class access specifiers, namely, `private`,
    `protected`, and `public`. These are used to put restrictions on the access of
    class attributes.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到`AttackOfTheOrcs`类的一些方法以下划线开头，例如`_process_user_choice()`。这是一种表示该方法不打算公开使用的方式。它打算在类内部使用。像C++这样的语言定义了类访问说明符，即`private`、`protected`和`public`。这些用于对类属性的访问进行限制。
- en: There is no such thing in Python. It allows outside access to the attributes
    with a single underscore as `game._process_user_choice()`. If the attribute name
    starts with double underscores, you can't call it directly. For example, you can't
    directly call `game.__process_user_choice()`. That being said, there is another
    way to access such attributes from outside. But let's not talk about it. Although
    Python allows you to access such attributes, it is is not good practice to do
    so!
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中不存在这样的东西。它允许通过单个下划线作为`game._process_user_choice()`从外部访问属性。如果属性名以下划线开头，则不能直接调用。例如，你不能直接调用`game.__process_user_choice()`。话虽如此，还有另一种从外部访问此类属性的方法。但让我们不要谈论它。尽管Python允许你访问这样的属性，但这并不是一个好的做法！
- en: 'Observe the `acquire_hut` method of the Knight class:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 观察骑士类中的`acquire_hut`方法：
- en: '![Reviewing the code](img/B05034_01_26.jpg)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![查看代码](img/B05034_01_26.jpg)'
- en: 'Let''s talk through this method next:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们接下来讨论这个方法：
- en: First, we need to check whether the hut's occupant is a friend or an enemy.
    This is determined by the variable `is_enemy`, as shown in the preceding figure.
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们需要检查小屋的居住者是朋友还是敌人。这由前面的图中的变量`is_enemy`确定。
- en: 'The hut''s occupant can be of the following types: an instance of the `Knight`
    class, an instance of the `OrcRider` class, or set to `None`.'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小屋的居住者可以是以下类型之一：`Knight`类的实例、`OrcRider`类的实例，或者设置为`None`。
- en: The `GameUnit` class, and its subclasses `Knight` and `OrcRider`, define a `unit_type`
    attribute. This is just a string that is set as either `'friend'` or `'enemy'`.
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GameUnit`类及其子类`Knight`和`OrcRider`定义了一个`unit_type`属性。这只是一个设置为`''friend''`或`''enemy''`的字符串。'
- en: Thus, to determine whether there is an enemy hiding in the hut, we will first
    check whether the `hut.occupant` is an instance of the superclass `GameUnit`.
    If true, we will know it has a `unit_type` parameter. So, we will check whether
    `hut.occupant.unit_type` is equal to `'enemy'`. For the `OrcRider` class, `unit_type`
    is set to `'enemy'` by default.
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此，为了确定小屋中是否隐藏着敌人，我们首先检查`hut.occupant`是否是超类`GameUnit`的实例。如果是真的，我们将知道它有一个`unit_type`参数。因此，我们将检查`hut.occupant.unit_type`是否等于`'enemy'`。对于`OrcRider`类，`unit_type`默认设置为`'enemy'`。
- en: 'The rest of the logic is simple. If the occupant is an enemy, it asks the user
    what to do next: attack or run away.'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其余的逻辑很简单。如果居住者是敌人，它会询问用户下一步做什么：攻击或逃跑。
- en: The `Knight.attack` method is similar to the one discussed earlier. One change
    here is that we can access the `health_meter` attribute of the injured unit and
    update it.
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Knight.attack`方法与之前讨论的方法类似。这里的一个变化是我们可以访问受伤单位的`health_meter`属性并更新它。'
- en: If `hut.occupant` happens to be `'friend'` or `None`, it calls `hut.acquire()`.
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`hut.occupant`恰好是`'friend'`或`None`，它将调用`hut.acquire()`。
- en: 'What happens when the `Hut.acquire()` method is called? Here is the code snippet
    for the `Hut` class:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`Hut.acquire()`方法时会发生什么？以下是`Hut`类的代码片段：
- en: '![Reviewing the code](img/B05034_01_27.jpg)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![查看代码](img/B05034_01_27.jpg)'
- en: The `acquire` method simply updates the `occupant` attribute with the object
    passed as an argument to this method.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '`acquire`方法只是简单地使用传递给此方法的参数更新`occupant`属性。'
- en: Running Attack of the Orcs v1.0.0
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行兽人攻击v1.0.0
- en: 'It''s play time! We have reviewed the most important methods of the new classes.
    You can review the rest of the code from the `ch01_ex03.py` file, or better try
    to write these methods on your own. Run the application from the command line,
    like we did earlier. The following screenshot shows the game in action:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 玩耍时间到了！我们已经回顾了新类中最重要的一些方法。你可以从`ch01_ex03.py`文件中查看其余的代码，或者更好的方法是尝试自己编写这些方法。像之前一样，从命令行运行应用程序。以下截图显示了游戏运行情况：
- en: '![Running Attack of the Orcs v1.0.0](img/B05034_01_28.jpg)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![运行兽人攻击v1.0.0](img/B05034_01_28.jpg)'
- en: Abstract base classes in Python
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python中的抽象基类
- en: In the previous section, we redesigned the code using the OOP approach. We also
    demonstrated the use of inheritance by defining a superclass `GameUnit`, and inheriting
    from it to create the `Knight` and `OrcRider` subclasses. As the last topic in
    this chapter, let's talk about using abstract base classes in Python.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们使用面向对象的方法重新设计了代码。我们还通过定义超类 `GameUnit` 并从它派生 `Knight` 和 `OrcRider` 子类来演示了继承的使用。作为本章的最后一个话题，让我们来谈谈在
    Python 中使用抽象基类。
- en: Tip
  id: totrans-319
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: This section is intended to provide a basic understanding of ABCs in Python.
    The discussion here is far from being comprehensive but will be just enough to
    implement an ABC in our application code. For further reading, check out the Python
    documentation at [https://docs.python.org/3/library/abc.html](https://docs.python.org/3/library/abc.html).
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 本节旨在提供 Python 中 ABC 的基本理解。这里的讨论远非全面，但足以在我们的应用程序代码中实现 ABC。欲了解更多信息，请参阅 [https://docs.python.org/3/library/abc.html](https://docs.python.org/3/library/abc.html)
    的 Python 文档。
- en: If you are familiar with OOP languages such as Java or C++, you probably already
    know the concept of an ABC.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉像 Java 或 C++ 这样的面向对象语言，你可能已经知道 ABC 的概念。
- en: 'A base class is a parent class from which other classes can be derived. Similarly,
    you can have an abstract base class and create other classes that inherit this
    class. So, where is the difference? One of the major differences is that an ABC
    can''t be instantiated. But that is not the only difference. An ABC forces the
    derived classes to implement specific methods defined within that class. This
    much knowledge about an ABC should be good enough to work through the examples
    in this book. For more details, see the aforementioned Python documentation link.
    Let''s review a simple example that shows how to implement an abstract base class
    in Python and how it differs from an ordinary base class. The `abc` module provides
    the necessary infrastructure. The following code snippet compares the implementation
    of an ABC to an ordinary base class:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 基类是一个父类，其他类可以从它派生。类似地，你可以有一个抽象基类，并创建继承这个类的其他类。那么，区别在哪里呢？其中一个主要区别是 ABC 不能被实例化。但这并不是唯一的区别。ABC
    强制派生类实现该类内部定义的特定方法。关于 ABC 的这些知识应该足够你处理这本书中的示例。更多细节，请参阅上述 Python 文档链接。让我们回顾一个简单的例子，展示如何在
    Python 中实现抽象基类以及它与普通基类的区别。`abc` 模块提供了必要的框架。以下代码片段比较了 ABC 的实现与普通基类的实现：
- en: '![Abstract base classes in Python](img/B05034_01_38.jpg)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
  zh: '![Python 中的抽象基类](img/B05034_01_38.jpg)'
- en: The class on the left, `AbstractGameUnit`,is the abstract base class, whereas
    the `GameUnit` class on the right is an ordinary base class. The three differences
    in the ABC implementation are marked with numbers, as shown in the preceding screenshot.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧的类 `AbstractGameUnit` 是抽象基类，而右侧的 `GameUnit` 类是一个普通基类。ABC 实现中的三个区别用数字标记，如前面的截图所示。
- en: The argument `metaclass=ABCMeta` is used to define `AbstractGameUnit` as an
    ABC.
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `metaclass=ABCMeta` 参数定义 `AbstractGameUnit` 为一个 ABC。
- en: 'The `ABCMeta` is a **metaclass** to define the abstract base class. It is a
    broad discussion topic, but the simplified meaning of a metaclass is as follows:
    to create an object, we use a class. Likewise, imagine a metaclass as one used
    to create a class.'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ABCMeta` 是一个用于定义抽象基类的 **元类**。这是一个广泛讨论的话题，但元类的简化意义如下：要创建一个对象，我们使用一个类。同样，想象一下元类是用于创建类的一种类。'
- en: A Python **decorator** provides a simple way to dynamically alter the functionality
    of a method, a class, or a function. This is a special Python syntax that starts
    with an @ symbol followed by the decorator name. A decorator is placed directly
    above the method definition.
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 的 **装饰器** 提供了一种简单的方法来动态改变方法、类或函数的功能。这是一种特殊的 Python 语法，以一个 @ 符号开始，后跟装饰器名称。装饰器直接放在方法定义之上。
- en: The `@abstractmethod` is a decorator that makes the method defined on the next
    line an abstract method.
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@abstractmethod` 是一个装饰器，它使得下一行定义的方法成为一个抽象方法。'
- en: The abstract method is the one that the ABC requires all the subclasses to implement.
    In this case, `AbstractGameUnit` requires its `Knight` subclass to implement the
    `info()` method. If the subclass does not implement this method, Python simply
    doesn't instantiate that subclass and will throw `TypeError`. You can try this
    by removing the `Knight.info` method and running the code.
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象方法是ABC要求所有子类必须实现的方法。在这种情况下，`AbstractGameUnit`要求其`Knight`子类实现`info()`方法。如果子类没有实现此方法，Python将简单地不会实例化该子类，并抛出`TypeError`。您可以尝试删除`Knight.info`方法并运行代码来测试这一点。
- en: There is no such restriction if the `Knight` class inherits from an ordinary
    base class, such as `GameUnit`.
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`Knight`类继承自一个普通基类，例如`GameUnit`，则没有这样的限制。
- en: Tip
  id: totrans-331
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The code illustrated here is for Python version 3.5\. For version 2.7, the syntax
    is different. Refer to the `ch01_ex03_AbstractBaseClass.py` file in the Python2
    directory of the supporting material for an equivalent example.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示的代码是为Python 3.5版本准备的。对于2.7版本，语法有所不同。请参阅支持材料中Python2目录下的`ch01_ex03_AbstractBaseClass.py`文件以获取等效示例。
- en: Exercise
  id: totrans-333
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: 'In the `ch01_ex03.py` file, you will see some comments. These are intentionally
    kept to give you an opportunity to improve portions of the code. There is plenty
    of room for improvement in this code. See if you can rewrite portions of the code
    to make it more robust. If you prefer a well-defined problem, here is one:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ch01_ex03.py`文件中，您将看到一些注释。这些注释是故意保留的，以给您一个改进代码部分的机会。此代码中有许多改进的空间。看看您是否可以重写代码的部分，使其更加健壮。如果您更喜欢一个定义明确的问题，这里有一个：
- en: The `Knight` and `OrcRider` classes inherit from the `GameUnit` superclass.
    This exercise is about converting `GameUnit` to `AbstractGameUnit`, an abstract
    base class. Here is a cheat sheet for you; the skeleton code shown in the following
    figure is with the Python 3.5 syntax.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '`Knight`和`OrcRider`类继承自`GameUnit`超类。这个练习是将`GameUnit`转换为抽象基类`AbstractGameUnit`。以下是一个为您准备的速查表；以下图中显示的代码骨架是Python
    3.5的语法。'
- en: 'Refer to the `ch01_ex03_AbstractBaseClass.py` file:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅`ch01_ex03_AbstractBaseClass.py`文件：
- en: '![Exercise](img/B05034_01_29.jpg)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
  zh: '![练习](img/B05034_01_29.jpg)'
- en: Tip
  id: totrans-338
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Note that for Python 2.7, there is a separate version of this code. Refer to
    the `src_ch1_Python2` directory in the supporting code bundle.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，对于Python 2.7，此代码有一个单独的版本。请参阅支持代码包中的`src_ch1_Python2`目录。
- en: Summary
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we touched upon some introductory concepts in Python to develop
    a simple command-line application. We first equipped ourselves by setting up a
    Python development environment.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们简要介绍了Python的一些基本概念，以开发一个简单的命令行应用程序。我们首先通过设置Python开发环境来装备自己。
- en: The first program we wrote was a simple Python script. We soon realized that
    a simple script would be hard to maintain if more features are added. As a next
    step, we did a bit of refactoring and wrapped the code inside functions. This
    improved the code readability and also made it easier to manage. The proposed
    introduction of more features to the application made us rethink the design. We
    learned how to transform the code into an object-oriented design and implemented
    a few of these new features.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写的第一个程序是一个简单的Python脚本。我们很快意识到，如果添加更多功能，简单的脚本将很难维护。作为下一步，我们进行了一些重构，并将代码封装在函数中。这提高了代码的可读性，也使其更容易管理。向应用程序引入更多功能使我们重新思考了设计。我们学习了如何将代码转换为面向对象的设计，并实现了这些新功能中的几个。
- en: And how can we forget Sir Foo! He will accompany us throughout this book.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 我们怎能忘记Sir Foo！他将陪伴我们走过整本书。
- en: Is the code developed free from bugs? You might have already noticed some problems
    while playing the game! In the next chapter, we will see how to make the application
    more robust by handling exceptions.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 代码是否开发得没有错误？您在玩游戏时可能已经注意到了一些问题！在下一章中，我们将看到如何通过处理异常来使应用程序更加健壮。
- en: Very important note for e-book readers
  id: totrans-345
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对于电子书阅读器的重要提示
- en: The code illustrations that you see in this book are actually image files or
    code snapshots.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 您在这本书中看到的代码示例实际上是图像文件或代码快照。
- en: The rendering quality of these images will vary depending on your PDF reader's
    page display resolution and the zoom level.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 这些图像的渲染质量将根据您的PDF阅读器的页面显示分辨率和缩放级别而有所不同。
- en: 'If you have trouble clearly reading this code, you may try the following in
    your PDF or e-book reader:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在阅读此代码时遇到困难，您可以在您的PDF或电子书阅读器中尝试以下操作：
- en: Set the zoom level to 100%
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将缩放级别设置为100%
- en: Use the page display resolution of 96 pixels/inch or similar
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用96像素/英寸或类似的页面显示分辨率
- en: If the problem still persists, you can try with a different resolution.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 如果问题仍然存在，你可以尝试使用不同的分辨率。
- en: How do you set this resolution? It will depend on your e-book reader. For example,
    if you are using Adobe Reader, go to **Edit** | **Preferences** and then select
    **Page Display** from the left panel. You will see **Resolution** as an option
    in the right panel. Select **96 pixels/inch** or similar and see if that helps
    render the images better.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何设置这个分辨率？这取决于你的电子书阅读器。例如，如果你正在使用Adobe Reader，请转到**编辑** | **首选项**，然后从左侧面板中选择**页面显示**。你将在右侧面板中看到**分辨率**作为选项。选择**96像素/英寸**或类似的设置，看看是否有助于更好地渲染图像。
