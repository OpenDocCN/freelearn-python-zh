- en: Testing and Deploying an API in a Microservice with Flask
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will configure, write, and execute unit tests and learn
    a few things related to deployment. We will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Set up unit tests with `pytest`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a database for testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create fixtures to perform setup and teardown tasks for running clean tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write the first round of unit tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run unit tests with `pytest` and check testing coverage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improve testing coverage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand strategies for deployments and scalability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up unit tests with pytest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have been writing code to add features to our RESTful API. We used
    command-line and GUI tools to understand how all the pieces worked together and
    to check the results of diverse HTTP requests made to the RESTful API with Flask's
    development server. Now we will write unit tests that will allow us to make sure
    that the RESTful API works as expected. Before we can start writing unit tests,
    it is necessary to install many additional packages in our virtual environment,
    create a new PostgreSQL database that we will use for testing, and build a configuration
    file for the testing environment.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you quit Flask's development server. You just need to press *Ctrl*
    + *C* in the Terminal or Command Prompt window in which it is running.
  prefs: []
  type: TYPE_NORMAL
- en: Now we will install many additional packages. Make sure you have activated the
    virtual environment named `Flask01`, which we created in [Chapter 1](dbf75cef-4962-4e40-8192-03873b774c48.xhtml),
    *Developing RESTful APIs and Microservices with Flask 1.0.2*. After you activate
    the virtual environment, it is time to run many commands, which will be the same
    for macOS, Linux, or Windows.
  prefs: []
  type: TYPE_NORMAL
- en: Now we will edit the existing `requirements.txt` file to specify the additional
    set of packages that our application requires to be installed in any supported
    platform. This way, it will be extremely easy to repeat the installation of the
    specified packages with their versions in any new virtual environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use your favorite editor to edit the existing text file named `requirements.txt`
    within the root folder for the virtual environment. Add the following lines after
    the last line to declare the additional packages and the versions that our new
    version of the API requires. The code file for the sample is included in the `restful_python_2_04_01`
    folder, in the `Flask01/requirements.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Each additional line added to the `requirements.txt` file indicates the package
    and the version that needs to be installed. The following table summarizes the
    packages and the version numbers that we specified as additional requirements
    to the previously included packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Package name | Version to be installed |'
  prefs: []
  type: TYPE_TB
- en: '| `pytest` | 4.0.1 |'
  prefs: []
  type: TYPE_TB
- en: '| `coverage` | 4.5.2 |'
  prefs: []
  type: TYPE_TB
- en: '| `pytest-cov` | 2.6.0 |'
  prefs: []
  type: TYPE_TB
- en: 'We will install the following Python packages in our virtual environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pytest`: This is a very popular Python unit testing framework that makes testing
    easy and reduces boilerplate code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`coverage`: This tool measures code coverage of Python programs and we will
    use it to determine which parts of the code are being executed by unit tests and
    which parts aren''t.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pytest-cov`: This plugin for `pytest` makes it easy to produce coverage reports
    that use the `coverage` tool under the hood, and provides some additional features.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now we must run the following command on macOS, Linux, or Windows to install
    the additional packages and the versions outlined in the previous table with `pip`
    using the recently edited `requirements.txt` file. Make sure you are in the folder
    that has the `requirements.txt` file before running the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The last lines for the output will indicate all the new packages and their
    dependencies have been successfully installed. If you downloaded the source code
    for the example and you didn''t work with the previous version of the API, `pip`
    will also install the other packages included in the `requirements.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Creating a database for testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we will create the PostgreSQL database that we will use as a repository
    for our testing environment. Notice that the testing computer or server must have
    PostgreSQL 10.5 installed on it, as explained in the previous chapters for the
    development environment. I assume that you are running the tests on the same computer
    in which you worked with the previous examples.
  prefs: []
  type: TYPE_NORMAL
- en: Remember to make sure that the PostgreSQL bin folder is included in the `PATH`
    environmental variable. You should be able to execute the `psql` command-line
    utility from your current Terminal, Command Prompt, or Windows PowerShell.
  prefs: []
  type: TYPE_NORMAL
- en: We will use the PostgreSQL command-line tools to create a new database named
    `test_flask_notifications`. If you already ...
  prefs: []
  type: TYPE_NORMAL
- en: Creating fixtures to perform setup and teardown tasks for running clean tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Test fixtures provide a fixed baseline to enable us to reliably and repeatedly
    execute tests. Pytest makes it easy to declare a test fixture function by marking
    a function with the `@pytest.fixture` decorator. Then, whenever we use the fixture
    function name as an argument in a test function declaration, `pytest` will make
    the fixture function provide the fixture object. Now we will create the following
    two `pytest` fixture functions, which we will use in future test functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`application`: This test fixture function will perform the necessary setup
    tasks to create the Flask test app with the appropriate testing configuration
    and create all the necessary tables in the test database. The fixture will launch
    the test execution and when the test finishes, the fixture will perform the necessary
    teardown tasks to leave the database as it was before running the test.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`client`: This test fixture function receives `application` as an argument,
    and therefore, it receives the Flask app created in the previously explained application
    test fixture function in this argument. Hence, the `client` test fixture function
    configures the application for testing, initializes the database, creates a test
    client for this application and returns it. We will use the test client in our
    test methods to easily compose and send requests to our API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create a new `conftest.py` file within the `service` folder. Add the following
    lines that declare many `import` statements and the previously explained `pytest`
    test fixture functions. The code file for the sample is included in the `restful_python_2_04_01`
    folder, in the `Flask01/service/conftest.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `application` fixture function will be executed each time a test that uses
    either `application` or `client` as arguments. The function calls the `create_app`
    function, declared in the `app` module, with `'test_config'` as an argument. The
    function will set up a Flask app with this module as the configuration file, and
    therefore, the app will use the previously created configuration file that specifies
    the desired values for our testing database and environment.
  prefs: []
  type: TYPE_NORMAL
- en: The next line calls the `orm.create_all` method to create all the necessary
    tables in our test database configured in the `test_config.py` file. All the code
    after the `yield app` line works as the teardown code that is executed afterÂ `app`
    is used and the test is executed. The code removes the SQLAlchemy session and
    drops all the tables that we created in the test database before starting the
    execution of the test. This way, after each test finishes its execution, the test
    database will be empty again.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the first round of unit tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we will write the first round of unit tests. Specifically, we will write
    unit tests related to the user and notification category resources: `UserResource`,
    `UserListResource`, `NotificationCategoryResource`, and `NotificationCategoryListResource`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new `tests` subfolder within the `service` folder. Then, create a
    new `test_views.py` file within the new `service/tests` subfolder. Add the following
    lines that declare many `import` statements and the first functions that we will
    use in many test functions. The code file for the sample is included in the `restful_python_2_04_01`
    folder, in the `Flask01/service/tests/test_views.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Running unit tests with pytest and checking testing coverage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new `setup.cfg` file within the `service` folder. The following lines
    show the code that specifies the desired configuration for `pytest` and the `coverage`
    tools. The code file for the sample is included in the `restful_python_2_04_01`
    folder, in the `Flask01/service/setup.cfg` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `tool:pytest` section specifies the configuration for `pytest`. The `testpaths`
    setting assigns the `tests` value to indicate that the tests are located within
    the `tests` subfolder.
  prefs: []
  type: TYPE_NORMAL
- en: The `coverage:run` section specifies the configuration for the `coverage` tool.
    The `branch` setting is set to `True` to enable branch coverage measurement, in
    addition to the default statement coverage. The `source` setting specifies the
    modules that we want to be considered for the coverage measurement. We just want
    to include the `models` and `views` modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we will use the `pytest` command to run tests and measure their code coverage.
    Make sure you run the command in the Terminal or Command Prompt window in which
    you have activated the virtual environment and that you are located within the
    `service` folder. Run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The test runner will execute all the functions defined in the `test_views.py`
    that start with the `test_` prefix and will display the results. We will use the
    `-v` option to instruct `pytest` to print the test function names and statuses
    in verbose mode. The `--cov` option turns on test-coverage-reporting generation
    with the usage of the `pytest-cov` plugin.
  prefs: []
  type: TYPE_NORMAL
- en: The tests won't make changes to the database we have been using when working
    on the API. Remember that we configured the `test_flask_notifications` database
    as our test database.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following lines show the sample output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Pytest uses the configuration specified in the previously created `setup.cfg`
    file to determine which path includes the modules whose names start with the `test`
    prefix. In this case, the only module that matches the criteria is the `test_views`
    module. In the modules that match the criteria, `pytest` loads tests from all
    the functions whose names start with the `test` prefix.
  prefs: []
  type: TYPE_NORMAL
- en: The output provided details that the test runner discovered and executed five
    tests and all of them passed. The output displays the module and function names
    for each method in the `test_views` module that started with the `test_` prefix
    and represented a test to be executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The test code coverage measurement report provided by the `coverage` package
    in combination with the `pytest-cov` plugin uses the code analysis tools and the
    tracing hooks included in the Python standard library to determine which lines
    of code are executable and which of these lines have been executed. The report
    provides a table with the following columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Name`: The Python module name'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Stmts`: The count of executable statements for the Python module'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Miss`: The number of executable statements missed, that is, the ones that
    weren''t executed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Branch`: The count of possible branches for the Python module'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BrPart`: The number of branches that were executed during tests'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Cover`: The coverage of executable statements and branches, expressed as a
    percentage'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We definitely have incomplete coverage for the `views.py` and `models.py` modules
    based on the measurements shown in the report. In fact, we just wrote a few tests
    related to the notification categories and users, and therefore, it makes sense
    that the coverage is lower than 50% for the `views.py` module. We didn't create
    tests related to notifications.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can run the `coverage` command with the `-m` command-line option to display
    the line numbers of the missing statements in a new `Missing` column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The command will use the information from the last execution and will display
    the missing statements and the missing branches. The next lines show a sample
    output that corresponds to the previous execution of the unit tests. A dash (`-`)
    is used to indicate a range of lines that were missed. For example, `22-23` means
    that lines `22` and `23` were missing statements. A dash followed by a greater
    than sign (`->`) indicates that the branch from the line before `->` to the line
    after it was missed. For example, `41->42` means that the branch from line `41`
    to line `42` was missed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now run the following command to get annotated HTML listings detailing missed
    lines. The command won''t produce any output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the `index.html` HTML file generated in the `htmlcov` folder with your
    web browser. The following screenshot shows an example report that coverage generated
    in HTML format:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aec4ebbd-55ec-4b41-b625-ca440e70f178.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click or tap `views.py` and the web browser will render a web page that displays
    the statements that were run, including the missing ones, the excluded ones, and
    the partially executed ones, with different colors. We can click or tap on the
    run, missing, excluded, and partial buttons to show or hide the background color
    that represents the status for each line of code. By default, the missing lines
    of code will be displayed with a pink background and the partially executed will
    be displayed with a yellow background. Thus, we must write unit tests that target
    these lines of code to improve our tests coverage. The following screenshot shows
    the buttons with the summary:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9c948132-01e0-4bee-acbd-b6e8ca63d362.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The next screenshot shows the highlighted missing lines and the partially evaluated
    branches for some lines of code in the `views.py` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/419e2a16-088a-40cf-8159-205b45bac59a.png)'
  prefs: []
  type: TYPE_IMG
- en: Improving testing coverage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we will write additional tests functions to improve the testing coverage.
    Specifically, we will write unit tests related to notifications and users.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the existing `service/tests/test_views.py` file and insert the following
    lines after the last line. The code file for the sample is included in the `restful_python_2_04_02`
    folder, in the `Flask01/service/tests/test_views.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Understanding strategies for deployments and scalability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Flask is a lightweight microframework for the web, and therefore, it is an ideal
    choice whenever we have to provide a RESTful API encapsulated in a microservice.
    So far, we have been working with the built-in development server provided by
    Werkzeug and with plain HTTP.
  prefs: []
  type: TYPE_NORMAL
- en: It is very important to understand that Flask's built-in development server
    is not suitable for production.
  prefs: []
  type: TYPE_NORMAL
- en: There are dozens of deployment options for Flask, and the different stacks and
    procedures are out of the scope of this book, which is focused on development
    tasks for RESTful APIs with the most popular Python frameworks. The most prominent
    cloud providers include instructions on how to deploy Flask applications with
    diverse possible configurations. In addition, there are many options to use **WSGI**
    (short for **Web Server Gateway Interface**) servers, which implement the web
    server side of the WSGI interface, allowing us to run Python web applications,
    such as Flask applications, in production.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, in a production environment, we will also want to work with HTTPS
    instead of HTTP. We will have to configure the appropriate TLS certificates, also
    known as SSL certificates.
  prefs: []
  type: TYPE_NORMAL
- en: We used Flask to develop a RESTful web service. The key advantage of these kinds
    of web services is that they are stateless, that is, they shouldn't keep a client
    state on any server. Our API is a good example of a stateless RESTful web service
    with Flask. Flask-RESTful and PostgreSQL 10.5 can be containerized in a Docker
    container. For example, we can produce an image with our application configured
    to run with NGINX, uWSGI, Redis, and Flask. Thus, we can make the API run as a
    microservice.
  prefs: []
  type: TYPE_NORMAL
- en: We always have to make sure that we profile the API and the database before
    we deploy our first version of our API. It is very important to make sure that
    the generated queries run properly on the underlying database and that the most
    popular queries do not end up in sequential scans. It is usually necessary to
    add the appropriate indexes to the tables in the database.
  prefs: []
  type: TYPE_NORMAL
- en: We have been using basic HTTP authentication. We can improve it with a token-based
    authentication. We must make sure that the API runs under HTTPS in production
    environments.
  prefs: []
  type: TYPE_NORMAL
- en: It is convenient to use a different configuration file for production. However,
    another approach that is becoming extremely popular, especially for cloud-native
    applications, is storing configuration in the environment. If we want to deploy
    cloud-native RESTful web services and follow the guidelines established in the
    Twelve-Factor App, we should store config in the environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each platform includes detailed instructions to deploy our application. All
    of them will require us to generate the `requirements.txt` file, which lists the
    application dependencies together with their versions. This way, the platforms
    will be able to install all the necessary dependencies listed in the file. We
    have been updating this file each time we needed to install a new package in our
    virtual environment. However, it is a good idea to run the following `pip freeze`
    within the root folder of our virtual environment, `Flask01`, to generate the
    final `requirements.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines show the contents of a sample generated `requirements.txt`
    file. Notice that the generated file also includes all the dependencies that were
    installed by the packages we specified in the original `requirements.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Test your knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see whether you can answer the following questions correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pytest makes it easy to declare a test fixture function by marking a function
    with which of the following decorators?:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`@pytest.fixture_function`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`@pytest.test_fixture`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`@pytest.fixture`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'By default, pytest discovers and executes functions as text functions when
    they start with which of the following prefixes?:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`test`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`test_`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`test-`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Which of the following commands displays the line numbers of the missing statements
    in the `Missing` column for a coverage report?:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`coverage report -m`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`coverage report missing`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`coverage -missing`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Pytest is a very popular Python:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unit test framework that makes testing easy and reduces boilerplate code
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: WSGI server that we can ...
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we set up a testing environment. We installed `pytest` to make
    it easy to discover and execute unit tests and we created a new database to be
    used for testing. We wrote a first round of unit tests, measured test coverage
    with the `pytest-cov` plugin combined with the `coverage` tool, and then we wrote
    additional unit tests to improve test coverage. Finally, we understood many considerations
    for deployment and scalability.
  prefs: []
  type: TYPE_NORMAL
- en: We built a complex API with Flask combined with Flask-RESTful and a PostgreSQL
    10.5 database that we can run as a microservice, and we tested it. Now we will
    move to another popular Python web framework, Django, which is the topic for the
    next chapter.
  prefs: []
  type: TYPE_NORMAL
