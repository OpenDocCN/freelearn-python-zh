- en: Chapter 4. Programming with HTTP for the Internet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Downloading data from an HTTP server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serving HTTP requests from your machine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extracting cookie information after visiting a website
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Submitting web forms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending web requests through a proxy server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking whether a web page exists with the HEAD request
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spoofing Mozilla Firefox in your client code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving bandwidth in web requests with the HTTP compression
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing an HTTP fail-over client with resume and partial downloading
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a simple HTTPS server code with Python and OpenSSL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter explains Python HTTP networking library functions with a few third-party
    libraries. For example, the `requests` library deals with the HTTP requests in
    a nicer and cleaner way. The `OpenSSL` library is used in one of the recipes to
    create a SSL-enabled web server.
  prefs: []
  type: TYPE_NORMAL
- en: Many common HTTP protocol features have been illustrated in a few recipes, for
    example, the web form submission with `POST`, manipulating header information,
    use of compression, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Downloading data from an HTTP server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You would like to write a simple HTTP client to fetch some data from any web
    server using the native HTTP protocol. This can be the very first steps towards
    creating your own HTTP browser.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us access [www.python.org](http://www.python.org) with our Pythonic minimal
    browser that uses Python's `httplib`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 4.1 explains the following code for a simple HTTP client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This recipe will by default fetch a page from [www.python.org](http://www.python.org).
    You can run this recipe with or without the host and path arguments. If this script
    is run, it will show the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run this recipe with an invalid path, it will show the following server
    response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe defines an `HTTPClient` class that fetches data from the remote
    host. It is built using Python's native `httplib` library. In the `fetch()` method,
    it uses the `HTTP()` function and other auxiliary functions to create a dummy
    HTTP client, such as `putrequest()` or `putheader()`. It first puts the `GET/path`
    string that is followed by setting up a user agent, which is the name of the current
    script (`__file__`).
  prefs: []
  type: TYPE_NORMAL
- en: The main request `getreply()`method is put inside a try-except block. The response
    is retrieved from the `getfile()` method and the stream's content is read.
  prefs: []
  type: TYPE_NORMAL
- en: Serving HTTP requests from your machine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You would like to create your own web server. Your web server should handle
    client requests and send a simple `hello` message.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python ships with a very simple web server that can be launched from the command
    line as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This will launch an HTTP web server on port `8080`. You can access this web
    server from your browser by typing `http://localhost:8080`. This will show the
    contents of the current directory from where you run the preceding command. If
    there is any web server index file, for example, `index.html`, inside that directory,
    your browser will show the contents of `index.html`. However, if you like to have
    full control over your web server, you need to launch your customized HTTP server..
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 4.2 gives the following code for the custom HTTP web server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows a simple HTTP server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/3463OS_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you run this web server and access the URL from a browser, this will send
    the one line text `Hello from server!` to the browser, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we created the `CustomHTTPServer` class inherited from the `HTTPServer`
    class. In the constructor method, the `CustomHTTPServer` class sets up the server
    address and port received as a user input. In the constructor, our web server's
    `RequestHandler` class has been set up. Every time a client is connected, the
    server handles the request according to this class.
  prefs: []
  type: TYPE_NORMAL
- en: The `RequestHandler` defines the action to handle the client's `GET` request.
    It sends an HTTP header (code 200) with a success message **Hello from server!**
    using the `write()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Extracting cookie information after visiting a website
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many websites use cookies to store their various information on to your local
    disk. You would like to see this cookie information and perhaps log in to that
    website automatically using cookies.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us try to pretend to log in to a popular code-sharing website, [www.bitbucket.org](http://www.bitbucket.org).
    We would like to submit the login information on the login page, [https://bitbucket.org/account/signin/?next=/](https://bitbucket.org/account/signin/?next=/).
    The following screenshot shows the login page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/3463OS_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So, we note down the form element IDs and decide which fake values should be
    submitted. We access this page the first time, and the next time, we access the
    home page to observe what cookies have been set up.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 4.3 explains extracting cookie information as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this recipe results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have used Python''s `cookielib` and set up a cookie jar, `cj`. The login
    data has been encoded using `urllib.urlencode`. `urllib2` has a `build_opener()`
    method, which takes the predefined cookie jar with an instance of `HTTPCookieProcessor()`
    and returns a URL opener. We call this opener twice: once for the login page and
    once for the home page of the website. It seems that only one cookie, `bb_session`,
    was set with the set-cookie directive present in the page header. More information
    about `cookielib` can be found on the official Python documentation site at [http://docs.python.org/2/library/cookielib.html](http://docs.python.org/2/library/cookielib.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Submitting web forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: During web browsing, we submit web forms many times in a day. Now, you would
    like do that using the Python code.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This recipe uses a third-party Python module called `requests`. You can install
    the compatible version of this module by following the instructions from [http://docs.python-requests.org/en/latest/user/install/](http://docs.python-requests.org/en/latest/user/install/).
    For example, you can use `pip` to install `requests` from the command line as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us submit some fake data to register with [www.twitter.com](http://www.twitter.com).
    Each form submission has two methods: `GET` and `POST`. The less sensitive data,
    for example, search queries, are usually submitted by `GET` and the more sensitive
    data is sent via the `POST` method. Let us try submitting data with both of them.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 4.4 explains the submit web forms, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run this script, you will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe uses a third-party module, `requests`. It has convenient wrapper
    methods, `get()` and `post()`, that do the URL encoding of data and submit forms
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we created a data payload with a username, password, and e-mail
    for creating the Twitter account. When we first submit the form with the `GET`
    method, the Twitter website returns an error saying that the page only supports
    `POST`. After we submit the data with `POST`, the page processes it. We can confirm
    this from the header data.
  prefs: []
  type: TYPE_NORMAL
- en: Sending web requests through a proxy server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You would like to browse web pages through a proxy. If you have configured your
    browser with a proxy server and that works, you can try this recipe. Otherwise,
    you can use any of the public proxy servers available on the Internet.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to have access to a proxy server. You can find a free proxy server
    by searching on Google or on any other search engine. Here, for the sake of demonstration,
    we have used `165.24.10.8`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us send our HTTP request through a public domain proxy server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 4.5 explains proxying web requests across a proxy server as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run this script, it will show the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is a short recipe where we access the social code-sharing site, [www.github.com](http://www.github.com),
    with a public proxy server found on Google search. The proxy address argument
    has been passed to the `urlopen()` method of `urllib`. We print the HTTP header
    of response to show that the proxy settings work here.
  prefs: []
  type: TYPE_NORMAL
- en: Checking whether a web page exists with the HEAD request
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You would like to check the existence of a web page without downloading the
    HTML content. This means that we need to send a `get HEAD` request with a browser
    client. According to Wikipedia, the `HEAD` request asks for the response identical
    to the one that would correspond to a `GET` request, but without the response
    body. This is useful for retrieving meta-information written in response headers,
    without having to transport the entire content.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We would like to send a `HEAD` request to [www.python.org](http://www.python.org).
    This will not download the content of the homepage, rather it checks whether the
    server returns one of the valid responses, for example, `OK`, `FOUND`, `MOVED
    PERMANENTLY`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 4.6 explains checking a web page with the `HEAD` request as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this script shows the success or error if the page is found by the
    `HEAD` request as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We used the `HTTPConnection()` method of `httplib`, which can make a `HEAD`
    request to a server. We can specify the path if necessary. Here, the `HTTPConnection()`
    method checks the home page or path of [www.python.org](http://www.python.org).
    However, if the URL is not correct, it can't find the return response inside the
    accepted list of return codes.
  prefs: []
  type: TYPE_NORMAL
- en: Spoofing Mozilla Firefox in your client code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From your Python code, you would like to pretend to the web server that you
    are browsing from Mozilla Firefox.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can send the custom user-agent values in the HTTP request header.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 4.7 explains spoofing Mozilla Firefox in your client code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run this script, you will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We used the `build_opener()` method of `urllib2` to create our custom browser
    whose user-agent string has been set up as `Mozilla/5.0 (Windows NT 5.1; rv:20.0)
    Gecko/20100101 Firefox/20.0`.
  prefs: []
  type: TYPE_NORMAL
- en: Saving bandwidth in web requests with the HTTP compression
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You would like to give your web server users better performance in downloading
    web pages. By compressing HTTP data, you can speed up the serving of web contents.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us create a web server that serves contents after compressing it to the
    `gzip` format.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 4.8 explains the HTTP compression as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'You can run this script and see the `Compressed Hello World!` text (as a result
    of the HTTP compression) on your browser screen when accessing `http://localhost:8800`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot illustrates serving compressed content by a web server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/3463OS_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created a web server by instantiating the `HTTPServer` class from the `BaseHTTPServer`
    module. We attached a custom request handler to this server instance, which compresses
    every client response using a `compress_buffer()` method. A predefined HTML content
    has been supplied to the clients.
  prefs: []
  type: TYPE_NORMAL
- en: Writing an HTTP fail-over client with resume and partial downloading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You would like to create a fail-over client that will resume downloading a file
    if it fails for any reason in the first instance.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us download the Python 2.7 code from [www.python.org](http://www.python.org).
    A `resume_download()` file will resume any unfinished download of that file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 4.9 explains resume downloading as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this script will result in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we created a custom URL opener class inheriting from the `FancyURLopener`
    method of `urllib`, but `http_error_206()` is overridden where partial content
    is downloaded. So, our method checks the existence of the target file and if it
    is not present, it tries to download with the custom URL opener class.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a simple HTTPS server code with Python and OpenSSL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You need a secure web server code written in Python. You already have your SSL
    keys and certificate files ready with you.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to install the third-party Python module, `pyOpenSSL`. This can be
    grabbed from PyPI ([https://pypi.python.org/pypi/pyOpenSSL](https://pypi.python.org/pypi/pyOpenSSL)).
    Both on Windows and Linux hosts, you may need to install some additional packages,
    which are documented at [http://pythonhosted.org//pyOpenSSL/](http://pythonhosted.org//pyOpenSSL/).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After placing a certificate file on the current working folder, we can create
    a web server that makes use of this certificate to serve encrypted content to
    the clients.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 4.10 explains the code for a secure HTTP server as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run this script, it will result in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you notice the previous recipes that create the web server, there is not
    much difference in terms of the basic procedure. The main difference is in applying
    the SSL `Context()` method with the `SSLv23_METHOD` argument. We have created
    the SSL socket with the Python OpenSSL third-party module's `Connection()` class.
    This class takes this context object along with the address family and socket
    type.
  prefs: []
  type: TYPE_NORMAL
- en: The server's certificate file is kept in the current directory, and this has
    been applied with the context object. Finally, the server has been activated with
    the `server_activate()` method.
  prefs: []
  type: TYPE_NORMAL
