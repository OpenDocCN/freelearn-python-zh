<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-182"><a id="_idTextAnchor183"/>7</h1>
<h1 id="_idParaDest-183"><a id="_idTextAnchor184"/>Error Handling and Logging</h1>
<p>We described how Python and Go run and how they access the network in the previous chapter; however, we missed two important points when building our network automation solution: how we report program execution events and how we handle errors.</p>
<p>These two topics are not as easy as they seem, and they are, most of the time, implemented in the system poorly. Some network developers might not do it properly because of lack of knowledge, but there are also some developers that don’t do it properly because of time constraints and extra time needed for coding.</p>
<p>But are these activities really important? Let’s examine these in this chapter. First, let’s investigate how and why we handle errors and then why and how we do event logging.</p>
<p>Here are the topics we are going to cover in this chapter:</p>
<ul>
<li>Writing code for error handling</li>
<li>Logging events</li>
<li>Adding logging to your code</li>
</ul>
<p>After reading this chapter, you will be able to add effectively code to handle errors and log events in your network development.</p>
<h1 id="_idParaDest-184"><a id="_idTextAnchor185"/>Technical requirements</h1>
<p>The source code described in this chapter is stored in the GitHub repository at <a href="https://github.com/PacktPublishing/Network-Programming-and-Automation-Essentials/tree/main/Chapter07">https://github.com/PacktPublishing/Network-Programming-and-Automation-Essentials/tree/main/Chapter07</a>.</p>
<h1 id="_idParaDest-185"><a id="_idTextAnchor186"/>Writing code for error handling</h1>
<p>To see how important<a id="_idIndexMarker846"/> handling errors is, we have to think of our system as a whole, including inputs and output. Our code by itself might never experience an error; however, when integrated with other systems, it might cause unpredictable outputs, or might just crash and stop working.</p>
<p>Therefore, handling errors is important to cope with the unpredictability of inputs and protect your code to avoid wrong outputs or crashes. But how do we do that?</p>
<p>First, we need to identify<a id="_idIndexMarker847"/> our inputs, and then we create a series of different combinations of values that are sent to our inputs. The behavior of these input combinations are then evaluated by running our code. For a function, we do that by adding unit tests, as we discussed in <a href="B18165_05.xhtml#_idTextAnchor127"><em class="italic">Chapter 5</em></a>. For the system, we add integration tests and end-to-end testing. Additional techniques were also discussed in <a href="B18165_05.xhtml#_idTextAnchor127"><em class="italic">Chapter 5</em></a>.</p>
<p>But what is the correct way to write code for handling errors? It will depend on the language.</p>
<p>Writing code to handle errors is quite different in Go compared to Python. Let’s see how we do this effectively in Go then in Python.</p>
<h2 id="_idParaDest-186"><a id="_idTextAnchor187"/>Adding error handling in Go</h2>
<p>The design of the Go language<a id="_idIndexMarker848"/> requires explicitly checking errors when they occur, which is different from throwing exceptions and then catching them like in Python. In Go, errors are just values returned by functions, which makes Go coding a bit more <a id="_idIndexMarker849"/>verbose and perhaps more repetitive. With Python, you would not need to check errors, as an exception would be raised, but in Go, you have <a id="_idIndexMarker850"/>to check the errors. But on the other hand, Go error handling is much simpler compared to Python.</p>
<p>Errors in Go are created by using an <code>error</code> type interface, as follows:</p>
<pre class="source-code">
type error interface {
    Error() string
}</pre>
<p>As you can see in the preceding code, the error implementation in Go is quite simple by using a method called <code>Error()</code> that returns an error message as a string.</p>
<p>The correct way to construct an error in your code is by using either the <code>errors</code> or <code>fmt</code> standard libraries</p>
<p>The following are two examples of using each of them for a division-by-zero function.</p>
<p>Using the <code>errors</code> library looks as follows:</p>
<pre class="source-code">
func divide(q int, d int) (int, error) {
    if d == 0 {
        return 0, errors.New("division by zero not valid")
    }
    return q / d, nil
}</pre>
<p>Using the <code>fmt</code> library<a id="_idIndexMarker851"/> looks as<a id="_idIndexMarker852"/> follows:</p>
<pre class="source-code">
func divide(q int, d int) (int, error) {
    if d == 0 {
        return 0, fmt.Errorf("divided by zero not valid")
    }
    return q / d, nil
}</pre>
<p>The preceding two examples produce the same results. For instance, if you call any of the two functions with <code>fmt.Println(divide(10, 0))</code>, it will print the following output: <code>0 divided by zero </code><code>not valid</code>.</p>
<p>The major difference <a id="_idIndexMarker853"/>between <code>fmt.Errorf</code> and <code>errors.New</code> is the possibility of formatting the string and adding values. Another point is that <code>errors.New</code> is faster because it does not invoke the formatter.</p>
<p>If you are looking to create custom errors, stack traces, and more advanced error features, consider using the <code>errors</code> library or third-party libraries such as the popular <code>pkg/errors</code> (<a href="https://pkg.go.dev/github.com/pkg/errors">https://pkg.go.dev/github.com/pkg/errors</a>) or <code>golang.org/x/xerrors</code> (<a href="https://pkg.go.dev/golang.org/x/xerrors">https://pkg.go.dev/golang.org/x/xerrors</a>).</p>
<p>Let’s focus now on the best practices when writing code for error handling in Go. The following are the top best practices.</p>
<h3>Return errors last and values to 0</h3>
<p>When creating a function that returns several values, the error should be placed as the last argument returned. When returning <a id="_idIndexMarker854"/>values with errors, use 0 when it is a number and <code>empty string</code> for strings, as in the following example:</p>
<pre class="source-code">
func findNameCount(text string) (string, int, error) {
    if len(text) &lt; 5 {
        return "", 0, fmt.Errorf("text too small")
    }
    . . .
}</pre>
<p>In the preceding example, the value of the string returned is empty and the value of <code>int</code> returned is 0. These values are just suggestions, because when an error is returned, the calling statement will first check whether there is an error before assigning the returned variables. Therefore, the values returned with an error are irrelevant.</p>
<h3>Add only information that the caller does not have</h3>
<p>When creating the error message, do not <a id="_idIndexMarker855"/>add information that is already known by the caller of your function. The following example illustrates this problem:</p>
<pre class="source-code">
func divide(q int, d int) (int, error) {
    if d == 0 {
        return 0, fmt.Errorf("%d can't be divided by zero", q)
    }
    return q / d, nil
}</pre>
<p>As you can see in the preceding example, the value of <code>q</code> was returned in the error message. But that is not necessary, because the caller of the <code>divide</code> function has this value.</p>
<p>When creating errors to return in your function, do not include any arguments passed in the function, as this is known<a id="_idIndexMarker856"/> by the caller. This can lead to information duplication.</p>
<h3>Use lowercase and do not end with punctuation</h3>
<p>Always use lowercase as your <a id="_idIndexMarker857"/>error message will be concatenated with other messages when returning. Most of the time, you should also not use any punctuation, because the error messages will probably be linked together, and punctuation<a id="_idIndexMarker858"/> will end up looking odd in the middle of the error message.</p>
<p>The exception of the lowercase rule is when you are referring to the names of functions or methods that already have capital letters.</p>
<h3>Add a colon to the error message</h3>
<p>A colon (<code>:</code>) is used whenever you want to<a id="_idIndexMarker859"/> add information from another error message of a call made inside your code. Let’s use the following code as an example:</p>
<pre class="source-code">
func connect(host string, conf ssh.ClientConfig) error {
    conn, err := ssh.Dial("tcp", host+":22", conf)
    if err != nil {
        return fmt.Errorf("ssh.Dial: %v", err)
    }
    . . .</pre>
<p>In the preceding example, the <code>connect</code> function encapsulates a call to <code>ssh.Dial</code>. We can add the context of the error to the error message by indicating which call generated the error by adding the name of the call or some information about <code>ssh.Dial</code>, using a colon to separate it if necessary. Note that the <code>config</code> and <code>host</code> arguments are known by the caller of the <code>connect</code> function and therefore should not be added to the error message.</p>
<h3>Use defer, panic, and recover</h3>
<p>Go has important mechanisms to control how the program flows during errors. That is mostly useful when using goroutines, because one might cause the program to crash, and you might need to be extra careful to avoid unclosed software pipes and software caches; and avoid unfreed memory and unclosed file descriptors</p>
<h4>defer</h4>
<p>Go <code>defer</code> is used to push the <a id="_idIndexMarker860"/>execution to a list that is only executed after the surrounding function has returned or when it crashes. The main intention of <code>defer</code> is to perform <a id="_idIndexMarker861"/>a cleanup. Consider the following example of a function that copies data from one file to another and then removes it:</p>
<pre class="source-code">
func moveFile(srcFile, dstFile string) error {
    src, err := os.Open(srcFile)
    if err != nil {
        return fmt.Errorf("os.Open: %v", err)
    }
    dst, err := os.Create(dstFile)
    if err != nil {
        return fmt.Errorf("os.Create: %v", err)
    }
    _, err = io.Copy(dst, src)
    if err != nil {
        return fmt.Errorf("io.Copy: %v", err)
    }
    dst.Close()
    src.Close()
    err = os.Remove(srcFile)
    if err != nil {
        return fmt.Errorf("os.Remove: %v", err)
    }
    return nil
}</pre>
<p>In the preceding example, if an error occurs in <code>os.Create</code>, the function would return before <a id="_idIndexMarker862"/>calling <code>src.Close()</code>, which means the file has not been closed properly.</p>
<p>The way to avoid having to <a id="_idIndexMarker863"/>add the <code>close</code> statement repetitively throughout the code is to use <code>defer</code>, like the following example:</p>
<pre class="source-code">
func moveFile(srcFile, dstFile string) error {
    src, err := os.Open(srcFile)
    if err != nil {
        return fmt.Errorf("os.Open: %v", err)
    }
    defer src.Close()
    dst, err := os.Create(dstFile)
    if err != nil {
        return fmt.Errorf("os.Create: %v", err)
    }
    defer dst.Close()
    _, err = io.Copy(dst, src)
    if err != nil {
        return fmt.Errorf("io.Copy: %v", err)
    }
    err = os.Remove(srcFile)
    if err != nil {
        return fmt.Errorf("os.Remove: %v", err)
    }
    return nil
}</pre>
<p>As you can see in the<a id="_idIndexMarker864"/> preceding example, <code>defer</code> is used just after a successful <code>os.Open</code> and after a successful <code>os.Create</code>. Therefore, if there is an error, or if the function ends, it will invoke <code>dst.Close()</code> first and then <code>src.Close()</code> in a<a id="_idIndexMarker865"/> reverse order, like in a <strong class="bold">Last In, First Out</strong> (<strong class="bold">LIFO</strong>) queue.</p>
<p>Let’s see how to use <code>panic</code> now.</p>
<h4>panic</h4>
<p>When writing code, if you don’t <a id="_idIndexMarker866"/>want to handle an error, you can use <code>panic</code> to indicate that you want to stop immediately. In Go, <code>panic</code> can be called in your <a id="_idIndexMarker867"/>program by explicitly writing it, but it is also called automatically during runtime if an error occurs. The following is a list of the major runtime errors that can occur:</p>
<ul>
<li>Out-of-bounds memory access, including arrays</li>
<li>Assertion of a wrong type</li>
<li>Attempting to call a function using a variable with a <code>nil</code> pointer</li>
<li>Sending data to a closed channel or file descriptor</li>
<li>Division by zero</li>
</ul>
<p>Therefore, <code>panic</code> is only used in your code when you are not planning to handle the error or are dealing with errors that are not yet understood.</p>
<p>It is important to note that before<a id="_idIndexMarker868"/> exiting the function and passing the <code>panic</code> message, the program will still run all <code>defer</code> statements that were stacked earlier in the function.</p>
<p>Here is an example of<a id="_idIndexMarker869"/> using <code>panic</code> to exit the program after receiving a negative value as an argument:</p>
<pre class="source-code">
import (
    "fmt"
    "math"
)
func squareRoot(value float64) float64 {
    if value &lt; 0 {
        panic("negative values are not allowed")
    }
    return math.Sqrt(value)
}
func main() {
    fmt.Println(squareRoot(-2))
    fmt.Println("done")
}</pre>
<p>Let’s run this program and check the output:</p>
<pre class="console">
$ go run panic-example.go
panic: negative values are not allowed
goroutine 1 [running]:
main.squareRoot(...)
    Dev/Chapter07/Go/panic-example.go:10
main.main()
    Dev/Chapter07/Go/panic-example.go:17 +0x45
exit status 2</pre>
<p>Note that the output does<a id="_idIndexMarker870"/> not print <code>done</code>, because <code>panic</code> is called inside the <code>squareRoot</code> function, before the instruction to print.</p>
<p>Say we add <code>defer</code> to the function <a id="_idIndexMarker871"/>as follows:</p>
<pre class="source-code">
func squareRoot(value float64) float64 {
    defer fmt.Println("ending the function")
    if value &lt; 0 {
        panic("negative values are not allowed")
    }
    return math.Sqrt(value)
}</pre>
<p>The output will be as follows:</p>
<pre class="console">
$ go run panic-example.go
ending the function
panic: negative values are not allowed
goroutine 1 [running]:
main.squareRoot(…)
    Dev/Chapter07/Go/panic-example.go:10
main.main()
    Dev/Chapter07/Go/panic-example.go:17 +0x45
exit status 2</pre>
<p>Note that the <code>ending the function</code> print statement was placed before sending the <code>panic</code> message. That is because, as we explained, the <code>defer</code> stack is executed before returning the <a id="_idIndexMarker872"/>function by <code>panic</code>.</p>
<p>Let’s now see how <a id="_idIndexMarker873"/>we can use <code>recover</code>.</p>
<h4>recover</h4>
<p>In Go, <code>recover</code> is the last piece of<a id="_idIndexMarker874"/> error flow control necessary to<a id="_idIndexMarker875"/> handle errors. It is used to handle a <code>panic</code> situation and regain control. It should only be used inside a <code>defer</code> function call. In a normal call, <code>recover</code> will return a <code>nil</code> value, but in the <code>panic</code> situation, it will return the value given to <code>panic</code>.</p>
<p>As an example, let’s consider the following program:</p>
<pre class="source-code">
import "fmt"
func divide(q, d int) int {
    fmt.Println("Dividing it now")
    return q / d
}
func main() {
    fmt.Println("the division is:", divide(4, 0))
}</pre>
<p>If you run the preceding <a id="_idIndexMarker876"/>program, you will get the following <code>panic</code> message:</p>
<pre class="console">
$ go run division-by-zero-panic.go
Dividing it now
panic: runtime error: integer divide by zero
goroutine 1 [running]:
main.divide(...)
    Dev/Chapter07/Go/division-by-zero-panic.go:7
main.main()
    Dev/Chapter07/Go/division-by-zero-panic.go:11 +0x85
exit status 2</pre>
<p>As you can see from this output, you have no control of the <code>panic</code> situation. It will basically crash the program without the possibility to handle the error properly. This is undesirable in most <a id="_idIndexMarker877"/>production software, especially using multiple goroutines.</p>
<p>Therefore, to properly handle the <code>panic</code> situation, you should add a <code>defer</code> function to test whether it is a <code>panic</code> situation by using <code>recover</code>, as in the following example:</p>
<pre class="source-code">
import "fmt"
func divide(q, d int) int {
    fmt.Println("Dividing it now")
    return q / d
}
func main() {
    defer func() {
        if r := recover(); r != nil {
            fmt.Println("Got a panic:", r)
        }
    }()
    fmt.Println("the division is:", divide(4, 0))
}</pre>
<p>After adding the <code>defer</code> function as in<a id="_idIndexMarker878"/> the preceding example, the output<a id="_idIndexMarker879"/> will be as follows:</p>
<pre class="console">
$ go run division-by-zero-panic-recover.go
Dividing it now
Got a panic: runtime error: integer divide by zero</pre>
<p>As you can see, adding a <code>recover</code> test inside the <code>defer</code> function will allow you to handle unexpected <code>panic</code> situations, avoiding your program crashing unexpectedly without doing a proper cleanup or fixing the error.</p>
<p>Now that we have investigated how to handle Go errors, let’s have a look at Python error handling.</p>
<h2 id="_idParaDest-187"><a id="_idTextAnchor188"/>Adding error handling in Python</h2>
<p>Python handles errors differently <a id="_idIndexMarker880"/>than Go. Python does not require your <a id="_idIndexMarker881"/>function to return error values. In Python, errors are thrown during runtime and they are called<a id="_idIndexMarker882"/> exceptions. To handle exceptions, your code has to catch them properly and avoid raising them.</p>
<h3>Catching exceptions</h3>
<p>In Python, there are built-in exceptions that are raised by many runtime errors. The list of built-in exceptions is quite long and can be found here: <a href="https://docs.python.org/3/library/exceptions.html">https://docs.python.org/3/library/exceptions.html</a>. As an example, the division-by-zero error is called a <code>ZeroDivisionError</code> exception.</p>
<p>To handle the error, you need to catch the <a id="_idIndexMarker883"/>exception and then handle it by using the <code>try</code>, <code>except</code>, <code>else</code>, and <code>finally</code> Python statements. To create an example of how to handle the exception for division by zero, let’s first run the following program without catching an exception:</p>
<pre class="source-code">
def division(q, d):
    return q/d
print(division(1, 0))</pre>
<p>If you run the preceding program, it will generate the following output:</p>
<pre class="console">
$ python catching-division-by-zero-exception.py
Traceback (most recent call last):
  File "Chapter07/Python/catching-division-by-zero-exception.py", line 7, in &lt;module&gt;
    print(division(1, 0))
  File "Chapter07/Python/catching-division-by-zero-exception.py", line 4, in division
    return q/d
<strong class="bold">ZeroDivisionError</strong>: division by zero</pre>
<p>As you can see, the program crashes and shows the error message as <code>Traceback</code> on the screen, with details of where the error occurs and the name of the exception, in this case, <code>ZeroDivisionError</code>.</p>
<p>Now, let’s update the Python code to catch this exception and handle the error more gracefully, like the following code:</p>
<pre class="source-code">
def division(q, d):
    return q/d
try:
    print(division(1, 0))
except <strong class="bold">ZeroDivisionError</strong>:
    print("Error: We should not divide by zero")</pre>
<p>Now, if you run the program, it will<a id="_idIndexMarker884"/> print the error gracefully without crashing it, as follows:</p>
<pre class="console">
$ python catching-division-by-zero-exception.py
Error: We should not divide by zero</pre>
<p>So, whenever you think there is a possibility for the function to raise an exception by an error, use the <code>try</code> and <code>except</code> statements, as shown in the preceding example.</p>
<p>In addition to <code>try</code> and <code>except</code> statements, Python also allows using <code>else</code> and <code>finally</code> statements to add more flow control of the error handling. They are not mandatory as the flow can be controlled outside the <code>try</code>/<code>except</code> statement, but they are sometimes useful. The following is the same example of adding the <code>else</code> and <code>finally</code> statements:</p>
<pre class="source-code">
def division(q, d):
    return q/d
try:
    result = division(10, 1)
except ZeroDivisionError:
    print("Error: We should not divide by zero")
else:
    print("Division succeded, result is:", result)
finally:
    print("done")</pre>
<p>If you run this program, it will generate the following output:</p>
<pre class="console">
$ python catch-else-finally-division-by-zero.py
Division succeded, result is: 10.0
done</pre>
<p>Note that the <code>else</code> statement is only executed if no exception was raised in the <code>try</code> clause. The <code>finally</code> statement is <a id="_idIndexMarker885"/>always executed, regardless of whether an exception was raised or not in the <code>try</code> clause.</p>
<p>Now that we have seen how to catch an exception in Python, let’s discuss how to choose the exception we want to catch.</p>
<h3>Choosing more specific exceptions</h3>
<p>In Python, exceptions are hierarchical <a id="_idIndexMarker886"/>and always start with the exception called <code>BaseException</code>. As an example, division by zero exhibits the following hierarchy:</p>
<pre class="source-code">
BaseException -&gt; Exception -&gt; ArithmeticError-&gt; ZeroDivisionError</pre>
<p>The exceptions hierarchy is quite useful, because your code can catch either a higher-level exception or a more specific one. With division by zero, you could catch the <code>ArithmeticError</code> exception instead of <code>ZeroDivisionError</code>. However, it’s a good practice sometimes to catch the more specific exception instead of a higher-level one.</p>
<p>More specific exceptions are more desirable to be caught inside functions and libraries, because if you catch generic exceptions inside the function, you might mask the problem when another part of the code calls your function. So, it will depend on where you are catching and how you are handling it.</p>
<p>We now have a good idea how to handle errors in Go and Python. Let’s discuss how to add logging to our code.</p>
<h1 id="_idParaDest-188"><a id="_idTextAnchor189"/>Logging events</h1>
<p>In computer software, logging is a <a id="_idIndexMarker887"/>well-known technique used to help troubleshoot a problem, record milestones, understand behavior, retrieve information, and check historical events, among other useful actions. Despite these advantages, not many developers add proper logging to their code. In fact, some developers do nothing and add logging only when the program has problems and needs debugging.</p>
<p>In network automation, logging is even more important, because network elements are normally distributed and rely heavily on logging to be able to be audited in case of a problem or if an improvement is needed. Adding logging to your code is a good practice that will be appreciated by several levels of engineering, such as network operators, network planners, network security, and network designers, among others.</p>
<p>But one important point here that must be observed is that time synchronization between network elements is<a id="_idIndexMarker888"/> mandatory to allow logging to be useful. Protocols such as the <strong class="bold">Network Time Protocol</strong> (<strong class="bold">NTP</strong>) or <strong class="bold">Precision Time Protocol</strong> (<strong class="bold">PTP</strong>) must be used<a id="_idIndexMarker889"/> throughout the network.</p>
<p>A good practice to use logging is to use the Unix logging reference called <code>syslog</code>, firstly published as an informational RFC in RFC3164 and then as a standard document in RFC5424 (<a href="https://www.rfc-editor.org/rfc/rfc3164">https://www.rfc-editor.org/rfc/rfc3164</a>).</p>
<p>For our network automation code, we do not need to follow all the details in the <code>syslog</code> protocol standard, but we are going to use it as a guide for logging useful information based on severity level.</p>
<p>Let’s now talk about some levels of information we want when logging events.</p>
<h2 id="_idParaDest-189"><a id="_idTextAnchor190"/>Severity levels</h2>
<p>The RFC5424 <code>syslog</code> protocol has defined eight levels of severity, which are described in <em class="italic">Section 6.2.1</em> of RFC5424 (<a href="https://www.rfc-editor.org/rfc/rfc5424#section-6.2.1">https://www.rfc-editor.org/rfc/rfc5424#section-6.2.1</a>). They are mentioned in the following list <a id="_idIndexMarker890"/>with a brief explanation of what kind of information message is intended to be added to each one:</p>
<ul>
<li><code>Emergency</code>: The system is not operational and there is no possible recovery.</li>
<li><code>Alert</code>: Immediate attention is required.</li>
<li><code>Critical</code>: Something bad is happening and quick attention is required to fix it.</li>
<li><code>Error</code>: Failure is occurring but does not need urgent attention.</li>
<li><code>Warning or Warn</code>: Indicates that something is wrong and might cause an error in the future, such as software not updated.</li>
<li><code>Notice</code>: An important milestone that has been reached and might indicate a future warning, such as<a id="_idIndexMarker891"/> configuration not saved or resource utilization limit not set.</li>
<li><code>Informational or Info</code>: Normal operational milestone messages. Used later for audit and investigation.</li>
<li><code>Debug</code>: Used by developers to troubleshoot a problem or to investigate possible improvements.</li>
</ul>
<p>Although these eight levels are defined in the <code>syslog</code> protocol, they are quite ambiguous and open to different interpretations. For instance, <code>Alert</code> and <code>Emergency</code> might be different for different developers when writing code, as is the case with other levels, such as <code>Notice</code> and <code>Informational</code>. Therefore, some network developers prefer to use less levels with easier interpretation. The number will depend on how the network operates, but varies between three and five levels. For Go and Python, the number of levels will depend on the library you are using to create the log messages. Some might have more levels than others.</p>
<p>Now, let’s investigate how to add log events to your code using Go and Python.</p>
<h1 id="_idParaDest-190"><a id="_idTextAnchor191"/>Adding logging to your code</h1>
<p>Adding event logging in your code <a id="_idIndexMarker892"/>will be different in Go and in Python and will vary depending on the library used in your code. But the idea for both languages is to divide the information into severity levels, as done in <code>syslog</code>.</p>
<p>The severity log levels will also vary depending on the library used. Python and Go have standard log libraries, but you are also able to use third-party libraries to log events in both languages.</p>
<p>One important point here is that when writing the code, you will decide whether there is a need to add a logging event line. The line of logging added must carry some information that will signal to the program which level of severity the message is. Therefore, important messages such as failures will have priority over less-important messages, such as debugging. Ideally, the decision about which level of logging should be exposed is normally made by<a id="_idIndexMarker893"/> adding input arguments to your program that allow setting the log level. So, if you are running the program for debugging, it will generate much more information compared to a normal operation.</p>
<p>Let’s now see how we can add logging events to our code in Go and then we check how to do it in Python.</p>
<h2 id="_idParaDest-191"><a id="_idTextAnchor192"/>Adding event logging in Go</h2>
<p>The Go language has a standard <a id="_idIndexMarker894"/>library for logging that comes with the Go installation, but it is quite<a id="_idIndexMarker895"/> limited. For more advanced logging capabilities in Go, you might want to use third-party libraries for logging.</p>
<p>Let’s see how we can<a id="_idIndexMarker896"/> use the standard library and then check other popular third-party libraries.</p>
<h3>Using standard Go logging</h3>
<p>The standard logging<a id="_idIndexMarker897"/> library in Go can be imported using <code>log</code> in the <code>import</code> statement. By default, Go standard<a id="_idIndexMarker898"/> logging does not provide any severity levels, but it has some helper functions that can help create logs. The helper functions are listed here:</p>
<ul>
<li><code>Print</code>, <code>Printf</code>, and <code>Println</code>: These functions print the message passed to them in the terminal using <code>stderr</code></li>
<li><code>Panic</code>, <code>Panicf</code>, and <code>Panicln</code>: These are like <code>Print</code>, but they call <code>Panic</code> after printing the log message</li>
<li><code>Fatal</code>, <code>Fatalf</code>, and <code>Fatalln</code>: These also work like <code>Print</code>, but they call <code>os.Exit(1)</code> after printing the log message</li>
</ul>
<p>The following is a simple example of using the standard Go logging library:</p>
<pre class="source-code">
import (
    "log"
    "os/user"
)
func main() {
    user, err := user.Current()
    if err != nil {
        log.Fatalf("Failed with error: %v", err)
    }
    log.Printf("Current user is %s", user.Username)
}</pre>
<p>Running this program will print<a id="_idIndexMarker899"/> the following output without errors:</p>
<pre class="console">
% go run standard-logging.go
2022/11/08 18:53:24 Current user is claus</pre>
<p>If for any reason it is not possible to retrieve the current user, it will call <code>Fatalf</code>, which will call <code>os.Exit(1)</code> after <a id="_idIndexMarker900"/>printing the failed message.</p>
<p>Now, let’s show a more complex example of how to create severity levels using the standard logging library and saving it to a file:</p>
<pre class="source-code">
import (
    "log"
    "os"
)
var criticalLog, errorLog, warnLog, infoLog, debugLog *log.Logger
func init() {
    file, err := os.Create("log-file.txt")
    if err != nil {
        log.Fatal(err)
    }
    flags := log.Ldate | log.Ltime
    criticalLog = log.New(file, "CRITICAL: ", flags)
    errorLog = log.New(file, "ERROR: ", flags)
    warnLog = log.New(file, "WARNING: ", flags)
    infoLog = log.New(file, "INFO: ", flags)
    debugLog = log.New(file, "DEBUG: ", flags)
}
func main() {
    infoLog.Print("That is a milestone")
    errorLog.Print("Got an error here")
    debugLog.Print("Extra information for a debug")
    warnLog.Print("You should be warned about this")
}</pre>
<p>In the preceding example, we<a id="_idIndexMarker901"/> created five levels of severity that can be used to write to a file as required. Note that in Go, the <code>init()</code> function is executed before the <code>main()</code> function. If you want to use<a id="_idIndexMarker902"/> these log definitions within other packages, remember to use capitalization of the variables; otherwise, the variables will be local to this package; for example, <code>errorLog</code> should be <code>ErrorLog</code>.</p>
<p>Also, if you want to set a log level to avoid <code>Debug</code> or <code>Info</code> messages, you will have to pass an argument to your program and suppress lower levels of severity depending on the level set. Using the Go<a id="_idIndexMarker903"/> standard logging library, you will have to do that on your own.</p>
<p>Now, let’s investigate a <a id="_idIndexMarker904"/>third-party logging library that is very popular with Go developers.</p>
<h3>Using logrus</h3>
<p>Perhaps one of the most popular libraries for logging in Go, <code>logrus</code> is a structured logging library with several <a id="_idIndexMarker905"/>logging capabilities. <code>logrus</code> has seven log levels and is compatible with the standard logging library. By default, the library allows you <a id="_idIndexMarker906"/>to set the log level, so it won’t create noise if you don’t want to see debugging information.</p>
<p>Here is a simple example of using <code>logrus</code> and setting the log level to <code>Error</code>, which means lower-level logs will not show, such as <code>Warning</code>, <code>Info,</code> or <code>Debug</code>:</p>
<pre class="source-code">
import (
    log "github.com/sirupsen/logrus"
)
func init() {
    log.SetFormatter(&amp;log.TextFormatter{
        DisableColors: true,
        FullTimestamp: true,
    })
    <strong class="bold">log.SetLevel(log.ErrorLevel)</strong>
}
func main() {
    log.Debug("Debug is suppressed in error level")
    log.Info("This info won't show in error level")
    log.Error("Got an error here")
}</pre>
<p>Running the preceding example<a id="_idIndexMarker907"/> will only show the following output in <a id="_idIndexMarker908"/>the terminal:</p>
<pre class="console">
% go run logrus-logging.go
time="2022-11-09T11:16:48-03:00" level=error msg="Got an error here"</pre>
<p>Because the level of severity is set to <code>ErrorLevel</code>, none of the less-significant log messages will be displayed – in the example, the calls for <code>log.Info</code> and <code>log.Debug</code>.</p>
<p><code>logrus</code> is very flexible and powerful with plenty of examples of usage on the internet. More details on <code>logrus</code> can be found at <a href="https://github.com/sirupsen/logrus">https://github.com/sirupsen/logrus</a>.</p>
<p>If you want to use more<a id="_idIndexMarker909"/> logging libraries in Go, here is a compiled list of third-party log libraries: <a href="https://awesome-go.com/logging/">https://awesome-go.com/logging/</a>.</p>
<p>Now, let’s check how we add logging to our code using Python.</p>
<h2 id="_idParaDest-192"><a id="_idTextAnchor193"/>Add event logging in Python</h2>
<p>In comparison to Go, Python<a id="_idIndexMarker910"/> has added many more features to the standard logging library. Despite the better support, the Python community has also developed <a id="_idIndexMarker911"/>many third-party logging libraries.</p>
<p>Let’s have a look at the standard library and then a popular third-party library for Python.</p>
<h3>Using standard logging for Python</h3>
<p>The standard logging library comes with five severity levels and an extra level that is used to indicate the level was<a id="_idIndexMarker912"/> not set by the logger. Each level has a number associated with it that can be <a id="_idIndexMarker913"/>used to interpret the priority level, where lower numbers have lower priority. The levels are <code>CRITICAL</code> (50), <code>ERROR</code> (40), <code>WARNING</code> (30), <code>INFO</code> (20), <code>DEBUG</code> (10), and <code>NOTSET</code> (0).</p>
<p>The <code>NOTSET</code> level is useful when using log hierarchies, allowing a non-root logger to delegate the level to its parent.</p>
<p>The following is an example of using Python standard logging:</p>
<pre class="source-code">
import logging
    logging.basicConfig(
        filename='file-log.txt',
        level=<strong class="bold">logging.ERROR</strong>,
        format='%(asctime)s.%(msecs)03d %(levelname)s: %(message)s',
        datefmt='%Y-%m-%d %H:%M:%S',
)
logging.debug("This won't show, level is set to info")
logging.info("Info is not that important as well")
logging.warning("Warning will not show as well")
logging.error("This is an error")</pre>
<p>Running the preceding program will produce the following line in the output file called <code>file-log.txt</code>:</p>
<pre class="console">
2022-11-09 14:48:52.920 ERROR: This is an error</pre>
<p>As illustrated in the preceding code, setting the level to <code>logging.ERROR</code> will not allow the lower-level log messages to be written in the file. The program just ignores the <code>logging.debug()</code>, <code>logging.info()</code>, and <code>logging.warning()</code> calls.</p>
<p>Another important point is to show how easier it is to use standard logging in Python. The preceding example shows that you just need one call to <code>logging.basicConfig</code> to set almost everything you need, from the formatter to the level of severity.</p>
<p>In addition to being easy to use, the Python community has created great tutorials and documentation for the standard<a id="_idIndexMarker914"/> logging library. Here are the three main references for the documentation and advanced utilization info:</p>
<ul>
<li><a href="https://docs.python.org/3/library/logging">https://docs.python.org/3/library/logging</a></li>
<li><a href="https://docs.python.org/3/howto/logging.html">https://docs.python.org/3/howto/logging.html</a></li>
<li><a href="https://docs.python.org/3/howto/logging-cookbook.html">https://docs.python.org/3/howto/logging-cookbook.html</a></li>
</ul>
<p>In essence, the Python standard logging library is quite complete, and you won’t need to use a third-party library for <a id="_idIndexMarker915"/>most of your work. However, there are some nice and interesting features in one popular third-party library for Python called <code>loguru</code>. Let’s see how to use it.</p>
<h3>Using Python loguru</h3>
<p>Python <code>loguru</code> provides a few more features than the standard Python logging library and has the aim of being easier to use<a id="_idIndexMarker916"/> and configure. For instance, using <code>loguru</code>, you will be able to set file rotation on the log file, use a more advanced string formatter, and use decorators to catch exceptions on functions, and it is thread and <a id="_idIndexMarker917"/>multiprocessing safe.</p>
<p>It also has interesting features that can allow you to add extra information to the logging by using a <code>patch</code> method (more on the <code>patch</code> method at <a href="https://loguru.readthedocs.io/en/stable/api/logger.html#loguru._logger.Logger.patch">https://loguru.readthedocs.io/en/stable/api/logger.html#loguru._logger.Logger.patch</a>).</p>
<p>The following is a simple example using <code>loguru</code>:</p>
<pre class="source-code">
from loguru import logger
logger.add(
    "file-log-{time}.txt",
    rotation="1 MB",
    colorize=False,
    level="ERROR",
)
logger.debug("That's not going to show")
logger.warning("This will not show")
logger.error("Got an error")</pre>
<p>Running the preceding example <a id="_idIndexMarker918"/>will create a file with the date and time with log messages that will rotate if it reaches 1 MB in size. The output<a id="_idIndexMarker919"/> written in the file will look as follows:</p>
<pre class="console">
% cat file-log-2022-11-09_15-53-58_056790.txt
2022-11-09 15:53:58.063 | ERROR    | __main__:&lt;module&gt;:13 - Got an error</pre>
<p>More detailed documentation can be found at <a href="https://loguru.readthedocs.io">https://loguru.readthedocs.io</a> and the source code at <a href="https://github.com/Delgan/loguru">https://github.com/Delgan/loguru</a>.</p>
<h1 id="_idParaDest-193"><a id="_idTextAnchor194"/>Summary</h1>
<p>After reading this chapter, you are probably more aware of why we need to handle errors and why we need to create proper event logging. You also should be more familiar with the differences between how Go and Python handle errors. Furthermore, you saw the differences in how to use standard libraries and third-party libraries for event logging. From now on, your network automation code design will have a special section on logging and error handling.</p>
<p>In the next chapter, we are going to talk about how we can scale our code and how our network automation solution can interact with large networks.</p>
</div>
</body></html>