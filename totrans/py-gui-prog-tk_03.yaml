- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating Basic Forms with Tkinter and Ttk Widgets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Good news! Your design has been reviewed and approved by the director. Now
    it''s time to start implementing it! In this chapter, we''ll be creating a very
    simple application that delivers the core functionality of the specification and
    little else. This is known as a **minimum viable product** or **MVP**. The MVP
    will not be production-ready, but it will give us something to show our users
    and help us better understand the problem and the technologies we''re working
    with. We''ll cover this in the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: In *The Ttk widget set*, we'll learn about a better widget set for Tkinter,
    Ttk.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In *Implementing the application*, we'll build our form design using Python,
    Tkinter, and Ttk.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get coding!
  prefs: []
  type: TYPE_NORMAL
- en: The Ttk widget set
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *Chapter 1*, *Introduction to Tkinter*, we created a survey application using
    the default Tkinter widgets. These widgets are perfectly functional and still
    used in many Tkinter applications, but modern Tkinter applications tend to prefer
    an improved set of widgets called **Ttk**. Ttk is a sub-module of Tkinter that
    provides themed versions of many (but not all) Tkinter widgets. These widgets
    are mostly identical to the traditional widgets but provide advanced styling options
    in an aim to look more modern and natural on Windows, macOS, and Linux.
  prefs: []
  type: TYPE_NORMAL
- en: On each platform, Ttk includes platform-specific themes that mimic the platform's
    native widgets. In addition, Ttk adds a few extra widgets that offer functionality
    not found in the default library.
  prefs: []
  type: TYPE_NORMAL
- en: Although this chapter will cover the basic usage of Ttk widgets, full coverage
    of the fonts, colors, and other style customization for Ttk widgets can be found
    in *Chapter 9*, *Improving the Look with Styles and Themes*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ttk is already included as part of Tkinter, so we do not need to install anything
    extra. To use Ttk widgets in our Tkinter applications, we will need to import
    `ttk` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In this section, we''ll take a deeper look at the Ttk widgets that will be
    useful in our application. Remember from our design that we need the following
    types of widgets for our application:'
  prefs: []
  type: TYPE_NORMAL
- en: Labels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Date entry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Text entry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Number entry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check boxes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Radio buttons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Select list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Long text entry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Buttons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boxed frames with headers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's look at the Ttk widgets that we can use to meet these needs.
  prefs: []
  type: TYPE_NORMAL
- en: The Label widget
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We made good use of the Tkinter `Label` widget in *Chapter 1*, *Introduction
    to Tkinter*, and the Ttk version is essentially the same. We can create one like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in a label that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17578_03_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.1: A Ttk Label widget'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Ttk `Label` widget shares most of the same options as the Tk version, the
    most common of which are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Argument | Values | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `text` | String | The text content of the label |'
  prefs: []
  type: TYPE_TB
- en: '| `textvariable` | `StringVar` | The variable to bind to the contents of the
    label |'
  prefs: []
  type: TYPE_TB
- en: '| `anchor` | Cardinal direction | The position of the text relative to the
    inner margins |'
  prefs: []
  type: TYPE_TB
- en: '| `justify` | `left`, `right`, or `center` | The alignment of the lines of
    text relative to one another |'
  prefs: []
  type: TYPE_TB
- en: '| `foreground` | Color string | The color of the text |'
  prefs: []
  type: TYPE_TB
- en: '| `wraplength` | Integer | Number of pixels before the text is wrapped to the
    next line |'
  prefs: []
  type: TYPE_TB
- en: '| `underline` | Integer | The index of a character in `text` to underline |'
  prefs: []
  type: TYPE_TB
- en: '| `font` | Font string or tuple | The font to be used |'
  prefs: []
  type: TYPE_TB
- en: Note that a label's text can either be specified directly using `text`, or bound
    to a `StringVar`, allowing for dynamic label text. The `underline` argument allows
    for underlining a single character in the label text; this is useful for indicating
    a keybinding for the user, for example, to activate a control widget labeled by
    the label. No keybinding is actually created by this argument; it's merely cosmetic.
    We'll learn to create keybindings in *Chapter 10*, *Maintaining Cross-Platform
    Compatibility*.
  prefs: []
  type: TYPE_NORMAL
- en: The Entry widget
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `ttk.Entry` widget is a simple one-line text entry, just like the Tkinter
    version. It looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17578_03_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.2: A Ttk Entry widget'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create an `Entry` widget using this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The Ttk `Entry` is very similar to the Tkinter `Entry` widget we''ve already
    seen, and supports many of the same arguments. Here is a selection of the more
    common `Entry` options:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Argument | Values | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `textvariable` | `StringVar` | Tkinter control variable to bind. |'
  prefs: []
  type: TYPE_TB
- en: '| `show` | String | Character or string to show when the user types. Useful
    for password fields, for example. |'
  prefs: []
  type: TYPE_TB
- en: '| `justify` | `left`, `right`, or `center` | Alignment of the text in the entry.
    `left` is default. |'
  prefs: []
  type: TYPE_TB
- en: '| `foreground` | Color string | Color of text. |'
  prefs: []
  type: TYPE_TB
- en: We'll learn some more options for the `Entry` as we dig deeper into the capabilities
    of Ttk widgets in future chapters. The `Entry` will be used for all of our text
    entry fields, as well as our `Date` field. Ttk does not have a dedicated `date`
    widget, but we'll learn in *Chapter 5*, *Reducing User Error with Validation and
    Automation*, how to turn our `Entry` into a `date` field.
  prefs: []
  type: TYPE_NORMAL
- en: The Spinbox widget
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like the Tkinter version, the Ttk `Spinbox` adds increment and decrement buttons
    to the standard `Entry` widget, making it suitable for numerical data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Ttk `Spinbox` is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17578_03_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.3: A Ttk Spinbox widget'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create one like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As this code shows, the Ttk `Spinbox` takes a number of arguments that control
    the behavior of its arrow buttons, listed in this table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Argument | Values | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `from_` | Float or Int | Minimum value the arrows will decrement to. |'
  prefs: []
  type: TYPE_TB
- en: '| `to` | Float or Int | Maximum value the arrows will increment to. |'
  prefs: []
  type: TYPE_TB
- en: '| `increment` | Float or Int | Value that will be added or subtracted by the
    arrows. |'
  prefs: []
  type: TYPE_TB
- en: '| `command` | Python function | Callback to be executed when either button
    is pushed. |'
  prefs: []
  type: TYPE_TB
- en: '| `textvariable` | Control variable (any type) | Variable bound to the field
    value. |'
  prefs: []
  type: TYPE_TB
- en: '| `values` | List of strings or numbers | Set of choices the buttons will scroll
    through. Overrides the `from_` and `to` values. |'
  prefs: []
  type: TYPE_TB
- en: Note that these arguments do *not* restrict what is entered into the `Spinbox`;
    they only impact the behavior of the arrows. Also, be aware that if you specify
    only one of `from_` or `to`, the other defaults to `0` automatically. This can
    lead to unexpected behavior; for example, if you set `from_=1` without specifying
    `to`, then `to` will default to `0` and your arrows will only toggle between `1`
    and `0`. To explicitly set no limit, you can use `from_='-infinity'` and `to='infinity'`.
  prefs: []
  type: TYPE_NORMAL
- en: The `Spinbox` widget is not merely for numbers, even though that's primarily
    how we'll be using it. As you can see, it can also take a `values` argument, which
    is a list of strings or numbers that can be scrolled through using the arrow buttons.
    Because of this, the `Spinbox` can be bound to any kind of control variable, not
    just `IntVar` or `DoubleVar` variables.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, none of these parameters actually limit what can be typed into a `Spinbox`
    widget. It's really nothing more than an `Entry` widget with buttons tacked on,
    and you can type not only numeric values outside the valid range but letters and
    symbols as well. Doing so can cause an exception if you've bound the widget to
    a non-string variable. In *Chapter 5*, *Reducing User Error with Validation and
    Automation*, we'll learn how to make the `Spinbox` widget limit entry to valid
    numeric characters only.
  prefs: []
  type: TYPE_NORMAL
- en: The Checkbutton widget
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Ttk `Checkbutton` widget is a labeled checkbox ideal for entering Boolean
    data. It can be created like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`Checkbutton` widgets can take a number of arguments in addition to those listed
    above, as shown in this table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Argument | Values | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `variable` | Control variable | The variable to which the checked/unchecked
    state of the box is bound |'
  prefs: []
  type: TYPE_TB
- en: '| `text` | String | The label text |'
  prefs: []
  type: TYPE_TB
- en: '| `textvariable` | `StringVar` | The variable to which the label text is bound
    |'
  prefs: []
  type: TYPE_TB
- en: '| `command` | Python function | A callback to execute whenever the box is checked
    or unchecked |'
  prefs: []
  type: TYPE_TB
- en: '| `onvalue` | Any | Value to set `variable` when the box is checked |'
  prefs: []
  type: TYPE_TB
- en: '| `offvalue` | Any | Value to set `variable` when the box is unchecked |'
  prefs: []
  type: TYPE_TB
- en: '| `underline` | Integer | Index of a character in `text` to underline |'
  prefs: []
  type: TYPE_TB
- en: The label included in the `Checkbutton` can be set directly using the `text`
    argument, or it can be bound to a control variable using `textvariable`. This
    allows for dynamic labeling of the widget, which can be useful in many situations.
  prefs: []
  type: TYPE_NORMAL
- en: Although the `Checkbutton` is ideal for Boolean data and defaults to setting
    its bound variable to `True` or `False`, we can override this behavior with the
    `onvalue` and `offvalue` arguments, allowing it to be usable with any type of
    control variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can use it with a `DoubleVar` like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The Ttk `Checkbutton` places the label to the right of the box, as shown in
    this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17578_03_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.4: A Ttk Checkbutton widget with its built-in label'
  prefs: []
  type: TYPE_NORMAL
- en: The Radiobutton widget
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Like its Tkinter counterpart, the Ttk `Radiobutton` widget is used for selection
    among a set of mutually exclusive options. A single `Radiobutton` by itself is
    not a terribly useful widget; instead, they are usually created as a group, as
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17578_03_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.5: A pair of Ttk Radiobutton widgets'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows how to create these buttons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: To group `Radiobutton` widgets, you simply need to assign them all the same
    control variable, then add a distinct `value` to each button. In our example,
    we've also grouped them on the same parent widget, but this is merely for visual
    reasons and not strictly necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'This table shows some of the various arguments you can use with a `Radiobutton`:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Argument | Values | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `variable` | Control variable | A variable to be bound to the button''s selected
    state |'
  prefs: []
  type: TYPE_TB
- en: '| `value` | Any | A value to set the variable to when the button is selected
    |'
  prefs: []
  type: TYPE_TB
- en: '| `command` | Python function | A callback to execute when the button is clicked
    |'
  prefs: []
  type: TYPE_TB
- en: '| `text` | String | The label connected to the radio button |'
  prefs: []
  type: TYPE_TB
- en: '| `textvariable` | `StringVar` | A variable bound to the button''s label text
    |'
  prefs: []
  type: TYPE_TB
- en: '| `underline` | Integer | Index of a character in `text` to underline |'
  prefs: []
  type: TYPE_TB
- en: The Combobox widget
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In *Chapter 1*, *Introduction to Tkinter*, we learned about a couple of options
    for providing a selection between distinct options: the `Listbox` and `OptionMenu`
    widgets. Ttk offers a new widget for this purpose, `Combobox`. The `Combobox`
    widget is an `Entry` widget that has a drop-down listbox added. It not only allows
    for mouse selection, but also keyboard entry. Although it may seem like `OptionMenu`
    is a better fit for our application in some ways, we''re going to exploit the
    `Combobox` widget''s keyboard functionality to build a superior drop-down widget.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create a `Combobox` widget like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Running that code will give us a combo box that looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17578_03_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.6: A Ttk Combobox widget'
  prefs: []
  type: TYPE_NORMAL
- en: Note that while we can specify a list of possible values to populate the drop-down
    listbox, the `Combobox` widget is not limited to those values. Users can type
    any text they wish into the box and the bound variable will be updated accordingly.
    By default, the `Combobox` is not suited to a list of values that must remain
    constrained to a set list; however, in *Chapter 5*, *Reducing User Error with
    Validation and Automation*, we'll learn how to address this.
  prefs: []
  type: TYPE_NORMAL
- en: 'This table shows some of the common arguments used with a `Combobox`:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Argument | Values | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `textvariable` | `StringVar` | Variable bound to the contents of the `Combobox`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `values` | List of strings | Values to populate the drop-down `listbox` |'
  prefs: []
  type: TYPE_TB
- en: '| `postcommand` | Python function | Callback to run just before the `listbox`
    is displayed |'
  prefs: []
  type: TYPE_TB
- en: '| `justify` | `left`, `right`, or `center` | Alignment of text in the box |'
  prefs: []
  type: TYPE_TB
- en: The Text widget
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Text` widget, which we have already met in *Chapter 1*, *Introduction to
    Tkinter*, is the only widget we'll use that *does not* have a Ttk version. While
    this widget is most often used for multi-line text entry, it actually offers much
    more than that. The `Text` widget can be used to display or edit text that contains
    images, multicolored text, hyperlink-style clickable text, and much more.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add one to an application as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The above code will produce something that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17578_03_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.7: A Tk Text widget'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Text` widget has a large number of arguments we can specify to control
    its appearance and behavior. Some of the more useful ones are listed in this table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Argument | Values | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `height` | Integer | Height of the widget in lines of text. |'
  prefs: []
  type: TYPE_TB
- en: '| `width` | Integer | Width of the widget in number of characters. For variable-width
    fonts, the width of a "0" character is used to calculate the width. |'
  prefs: []
  type: TYPE_TB
- en: '| `undo` | Boolean | Activates or deactivates the undo functionality. Undo
    and redo actions are activated using the platform''s default shortcuts. |'
  prefs: []
  type: TYPE_TB
- en: '| `maxundo` | Integer | Maximum number of edits that will be stored for undo.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `wrap` | `none`, `char`, or `word` | Specifies how a line of text will be
    broken and wrapped when it exceeds the width of the widget. |'
  prefs: []
  type: TYPE_TB
- en: '| `spacing1` | Integer | The number of pixels to pad above each complete line
    of text. |'
  prefs: []
  type: TYPE_TB
- en: '| `spacing2` | Integer | The number of pixels to pad between displayed lines
    of wrapped text. |'
  prefs: []
  type: TYPE_TB
- en: '| `spacing3` | Integer | The number of pixels to pad below each complete line
    of text. |'
  prefs: []
  type: TYPE_TB
- en: More advanced visual configuration of the `Text` widget is implemented using
    **tags**. We'll discuss tags in *Chapter 9*, *Improving the Look with Styles and
    Themes*.
  prefs: []
  type: TYPE_NORMAL
- en: Text widget indices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that a `Text` widget cannot be bound to a control variable; to access,
    set, or clear its contents, we need to use its `get()`, `insert()`, and `delete()`
    methods, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'When reading or modifying with these methods, you are required to pass in one
    or two **index values** to select the character or range of characters that you''re
    operating on. These index values are strings that can take any of the following
    formats:'
  prefs: []
  type: TYPE_NORMAL
- en: The line number and character number separated by a dot. Lines are numbered
    from 1 and characters from 0, so the first character on the first line is `1.0`,
    while the twelfth character on the fourth line would be `4.11`. Note that a *line*
    is determined by the presence of a newline character; a wrapped line of text is
    still only considered one line for index purposes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The string literal `end`, or the Tkinter constant `END`, indicating the end
    of the text.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A numerical index plus one of the words `linestart`, `lineend`, `wordstart`,
    or `wordend`, indicating the start or end of the line or word relative to the
    numerical index. For example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`6.2 wordstart` would be the start of the word containing the third character
    on line 6'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`2.0 lineend` would be the end of line 2'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Any of the preceding, a plus or minus operator, and a number of characters
    or lines. For example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`2.5 wordend - 1 chars` would be the character before the end of the word containing
    the sixth character on line 2'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following example shows these indices in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note in the last example that we deleted two characters in order to delete the
    last character. The `Text` widget automatically appends a newline to the end of
    its text content, so we always need to remember to account for that extra character
    when dealing with indices or the extracted text.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, these indices should be *strings*, not float values! Float values
    will sometimes work due to implicit type casting, but don't rely on that behavior.
  prefs: []
  type: TYPE_NORMAL
- en: The Button widget
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Ttk `Button` is a simple clickable pushbutton that can activate a callback
    function. It appears something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17578_03_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.8: A Ttk Button widget'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create one like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The button is a pretty straightforward widget, but it has a few options that
    can be used to configure it. These are shown in the table below:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Arguments | Values | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `text` | String | Label text on the button. |'
  prefs: []
  type: TYPE_TB
- en: '| `textvariable` | `StringVar` | Variable bound to the label text of the button.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `command` | Python function | Callback to be executed when the button is
    clicked. |'
  prefs: []
  type: TYPE_TB
- en: '| `default` | `normal`, `active`, `disabled` | If the button executes when
    `Enter` is pushed. `active` means it will execute in response to `Enter`, `normal`
    means it will only if selected first, and `disabled` means it will not respond
    to `Enter`. |'
  prefs: []
  type: TYPE_TB
- en: '| `underline` | Integer | Index of a character in `text` to underline. |'
  prefs: []
  type: TYPE_TB
- en: Buttons can also be configured to display images rather than text. We'll learn
    more about that in *Chapter 9*, *Improving the Look with Styles and Themes*.
  prefs: []
  type: TYPE_NORMAL
- en: The LabelFrame widget
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *Chapter 1*, *Introduction to Tkinter*, we used the `Frame` widget to group
    together our widgets. Ttk offers us a more powerful option in the `LabelFrame`,
    which provides a frame with a border and a label. This is a very useful widget
    to provide visual grouping for widgets in our GUI.
  prefs: []
  type: TYPE_NORMAL
- en: 'This code shows an example of a `LabelFrame`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting GUI would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17578_03_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.9: A Ttk LabelFrame widget'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `LabelFrame` widget offers us a few arguments for configuration, shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Argument | Values | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `text` | String | The text of the label to display. |'
  prefs: []
  type: TYPE_TB
- en: '| `labelanchor` | Cardinal direction | Where to anchor the text label. |'
  prefs: []
  type: TYPE_TB
- en: '| `labelwidget` | `ttk.Label` object | A label widget to use for the label.
    Overrides `text`. |'
  prefs: []
  type: TYPE_TB
- en: '| `underline` | Integer | The index of a character in `text` to underline.
    |'
  prefs: []
  type: TYPE_TB
- en: As you can see, we can configure the label of the `LabelFrame` either by specifying
    the `text` argument, or by creating a `Label` widget and assigning it using the
    `labelwidget` argument. The latter case may be preferable if we want to take advantage
    of some of the `Label` widget's advanced features, such as binding a `textvariable`
    to it. If we use it, it will override the `text` argument.
  prefs: []
  type: TYPE_NORMAL
- en: Tkinter and Ttk contain many more widgets, some of which we'll encounter later
    in this book. Python also ships with a widget library called `tix`, which contains
    several dozen widgets. However, `tix` is very outdated, and we won't be covering
    it in this book. You should know that it exists, though.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we''ve learned some Tkinter basics, researched the user''s needs, designed
    our application, and determined which Ttk widgets will be useful in our application.
    Now it''s time to put all of this together and actually code the first version
    of the ABQ Data Entry application. Recall our design from *Chapter 2*, *Designing
    GUI Applications*, shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17578_03_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.10: The ABQ Data Entry application layout'
  prefs: []
  type: TYPE_NORMAL
- en: Take a moment to review the widgets we need to create, and we'll begin coding.
  prefs: []
  type: TYPE_NORMAL
- en: First steps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open a new file in your editor called `data_entry_app.py`, and let''s begin
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Our script starts with a **docstring**, as all Python scripts should. This string
    at a minimum should give the name of the application to which the file belongs,
    and may also include notes about usage, authorship, or other items a future maintainer
    would need to know.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''re importing the Python modules that we''ll need for this application;
    these are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`tkinter` and `ttk`, of course, for our GUI items'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `datetime` class, from the `datetime` module, which we'll use to generate
    a datestring for the filename
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Path` class, from the `pathlib` module, which is used for some file operations
    in our save routine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `csv` module, which we'll use to interact with the CSV file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, let''s create some global variables that the app will use to keep track
    of information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `variables` dictionary will hold all of the form's control variables. Keeping
    them in a dictionary will make it a little easier to manage them and will keep
    our global namespace lean and clean. The `records_saved` variable will store how
    many records the user has saved since opening the app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now it''s time to create and configure the root window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We've set the window title for the application and also configured its layout
    grid so that the first column is allowed to expand. The root window will only
    have one column, but by setting this it will allow the form to remain centered
    on the application if the window is expanded. Without it, the form would be stuck
    to the left side of the window when the window is expanded.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we''ll add a heading for the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Because we won't need to refer to this widget again, we won't bother assigning
    it to a variable. This also allows us to call `grid()` on the `Label` on the same
    line, keeping our code more concise and the namespace less cluttered. We'll do
    this for most of the widgets in the application, unless there is some reason we
    may need to interact with the widget elsewhere in the code.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we used `TkDefaultFont` as the font family value for this label widget.
    This is an alias defined in Tkinter that points to the default window font on
    your platform. We'll learn more about fonts in *Chapter 9*, *Improving the Look
    with Styles and Themes*.
  prefs: []
  type: TYPE_NORMAL
- en: Building the data record form
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the initial application window set up, let''s start building the actual
    data entry form. We''ll create a frame to contain the entire data record form,
    called `drf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `drf` frame is added to the main window with a bit of horizontal padding,
    and the `sticky` argument ensures that it will stretch when the containing column
    is stretched. We're also going to configure its grid to expand the first column.
  prefs: []
  type: TYPE_NORMAL
- en: For windows or frames using a grid layout, if you want to make the child widgets
    stretch when the parent is stretched, you need to make sure both the container
    will expand (using `columnconfigure` and `rowconfigure` on the parent) *and* the
    child widget will expand with the container (using `sticky` when you call `grid()`
    on the child widget).
  prefs: []
  type: TYPE_NORMAL
- en: The Record Information section
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first section of our form is the `Record Information` section. Let''s create
    and configure a `LabelFrame` to store that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We start by creating a Ttk `LabelFrame` widget with the data record form as
    its parent. We add it to the parent's grid, setting the `sticky` argument so that
    it will expand when the window is resized. Each frame of this form is going to
    have three columns of input widgets, and we want each column to expand evenly
    to fill the width of the frame. So, we have used a `for` loop to set the `weight`
    attribute of each column to `1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can begin creating the contents of the frame, starting with the first
    input widget, the `Date` field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: First, we created a control variable and put it in the `variables` dictionary.
    Then we created our `Label` widget for the `Date` field and added it to the `LabelFrame`
    widget's grid. We're going to use explicit `row` and `column` values here, even
    when it's not strictly necessary, because we're going to be placing objects a
    little out of order. Without explicit coordinates, things could get confusing.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we create the `Entry` widget, passing in the control variable. Note
    that we aren't going to save any references to our widgets if we can use a variable
    to store the value. This will keep the code more concise. We've added our widget
    to the grid, placing it *below* its label by specifying the first column of the
    next row. For both the `Entry` and the `Label`, we've used the `sticky` argument
    to make sure the widget stretches when the GUI is expanded.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s add the rest of the first line, the `Time` and `Technician` fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Once again, we create a variable, `Label`, and input widget for each item. Recall
    that the `Combobox` widget takes a list of strings for its `values` argument,
    which will populate the drop-down part of the widget. That takes care of the first
    row.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the second row, we''ll start with the `Lab` inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Like before, we've created the control variable and `Label`, but for the input
    widget we've created a `Frame` to hold the three `Radiobutton` widgets. We're
    also creating our `Radiobutton` widgets using a `for` loop to keep the code more
    concise and consistent.
  prefs: []
  type: TYPE_NORMAL
- en: The `pack()` geometry manager comes in handy here because we can populate from
    left to right without having to explicitly manage column numbers. The `expand`
    argument causes the widget to use extra space when the window is resized; this
    will help our buttons to utilize available space and not be scrunched into the
    left side of the window.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s do the remaining portion of line two, the `Plot` and `Seed Sample`
    fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We have the same thing going on here: create a variable, create a `Label`,
    create the input widget. Note that for the `Plot` values we''re generating a list
    using `range()` to keep our code concise.'
  prefs: []
  type: TYPE_NORMAL
- en: The Environment Data section
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The next part of the form is the `Environment Data` frame. Let''s begin that
    section as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This is exactly what we did for the last `LabelFrame`, with only the names
    updated. Let''s start populating it with the `Humidity`, `Light`, and `Temperature`
    widgets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Good! Now, for the second row of this section, we only need to add in the `Equipment
    Fault` check button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The first three values are all floating-point numbers, so we''re using `DoubleVar`
    control variables and `Spinbox` widgets for entry. Don''t forget to populate the
    `from_`, `to`, and `increment` values for the `Spinbox` widgets, so that the arrows
    behave properly. Our `Checkbutton` takes a `BooleanVar` control variable and doesn''t
    need a `Label` widget due to its built-in label. Also, note that because we''ve
    started a new frame, our rows and columns for the grid start over. This is a benefit
    of breaking up the form into smaller frames: we don''t have to keep track of ever-increasing
    row or column numbers.'
  prefs: []
  type: TYPE_NORMAL
- en: The Plant Data section
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We''ll create the next frame, `Plant Data`, just like the other two:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, having created and configured the frame, let''s add in the first row of
    inputs, `Plants`, `Blossoms`, and `Fruit`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: There is nothing really new here, except that, since we're using `IntVar` control
    variables, we've set the `Spinbox` increment to `1`. That won't really stop anyone
    from entering a decimal (or any arbitrary string for that matter), but at least
    the buttons won't steer the user wrong. In *Chapter 5*, *Reducing User Error with
    Validation and Automation*, we'll see how to enforce `increment` more thoroughly.
  prefs: []
  type: TYPE_NORMAL
- en: 'And now finally our last row of inputs, `Min Height`, `Max Height`, and `Med
    Height`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We've made three more `DoubleVar` objects, three more labels, and three more
    `Spinbox` widgets. If this feels a little repetitive, don't be surprised; GUI
    code can tend to be quite repetitive. In *Chapter 4*, *Organizing Our Code with
    Classes*, we'll find ways to reduce this repetitiveness.
  prefs: []
  type: TYPE_NORMAL
- en: Finishing the GUI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'That finishes our three info sections; now we need to add the `Notes` input.
    We''ll add it directly to the `drf` frame with a label, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Since we cannot associate a control variable with the `Text` widget, we'll need
    to keep a regular variable reference to it.
  prefs: []
  type: TYPE_NORMAL
- en: When you do need to save a reference to a widget, don't forget to call `grid()`
    in a separate statement! Since `grid()` (and other geometry manager methods) returns
    `None`, if you create and position the widget in one statement your saved widget
    reference will just be `None`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re almost finished with the form! We just need to add some buttons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: To keep the form's grid layout simpler, we've packed the two buttons into a
    sub-frame, using `pack()` with the `side` argument to keep them over on the right.
  prefs: []
  type: TYPE_NORMAL
- en: 'That finishes the data record form; to finish out the application GUI, we only
    need to add in a status bar with an associated variable, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The status bar is simply a `Label` widget, which we've placed on the `root`
    window's grid at row `99` to ensure that it stays at the bottom in case of any
    future additions to the application. Note that we have not added the status variable
    to the `variables` dictionary; that dictionary is reserved for variables that
    will hold user input. This variable is just going to be used to display messages
    to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the callback functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that our layout is done, let''s work on creating the functionality of our
    application. Our form has two buttons that need callback functions: `Reset` and
    `Save`.'
  prefs: []
  type: TYPE_NORMAL
- en: The Reset function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The job of our reset function is to return the entire form to a blank state
    so the user can enter in more data. We'll need this function not only as a callback
    to the `Reset` button, but also to prepare the form for the next record after
    the user saves a record. Otherwise, the user would have to manually delete and
    overwrite the data in each field for every new record.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we''ll need to call the reset callback from the save callback, we need
    to write the reset function first. At the end of `data_entry_app.py`, start a
    new function like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The function is called `on_reset()`. Recall from *Chapter 1*, *Introduction
    to Tkinter*, that, by convention, callback functions are typically named `on_<eventname>`,
    where `eventname` refers to the event that triggers it. Since this will be triggered
    by clicking the `Reset` button, we'll call it `on_reset()`.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the function, we need to reset all the widgets to an empty value. But
    wait! We didn't save references to any of the widgets, apart from the `Notes`
    input. What do we need to do?
  prefs: []
  type: TYPE_NORMAL
- en: 'Simple: we reset all the *variables* to a blank string, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '`StringVar`, `DoubleVar`, and `IntVar` objects can be set to a blank string,
    which will cause any widgets bound to them to be blank. `BooleanVar` variables
    will raise an exception if we try to do that, so instead we''ll check if our variable
    is a `BooleanVar` using Python''s built-in `isinstance()` function. If it is,
    we simply set it to `False`.'
  prefs: []
  type: TYPE_NORMAL
- en: For the `Notes` input, we can use the `Text` widget's `delete()` method to clear
    its contents. This method takes a start and end location, just like the `get()`
    method does. The values `1.0` and `tk.END` indicate the entire contents of the
    widget. Recall from our earlier discussion of the `Text` widget that this index
    is the *string* `1.0`, *not* a float value.
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s all we need in our reset callback. To bind it to the button, use the
    button''s `configure()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `configure()` method can be called on any Tkinter widget to change its properties.
    It accepts the same keyword arguments as the widget's constructor.
  prefs: []
  type: TYPE_NORMAL
- en: The Save callback
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our last bit of functionality, and the most important, is the `Save` callback.
    Recall from our program specification that our application needs to append the
    entered data to a **CSV** (**comma-separated values**) file with the filename
    `abq_data_record_CURRENTDATE.csv`, where `CURRENTDATE` is the date in ISO format
    (year-month-day). The CSV should be created if it doesn''t exist, and have the
    column headers written to the first row. Therefore, this function needs to do
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Determine the current date and generate the filename
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Determine if the file exists, and if not create it and write a header row
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extract the data from the form and do any clean-up necessary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Append the row of data to the file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increment `records_saved` and alert the user that the record was saved
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reset the form for the next record
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s start the function out this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Once again, we're using the `on_<eventname>` naming convention. The first thing
    we've done is declared `records_saved` as a global variable. If we don't do this,
    Python will interpret the name `records_saved` as a local variable and we won't
    be able to update it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modifying global variables is generally bad form, but Tkinter doesn''t really
    give us many options here: we can''t use a return value to update the variable,
    because this is a callback function that is called in response to an event, not
    at any place in our code where we have direct access to `records_saved`. In *Chapter
    4*, *Organizing Our Code with Classes*, we''ll learn a better way to implement
    this functionality without global variables; for now, though, we''re stuck with
    it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s figure out the details of the filename and whether it exists or
    not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The `datetime.today()` function returns a `Date` object for the current day,
    and its `strftime()` method allows us to format that date into a string in any
    way we specify. The syntax for `strftime()` has its roots in C programming, so
    it's rather cryptic in some cases; but hopefully it is clear that `%Y` means year,
    `%m` means month, and `%d` means day. This will return the date in ISO format;
    for example, 2021-10-31 for October 31, 2021.
  prefs: []
  type: TYPE_NORMAL
- en: With the `datestring` in hand, we can use it to build the filename for the day's
    CSV file. In the next line, `Path(filename).exists()` tells us whether the file
    exists in the current working directory. It does this by constructing a `Path`
    object using the filename, then calling its `exists()` method to see if the file
    is already on the filesystem. We'll save this information to a variable called
    `newfile`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now it''s time to get the data from the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We're going to store the data in a new dictionary object called `data`. To do
    this, we'll iterate through our `variables` dictionary, calling `get()` on each
    variable. Of course, if there is an equipment fault, we want to skip the values
    for `Light`, `Humidity`, and `Temperature`, so we're first getting the value of
    `Equipment Fault` and checking it before those field values are being retrieved.
    If we do need to retrieve a value from the variable, we'll do this in a `try`
    block. Remember that variables will raise a `TclError` if the `get()` method is
    called when there is an invalid value in them, so we need to handle that exception.
    In this case, we'll let the user know that there was a problem with that particular
    field and exit the function immediately.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to get the data from the `Notes` field using `get()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the data, we need to write it to a CSV. Add the following
    code next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: First, we're opening the file using a context manager (the `with` keyword).
    Doing it this way ensures that the file will be closed when we exit the indented
    block. We're opening in *append* mode (indicated by the `a` argument to `open`),
    which means any data we write will simply be added to the end of whatever is already
    there. Note the `newline` argument, which we've set to an empty string. This is
    to work around a bug in the CSV module on Windows that causes an extra empty line
    to appear between each record. It does no harm on other platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the block, we need to create something called a **CSV Writer object**.
    The standard library `csv` module contains a few different types of objects that
    can write data into a CSV file. The `DictWriter` class is handy in that it can
    take a dictionary of values in any order and write them to the proper fields of
    the CSV, provided the first row contains the names of the columns. We can tell
    the `DictWriter` what those header values should be by passing it `data.keys()`,
    which is all the names of our data values.
  prefs: []
  type: TYPE_NORMAL
- en: Append mode will create the file if it does not exist, but it won't write the
    header row automatically. Therefore, we need to check if the file is a new file
    (using the `newfile` value we found earlier), and if it is, we'll write the header
    row. The `DictWriter` object has a method for this, which causes it to just write
    a single row containing all the field names.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we can use the `DictWriter` object's `writerow()` method to pass in
    our dictionary of data to be written to the file. As we exit the indented block,
    Python closes the file and saves it to disk.
  prefs: []
  type: TYPE_NORMAL
- en: 'That leaves us with just a few final lines in the `on_save()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: First, we'll increment the `records_saved` variable, then alert the user in
    the status bar how many records have been saved so far. This is good feedback
    that helps the user know their actions were successful. Finally, we call `on_reset()`
    to prepare the form for the next record to be entered.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the save method implemented, let''s go ahead and bind it to our button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Last of all, let''s reset the form and launch the main event loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: That's it, your first application for ABQ is finished and ready to go!
  prefs: []
  type: TYPE_NORMAL
- en: Finishing up and testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we send our application out into the world, let''s fire it up and give
    it a test:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17578_03_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.11: Our first ABQ Data Entry application'
  prefs: []
  type: TYPE_NORMAL
- en: Looking good! And it works, too. Go ahead and enter some test data and save
    it. Of course, this isn't the end – we haven't quite addressed everything on the
    program specification, and once users get their hands on the application, the
    feature requests will undoubtedly begin. But for now, we can celebrate the victory
    of a working MVP.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Well, we've come a long way in this chapter! You took your design from a specification
    and some drawings to a running MVP of the application that already covers the
    basic functionality you need. You learned about basic Ttk widgets, such as `Entry`,
    `Spinbox`, `Combobox`, `Radiobutton`, and `Checkbutton`, as well as the Tkinter
    `Text` widget. You learned how to assemble these widgets into a complex but organized
    GUI using nested `LabelFrame` widgets, and how to save a file using a callback
    method.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we're going to utilize classes and object-oriented programming
    techniques to clean up our code and expand the capabilities of our widgets.
  prefs: []
  type: TYPE_NORMAL
