- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Integrating the React Frontend with the Flask Backend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter represents a critical point in our quest to build a full stack
    web application. In this chapter, you will be introduced to a set of instructions
    on how to connect a Flask web server to a React frontend. You will learn how to
    pass form entries from the React frontend to the Flask backend. And after this
    integration, you can be officially called a **full stack** **web developer**.
  prefs: []
  type: TYPE_NORMAL
- en: React web applications usually have a sleek look and feel and are regarded as
    the Rolls-Royce of modern frontend web application applications. React has an
    intuitive user-interface-focused library, capable of powering production-grade
    web and mobile applications with ease.
  prefs: []
  type: TYPE_NORMAL
- en: The robust React ecosystem coupled with React’s tools and libraries facilitates
    end-to-end web development. When you combine React’s incredible component-based
    design pattern with a minimalist lightweight Flask framework, you get a rich web
    application that can withstand the test of time and scale at large.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will help you understand the dynamics of integrating React, a frontend
    library, and Flask, a backend framework, in developing valuable software products.
    You will also learn how React handles forms with the Flask backend in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Ever since the advent of the web, there has been a need for more dynamic and
    responsive forms in web applications. We will explore server-side handling of
    form elements, validation, and security concerns.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The *Bizza* application structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring the React frontend
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making the Flask backend ready
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling forms in React and Flask
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Troubleshooting tips for the React frontend and the Flask backend
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The complete code for this chapter is available on GitHub at: [https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter10](https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter10).'
  prefs: []
  type: TYPE_NORMAL
- en: The Bizza application structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will go deeper into the structure of the application we
    will build in this book. As stated previously, we will name the fictitious web
    app *Bizza*, a conference event web application.
  prefs: []
  type: TYPE_NORMAL
- en: This *Bizza* web app will serve as the digital hub for a conference event for
    speakers from the information technology industry, providing a myriad of features
    and functionalities that enhance the speakers’ and attendees’ overall experience.
    Let’s delve into the *Bizza* application structure.
  prefs: []
  type: TYPE_NORMAL
- en: Application overview
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Bizza* is a fictitious data-driven event application that allows subject experts
    in the information technology industry to share their insights and experiences,
    providing valuable knowledge to enhance event attendees’ skills.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Bizza* lets you see a list of speakers and workshop schedules with details.
    This site lets users register and browse for a workshop. Essentially, the application
    will have the following functionalities:'
  prefs: []
  type: TYPE_NORMAL
- en: A home page that displays event speakers and available event schedules with
    locations and subjects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A registration form for event attendees
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A registration form for speakers with a subject of interest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A page for users to log in to the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A page containing the names and details of speakers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we will delve into the *Bizza* app and break it down into its frontend
    and backend components. By doing so, we will gain a comprehensive understanding
    of the distinct roles and functionalities that each component serves within the
    app.
  prefs: []
  type: TYPE_NORMAL
- en: Breaking down the code structure into frontend and backend
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the world of software development, frontend and backend are like the yin
    and yang – opposites but complementing each other to provide a harmonious digital
    experience. *Yin and yang* is a Chinese philosophical concept that describes opposite
    but interconnected forces.
  prefs: []
  type: TYPE_NORMAL
- en: In a nutshell, breaking down an application into its frontend and backend components
    provides a clear separation of concerns, promotes code reusability and portability,
    enables scalability and performance optimization, and fosters collaboration and
    parallel development. This approach ultimately contributes to the overall success
    of the web application development process.
  prefs: []
  type: TYPE_NORMAL
- en: The practice of separating frontend and backend components in software development
    started to gain prominence in the late 1990s and early 2000s, with the rise of
    web-based applications. During this time, web technologies were evolving in the
    blink of an eye, and the need for scalable and modular applications became apparent.
  prefs: []
  type: TYPE_NORMAL
- en: The introduction of JavaScript frameworks such as jQuery in the early 2000s
    enabled more dynamic and interactive user interfaces in the frontend. This led
    to a clearer distinction between the presentation layer (frontend) and the data
    processing layer (backend) of web applications.
  prefs: []
  type: TYPE_NORMAL
- en: With the emergence of **single-page applications** (**SPAs**) and the proliferation
    of JavaScript frameworks and libraries such as AngularJS, React, and Vue.js, the
    separation between the frontend and the backend became more standardized and widely
    adopted. SPAs shifted the responsibility of rendering and managing the UI to the
    client side, while the backend APIs handled data retrieval and manipulation.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have discussed the key reasons for breaking down the code structure,
    let’s examine the frontend and backend components of the *Bizza* web application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code structure represents the high-end level code split between
    the frontend and the backend. This allows us to separate concerns and improve
    code reusability:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Frontend structure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, let’s provide an overview of the detailed `frontend` structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The preceding frontend code structure comprises majorly of `node_modules`, `package.json`,
    `public`, `src`, `.gitignore`, `.prettierrc`, `package-lock.json`, and `README.md`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s quickly break down the major directories and files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`node_modules`: This directory contains all the packages (libraries and frameworks)
    that your application depends on. These packages are listed in the `dependencies`
    and `devDependencies` sections of the `package.json` file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`package.json`: This file contains metadata about your application, including
    its name, version, and dependencies. It also includes scripts you can use to build,
    test, and run your application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public`: This directory contains static assets that your application will
    use, such as the favicon and the main HTML file (`index.html`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`src`: This directory contains the source code for your application. It is
    organized into subdirectories for components, pages, hooks, and assets. The `src`
    directories are critical to the design pattern adopted for the React frontend.
    The `components` folders contain all the components we intend to use in the *Bizza*
    app, `pages` contains the presentational component of the app, `hook` contains
    custom hooks, and finally, the `assets` folder contains all the assets, such as
    `images`, `logos`, and `svg`, that are used in the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.gitignore`: This file tells Git which files and directories to ignore when
    you commit your code to a repository.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.prettierrc`: This file specifies the configuration options for the Prettier
    code formatter. Prettier is a popular code formatting tool that enforces a consistent
    style across your code base. It is typically placed in the `root` directory of
    a JavaScript project and contains JSON syntax to define the formatting rules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`package-lock.json`: This file records the exact versions of all the packages
    that your application depends on, as well as any packages those packages depend
    on. It ensures that your application uses the same versions of its dependencies
    every time it is installed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`README.md`: This file contains documentation for your application, such as
    instructions to install and run it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Backend structure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, we will examine how the backend will be structured:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The preceding represents the files and directories structure for the Flask backend
    application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s break down the directories and files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`app.py`: This file contains the main code for your backend application, including
    routes and logic to handle HTTP requests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`models`: This directory contains modules of each of the model definitions
    for database models.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`config`: This directory contains a configuration options file for the application,
    such as database connection strings or secret keys.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.flaskenv`: This file contains environment variables that are specific to
    the Flask application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`requirements.txt`: This file lists the packages that the application depends
    on, including any third-party libraries. You can use this file to install the
    necessary dependencies by running `pip install -``r requirements.txt`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we will see how to configure the React frontend and prepare it to consume
    the backend API services.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the React frontend for API consumption
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will configure the frontend React app to communicate with
    the backend Flask server by setting up a proxy in React to consume the API from
    the Flask server.
  prefs: []
  type: TYPE_NORMAL
- en: In order to configure the React proxy for API consumption, you will need to
    update the `proxy` field in the `package.json` file of the frontend React app.
    The `proxy` field allows you to specify a URL that will be used as the base for
    all API requests made from the React app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s update the `package.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `package.json` file in the `project` directory using a text editor,
    and then add a `proxy` field to the `package.json` file and set it to the URL
    of your Flask server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, you will need to make HTTP requests to the Flask server from the React
    frontend. We will use the `Fetch()` method is an alternative to Axios.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Axios is a JavaScript library that allows you to make HTTP requests from the
    browser. It is a promise-based library that uses modern techniques to make it
    easy to work with asynchronous requests. With Axios, you can make HTTP requests
    to retrieve data from a server, submit form data, or send data to a server.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Axios supports a number of different request methods, such as `GET`, `POST`,
    `PUT`, `DELETE`, and `PATCH`, and it can handle both JSON and XML data formats.
    Axios is popular among developers because it has a simple and straightforward
    API, making it easy to use for both beginners and experienced developers.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Axios also has a number of features that make it flexible and powerful, such
    as the automatic transformation of data, support for interceptors (which allow
    you to modify requests or responses before they are sent or received), and the
    ability to cancel requests.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can install Axios by running the following command in your terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once Axios is installed, you can use it to make HTTP requests to the Flask server
    from the React frontend.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Make sure that both the frontend React app and the backend Flask server run
    on separate ports. By default, the React development server runs on port `3000`,
    while the Flask development server runs on port `5000`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, you will need to define routes and functions in the Flask backend to handle
    HTTP requests coming from the React frontend.
  prefs: []
  type: TYPE_NORMAL
- en: Making Flask backend-ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the *Setting up the development environment with Flask* section of [*Chapter
    1*](B18554_01.xhtml#_idTextAnchor014), *Getting Full Stack Ready with React and
    Flask*, we set up the development environment for the Flask server. Ensure your
    virtual environment is activated. You can do so by running the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '**For Mac/Linux**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**For Windows**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Your virtual environment should now be activated, and your terminal prompt should
    be prefixed with the name of the virtual environment (for example, `(``venv) $`).
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s dive straight into defining an event registration route, with its
    function as part of the requirements for Bizza application model.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s add a model to handle registrations for event attendees. You will later
    use it to accept requests from the React frontend in the next section, where we
    will handle form inputs in React and Flask.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `app.py` file in the root directory of your application is still the main
    entry point for the Flask application. Update `app.py` with the following code
    snippet to define the model and endpoint to handle the event registration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, the `EventRegistration` class represents a model for
    event registration in a database.
  prefs: []
  type: TYPE_NORMAL
- en: The `__tablename__` attribute specifies the name of the table in the database
    that this model is stored in. The `db.Model` class is a base class for all models
    in `Flask-SQLAlchemy`, and the `db.Column` objects define the fields of the model,
    each with a type and some additional options.
  prefs: []
  type: TYPE_NORMAL
- en: The `format` method returns a dictionary representation of the model instance,
    with keys corresponding to the field names and values corresponding to the field
    values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s define the route or endpoint, `/api/v1/events-registration`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `/api/v1/events-registration` endpoint function handles an HTTP `POST` request
    to the `/api/v1/events-registration` route. This endpoint allows users to register
    for events by providing their name, email address, phone number, and subject.
  prefs: []
  type: TYPE_NORMAL
- en: The endpoint function first checks that the request method is indeed `POST`,
    and then extracts the name, email, phone, and subject values from the request
    body, which is expected to be in JSON format.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the function checks that all of the required input values (`first_name`,
    `last_name,` `email`, `phone`, and `subject`) are present. If they are, it checks
    whether there is already an attendee with the same email address in the database.
    If there is, it returns a JSON response, with a message indicating that the email
    address is already in use, and an HTTP `409` status code (conflict).
  prefs: []
  type: TYPE_NORMAL
- en: If the email address is not in use, the function creates a new `EventRegistration`
    object with the input values, adds it to the database session, and commits the
    changes to the database. It then returns a JSON response with a success message
    and the details of the new attendee, along with an HTTP `201` status code (created).
  prefs: []
  type: TYPE_NORMAL
- en: If any of the required input values is missing, the function returns a JSON
    response with an error message and an HTTP `400` status code (bad request). Now,
    let’s update the database and add an `eventregistration` table to it. The `eventregistration`
    table will accept all the entries for the event registrations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps create the `eventregistration` table in the database. In
    the terminal of the `project` directory, enter the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can continue to use migration tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: With any of these options, the backend will contain the new table.
  prefs: []
  type: TYPE_NORMAL
- en: Execute `flask run` in the terminal to start the Flask development server on
    `localhost` using the default port (`5000`).
  prefs: []
  type: TYPE_NORMAL
- en: That’s it! The backend is now ready to receive form entries from the React frontend.
    Let’s design the form component in React and submit the form entries to the Flask
    backend.
  prefs: []
  type: TYPE_NORMAL
- en: Handling forms in React and Flask
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Handling forms in a React frontend and a Flask backend is a common pattern in
    web development. In this pattern, the React frontend sends HTTP requests to the
    Flask backend to submit or retrieve form data.
  prefs: []
  type: TYPE_NORMAL
- en: On the React frontend side, you can use a form component to render a form and
    handle form submissions. You can use controlled components, such as `input`, `textarea`,
    and `select`, to control the form values and update the component state as a user
    inputs data.
  prefs: []
  type: TYPE_NORMAL
- en: When the user submits the form, you can use an event handler to prevent the
    default form submission behavior and send an HTTP request to the Flask backend
    using a library such as Axios. In this section, we will work with the Axios library.
  prefs: []
  type: TYPE_NORMAL
- en: On the Flask backend side, you can define a route to handle the HTTP request
    and retrieve the form data from the request object. You can then process the form
    data and return a response to the frontend.
  prefs: []
  type: TYPE_NORMAL
- en: The `EventRegistration` component provides a simple form for non-authenticated
    users to register for an event in the frontend of the *Bizza* app. The form includes
    fields for the user’s name, email address, phone number, and subject – the topic
    or title of the event they register for.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s dive into the React form implementation that will work with the Flask
    backend:'
  prefs: []
  type: TYPE_NORMAL
- en: In the project directory and inside the `components` folder, create `EventRegistration/EventRegistration.jsx`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code snippet to the `EventRegistration.jsx` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `EventRegistration` component also includes a `validate` function that checks
    the form values for errors, and an `onChangeHandler` function that updates the
    form values as the user types.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s discuss the component state variables used in the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`formValues`: This is an object that stores the current values of the form
    fields (name, email, phone, and subject)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`formErrors`: This is an object that stores any errors found in the form values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`response`: This is an object that stores the response from the server after
    the form is submitted'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`feedback`: This is a string that stores a feedback message to display to the
    user (for example, **Registration successful!**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`status`: This is a string that stores the status of the form submission (for
    example, **success** or **error**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We then define the following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`validate`: This is a function that accepts the form values and returns an
    object with any errors found in the values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onChangeHandler`: This is a function that updates the `formValues` state variable
    as the `user` types in the form fields.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`handleSubmit`: This is a function that is called when the form is submitted.
    It prevents the default form submission behavior, calls the `validate` function
    to check for errors, and then sends the form data to the server using the `sendEventData`
    function. It also updates the feedback and status state variables based on the
    response from the server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sendEventData`: This is an `async` function that sends an HTTP `POST` request
    to the `/api/v1/events-registration` route with the form data and updates the
    response state variable with the response from the server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `EventRegistration` component also has a `useEffect` hook that calls the
    `sendEventData` function when the `formValues` state variable changes. Finally,
    the `EventRegistration` component renders a form element with the form fields
    and displays the feedback message and status to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Now, start the React frontend with `npm start` and submit your form entries.
    Make sure the Flask server is running as well. With any development process, issues
    and bugs are bound to arise. We will explore some valuable troubleshooting tips
    to help you debug and fix issues during the integration of the React frontend
    and the Flask backend.
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting tips for the React frontend and the Flask backend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Integrating a React frontend with a Flask backend can be a powerful combination
    to build dynamic and scalable web applications. However, like any integration,
    it can come with its own set of unavoidable challenges. Troubleshooting issues
    that arise during the React-Flask integration process requires a systematic approach
    to identify and resolve problems effectively.
  prefs: []
  type: TYPE_NORMAL
- en: This section will discuss how you can resolve some of the issues that you may
    encounter while integrating the frontend with the backend. By following these
    tips, you will be able to diagnose and resolve common problems that may arise
    during the development and deployment of your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s dive into the troubleshooting tips for the React frontend and the Flask
    backend integration:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Verifying the** **Flask setup**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure that Flask is properly configured and running on the server
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Check the Flask server console for any error messages or exceptions that may
    indicate misconfigurations
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Confirm that the necessary Flask packages and dependencies are installed
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Verify that the Flask server is accessible and responding to requests by testing
    basic endpoints
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Checking the** **React configuration**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure that the React application is correctly configured and running
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Confirm that the necessary dependencies and packages are installed in the React
    project
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Inspect the console logs in the browser’s developer tools for any JavaScript
    errors or warnings that may indicate issues with the frontend setup
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure that the proxy attribute is added to `package.json` and points to the
    Flask server address – for example, `http://127.0.0.1:5000`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Investigate** **network requests**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the browser's developer tools to inspect network requests made by the React
    application
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Verify that the requests are sent to the correct Flask endpoints
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Check the network response status codes to identify any server-side errors
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Inspect the response payloads to ensure that data is transmitted correctly
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Pay attention to **Cross-Origin Resource Sharing** (**CORS**) issues if the
    React frontend and the Flask backend are hosted on different domains or ports
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: By following these troubleshooting tips, you will be equipped with the necessary
    knowledge to efficiently diagnose and resolve issues in the React-Flask integration.
    This will ensure a smooth and robust integration for your web application.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed extensively the application code structure and
    a few key steps required to integrate a React frontend with a Flask backend. First,
    you will need to set up the frontend to communicate with the backend, using an
    HTTP client library, and handle forms and user input.
  prefs: []
  type: TYPE_NORMAL
- en: Then, you will need to set up the Flask backend with the necessary routes and
    functions to handle the requests from the frontend and process the form data.
    Finally, you will need to test the entire application to ensure that it works
    correctly and as expected.
  prefs: []
  type: TYPE_NORMAL
- en: With these steps, you can successfully integrate a React frontend with a Flask
    backend for your web application. In the next chapter, we will scale up the React-Flask
    interactions by creating more tables. These tables will have relationships, and
    we will be able to fetch and display data.
  prefs: []
  type: TYPE_NORMAL
