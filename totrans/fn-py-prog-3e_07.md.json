["```py\n>>> some_leg = (\n... (37.549016, -76.330295),\n... (37.840832, -76.273834),\n... 17.7246\n... )\n\n```", "```py\n>>> start = lambda leg: leg[0] \n>>> end = lambda leg: leg[1] \n>>> distance = lambda leg: leg[2] \n\n>>> latitude = lambda pt: pt[0] \n>>> longitude = lambda pt: pt[1]\n```", "```py\n>>> latitude(start(some_leg))\n37.549016\n\n```", "```py\nfrom collections.abc import Callable \nfrom typing import TypeAlias \n\nPoint: TypeAlias = tuple[float, float] \nLeg: TypeAlias = tuple[Point, Point, float] \n\nstart: Callable[[Leg], Point] = lambda leg: leg[0]\n```", "```py\n>>> start_s = lambda start, end, distance: start \n>>> end_s = lambda start, end, distance: end \n>>> distance_s = lambda start, end, distance: distance \n\n>>> latitude_s = lambda lat, lon: lat \n>>> longitude_s = lambda lat, lon: lon\n```", "```py\n>>> longitude_s(*start_s(*some_leg)) \n-76.330295\n```", "```py\nfrom typing import NamedTuple \n\nclass PointNT(NamedTuple): \n    latitude: float \n    longitude: float \n\nclass LegNT(NamedTuple): \n    start: PointNT \n    end: PointNT \n    distance: float\n```", "```py\n>>> first_leg = LegNT( \n...     PointNT(29.050501, -80.651169), \n...     PointNT(27.186001, -80.139503), \n...     115.1751) \n>>> first_leg.start.latitude \n29.050501\n```", "```py\nfrom collections.abc import Iterable, Iterator \nfrom Chapter04.ch04_ex1 import pick_lat_lon \n\ndef float_lat_lon_tuple( \n        row_iter: Iterable[list[str]] \n) -> Iterator[tuple[float, float]]: \n    lat_lon_iter = (pick_lat_lon(*row) for row in row_iter) \n    return ( \n        (float(lat), float(lon)) \n        for lat, lon in lat_lon_iter \n    )\n```", "```py\nfrom Chapter04.ch04_ex1 import pick_lat_lon \nfrom typing import Iterable, Iterator \n\ndef float_lat_lon( \n    row_iter: Iterable[list[str]] \n) -> Iterator[PointNT]: \n              #------ \n    lat_lon_iter = (pick_lat_lon(*row) for row in row_iter) \n    return ( \n        PointNT(float(lat), float(lon)) \n        #------ \n        for lat, lon in lat_lon_iter \n    )\n```", "```py\nfrom collections.abc import Iterable, Iterator \nfrom typing import cast, TextIO \nimport urllib.request \nfrom Chapter04.ch04_ex1 import legs, haversine, row_iter_kml \n\nsource_url = \"file:./Winter%202012-2013.kml\" \ndef get_trip(url: str=source_url) -> list[LegNT]: \n    with urllib.request.urlopen(url) as source: \n        path_iter = float_lat_lon(row_iter_kml(source)) \n        pair_iter = legs(path_iter) \n        trip_iter = ( \n            LegNT(start, end, round(haversine(start, end), 4)) \n            for start, end in pair_iter \n        ) \n        trip = list(trip_iter) \n    return trip\n```", "```py\n>>> source_url = \"file:./Winter%202012-2013.kml\" \n>>> trip = get_trip(source_url) \n\n>>> trip[0].start \nPointNT(latitude=37.54901619777347, longitude=-76.33029518659048) \n>>> trip[0].end \nPointNT(latitude=37.840832, longitude=-76.273834) \n>>> trip[0].distance \n17.7246\n```", "```py\nimport math \n\nclass PointE(NamedTuple): \n    latitude: float \n    longitude: float \n\n    def distance(self, other: \"PointE\", R: float = 360*60/math.tau) -> float: \n        \"\"\"Equirectangular, ’flat-earth’ distance.\"\"\" \n        Δϕ = ( \n            math.radians(self.latitude) - math.radians(other.latitude) \n        ) \n        Δλ = ( \n            math.radians(self.longitude) - math.radians(other.longitude) \n        ) \n        mid_ϕ = ( \n            (math.radians(self.latitude) - math.radians(other.latitude)) \n            / 2 \n        ) \n        x = R * Δλ * math.cos(mid_ϕ) \n        y = R * Δϕ \n        return math.hypot(x, y)\n```", "```py\n>>> start = PointE(latitude=38.330166, longitude=-76.458504) \n>>> end = PointE(latitude=38.976334, longitude=-76.473503) \n\n# Apply the distance() method of the start object... \n>>> leg = LegNT(start, end, round(start.distance(end), 4)) \n>>> leg.start == start \nTrue \n>>> leg.end == end \nTrue \n>>> leg.distance \n38.7805\n```", "```py\nfrom dataclasses import dataclass \n\n@dataclass(frozen=True) \nclass PointDC: \n    latitude: float \n    longitude: float \n\n@dataclass(frozen=True) \nclass LegDC: \n    start: PointDC \n    end: PointDC \n    distance: float\n```", "```py\n>>> first_leg = LegDC( \n...     PointDC(29.050501, -80.651169), \n...     PointDC(27.186001, -80.139503), \n...     115.1751) \n>>> first_leg.start.latitude \n29.050501\n```", "```py\nfrom typing import NamedTuple \n\nclass LargeNT(NamedTuple): \n  a: str \n  b: int \n  c: float \n  d: complex\n```", "```py\nfrom typing import Type, Any \n\ndef sizing(obj_type: Type[Any]) -> None: \n    big_sequence = [ \n        obj_type(f\"Hello, {i}\", 42*i, 3.1415926*i, i+2j) \n        for i in range(1_000_000) \n    ] \n    sys._clear_type_cache() \n    gc.collect() \n    print(f\"{obj_type.__name__} {sys.getallocatedblocks()}\") \n    del big_sequence\n```", "```py\nfrom typing import NamedTuple \n\nclass EagerLeg(NamedTuple): \n    start: Point \n    end: Point \n    distance: float \n\n    @classmethod \n    def create(cls, start: Point, end: Point) -> \"EagerLeg\": \n        return cls( \n            start=start, \n            end=end, \n            distance=round(haversine(start, end), 4) \n        )\n```", "```py\nfrom typing import NamedTuple \n\nclass LazyLeg(NamedTuple): \n    start: Point \n    end: Point \n\n    @property \n    def distance(self) -> float: \n        return round(haversine(self.start, self.end), 4) \n\n    @classmethod \n    def create(cls, start: Point, end: Point) -> \"LazyLeg\": \n        return cls( \n            start=start, \n            end=end \n        )\n```", "```py\n    LegNT(start, end, round(haversine(start, end), 4))\n    ```", "```py\n    PointNT(*map(float, pick_lat_lon(*row)))\n    ```", "```py\n    PointNT(longitude=float(row[0]), latitude=float(row[1]))\n    ```", "```py\n>>> import pyrsistent \n>>> v = pyrsistent.pmap({\"hello\": 42, \"world\": 3.14159}) \n>>> v  # doctest: +SKIP \npmap({’hello’: 42, ’world’: 3.14159}) \n>>> v[’hello’] \n42 \n>>> v[’world’] \n3.14159\n```", "```py\n>>> v2 = v.set(\"another\", 2.71828) \n>>> v2    # doctest: +SKIP \npmap({’hello’: 42, ’world’: 3.14159, ’another’: 2.71828})\n```", "```py\n>>> v    # doctest: +SKIP \npmap({’hello’: 42, ’world’: 3.14159})\n```", "```py\nfrom pyrsistent import PRecord, field \n\nclass PointPR(PRecord):  # type: ignore [type-arg] \n    latitude = field(type=float) \n    longitude = field(type=float) \n\nclass LegPR(PRecord):  # type: ignore [type-arg] \n    start = field(type=PointPR) \n    end = field(type=PointPR) \n    distance = field(type=float)\n```", "```py\nfrom math import isclose, modf \n\ndef to_dm(format: dict[str, str], point: float) -> str: \n    \"\"\"Use {\"+\": \"N\", \"-\": \"S\"} for latitude; {\"+\": \"E\", \"-\": \"W\"} for longitude.\"\"\" \n    sign = \"-\" if point < 0 else \"+\" \n    ms, d = modf(abs(point)) \n    ms = 60 * ms \n    # Handle the 59.999 case: \n    if isclose(ms, 60, rel_tol=1e-5): \n        ms = 0.0 \n        d += 1 \n    return f\"{d:3.0f}{ms:.3f}’{format.get(sign, sign)}\"\n```", "```py\nfrom pyrsistent import PRecord, field \n\nclass PointPR_S(PRecord):  # type: ignore[type-arg] \n    latitude = field( \n        type=float, \n        serializer=( \n            lambda format, value: \n                to_dm((format or {}) | {\"+\": \"N\", \"-\": \"S\"}, value) \n        ) \n    ) \n    longitude = field( \n        type=float, \n        serializer=( \n            lambda format, value: \n                to_dm((format or {}) | {\"+\": \"E\", \"-\": \"W\"}, value) \n        ) \n    )\n```", "```py\n>>> p = PointPR_S(latitude=32.842833333, longitude=-79.929166666) \n>>> p.serialize()  # doctest: +SKIP \n{’latitude’: \" 32Â°50.570’N\", ’longitude’: \" 79Â°55.750’W\"}\n```", "```py\nfrom collections.abc import Iterable, Iterator \nfrom typing import TextIO \nimport urllib.request \nfrom Chapter04.ch04_ex1 import legs, haversine, row_iter_kml \nfrom pyrsistent import pvector \nfrom pyrsistent.typing import PVector \n\nsource_url = \"file:./Winter%202012-2013.kml\" \ndef get_trip_p(url: str=source_url) -> PVector[LegPR]: \n    with urllib.request.urlopen(url) as source: \n        path_iter = float_lat_lon(row_iter_kml(source)) \n        pair_iter = legs(path_iter) \n        trip_iter = ( \n            LegPR( \n                start=PointPR.create(start._asdict()), \n                end=PointPR.create(end._asdict()), \n                distance=round(haversine(start, end), 4)) \n            #-------------------------------------------- \n            for start, end in pair_iter \n        ) \n        trip = pvector(trip_iter) \n               #------ \n    return trip\n```", "```py\n>>> p = PointNT(2, 3) \n>>> p._asdict() \n{’latitude’: 2, ’longitude’: 3}\n```", "```py\n>>> from Chapter03.ch03_ex4 import ( \n... series, head_map_filter, row_iter) \n>>> from pathlib import Path \n\n>>> source_path = Path(\"Anscombe.txt\") \n>>> with source_path.open() as source: \n...     data = list(head_map_filter(row_iter(source)))\n```", "```py\ndef series( \n      n: int, \n      row_iter: Iterable[list[SrcT]] \n) -> Iterator[tuple[SrcT, SrcT]]:\n```", "```py\nfrom typing import NamedTuple \n\nclass Pair(NamedTuple): \n    x: float \n    y: float\n```", "```py\nfrom collections.abc import Callable, Iterable \nfrom typing import TypeAlias \n\nRawPairIter: TypeAlias = Iterable[tuple[float, float]] \n\npairs: Callable[[RawPairIter], list[Pair]] \\ \n    = lambda source: list(Pair(*row) for row in source)\n```", "```py\n>>> series_I = pairs(series(0, data)) \n>>> series_II = pairs(series(1, data)) \n>>> series_III = pairs(series(2, data)) \n>>> series_IV = pairs(series(3, data))\n```", "```py\n>>> from pprint import pprint \n\n>>> pprint(series_I) \n[Pair(x=10.0, y=8.04), \n Pair(x=8.0, y=6.95), \n ... \n Pair(x=5.0, y=5.68)]\n```", "```py\nfrom collections import defaultdict \nfrom collections.abc import Callable, Iterator, Iterable, Hashable \nfrom typing import NamedTuple, TypeVar, Any, Protocol, cast \n\nBaseT = TypeVar(\"BaseT\", int, str, float) \nDataT = TypeVar(\"DataT\") \n\ndef rank( \n    data: Iterable[DataT], \n    key: Callable[[DataT], BaseT] \n) -> Iterator[tuple[float, DataT]]: \n\n    def build_duplicates( \n            duplicates: dict[BaseT, list[DataT]], \n            data_iter: Iterator[DataT], \n            key: Callable[[DataT], BaseT] \n    ) -> dict[BaseT, list[DataT]]: \n        for item in data_iter: \n            duplicates[key(item)].append(item) \n        return duplicates \n\n    def rank_output( \n            duplicates: dict[BaseT, list[DataT]], \n            key_iter: Iterator[BaseT], \n            base: int=0 \n    ) -> Iterator[tuple[float, DataT]]: \n        for k in key_iter: \n            dups = len(duplicates[k]) \n            for value in duplicates[k]: \n                yield (base+1+base+dups)/2, value \n            base += dups \n\n    duplicates = build_duplicates( \n        defaultdict(list), iter(data), key \n    ) \n    return rank_output( \n        duplicates, \n        iter(sorted(duplicates.keys())), \n        0 \n    )\n```", "```py\n>>> from pprint import pprint \n\n>>> data_1 = [(0.8,), (1.2,), (1.2,), (2.3,), (18.,)] \n>>> ranked_1 = list(rank(data_1, lambda row: row[0])) \n>>> pprint(ranked_1) \n[(1.0, (0.8,)), (2.5, (1.2,)), (2.5, (1.2,)), (4.0, (2.3,)), (5.0, (18.0,))] \n\n>>> from random import shuffle \n>>> shuffle(data_1) \n>>> ranked_1s = list(rank(data_1, lambda row: row[0])) \n>>> ranked_1s == ranked_1 \nTrue \n\n>>> data_2 = [(2., 0.8), (3., 1.2), (5., 1.2), (7., 2.3), (11., 18.)] \n>>> ranked_2 = list(rank(data_2, key=lambda x: x[1],)) \n>>> pprint(ranked_2) \n[(1.0, (2.0, 0.8)), \n (2.5, (3.0, 1.2)), \n (2.5, (5.0, 1.2)), \n (4.0, (7.0, 2.3)), \n (5.0, (11.0, 18.0))]\n```", "```py\nclass Ranked_XY(NamedTuple): \n    r_x: float \n    r_y: float \n    raw: Pair\n```", "```py\nfrom pyrsistent import PRecord, field, PMap, pmap \n\nclass Ranked_XY(PRecord):  # type: ignore [type-arg] \n    rank = field(type=PMap) \n    raw = field(type=Pair)\n```", "```py\ndef rank_xy(pairs: Sequence[Pair]) -> Iterator[Ranked_XY]: \n    data = list(Ranked_XY(rank=pmap(), raw=p) for p in pairs) \n\n    for attribute_name in (’x’, ’y’): \n        ranked = rank( \n            data, \n            lambda rxy: cast(float, getattr(rxy.raw, attribute_name)) \n        ) \n        data = list( \n            original.set( \n                rank=original.rank.set(attribute_name, r)  # type: ignore [arg-type] \n            ) \n            for r, original in ranked \n        ) \n\n    yield from iter(data)\n```", "```py\noriginal.rank.set(attribute_name, r)\n```", "```py\nfrom collections.abc import Sequence \n\ndef rank_corr(pairs: Sequence[Pair]) -> float: \n    ranked = rank_xy(pairs) \n    sum_d_2 = sum( \n        (r.rank[’x’] - r.rank[’y’]) ** 2  # type: ignore[operator, index] \n        for r in ranked \n    ) \n    n = len(pairs) \n    return 1 - 6 * sum_d_2/(n * (n ** 2 - 1))\n```", "```py\n>>> data = [Pair(x=10.0, y=8.04), \n... Pair(x=8.0, y=6.95), \n... Pair(x=13.0, y=7.58), Pair(x=9.0, y=8.81), \n... Pair(x=11.0, y=8.33), Pair(x=14.0, y=9.96), \n... Pair(x=6.0, y=7.24), Pair(x=4.0, y=4.26), \n... Pair(x=12.0, y=10.84), Pair(x=7.0, y=4.82), \n... Pair(x=5.0, y=5.68)] \n>>> round(pearson_corr(data), 3) \n0.816\n```", "```py\nfrom collections.abc import Sequence \nfrom Chapter04.ch04_ex4 import corr \n\ndef pearson_corr(pairs: Sequence[Pair]) -> float: \n    X = tuple(p.x for p in pairs) \n    Y = tuple(p.y for p in pairs) \n    return corr(X, Y)\n```", "```py\nfrom typing import NamedTuple, Any \n\nclass RankData(NamedTuple): \n    rank_seq: tuple[float, ...] \n    raw: Any\n```", "```py\n>>> raw_data = {’key1’: 1, ’key2’: 2} \n>>> r = RankData((2, 7), raw_data) \n>>> r.rank_seq[0] \n2 \n>>> r.raw \n{’key1’: 1, ’key2’: 2}\n```", "```py\nfrom collections.abc import Iterator, Iterable \nfrom typing import Any, TypeVar \n\nLL_Type = TypeVar(’LL_Type’) \n\ndef legs( \n        lat_lon_iter: Iterator[LL_Type] \n) -> Iterator[tuple[LL_Type, LL_Type]]: \n    begin = next(lat_lon_iter) \n    for end in lat_lon_iter: \n        yield begin, end \n        begin = end\n```", "```py\nfrom collections.abc import Iterator, Iterable, Sequence \nfrom typing import Any, TypeVar \n\n# Defined earlier \n# LL_Type = TypeVar(’LL_Type’) \n\ndef legs_g( \n        lat_lon_src: Iterator[LL_Type] | Sequence[LL_Type] \n) -> Iterator[tuple[LL_Type, LL_Type]]: \n    if isinstance(lat_lon_src, Sequence): \n        return legs_g(iter(lat_lon_src)) \n    elif isinstance(lat_lon_src, Iterator): \n        begin = next(lat_lon_src) \n        for end in lat_lon_src: \n            yield begin, end \n            begin = end \n    else: \n        raise TypeError(\"not an Iterator or Sequence\")\n```", "```py\nfrom collections.abc import Sequence, Iterator, Iterable \nfrom typing import Any, TypeVar \n\n# Defined earlier \n# LL_Type = TypeVar(’LL_Type’) \n\ndef legs_m( \n        lat_lon_src: Iterator[LL_Type] | Sequence[LL_Type] \n) -> Iterator[tuple[LL_Type, LL_Type]]: \n\n    match lat_lon_src: \n        case Sequence(): \n            lat_lon_iter = iter(lat_lon_src) \n        case Iterator() as lat_lon_iter: \n            pass \n        case _: \n            raise TypeError(\"not an Iterator or Sequence\") \n\n    begin = next(lat_lon_iter) \n    for end in lat_lon_iter: \n        yield begin, end \n        begin = end\n```", "```py\n    def some_method(self, *args: Any, **kwargs: Any) -> None: \n        if self.frozen: \n            raise RuntimeError(\"mapping is frozen\") \n        else: \n            super.some_method(*args, **kwargs)\n```"]