- en: Assessments
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估
- en: Chapter 1
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一章
- en: 'In the order of importance: functionality, correctness, and efficiency.'
  id: totrans-2
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重要性顺序：功能、正确性和效率。
- en: An `assert` statement raises an error when the condition it checks for is not
    satisfied. As such, these statements are used in tests, where we determine whether
    a program computes and outputs values as it is supposed to.
  id: totrans-3
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当检查的条件不满足时，`assert`语句会引发错误。因此，这些语句用于测试中，我们确定程序是否按预期计算并输出值。
- en: A benchmark is a small but representative use case that can be used to estimate
    the speed of a program. Benchmarks can be used to compare different versions of
    a program to see if a new implementation leads to an improvement in efficiency.
  id: totrans-4
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基准是一个小但具有代表性的用例，可以用来估计程序的速度。基准可以用来比较程序的不同版本，以查看新实现是否提高了效率。
- en: In IPython or Jupyter notebooks, the `timeit` magic command, when placed in
    front of a code snippet, will run that code several times and record the running
    time of each run. The output of the command will show summary statistics of the
    recorded times so that we can estimate the average running time of the code we
    are interested in.
  id: totrans-5
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在IPython或Jupyter笔记本中，`timeit`魔法命令，当放置在代码片段之前，将会运行该代码多次并记录每次运行的运行时间。命令的输出将显示记录时间的摘要统计，以便我们可以估计我们感兴趣的代码的平均运行时间。
- en: '`cProfile` includes the following in its output:'
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`cProfile`的输出包括以下内容：'
- en: '`ncalls`: The number of times the function was called.'
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ncalls`：函数被调用的次数。'
- en: '`tottime`: The total time spent in the function without considering the calls
    to other functions.'
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`tottime`：函数中不考虑对其他函数调用的总耗时。'
- en: '`cumtime`: The time in the function, including other function calls.'
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`cumtime`：函数中的时间，包括其他函数调用。'
- en: '`percall`: The time spent for a single call of the function, which can be obtained
    by dividing the total or cumulative time by the number of calls.'
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`percall`：函数单次调用的耗时，可以通过将总时间或累积时间除以调用次数获得。'
- en: '`filename:lineno`: The filename and corresponding line numbers. This information
    is not available when calling C extensions modules.'
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`filename:lineno`：文件名和相应的行号。当调用C扩展模块时，此信息不可用。'
- en: The `dis` module analyzes the low-level bytecode and shows how Python code is
    converted. This is helpful when we are interested in the number of low-level instructions
    that correspond to a specific statement.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`dis`模块分析低级字节码并显示Python代码是如何转换的。当我们对与特定语句相对应的低级指令数量感兴趣时，这很有帮助。'
- en: 'Using IPython, we may profile the function as follows:'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用IPython，我们可以按以下方式分析函数：
- en: '[PRE0]'
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Perhaps surprisingly, the unpacking and `p0` and `p1` takes two thirds of the
    execution time of the `close()` function.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 可能令人惊讶的是，`close()`函数的执行时间中有三分之二用于解包和`p0`以及`p1`。
- en: Chapter 2
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章
- en: 'The most appropriate data structure for each of the following use cases is
    as follows:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下每个用例最合适的数据结构如下：
- en: 'Mapping items to another set of items (with set being used in the most general
    sense): dictionaries.'
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将项映射到另一组项（集合在最一般的意义上）：字典。
- en: 'Accessing, modifying, and appending elements: lists.'
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问、修改和追加元素：列表。
- en: 'Maintaining a collection of unique elements: sets.'
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 维护唯一元素集合：集合。
- en: 'Keeping track of the minimum/maximum of a set (in the most general sense):
    heaps.'
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 跟踪集合（在最一般的意义上）的最小/最大值：堆。
- en: 'Appending and removing elements at the endpoints of a sequence (in the most
    general sense): deques.'
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在序列的端点追加和移除元素（在最一般的意义上）：双端队列。
- en: 'Fast searching according to some similarity criterion (used by, for example,
    autocompletion engines): tries.'
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据某些相似性标准进行快速搜索（例如，自动完成引擎所使用）：Trie树。
- en: Caching is a design where we store expensive results in a temporary location,
    which can be in memory, on-disk, or a remote location. Memoization is specifically
    about storing and reusing the results of previous function calls in an application.
    As such, memoization is a form of caching.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 缓存是一种设计，我们将昂贵的计算结果存储在临时位置，这可以是内存、磁盘或远程位置。记忆化专门指在应用程序中存储和重用先前函数调用的结果。因此，记忆化是一种缓存形式。
- en: Comprehensions and generators are optimized under the hood, so they are generally
    more efficient than explicit for loops. They are also more compact in code and
    are more readable.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 紧凑性和生成器在底层进行了优化，因此它们通常比显式的for循环更高效。它们在代码中也更紧凑，更易读。
- en: A dictionary would be a more appropriate data structure. If the numbers represented
    the counts, a `Counter` data structure would be the best data structure to use.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 字典将是一个更合适的数据结构。如果数字表示计数，那么`Counter`数据结构将是使用最佳的数据结构。
- en: Chapter 3
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章
- en: NumPy offers efficient operations on multidimensional arrays, such as array
    creation, accessing elements (indexing) and slicing along specific axes, and optimized
    mathematical operations.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: NumPy提供了对多维数组的有效操作，例如创建数组、访问元素（索引）和沿特定轴进行切片，以及优化的数学运算。
- en: Using pandas, you can apply "mapping" operations to data, group, aggregate,
    and summarize data.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用pandas，你可以对数据进行“映射”操作，分组、聚合和总结数据。
- en: NumPy cannot handle labeled data, while pandas cannot process multidimensional
    data. `xarray` combines the best features of the two libraries to offer APIs the
    ability to handle multi-dimensional, labeled data.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: NumPy无法处理带标签的数据，而pandas无法处理多维数据。`xarray`结合了这两个库的最佳特性，为API提供了处理多维、带标签数据的能力。
- en: Chapter 4
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章
- en: Static types allow the compiler to generate type-specific optimization, making
    the compiled code more efficient.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 静态类型允许编译器生成特定类型的优化，使编译后的代码更高效。
- en: A memory view belongs to Cython's interface, which helps it work with different
    data types such as `byte`, `bytearray`, or `array.array` easier. Specifically,
    it offers a universal interface that simplifies the process of accessing the values
    that are stored in these different data types.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 内存视图属于Cython的接口，这有助于它更容易地与不同的数据类型（如`byte`、`bytearray`或`array.array`）一起工作。具体来说，它提供了一个通用接口，简化了访问存储在这些不同数据类型中的值的流程。
- en: To profile Cython, we can use the annotated view to identify hard-to-find interpreter-related
    calls, as well as the familiar `cProfile` tool.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了分析Cython，我们可以使用注解视图来识别难以发现的与解释器相关的调用，以及熟悉的`cProfile`工具。
- en: Chapter 5
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章
- en: JIT compilers perform compilation at runtime rather than before running the
    code. This allows a piece of code that is expected to run many times to become
    more efficient, as recompilation is no longer necessary.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JIT编译器在运行时而不是在运行代码之前进行编译。这使得预期将多次运行的代码变得更加高效，因为不再需要重新编译。
- en: We use the signature of an `nb.jit` function to specify the data types that
    the function works with, which allows for further optimization for specific numerical
    data types. When Numba encounters other, unsupported types, it simply registers
    them as the generic `pyobject` type.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`nb.jit`函数的签名来指定函数处理的数据类型，这允许对特定数值数据类型进行进一步优化。当Numba遇到其他不受支持的类型时，它简单地将其注册为通用的`pyobject`类型。
- en: Tracing JIT compilation refers to the process of identifying the most intensive
    loops in a program, tracing the operations involved, and compiling the corresponding
    optimized, interpreter-free code. This allows us to actively optimize the most
    inefficient part of our code.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 追踪JIT编译指的是识别程序中最密集的循环、跟踪涉及的运算，并编译相应的优化、无解释器的代码的过程。这允许我们积极优化代码中最不高效的部分。
- en: Chapter 6
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章
- en: The main components of a typical machine learning pipeline are the predictive
    model (model assumptions, parameters), the loss function, and the optimization
    of the model parameters to minimize the loss function.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 典型机器学习流程的主要组件是预测模型（模型假设、参数）、损失函数以及模型参数的优化以最小化损失函数。
- en: The loss function may be minimized using gradient descent, in which we compute
    the gradient of the loss with the current values of the model parameters and adjust
    those values in the opposite direction of the gradient. JAX can compose this gradient
    loss function using `grad`.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 损失函数可以通过梯度下降来最小化，其中我们计算损失相对于当前模型参数的梯度，并调整这些值以与梯度的反方向。JAX可以使用`grad`来组合这个梯度损失函数。
- en: In our example, we utilized kernels to create nonlinear features from the features
    we were given. Naïve implementations of kernels are hard to vectorize, which may
    lead to inefficient for loops. JAX can automatically vectorize these kernels to
    address this problem.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们利用核从给定的特征中创建非线性特征。核的朴素实现难以向量化，这可能导致效率低下的循环。JAX可以自动向量化这些核来解决此问题。
- en: Chapter 7
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章
- en: At a high level, asynchronous programming aims to avoid idle waiting for unavailable
    resources. This typically involves interacting with slow and unpredictable resources.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从高层次来看，异步编程旨在避免空闲等待不可用资源。这通常涉及与缓慢且不可预测的资源交互。
- en: A callback is a function that will be called at a given, later time. A future,
    on the other hand, is a more convenient abstraction that helps us keep track of
    requested resources and whether they are available. Futures are generally easier
    to use than callbacks.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回调是一个将在给定的时间后调用的函数。另一方面，未来是一个更方便的抽象，帮助我们跟踪请求的资源及其可用性。与回调相比，未来通常更容易使用。
- en: A reactive application should be responsive, elastic, resilient, and message-driven.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个响应式应用应该是响应的、弹性的、有弹性的和消息驱动的。
- en: Chapter 8
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章
- en: Multithreading cannot possibly speed up Python code due to the **global interpreter
    lock** (**GIL**). In this chapter, we examined different approaches to multiprocessing;
    that is, running code using multiple processes.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于**全局解释器锁**（**GIL**），多线程不可能加快Python代码的执行速度。在本章中，我们探讨了不同的多进程方法；也就是说，使用多个进程来运行代码。
- en: Using the `Process` interface, we can have more low-level control by subclassing
    it. The `Pool` interface, on the other hand, offers a convenient way to distribute
    tasks across processes using the `apply` and `map` methods.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Process`接口，我们可以通过继承它来获得更底层的控制。另一方面，`Pool`接口提供了一个方便的方法，通过`apply`和`map`方法在进程间分配任务。
- en: Theano and TensorFlow automatically translate our code into a parallelized version
    by taking advantage of special operations such as matrix multiplication.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Theano和TensorFlow通过利用特殊操作，如矩阵乘法，自动将我们的代码转换为并行版本。
- en: Chapter 9
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章
- en: '**HTML** stands for **Hypertext Markup Language**, which is the standard and
    most common language for developing web pages and applications.'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**HTML**代表**超文本标记语言**，它是开发网页和应用程序的标准和最常用的语言。'
- en: Most of the communication that's done via the internet (more specifically, the
    **World Wide Web** (**WWW**)) uses HTTP. In HTTP, request methods are used to
    convey information on what data is being requested and should be sent back from
    a server.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过互联网（更具体地说，是**万维网**（**WWW**））进行的通信的大部分（更具体地说，是**万维网**（**WWW**））都使用HTTP。在HTTP中，请求方法用于传达有关请求的数据以及应从服务器返回的数据的信息。
- en: HTTP response status codes are three-digit numbers that signify the state of
    communication between a server and its client. They are split into five categories,
    each indicating a specific state.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: HTTP响应状态码是三位数，表示服务器与其客户端之间通信的状态。它们分为五个类别，每个类别指示一个特定的状态。
- en: The `requests` module manages the communication between a Python program and
    a web server through HTTP requests.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`requests`模块通过HTTP请求管理Python程序与Web服务器之间的通信。'
- en: A ping test is a tool that's typically used by web administrators to make sure
    that their sites are still available to clients. A ping test does this by making
    requests to the websites and analyzing the returned response status code.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Ping测试是一种通常由网络管理员使用的工具，以确保他们的网站对客户端仍然可用。Ping测试通过向网站发送请求并分析返回的响应状态码来完成此操作。
- en: Both the process of making different requests to a web server and parsing the
    processing downloaded HTML source code are independent across separate requests.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向一个Web服务器发送不同请求的过程以及解析下载的HTML源代码的处理是跨不同请求独立的。
- en: 'The following considerations should be made when you''re developing applications
    that make concurrent web requests:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在开发执行并发Web请求的应用程序时，应考虑以下因素：
- en: The terms of service and data-collecting policies
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务条款和数据收集政策
- en: Error handling
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误处理
- en: Updating your program regularly
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定期更新你的程序
- en: Avoiding over-scraping
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 避免过度抓取
- en: Chapter 10
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章
- en: Image processing is the task of analyzing and manipulating digital image files
    to create new versions of the images, or to extract important data from them.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 图像处理是分析和管理数字图像文件的任务，以创建图像的新版本或从中提取重要数据。
- en: 'The smallest unit of a digital image is a pixel, which typically contains an
    RGB value: a tuple of integers between 0 and 255.'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数字图像的最小单位是像素，它通常包含一个RGB值：一个介于0到255之间的整数的元组。
- en: Grayscaling is the processing of converting an image into gray colors by considering
    only the intensity of each pixel, represented by the amount of light available.
    It reduces the dimensionality of the image pixel matrix by mapping traditional
    three-dimensional color data to one-dimensional gray data.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 灰度化是将图像转换为灰度颜色的处理过程，只考虑每个像素的强度，即可用光量。它通过将传统的三维颜色数据映射到一维灰度数据来减少图像像素矩阵的维度。
- en: Thresholding replaces each pixel in an image with a white pixel if the pixel's
    intensity is greater than a previously specified threshold, and with a black pixel
    if the pixel's intensity is less than that threshold. After performing thresholding
    on an image, each pixel of that image can only hold two possible values, significantly
    reducing the complexity of image data.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 阈值化将图像中的每个像素替换为白色像素，如果像素的强度大于先前指定的阈值，如果像素的强度小于该阈值，则替换为黑色像素。在执行图像的阈值化后，该图像的每个像素只能持有两种可能值，显著降低了图像数据复杂性。
- en: Heavy computational number-crunching processes are typically involved when it
    comes to image processing, as each image is a matrix of integer tuples. However,
    these processes can be executed independently, which suggests that the whole task
    should be made concurrent.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当涉及到图像处理时，通常涉及大量的计算密集型处理过程，因为每个图像都是一个整数元组的矩阵。然而，这些过程可以独立执行，这表明整个任务应该被并行化。
- en: 'Some good practices for concurrent image processing are as follows:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 并发图像处理的一些良好实践如下：
- en: Choose the correct method (out of many)
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择正确的方法（众多方法中的一种）
- en: Spawn an appropriate number of processes
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成适当数量的进程
- en: Process the input/output concurrently
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 并发处理输入/输出
- en: Chapter 11
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章
- en: Communication channels are used to denote both the physical wiring connection
    between different systems and the logical communication of data that facilitates
    computer networks. The latter is related to computing and is more relevant to
    the idea of asynchronous programming. Asynchronous programming can provide functionalities
    that complement the process of facilitating communication channels efficiently.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通信通道用于表示不同系统之间的物理布线连接以及促进计算机网络数据逻辑通信。后者与计算相关，并且更符合异步编程的概念。异步编程可以提供补充高效促进通信通道进程的功能。
- en: The media layers contain fairly low-level operations that interact with the
    underlying process of the communication channel, while the host layers deal with
    high-level data communication and manipulation.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 媒体层包含相当低级的操作，这些操作与通信通道的底层过程交互，而主机层处理高级数据通信和操作。
- en: The transport layer is often viewed as the conceptual transition between the
    media layers and the host layers. It is responsible for sending data along end-to-end
    connections between different systems.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 传输层通常被视为媒体层和主机层之间的概念过渡。它负责在不同系统之间的端到端连接上发送数据。
- en: Server-wise, the `asyncio` module combines the abstraction of transport with
    the implementation of an asynchronous program. Specifically, via its `BaseTransport`
    and `BaseProtocol` classes, `asyncio` provides different ways to customize the
    underlying architecture of a communication channel.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在服务器端，`asyncio`模块结合了传输的抽象与异步程序实现的实现。具体来说，通过其`BaseTransport`和`BaseProtocol`类，`asyncio`提供了不同的方式来自定义通信通道的底层架构。
- en: Together with the `aiohttp` module and, specifically, `aiohttp.ClientSession`,
    `asyncio` also offers efficiency and flexibility regarding client-side communication
    processes, via asynchronously making requests and reading the returned responses.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与`aiohttp`模块以及特别地`aiohttp.ClientSession`一起，`asyncio`通过异步发送请求和读取返回的响应，在客户端通信过程中提供了效率和灵活性。
- en: The `aiofiles` module, which can work in conjunction with `asyncio` and `aiohttp`,
    helps facilitate asynchronous file reading/writing.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`aiofiles`模块可以与`asyncio`和`aiohttp`一起工作，帮助促进异步的文件读写。'
- en: Chapter 12
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章
- en: A lack of (or mishandled) coordination between different lock objects can cause
    a deadlock, in which no progress can be made, and the program is locked in its
    current state.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不同锁对象之间缺乏（或处理不当）的协调可能导致死锁，在这种情况下，无法取得进展，程序被锁定在其当前状态。
- en: In the dining philosophers problem, since each philosopher is holding only one
    fork with their left hand, they cannot proceed to eat or put down the fork they
    are holding. The only way a philosopher gets to eat their food is for their neighbor
    philosopher to put their fork down, which is only possible if they can eat their
    food; this creates a never-ending circle of conditions that can never be satisfied.
    This situation is, in essence, the nature of a deadlock, in which all the elements
    of a system are stuck in place and no progress can be made.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在就餐哲学家问题中，由于每位哲学家只用左手拿着一个叉子，他们无法继续进食或放下他们持有的叉子。哲学家唯一能够进食的方式是他们的邻居哲学家放下他们的叉子，而这只有在他们能够进食的情况下才可能；这创造了一个永远无法满足的条件的循环。本质上，这种情况是死锁的本质，其中系统的所有元素都卡在原地，无法取得任何进展。
- en: 'A deadlock is also defined by the necessary conditions that a concurrent program
    needs to have at the same time for a deadlock to occur. These conditions were
    first proposed by the computer scientist Edward G. Coffman Jr, and are therefore
    known as the Coffman conditions. These conditions are as follows:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 死锁还定义了并发程序在发生死锁时必须同时满足的必要条件。这些条件最初由计算机科学家爱德华·G·科夫曼（Edward G. Coffman Jr）提出，因此被称为科夫曼条件。这些条件如下：
- en: At least one resource has to be in a non-shareable state. This means that the
    resource is being held by an individual process (or thread) and cannot be accessed
    by others; the resource can only be accessed and held by a single process (or
    thread) at any given time. This condition is also known as mutual exclusion.
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 至少必须有一个资源处于不可共享状态。这意味着该资源被某个个体进程（或线程）持有，并且不能被其他人访问；在任何给定时间，资源只能被单个进程（或线程）访问和持有。这种条件也被称为互斥。
- en: One process (or thread) exists that is simultaneously accessing a resource and
    waiting for another that's held by other processes (or threads). In other words,
    this process (or thread) needs access to two resources to execute its instructions,
    one of which it is already holding, and the other of which it is waiting for from
    other processes (or threads). This condition is called hold and wait.
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 存在一个进程（或线程）同时访问一个资源并等待另一个被其他进程（或线程）持有的资源。换句话说，这个进程（或线程）需要访问两个资源来执行其指令，其中一个它已经持有，另一个它正在等待从其他进程（或线程）那里获得。这种条件被称为持有和等待。
- en: Resources can only be released by a process (or a thread) holding them if there
    are specific instructions for the process (or thread) to do so. This is to say
    that unless the process (or thread) voluntarily and actively releases the resource,
    the resource remains in a non-shareable state. This is the no preemption condition.
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只有在存在特定指令要求进程（或线程）这样做的情况下，资源才能由持有它们的进程（或线程）释放。也就是说，除非进程（或线程）自愿并主动释放资源，否则资源将保持在一个不可共享的状态。这就是不可抢占条件。
- en: The final condition is called circular wait. As its name suggests, this condition
    specifies that a set of processes (or threads) exists where the first process
    (or thread) in the set is waiting for a resource to be released by the second
    process (or thread), which, in turn, needs to be waiting for the third process
    (or thread); finally, the last process (or thread) in the set is waiting for the
    first one.
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一个条件被称为循环等待。正如其名所示，这个条件指定了一个存在一组进程（或线程）的集合，其中集合中的第一个进程（或线程）正在等待第二个进程（或线程）释放一个资源，而第二个进程（或线程）反过来又需要等待第三个进程（或线程）；最后，集合中的最后一个进程（或线程）正在等待第一个进程（或线程）。
- en: Instead of accessing the resources arbitrarily, if the processes (or threads)
    are to access them in a predetermined, static order, the circular nature of the
    way that they acquire and wait for the resources will be eliminated. However,
    if you place enough locks on the resources of your concurrent program, it will
    become entirely sequential in its execution, and, combined with the overhead of
    concurrent programming functionalities, it will have an even worse speed than
    the purely sequential version of the program.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果进程（或线程）要按照预定的、静态的顺序访问资源，而不是任意访问资源，那么它们获取和等待资源的循环性质将被消除。然而，如果你在你的并发程序的资源上放置足够的锁，它的执行将完全变为顺序执行，并且，结合并发编程功能的开销，它的速度甚至比程序的纯顺序版本还要差。
- en: 'By ignoring locks, our program resources effectively become shareable among
    different processes/threads in a concurrent program, thus eliminating the first
    of the four Coffman conditions: mutual exclusion. Doing this, however, can be
    seen as misunderstanding the problem completely. We know that locks are utilized
    so that processes and threads can access the shared resources in a program in
    a systematic, coordinated way, to avoid mishandling the data. Removing any locking
    mechanisms in a concurrent program means that the likelihood of the shared resources,
    which are now free from accessing limitations, being manipulated in an uncoordinated
    way (and therefore becoming corrupted) increases significantly.'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过忽略锁，我们的程序资源在并发程序的不同进程/线程之间有效地变得可共享，从而消除了四个Coffman条件中的第一个：互斥。然而，这样做可以被视为完全误解了问题。我们知道，锁被用来确保进程和线程以系统化、协调的方式访问程序中的共享资源，以避免误操作数据。在并发程序中移除任何锁定机制意味着现在不受访问限制的共享资源被无序操作（因此被破坏）的可能性显著增加。
- en: In a livelock situation, the processes (or threads) in the concurrent program
    can switch their states, yet they simply switch back and forth infinitely, and
    no progress can be made.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在活锁情况下，并发程序中的进程（或线程）可以切换它们的状态，但它们只是简单地无限地来回切换，无法取得任何进展。
- en: Chapter 13
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第13章
- en: Starvation is a problem in concurrent systems in which a process (or thread)
    cannot gain access to the necessary resources to proceed with its execution, which
    means it cannot make any progress.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 饥饿是并发系统中的一个问题，其中进程（或线程）无法获得执行所需的必要资源，这意味着它无法取得任何进展。
- en: 'Most of the time, a poorly coordinated set of scheduling instructions is the
    main cause of starvation. Some high-level causes for starvation may include the
    following:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 大多数情况下，一组协调不良的调度指令是导致饥饿的主要原因。饥饿的一些高级原因可能包括以下内容：
- en: Processes (or threads) with high priorities dominate the execution flow in the
    CPU, so low-priority processes (or threads) are not allowed to execute their instructions.
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 优先级高的进程（或线程）在CPU中的执行流程中占主导地位，因此低优先级的进程（或线程）不允许执行它们的指令。
- en: Processes (or threads) with high priorities dominate the usage of non-shareable
    resources, so low-priority processes (or threads) are not allowed to execute their
    instructions. This situation is similar to the first one but addresses the priority
    of accessing resources, instead of the priority of execution itself.
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 优先级高的进程（或线程）会主导对不可共享资源的使用，因此低优先级的进程（或线程）不允许执行它们的指令。这种情况与第一种情况类似，但解决的是访问资源的优先级，而不是执行本身的优先级。
- en: Processes (or threads) with low priorities are waiting for resources to execute
    their instructions, but as soon as the resources become available, other processes
    (or threads) with higher priorities are immediately given access to them, so the
    low-priority processes (or threads) wait infinitely.
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 优先级低的进程（或线程）正在等待资源以执行它们的指令，但一旦资源可用，优先级更高的进程（或线程）会立即获得访问权限，因此低优先级的进程（或线程）会无限期地等待。
- en: Deadlock situations can also lead to starvation, as the definition of starvation
    states that if a process (or thread) exists that is unable to make any progress
    because it cannot gain access to the necessary process, the process (or thread)
    is experiencing starvation. This is also illustrated in the dining philosophers'
    problem.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 死锁情况也可能导致饥饿，因为饥饿的定义指出，如果一个进程（或线程）存在，它无法取得任何进展，因为它无法获得必要的进程，那么该进程（或线程）正在经历饥饿。这一点在哲学家就餐问题中也得到了说明。
- en: The readers-writers problem asks for a scheduling algorithm so that readers
    and writers can access the text file appropriately and efficiently, without mishandling/corrupting
    the data that's included.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读者-写者问题要求一个调度算法，以便读者和写者可以适当地、高效地访问文本文件，而不会误操作/损坏包含的数据。
- en: The first approach allows for multiple readers to access the text file simultaneously
    since readers simply read in the text file and do not alter the data in it. The
    problem with the first approach is that when a reader is accessing the text file
    and a writer is waiting for the file to be unlocked, if another reader starts
    its execution and wants to access the file, it will be given priority over the
    writer, who has already been waiting. Additionally, if more and more readers keep
    requesting access to the file, the writer will be waiting infinitely.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一种方法允许多个读者同时访问文本文件，因为读者只是读取文本文件，并不修改其中的数据。第一种方法的问题在于，当一个读者正在访问文本文件而写者正在等待文件解锁时，如果另一个读者开始执行并想要访问文件，它将优先于已经等待的写者。此外，如果越来越多的读者不断请求访问文件，写者将无限期地等待。
- en: This approach implements the specification that once a writer requests to access
    the file, no reader should be able to jump in line and access the file before
    that writer. As opposed to what we see in the first solution to the readers-writers
    problem, this solution is giving priority to writers and, as a consequence, the
    readers are starved.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此方法实现了以下规范：一旦写者请求访问文件，任何读者都不应该能够跳过队列中的写者并在此之前访问文件。与我们在读者-写者问题的第一个解决方案中看到的情况相反，此解决方案优先考虑写者，因此读者会遭受饥饿。
- en: This approach implements a lock on both readers and writers. All threads will
    then be subject to the constants of the lock, so equal priority will be achieved
    among separate threads.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此方法在读者和写者上都实现了锁。因此，所有线程都将受到锁的常数约束，从而在各个线程之间实现平等优先级。
- en: 'Some common solutions to starvation include the following:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解决饥饿的一些常见方法包括以下内容：
- en: Increasing the priority of low-priority threads.
  id: totrans-103
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提高低优先级线程的优先级。
- en: Implementing a first-in-first-out thread queue.
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个先进先出（FIFO）线程队列。
- en: Implementing a priority queue that also gives gradually increasing priority
    to threads that have been waiting in the queue for a long time.
  id: totrans-105
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个优先队列，同时逐渐提高在队列中等待时间较长的线程的优先级。
- en: If a thread has been able to access the shared resource many times, it should
    be given less priority.
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一个线程能够多次访问共享资源，则应给予较低的优先级。
- en: Chapter 14
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第14章
- en: Critical sections indicate shared resources that are accessed by multiple processes
    or threads in a concurrent application, which can lead to unexpected, and even
    erroneous, behaviors.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 临界区指示在并发应用程序中由多个进程或线程访问的共享资源，这可能导致意外的，甚至错误的行为。
- en: A race condition occurs when two or more threads/processes access and alter
    a shared resource simultaneously, resulting in mishandled and corrupted data.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当两个或更多线程/进程同时访问和修改共享资源时，就会发生竞态条件，导致数据被错误处理和损坏。
- en: The root cause of a race condition is multiple threads/processes reading in
    and altering a shared resource simultaneously. When all of the threads/processes
    finish their execution, only the result of the last thread/process is registered.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 竞态条件的根本原因是多个线程/进程同时读取和修改共享资源。当所有线程/进程完成它们的执行后，只有最后一个线程/进程的结果被注册。
- en: Since race conditions arise when multiple threads or processes access and write
    to a shared resource simultaneously, the solution is to isolate the execution
    of different threads/processes, especially when interacting with the shared resource.
    With locks, we can turn a shared resource in a concurrent program into a critical
    section, whose data integrity is guaranteed to be protected.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于竞态条件发生在多个线程或进程同时访问和写入共享资源时，因此解决方案是隔离不同线程/进程的执行，尤其是在与共享资源交互时。使用锁，我们可以将并发程序中的共享资源转换为临界区，其数据完整性得到保证。
- en: 'There are several disadvantages to using locks: with enough locks implemented
    in a concurrent program, the whole program may become entirely sequential; locks
    don''t lock anything.'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用锁有几个缺点：在一个并发程序中实现足够的锁，整个程序可能会完全变为顺序执行；锁不会锁定任何东西。
- en: 'The problems that race conditions raise in real-life systems and applications
    are as follows:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 竞态条件在现实生活中的系统和应用程序中引起的问题如下：
- en: 'Security: A race condition can be both exploited as a security vulnerability
    (to give external agents illegal access to a system) and used as random key generation,
    for security processes.'
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安全性：竞态条件既可以被利用作为安全漏洞（为外部代理提供非法访问系统的权限），也可以用作随机密钥生成，用于安全过程。
- en: 'Operating systems: A race condition occurring when two agents (users and applications)
    interact with the same memory space can lead to unpredictable behaviors.'
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 操作系统：当两个代理（用户和应用程序）与相同的内存空间交互时发生的竞态条件可能导致不可预测的行为。
- en: 'Networking: In networking, a race condition can lead to giving multiple users
    powerful privileges in a network.'
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 网络：在网络中，竞态条件可能导致多个用户在网络中获得强大的权限。
- en: Chapter 15
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 15 章
- en: C++ associates a variable with its value by simply writing the value to the
    memory location of the variable; Python has its variables reference point to the
    memory location of the values that they hold. For this reason, Python needs to
    maintain a reference count for every value in its memory space.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C++ 通过将值写入变量的内存位置来将变量与其值关联起来；Python 的变量通过引用指向它们持有的值的内存位置。因此，Python 需要为其内存空间中的每个值维护一个引用计数。
- en: To avoid race conditions and, consequently, value reference counts from being
    corrupted, the GIL is implemented so that only one thread can access and mutate
    the counts at any given time.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了避免竞态条件，从而防止值引用计数被破坏，GIL 被实现为在任何给定时间只能由一个线程访问和修改计数。
- en: The GIL effectively prevents multiple threads from taking advantage of the CPU
    and executing CPU-bound instructions at the same time. This means that if multiple
    threads that are meant to be executed concurrently are CPU-bound, they will be
    executed sequentially.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: GIL 有效地防止了多个线程同时利用 CPU 并执行 CPU 密集型指令。这意味着如果多个线程是 CPU 密集型的并且打算并发执行，它们将按顺序执行。
- en: There are a few ways to deal with the GIL in your Python applications; namely,
    implementing multiprocessing instead of multithreading and utilizing other, alternative
    Python interpreters.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 Python 应用程序中处理 GIL 有几种方法；即，实现多进程而不是多线程，并利用其他替代的 Python 解释器。
- en: Chapter 16
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 16 章
- en: The factory pattern makes it easy to keep track of the objects that are created
    within a program. Another benefit lies in the separation of code, which creates
    an object and the code that the object uses.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 工厂模式使得跟踪程序中创建的对象变得容易。另一个好处在于代码的分离，即创建对象的代码和对象使用的代码。
- en: 'There are two forms of the factory pattern: the factory method and the abstract
    method. The former is used to handle the creation of a single object, while the
    latter is a group of factory methods.'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 工厂模式有两种形式：工厂方法和抽象方法。前者用于处理单个对象的创建，而后者是一组工厂方法。
- en: You should start with the factory method first since it is the simpler of the
    two. If you find yourself needing many factory methods, then you should start
    thinking about grouping them into different abstract methods.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该首先从工厂方法开始，因为它比另一个方法简单。如果你发现自己需要很多工厂方法，那么你应该开始考虑将它们分组到不同的抽象方法中。
- en: Chapter 17
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 17 章
- en: The builder pattern helps manage objects that contain many individual components
    that need to be created sequentially. The pattern allows you to reuse a construction
    multiple times as well since it decouples an object's construction and the object
    itself.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建器模式有助于管理包含许多需要依次创建的单独组件的对象。该模式还允许你多次重复使用构建过程，因为它将对象的构建与对象本身解耦。
- en: Many applications, such as HTML page generators, document converters, and UI
    form creators, are implemented with the builder pattern.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 许多应用程序，如 HTML 页面生成器、文档转换器和 UI 表单创建器，都是使用构建器模式实现的。
- en: The builder pattern uses a director to create an object via multiple steps sequentially,
    while the factory pattern creates an object in a single step.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建器模式使用一个导演通过多个步骤依次创建一个对象，而工厂模式通过单个步骤创建一个对象。
- en: Chapter 18
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 18 章
- en: The prototype pattern helps us create objects that are based on an existing
    object (or prototype) via cloning. This can easily be done in Python using the
    `copy` function.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 原型模式帮助我们通过克隆现有对象（或原型）来创建对象。这可以通过 Python 中的 `copy` 函数轻松实现。
- en: Objects in a database need to be duplicated many times, depending on the application
    and its users. This may be an expensive operation without prototypes.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据库中的对象需要根据应用程序及其用户多次复制。如果没有原型，这可能会是一个昂贵的操作。
- en: The singleton pattern is helpful when we want to implement a class that should
    only have one instance. This is useful, for example, when we'd like to maintain
    the global state of a Python program.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单例模式在我们要实现一个只能有一个实例的类时非常有用。例如，当我们想维护 Python 程序的全局状态时，这很有用。
- en: The singleton pattern may be used to control concurrent access to a shared resource,
    preventing many concurrency-based bugs and errors.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 20
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The decorator pattern specifies the usage and responsibilities of an object
    dynamically in a transparent and readable way.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Python has a built-in decorator feature, allowing programmers to extend the
    functionalities of a function, method, or class.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the decorator pattern, we can implement memoization with minimal code,
    which, as we have seen in the main text, helps keep the computation of Fibonacci
    numbers fast and its code readable.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 21
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The bridge pattern is useful when there is a need to share an implementation
    among different objects without having to implement individual specialized classes.
    This is typically done with either an abstract class that generalizes the different
    use cases or the individual specialized classes themselves.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The adapter is generally used to make two incompatible interfaces compatible,
    while the bridge abstracts out the generalization of different classes.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We define an abstract content fetcher class, from which two specialized classes
    inherit: a local file fetcher and a URL fetcher.'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 22
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The façade pattern helps hide the inner implementation of an application and
    only exposing the necessary interface. This is particularly important when we
    are working with a large code base but our user only needs to interact with a
    small portion of our code.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When we need to make a change to an application, the abstraction that the façade
    pattern provides helps keep the client code separate and safe, which is useful
    in making the client side unaffected by pending software changes.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The operating system class works as a façade, hiding access to the different
    server classes from client code.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 23
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The flyweight pattern is designed to keep memory usage at a minimum by sharing
    resources among similar objects.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The MVC pattern generalizes a common structure among different applications
    with a model, a view, and a controller. This helps prevent mixing the backend
    logic with user interfaces.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The proxy pattern is useful in requiring the necessary code to be run before
    an important object is accessed.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 24
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The chain of responsibility pattern gracefully handles an unknown number of
    requests or events that our program needs to process. This is useful in event-based
    logic such as purchase applications and shipping systems.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In our system, if an object does not know how to handle a given request, it
    passes the request along the chain. As we have seen, a `close` event cannot be
    handled directly by `SendDialog` and `MsgText` and is passed to `MainWindow`.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The chain of responsibility pattern may not be useful if there are multiple
    requests, but they may be processed by a single object. This renders all the bookkeeping
    that's done by the pattern useless.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 25
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The command pattern helps encapsulate operational logic (copy, paste, undo,
    redo, and so on) in an object. This leads to better abstraction and management
    of the logical steps to be taken for each operation, such as grouping multiple
    operations and implementing macros.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命令模式有助于封装操作逻辑（复制、粘贴、撤销、重做等）在对象中。这导致了对每个操作要采取的逻辑步骤的更好抽象和管理，例如分组多个操作和实现宏。
- en: The command pattern abstracts out the implementation of the operations that
    are used, so any client code that executes it does not need to know about the
    details of their implementation.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命令模式抽象出操作的实现，因此任何执行它的客户端代码都不需要了解其实现的细节。
- en: In our example, we implemented an abstraction on top of various functionalities
    provided by the `os` module. A particular feature is its undoing function. Moreover,
    as commands have a consistent interface, grouping them can be done with ease.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们在`os`模块提供的各种功能之上实现了一个抽象。一个特定功能是其撤销功能。此外，由于命令具有一致的接口，分组可以轻松完成。
- en: Chapter 26
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第26章
- en: The observer pattern maintains a list of objects that are interested in the
    state of a target object and notifies the former when the latter changes.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 观察者模式维护一个对目标对象状态感兴趣的对象列表，并在后者发生变化时通知前者。
- en: While the MVC pattern may implement the same function logic of updating views
    when the model changes, the observer pattern is more effective at maintaining
    and managing the list of subscribers for a given publisher, making it easy to,
    for example, add or remove subscribers.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虽然MVC模式可能在模型变化时实现更新视图的相同功能逻辑，但观察者模式在维护和管理特定发布者的订阅者列表方面更为有效，这使得例如添加或删除订阅者变得容易。
- en: We implement data formatters that display an object in different ways. Here,
    we have multiple subscribing formatters that are interested in a publishing default
    formatter. When the default formatter is updated, the subscribers are notified
    and proceed with their respective logic.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们实现了数据格式化器，以不同的方式显示对象。在这里，我们有多个订阅格式化器，它们对发布默认格式化器感兴趣。当默认格式化器更新时，订阅者会被通知并执行各自的逻辑。
