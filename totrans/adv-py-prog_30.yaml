- en: Assessments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Chapter 1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the order of importance: functionality, correctness, and efficiency.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An `assert` statement raises an error when the condition it checks for is not
    satisfied. As such, these statements are used in tests, where we determine whether
    a program computes and outputs values as it is supposed to.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A benchmark is a small but representative use case that can be used to estimate
    the speed of a program. Benchmarks can be used to compare different versions of
    a program to see if a new implementation leads to an improvement in efficiency.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In IPython or Jupyter notebooks, the `timeit` magic command, when placed in
    front of a code snippet, will run that code several times and record the running
    time of each run. The output of the command will show summary statistics of the
    recorded times so that we can estimate the average running time of the code we
    are interested in.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`cProfile` includes the following in its output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ncalls`: The number of times the function was called.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`tottime`: The total time spent in the function without considering the calls
    to other functions.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`cumtime`: The time in the function, including other function calls.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`percall`: The time spent for a single call of the function, which can be obtained
    by dividing the total or cumulative time by the number of calls.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`filename:lineno`: The filename and corresponding line numbers. This information
    is not available when calling C extensions modules.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The `dis` module analyzes the low-level bytecode and shows how Python code is
    converted. This is helpful when we are interested in the number of low-level instructions
    that correspond to a specific statement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Using IPython, we may profile the function as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Perhaps surprisingly, the unpacking and `p0` and `p1` takes two thirds of the
    execution time of the `close()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The most appropriate data structure for each of the following use cases is
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Mapping items to another set of items (with set being used in the most general
    sense): dictionaries.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Accessing, modifying, and appending elements: lists.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Maintaining a collection of unique elements: sets.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Keeping track of the minimum/maximum of a set (in the most general sense):
    heaps.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Appending and removing elements at the endpoints of a sequence (in the most
    general sense): deques.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Fast searching according to some similarity criterion (used by, for example,
    autocompletion engines): tries.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Caching is a design where we store expensive results in a temporary location,
    which can be in memory, on-disk, or a remote location. Memoization is specifically
    about storing and reusing the results of previous function calls in an application.
    As such, memoization is a form of caching.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Comprehensions and generators are optimized under the hood, so they are generally
    more efficient than explicit for loops. They are also more compact in code and
    are more readable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A dictionary would be a more appropriate data structure. If the numbers represented
    the counts, a `Counter` data structure would be the best data structure to use.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: NumPy offers efficient operations on multidimensional arrays, such as array
    creation, accessing elements (indexing) and slicing along specific axes, and optimized
    mathematical operations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using pandas, you can apply "mapping" operations to data, group, aggregate,
    and summarize data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: NumPy cannot handle labeled data, while pandas cannot process multidimensional
    data. `xarray` combines the best features of the two libraries to offer APIs the
    ability to handle multi-dimensional, labeled data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Static types allow the compiler to generate type-specific optimization, making
    the compiled code more efficient.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A memory view belongs to Cython's interface, which helps it work with different
    data types such as `byte`, `bytearray`, or `array.array` easier. Specifically,
    it offers a universal interface that simplifies the process of accessing the values
    that are stored in these different data types.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To profile Cython, we can use the annotated view to identify hard-to-find interpreter-related
    calls, as well as the familiar `cProfile` tool.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JIT compilers perform compilation at runtime rather than before running the
    code. This allows a piece of code that is expected to run many times to become
    more efficient, as recompilation is no longer necessary.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We use the signature of an `nb.jit` function to specify the data types that
    the function works with, which allows for further optimization for specific numerical
    data types. When Numba encounters other, unsupported types, it simply registers
    them as the generic `pyobject` type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tracing JIT compilation refers to the process of identifying the most intensive
    loops in a program, tracing the operations involved, and compiling the corresponding
    optimized, interpreter-free code. This allows us to actively optimize the most
    inefficient part of our code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main components of a typical machine learning pipeline are the predictive
    model (model assumptions, parameters), the loss function, and the optimization
    of the model parameters to minimize the loss function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The loss function may be minimized using gradient descent, in which we compute
    the gradient of the loss with the current values of the model parameters and adjust
    those values in the opposite direction of the gradient. JAX can compose this gradient
    loss function using `grad`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In our example, we utilized kernels to create nonlinear features from the features
    we were given. Naïve implementations of kernels are hard to vectorize, which may
    lead to inefficient for loops. JAX can automatically vectorize these kernels to
    address this problem.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At a high level, asynchronous programming aims to avoid idle waiting for unavailable
    resources. This typically involves interacting with slow and unpredictable resources.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A callback is a function that will be called at a given, later time. A future,
    on the other hand, is a more convenient abstraction that helps us keep track of
    requested resources and whether they are available. Futures are generally easier
    to use than callbacks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A reactive application should be responsive, elastic, resilient, and message-driven.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Multithreading cannot possibly speed up Python code due to the **global interpreter
    lock** (**GIL**). In this chapter, we examined different approaches to multiprocessing;
    that is, running code using multiple processes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the `Process` interface, we can have more low-level control by subclassing
    it. The `Pool` interface, on the other hand, offers a convenient way to distribute
    tasks across processes using the `apply` and `map` methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Theano and TensorFlow automatically translate our code into a parallelized version
    by taking advantage of special operations such as matrix multiplication.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**HTML** stands for **Hypertext Markup Language**, which is the standard and
    most common language for developing web pages and applications.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Most of the communication that's done via the internet (more specifically, the
    **World Wide Web** (**WWW**)) uses HTTP. In HTTP, request methods are used to
    convey information on what data is being requested and should be sent back from
    a server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: HTTP response status codes are three-digit numbers that signify the state of
    communication between a server and its client. They are split into five categories,
    each indicating a specific state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `requests` module manages the communication between a Python program and
    a web server through HTTP requests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A ping test is a tool that's typically used by web administrators to make sure
    that their sites are still available to clients. A ping test does this by making
    requests to the websites and analyzing the returned response status code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Both the process of making different requests to a web server and parsing the
    processing downloaded HTML source code are independent across separate requests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following considerations should be made when you''re developing applications
    that make concurrent web requests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The terms of service and data-collecting policies
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Error handling
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Updating your program regularly
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Avoiding over-scraping
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Image processing is the task of analyzing and manipulating digital image files
    to create new versions of the images, or to extract important data from them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The smallest unit of a digital image is a pixel, which typically contains an
    RGB value: a tuple of integers between 0 and 255.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Grayscaling is the processing of converting an image into gray colors by considering
    only the intensity of each pixel, represented by the amount of light available.
    It reduces the dimensionality of the image pixel matrix by mapping traditional
    three-dimensional color data to one-dimensional gray data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Thresholding replaces each pixel in an image with a white pixel if the pixel's
    intensity is greater than a previously specified threshold, and with a black pixel
    if the pixel's intensity is less than that threshold. After performing thresholding
    on an image, each pixel of that image can only hold two possible values, significantly
    reducing the complexity of image data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Heavy computational number-crunching processes are typically involved when it
    comes to image processing, as each image is a matrix of integer tuples. However,
    these processes can be executed independently, which suggests that the whole task
    should be made concurrent.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Some good practices for concurrent image processing are as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose the correct method (out of many)
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Spawn an appropriate number of processes
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Process the input/output concurrently
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Communication channels are used to denote both the physical wiring connection
    between different systems and the logical communication of data that facilitates
    computer networks. The latter is related to computing and is more relevant to
    the idea of asynchronous programming. Asynchronous programming can provide functionalities
    that complement the process of facilitating communication channels efficiently.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The media layers contain fairly low-level operations that interact with the
    underlying process of the communication channel, while the host layers deal with
    high-level data communication and manipulation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The transport layer is often viewed as the conceptual transition between the
    media layers and the host layers. It is responsible for sending data along end-to-end
    connections between different systems.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Server-wise, the `asyncio` module combines the abstraction of transport with
    the implementation of an asynchronous program. Specifically, via its `BaseTransport`
    and `BaseProtocol` classes, `asyncio` provides different ways to customize the
    underlying architecture of a communication channel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Together with the `aiohttp` module and, specifically, `aiohttp.ClientSession`,
    `asyncio` also offers efficiency and flexibility regarding client-side communication
    processes, via asynchronously making requests and reading the returned responses.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `aiofiles` module, which can work in conjunction with `asyncio` and `aiohttp`,
    helps facilitate asynchronous file reading/writing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A lack of (or mishandled) coordination between different lock objects can cause
    a deadlock, in which no progress can be made, and the program is locked in its
    current state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the dining philosophers problem, since each philosopher is holding only one
    fork with their left hand, they cannot proceed to eat or put down the fork they
    are holding. The only way a philosopher gets to eat their food is for their neighbor
    philosopher to put their fork down, which is only possible if they can eat their
    food; this creates a never-ending circle of conditions that can never be satisfied.
    This situation is, in essence, the nature of a deadlock, in which all the elements
    of a system are stuck in place and no progress can be made.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A deadlock is also defined by the necessary conditions that a concurrent program
    needs to have at the same time for a deadlock to occur. These conditions were
    first proposed by the computer scientist Edward G. Coffman Jr, and are therefore
    known as the Coffman conditions. These conditions are as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At least one resource has to be in a non-shareable state. This means that the
    resource is being held by an individual process (or thread) and cannot be accessed
    by others; the resource can only be accessed and held by a single process (or
    thread) at any given time. This condition is also known as mutual exclusion.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: One process (or thread) exists that is simultaneously accessing a resource and
    waiting for another that's held by other processes (or threads). In other words,
    this process (or thread) needs access to two resources to execute its instructions,
    one of which it is already holding, and the other of which it is waiting for from
    other processes (or threads). This condition is called hold and wait.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Resources can only be released by a process (or a thread) holding them if there
    are specific instructions for the process (or thread) to do so. This is to say
    that unless the process (or thread) voluntarily and actively releases the resource,
    the resource remains in a non-shareable state. This is the no preemption condition.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The final condition is called circular wait. As its name suggests, this condition
    specifies that a set of processes (or threads) exists where the first process
    (or thread) in the set is waiting for a resource to be released by the second
    process (or thread), which, in turn, needs to be waiting for the third process
    (or thread); finally, the last process (or thread) in the set is waiting for the
    first one.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Instead of accessing the resources arbitrarily, if the processes (or threads)
    are to access them in a predetermined, static order, the circular nature of the
    way that they acquire and wait for the resources will be eliminated. However,
    if you place enough locks on the resources of your concurrent program, it will
    become entirely sequential in its execution, and, combined with the overhead of
    concurrent programming functionalities, it will have an even worse speed than
    the purely sequential version of the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'By ignoring locks, our program resources effectively become shareable among
    different processes/threads in a concurrent program, thus eliminating the first
    of the four Coffman conditions: mutual exclusion. Doing this, however, can be
    seen as misunderstanding the problem completely. We know that locks are utilized
    so that processes and threads can access the shared resources in a program in
    a systematic, coordinated way, to avoid mishandling the data. Removing any locking
    mechanisms in a concurrent program means that the likelihood of the shared resources,
    which are now free from accessing limitations, being manipulated in an uncoordinated
    way (and therefore becoming corrupted) increases significantly.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In a livelock situation, the processes (or threads) in the concurrent program
    can switch their states, yet they simply switch back and forth infinitely, and
    no progress can be made.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Starvation is a problem in concurrent systems in which a process (or thread)
    cannot gain access to the necessary resources to proceed with its execution, which
    means it cannot make any progress.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Most of the time, a poorly coordinated set of scheduling instructions is the
    main cause of starvation. Some high-level causes for starvation may include the
    following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Processes (or threads) with high priorities dominate the execution flow in the
    CPU, so low-priority processes (or threads) are not allowed to execute their instructions.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Processes (or threads) with high priorities dominate the usage of non-shareable
    resources, so low-priority processes (or threads) are not allowed to execute their
    instructions. This situation is similar to the first one but addresses the priority
    of accessing resources, instead of the priority of execution itself.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Processes (or threads) with low priorities are waiting for resources to execute
    their instructions, but as soon as the resources become available, other processes
    (or threads) with higher priorities are immediately given access to them, so the
    low-priority processes (or threads) wait infinitely.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Deadlock situations can also lead to starvation, as the definition of starvation
    states that if a process (or thread) exists that is unable to make any progress
    because it cannot gain access to the necessary process, the process (or thread)
    is experiencing starvation. This is also illustrated in the dining philosophers'
    problem.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The readers-writers problem asks for a scheduling algorithm so that readers
    and writers can access the text file appropriately and efficiently, without mishandling/corrupting
    the data that's included.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first approach allows for multiple readers to access the text file simultaneously
    since readers simply read in the text file and do not alter the data in it. The
    problem with the first approach is that when a reader is accessing the text file
    and a writer is waiting for the file to be unlocked, if another reader starts
    its execution and wants to access the file, it will be given priority over the
    writer, who has already been waiting. Additionally, if more and more readers keep
    requesting access to the file, the writer will be waiting infinitely.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This approach implements the specification that once a writer requests to access
    the file, no reader should be able to jump in line and access the file before
    that writer. As opposed to what we see in the first solution to the readers-writers
    problem, this solution is giving priority to writers and, as a consequence, the
    readers are starved.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This approach implements a lock on both readers and writers. All threads will
    then be subject to the constants of the lock, so equal priority will be achieved
    among separate threads.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Some common solutions to starvation include the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Increasing the priority of low-priority threads.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Implementing a first-in-first-out thread queue.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Implementing a priority queue that also gives gradually increasing priority
    to threads that have been waiting in the queue for a long time.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If a thread has been able to access the shared resource many times, it should
    be given less priority.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Critical sections indicate shared resources that are accessed by multiple processes
    or threads in a concurrent application, which can lead to unexpected, and even
    erroneous, behaviors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A race condition occurs when two or more threads/processes access and alter
    a shared resource simultaneously, resulting in mishandled and corrupted data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The root cause of a race condition is multiple threads/processes reading in
    and altering a shared resource simultaneously. When all of the threads/processes
    finish their execution, only the result of the last thread/process is registered.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since race conditions arise when multiple threads or processes access and write
    to a shared resource simultaneously, the solution is to isolate the execution
    of different threads/processes, especially when interacting with the shared resource.
    With locks, we can turn a shared resource in a concurrent program into a critical
    section, whose data integrity is guaranteed to be protected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There are several disadvantages to using locks: with enough locks implemented
    in a concurrent program, the whole program may become entirely sequential; locks
    don''t lock anything.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The problems that race conditions raise in real-life systems and applications
    are as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Security: A race condition can be both exploited as a security vulnerability
    (to give external agents illegal access to a system) and used as random key generation,
    for security processes.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Operating systems: A race condition occurring when two agents (users and applications)
    interact with the same memory space can lead to unpredictable behaviors.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Networking: In networking, a race condition can lead to giving multiple users
    powerful privileges in a network.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++ associates a variable with its value by simply writing the value to the
    memory location of the variable; Python has its variables reference point to the
    memory location of the values that they hold. For this reason, Python needs to
    maintain a reference count for every value in its memory space.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To avoid race conditions and, consequently, value reference counts from being
    corrupted, the GIL is implemented so that only one thread can access and mutate
    the counts at any given time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The GIL effectively prevents multiple threads from taking advantage of the CPU
    and executing CPU-bound instructions at the same time. This means that if multiple
    threads that are meant to be executed concurrently are CPU-bound, they will be
    executed sequentially.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There are a few ways to deal with the GIL in your Python applications; namely,
    implementing multiprocessing instead of multithreading and utilizing other, alternative
    Python interpreters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The factory pattern makes it easy to keep track of the objects that are created
    within a program. Another benefit lies in the separation of code, which creates
    an object and the code that the object uses.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There are two forms of the factory pattern: the factory method and the abstract
    method. The former is used to handle the creation of a single object, while the
    latter is a group of factory methods.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should start with the factory method first since it is the simpler of the
    two. If you find yourself needing many factory methods, then you should start
    thinking about grouping them into different abstract methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The builder pattern helps manage objects that contain many individual components
    that need to be created sequentially. The pattern allows you to reuse a construction
    multiple times as well since it decouples an object's construction and the object
    itself.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Many applications, such as HTML page generators, document converters, and UI
    form creators, are implemented with the builder pattern.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The builder pattern uses a director to create an object via multiple steps sequentially,
    while the factory pattern creates an object in a single step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The prototype pattern helps us create objects that are based on an existing
    object (or prototype) via cloning. This can easily be done in Python using the
    `copy` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Objects in a database need to be duplicated many times, depending on the application
    and its users. This may be an expensive operation without prototypes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The singleton pattern is helpful when we want to implement a class that should
    only have one instance. This is useful, for example, when we'd like to maintain
    the global state of a Python program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The singleton pattern may be used to control concurrent access to a shared resource,
    preventing many concurrency-based bugs and errors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The decorator pattern specifies the usage and responsibilities of an object
    dynamically in a transparent and readable way.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Python has a built-in decorator feature, allowing programmers to extend the
    functionalities of a function, method, or class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the decorator pattern, we can implement memoization with minimal code,
    which, as we have seen in the main text, helps keep the computation of Fibonacci
    numbers fast and its code readable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The bridge pattern is useful when there is a need to share an implementation
    among different objects without having to implement individual specialized classes.
    This is typically done with either an abstract class that generalizes the different
    use cases or the individual specialized classes themselves.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The adapter is generally used to make two incompatible interfaces compatible,
    while the bridge abstracts out the generalization of different classes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We define an abstract content fetcher class, from which two specialized classes
    inherit: a local file fetcher and a URL fetcher.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The façade pattern helps hide the inner implementation of an application and
    only exposing the necessary interface. This is particularly important when we
    are working with a large code base but our user only needs to interact with a
    small portion of our code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When we need to make a change to an application, the abstraction that the façade
    pattern provides helps keep the client code separate and safe, which is useful
    in making the client side unaffected by pending software changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The operating system class works as a façade, hiding access to the different
    server classes from client code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The flyweight pattern is designed to keep memory usage at a minimum by sharing
    resources among similar objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The MVC pattern generalizes a common structure among different applications
    with a model, a view, and a controller. This helps prevent mixing the backend
    logic with user interfaces.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The proxy pattern is useful in requiring the necessary code to be run before
    an important object is accessed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The chain of responsibility pattern gracefully handles an unknown number of
    requests or events that our program needs to process. This is useful in event-based
    logic such as purchase applications and shipping systems.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In our system, if an object does not know how to handle a given request, it
    passes the request along the chain. As we have seen, a `close` event cannot be
    handled directly by `SendDialog` and `MsgText` and is passed to `MainWindow`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The chain of responsibility pattern may not be useful if there are multiple
    requests, but they may be processed by a single object. This renders all the bookkeeping
    that's done by the pattern useless.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The command pattern helps encapsulate operational logic (copy, paste, undo,
    redo, and so on) in an object. This leads to better abstraction and management
    of the logical steps to be taken for each operation, such as grouping multiple
    operations and implementing macros.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The command pattern abstracts out the implementation of the operations that
    are used, so any client code that executes it does not need to know about the
    details of their implementation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In our example, we implemented an abstraction on top of various functionalities
    provided by the `os` module. A particular feature is its undoing function. Moreover,
    as commands have a consistent interface, grouping them can be done with ease.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The observer pattern maintains a list of objects that are interested in the
    state of a target object and notifies the former when the latter changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: While the MVC pattern may implement the same function logic of updating views
    when the model changes, the observer pattern is more effective at maintaining
    and managing the list of subscribers for a given publisher, making it easy to,
    for example, add or remove subscribers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We implement data formatters that display an object in different ways. Here,
    we have multiple subscribing formatters that are interested in a publishing default
    formatter. When the default formatter is updated, the subscribers are notified
    and proceed with their respective logic.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
