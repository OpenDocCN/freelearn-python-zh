<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0;Custom Template Filters and Tags"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Custom Template Filters and Tags</h1></div></div></div><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Following conventions for your own template filters and tags</li><li class="listitem" style="list-style-type: disc">Creating a template filter to show how many days have passed since a post was published</li><li class="listitem" style="list-style-type: disc">Creating a template filter to extract the first media object</li><li class="listitem" style="list-style-type: disc">Creating a template filter to humanize URLs</li><li class="listitem" style="list-style-type: disc">Creating a template tag to include a template if it exists</li><li class="listitem" style="list-style-type: disc">Creating a template tag to load a QuerySet in a template</li><li class="listitem" style="list-style-type: disc">Creating a template tag to parse content as a template</li><li class="listitem" style="list-style-type: disc">Creating a template tag to modify request query parameters</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec55"/>Introduction</h1></div></div></div><p>As you know, Django has an extensive template system with features such as template inheritance, filters to change the representation of values, and tags for presentational logic. Moreover, Django allows you to add your own template filters and tags to your apps. Custom filters or tags should be located in a template-tag library file under the <code class="literal">templatetags</code> Python package in your app. Then, your template-tag library can be loaded in any template with a <code class="literal">{% load %}</code> template tag. In this chapter, we will create several useful filters and tags that will give more control to template editors.</p><p>To see the template tags of this chapter in action, create a virtual environment, extract the code provided for this chapter there, run the development server, and visit <code class="literal">http://127.0.0.1:8000/en/</code> in a browser.</p></div></div>
<div class="section" title="Following conventions for your own template filters and tags"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec56"/>Following conventions for your own template filters and tags</h1></div></div></div><p>Custom template filters and tags can become a total mess if you don't have persistent guidelines to follow. Template filters and tags should serve template editors as much as possible. They should be both handy and flexible. In this recipe, we will take a look at some conventions that should be used when enhancing the functionality of the Django template system.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec182"/>How to do it...</h2></div></div></div><p>Follow these<a class="indexterm" id="id256"/> conventions when extending the<a class="indexterm" id="id257"/> Django template system:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Don't create or use custom template filters or tags when the logic for the page fits better in the view, context processors, or model methods. When your content is context-specific, such as a list of objects or object-detail view, load the object in the view. If you need to show some content on every page, create a context processor. Use custom methods of the model instead of template filters when you need to get some properties of an object that are not related to the context of the template.</li><li class="listitem">Name the template-tag library with the <code class="literal">_tags</code> suffix. When your app is named differently than your template-tag library, you can avoid ambiguous package importing problems.</li><li class="listitem">In the newly created library, separate the filters from tags, for example, using comments as shown the following code:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># utils/templatetags/utility_tags.py</strong></span>
# -*- coding: UTF-8 -*-
from __future__ import unicode_literals
from django import template
register = template.Library()

<span class="strong"><strong>### FILTERS ###</strong></span>
# .. your filters go here..

<span class="strong"><strong>### TAGS ###</strong></span>
# .. your tags go here..</pre></div></li><li class="listitem">When creating advanced custom template tags, make sure that their syntax is easy to remember by including the following constructs:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">for [app_name.model_name]</code>: Include this construct in order to use a specific model</li><li class="listitem" style="list-style-type: disc"><code class="literal">using [template_name]</code>: Include this construct in order to use a template for the output of the template tag</li><li class="listitem" style="list-style-type: disc"><code class="literal">limit [count]</code>: Include this construct in order to limit the results to a specific amount</li><li class="listitem" style="list-style-type: disc"><code class="literal">as [context_variable]</code>: Include this construct in order to save the results to a context variable that can be reused multiple times</li></ul></div></li><li class="listitem">Try to <a class="indexterm" id="id258"/>avoid multiple values that<a class="indexterm" id="id259"/> are defined positionally in the template tags, unless they are self-explanatory. Otherwise, this will likely confuse the template developers.</li><li class="listitem">Make as many resolvable arguments as possible. Strings without quotes should be treated as context variables that need to be resolved or short words that remind you of the structure of the template tag components.</li></ol></div></div></div>
<div class="section" title="Creating a template filter to show how many days have passed since a post was published"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec57"/>Creating a template filter to show how many days have passed since a post was published</h1></div></div></div><p>Not all people keep track of the date and when talking about creation or modification dates of<a class="indexterm" id="id260"/> cutting-edge information; for many of us, it is convenient to read the time difference. For example, the blog entry was posted <span class="emphasis"><em>three days ago</em></span>, the news article was published <span class="emphasis"><em>today</em></span>, and the user last logged in <span class="emphasis"><em>yesterday</em></span>. In this recipe, we will create a template filter named <code class="literal">days_since</code>, which converts dates to humanized time differences.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec183"/>Getting ready</h2></div></div></div><p>Create the <code class="literal">utils</code> app and put it under <code class="literal">INSTALLED_APPS</code> in the settings, if you haven't done that yet. Then, create a <code class="literal">templatetags</code> Python package in this app (Python packages are directories with an empty <code class="literal">__init__.py</code> file).</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec184"/>How to do it...</h2></div></div></div><p>Create a <code class="literal">utility_tags.py</code> file with the following content:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># utils/templatetags/utility_tags.py</strong></span>
# -*- coding: UTF-8 -*-
from __future__ import unicode_literals
from datetime import datetime
from django import template
from django.utils.translation import ugettext_lazy as _
from django.utils.timezone import now as tz_now
register = template.Library()

### FILTERS ###

@register.filter
def days_since(value):
    """ Returns number of days between today and value."""

    today = tz_now().date()
    if isinstance(value, datetime.datetime):
        value = value.date()
    diff = today - value
    if diff.days &gt; 1:
        return _("%s days ago") % diff.days
    elif diff.days == 1:
        return _("yesterday")
    elif diff.days == 0:
        return _("today")
    else:
        # Date is in the future; return formatted date.
        return value.strftime("%B %d, %Y")</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec185"/>How it works...</h2></div></div></div><p>If you<a class="indexterm" id="id261"/> use this filter in a template as shown in the following code, it will render something similar to <span class="emphasis"><em>yesterday</em></span> or <span class="emphasis"><em>5 days ago</em></span>:</p><div class="informalexample"><pre class="programlisting">{% load utility_tags %}
{{ object.published|days_since }}</pre></div><p>You can apply this filter to values of the <code class="literal">date</code> and <code class="literal">datetime</code> types.</p><p>Each template-tag library has a register, where filters and tags are collected. Django filters are functions registered by the <code class="literal">@register.filter</code> decorator. By default, the filter in the template system will be named same as the function or other callable object. If you want, you can set a different name for the filter by passing the name to the decorator, as follows:</p><div class="informalexample"><pre class="programlisting">@register.filter(name="humanized_days_since")
def days_since(value):
    ...</pre></div><p>The filter itself is quite self-explanatory. At first, the current date is read. If the given value of the filter is of the <code class="literal">datetime</code> type, <code class="literal">date</code> is extracted. Then, the difference between today and the extracted value is calculated. Depending on the number of days, different string results are returned.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec186"/>There's more...</h2></div></div></div><p>This<a class="indexterm" id="id262"/> filter is also easy to extend in order to show the difference in time, such as <span class="emphasis"><em>just now</em></span>, <span class="emphasis"><em>7 minutes ago</em></span>, and <span class="emphasis"><em>3 hours ago</em></span>. Just operate on the <code class="literal">datetime</code> values instead of the date values.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec187"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Creating a template filter to extract the first media object</em></span> recipe</li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Creating a template filter to humanize URLs</em></span> recipe</li></ul></div></div></div>
<div class="section" title="Creating a template filter to extract the first media object"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec58"/>Creating a template filter to extract the first media object</h1></div></div></div><p>Imagine that you are developing a blog overview page, and for each post, you want to show<a class="indexterm" id="id263"/> images, music, or videos in that page taken from the content. In such a case, you need to extract the <code class="literal">&lt;figure&gt;</code>, <code class="literal">&lt;img&gt;</code>, <code class="literal">&lt;object&gt;</code>, <code class="literal">&lt;embed&gt;</code>, <code class="literal">&lt;video&gt;</code>, <code class="literal">&lt;audio&gt;</code>, and <code class="literal">&lt;iframe&gt;</code> tags from the HTML content of the post. In this recipe, we will see how to perform this using regular expressions in the <code class="literal">first_media</code> filter.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec188"/>Getting ready</h2></div></div></div><p>We will start with the <code class="literal">utils</code> app that should be set in <code class="literal">INSTALLED_APPS</code> in the settings and the <code class="literal">templatetags</code> package in this app.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec189"/>How to do it...</h2></div></div></div><p>In the <code class="literal">utility_tags.py</code> file, add the following content:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># utils/templatetags/utility_tags.py</strong></span>
# -*- coding: UTF-8 -*-
from __future__ import unicode_literals
import re
from django import template
from django.utils.safestring import mark_safe
register = template.Library()

### FILTERS ###


media_tags_regex = re.compile(
    r"&lt;figure[\S\s]+?&lt;/figure&gt;|"
    r"&lt;object[\S\s]+?&lt;/object&gt;|"
    r"&lt;video[\S\s]+?&lt;/video&gt;|"
    r"&lt;audio[\S\s]+?&lt;/audio&gt;|"
    r"&lt;iframe[\S\s]+?&lt;/iframe&gt;|"
    r"&lt;(img|embed)[^&gt;]+&gt;",
    re.MULTILINE
)

@register.filter
def first_media(content):
    """ Returns the first image or flash file from the html
 content """
    m = media_tags_regex.search(content)
    media_tag = ""
    if m:
        media_tag = m.group()
    return mark_safe(media_tag)</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec190"/>How it works...</h2></div></div></div><p>If the<a class="indexterm" id="id264"/> HTML content in the database is valid, when you put the following code in the template, it will retrieve the media tags from the content field of the object; otherwise, an empty string will be returned if no media is found:</p><div class="informalexample"><pre class="programlisting">{% load utility_tags %}
{{ object.content|first_media }}</pre></div><p>Regular expressions are powerful feature to search/replace patterns of text. At first, we will define the compiled regular expression as <code class="literal">media_file_regex</code>. In our case, we will search for all the possible media tags that can also occur in multiple lines.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="tip13"/>Tip</h3><p>Python strings can be concatenated without a plus (+) symbol.</p></div></div><p>Let's see how this regular expression works, as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Alternating patterns are separated by the pipe (<code class="literal">|</code>) symbol.</li><li class="listitem" style="list-style-type: disc">For possibly multiline tags, we will use the <code class="literal">[\S\s]+?</code> pattern that matches any symbol at least once; however, as little times as possible, until we find the the string that goes after it. Therefore, <code class="literal">&lt;figure[\S\s]+?&lt;/figure&gt;</code> searches for a <code class="literal">&lt;figure&gt;</code> tag and everything after it, until it finds the closing <code class="literal">&lt;/figure&gt;</code> tag.</li><li class="listitem" style="list-style-type: disc">Similarly, with the <code class="literal">[^&gt;]+</code> pattern, we search for any symbol except the greater than (<code class="literal">&gt;</code>) symbol at least once and as many times as possible.</li></ul></div><p>The <code class="literal">re.MULTILINE</code> flag ensures that the search will happen in multiple lines. Then, in the filter, we will perform a search for this regular expression pattern. By default, the result <a class="indexterm" id="id265"/>of the filter will show the <code class="literal">&lt;</code>, <code class="literal">&gt;</code>, and <code class="literal">&amp;</code> symbols escaped as the <code class="literal">&amp;lt;</code>, <code class="literal">&amp;gt;</code>, and <code class="literal">&amp;amp;</code> entities. However, we use the <code class="literal">mark_safe()</code> function that marks the result as safe and HTML-ready in order to be shown in the template without escaping.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec191"/>There's more...</h2></div></div></div><p>If you are interested in regular expressions, you can learn more about them in the official Python <a class="indexterm" id="id266"/>documentation at <a class="ulink" href="https://docs.python.org/2/library/re.html">https://docs.python.org/2/library/re.html</a>.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec192"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Creating a template filter to show how many days have passed since a post was published</em></span> recipe</li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Creating a template filter to humanize URLs</em></span> recipe</li></ul></div></div></div>
<div class="section" title="Creating a template filter to humanize URLs"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec59"/>Creating a template filter to humanize URLs</h1></div></div></div><p>Usually, common web users enter URLs in address fields without protocol and trailing slashes. In this recipe, we will create a <code class="literal">humanize_url</code> filter that is used to present URLs to the<a class="indexterm" id="id267"/> user in a shorter format, truncating very long addresses, similar to what Twitter does with the links in the tweets.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec193"/>Getting ready</h2></div></div></div><p>Similar to the previous recipes, we will start with the <code class="literal">utils</code> app that should be set in <code class="literal">INSTALLED_APPS</code> in the settings and contain the <code class="literal">templatetags</code> package.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec194"/>How to do it...</h2></div></div></div><p>In the <code class="literal">FILTERS</code> section of the <code class="literal">utility_tags.py</code> template library in the <code class="literal">utils</code> app, let's add a <code class="literal">humanize_url</code> filter and register it, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># utils/templatetags/utility_tags.py</strong></span>
# -*- coding: UTF-8 -*-
from __future__ import unicode_literals
import re
from django import template
register = template.Library()

### FILTERS ###

@register.filter
def humanize_url(url, letter_count):
    """ Returns a shortened human-readable URL """
    letter_count = int(letter_count)
    re_start = re.compile(r"^https?://")
    re_end = re.compile(r"/$")
    url = re_end.sub("", re_start.sub("", url))
    if len(url) &gt; letter_count:
        url = "%s…" % url[:letter_count - 1]
    return url</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec195"/>How it works...</h2></div></div></div><p>We <a class="indexterm" id="id268"/>can use the <code class="literal">humanize_url</code> filter in any template, as follows:</p><div class="informalexample"><pre class="programlisting">{% load utility_tags %}
&lt;a href="{{ object.website }}" target="_blank"&gt;
    {{ object.website|humanize_url:30 }}
&lt;/a&gt;</pre></div><p>The filter uses regular expressions to remove the leading protocol and trailing slash, shorten the URL to the given amount of letters, and add an ellipsis to the end if the URL doesn't fit in the specified letter count.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec196"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Creating a template filter to show how many days have passed since a post was published</em></span> recipe</li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Creating a template filter to extract the first media object</em></span> recipe</li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Creating a template tag to include a template if it exists</em></span> recipe</li></ul></div></div></div>
<div class="section" title="Creating a template tag to include a template if it exists"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec60"/>Creating a template tag to include a template if it exists</h1></div></div></div><p>Django has the <code class="literal">{% include %}</code> template tag that renders and includes another template. However, there is a problem in some situations, where an error is raised if the template does not<a class="indexterm" id="id269"/> exist. In this recipe, we will see how to create a <code class="literal">{% try_to_include %}</code> template tag that includes another template and fails silently if there is no such template.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec197"/>Getting ready</h2></div></div></div><p>We will <a class="indexterm" id="id270"/>start again with the <code class="literal">utils</code> app that is installed and ready for custom template tags.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec198"/>How to do it...</h2></div></div></div><p>Advanced custom template tags consist of two things: the function that is parsing the arguments of the template tag and the <code class="literal">Node</code> class that is responsible for the logic of the template tag as well as the output. Perform the following steps to create the <code class="literal">{% try_to_include %}</code> template tag:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, let's create the function parsing the template-tag arguments, as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># utils/templatetags/utility_tags.py</strong></span>
# -*- coding: UTF-8 -*-
from __future__ import unicode_literals
from django import template
from django.template.loader import get_template
register = template.Library()

### TAGS ###

@register.tag
def try_to_include(parser, token):
  """Usage: {% try_to_include "sometemplate.html" %}
  This will fail silently if the template doesn't exist.
  If it does exist, it will be rendered with the current
  context."""
  try:
    tag_name, template_name = token.split_contents()
  except ValueError:
    raise template.TemplateSyntaxError, \
      "%r tag requires a single argument" % \
      token.contents.split()[0]
  return IncludeNode(template_name)</pre></div></li><li class="listitem">Then, we need the <code class="literal">Node</code> class in the same file, as follows:<div class="informalexample"><pre class="programlisting">class IncludeNode(template.Node):
  def __init__(self, template_name):
    self.template_name = template_name

  def render(self, context):
    try:
      # Loading the template and rendering it
      template_name = template.resolve_variable(
        self. template_name, context)
      included_template = get_template(
        template_name
      ).render(context)
    except template.TemplateDoesNotExist:
      included_template = ""
    return included_template</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec199"/>How it works...</h2></div></div></div><p>The <code class="literal">{% try_to_include %}</code> template tag expects one argument, that is, <code class="literal">template_name</code>. Therefore, in the <code class="literal">try_to_include()</code> function, we try to assign the split contents of the token only to the <code class="literal">tag_name</code> variable (which is <code class="literal">try_to_include</code>) and the <code class="literal">template_name</code> variable. If this doesn't work, the template syntax error is raised. The<a class="indexterm" id="id271"/> function returns the <code class="literal">IncludeNode</code> object, which gets the <code class="literal">template_name</code> field for later use.</p><p>In the <code class="literal">render()</code> method of <code class="literal">IncludeNode</code>, we resolve the <code class="literal">template_name</code> variable. If a context variable was passed to the template tag, its value will be used here for <code class="literal">template_name</code>. If a quoted string was passed to the template tag, then the content in the quotes will be used for <code class="literal">template_name</code>.</p><p>Lastly, we will try to load the template and render it with the current template context. If that doesn't work, an empty string is returned.</p><p>There are at least two situations where we could use this template tag:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">It is used when including a template whose path is defined in a model, as follows:<div class="informalexample"><pre class="programlisting">{% load utility_tags %}
{% try_to_include object.template_path %}</pre></div></li><li class="listitem" style="list-style-type: disc">It is used when including a template whose path is defined with the <code class="literal">{% with %}</code> template tag somewhere high in the template context variable's scope. This is especially useful when you need to create custom layouts for plugins in the placeholder of a template in Django CMS:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>{# templates/cms/start_page.html #}</strong></span>
{% with editorial_content_template_path="cms/plugins/editorial_content/start_page.html" %}
    {% placeholder "main_content" %}
{% endwith %}

<span class="strong"><strong>{# templates/cms/plugins/editorial_content.html #}</strong></span>
{% load utility_tags %}

{% if editorial_content_template_path %}
    {% try_to_include editorial_content_template_path %}
{% else %}
    &lt;div&gt;
        &lt;!-- Some default presentation of
             editorial content plugin --&gt;
    &lt;/div&gt;
{% endif %}</pre></div></li></ul></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec200"/>There's more...</h2></div></div></div><p>You can use the <code class="literal">{% try_to_include %}</code> tag as well as the default <code class="literal">{% include %}</code> tag to include the templates that extend other templates. This is beneficial for large-scale portals, where you have different kinds of lists in which complex items share the same structure as widgets but have a different source of data.</p><p>For<a class="indexterm" id="id272"/> example, in the artist list template, you can include the artist item template, as follows:</p><div class="informalexample"><pre class="programlisting">{% load utility_tags %}
{% for object in object_list %}
    {% try_to_include "artists/includes/artist_item.html" %}
{% endfor %}</pre></div><p>This template will extend from the item base, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>{# templates/artists/includes/artist_item.html #}</strong></span>
{% extends "utils/includes/item_base.html" %}

{% block item_title %}
    {{ object.first_name }} {{ object.last_name }}
{% endblock %}</pre></div><p>The item base defines the markup for any item and also includes a Like widget, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>{# templates/utils/includes/item_base.html #}</strong></span>
{% load likes_tags %}

&lt;h3&gt;{% block item_title %}{% endblock %}&lt;/h3&gt;
{% if request.user.is_authenticated %}
    {% like_widget for object %}
{% endif %}</pre></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec201"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Creating templates for Django CMS</em></span> recipe in <a class="link" href="ch07.html" title="Chapter 7. Django CMS">Chapter 7</a>, <span class="emphasis"><em>Django CMS</em></span></li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Writing your own CMS plugin</em></span> recipe in <a class="link" href="ch07.html" title="Chapter 7. Django CMS">Chapter 7</a>, <span class="emphasis"><em>Django CMS</em></span></li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Implementing the Like widget</em></span> recipe in <a class="link" href="ch04.html" title="Chapter 4. Templates and JavaScript">Chapter 4</a>, <span class="emphasis"><em>Templates and JavaScript</em></span></li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Creating a template tag to load a QuerySet in a template</em></span> recipe</li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Creating a template tag to parse content as a template</em></span> recipe</li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Creating a template tag to modify request query parameters</em></span> recipe</li></ul></div></div></div>
<div class="section" title="Creating a template tag to load a QuerySet in a template"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec61"/>Creating a template tag to load a QuerySet in a template</h1></div></div></div><p>Most often, the content that should be shown on a webpage will have to be defined in the view. If this is the content to be shown on every page, it is logical to create a context processor. Another situation is where you need to show additional content such as the latest <a class="indexterm" id="id273"/>news or a random quote on some pages; for example, the starting page or the details page of an object. In this case, you can load the necessary content with the <code class="literal">{% get_objects %}</code> template tag, which we will implement in this recipe.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec202"/>Getting ready</h2></div></div></div><p>Once again, we will start with the <code class="literal">utils</code> app that should be installed and ready for custom template tags.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec203"/>How to do it...</h2></div></div></div><p>An advanced custom template tag consists of a function that parses arguments that are passed to the tag and a <code class="literal">Node</code> class that renders the output of the tag or modifies the template context. Perform the following steps to create the <code class="literal">{% get_objects %}</code> template tag:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, let's create the function parsing the template-tag arguments, as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># utils/templatetags/utility_tags.py</strong></span>
# -*- coding: UTF-8 -*-
from __future__ import unicode_literals
from django.db import models
from django import template
register = template.Library()

### TAGS ###

@register.tag
def get_objects(parser, token):
    """
    Gets a queryset of objects of the model specified
    by app and model names
    Usage:
        {% get_objects [&lt;manager&gt;.]&lt;method&gt; from
&lt;app_name&gt;.&lt;model_name&gt; [limit &lt;amount&gt;] as
        &lt;var_name&gt; %}
    Example:
        {% get_objects latest_published from people.Person
limit 3 as people %}
        {% get_objects site_objects.all from news.Article
        limit 3 as articles %}
        {% get_objects site_objects.all from news.Article
         as articles %}
    """
    amount = None
    try:
        tag_name, manager_method, str_from, appmodel, \
        str_limit, amount, str_as, var_name = \
            token.split_contents()
    except ValueError:
        try:
            tag_name, manager_method, str_from, appmodel, \
            str_as, var_name = token.split_contents()
        except ValueError:
            raise template.TemplateSyntaxError, \
                "get_objects tag requires a following "\
                "syntax: "\
                "{% get_objects [&lt;manager&gt;.]&lt;method&gt; "\
                "from &lt;app_ name&gt;.&lt;model_name&gt; "\
                "[limit &lt;amount&gt;] as &lt;var_name&gt; %}"
    try:
        app_name, model_name = appmodel.split(".")
    except ValueError:
        raise template.TemplateSyntaxError, \
            "get_objects tag requires application name "\
            "and model name separated by a dot"
    model = models.get_model(app_name, model_name)
    return ObjectsNode(
        model, manager_method, amount, var_name
    )</pre></div></li><li class="listitem">Then, we will create the <code class="literal">Node</code> class in the same file, as shown in the following code:<div class="informalexample"><pre class="programlisting">class ObjectsNode(template.Node):
    def __init__(
        self, model, manager_method, amount, var_name
    ):
        self.model = model
        self.manager_method = manager_method
        self.amount = amount
        self.var_name = var_name

    def render(self, context):
        if "." in self.manager_method:
            manager, method = \
                self.manager_method.split(".")
        else:
            manager = "_default_manager"
            method = self.manager_method

        qs = getattr(
            getattr(self.model, manager),
            method,
            self.model._default_manager.none,
        )()
        if self.amount:
            amount = template.resolve_variable(
                self.amount, context
            )
            context[self.var_name] = qs[:amount]
        else:
            context[self.var_name] = qs
        return ""</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec204"/>How it works...</h2></div></div></div><p>The <code class="literal">{% get_objects %}</code> template tag loads QuerySet  defined by the method of the manager from a <a class="indexterm" id="id274"/>specified app and model, limits the result to the specified amount, and saves the result to a context variable.</p><p>The following code is the simplest example of how to use the template tag that we have just created. It will load all news articles in any template using the following snippet:</p><div class="informalexample"><pre class="programlisting">{% load utility_tags %}
{% get_objects all from news.Article as all_articles %}
{% for article in all_articles %}
    &lt;a href="{{ article.get_url_path }}"&gt;{{ article.title }}&lt;/a&gt;
{% endfor %}</pre></div><p>This is using the <code class="literal">all()</code> method of the default <code class="literal">objects</code> manager of the <code class="literal">Article</code> model and it will sort the articles by the <code class="literal">ordering</code> attribute defined in the <code class="literal">Meta</code> class of the model.</p><p>A more<a class="indexterm" id="id275"/> advanced example would be required to create a custom manager with a custom method to query the objects from the database. A manager is an interface that provides the database query operations to models. Each model has at least one manager called <code class="literal">objects</code> by default. As an example, let's create an <code class="literal">Artist</code> model that has a draft or published status and a new <code class="literal">custom_manager</code> that allows you to select random published artists:</p><div class="informalexample"><pre class="programlisting"># artists/models.py
# -*- coding: UTF-8 -*-
from __future__ import unicode_literals
from django.db import models
from django.utils.translation import ugettext_lazy as _

STATUS_CHOICES = (
    ("draft", _("Draft"),
    ("published", _("Published"),
)
class ArtistManager(models.Manager):
    def random_published(self):
        return self.filter(status="published").order_by("?")

class Artist(models.Model):
    # ...
    status = models.CharField(_("Status"), max_length=20, 
        choices=STATUS_CHOICES)
    custom_manager =  ArtistManager()</pre></div><p>To load a random published artist, you add the following snippet to any template:</p><div class="informalexample"><pre class="programlisting">{% load utility_tags %}
{% get_objects custom_manager.random_published from artists.Artist limit 1 as random_artists %}
{% for artist in random_artists %}
    {{ artist.first_name }} {{ artist.last_name }}
{% endfor %}</pre></div><p>Let's look at the code of the <code class="literal">{% get_objects %}</code> template tag. In the parsing function, there is one of the two formats expected; with the limit and without it. The string is parsed, the model is recognized, and then the components of the template tag are passed to the <code class="literal">ObjectNode</code> class.</p><p>In the <code class="literal">render()</code> method of the <code class="literal">Node</code> class, we will check the manager's name and its method's name. If this is not defined, <code class="literal">_default_manager</code> will be used, which is an automatic property of any model injected by Django and points to the first available <code class="literal">models.Manager()</code> instance. In most cases, <code class="literal">_default_manager</code> will be same as <code class="literal">objects</code>. After that, we will call the method of the manager and fall back to empty <code class="literal">QuerySet</code> if the<a class="indexterm" id="id276"/> method doesn't exist. If a limit is defined, we will resolve the value of it and limit <code class="literal">QuerySet</code>. Lastly, we will save the <code class="literal">QuerySet</code> to the context variable.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec205"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Creating a template tag to include a template if it exists</em></span> recipe</li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Creating a template tag to parse content as a template</em></span> recipe</li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Creating a template tag to modify request query parameters</em></span> recipe</li></ul></div></div></div>
<div class="section" title="Creating a template tag to parse content as a template"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec62"/>Creating a template tag to parse content as a template</h1></div></div></div><p>In this recipe, we will create a <code class="literal">{% parse %}</code> template tag, which will allow you to put template <a class="indexterm" id="id277"/>snippets in the database. This is valuable when you want to provide different content for authenticated and unauthenticated users, when you want to include a personalized salutation or you don't want to hardcode the media paths in the database.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec206"/>Getting ready</h2></div></div></div><p>As usual, we will start with the <code class="literal">utils</code> app that should be installed and ready for custom template tags.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec207"/>How to do it...</h2></div></div></div><p>An advanced custom template tag consists of a function that parses the arguments that are passed to the tag and a <code class="literal">Node</code> class that renders the output of the tag or modifies the template context. Perform the following steps to create them:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, let's create the function parsing the arguments of the template tag, as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># utils/templatetags/utility_tags.py</strong></span>
# -*- coding: UTF-8 -*-
from __future__ import unicode_literals
from django import template
register = template.Library()

### TAGS ###

@register.tag
def parse(parser, token):
    """
    Parses the value as a template and prints it or
    saves to a variable
    Usage:
        {% parse &lt;template_value&gt; [as &lt;variable&gt;] %}
    Examples:
        {% parse object.description %}
        {% parse header as header %}
        {% parse "{{ MEDIA_URL }}js/" as js_url %}
    """
    bits = token.split_contents()
    tag_name = bits.pop(0)
    try:
        template_value = bits.pop(0)
        var_name = None
        if len(bits) == 2:
            bits.pop(0)  # remove the word "as"
            var_name = bits.pop(0)
    except ValueError:
        raise template.TemplateSyntaxError, \
            "parse tag requires a following syntax: "\
            "{% parse &lt;template_value&gt; [as &lt;variable&gt;] %}"

    return ParseNode(template_value, var_name)</pre></div></li><li class="listitem">Then, we<a class="indexterm" id="id278"/> will create the <code class="literal">Node</code> class in the same file, as follows:<div class="informalexample"><pre class="programlisting">class ParseNode(template.Node):
    def __init__(self, template_value, var_name):
        self.template_value = template_value
        self.var_name = var_name

    def render(self, context):
        template_value = template.resolve_variable(
            self.template_value, context)
        t = template.Template(template_value)
        context_vars = {}
        for d in list(context):
            for var, val in d.items():
                context_vars[var] = val
        result = t.render(template.RequestContext(
            context["request"], context_vars))
        if self.var_name:
            context[self.var_name] = result
            return ""
        return result</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec208"/>How it works...</h2></div></div></div><p>The <code class="literal">{% parse %}</code> template tag allows you to parse a value as a template and render it immediately or save it as a context variable.</p><p>If we have <a class="indexterm" id="id279"/>an object with a description field, which can contain template variables or logic, we can parse and render it using the following code:</p><div class="informalexample"><pre class="programlisting">{% load utility_tags %}
{% parse object.description %}</pre></div><p>It is also possible to define a value in order to parse using a quoted string as shown in the following code:</p><div class="informalexample"><pre class="programlisting">{% load utility_tags %}
{% parse "{{ STATIC_URL }}site/img/" as img_path %}
&lt;img src="{{ img_path }}someimage.png" alt="" /&gt;</pre></div><p>Let's take a look at the code of the <code class="literal">{% parse %}</code> template tag. The parsing function checks the arguments of the template tag bit by bit. At first, we expect the <code class="literal">parse</code> name, then the template value, and at last we expect the optional <code class="literal">as</code> word followed by the context variable name. The template value and variable name are passed to the <code class="literal">ParseNode</code> class. The <code class="literal">render()</code> method of that class, at first, resolves the value of the template variable and creates a template object out of it. Then, it renders the template with all the context variables. If the variable name is defined, the result is saved to it; otherwise, the result is shown immediately.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec209"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Creating a template tag to include a template if it exists</em></span> recipe</li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Creating a template tag to load a QuerySet in a template</em></span> recipe</li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Creating a template tag to modify request query parameters</em></span> recipe</li></ul></div></div></div>
<div class="section" title="Creating a template tag to modify request query parameters"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec63"/>Creating a template tag to modify request query parameters</h1></div></div></div><p>Django has<a class="indexterm" id="id280"/> a convenient and flexible system to create canonical and clean URLs just by adding regular expression rules to the URL configuration files. However, there is a lack of built-in mechanisms in order to manage query parameters. Views such as search or filterable object lists need to accept query parameters to drill down through the filtered results using another parameter or to go to another page. In this recipe, we will create the <code class="literal">{% modify_query %}</code>, <code class="literal">{% add_to_query %}</code>, and <code class="literal">{% remove_from_query %}</code> template tags, which let you add, change, or remove the parameters of the current query.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec210"/>Getting ready</h2></div></div></div><p>Once <a class="indexterm" id="id281"/>again, we start with the <code class="literal">utils</code> app that should be set in <code class="literal">INSTALLED_APPS</code> and contain the <code class="literal">templatetags</code> package.</p><p>Also, make sure that you have the <code class="literal">request</code> context processor set for the <code class="literal">TEMPLATE_CONTEXT_PROCESSORS</code> setting, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># conf/base.py or settings.py</strong></span>
TEMPLATE_CONTEXT_PROCESSORS = (
    "django.contrib.auth.context_processors.auth",
    "django.core.context_processors.debug",
    "django.core.context_processors.i18n",
    "django.core.context_processors.media",
    "django.core.context_processors.static",
    "django.core.context_processors.tz",
    "django.contrib.messages.context_processors.messages",
<span class="strong"><strong>    "django.core.context_processors.request",</strong></span>
)</pre></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec211"/>How to do it...</h2></div></div></div><p>For these template tags, we will be using the <code class="literal">simple_tag</code> decorator that parses the components and requires you to just define the rendering function, as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">At first, we will create the <code class="literal">{% modify_query %}</code> template tag:<div class="informalexample"><pre class="programlisting"># utils/templatetags/utility_tags.py
# -*- coding: UTF-8 -*-
from __future__ import unicode_literals
import urllib
from django import template
from django.utils.encoding import force_str
register = template.Library()

### TAGS ###

@register.simple_tag(takes_context=True)
def modify_query(
    context, *params_to_remove, **params_to_change
):
    """ Renders a link with modified current query
    parameters """
    query_params = []
    for key, value_list in \
        context["request"].GET._iterlists():
        if not key in params_to_remove:
            # don't add key-value pairs for
            # params_to_change
            if key in params_to_change:
                query_params.append(
                    (key, params_to_change[key])
                )
                params_to_change.pop(key)
            else:
                # leave existing parameters as they were
                # if not mentioned in the params_to_change
                for value in value_list:
                    query_params.append((key, value))
    # attach new params
    for key, value in params_to_change.items():
        query_params.append((key, value))
    query_string = context["request"].path
    if len(query_params):
        query_string += "?%s" % urllib.urlencode([
            (key, force_str(value))
            for (key, value) in query_params if value
        ]).replace("&amp;", "&amp;amp;")
    return query_string</pre></div></li><li class="listitem">Then, let's <a class="indexterm" id="id282"/>create the <code class="literal">{% add_to_query %}</code> template tag:<div class="informalexample"><pre class="programlisting">@register.simple_tag(takes_context=True)
def add_to_query(
    context, *params_to_remove, **params_to_add
):
    """ Renders a link with modified current query
    parameters """
    query_params = []
    # go through current query params..
    for key, value_list in \
        context["request"].GET._iterlists():
        if not key in params_to_remove:
            # don't add key-value pairs which already
            # exist in the query
            if key in params_to_add and \
            unicode(params_to_add[key]) in value_list:
                params_to_add.pop(key)
            for value in value_list:
                query_params.append((key, value))
    # add the rest key-value pairs
    for key, value in params_to_add.items():
        query_params.append((key, value))
    # empty values will be removed
    query_string = context["request"].path
    if len(query_params):
        query_string += "?%s" % urllib.urlencode([
            (key, force_str(value))
            for (key, value) in query_params if value
        ]).replace("&amp;", "&amp;amp;")
    return query_string</pre></div></li><li class="listitem">Lastly, <a class="indexterm" id="id283"/>let's create the <code class="literal">{% remove_from_query %}</code> template tag:<div class="informalexample"><pre class="programlisting">@register.simple_tag(takes_context=True)
def remove_from_query(context, *args, **kwargs):
    """ Renders a link with modified current query
    parameters """
    query_params = []
    # go through current query params..
    for key, value_list in \
        context["request"].GET._iterlists():
        # skip keys mentioned in the args
        if not key in args:
            for value in value_list:
                # skip key-value pairs mentioned in kwargs
                if not (key in kwargs and
                  unicode(value) == unicode(kwargs[key])):
                    query_params.append((key, value))
    # empty values will be removed
    query_string = context["request"].path
    if len(query_params):
        query_string = "?%s" % urllib.urlencode([
            (key, force_str(value))
            for (key, value) in query_params if value
        ]).replace("&amp;", "&amp;amp;")
    return query_string</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec212"/>How it works...</h2></div></div></div><p>All the three created template tags behave similarly. At first, they read the current query parameters from the <code class="literal">request.GET</code> dictionary-like <code class="literal">QueryDict</code> object to a new list of key value <code class="literal">query_params</code> tuples. Then, the values are updated depending on the positional arguments and keyword arguments. Lastly, the new query string is formed, all spaces and special<a class="indexterm" id="id284"/> characters are URL-encoded, and the ampersands connecting the query parameters are escaped. This new query string is returned to the template.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="tip14"/>Tip</h3><p>To read more <a class="indexterm" id="id285"/>about the <code class="literal">QueryDict</code> objects, refer to the official Django documentation at <a class="ulink" href="https://docs.djangoproject.com/en/1.8/ref/request-response/#querydict-objects">https://docs.djangoproject.com/en/1.8/ref/request-response/#querydict-objects</a>.</p></div></div><p>Let's take a look at an example of how the <code class="literal">{% modify_query %}</code> template tag can be used. Positional arguments in the template tag define which query parameters are to be removed and the keyword arguments define which query parameters are to be modified at the current query. If the current URL is <code class="literal">http://127.0.0.1:8000/artists/?category=fine-art&amp;page=5</code>, we can use the following template tag to render a link that goes to the next page:</p><div class="informalexample"><pre class="programlisting">{% load utility_tags %}
&lt;a href="{% modify_query page=6 %}"&gt;6&lt;/a&gt;</pre></div><p>The following snippet is the output rendered using the preceding template tag:</p><div class="informalexample"><pre class="programlisting">&lt;a href="/artists/?category=fine-art&amp;amp;page=6"&gt;6&lt;/a&gt;</pre></div><p>We can also use the following example to render a link that resets pagination and goes to another category, <span class="emphasis"><em>Sculpture</em></span>, as follows:</p><div class="informalexample"><pre class="programlisting">{% load utility_tags i18n %}
&lt;a href="{% modify_query "page" category="sculpture" %}"&gt;{% trans "Sculpture" %}&lt;/a&gt;</pre></div><p>The following snippet is the output rendered using the preceding template tag:</p><div class="informalexample"><pre class="programlisting">&lt;a href="/artists/?category=sculpture"&gt;Sculpture&lt;/a&gt;</pre></div><p>With the <code class="literal">{% add_to_query %}</code> template tag, you can add the parameters step-by-step with the same name. For example, if the current URL is <code class="literal">http://127.0.0.1:8000/artists/?category=fine-art</code>, you can add another category, <span class="emphasis"><em>Sculpture</em></span>, with the help of the following link:</p><div class="informalexample"><pre class="programlisting">{% load utility_tags i18n %}
&lt;a href="{% add_to_query "page" category="sculpture" %}"&gt;{% trans "Sculpture" %}&lt;/a&gt;</pre></div><p>This will be rendered in the template as shown in the following snippet:</p><div class="informalexample"><pre class="programlisting">&lt;a href="/artists/?category=fine-art&amp;amp;category=sculpture"&gt;Sculpture&lt;/a&gt;</pre></div><p>Lastly, with the help of the <code class="literal">{% remove_from_query %}</code> template tag, you can remove the parameters step-by-step with the same name. For example, if the current URL is <code class="literal">http://127.0.0.1:8000/artists/?category=fine-art&amp;category=sculpture</code>, you <a class="indexterm" id="id286"/>can remove the <span class="emphasis"><em>Sculpture</em></span> category with the help of the following link:</p><div class="informalexample"><pre class="programlisting">{% load utility_tags i18n %}
&lt;a href="{% remove_from_query "page" category="sculpture" %}"&gt;&lt;span class="glyphicon glyphicon-remove"&gt;&lt;/span&gt; {% trans "Sculpture" %}&lt;/a&gt;</pre></div><p>This will be rendered in the template as follows:</p><div class="informalexample"><pre class="programlisting">&lt;a href="/artists/?category=fine-art"&gt;&lt;span class="glyphicon glyphicon-remove"&gt;&lt;/span&gt; Sculpture&lt;/a&gt;</pre></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec213"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Filtering object lists</em></span> recipe in <a class="link" href="ch03.html" title="Chapter 3. Forms and Views">Chapter 3</a>, <span class="emphasis"><em>Forms and Views</em></span></li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Creating a template tag to include a template if it exists</em></span> recipe</li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Creating a template tag to load a QuerySet in a template</em></span> recipe</li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Creating a template tag to parse content as a template</em></span> recipe</li></ul></div></div></div></body></html>