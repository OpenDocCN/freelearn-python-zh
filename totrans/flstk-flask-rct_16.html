<html><head></head><body>
<div id="_idContainer113">
<h1 class="chapter-number" id="_idParaDest-288"><a id="_idTextAnchor328"/><span class="koboSpan" id="kobo.1.1">16</span></h1>
<h1 id="_idParaDest-289"><a id="_idTextAnchor329"/><span class="koboSpan" id="kobo.2.1">Containerization and Flask Application Deployment</span></h1>
<p><span class="koboSpan" id="kobo.3.1">After a long journey, we’ve reached the last chapter! </span><span class="koboSpan" id="kobo.3.2">We’re thrilled beyond words! </span><span class="koboSpan" id="kobo.3.3">Right now, we are about to embark on the last lap of showcasing our full stack web application to the world. </span><span class="koboSpan" id="kobo.3.4">In today’s modern software development sphere, the pace of containerization adoption is </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">rapidly increasing.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">According to Gartner’s predictions, the adoption of containerized applications in production will increase significantly, with more than 75% of global organizations expected to utilize them by 2022, a notable increase from the less than 30% reported in </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">2020 (</span></span><a href="https://www.gartner.com/en/documents/3985796"><span class="No-Break"><span class="koboSpan" id="kobo.7.1">https://www.gartner.com/en/documents/3985796</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.8.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.9.1">Containerization and the deployment of software applications have become essential skills needed for developers to stay modern and in demand. </span><span class="koboSpan" id="kobo.9.2">Developers who have the skills and knowledge to containerize and deploy software applications are better equipped to meet the demands of modern software development practices, stay up to date with industry trends, and remain competitive in the </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">job market.</span></span></p>
<p><span class="koboSpan" id="kobo.11.1">Containerization </span><a id="_idIndexMarker1122"/><span class="koboSpan" id="kobo.12.1">allows developers to package applications and required dependencies into a standardized and portable container that can run consistently across different computing environments. </span><span class="koboSpan" id="kobo.12.2">And, of course, deployment ensures </span><a id="_idIndexMarker1123"/><span class="koboSpan" id="kobo.13.1">that your application gets to the production environment, where it can be used by </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">end users.</span></span></p>
<p><span class="koboSpan" id="kobo.15.1">In this chapter, we will discuss containerization as a revolution changing the information technology industry. </span><span class="koboSpan" id="kobo.15.2">We will touch on the significance and benefits of containerization in software development, as well as exploring the issues </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">it tackles.</span></span></p>
<p><span class="koboSpan" id="kobo.17.1">Furthermore, we will delve into one of the containerization platforms in the software development</span><a id="_idIndexMarker1124"/><span class="koboSpan" id="kobo.18.1"> industry, called </span><strong class="bold"><span class="koboSpan" id="kobo.19.1">Docker</span></strong><span class="koboSpan" id="kobo.20.1">. </span><span class="koboSpan" id="kobo.20.2">We will introduce Docker and use it to containerize both the React frontend and the Flask backend. </span><span class="koboSpan" id="kobo.20.3">We will discuss Docker’s benefits and why it is popular </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">among developers.</span></span></p>
<p><span class="koboSpan" id="kobo.22.1">By the end of the chapter, you will understand the importance of containerization in modern software development, and you will be able to package React and Flask applications into containers ready to be shipped </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">and shared.</span></span></p>
<p><span class="koboSpan" id="kobo.24.1">Finally, you will learn how to use </span><strong class="bold"><span class="koboSpan" id="kobo.25.1">Amazon Web Services</span></strong><span class="koboSpan" id="kobo.26.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.27.1">AWS</span></strong><span class="koboSpan" id="kobo.28.1">) Elastic Beanstalk to deploy React-Flask applications leveraging the AWS fully managed cloud platform, which allows developers to deploy, manage, and scale their web applications and services </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">with ease.</span></span></p>
<p><span class="koboSpan" id="kobo.30.1">In this chapter, we’ll cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.32.1">What </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">is containerization?</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.34.1">Introducing Docker</span></span></li>
<li><span class="koboSpan" id="kobo.35.1">Dockerizing React and </span><span class="No-Break"><span class="koboSpan" id="kobo.36.1">Flask applications</span></span></li>
<li><span class="koboSpan" id="kobo.37.1">Understanding AWS Elastic </span><span class="No-Break"><span class="koboSpan" id="kobo.38.1">Container Registry</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.39.1">Using </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.40.1">docker-compose</span></strong></span></li>
<li><span class="koboSpan" id="kobo.41.1">Deploying React and Flask applications to AWS </span><span class="No-Break"><span class="koboSpan" id="kobo.42.1">Elastic Beanstalk</span></span></li>
</ul>
<h1 id="_idParaDest-290"><a id="_idTextAnchor330"/><span class="koboSpan" id="kobo.43.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.44.1">The complete code for this chapter is available on GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">at: </span></span><a href="https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter16"><span class="No-Break"><span class="koboSpan" id="kobo.46.1">https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter16</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.47.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.48.1">Due to page count constraints, some of the long code blocks have been shortened. </span><span class="koboSpan" id="kobo.48.2">Please refer to GitHub for the </span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">complete code.</span></span></p>
<h1 id="_idParaDest-291"><a id="_idTextAnchor331"/><span class="koboSpan" id="kobo.50.1">What is containerization?</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.51.1">Containerization</span></strong><span class="koboSpan" id="kobo.52.1"> is a </span><a id="_idIndexMarker1125"/><span class="koboSpan" id="kobo.53.1">software development practice that involves packaging an application and required dependencies into a self-contained unit called a </span><strong class="bold"><span class="koboSpan" id="kobo.54.1">container</span></strong><span class="koboSpan" id="kobo.55.1">. </span><span class="koboSpan" id="kobo.55.2">A container </span><a id="_idIndexMarker1126"/><span class="koboSpan" id="kobo.56.1">is an isolated and lightweight runtime environment that provides a consistent and reproducible way to run an application across different </span><span class="No-Break"><span class="koboSpan" id="kobo.57.1">computing environments.</span></span></p>
<p><span class="koboSpan" id="kobo.58.1">Let’s say you have developed a web application using the Flask framework on your local machine running on MacOS. </span><span class="koboSpan" id="kobo.58.2">You want to deploy this application to a server running Ubuntu Linux in a production environment. </span><span class="koboSpan" id="kobo.58.3">However, there may be differences in the versions of the operating system, dependencies, or other system configurations that could affect the behavior of </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">your application.</span></span></p>
<p><span class="koboSpan" id="kobo.60.1">By packaging your Flask application and all the required dependencies into a container, you can ensure that the application runs consistently and reliably across different computing environments. </span><span class="koboSpan" id="kobo.60.2">The container will provide an isolated and lightweight runtime environment that encapsulates the application and related dependencies, ensuring that it runs consistently regardless of the underlying </span><span class="No-Break"><span class="koboSpan" id="kobo.61.1">system configurations.</span></span></p>
<p><span class="koboSpan" id="kobo.62.1">Containers </span><a id="_idIndexMarker1127"/><span class="koboSpan" id="kobo.63.1">are like </span><strong class="bold"><span class="koboSpan" id="kobo.64.1">virtual machines</span></strong><span class="koboSpan" id="kobo.65.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.66.1">VMs</span></strong><span class="koboSpan" id="kobo.67.1">) in that they provide a way to isolate applications from the underlying host operating system. </span><span class="koboSpan" id="kobo.67.2">However, while VMs require a complete copy of the host operating system to run, containers only require the minimal runtime components needed to run </span><span class="No-Break"><span class="koboSpan" id="kobo.68.1">the application.</span></span></p>
<p><span class="koboSpan" id="kobo.69.1">Containers </span><a id="_idIndexMarker1128"/><span class="koboSpan" id="kobo.70.1">utilize a technique called containerization, which employs virtualization at the operating system level. </span><span class="koboSpan" id="kobo.70.2">Containerization allows multiple containers to run on the same host operating system, each with its own isolated filesystem, networking, and process space. </span><span class="koboSpan" id="kobo.70.3">With containerization, developers can lower the deployment time </span><span class="No-Break"><span class="koboSpan" id="kobo.71.1">and cost.</span></span></p>
<p><span class="koboSpan" id="kobo.72.1">Let’s check out a few </span><a id="_idIndexMarker1129"/><span class="koboSpan" id="kobo.73.1">other benefits </span><span class="No-Break"><span class="koboSpan" id="kobo.74.1">of containerization:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.75.1">Containers provide a standardized way of packaging applications and required dependencies, which reduces the time and effort required for configuration </span><span class="No-Break"><span class="koboSpan" id="kobo.76.1">and setup.</span></span></li>
<li><span class="koboSpan" id="kobo.77.1">Containers are portable across different computing environments, allowing for deployment on any system with the same container runtime. </span><span class="koboSpan" id="kobo.77.2">This portability approach eliminates the need to create and maintain separate deployment configurations for </span><span class="No-Break"><span class="koboSpan" id="kobo.78.1">different environments.</span></span></li>
<li><span class="koboSpan" id="kobo.79.1">Containers share the same operating system kernel, enabling more efficient use of system resources compared to </span><span class="No-Break"><span class="koboSpan" id="kobo.80.1">traditional virtualization.</span></span></li>
<li><span class="koboSpan" id="kobo.81.1">Containers provide isolation between applications and accompanying dependencies, making the conflicts and errors that can arise when running applications on a </span><a id="_idIndexMarker1130"/><span class="koboSpan" id="kobo.82.1">shared </span><span class="No-Break"><span class="koboSpan" id="kobo.83.1">infrastructure obsolete.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.84.1">In a nutshell, containers are lightweight, self-containing to run applications, portable, and efficient, and can be easily replicated and scaled </span><span class="No-Break"><span class="koboSpan" id="kobo.85.1">as needed.</span></span></p>
<p><span class="koboSpan" id="kobo.86.1">Although there are several containerization technologies to choose from, we will specifically discuss Docker in the next section. </span><span class="koboSpan" id="kobo.86.2">Before exploring Docker in depth, let’s take a brief look at some of </span><a id="_idIndexMarker1131"/><span class="koboSpan" id="kobo.87.1">the other containerization tools and platforms</span><a id="_idIndexMarker1132"/><span class="koboSpan" id="kobo.88.1"> available in the </span><span class="No-Break"><span class="koboSpan" id="kobo.89.1">software industry:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.90.1">Kubernetes</span></strong><span class="koboSpan" id="kobo.91.1">: An </span><a id="_idIndexMarker1133"/><span class="koboSpan" id="kobo.92.1">open source container orchestration system that automates deploying, scaling, and managing </span><span class="No-Break"><span class="koboSpan" id="kobo.93.1">containerized applications</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.94.1">Apache Mesos</span></strong><span class="koboSpan" id="kobo.95.1">: An </span><a id="_idIndexMarker1134"/><span class="koboSpan" id="kobo.96.1">open source platform for managing and deploying containerized applications and big </span><span class="No-Break"><span class="koboSpan" id="kobo.97.1">data services</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.98.1">LXC/LXD</span></strong><span class="koboSpan" id="kobo.99.1">: A </span><a id="_idIndexMarker1135"/><span class="koboSpan" id="kobo.100.1">containerization solution that uses lightweight VMs to provide isolation and </span><span class="No-Break"><span class="koboSpan" id="kobo.101.1">resource management</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.102.1">CoreOS rkt</span></strong><span class="koboSpan" id="kobo.103.1">: A </span><a id="_idIndexMarker1136"/><span class="koboSpan" id="kobo.104.1">container runtime that provides security, simplicity, and speed to the </span><span class="No-Break"><span class="koboSpan" id="kobo.105.1">container environment</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.106.1">OpenVZ</span></strong><span class="koboSpan" id="kobo.107.1">: An</span><a id="_idIndexMarker1137"/><span class="koboSpan" id="kobo.108.1"> open source containerization platform that provides container-based virtualization </span><span class="No-Break"><span class="koboSpan" id="kobo.109.1">for Linux</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.110.1">AWS Elastic Container Service (ECS)</span></strong><span class="koboSpan" id="kobo.111.1">: A</span><a id="_idIndexMarker1138"/><span class="koboSpan" id="kobo.112.1"> fully managed container orchestration service provided </span><span class="No-Break"><span class="koboSpan" id="kobo.113.1">by AWS</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.114.1">Google Kubernetes Engine (GKE)</span></strong><span class="koboSpan" id="kobo.115.1">: A</span><a id="_idIndexMarker1139"/><span class="koboSpan" id="kobo.116.1"> fully managed Kubernetes service provided by Google </span><span class="No-Break"><span class="koboSpan" id="kobo.117.1">Cloud Platform</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.118.1">As the demand for scalable and efficient software deployment grows, more and more developers are going to turn to Docker as a solution. </span><span class="koboSpan" id="kobo.118.2">In the next section, we’ll explore the basics of Docker and how it can help you streamline your </span><span class="No-Break"><span class="koboSpan" id="kobo.119.1">development workflow.</span></span></p>
<h1 id="_idParaDest-292"><a id="_idTextAnchor332"/><span class="koboSpan" id="kobo.120.1">Introducing Docker</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.121.1">Docker</span></strong><span class="koboSpan" id="kobo.122.1"> is a </span><a id="_idIndexMarker1140"/><span class="koboSpan" id="kobo.123.1">popular platform for developing, packaging, and deploying applications in containers. </span><span class="koboSpan" id="kobo.123.2">Before Docker’s invention, software developers had to deal with the problem of software dependencies, which meant that the software would work well on one computer but fail to work on </span><span class="No-Break"><span class="koboSpan" id="kobo.124.1">another system.</span></span></p>
<p><span class="koboSpan" id="kobo.125.1">Software developers would create programs on their computers, but when they tried to share them with other people, things often went wrong. </span><span class="koboSpan" id="kobo.125.2">Programs that worked perfectly on one computer might not have worked on another because of differences in the operating system, software versions, configuration files, or other </span><span class="No-Break"><span class="koboSpan" id="kobo.126.1">system-related factors.</span></span></p>
<p><span class="koboSpan" id="kobo.127.1">To solve this problem, a group of developers in 2013 released a tool called Docker. </span><span class="koboSpan" id="kobo.127.2">Docker lets developers package programs and all the necessary dependencies into something called a </span><strong class="bold"><span class="koboSpan" id="kobo.128.1">Docker image</span></strong><span class="koboSpan" id="kobo.129.1">. </span><span class="koboSpan" id="kobo.129.2">A </span><a id="_idIndexMarker1141"/><span class="koboSpan" id="kobo.130.1">Docker image is a read-only template that contains the instructions for creating a Docker container. </span><span class="koboSpan" id="kobo.130.2">A Docker image includes the application code, runtime, libraries, dependencies, and configurations needed to run </span><span class="No-Break"><span class="koboSpan" id="kobo.131.1">the application.</span></span></p>
<p><span class="koboSpan" id="kobo.132.1">With Docker, developers can create a Docker image for their programs and share it with others. </span><span class="koboSpan" id="kobo.132.2">A Docker container is a runnable instance of a Docker image. </span><span class="koboSpan" id="kobo.132.3">A Docker container is a lightweight, isolated, and portable environment that can run on any system that supports Docker. </span><span class="koboSpan" id="kobo.132.4">This means that the program will run the same way on every computer, which makes it much easier to share </span><span class="No-Break"><span class="koboSpan" id="kobo.133.1">and deploy.</span></span></p>
<p><span class="koboSpan" id="kobo.134.1">Developers can create a Docker image </span><a id="_idIndexMarker1142"/><span class="koboSpan" id="kobo.135.1">by writing a </span><strong class="bold"><span class="koboSpan" id="kobo.136.1">Dockerfile</span></strong><span class="koboSpan" id="kobo.137.1">, which is a text file that contains the instructions for building a Docker image. </span><span class="koboSpan" id="kobo.137.2">The Dockerfile specifies the base image, adds the necessary packages and files, and sets the configuration options for </span><span class="No-Break"><span class="koboSpan" id="kobo.138.1">the application.</span></span></p>
<p><span class="koboSpan" id="kobo.139.1">Once you have built your application Docker image, you might want to ship to production or send it to other developers. </span><span class="koboSpan" id="kobo.139.2">To achieve this, you can use a Docker registry, which is a central repository for storing and distributing Docker images. </span><span class="koboSpan" id="kobo.139.3">Docker Hub is the most popular public registry, but you can also set up your own private registry for your organization. </span><span class="koboSpan" id="kobo.139.4">In the course of this chapter, we will store the book project Docker images in</span><a id="_idIndexMarker1143"/><span class="koboSpan" id="kobo.140.1"> AWS </span><strong class="bold"><span class="koboSpan" id="kobo.141.1">Elastic Container </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.142.1">Registry</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.143.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.144.1">ECR</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.145.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.146.1">Docker Compose is </span><a id="_idIndexMarker1144"/><span class="koboSpan" id="kobo.147.1">another tool of interest in the Docker ecosystem. </span><span class="koboSpan" id="kobo.147.2">Docker Compose is a tool for defining and running multi-container Docker applications. </span><span class="koboSpan" id="kobo.147.3">Docker Compose uses a YAML file to define the services, networks, and volumes needed to run the application. </span><span class="koboSpan" id="kobo.147.4">In the subsequent section, we will discuss Docker Compose in great detail. </span><span class="koboSpan" id="kobo.147.5">Next, we will explore how we can containerize a simple </span><span class="No-Break"><span class="koboSpan" id="kobo.148.1">Flask application.</span></span></p>
<h2 id="_idParaDest-293"><a id="_idTextAnchor333"/><span class="koboSpan" id="kobo.149.1">Creating a Flask application</span></h2>
<p><span class="koboSpan" id="kobo.150.1">Now, let’s </span><a id="_idIndexMarker1145"/><span class="koboSpan" id="kobo.151.1">demonstrate with a simple Flask application the process of containerization </span><span class="No-Break"><span class="koboSpan" id="kobo.152.1">using Docker:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.153.1">Download Docker</span><a id="_idIndexMarker1146"/><span class="koboSpan" id="kobo.154.1"> from </span><a href="https://docs.docker.com/get-docker/"><span class="koboSpan" id="kobo.155.1">https://docs.docker.com/get-docker/</span></a><span class="koboSpan" id="kobo.156.1"> and install Docker on </span><span class="No-Break"><span class="koboSpan" id="kobo.157.1">your system.</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer102">
<span class="koboSpan" id="kobo.158.1"><img alt="Figure 16.1 – The download page of Docker" src="image/Figure_16.01_B18554.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.159.1">Figure 16.1 – The download page of Docker</span></p>
<ol>
<li value="2"><span class="koboSpan" id="kobo.160.1">Select the appropriate computer OS for your </span><span class="No-Break"><span class="koboSpan" id="kobo.161.1">Docker platform.</span></span></li>
<li><span class="koboSpan" id="kobo.162.1">Once the Docker installation is complete, test it in your Terminal with the </span><span class="No-Break"><span class="koboSpan" id="kobo.163.1">following command:</span></span><pre class="source-code"><strong class="bold"><span class="koboSpan" id="kobo.164.1">Docker –-version</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.165.1">Alternatively, you can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.166.1">Docker version</span></strong><span class="koboSpan" id="kobo.167.1"> and you will get the </span><span class="No-Break"><span class="koboSpan" id="kobo.168.1">following output:</span></span></p></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer103">
<span class="koboSpan" id="kobo.169.1"><img alt="Figure 16.2 – The command to verify the Docker installation" src="image/Figure_16.02_B18554.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.170.1">Figure 16.2 – The command to verify the Docker installation</span></p>
<ol>
<li value="4"><span class="koboSpan" id="kobo.171.1">Now that </span><a id="_idIndexMarker1147"/><span class="koboSpan" id="kobo.172.1">Docker is installed on your computer, run the </span><strong class="source-inline"><span class="koboSpan" id="kobo.173.1">mkdir bizza-docker</span></strong><span class="koboSpan" id="kobo.174.1"> command to create a new working directory for deploying a Flask application using a Docker container. </span><span class="koboSpan" id="kobo.174.2">Then, enter </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.175.1">cd bizza-docker</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.176.1">:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer104">
<span class="koboSpan" id="kobo.177.1"><img alt="Figure 16.3 – The creation of a Docker working directory" src="image/Figure_16.03_B18554.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.178.1">Figure 16.3 – The creation of a Docker working directory</span></p>
<p class="list-inset"><span class="koboSpan" id="kobo.179.1">Let’s create a virtual environment for the new Flask </span><span class="No-Break"><span class="koboSpan" id="kobo.180.1">Docker application.</span></span></p>
<ol>
<li value="5"><span class="koboSpan" id="kobo.181.1">Run </span><strong class="source-inline"><span class="koboSpan" id="kobo.182.1">python –m venv venv</span></strong><span class="koboSpan" id="kobo.183.1"> in the Terminal to install a </span><span class="No-Break"><span class="koboSpan" id="kobo.184.1">virtual environment.</span></span></li>
<li><span class="koboSpan" id="kobo.185.1">Activate the virtual environment with </span><span class="No-Break"><span class="koboSpan" id="kobo.186.1">these commands:</span></span><ul><li><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.187.1">Windows</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.188.1">: </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.189.1">venv\Scripts\activate</span></strong></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.190.1">MacOS/Linux</span></strong><span class="koboSpan" id="kobo.191.1">: </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.192.1">source venv/bin/activate</span></strong></span></li>
</ul></li>
<li><span class="koboSpan" id="kobo.193.1">Inside the Docker project directory, </span><strong class="source-inline"><span class="koboSpan" id="kobo.194.1">bizza-docker/</span></strong><span class="koboSpan" id="kobo.195.1">, create an </span><strong class="source-inline"><span class="koboSpan" id="kobo.196.1">app.py</span></strong><span class="koboSpan" id="kobo.197.1"> file and add the following code snippet to run a simple </span><span class="No-Break"><span class="koboSpan" id="kobo.198.1">Flask application:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.199.1">from flask import Flaskapp = Flask(__name__)@app.route('/')def index():    return "Bizza Web App Dockerization!"if __name__ == "__main__":    app.run(host='0.0.0.0', port=5001, debug=True)</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.200.1">The </span><a id="_idIndexMarker1148"/><span class="koboSpan" id="kobo.201.1">preceding code runs a simple Flask app showing </span><strong class="bold"><span class="koboSpan" id="kobo.202.1">Bizza Web App Dockerization!</span></strong><span class="koboSpan" id="kobo.203.1"> in </span><span class="No-Break"><span class="koboSpan" id="kobo.204.1">the browser.</span></span></p></li>
<li><span class="koboSpan" id="kobo.205.1">Create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.206.1">.flaskenv</span></strong><span class="koboSpan" id="kobo.207.1"> file inside </span><strong class="source-inline"><span class="koboSpan" id="kobo.208.1">bizza-docker/</span></strong><span class="koboSpan" id="kobo.209.1"> and add the following </span><span class="No-Break"><span class="koboSpan" id="kobo.210.1">code snippet:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.211.1">FLASK_APP = app.pyFLASK_DEBUG = True</span></pre></li>
<li><span class="koboSpan" id="kobo.212.1">Now, run the Flask app with </span><strong class="source-inline"><span class="koboSpan" id="kobo.213.1">flask run</span></strong><span class="koboSpan" id="kobo.214.1"> in the Terminal and you will get the </span><span class="No-Break"><span class="koboSpan" id="kobo.215.1">following output:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer105">
<span class="koboSpan" id="kobo.216.1"><img alt="Figure 16.4 – Testing the Flask application" src="image/Figure_16.04_B18554.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.217.1">Figure 16.4 – Testing the Flask application</span></p>
<p class="list-inset"><span class="koboSpan" id="kobo.218.1">Now that the Flask app is working, let’s create a Flask application </span><strong class="source-inline"><span class="koboSpan" id="kobo.219.1">requirements.txt</span></strong><span class="koboSpan" id="kobo.220.1"> file to be able to reproduce the dependencies for this </span><span class="No-Break"><span class="koboSpan" id="kobo.221.1">simple application.</span></span></p>
<ol>
<li value="10"><span class="koboSpan" id="kobo.222.1">Run the </span><strong class="source-inline"><span class="koboSpan" id="kobo.223.1">pip freeze &gt; requirements.txt</span></strong><span class="koboSpan" id="kobo.224.1"> command and you will get the </span><span class="No-Break"><span class="koboSpan" id="kobo.225.1">following output:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer106">
<span class="koboSpan" id="kobo.226.1"><img alt="Figure 16.5 – The requirements.txt file for the Flask dependencies" src="image/Figure_16.05_B18554.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.227.1">Figure 16.5 – The requirements.txt file for the Flask dependencies</span></p>
<p><span class="koboSpan" id="kobo.228.1">The following </span><a id="_idIndexMarker1149"/><span class="koboSpan" id="kobo.229.1">block displays the content of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.230.1">requirements.txt</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.231.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.232.1">blinker==1.6.2click==8.1.3
colorama==0.4.6
Flask==2.3.2
itsdangerous==2.1.2
Jinja2==3.1.2
MarkupSafe==2.1.2
python-dotenv==1.0.0
Werkzeug==2.3.3</span></pre>
<p><span class="koboSpan" id="kobo.233.1">We now have all the resources to build the </span><span class="No-Break"><span class="koboSpan" id="kobo.234.1">Docker image.</span></span></p>
<h2 id="_idParaDest-294"><a id="_idTextAnchor334"/><span class="koboSpan" id="kobo.235.1">Creating a Dockerfile</span></h2>
<p><span class="koboSpan" id="kobo.236.1">A Dockerfile </span><a id="_idIndexMarker1150"/><span class="koboSpan" id="kobo.237.1">defines the container image for a Flask application. </span><span class="koboSpan" id="kobo.237.2">We are going to create a Dockerfile that uses the official Python 3.8 image as the base image, installs Flask and its dependencies, and copies the Flask application code into </span><span class="No-Break"><span class="koboSpan" id="kobo.238.1">the container.</span></span></p>
<p><span class="koboSpan" id="kobo.239.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.240.1">bizza-docker</span></strong><span class="koboSpan" id="kobo.241.1"> directory, create a Dockerfile file – make sure the capital </span><em class="italic"><span class="koboSpan" id="kobo.242.1">D</span></em><span class="koboSpan" id="kobo.243.1"> is used in creating the Dockerfile file. </span><span class="koboSpan" id="kobo.243.2">Don’t worry about why; this is </span><span class="No-Break"><span class="koboSpan" id="kobo.244.1">a convention:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.245.1">FROM python:3.8.2-alpineWORKDIR /packt-bizza-docker
ADD . </span><span class="koboSpan" id="kobo.245.2">/packt-bizza-docker
COPY requirements.txt .
</span><span class="koboSpan" id="kobo.245.3">RUN pip install --no-cache-dir -r requirements.txt
RUN pip3 install -r requirements.txt
COPY . </span><span class="koboSpan" id="kobo.245.4">.
</span><span class="koboSpan" id="kobo.245.5">ENV FLASK_APP=app.py
ENV FLASK_ENV=development
EXPOSE 5001
CMD ["python3", "app.py"]</span></pre>
<p><span class="koboSpan" id="kobo.246.1">To </span><a id="_idIndexMarker1151"/><span class="koboSpan" id="kobo.247.1">simplify the deployment process and ensure consistent environments across different stages of development, testing, and production, let’s examine the anatomy of the </span><span class="No-Break"><span class="koboSpan" id="kobo.248.1">preceding Dockerfile.</span></span></p>
<p><span class="koboSpan" id="kobo.249.1">The preceding code is a Dockerfile used to build a Docker image for a Python Flask </span><span class="No-Break"><span class="koboSpan" id="kobo.250.1">web application:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.251.1">FROM python:3.8.2-alpine</span></strong><span class="koboSpan" id="kobo.252.1">: This specifies the base image to use for building the Docker image. </span><span class="koboSpan" id="kobo.252.2">In this case, the base image is </span><strong class="source-inline"><span class="koboSpan" id="kobo.253.1">python:3.8.2-alpine</span></strong><span class="koboSpan" id="kobo.254.1">, which is a lightweight version of Python 3.8.2 optimized for running in </span><span class="No-Break"><span class="koboSpan" id="kobo.255.1">Alpine Linux.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.256.1">WORKDIR /packt-bizza-docker</span></strong><span class="koboSpan" id="kobo.257.1">: This sets the working directory of the Docker container to </span><strong class="source-inline"><span class="koboSpan" id="kobo.258.1">/packt-bizza-docker</span></strong><span class="koboSpan" id="kobo.259.1">. </span><span class="koboSpan" id="kobo.259.2">All subsequent commands in the Dockerfile will be executed relative to </span><span class="No-Break"><span class="koboSpan" id="kobo.260.1">this directory.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.261.1">ADD . </span><span class="koboSpan" id="kobo.261.2">/packt-bizza-docker</span></strong><span class="koboSpan" id="kobo.262.1">: This line copies all the files and directories in the current directory into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.263.1">/packt-bizza-docker</span></strong><span class="koboSpan" id="kobo.264.1"> directory in the </span><span class="No-Break"><span class="koboSpan" id="kobo.265.1">Docker container.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.266.1">COPY requirements.txt .</span></strong><span class="koboSpan" id="kobo.267.1">: This copies the </span><strong class="source-inline"><span class="koboSpan" id="kobo.268.1">requirements.txt</span></strong><span class="koboSpan" id="kobo.269.1"> file from the current directory to the root directory of the </span><span class="No-Break"><span class="koboSpan" id="kobo.270.1">Docker container.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.271.1">RUN pip install --no-cache-dir -r requirements.txt</span></strong><span class="koboSpan" id="kobo.272.1">: This installs the Python dependencies specified in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.273.1">requirements.txt</span></strong><span class="koboSpan" id="kobo.274.1"> file using </span><strong class="source-inline"><span class="koboSpan" id="kobo.275.1">pip</span></strong><span class="koboSpan" id="kobo.276.1">. </span><span class="koboSpan" id="kobo.276.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.277.1">--no-cache-dir</span></strong><span class="koboSpan" id="kobo.278.1"> option ensures that </span><strong class="source-inline"><span class="koboSpan" id="kobo.279.1">pip</span></strong><span class="koboSpan" id="kobo.280.1"> does not cache the </span><span class="No-Break"><span class="koboSpan" id="kobo.281.1">downloaded packages.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.282.1">RUN pip install -r requirements.txt</span></strong><span class="koboSpan" id="kobo.283.1">: This line installs the Python dependencies specified in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.284.1">requirements.txt</span></strong><span class="koboSpan" id="kobo.285.1"> file </span><span class="No-Break"><span class="koboSpan" id="kobo.286.1">using </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.287.1">pip3</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.288.1">.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.289.1">COPY . </span><span class="koboSpan" id="kobo.289.2">.</span></strong><span class="koboSpan" id="kobo.290.1">: This copies all the files and directories in the current directory to the root directory of the Docker container. </span><span class="koboSpan" id="kobo.290.2">This includes the Flask </span><span class="No-Break"><span class="koboSpan" id="kobo.291.1">application code.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.292.1">ENV FLASK_APP=app.py, ENV FLASK_ENV=development</span></strong><span class="koboSpan" id="kobo.293.1">: This sets the </span><a id="_idIndexMarker1152"/><span class="koboSpan" id="kobo.294.1">environment variables for the Flask application. </span><strong class="source-inline"><span class="koboSpan" id="kobo.295.1">FLASK_APP</span></strong><span class="koboSpan" id="kobo.296.1"> specifies the name of the main Flask application file (in this case, </span><strong class="source-inline"><span class="koboSpan" id="kobo.297.1">app.py</span></strong><span class="koboSpan" id="kobo.298.1">). </span><strong class="source-inline"><span class="koboSpan" id="kobo.299.1">FLASK_ENV</span></strong><span class="koboSpan" id="kobo.300.1"> sets the Flask environment to </span><span class="No-Break"><span class="koboSpan" id="kobo.301.1">development mode.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.302.1">EXPOSE 5001</span></strong><span class="koboSpan" id="kobo.303.1">: This exposes port </span><strong class="source-inline"><span class="koboSpan" id="kobo.304.1">5001</span></strong><span class="koboSpan" id="kobo.305.1"> of the </span><span class="No-Break"><span class="koboSpan" id="kobo.306.1">Docker container.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.307.1">CMD ["python3", "app.py"]</span></strong><span class="koboSpan" id="kobo.308.1">: This specifies the command to run when the Docker container is started. </span><span class="koboSpan" id="kobo.308.2">In this case, it runs the </span><strong class="source-inline"><span class="koboSpan" id="kobo.309.1">app.py</span></strong><span class="koboSpan" id="kobo.310.1"> file using </span><span class="No-Break"><span class="koboSpan" id="kobo.311.1">Python 3.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.312.1">Next, we will build the Docker image from the preceding </span><span class="No-Break"><span class="koboSpan" id="kobo.313.1">defined </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.314.1">Dockerfile</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.315.1">.</span></span></p>
<h2 id="_idParaDest-295"><a id="_idTextAnchor335"/><span class="koboSpan" id="kobo.316.1">Building the Docker image</span></h2>
<p><span class="koboSpan" id="kobo.317.1">With</span><a id="_idIndexMarker1153"/><span class="koboSpan" id="kobo.318.1"> the Dockerfile defined, you can build a Docker image of the Flask application. </span><span class="koboSpan" id="kobo.318.2">This image contains all the dependencies and configuration files required to run </span><span class="No-Break"><span class="koboSpan" id="kobo.319.1">the application.</span></span></p>
<p><span class="koboSpan" id="kobo.320.1">To construct the Docker image, execute the following command in the Terminal from within the </span><strong class="source-inline"><span class="koboSpan" id="kobo.321.1">bizza-docker</span></strong><span class="koboSpan" id="kobo.322.1"> directory that contains </span><span class="No-Break"><span class="koboSpan" id="kobo.323.1">the Dockerfile:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.324.1">docker build -t packt-bizza-docker .</span></pre>
<p><span class="koboSpan" id="kobo.325.1">We will get the </span><span class="No-Break"><span class="koboSpan" id="kobo.326.1">following output:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer107">
<span class="koboSpan" id="kobo.327.1"><img alt="Figure 16.6 – Output of the docker build command" src="image/Figure_16.06_B18554.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.328.1">Figure 16.6 – Output of the docker build command</span></p>
<p><span class="koboSpan" id="kobo.329.1">The </span><a id="_idIndexMarker1154"/><span class="koboSpan" id="kobo.330.1">preceding command will build the Docker image using the Dockerfile present in the current directory. </span><span class="koboSpan" id="kobo.330.2">The resulting image will be tagged as </span><strong class="source-inline"><span class="koboSpan" id="kobo.331.1">packt-bizza-docker</span></strong><span class="koboSpan" id="kobo.332.1">. </span><span class="koboSpan" id="kobo.332.2">Now, let’s proceed to the next step and launch the container to make the simple Flask </span><span class="No-Break"><span class="koboSpan" id="kobo.333.1">application functional.</span></span></p>
<h2 id="_idParaDest-296"><a id="_idTextAnchor336"/><span class="koboSpan" id="kobo.334.1">Running the Docker container</span></h2>
<p><span class="koboSpan" id="kobo.335.1">After </span><a id="_idIndexMarker1155"/><span class="koboSpan" id="kobo.336.1">building the Docker image, you can run a Docker container from the image. </span><span class="koboSpan" id="kobo.336.2">This container provides a lightweight, isolated, and portable environment for running the </span><span class="No-Break"><span class="koboSpan" id="kobo.337.1">Flask application.</span></span></p>
<p><span class="koboSpan" id="kobo.338.1">To run the Docker container, use the </span><span class="No-Break"><span class="koboSpan" id="kobo.339.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.340.1">docker run -d -p 5001:5001 packt-bizza-docker .</span></pre>
<p><span class="koboSpan" id="kobo.341.1">We will get the </span><span class="No-Break"><span class="koboSpan" id="kobo.342.1">following output:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer108">
<span class="koboSpan" id="kobo.343.1"><img alt="Figure 16.7 – Output of docker run in detached mode" src="image/Figure_16.07_B18554.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.344.1">Figure 16.7 – Output of docker run in detached mode</span></p>
<p><span class="koboSpan" id="kobo.345.1">The preceding command will run the container in detached mode (</span><strong class="source-inline"><span class="koboSpan" id="kobo.346.1">-d</span></strong><span class="koboSpan" id="kobo.347.1">) and perform port mapping (</span><strong class="source-inline"><span class="koboSpan" id="kobo.348.1">-p</span></strong><span class="koboSpan" id="kobo.349.1">) by mapping the host port </span><strong class="source-inline"><span class="koboSpan" id="kobo.350.1">5001</span></strong><span class="koboSpan" id="kobo.351.1"> to the container port </span><strong class="source-inline"><span class="koboSpan" id="kobo.352.1">5001</span></strong><span class="koboSpan" id="kobo.353.1">. </span><span class="koboSpan" id="kobo.353.2">The container will be based on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.354.1">packt-bizza-docker</span></strong><span class="koboSpan" id="kobo.355.1"> image. </span><span class="koboSpan" id="kobo.355.2">Alternatively, you can run the command without the </span><strong class="source-inline"><span class="koboSpan" id="kobo.356.1">-d</span></strong><span class="koboSpan" id="kobo.357.1"> flag to launch the container in a non-detached mode, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.358.1">following figure:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer109">
<span class="koboSpan" id="kobo.359.1"><img alt="Figure 16.8 – Output of docker run in a non-detached mode" src="image/Figure_16.08_B18554.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.360.1">Figure 16.8 – Output of docker run in a non-detached mode</span></p>
<p><span class="koboSpan" id="kobo.361.1">The </span><a id="_idIndexMarker1156"/><span class="koboSpan" id="kobo.362.1">preceding </span><strong class="source-inline"><span class="koboSpan" id="kobo.363.1">docker run</span></strong><span class="koboSpan" id="kobo.364.1"> command allows us to access the Flask application running inside the Docker container. </span><span class="koboSpan" id="kobo.364.2">You need to expose the ports on the container to the host machine with </span><strong class="source-inline"><span class="koboSpan" id="kobo.365.1">-p </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.366.1">5001:5001 .</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.367.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.368.1">Now that we have the Docker container running, we can test the Flask application by accessing it through a web browser or using a command-line tool such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.369.1">curl-</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.370.1">http://127.0.0.1:5001</span></strong><span class="koboSpan" id="kobo.371.1">. </span><span class="koboSpan" id="kobo.371.2">Make sure that the application is functioning as expected and that all the dependencies are </span><span class="No-Break"><span class="koboSpan" id="kobo.372.1">working correctly.</span></span></p>
<p><span class="koboSpan" id="kobo.373.1">Finally, you can push the Docker image to a Docker registry such as Docker Hub or AWS ECS. </span><span class="koboSpan" id="kobo.373.2">This makes it easy to share the image with other developers or deploy it to </span><span class="No-Break"><span class="koboSpan" id="kobo.374.1">production environments.</span></span></p>
<p><span class="koboSpan" id="kobo.375.1">To stop a running Docker container, you can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.376.1">docker stop</span></strong><span class="koboSpan" id="kobo.377.1"> command followed by the </span><em class="italic"><span class="koboSpan" id="kobo.378.1">container ID</span></em> <span class="No-Break"><span class="koboSpan" id="kobo.379.1">or </span></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.380.1">name</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.381.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.382.1">For example, if the container ID is </span><strong class="source-inline"><span class="koboSpan" id="kobo.383.1">c2d8f8a4b5e3</span></strong><span class="koboSpan" id="kobo.384.1">, you can stop the container using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.385.1">docker stop c2d8f8a4b5e3</span></strong><span class="koboSpan" id="kobo.386.1"> command, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.387.1">following figure:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer110">
<span class="koboSpan" id="kobo.388.1"><img alt="Figure 16.9 – Output of the docker stop command" src="image/Figure_16.09_B18554.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.389.1">Figure 16.9 – Output of the docker stop command</span></p>
<p><span class="koboSpan" id="kobo.390.1">And if you don’t know the container ID or name, you can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.391.1">docker ps</span></strong><span class="koboSpan" id="kobo.392.1"> command to list all running containers and their details, including the ID and name. </span><span class="koboSpan" id="kobo.392.2">Once you have identified the container that you want to stop, you can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.393.1">docker stop</span></strong><span class="koboSpan" id="kobo.394.1"> command as </span><span class="No-Break"><span class="koboSpan" id="kobo.395.1">described earlier.</span></span></p>
<p><span class="koboSpan" id="kobo.396.1">Let’s glance at another important Docker command: </span><strong class="source-inline"><span class="koboSpan" id="kobo.397.1">docker </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.398.1">container prune</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.399.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.400.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.401.1">docker container prune</span></strong><span class="koboSpan" id="kobo.402.1"> command is used to remove stopped containers and free up disk space. </span><span class="koboSpan" id="kobo.402.2">When you run a Docker container, the container consumes system resources such as memory and CPU cycles. </span><span class="koboSpan" id="kobo.402.3">When you stop a container, those resources are freed up, but the container still exists on your system. </span><span class="koboSpan" id="kobo.402.4">With time, if you run multiple containers, you may be housing many stopped containers, which can take up significant disk space on </span><span class="No-Break"><span class="koboSpan" id="kobo.403.1">your system.</span></span></p>
<p><span class="koboSpan" id="kobo.404.1">Running </span><a id="_idIndexMarker1157"/><span class="koboSpan" id="kobo.405.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.406.1">docker container prune</span></strong><span class="koboSpan" id="kobo.407.1"> command is a simple way to remove all stopped containers and reclaim disk space. </span><span class="koboSpan" id="kobo.407.2">This </span><strong class="source-inline"><span class="koboSpan" id="kobo.408.1">docker container prune</span></strong><span class="koboSpan" id="kobo.409.1"> command will prompt you to confirm that you want to remove the containers before proceeding, so make sure you review the list of containers carefully </span><span class="No-Break"><span class="koboSpan" id="kobo.410.1">before confirming.</span></span></p>
<p><span class="koboSpan" id="kobo.411.1">It’s important to note that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.412.1">docker container prune</span></strong><span class="koboSpan" id="kobo.413.1"> command will only remove stopped containers. </span><span class="koboSpan" id="kobo.413.2">If you have any running containers, they will not be affected by </span><span class="No-Break"><span class="koboSpan" id="kobo.414.1">this command.</span></span></p>
<p><span class="koboSpan" id="kobo.415.1">Next, we will discuss the process of dockerizing React and Flask applications. </span><span class="koboSpan" id="kobo.415.2">We will use the full stack Bizza web application as a </span><span class="No-Break"><span class="koboSpan" id="kobo.416.1">case study.</span></span></p>
<h1 id="_idParaDest-297"><a id="_idTextAnchor337"/><span class="koboSpan" id="kobo.417.1">Dockerizing React and Flask applications</span></h1>
<p><span class="koboSpan" id="kobo.418.1">Dockerizing</span><a id="_idIndexMarker1158"/><span class="koboSpan" id="kobo.419.1"> web applications allows developers to set up a consistent development environment across different machines. </span><span class="koboSpan" id="kobo.419.2">Dockerizing tools reduce the time and effort required to set up a new development environment. </span><span class="koboSpan" id="kobo.419.3">With Docker, developers can easily replicate the production environment on their local machines, test their code, and debug any issues before </span><span class="No-Break"><span class="koboSpan" id="kobo.420.1">deploying it.</span></span></p>
<p><span class="koboSpan" id="kobo.421.1">In this section, we will dockerize working applications for React and Flask, and make them ready to be shipped </span><span class="No-Break"><span class="koboSpan" id="kobo.422.1">for production.</span></span></p>
<p><span class="koboSpan" id="kobo.423.1">Let’s start with </span><span class="No-Break"><span class="koboSpan" id="kobo.424.1">the React.</span></span></p>
<h2 id="_idParaDest-298"><a id="_idTextAnchor338"/><span class="koboSpan" id="kobo.425.1">Bizza frontend application with React</span></h2>
<p><span class="koboSpan" id="kobo.426.1">Once you</span><a id="_idIndexMarker1159"/><span class="koboSpan" id="kobo.427.1"> have created your React application, the</span><a id="_idIndexMarker1160"/><span class="koboSpan" id="kobo.428.1"> initial step toward making it accessible to internet users is to build the application. </span><span class="koboSpan" id="kobo.428.2">Building a React application is an essential step in the development process to ensure that the application is optimized for production and performs </span><span class="No-Break"><span class="koboSpan" id="kobo.429.1">as expected.</span></span></p>
<p><span class="koboSpan" id="kobo.430.1">The building process takes the source code of a React project and transforms it into a production-ready format</span><a id="_idIndexMarker1161"/><span class="koboSpan" id="kobo.431.1"> that can be deployed and served </span><span class="No-Break"><span class="koboSpan" id="kobo.432.1">to users:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.433.1">Let’s download the </span><em class="italic"><span class="koboSpan" id="kobo.434.1">Bizza</span></em><span class="koboSpan" id="kobo.435.1"> app directory from the GitHub repo – </span><a href="https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter16/bizza/frontend"><span class="No-Break"><span class="koboSpan" id="kobo.436.1">https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter16/bizza/frontend</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.437.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.438.1">To install the dependencies required for the application, navigate to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.439.1">bizza/frontend</span></strong><span class="koboSpan" id="kobo.440.1"> directory and execute the </span><strong class="source-inline"><span class="koboSpan" id="kobo.441.1">npm install</span></strong><span class="koboSpan" id="kobo.442.1"> command in </span><span class="No-Break"><span class="koboSpan" id="kobo.443.1">the Terminal.</span></span></li>
<li><span class="koboSpan" id="kobo.444.1">To run the frontend application, execute the </span><strong class="source-inline"><span class="koboSpan" id="kobo.445.1">npm start</span></strong><span class="koboSpan" id="kobo.446.1"> command in </span><span class="No-Break"><span class="koboSpan" id="kobo.447.1">the Terminal.</span></span></li>
<li><span class="koboSpan" id="kobo.448.1">Now, let’s build the application with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.449.1">npm run </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.450.1">build</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.451.1"> command.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.452.1">Now that </span><a id="_idIndexMarker1162"/><span class="koboSpan" id="kobo.453.1">the </span><em class="italic"><span class="koboSpan" id="kobo.454.1">bizza</span></em><span class="koboSpan" id="kobo.455.1"> React application has been built, the resulting files can be deployed to a web server or cloud platform and served to users. </span><span class="koboSpan" id="kobo.455.2">The eventual build directory is located </span><span class="No-Break"><span class="koboSpan" id="kobo.456.1">inside </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.457.1">bizza/frontend/src/build</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.458.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.459.1">During the build process, the following steps </span><span class="No-Break"><span class="koboSpan" id="kobo.460.1">were taken:</span></span></p>
<ol>
<li><strong class="bold"><span class="koboSpan" id="kobo.461.1">Transpiling JavaScript and JSX code</span></strong><span class="koboSpan" id="kobo.462.1">: React applications are typically written</span><a id="_idIndexMarker1163"/><span class="koboSpan" id="kobo.463.1"> in JavaScript and JSX, a syntax extension for JavaScript. </span><span class="koboSpan" id="kobo.463.2">However, modern web browsers can only execute JavaScript code. </span><span class="koboSpan" id="kobo.463.3">Therefore, before deploying a React application, the JavaScript and JSX code needs to be transpiled into plain JavaScript using a tool such </span><span class="No-Break"><span class="koboSpan" id="kobo.464.1">as Babel.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.465.1">Bundling the code and assets</span></strong><span class="koboSpan" id="kobo.466.1">: React </span><a id="_idIndexMarker1164"/><span class="koboSpan" id="kobo.467.1">applications often consist of multiple components, modules, and assets such as images, CSS files, and fonts. </span><span class="koboSpan" id="kobo.467.2">Bundling involves grouping all the required code and assets into a single file or set of files that can be served to </span><span class="No-Break"><span class="koboSpan" id="kobo.468.1">the user.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.469.1">Optimizing the code and assets</span></strong><span class="koboSpan" id="kobo.470.1">: To improve performance, the bundled code and assets</span><a id="_idIndexMarker1165"/><span class="koboSpan" id="kobo.471.1"> can be optimized by minifying, compressing, or removing </span><span class="No-Break"><span class="koboSpan" id="kobo.472.1">unnecessary code.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.473.1">Creating a build directory</span></strong><span class="koboSpan" id="kobo.474.1">: Once</span><a id="_idIndexMarker1166"/><span class="koboSpan" id="kobo.475.1"> the code and assets are bundled and optimized, the code needs to be placed in a directory that can be served by a web server. </span><span class="koboSpan" id="kobo.475.2">This directory is typically named </span><strong class="source-inline"><span class="koboSpan" id="kobo.476.1">build</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.477.1">or </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.478.1">dist</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.479.1">.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.480.1">Now, typically</span><a id="_idIndexMarker1167"/><span class="koboSpan" id="kobo.481.1"> at this stage, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.482.1">build</span></strong><span class="koboSpan" id="kobo.483.1"> directory </span><a id="_idIndexMarker1168"/><span class="koboSpan" id="kobo.484.1">contents are deployed to a web server or cloud for end users. </span><span class="koboSpan" id="kobo.484.2">However, for the deployment process outlined in this book, you will utilize a Docker functionality known </span><a id="_idIndexMarker1169"/><span class="koboSpan" id="kobo.485.1">as </span><strong class="bold"><span class="koboSpan" id="kobo.486.1">multi-stage builds</span></strong><span class="koboSpan" id="kobo.487.1">. </span><span class="koboSpan" id="kobo.487.2">A multi-stage build is a feature in Docker that allows you to create a Docker image that consists of multiple stages, where each stage is a self-contained Docker image with a </span><span class="No-Break"><span class="koboSpan" id="kobo.488.1">specific purpose.</span></span></p>
<p><span class="koboSpan" id="kobo.489.1">The purpose of a multi-stage build is to optimize the size and efficiency of Docker images. </span><span class="koboSpan" id="kobo.489.2">With a multi-stage build, you can reduce the size of your final Docker image by only including the necessary files and dependencies. </span><span class="koboSpan" id="kobo.489.3">This results in faster builds, smaller image sizes, and more efficient use </span><span class="No-Break"><span class="koboSpan" id="kobo.490.1">of resources.</span></span></p>
<p><span class="koboSpan" id="kobo.491.1">The multi-stage build process involves creating multiple Docker images, each with a specific purpose. </span><span class="koboSpan" id="kobo.491.2">The first stage of the build typically contains the source code, dependencies, libraries, and other </span><span class="No-Break"><span class="koboSpan" id="kobo.492.1">necessary files.</span></span></p>
<p><span class="koboSpan" id="kobo.493.1">The final stage of the build usually contains only the essential files and dependencies required to run the application, resulting in a smaller and more efficient Docker image. </span><span class="koboSpan" id="kobo.493.2">The essence of a multi-stage build is to ensure that the intermediate stages are used to build and compile the application but are not included in the </span><span class="No-Break"><span class="koboSpan" id="kobo.494.1">final image.</span></span></p>
<p><span class="koboSpan" id="kobo.495.1">Right now, let’s examine a </span><strong class="source-inline"><span class="koboSpan" id="kobo.496.1">Dockerfile</span></strong><span class="koboSpan" id="kobo.497.1"> for the React frontend app that uses </span><span class="No-Break"><span class="koboSpan" id="kobo.498.1">multi-stage builds:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.499.1"># Build stageFROM node:14.17.0-alpine3.13 as build-stage
WORKDIR /frontend
COPY package*.json ./
RUN npm install --production
COPY . </span><span class="koboSpan" id="kobo.499.2">.
</span><span class="koboSpan" id="kobo.499.3">RUN npm run build
# Production stage
FROM nginx:1.21.0-alpine
COPY --from=build-stage /frontend/build /usr/share/nginx/html
EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]
# Clean up unnecessary files
RUN rm -rf /var/cache/apk/* \
          /tmp/* \
          /var/tmp/* \
          /frontend/node_modules \
          /frontend/.npm \
          /frontend/.npmrc \
          /frontend/package*.json \
          /frontend/tsconfig*.json \
          /frontend/yarn.lock</span></pre>
<p><span class="koboSpan" id="kobo.500.1">Let’s break </span><a id="_idIndexMarker1170"/><span class="koboSpan" id="kobo.501.1">the preceding </span><strong class="source-inline"><span class="koboSpan" id="kobo.502.1">Dockerfile</span></strong><span class="koboSpan" id="kobo.503.1"> image-building </span><a id="_idIndexMarker1171"/><span class="No-Break"><span class="koboSpan" id="kobo.504.1">instruction down:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.505.1">The build stage</span></strong><span class="koboSpan" id="kobo.506.1">: The </span><a id="_idIndexMarker1172"/><span class="koboSpan" id="kobo.507.1">first part of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.508.1">Dockerfile</span></strong><span class="koboSpan" id="kobo.509.1"> creates a build stage using the Node.js </span><strong class="source-inline"><span class="koboSpan" id="kobo.510.1">14.17.0-alpine3.13</span></strong><span class="koboSpan" id="kobo.511.1"> image as the base. </span><span class="koboSpan" id="kobo.511.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.512.1">Dockerfile</span></strong><span class="koboSpan" id="kobo.513.1"> sets the working directory to </span><strong class="source-inline"><span class="koboSpan" id="kobo.514.1">/frontend</span></strong><span class="koboSpan" id="kobo.515.1"> and copies the </span><strong class="source-inline"><span class="koboSpan" id="kobo.516.1">package*.json</span></strong><span class="koboSpan" id="kobo.517.1"> files from the local directory to the image. </span><span class="koboSpan" id="kobo.517.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.518.1">npm install --production</span></strong><span class="koboSpan" id="kobo.519.1"> command is then run to install the </span><a id="_idIndexMarker1173"/><span class="koboSpan" id="kobo.520.1">production dependencies. </span><span class="koboSpan" id="kobo.520.2">Next, the Dockerfile copies the entire project directory to the image and runs the </span><strong class="source-inline"><span class="koboSpan" id="kobo.521.1">npm run build</span></strong><span class="koboSpan" id="kobo.522.1"> command to build the </span><span class="No-Break"><span class="koboSpan" id="kobo.523.1">React app.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.524.1">Production stage</span></strong><span class="koboSpan" id="kobo.525.1">: The</span><a id="_idIndexMarker1174"/><span class="koboSpan" id="kobo.526.1"> second part of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.527.1">Dockerfile</span></strong><span class="koboSpan" id="kobo.528.1"> creates a production stage using the smaller </span><strong class="source-inline"><span class="koboSpan" id="kobo.529.1">nginx:1.21.0-alpine image</span></strong><span class="koboSpan" id="kobo.530.1"> as the base. </span><span class="koboSpan" id="kobo.530.2">The Dockerfile copies the built React app from the build stage, located at </span><strong class="source-inline"><span class="koboSpan" id="kobo.531.1">/frontend/build</span></strong><span class="koboSpan" id="kobo.532.1">, to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.533.1">nginx</span></strong><span class="koboSpan" id="kobo.534.1"> HTML directory </span><span class="No-Break"><span class="koboSpan" id="kobo.535.1">at </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.536.1">/usr/share/nginx/html</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.537.1">.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.538.1">EXPOSE</span></strong><span class="koboSpan" id="kobo.539.1">: The </span><strong class="source-inline"><span class="koboSpan" id="kobo.540.1">EXPOSE</span></strong><span class="koboSpan" id="kobo.541.1"> command </span><a id="_idIndexMarker1175"/><span class="koboSpan" id="kobo.542.1">exposes port </span><strong class="source-inline"><span class="koboSpan" id="kobo.543.1">80</span></strong><span class="koboSpan" id="kobo.544.1"> to allow communication with </span><span class="No-Break"><span class="koboSpan" id="kobo.545.1">the container.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.546.1">CMD</span></strong><span class="koboSpan" id="kobo.547.1">: The </span><strong class="source-inline"><span class="koboSpan" id="kobo.548.1">CMD</span></strong><span class="koboSpan" id="kobo.549.1"> command sets </span><a id="_idIndexMarker1176"/><span class="koboSpan" id="kobo.550.1">the default command to run when the container starts up. </span><span class="koboSpan" id="kobo.550.2">In this case, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.551.1">Dockerfile</span></strong><span class="koboSpan" id="kobo.552.1"> starts the </span><strong class="source-inline"><span class="koboSpan" id="kobo.553.1">nginx</span></strong><span class="koboSpan" id="kobo.554.1"> server in the foreground with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.555.1">nginx -g 'daemon </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.556.1">off;'</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.557.1"> command.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.558.1">Cleaning up unnecessary files</span></strong><span class="koboSpan" id="kobo.559.1">: Finally, to </span><a id="_idIndexMarker1177"/><span class="koboSpan" id="kobo.560.1">further optimize the image size, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.561.1">Dockerfile</span></strong><span class="koboSpan" id="kobo.562.1"> cleans up unnecessary files, such as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.563.1">node_modules</span></strong><span class="koboSpan" id="kobo.564.1"> directory and other configuration </span><a id="_idIndexMarker1178"/><span class="koboSpan" id="kobo.565.1">files, using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.566.1">RUN</span></strong><span class="koboSpan" id="kobo.567.1"> command with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.568.1">rm</span></strong><span class="koboSpan" id="kobo.569.1"> command </span><a id="_idIndexMarker1179"/><span class="koboSpan" id="kobo.570.1">to remove them from the image. </span><span class="koboSpan" id="kobo.570.2">This cleaning-up process reduces the overall size of the image, making it faster </span><span class="No-Break"><span class="koboSpan" id="kobo.571.1">to deploy.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.572.1">Now that we have the Docker image of the bizza frontend React app. </span><span class="koboSpan" id="kobo.572.2">Let’s create the Flask backend </span><span class="No-Break"><span class="koboSpan" id="kobo.573.1">Docker image.</span></span></p>
<h2 id="_idParaDest-299"><a id="_idTextAnchor339"/><span class="koboSpan" id="kobo.574.1">Bizza backend application with Flask</span></h2>
<p><span class="koboSpan" id="kobo.575.1">In the </span><a id="_idIndexMarker1180"/><span class="koboSpan" id="kobo.576.1">Flask backend, we are going to create two Docker images. </span><span class="koboSpan" id="kobo.576.2">Download the full Flask backend application </span><span class="No-Break"><span class="koboSpan" id="kobo.577.1">here: </span></span><a href="https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter16/bizza/backend"><span class="No-Break"><span class="koboSpan" id="kobo.578.1">https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter16/bizza/backend</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.579.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.580.1">We will </span><a id="_idIndexMarker1181"/><span class="koboSpan" id="kobo.581.1">create a Docker image for the Flask application and another Docker image for PostgreSQL. </span><span class="koboSpan" id="kobo.581.2">While it is possible to fuse the two images into a single Docker image, it is a best practice to separate the concerns for scalability and to reduce the </span><span class="No-Break"><span class="koboSpan" id="kobo.582.1">image size.</span></span></p>
<p><span class="koboSpan" id="kobo.583.1">Let’s review the Flask application multi-stage build </span><span class="No-Break"><span class="koboSpan" id="kobo.584.1">Dockerfile definition.</span></span></p>
<p><span class="koboSpan" id="kobo.585.1">The Dockerfile for the Flask application will be stored in the project </span><strong class="source-inline"><span class="koboSpan" id="kobo.586.1">root</span></strong><span class="koboSpan" id="kobo.587.1"> directory while a subdirectory named </span><strong class="source-inline"><span class="koboSpan" id="kobo.588.1">postgres</span></strong><span class="koboSpan" id="kobo.589.1"> will house the Dockerfile </span><span class="No-Break"><span class="koboSpan" id="kobo.590.1">for PostgreSQL:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.591.1"># Build StageFROM python:3.8.12-slim-buster AS build
WORKDIR /app
COPY requirements.txt .
</span><span class="koboSpan" id="kobo.591.2">RUN pip install --no-cache-dir -U pip==21.3.1 &amp;&amp; \
    pip install --no-cache-dir --user -r requirements.txt
COPY . </span><span class="koboSpan" id="kobo.591.3">.
</span><span class="koboSpan" id="kobo.591.4"># Run Stage
FROM python:3.8.12-slim-buster AS run
WORKDIR /app
COPY --from=build /root/.local /root/.local
COPY --from=build /app .
</span><span class="koboSpan" id="kobo.591.5">ENV PATH=/root/.local/bin:$PATH
ENV FLASK_APP=app.py
ENV FLASK_ENV=production
EXPOSE 5001
CMD ["python3", "app.py"]</span></pre>
<p><span class="koboSpan" id="kobo.592.1">Let’s break</span><a id="_idIndexMarker1182"/><span class="koboSpan" id="kobo.593.1"> down the </span><span class="No-Break"><span class="koboSpan" id="kobo.594.1">preceding Dockerfile.</span></span></p>
<p><span class="koboSpan" id="kobo.595.1">This</span><a id="_idIndexMarker1183"/><span class="koboSpan" id="kobo.596.1"> Dockerfile defines a multi-stage build for a Flask application. </span><span class="koboSpan" id="kobo.596.2">The Dockerfile has two stages: </span><strong class="source-inline"><span class="koboSpan" id="kobo.597.1">build</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.598.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.599.1">run</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.600.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.601.1">The first stage, </span><strong class="source-inline"><span class="koboSpan" id="kobo.602.1">build</span></strong><span class="koboSpan" id="kobo.603.1">, is responsible for building the application and installing the required dependencies. </span><span class="koboSpan" id="kobo.603.2">Right now, let’s check what each line of the build </span><span class="No-Break"><span class="koboSpan" id="kobo.604.1">stage does:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.605.1">FROM python:3.8.12-slim-buster AS build</span></strong><span class="koboSpan" id="kobo.606.1">: This line sets the base image for the build stage </span><span class="No-Break"><span class="koboSpan" id="kobo.607.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.608.1">python:3.8.12-slim-buster</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.609.1">.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.610.1">WORKDIR /app</span></strong><span class="koboSpan" id="kobo.611.1">: This line sets the working directory </span><span class="No-Break"><span class="koboSpan" id="kobo.612.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.613.1">/app</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.614.1">.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.615.1">COPY requirements.txt .</span></strong><span class="koboSpan" id="kobo.616.1">: This line copies the </span><strong class="source-inline"><span class="koboSpan" id="kobo.617.1">requirements.txt</span></strong><span class="koboSpan" id="kobo.618.1"> file from the host machine to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.619.1">/app</span></strong><span class="koboSpan" id="kobo.620.1"> directory in </span><span class="No-Break"><span class="koboSpan" id="kobo.621.1">the container.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.622.1">RUN pip install --no-cache-dir -U pip==21.3.1 &amp;&amp; \    pip install --no-cache-dir --user -r requirements.txt</span></strong><span class="koboSpan" id="kobo.623.1">: These lines update </span><strong class="source-inline"><span class="koboSpan" id="kobo.624.1">pip</span></strong><span class="koboSpan" id="kobo.625.1"> to version </span><strong class="source-inline"><span class="koboSpan" id="kobo.626.1">21.3.1</span></strong><span class="koboSpan" id="kobo.627.1"> and install the Python packages specified in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.628.1">requirements.txt</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.629.1"> file.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.630.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.631.1">--no-cache-dir</span></strong><span class="koboSpan" id="kobo.632.1"> option is used to prevent the installation from using any cached data from previous runs, which helps ensure that the installed packages are up to date and match the versions specified in </span><strong class="source-inline"><span class="koboSpan" id="kobo.633.1">requirements.txt</span></strong><span class="koboSpan" id="kobo.634.1">. </span><span class="koboSpan" id="kobo.634.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.635.1">--user</span></strong><span class="koboSpan" id="kobo.636.1"> option is used to install the packages to the user’s home directory, which helps avoid </span><span class="No-Break"><span class="koboSpan" id="kobo.637.1">permission issues.</span></span></p></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.638.1">COPY . </span><span class="koboSpan" id="kobo.638.2">.</span></strong><span class="koboSpan" id="kobo.639.1">: This line copies the entire application directory from the host machine to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.640.1">/app</span></strong><span class="koboSpan" id="kobo.641.1"> directory in </span><span class="No-Break"><span class="koboSpan" id="kobo.642.1">the container.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.643.1">FROM python:3.8.12-slim-buster AS run</span></strong><span class="koboSpan" id="kobo.644.1">: This represents the start of the </span><span class="No-Break"><span class="koboSpan" id="kobo.645.1">second stage.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.646.1">The </span><a id="_idIndexMarker1184"/><span class="koboSpan" id="kobo.647.1">second stage, </span><strong class="source-inline"><span class="koboSpan" id="kobo.648.1">run</span></strong><span class="koboSpan" id="kobo.649.1">, is responsible for running the application in a production environment. </span><span class="koboSpan" id="kobo.649.2">The line sets the base image for </span><a id="_idIndexMarker1185"/><span class="koboSpan" id="kobo.650.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.651.1">run</span></strong><span class="koboSpan" id="kobo.652.1"> stage </span><span class="No-Break"><span class="koboSpan" id="kobo.653.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.654.1">python:3.8.12-slim-buster</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.655.1">:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.656.1">WORKDIR /app</span></strong><span class="koboSpan" id="kobo.657.1">: This line sets the working directory </span><span class="No-Break"><span class="koboSpan" id="kobo.658.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.659.1">/app</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.660.1">.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.661.1">COPY --from=build /root/.local /root/.local</span></strong><span class="koboSpan" id="kobo.662.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.663.1">COPY --from=build /app .</span></strong><span class="koboSpan" id="kobo.664.1">: These two lines copy the application directory and the installed packages from the build stage to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.665.1">run</span></strong><span class="koboSpan" id="kobo.666.1"> stage. </span><span class="koboSpan" id="kobo.666.2">The first line copies the installed packages from the build stage to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.667.1">/root/.local</span></strong><span class="koboSpan" id="kobo.668.1"> directory in the run stage. </span><span class="koboSpan" id="kobo.668.2">The second line copies the application directory from the build stage to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.669.1">/app</span></strong><span class="koboSpan" id="kobo.670.1"> directory in the </span><span class="No-Break"><span class="koboSpan" id="kobo.671.1">run stage.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.672.1">ENV PATH=/root/.local/bin:$PATH</span></strong><span class="koboSpan" id="kobo.673.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.674.1">ENV FLASK_APP=app.py</span></strong><span class="koboSpan" id="kobo.675.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.676.1">ENV FLASK_ENV=production</span></strong><span class="koboSpan" id="kobo.677.1">: These three lines set the environment variables for the application. </span><span class="koboSpan" id="kobo.677.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.678.1">PATH</span></strong><span class="koboSpan" id="kobo.679.1"> environment variable is updated to include the </span><strong class="source-inline"><span class="koboSpan" id="kobo.680.1">/root/.local/bin</span></strong><span class="koboSpan" id="kobo.681.1"> directory, which contains the </span><span class="No-Break"><span class="koboSpan" id="kobo.682.1">installed packages.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.683.1">This ensures </span><a id="_idIndexMarker1186"/><span class="koboSpan" id="kobo.684.1">that the installed packages are available in the system </span><strong class="source-inline"><span class="koboSpan" id="kobo.685.1">PATH</span></strong><span class="koboSpan" id="kobo.686.1">. </span><span class="koboSpan" id="kobo.686.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.687.1">FLASK_APP</span></strong><span class="koboSpan" id="kobo.688.1"> environment variable is set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.689.1">app.py</span></strong><span class="koboSpan" id="kobo.690.1">, which specifies the main application file for Flask to run. </span><span class="koboSpan" id="kobo.690.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.691.1">FLASK_ENV</span></strong><span class="koboSpan" id="kobo.692.1"> environment variable is set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.693.1">production</span></strong><span class="koboSpan" id="kobo.694.1">, which enables features such as better error handling and </span><span class="No-Break"><span class="koboSpan" id="kobo.695.1">improved performance.</span></span></p></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.696.1">EXPOSE 5001</span></strong><span class="koboSpan" id="kobo.697.1">: This line exposes port </span><strong class="source-inline"><span class="koboSpan" id="kobo.698.1">5001</span></strong><span class="koboSpan" id="kobo.699.1">, which is the port that the Flask application will </span><span class="No-Break"><span class="koboSpan" id="kobo.700.1">listen on.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.701.1">CMD ["python3", "app.py"]</span></strong><span class="koboSpan" id="kobo.702.1">: This line specifies the default command to run when the container starts. </span><span class="koboSpan" id="kobo.702.2">It runs the </span><strong class="source-inline"><span class="koboSpan" id="kobo.703.1">app.py</span></strong><span class="koboSpan" id="kobo.704.1"> file using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.705.1">python3</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.706.1"> command.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.707.1">Having discussed the Dockerfile for the main Flask application, let’s examine the Dockerfile </span><span class="No-Break"><span class="koboSpan" id="kobo.708.1">for PostgreSQL.</span></span></p>
<p><span class="koboSpan" id="kobo.709.1">Here’s the Dockerfile </span><a id="_idIndexMarker1187"/><span class="koboSpan" id="kobo.710.1">for Postgres to create a </span><span class="No-Break"><span class="koboSpan" id="kobo.711.1">database image:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.712.1">FROM postgres:13-alpineENV POSTGRES_DB=&lt;databse_name&gt;
ENV POSTGRES_USER= &lt;databse_user&gt;
ENV POSTGRES_PASSWORD= &lt;databse_password&gt;
RUN apk add --no-cache --update bash
COPY init.sql /docker-entrypoint-initdb.d/
EXPOSE 5432</span></pre>
<p><span class="koboSpan" id="kobo.713.1">Let’s go through the </span><a id="_idIndexMarker1188"/><span class="No-Break"><span class="koboSpan" id="kobo.714.1">Postgres Dockerfile:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.715.1">FROM postgres:13-alpine</span></strong><span class="koboSpan" id="kobo.716.1">: This line specifies the base image for our Docker container, which is </span><strong class="source-inline"><span class="koboSpan" id="kobo.717.1">postgres:13-alpine</span></strong><span class="koboSpan" id="kobo.718.1">. </span><span class="koboSpan" id="kobo.718.2">This image is based on the Alpine Linux distribution and includes PostgreSQL </span><span class="No-Break"><span class="koboSpan" id="kobo.719.1">version 13.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.720.1">ENV POSTGRES_DB=&lt;database_name&gt;</span></strong><span class="koboSpan" id="kobo.721.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.722.1">ENV POSTGRES_USER=&lt;database_user&gt;</span></strong><span class="koboSpan" id="kobo.723.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.724.1">ENV POSTGRES_PASSWORD=&lt;database_password&gt;</span></strong><span class="koboSpan" id="kobo.725.1">: These three lines set the environment variables for the Postgres container. </span><span class="koboSpan" id="kobo.725.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.726.1">POSTGRES_DB</span></strong><span class="koboSpan" id="kobo.727.1"> variable specifies the name of the database to be created. </span><span class="koboSpan" id="kobo.727.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.728.1">POSTGRES_USER</span></strong><span class="koboSpan" id="kobo.729.1"> variable specifies the username to be created for the database, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.730.1">POSTGRES_PASSWORD</span></strong><span class="koboSpan" id="kobo.731.1"> variable specifies the password for </span><span class="No-Break"><span class="koboSpan" id="kobo.732.1">that user.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.733.1">RUN apk add --no-cache --update bash</span></strong><span class="koboSpan" id="kobo.734.1">: This line copies the </span><strong class="source-inline"><span class="koboSpan" id="kobo.735.1">init.sql</span></strong><span class="koboSpan" id="kobo.736.1"> file to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.737.1">/docker-entrypoint-initdb.d/</span></strong><span class="koboSpan" id="kobo.738.1"> directory in the container. </span><span class="koboSpan" id="kobo.738.2">This directory is used by the Postgres image to run initialization scripts when the container is first started. </span><span class="koboSpan" id="kobo.738.3">In this case, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.739.1">init.sql</span></strong><span class="koboSpan" id="kobo.740.1"> file is a script that will create the database and any </span><span class="No-Break"><span class="koboSpan" id="kobo.741.1">necessary tables.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.742.1">EXPOSE 5432</span></strong><span class="koboSpan" id="kobo.743.1">: This line exposes port </span><strong class="source-inline"><span class="koboSpan" id="kobo.744.1">5432</span></strong><span class="koboSpan" id="kobo.745.1">, which is the default port used by PostgreSQL, to allow connections from outside the container. </span><span class="koboSpan" id="kobo.745.2">However, this does not actually publish the port, as this needs to be done at runtime using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.746.1">docker run</span></strong><span class="koboSpan" id="kobo.747.1"> or </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.748.1">docker-compose</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.749.1"> commands.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.750.1">This </span><a id="_idIndexMarker1189"/><span class="koboSpan" id="kobo.751.1">Postgres Dockerfile can be used to build a Docker </span><a id="_idIndexMarker1190"/><span class="koboSpan" id="kobo.752.1">image for a Postgres database, which can be used in conjunction with React and Flask application Docker containers to build a complete web </span><span class="No-Break"><span class="koboSpan" id="kobo.753.1">application stack.</span></span></p>
<p><span class="koboSpan" id="kobo.754.1">With the Flask application and Postgres images well defined, we will be pushing the created Docker images to AWS ECR for online storage of </span><span class="No-Break"><span class="koboSpan" id="kobo.755.1">Docker images.</span></span></p>
<h1 id="_idParaDest-300"><a id="_idTextAnchor340"/><span class="koboSpan" id="kobo.756.1">Understanding AWS ECR</span></h1>
<p><span class="koboSpan" id="kobo.757.1">Amazon ECR </span><a id="_idIndexMarker1191"/><span class="koboSpan" id="kobo.758.1">is a fully managed Docker registry service that makes it easy to store, manage, and deploy Docker images. </span><span class="koboSpan" id="kobo.758.2">Amazon ECR is integrated with Amazon ECS to provide a seamless experience for building, deploying, and managing containerized applications at scale. </span><span class="koboSpan" id="kobo.758.3">Amazon ECR is designed to scale to meet the needs of even the most demanding containerized applications. </span><span class="koboSpan" id="kobo.758.4">Amazon ECR has security features to protect your container images, including encryption</span><a id="_idIndexMarker1192"/><span class="koboSpan" id="kobo.759.1"> at rest and in transit, and </span><strong class="bold"><span class="koboSpan" id="kobo.760.1">role-based access </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.761.1">control</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.762.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.763.1">RBAC</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.764.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.765.1">To begin using </span><a id="_idIndexMarker1193"/><span class="koboSpan" id="kobo.766.1">Amazon ECR, the first step is to create an ECR repository. </span><span class="koboSpan" id="kobo.766.2">Please refer to the following screenshot of the Amazon </span><span class="No-Break"><span class="koboSpan" id="kobo.767.1">ECR interface.</span></span></p>
<p><span class="koboSpan" id="kobo.768.1">Click on the </span><strong class="bold"><span class="koboSpan" id="kobo.769.1">Get Started</span></strong><span class="koboSpan" id="kobo.770.1"> button to initiate the repository creation process. </span><span class="koboSpan" id="kobo.770.2">This will allow you to establish a dedicated location for storing your </span><span class="No-Break"><span class="koboSpan" id="kobo.771.1">Docker images.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer111">
<span class="koboSpan" id="kobo.772.1"><img alt="Figure 16.10 ﻿– AWS ECR" src="image/Figure_16.10_B18554.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.773.1">Figure 16.10 – AWS ECR</span></p>
<p><span class="koboSpan" id="kobo.774.1">Next, we have a screenshot showcasing a public repository named </span><strong class="source-inline"><span class="koboSpan" id="kobo.775.1">packt-bizza-web-app</span></strong><span class="koboSpan" id="kobo.776.1"> in </span><span class="No-Break"><span class="koboSpan" id="kobo.777.1">Amazon ECR:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer112">
<span class="koboSpan" id="kobo.778.1"><img alt="Figure 16.11 – The public repository" src="image/Figure_16.11_B18554.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.779.1">Figure 16.11 – The public repository</span></p>
<p><span class="koboSpan" id="kobo.780.1">A </span><strong class="bold"><span class="koboSpan" id="kobo.781.1">repository</span></strong><span class="koboSpan" id="kobo.782.1"> is a</span><a id="_idIndexMarker1194"/><span class="koboSpan" id="kobo.783.1"> logical container for storing your Docker images. </span><span class="koboSpan" id="kobo.783.2">Once </span><a id="_idIndexMarker1195"/><span class="koboSpan" id="kobo.784.1">you have created a repository, you can push your Docker images to the repository. </span><span class="koboSpan" id="kobo.784.2">You can then pull your images from the repository to deploy them to your </span><span class="No-Break"><span class="koboSpan" id="kobo.785.1">ECS clusters.</span></span></p>
<p><span class="koboSpan" id="kobo.786.1">Amazon ECR is a powerful tool that can help you to simplify the management of your container images. </span><span class="koboSpan" id="kobo.786.2">Interestingly, Amazon ECR is very cost-effective in storing and managing </span><span class="No-Break"><span class="koboSpan" id="kobo.787.1">container images.</span></span></p>
<p><span class="koboSpan" id="kobo.788.1">Using ECR is free; you only pay for the storage and bandwidth that you use. </span><span class="koboSpan" id="kobo.788.2">Next, we will use Docker Compose to define and run the React, Flask, and </span><span class="No-Break"><span class="koboSpan" id="kobo.789.1">Postgres containers.</span></span></p>
<h1 id="_idParaDest-301"><a id="_idTextAnchor341"/><span class="koboSpan" id="kobo.790.1">Using Docker Compose</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.791.1">Docker Compose</span></strong><span class="koboSpan" id="kobo.792.1"> is a</span><a id="_idIndexMarker1196"/><span class="koboSpan" id="kobo.793.1"> tool for defining and running multi-container Docker applications. </span><span class="koboSpan" id="kobo.793.2">Docker Compose provides a tool to define a set of containers and their relationships to each other, and then run them all with a </span><span class="No-Break"><span class="koboSpan" id="kobo.794.1">single command.</span></span></p>
<p><span class="koboSpan" id="kobo.795.1">With</span><a id="_idIndexMarker1197"/><span class="koboSpan" id="kobo.796.1"> Docker Compose, developers can define the exact configuration of the application’s containers, including the images, environment variables, and network settings. </span><span class="koboSpan" id="kobo.796.2">This ensures that the application runs consistently across different environments and can be </span><span class="No-Break"><span class="koboSpan" id="kobo.797.1">easily reproduced.</span></span></p>
<p><span class="koboSpan" id="kobo.798.1">The following are a </span><a id="_idIndexMarker1198"/><span class="koboSpan" id="kobo.799.1">few components of Docker Compose we need to understand before we delve into details for </span><span class="No-Break"><span class="koboSpan" id="kobo.800.1">configuration definitions:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.801.1">YAML file</span></strong><span class="koboSpan" id="kobo.802.1">: A </span><a id="_idIndexMarker1199"/><span class="koboSpan" id="kobo.803.1">YAML file is used to define the configuration of your application’s containers. </span><span class="koboSpan" id="kobo.803.2">The YAML file specifies the images to use, ports to expose, environment variables, and any other settings that </span><span class="No-Break"><span class="koboSpan" id="kobo.804.1">are required.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.805.1">Services</span></strong><span class="koboSpan" id="kobo.806.1">: Each </span><a id="_idIndexMarker1200"/><span class="koboSpan" id="kobo.807.1">container in your application is defined as a service in the YAML file. </span><span class="koboSpan" id="kobo.807.2">Services can depend on each other and can be started and </span><span class="No-Break"><span class="koboSpan" id="kobo.808.1">stopped together.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.809.1">Networks</span></strong><span class="koboSpan" id="kobo.810.1">: Docker Compose </span><a id="_idIndexMarker1201"/><span class="koboSpan" id="kobo.811.1">creates a network for your application, allowing the containers to communicate with </span><span class="No-Break"><span class="koboSpan" id="kobo.812.1">each other.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.813.1">Volumes</span></strong><span class="koboSpan" id="kobo.814.1">: Volumes </span><a id="_idIndexMarker1202"/><span class="koboSpan" id="kobo.815.1">are used to persist data between </span><span class="No-Break"><span class="koboSpan" id="kobo.816.1">container runs.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.817.1">Commands</span></strong><span class="koboSpan" id="kobo.818.1">: Docker Compose </span><a id="_idIndexMarker1203"/><span class="koboSpan" id="kobo.819.1">provides a set of commands to start, stop, and manage </span><span class="No-Break"><span class="koboSpan" id="kobo.820.1">your application.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.821.1">Now, let’s create</span><a id="_idIndexMarker1204"/><span class="koboSpan" id="kobo.822.1"> a Docker Compose file that manages the relationship between the React frontend, Flask backend, and PostgreSQL </span><span class="No-Break"><span class="koboSpan" id="kobo.823.1">database containers:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.824.1">Inside the main project directory, </span><strong class="source-inline"><span class="koboSpan" id="kobo.825.1">bizza/</span></strong><span class="koboSpan" id="kobo.826.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.827.1">create </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.828.1">docker-compose.yaml</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.829.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.830.1">Define services for each container. </span><span class="koboSpan" id="kobo.830.2">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.831.1">docker-compose.yaml</span></strong><span class="koboSpan" id="kobo.832.1"> file, define a separate service for </span><span class="No-Break"><span class="koboSpan" id="kobo.833.1">each container:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.834.1">version: '3'services:  frontend:    image: &lt;your-ecr-repository&gt;/bizza-frontend-react-      app    ports:      - "3000:3000"  backend:    image: &lt;your-ecr-repository&gt;/bizza-backend-flask-      app    ports:      - "5000:5000"    depends_on:      - db  db:    image: &lt;your-ecr-repository&gt;/bizza-postgresql    environment:      POSTGRES_USER: &lt;your-db-username&gt;      POSTGRES_PASSWORD: &lt;your-db-password&gt;      POSTGRES_DB: &lt;your-db-name&gt;    ports:      - "5432:5432"</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.835.1">In the </span><a id="_idIndexMarker1205"/><span class="koboSpan" id="kobo.836.1">preceding code, we define three services: </span><strong class="source-inline"><span class="koboSpan" id="kobo.837.1">frontend</span></strong><span class="koboSpan" id="kobo.838.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.839.1">backend</span></strong><span class="koboSpan" id="kobo.840.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.841.1">db</span></strong><span class="koboSpan" id="kobo.842.1">. </span><span class="koboSpan" id="kobo.842.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.843.1">frontend</span></strong><span class="koboSpan" id="kobo.844.1"> service runs the </span><em class="italic"><span class="koboSpan" id="kobo.845.1">Bizza</span></em><span class="koboSpan" id="kobo.846.1"> frontend React app, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.847.1">backend</span></strong><span class="koboSpan" id="kobo.848.1"> service runs the </span><em class="italic"><span class="koboSpan" id="kobo.849.1">Bizza</span></em><span class="koboSpan" id="kobo.850.1"> backend Flask app, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.851.1">db</span></strong><span class="koboSpan" id="kobo.852.1"> service runs the </span><span class="No-Break"><span class="koboSpan" id="kobo.853.1">PostgreSQL database.</span></span></p>
<p><span class="koboSpan" id="kobo.854.1">Now, let’s configure</span><a id="_idIndexMarker1206"/><span class="koboSpan" id="kobo.855.1"> networking and</span><a id="_idIndexMarker1207"/><span class="koboSpan" id="kobo.856.1"> dependencies. </span><span class="koboSpan" id="kobo.856.2">Use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.857.1">ports</span></strong><span class="koboSpan" id="kobo.858.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.859.1">depend_ on</span></strong><span class="koboSpan" id="kobo.860.1"> options to configure the network connections between the services. </span><span class="koboSpan" id="kobo.860.2">For instance, the frontend service is exposed on port </span><strong class="source-inline"><span class="koboSpan" id="kobo.861.1">3000</span></strong><span class="koboSpan" id="kobo.862.1">, the backend service is exposed on port </span><strong class="source-inline"><span class="koboSpan" id="kobo.863.1">5000</span></strong><span class="koboSpan" id="kobo.864.1">, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.865.1">db</span></strong><span class="koboSpan" id="kobo.866.1"> service is exposed on port </span><strong class="source-inline"><span class="koboSpan" id="kobo.867.1">5432</span></strong><span class="koboSpan" id="kobo.868.1">. </span><span class="koboSpan" id="kobo.868.2">The backend service also depends on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.869.1">db</span></strong><span class="koboSpan" id="kobo.870.1"> service, so the backend will start after the </span><strong class="source-inline"><span class="koboSpan" id="kobo.871.1">db</span></strong><span class="koboSpan" id="kobo.872.1"> service </span><span class="No-Break"><span class="koboSpan" id="kobo.873.1">is running.</span></span></p>
<p><span class="koboSpan" id="kobo.874.1">Once </span><a id="_idIndexMarker1208"/><span class="koboSpan" id="kobo.875.1">we’ve </span><a id="_idIndexMarker1209"/><span class="koboSpan" id="kobo.876.1">defined the services in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.877.1">docker-compose.yaml</span></strong><span class="koboSpan" id="kobo.878.1"> file, we can start the containers using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.879.1">docker-compose up</span></strong><span class="koboSpan" id="kobo.880.1"> command. </span><span class="koboSpan" id="kobo.880.2">This will start the containers and connect them to the </span><span class="No-Break"><span class="koboSpan" id="kobo.881.1">appropriate network.</span></span></p>
<p><span class="koboSpan" id="kobo.882.1">With Docker Compose managing the application’s containers, we can simplify the process of starting and stopping our application, as well as ensure that all the required components are running correctly and communicating with </span><span class="No-Break"><span class="koboSpan" id="kobo.883.1">each other.</span></span></p>
<p><span class="koboSpan" id="kobo.884.1">Interestingly, Docker Compose</span><a id="_idIndexMarker1210"/><span class="koboSpan" id="kobo.885.1"> is a useful tool for managing containers; however, Docker Compose is more suited to small-scale deployments and development environments. </span><span class="koboSpan" id="kobo.885.2">Docker Compose serves the purpose of the </span><em class="italic"><span class="koboSpan" id="kobo.886.1">bizza</span></em><span class="koboSpan" id="kobo.887.1"> project, being a small-scale application for </span><span class="No-Break"><span class="koboSpan" id="kobo.888.1">learning purposes.</span></span></p>
<p><span class="koboSpan" id="kobo.889.1">However, AWS Elastic Beanstalk, on the other hand, is designed to handle production-grade workloads and provides many features and benefits that can help simplify the management and scaling of web applications. </span><span class="koboSpan" id="kobo.889.2">Regardless, we will pivot the </span><em class="italic"><span class="koboSpan" id="kobo.890.1">bizza</span></em><span class="koboSpan" id="kobo.891.1"> application's final deployment on AWS </span><span class="No-Break"><span class="koboSpan" id="kobo.892.1">Elastic Beanstalk.</span></span></p>
<p><span class="koboSpan" id="kobo.893.1">In the next section, we will explore AWS Elastic Beanstalk, a service for deploying and managing applications in </span><span class="No-Break"><span class="koboSpan" id="kobo.894.1">the cloud.</span></span></p>
<h1 id="_idParaDest-302"><a id="_idTextAnchor342"/><span class="koboSpan" id="kobo.895.1">Deploying React and Flask applications to AWS Elastic Beanstalk</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.896.1">AWS Elastic Beanstalk</span></strong><span class="koboSpan" id="kobo.897.1"> is a</span><a id="_idIndexMarker1211"/><span class="koboSpan" id="kobo.898.1"> fully managed AWS cloud service that </span><a id="_idIndexMarker1212"/><span class="koboSpan" id="kobo.899.1">allows developers to easily </span><a id="_idIndexMarker1213"/><span class="koboSpan" id="kobo.900.1">deploy and manage web applications and services on AWS. </span><span class="koboSpan" id="kobo.900.2">AWS Elastic Beanstalk </span><a id="_idIndexMarker1214"/><span class="koboSpan" id="kobo.901.1">provides a</span><a id="_idIndexMarker1215"/><span class="koboSpan" id="kobo.902.1"> platform that simplifies the process of deploying and managing web applications on AWS by automatically handling the infrastructure provisioning, load balancing, and scaling of </span><span class="No-Break"><span class="koboSpan" id="kobo.903.1">the application.</span></span></p>
<p><span class="koboSpan" id="kobo.904.1">You can deploy Elastic Beanstalk on a wide range of programming languages and web frameworks, including Node.js, Python, Ruby, and Go. </span><span class="koboSpan" id="kobo.904.2">Elastic Beanstalk also integrates with other AWS services such as Amazon RDS, Amazon DynamoDB, and Amazon SNS to provide a complete solution for building and scaling </span><span class="No-Break"><span class="koboSpan" id="kobo.905.1">web applications.</span></span></p>
<p><span class="koboSpan" id="kobo.906.1">With </span><a id="_idIndexMarker1216"/><span class="koboSpan" id="kobo.907.1">Elastic Beanstalk, developers </span><a id="_idIndexMarker1217"/><span class="koboSpan" id="kobo.908.1">can easily focus on coding. </span><span class="koboSpan" id="kobo.908.2">Once you are ready to deploy your </span><a id="_idIndexMarker1218"/><span class="koboSpan" id="kobo.909.1">application, you can simply upload your application package or link to a repository, and then choose the appropriate platform and environment for your application. </span><span class="koboSpan" id="kobo.909.2">Elastic Beanstalk</span><a id="_idIndexMarker1219"/><span class="koboSpan" id="kobo.910.1"> automatically provisions the required resources and sets up the environment and can also automatically scale the application based </span><span class="No-Break"><span class="koboSpan" id="kobo.911.1">on demand.</span></span></p>
<p><span class="koboSpan" id="kobo.912.1">Also, AWS Elastic Beanstalk provides a range of capabilities and tools that help developers streamline their development </span><a id="_idIndexMarker1220"/><span class="koboSpan" id="kobo.913.1">workflows, such as </span><strong class="bold"><span class="koboSpan" id="kobo.914.1">continuous integration and continuous delivery</span></strong><span class="koboSpan" id="kobo.915.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.916.1">CI/CD</span></strong><span class="koboSpan" id="kobo.917.1">) pipelines, monitoring and logging tools, and integration with popular development tools such as Git </span><span class="No-Break"><span class="koboSpan" id="kobo.918.1">and Jenkins.</span></span></p>
<p><span class="koboSpan" id="kobo.919.1">Now, let’s get started with using Elastic Beanstalk to deploy our application. </span><span class="koboSpan" id="kobo.919.2">This guide assumes you have created an </span><a id="_idIndexMarker1221"/><span class="koboSpan" id="kobo.920.1">AWS account. </span><span class="koboSpan" id="kobo.920.2">If not, go to </span><a href="https://aws.amazon.com/free/"><span class="koboSpan" id="kobo.921.1">https://aws.amazon.com/free/</span></a><span class="koboSpan" id="kobo.922.1"> and follow the instructions to create an AWS account. </span><span class="koboSpan" id="kobo.922.2">The AWS free tier is enough to deploy this </span><span class="No-Break"><span class="koboSpan" id="kobo.923.1">book project:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.924.1">Log in to your AWS account and go to the </span><a id="_idIndexMarker1222"/><span class="koboSpan" id="kobo.925.1">Amazon ECR console </span><span class="No-Break"><span class="koboSpan" id="kobo.926.1">at </span></span><a href="https://console.aws.amazon.com/ecr/"><span class="No-Break"><span class="koboSpan" id="kobo.927.1">https://console.aws.amazon.com/ecr/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.928.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.929.1">To create an Amazon ECR repository, you can use the </span><span class="No-Break"><span class="koboSpan" id="kobo.930.1">following steps:</span></span><ol><li class="upper-roman"><span class="koboSpan" id="kobo.931.1">Go to the Amazon </span><span class="No-Break"><span class="koboSpan" id="kobo.932.1">ECR console.</span></span></li>
<li class="upper-roman"><span class="koboSpan" id="kobo.933.1">In the navigation pane, </span><span class="No-Break"><span class="koboSpan" id="kobo.934.1">select </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.935.1">Repositories</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.936.1">.</span></span></li>
<li class="upper-roman"><span class="koboSpan" id="kobo.937.1">Select </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.938.1">Create repository</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.939.1">.</span></span></li>
<li class="upper-roman"><span class="koboSpan" id="kobo.940.1">In the </span><strong class="bold"><span class="koboSpan" id="kobo.941.1">Repository name</span></strong><span class="koboSpan" id="kobo.942.1"> field, enter a name for </span><span class="No-Break"><span class="koboSpan" id="kobo.943.1">your repository.</span></span></li>
<li class="upper-roman"><span class="koboSpan" id="kobo.944.1">In the </span><strong class="bold"><span class="koboSpan" id="kobo.945.1">Repository type</span></strong><span class="koboSpan" id="kobo.946.1"> field, select </span><strong class="bold"><span class="koboSpan" id="kobo.947.1">Public</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.948.1">or </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.949.1">Private</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.950.1">.</span></span></li>
<li class="upper-roman"><span class="No-Break"><span class="koboSpan" id="kobo.951.1">Select </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.952.1">Create</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.953.1">.</span></span></li>
</ol></li>
<li><span class="koboSpan" id="kobo.954.1">Alternatively, you </span><a id="_idIndexMarker1223"/><span class="koboSpan" id="kobo.955.1">can create an Amazon ECR repository with the following AWS </span><span class="No-Break"><span class="koboSpan" id="kobo.956.1">CLI command:</span></span><pre class="source-code"><strong class="bold"><span class="koboSpan" id="kobo.957.1">aws ecr create-repository --repository-name nameofyourrepository</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.958.1">However, to successfully run the preceding command you need to have the </span><span class="No-Break"><span class="koboSpan" id="kobo.959.1">following sorted:</span></span></p><ul><li><span class="koboSpan" id="kobo.960.1">Have an AWS account </span><a id="_idIndexMarker1224"/><span class="koboSpan" id="kobo.961.1">and an IAM user with permissions to create ECR repositories. </span><span class="koboSpan" id="kobo.961.2">You can find the link to the permissions JSON file on the GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.962.1">at </span></span><a href="B18554_16.xhtml"><span class="No-Break"><span class="koboSpan" id="kobo.963.1">https://github.com/PacktPublishing/Full-Stack-Flask-and-React/blob/main/Chapter16/bizza/Deployment/ecr-permissions.json</span></span></a></li>
<li><span class="koboSpan" id="kobo.964.1">Have AWS CLI installed and configured with your </span><span class="No-Break"><span class="koboSpan" id="kobo.965.1">AWS credentials.</span></span></li>
</ul></li>
<li><span class="koboSpan" id="kobo.966.1">Next, we need to push the Docker images to the Amazon ECR repository. </span><span class="koboSpan" id="kobo.966.2">To push the bizza application Docker images to the Amazon ECR repository, follow </span><span class="No-Break"><span class="koboSpan" id="kobo.967.1">these steps:</span></span><ol><li class="upper-roman"><span class="koboSpan" id="kobo.968.1">On the command line, navigate to the directory that contains each of the applications’ Dockerfile. </span><span class="koboSpan" id="kobo.968.2">Build the Docker image with the </span><span class="No-Break"><span class="koboSpan" id="kobo.969.1">following command:</span></span><pre class="source-code"><strong class="bold"><span class="koboSpan" id="kobo.970.1">docker build -t &lt;image-name&gt; .</span></strong></pre></li>
</ol><ol><li class="upper-roman" value="2"><span class="koboSpan" id="kobo.971.1">Then, tag your image with the </span><span class="No-Break"><span class="koboSpan" id="kobo.972.1">following command:</span></span><pre class="source-code"><strong class="bold"><span class="koboSpan" id="kobo.973.1">docker tag &lt;docker_image_name&gt;:&lt;tag_name&gt; &lt;AWS_ACCOUNT_ID&gt;.dkr.ecr.&lt;region&gt;.amazonaws.com/&lt;AWS_REPOSITORY_NAME&gt;:&lt;tag_name&gt;</span></strong></pre></li>
</ol><ol><li class="upper-roman" value="3"><span class="koboSpan" id="kobo.974.1">Push each of the Docker images to the Amazon ECR repository. </span><span class="koboSpan" id="kobo.974.2">Inside your project directory, run </span><strong class="source-inline"><span class="koboSpan" id="kobo.975.1">docker login</span></strong><span class="koboSpan" id="kobo.976.1"> and enter docker login credentials. </span><span class="koboSpan" id="kobo.976.2">Once done, run the </span><strong class="source-inline"><span class="koboSpan" id="kobo.977.1">aws configure</span></strong><span class="koboSpan" id="kobo.978.1"> command to log in to AWS </span><span class="No-Break"><span class="koboSpan" id="kobo.979.1">as well.</span></span></li>
<li class="upper-roman"><span class="koboSpan" id="kobo.980.1">Once you are logged in to both Docker and AWS in your terminal, run the </span><span class="No-Break"><span class="koboSpan" id="kobo.981.1">following command:</span></span><pre class="source-code"><strong class="bold"><span class="koboSpan" id="kobo.982.1">aws ecr get-login-password --region &lt;region&gt; | docker login --username AWS --password-stdin AWS_ACCOUNT_ID.dkr.ecr.&lt;region&gt;.amazonaws.com</span></strong></pre></li>
</ol><p class="list-inset"><span class="koboSpan" id="kobo.983.1">Let’s go over the aspects of the </span><span class="No-Break"><span class="koboSpan" id="kobo.984.1">preceding command:</span></span></p><ul><li><strong class="source-inline"><span class="koboSpan" id="kobo.985.1">aws ecr get-login-password</span></strong><span class="koboSpan" id="kobo.986.1">:- This command retrieves an authentication token </span><span class="No-Break"><span class="koboSpan" id="kobo.987.1">from ECR.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.988.1">--region &lt;region&gt;</span></strong><span class="koboSpan" id="kobo.989.1">: This specifies the region where the ECR registry is located. </span><span class="koboSpan" id="kobo.989.2">If you do not know where your ECR repository is located, run the following command: </span><strong class="source-inline"><span class="koboSpan" id="kobo.990.1">aws ecr describe-repositories –</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.991.1">repository-names nameofyourrepository</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.992.1">.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.993.1">|</span></strong><span class="koboSpan" id="kobo.994.1">: This is the pipe operator. </span><span class="koboSpan" id="kobo.994.2">It tells the shell to take the output of the first command and pass it as input to the </span><span class="No-Break"><span class="koboSpan" id="kobo.995.1">second command.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.996.1">docker login</span></strong><span class="koboSpan" id="kobo.997.1">: This command logs you in to a </span><span class="No-Break"><span class="koboSpan" id="kobo.998.1">Docker registry.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.999.1">--username AWS</span></strong><span class="koboSpan" id="kobo.1000.1">: This specifies the username to use when logging in to </span><span class="No-Break"><span class="koboSpan" id="kobo.1001.1">the registry.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1002.1">--password-stdin</span></strong><span class="koboSpan" id="kobo.1003.1">:- This </span><a id="_idIndexMarker1225"/><span class="koboSpan" id="kobo.1004.1">tells the </span><a id="_idIndexMarker1226"/><span class="koboSpan" id="kobo.1005.1">Docker CLI to read the password from </span><span class="No-Break"><span class="koboSpan" id="kobo.1006.1">standard input.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1007.1">&lt;AWS_ACCOUNT_ID&gt;.dkr.ecr.&lt;region&gt;.amazonaws.com</span></strong><span class="koboSpan" id="kobo.1008.1">:- This is the registry ID of the ECR registry you want to log </span><span class="No-Break"><span class="koboSpan" id="kobo.1009.1">in to.</span></span></li>
</ul><ol><li class="upper-roman" value="5"><span class="koboSpan" id="kobo.1010.1">Enter </span><strong class="source-inline"><span class="koboSpan" id="kobo.1011.1">docker push &lt;account-id&gt;.dkr.ecr.&lt;region&gt;.amazonaws.com/&lt;nameof yourrepository:&lt;tag_name&gt;&gt;</span></strong><span class="koboSpan" id="kobo.1012.1"> in each of the project </span><span class="No-Break"><span class="koboSpan" id="kobo.1013.1">component directories.</span></span></li>
</ol></li>
<li><span class="koboSpan" id="kobo.1014.1">To create an Elastic Beanstalk environment, you can use the </span><span class="No-Break"><span class="koboSpan" id="kobo.1015.1">following steps:</span></span><ol><li class="upper-roman"><span class="koboSpan" id="kobo.1016.1">Go to the Elastic Beanstalk console </span><span class="No-Break"><span class="koboSpan" id="kobo.1017.1">at </span></span><a href="https://console.aws.amazon.com/elasticbeanstalk"><span class="No-Break"><span class="koboSpan" id="kobo.1018.1">https://console.aws.amazon.com/elasticbeanstalk</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1019.1">.</span></span></li>
<li class="upper-roman"><span class="koboSpan" id="kobo.1020.1">In the navigation pane, select </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1021.1">Create environment</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1022.1">.</span></span></li>
<li class="upper-roman"><span class="koboSpan" id="kobo.1023.1">In the </span><strong class="bold"><span class="koboSpan" id="kobo.1024.1">Platform</span></strong><span class="koboSpan" id="kobo.1025.1"> section, </span><span class="No-Break"><span class="koboSpan" id="kobo.1026.1">select </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1027.1">Docker</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1028.1">.</span></span></li>
<li class="upper-roman"><span class="koboSpan" id="kobo.1029.1">In the </span><strong class="bold"><span class="koboSpan" id="kobo.1030.1">Application</span></strong><span class="koboSpan" id="kobo.1031.1"> code section, select </span><strong class="bold"><span class="koboSpan" id="kobo.1032.1">Use an </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1033.1">existing application</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1034.1">.</span></span></li>
<li class="upper-roman"><span class="koboSpan" id="kobo.1035.1">In the </span><strong class="bold"><span class="koboSpan" id="kobo.1036.1">Application code repository</span></strong><span class="koboSpan" id="kobo.1037.1"> field, enter the URL of your Docker </span><span class="No-Break"><span class="koboSpan" id="kobo.1038.1">image repository.</span></span></li>
<li class="upper-roman"><span class="koboSpan" id="kobo.1039.1">In the </span><strong class="bold"><span class="koboSpan" id="kobo.1040.1">Application name</span></strong><span class="koboSpan" id="kobo.1041.1"> field, enter a name for </span><span class="No-Break"><span class="koboSpan" id="kobo.1042.1">your environment.</span></span></li>
<li class="upper-roman"><span class="koboSpan" id="kobo.1043.1">Select </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1044.1">Create environment</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1045.1">.</span></span></li>
</ol></li>
<li><span class="koboSpan" id="kobo.1046.1">To configure the Elastic Beanstalk environment to use the Amazon ECR repository, you can use the </span><span class="No-Break"><span class="koboSpan" id="kobo.1047.1">following steps:</span></span><ol><li class="upper-roman"><span class="koboSpan" id="kobo.1048.1">In the Elastic Beanstalk console, select the name of </span><span class="No-Break"><span class="koboSpan" id="kobo.1049.1">your environment.</span></span></li>
<li class="upper-roman"><span class="koboSpan" id="kobo.1050.1">In the navigation pane, </span><span class="No-Break"><span class="koboSpan" id="kobo.1051.1">select </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1052.1">Configuration</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1053.1">.</span></span></li>
<li class="upper-roman"><span class="koboSpan" id="kobo.1054.1">In the </span><strong class="bold"><span class="koboSpan" id="kobo.1055.1">Software</span></strong><span class="koboSpan" id="kobo.1056.1"> section, </span><span class="No-Break"><span class="koboSpan" id="kobo.1057.1">select </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1058.1">Docker</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1059.1">.</span></span></li>
<li class="upper-roman"><span class="koboSpan" id="kobo.1060.1">In the </span><strong class="bold"><span class="koboSpan" id="kobo.1061.1">Repository URL</span></strong><span class="koboSpan" id="kobo.1062.1"> field, enter the URL of your Amazon </span><span class="No-Break"><span class="koboSpan" id="kobo.1063.1">ECR repository.</span></span></li>
<li class="upper-roman"><span class="No-Break"><span class="koboSpan" id="kobo.1064.1">Select </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1065.1">Save</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1066.1">.</span></span></li>
</ol></li>
<li><span class="koboSpan" id="kobo.1067.1">To </span><a id="_idIndexMarker1227"/><span class="koboSpan" id="kobo.1068.1">deploy </span><a id="_idIndexMarker1228"/><span class="koboSpan" id="kobo.1069.1">the application to </span><a id="_idIndexMarker1229"/><span class="koboSpan" id="kobo.1070.1">the Elastic Beanstalk environment, you </span><a id="_idIndexMarker1230"/><span class="koboSpan" id="kobo.1071.1">can use the </span><span class="No-Break"><span class="koboSpan" id="kobo.1072.1">following steps:</span></span><ol><li class="upper-roman"><span class="koboSpan" id="kobo.1073.1">In the Elastic Beanstalk console, select the name of </span><span class="No-Break"><span class="koboSpan" id="kobo.1074.1">your environment.</span></span></li>
<li class="upper-roman"><span class="koboSpan" id="kobo.1075.1">In the navigation pane, </span><span class="No-Break"><span class="koboSpan" id="kobo.1076.1">select </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1077.1">Deploy</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1078.1">.</span></span></li>
<li class="upper-roman"><span class="koboSpan" id="kobo.1079.1">In the </span><strong class="bold"><span class="koboSpan" id="kobo.1080.1">Deployment method</span></strong><span class="koboSpan" id="kobo.1081.1"> section, select </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1082.1">One-click deploy</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1083.1">.</span></span></li>
<li class="upper-roman"><span class="No-Break"><span class="koboSpan" id="kobo.1084.1">Select </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1085.1">Deploy</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1086.1">.</span></span></li>
</ol><p class="list-inset"><span class="koboSpan" id="kobo.1087.1">Now the application is deployed to the Elastic Beanstalk environment. </span><span class="koboSpan" id="kobo.1087.2">You can access the application by using the URL that is displayed in the Elastic </span><span class="No-Break"><span class="koboSpan" id="kobo.1088.1">Beanstalk console.</span></span></p></li>
</ol>
<p><span class="koboSpan" id="kobo.1089.1">AWS Elastic Beanstalk is undoubtedly an excellent choice for developers who want to focus on building applications and services rather than managing infrastructure. </span><span class="koboSpan" id="kobo.1089.2">AWS Elastic Beanstalk provides a simple, scalable, and flexible platform that can help developers quickly and easily deploy applications on the AWS </span><span class="No-Break"><span class="koboSpan" id="kobo.1090.1">cloud platform.</span></span></p>
<h1 id="_idParaDest-303"><a id="_idTextAnchor343"/><span class="koboSpan" id="kobo.1091.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.1092.1">In this chapter, we explored the world of containerization and deployment. </span><span class="koboSpan" id="kobo.1092.2">We began by discussing what containerization is and why it is useful for modern software development. </span><span class="koboSpan" id="kobo.1092.3">We then introduced Docker, the most popular containerization technology, and learned how to use it to package and deploy React and </span><span class="No-Break"><span class="koboSpan" id="kobo.1093.1">Flask applications.</span></span></p>
<p><span class="koboSpan" id="kobo.1094.1">Next, we explored the use of Docker Compose, a tool for defining and running multi-container Docker applications. </span><span class="koboSpan" id="kobo.1094.2">We learned how to use Docker Compose to orchestrate the deployment of our applications across </span><span class="No-Break"><span class="koboSpan" id="kobo.1095.1">multiple containers.</span></span></p>
<p><span class="koboSpan" id="kobo.1096.1">We also delved into AWS ECR, a fully managed container registry service that allows developers to store, manage, and deploy Docker container images securely and reliably. </span><span class="koboSpan" id="kobo.1096.2">Finally, we looked at AWS Elastic Beanstalk, a service that simplifies the process of deploying, managing, and scaling web applications. </span><span class="koboSpan" id="kobo.1096.3">We learned how to deploy our dockerized React and Flask applications to Elastic Beanstalk with all the features with security </span><span class="No-Break"><span class="koboSpan" id="kobo.1097.1">and scalability.</span></span></p>
<p><span class="koboSpan" id="kobo.1098.1">In a nutshell, containerization and deployment are critical components of modern software development, and tools such as Docker and AWS services such as Elastic Container Registry and Elastic Beanstalk are essential for managing and scaling </span><span class="No-Break"><span class="koboSpan" id="kobo.1099.1">container-based applications.</span></span></p>
<p><span class="koboSpan" id="kobo.1100.1">We extend our sincere gratitude to you for selecting this book as your guide in mastering the art of full stack development. </span><span class="koboSpan" id="kobo.1100.2">Your choice reflects your determination to embark on a transformative journey that combines the power of modern web technologies. </span><span class="koboSpan" id="kobo.1100.3">It is our honor to accompany you on this path of discovery </span><span class="No-Break"><span class="koboSpan" id="kobo.1101.1">and learning.</span></span></p>
<p><span class="koboSpan" id="kobo.1102.1">Throughout the pages of this book, we have meticulously crafted a comprehensive roadmap to equip you with the skill set needed to conquer the realms of both frontend and backend development. </span><span class="koboSpan" id="kobo.1102.2">We delved into the depths of React, unraveling its component-based architecture, state management, and dynamic user interfaces. </span><span class="koboSpan" id="kobo.1102.3">Simultaneously, we navigated the intricacies of Flask, empowering you to construct robust APIs, manage databases, and handle server-side operations </span><span class="No-Break"><span class="koboSpan" id="kobo.1103.1">with finesse.</span></span></p>
<p><span class="koboSpan" id="kobo.1104.1">As you turn the final pages of this book, please take a moment to appreciate the knowledge you’ve gained and the skills you’ve honed. </span><span class="koboSpan" id="kobo.1104.2">You now possess the tools to craft stunning user interfaces, harness the power of server-side applications, and seamlessly connect frontend and backend functionalities. </span><span class="koboSpan" id="kobo.1104.3">Your journey as a full stack developer has begun, and the possibilities </span><span class="No-Break"><span class="koboSpan" id="kobo.1105.1">are limitless.</span></span></p>
<p><span class="koboSpan" id="kobo.1106.1">But wait, your expedition doesn’t end here! </span><span class="koboSpan" id="kobo.1106.2">As you close this chapter, new horizons await you. </span><span class="koboSpan" id="kobo.1106.3">The world of technology is ever-evolving, and your dedication to mastering full stack development aligns perfectly with the opportunities that lie ahead. </span><span class="koboSpan" id="kobo.1106.4">Whether you choose to build intricate web applications, design intuitive user experiences, or contribute to innovative projects, your expertise will be a cornerstone </span><span class="No-Break"><span class="koboSpan" id="kobo.1107.1">of success.</span></span></p>
<p><span class="koboSpan" id="kobo.1108.1">So, with your newfound proficiency in React and Flask, what’s next? </span><span class="koboSpan" id="kobo.1108.2">Perhaps you’ll explore advanced React frameworks such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1109.1">Next.js</span></strong><span class="koboSpan" id="kobo.1110.1">, dive deeper into microservices with Flask, or even embark on creating your own groundbreaking applications. </span><span class="koboSpan" id="kobo.1110.2">The road ahead is paved with endless prospects, and your ability </span><a id="_idTextAnchor344"/><span class="koboSpan" id="kobo.1111.1">to shape digital experiences has never been </span><span class="No-Break"><span class="koboSpan" id="kobo.1112.1">more significant.</span></span></p>
<p><span class="koboSpan" id="kobo.1113.1">Once again, thank you for choosing </span><em class="italic"><span class="koboSpan" id="kobo.1114.1">Full Stack with Flask and React</span></em><span class="koboSpan" id="kobo.1115.1"> as your guide. </span><span class="koboSpan" id="kobo.1115.2">Your commitment to learning and growth is inspiring, and we eagerly anticipate the remarkable contributions you will make to the ever-evolving world </span><span class="No-Break"><span class="koboSpan" id="kobo.1116.1">of technology.</span></span></p>
</div>
</body></html>