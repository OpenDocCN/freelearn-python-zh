- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Linked Lists
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链表
- en: Python’s list implementation is quite powerful and can encompass several different
    use cases. We have discussed the built-in data structures of **lists** in Python
    in *Chapter 1*, *Python Data Types and Structures*. Most of the time, Python’s
    built-in implementation of a list data structure is used to store data using a
    linked list. In this chapter, we will understand how linked lists work along with
    their internals.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Python的列表实现非常强大，可以涵盖多个不同的用例。我们在*第1章*，*Python数据类型和结构*中讨论了Python的内置数据结构**列表**。大多数时候，Python的内置列表数据结构实现用于使用链表存储数据。在本章中，我们将了解链表的工作原理及其内部结构。
- en: A linked list is a data structure where the data elements are stored in a linear
    order. Linked lists provide efficient storage of data in linear order through
    pointer structures. Pointers are used to store the memory address of data items.
    They store the data and location, and the location stores the position of the
    next data item in the memory.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 链表是一种数据结构，其中数据元素按线性顺序存储。链表通过指针结构提供高效的数据线性存储。指针用于存储数据项的内存地址。它们存储数据和位置，位置存储内存中下一个数据项的位置。
- en: 'The focus of this chapter will be the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的重点将是以下内容：
- en: Arrays
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组
- en: Introducing linked lists
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链表的介绍
- en: Singly linked lists
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单链表
- en: Doubly linked lists
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 双向链表
- en: Circular lists
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环链表
- en: Practical applications of linked lists
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链表的实用应用
- en: Before discussing linked lists, let us first discuss an array, which is one
    of the most elementary data structures.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论链表之前，让我们首先讨论数组，它是最基本的数据结构之一。
- en: Arrays
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组
- en: An array is a collection of data items of the same type, whereas a linked list
    is a collection of the same data type stored sequentially and connected through
    pointers. In the case of lists, the data elements are stored in different memory
    locations, whereas the array elements are stored in contiguous memory locations.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是一系列相同类型的数据项的集合，而链表是按顺序存储并通过指针连接的相同数据类型的集合。在列表的情况下，数据元素存储在不同的内存位置，而数组元素存储在连续的内存位置中。
- en: An array stores the data of the same data type and each data element in the
    array is stored in contiguous memory locations. Storing multiple data values of
    the same type makes it easier and faster to compute the position of any element
    in the array using **offset** and **base address**. The term *base address* refers
    to the address of memory location where the first element is stored, and offset
    refers to an integer indicating the displacement between the first element and
    a given element.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 数组存储相同数据类型的数据，数组中的每个数据元素都存储在连续的内存位置中。存储多个相同类型的数据值使得使用**偏移量**和**基址**计算数组中任何元素的位容易且快速。术语*基址*指的是存储第一个元素的内存位置的地址，而偏移量指的是一个整数，表示第一个元素和给定元素之间的位移。
- en: '*Figure 4.1* demonstrates an array holding a sequence of seven integer values
    that are stored sequentially in contiguous memory locations. The first element
    (data value 3) is stored at index 0, the second element at index position 1, and
    so on.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4.1* 展示了一个包含七个整数值的数组，这些值按顺序存储在连续的内存位置中。第一个元素（数据值3）存储在索引0处，第二个元素在索引位置1，以此类推。'
- en: '![](img/B17217_04_01.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_04_01.png)'
- en: 'Figure 4.1: Representation of a one-dimensional array'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1：一维数组的表示
- en: To store, traverse, and access array elements is very fast as compared to lists
    since elements can be accessed randomly using their index positions, whereas in
    the case of a linked list, the elements are accessed sequentially. Therefore,
    if the data to be stored in the array is large and the system has low memory,
    the array data structure will not be a good choice to store the data because it
    is difficult to allot a large block of memory locations. The array data structure
    has further limitations in that it has a static size that has to be declared at
    the time of creation.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 与列表相比，存储、遍历和访问数组元素非常快，因为可以通过它们的索引位置随机访问元素，而在链表的情况下，元素是顺序访问的。因此，如果要存储在数组中的数据量很大且系统内存较低，数组数据结构不是存储数据的良好选择，因为很难分配一大块内存位置。数组数据结构还有进一步的限制，即它具有静态大小，必须在创建时声明。
- en: In addition, the insertion and deletion operations in array data structures
    are slow as compared to linked lists. This is because it is difficult to insert
    an element in an array at a given location since all data elements after that
    desired position must be shifted and then new elements inserted in between. Thus,
    array data structures are suitable when we want to do a lot of accessing of elements
    and fewer insertion and deletion operations, whereas linked lists are suitable
    in applications where the size of the list is not fixed, and a lot of insertion
    and deletion operations will be required.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，与链表相比，数组数据结构中的插入和删除操作较慢。这是因为很难在数组中给定位置插入一个元素，因为在此位置之后的所有数据元素都必须移动，然后才能在它们之间插入新元素。因此，当我们需要进行大量元素访问而插入和删除操作较少时，数组数据结构是合适的，而链表适用于列表大小不固定且需要大量插入和删除操作的应用。
- en: Introducing linked lists
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍链表
- en: 'The linked list is an important and popular data structure with the following
    properties:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 链表是一个重要且流行的数据结构，具有以下特性：
- en: The data elements are stored in memory in different locations that are connected
    through pointers. A pointer is an object that can store the memory address of
    a variable, and each data element points to the next data element and so on until
    the last element, which points to `None`.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据元素存储在内存的不同位置，通过指针连接。指针是一个可以存储变量内存地址的对象，每个数据元素都指向下一个数据元素，以此类推，直到最后一个元素，它指向`None`。
- en: The length of the list can increase or decrease during the execution of the
    program.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在程序执行过程中，列表的长度可以增加或减少。
- en: Contrary to arrays, linked lists store data items sequentially in different
    locations in memory, wherein each data item is stored separately and linked to
    other data items using pointers. Each of these data items is called a node. More
    specifically, a node stores the actual data and a pointer. In *Figure 4.2*, nodes
    A and B store the data independently, and node A is connected to node B.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组不同，链表在内存的不同位置顺序存储数据项，其中每个数据项都是独立存储的，并使用指针与其他数据项链接。这些数据项中的每一个都称为节点。更具体地说，节点存储实际数据和指针。在*图4.2*中，节点A和B独立存储数据，节点A连接到节点B。
- en: '![](img/B17217_04_02.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_04_02.png)'
- en: 'Figure 4.2: A linked list with two nodes'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2：包含两个节点的链表
- en: Moreover, the nodes can have links to other nodes based differently on how we
    want to store the data, and on which basis we will learn various kinds of data
    structures, such as singular linked lists, doubly linked lists, circular link
    lists, and trees.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，节点可以根据我们想要存储数据的方式以及基于何种基础来链接到其他节点，我们将学习各种数据结构，如单链表、双链表、循环链表和树。
- en: Nodes and pointers
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 节点和指针
- en: A node is a key component of several data structures such as linked lists. A
    node is a container of data, together with one or more links to other nodes where
    a link is a pointer.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 节点是多个数据结构（如链表）的关键组成部分。节点是数据的容器，同时包含一个或多个指向其他节点的链接，其中链接是一个指针。
- en: To begin with, let us consider an example of creating a linked list of two nodes
    that contains data (for example, strings). For this, we first declare the variable
    that stores the data along with pointers that point to the next variable. Consider
    the example in the following *Figure 4.3*, in which there are two nodes. The first
    node has a pointer to the string (**eggs**), and another node pointing to the
    **ham** string.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们考虑一个创建包含数据（例如，字符串）的两个节点链表的例子。为此，我们首先声明一个变量来存储数据，以及指向下一个变量的指针。请参考以下*图4.3*的例子，其中有两个节点。第一个节点有一个指向字符串（**eggs**）的指针，另一个节点指向**ham**字符串。
- en: Furthermore, the first node that points to the **eggs** string has a link to
    another node. Pointers are used to store the address of a variable, and since
    the string is not actually stored in the node, rather, the address of the string
    is stored in the node.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，第一个指向**eggs**字符串的节点有一个指向另一个节点的链接。指针用于存储变量的地址，由于字符串实际上并不存储在节点中，而是在节点中存储字符串的地址。
- en: '![Diagram  Description automatically generated](img/B17217_04_03.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图描述自动生成](img/B17217_04_03.png)'
- en: 'Figure 4.3: A sample linked list of two nodes'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3：两个节点的示例链表
- en: Furthermore, we can also add a new third node to this existing linked list that
    stores spam as a data value, while a second node points to the third node, as
    shown in *Figure 4.4*. Hence, *Figure 4.3* demonstrates the structure of three
    nodes having data strings, in other words, **eggs**, **ham**, and **spam**, which
    are stored sequentially in a linked list.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还可以向现有的链表添加一个新的第三个节点，该节点存储的数据值为垃圾邮件，而第二个节点指向第三个节点，如图 4.4 所示。因此，图 4.3 展示了具有数据字符串的三个节点的结构，换句话说，**鸡蛋**、**火腿**和**垃圾邮件**，它们按顺序存储在链表中。
- en: '![](img/B17217_04_04.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_04_04.png)'
- en: 'Figure 4.4: A sample linked list of three nodes'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4：三个节点的示例链表
- en: So, we have created three nodes—one containing **eggs**, one **ham**, and another
    **spam**. The **eggs** node points to the **ham** node, which in turn points to
    the **spam** node. But what does the **spam** node point to? Since this is the
    last element in the list, we need to make sure its next member has a value that
    makes this clear. If we make the last element point to nothing, then we make this
    fact clear. In Python, we will use the special value **None** to denote nothing.
    Consider *Figure 4.5*. Node **B** is the last element in the list, and thus it
    is pointing to **None**.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们创建了三个节点——一个包含 **鸡蛋**，一个 **火腿**，另一个 **垃圾邮件**。**鸡蛋** 节点指向 **火腿** 节点，而 **火腿**
    节点又指向 **垃圾邮件** 节点。但 **垃圾邮件** 节点指向什么？由于这是列表中的最后一个元素，我们需要确保其 **next** 成员具有一个值来明确这一点。如果我们让最后一个元素指向空值，那么我们就清楚地表明了这一点。在
    Python 中，我们将使用特殊值 **None** 来表示空值。考虑图 4.5。节点 **B** 是列表中的最后一个元素，因此它指向 **None**。
- en: '![Diagram  Description automatically generated](img/B17217_04_05.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图描述自动生成](img/B17217_04_05.png)'
- en: 'Figure 4.5: A linked list with two nodes'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5：包含两个节点的链表
- en: 'Let us first learn about the implementation of the node, as shown in the following
    code snippet:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先了解节点的实现，如下代码片段所示：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, the **next** pointer is initialized to `None`, meaning that unless we
    change the value of **next**, the node is going to be an endpoint, meaning that
    initially, any node that is attached to the list will be independent.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，**next** 指针被初始化为 `None`，这意味着除非我们更改 **next** 的值，否则节点将成为一个端点，也就是说，最初，任何附加到列表中的节点将是独立的。
- en: You can also add any other data items to the node class if required. If your
    node is going to contain customer data, then create a `Customer` class and place
    all the data there.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，您也可以向节点类添加任何其他数据项。如果您的节点将包含客户数据，那么创建一个 `Customer` 类并将所有数据放在那里。
- en: There are three kinds of list—a singly linked list, a doubly linked list, and
    a circular linked list. First of all, let’s discuss singly linked lists.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种类型的列表——单链表、双链表和循环链表。首先，让我们讨论单链表。
- en: We need to learn the following operations in order to use any linked lists in
    real-time applications.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在实时应用中使用任何链表，我们需要学习以下操作。
- en: Traversing the list
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遍历列表
- en: 'Inserting a data item in the list:'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在列表中插入数据项：
- en: Inserting a new data item (node) at the beginning
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在列表开头插入新的数据项（节点）
- en: Inserting a new data item (node) at the end of the list
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在列表末尾插入新的数据项（节点）
- en: Inserting a new data item (node) in the middle/or at any given position in the
    list
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在列表中间/任何给定位置插入新的数据项（节点）
- en: 'Deleting an item from the list:'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从列表中删除一个项目：
- en: Deleting the first node
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除第一个节点
- en: Deleting the last node
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除最后一个节点
- en: Deleting a node in the middle/or at any given position in the list
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在列表中间/任何给定位置删除节点
- en: We will be discussing these important operations on different types of linked
    lists in subsequent subsections, along with their implementations, using Python.
    Let us start with singly linked lists.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后续的小节中讨论这些重要操作，包括它们的实现，使用 Python。让我们从单链表开始。
- en: Singly linked lists
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单链表
- en: A linked list (also called a singly linked list) contains a number of nodes
    in which each node contains data and a pointer that links to the next node. The
    link of the last node in the list is `None`, which indicates the end of the list.
    Refer to the following linked list in *Figure 4.6*, in which a sequence of integers
    is stored.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 链表（也称为单链表）包含多个节点，其中每个节点包含数据和指向下一个节点的指针。列表中最后一个节点的链接是 `None`，这表示列表的末尾。请参考以下链表，如图
    4.6 所示，其中存储了一系列整数。
- en: '![](img/B17217_04_06.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_04_06.png)'
- en: 'Figure 4.6: An example of a singly linked list'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.6：单链表的示例
- en: Next, we discuss how to create a singly linked list, and how to traverse it.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们讨论如何创建单链表以及如何遍历它。
- en: Creating and traversing
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和遍历
- en: 'In order to implement the singly linked list, we can use the node class that
    we created in the previous section. For example, we create three nodes, `n1`,
    `n2`, and `n3`, that store three strings:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现单链表，我们可以使用我们在上一节中创建的节点类。例如，我们创建三个节点`n1`、`n2`和`n3`，它们存储三个字符串：
- en: '[PRE1]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, we link the nodes sequentially to form the linked list. For example,
    in the following code, node `n1` is pointing to node `n2`, node `n2` is pointing
    to node `n3`, and node `n3` is the last node, and is pointing to **None**:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将节点依次链接起来形成链表。例如，在以下代码中，节点`n1`指向节点`n2`，节点`n2`指向节点`n3`，节点`n3`是最后一个节点，并指向**None**：
- en: '[PRE2]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Traversal of the linked lists means visiting all the nodes of the list, from
    the starting node to the last node. The process of traversing the singly linked
    list begins with the first node, displaying the data of the current node, following
    the pointers, and finally stopping when we reach the last node.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 链表遍历意味着访问列表中的所有节点，从起始节点到最后一个节点。遍历单链表的过程从第一个节点开始，显示当前节点的数据，跟随指针，最后在到达最后一个节点时停止。
- en: 'To implement the traversal of the linked list, we start by setting the `current`
    variable to the first item (starting node) in the list, and then we traverse the
    complete list through a loop, traversing each node as shown in the following code:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现链表的遍历，我们首先将`current`变量设置为列表中的第一个项目（起始节点），然后通过循环遍历整个列表，如以下代码所示：
- en: '[PRE3]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the loop, we print out the current element after which we set `current`
    to point to the next element in the list. We keep doing this until we reach the
    end of the list. The output of the preceding code for this example is:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环中，我们在打印当前元素后，将`current`设置为指向列表中的下一个元素。我们一直这样做，直到到达列表的末尾。前面代码的输出如下：
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'There are, however, several problems with this simplistic list implementation:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种简单列表实现存在几个问题：
- en: It requires too much manual work by the programmer
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这需要程序员进行太多的手动操作。
- en: Too much of the inner workings of the list is exposed to the programmer
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链表的大部分内部工作都暴露给了程序员。
- en: So, let us discuss a better and more efficient way of traversing the linked
    list.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们讨论一种更好、更高效的遍历链表的方法。
- en: Improving list creation and traversal
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 改进列表创建和遍历
- en: 'As you will notice in the earlier example of the list traversal, we are exposing
    the node class to the client/user. However, the client node should not interact
    with the node object. We need to use `node.data` to get the contents of the node,
    and `node.next` to get the next node. We can access the data by creating a method
    that returns a generator, which can be done using the `yield` keyword in Python.
    The updated code snippet for list traversal is as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你将在列表遍历的早期示例中注意到的那样，我们正在将节点类暴露给客户端/用户。然而，客户端节点不应与节点对象交互。我们需要使用`node.data`来获取节点的内容，使用`node.next`来获取下一个节点。我们可以通过创建一个返回生成器的方法来访问数据，这可以通过Python中的`yield`关键字来完成。列表遍历的更新代码片段如下：
- en: '[PRE5]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, the `yield` keyword is used to return from a function while saving the
    states of its local variables to enable the function to resume from where it left
    off. Whenever the function is called again, the execution starts from the last
    yield statement. Any function that contains a yield keyword is termed a **generator**.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`yield`关键字用于在保存函数局部变量的状态的同时从函数返回，以便函数可以从上次停止的地方继续执行。每次函数再次被调用时，执行从最后一个`yield`语句开始。任何包含`yield`关键字的函数都被称为**生成器**。
- en: 'Now, list traversal is much simpler. We can completely ignore the fact that
    there is anything called a node outside of the list:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，列表遍历变得简单多了。我们可以完全忽略列表外存在任何称为节点的东西：
- en: '[PRE6]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Notice that since the `iter()` method yields the data member of the node, our
    client code doesn’t need to worry about that at all.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于`iter()`方法返回节点的数据成员，我们的客户端代码根本不需要担心这一点。
- en: 'A singly linked list can be created using a simple class to hold the list.
    We start with a constructor that holds a reference to the very first node in the
    list (that is `head` in the following code). Since this list is initially empty,
    we will start by setting this reference to `None`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用一个简单的类来创建单链表。我们从一个构造函数开始，该构造函数包含对列表中第一个节点的引用（在下面的代码中是`head`）。由于这个列表最初是空的，我们将把这个引用设置为`None`：
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding code, we start with an empty list that points to `None`. Now,
    new data elements can be appended/added to this list.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们从一个空列表开始，该列表指向`None`。现在，新的数据元素可以被追加/添加到这个列表中。
- en: Appending items
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 追加项目
- en: The first operation that we need to perform is to `append` items to the list.
    This operation is also called an `insertion` operation. Here we get a chance to
    hide the `Node` class away. The user of the list class should never have to interact
    with `Node` objects.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要执行的第一项操作是将项目`append`到列表中。这个操作也称为`插入`操作。在这里，我们有机会将`Node`类隐藏起来。列表类的用户永远不需要与`Node`对象交互。
- en: Appending items to the end of a list
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在列表末尾追加项目
- en: 'Let’s have a look at the Python code for creating a linked list where we append
    new elements to the list using the `append()` method, as shown here:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看创建链表的Python代码，其中我们使用`append()`方法将新元素追加到列表中，如下所示：
- en: 'The first shot at an `append()` method may look like this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次尝试的 `append()` 方法可能看起来像这样：
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, in this code, we encapsulate data in a node so that it has the next pointer
    attribute. From here, we check if there are any existing nodes in the list (that
    is, whether `self.head` points to a `Node`). If there is `None`, this means that
    initially, the list is empty and the new node will be the first node. So, we make
    the new node the first node of the list; otherwise, we find the insertion point
    by traversing the list to the last node and updating the next pointer of the last
    node to the new node. This working is depicted in *Figure 4.7*.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们将数据封装在节点中，以便它具有下一个指针属性。从这里，我们检查列表中是否存在任何现有节点（即`self.head`是否指向一个`Node`）。如果为`None`，这意味着列表最初是空的，新节点将是第一个节点。因此，我们将新节点作为列表的第一个节点；否则，我们通过遍历列表到最后一个节点并更新最后一个节点的下一个指针来找到插入点。这种工作方式在*图4.7*中有所描述。
- en: '![](img/B17217_04_07.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_04_07.png)'
- en: 'Figure 4.7: Inserting a node at the end of the list in a singly linked list'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7：在单链表中在列表末尾插入节点
- en: 'Consider the following example code to append three nodes:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例代码来追加三个节点：
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'List traversal will work as we discussed before. You will get the first element
    of the list from the list itself, and then traverse the list through the `next`
    pointer:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 列表遍历将像我们之前讨论的那样工作。您将从列表本身获取列表的第一个元素，然后通过`next`指针遍历列表：
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Still, this implementation is not very efficient, and there is a drawback with
    the append method. In this, we have to traverse the entire list to find the insertion
    point. This may not be a problem when there are just a few items in the list,
    but it will be very inefficient when the list is long, as it will have to traverse
    the whole list to add an item every time. Let us discuss a better implementation
    of the `append` method.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，这种实现并不非常高效，append方法存在一个缺点。在这种情况下，我们必须遍历整个列表来找到插入点。当列表中只有少量项目时，这可能不是问题，但当列表很长时，这将非常低效，因为它每次添加项目时都必须遍历整个列表。让我们讨论`append`方法的更好实现。
- en: For this, the idea is that we not only have a reference to the first node in
    the list but also have one more variable in the node that references the last
    node of the list. That way, we can quickly append a new node at the end of the
    list. The worst-case running time of the append operation can be reduced from
    `O(n)` to `O(1)` using this method. We must ensure that the previous last node
    points to the new node that is to be appended to the list.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这一点，我们的想法是，我们不仅有一个指向列表中第一个节点的引用，而且在节点中还有一个变量，它引用列表的最后一个节点。这样，我们可以快速在列表末尾追加一个新的节点。使用这种方法，append操作的运行时间最坏情况可以从`O(n)`减少到`O(1)`。我们必须确保上一个最后一个节点指向要追加到列表中的新节点。
- en: 'Here is our updated code:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的更新后的代码：
- en: '[PRE11]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Take note of the convention being used. The point at which we append new nodes
    is through `self.tail`. The `self.head` variable points to the first node in the
    list.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 注意所使用的约定。我们通过`self.tail`来追加新节点。`self.head`变量指向列表中的第一个节点。
- en: In this code, a new node can be appended in the end through a `tail` pointer
    by making a link from the last node to the new node. *Figure 4.8* shows the workings
    of the preceding code.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，可以通过`tail`指针通过从最后一个节点到新节点的链接来在末尾追加一个新节点。*图4.8*显示了前面代码的工作原理。
- en: '![](img/B17217_04_08.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_04_08.png)'
- en: 'Figure 4.8: Illustrating the insertion of a node at the end of a linked list'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.8：展示在链表末尾插入节点
- en: In *Figure 4.8*, *step 1* shows the addition of the new node at the end, and
    *step 2* shows when the list is empty. In that case, `head` is made the new node,
    with `tail` pointing to that node.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 4.8* 中，*步骤 1* 显示了在末尾添加新节点，而 *步骤 2* 显示了列表为空的情况。在这种情况下，`head` 被设置为新的节点，`tail`
    指向该节点。
- en: 'Furthermore, the following code snippet shows the workings of the code:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，以下代码片段显示了代码的工作原理：
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The output of the above code is as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Appending items at intermediate positions
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在中间位置追加项目
- en: To append or insert an element in an existing linked list at a given position,
    firstly, we have to traverse the list to reach the desired position where we want
    to insert an element. An element can be inserted in between two successive nodes
    using two pointers (`prev` and `current`).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在现有的链表中在指定位置追加或插入一个元素时，首先，我们必须遍历列表以到达我们想要插入元素的目标位置。可以使用两个指针（`prev` 和 `current`）在两个连续的节点之间插入一个元素。
- en: A new node can easily be inserted in between two existing nodes by updating
    these links, as shown in *Figure 4.9*.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 通过更新这些链接，可以轻松地在两个现有节点之间插入一个新节点，如图 *4.9* 所示。
- en: '![](img/B17217_04_09.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_04_09.png)'
- en: 'Figure 4.9: Insertion of a node between two successive nodes in a linked list'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.9：在链表中两个连续节点之间插入节点
- en: When we want to insert a node in between two existing nodes, all we have to
    do is update two links. The previous node points to the new node, and the new
    node should point to the successor of the previous node.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想在两个现有节点之间插入一个节点时，我们只需更新两个链接。前一个节点指向新节点，而新节点应该指向前一个节点的后继节点。
- en: 'Let’s look at the complete code below to add a new element at a given index
    position:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看下面的完整代码，以在给定索引位置添加一个新元素：
- en: '[PRE14]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding code, we start from the first node and move the current pointer
    to reach the index position where we want to add a new element, and then we update
    the node pointers accordingly. In the `if` condition, firstly, we check whether
    the index position is `1`. In that case, we have to update the nodes as we are
    adding the new node at the start of the list. Therefore, we have to make the new
    node a `head` node. Next, in the `else` part, we check whether we have reached
    the required index position by comparing the value of `count` and `index`. If
    both values are equal, we add a new node in between nodes indicated by `prev`
    and `current` and update the pointers accordingly. Finally, we print an appropriate
    message if the required index position is greater than the length of the linked
    list.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们从第一个节点开始，移动当前指针以到达我们想要添加新元素的索引位置，然后相应地更新节点指针。在 `if` 条件中，首先检查索引位置是否为
    `1`。在这种情况下，我们必须更新节点，因为我们正在列表的开始处添加新节点。因此，我们必须使新节点成为 `head` 节点。接下来，在 `else` 部分，我们通过比较
    `count` 和 `index` 的值来检查是否已到达所需的索引位置。如果这两个值相等，我们在由 `prev` 和 `current` 指示的节点之间添加一个新节点，并相应地更新指针。最后，如果所需的索引位置大于链表的长度，我们打印一条适当的消息。
- en: '[PRE15]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The output of the above code is as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE17]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'It is important to note that the condition where we may want to insert a new
    element can change depending upon the requirement, so let’s say we want to insert
    a new element just before an element that has the same data value. In that case,
    the code to `append_at_a_position` will be as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，我们想要插入新元素的条件可能会根据需求而改变，所以假设我们想在具有相同数据值的元素之前插入一个新元素。在这种情况下，`append_at_a_position`
    的代码如下：
- en: '[PRE18]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can now use the preceding code to insert a new node at an intermediate position:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用前面的代码在中间位置插入一个新节点：
- en: '[PRE19]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The output of the above code is as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE20]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The worst-case time complexity of the `insert` operation is `O(1)` when we have
    an additional pointer that points to the last node. Otherwise, when we do not
    have the link to the last node, the time complexity will be `O(n)` since we have
    to traverse the list to reach the desired position and in the worst case, we may
    have to traverse all the *n* nodes in the list.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有一个指向最后一个节点的额外指针时，`insert` 操作的最坏情况时间复杂度是 `O(1)`。否则，当我们没有指向最后一个节点的链接时，时间复杂度将是
    `O(n)`，因为我们必须遍历列表以到达目标位置，在最坏的情况下，我们可能需要遍历列表中的所有 *n* 个节点。
- en: Querying a list
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询列表
- en: Once the list is created, we may require some quick information about the linked
    list, such as the size of the list, and occasionally to establish whether a given
    data item is present in the list.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建列表，我们可能需要一些有关链表的快速信息，例如列表的大小，有时还需要确定给定的数据项是否存在于列表中。
- en: Searching an element in a list
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在列表中搜索元素
- en: 'We may also need to check whether a list contains a given item. This can be
    implemented using the `iter()` method, which we have already seen in the previous
    section while traversing the linked list. Using that, we write the search method
    as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可能需要检查列表是否包含给定的项。这可以通过使用我们在上一节中遍历链表时已经看到的`iter()`方法来实现。使用它，我们编写如下搜索方法：
- en: '[PRE21]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the above code, each pass of the loop compares the data to be searched with
    each data item in the list one by one. If a match is found, `True` is returned,
    otherwise `False` is returned.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，循环的每次迭代都会将待搜索的数据与列表中的每个数据项逐一比较。如果找到匹配项，则返回`True`，否则返回`False`。
- en: 'If we run the following code for searching a given data item:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行以下代码来搜索给定的数据项：
- en: '[PRE22]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE23]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Getting the size of the list
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取列表的大小
- en: 'It is important to get the size of the list by counting the number of nodes.
    One way to do it is by traversing the entire list and increasing the counter as
    we go along:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 通过计数节点数量来获取列表的大小是很重要的。一种方法是在遍历整个列表的同时增加计数器：
- en: '[PRE24]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The above code is very similar to what we did while traversing the linked list.
    Similarly, in this code, we traverse the nodes of the list one by one and increase
    the `count` variable. However, list traversal is potentially an expensive operation
    that we should avoid wherever we can.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码与我们遍历链表时所做的非常相似。同样，在这段代码中，我们逐个遍历列表的节点，并增加`count`变量。然而，列表遍历可能是一个昂贵的操作，我们应该尽量避免。
- en: 'So instead, we can opt for another method in which we can add a size member
    to the `SinglyLinkedList` class, initializing it to `0` in the constructor, as
    shown in the following code snippet:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以选择另一种方法，在`SinglyLinkedList`类中添加一个大小成员，并在构造函数中将它初始化为`0`，如下面的代码片段所示：
- en: '[PRE25]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Because we are now only reading the size attribute of the node object, and not
    using a loop to count the number of nodes in the list, we reduce the worst-case
    running time from `O(n)` to `O(1)`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们现在只读取节点对象的`size`属性，而不是使用循环来计数列表中的节点数量，所以我们把最坏情况下的运行时间从`O(n)`降低到`O(1)`。
- en: Deleting items
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除项
- en: Another common operation on a linked list is to delete nodes. There are three
    possibilities that we may encounter in order to delete a node from the singly
    linked list.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在链表上进行的另一个常见操作是删除节点。为了从单链表中删除节点，我们可能会遇到三种可能性。
- en: Deleting the node at the beginning of the singly linked list
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除单链表开头的节点
- en: 'Deleting a node from the beginning is quite easy. It involves updating the
    `head` pointer to the second node in the list. This can be done in two steps:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 从列表开头删除节点相当简单。这涉及到将`head`指针更新为列表中的第二个节点。这可以通过以下两个步骤完成：
- en: A temporary pointer (`current` pointer) is created that points to the first
    node (`head` node), as shown in *Figure 4.10*.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个临时指针（`current`指针），它指向第一个节点（`head`节点），如图*4.10*所示。
- en: '![](img/B17217_04_10.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_04_10.png)'
- en: 'Figure 4.10: Illustration of the deletion of the first node from the linked
    list'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.10：展示从链表中删除第一个节点的示意图
- en: Next, the `current` node pointer is moved to the next node and assigned to the
    `head` node. Now, the second node becomes the `head` node that is pointed to by
    the `head` pointer, as shown in *Figure 4.11*.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将`current`节点指针移动到下一个节点，并将其分配给`head`节点。现在，第二个节点成为由`head`指针指向的`head`节点，如图*4.11*所示。
- en: '![](img/B17217_04_11.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_04_11.png)'
- en: 'Figure 4.11: After deleting the first node, the head pointer now points to
    the new starting element'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.11：删除第一个节点后，头指针现在指向新的起始元素
- en: 'This can be implemented using the following Python code. In this code, initially,
    three data elements are added as we have done previously, and then the first node
    of the list is deleted:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过以下Python代码实现。在这个代码中，最初添加了三个数据元素，就像我们之前做的那样，然后删除了列表的第一个节点：
- en: '[PRE26]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In the above code, we initially check if there is no item to delete from the
    list, and we print the appropriate message. Next, if there is some data item in
    the list, we assign the `head` pointer to the temporary pointer current as per
    *step 1*, and then the `head` pointer is now pointing to the next node, assuming
    that we already have a linked list of three data items – “eggs”, “ham”, and “spam”:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们首先检查链表中是否没有要删除的项目，并打印相应的消息。接下来，如果链表中有一些数据项，我们根据*步骤1*将`head`指针赋值给临时指针`current`，然后`head`指针现在指向下一个节点，假设我们已经有了一个包含三个数据项的链表——“鸡蛋”、“火腿”和“垃圾”：
- en: '[PRE27]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE28]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Deleting the node at the end in the singly linked list
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从单链表末尾删除节点
- en: 'To delete the last node from the list, we have to first traverse the list to
    reach the last node. At that time, we also need an extra pointer that points to
    just one node before the last node, so that after deleting the last node, the
    second last node can be marked as the last node. It can be implemented in the
    following three steps:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要从链表中删除最后一个节点，我们首先需要遍历链表到达最后一个节点。那时，我们还需要一个额外的指针，它指向最后一个节点之前的一个节点，这样在删除最后一个节点后，倒数第二个节点可以被标记为最后一个节点。这可以通过以下三个步骤实现：
- en: Firstly, we have two pointers, in other words, a `current` pointer that will
    point to the last node, and a `prev` pointer that will point to the node previous
    to the last node (second last node). Initially, we will have three pointers (`current`,
    `prev`, and `head`) pointing to the first node, as shown in *Figure 4.12*.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们有两个指针，换句话说，一个`current`指针将指向最后一个节点，一个`prev`指针将指向最后一个节点之前的节点（倒数第二个节点）。最初，我们将有三个指针（`current`、`prev`和`head`）指向第一个节点，如图*图4.12*所示。
- en: '![](img/B17217_04_12.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_04_12.png)'
- en: 'Figure 4.12: Illustration of the deletion of the end node from the linked list'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.12：从链表中删除末尾节点的示意图
- en: To reach the last node, we move the `current` and `prev` pointers in such a
    way that the `current` pointer should point to the last node and the `prev` pointer
    should point to the second last node. So, we stop when the `current` pointer reaches
    the last node. This is shown in *Figure 4.13*.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要到达最后一个节点，我们需要移动`current`和`prev`指针，使得`current`指针指向最后一个节点，而`prev`指针指向倒数第二个节点。因此，当`current`指针到达最后一个节点时，我们停止。这如图*图4.13*所示。
- en: '![](img/B17217_04_13.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_04_13.png)'
- en: 'Figure 4.13: Traversal of the linked list to reach the end of the list'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.13：遍历链表到达链表末尾
- en: Finally, we mark the `prev` pointer to point to the second last node, which
    is rendered as the last node of the list by pointing this node to `None`, as shown
    in *Figure 4.14*.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将`prev`指针标记为指向倒数第二个节点，通过将此节点指向`None`将其表示为链表的最后一个节点，如图*图4.14*所示。
- en: '![](img/B17217_04_14.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_04_14.png)'
- en: 'Figure 4.14: Deletion of the last node from the linked list'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.14：从链表中删除最后一个节点
- en: 'The implementation in Python for deleting a node from the end of the list is
    as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中从链表末尾删除节点的实现如下：
- en: '[PRE29]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the preceding code, firstly, the `current` and `prev` pointers are assigned
    the `head` pointer as per *step 1*. Then, in the `while` loop, we check whether
    we reached the end of the list using the `current.next is None` condition. Once
    we reach the end of the list, we make the second last node, which is indicated
    by the `prev` pointer, the last node. We also decrement the size of the list.
    If we do not reach the end of the list, we increment the `prev` and `current`
    pointers in the `while` loop in the last two lines of code. Next, let us discuss
    how to delete any intermediate node in a singly linked list.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，首先，根据*步骤1*，将`current`和`prev`指针赋值为`head`指针。然后，在`while`循环中，我们使用`current.next
    is None`条件检查是否到达了链表的末尾。一旦到达链表末尾，我们将由`prev`指针指示的倒数第二个节点标记为最后一个节点。我们还会减少链表的大小。如果我们没有到达链表末尾，我们在代码的最后两行中的`while`循环中增加`prev`和`current`指针。接下来，让我们讨论如何删除单链表中的任何中间节点。
- en: Deleting any intermediate node in a singly linked list
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从单链表中删除任何中间节点
- en: We first have to decide how to select a node for deletion. Identifying the intermediate
    node to be deleted can be determined by the index number or by the data the node
    contains. Let us understand this concept by deleting a node depending on the data
    it contains.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先必须决定如何选择要删除的节点。通过索引号或节点包含的数据来识别要删除的中间节点。让我们通过根据节点包含的数据删除节点来理解这个概念。
- en: 'To delete any intermediary node, we need two pointers similar to the case when
    we learned to delete the last node; in other words, the `current` pointer and
    the `prev` pointer. Once we reach the node that is to be deleted, the desired
    node can be deleted by making the previous node point to the next node of the
    node that is to be deleted. The process is provided in the following steps:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除任何中间节点，我们需要两个指针，类似于我们学习删除最后一个节点的情况；换句话说，`current`指针和`prev`指针。一旦我们到达要删除的节点，可以通过使前一个节点指向要删除的节点的下一个节点来删除所需的节点。这个过程在以下步骤中提供：
- en: '*Figure 4.15* shows when an intermediate node is deleted from the given linked
    list. In this, we can see that the initial pointers point to the first node.'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*图4.15*显示了从给定的链表中删除中间节点的情况。在这里，我们可以看到初始指针指向第一个节点。'
- en: '![](img/B17217_04_15.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_04_15.png)'
- en: 'Figure 4.15: Illustration of the deletion of an intermediate node from the
    linked list'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.15：从链表中删除中间节点的示意图
- en: Once the node is identified, the `prev` pointer is updated to delete the node,
    as shown in *Figure 4.16*. The node to be deleted is shown along with the link
    to those to be updated in *Figure 4.16*.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦识别出节点，`prev`指针就会更新以删除节点，如*图4.16*所示。要删除的节点以及需要更新的链接在*图4.16*中显示。
- en: '![](img/B17217_04_16.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_04_16.png)'
- en: 'Figure 4.16: Traversing to reach the intermediate node that is to be deleted
    in the linked list'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.16：遍历以到达要删除的中间节点在链表中的位置
- en: Finally, the list after deleting the node is shown in *Figure 4.17*.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，删除节点后的列表在*图4.17*中显示。
- en: '![](img/B17217_04_17.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_04_17.png)'
- en: 'Figure 4.17: Deletion of an intermediate node from the linked list'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.17：从链表中删除中间节点
- en: Let’s say we want to delete a data element that has the given value. For this
    given condition, we can first search the node to be deleted and then delete the
    node as per the steps discussed.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要删除具有给定值的数据元素。对于这个条件，我们首先可以搜索要删除的节点，然后按照讨论的步骤进行删除。
- en: 'Here is what the implementation of the `delete()` method may look like:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`delete()`方法实现的可能样子：
- en: '[PRE30]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Assuming that we already have a linked list of three items – “eggs”, “ham”,
    and “spam”, the following code is for executing the delete operation, that is,
    deleting a data element with the value “ham” from the given linked list:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们已经有了一个包含三个项目——“鸡蛋”、“火腿”和“垃圾食品”的链表，以下代码是执行删除操作，即从给定的链表中删除具有值“火腿”的数据元素：
- en: '[PRE31]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE32]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The worst-case time complexity of the `delete` operation is `O(n)` since we
    have to traverse the list to reach the desired position and, in the worst-case
    scenario, we may have to traverse all the *n* nodes in the list.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`delete`操作的 worst-case 时间复杂度为`O(n)`，因为我们必须遍历列表以到达目标位置，在 worst-case 情景下，我们可能需要遍历列表中的所有
    *n* 个节点。'
- en: Clearing a list
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 清除列表
- en: 'We may need to clear a list quickly, and there is a very simple way to do this.
    We can clear a list by simply clearing the pointer head and tail by setting them
    to `None`:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能需要快速清除列表，有一种非常简单的方法。我们可以通过将指针`head`和`tail`设置为`None`来清除列表：
- en: '[PRE33]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the above code, we can clear the list by assigning `None` to the `tail` and
    `head` pointers.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们可以通过将`tail`和`head`指针赋值为`None`来清除列表。
- en: We have discussed different operations for a singly linked list, and now we
    will discuss the concept of doubly linked list and learn how different operations
    can be implemented in a doubly linked list in the next section.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了单链表的不同操作，现在我们将讨论双链表的概念，并学习如何在下一节中实现双链表的不同操作。
- en: Doubly linked lists
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 双链表
- en: A doubly linked list is quite similar to the singly linked list in the sense
    that we use the same fundamental concept of nodes along with how we can store
    data and links together, as we did in a singly linked list. The only difference
    between a singly linked list and a doubly linked list is that in a singly linked
    list, there is only one link between each successive node, whereas, in a doubly
    linked list, we have two pointers—a pointer to the next node and a pointer to
    the previous node. See the following *Figure 4.18* of a node; there is a pointer
    to the next node and the previous node, which are set to `None` as there is no
    node attached to this node.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 从某种意义上说，双链表与单链表非常相似，因为我们使用相同的节点基本概念，以及我们如何将数据和链接一起存储，就像我们在单链表中做的那样。单链表和双链表之间的唯一区别是，在单链表中，每个连续节点之间只有一个链接，而在双链表中，我们有两个指针——一个指向下一个节点，一个指向前一个节点。请参考以下
    *图4.18* 的节点；有一个指向下一个节点和前一个节点的指针，这些指针被设置为 `None`，因为没有节点连接到这个节点。
- en: '![](img/B17217_04_18.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_04_18.png)'
- en: 'Figure 4.18: Represents a doubly linked list with a single node'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.18：表示具有单个节点的双链表
- en: A node in a singly linked list can only determine the next node associated with
    it. However, there is no link to go back from this referenced node. The direction
    of flow is only one way. In a doubly linked list, we solve this issue and include
    the ability not only to reference the next node, but also to reference the previous
    node. Consider the following *Figure 4.19* to understand the nature of the linkages
    between two successive nodes. Here, node **A** is referencing node **B**; in addition,
    there is also a link back to node **A**.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 单链表中的一个节点只能确定与其关联的下一个节点。然而，从该引用节点返回没有链接。流的方向只有单向。在双链表中，我们解决了这个问题，并包括了不仅能够引用下一个节点，还能够引用前一个节点的功能。请参考以下
    *图4.19* 来理解两个连续节点之间链接的性质。在这里，节点 **A** 引用了节点 **B**；此外，还有一个返回到节点 **A** 的链接。
- en: '![](img/B17217_04_19.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_04_19.png)'
- en: 'Figure 4.19: Doubly linked list with two nodes'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.19：具有两个节点的双链表
- en: Doubly linked lists can be traversed in any direction. A node in a doubly linked
    list can be easily referred to by its previous node whenever required without
    having a variable to keep track of that node.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 双链表可以双向遍历。在需要时，双链表中的一个节点可以很容易地通过其前一个节点来引用，而不需要有一个变量来跟踪该节点。
- en: However, in a singly linked list, it may be difficult to move back to the start
    or beginning of the list to make some changes at the start of the list, which
    is very easy now in the case of a doubly linked list.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在单链表中，可能很难回到列表的起始或开头以在列表的开头进行一些更改，而现在在双链表中这变得非常容易。
- en: Creating and traversing
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和遍历
- en: 'The Python code to create a doubly linked list node includes its initializing
    methods, the `prev` pointer, the `next` pointer, and the `data` instance variables.
    When a node is newly created, all these variables default to `None`:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 创建双链表节点的 Python 代码包括其初始化方法、`prev` 指针、`next` 指针和 `data` 实例变量。当一个节点被新创建时，所有这些变量默认为
    `None`：
- en: '[PRE34]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `prev` variable has a reference to the previous node, while the `next` variable
    keeps the reference to the next node, and the `data` variable stores the data.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`prev` 变量有一个对前一个节点的引用，而 `next` 变量保持对下一个节点的引用，`data` 变量存储数据。'
- en: Next, let’s create a doubly linked list class.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个双链表类。
- en: 'The doubly linked list class has two pointers, `head` and `tail`, that will
    point to the start and end of the doubly linked list, respectively. In addition,
    for the size of the list, we set the count instance variable to `0`. It can be
    used to keep track of the number of items in the linked list. Consider the following
    Python code for creating a doubly linked list class:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 双链表类有两个指针，`head` 和 `tail`，分别指向双链表的起始和结束。此外，对于列表的大小，我们设置 `count` 实例变量为 `0`。它可以用来跟踪链表中的项目数量。请参考以下创建双链表类的
    Python 代码：
- en: '[PRE35]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Here, `self.head` points to the beginner node of the list, and `self.tail` points
    to the last node. However, there are no fixed rules as to the naming of the head
    and tail node pointers.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`self.head` 指向链表的起始节点，而 `self.tail` 指向最后一个节点。然而，关于头尾节点指针的命名并没有固定的规则。
- en: Doubly linked lists also require functionalities that return the size of the
    list, insert items into the list, and delete nodes from the list. Next, we discuss
    different operations that can be applied to the doubly linked list. Let’s start
    with the append operation.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 双链表还需要一些功能，例如返回列表的大小、将项目插入列表以及从列表中删除节点。接下来，我们将讨论可以应用于双链表的不同操作。让我们从追加操作开始。
- en: Appending items
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 追加项目
- en: The `append` operation is used to add an element at the end of a list. An element
    can be appended or inserted into a doubly linked list in the following instances.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`append`操作用于在列表的末尾添加一个元素。在以下情况下，可以将元素追加或插入到双链表中。'
- en: Inserting a node at beginning of the list
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在列表的起始处插入节点
- en: Firstly, it is important to check whether the `head` node of the list is `None`.
    If it is `None`, this means that the list is empty, otherwise the list has some
    nodes, and a new node can be appended to the list. If a new node is to be added
    to the empty list, it should have the `head` pointer pointing to the newly created
    node, and the tail of the list should also point to this newly created node.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，重要的是检查列表的`head`节点是否为`None`。如果是`None`，这意味着列表为空，否则列表有一些节点，可以在列表中追加一个新节点。如果要将新节点添加到空列表中，它应该有`head`指针指向新创建的节点，并且列表的尾部也应该指向这个新创建的节点。
- en: The following *Figure 4.20* illustrates the `head` and `tail` pointers of the
    doubly linked list when a new node is added to an empty list.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 以下*图4.20*说明了在空列表中添加新节点时双链表的`head`和`tail`指针。
- en: '![](img/B17217_04_20.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_04_20.png)'
- en: 'Figure 4.20: Illustration of inserting a node in an empty doubly linked list'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.20：空双链表中插入节点的示意图
- en: Alternatively, we can insert or append a new node at the beginning of an existing
    doubly linked list, as shown in *Figure 4.21*.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以在现有双链表的开始处插入或追加一个新节点，如图*图4.21*所示。
- en: '![](img/B17217_04_21.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_04_21.png)'
- en: 'Figure 4.21: Illustration of inserting an element in a doubly linked list'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.21：双链表中插入元素的示意图
- en: The new node should be made as a new starting node of the list and that should
    now point to the previous `head` node.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 新节点应成为列表的新起始节点，并指向之前的`head`节点。
- en: 'It can be done by updating the three links, which are also shown with dotted
    lines in *Figure 4.22* and described as follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过更新三个链接来实现，这三个链接也在*图4.22*中以虚线显示，具体描述如下：
- en: Firstly, the `next` pointer of a new node should point to the `head` node of
    the existing list
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，新节点的`next`指针应指向现有列表的`head`节点
- en: The `prev` pointer of the `head` node of the existing list should point to the
    new node
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现有列表的`head`节点的`prev`指针应指向新节点
- en: Finally, mark the new node as the `head` node in the list
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将新节点标记为列表中的`head`节点
- en: '![](img/B17217_04_22.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_04_22.png)'
- en: 'Figure 4.22: Inserting a node at the beginning of the doubly linked list'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.22：在双链表的起始处插入节点
- en: 'The following code is used to append/insert an item at the beginning when the
    list is initially empty and with an existing doubly linked list:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 当列表最初为空且存在双链表时，以下代码用于在列表的起始处追加/插入一个项目：
- en: '[PRE36]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In the above code, firstly, the `self.head` condition is checked irrespective
    of whether the list is empty. If it is empty, then the head and tail pointers
    point to the newly created node. In this case, the new node becomes the `head`
    node. Next, if the condition is not true, this means the list is not empty, and
    a new node has to be added at the beginning of the list. For this, three links
    are updated as shown in *Figure 4.22*, and also shown in the code in bold font.
    After updating these three links, finally, the size of the list is increased by
    `1`. Furthermore, let us understand how to insert an element at the end of the
    doubly linked list.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，首先检查`self.head`条件，无论列表是否为空。如果为空，则头和尾指针指向新创建的节点。在这种情况下，新节点成为`head`节点。接下来，如果条件不成立，这意味着列表不为空，需要在列表的起始处添加一个新节点。为此，需要更新如图*图4.22*所示的三条链接，并在粗体字体的代码中显示。更新这些三条链接后，最后将列表的大小增加`1`。此外，让我们了解如何将元素插入到双链表的末尾。
- en: 'Further, the following code snippet shows how we can create a double link list
    and append a new node at the starting of the list:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，以下代码片段展示了我们如何创建一个双链表并在列表的起始处追加一个新节点：
- en: '[PRE37]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The output of the above code is:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出为：
- en: '[PRE38]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In the output, we can see that the new data item “`book`" is added in the starting
    of the list.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出中，我们可以看到新数据项“`book`"被添加到列表的起始处。
- en: Inserting a node at the end of the list
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To append/insert a new element at the end of the doubly linked list, we will
    need to traverse through the list to reach the end of the list if we do not have
    a separate pointer pointing to the end of the list. Here, we have a `tail` pointer
    that points to the end of the list.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: A visual representation of the append operation to an existing list is shown
    in the following *Figure 4.23*.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17217_04_23.png)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.23: Inserting a node at the end of the list in a doubly linked list'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: 'To add a new node at the end, we update two links as follows:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Make the `prev` pointer of the new node point to the previous `tail` node
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make the previous `tail` node point to the new node
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, update the `tail` pointer so that the `tail` pointer now points to
    the new node
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following code is used to append an item at the end of the doubly linked
    list:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In the above code, the `if` part of the preceding program is for adding a node
    to the empty list; the `else` part of the preceding program will be executed if
    the list is not empty. If the new node is to be added to a list, the new node’s
    previous variable is to be set to the tail of the list:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The tail’s next pointer (or variable) has to be set to the new node:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Lastly, we update the tail pointer to point to the new node:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Since an append operation increases the number of nodes by one, we increase
    the counter by one:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The following code snippet can be used to append a node at the end of the list:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The output of the above code:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The worst-case time complexity of appending an element to the doubly linked
    list is `O(1)` since we already have the tail pointer that points to the end of
    the list, and we can directly add a new element. Next, we will discuss how to
    insert a node at an intermediate position of the doubly linked list.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: Inserting a node at an intermediate position in the list
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Inserting a new node at any given position in a doubly linked list is similar
    to what we discussed in a singly linked list. Let us take an example in which
    we insert a new element just before the element that has the same data value as
    the given data.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, we traverse to the position where we want to insert a new element in
    that situation. The `current` pointer points to the target node, while the `prev`
    pointer just points to the previous node of the target node, as shown in *Figure
    4.24*.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17217_04_24.png)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.24: Illustration of pointers for inserting a node at an intermediate
    position in a doubly linked list'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: 'After reaching the correct position, a few pointers have to be added in order
    to add a new node. The details of these links that need to be updated (also shown
    in *Figure 4.25*) are as follows:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: The `next` pointer of the new node points to the current node
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `prev` pointer of the new node should point to the previous node
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `next` pointer of the previous node should point to the new node
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `prev` pointer of the current node should point to the new node
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B17217_04_25.png)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_04_25.png)'
- en: 'Figure 4.25: Demonstration of links that need to be updated in order to add
    a new node at any intermediate position in the list'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.25：演示在列表中任何中间位置添加新节点需要更新的链接
- en: 'Here is what the implementation of the `append_at_a_location()` method may
    look like:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`append_at_a_location()`方法实现可能的样子：
- en: '[PRE46]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In the preceding code, firstly, the `current` and `prev` pointers are initialized
    by pointing to the `head` node. Then, in the `while` loop, we first reach the
    desired position by checking the condition. In this example, we check the data
    value of the current node against the data value provided by the user. Once we
    reach the desired position, we update four links as discussed, which are also
    shown in *Figure 4.25*.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，首先，通过指向`head`节点初始化`current`和`prev`指针。然后，在`while`循环中，我们首先通过检查条件到达期望的位置。在这个例子中，我们检查当前节点的数据值与用户提供的值。一旦我们到达期望的位置，我们就更新四个链接，如前所述，这些链接也显示在*图4.25*中。
- en: '[PRE47]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The output of the above code:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出：
- en: '[PRE49]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Appending at the start and end positions in a doubly linked list will have a
    worst-case running time complexity of `O(1)` since we can directly append the
    new node, and the worst-case time complexity for appending a new node at any intermediate
    position will be `O(n)` since we may have to traverse the list of *n* items.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在双链表中，在起始位置和末尾位置添加将具有最坏情况下的运行时间复杂度`O(1)`，因为我们可以直接添加新节点，而在任何中间位置添加新节点的最坏情况时间复杂度将是`O(n)`，因为我们可能需要遍历包含*n*个项目的列表。
- en: Next, let us learn how to search a given item if that is present in the doubly
    linked list or not.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们学习如何搜索给定项是否存在于双链表中。
- en: Querying a list
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询列表
- en: 'The search for an item in a doubly linked list is similar to the way we did
    it in the singly linked list. We use the `iter()` method to check the data in
    all the nodes. As we run a loop through all the data in the list, each node is
    matched with the data passed in the `contain` method. If we find the item in the
    list, `True` is returned, denoting that the item is found, otherwise `False` is
    returned, which means the item was not found in the list. The Python code for
    this is as follows:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在双链表中搜索一个项目的方式与我们之前在单链表中所做的方式相似。我们使用`iter()`方法检查所有节点的数据。当我们遍历列表中的所有数据时，每个节点都与通过`contain`方法传入的数据进行匹配。如果我们找到列表中的项目，则返回`True`，表示找到了项目，否则返回`False`，表示列表中没有找到该项目。相应的Python代码如下：
- en: '[PRE50]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The following code can be used to search if a data item is present in the existing
    doubly linked list:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码可以用来搜索一个数据项是否存在于现有的双链表中：
- en: '[PRE51]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The output of the above code is as follows:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE52]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The search operation in a doubly linked list has a running time complexity of
    `O(n)` since we have to traverse the list in order to reach the desired element
    and, in the worst case, we may have to traverse the whole list of *n* items.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在双链表中的搜索操作具有运行时间复杂度`O(n)`，因为我们必须遍历列表以到达期望的元素，在最坏的情况下，我们可能需要遍历包含*n*个项目的整个列表。
- en: Deleting items
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除项目
- en: The deletion operation is easier in the doubly linked list compared to the singly
    linked list. Unlike in a singly linked list, where we need to traverse the linked
    list to reach the desired position, and we also need one more pointer to keep
    track of the previous node of the target node, in a doubly linked list, we don’t
    have to do that because we can traverse in both directions.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 与单链表相比，在双链表中删除操作更简单。与单链表不同，在单链表中我们需要遍历链表以到达期望的位置，我们还需要一个额外的指针来跟踪目标节点的上一个节点，而在双链表中，我们不需要这样做，因为我们可以在两个方向上遍历。
- en: 'The `delete` operation in a doubly linked list can have four scenarios, which
    are discussed as follows:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在双链表中的`delete`操作有四种情况，如下所述：
- en: The item to be deleted is located at the start of the list
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要删除的项目位于列表的起始位置
- en: The item to be deleted is found at the tail end of the list
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要删除的项目位于列表的末尾
- en: The item to be deleted is located anywhere at an intermediate position in the
    list
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要删除的项目位于列表的中间位置
- en: The item to be deleted is not found in the list
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要删除的项目不在列表中
- en: 'The node to be deleted is identified by matching the data instance variable
    with the data that is passed to the method. If the data matches the data variable
    of a node, that matching node will be deleted:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将数据实例变量与传递给方法的数据进行匹配来识别要删除的节点。如果数据与节点的数据变量匹配，则该匹配节点将被删除：
- en: For the first scenario, when we have found the item to be deleted at the first
    position, we will have to simply update the `head` pointer to the next node. It
    is shown in *Figure 4.26*.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于第一种情况，当我们找到要删除的第一个位置的项时，我们只需简单地更新`head`指针到下一个节点。这如图*4.26*所示。
- en: '![](img/B17217_04_26.png)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_04_26.png)'
- en: 'Figure 4.26: Illustration of the deletion of the first node in a doubly linked
    list'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.26：双链表中删除第一个节点的示意图
- en: For the second scenario, when we found the item to be deleted at the last position
    in the list, we will have to simply update the `tail` pointer to the second last
    node. It is shown in *Figure 4.27*.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于第二种情况，当我们找到要删除的项位于列表的最后一个位置时，我们只需简单地更新`tail`指针到倒数第二个节点。这如图*4.27*所示。
- en: '![](img/B17217_04_27.png)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_04_27.png)'
- en: 'Figure 4.27: Illustration of the deletion of the last node in a doubly linked
    list'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.27：双链表中删除最后一个节点的示意图
- en: For the third scenario, we found the data item to be deleted at any intermediate
    position. To better understand this, consider the example shown in *Figure 4.28*.
    In this, there are three nodes, **A**, **B**, and **C**. To delete node **B**
    in the middle of the list, we will essentially make **A** point to node **C**
    as its next node, while making **C** point to **A** as its previous node.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于第三种情况，我们在任何中间位置找到要删除的数据项。为了更好地理解这一点，请考虑图*4.28*中所示的示例。在这里，有三个节点，**A**、**B**和**C**。要删除列表中间的节点**B**，我们实际上会让**A**指向节点**C**作为其下一个节点，同时让**C**指向**A**作为其前一个节点。
- en: '![](img/B17217_04_28.png)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_04_28.png)'
- en: 'Figure 4.28: Illustration of the deletion of the intermediate node B from the
    doubly linked list'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.28：双链表中删除中间节点B的示意图
- en: 'The complete implementation to delete a node from the doubly linked list in
    Python is as follows. We’ll discuss each part of this code step by step:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 删除双链表中节点在Python中的完整实现如下。我们将逐步讨论此代码的每个部分：
- en: '[PRE53]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Initially, we create a `node_deleted` variable to denote the deleted node in
    the list and this is initialized to `False`. The `node_deleted` variable is set
    to `True` if a matching node is found and subsequently removed.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，我们创建一个`node_deleted`变量来表示列表中删除的节点，并将其初始化为`False`。如果找到匹配的节点并将其删除，则`node_deleted`变量被设置为`True`。
- en: 'In the `delete` method, the `current` variable is initially set to the `head`
    node of the list (that is, it points to the `self.head` node of the list). This
    is shown in the following code fragment:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在`delete`方法中，`current`变量最初被设置为列表的`head`节点（即，它指向列表的`self.head`节点）。这在上面的代码片段中有所体现：
- en: '[PRE54]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Next, we use a set of `if...else` statements to search various parts of the
    list to ascertain the node with the specified data that is to be deleted.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用一组`if...else`语句来搜索列表的各个部分，以确定要删除的指定数据的节点。
- en: 'First of all, we search for the data to be deleted at the `head` node, and
    if the data is matched at the `head` node, this node would be deleted. Since `current`
    is pointing at `head`, if `current` is `None`, this means that the list is empty
    and has no nodes to find the node to be deleted. The following is its code fragment:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在`head`节点搜索要删除的数据，如果数据与`head`节点匹配，则该节点将被删除。由于`current`指向`head`，如果`current`是`None`，这意味着列表为空，没有节点可以找到要删除的节点。以下是其代码片段：
- en: '[PRE55]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'However, if `current` (which now points to `head`) contains the data being
    searched for, this means that we found the data to be deleted at the `head` node,
    and `self.head` is then marked to point to the `current.next` node. Since there
    is now no node behind `head`, `self.head.prev` is set to `None`. Consider the
    following code snippet for this:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果`current`（现在指向`head`）包含正在搜索的数据，这意味着我们在`head`节点找到了要删除的数据，然后`self.head`被标记为指向`current.next`节点。由于现在`head`后面没有节点，`self.head.prev`被设置为`None`。以下是其代码片段：
- en: '[PRE56]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Similarly, if the node that is to be deleted is found at the `tail` end of
    the list, we delete the last node by setting its previous node pointing to `None`.
    `self.tail` is set to point to `self.tail.prev`, and `self.tail.next` is set to
    `None` as there is no node afterward. Consider the following code fragment for
    this:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，如果要删除的节点位于列表的`tail`端，我们通过将其前一个节点指向`None`来删除最后一个节点。`self.tail`被设置为指向`self.tail.prev`，而`self.tail.next`被设置为`None`，因为没有后续的节点。以下是其代码片段：
- en: '[PRE57]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Lastly, we search for the node to be deleted by looping through the entire list
    of nodes. If the data that is to be deleted is matched with a node, that node
    will be deleted.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过遍历整个节点列表来搜索要删除的节点。如果要删除的数据与节点匹配，则该节点将被删除。
- en: 'To delete a node, we make the previous node of the `current` node point to
    the next node using the `current.prev.next = current.next` code. After that step,
    we make the current’s next node point to the previous node of the `current` node
    using `current.next.prev = current.prev`. Furthermore, if we traverse the complete
    list, and the desired item is not found, we print the appropriate message. Consider
    the following code snippet for this:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除一个节点，我们使用 `current.prev.next = current.next` 代码使前一个节点指向下一个节点。之后，我们使用 `current.next.prev
    = current.prev` 使当前节点的下一个节点指向当前节点的前一个节点。此外，如果我们遍历整个列表，并且找不到所需的项目，我们将打印相应的消息。以下代码片段展示了这一点：
- en: '[PRE58]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Finally, the `node_delete` variable is then checked to ascertain whether a
    node is actually deleted. If any node is deleted, then we decrease the count variable
    by `1`, and this keeps track of the total number of nodes in the list. See the
    following code fragment:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，检查 `node_delete` 变量以确认是否确实删除了节点。如果删除了任何节点，则将计数变量减 `1`，这样就可以跟踪列表中的总节点数。以下代码片段展示了这一点：
- en: '[PRE59]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This decrements the count variable by `1` in case any node is deleted.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 如果删除了任何节点，则将计数变量减 `1`。
- en: 'Let’s take an example to see how the delete operation works with the same example
    of adding three strings – “egg”, “ham”, and “spam”, and then a node with the value
    “ham” is deleted from the list. The code is as follows:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过添加三个字符串的示例来了解删除操作是如何工作的——“egg”、“ham”和“spam”，然后从列表中删除一个值为“ham”的节点。代码如下：
- en: '[PRE60]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码的输出如下：
- en: '[PRE61]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The worst-case running time complexity of the delete operation is `O(n)` since
    we may have to traverse the list of *n* items to search for the item to be deleted.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 删除操作的最坏情况运行时间复杂度是 `O(n)`，因为我们可能需要遍历包含 *n* 个项目的列表来搜索要删除的项目。
- en: In the next section, we will learn different operations on a circular linked
    list.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习循环链表的不同操作。
- en: Circular lists
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环列表
- en: A circular linked list is a special case of a linked list. In a circular linked
    list, the endpoints are connected, which means that the last node in the list
    points back to the first node. In other words, we can say that in circular linked
    lists, all the nodes point to the next node (and the previous node in the case
    of a doubly linked list) and there is no end node, meaning no node will point
    to `None`.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 循环链表是链表的一种特殊情况。在循环链表中，端点是相连的，这意味着列表中的最后一个节点指向第一个节点。换句话说，我们可以说在循环链表中，所有节点都指向下一个节点（在双链表中是前一个节点）并且没有结束节点，意味着没有节点会指向
    `None`。
- en: The circular linked lists can be based on both singly and doubly linked lists.
    Consider *Figure 4.29* for the circular linked list based on a singly linked list
    where the last node, **C**, is again connected to the first node **A**, thus making
    a circular list.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 循环链表可以基于单链表和双链表。考虑 *图4.29*，它展示了基于单链表的循环链表，其中最后一个节点 **C** 再次连接到第一个节点 **A**，从而形成一个循环列表。
- en: '![](img/B17217_04_29.png)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_04_29.png)'
- en: 'Figure 4.29: Example of a circular list based on a singly linked list'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.29：基于单链表的单循环列表示例
- en: In the case of a doubly linked circular list, the first node points to the last
    node, and the last node points back to the first node. *Figure 4.30* shows the
    concept of the circular linked list based on a doubly linked list where the last
    node **C** is again connected to the first node **A** through the `next` pointer.
    Node **A** is also connected to node **C** through the `previous` pointer, thus
    making a circular list.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在双链表循环列表的情况下，第一个节点指向最后一个节点，最后一个节点又指向第一个节点。*图4.30* 展示了基于双链表的循环链表的概念，其中最后一个节点
    **C** 再次通过 `next` 指针连接到第一个节点 **A**。节点 **A** 也通过 `previous` 指针连接到节点 **C**，从而形成一个循环列表。
- en: '![](img/B17217_04_30.png)'
  id: totrans-346
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_04_30.png)'
- en: 'Figure 4.30: Example of a circular list based on a doubly linked list'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.30：基于双链表的单循环列表示例
- en: Now, we are going to look at an implementation of a singly linked circular list.
    It is very straightforward to implement a doubly linked circular list once we
    understand the basic concepts of singly and doubly linked lists.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将查看单链表循环列表的实现。一旦我们理解了单链表和双链表的基本概念，实现双链表循环列表就非常直接了。
- en: Almost everything is similar except that we should be careful in managing the
    link of the last node to the first node.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有内容都是相似的，但我们应小心管理最后一个节点到第一个节点的链接。
- en: We can reuse the node class that we created in the singly linked lists subsection.
    We can reuse most parts of the `SinglyLinkedList` class as well. So, we are going
    to focus on where the circular list implementation differs from the normal singly
    linked list.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以重用我们在单链表部分创建的节点类。我们也可以重用`SinglyLinkedList`类的大部分内容。因此，我们将关注循环链表实现与普通单链表的不同之处。
- en: Creating and traversing
  id: totrans-351
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和遍历
- en: 'The circular linked list class can be created using the following code:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下代码创建循环链表类：
- en: '[PRE62]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: In the above code, initially in the circular linked list class, we have two
    pointers; `self.tail` is used to point to the last node, and `self.head` is used
    to point to the first node of the list.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，最初在循环链表类中，我们有两个指针；`self.tail`用于指向最后一个节点，而`self.head`用于指向列表的第一个节点。
- en: Appending items
  id: totrans-355
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加项目
- en: Here, we want to add a node at the end of a circular linked list, as shown in
    *Figure 4.31*, in which we have four nodes, wherein the head is pointing to the
    starting node and the tail is pointing to the last node.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们想在循环链表的末尾添加一个节点，如图*图4.31*所示，其中我们有一个四个节点的列表，其中头指针指向起始节点，尾指针指向最后一个节点。
- en: '![](img/B17217_04_31.png)'
  id: totrans-357
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_04_31.png)'
- en: 'Figure 4.31: Example of a circular linked list for adding a node at the end'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.31：在链表末尾添加节点的示例
- en: '*Figure 4.32* shows how a node is added to a circular linked list.'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4.32* 展示了如何将一个节点添加到循环链表中。'
- en: '![](img/B17217_04_32.png)'
  id: totrans-360
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_04_32.png)'
- en: 'Figure 4.32: Inserting a node at the end of the singly circular list'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.32：在单链表的末尾插入节点
- en: 'To add a node at the end, we will update three links:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 要在末尾添加节点，我们将更新三个链接：
- en: The `next` pointer of the last node to point to a new node
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将最后一个节点的`next`指针指向新节点
- en: The `next` pointer of a new node to point to the `head` node
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新节点的`next`指针指向`head`节点
- en: Update the `tail` pointer to point to the new node
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`tail`指针以指向新节点
- en: 'The implementation of the circular linked list to append an element at the
    end of the circular list based on a singly linked list is as follows:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 基于单链表在循环链表的末尾添加元素的循环链表实现如下：
- en: '[PRE63]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: In the above code, firstly, we check whether the list is empty. If the list
    is empty, we go to the `else` part of the above code. In this case, the new node
    will be the first node of the list, and both the `head` and `tail` pointers will
    point to the new node, while the `next` pointer of the new node will again point
    to the new node.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，首先检查列表是否为空。如果列表为空，则进入上述代码的`else`部分。在这种情况下，新节点将成为列表的第一个节点，`head`和`tail`指针都将指向新节点，而新节点的`next`指针将再次指向新节点。
- en: Otherwise, if the list is not empty, we go to the `if` part of the preceding
    code. In this case, we update the three pointers as shown in *Figure 4.32*. This
    is similar to what we did in the case of the single linked list. Only one link
    is additionally added in this case, which is shown in bold font in the preceding
    code.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，如果列表不为空，则进入前面代码的`if`部分。在这种情况下，我们将更新三个指针，如图*图4.32*所示。这与我们在单链表的情况中所做的是相似的。在这种情况下，额外添加了一个链接，这在前面代码中以粗体显示。
- en: 'Further, we can use `iter()` method traverse all the elements of the list,
    The `iter()` method described below should be defined in `CircularList` class:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以使用`iter()`方法遍历列表的所有元素，下面的`iter()`方法应在`CircularList`类中定义：
- en: '[PRE64]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The below code can be used to create a singly circular linked list, and then
    print all the data elements of the list, and then we stop when the counter becomes
    3 which is the length of the list.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码可以用来创建单链表循环，然后打印列表的所有数据元素，然后当计数器变为3（列表的长度）时停止。
- en: '[PRE65]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE67]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Appending any element at an intermediate position in a circular list is exactly
    to its implementation in a singly linked list.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环链表中在任何中间位置添加任何元素与单链表的实现方式完全相同。
- en: Querying a list
  id: totrans-378
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询列表
- en: 'Traversing a circular linked list is very convenient as we don’t need to look
    for the starting point. We can start anywhere, and we just need to carefully stop
    traversing when we reach the same node again. We can use the same `iter()` method,
    which we discussed at the start of this chapter. This will also be the case for
    the circular list; the only difference is that we have to mention an exit condition
    when we are iterating through the circular list, otherwise the program will get
    stuck in a loop, and it will run indefinitely. We can make any exit condition
    dependent upon our requirements; for example, we can use a counter variable. Consider
    the following example code:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历循环链表非常方便，因为我们不需要寻找起始点。我们可以从任何地方开始，只需要在再次遇到相同的节点时小心地停止遍历。我们可以使用相同的`iter()`方法，这是我们在本章开头讨论的。这也会是循环链表的情况；唯一的区别是我们必须在遍历循环链表时提到一个退出条件，否则程序将陷入循环，并且会无限期地运行。我们可以根据我们的需求设置任何退出条件；例如，我们可以使用一个计数器变量。考虑以下示例代码：
- en: '[PRE68]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: In the above code, we add three strings of data to the circular linked list,
    and then we print the data values iterating through the list 100 times.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们向循环链表中添加了三条数据字符串，然后通过遍历链表100次来打印数据值。
- en: In the next section, let us understand how the `delete` operation works in a
    circular linked list.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，让我们了解如何在循环链表中实现`delete`操作。
- en: Deleting an element in a circular list
  id: totrans-383
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在循环链表中删除一个元素
- en: 'To delete a node in a circular list, it looks like we can do it similarly to
    how we did in the case of the append operation—simply make sure that the last
    node through the `tail` pointer points back to the starting node of the list through
    the `head` pointer. We have the following three scenarios:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 要在循环链表中删除一个节点，看起来我们可以像在追加操作的情况中那样做——只需确保通过`tail`指针指向的最后一个节点通过`head`指针指向链表的起始节点。我们有以下三种情况：
- en: 'When the item to be deleted is the `head` node:'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当要删除的项是`head`节点时：
- en: In this scenario, we have to ensure that we make the second node of the list
    the new `head` node (shown as *step 1* in *Figure 4.33*), and the last node should
    be pointing back to the new head (shown as *step 2* in *Figure 4.33*).
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个场景中，我们必须确保将列表的第二个节点作为新的`head`节点（如图*图4.33*中的*步骤1*所示），并且最后一个节点应该指向新的头节点（如图*图4.33*中的*步骤2*所示）。
- en: '![](img/B17217_04_33.png)'
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/B17217_04_33.png)'
- en: 'Figure 4.33: Deletion of a starting node in a singly circular list'
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.33：单循环链表中删除起始节点
- en: 'When the item to be deleted is the `last` node:'
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当要删除的项是`last`节点时：
- en: In this scenario, we have to ensure that we make the second last node the new
    tail node (shown as *step 1* in *Figure 4.34*), while the new tail node should
    be pointing back to the new head (shown as *step 2* in *Figure 4.34*).
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个场景中，我们必须确保将第二个最后一个节点作为新的尾节点（如图*图4.34*中的*步骤1*所示），而新的尾节点应该指向新的头节点（如图*图4.34*中的*步骤2*所示）。
- en: '![](img/B17217_04_34.png)'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/B17217_04_34.png)'
- en: 'Figure 4.34: Deletion of the last node in a singly circular list'
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.34：单循环链表中删除最后一个节点
- en: 'When the item to be deleted is an intermediate node:'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当要删除的项是中间节点时：
- en: This is very similar to what we did in the singly linked list. We have to make
    a link from the previous node of the target node to the next node of the target
    node, as shown in *Figure 4.35*.
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这与我们之前在单链表中所做的是非常相似的。我们需要从目标节点的上一个节点建立一个链接到目标节点的下一个节点，如图*图4.35*所示。
- en: '![](img/B17217_04_35.png)'
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/B17217_04_35.png)'
- en: 'Figure 4.35: Deletion of any intermediate node in a singly circular list'
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.35：单循环链表中删除任何中间节点
- en: 'The implementation of the `delete` operation is as follows:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '`delete`操作的实现如下：'
- en: '[PRE69]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: In the preceding code, firstly, iterate over all the elements to search the
    desired element to be deleted. Here, it is important to note the stopping condition.
    If we simply check the `current` pointer to be equal to `None` (which we did in
    the singly linked list), the program will go into an indefinite loop since the
    current node will never point to `None` in the case of circular linked lists.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，首先遍历所有元素以搜索要删除的所需元素。在这里，重要的是要注意停止条件。如果我们简单地检查`current`指针是否等于`None`（我们在单链表中就是这样做的），由于在循环链表中当前节点永远不会指向`None`，程序将进入无限循环。
- en: For this, we cannot check whether `current` has reached `tail` because then
    it will never check the last node. So, the stopping criterion in the circular
    list is the fact that the `prev` and `current` pointers point to the same node.
    It will work fine except on one occasion when the first loop iteration, at that
    time, `current` and `prev`, will point to the same node, in other words, the `head`
    node.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种情况，我们不能检查 `current` 是否到达 `tail`，因为那样它将永远不会检查最后一个节点。所以，循环链表的停止标准是 `prev`
    和 `current` 指针指向相同的节点。它将正常工作，除非在第一次循环迭代时，那时 `current` 和 `prev` 将指向相同的节点，换句话说，就是
    `head` 节点。
- en: Once, we enter the loop, we check the data value of the current pointer with
    the given data value to get the node to be deleted. We check whether the node
    to be deleted is the `head` node, tail node, or intermediate node, and then update
    the appropriate links shown in *Figures 4.33*, *4.34*, and *4.35*.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦进入循环，我们就将当前指针的数据值与给定数据值进行比较，以找到要删除的节点。我们检查要删除的节点是 `head` 节点、尾节点还是中间节点，然后更新如
    *图 4.33*、*图 4.34* 和 *图 4.35* 所示的适当链接。
- en: So, we have discussed the different scenarios while deleting any node in singly
    circular linked list, similarly, the doubly linked list based circular linked
    list can be implemented.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经讨论了在单链循环链表中删除任何节点时的不同场景，同样，基于双链表的循环链表也可以实现。
- en: 'The following code can be used to create a circular linked list, and apply
    different delete operations:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码可以用来创建循环链表，并应用不同的删除操作：
- en: '[PRE70]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The output of the above code is as follows:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE71]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The worst-case time complexity of inserting an element at a given location in
    the circular linked list is `O(n)` since we have to traverse the list to the desired
    location. The complexity of insertion at the first and last locations of the circular
    list will be `O(1)`. Similarly, the worst-case time complexity to delete an element
    at a given location is `O(n)`.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环链表中在指定位置插入一个元素的 worst-case 时间复杂度是 `O(n)`，因为我们必须遍历链表到所需的位置。在循环链表的第一和最后一个位置插入的复杂度将是
    `O(1)`。同样，在指定位置删除一个元素的 worst-case 时间复杂度也是 `O(n)`。
- en: So far, we have discussed the different scenarios while deleting any node in
    a singly circular linked list. Similarly, the doubly linked list can be implemented
    based on a circular linked list.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了在单链循环链表中删除任何节点时的不同场景。同样，基于循环链表的双链表也可以实现。
- en: In a singly linked list, the traversal of nodes can be done in one direction,
    whereas, in a doubly linked list, it is possible to traverse in both directions
    (forward and backward). In both cases, the complexity of the insertion and deletion
    operations at a given location is `O(n)` whenever we have to traverse the list
    in order to reach the desired location where we want to insert or delete any element.
    Similarly, the worst-case time complexity of the insertion or deletion of a node
    for a given desired location is `O(n)`. Whenever we need to save memory space,
    we should use a singly linked list since it only needs one pointer, whereas a
    doubly linked list takes more memory space to store double pointers. When a search
    operation is important, we should use a doubly linked list since it is possible
    to search in both directions. Furthermore, the circular linked list should be
    used when we have an application when we need to iterate over the nodes in the
    list. Let us now see more real-world applications of linked lists.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 在单链表中，节点的遍历可以单向进行，而在双链表中，可以双向遍历（正向和反向）。在这两种情况下，在给定位置进行插入和删除操作的复杂度都是 `O(n)`，无论何时我们需要遍历链表以到达我们想要插入或删除元素的位置。同样，对于给定位置的节点插入或删除的
    worst-case 时间复杂度也是 `O(n)`。当我们需要节省内存空间时，我们应该使用单链表，因为它只需要一个指针，而双链表需要更多的内存空间来存储双指针。当搜索操作很重要时，我们应该使用双链表，因为它可以双向搜索。此外，当我们有一个需要遍历链表中节点应用时，应该使用循环链表。现在让我们看看链表在现实世界中的更多应用。
- en: Practical applications of linked lists
  id: totrans-410
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链表的实用应用
- en: As of now, we have discussed singly linked lists, circular linked lists, and
    doubly linked lists. Depending upon what kind of operations (insertion, deletion,
    updating, and so on) will be required in different applications, these data structures
    are used accordingly. Let’s see a few real-time applications where these data
    structures are being used.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了单链表、循环链表和双向链表。根据不同应用中所需的不同操作（插入、删除、更新等），相应地使用这些数据结构。让我们看看这些数据结构在实际应用中的几个实时例子。
- en: Singly linked lists can be used to represent any sparse matrix. Another important
    application is to represent and manipulate polynomials by accumulating constants
    in the node of linked lists.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 单链表可以用来表示任何稀疏矩阵。另一个重要的应用是通过在链表节点中累积常数来表示和操作多项式。
- en: It can also be used in implementing a dynamic memory management scheme that
    allows the user to allocate and deallocate the memory as per requirements during
    the execution of programs.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 它还可以用于实现一个动态内存管理方案，允许用户在程序执行期间根据需要分配和释放内存。
- en: On the other hand, doubly linked lists are used by the thread schedular in the
    operating system to maintain the list of processes running at that time. These
    lists are also used in the implementation of **MRU** (most recently used) and
    **LRU** (least recently used) cache in the operating system.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，双向链表被操作系统中的线程调度器用来维护当时正在运行的进程列表。这些列表也被用于操作系统中的**MRU**（最近最少使用）和**LRU**（最近最少使用）缓存的实现。
- en: Doubly linked lists can also be used by various applications to implement **Undo**
    and **Redo** functionality. The browsers can use these lists to implement backward
    and forward navigation of the web pages visited.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 双向链表也可以被各种应用程序用来实现**撤销**和**重做**功能。浏览器可以使用这些列表来实现访问过的网页的向前和向后导航。
- en: A circular linked list can be used by operating systems to implement a round-robin
    scheduling mechanism. Another application of circular linked lists is to implement
    **Undo** functionality in Photoshop or Word software and use it in implementing
    a browser cache that allows you to hit the **BACK** button. Besides that, it is
    also used to implement advanced data structures such as the Fibonacci heap. Multiplayer
    games also use a circular linked list to swap between players in a loop.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 循环链表可以被操作系统用来实现循环调度机制。循环链表的另一个应用是在 Photoshop 或 Word 软件中实现**撤销**功能，并用于实现允许你点击**后退**按钮的浏览器缓存。除此之外，它还被用来实现如斐波那契堆等高级数据结构。多人游戏也使用循环链表在玩家之间循环切换。
- en: Summary
  id: totrans-417
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we studied the concepts that underlie lists, such as nodes
    and pointers to other nodes. We have discussed singly linked lists, doubly linked
    lists, and circular linked lists. We have seen various operations that can be
    applied to these data structures and their implementations using Python.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们研究了列表背后的概念，例如节点和其他节点的指针。我们讨论了单链表、双向链表和循环链表。我们看到了可以应用于这些数据结构的各种操作及其使用
    Python 的实现。
- en: These types of data structures have certain advantages over arrays. In the case
    of arrays, insertion and deletion are quite time-consuming as these operations
    require the shifting of elements downward and upward, respectively, due to contiguous
    memory allocations. On the other hand, in the case of linked lists, these operations
    require only changes in pointers. Another advantage of linked lists over arrays
    is the allowance of a dynamic memory management scheme that allocates memory during
    the runtime as and when needed, while the array is based on a static memory allocation
    scheme.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型的数据结构相对于数组有一定的优势。在数组的情况下，插入和删除操作相当耗时，因为这些操作需要由于连续内存分配而向下和向上移动元素。另一方面，在链表的情况下，这些操作只需要改变指针。链表相对于数组的另一个优势是允许动态内存管理方案，该方案在程序执行期间根据需要分配内存，而数组基于静态内存分配方案。
- en: The singly linked list can traverse in a forward direction only, while traversal
    in doubly linked lists is bidirectional, hence the reason why the deletion of
    a node in a doubly linked list is easy compared to a singly linked list. Similarly,
    circular linked lists save time while accessing the first node from the last node
    as compared to the singly linked list. Thus, each list has its advantages and
    disadvantages. We should use them as per the requirements of the application.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 单链表只能向前遍历，而双链表的遍历是双向的，这就是为什么与单链表相比，在双链表中删除节点更容易。同样，与单链表相比，循环链表在从末尾访问第一个节点时可以节省时间。因此，每种链表都有其优缺点。我们应该根据应用程序的需求来使用它们。
- en: In the next chapter, we are going to look at two other data structures that
    are usually implemented using lists—stacks and queues.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨两种通常使用列表实现的其他数据结构——栈和队列。
- en: Exercise
  id: totrans-422
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: What will be the time complexity when inserting a data element after an element
    that is being pointed to by a pointer in a linked list?
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在链表中插入数据元素到指针所指向的元素之后时的时间复杂度是多少？
- en: What will be the time complexity when ascertaining the length of the given linked
    list?
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定给定链表长度时的时间复杂度是多少？
- en: What will be the worst-case time complexity for searching a given element in
    a singly linked list of length n?
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在长度为n的单链表中搜索给定元素的最坏情况时间复杂度是多少？
- en: For a given linked list, assuming it has only one `head` pointer that points
    to the starting point of the list, what will be the time complexity for the following
    operations?
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于给定的链表，假设它只有一个指向列表起始点的`head`指针，以下操作的时间复杂度是多少？
- en: Insertion at the front of the linked list
  id: totrans-427
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在链表前端插入节点
- en: Insertion at the end of the linked list
  id: totrans-428
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在链表末尾插入节点
- en: Deletion of the front node of the linked list
  id: totrans-429
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除链表的前端节点
- en: Deletion of the last node of the linked list
  id: totrans-430
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除链表最后一个节点
- en: Find the n^(th) node from the end of a linked list.
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从链表末尾找到第n个节点。
- en: How can you establish whether there is a loop (or circle) in a given linked
    list?
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何确定给定链表中是否存在循环（或环形）？
- en: How can you ascertain the middle element of the linked list?
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何确定链表的中间元素？
- en: Join our community on Discord
  id: totrans-434
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的Discord社区
- en: 'Join our community’s Discord space for discussions with the author and other
    readers: [https://packt.link/MEvK4](https://packt.link/MEvK4)'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的社区Discord空间，与作者和其他读者进行讨论：[https://packt.link/MEvK4](https://packt.link/MEvK4)
- en: '![](img/QR_Code1421249772551223062.png)'
  id: totrans-436
  prefs: []
  type: TYPE_IMG
  zh: '![二维码](img/QR_Code1421249772551223062.png)'
