["```py\nimport unittest\nfrom unittest.mock import mock_open, patch\n```", "```py\nclass Logger:\n    def __init__(self, filepath):\n        self.filepath = filepath\n    def log(self, message):\n        with open(self.filepath, \"a\") as file:\n            file.write(f\"{message}\\n\")\n```", "```py\nclass TestLogger(unittest.TestCase):\n    def test_log(self):\n        msg = \"Hello, logging world!\"\n```", "```py\n        m_open = mock_open()\n        with patch(\"builtins.open\", m_open):\n            logger = Logger(\"dummy.log\")\n            logger.log(msg)\n```", "```py\n            m_open.assert_called_once_with(\n                \"dummy.log\", \"a\"\n            )\n            m_open().write.assert_called_once_with(\n                f\"{msg}\\n\"\n            )\n```", "```py\nif __name__ == \"__main__\":\n    unittest.main()\n```", "```py\npython ch10/mock_object.py\n```", "```py\n.\n---------------------------------------------------------\nRan 1 test in 0.012s\nOK\n```", "```py\nfrom typing import Protocol\nclass WeatherApiClient(Protocol):\n    def fetch_weather(self, location):\n        \"\"\"Fetch weather data for a given location\"\"\"\n        ...\n```", "```py\nclass RealWeatherApiClient:\n    def fetch_weather(self, location):\n        return f\"Real weather data for {location}\"\n```", "```py\nclass WeatherService:\n    def __init__(self, weather_api: WeatherApiClient):\n        self.weather_api = weather_api\n    def get_weather(self, location):\n        return self.weather_api.fetch_weather(location)\n```", "```py\nif __name__ == \"__main__\":\n    ws = WeatherService(RealWeatherApiClient())\n    print(ws.get_weather(\"Paris\"))\n```", "```py\npython ch10/dependency_injection/di_with_mock.py\n```", "```py\nch10/dependency_injection/test_di_with_mock.py).\n\t\t\tFirst, we import the `unittest` module, as well as the `WeatherService` class (from our `di_with_mock` module), as follows:\n\n```", "```py\n\n\t\t\tThen, we create a mock version of the weather API client implementation that will be useful for unit testing, simulating responses without making real API calls:\n\n```", "```py\n\n\t\t\tNext, we write the test case class, with a test function. In that function, we inject the mock API client instead of the real API client, passing it to the `WeatherService` constructor, as follows:\n\n```", "```py\n\n\t\t\tWe finish by adding the usual lines for executing unit tests when the file is interpreted by Python:\n\n```", "```py\n\n\t\t\tExecuting this part of the example (in the `ch10/dependency_injection/test_di_with_mock.py` file), using the `python ch10/dependency_injection/test_di_with_mock.py` command, gives the following output:\n\n```", "```py\n\n\t\t\tThe test with the dependency injected using a mock object succeeded.\n\t\t\tThrough this example, we were able to see that the `WeatherService` class doesn’t need to know whether it’s using a real or a mock API client, making the system more modular and easier to test.\n\t\t\tImplementing the Dependency Injection pattern – using a decorator\n\t\t\tIt is also possible to use decorators for DI, which simplifies the injection process. Let’s see a simple example demonstrating how to do that, where we’ll create a notification system that can send notifications through different channels (for example, email or SMS). The first part of the example will show the result based on manual testing, and the second part will provide unit tests.\n\t\t\tFirst, we define a `NotificationSender` interface, outlining the methods any notification sender should have:\n\n```", "```py\n\n\t\t\tThen, we implement two specific notification senders: the `EmailSender` class implements sending a notification using email, and the `SMSSender` class implements sending using SMS. This part of the code is as follows:\n\n```", "```py\n\n\t\t\tWe also define a notification service class, `NotificationService`, with a class attribute sender and a `.notify()` method, which takes in a message and calls `.send()` on the provided sender object to send the message, as follows:\n\n```", "```py\n\n\t\t\tWhat is missing is the decorator that will operate the DI, to provide the specific sender object to be used. We create our decorator to decorate the `NotificationService` class for injecting the sender. It will be used by calling `@inject_sender(EmailSender)` if we want to inject the email sender, or `@inject_sender(SMSSender)` if we want to inject the SMS sender. The code for the decorator is as follows:\n\n```", "```py\n\n\t\t\tNow, if we come back to the notification service’s class, the code would be as follows:\n\n```", "```py\n\n\t\t\tFinally, we can instantiate the `NotificationService` class in our application and notify a message for testing the implementation, as follows:\n\n```", "```py\n\n\t\t\tThat first part of our example (in the `ch10/dependency_injection/di_with_decorator.py` file) can be manually tested by using the following command:\n\n```", "```py\n\n\t\t\tYou should get the following output:\n\n```", "```py\n\n\t\t\tIf you change the decorating line, replace the `EmailSender` class with `SMSSender`, and rerun that command, you will get the following output:\n\n```", "```py\n\n\t\t\tThat shows the DI is effective.\n\t\t\tNext, we want to write unit tests for that implementation. We could use the mocking technique, but to see other ways, we are going to use the stub classes approach. The stubs manually implement the dependency interfaces and include additional mechanisms to verify that methods have been called correctly. Let’s start by importing what we need:\n\n```", "```py\n\n\t\t\tThen, we create stub classes that implement the `NotificationSender` interface. These classes will help record calls to their `send()` method, using the `messages_sent` attribute on their instances, allowing us to check whether the correct methods were called during the test. Both stub classes are as follows:\n\n```", "```py\n\n\t\t\tNext, we are going to use both stubs in our test case to verify the functionality of `NotificationService`. In the test function, `test_notify_with_email`, we create an instance of `EmailSenderStub`, inject that stub into the service, send a notification message, and then verify that the message was sent by the email stub. That part of the code is as follows:\n\n```", "```py\n\n\t\t\tWe need another function for the notification with SMS functionality, `test_notify_with_sms`. Similarly to the previous case, we create an instance of `SMSSenderStub`. Then, we need to inject that stub into the notification service. But, for that, in the scope of the test, we define a custom notification service class, and decorate it with `@inject_sender(SMSSenderStub)`, as follows:\n\n```", "```py\n\n\t\t\tBased on that, we inject the SMS sender stub into the custom service, send a notification message, and then verify that the message was sent by the SMS stub. The complete code for the second unit test is as follows:\n\n```", "```py\n\n\t\t\tFinally, we should not forget to add the lines needed for executing unit tests when the file is interpreted by Python:\n\n```", "```py\n\n\t\t\tExecuting the unit test code (in the `ch10/dependency_injection/test_di_with_decorator.py` file), using the `python ch10/dependency_injection/test_di_with_decorator.py` command, gives the following output:\n\n```", "```py\n\n\t\t\tThis is what was expected.\n\t\t\tSo, this example showed how using a decorator to manage dependencies allows for easy changes without modifying the class internals, which not only keeps the application flexible but also encapsulates the dependency management outside of the core business logic of your application. In addition, we saw how DI can be tested with unit tests using the stubs technique, ensuring the application’s components work as expected in isolation.\n\t\t\tSummary\n\t\t\tIn this chapter, we’ve explored two pivotal patterns essential for writing clean code and enhancing our testing strategies: the Mock Object pattern and the Dependency Injection pattern.\n\t\t\tThe Mock Object pattern is crucial for ensuring test isolation, which helps avoid unwanted side effects. It also facilitates behavior verification and simplifies test setup. We discussed how mocking, particularly through the `unittest.mock` module, allows us to simulate components within a unit test, demonstrating this with a practical example.\n\t\t\tThe Dependency Injection pattern, on the other hand, offers a robust framework for managing dependencies in a way that enhances flexibility, testability, and maintainability. It’s applicable not only in testing scenarios but also in general software design. We illustrated this pattern with an initial example that integrates mocking for either unit or integration tests. Subsequently, we explored a more advanced implementation using a decorator to streamline dependency management across both the application and its tests.\n\t\t\tAs we conclude this chapter and prepare to enter the final one, we’ll shift our focus slightly to discuss Python anti-patterns, identifying common pitfalls, and learning how to avoid them.\n\n```"]