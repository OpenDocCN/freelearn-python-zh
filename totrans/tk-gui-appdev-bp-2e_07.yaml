- en: Piano Tutor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, we explored most of the common options available for the
    Canvas widget. Let's now see the PhotoImage widget in action.
  prefs: []
  type: TYPE_NORMAL
- en: Let's build a program called *Piano Tutor*. This program will help new piano
    players identify musical scales, chords, and chord progressions. It will also
    help piano learners learn and identify music written on music sheets. People with
    some musical knowledge will feel right at home, but do not worry if you know nothing
    about piano or musical terms such as scales, chords, and chord progressions. We
    will cover the bare minimum of musical know-how as we progress.
  prefs: []
  type: TYPE_NORMAL
- en: 'In its final form, the program looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/290771f0-61fd-43ba-8210-0d8eb4af6f03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The Piano Tutor will have *three broad sections* that can be selected from
    the topmost drop-down menu. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Scale Finder
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chord Finder
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chord Progression Builder
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some of the key objectives of this chapter are:'
  prefs: []
  type: TYPE_NORMAL
- en: Getting to understand some important methods defined on the root window
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the PhotoImage widget class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Practical applications of the Place geometry manager
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding grid weights
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning how to work with seemingly complex ideas such as representing musical
    knowledge in a fashion that computers can understand
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using JSON to store data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Besides Tkinter, we will use a few standard Python libraries. The next import
    should execute without any error as they are built-in in most Python distributions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In addition, we use `simpleaudio`, which is a module that lets us play notes
    on the piano.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can install `simpleaudio` using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: A brief primer on piano terms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since this is a piano-related program, a brief understanding of some of the
    common terms used in this context is required.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will use this figure as a reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fe2797e3-e89e-41a2-8618-d7453baef5da.png)'
  prefs: []
  type: TYPE_IMG
- en: The keyboard of a piano comprises a set of 12 keys (seven white and five black
    keys), which forms what is called a **chromatic scale**. This pattern of 12 keys
    repeats over and over again totaling up to 88 keys on a standard piano. The pattern
    repeats twice in the preceding image (*C1* to *B1* and then *C2* to *B2*).
  prefs: []
  type: TYPE_NORMAL
- en: The distance between any two adjacent keys is called a **semitone**. Please
    take note of this term as we will define all piano-related rules using semitones—a
    measure of distance between keys. An interval of two semitones is called a **whole
    tone**. We will not bother with whole tones as far as our program is concerned.
  prefs: []
  type: TYPE_NORMAL
- en: The white keys of the piano are labeled by note names *A* to *G*. However, as
    per convention the counting of notes begins at *C*. *C* is the first white key
    just before the set of two black keys. The names of white keys are marked on the
    keys and the names of black keys are marked above them.
  prefs: []
  type: TYPE_NORMAL
- en: Since there are multiple sets of 12 keys they are differentiated among themselves
    by appending a number after them. For example, *C1* is the first white key, while
    *C2* is the key at the same position, but an octave higher. The black key just
    next to *C* is called **C sharp** (**C#**). Since it is also just before the key
    **D** it has another name—*D* flat ( D♭). We will, however, stick with calling
    all black keys by using the sharp symbol (#). Since the notes *E* and *B* do not
    have any sharp keys they are not immediately followed by any black key.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about scales
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **scale** is an organized sequence of notes chosen from the 12 notes in a
    particular pattern, which gives it a characteristic feel, perhaps a happy, sad,
    exotic, oriental, enigmatic, or rebellious feel. A scale can start on any note
    of the 12 notes and follows a definite pattern. The first note of a scale is called
    its **root note** and the pattern it follows gives it a scale type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One particular scale of relevance to us is called the **Major scale**. Starting
    at any key, the Major scale follows the following pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: W W S W W W S
  prefs: []
  type: TYPE_NORMAL
- en: where *W* stands for whole tone (jump of two keys) and *S* stands for semitones
    (jump of one key).
  prefs: []
  type: TYPE_NORMAL
- en: For example, if you play the notes *C1*, *D1*, *E1*, *F1*, *G1*, *A1*, *B1*,
    *C2*, and back, one-by-one, you have played a *C* Major scale.  A Major scale
    sounds uplifting while another scale named minor can sound a bit sad. Don't worry
    about names—there are hundreds of scales and we just need to know that scales
    are a *sequence* of notes played together following a certain set of rules.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about chords
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In contrast, a **chord** is when you play two or more notes simultaneously.
    For example, if I play three notes C, F, and G altogether; it's a chord. Chords
    generally provide the bass section to a music.
  prefs: []
  type: TYPE_NORMAL
- en: If you keep playing the same chord over and over again it will sound monotonous—so
    you jump from one chord—again following a rule. This is called **chord progression**.
     More simply, an ordered series of chords is called a chord progression.
  prefs: []
  type: TYPE_NORMAL
- en: 'The musical notes can be written on a music sheet or **score sheet** that comprises
    of five lines. The notes are represented by black dots, which can lie on the line
    or in spaces between them. The names of notes for two octaves are shown on the
    following score sheet. The icon marked as **treble clef** means that these notes
    are to be played with the right hand:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9a5ed504-bde0-4eb3-bcc6-b4a04fd934f0.png)'
  prefs: []
  type: TYPE_IMG
- en: Do not worry, we are not required to memorize the music notation for completing
    our program. We will, however, use it as a reference when drawing the score sheet.
  prefs: []
  type: TYPE_NORMAL
- en: We are now equipped with all the musical knowledge required to write this program.
    Let's start coding.
  prefs: []
  type: TYPE_NORMAL
- en: Building the broad GUI structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We start as usual by building the root window (`7.01/view.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We also create a new file named `constants.py`( `7.01`), which currently holds
    the height parameters for the window.
  prefs: []
  type: TYPE_NORMAL
- en: We use two root window methods,  `root.winfo_screenwidth()`and `root_winfo_screenheight()`,
    to obtain the screen width and height, respectively. We define two constants,  `WINDOW_WIDTH`
    and `WINDOW_HEIGHT`, and then place the window on the *x*, *y* center of the computer
    screen.
  prefs: []
  type: TYPE_NORMAL
- en: Notice the line `root.resizable(False, False)`. This root window method takes
    two Boolean arguments to decide if the window is resizable in the *x* and *y*
    directions.  Setting both arguments to `False` makes our window fixed in size.
  prefs: []
  type: TYPE_NORMAL
- en: The root window is then passed as an argument to a new class, `PianoTutor`,
    which takes care of building the internals of the program. This class is defined
    next.
  prefs: []
  type: TYPE_NORMAL
- en: 'The GUI for this program is divided into four broad rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8d23c407-3e73-430e-980a-d45939106434.png)'
  prefs: []
  type: TYPE_IMG
- en: The topmost row is built in a `Frame` named `mode_selector_frame` and has a
    `combobox` that lets the user select from one of three options—scales, chords, and
    chord progressions.
  prefs: []
  type: TYPE_NORMAL
- en: The second row is a placeholder for placing the music score sheet and is accordingly
    called the `score_sheet_frame.`
  prefs: []
  type: TYPE_NORMAL
- en: The third row requires a bit of attention. Depending on what is selected in
    the topmost `combobox`, the contents of this row change.  In our code so far,
    (`7.01/view.py`*)*, it displays three different colored frames for the three different
    choices one can make using the topmost `combobox`. Since we will place controls
    on this frame, we decided to call it a `controls_frame` for want of a better name.
  prefs: []
  type: TYPE_NORMAL
- en: The fourth row shows the piano keyboard and the frame is named `keyboard_frame`,
    the implementation of which will be discussed in the section entitled *Making
    the Piano Keyboard*.
  prefs: []
  type: TYPE_NORMAL
- en: Putting up the skeleton structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To start, we build a class `PianoTutor` (`7.01/view.py`), the `__init__` method
    of which is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we are simply defining method calls to build multiple
    Frame widgets of predefined heights.  We won't elaborate much upon the preceding
    code as we wrote similar code in all of the previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at one example of frame creation. All other frames follow a similar
    pattern (`7.01 /view.py`) and will not be discussed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This is simple `Frame` creation using the `grid` geometry manager. However,
    take a note of the line `self.score_sheet_frame.grid_propagate(False)`.
  prefs: []
  type: TYPE_NORMAL
- en: In Tkinter, the container window (Frame in the previous example) is designed
    to *shrink to fit* around its contents.
  prefs: []
  type: TYPE_NORMAL
- en: Even though we have explicitly added a  width or height to the frame, if we
    comment the `grid_propagate(false)` line, you will notice that the width and height
    parameters given by us are simply ignored and the frame will shrink to exactly
    fit its children—the Label widgets height in our case. We do not want to allow
    this shrinking of Frames and `grid_propagate(False)` lets us achieve that.
  prefs: []
  type: TYPE_NORMAL
- en: If we were using pack manager, we would have used `frame.pack_propagate(False)` instead
    to achieve the same result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, our topmost mode selector `combobox` is bound to the following callback (`7.01/view.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s how we define the `on_mode_changed` method (`7.01/view.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Take a note of the `grid_remove()` method mentioned previously. This method
    removes the widget from the grid manager, thereby making it invisible. You can
    make it visible again by using `grid()` on it. So effectively, whenever a user
    selects one of the three options (`Scales`, `Chords`, and `Chord Progression`)
    from the topmost `combobox`, the other two frames are hidden using `grid_remove`
    and the frame for the selected option is made visible using `grid.`
  prefs: []
  type: TYPE_NORMAL
- en: This completes the first iteration where we defined the broad GUI structure
    with the capability to switch between scales, chords, and chord progression frames
    based on choices made in the topmost combobox.
  prefs: []
  type: TYPE_NORMAL
- en: Making the piano keyboard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's now build the piano keyboard. All keys on the keyboard will be made using
    the Label widget. We will superimpose the label widget with an image of black
    and white keys using Tkinter's `PhotoImage` class.
  prefs: []
  type: TYPE_NORMAL
- en: The `PhotoImage` class is used to display images in label, text, button, and
    canvas widgets. We used it in [Chapter 2](41f1fda5-b3b1-4dfa-8971-2a016274d39a.xhtml),* Making
    a Text Editor* to add icons to buttons.  Since this class can only handle `.gif`
    or `.bpm` format images, we add four `.gif` images to a folder named `pictures`.
    These four images are `black_key.gif`, `white_key.gif`, ` black_key_pressed.gif`,
    and `white_key_pressed.gif`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we will refer to these images over and over again,  we add their reference
    to `7.02` `constants.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The symbol `../`  used previously is a way to specify a file path relative to
    the current working directory. A single `../` means—go back one directory, a set
    of two `../../` means go back two directories, and so on.  This system is generally
    honored by most modern operating systems. However, some very old operating systems
    might not support it. So a better but a more verbose way is to use the `os` module
    of Python to traverse directories.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will define a method named `create_key` that creates a piano key for
    us at a given `x` location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s a brief code description:'
  prefs: []
  type: TYPE_NORMAL
- en: Note that since we want to place keys at a specific x coordinate we use the
    `place` geometry manager.  We briefly touched upon the place geometry manager
    in [Chapter 1](39a58f50-293e-4ff5-9b65-0d9e0c0cc15e.xhtml),* Meet Tkinter*. Now
    is a good place to see this rarely used geometry in action.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This method also takes an image location as its input and creates a `PhotoImage`
    class, which is then attached to the label widget using the `image=key_image`
    option in the previous example.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A third parameter, `key_name`, is attached to the created label widget by using
    the command `widget.name = key_name`. This is needed to later identify which particular
    key was pressed. For example, to create the first key *C1*, we attach the name
    *C1* to the label widget and then later this string value can be accessed by calling
    `widget.name`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We bind the label to two events, `'<Button-1>'` and `'<ButtonRelease-1>'`, to
    handle mouse press events.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we add a reference to the newly created widget into an attribute newly
    defined here as `self.keys`. We keep this reference as we will need to change
    the image of these widgets to highlight the keys.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that we have attached events to two callbacks, let''s define them next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'For now, the previous methods print the name of the key pressed and then call
    another two methods that change the image of the pressed label to a different
    colored image on button press and release:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The white key widget will have a name of length `2` (for example, `C1`, `D2`,
    `G1`), while a black key will have an image length of `3` (for example, `C#1`,
    `D#1`). We utilize this fact to decide if to use a black key image or a white
    key image. The rest of the preceding code should be self-explanatory.
  prefs: []
  type: TYPE_NORMAL
- en: Putting the keyboard together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now it's finally time to combine all the preceding methods to build our complete
    keyboard of two octaves.
  prefs: []
  type: TYPE_NORMAL
- en: 'We begin by defining the exact `x_coordinates` for all the keys from *C1* to
    *B2* in the file `constants.py` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The preceding *x* coordinate numbers have been obtained simply by trial and
    error as to emulate their location on a keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we modify the previously defined `build_keyboard_frame` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The first three lines of the previous method remain as defined in the previous
    iteration. We then go through all white and black keys creating labels for them
    at given *x* coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: 'That concludes the iteration. If you now run  `7.02 view.py`, you should see
    a two-octave keyboard. When you press any key, the key''s image should change
    to blue and it should print the name of the key pressed or released in the Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bf3fe252-9b41-4da9-b598-395ba3097f6e.png)'
  prefs: []
  type: TYPE_IMG
- en: Playing audio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To begin with, we have added 24 sound samples in `.wav` format in a folder named
    `sounds` in this chapter's code folder. These audio files correspond to the 24
    notes on our keyboard. The audio files are named according to the note name it
    represents.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to keep the audio processing separate from the GUI code, we create
    a new file called `audio.py` (`7.03`).The code is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The code description is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `play_note` method follows the API provided by `simpleaudio` to play an
    audio file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `play_scale` method takes in a list of notes and plays them sequentially,
    giving a time gap between each played note
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `play_chord` method takes a list of notes and plays them all together
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last two methods call these methods in new threads as we don't want to block
    the main GUI thread when playing these notes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, let''s import this file (`7.03` `view.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, modify the `on_key_pressed` method to play the given note:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This concludes the iteration. If you now run the code and press any key on the
    keyboard, it should play the note for that key.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we start with building the actual tutor. The next three sections will
    develop the scales, chords, and chord progression sections.  We will start by
    building the scales tutor.
  prefs: []
  type: TYPE_NORMAL
- en: Building the scales tutor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All the rules for defining which notes to play for a given scale are added
    in a JSON file named `scales.json` within a folder named `json`. Let''s take a
    look at the first few lines in the `scales.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Recall that a scale is a set of notes played sequentially. The first note of
    the scale is called its **root** or **key**. So if you play a scale starting at
    say the note *B*, you are playing the scale in the key of *B*.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take the fourth item in the key-value pairs. The key is named `"Melodic
    minor"` and its associated value is `[ 0, 2, 3, 5, 7, 9, 11 ]`. This means that,
    to play a melodic minor scale in the key of *B*, you will take *B* as the first
    item—that is represented by `0` in the values list. The next key is two semitones
    above *B*, the third key is three semitones above *B*, and the next is 5, followed
    by 7, 9, and 11 semitones above *B*.
  prefs: []
  type: TYPE_NORMAL
- en: 'So to summarize—in order to play Melodic minor in the key of *B* you will play
    the following keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Where the preceding numbers represent semitones.
  prefs: []
  type: TYPE_NORMAL
- en: 'So our task is—given a scale and the key for the scale, our program should
    highlight the keys and play it out:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/48044a81-d04b-4b28-9354-e0c273aa23b0.png)'
  prefs: []
  type: TYPE_IMG
- en: The first thing is to build two `combobox` for the scale and keys as shown previously.
    This should be easy for you as we have built `combobox` several times in the previous
    chapters.
  prefs: []
  type: TYPE_NORMAL
- en: The second step involves reading the JSON file into our program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Quoting from json.org ([http://json.org/](http://json.org/)):'
  prefs: []
  type: TYPE_NORMAL
- en: JSON (JavaScript Object Notation) is a lightweight data-interchange format.
    It is easy for humans to read and write. It is easy for machines to parse and
    generate. These are universal data structures. Virtually all modern programming
    languages support them in one form or another. It makes sense that a data format
    that is interchangeable with programming languages is also be based on these structures.
    Read more about JSON at [https://www.json.org](https://www.json.org).
  prefs: []
  type: TYPE_NORMAL
- en: Python implements a standard module for reading and writing JSON data too. The
    module is rightfully called `json`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We first import the built-in `json` module in our namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We next add a new method, `self.load_json_files()`, and call it from the class
    `__init__` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `SCALES_JSON_FILE` path is defined in the file `constants.py`*.* This loads
    up the scales data as a dictionary in the `self.scales` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: You can read JSON files by using the `json.load` command. You can write to a
    JSON file by using the `json.dump` command. However, `json.load` methods do not preserve
    key order from a parsed JSON document. That is to say, `json.load` jumbles up
    the order of the keys. We do not want to jumble up the order of the keys and want
    them to appear in the order they are mentioned in the file. We therefore use the
    `OrderedDict` class from the `collections` module to preserve the key order.  This
    is achieved by passing the second argument as `object_pairs_hook=OrderedDict`. An `OrderedDict` is
    a Python dictionary object that remembers the order that keys were first inserted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the scales data available as the `self.scales` dictionary,
    our next task is to figure out the keys to highlight. We start by creating a new
    attribute in the class `__init__` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we define methods to highlight a key and another method to highlight
    a list of keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is similar to the previous code we wrote to highlight a
    key when it is pressed. Next, we also need methods to remove existing highlights:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The logic here is exactly similar to the one we applied for highlighting keys.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have methods to highlight and remove highlights from keys, let''s
    define the callbacks attached to the two combobox for scale and key selection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, here is the logic to select which keys to highlight. Furthermore, once
    we have the list of keys to be highlighted, we pass it to the previously defined
    `play_scale_in_new_thread` method that plays the actual sound for the scale:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Do notice the highlighted part of the code.
  prefs: []
  type: TYPE_NORMAL
- en: So given the index of the selected key, we simply add all items in the list
    of selected scale to obtain the list of keys to be highlighted.
  prefs: []
  type: TYPE_NORMAL
- en: We also want to call this method as soon as the program runs. So we add a call
    to `self.find_scale()` right in our `__init__` method. That ensures that we are
    greeted by playing of *C* Major scale (the default selection in `combobox`) as
    soon as the program runs.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes the iteration. Now if you go and run `7.04 view.py` and select
    the appropriate scale and key name, the keyboard will highlight the keys and also
    play it out for you.
  prefs: []
  type: TYPE_NORMAL
- en: Building the chord finder section
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have had a glimpse of working with *JSON* files, this should be
    easy. Let''s take a look at the first few lines of the `chords.json` file from
    the `json` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This is very similar to the scales structure. Let''s say we want to figure
    out what the *C*# major chord would look like. So we start with the *C*# key,
    which is `0`. Then we look at the list of major chords, which read: `[0, 4, 7]`.
    So starting at *C*# the next key to highlight is `4` semitones above and the next
    is `7` semitones above *C*#. So the final chord structure for the C# major chord
    would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The GUI is also very similar to the scales section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9c7f7ed7-1884-4546-8152-6df9af62fcfb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We begin by adding a constant for the path to the `chords.json` file in  `7.05
    constants.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we read the contents of this file in a new class attribute, `self.chords`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We then modify the chords frame GUI to add two `combobox` (see the complete
    GUI in `7.05 view.py` `build_chords_frame`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we added the two event callbacks defined previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The `find_chord` method queries the `self.chords` dict for the keys to be highlighted,
    adds the key offsets from the root note, and calls it to be highlighted and played:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The final code in this iteration modifies the `on_mode_changed` method to highlight
    the chord as soon as the chord mode is selected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: That concludes the iteration. If you now run `7.05 view.py`, you will find a
    functional chords section that lets us find chords of different varieties in different
    scales.
  prefs: []
  type: TYPE_NORMAL
- en: Building the chord progression tutor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The GUI component of the chord progression section is slightly more evolved
    than the previous two sections. Here''s how a typical chord progression GUI looks
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5400163b-8525-4fd4-befe-42f9b4bc53c0.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice that this section has the combobox as opposed to two for the earlier
    sections.  Depending on what progression is chosen in the middle combobox, we
    need to draw a number of buttons, each button representing one chord in the complete
    chord progression.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, note that the progression combobox has a value
    of I-V-vi-IV. This is a total of four roman numbers separated by a dash. This
    means that this chord progression is made up of four chords. Also notice that
    a few of the roman numbers (I, V, IV, and so on) are written in capital letters
    and others (vi) are written in small letters.  All capital letters in the series
    denote major chords, while each small letter represents a minor chord.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let us take a look at the `progressions.json` file from the `json` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: As a first observation, the chord progressions are broadly of two types—major
    and minor. Each type has a list of chord progressions, which is identified by
    a set of roman numerals.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see an example of how this would work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Say we want to display the major chord progression `ii-V-I` in the key of *C*,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fde4c1fc-e1fe-48e0-b565-efbcff470290.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The JSON file lists the progression under the Major section as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s first lay down the 12 notes in a table starting at the key of the chord
    progression (C in our example). We need to pick up the 2^(nd),  7^(th), and  0^(th)
    keys for this progression:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **0** | 1 | **2** | 3 | 4 | 5 | 6 | **7** | 8 | 9 | 10 | 11 |'
  prefs: []
  type: TYPE_TB
- en: '| **C** | C# | **D** | D# | E | F | F# | **G** | G# | A | A# | B |'
  prefs: []
  type: TYPE_TB
- en: The keys are D(2^(nd)), G(7^(th)), and C(0^(th)). With the keys in hand—we next
    need to identify if each of the keys plays a major or minor chord. This is simple.
    Those roman numbers written in lower case play a minor chord, while those written
    in capitals play a major chord.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given this rule, our final chords in the chord progression in the key of *C*
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: D Minor - G Major - C Major
  prefs: []
  type: TYPE_NORMAL
- en: Having identified these, our program should dynamically create three buttons.
    Clicking on these buttons should then play the preceding three chords, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s code this feature. We begin by defining the location of the chords progression
    file in `7.06 constants.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We then load it from the method `load_json_files()` into an attribute named
    `self.progressions`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Next, we modify the progression frame to add three `combobox` elements. See
    the `build_progressions_frame`  code `7.06 view.py`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The three combobox are attached to the following three callbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The most complex of the three combobox is the progression scale combobox. It
    lets you choose between *Major* and *Minor* progression scales. Depending on the
    choice you make there,  it populates the second combobox with the progression
    values from the JSON file. This is what the first four lines of the `on_progression_scale_changed`
    method do.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other than that, all three preceding callback methods defined make a call to
    the `show_progression_buttons` method, which is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code dynamically creates buttons—one for each chord in the chord
    progression and stores all the buttons in a list named `self.progression_buttons`.
     We will keep this reference because we will have to destroy the buttons and create
    fresh ones every time a new chord progression is selected.
  prefs: []
  type: TYPE_NORMAL
- en: Note the use of the `partial` method from the `functools` module to define the
    button command callbacks. Since the buttons are being created dynamically, we
    need to keep track of the button number. We use this handy method `partials` that
    lets us call a method with only a partial number of arguments. Quoting from Python's
    documentation - The `partial()` function is used for partial function application,
    which *freezes* some portion of a function's arguments and/or keywords resulting
    in a new object with a simplified signature. You can read more about partials
    at [https://docs.python.org/3/library/functools.html#functools.partial](https://docs.python.org/3/library/functools.html#functools.partial).
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding code calls a `destroy_button` method whose task is to clear the
    frame for drawing the next set of buttons, in case a new progression is selected.
     The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we want to display an individual chord from the chord progression
    when a button is clicked. This is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s a brief description of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: We first split the text, say `ii-V-I`, using the dash (`-`) delimiter. We then
    loop through the list and check if it is in uppercase or lowercase. If it is uppercase,
    the `selected_chord` variable is set to `Major`, if not it is set to `Minor`*.*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The index of the keys is calculated by adding the key to the numbers mentioned
    in the JSON file. We apply modulo operator (`%`) to the added value to ensure
    that the value does not exceed the limits of 12 notes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Since the numbers are stored as roman numerals (this is the convention used
    by musicians), we need to convert it to integers. We do that by defining a simple
    key-value mapping in `7.05/constants.py`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Note that we have mapped all numbers starting at 0 and the mapping follows the
    Major scale pattern (`W W H W W S`), where `W` stands for whole tone (two keys
    jump) and `S` stands for semitone (one key jump).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we know that if the chord is a major or a minor, the rest of the code
    is exactly the same as we earlier used to identify the individual chords. We then
    highlight and play the individual chord.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To end, we modify the `on_mode_changed`  to add a call to `show_progression_buttons()`
    so that every time we switch to the chord progression section, the first chord
    progression buttons are laid down for us.
  prefs: []
  type: TYPE_NORMAL
- en: This completes the iteration. Our chord progression section is ready. Run code
    `7.06/view.py`. Inside the chord progression tutor, you can select the chord progression
    type (major or minor), the progression, and its key from the comboboxes and it
    will create one button for each of the chords in the chord progression. Press
    the individual buttons and it will play you the chords in that progression.
  prefs: []
  type: TYPE_NORMAL
- en: Building the score maker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let us now build the score maker. This will display whatever is played on the
    piano in music notation. For the sake of program modularity, we will build the
    program in a separate file named `score_maker.py`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by defining a class `ScoreMaker`. Since we will be showing just two
    octaves of notes, we will define a constant `NOTES` listing all the notes (`7.06/score_maker.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The `__init__` method of this class takes the container as an argument. This
    is the container on which this class will draw the score (`7.06/score_maker.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Note the use of `update_idletasks()` on the `container` frame. Calling this
    method here is necessary because we created a canvas in the previous line of code,
    which requires a redrawing of widgets. However, the redraw will only take place
    after the next run of the event loop. But we want to know the canvas width immediately after
    it was created. An explicit call to `update_idletasks` immediately carries out
    all pending events including geometry management. This ensures that we get the
    correct width of the canvas in the very next step. If you comment out the `update_idletasks`
    line and try to print the width of the canvas, it will print `1` even though we
    have explicitly set it to `500`.
  prefs: []
  type: TYPE_NORMAL
- en: We also initialize two `.gif` images that we will use to draw the score. The
    `treble_clef` image will be used to draw the treble clef to the left of the score,
    while the `sharp_image`  will draw a sharp (#) symbol prior to any sharp note
    (notes on the black keys).
  prefs: []
  type: TYPE_NORMAL
- en: Tkinter uses the concept of event loop to handle all events. Here's an excellent
    article that explains the concept in depth [http://wiki.tcl.tk/1527](http://wiki.tcl.tk/1527).  `update_idletask` is
    an example of the method available on all widgets. Visit [http://effbot.org/tkinterbook/widget.htm](http://effbot.org/tkinterbook/widget.htm)
    to see a list of methods that are available to be called on all widgets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our first task is to draw five equally spaced lines on the canvas. We accordingly
    define a new method to do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This creates five parallel lines each 10 pixels apart. The underscore in the
    method name is an indication that this is to be treated as a private method of
    the class. While Python does not enforce method privacy, this tells the users
    not to use this method directly in their program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s then build a method that actually calls the previous method and adds
    a treble clef to the left, thereby creating an empty staff on which we can draw
    notes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'At the outset, we need to differentiate between drawing a chord and drawing
    notes of the scale. Since all the notes of a chord are played together, the notes
    of a chord are drawn at a single *x* location. In contrast, the notes in a scale
    are drawn at regular *x* offsets, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f8dd155a-841b-4dc0-b05a-e2d950d88f17.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Since we need to offset the *x* value for scales at regular intervals, we use
    the `count` method from the `itertools` module to provide an ever-increasing value
    of *x*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Now every subsequent call to `x = next(self.x_counter)` increments *x* by `30`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now here''s the code that draws the actual note on the canvas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The description of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The method accepts a note name, for example, `C1` or *D2*#, and draws an oval
    at an appropriate place.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to get the *x*, *y* values for drawing an oval.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We first calculate the *x* value. If the note is part of a chord, we fix the
    *x* value at `75` px, whereas if the note is part of a scale, the *x* value is
    incremented by *30* pixels from the previous *x* value by calling `next` on the
    `itertool counter` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, we calculate the *y* value. The code to do this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Basically, the *y* offset is calculated based on the index of the note in the
    list and each subsequent note is offset by `5` pixels.  The number `85` is found
    by trial and error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the *x* and *y* value, we simply draw the oval of given `radius`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: If the note is a sharp note, that is, if it contains the character `#`,  it
    draws the `#` image 10 pixels left of the oval for the note.
  prefs: []
  type: TYPE_NORMAL
- en: The notes C1, G2, A2, and B2 are drawn outside the five lines. So in addition
    to oval we need to draw a small line crossing horizontally through them. This
    is what the last 11 lines of `if…else` statements achieve.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we have the `draw_notes` method and `draw_chord` method that given
    a list of notes draw out the notes and chords, respectively. These are the only
    two methods that do not have an underscore before their names. This means we expose
    the interface of our program only using these two methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our `ScoreMaker` ready, we simply import it into `7.07/view.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'We modify `build_score_sheet_frame` to instantiate the `ScoreMaker`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'We then modify `find_scale` to add this line (`7.07/view.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'We similarly modify `find_chord`  and `on_progression_button_clicked` to add
    this line (`7.07/view.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: That brings us to the end of this project. If you now run `7.07/view.py`, you
    should see a functional score maker and a functional Piano Tutor.
  prefs: []
  type: TYPE_NORMAL
- en: However, let's end this chapter with a brief discussion on window responsiveness.
  prefs: []
  type: TYPE_NORMAL
- en: A note on window responsiveness
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We used `.grid_propagate(False)` in this program to ensure that our frames did
    not shrink to fit their contents, but rather stayed at a fixed height and width
    that we had specified while making the frames.
  prefs: []
  type: TYPE_NORMAL
- en: This served us well for this example, but this made our window and its content
    fixed in size. This is what you would typically call a non-responsive window.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us take a look at the program `nonresponsive.py` *a*s an example of a non-responsive
    window. This program simply draws `10` buttons in a row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Run this program and resize the window. These buttons are drawn on the root
    window and are not responsive. The buttons remain fixed in size. They do not adapt
    in size to change in the window size.  If the window size is made smaller, some
    of the buttons even disappear from view.
  prefs: []
  type: TYPE_NORMAL
- en: 'In contrast, let us take a look at the program `responsive.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run this program and resize the window, you will see that the buttons
    respond by resizing themselves to fit the container root window. So what''s the
    difference between the two previous pieces of code? We simply added these two
    lines to the second program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: These two lines add **non-zero weights** (`weight=1`) to the `x`^(th) button
    widget in the container (root in the preceding example).
  prefs: []
  type: TYPE_NORMAL
- en: The key here is to understand the importance of weights. If we have two widgets, `widget1`
    and `widget2`, and we assign them weights of 3 and 1, respectively. Now when you
    resize its parent, `widget1` will take up 3/4^(th) of the space, while `widget2`
    will take up 1/4^(th) of the space.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the documentation of `rowconfigure` and `columnconfigure`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://infohost.nmt.edu/tcc/help/pubs/tkinter/web/grid-config.html](http://infohost.nmt.edu/tcc/help/pubs/tkinter/web/grid-config.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Experimenting with the code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The best way to experience this piece of code is to make the following tweaks
    one by one, run the program, and resize the window to see the effect of each option.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a first tweak, change the weights to `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: This will make the window non-responsive again.
  prefs: []
  type: TYPE_NORMAL
- en: Next, reassign the weights back to 1 and then comment out one of the two lines
    and see the difference. If you comment out the `rowconfigure` line the buttons
    will be responsive in the *y* direction, but non-responsive in the `x` direction
    and vice versa for `columnconfigure`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Restore the program to its original state and then assign a different weight
    in each loop by changing the weight to `x`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'So the first button will have a weight of 0, the second button will have a
    weight of 1, and so on. Now if you run the program and resize the window, the
    last button with weight=9 will be the most responsive (will take up the largest
    proportion of the available space), while the first button with a weight of 0
    will be completely non-responsive (fixed size), as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6a202f22-393d-4719-ba6d-a39491e116e2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As the last tweak, restore the program to its original state and change the
    value of the second argument to a fixed number, say *2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'This will assign the weight only to the third button (counting starts with
    0), so the third button becomes responsive, while the others stay non-responsive,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d7508541-365c-47ce-970d-599082b1a8b8.png)'
  prefs: []
  type: TYPE_IMG
- en: As a matter of fact, in this last case since we are assigning weight only to
    a single widget, we could have as well assigned it outside the loop.
  prefs: []
  type: TYPE_NORMAL
- en: Handling widget resize with <Configure>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There might be occasions when you <indexentry content="window responsiveness:widget
    resize, handling with ">want to do some specific action when a user resizes a
    window or a widget. Tkinter provides an event named `<Configure>`, which can be
    bound to a callback to react to changes in widget size.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a simple example (see `handle_widget_resize.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The description of the code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We have a Label widget in a `root` window. We set the pack options for the label
    to `(fill='both', expand=True)` as we want it to resize every time the root window
    resizes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We attach a callback to the `<Configure>` event to listen for any changes in
    the size of the label widget. As soon as the label widget changes, it triggers
    a call to the method `on_label_resized`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now if you resize the window, the label resizes and that triggers `on_label_resized`,
    which prints the new height and width of the label widget to the console. This
    can be used for adjusting the placement of items on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: That concludes our brief discussion on window responsiveness.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We worked with several useful standard modules such as `functools`, `itertools`,
     and `json`.
  prefs: []
  type: TYPE_NORMAL
- en: We saw how to work with *JSON* files. JSON helps us present complex rules about
    our domain and are an easier and more portable alternative to storing the same
    information in say a database.
  prefs: []
  type: TYPE_NORMAL
- en: We looked at the practical usage of `widget.grid_propagate(False)`  along with
    some of its limitations in terms of non-responsiveness.
  prefs: []
  type: TYPE_NORMAL
- en: We saw the usage of `OrderedDict` from the `collections` module and `partials`
    from the `functools` module.
  prefs: []
  type: TYPE_NORMAL
- en: We looked at various root window methods such as `root.geometry`, `root.winfo_screenwidth`,
    and `root.resizable`.
  prefs: []
  type: TYPE_NORMAL
- en: We looked at `widget.update_idletasks`, which lets us clear all pending updates
    without having to wait for the next run of mainloop.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we looked at the steps involved in making a window responsive in Tkinter.
  prefs: []
  type: TYPE_NORMAL
- en: QA section
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before you proceed to the next chapter, make sure you can answer these questions
    to your
  prefs: []
  type: TYPE_NORMAL
- en: 'satisfaction:'
  prefs: []
  type: TYPE_NORMAL
- en: What is `partial` from the `functools` module used for?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When and why do we need to use `widget.update_idletasks` in a Tkinter program?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If needed, how can we handle resizing of the main window or any other widget
    in Tkinter?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the data structures available in JSON? (read about it here: [https://www.json.org/](https://www.json.org/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do you make widgets responsive in Tkinter?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Read more about JSON data structures. They are popular and are used everywhere.
    An alternative structure is XML.  Read about XML and JSON and when and why one
    should be preferred over the other.
  prefs: []
  type: TYPE_NORMAL
- en: The collections module of Python provides some very versatile and useful data
    structures such as `namedtuple`, `deque`, `Counter`, `dict`, `OrderedDict`, `defaultdict`,
    `chainMap`, `UserDict`, `UserList`, and `userString`. These can be suitably used
    in a wide variety of use cases. More information can be found at:[ https://docs.python.org/3/library/collections.html](https://docs.python.org/3/library/collections.html).
  prefs: []
  type: TYPE_NORMAL
- en: We used external audio files and external images in our program. This means
    that they need to be bundled with the program if it has to be packaged and distributed.
    An alternative packaging of audio files and images can be done using what is called
    **base-64 encoding**.  The audio files and the images can be base-64 encoded in
    a text file and then read back and decoded by the program to be used as audio
    files or image files. Read about base-64 encoding and if you feel motivated enough,
    try to convert all audio files and images used in this program into base-64 encoding.
    More information on base-64 encoding can be found here: [https://en.wikipedia.org/wiki/Base64](https://en.wikipedia.org/wiki/Base64).
  prefs: []
  type: TYPE_NORMAL
- en: The Python implementation of base-64 encoding can be found here: [https://docs.python.org/3/library/base64.html](https://docs.python.org/3/library/base64.html).
  prefs: []
  type: TYPE_NORMAL
