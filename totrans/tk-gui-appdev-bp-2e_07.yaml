- en: Piano Tutor
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 钢琴辅导
- en: In the last chapter, we explored most of the common options available for the
    Canvas widget. Let's now see the PhotoImage widget in action.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了Canvas小部件可用的常见选项。现在，让我们看看PhotoImage小部件的实际应用。
- en: Let's build a program called *Piano Tutor*. This program will help new piano
    players identify musical scales, chords, and chord progressions. It will also
    help piano learners learn and identify music written on music sheets. People with
    some musical knowledge will feel right at home, but do not worry if you know nothing
    about piano or musical terms such as scales, chords, and chord progressions. We
    will cover the bare minimum of musical know-how as we progress.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建一个名为 *钢琴辅导* 的程序。这个程序将帮助新手钢琴演奏者识别音阶、和弦以及和弦进行。它还将帮助钢琴学习者学习和识别乐谱上的音乐。拥有一些音乐知识的人会感到如鱼得水，但如果你对钢琴或音阶、和弦、和弦进行等音乐术语一无所知，也不要担心。随着我们的进展，我们将涵盖音乐知识的最基本内容。
- en: 'In its final form, the program looks as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在其最终形式中，该程序看起来如下：
- en: '![](img/290771f0-61fd-43ba-8210-0d8eb4af6f03.png)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/290771f0-61fd-43ba-8210-0d8eb4af6f03.png)'
- en: 'The Piano Tutor will have *three broad sections* that can be selected from
    the topmost drop-down menu. They are as follows:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 钢琴辅导课程将包含*三个主要部分*，您可以从最顶部的下拉菜单中选择。具体如下：
- en: Scale Finder
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 规模查找器
- en: Chord Finder
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 和弦查找器
- en: Chord Progression Builder
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 和弦进行构建器
- en: 'Some of the key objectives of this chapter are:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的一些关键目标包括：
- en: Getting to understand some important methods defined on the root window
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解在根窗口上定义的一些重要方法
- en: Using the PhotoImage widget class
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 PhotoImage 小部件类
- en: Practical applications of the Place geometry manager
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Place几何管理器的实际应用
- en: Understanding grid weights
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解网格权重
- en: Learning how to work with seemingly complex ideas such as representing musical
    knowledge in a fashion that computers can understand
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何处理看似复杂的概念，例如以计算机能够理解的方式表示音乐知识
- en: Using JSON to store data
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 JSON 存储数据
- en: Technical requirements
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Besides Tkinter, we will use a few standard Python libraries. The next import
    should execute without any error as they are built-in in most Python distributions:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Tkinter，我们还将使用几个标准的Python库。接下来的导入应该不会出现任何错误，因为它们在大多数Python发行版中都是内置的：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In addition, we use `simpleaudio`, which is a module that lets us play notes
    on the piano.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们使用`simpleaudio`模块，这是一个允许我们在钢琴上播放音符的模块。
- en: 'You can install `simpleaudio` using the following command:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令安装 `simpleaudio`：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: A brief primer on piano terms
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 钢琴术语简要入门
- en: Since this is a piano-related program, a brief understanding of some of the
    common terms used in this context is required.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个与钢琴相关的程序，因此需要简要了解在此背景下使用的某些常用术语。
- en: 'In this section, we will use this figure as a reference:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将以此图作为参考：
- en: '![](img/fe2797e3-e89e-41a2-8618-d7453baef5da.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fe2797e3-e89e-41a2-8618-d7453baef5da.png)'
- en: The keyboard of a piano comprises a set of 12 keys (seven white and five black
    keys), which forms what is called a **chromatic scale**. This pattern of 12 keys
    repeats over and over again totaling up to 88 keys on a standard piano. The pattern
    repeats twice in the preceding image (*C1* to *B1* and then *C2* to *B2*).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 钢琴的键盘由一组12个键（七个白键和五个黑键）组成，这形成了所谓的**音阶**。这12个键的模式不断重复，在标准钢琴上总共有88个键。在先前的图像中，这个模式重复了两次（从*C1*到*B1*，然后从*C2*到*B2*）。
- en: The distance between any two adjacent keys is called a **semitone**. Please
    take note of this term as we will define all piano-related rules using semitones—a
    measure of distance between keys. An interval of two semitones is called a **whole
    tone**. We will not bother with whole tones as far as our program is concerned.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 任何两个相邻键之间的距离被称为**半音**。请注意这个术语，因为我们将会使用半音来定义所有与钢琴相关的规则——即键之间的距离度量。两个半音的间隔被称为**全音**。就我们的程序而言，我们不会关心全音。
- en: The white keys of the piano are labeled by note names *A* to *G*. However, as
    per convention the counting of notes begins at *C*. *C* is the first white key
    just before the set of two black keys. The names of white keys are marked on the
    keys and the names of black keys are marked above them.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 钢琴的白键被标记为音符名称 *A* 到 *G*。然而，按照惯例，音符的计数从 *C* 开始。*C* 是位于两组黑色键之前的第一个白键。白键的名称标记在键上，而黑键的名称则标记在其上方。
- en: Since there are multiple sets of 12 keys they are differentiated among themselves
    by appending a number after them. For example, *C1* is the first white key, while
    *C2* is the key at the same position, but an octave higher. The black key just
    next to *C* is called **C sharp** (**C#**). Since it is also just before the key
    **D** it has another name—*D* flat ( D♭). We will, however, stick with calling
    all black keys by using the sharp symbol (#). Since the notes *E* and *B* do not
    have any sharp keys they are not immediately followed by any black key.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 由于存在多套12个键的集合，它们通过在其后附加一个数字来相互区分。例如，*C1* 是第一个白键，而 *C2* 是同一位置上的键，但音高高一个八度。紧挨着
    *C* 的黑键被称为 **C#**（**C sharp**）。由于它也在 **D** 键之前，它还有一个名字——*D* 平（D♭）。然而，我们将坚持使用升号符号（#）来称呼所有黑键。由于音符
    *E* 和 *B* 没有升音键，它们后面不直接跟着任何黑键。
- en: Learning about scales
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习关于比例的知识
- en: A **scale** is an organized sequence of notes chosen from the 12 notes in a
    particular pattern, which gives it a characteristic feel, perhaps a happy, sad,
    exotic, oriental, enigmatic, or rebellious feel. A scale can start on any note
    of the 12 notes and follows a definite pattern. The first note of a scale is called
    its **root note** and the pattern it follows gives it a scale type.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**音阶**是一系列从特定模式中选取的12个音符的有序序列，这赋予它一种特有的感觉，可能是快乐的、悲伤的、异国情调的、东方的、神秘的或叛逆的感觉。音阶可以从12个音符中的任何一个音符开始，并遵循一个确定的模式。音阶的第一个音符被称为其**基音**，它遵循的模式决定了音阶的类型。'
- en: 'One particular scale of relevance to us is called the **Major scale**. Starting
    at any key, the Major scale follows the following pattern:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 对我们来说，有一个特别的音阶称为**大调音阶**。从任何键开始，大调音阶遵循以下模式：
- en: W W S W W W S
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: W W S W W W S
- en: where *W* stands for whole tone (jump of two keys) and *S* stands for semitones
    (jump of one key).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *W* 代表全音（两个键的跳跃）和 *S* 代表半音（一个键的跳跃）。
- en: For example, if you play the notes *C1*, *D1*, *E1*, *F1*, *G1*, *A1*, *B1*,
    *C2*, and back, one-by-one, you have played a *C* Major scale.  A Major scale
    sounds uplifting while another scale named minor can sound a bit sad. Don't worry
    about names—there are hundreds of scales and we just need to know that scales
    are a *sequence* of notes played together following a certain set of rules.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你依次演奏音符 *C1*、*D1*、*E1*、*F1*、*G1*、*A1*、*B1*、*C2*，然后再返回，你就演奏了一个 *C* 大调。大调听起来让人振奋，而另一个名为小调的音阶听起来可能有点悲伤。不用担心名称——有成百上千种音阶，我们只需要知道音阶是一系列按照一定规则一起演奏的音符的
    *序列*。
- en: Learning about chords
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习和弦
- en: In contrast, a **chord** is when you play two or more notes simultaneously.
    For example, if I play three notes C, F, and G altogether; it's a chord. Chords
    generally provide the bass section to a music.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，**和弦**是指同时演奏两个或更多音符。例如，如果我同时演奏三个音符C、F和G；那就是一个和弦。和弦通常为音乐提供低音部分。
- en: If you keep playing the same chord over and over again it will sound monotonous—so
    you jump from one chord—again following a rule. This is called **chord progression**.
     More simply, an ordered series of chords is called a chord progression.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你一遍又一遍地弹奏同一个和弦，它听起来会单调乏味——所以你会从一个和弦跳到另一个和弦——再次遵循一个规则。这被称为**和弦进行**。更简单地说，一系列有序的和弦被称为和弦进行。
- en: 'The musical notes can be written on a music sheet or **score sheet** that comprises
    of five lines. The notes are represented by black dots, which can lie on the line
    or in spaces between them. The names of notes for two octaves are shown on the
    following score sheet. The icon marked as **treble clef** means that these notes
    are to be played with the right hand:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 音乐符号可以写在乐谱或**五线谱**上，它由五条线组成。音符由黑色圆点表示，这些圆点可以位于线上或它们之间的空白处。以下五线谱上显示了两个八度音符的名称。标记为**高音谱号**的图标表示这些音符应由右手演奏：
- en: '![](img/9a5ed504-bde0-4eb3-bcc6-b4a04fd934f0.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9a5ed504-bde0-4eb3-bcc6-b4a04fd934f0.png)'
- en: Do not worry, we are not required to memorize the music notation for completing
    our program. We will, however, use it as a reference when drawing the score sheet.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 不要担心，我们完成项目时不需要记住音乐符号。然而，我们在绘制乐谱时将会将其作为参考。
- en: We are now equipped with all the musical knowledge required to write this program.
    Let's start coding.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经拥有了编写这个程序所需的所有音乐知识。让我们开始编码。
- en: Building the broad GUI structure
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建广泛的GUI结构
- en: 'We start as usual by building the root window (`7.01/view.py`):'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们像往常一样从构建根窗口开始（`7.01/view.py`）：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We also create a new file named `constants.py`( `7.01`), which currently holds
    the height parameters for the window.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还创建了一个名为 `constants.py`（`7.01`）的新文件，该文件目前包含窗口的高度参数。
- en: We use two root window methods,  `root.winfo_screenwidth()`and `root_winfo_screenheight()`,
    to obtain the screen width and height, respectively. We define two constants,  `WINDOW_WIDTH`
    and `WINDOW_HEIGHT`, and then place the window on the *x*, *y* center of the computer
    screen.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用两种根窗口方法，`root.winfo_screenwidth()` 和 `root_winfo_screenheight()`，分别获取屏幕的宽度和高度。我们定义了两个常量，`WINDOW_WIDTH`
    和 `WINDOW_HEIGHT`，然后将窗口放置在计算机屏幕的 *x*，*y* 中心。
- en: Notice the line `root.resizable(False, False)`. This root window method takes
    two Boolean arguments to decide if the window is resizable in the *x* and *y*
    directions.  Setting both arguments to `False` makes our window fixed in size.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到这一行代码 `root.resizable(False, False)`。这个 `root` 窗口方法接受两个布尔参数来决定窗口是否在 *x* 和
    *y* 方向上可调整大小。将这两个参数都设置为 `False` 使得我们的窗口大小固定。
- en: The root window is then passed as an argument to a new class, `PianoTutor`,
    which takes care of building the internals of the program. This class is defined
    next.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 根窗口随后被传递给一个新的类，`PianoTutor`，该类负责构建程序的内部结构。这个类将在下面定义。
- en: 'The GUI for this program is divided into four broad rows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序的图形用户界面分为四个主要行：
- en: '![](img/8d23c407-3e73-430e-980a-d45939106434.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8d23c407-3e73-430e-980a-d45939106434.png)'
- en: The topmost row is built in a `Frame` named `mode_selector_frame` and has a
    `combobox` that lets the user select from one of three options—scales, chords, and
    chord progressions.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 最顶行是在名为 `mode_selector_frame` 的 `Frame` 中构建的，并包含一个 `combobox`，允许用户从三个选项中选择一个——音阶、和弦以及和弦进行。
- en: The second row is a placeholder for placing the music score sheet and is accordingly
    called the `score_sheet_frame.`
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行是放置乐谱的占位符，因此被称为`score_sheet_frame`。
- en: The third row requires a bit of attention. Depending on what is selected in
    the topmost `combobox`, the contents of this row change.  In our code so far,
    (`7.01/view.py`*)*, it displays three different colored frames for the three different
    choices one can make using the topmost `combobox`. Since we will place controls
    on this frame, we decided to call it a `controls_frame` for want of a better name.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 第三行需要一点注意。根据在顶部`combobox`中选择的选项，这一行的内容会发生变化。在我们目前的代码中（`7.01/view.py`*），它显示三个不同颜色的框架，对应于使用顶部`combobox`可以做出的三种不同选择。由于我们将在这一框架上放置控件，我们决定将其称为`controls_frame`，因为没有更好的名字。
- en: The fourth row shows the piano keyboard and the frame is named `keyboard_frame`,
    the implementation of which will be discussed in the section entitled *Making
    the Piano Keyboard*.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 第四行显示了钢琴键盘，框架被命名为 `keyboard_frame`，其实现将在标题为 *制作钢琴键盘* 的章节中进行讨论。
- en: Putting up the skeleton structure
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建立骨架结构
- en: 'To start, we build a class `PianoTutor` (`7.01/view.py`), the `__init__` method
    of which is defined as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个名为 `PianoTutor` 的类（`7.01/view.py`），其 `__init__` 方法定义如下：
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding code, we are simply defining method calls to build multiple
    Frame widgets of predefined heights.  We won't elaborate much upon the preceding
    code as we wrote similar code in all of the previous chapters.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们只是简单地定义了方法调用，以构建多个具有预定义高度的 Frame 小部件。由于我们在前几章中已经编写了类似的代码，因此我们不会对前面的代码进行过多解释。
- en: 'Let''s look at one example of frame creation. All other frames follow a similar
    pattern (`7.01 /view.py`) and will not be discussed here:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下创建框架的一个示例。所有其他框架都遵循类似的模式（`7.01 /view.py`）并且在此处不会进行讨论：
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is simple `Frame` creation using the `grid` geometry manager. However,
    take a note of the line `self.score_sheet_frame.grid_propagate(False)`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过`grid`布局管理器创建简单`Frame`的过程。然而，请注意这一行`self.score_sheet_frame.grid_propagate(False)`。
- en: In Tkinter, the container window (Frame in the previous example) is designed
    to *shrink to fit* around its contents.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在Tkinter中，容器窗口（前一个示例中的Frame）被设计为*自动调整大小以适应*其内容。
- en: Even though we have explicitly added a  width or height to the frame, if we
    comment the `grid_propagate(false)` line, you will notice that the width and height
    parameters given by us are simply ignored and the frame will shrink to exactly
    fit its children—the Label widgets height in our case. We do not want to allow
    this shrinking of Frames and `grid_propagate(False)` lets us achieve that.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们明确地为框架添加了宽度或高度，如果我们注释掉`grid_propagate(false)`这一行，你会注意到我们提供的宽度和高度参数被简单地忽略，框架将缩小以恰好适应其子元素——在我们的例子中是标签小部件的高度。我们不希望允许框架缩小，而`grid_propagate(False)`则让我们实现了这一点。
- en: If we were using pack manager, we would have used `frame.pack_propagate(False)` instead
    to achieve the same result.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用包管理器，我们会使用 `frame.pack_propagate(False)` 来达到相同的效果。
- en: 'Next, our topmost mode selector `combobox` is bound to the following callback (`7.01/view.py`):'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们最顶层的模式选择器 `combobox` 绑定到以下回调函数（`7.01/view.py`）：
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here''s how we define the `on_mode_changed` method (`7.01/view.py`):'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们定义`on_mode_changed`方法的方式（`7.01/view.py`）：
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Take a note of the `grid_remove()` method mentioned previously. This method
    removes the widget from the grid manager, thereby making it invisible. You can
    make it visible again by using `grid()` on it. So effectively, whenever a user
    selects one of the three options (`Scales`, `Chords`, and `Chord Progression`)
    from the topmost `combobox`, the other two frames are hidden using `grid_remove`
    and the frame for the selected option is made visible using `grid.`
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 记下之前提到的 `grid_remove()` 方法。此方法将从网格管理器中移除小部件，从而使其不可见。您可以通过对其使用 `grid()` 来再次使其可见。因此，每当用户从最顶部的
    `combobox` 中选择三个选项之一（`Scales`、`Chords` 和 `Chord Progression`）时，其他两个框架将使用 `grid_remove`
    隐藏，而所选选项的框架将使用 `grid` 显示出来。
- en: This completes the first iteration where we defined the broad GUI structure
    with the capability to switch between scales, chords, and chord progression frames
    based on choices made in the topmost combobox.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了第一次迭代，我们在其中定义了具有根据顶部组合框中的选择在音阶、和弦和弦进行框架之间切换能力的广泛GUI结构。
- en: Making the piano keyboard
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制作钢琴键盘
- en: Let's now build the piano keyboard. All keys on the keyboard will be made using
    the Label widget. We will superimpose the label widget with an image of black
    and white keys using Tkinter's `PhotoImage` class.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在构建钢琴键盘。键盘上的所有键都将使用标签小部件（Label widget）制作。我们将使用Tkinter的`PhotoImage`类将标签小部件与黑白键的图像叠加。
- en: The `PhotoImage` class is used to display images in label, text, button, and
    canvas widgets. We used it in [Chapter 2](41f1fda5-b3b1-4dfa-8971-2a016274d39a.xhtml),* Making
    a Text Editor* to add icons to buttons.  Since this class can only handle `.gif`
    or `.bpm` format images, we add four `.gif` images to a folder named `pictures`.
    These four images are `black_key.gif`, `white_key.gif`, ` black_key_pressed.gif`,
    and `white_key_pressed.gif`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`PhotoImage` 类用于在标签、文本、按钮和画布小部件中显示图像。我们在[第2章](41f1fda5-b3b1-4dfa-8971-2a016274d39a.xhtml)，“制作文本编辑器”中使用了它来为按钮添加图标。由于这个类只能处理
    `.gif` 或 `.bpm` 格式的图像，我们在名为 `pictures` 的文件夹中添加了四个 `.gif` 图像。这四个图像分别是 `black_key.gif`、`white_key.gif`、`black_key_pressed.gif`
    和 `white_key_pressed.gif`。'
- en: 'Since we will refer to these images over and over again,  we add their reference
    to `7.02` `constants.py`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将反复引用这些图像，我们将其引用添加到`7.02` `constants.py`文件中：
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The symbol `../`  used previously is a way to specify a file path relative to
    the current working directory. A single `../` means—go back one directory, a set
    of two `../../` means go back two directories, and so on.  This system is generally
    honored by most modern operating systems. However, some very old operating systems
    might not support it. So a better but a more verbose way is to use the `os` module
    of Python to traverse directories.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 之前使用的符号 `../` 是一种指定相对于当前工作目录的文件路径的方法。单个 `../` 表示退回一个目录，一对两个 `../../` 表示退回两个目录，以此类推。这个系统通常被大多数现代操作系统所支持。然而，一些非常古老的操作系统可能不支持它。因此，一个更好但更啰嗦的方法是使用
    Python 的 `os` 模块来遍历目录。
- en: 'Next, we will define a method named `create_key` that creates a piano key for
    us at a given `x` location:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将定义一个名为 `create_key` 的方法，该方法在给定的 `x` 位置为我们创建一个钢琴键：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here''s a brief code description:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个简短的代码描述：
- en: Note that since we want to place keys at a specific x coordinate we use the
    `place` geometry manager.  We briefly touched upon the place geometry manager
    in [Chapter 1](39a58f50-293e-4ff5-9b65-0d9e0c0cc15e.xhtml),* Meet Tkinter*. Now
    is a good place to see this rarely used geometry in action.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意，由于我们希望将键放置在特定的 x 坐标上，我们使用了 `place` 几何管理器。我们曾在 [第 1 章](39a58f50-293e-4ff5-9b65-0d9e0c0cc15e.xhtml)，*认识
    Tkinter* 中简要介绍了 place 几何管理器。现在是一个很好的时机来观察这个很少使用的几何管理器在实际中的应用。
- en: This method also takes an image location as its input and creates a `PhotoImage`
    class, which is then attached to the label widget using the `image=key_image`
    option in the previous example.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此方法也接受一个图像位置作为其输入，并创建一个`PhotoImage`类，然后使用前一个示例中的`image=key_image`选项将该类附加到标签小部件上。
- en: A third parameter, `key_name`, is attached to the created label widget by using
    the command `widget.name = key_name`. This is needed to later identify which particular
    key was pressed. For example, to create the first key *C1*, we attach the name
    *C1* to the label widget and then later this string value can be accessed by calling
    `widget.name`
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个参数，`key_name`，通过使用命令`widget.name = key_name`附加到创建的标签小部件上。这需要在以后识别哪个特定的键被按下。例如，为了创建第一个键*C1*，我们将名称*C1*附加到标签小部件上，然后以后可以通过调用`widget.name`来访问这个字符串值。
- en: We bind the label to two events, `'<Button-1>'` and `'<ButtonRelease-1>'`, to
    handle mouse press events.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将标签绑定到两个事件，`'<Button-1>'` 和 `'<ButtonRelease-1>'`，以处理鼠标按下事件。
- en: Finally, we add a reference to the newly created widget into an attribute newly
    defined here as `self.keys`. We keep this reference as we will need to change
    the image of these widgets to highlight the keys.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们将对新创建的小部件的引用添加到此处新定义的属性`self.keys`中。我们保留这个引用，因为我们还需要更改这些小部件的图片以突出显示键。
- en: 'Now that we have attached events to two callbacks, let''s define them next:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将事件附加到两个回调函数上了，接下来让我们定义它们：
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'For now, the previous methods print the name of the key pressed and then call
    another two methods that change the image of the pressed label to a different
    colored image on button press and release:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，之前的方法会在按下键后打印按键名称，然后调用另外两个方法，在按键按下和释放时将按下标签的图像更改为不同颜色的图像：
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The white key widget will have a name of length `2` (for example, `C1`, `D2`,
    `G1`), while a black key will have an image length of `3` (for example, `C#1`,
    `D#1`). We utilize this fact to decide if to use a black key image or a white
    key image. The rest of the preceding code should be self-explanatory.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 白键小部件将有一个长度为`2`的名称（例如，`C1`，`D2`，`G1`），而黑键将有一个长度为`3`的图像（例如，`C#1`，`D#1`）。我们利用这一事实来决定是否使用黑键图像或白键图像。前述代码的其余部分应该是不言自明的。
- en: Putting the keyboard together
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组装键盘
- en: Now it's finally time to combine all the preceding methods to build our complete
    keyboard of two octaves.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在终于到了将所有前面的方法结合起来构建我们完整的八度键盘的时候了。
- en: 'We begin by defining the exact `x_coordinates` for all the keys from *C1* to
    *B2* in the file `constants.py` as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在文件 `constants.py` 中定义了从 *C1* 到 *B2* 所有键的精确 `x_coordinates` 如下：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The preceding *x* coordinate numbers have been obtained simply by trial and
    error as to emulate their location on a keyboard.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的 *x* 坐标数值是通过简单的试错法获得的，以模拟它们在键盘上的位置。
- en: 'Then we modify the previously defined `build_keyboard_frame` method as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将之前定义的 `build_keyboard_frame` 方法修改如下：
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The first three lines of the previous method remain as defined in the previous
    iteration. We then go through all white and black keys creating labels for them
    at given *x* coordinates.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 前一种方法的头三行保持与上一次迭代中定义的状态不变。然后我们遍历所有白键和黑键，在给定的 *x* 坐标处为它们创建标签。
- en: 'That concludes the iteration. If you now run  `7.02 view.py`, you should see
    a two-octave keyboard. When you press any key, the key''s image should change
    to blue and it should print the name of the key pressed or released in the Terminal:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了迭代。如果你现在运行 `7.02 view.py`，你应该看到一个八度键盘。当你按下任何键时，该键的图像应该变为蓝色，并且应该在终端中打印出按下的或释放的键的名称：
- en: '![](img/bf3fe252-9b41-4da9-b598-395ba3097f6e.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bf3fe252-9b41-4da9-b598-395ba3097f6e.png)'
- en: Playing audio
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 播放音频
- en: To begin with, we have added 24 sound samples in `.wav` format in a folder named
    `sounds` in this chapter's code folder. These audio files correspond to the 24
    notes on our keyboard. The audio files are named according to the note name it
    represents.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在本章代码文件夹中名为 `sounds` 的文件夹中添加了24个 `.wav` 格式的声音样本。这些音频文件对应于我们键盘上的24个音符。音频文件按照其代表的音符名称命名。
- en: 'In order to keep the audio processing separate from the GUI code, we create
    a new file called `audio.py` (`7.03`).The code is defined as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将音频处理与GUI代码分离，我们创建了一个名为`audio.py`的新文件（`7.03`）。代码定义如下：
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The code description is as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 代码描述如下：
- en: The `play_note` method follows the API provided by `simpleaudio` to play an
    audio file
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`play_note` 方法遵循 `simpleaudio` 提供的 API 来播放音频文件'
- en: The `play_scale` method takes in a list of notes and plays them sequentially,
    giving a time gap between each played note
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`play_scale` 方法接收一个音符列表并按顺序播放它们，在每播放一个音符之间留有时间间隔'
- en: The `play_chord` method takes a list of notes and plays them all together
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`play_chord` 方法接受一个音符列表并一起播放这些音符'
- en: The last two methods call these methods in new threads as we don't want to block
    the main GUI thread when playing these notes
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后两种方法在新线程中调用这些方法，因为我们不想在播放这些音符时阻塞主GUI线程。
- en: 'Next, let''s import this file (`7.03` `view.py`):'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们导入这个文件（`7.03` `view.py`）：
- en: '[PRE14]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, modify the `on_key_pressed` method to play the given note:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，修改`on_key_pressed`方法以播放指定的音符：
- en: '[PRE15]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This concludes the iteration. If you now run the code and press any key on the
    keyboard, it should play the note for that key.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了迭代。如果你现在运行代码并按键盘上的任意键，它应该会播放那个键的音符。
- en: Next, we start with building the actual tutor. The next three sections will
    develop the scales, chords, and chord progression sections.  We will start by
    building the scales tutor.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们开始构建实际的辅导工具。接下来的三个部分将开发音阶、和弦和弦进行部分。我们将从构建音阶辅导工具开始。
- en: Building the scales tutor
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建音阶辅导师
- en: 'All the rules for defining which notes to play for a given scale are added
    in a JSON file named `scales.json` within a folder named `json`. Let''s take a
    look at the first few lines in the `scales.json` file:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 定义给定音阶应演奏哪些音符的所有规则都添加在一个名为 `scales.json` 的 JSON 文件中，该文件位于名为 `json` 的文件夹内。让我们来看看
    `scales.json` 文件的前几行：
- en: '[PRE16]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Recall that a scale is a set of notes played sequentially. The first note of
    the scale is called its **root** or **key**. So if you play a scale starting at
    say the note *B*, you are playing the scale in the key of *B*.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，音阶是一系列依次演奏的音符。音阶的第一个音符被称为其**根音**或**调性**。所以，如果你从一个音符，比如说音符*B*开始演奏音阶，你就是在*B*调上演奏音阶。
- en: Let's take the fourth item in the key-value pairs. The key is named `"Melodic
    minor"` and its associated value is `[ 0, 2, 3, 5, 7, 9, 11 ]`. This means that,
    to play a melodic minor scale in the key of *B*, you will take *B* as the first
    item—that is represented by `0` in the values list. The next key is two semitones
    above *B*, the third key is three semitones above *B*, and the next is 5, followed
    by 7, 9, and 11 semitones above *B*.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下键值对中的第四项。键名为 `"Melodic minor"`，其关联的值为 `[ 0, 2, 3, 5, 7, 9, 11 ]`。这意味着，要在
    *B* 音上演奏旋律小调音阶，你需要将 *B* 作为第一个音项——在值列表中由 `0` 表示。下一个键比 *B* 高两个半音，第三个键比 *B* 高三个半音，接下来是
    5，然后是 7，9，最后是比 *B* 高 11 个半音。
- en: 'So to summarize—in order to play Melodic minor in the key of *B* you will play
    the following keys:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 所以总结一下——为了在B调上演奏旋律小调，你需要按下以下键位：
- en: '[PRE17]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Where the preceding numbers represent semitones.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的数字代表半音。
- en: 'So our task is—given a scale and the key for the scale, our program should
    highlight the keys and play it out:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的任务是——给定一个音阶及其键，我们的程序应该突出显示这些键并播放它们：
- en: '![](img/48044a81-d04b-4b28-9354-e0c273aa23b0.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/48044a81-d04b-4b28-9354-e0c273aa23b0.png)'
- en: The first thing is to build two `combobox` for the scale and keys as shown previously.
    This should be easy for you as we have built `combobox` several times in the previous
    chapters.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 首先需要构建两个`combobox`，一个用于缩放，另一个用于键，正如之前所示。这对您来说应该很容易，因为我们之前章节中已经构建过`combobox`多次。
- en: The second step involves reading the JSON file into our program.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步涉及将 JSON 文件读入我们的程序中。
- en: 'Quoting from json.org ([http://json.org/](http://json.org/)):'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '引用自 json.org ([http://json.org/](http://json.org/)):'
- en: JSON (JavaScript Object Notation) is a lightweight data-interchange format.
    It is easy for humans to read and write. It is easy for machines to parse and
    generate. These are universal data structures. Virtually all modern programming
    languages support them in one form or another. It makes sense that a data format
    that is interchangeable with programming languages is also be based on these structures.
    Read more about JSON at [https://www.json.org](https://www.json.org).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: JSON（JavaScript对象表示法）是一种轻量级的数据交换格式。它易于人类阅读和编写。它也易于机器解析和生成。这些是通用的数据结构。几乎所有的现代编程语言都以某种形式支持它们。一个可以与编程语言交换的数据格式也基于这些结构是有意义的。更多关于JSON的信息请参阅[https://www.json.org](https://www.json.org)。
- en: Python implements a standard module for reading and writing JSON data too. The
    module is rightfully called `json`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Python 实现了一个用于读取和写入 JSON 数据的标准模块，该模块名称恰当地被称为 `json`。
- en: 'We first import the built-in `json` module in our namespace:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在我们的命名空间中导入内置的`json`模块：
- en: '[PRE18]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We next add a new method, `self.load_json_files()`, and call it from the class
    `__init__` method:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来添加一个新的方法，`self.load_json_files()`，并在类的`__init__`方法中调用它：
- en: '[PRE19]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `SCALES_JSON_FILE` path is defined in the file `constants.py`*.* This loads
    up the scales data as a dictionary in the `self.scales` attribute:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`SCALES_JSON_FILE` 路径在文件 `constants.py` 中定义*。*这会将刻度数据作为字典加载到 `self.scales`
    属性中：'
- en: You can read JSON files by using the `json.load` command. You can write to a
    JSON file by using the `json.dump` command. However, `json.load` methods do not preserve
    key order from a parsed JSON document. That is to say, `json.load` jumbles up
    the order of the keys. We do not want to jumble up the order of the keys and want
    them to appear in the order they are mentioned in the file. We therefore use the
    `OrderedDict` class from the `collections` module to preserve the key order.  This
    is achieved by passing the second argument as `object_pairs_hook=OrderedDict`. An `OrderedDict` is
    a Python dictionary object that remembers the order that keys were first inserted.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`json.load`命令读取JSON文件。您可以使用`json.dump`命令写入JSON文件。然而，`json.load`方法不会保留解析的JSON文档中的键顺序。也就是说，`json.load`打乱了键的顺序。我们不希望打乱键的顺序，并希望它们按照在文件中提到的顺序出现。因此，我们使用`collections`模块中的`OrderedDict`类来保留键顺序。这是通过将第二个参数传递为`object_pairs_hook=OrderedDict`来实现的。`OrderedDict`是一个Python字典对象，它记得键首次插入的顺序。
- en: 'Now that we have the scales data available as the `self.scales` dictionary,
    our next task is to figure out the keys to highlight. We start by creating a new
    attribute in the class `__init__` method:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了`scales`数据作为字典`self.scales`可用，我们的下一个任务是确定要突出的键。我们首先在类的`__init__`方法中创建一个新的属性：
- en: '[PRE20]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Next, we define methods to highlight a key and another method to highlight
    a list of keys:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义了用于突出显示一个关键点的方法，以及用于突出显示一系列关键点的方法：
- en: '[PRE21]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The preceding code is similar to the previous code we wrote to highlight a
    key when it is pressed. Next, we also need methods to remove existing highlights:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码与之前我们编写的用于在按键时突出显示关键内容的代码类似。接下来，我们还需要方法来移除现有的突出显示：
- en: '[PRE22]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The logic here is exactly similar to the one we applied for highlighting keys.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的逻辑与我们所应用的用于突出显示键的逻辑完全相同。
- en: 'Now that we have methods to highlight and remove highlights from keys, let''s
    define the callbacks attached to the two combobox for scale and key selection:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了高亮和移除键高亮的方法，让我们定义两个组合框（用于缩放和键选择）所附加的回调函数：
- en: '[PRE23]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Lastly, here is the logic to select which keys to highlight. Furthermore, once
    we have the list of keys to be highlighted, we pass it to the previously defined
    `play_scale_in_new_thread` method that plays the actual sound for the scale:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这是选择哪些键要高亮的逻辑。此外，一旦我们有了要高亮的键列表，我们就将其传递给之前定义的`play_scale_in_new_thread`方法，该方法播放实际的音阶声音：
- en: '[PRE24]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Do notice the highlighted part of the code.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意代码中高亮的部分。
- en: So given the index of the selected key, we simply add all items in the list
    of selected scale to obtain the list of keys to be highlighted.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，给定所选键的索引，我们只需将所选比例列表中的所有项相加，即可获得要突出显示的键列表。
- en: We also want to call this method as soon as the program runs. So we add a call
    to `self.find_scale()` right in our `__init__` method. That ensures that we are
    greeted by playing of *C* Major scale (the default selection in `combobox`) as
    soon as the program runs.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也希望程序运行时立即调用这个方法。因此，我们在`__init__`方法中直接添加了对`self.find_scale()`的调用。这确保了程序运行后，我们会被演奏的**C大调音阶**（`combobox`中的默认选择）所迎接。
- en: This concludes the iteration. Now if you go and run `7.04 view.py` and select
    the appropriate scale and key name, the keyboard will highlight the keys and also
    play it out for you.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了迭代。现在如果你去运行 `7.04 view.py` 并选择合适的比例和键名，键盘将会高亮显示这些键，并且为你播放出来。
- en: Building the chord finder section
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建和弦查找部分
- en: 'Now that we have had a glimpse of working with *JSON* files, this should be
    easy. Let''s take a look at the first few lines of the `chords.json` file from
    the `json` directory:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对处理 *JSON* 文件有了一定的了解，这应该很容易。让我们来看看 `json` 目录下 `chords.json` 文件的头几行：
- en: '[PRE25]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This is very similar to the scales structure. Let''s say we want to figure
    out what the *C*# major chord would look like. So we start with the *C*# key,
    which is `0`. Then we look at the list of major chords, which read: `[0, 4, 7]`.
    So starting at *C*# the next key to highlight is `4` semitones above and the next
    is `7` semitones above *C*#. So the final chord structure for the C# major chord
    would be:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这与音阶结构非常相似。假设我们想要了解C#大和弦的形态。所以我们从C#键开始，它是`0`。然后我们查看大和弦的列表，它读作：`[0, 4, 7]`。所以从C#开始，下一个需要突出的键是比它高4个半音的`4`，下一个是比C#高7个半音的键。因此，C#大和弦的最终和弦结构将是：
- en: '[PRE26]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The GUI is also very similar to the scales section:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 界面（GUI）也非常类似于刻度（scales）部分：
- en: '![](img/9c7f7ed7-1884-4546-8152-6df9af62fcfb.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9c7f7ed7-1884-4546-8152-6df9af62fcfb.png)'
- en: 'We begin by adding a constant for the path to the `chords.json` file in  `7.05
    constants.py`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在`7.05 constants.py`文件中为`chords.json`文件路径添加一个常数：
- en: '[PRE27]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Next, we read the contents of this file in a new class attribute, `self.chords`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在新的类属性中读取这个文件的内容，`self.chords`：
- en: '[PRE28]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We then modify the chords frame GUI to add two `combobox` (see the complete
    GUI in `7.05 view.py` `build_chords_frame`):'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后修改和弦框架GUI以添加两个`combobox`（参见`7.05 view.py`中的完整GUI `build_chords_frame`）：
- en: '[PRE29]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, we added the two event callbacks defined previously:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们添加了之前定义的两个事件回调：
- en: '[PRE30]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `find_chord` method queries the `self.chords` dict for the keys to be highlighted,
    adds the key offsets from the root note, and calls it to be highlighted and played:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`find_chord` 方法查询 `self.chords` 字典以获取要高亮显示的键，将根音符的键偏移量添加到其中，并调用它进行高亮显示和播放：'
- en: '[PRE31]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The final code in this iteration modifies the `on_mode_changed` method to highlight
    the chord as soon as the chord mode is selected:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 本迭代中的最终代码修改了`on_mode_changed`方法，以便在选择和弦模式时立即突出显示和弦：
- en: '[PRE32]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: That concludes the iteration. If you now run `7.05 view.py`, you will find a
    functional chords section that lets us find chords of different varieties in different
    scales.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了迭代。如果你现在运行 `7.05 view.py`，你会找到一个功能性的和弦部分，它让我们能够在不同的音阶中找到不同种类的和弦。
- en: Building the chord progression tutor
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建和弦进行教程
- en: 'The GUI component of the chord progression section is slightly more evolved
    than the previous two sections. Here''s how a typical chord progression GUI looks
    like:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 和弦进行部分的GUI组件比前两个部分稍微进化一些。下面是一个典型的和弦进行GUI的样貌：
- en: '![](img/5400163b-8525-4fd4-befe-42f9b4bc53c0.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5400163b-8525-4fd4-befe-42f9b4bc53c0.png)'
- en: Notice that this section has the combobox as opposed to two for the earlier
    sections.  Depending on what progression is chosen in the middle combobox, we
    need to draw a number of buttons, each button representing one chord in the complete
    chord progression.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，本节使用的是组合框，而前几节使用的是两个。根据中间组合框中选择的进度，我们需要绘制一定数量的按钮，每个按钮代表完整和弦进行中的一个和弦。
- en: In the preceding screenshot, note that the progression combobox has a value
    of I-V-vi-IV. This is a total of four roman numbers separated by a dash. This
    means that this chord progression is made up of four chords. Also notice that
    a few of the roman numbers (I, V, IV, and so on) are written in capital letters
    and others (vi) are written in small letters.  All capital letters in the series
    denote major chords, while each small letter represents a minor chord.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图里，请注意进度组合框的值为 I-V-vi-IV。这代表四个用连字符分隔的罗马数字。这意味着这个和弦进行由四个和弦组成。同时，注意其中一些罗马数字（I、V、IV等）是大写字母，而另一些（vi）是小写字母。系列中的所有大写字母表示大和弦，而每个小写字母代表小和弦。
- en: 'Next, let us take a look at the `progressions.json` file from the `json` folder:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看一下来自`json`文件夹的`progressions.json`文件：
- en: '[PRE33]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As a first observation, the chord progressions are broadly of two types—major
    and minor. Each type has a list of chord progressions, which is identified by
    a set of roman numerals.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，和弦进行大致分为两种类型——大调和小调。每种类型都有一系列和弦进行，这些和弦进行通过一组罗马数字来标识。
- en: Let's see an example of how this would work.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个例子，看看这是如何工作的。
- en: 'Say we want to display the major chord progression `ii-V-I` in the key of *C*,
    as shown in the following screenshot:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要在*C*调中显示主要和弦进行`ii-V-I`，如下截图所示：
- en: '![](img/fde4c1fc-e1fe-48e0-b565-efbcff470290.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fde4c1fc-e1fe-48e0-b565-efbcff470290.png)'
- en: 'The JSON file lists the progression under the Major section as:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: JSON文件在“主要”部分列出的进度如下：
- en: '[PRE34]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Let''s first lay down the 12 notes in a table starting at the key of the chord
    progression (C in our example). We need to pick up the 2^(nd),  7^(th), and  0^(th)
    keys for this progression:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先在表中列出和弦进行中的12个音符，从和弦的根音开始（以我们的例子中的C音为例）。我们需要为这个进行选择2^(nd)，7^(th)，和0^(th)的音符：
- en: '| **0** | 1 | **2** | 3 | 4 | 5 | 6 | **7** | 8 | 9 | 10 | 11 |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
- en: '| **C** | C# | **D** | D# | E | F | F# | **G** | G# | A | A# | B |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| **C** | C# | **D** | D# | E | F | F# | **G** | G# | A | A# | B |'
- en: The keys are D(2^(nd)), G(7^(th)), and C(0^(th)). With the keys in hand—we next
    need to identify if each of the keys plays a major or minor chord. This is simple.
    Those roman numbers written in lower case play a minor chord, while those written
    in capitals play a major chord.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 关键音符是D(第2个), G(第7个), 和C(第0个)。手握这些音符后——我们接下来需要确定每个音符是构成大和弦还是小和弦。这很简单。那些用小写罗马数字标注的音符构成小和弦，而那些用大写罗马数字标注的音符构成大和弦。
- en: 'Given this rule, our final chords in the chord progression in the key of *C*
    are:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这个规则，我们在 *C* 调的和弦进行中的最终和弦是：
- en: D Minor - G Major - C Major
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: D小调 - G大调 - C大调
- en: Having identified these, our program should dynamically create three buttons.
    Clicking on these buttons should then play the preceding three chords, respectively.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 确定这些之后，我们的程序应该动态创建三个按钮。点击这些按钮后，应该分别播放前面的三个和弦。
- en: 'Let''s code this feature. We begin by defining the location of the chords progression
    file in `7.06 constants.py`:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写这个功能。我们首先在`7.06 constants.py`中定义和弦进行文件的位置：
- en: '[PRE35]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We then load it from the method `load_json_files()` into an attribute named
    `self.progressions`:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后从方法 `load_json_files()` 中将其加载到一个名为 `self.progressions` 的属性中：
- en: '[PRE36]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Next, we modify the progression frame to add three `combobox` elements. See
    the `build_progressions_frame`  code `7.06 view.py`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们修改进度框架以添加三个`combobox`元素。请参阅`build_progressions_frame`的代码`7.06 view.py`。
- en: 'The three combobox are attached to the following three callbacks:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个组合框连接到以下三个回调函数：
- en: '[PRE37]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The most complex of the three combobox is the progression scale combobox. It
    lets you choose between *Major* and *Minor* progression scales. Depending on the
    choice you make there,  it populates the second combobox with the progression
    values from the JSON file. This is what the first four lines of the `on_progression_scale_changed`
    method do.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 三种组合框中最复杂的是进度尺度组合框。它允许你选择**主调**和**副调**进度尺度。根据你的选择，它将从JSON文件中填充第二个组合框的进度值。这正是`on_progression_scale_changed`方法的前四行所做的事情。
- en: 'Other than that, all three preceding callback methods defined make a call to
    the `show_progression_buttons` method, which is defined as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 除了那个之外，前面定义的所有三个回调方法都会调用`show_progression_buttons`方法，该方法定义如下：
- en: '[PRE38]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The preceding code dynamically creates buttons—one for each chord in the chord
    progression and stores all the buttons in a list named `self.progression_buttons`.
     We will keep this reference because we will have to destroy the buttons and create
    fresh ones every time a new chord progression is selected.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码动态创建按钮——每个和弦进行一个按钮，并将所有按钮存储在一个名为 `self.progression_buttons` 的列表中。我们将保留这个引用，因为每次选择新的和弦进行时，我们都需要销毁这些按钮并创建新的按钮。
- en: Note the use of the `partial` method from the `functools` module to define the
    button command callbacks. Since the buttons are being created dynamically, we
    need to keep track of the button number. We use this handy method `partials` that
    lets us call a method with only a partial number of arguments. Quoting from Python's
    documentation - The `partial()` function is used for partial function application,
    which *freezes* some portion of a function's arguments and/or keywords resulting
    in a new object with a simplified signature. You can read more about partials
    at [https://docs.python.org/3/library/functools.html#functools.partial](https://docs.python.org/3/library/functools.html#functools.partial).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用来自`functools`模块的`partial`方法来定义按钮命令回调。由于按钮是动态创建的，我们需要跟踪按钮编号。我们使用这个方便的`partials`方法，它允许我们只使用部分参数调用一个方法。引用Python的文档——`partial()`函数用于部分函数应用，它将函数的部分参数和/或关键字*冻结*，从而生成一个具有简化签名的新的对象。您可以在[https://docs.python.org/3/library/functools.html#functools.partial](https://docs.python.org/3/library/functools.html#functools.partial)了解更多关于部分函数应用的信息。
- en: 'The preceding code calls a `destroy_button` method whose task is to clear the
    frame for drawing the next set of buttons, in case a new progression is selected.
     The code is as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码调用了`destroy_button`方法，其任务是清除框架以便绘制下一组按钮，以防选择新的进度。代码如下：
- en: '[PRE39]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Finally, we want to display an individual chord from the chord progression
    when a button is clicked. This is defined as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们希望在点击按钮时显示和弦进行中的单个和弦。这被定义为如下：
- en: '[PRE40]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Here''s a brief description of the preceding code:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是对前面代码的简要描述：
- en: We first split the text, say `ii-V-I`, using the dash (`-`) delimiter. We then
    loop through the list and check if it is in uppercase or lowercase. If it is uppercase,
    the `selected_chord` variable is set to `Major`, if not it is set to `Minor`*.*
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们首先使用连字符（`-`）分隔符将文本拆分，例如`ii-V-I`。然后我们遍历列表并检查它是否为大写或小写。如果它是大写，则`selected_chord`变量被设置为`Major`，如果不是，则设置为`Minor`*.*
- en: The index of the keys is calculated by adding the key to the numbers mentioned
    in the JSON file. We apply modulo operator (`%`) to the added value to ensure
    that the value does not exceed the limits of 12 notes.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 键的索引是通过将键值与JSON文件中提到的数字相加来计算的。我们应用模运算符（`%`）到相加的值上，以确保该值不超过12个音符的限制。
- en: 'Since the numbers are stored as roman numerals (this is the convention used
    by musicians), we need to convert it to integers. We do that by defining a simple
    key-value mapping in `7.05/constants.py`:'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于数字是以罗马数字存储的（这是音乐家使用的惯例），我们需要将其转换为整数。我们通过在`7.05/constants.py`中定义一个简单的键值映射来实现这一点：
- en: '[PRE41]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Note that we have mapped all numbers starting at 0 and the mapping follows the
    Major scale pattern (`W W H W W S`), where `W` stands for whole tone (two keys
    jump) and `S` stands for semitone (one key jump).
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意，我们已经将所有从0开始的数字进行了映射，映射遵循大调式模式（`W W H W W S`），其中`W`代表全音（两个键跳跃）而`S`代表半音（一个键跳跃）。
- en: Now that we know that if the chord is a major or a minor, the rest of the code
    is exactly the same as we earlier used to identify the individual chords. We then
    highlight and play the individual chord.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在我们知道，如果和弦是大调或小调，其余的代码与我们之前用来识别单个和弦的代码完全相同。然后我们突出显示并演奏单个和弦。
- en: To end, we modify the `on_mode_changed`  to add a call to `show_progression_buttons()`
    so that every time we switch to the chord progression section, the first chord
    progression buttons are laid down for us.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将`on_mode_changed`进行修改，以添加对`show_progression_buttons()`的调用，这样每次我们切换到和弦进行部分时，第一个和弦进行按钮就会自动为我们设置。
- en: This completes the iteration. Our chord progression section is ready. Run code
    `7.06/view.py`. Inside the chord progression tutor, you can select the chord progression
    type (major or minor), the progression, and its key from the comboboxes and it
    will create one button for each of the chords in the chord progression. Press
    the individual buttons and it will play you the chords in that progression.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了迭代。我们的和弦进行部分已经准备好了。运行代码`7.06/view.py`。在和弦进行辅导程序中，你可以从下拉菜单中选择和弦进行类型（大调或小调）、进行方式和其键，程序将为和弦进行中的每个和弦创建一个按钮。按下单个按钮，它将为你播放该进行方式中的和弦。
- en: Building the score maker
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建得分生成器
- en: Let us now build the score maker. This will display whatever is played on the
    piano in music notation. For the sake of program modularity, we will build the
    program in a separate file named `score_maker.py`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在构建得分生成器。这个生成器将显示钢琴上演奏的任何音乐符号。为了程序的模块化，我们将把程序构建在一个名为 `score_maker.py` 的单独文件中。
- en: 'We start by defining a class `ScoreMaker`. Since we will be showing just two
    octaves of notes, we will define a constant `NOTES` listing all the notes (`7.06/score_maker.py`):'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '我们首先定义一个类 `ScoreMaker`。由于我们只展示两个八度的音符，我们将定义一个常量 `NOTES`，列出所有音符（`7.06/score_maker.py`）:'
- en: '[PRE42]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The `__init__` method of this class takes the container as an argument. This
    is the container on which this class will draw the score (`7.06/score_maker.py`):'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类的`__init__`方法接收容器作为参数。这是这个类将要绘制分数的容器（`7.06/score_maker.py`）：
- en: '[PRE43]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Note the use of `update_idletasks()` on the `container` frame. Calling this
    method here is necessary because we created a canvas in the previous line of code,
    which requires a redrawing of widgets. However, the redraw will only take place
    after the next run of the event loop. But we want to know the canvas width immediately after
    it was created. An explicit call to `update_idletasks` immediately carries out
    all pending events including geometry management. This ensures that we get the
    correct width of the canvas in the very next step. If you comment out the `update_idletasks`
    line and try to print the width of the canvas, it will print `1` even though we
    have explicitly set it to `500`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在`container`框架中使用`update_idletasks()`。在这里调用此方法是必要的，因为我们上一行代码中创建了一个画布，这需要重绘小部件。然而，重绘将在事件循环的下一轮运行后才会发生。但我们希望在画布创建后立即知道其宽度。显式调用`update_idletasks`会立即执行所有挂起的任务，包括几何管理。这确保我们在下一步中能够得到正确的画布宽度。如果你注释掉`update_idletasks`这一行并尝试打印画布的宽度，即使我们明确将其设置为`500`，它也会打印出`1`。
- en: We also initialize two `.gif` images that we will use to draw the score. The
    `treble_clef` image will be used to draw the treble clef to the left of the score,
    while the `sharp_image`  will draw a sharp (#) symbol prior to any sharp note
    (notes on the black keys).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还初始化了两个 `.gif` 图片，我们将使用它们来绘制分数。`treble_clef` 图片将被用来在分数左侧绘制高音谱号，而 `sharp_image`
    将在所有升音（黑键上的音符）之前绘制一个升号（#）符号。
- en: Tkinter uses the concept of event loop to handle all events. Here's an excellent
    article that explains the concept in depth [http://wiki.tcl.tk/1527](http://wiki.tcl.tk/1527).  `update_idletask` is
    an example of the method available on all widgets. Visit [http://effbot.org/tkinterbook/widget.htm](http://effbot.org/tkinterbook/widget.htm)
    to see a list of methods that are available to be called on all widgets.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter 使用事件循环的概念来处理所有事件。这里有一篇优秀的文章深入解释了这个概念 [http://wiki.tcl.tk/1527](http://wiki.tcl.tk/1527)。`update_idletask`
    是所有小部件上可用的方法的一个例子。访问 [http://effbot.org/tkinterbook/widget.htm](http://effbot.org/tkinterbook/widget.htm)
    查看所有小部件上可调用的方法列表。
- en: 'Our first task is to draw five equally spaced lines on the canvas. We accordingly
    define a new method to do that:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的首要任务是画五条等间距的线在画布上。因此，我们定义了一种新的方法来完成这个任务：
- en: '[PRE44]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This creates five parallel lines each 10 pixels apart. The underscore in the
    method name is an indication that this is to be treated as a private method of
    the class. While Python does not enforce method privacy, this tells the users
    not to use this method directly in their program.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了五个相互平行的线条，每条线之间相隔10像素。方法名称中的下划线表示这是一个类中的私有方法。虽然Python不强制执行方法隐私，但这告诉用户不要直接在他们的程序中使用此方法。
- en: 'Let''s then build a method that actually calls the previous method and adds
    a treble clef to the left, thereby creating an empty staff on which we can draw
    notes:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们构建一个方法，该方法实际上调用前一个方法并在左侧添加一个高音谱号，从而创建一个空谱表，我们可以在其上绘制音符：
- en: '[PRE45]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'At the outset, we need to differentiate between drawing a chord and drawing
    notes of the scale. Since all the notes of a chord are played together, the notes
    of a chord are drawn at a single *x* location. In contrast, the notes in a scale
    are drawn at regular *x* offsets, as shown here:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要区分绘制和弦与绘制音阶的音符。由于和弦中的所有音符都是一起演奏的，因此和弦的音符在单个 *x* 位置上绘制。相比之下，音阶中的音符在规则的
    *x* 偏移量上绘制，如下所示：
- en: '![](img/f8dd155a-841b-4dc0-b05a-e2d950d88f17.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f8dd155a-841b-4dc0-b05a-e2d950d88f17.png)'
- en: 'Since we need to offset the *x* value for scales at regular intervals, we use
    the `count` method from the `itertools` module to provide an ever-increasing value
    of *x*:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们需要在固定间隔内调整 *x* 值以适应刻度，我们使用 `itertools` 模块中的 `count` 方法来提供一个不断增长的 *x* 值：
- en: '[PRE46]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Now every subsequent call to `x = next(self.x_counter)` increments *x* by `30`.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在每次调用`x = next(self.x_counter)`都会将*x*增加`30`。
- en: 'Now here''s the code that draws the actual note on the canvas:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是绘制实际笔记到画布上的代码：
- en: '[PRE47]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The description of the preceding code is as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 前述代码的描述如下：
- en: The method accepts a note name, for example, `C1` or *D2*#, and draws an oval
    at an appropriate place.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该方法接受一个音符名称，例如，`C1` 或 *D2*#，并在适当的位置绘制一个椭圆形。
- en: We need to get the *x*, *y* values for drawing an oval.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要获取绘制椭圆的*x*，*y*值。
- en: We first calculate the *x* value. If the note is part of a chord, we fix the
    *x* value at `75` px, whereas if the note is part of a scale, the *x* value is
    incremented by *30* pixels from the previous *x* value by calling `next` on the
    `itertool counter` method.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们首先计算 *x* 值。如果音符是和弦的一部分，我们将 *x* 值固定在 `75` 像素，而如果音符是音阶的一部分，则通过在 `itertool counter`
    方法上调用 `next` 来将 *x* 值从上一个 *x* 值增加 *30* 像素。
- en: 'Next, we calculate the *y* value. The code to do this is as follows:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们计算 *y* 值。 执行此操作的代码如下：
- en: '[PRE48]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Basically, the *y* offset is calculated based on the index of the note in the
    list and each subsequent note is offset by `5` pixels.  The number `85` is found
    by trial and error.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，*y* 偏移量是根据列表中音符的索引计算的，每个后续音符偏移 `5` 像素。数字 `85` 是通过试错法得到的。
- en: 'Now that we have the *x* and *y* value, we simply draw the oval of given `radius`:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了 *x* 和 *y* 值，我们只需绘制给定 `半径` 的椭圆：
- en: '[PRE49]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: If the note is a sharp note, that is, if it contains the character `#`,  it
    draws the `#` image 10 pixels left of the oval for the note.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如果音符是升音符，即如果它包含字符`#`，则会在音符的椭圆左侧10像素处绘制`#`图像。
- en: The notes C1, G2, A2, and B2 are drawn outside the five lines. So in addition
    to oval we need to draw a small line crossing horizontally through them. This
    is what the last 11 lines of `if…else` statements achieve.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 音符C1、G2、A2和B2绘制在五条线之外。因此，除了椭圆形之外，我们还需要画一条小横线穿过它们。这正是最后11行`if…else`语句所实现的功能。
- en: 'Finally, we have the `draw_notes` method and `draw_chord` method that given
    a list of notes draw out the notes and chords, respectively. These are the only
    two methods that do not have an underscore before their names. This means we expose
    the interface of our program only using these two methods:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有`draw_notes`方法和`draw_chord`方法，分别用于绘制音符和和弦。这两个方法的名字前没有下划线，这意味着我们只通过这两个方法暴露了我们的程序接口：
- en: '[PRE50]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now that we have our `ScoreMaker` ready, we simply import it into `7.07/view.py`:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了`ScoreMaker`，我们只需将其导入到`7.07/view.py`中：
- en: '[PRE51]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We modify `build_score_sheet_frame` to instantiate the `ScoreMaker`:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们修改`build_score_sheet_frame`以实例化`ScoreMaker`：
- en: '[PRE52]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We then modify `find_scale` to add this line (`7.07/view.py`):'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后修改`find_scale`以添加此行（`7.07/view.py`）：
- en: '[PRE53]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We similarly modify `find_chord`  and `on_progression_button_clicked` to add
    this line (`7.07/view.py`):'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '我们同样修改了 `find_chord` 和 `on_progression_button_clicked` 以添加此行 (`7.07/view.py`):'
- en: '[PRE54]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: That brings us to the end of this project. If you now run `7.07/view.py`, you
    should see a functional score maker and a functional Piano Tutor.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这就标志着这个项目的结束。如果你现在运行 `7.07/view.py`，你应该会看到一个功能齐全的得分生成器和一个功能齐全的钢琴辅导工具。
- en: However, let's end this chapter with a brief discussion on window responsiveness.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，让我们以对窗口响应性的简要讨论来结束这一章。
- en: A note on window responsiveness
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于窗口响应性的说明
- en: We used `.grid_propagate(False)` in this program to ensure that our frames did
    not shrink to fit their contents, but rather stayed at a fixed height and width
    that we had specified while making the frames.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序中，我们使用了`.grid_propagate(False)`来确保我们的框架不会缩小以适应其内容，而是保持在我们制作框架时指定的固定高度和宽度。
- en: This served us well for this example, but this made our window and its content
    fixed in size. This is what you would typically call a non-responsive window.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子中这做得很好，但这使得我们的窗口及其内容大小固定。这通常被称为非响应式窗口。
- en: 'Let us take a look at the program `nonresponsive.py` *a*s an example of a non-responsive
    window. This program simply draws `10` buttons in a row:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以程序 `nonresponsive.py` 作为非响应式窗口的例子。这个程序简单地在一行中绘制了 `10` 个按钮：
- en: '[PRE55]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Run this program and resize the window. These buttons are drawn on the root
    window and are not responsive. The buttons remain fixed in size. They do not adapt
    in size to change in the window size.  If the window size is made smaller, some
    of the buttons even disappear from view.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此程序并调整窗口大小。这些按钮绘制在根窗口上，并且无响应。按钮的大小保持固定。它们不会根据窗口大小的变化而调整大小。如果窗口大小减小，一些按钮甚至会从视图中消失。
- en: 'In contrast, let us take a look at the program `responsive.py`:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，让我们来看看程序 `responsive.py`：
- en: '[PRE56]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'If you run this program and resize the window, you will see that the buttons
    respond by resizing themselves to fit the container root window. So what''s the
    difference between the two previous pieces of code? We simply added these two
    lines to the second program:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这个程序并调整窗口大小，你会看到按钮会相应地调整自身大小以适应容器根窗口。那么这两段之前的代码有什么区别呢？我们只是简单地在第二个程序中添加了这两行：
- en: '[PRE57]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: These two lines add **non-zero weights** (`weight=1`) to the `x`^(th) button
    widget in the container (root in the preceding example).
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这两行代码向容器中的`x`^(th)按钮小部件添加了**非零权重**（`weight=1`）（在前面的示例中是根）。
- en: The key here is to understand the importance of weights. If we have two widgets, `widget1`
    and `widget2`, and we assign them weights of 3 and 1, respectively. Now when you
    resize its parent, `widget1` will take up 3/4^(th) of the space, while `widget2`
    will take up 1/4^(th) of the space.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的关键是理解权重的重要性。如果我们有两个小部件，`widget1` 和 `widget2`，并且分别给它们分配权重 3 和 1。现在当你调整其父元素的大小时，`widget1`
    将占据 3/4 的空间，而 `widget2` 将占据 1/4 的空间。
- en: 'Here''s the documentation of `rowconfigure` and `columnconfigure`:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`rowconfigure`和`columnconfigure`的文档：
- en: '[http://infohost.nmt.edu/tcc/help/pubs/tkinter/web/grid-config.html](http://infohost.nmt.edu/tcc/help/pubs/tkinter/web/grid-config.html).'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://infohost.nmt.edu/tcc/help/pubs/tkinter/web/grid-config.html](http://infohost.nmt.edu/tcc/help/pubs/tkinter/web/grid-config.html).'
- en: Experimenting with the code
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在代码上进行实验
- en: The best way to experience this piece of code is to make the following tweaks
    one by one, run the program, and resize the window to see the effect of each option.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 体验这段代码的最佳方式是逐一进行以下调整，运行程序，并调整窗口大小以查看每个选项的效果。
- en: 'As a first tweak, change the weights to `0`:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一次调整，将权重改为`0`：
- en: '[PRE58]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This will make the window non-responsive again.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这将再次使窗口无响应。
- en: Next, reassign the weights back to 1 and then comment out one of the two lines
    and see the difference. If you comment out the `rowconfigure` line the buttons
    will be responsive in the *y* direction, but non-responsive in the `x` direction
    and vice versa for `columnconfigure`.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将权重重新分配回1，然后注释掉其中一行，观察差异。如果你注释掉`rowconfigure`行，按钮将在*y*方向上响应，但在*x*方向上则不响应，反之亦然对于`columnconfigure`。
- en: 'Restore the program to its original state and then assign a different weight
    in each loop by changing the weight to `x`:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 将程序恢复到其原始状态，然后在每个循环中通过将权重更改为`x`来分配不同的权重：
- en: '[PRE59]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'So the first button will have a weight of 0, the second button will have a
    weight of 1, and so on. Now if you run the program and resize the window, the
    last button with weight=9 will be the most responsive (will take up the largest
    proportion of the available space), while the first button with a weight of 0
    will be completely non-responsive (fixed size), as shown in the following screenshot:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，第一个按钮的权重将为0，第二个按钮的权重将为1，以此类推。现在，如果你运行程序并调整窗口大小，权重为9的最后一个按钮将是最灵敏的（将占据可用空间的最大比例），而权重为0的第一个按钮将完全不灵敏（固定大小），如下面的截图所示：
- en: '![](img/6a202f22-393d-4719-ba6d-a39491e116e2.png)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6a202f22-393d-4719-ba6d-a39491e116e2.png)'
- en: 'As the last tweak, restore the program to its original state and change the
    value of the second argument to a fixed number, say *2*:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后的调整，将程序恢复到其原始状态，并将第二个参数的值更改为一个固定数字，比如说 *2*：
- en: '[PRE60]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'This will assign the weight only to the third button (counting starts with
    0), so the third button becomes responsive, while the others stay non-responsive,
    as shown in the following screenshot:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这将只分配权重到第三个按钮（计数从0开始），因此第三个按钮变得响应，而其他按钮保持非响应状态，如下面的截图所示：
- en: '![](img/d7508541-365c-47ce-970d-599082b1a8b8.png)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d7508541-365c-47ce-970d-599082b1a8b8.png)'
- en: As a matter of fact, in this last case since we are assigning weight only to
    a single widget, we could have as well assigned it outside the loop.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，在这个最后的情况下，因为我们只对一个单个的小部件分配权重，我们完全可以把它分配在循环之外。
- en: Handling widget resize with <Configure>
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `<Configure>` 处理小部件尺寸调整
- en: There might be occasions when you <indexentry content="window responsiveness:widget
    resize, handling with ">want to do some specific action when a user resizes a
    window or a widget. Tkinter provides an event named `<Configure>`, which can be
    bound to a callback to react to changes in widget size.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会有这样的情况，当用户调整窗口或小部件大小时，你<indexentry content="窗口响应性：小部件调整大小，处理方式">想要执行一些特定的操作。Tkinter
    提供了一个名为 `<Configure>` 的事件，它可以绑定到一个回调函数上，以响应小部件大小的变化。
- en: 'Here is a simple example (see `handle_widget_resize.py`):'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个简单的例子（见 `handle_widget_resize.py`）：
- en: '[PRE61]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The description of the code is as follows:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的描述如下：
- en: We have a Label widget in a `root` window. We set the pack options for the label
    to `(fill='both', expand=True)` as we want it to resize every time the root window
    resizes.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在`root`窗口中有一个标签小部件。我们为标签设置了`pack`选项为`(fill='both', expand=True)`，因为我们希望它在`root`窗口大小调整时能够相应地调整大小。
- en: We attach a callback to the `<Configure>` event to listen for any changes in
    the size of the label widget. As soon as the label widget changes, it triggers
    a call to the method `on_label_resized`.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将一个回调函数附加到 `<Configure>` 事件上，以监听标签小部件大小的任何变化。一旦标签小部件发生变化，它就会触发对方法 `on_label_resized`
    的调用。
- en: Now if you resize the window, the label resizes and that triggers `on_label_resized`,
    which prints the new height and width of the label widget to the console. This
    can be used for adjusting the placement of items on the screen.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果您调整窗口大小，标签也会随之调整，这会触发`on_label_resized`事件，将标签小部件的新高度和宽度打印到控制台。这可以用来调整屏幕上项目的位置。
- en: That concludes our brief discussion on window responsiveness.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对窗口响应性的简要讨论。
- en: Summary
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We worked with several useful standard modules such as `functools`, `itertools`,
     and `json`.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了几个有用的标准模块，例如 `functools`、`itertools` 和 `json`。
- en: We saw how to work with *JSON* files. JSON helps us present complex rules about
    our domain and are an easier and more portable alternative to storing the same
    information in say a database.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了如何处理 *JSON* 文件。JSON 帮助我们呈现关于我们领域的复杂规则，并且相较于在数据库中存储相同信息来说，它是一个更简单、更便携的替代方案。
- en: We looked at the practical usage of `widget.grid_propagate(False)`  along with
    some of its limitations in terms of non-responsiveness.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探讨了`widget.grid_propagate(False)`的实际用法及其在非响应性方面的局限性。
- en: We saw the usage of `OrderedDict` from the `collections` module and `partials`
    from the `functools` module.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了`collections`模块中`OrderedDict`的用法和`functools`模块中`partials`的用法。
- en: We looked at various root window methods such as `root.geometry`, `root.winfo_screenwidth`,
    and `root.resizable`.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们研究了各种根窗口方法，例如`root.geometry`、`root.winfo_screenwidth`和`root.resizable`。
- en: We looked at `widget.update_idletasks`, which lets us clear all pending updates
    without having to wait for the next run of mainloop.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们查看了`widget.update_idletasks`，它允许我们在不需要等待主循环下一次运行的情况下清除所有挂起的更新。
- en: Finally, we looked at the steps involved in making a window responsive in Tkinter.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们探讨了在Tkinter中使窗口响应式所需的步骤。
- en: QA section
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QA部分
- en: Before you proceed to the next chapter, make sure you can answer these questions
    to your
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在你继续阅读下一章之前，请确保你能回答这些问题
- en: 'satisfaction:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 满意度：
- en: What is `partial` from the `functools` module used for?
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`functools`模块中的`partial`函数有什么用途？'
- en: When and why do we need to use `widget.update_idletasks` in a Tkinter program?
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Tkinter程序中，何时以及为什么需要使用`widget.update_idletasks`？
- en: If needed, how can we handle resizing of the main window or any other widget
    in Tkinter?
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要，我们该如何处理Tkinter中主窗口或任何其他小部件的调整大小问题？
- en: What are the data structures available in JSON? (read about it here: [https://www.json.org/](https://www.json.org/))
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON 中有哪些可用的数据结构？（了解更多信息请参阅：[https://www.json.org/](https://www.json.org/))
- en: How do you make widgets responsive in Tkinter?
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你如何在Tkinter中使小部件响应式？
- en: Further reading
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: Read more about JSON data structures. They are popular and are used everywhere.
    An alternative structure is XML.  Read about XML and JSON and when and why one
    should be preferred over the other.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 了解更多关于 JSON 数据结构的信息。它们非常流行，并被广泛应用于各个领域。另一种结构是 XML。阅读有关 XML 和 JSON 的内容，以及何时以及为什么应该选择其中一种而不是另一种。
- en: The collections module of Python provides some very versatile and useful data
    structures such as `namedtuple`, `deque`, `Counter`, `dict`, `OrderedDict`, `defaultdict`,
    `chainMap`, `UserDict`, `UserList`, and `userString`. These can be suitably used
    in a wide variety of use cases. More information can be found at:[ https://docs.python.org/3/library/collections.html](https://docs.python.org/3/library/collections.html).
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的 collections 模块提供了一些非常灵活和有用的数据结构，例如 `namedtuple`、`deque`、`Counter`、`dict`、`OrderedDict`、`defaultdict`、`chainMap`、`UserDict`、`UserList`
    和 `userString`。这些数据结构可以在各种用例中适当使用。更多信息可以在[这里](https://docs.python.org/3/library/collections.html)找到。
- en: We used external audio files and external images in our program. This means
    that they need to be bundled with the program if it has to be packaged and distributed.
    An alternative packaging of audio files and images can be done using what is called
    **base-64 encoding**.  The audio files and the images can be base-64 encoded in
    a text file and then read back and decoded by the program to be used as audio
    files or image files. Read about base-64 encoding and if you feel motivated enough,
    try to convert all audio files and images used in this program into base-64 encoding.
    More information on base-64 encoding can be found here: [https://en.wikipedia.org/wiki/Base64](https://en.wikipedia.org/wiki/Base64).
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在程序中使用了外部音频文件和外部图像。这意味着如果需要打包和分发，它们需要与程序捆绑在一起。可以使用所谓的**base-64编码**来对音频文件和图像进行另一种打包。音频文件和图像可以被base-64编码到文本文件中，然后由程序读取并解码，用作音频文件或图像文件。阅读有关base-64编码的信息，如果你有足够的动力，尝试将此程序中使用的所有音频文件和图像转换为base-64编码。有关base-64编码的更多信息，请参阅此处：[https://en.wikipedia.org/wiki/Base64](https://en.wikipedia.org/wiki/Base64)。
- en: The Python implementation of base-64 encoding can be found here: [https://docs.python.org/3/library/base64.html](https://docs.python.org/3/library/base64.html).
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的 base-64 编码实现可以在这里找到：[https://docs.python.org/3/library/base64.html](https://docs.python.org/3/library/base64.html).
