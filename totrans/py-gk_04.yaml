- en: '*Chapter 3*: Advanced Object-Oriented Python Programming'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python can be used as a declarative modular programming language such as C,
    as well as being used for imperative programming or full **object-oriented programming**
    (**OOP**) with programming languages such as Java. **Declarative programming**
    is a paradigm in which we focus on what we want to implement, while **imperative
    programming** is where we describe the exact steps of how to implement what we
    want. Python is suitable for both types of programming paradigms. OOP is a form
    of imperative programming in which we bundle the properties and behaviors of real-world
    objects into programs. Moreover, OOP also addresses the relations between different
    types of real-world objects.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will explore how the advanced concepts of OOP can be implemented
    using Python. We are assuming that you are familiar with general concepts such
    as classes, objects, and instances and have basic knowledge of inheritance between
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing classes and objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding OOP principles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using composition as an alternative design approach
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing duck typing in Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning when not to use OOP in Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These are the technical requirements for this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: You need to have Python 3.7 or later installed on your computer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The sample code for this chapter can be found at [https://github.com/PacktPublishing/Python-for-Geeks/tree/master/Chapter03](https://github.com/PacktPublishing/Python-for-Geeks/tree/master/Chapter03).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing classes and objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A class is a blueprint for how something should be defined. It doesn't actually
    contain any data—it is a template that is used to create instances as per the
    specifications defined in a template or a blueprint.
  prefs: []
  type: TYPE_NORMAL
- en: An object of a class is an instance that is built from a class, and that is
    why it is also called an instance of a class. For the rest of this chapter and
    this book, we will refer to *object* and *instance* synonymously. Objects in OOP
    are occasionally represented by physical objects such as tables, chairs, or books.
    On most occasions, the objects in a software program represent abstracted entities
    that may not be physical, such as accounts, names, addresses, and payments.
  prefs: []
  type: TYPE_NORMAL
- en: To refresh ourselves with basic concepts of classes and objects, we will define
    these terminologies with code examples.
  prefs: []
  type: TYPE_NORMAL
- en: Distinguishing between class attributes and instance attributes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Class attributes** are defined as part of the class definition, and their
    values are meant to be the same across all instances created from that class.
    The class attributes can be accessed using the class name or instance name, although
    it is recommended to use a class name to access these attributes (for reading
    or updating). The state or data of an object is provided by **instance attributes**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Defining a class in Python is simply done by using the `class` keyword. As
    discussed in [*Chapter 1*](B17189_01_Final_PG_ePub.xhtml#_idTextAnchor013), *Optimal
    Python Development Life Cycle,* the name of the class should be CamelCase. The
    following code snippet creates a `Car` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This class has no attributes and methods. It is an empty class, and you may
    think this class is useless until we add more components to it. Not exactly! In
    Python, you can add attributes on the fly without defining them in the class.
    The following snippet is a valid example of code in which we add attributes to
    a class instance at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In this extended example, we created an instance (`car`) of our `Car` class
    and then added two attributes to this instance: `color` and `miles`. Note that
    the attributes added using this approach are instance attributes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will add class attributes and instance attributes using a constructor
    method (`__init__`), which is loaded at the time of object creation. A code snippet
    with two instance attributes (`color` and `miles`) and the `init` method is shown
    next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In this program, we did the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We created a `Car` class with a `c_mileage_units` class attribute and two instance
    variables, `i_color` and `i_mileage`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We created an instance (`car`) of the `Car` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We printed out the instance attributes using the `car` instance variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We printed out the class attribute using the `car` instance variable as well
    as the `Car` class name. The console output is the same for both cases.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Important note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`self` is a reference to the instance that is being created. Use of `self`
    is common in Python to access the instance attributes and methods within the instance
    method, including the `init` method. `self` is not a keyword, and it is not mandatory
    to use the word `self`. It can be anything such as `this` or `blah`, except that
    it has to be the first parameter to the instance methods, but the convention of
    using `self` as the argument name is too strong.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can update the class attributes using an instance variable or class name,
    but the outcome can be different. When we update a class attribute using the class
    name, it is updated for all the instances of that class. But if we update a class
    attribute using an instance variable, it will be updated only for that particular
    instance. This is demonstrated in the following code snippet, which is using the
    `Car` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The console output of this program can be analyzed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The first set of `print` statements will output the default value of the class
    attribute, which is `Mi`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After executing the `car1.c_mileage_units = "km"` statement, the value of the
    class attribute will be the same (`Mi`) for the `car2` instance and the class-level
    attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After executing the `Car.c_mileage_units = "NP"` statement, the value of the
    class attribute for `car2` and the class level will change to `NP,` but it will
    stay the same (`km`) for `car1` as it was explicitly set by us.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Important note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Attribute names start with `c` and `i` to indicate that they are class and instance
    variables, respectively, and not regular local or global variables. The name of
    non-public instance attributes must start with a single or double underscore to
    make them protected or private. This will be discussed later in the chapter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Using constructors and destructors with classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As with any other OOP language, Python also has constructors and destructors,
    but the naming convention is different. The purpose of having constructors in
    a class is to initialize or assign values to the class- or instance-level attributes
    (mainly instance attributes) whenever an instance of a class is being created.
    In Python, the `__init__` method is known as the constructor and is always executed
    when a new instance is created. There are three types of constructors supported
    in Python, listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`__init__` method) in a class or forget to declare it, then that class will
    use a default constructor that is empty. The constructor does nothing other than
    initialize the instance of a class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Name:` class:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Name` class will be updated with a parameterized constructor, as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Destructors are the opposite of constructors—they are executed when an instance
    is deleted or destroyed. In Python, destructors are hardly used because Python
    has a garbage collector that handles the deletion of the instances that are no
    longer referenced by any other instance or program. If we need to add logic inside
    a destructor method, we can implement it by using a special `__del__` method.
    It is automatically called when all references of an instance are deleted. Here
    is the syntax of how to define a destructor method in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Distinguishing between class methods and instance methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Python, we can define three types of methods in a class, which are described
    next:'
  prefs: []
  type: TYPE_NORMAL
- en: '`self`) and can read and update the state of the instance. `__init__`, which
    is a constructor method, is an example of an instance method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@classmethod` decorator. These methods don''t need a class instance for execution.
    For this method, the class reference (`cls` is used as a convention) will be automatically
    sent as the first argument.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@staticmethod` decorator. They don''t have access to `cls` or `self` objects.
    Static methods are like utility functions that take certain arguments and provide
    the output based on the arguments'' values—for example, if we need to evaluate
    certain input data or parse data for processing, we can write static methods to
    achieve these goals. Static methods work like regular functions that we define
    in modules but are available in the context of the class''s namespace.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To illustrate how these methods can be defined and then used in Python, we
    created a simple program, which is shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In this program, we did the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We created a `Car` class with a class attribute (`c_mileage_units`), a class
    method (`print_units`), a static method (`print_hello`), instance attributes (`i_color`
    and `i_mileage`), an instance method (`print_color`), and a constructor method
    `(__init__)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We created an instance of the `Car` class using its constructor as `car`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the instance variable (`car` in this example), we called the instance
    method, the class method, and the static method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the class name (`Car` in this example), we again triggered the instance
    method, the class method, and the static method. Note that we can trigger the
    instance method using the class name, but we need to pass the instance variable
    as a first argument (this also explains why we need the `self` argument for each
    instance method).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The console output of this program is shown next for reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Special methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we define a class in Python and try to print one of its instances using
    a `print` statement, we will get a string containing the class name and the reference
    of the object instance, which is the object''s memory address. There is no default
    implementation of the `to string` functionality available with an instance or
    object. The code snippet showing this behavior is presented here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get console output similar to the following, which is not what is expected
    from a `print` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To get something meaningful from a `print` statement, we need to implement
    a special `__str__` method that will return a string with information about the
    instance and that can be customized as needed. Here is a code snippet showing
    the `carexample4.py` file with the `__str__` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'And the console output of the `print` statement is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: With a proper `__str__` implementation, we can use a `print` statement without
    implementing special functions such as `to_string()`. It is the Pythonic way to
    control the string conversion. Another popular method used for similar reasons
    is `__repr__`, which is used by a Python interpreter for inspecting an object.
    The `__repr__` method is more for debugging purposes.
  prefs: []
  type: TYPE_NORMAL
- en: These methods (and a few more) are called special methods or **dunders**, as
    they always start and end with double underscores. Normal methods should not use
    this convention. These methods are also known as magic **methods** in some literature,
    but it is not the official terminology. There are several dozen special methods
    available for implementation with a class. A comprehensive list of special methods
    is available with the official Python 3 documentation at https://docs.python.org/3/reference/datamodel.html#specialnames.
  prefs: []
  type: TYPE_NORMAL
- en: We reviewed the classes and the objects with code examples in this section.
    In the next section, we will study different object-oriented principles available
    in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding OOP principles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'OOP is a way of bundling properties and behavior into a single entity, which
    we call objects. To make this bundling more efficient and modular, there are several
    principles available in Python, outlined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulation of data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Polymorphism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Abstraction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next subsections, we will study each of these principles in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulation of data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Encapsulation is a fundamental concept in OOP and is also sometimes referred
    to as abstraction. But in reality, the encapsulation is more than the abstraction.
    In OOP, bundling of data and the actions associated with the data into a single
    unit is known as encapsulation. Encapsulation is actually more than just bundling
    data and the associated actions. We can enumerate three main objectives of encapsulation
    here, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Encompass data and associated actions in a single unit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hide the internal structure and implementation details of the object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Restrict access to certain components (attributes or methods) of the object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encapsulation simplifies the use of the objects without knowing internal details
    on how it is implemented, and it also helps to control updates to the state of
    the object.
  prefs: []
  type: TYPE_NORMAL
- en: In the next subsections, we will discuss these objectives in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Encompassing data and actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To encompass data and actions in one init, we define attributes and methods
    in a class. A class in Python can have the following types of elements:'
  prefs: []
  type: TYPE_NORMAL
- en: Constructor and destructor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class methods and attributes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instance methods and attributes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Nested** classes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have discussed these class elements already in the previous section, except
    nested or **inner** classes. We already provided the Python code examples to illustrate
    the implementation of constructors and destructors. We have used instance attributes
    to encapsulate data in our instances or objects. We have also discussed the class
    methods, static methods, and class attributes with code examples in the previous
    section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To complete the topic, we will discuss the following Python code snippet with
    a nested class. Let''s take an example of our `Car` class and an `Engine` inner
    class within it. Every car needs an engine, so it makes sense to make it a nested
    or inner class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we defined an `Engine` inner class inside our regular `Car`
    class. The `Engine` class has only one attribute—`i_size`, the constructor method
    (`__init__)`, and the `__str__` method. For the `Car` class, we updated the following
    as compared to our previous examples:'
  prefs: []
  type: TYPE_NORMAL
- en: The `__init__` method includes a new attribute for engine size, and a new line
    has been added to create a new instance of `Engine` associated with the `Car`
    instance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `__str__` method of the `Car` class includes the `i_size` inner class attributes
    in it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The main program is using a `print` statement on the `Car` instance and also
    has a line to print the value of the `i_size` attribute of the `Engine` class.
    The console output of this program will be similar to what is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The console output of the main program shows that we have access to the inner
    class from within the class implementation and we can access the inner class attributes
    from outside.
  prefs: []
  type: TYPE_NORMAL
- en: In the next subsection, we will discuss how we can hide some of the attributes
    and methods to not be accessible or visible from outside the class.
  prefs: []
  type: TYPE_NORMAL
- en: Hiding information
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have seen in our previous code examples that we have access to all class-level
    as well as instance-level attributes without any restrictions. Such an approach
    led us to a flat design, and the class will simply become a wrapper around the
    variables and methods. A better object-oriented design approach is to hide some
    of the instance attributes and make only the necessary attributes visible to the
    outside world. To discuss how this is achieved in Python, we introduce two terms:
    **private** and **protected**.'
  prefs: []
  type: TYPE_NORMAL
- en: Private variables and methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A private **variable** or attribute can be defined by using a double *underscore*
    as a prefix before a variable name. In Python, there is no keyword such as *private,*
    as we have in other programming languages. Both class and instance variables can
    be marked as private.
  prefs: []
  type: TYPE_NORMAL
- en: A private **method** can also be defined by using a double *underscore* before
    a method name. A private method can only be called within the class and is not
    available outside the class.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever we define an attribute or a method as private, the Python interpreter
    doesn't allow access for such an attribute or a method outside of the class definition.
    The restriction also applies to subclasses; therefore, only the code within a
    class can access such attributes and methods.
  prefs: []
  type: TYPE_NORMAL
- en: Protected variables and methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A `i_color` attribute from a public to a protected attribute, we just need to
    change its name to `_i_color`. The Python interpreter does not enforce this usage
    of the protected elements within a class or subclass. It is more to honor the
    naming convention and use or access the attribute or methods as per the definition
    of the protected variables and methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'By using private and protected variables and methods, we can hide some of the
    details of the implementation of an object. This is helpful, enabling us to have
    a tight and clean source code inside a large-sized class without exposing everything
    to the outside world. Another reason for hiding attributes is to control the way
    they can be accessed or updated. This is a topic for the next subsection. To conclude
    this section, we will discuss an updated version of our `Car` class with private
    and protected variables and a private method, which is shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In this updated `Car` class, we have updated or added the following as per
    the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: A private `__max_speed` class variable with a default value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A private `__no_doors` instance variable with a default value inside the `__init__`
    constructor method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `_model` protected instance variable, added for illustration purposes only
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `__doors()` private instance method to get the number of doors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `__str__` method is updated to get the door by using the `__doors()` private
    method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The console output of this program works as expected, but if we try to access
    any of the private methods or private variables from the main program, it is not
    available, and the Python interpreter will throw an error. This is as per the
    design, as the intended purpose of these private variables and private methods
    is to be only available within a class.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Python does not really make the variables and methods private, but it pretends
    to make them private. Python actually mangles the variable names with the class
    name so that they are not easily visible outside the class that contains them.
  prefs: []
  type: TYPE_NORMAL
- en: For the `Car` class example, we can access the private variables and private
    methods. Python provides access to these attributes and methods outside of the
    class definition with a different attribute name that is composed of a leading
    underscore, followed by the class name, and then a private attribute name. In
    the same way, we can access the private methods as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following lines of codes are valid but not encouraged and are against the
    definition of private and protected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, `_Car` is appended before the actual private variable name. This
    is done to minimize the conflicts with variables in inner classes as well.
  prefs: []
  type: TYPE_NORMAL
- en: Protecting the data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have seen in our previous code examples that we can access the instance attributes
    without any restrictions. We also implemented instance methods and we have no
    restriction on the use of these. We emulate to define them as private or protected,
    which works to hide the data and actions from the outside world.
  prefs: []
  type: TYPE_NORMAL
- en: 'But in real-world problems, we need to provide access to the variables in a
    way that is controllable and easy to maintain. This is achieved in many object-oriented
    languages through **access modifiers** such as getters and setters, which are
    defined next:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Getters**: These are methods used to access the private attributes from a
    class or its instance'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Setters**: These are methods used to set the private attributes of a class
    or its instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Getters and setters methods can also be used to implement additional logic
    of accessing or setting the attributes, and it is convenient to maintain such
    an additional logic in one place. There are two ways to implement the getters
    and setters methods: a *traditional way* and a *decorative* way.'
  prefs: []
  type: TYPE_NORMAL
- en: Using traditional getters and setters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Traditionally, we write the instance methods with a `get` and `set` prefix,
    followed by the underscore and the variable name. We can transform our `Car` class
    to use the getter and setter methods for instance attributes, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In this updated `Car` class, we added the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`color` and `mileage` instance attributes were added as private variables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getter methods for `color` and `mileage` instance attributes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A setter method only for the `mileage` attribute because `color` usually doesn't
    change once it is set at the time of object creation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the main program, we get data for the newly created instance of the class
    using getter methods. Next, we updated the mileage using a setter method, and
    then we got data again for the `color` and `mileage` attributes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The console output of each statement in this example is trivial and as per expectations.
    As mentioned, we did not define a setter for each attribute, but only for those
    attributes where it makes sense and the design demands. Using getters and setters
    is a best practice in OOP, but they are not very popular in Python. The culture
    of Python developers (also known as the Pythonic way) is still to access attributes
    directly.
  prefs: []
  type: TYPE_NORMAL
- en: Using property decorators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using a **decorator** to define getters and setters is a modern approach that
    helps to achieve the Python way of programming.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are into using decorators, then we have a `@property` decorator in Python
    to make the code simpler and cleaner. The `Car` class with traditional getters
    and setters is updated with decorators, and here is a code snippet showing this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In this updated class definition, we updated or added the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Instance attributes as private variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getter methods for `color` and `mileage` by using the name of the attribute
    as the method name and using `@property`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setter methods for `mileage` using the `@mileage.setter` decorator, giving the
    method the same name as the name of the attribute
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the main script, we access the color and the mileage attributes by using
    the instance name followed by a dot and the attribute name (the Pythonic way).
    This makes the code syntax concise and readable. The use of decorators also makes
    the name of the methods simpler.
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion, we discussed all aspects of encapsulation in Python, using classes
    for the bundling of data and actions, hiding unnecessary information from the
    outside world of a class, and how to protect data in a class using getters, setters,
    and property features of Python. In the next section, we will discuss how inheritance
    is implemented in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Extending classes with inheritance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The concept of inheritance in OOP is similar to the concept of inheritance in
    the real world, where children inherit some of the characteristics from their
    parents on top of their own characteristics.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, a class can inherit elements from another class. These elements
    include attributes and methods. The class from which we inherit another class
    is commonly known as a parent class, a **superclass**, or a **base** class. The
    class we inherit from another class is called a **derived** **class**, a **child**
    **class**, or a **subclass**. The following screenshot shows a simple relationship
    between a parent class and a child class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – Parent-and-child class relationship'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17189_03_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.1 – Parent-and-child class relationship
  prefs: []
  type: TYPE_NORMAL
- en: In Python, when a class inherits from another class, it typically inherits all
    the elements that compose the parent class, but this can be controlled by using
    naming conventions (such as double underscore) and access modifiers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inheritance can be of two types: **simple** or **multiple**. We will discuss
    these in the next sections.'
  prefs: []
  type: TYPE_NORMAL
- en: Simple inheritance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In simple or basic inheritance, a class is derived from a single parent. This
    is a commonly used inheritance form in OOP and is closer to the family tree of
    human beings. The syntax of a parent class and a child class using simple inheritance
    is shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'For this simple inheritance, we will modify our example of the `Car` class
    so that it is derived from a `Vehicle` parent class. We will also add a `Truck`
    child class to elaborate on the concept of inheritance. Here is the code with
    modifications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we created a `Vehicle` parent class with one `i_color` attribute
    and one `print_vehicle_info` method. Both the elements are a candidate for inheritance.
    Next, we created two child classes, `Car` and `Truck`. Each child class has one
    additional attribute (`i_seats` and `i_capacity`) and one additional method (`print_me`).
    In the `print_me` methods in each child class, we access the parent class instance
    attribute as well as child class instance attributes.
  prefs: []
  type: TYPE_NORMAL
- en: This design was intentional, to elaborate the idea of inheriting some elements
    from the parent class and adding some elements of its own in a child class. The
    two child classes are used in this example to demonstrate the role of inheritance
    toward reusability.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our main program, we created `Car` and `Truck` instances and tried to access
    the parent method as well as the instance method. The console output of this program
    is as expected and is shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Multiple inheritance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In multiple inheritance, a child class can be derived from multiple parents.
    The concept of multiple inheritance is applicable in advanced object-oriented
    designs where the objects have relationships with multiple objects, but we must
    be careful when inheriting from multiple classes, especially if those classes
    are inherited from a common superclass. This can lead us to problems such as the
    diamond problem. The diamond problem is a situation when we create an `X` class
    by inheriting from two classes, `Y` and `Z`, and the `Y` and `Z` classes are inherited
    from a common class, `A`. The `X` class will have ambiguity about the common code
    of the `A` class, which it inherits from classes `Y` and `Z`.  Multiple inheritance
    is not encouraged because of the possible issues it can bring with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate the concept, we will modify our `Vehicle` and `Car` classes and
    we will add an `Engine` class as one of the parents. The complete code with multiple
    inheritance of classes is shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In this multiple inheritance example, we created two parent classes as a parent:
    `Vehicle` and `Engine`. The `Vehicle` parent class is the same as in the previous
    example. The `Engine` class has one attribute (`i_size`) and one method (`print_engine_info`).
    The `Car` class is derived from both `Vehicle` and `Engine` and adds one additional
    attribute (`i_seats`) and one additional method (`print_car_info`). In the instance
    method, we can access instance attributes of both parent classes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the main program, we created an instance of the `Car` class. With this instance,
    we can access the instance methods of parent classes as well as child classes.
    The console output of the main program is shown here and is as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we introduced inheritance and its types as simple and multiple.
    Next, we will study the concept of polymorphism in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In its literal meaning, a process of having multiple forms is called polymorphism.
    In OOP, **polymorphism** is the ability of an instance to behave in multiple ways
    and a way to use the same method with the same name and the same arguments, to
    behave differently in accordance with the class it belongs to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Polymorphism can be implemented in two ways: **method overloading** and **method**
    **overriding**. We will discuss each in the next subsections.'
  prefs: []
  type: TYPE_NORMAL
- en: Method overloading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Method overloading is a way to achieve polymorphism by having multiple methods
    with the same name, but with a different type or number of arguments. There is
    no clean way to implement method overloading in Python. Two methods cannot have
    the same name in Python. In Python, everything is an object, including classes
    and methods. When we write methods for a class, they are in fact attributes of
    a class from the namespace perspective and thus cannot have the same name. If
    we write two methods with the same name, there will be no syntax error, and the
    second one will simply replace the first one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside a class, a method can be overloaded by setting the default value to
    the arguments. This is not the perfect way of implementing method overloading,
    but it works. Here is an example of method overloading inside a class in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we add a `print_me` method with an argument that has a default
    value. The default value will be used when no parameter will be passed. When no
    parameter is passed to the `print_me` method, the console output will only provide
    the color of the `Car` instance. When an argument is passed to this method (regardless
    of the value), we have a different behavior of this method, which is providing
    both the color and the number of seats of the `Car` instance. Here is the console
    output of this program for reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: There are third-party libraries (for example, `overload`) available that can
    be used to implement method overloading in a cleaner way.
  prefs: []
  type: TYPE_NORMAL
- en: Method overriding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Having the same method name in a child class as in a parent class is known as
    method overriding. The implementation of a method in a parent class and a child
    class is expected to be different. When we call an overriding method on an instance
    of a child class, the Python interpreter looks for the method in the child class
    definition, which is the overridden method. The interpreter executes the child
    class-level method. If the interpreter does not find a method at a child instance
    level, it looks for it in a parent class. If we have to specifically execute a
    method in a parent class that is overridden in a child class using the child class
    instance, we can use the `super()` method to access the parent class-level method.
    This is a more popular polymorphism concept in Python as it goes hand in hand
    with inheritance and is one of the powerful ways of implementing inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate how to implement method overriding, we will update the `inhertance1.py`
    snippet by renaming the `print_vehicle_info` method name as `print_me`. As we
    know, `print_me` methods are already in the two child classes with different implementations.
    Here is the updated code with the changes highlighted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we override the `print_me` method in the child classes. When
    we create three different instances of `Vehicle`, `Car`, and `Truck` classes and
    execute the same method, we get different behavior. Here is the console output
    as a reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Method overriding has many practical applications in real-world problems—for
    example, we can inherit the built-in `list` class and can override its methods
    to add our functionality. Introducing a custom *sorting* approach is an example
    of method overriding for a `list` object. We will cover a few examples of method
    overriding in the next chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Abstraction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Abstraction is another powerful feature of OOP and is mainly related to hide
    the details of the implementation and show only the essential or high-level features
    of an object. A real-world example is a car that we derive with the main features
    available to us as a driver, without knowing the real details of how the feature
    works and which other objects are involved to provide these features.
  prefs: []
  type: TYPE_NORMAL
- en: Abstraction is a concept that is related to encapsulation and inheritance together,
    and that is why we have kept this topic till the end to understand encapsulation
    and inheritance first. Another reason for having this as a separate topic is to
    emphasize the use of abstract classes in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Abstract classes in Python
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An abstract class acts like a blueprint for other classes. An abstract class
    allows you to create a set of abstract methods (empty) that are to be implemented
    by a child class. In simple terms, a class that contains one or more abstract
    methods is called an abstract **class**. On the other hand, an abstract **method**
    is one that only has a declaration but no implementation.
  prefs: []
  type: TYPE_NORMAL
- en: There can be methods in an abstract class that are already implemented and that
    can be leveraged by a child class (*as is*) using inheritance. The concept of
    abstract classes is useful to implement common interfaces such as **application
    programming interfaces** (**APIs**) and also to define a common code base in one
    place that can be reused by child classes.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Abstract classes cannot be instantiated.
  prefs: []
  type: TYPE_NORMAL
- en: 'An abstract class can be implemented using a Python built-in module called
    `abc` package. The `abc` package also includes the `Abstractmethod` module, which
    utilizes decorators to declare the abstract methods. A simple Python example with
    the use of the `ABC` module and the `abstractmethod` decorator is shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we did the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We made the `Vehicle` class abstract by inheriting it from the `ABC` class and
    also by declaring one of the methods (`print_me`) as an abstract method. We used
    the `@abstractmethod` decorator to declare an abstract method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we updated our famous `Car` class by implementing the `print_me` method
    in it and keeping the rest of the code the same as in the previous example.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the main part of the program, we attempted to create an instance of the `Vehicle`
    class (code commented in the illustration). We created an instance of the `Car`
    class and executed the `print_me` and `hello` methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When we attempt to create an instance of the `Vehicle` class, it gives us an
    error like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Also, if we try to not implement the `print_me` method in the `Car` child class,
    we get an error. For an instance of the `Car` class, we get the expected console
    output from the `print_me` and `hello` methods.
  prefs: []
  type: TYPE_NORMAL
- en: Using composition as an alternative design approach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Composition is another popular concept in OOP that is again somewhat relevant
    to encapsulation. In simple words, composition means to include one or more objects
    inside an object to form a real-world object. A class that includes other class
    objects is called a **composite** class, and the classes whose objects are included
    in a composite class are known as **component** classes. In the following screenshot,
    we show an example of a composite class that has three component class objects,
    **A**, **B**, and **C**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – Relationship between a composite class and its component classes](img/B17189_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – Relationship between a composite class and its component classes
  prefs: []
  type: TYPE_NORMAL
- en: Composition is considered an alternative approach to inheritance. Both design
    approaches are meant to establish a relationship between objects. In the case
    of inheritance, the objects are tightly coupled because any changes in parent
    classes can break the code in child classes. On the other hand, the objects are
    loosely coupled in the case of composition, which facilitates changes in one class
    without breaking our code in another class. Because of the flexibility, the composition
    approach is quite popular, but this does not mean it is the right choice for every
    problem. How, then, can we determine which one to use for which problem? There
    is a rule of thumb for this. When we have an *is a* relationship between objects,
    inheritance is the right choice—for example, a car *is a* vehicle, and a cat *is
    an* animal. In the case of inheritance, a child class is an extension of a parent
    class, with additional functionality and the ability to reuse parent class functionality.
    If the relation between objects is that one object *has* another object, then
    it is better to use composition—for example, a car *has* a battery.
  prefs: []
  type: TYPE_NORMAL
- en: We will take our previous example of the `Car` class and the `Engine` class.
    In the example code for multiple inheritance, we implemented the `Car` class as
    a child of the `Engine` class, which is not really a good use case of inheritance.
    It's time to use composition by implementing the `Car` class with the `Engine`
    object inside the `Car` class. We can have another class for `Seat` and we can
    include it inside the `Car` class as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will illustrate this concept further in the following example, in which
    we build a `Car` class by including `Engine` and `Seat` classes in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We can analyze this example code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We defined `Engine` and `Seat` classes with one attribute in each class: `i_size`
    for the `Engine` class and `i_type` for the `Seat` class.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Later, we defined a `Car` class by adding the `i_color` attribute, an `Engine`
    instance, and a `Seat` instance in it. The `Engine` and `Seat` instances were
    created at the time of creating a `Car` instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this main program, we created an instance of `Car` and performed the following
    actions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'a) `car.print_me`: This accesses the `print_me` method on the `Car` instance.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'b) `print(car.engine`): This executes the `__str__` method of the `Engine`
    class.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'c) `print(car.seat)`: This executes the `__str__` method of the `Seat` class.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'd) `print(car.i_color)`: This accesses the `i_color` attribute of the `Car`
    instance.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'e) `print(car.engine.i_size)`: This accesses the `i_size` attribute of the
    `Engine` instance inside the `Car` instance.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'f) `print(car.seat.i_type)`: This accesses the `i_type` attribute of the `Seat`
    instance inside the `Car` instance'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The console output of this program is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will discuss duck typing, which is an alternative to polymorphism.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing duck typing in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Duck typing**, sometimes referred to as **dynamic typing**, is mostly adopted
    in programming languages that support dynamic typing, such as Python and JavaScript.
    The name *duck typing* is borrowed based on the following quote:'
  prefs: []
  type: TYPE_NORMAL
- en: '"*If it looks like a duck, swims like a duck, and quacks like a duck, then
    it probably is a duck.*"'
  prefs: []
  type: TYPE_NORMAL
- en: This means that if a bird is behaving like a duck, it will likely be a duck.
    The point of mentioning this quote is that it is possible to identify an object
    by its behavior, which is the core principle of duck typing in Python.
  prefs: []
  type: TYPE_NORMAL
- en: In duck typing, the type of class of an object is less important than the method
    (behavior) it defines. Using duck typing, the types of the object are not checked,
    but the method that is expected is executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate this concept, we take a simple example with three classes, `Car`,
    `Cycle`, and `Horse`, and we try to implement a `start` method in each of them.
    In the `Horse` class, instead of naming the method `start`, we call it `push`.
    Here is a code snippet with all three classes and the main program at the end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In the main program, we try to iterate the instances of these classes dynamically
    and call the `start` method. As expected, the `obj.start()` line failed for the
    `Horse` object because the class does not have any such method. As we can see
    in this example, we can put different class or instance types in one statement
    and execute the methods across them.
  prefs: []
  type: TYPE_NORMAL
- en: If we change the method named `push` to `start` inside the `Horse` class, the
    main program will execute without any error. Duck typing has many use cases, where
    it simplifies the solutions. Use of the `len` method in many objects and the use
    of iterators are a couple of many examples. We will explore iterators in detail
    in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have reviewed different object-oriented concepts and principles and
    their benefits. In the next section, we will also discuss briefly when it is not
    very beneficial to use OOP.
  prefs: []
  type: TYPE_NORMAL
- en: Learning when not to use OOP in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python has the flexibility to develop programs using either OOP languages such
    as Java or using declarative programming such as C. OOP is always appealing to
    developers because it provides powerful tools such as encapsulation, abstraction,
    inheritance, and polymorphism, but these tools may not fit every scenario and
    use case. These tools are more beneficial when used to build a large and complex
    application, especially one that involves **user interfaces** (**UIs**) and user
    interactions.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your program is more like a script that has to execute certain tasks and
    there is no need to keep the state of objects, using OOP is overkill. Data science
    applications and intensive data processing are examples where it is less important
    to use OOP but more important to define how to execute tasks in a certain order
    to achieve goals. A real-world example is writing client programs for executing
    data-intensive jobs on a cluster of nodes, such as Apache Spark for parallel processing.
    We will cover these types of applications in later chapters. Here are a few more
    scenarios where using OOP is not necessary:'
  prefs: []
  type: TYPE_NORMAL
- en: Reading a file, applying logic, and writing back to a new file is a type of
    program that is easier to implement using functions in a module rather than using
    OOP.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring devices using Python is very popular and it is another candidate
    to be done using regular functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parsing and transforming data from one format to another format is also a use
    case that can be programmed by using declarative programming rather than OOP.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Porting an old code base to a new one with OOP is not a good idea. We need to
    remember that the old code may not be built using OOP design patterns and we may
    end up with non-OOP functions wrapped in classes and objects that are hard to
    maintain and extend.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In short, it is important to analyze the problem statement and requirements
    first before choosing whether to use OOP or not. It also depends on which third-party
    libraries you will be using with your program. If you are required to extend classes
    from third-party libraries, you will have to go along with OOP in that case.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we learned the concept of classes and objects in Python and
    we also discussed how to build classes and use them to create objects and instances.
    Later, we deep-dived into the four pillars of OOP: encapsulation, inheritance,
    polymorphism, and abstraction. We also worked through simple and clear code examples
    to make it easier for readers to grasp the concepts of OOP. These four pillars
    are fundamental to using OOP in Python.'
  prefs: []
  type: TYPE_NORMAL
- en: In the later sections, we also covered duck typing, which is important for clarifying
    its non-dependency on classes, before ending the chapter by reviewing when it
    is not significantly beneficial to use OOP.
  prefs: []
  type: TYPE_NORMAL
- en: By going through this chapter, you not only refreshed your knowledge of the
    main concepts of OOP but also learned how to apply the concepts using Python syntax.
    We will review a few Python libraries for advanced programming in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are a class and an object?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are dunders?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Does Python support inheriting a class from multiple classes?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can we create an instance of an abstract class?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The type of a class is important in duct typing: true or false?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Modular Programming with Python*, by *Erik Westra*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Python 3 Object-Oriented Programming*, by *Dusty Phillips*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Learning Object-Oriented Programming*, by *Gaston C. Hillar*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Python for Everyone – Third edition*, by *Cay Horstmann* and *Rance Necaise*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A class is a blueprint or a template to tell the Python interpreter how something
    needs to be defined. An object is an instance that is built from a class based
    on what is defined in that class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Dunders are special methods that always start and end with double underscores.
    There are a few dozen special methods available to be implemented with every class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Yes—Python supports inheriting a class from multiple classes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No—we can't create an instance of an abstract class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: False. It is the methods that are more important than the class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
