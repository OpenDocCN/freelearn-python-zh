- en: A
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Quick Primer on reStructuredText
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it comes to writing software documentation, software developers generally
    prefer to use a **lightweight markup language** over binary formats such as DOCX
    or other word processor files. Such languages aim to provide a standardized way
    of notating basic rich-text features like bullet lists, emphasized text, section
    headings, tables, and inline code within the limits of a plaintext file, while
    remaining human-readable. Documents written in lightweight markup languages can
    be read as-is, or compiled into other formats like PDF, DOCX, or HTML.
  prefs: []
  type: TYPE_NORMAL
- en: 'This approach has several advantages over the use of binary word processor
    files:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The documentation can be treated like code: it can be edited with the code
    editor and easily managed with tools like a **Version Control System** (**VCS**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The documentation has universal access: it can be read from any system with
    a text editor, or even from a terminal prompt.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The writing process is less distracting: as markup languages typically focus
    on semantic objects like headings, paragraphs, tables, and so forth rather than
    cosmetic concerns like colors, font faces, or text size, the developer is less
    distracted with appearance details and more focused on organization and correct
    information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the 1990s and earlier, developers tended to use various ASCII-art contrivances
    to convey rich-text features visually, such as tables made of pipes and underscores,
    bullet lists made with asterisks, or headings denoted with a second line of dashes.
    In the early 2000s, several projects worked to formalize and define these structures
    and develop tools that would allow developers to compile their markup into binary
    rich-text formats for distribution or publication.
  prefs: []
  type: TYPE_NORMAL
- en: This book was actually written in a code editor using a markup language, and
    then subsequently converted by scripts to the format required by the publisher.
  prefs: []
  type: TYPE_NORMAL
- en: The reStructuredText markup language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Though several markup language options exist, the Python community tends to
    prefer **reStructuredText** (**RST**). The reStructuredText markup language is
    part of the Python Docutils project, located at [http://docutils.sourceforge.net](http://docutils.sourceforge.net).
    The Docutils project develops the RST standard and provides utilities for converting
    RST to formats like PDF, ODT, HTML, and LaTeX.
  prefs: []
  type: TYPE_NORMAL
- en: Document structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'RST is geared toward the creation of structured documents; as such, the first
    thing we should create is a title for our document. This is denoted using a line
    of symbols above and below a single line of text, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we''ve used the equals sign on either side of the title to denote
    it as our document title. We can also add a subtitle by adding another line underlined
    with a different symbol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The exact symbols used here are not important; they can be any of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: What establishes one as a title and the other as a subtitle is the order. Whichever
    symbol we choose to use first in the document will become the top-level title.
    Whichever we use second will become a second-level title, and so on. By convention,
    the equals sign is typically used for level one, the hyphen for level two, the
    tilde for level three, and the plus symbol for level four. This is only convention,
    however; within a document, the hierarchy is determined by the order in which
    you use the symbols.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can write titles without the top line of symbols as well, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: While not required, this style is usually preferred for section titles over
    the document title. The document title is denoted by creating a top-level section
    header with no content inside, whereas regular section headers have content.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, they can contain paragraphs of text. Paragraphs in RST are indicated
    by a blank line between blocks of text, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note that paragraphs should not be indented. Indenting a line of text would
    indicate some other structure, as we'll see below.
  prefs: []
  type: TYPE_NORMAL
- en: Lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: RST is capable of denoting both bullet and number lists, both of which can contain
    nested lists.
  prefs: []
  type: TYPE_NORMAL
- en: 'Bullet lists are created by starting a line with any of `*`, `-`, or `+` followed
    by a space, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To create a sub-list, simply indent two spaces, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note that the actual symbol used for the list doesn't have any syntactic meaning,
    though it can be helpful for plaintext readers to distinguish sub-lists. Also
    notice that we've created a multi-line bullet point (the last point under `markdown`)
    by indenting the subsequent lines to the same indent as the text in the first
    line of the bullet.
  prefs: []
  type: TYPE_NORMAL
- en: Note the blank lines before the first point in the list, and around each sub-list.
    Lists should always have a blank line before the first item in the list and after
    the last. Lists can optionally contain blank lines between their bullet points,
    which is sometimes helpful for readability.
  prefs: []
  type: TYPE_NORMAL
- en: 'Numbered lists are created like bullet lists, but using either digits or the
    `#` symbol, followed by a dot, as a bullet; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: While the `#` symbol is not very helpful to plaintext readers, conversion programs
    will automatically generate a numbered list in this case. Note that we can nest
    numbered lists or bullet lists within this numbered list.
  prefs: []
  type: TYPE_NORMAL
- en: Character styles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With reStructuredText we can denote a variety of inline character styles, the
    most common of which are emphasis, strong emphasis, and inline literals.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is done by surrounding the text with particular symbols, as shown in this
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Syntax | Use for | Typical rendering |'
  prefs: []
  type: TYPE_TB
- en: '| `*Single asterisks indicate emphasized text*` | Mild emphasis | Italic text
    |'
  prefs: []
  type: TYPE_TB
- en: '| `**Double asterisks are for strongly emphasized text**` | Strong emphasis
    | Bold text |'
  prefs: []
  type: TYPE_TB
- en: '| [PRE8] | Literal examples, such as code | Monospace text, inline whitespace
    preserved |'
  prefs: []
  type: TYPE_TB
- en: Note that there should be no space between the symbol and the text being marked
    up.
  prefs: []
  type: TYPE_NORMAL
- en: Blocks and quotes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When documenting code, it''s quite common that we might need to include a block
    quote from some other source. Simple block quotes can be done in RST by indenting
    a paragraph with four spaces, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In situations where we need to preserve whitespace like indentation and line
    breaks, we can use a **line block**, in which each line begins with a vertical
    bar and a space. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'While your documentation may contain a handful of poems or literary quotes,
    it''s far more likely to need code blocks. A code block in RST is indicated by
    an indented block preceded by a paragraph containing only a double colon, like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Within a code block, whitespace will be preserved (ignoring the initial indent,
    of course), and no RST markup will be interpreted, just as you would expect for
    quoting actual code.
  prefs: []
  type: TYPE_NORMAL
- en: Tables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Tables are commonly needed in documentation, and RST provides two ways of denoting
    them. The simpler but more limited approach looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Using this syntax, we arrange the data in columns using spaces, and surround
    the table and header row with `=` symbols. An empty space through the whole table
    denotes a column break. Note that the symbols must extend as wide as the width
    of the longest cell. This syntax is limited in that it cannot represent multi-line
    cells or cells that span multiple rows or columns.
  prefs: []
  type: TYPE_NORMAL
- en: 'For that, we can use the more verbose table format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In this format, the table cells are defined using hyphens and pipes, with plus
    symbols at the corners of each cell. A cell can be made to span multiple rows
    or columns by simply omitting the border characters between them. For example,
    in the above table, the cell containing `Orange` extends to the bottom of the
    table, and the first row under the header spans the second and third columns.
    Note that table headers are denoted by using an equals symbol rather than a hyphen.
  prefs: []
  type: TYPE_NORMAL
- en: Tables can be tedious to create in a plaintext editor, but some programming
    tools have plugins to generate RST tables. If you plan to make a lot of tables
    in an RST document, you may want to see if your editor has a tool for this.
  prefs: []
  type: TYPE_NORMAL
- en: Converting RST to other formats
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If nothing else, following the reStructuredText syntax leads to a very readable
    and expressive plaintext file. However, the real power in using a standardized
    markup language is in converting it to other formats.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `docutils` package, available in PyPI, comes with several command-line
    utilities for converting RST files. The more useful ones are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Command | Format | Format description |'
  prefs: []
  type: TYPE_TB
- en: '| `rst2html` | Hypertext Markup Language (HTML) | Standard markup language
    for the web, useful for publishing to a website. |'
  prefs: []
  type: TYPE_TB
- en: '| `rst2html5` | Hypertext Markup Language version 5 (HTML 5) | More modern
    version of HTML, preferred for web use. |'
  prefs: []
  type: TYPE_TB
- en: '| `rst2pdf` | Portable Document Format (PDF) | Good for printable documents,
    or for distributing read-only documentation. |'
  prefs: []
  type: TYPE_TB
- en: '| `rst2odt` | Open Document Text (ODT) | Word processing format, useful when
    you want to do further editing in a word processor. |'
  prefs: []
  type: TYPE_TB
- en: '| `rst2latex` | LaTeX markup language | Very powerful markup language often
    used in scientific publications. |'
  prefs: []
  type: TYPE_TB
- en: '| `rst2man` | `MAN` page markup | Markup used by UNIX man pages. Useful for
    documentation on Linux, BSD, or macOS. |'
  prefs: []
  type: TYPE_TB
- en: '| `rst2s5` | Simple standards-based slideshow system (S5) | HTML-based slideshow
    format. Good for presentations. |'
  prefs: []
  type: TYPE_TB
- en: To use any of these commands, simply call it with the name of the RST file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending on the command, an output file can be specified by either an `-o`
    switch or as a second positional argument, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The scripts interpret the markup in the RST file and build a nicely formatted
    PDF or HTML file. You can try these commands on the `README.rst` file included
    with the example code for this appendix, which is a README for the binary release
    of ABQ Data Entry. For example, if you render a default HTML file, it will look
    something like this in your browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Default HTML5 rendering of README.rst](img/Figure_A.1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure A.1: Default HTML5 rendering of README.rst'
  prefs: []
  type: TYPE_NORMAL
- en: 'Each command has a large number of options available, which you can view by
    calling the command with the `--help` switch, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, the `rst2html` command allows us to specify a CSS style sheet
    that will be embedded into the generated HTML file. We can use that to change
    the look of our generated document, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'An `abq_stylesheet.css` file is included with the example code for this book,
    though you can create your own if you know CSS. If you used the bundled file,
    the resulting HTML looks like this in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_A.2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure A.2: The README.rst file, but with a style sheet added'
  prefs: []
  type: TYPE_NORMAL
- en: Other ways to render RST
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In addition to `docutils`, there are other tools that can make use of an RST
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: The `pandoc` utility, available from [https://pandoc.org](https://pandoc.org),
    can convert RST files to a wider variety of output formats with a number of additional
    rendering options.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many popular code-sharing services like GitHub, GitLab, and Bitbucket will automatically
    render RST files to HTML for display in their web interfaces.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Sphinx project, available from [https://sphinx-doc.org](https://sphinx-doc.org),
    is a comprehensive documentation generator for Python projects. It can generate
    complete documentation for your project by rendering RST it finds in docstrings,
    README files, and other documentation in your code. Sphinx is widely used by Python
    projects, including the official Python documentation at [https://docs.python.org](https://docs.python.org).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since RST is widely accepted as the standard for Python documentation, you can
    safely assume that any documentation-oriented tools for Python will expect to
    work with it.
  prefs: []
  type: TYPE_NORMAL
- en: This tutorial only scratched the surface of reStructuredText syntax! For a quick
    syntax reference, see [https://docutils.sourceforge.io/docs/user/rst/quickref.html](https://docutils.sourceforge.io/docs/user/rst/quickref.html).
    For complete documentation, see [https://docutils.sourceforge.io/rst.html](https://docutils.sourceforge.io/rst.html).
  prefs: []
  type: TYPE_NORMAL
