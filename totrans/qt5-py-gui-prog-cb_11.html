<html><head></head><body>
  <div id="sbo-rt-content"><div class="chapter" title="Chapter 11. Best Practices"><div class="titlepage"><div><div><h1 class="title"><a id="ch11"/>Chapter 11. Best Practices</h1></div></div></div><p>In this chapter, we will explore best practices related to our Python GUI.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Avoiding spaghetti code</li><li class="listitem" style="list-style-type: disc">Using __init__ to connect modules</li><li class="listitem" style="list-style-type: disc">Mixing fall-down and OOP coding</li><li class="listitem" style="list-style-type: disc">Using a code naming convention</li><li class="listitem" style="list-style-type: disc">When not to use OOP</li><li class="listitem" style="list-style-type: disc">How to use design patterns successfully</li><li class="listitem" style="list-style-type: disc">Avoiding complexity</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec97"/>Introduction</h1></div></div></div><p>In this chapter, we will explore different best practices that can help us to build our GUI in an efficient way and keep it both maintainable and extendible.</p><p>These best practices will also help us to debug our GUI to get it just the way we want it to be.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Avoiding spaghetti code"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec98"/>Avoiding spaghetti code</h1></div></div></div><p>In this<a id="id494" class="indexterm"/> recipe, we will explore a typical way to create spaghetti code and then we will see a much better way of how to avoid such code.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note157"/>Note</h3><p>Spaghetti code is<a id="id495" class="indexterm"/> code in which a lot of functionality is intertangled.</p></div></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec253"/>Getting ready</h2></div></div></div><p>We will create a new, simple GUI written in Python using the tkinter built-in Python library.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec254"/>How to do it...</h2></div></div></div><p>Having<a id="id496" class="indexterm"/> searched online and read the documentation, we might start by writing the following code to create our GUI:</p><div class="informalexample"><pre class="programlisting"># Spaghetti Code #############################
def PRINTME(me):print(me)
import tkinter 
x=y=z=1
PRINTME(z) 
from tkinter import *
scrolW=30;scrolH=6
win=tkinter.Tk()
if x:chVarUn=tkinter.IntVar()
from tkinter import ttk
WE='WE'
import tkinter.scrolledtext
outputFrame=tkinter.ttk.LabelFrame(win,text=' Type into the scrolled text control: ')
scr=tkinter.scrolledtext.ScrolledText(outputFrame,width=scrolW,height=scrolH,wrap=tkinter.WORD)
e='E'
scr.grid(column=1,row=1,sticky=WE)
outputFrame.grid(column=0,row=2,sticky=e,padx=8)
lFrame=None
if y:chck2=tkinter.Checkbutton(lFrame,text="Enabled",variable=chVarUn)
wE='WE'
if y==x:PRINTME(x) 
lFrame=tkinter.ttk.LabelFrame(win,text="Spaghetti")
chck2.grid(column=1,row=4,sticky=tkinter.W,columnspan=3)  
PRINTME(z)
lFrame.grid(column=0,row=0,sticky=wE,padx=10,pady=10) 
chck2.select()
try: win.mainloop()
except:PRINTME(x)
chck2.deselect()
if y==x:PRINTME(x) 
# End Pasta #############################</pre></div><p>Running the preceding code results in the following GUI:</p><div class="mediaobject"><img src="images/B04829_11_01.jpg" alt="How to do it..."/></div><p>This is <a id="id497" class="indexterm"/>not quite the GUI we intended. We wanted it to look something more like this:</p><div class="mediaobject"><img src="images/B04829_11_02.jpg" alt="How to do it..."/></div><p>While the spaghetti code created a GUI, the code is very hard to debug because there is so much confusion in the code.</p><p>The following is the code that produces the desired GUI:</p><div class="informalexample"><pre class="programlisting">#======================
# imports
#======================
import tkinter as tk
from tkinter import ttk
from tkinter import scrolledtext

#======================
# Create instance
#======================
win = tk.Tk()   

#======================
# Add a title       
#====================== 
win.title("Python GUI")

#=========================
# Disable resizing the GUI
#=========================
win.resizable(0,0)

#=============================================================
# Adding a LabelFrame, Textbox (Entry) and Combobox  
#=============================================================
lFrame = ttk.LabelFrame(win, text="Python GUI Programming Cookbook")
lFrame.grid(column=0, row=0, sticky='WE', padx=10, pady=10)

#=============================================================
# Using a scrolled Text control    
#=============================================================
outputFrame = ttk.LabelFrame(win, text=' Type into the scrolled text control: ')
outputFrame.grid(column=0, row=2, sticky='E', padx=8)
scrolW  = 30
scrolH  =  6
scr = scrolledtext.ScrolledText(outputFrame, width=scrolW, height=scrolH, wrap=tk.WORD)
scr.grid(column=1, row=0, sticky='WE')

#=============================================================
# Creating a checkbutton
#=============================================================
chVarUn = tk.IntVar()
check2 = tk.Checkbutton(lFrame, text="Enabled", variable=chVarUn)
check2.deselect()
check2.grid(column=1, row=4, sticky=tk.W, columnspan=3) 

#======================
# Start GUI
#======================
win.mainloop()</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec255"/>How it works...</h2></div></div></div><p>In this<a id="id498" class="indexterm"/> recipe, we compared spaghetti code to good code. Good code has many advantages over the spaghetti code.</p><p>It has clearly commented sections.</p><p>Spaghetti code:</p><div class="informalexample"><pre class="programlisting">def PRINTME(me):print(me)
import tkinter 
x=y=z=1
PRINTME(z) 
from tkinter import *</pre></div><p>Good code:</p><div class="informalexample"><pre class="programlisting">#======================
# imports
#======================
import tkinter as tk
from tkinter import ttk</pre></div><p>It has a natural flow that follows how the widgets get laid out in the GUI main form.</p><p>In the spaghetti code, the bottom LabelFrame gets created before the top LabelFrame and it is intermixed with an import statement and some widget creation.</p><p>Spaghetti code:</p><div class="informalexample"><pre class="programlisting">import tkinter.scrolledtext
outputFrame=tkinter.ttk.LabelFrame(win,text=' Type into the scrolled text control: ')
scr=tkinter.scrolledtext.ScrolledText(outputFrame,width=scrolW,height=scrolH,wrap=tkinter.WORD)
e='E'
scr.grid(column=1,row=1,sticky=WE)
outputFrame.grid(column=0,row=2,sticky=e,padx=8)
lFrame=None
if y:chck2=tkinter.Checkbutton(lFrame,text="Enabled",variable=chVarUn)
wE='WE'
if y==x:PRINTME(x) 
lFrame=tkinter.ttk.LabelFrame(win,text="Spaghetti")</pre></div><p>Good code:</p><div class="informalexample"><pre class="programlisting">#=============================================================
# Adding a LabelFrame, Textbox (Entry) and Combobox  
#=============================================================
lFrame = ttk.LabelFrame(win, text="Python GUI Programming Cookbook")
lFrame.grid(column=0, row=0, sticky='WE', padx=10, pady=10)

#=============================================================
# Using a scrolled Text control    
#=============================================================
outputFrame = ttk.LabelFrame(win, text=' Type into the scrolled text control: ')
outputFrame.grid(column=0, row=2, sticky='E', padx=8)</pre></div><p>It does<a id="id499" class="indexterm"/> not contain unnecessary variable assignments and neither does it have a <code class="literal">print</code> function that does not do the debugging one might expect it to do when reading the code.</p><p>Spaghetti code:</p><div class="informalexample"><pre class="programlisting">def PRINTME(me):print(me)
x=y=z=1
e='E'
WE='WE'
scr.grid(column=1,row=1,sticky=WE)
wE='WE'
if y==x:PRINTME(x) 
lFrame.grid(column=0,row=0,sticky=wE,padx=10,pady=10) 
PRINTME(z)
try: win.mainloop()
except:PRINTME(x)
chck2.deselect()
if y==x:PRINTME(x) </pre></div><p>Good code:</p><p>Has none of the above.</p><p>The <code class="literal">import</code> statements only import the required modules. They are not cluttered throughout the code. There are no duplicate <code class="literal">import</code> statements. There is no <code class="literal">import *</code> statement.</p><p>Spaghetti code:</p><div class="informalexample"><pre class="programlisting">import tkinter 1
x=y=z=1
PRINTME(z) 
from tkinter import *
scrolW=30;scrolH=6
win=tkinter.Tk()
if x:chVarUn=tkinter.IntVar()
from tkinter import ttk
WE='WE'
import tkinter.scrolledtext</pre></div><p>Good code:</p><div class="informalexample"><pre class="programlisting">import tkinter as tk
from tkinter import ttk
from tkinter import scrolledtext</pre></div><p>The chosen<a id="id500" class="indexterm"/> variable names are quite meaningful. There are no unnecessary <code class="literal">if</code> statements that use the number <code class="literal">1</code> instead of <code class="literal">True</code>.</p><p>Spaghetti code:</p><div class="informalexample"><pre class="programlisting">x=y=z=1
if x:chVarUn=tkinter.IntVar()
wE='WE'</pre></div><p>Good code:</p><div class="informalexample"><pre class="programlisting">#=============================================================
# Using a scrolled Text control    
#=============================================================
outputFrame = ttk.LabelFrame(win, text=' Type into the scrolled text control: ')
outputFrame.grid(column=0, row=2, sticky='E', padx=8)
scrolW  = 30
scrolH  =  6
scr = scrolledtext.ScrolledText(outputFrame, width=scrolW, height=scrolH, wrap=tk.WORD)
scr.grid(column=1, row=0, sticky='WE')</pre></div><p>We did not lose the intended window title and our check button ended up in the correct position. We also made the <code class="literal">LabelFrame</code> surrounding the check button visible.</p><p>Spaghetti code:</p><p>We lost both the window title and did not display the top <code class="literal">LabelFrame</code>. The check button ended up in the wrong place.</p><p>Good code:</p><div class="informalexample"><pre class="programlisting">#======================
# Create instance
#======================
win = tk.Tk()   

#======================
# Add a title       
#====================== 
win.title("Python GUI")

#=============================================================
# Adding a LabelFrame, Textbox (Entry) and Combobox  
#=============================================================
lFrame = ttk.LabelFrame(win, text="Python GUI Programming Cookbook")
lFrame.grid(column=0, row=0, sticky='WE', padx=10, pady=10)

#=============================================================
# Creating a checkbutton
#=============================================================
chVarUn = tk.IntVar()
check2 = tk.Checkbutton(lFrame, text="Enabled", variable=chVarUn)
check2.deselect()
check2.grid(column=1, row=4, sticky=tk.W, columnspan=3) 

#======================
# Start GUI
#======================
win.mainloop()</pre></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Using __init__ to connect modules"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec99"/>Using __init__ to connect modules</h1></div></div></div><p>When<a id="id501" class="indexterm"/> we create a new Python project using the <a id="id502" class="indexterm"/>PyDev plugin for the Eclipse IDE, it automatically creates a <code class="literal">__init__.py</code> module. We can also create it ourselves manually when not using Eclipse.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note158"/>Note</h3><p>The <code class="literal">__init__.py</code> module is usually empty and then has a size of 0 kilobytes.</p></div></div><p>We can use this usually empty module to connect different Python modules by entering code into it. This recipe will show how to do this.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec256"/>Getting ready</h2></div></div></div><p>We will create a new GUI similar to the one we created in the previous recipe.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec257"/>How to do it...</h2></div></div></div><p>As our project becomes larger and larger, we naturally break it out into several Python modules. Using a modern IDE such as Eclipse, it is surprisingly complicated to find modules that are located in different subfolders either above or below the code that needs to import it.</p><p>One practical <a id="id503" class="indexterm"/>way to get around this limitation<a id="id504" class="indexterm"/> is to use the <code class="literal">__init__.py</code> module.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note159"/>Note</h3><p>In Eclipse, we can set the Eclipse internal project environment to certain folders and our Python code will find it. But outside of Eclipse, for example when running from a command window, there is sometimes a mismatch in the Python module import mechanism and the code will not run.</p></div></div><p>Here is a screenshot of the empty <code class="literal">__init__.py</code> module, which appears not with the name <code class="literal">__init__</code> but with the name of the PyDev package it belongs to when opened in the Eclipse code editor. The "1" on the left side of the code editor is the line number and not any code written in this module. There is absolutely no code in this empty <code class="literal">__init__.py</code> module.</p><div class="mediaobject"><img src="images/B04829_11_03.jpg" alt="How to do it..."/></div><p>This file is empty, but it does exist.</p><div class="mediaobject"><img src="images/B04829_11_04.jpg" alt="How to do it..."/></div><p>When we run the following code and click the <code class="literal">clickMe Button</code>, we get the result shown following the code. This <a id="id505" class="indexterm"/>is a regular Python module <a id="id506" class="indexterm"/>that does not yet use the <code class="literal">__init__.py</code> module.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note160"/>Note</h3><p>The __<code class="literal">init__.py</code> module is not the same as the <code class="literal">__init__(self)</code> method of a Python class.</p></div></div><div class="informalexample"><pre class="programlisting">#  Ch11_GUI__init.py
#======================
# imports
#======================
import tkinter as tk
from tkinter import ttk

#======================
# Create instance
#======================
win = tk.Tk()   

#======================
# Add a title       
#====================== 
win.title("Python GUI")

#=============================================================
# Adding a LabelFrame and a Button
#=============================================================
lFrame = ttk.LabelFrame(win, text="Python GUI Programming Cookbook")
lFrame.grid(column=0, row=0, sticky='WE', padx=10, pady=10)

def clickMe():
    from tkinter import messagebox
    messagebox.showinfo('Message Box', 'Hi from same Level.')
    
button = ttk.Button(lFrame, text="Click Me ", command=clickMe)
button.grid(column=1, row=0, sticky=tk.S)  

#======================
# Start GUI
#======================
win.mainloop()</pre></div><div class="mediaobject"><img src="images/B04829_11_05.jpg" alt="How to do it..."/></div><p>In the preceding code, we created the following<a id="id507" class="indexterm"/> function, which imports Python's message box and then uses it to display the message box window:</p><div class="informalexample"><pre class="programlisting">def clickMe():
    from tkinter import messagebox
    messagebox.showinfo('Message Box', 'Hi from same Level.')</pre></div><p>When we move the <code class="literal">clickMe()</code> message box code into a nested directory folder and try to <code class="literal">import</code> it into our GUI module, we run into some problems.</p><p>We have created three sub-folders below where our Python module lives. We then placed the <code class="literal">clickMe()</code> message box code into a new Python module, which we named <code class="literal">MessageBox.py</code>. This module lives in <code class="literal">Folder3</code>, three levels below where our Python module lives.</p><p>We need to import this <code class="literal">MessageBox.py</code> module in order to use the <code class="literal">clickMe()</code> function that this module contains.</p><p>At first, it appears to work because it seems we can import the new nested module as we are not getting any errors or warnings from the Eclipse IDE.</p><p>We are using Python's relative import syntax:</p><div class="informalexample"><pre class="programlisting">from .Folder1.Folder2.Folder3.MessageBox import clickme</pre></div><p>This can be seen in the following screenshot:</p><div class="mediaobject"><img src="images/B04829_11_06.jpg" alt="How to do it..."/></div><p>We <a id="id508" class="indexterm"/>have deleted the local <code class="literal">clickMe()</code> function<a id="id509" class="indexterm"/> and now our callback should use the imported <code class="literal">clickMe()</code> function, but it is not working as expected. Instead of the expected popup window, we get an import system error when we run the code:</p><div class="mediaobject"><img src="images/B04829_11_07.jpg" alt="How to do it..."/></div><p>We can add the subfolder where our new function lives as an external library in Eclipse by going to the PyDev Project properties and adding ourselves as an external library. This does not seem very intuitive, but it does work.</p><div class="mediaobject"><img src="images/B04829_11_08.jpg" alt="How to do it..."/></div><p>When <a id="id510" class="indexterm"/>we now comment out the folder structure<a id="id511" class="indexterm"/> and, instead, directly import the function from the module which is nested to three levels, the code works as expected.</p><div class="informalexample"><pre class="programlisting">#======================
# imports
#======================
import tkinter as tk
from tkinter import ttk
# from .Folder1.Folder2.Folder3.MessageBox import clickMe
from MessageBox import clickMe</pre></div><p>This function displays a different text in a message box:</p><div class="mediaobject"><img src="images/B04829_11_09.jpg" alt="How to do it..."/></div><p>A better <a id="id512" class="indexterm"/>way to achieve the same result is to use<a id="id513" class="indexterm"/> Python's built-in <code class="literal">__init__.py</code> module. </p><p>After deleting the previously Eclipse-specific external library dependency, we can now use this module directly.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note161"/>Note</h3><p>The code we place into this module runs before all of our other code if we import the <code class="literal">__init__.py</code> module into our program, as of Python 3.4.3.</p><p>Ignore the PyDev Unresolved Import (red circle with a cross) error. This <code class="literal">import</code> is necessary; it makes our code run and the entire Python importing mechanism work.</p></div></div><div class="mediaobject"><img src="images/B04829_11_10.jpg" alt="How to do it..."/></div><p>After<a id="id514" class="indexterm"/> importing the <code class="literal">__init__.py</code> module into<a id="id515" class="indexterm"/> our program, we can use it. The first test to check if it works is to code a print statement into this module.</p><div class="mediaobject"><img src="images/B04829_11_11.jpg" alt="How to do it..."/></div><p>By adding the following code, we can find out programmatically where we are located:</p><div class="mediaobject"><img src="images/B04829_11_12.jpg" alt="How to do it..."/></div><p>Now, we <a id="id516" class="indexterm"/>can initialize our Python search path from <a id="id517" class="indexterm"/>within this <code class="literal">__init__.py</code> module by adding the following code to the same <code class="literal">__init__.py</code> module:</p><div class="informalexample"><pre class="programlisting">print('hi from GUI init\n')
from sys import path
from pprint import pprint
#=======================================================
# Required setup for the PYTONPATH in order to find
# all package folders
#=======================================================
from site import addsitedir
from os import getcwd, chdir, pardir
for _ in range(10):
    curFull = getcwd()
    curDir = curFull.split('\\')[-1] 
    if 'B04829_Ch11_Code' == curDir:
        addsitedir(curFull)
        addsitedir(curFull + '\\Folder1\\Folder2\\Folder3\\')
        break
    chdir(pardir)
pprint(path)</pre></div><p>When we now run our GUI code, we get the same expected windows, but we have removed our dependency on the Eclipse <code class="literal">PYTHONPATH</code> variable.</p><p>Now <a id="id518" class="indexterm"/>we can successfully run the same code <a id="id519" class="indexterm"/>outside of the Eclipse PyDev plugin.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note162"/>Note</h3><p>Our code has become more Pythonic.</p></div></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec258"/>How it works...</h2></div></div></div><p>In this recipe, we discovered a limitation of using the PyDev plugin, which comes free with the wonderful and free Eclipse IDE.</p><p>We first found a workaround in the Eclipse IDE, and next, we became independent from this IDE by becoming Pythonic.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note163"/>Note</h3><p>Using pure Python is usually the best way to go.</p></div></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Mixing fall-down and OOP coding"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec100"/>Mixing fall-down and OOP coding</h1></div></div></div><p>Python is an object-oriented programming language yet it does not always make sense to use OOP. For simple scripting tasks, the legacy waterfall coding style is still appropriate.</p><p>In this<a id="id520" class="indexterm"/> recipe, we will create a new GUI that mixes both the fall-down coding style with the more modern OOP coding style.</p><p>We will create an OOP-style class that will display a tooltip when we hover the mouse over a widget in a Python GUI that we will create using a waterfall style.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note164"/>Note</h3><p>Fall-down and waterfall coding styles are the same. It means that we have to physically place code above code before we can call it from the code below. In this paradigm, the code literally falls down from the top of our program to the bottom of our program when we execute the code.</p></div></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec259"/>Getting ready</h2></div></div></div><p>In this recipe, we will create a GUI using tkinter, which is similar to the GUI we created in the first chapter of this book.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec260"/>How to do it...</h2></div></div></div><p>In Python, we can bind functions to classes by turning them into methods using the <code class="literal">self</code> keyword. This is a truly wonderful capability of Python and it allows us to create large systems that are understandable and maintainable.</p><p>Sometimes, when <a id="id521" class="indexterm"/>we only write short scripts, OOP does not make sense because we find ourselves prepending a lot of variables with the <code class="literal">self</code> keyword and the code gets unnecessarily large when it does not need to be.</p><p>Let's first create a Python GUI using tkinter and code it in the waterfall style.</p><p>The following code creates the GUI:</p><div class="informalexample"><pre class="programlisting">#======================
# imports
#======================
import tkinter as tk
from tkinter import ttk
from tkinter import messagebox

#======================
# Create instance
#======================
win = tk.Tk()   

#======================
# Add a title       
#====================== 
win.title("Python GUI")

#=========================
# Disable resizing the GUI
#=========================
win.resizable(0,0)

#=============================================================
# Adding a LabelFrame, Textbox (Entry) and Combobox  
#=============================================================
lFrame = ttk.LabelFrame(win, text="Python GUI Programming Cookbook")
lFrame.grid(column=0, row=0, sticky='WE', padx=10, pady=10)

#=============================================================
# Labels
#=============================================================
ttk.Label(lFrame, text="Enter a name:").grid(column=0, row=0)
ttk.Label(lFrame, text="Choose a number:").grid(column=1, row=0, sticky=tk.W)

#=============================================================
# Buttons click command
#=============================================================
def clickMe(name, number):
    messagebox.showinfo('Information Message Box', 'Hello '+name+
                        ', your number is: ' + number)
    
#=============================================================
# Creating several controls in a loop
#=============================================================
names         = ['name0', 'name1', 'name2']
nameEntries   = ['nameEntry0', 'nameEntry1', 'nameEntry2']

numbers       = ['number0', 'number1', 'number2']
numberEntries = ['numberEntry0', 'numberEntry1', 'numberEntry2']

buttons = []

for idx in range(3):
    names[idx] = tk.StringVar()
    nameEntries[idx] = ttk.Entry(lFrame, width=12, textvariable=names[idx])
    nameEntries[idx].grid(column=0, row=idx+1)
    nameEntries[idx].delete(0, tk.END)
    nameEntries[idx].insert(0, '&lt;name&gt;')

    numbers[idx] = tk.StringVar()
    numberEntries[idx] = ttk.Combobox(lFrame, width=14, textvariable=numbers[idx])
    numberEntries[idx]['values'] = (1+idx, 2+idx, 4+idx, 42+idx, 100+idx)
    numberEntries[idx].grid(column=1, row=idx+1)
    numberEntries[idx].current(0)
  
    button = ttk.Button(lFrame, text="Click Me "+str(idx+1), command=lambda idx=idx: clickMe(names[idx].get(), numbers[idx].get()))
    button.grid(column=2, row=idx+1, sticky=tk.W)  
    buttons.append(button)
#======================
# Start GUI
#======================
win.mainloop()</pre></div><p>When we run the code, we get the GUI and it looks like this:</p><div class="mediaobject"><img src="images/B04829_11_13.jpg" alt="How to do it..."/></div><p>We <a id="id522" class="indexterm"/>can improve our Python GUI by adding tooltips. The best way to do this is to isolate the code that creates the tooltip functionality from our GUI.</p><p>We do this by creating a separate class that has the tooltip functionality, and then we create an instance of this class in the same Python module that creates our GUI.</p><p>Using Python, there is no need to place our <code class="literal">ToolTip</code> class into a separate module. We can place it just above the procedural code and then call it from below this code.</p><p>The code now looks like this:</p><div class="informalexample"><pre class="programlisting">#======================
# imports
#======================
import tkinter as tk
from tkinter import ttk
from tkinter import messagebox

#-----------------------------------------------
class ToolTip(object):
    def __init__(self, widget):
        self.widget = widget
        self.tipwindow = None
        self.id = None
        self.x = self.y = 0

#-----------------------------------------------
def createToolTip(widget, text):
    toolTip = ToolTip(widget)
    def enter(event): toolTip.showtip(text)
    def leave(event): toolTip.hidetip()
    widget.bind('&lt;Enter&gt;', enter)
    widget.bind('&lt;Leave&gt;', leave)

#-----------------------------------------------
# further down the module we call the createToolTip function
#-----------------------------------------------

for idx in range(3):
    names[idx] = tk.StringVar()
    nameEntries[idx] = ttk.Entry(
lFrame, width=12, textvariable=names[idx])
    nameEntries[idx].grid(column=0, row=idx+1)
    nameEntries[idx].delete(0, tk.END)
    nameEntries[idx].insert(0, '&lt;name&gt;')

    numbers[idx] = tk.StringVar()
    numberEntries[idx] = ttk.Combobox(
lFrame, width=14, textvariable=numbers[idx])
    numberEntries[idx]['values'] = (
1+idx, 2+idx, 4+idx, 42+idx, 100+idx)
    numberEntries[idx].grid(column=1, row=idx+1)
    numberEntries[idx].current(0)
  
    button = ttk.Button(
lFrame, text="Click Me "+str(idx+1), command=lambda idx=idx: clickMe(names[idx].get(), numbers[idx].get()))
    button.grid(column=2, row=idx+1, sticky=tk.W)  
    buttons.append(button)

#-----------------------------------------------
    # Add Tooltips to more widgets
    createToolTip(nameEntries[idx], 'This is an Entry widget.') 
    createToolTip(
numberEntries[idx], 'This is a DropDown widget.') 
    createToolTip(buttons[idx], 'This is a Button widget.')
#-----------------------------------------------</pre></div><p>Running<a id="id523" class="indexterm"/> the code creates tooltips for our widgets when we hover the mouse over them.</p><div class="mediaobject"><img src="images/B04829_11_14.jpg" alt="How to do it..."/></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec261"/>How it works...</h2></div></div></div><p>In this <a id="id524" class="indexterm"/>recipe, we created a Python GUI in a procedural way, and later, we added a class to the top of the module.</p><p>We can very easily mix and match both procedural and OOP programming in the same Python module.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Using a code naming convention"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec101"/>Using a code naming convention</h1></div></div></div><p>The previous <a id="id525" class="indexterm"/>recipes in this book have not used a structured code naming convention. This recipe will show you the value of adhering to a code naming scheme because it helps us to find the code we want to extend, as well as reminds us of the design of our program.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec262"/>Getting ready</h2></div></div></div><p>In this recipe, we will look at the Python module names from the first chapter of this book and compare them to better naming conventions.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec263"/>How to do it...</h2></div></div></div><p>In the first chapter of this book, we created our first Python GUI. We improved our GUI by incrementing the different code module names via sequential numbers.</p><p>It looked like this:</p><div class="mediaobject"><img src="images/B04829_11_15.jpg" alt="How to do it..."/></div><p>While this<a id="id526" class="indexterm"/> is a typical way to code, it does not provide much meaning. When we write our Python code during development, it is very easy to increment numbers.</p><p>Later, coming back to this code, we don't have much of an idea which Python module provides which functionality, and sometimes, our last incremented modules are not as good as earlier versions.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note165"/>Note</h3><p>A clear naming convention does help.</p></div></div><p>We can compare the module names from <a class="link" href="ch01.html" title="Chapter 1. Creating the GUI Form and Adding Widgets">Chapter 1</a>, <span class="emphasis"><em>Creating the GUI Form and Adding Widgets</em></span>, to the names from <a class="link" href="ch08.html" title="Chapter 8. Internationalization and Testing">Chapter 8</a>, <span class="emphasis"><em>Internationalization and Testing</em></span>, which are much more meaningful.</p><div class="mediaobject"><img src="images/B04829_11_16.jpg" alt="How to do it..."/></div><p>While<a id="id527" class="indexterm"/> not perfect, the names chosen for the different Python modules, indicate what each module's responsibility is. When we want to add more unit tests, it is clear in which module they reside.</p><p>The following is another example of how to use a code naming convention to create a GUI in Python:</p><div class="mediaobject"><img src="images/B04829_11_17.jpg" alt="How to do it..."/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note166"/>Note</h3><p>Replace the word <code class="literal">PRODUCT</code> with the product you are currently working on.</p></div></div><p>The entire application is a GUI. All parts are connected. The <code class="literal">DEBUG.py</code> module is only used for debugging our code. The main function to invoke the GUI has its name reversed when compared to all of the other modules. It starts with <code class="literal">Gui</code> and ends in a <code class="literal">.pyw</code> extension.</p><p>It is the <a id="id528" class="indexterm"/>only Python module that has this extension name.</p><p>From this naming convention, if you are familiar enough with Python, it will be obvious that, in order to run this GUI, you double-click the <code class="literal">Gui_PRODUCT.pyw</code> module.</p><p>All other Python modules contain functionality to supply to the GUI as well as execute the underlying business logic to fulfil the purpose this GUI addresses.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec264"/>How it works...</h2></div></div></div><p>Naming conventions for Python code modules are a great help in keeping us efficient and remembering our original design. When we need to debug and fix a defect or add new functionality, they are the first resource to look at.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note167"/>Note</h3><p>Incrementing module names by numbers is not very meaningful and eventually wastes development time.</p></div></div><p>On the other hand, naming Python variables is more of a free form. Python infers types, so we do not have to specify that a variable will be of type <code class="literal">&lt;list&gt;</code> (it might not be or actually, later in the code, it might become a different type).</p><p>A good idea for naming variables is to make them descriptive and it is also a good idea not to abbreviate too much.</p><p>If we wish to point out that a certain variable is designed to be of type <code class="literal">&lt;list&gt;</code>, then it is much more intuitive to use the full word <code class="literal">list</code> instead of <code class="literal">lst</code>.</p><p>It is similar for <code class="literal">number</code> instead of <code class="literal">num</code>.</p><p>While it is a good idea to have very descriptive names for variables, sometimes that can get too long. In Apple's Objective-C language, some variable and function names are extreme: <code class="literal">thisIsAMethodThatDoesThisAndThatAndAlsoThatIfYouPassInNIntegers:1:2:3</code>
</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note168"/>Note</h3><p>Use common sense when naming variables, methods, and functions.</p></div></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="When not to use OOP"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec102"/>When not to use OOP</h1></div></div></div><p>Python<a id="id529" class="indexterm"/> comes built-in with object-oriented programming capabilities, but at the same time, we can write scripts that do not need to use OOP.</p><p>For some tasks, OOP does not make sense.</p><p>This recipe will show when not to use OOP.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec265"/>Getting ready</h2></div></div></div><p>In this recipe, we will create a Python GUI similar to previous recipes. We will compare the OOP code to the non-OOP alternative way of programming.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec266"/>How to do it...</h2></div></div></div><p>Let's first create <a id="id530" class="indexterm"/>a new GUI using <span class="strong"><strong>OOP</strong></span> methodology. The following code will create the GUI displayed below the code:</p><div class="informalexample"><pre class="programlisting">import tkinter as tk
from tkinter import ttk
from tkinter import scrolledtext
from tkinter import Menu

class OOP():
    def __init__(self): 
        self.win = tk.Tk()         
        self.win.title("Python GUI")      
        self.createWidgets()

    def createWidgets(self):    
        tabControl = ttk.Notebook(self.win)     
        tab1 = ttk.Frame(tabControl)            
        tabControl.add(tab1, text='Tab 1')    
        tabControl.pack(expand=1, fill="both")  
        self.monty = ttk.LabelFrame(tab1, text=' Monty Python ')
        self.monty.grid(column=0, row=0, padx=8, pady=4)        
        
        ttk.Label(self.monty, text="Enter a name:").grid(
column=0, row=0, sticky='W')
        self.name = tk.StringVar()
        nameEntered = ttk.Entry(
self.monty, width=12, textvariable=self.name)
        nameEntered.grid(column=0, row=1, sticky='W')

        self.action = ttk.Button(self.monty, text="Click Me!")   
        self.action.grid(column=2, row=1)
        
        ttk.Label(self.monty, 
text="Choose a number:").grid(column=1, row=0)
        number = tk.StringVar()
        numberChosen = ttk.Combobox(self.monty, 
width=12, textvariable=number)
        numberChosen['values'] = (42)
        numberChosen.grid(column=1, row=1)
        numberChosen.current(0)
   
        scrolW = 30; scrolH = 3
        self.scr = scrolledtext.ScrolledText(
self.monty, width=scrolW, height=scrolH, wrap=tk.WORD)
        self.scr.grid(column=0, row=3, sticky='WE', columnspan=3)

        menuBar = Menu(tab1)
        self.win.config(menu=menuBar)
        fileMenu = Menu(menuBar, tearoff=0)
        menuBar.add_cascade(label="File", menu=fileMenu)
        helpMenu = Menu(menuBar, tearoff=0)
        menuBar.add_cascade(label="Help", menu=helpMenu)

        nameEntered.focus()     
#==========================
oop = OOP()
oop.win.mainloop()</pre></div><div class="mediaobject"><img src="images/B04829_11_18.jpg" alt="How to do it..."/></div><p>We can achieve the same GUI without using an OOP approach by restructuring our code slightly. First, we remove the <code class="literal">OOP</code> class and its <code class="literal">__init__</code> method.</p><p>Next, we <a id="id531" class="indexterm"/>move all methods to the left and remove the <code class="literal">self</code> class reference which turns them into unbound functions.</p><p>We also remove any other <code class="literal">self</code> references our previous code had. Then, we move the <code class="literal">createWidgets</code> function call below the point of the function's declaration. We place it just above the <code class="literal">mainloop</code> call.</p><p>In the end, we achieve the same GUI but without using OOP.</p><p>The refactored code is shown as follows:</p><div class="informalexample"><pre class="programlisting">import tkinter as tk
from tkinter import ttk
from tkinter import scrolledtext
from tkinter import Menu   

def createWidgets():    
    tabControl = ttk.Notebook(win)     
    tab1 = ttk.Frame(tabControl)            
    tabControl.add(tab1, text='Tab 1')    
    tabControl.pack(expand=1, fill="both")  
    monty = ttk.LabelFrame(tab1, text=' Monty Python ')
    monty.grid(column=0, row=0, padx=8, pady=4)        
    
    ttk.Label(monty, text="Enter a name:").grid(
column=0, row=0, sticky='W')
    name = tk.StringVar()
    nameEntered = ttk.Entry(monty, width=12, textvariable=name)
    nameEntered.grid(column=0, row=1, sticky='W')
    
    action = ttk.Button(monty, text="Click Me!")   
    action.grid(column=2, row=1)
    
    ttk.Label(monty, text="Choose a number:").grid(
column=1, row=0)
    number = tk.StringVar()
    numberChosen = ttk.Combobox(
monty, width=12, textvariable=number)
    numberChosen['values'] = (42)
    numberChosen.grid(column=1, row=1)
    numberChosen.current(0)
    
    scrolW = 30; scrolH = 3
    scr = scrolledtext.ScrolledText(
monty, width=scrolW, height=scrolH, wrap=tk.WORD)
    scr.grid(column=0, row=3, sticky='WE', columnspan=3)
    
    menuBar = Menu(tab1)
    win.config(menu=menuBar)
    fileMenu = Menu(menuBar, tearoff=0)
    menuBar.add_cascade(label="File", menu=fileMenu)
    helpMenu = Menu(menuBar, tearoff=0)
    menuBar.add_cascade(label="Help", menu=helpMenu)
    
    nameEntered.focus()     
#======================
win = tk.Tk()         
win.title("Python GUI")   
createWidgets()
win.mainloop()</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec267"/>How it works...</h2></div></div></div><p>Python<a id="id532" class="indexterm"/> enables us to use OOP when it makes sense. Other languages such as Java and C# force us to always use the OOP approach to coding. In this recipe, we explored a situation when it did not make sense to use OOP.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note169"/>Note</h3><p>The OOP approach will be more extendible if the codebase grows but, if it's certain that it is the only code that's needed then there's no need to go through OOP.</p></div></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="How to use design patterns successfully"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec103"/>How to use design patterns successfully</h1></div></div></div><p>In this<a id="id533" class="indexterm"/> recipe, we will create widgets for our Python GUI by using the factory design pattern.</p><p>In previous recipes, we created our widgets either manually one at a time or dynamically in a loop.</p><p>Using the factory design pattern, we will use the factory to create our widgets.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec268"/>Getting ready</h2></div></div></div><p>We will create a Python GUI which has three buttons each having different styles.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec269"/>How to do it...</h2></div></div></div><p>Towards<a id="id534" class="indexterm"/> the top of our Python GUI module, just below the import statements, we create several classes:</p><div class="informalexample"><pre class="programlisting">import tkinter as tk
from tkinter import ttk
from tkinter import scrolledtext
from tkinter import Menu

class ButtonFactory():
    def createButton(self, type_):
        return buttonTypes[type_]()
            
class ButtonBase():     
    relief     ='flat'
    foreground ='white'
    def getButtonConfig(self):
        return self.relief, self.foreground
    
class ButtonRidge(ButtonBase):
    relief     ='ridge'
    foreground ='red'        
    
class ButtonSunken(ButtonBase):
    relief     ='sunken'
    foreground ='blue'        

class ButtonGroove(ButtonBase):
    relief     ='groove'
    foreground ='green'        

buttonTypes = [ButtonRidge, ButtonSunken, ButtonGroove] 

class OOP():
    def __init__(self): 
        self.win = tk.Tk()         
        self.win.title("Python GUI")      
        self.createWidgets()</pre></div><p>We create a base class which our different button style classes inherit from and in which each of them overrides the <code class="literal">relief</code> and <code class="literal">foreground</code> configuration properties. All subclasses inherit the <code class="literal">getButtonConfig</code> method from this base class. This method returns a tuple.</p><p>We also create a button factory class and a list that holds the names of our button subclasses. We name the list <code class="literal">buttonTypes</code> as our factory will create different types of buttons.</p><p>Further <a id="id535" class="indexterm"/>
<a id="id536" class="indexterm"/>down in the module we create the button widgets, using the same <code class="literal">buttonTypes</code> list.</p><div class="informalexample"><pre class="programlisting">    def createButtons(self):
            
        factory = ButtonFactory()

        # Button 1
        rel = factory.createButton(0).getButtonConfig()[0]
        fg  = factory.createButton(0).getButtonConfig()[1]
        action = tk.Button(self.monty, 
text="Button "+str(0+1), relief=rel, foreground=fg)   
        action.grid(column=0, row=1)  

        # Button 2
        rel = factory.createButton(1).getButtonConfig()[0]
        fg  = factory.createButton(1).getButtonConfig()[1]
        action = tk.Button(self.monty, 
text="Button "+str(1+1), relief=rel, foreground=fg)   
        action.grid(column=1, row=1)  
        
        # Button 3
        rel = factory.createButton(2).getButtonConfig()[0]
        fg  = factory.createButton(2).getButtonConfig()[1]
        action = tk.Button(self.monty, 
text="Button "+str(2+1), relief=rel, foreground=fg)   
       action.grid(column=2, row=1)   </pre></div><p>First, we create an instance of the button factory and then we use our factory to create our buttons.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note170"/>Note</h3><p>The items in the <code class="literal">buttonTypes</code> list are the names of our subclasses.</p></div></div><p>We invoke the <code class="literal">createButton</code> method and then immediately call the <code class="literal">getButtonConfig</code> method of the base class and retrieve the configuration properties using dot notation.</p><p>When we run the entire code, we get the following Python tkinter GUI:</p><div class="mediaobject"><img src="images/B04829_11_19.jpg" alt="How to do it..."/></div><p>We can <a id="id537" class="indexterm"/>see that our Python GUI factory did indeed create different buttons, each having a different style. They differ in the color of their text and in their relief property.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec270"/>How it works...</h2></div></div></div><p>In this recipe, we used the factory design pattern to create several widgets that have different styles. We can easily use this design pattern to create entire GUIs.</p><p>Design patterns are a very exciting tool in our software development toolbox.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Avoiding complexity"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec104"/>Avoiding complexity</h1></div></div></div><p>In this<a id="id538" class="indexterm"/> recipe, we will extend our Python GUI and learn ways to handle the ever-increasing complexity of our software development efforts.</p><p>Our co-workers and clients love the GUIs we create in Python and ask for more and more features to add to our GUI.</p><p>This increases complexity and can easily ruin our original nice design.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec271"/>Getting ready</h2></div></div></div><p>We will create a new Python GUI similar to those in previous recipes and will add many features to it in the form of widgets.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec272"/>How to do it...</h2></div></div></div><p>We will start with a Python GUI that has two tabs and looks like this:</p><div class="mediaobject"><img src="images/B04829_11_20.jpg" alt="How to do it..."/></div><p>The first <a id="id539" class="indexterm"/>new feature request we receive is to add functionality to <span class="strong"><strong>Tab 1</strong></span>, which clears the <code class="literal">scrolledtext</code> widget.</p><p>Easy enough. We just add another button to <span class="strong"><strong>Tab 1</strong></span>.</p><div class="informalexample"><pre class="programlisting">        # Adding another Button
        self.action = ttk.Button(.
self.monty, text="Clear Text", command=self.clearScrol)   
        self.action.grid(column=2, row=2)</pre></div><p>We also have to create the callback method to add the desired functionality, which we define towards the top of our class and outside the method that creates our widgets.</p><div class="informalexample"><pre class="programlisting">    # Button callback
    def clickMe(self):
        self.action.configure(text='Hello ' + self.name.get())
    
    # Button callback Clear Text   
    def clearScrol(self):
        self.scr.delete('1.0', tk.END)</pre></div><p>Now our GUI has a new button and, when we click it, we clear the text of the <code class="literal">ScrolledText</code> widget.</p><div class="mediaobject"><img src="images/B04829_11_21.jpg" alt="How to do it..."/></div><p>In order <a id="id540" class="indexterm"/>to add this functionality, we had to add code in two places in the same Python module.</p><p>We inserted the new button in the <code class="literal">createWidgets</code> method (not shown) and then we created a new callback method, which our new button calls when it is clicked. We placed this code just below the callback of our first button.</p><p>Our next feature request is to add more functionality. The business logic is encapsulated in another Python module. We invoke this new functionality by adding three more buttons to <span class="strong"><strong>Tab 1</strong></span>. We use a loop to do this.</p><div class="informalexample"><pre class="programlisting">        # Adding more Feature Buttons
        for idx in range(3):
            b = ttk.Button(
self.monty, text="Feature" + str(idx+1))   
            b.grid(column=idx, row=4)</pre></div><p>Our GUI now looks like this:</p><div class="mediaobject"><img src="images/B04829_11_22.jpg" alt="How to do it..."/></div><p>Next, our<a id="id541" class="indexterm"/> customers ask for more features and we use the same approach. Our GUI now looks as follows:</p><div class="mediaobject"><img src="images/B04829_11_23.jpg" alt="How to do it..."/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note171"/>Note</h3><p>This is not too bad. When we get new feature requests for another 50 new features, we start to wonder if our approach is still the best approach to use…</p></div></div><p>One <a id="id542" class="indexterm"/>way to handle the ever-increasing complexity our GUI has to handle is by adding tabs. By adding more tabs and placing related features into their own tab, we get control of the complexity and make our GUI more intuitive.</p><p>Here is the code that creates our new <span class="strong"><strong>Tab 3</strong></span> and, below it, is our new Python GUI:</p><div class="informalexample"><pre class="programlisting"># Tab Control 3  -----------------------------------------
        tab3 = ttk.Frame(tabControl)          # Add a tab
        tabControl.add(tab3, text='Tab 3')    # Make tab visible
        
        monty3 = ttk.LabelFrame(tab3, text=' New Features ')
        monty3.grid(column=0, row=0, padx=8, pady=4)

        # Adding more Feature Buttons
        startRow = 4
        for idx in range(24):
            if idx &lt; 2:
                colIdx = idx
                col = colIdx
            else:
                col += 1
            if not idx % 3: 
                startRow += 1
                col = 0

            b = ttk.Button(monty3, text="Feature " + str(idx+1))
            b.grid(column=col, row=startRow)    
            
        # Add some space around each label
        for child in monty3.winfo_children(): 
            child.grid_configure(padx=8)</pre></div><div class="mediaobject"><img src="images/B04829_11_24.jpg" alt="How to do it..."/></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec273"/>How it works...</h2></div></div></div><p>In this recipe, we added several new widgets to our GUI in order to add more functionality to our Python GUI. We saw how more and more new feature requests easily got our nice GUI design into a state where it became less clear how to use the GUI.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note172"/>Note</h3><p>Suddenly, widgets took over the world…</p></div></div><p>We saw <a id="id543" class="indexterm"/>how to handle complexity by modularizing our GUI by breaking large features into smaller pieces and arranging them in functionally-related areas using tabs.</p><p>While complexity has many aspects, modularizing and refactoring code is usually a very good approach to handling software code complexity.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note173"/>Note</h3><p>In programming, at certain times, we run into a wall and get stuck. We keep banging our head against this wall but nothing happens.</p><p>Sometimes we feel like we want to give up.</p><p>However, miracles do happen…</p><p>If we keep on banging against this wall, at a certain moment in time, the wall will collapse and the road will be open.</p><p>At that point in time, we can make a positive dent in the software universe.</p></div></div></div></div></div>
</body></html>