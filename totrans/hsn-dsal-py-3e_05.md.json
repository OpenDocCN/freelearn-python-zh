["```py\ndef b(): \n    print('b') \ndef a(): \n    b() \na() \nprint(\"done\") \n```", "```py\nb\ndone \n```", "```py\nsize = 3\ndata = [0]*(size)   #Initialize the stack\ntop = -1\ndef push(x):\n     global top\n     if top >= size - 1:\n           print(\"Stack Overflow\")\n     else:\n           top = top + 1\n           data[top] = x \n```", "```py\npush('egg')\npush('ham')\npush('spam')\nprint(data[0 : top + 1] ) \npush('new')\npush('new2') \n```", "```py\n['egg', 'ham', 'spam'] \nStack Overflow \nStack Overflow \n```", "```py\ndef pop():\n    global top\n    if top == -1:\n        print(\"Stack Underflow\")\n    else:\n        top = top â€“ 1\n        data[top] = 0\n        return data[top+1] \n```", "```py\nprint(data[0 : top + 1])\npop()\npop()\npop()\npop()\nprint(data[0 : top + 1]) \n```", "```py\n['egg', 'ham', 'spam']\nStack Underflow \n[] \n```", "```py\ndef peek():\n   global top\n   if top == -1:\n       print(\"Stack is empty\")\n   else:\n       print(data[top]) \n```", "```py\nclass Node: \n    def __init__(self, data=None): \n        self.data = data \n        self.next = None \n```", "```py\nStack class:\n```", "```py\nclass Stack: \n    def __init__(self): \n        self.top = None \n        self.size = 0 \n```", "```py\n def push(self, data):\n        # create a new node\n       node = Node(data)\n       if self.top:\n           node.next = self.top\n           self.top = node\n       else: \n           self.top = node\n       self.size += 1 \n```", "```py\nwords = Stack()\nwords.push('egg')\nwords.push('ham')\nwords.push('spam')\n#print the stack elements.\ncurrent = words.top\nwhile current:\n      print(current.data)\n      current = current.next \n```", "```py\nspam\nham\negg \n```", "```py\n def pop(self): \n        if self.top: \n            data = self.top.data \n            self.size -= 1  \n            if self.top.next:  #check if there is more than one node.\n                self.top = self.top.next \n            else: \n                self.top = None \n            return data \n        else: \n            print(\"Stack is empty\") \n```", "```py\nwords.pop()\ncurrent = words.top\nwhile current:\n     print(current.data)\n     current = current.next \n```", "```py\nham\negg \n```", "```py\n def peek(self): \n        if self.top: \n             return self.top.data \n        else: \n            print(\"Stack is empty\") \n```", "```py\nwords.peek() \n```", "```py\nspam \n```", "```py\ndef check_brackets(expression):  \n    brackets_stack = Stack()     #The stack class, we defined in previous section. \n    last = ' ' \n    for ch in expression:  \n        if ch in ('{', '[', '('):  \n            brackets_stack.push(ch)  \n        if ch in ('}', ']', ')'): \n            last = brackets_stack.pop()  \n            if last == '{' and ch == '}': \n                continue  \n            elif last == '[' and ch == ']': \n                continue  \n            elif last == '(' and ch == ')':  \n                continue  \n            else:  \n                return False  \n    if brackets_stack.size > 0: \n        return False  \n    else:\n        return True \n```", "```py\nsl = ( \n   \"{(foo)(bar)}[hello](((this)is)a)test\", \n   \"{(foo)(bar)}[hello](((this)is)atest\", \n   \"{(foo)(bar)}[hello](((this)is)a)test))\" \n) \nfor s in sl: \n   m = check_brackets(s) \n   print(\"{}: {}\".format(s, m)) \n```", "```py\n{(foo)(bar)}[hello](((this)is)a)test: True\n{(foo)(bar)}[hello](((this)is)atest: False \n{(foo)(bar)}[hello](((this)is)a)test)): False \n```", "```py\nclass ListQueue: \n    def __init__(self): \n        self.items = [] \n        self.front = self.rear = 0\n        self.size = 3     # maximum capacity of the queue \n```", "```py\n def enqueue(self, data):  \n        if self.size == self.rear:\n            print(\"\\n Queue is full\")\n        else:   \n            self.items.append(data)  \n            self.rear += 1 \n```", "```py\nq= ListQueue()\nq.enqueue(20)\nq.enqueue(30)\nq.enqueue(40)\nq.enqueue(50)\nprint(q.items) \n```", "```py\nQueue is full\n[20, 30, 40] \n```", "```py\n def dequeue(self):\n        if self.front == self.rear:\n            print(\"Queue is empty\")\n        else:\n            data = self.items.pop(0)    # delete the item from front end of the queue        \n            self.rear -= 1\n            return data \n```", "```py\ndata = q.dequeue()\nprint(data)\nprint(q.items) \n```", "```py\n20\n[30, 40] \n```", "```py\nclass Node(object):\n    def __init__(self, data=None, next=None, prev=None):\n        self.data = data\n        self.next = next\n        self.prev = prev\nclass Queue: \n    def __init__(self): \n        self.head = None \n        self.tail = None \n        self.count = 0 \n```", "```py\n def enqueue(self, data): \n        new_node = Node(data, None, None) \n        if self.head == None: \n            self.head = new_node \n            self.tail = self.head \n        else: \n            new_node.prev = self.tail \n            self.tail.next = new_node \n            self.tail = new_node \n        self.count += 1 \n```", "```py\n def dequeue(self): \n        if self.count == 1: \n            self.count -= 1 \n            self.head = None \n            self.tail = None \n        elif self.count > 1: \n            self.head = self.head.next \n            self.head.prev = None \n        elif self.count <1:\n            print(\"Queue is empty\")\n        self.count -= 1 \n```", "```py\nclass Queue: \n    def __init__(self): \n        self.Stack1 = [] \n        self.Stack2 = [] \n```", "```py\ndef enqueue(self, data): \n    self.Stack1.append(data) \n```", "```py\nqueue = Queue() \nqueue.enqueue(23) \nqueue.enqueue(13) \nqueue.enqueue(11) \nprint(queue.Stack1) \n```", "```py\n[23, 13, 11] \n```", "```py\n def dequeue(self):   \n        if not self.Stack2:  \n            while self.Stack1:  \n                self.Stack2.append(self.Stack1.pop())  \n        if not self.Stack2:\n            print(\"No element to dequeue\")\n            return\n        return self.Stack2.pop() \n```", "```py\nreturn self.Stack2.pop() \n```", "```py\nwhile self.Stack1: \n    self.Stack2.append(self.Stack1.pop()) \n```", "```py\nqueue = Queue()  \nqueue.enqueue(23)  \nqueue.enqueue(13)  \nqueue.enqueue(11)  \nprint(queue.Stack1) \n\nqueue.dequeue()    \nprint(queue.Stack2) \n```", "```py\n [23, 13, 11] \n [13, 11] \ndequeue method is called, after which a change in the number of elements is observed when the queue is printed out again.\n```", "```py\nfrom random import randint \nclass Track: \n    def __init__(self, title=None): \n        self.title = title \n        self.length = randint(5, 10) \n```", "```py\ntrack1 = Track(\"white whistle\") \ntrack2 = Track(\"butter butter\") \nprint(track1.length) \nprint(track2.length) \n```", "```py\n6\n7 \n```", "```py\nimport time \nclass MediaPlayerQueue(Queue): \n```", "```py\n def add_track(self, track):\n        self.enqueue(track) \n```", "```py\ndef play(self):\n        while self.count > 0:\n            current_track_node = self.dequeue()\n            print(\"Now playing {}\".format(current_track_node.data.title)) \n            time.sleep(current_track_node.data.length) \n```", "```py\ntime.sleep(current_track_node.data.length) \n```", "```py\ntrack1 = Track(\"white whistle\") \ntrack2 = Track(\"butter butter\") \ntrack3 = Track(\"Oh black star\") \ntrack4 = Track(\"Watch that chicken\") \ntrack5 = Track(\"Don't go\") \n```", "```py\nprint(track1.length) \nprint(track2.length) \n```", "```py\n 8\n 9 \n```", "```py\nmedia_player = MediaPlayerQueue() \n```", "```py\nmedia_player.add_track(track1) \nmedia_player.add_track(track2) \nmedia_player.add_track(track3) \nmedia_player.add_track(track4) \nmedia_player.add_track(track5) \nmedia_player.play() \n```", "```py\n Now playing white whistle\n    Now playing butter butter\n    Now playing Oh black star\n    Now playing Watch that chicken\n    Now playing Don't go \n```"]