<html><head></head><body>
        

                            
                    <h1 class="header-title">Multiple Fun Projects</h1>
                
            
            
                
<p class="mce-root">By now, we have explored most of the important features of Tkinter. Let's use this chapter to explore aspects of programming that, though not core to Tkinter, are often encountered while writing GUI applications.<br/></p>
<p class="mce-root">In this chapter, we will develop several small applications from different domains. The applications we will build here include:</p>
<ul>
<li class="mce-root">A snake game application </li>
<li class="mce-root">A weather reporter application </li>
<li class="mce-root">A port scanner application </li>
<li class="mce-root">A chat application </li>
<li class="mce-root">A phone book application</li>
<li>An ultrasound distance scanner application </li>
</ul>
<p>Some of the key objectives of the chapter are:</p>
<ul>
<li>To learn to use <kbd>Queue</kbd> module to avoid race conditions and other synchronization issues involved in writing multithreaded programs</li>
<li>To understand the basics of data mining over the network</li>
<li>To understand socket programming and to learn the basics of server-client architecture</li>
<li>To learn database programming</li>
<li>To learn to use <kbd>asyncio</kbd> with Tkinter</li>
<li>To learn how to interface and interact with external hardware components using serial communication</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Technical requirements</h1>
                
            
            
                
<p>Most of the projects in this chapter rely on the standard libraries and do not require anything extra. The exception is the ultrasonic range finder project, which requires an Arduino board and an ultrasonic range finder sensor.  The hardware is relatively cheap (under 10 dollars). You may also decide not to buy the hardware and still read the project to understand how serial communication takes place between two pieces of equipment.</p>
<p>In addition, you will also need to download and install the Arduino <strong>integrated development environment</strong> (<strong>IDE</strong>), the details of which will be discussed in the project itself. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Building a Snake game</h1>
                
            
            
                
<p>Let's now build a simple Snake game. As usual, we will be making use of the <kbd>Canvas</kbd> widget to provide the platform for our Snake program. We will use <kbd>canvas.create_line</kbd> to draw our snake and <kbd>canvas.create_rectangle</kbd> to draw the snake food.</p>
<p>The primary objective of this project is to learn how to use <kbd>Queue</kbd> module as a <strong>synchronization technique</strong> in a multithreaded application.</p>
<p>Writing a multithreaded application poses the challenge of synchronization between different threads. When multiple threads try to access shared data simultaneously, the data is likely to get corrupted or modified in ways that were not intended in the program. This is called a <strong>race condition</strong>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Understanding a race condition</h1>
                
            
            
                
<p>The <kbd>9.01_race_condition.py</kbd> code demonstrates a race condition. The program is as follows:</p>
<pre>import threading<br/><br/>class RaceConditionDemo:<br/>  def __init__(self):<br/>    self.shared_var = 0<br/>    self.total_count = 100000<br/>    self.demo_of_race_condition()<br/><br/>  def increment(self):<br/>    for i in range(self.total_count):<br/>      self.shared_var += 1<br/><br/>  def decrement(self):<br/>    for i in range(self.total_count):<br/>      self.shared_var -= 1<br/><br/>  def demo_of_race_condition(self):<br/>    t1 = threading.Thread(target=self.increment)<br/>    t2 = threading.Thread(target=self.decrement)<br/>    t1.start()<br/>    t2.start()<br/>    t1.join()<br/>    t2.join()<br/>    print("value of shared_var after all increments &amp; decrements :", self.shared_var)<br/><br/>if __name__ == "__main__":<br/>  for i in range(100):<br/>     RaceConditionDemo()</pre>
<p>The preceding code consists of two methods named <kbd>increment</kbd> and <kbd>decrement</kbd> that both operate on a single shared variable named <kbd>shared_var</kbd>. These two methods are called from separate threads.</p>
<p>One would expect that an equal number of increments and decrements on a shared variable would produce no change in its value at the end. However, when you run this program, say 100 times as before, it produces a different value for the shared variable in each consecutive run. This is a classic example for how a race condition can make the output of a program nondeterministic.</p>
<p>Race conditions occur because we cannot predict the thread execution order at all. The operating system does it very randomly and so the execution order of threads varies each time the program is run.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using synchronization primitives</h1>
                
            
            
                
<p>To handle this complexity, the <kbd>threading</kbd> module provides some synchronization primitives, such as locks, joins, semaphores, events, and condition variables.</p>
<p><kbd>9.02_lock_demo.py</kbd> slightly modifies the preceding code by introducing a <kbd>lock</kbd> using this line:</p>
<pre>self.lock = threading.Lock()</pre>
<p>Next, every time <kbd>shared_variable</kbd> is to be modified, it is done after acquiring a <kbd>lock</kbd>. The <kbd>lock</kbd> is released when the variable has been modified, as shown in the following code:</p>
<pre>self.lock.acquire()<br/>self.shared_var += 1<br/>self.lock.release()</pre>
<p>This enables us to avoid a race condition. Since this code operates with a <kbd>lock</kbd>, it produces no change in the shared variable after an equal number of increments and decrements.</p>
<p>It seemed easy to use the <kbd>lock</kbd> mechanism to avoid a race condition. However, as the complexity of a program grows, there are many places where a variable may be modified. Tracking large code bases for places where a variable may be changed is often a difficult task.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using queues</h1>
                
            
            
                
<p>In most cases, it is safer and simpler to use <strong>queues</strong>. Simply put, a queue is a compound memory structure that is thread-safe. Queues effectively channel access to a resource to multiple threads in a sequential order, and are a recommended design pattern that uses threads for most of the scenarios that require concurrency.</p>
<p>The <kbd>Queue</kbd> module provides a way to implement different kinds of queuing, such as FIFO (default implementation), LIFO queues, and priority queues, and this module comes with a built-in implementation of all the locking semantics required for running multithreaded programs.</p>
<p>Here's a quick roundup of the basic usage of the <kbd>Queue</kbd> module:</p>
<pre>my_queue = Queue() #create empty queue<br/>my_queue.put(data)# put items into queue<br/>task = my_queue.get () #get the next item in the queue<br/>my_queue.task_done() # called when a queued task has completed<br/>my_queue.join() # awaits for all tasks in queue to get completed</pre>
<p>Let's see a simple demonstration of using a queue to implement a multithreaded application (see <kbd>9.03_threading_with_queue.py</kbd>):</p>
<pre>import queue<br/>import threading<br/><br/>class Consumer(threading.Thread):<br/> <br/>  def __init__(self, queue):<br/>   threading.Thread.__init__(self)<br/>   self.queue = queue<br/> <br/>  def run(self):<br/>    while True:<br/>      task = self.queue.get()<br/>      self.do_task(task)<br/> <br/>  def do_task(self, task):<br/>    print ('doing task{}'.format(task))<br/>    self.queue.task_done()<br/><br/> <br/>def producer(tasks):<br/>    my_queque = queue.Queue()<br/>    # populate queue with tasks<br/>    for task in tasks:<br/>      my_queque.put(task)<br/>    # create 6 threads and pass the queue as its argument<br/>    for i in range(6):<br/>      my_thread = Consumer(my_queque)<br/>      my_thread.daemon = True<br/>      my_thread.start()<br/>    # wait for the queue to finish<br/>    my_queque.join()<br/>    print ('all tasks completed')<br/><br/>if __name__ == "__main__":<br/>  tasks = 'A B C D E F'.split()<br/>  producer(tasks)</pre>
<p>The description of the code is as follows:</p>
<ul>
<li>We first create a <kbd>Consumer</kbd> class, which inherits from the <kbd>threading</kbd> module of Python. The <kbd>__init__</kbd> method takes in a queue as its argument. </li>
<li>We then override the <kbd>run</kbd> method of the <kbd>threading</kbd> module to get each item from the queue using <kbd>queue.get()</kbd>, which is then passed on to the <kbd>task_handler</kbd> method, which actually executes the task specified in the current queue item. In our example, it does nothing useful except print the name of the task.</li>
<li>After the work is done on a particular thread by our <kbd>task_handler</kbd> method, it sends a signal to the queue telling it that the task has been completed using the <kbd>queue.task_done()</kbd> method.</li>
<li>Outside our <kbd>Consumer</kbd> class, we create an empty queue in our <kbd>producer()</kbd> module function. This queue is populated with a list of tasks using <kbd>queue.put(task)</kbd>.</li>
<li>We then create six different threads and pass this populated queue as its argument. Now that the tasks are handled by the queue, all threads automatically ensure that the tasks are completed in the sequence in which they are encountered by the threads, without causing any deadlocks or two different threads trying to work on the same queued task.</li>
<li>At the time of creating each thread, we also create a pool of daemon threads using <kbd>my_thread.daemon = True</kbd>. Doing this passes control to our main program once all threads have completed execution. If you comment out the line, the program would still run, but would fail to exit after all threads have completed executing the tasks in the queue. Without the daemon threads, you'd have to keep track of all the threads and tell them to exit before your program could completely quit. </li>
<li>Finally, the <kbd>queue.join()</kbd> method ensures that the program flow waits there until all queued tasks are actually done and the queue is empty.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Building the Snake game</h1>
                
            
            
                
<p>With that background information about using a queue to handle multithreaded applications, let's build our Snake game.</p>
<p>Upon completion, the game will look as follows:</p>
<div><img height="154" src="img/dbe3da18-357d-4e24-93fb-0ecdd3be9304.png" width="239"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">The View class</h1>
                
            
            
                
<p>Let's start coding our game by first creating a basic <kbd>View</kbd> class. This class will be responsible for creating the GUI, checking for <em>game over</em> logic, and most importantly acting as the consumer, taking items from the queue and processing them to update the view (see <kbd>9.04_game_of_snake.py</kbd>):</p>
<pre>class View(Tk):<br/>  def __init__(self, queue):<br/>    Tk.__init__(self)<br/>    self.queue = queue<br/>    self.create_gui()<br/><br/>  def create_gui(self):<br/>    self.canvas = Canvas(self, width=495, height=305, bg='#FF75A0')<br/>    self.canvas.pack()<br/>    self.snake = self.canvas.create_line((0, 0), (0,0),fill='#FFCC4C', <br/>      width=10)<br/>    self.food = self.canvas.create_rectangle(0, 0, 0, 0,  <br/>      fill='#FFCC4C', outline='#FFCC4C')<br/>    self.points_earned = self.canvas.create_text(455, 15, fill='white', <br/>      text='Score:0')</pre>
<p>The preceding code should be mostly familiar to you by now as we have written similar code in the past. Note, however, that rather than passing the root instance as an argument to its <kbd>__init__</kbd> method, our <kbd>View</kbd> class now inherits from the <kbd>Tk</kbd> class. The line <kbd>Tk.__init__(self)</kbd> ensures that the root window is available to all methods of this class. This way we can avoid writing a root attribute on every line by referencing root simply as <kbd>self</kbd>.</p>
<p>This class will also have code to process items put in the queue. We will code the rest of this class after we have coded the classes that put items in the queue.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The Food class</h1>
                
            
            
                
<p>Next, we will create the <kbd>Food</kbd> class (see <kbd>9.04_game_of_snake.py</kbd>):</p>
<pre>class Food:<br/><br/>def __init__(self, queue):<br/> self.queue = queue<br/> self.generate_food()<br/><br/>def generate_food(self):<br/> x = random.randrange(5, 480, 10)<br/> y = random.randrange(5, 295, 10)<br/> self.position = (x, y)<br/> rectangle_position = (x - 5, y - 5, x + 5, y + 5)<br/> self.queue.put({'food': rectangle_position})</pre>
<p>The description of the code is as follows:</p>
<ul>
<li>Because we want to process all data centrally from within a queue, we pass the queue as an argument to the <kbd>__init__</kbd> method of the <kbd>Food</kbd> class.</li>
<li>The <kbd>__init__</kbd> method calls another method called <kbd>generate_food</kbd>, which is responsible for generating the snake food at random positions on the canvas.</li>
<li>The <kbd>generate_food</kbd> method generates a random (<kbd>x</kbd>, <kbd>y</kbd>) position on the canvas. However, because the place where the coordinates coincide is just a small point on the canvas, it would be barely visible. We, therefore, generate an expanded coordinate (<kbd>rectangle_position</kbd> ) ranging from five values less than the (<kbd>x</kbd>, <kbd>y</kbd>) coordinate up to five values higher than the same coordinate. Using this range, we can create a small rectangle on the canvas that would be easily visible and would represent our food.</li>
<li>However, we do not create the rectangle here. Instead, we pass the coordinates for the food (rectangle) into our queue using <kbd>queue.put</kbd>.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">The Snake class</h1>
                
            
            
                
<p>Let's now create the <kbd>Snake</kbd> class. We have already passed a task to generate our food to the central queue. However, no additional thread was involved in the task. We could also generate our <kbd>Snake</kbd> class without using threads. However, because we are talking about ways to implement multithreaded applications, let's implement our <kbd>Snake</kbd> class to work from a separate thread (see <kbd>9.04_game_of_snake.py</kbd>):</p>
<pre>class Snake(threading.Thread):<br/>  <br/>  is_game_over = False<br/><br/>  def __init__(self, queue):<br/>    threading.Thread.__init__(self)<br/>    self.queue = queue<br/>    self.daemon = True<br/>    self.points_earned = 0<br/>    self.snake_points = [(495, 55), (485, 55), (475, 55), (465, 55), <br/>      (455, 55)]<br/>    self.food = Food(queue)<br/>    self.direction = 'Left'<br/>    self.start()<br/><br/>  def run(self):<br/>    while not self.is_game_over:<br/>      self.queue.put({'move': self.snake_points})<br/>    time.sleep(0.1)<br/>    self.move()<br/><br/>  def on_keypress(self, e):<br/>    self.direction = e.keysym<br/><br/>  def move(self):<br/>   new_snake_point = self.calculate_new_coordinates()<br/>   if self.food.position == new_snake_point:<br/>     self.points_earned += 1<br/>     self.queue.put({'points_earned': self.points_earned})<br/>     self.food.generate_food()<br/>   else:<br/>     self.snake_points.pop(0)<br/>   self.check_game_over(new_snake_point)<br/>   self.snake_points.append(new_snake_point)<br/><br/>  def calculate_new_coordinates(self):<br/>    last_x, last_y = self.snake_points[-1]<br/>    if self.direction == 'Up':<br/>      new_snake_point = (last_x, last_y - 10)<br/>    elif self.direction == 'Down':<br/>      new_snake_point = (last_x, last_y + 10)<br/>    elif self.direction == 'Left':<br/>      new_snake_point = (last_x - 10, last_y)<br/>    elif self.direction == 'Right':<br/>      new_snake_point = (last_x + 10, last_y)<br/>    return new_snake_point<br/><br/>  def check_game_over(self, snake_point):<br/>    x, y = snake_point<br/>    if not -5 &lt; x &lt; 505 or not -5 &lt; y &lt; 315 or snake_point in self.snake_points:<br/>      self.is_game_over = True<br/>      self.queue.put({'game_over': True})</pre>
<p>The description of the code is as follows:</p>
<ul>
<li>We create a class named <kbd>Snake</kbd> to run from a separate thread. This class takes the <kbd>queue</kbd> as its input arguments.</li>
<li>We initialize the points earned by the player from zero and set the initial location of the snake using the attribute <kbd>self.snake_points</kbd>. Note that initially, the snake is <kbd>40</kbd> pixels long.</li>
<li>Finally, we start the thread and create an infinite loop to call the <kbd>move()</kbd> method at small intervals. During every run of the loop, the method populates the <kbd>queue</kbd> with a dictionary having the key as move and the value equal to the updated position of the snake, through the <kbd>self.snake_points</kbd> attribute.</li>
<li>First, the <kbd>move</kbd> method obtains the latest coordinates for the snake depending on the keyboard event. It uses a separate method called <kbd>calculate_new_coordinates</kbd> to get the latest coordinates.</li>
<li>It then checks whether the location of the new coordinates coincides with the location of the food. If they match, it increases the score of the player by one and calls the <kbd>Food</kbd> class' <kbd>generate_food</kbd> method to generate a new food at a new location.</li>
<li>If the current point does not coincide with the food coordinates, it deletes the first item from the snake coordinates using <kbd>self.snake_points.pop(0)</kbd>.</li>
<li>Then, it calls another method named <kbd>check_game_over</kbd> to check whether the snake collides with the wall or itself. If the snake does collide, it appends a new dictionary item in the queue with the value <kbd>'game_over':True</kbd>.</li>
<li>Finally, if the game is not over, it appends the new position of the snake to the list <kbd>self.snake_points</kbd>. This is automatically added to the queue, because we have defined <kbd>self.queue.put({'move': self.snake_points } )</kbd> in the <kbd>Snake</kbd> class's <kbd>run()</kbd> method to update every <kbd>0.1</kbd> seconds as long as the game is not over.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Queue handler</h1>
                
            
            
                
<p>Now that the queue is getting populated with various actionables, let's create the <kbd>queue_handler</kbd> method to process the items in the queue and update the <kbd>View</kbd> accordingly.</p>
<p>We define the <kbd>queue_handler()</kbd> method in our <kbd>View</kbd> class as follows:</p>
<pre>def queue_handler(self):<br/> try:<br/>   while True:<br/>     task = self.queue.get_nowait()<br/>     if 'game_over' in task:<br/>       self.game_over()<br/>     elif 'move' in task:<br/>       points = [x for point in task['move'] for x in point]<br/>       self.canvas.coords(self.snake, *points)<br/>     elif 'food' in task:<br/>       self.canvas.coords(self.food, *task['food'])<br/>     elif 'points_earned' in task:<br/>       self.canvas.itemconfigure(self.points_earned, text='Score:  <br/>                               {}'.format (task['points_earned'])) <br/>     self.queue.task_done()<br/> except queue.Empty:<br/>   self.after(100, self.queue_handler)</pre>
<p>The description for the code is as follows:</p>
<ul>
<li>The <kbd>queue_handler</kbd> method gets into an infinite loop looking for tasks in the queue using <kbd>task = self.queue.get_nowait()</kbd>. If the queue becomes empty, the loop is restarted using <kbd>canvas.after</kbd>.</li>
<li>When we use <kbd>queue_get_nowait()</kbd>, the call does not block the calling thread until an item is available. It removes and returns an item from the queue, if available. If the queue is empty, it raises <kbd>Queue.Empty</kbd>.</li>
<li>Once a task is fetched from the queue, the method checks its key.</li>
<li>If the key is <kbd>game_over</kbd>, it calls another method named <kbd>game_over()</kbd> which we define next.</li>
<li>If the key of the task is <kbd>move</kbd>, it uses <kbd>canvas.coords</kbd> to move the line to its new position.</li>
<li>If the key is <kbd>points_earned</kbd>, it updates the score on the canvas.</li>
</ul>
<p>When the execution of a task completes, it signals the thread with the <kbd>task_done()</kbd> method. Finally, we create the main loop as follows:</p>
<pre>def main():<br/>  q = queue.Queue()<br/>  gui = View(q)<br/>  snake = Snake(q)<br/>  for key in ("Left", "Right", "Up", "Down"):<br/>    gui.bind("&lt;Key-{}&gt;".format(key), snake.on_keypress)<br/>    gui.mainloop()<br/> <br/>if __name__ == '__main__':<br/>  main()</pre>
<p>Our game is now functional. Go and try controlling the snake while keeping its stomach filled.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a Weather Reporter application</h1>
                
            
            
                
<p>Let's now build a simple Weather Reporter application. The weather data for any given location will be fetched from the network, suitably formatted, and presented to the user.</p>
<p>We will use a higher level module named <kbd>urllib</kbd> to fetch weather data from the web. The <kbd>urllib</kbd> module is part of Python's standard library and it provides an easy to use API for working with URLs. It has four submodules:</p>
<ul>
<li><kbd>urllib.request</kbd>: For opening and reading URLs</li>
<li><kbd>urllib.error</kbd>: For handling exceptions raised by <kbd>urllib.request</kbd></li>
<li><kbd>urllib.parse</kbd>: For parsing URLs</li>
<li><kbd>urllib.robotparser</kbd>: For parsing <kbd>robots.txt</kbd> files</li>
</ul>
<p>With <kbd>urllib.request</kbd>, fetching the contents of a web page turns into three lines of code   (see <kbd>9.05_urllib_demo.py</kbd>):</p>
<pre>import urllib.request<br/><br/>with urllib.request.urlopen('http://www.packtpub.com/') as f:<br/>  print(f.read())</pre>
<p>This prints the entire HTML source code or whatever is the response from the web page <a href="http://www.packtpub.com">http://www.packtpub.com</a>. This is, in essence, the core of mining the web for information.</p>
<p>Now that we know how to get data from a URL, let's apply it to building our Weather Reporter application. This application should take the location as an input from the user and fetch relevant weather-related data, as shown in the following screenshot:</p>
<div><img height="336" src="img/62812610-8b31-43db-915d-8da3ee60cbf7.png" width="239"/></div>
<p>We create a class, <kbd>WeatherReporter</kbd>, and call it from outside the class within the <kbd>mainloop</kbd> (see the code of <kbd>9.06_weather_reporter.py</kbd>):</p>
<pre>def main():<br/>  root=Tk()<br/>  WeatherReporter(root)<br/>  root.mainloop()<br/><br/>if __name__ == '__main__':<br/>  main()</pre>
<p>We do not discuss the code for creating this GUI here, as we have done similar coding many times in all the the previous chapters. The weather data is displayed on a canvas (see <kbd>9.06_weather_reporter.py</kbd>):</p>
<p>When you specify a location and click on the <strong>Go</strong> button, it calls a command callback named <kbd>on_show_weather_button_clicked</kbd>.</p>
<p>We then fetch the weather data from a website.</p>
<p>There are two ways to fetch data from a website. The first method involves getting an HTML response from a website, and then parsing the received HTML response for data that is relevant to us. This type of data extraction is called <strong>site scraping</strong>.</p>
<p><strong>Scrapy</strong> and <strong>Beautiful Soup</strong> are two popular site-scraping frameworks for extracting data from websites. You can find the official documentation of the two libraries at <a href="http://scrapy.org/">http://scrapy.org/</a> and <a href="http://www.crummy.com/software/BeautifulSoup/">http://www.crummy.com/software/BeautifulSoup/</a>.</p>
<p>Site scraping is a rather crude method that is employed only when a given website does not provide a structured way to retrieve data. On the other hand, some websites are willing to share data through a set of APIs, provided you query it for data using the specified URL structure. This is clearly more elegant than site scraping, because data is interchanged in a reliable and <em>mutually agreed</em> format.</p>
<p>For our Weather Reporter application, we want to query some weather channels for a given location, and in turn retrieve and display the data on our canvas.</p>
<p>Fortunately, there are several weather APIs that we can use. In our example, we will use the weather data provided by the following website:<br/>
<a href="http://openweathermap.org/">http://openweathermap.org/</a></p>
<p>In order to use the API, you need to sign up for a free API key here:<br/>
<a href="http://home.openweathermap.org/users/sign_up">http://home.openweathermap.org/users/sign_up</a></p>
<p>The <kbd>OpenWeatherMap</kbd> service provides free weather data and forecast APIs. This site collates weather data from more than 40,000 weather stations across the globe, and the data can be assessed by city name and geographic coordinates, or their internal city ID.</p>
<p>The website provides weather data in two data formats:</p>
<ul>
<li><strong>JSON</strong> (<strong>JavaScript Object Notation</strong>)</li>
<li><strong>XML</strong> (<strong>Extensible Markup Language</strong>)</li>
</ul>
<p>XML and JSON are two popular interchangeable data serialization formats widely used for interchanging data between different applications, which may be running on different platforms and using different programming languages, thus providing the benefit of interoperability.</p>
<p>JSON is simpler than XML, because its grammar is simpler and it maps more directly onto the data structures used in modern programming languages. JSON is better suited for exchanging data, but XML is good for exchanging documents.</p>
<p>The API documentation tells us of a query such as:</p>
<pre>api.openweathermap.org/data/2.5/weather?q=London,uk&amp;APPID={APIKEY} </pre>
<p>The preceding code returns weather data for London in JSON format as follows:</p>
<pre><strong>{"coord":{"lon":-0.12574,"lat":51.50853},"sys":{"country":"GB","sunrise":1377147503,"sunset":1377198481},"weather":[{"id":500,"main":"Rain", "description": "light rain","icon":"10d"}],"base":"gdps stations","main":{"temp":294.2, "pressure":1020,"humidity":88, "temp_min":292.04,"temp_max":296.48},"wind":{"speed":1,"deg":0},"rain":{"1h":0.25},"clouds":{"</strong><br/><strong> all":40},"dt":1377178327,"id":2643743,"name":"London","cod":200}</strong></pre>
<p>The syntax of JSON is simple. Any piece of JSON data is a name/value pair and each piece of data is separated from the others by commas. JSON uses curly braces <kbd>{}</kbd> to hold objects and square brackets <kbd>[ ]</kbd> to hold arrays. Accordingly, we define a method to get the weather data in JSON format in our application (see <kbd>9.06_weather_reporter.py</kbd>):</p>
<pre>def get_data_from_url(self):<br/> try:<br/>   params = urllib.parse.urlencode( {'q': self.location.get(), 'APPID': self.APIKEY},<br/>    encoding="utf-8")<br/>   api_url = ('http://api.openweathermap.org/data/2.5/weather?{}'.format(params))<br/>   with urllib.request.urlopen(api_url) as f:<br/>     json_data = f.read()<br/>     return json_data<br/> except IOError as e:<br/>   messagebox.showerror('Unable to connect', 'Unable to connect %s' % e)<br/>   sys.exit(1)</pre>
<p>The description for the code is as follows:</p>
<ul>
<li>This method uses <kbd>urllib</kbd> to retrieve responses from the website. It returns the response in JSON format.</li>
<li>Now, we'll start processing the JSON data. The weather data returned using the API is encoded in JSON format. We need to convert this data into the Python data type. Python provides a built-in <kbd>json</kbd> module that simplifies the process of encoding/decoding JSON data. We therefore import the <kbd>json</kbd> module into our current namespace.</li>
</ul>
<p>Then, we'll use this module to convert the retrieved JSON data into the Python dictionary format (see <kbd>9.06_weather_reporter.py</kbd>):</p>
<pre>def json_to_dict(self, json_data):<br/> decoder = json.JSONDecoder()<br/> decoded_json_data = decoder.decode(json_data.decode("utf-8"))<br/> flattened_dict = {}<br/> for key, value in decoded_json_data.items():<br/>   if key == 'weather':<br/>     for ke, va in value[0].items():<br/>       flattened_dict[str(ke)] =  str(va).upper()<br/>     continue<br/>   try:<br/>     for k, v in value.items():<br/>     flattened_dict[str(k)] = str(v).upper()<br/>   except:<br/>     flattened_dict[str(key)] = str(value).upper()<br/> return flattened_dict </pre>
<p>Now that we have a dictionary of all weather-related information provided by the API, we simply display the retrieved weather data using <kbd>canvas.create_text</kbd> and <kbd>canvas.create_image</kbd>. The code for displaying the weather data is self-explanatory (see <kbd>9.06_weather_reporter.py</kbd>).</p>
<p>Our Weather Reporter application is now functional.</p>
<p>When you access a server from your Python program, it is very important to send requests after small time gaps.<br/>
A typical Python program is capable of running several million instructions per second. However, the server that sends you the data at the other end is not equipped to work at that speed. If you knowingly or unknowingly send a large number of requests to a server within a short time span, you may prevent it from servicing its routine requests from normal web users. This constitutes what is called a <strong>denial of service</strong> (<strong>DOS</strong>) attack on the server. You may be banned or, in a worst case scenario, be sued for disrupting a server, if your program does not make a limited number of well-behaved requests.</p>
<p>To summarize the code for the Weather Reporter, we use the <kbd>urllib</kbd> module to query the weather API provided by our data provider. The data is fetched in JSON format. The JSON data is then decoded into a Python-readable format (dictionary).</p>
<p>The converted data is then displayed on the canvas using the <kbd>create_text</kbd> and <kbd>create_image</kbd> methods.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">A simple socket demo</h1>
                
            
            
                
<p>The goal of this project is to introduce you to the basics of network programming and how to use it in your GUI application. </p>
<p>Python has great support for network programming. At the lowest level, Python provides a <kbd>socket</kbd> module that lets you connect and interact with the network using a simple-to-use, object-oriented interface.</p>
<p>For those new to socket programming, <strong>sockets</strong> are the fundamental concept behind any kind of network communication done by your computer. For instance, when you type <kbd>www.packtpub.com</kbd> in your browser, the operating system on your computer opens a socket and connects to the remote server to fetch the web page for you. The same happens with any application that needs to connect to the network.</p>
<p>More specifically, sockets refer to a communications endpoint that is characterized by a five-element tuple that contains the following information: </p>
<pre>(protocol, local address, local port, remote address, remote port) </pre>
<p>This tuple must be unique for communication on a channel between a local machine and a remote machine.</p>
<p>Sockets may be connection-oriented or connectionless. Connection-oriented sockets allow for the flow of data to and fro as required. Connectionless sockets (or datagram sockets) allow only one message at a time to be transmitted, without an open connection.</p>
<p>Sockets can be classified into different types or families. The two most common socket families are <kbd>AF_INET</kbd> (for internet connections) and <kbd>AF_UNIX</kbd> for interprocess communications on a Unix machine. We will use <kbd>AF_INET</kbd> in our chat program.</p>
<p>This is the lowest level at which a programmer can access the network. Underneath the socket layer lie raw UDP and TCP connections, which are handled by your computer's operating system with no direct access points for programmers.</p>
<p>Let's take a brief look at some of the APIs available in the <kbd>socket</kbd> module:</p>
<table>
<tbody>
<tr>
<td><strong>API</strong> </td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td><kbd>socket.socket</kbd><br/>
<kbd>(addressfamily=AF_INET,</kbd><br/>
<kbd>type=SOCK_STREAM, proto=0,</kbd><br/>
<kbd>fileno=None)</kbd></td>
<td>Creates a socket. The <kbd>addressfamily</kbd> represents the format for providing the address, normally the IP address; type is usually <kbd>SOCK_STREAM</kbd> for TCP or <kbd>SOCK_DGRAM</kbd> for the UDP connection protocol. The protocol number is usually zero and may be omitted. Returns a socket object.</td>
</tr>
<tr>
<td><kbd>socket.bind(address)</kbd></td>
<td>Associates a local address with a socket. The socket must not already be bound. (The format of the address depends on the address family defined when creating the socket.)</td>
</tr>
<tr>
<td><kbd>socket.listen(backlog)</kbd></td>
<td>Announces a willingness to accept connections. The backlog argument specifies the maximum number of queued connections and should be at least zero; the maximum value is system-dependent.</td>
</tr>
<tr>
<td><kbd>socket.accept()</kbd></td>
<td>Passively establishes an incoming connection. Before accepting, the socket must be bound to an address and listening for connections. Returns a (<kbd>conn</kbd>, <kbd>address</kbd>) pair, where <kbd>conn</kbd> is a new socket object usable to send and receive data on the connection, and <kbd>address</kbd> is the address bound to the socket on the other end of the connection.</td>
</tr>
<tr>
<td><kbd>socket.connect()</kbd></td>
<td>Actively attempts to establish a connection to a remote socket at the address.</td>
</tr>
<tr>
<td><kbd>socket.send(bytes)/socket.</kbd><br/>
<kbd>sendall(bytes)</kbd></td>
<td>Sends some data over the connection. Unlike <kbd>send()</kbd>, <kbd>sendall()</kbd>, this continues to send data from bytes until either all data has been sent or an error occurs. Returns <kbd>None</kbd> on success.</td>
</tr>
<tr>
<td><kbd>socket.recv(bufsize)</kbd></td>
<td>Receives some data over the connection. Returns a bytes object representing the data received. The maximum amount of data to be received at once is specified by <kbd>bufsize</kbd>.</td>
</tr>
<tr>
<td><kbd>socket.close()</kbd></td>
<td>Releases the connection. The underlying system resource (for example, a file descriptor) is also closed.</td>
</tr>
</tbody>
</table>
<p> </p>
<p>If you look at the <kbd>9.07_socket_demo.py</kbd> Python file in the code bundle of this project, you'll find that it sends a very obscure-looking <kbd>GET</kbd> request to fetch the contents from the URL in the following line of code:</p>
<pre>message = "GET / HTTP/1.1 \r\nHost:" + host + "\r\n\r\nAccept: text/html\r\n\r\n"</pre>
<p>The data received from the server is also sent in packets, and it is our task to collect all the data and assemble it at our end.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Building a port scanner</h1>
                
            
            
                
<p>Now that we know the basics of socket programming, let's build a port scanner.</p>
<p>Ports are to computers what entrances are to houses. A computer has 65,535 ports through which it can communicate with the outside world. Most of the ports are closed by default. However, typically computers need to keep certain ports open for other computers on the network to connect and communicate. </p>
<p>A port scanner then is software that scans all the ports of a computer to find out which ports of the computer are open and listening for incoming communications. Port scanning is used by network administrators to strengthen their security regimes, but it is also used by hackers to look for entry points to break into a computer.</p>
<p>Before you get into scanning random website servers with this tool, it is important to know that port scanning without proper authorization is illegal in a few jurisdictions. Many ISPs ban port scanning. Furthermore, many websites have explicit policies banning any attempts at port scanning.  There have been cases of convictions for unauthorized scans.<br/>
You may even want to consult a lawyer if you are scanning third-party websites with this tool. Even if a website is silent about port scanning, it's always better to get authorization from a website before you scan its ports. Repeated scan<br/>
attempts on a single target may also cause your IP address to be blocked by the administrators.<br/>
We recommend that you use this tool to analyze security vulnerabilities only on computers that you are authorized to scan, or on websites that have a liberal policy allowing for limited and non-disruptive scans.</p>
<p>With that disclaimer out of the way, let's get into building the port scanner. On completion, our port scanner will look as follows:</p>
<div><img height="326" src="img/d37ea535-58e6-4fca-a31f-622ccf4a9f2b.png" width="499"/></div>
<p>We do not discuss the code that creates the preceding GUI, as this should be easy for you. See <kbd>9.08_port_scanner.py</kbd> for the complete code. We instead discuss the code related to port scanning.</p>
<p>There are several techniques used for port scanning. TCP SYN scanning is the most commonly used technique. It exploits the three-way handshake protocol employed by TCP, which involves sending and receiving SYN, SYN-ACK, and ACK messages. Here, SYN stands for synchronize and ACK stands for acknowledge. Visit <a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol">https://en.wikipedia.org/wiki/Transmission_Control_Protocol</a> for more details on this three-way handshake protocol.</p>
<p>A TCP SYN scan involves sending a SYN packet as if you will make a real connection and then waiting for the response. A SYN/ACK response from the target means that the port is open. A RST (reset) response suggests that the port is closed. If no response is received, the port is considered to be filtered.</p>
<p>Another common technique, and the one we will use for port scanning, is called the TCP connect scanner. This involves requesting a connection to the target operating system using the connect system call. This is exactly how web browsers and other high-level clients make a connection.</p>
<p>The connect command establishes an actual connection to the target, as opposed to the half-open scan that TCP SYN scan does. Since a complete connection is established, a connect scan is slower and requires more transmission than an SYN scan to find out whether a port is open. Furthermore, the target machine is more likely to log the connection and it is therefore not as stealthy as an SYN scan.</p>
<p>Accordingly, the code that checks whether a port is open is defined as follows (see <kbd>9.08_port_scanner.py</kbd>):</p>
<pre>def is_port_open(self,url, port):<br/> try:<br/>   s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br/>   s.settimeout(1)<br/>   s.connect((socket.gethostbyname(url), port))<br/>   s.close()<br/>   return True<br/> except:<br/>   return False</pre>
<p>Note that the preceding code simply uses <kbd>socket.connect</kbd> to make a connection to probe the port</p>
<p>We call the preceding method from another method, <kbd>start_scan</kbd>, which simply loops over each of the ports in the range provided by the user:</p>
<pre>def start_scan(self, url, start_port, end_port):<br/> for port in range (start_port, end_port+1):<br/>   if not self.stop:<br/>     self.output_to_console("Scanning port{}".format(port))<br/>     if self.is_port_open(url, port):<br/>       self.output_to_console(" -- Port {} open \n".format(port))<br/>     else:<br/>       self.output_to_console("-- Port {} closed \n".format(port))</pre>
<p>Finally, we do not want a call to this method to block our Tkinter main loop. Therefore, we call the preceding method in a new thread as follows:</p>
<pre>def scan_in_a_new_thread(self):<br/>  url = self.host_entry.get()<br/>  start_port = int(self.start_port_entry.get())<br/>  end_port = int(self.end_port_entry.get())<br/>  thread = Thread(target=self.start_scan, args=(url, start_port, <br/>    end_port ))<br/>  thread.start()</pre>
<p>The preceding method gets the values entered by the user and passes them as arguments to the <kbd>start_scan</kbd> method in a new thread.</p>
<p>The rest of the code simply creates and updates the GUI with the result and should be self-explanatory. This concludes the port scanner project.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Building a chat application</h1>
                
            
            
                
<p>Next, let's build a multi-client chat room. The goal of this program is to explore socket programming in further detail. This section also implements and discusses the client-server architecture that is so common in all network programs.</p>
<p>Our chat program will consist of a chat server, which listens for and receives all incoming messages on a given port.</p>
<p>It also maintains a list of chat clients that connect to the server. It then broadcasts any incoming messages to all connected clients:</p>
<div><img src="img/0cabf5fd-2e22-4eaf-8eea-11cdfd7aada8.png"/></div>
<p>Let's start with the code for the chat server.</p>
<p>A server runs on a remote host and has a socket bound to a specific port number. The server just waits, listening to the socket for a client to make a connection request.</p>
<p>Here's the code for a chat server (see <kbd>9.09_chat_server.py</kbd>):</p>
<pre>class ChatServer:<br/>  clients_list = []<br/>  last_received_message = ""<br/><br/>  def __init__(self):<br/>    self.create_listening_server()<br/><br/>  def create_listening_server(self):<br/>    self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br/>    local_ip = '127.0.0.1'<br/>    local_port = 10319<br/>    self.server_socket.setsockopt(socket.SOL_SOCKET, <br/>      socket.SO_REUSEADDR, 1)<br/>    self.server_socket.bind((local_ip, local_port))<br/>    print("Listening for incoming messages..")<br/>    self.server_socket.listen(5)<br/>    self.receive_messages_in_a_new_thread()<br/><br/>  def receive_messages_in_a_new_thread(self):<br/>    while 1:<br/>      client = so, (ip, port) = self.server_socket.accept()<br/>      self.add_to_clients_list(client)<br/>      print ('Connected to ', ip , ':' , str(port))   <br/>      t = threading.Thread(target=self.receive_messages, args=(so,))<br/>      t.start()<br/><br/>  def receive_messages(self, so):<br/>    while True:<br/>      incoming_buffer = so.recv(256)<br/>      if not incoming_buffer: break<br/>      self.last_received_message = incoming_buffer.decode('utf-8')<br/>      self.broadcast_to_all_clients(so)<br/>      so.close()<br/><br/>  def broadcast_to_all_clients(self, senders_socket):<br/>     for client in self.clients_list:<br/>        socket, (ip, port) = client<br/>        if socket is not senders_socket:<br/>           socket.sendall(self.last_received_message.encode('utf-8'))<br/><br/>  def add_to_clients_list(self, client):<br/>      if client not in self.clients_list:<br/>         self.clients_list.append(client)<br/><br/>if __name__ == "__main__":<br/>ChatServer()</pre>
<p>The description of the preceding code is as follows:</p>
<ul>
<li>We create a TCP socket with an address family of IPv4 using the line <kbd>self.server_socket = socket(AF_INET, SOCK_STREAM)</kbd>. The IPv4 socket uses a 32-bit number to represent the address size. It is the most popular addressing scheme and accounts for most current internet traffic. IPv6 is a newer numbering system with a 128-bit address size, thereby providing a much larger pool of addresses. IPv6 has seen some adoption but it has not yet become the mainstream standard.</li>
<li>The <kbd>SOCK_STREAM</kbd> parameter means that we will be using a TCP connection for the communication. Another less popular option is to use <kbd>SOCK_DGRAM</kbd>, which refers to the UDP mode of transmission.</li>
<li>TCP is a more reliable protocol for communication than UDP as it offers a guarantee against packet loss. It also takes care of the proper ordering of bytes at the receiving end. If we use a UDP protocol, we will have to take care of handling packet loss, duplication, and the ordering of packets at the receiving end.</li>
<li>We used <kbd>socket.bind(('127.0.01', 10319))</kbd> in the preceding code to bind the socket. We could have alternatively used <kbd>socket.bind</kbd> <kbd>((socket.gethostname( ), 10319)</kbd> so that the socket would have been visible to the outside world. Alternatively, we could have specified an empty string such as <kbd>socket.bind((' ', 10319))</kbd> to make the socket reachable by any address the machine could have.</li>
<li>The <kbd>socket.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1)</kbd> line of code allows other sockets to <kbd>bind()</kbd> to this local port, unless there is an active socket already bound to the port. This lets us get around the <kbd>Address already in use</kbd> error message when a server is restarted after a crash.</li>
<li>The line <kbd>self.server_socket.accept()</kbd> returns a value of the form <kbd>(socket, (ip, port))</kbd> as soon as a remote client connects to the server. Each client is then uniquely identified by the following data: <kbd>(socket, (ip, port))</kbd>.</li>
<li>The line <kbd>Thread(target=self.receive_messages, args=(so,))</kbd> receives each new message on a new thread.</li>
<li>Finally, the line <kbd>socket.sendall(self.last_received_message.encode('utf-8'))</kbd> sends the message to individual clients.</li>
<li>The <kbd>receive_messages</kbd> method receives messages using the <kbd>socket.recv</kbd> method. The <kbd>socket.recv</kbd> method receives messages in buffers. It is your responsibility to call the method again and again until the entire message has been dealt with. When the <kbd>socket.recv</kbd> method returns <kbd>0</kbd> bytes, it means that the sender has closed the connection. We then break out of the infinite loop and get the complete message from the buffer.</li>
</ul>
<p>Also note that message transmission over the network occurs in bytes.</p>
<p>Any message that we send must be converted to byte form using <kbd>outgoing_message.encode('utf-8')</kbd>. Similarly, any message that we receive from the network must be converted from bytes to a string or any other format.</p>
<p>To convert bytes to a string, we use <kbd>incoming_bytes.decode('utf-8')</kbd>.</p>
<p>Our chat server is now ready. Next, let's build the chat client.</p>
<p>Our chat client should connect to the remote server and send a message to the server. It should also be listening for any incoming messages from the central chat server. We do not reproduce the entire code for our chat client. Specifically, we omit the code that produces the GUI for our chat client as we have coded similar widgets in the past.</p>
<p>The partial code in our chat client that sends and receives messages to and from the chat server is as follows (see <kbd>9.10_chat_client.py</kbd>):</p>
<pre>class ChatClient:<br/>  client_socket = None<br/>  last_received_message = None<br/><br/>  def __init__(self, root):<br/>    self.root = root<br/>    self.initialize_socket()<br/>    self.initialize_gui()<br/>    self.listen_for_incoming_messages_in_a_thread()<br/><br/>  def initialize_socket(self):<br/>    self.client_socket = socket(AF_INET, SOCK_STREAM)<br/>    remote_ip = '127.0.0.1'<br/>    remote_port = 10319<br/>    self.client_socket.connect((remote_ip, remote_port))<br/><br/>  def listen_for_incoming_messages_in_a_thread(self):<br/>    t = Thread(target=self.recieve_message_from_server,<br/>    args=(self.client_socket,))<br/>    t.start()<br/><br/>  def recieve_message_from_server(self, so):<br/>    while True:<br/>      buf = so.recv(256)<br/>      if not buf:<br/>        break <br/>      self.chat_transcript_area.insert('end',buf.decode('utf-8') + '\n')<br/>      self.chat_transcript_area.yview(END)<br/>    so.close()<br/><br/>  def send_chat(self):<br/>    senders_name = self.name_widget.get().strip() + ":"<br/>    data = self.enter_text_widget.get(1.0, 'end').strip()<br/>    message = (senders_name + data).encode('utf-8')<br/>    self.chat_transcript_area.insert('end', message.decode('utf-8') + '\n')<br/>    self.chat_transcript_area.yview(END)<br/>    self.client_socket.send(message)<br/>    self.enter_text_widget.delete(1.0, 'end')<br/>    return 'break'</pre>
<p>This code is very similar to the code of our chat server. Here's a short description of the code:</p>
<ul>
<li>We first create a socket using <kbd>socket(AF_INET, SOCK_STREAM)</kbd></li>
<li>We then connect the socket to the remote IP and the remote port of our chat server using <kbd>socket.connect()</kbd></li>
<li>We receive messages from the server using <kbd>socket.recv()</kbd></li>
<li>We send messages to the server using <kbd>socket.send()</kbd></li>
</ul>
<p>Note that when a client attempts to connect to the server using the <kbd>socket.connect</kbd> method, the operating system will assign a unique but random port to identify the client when a message is returned by the server. </p>
<p>The port numbers from <kbd>0</kbd> to <kbd>1023</kbd> are referred to as the well-known ports, reserved ports, or system ports. They are used by the operating system to provide widely used network services. For example, port <kbd>21</kbd> is reserved for FTP services, port <kbd>80</kbd> is reserved for HTTP services, port <kbd>22</kbd> is reserved for SSH and SFTP, and port <kbd>443</kbd> is reserved for a secure HTTP service (HTTPS) over TLS/SSL.<br/>
The random port that the operating system assigns to our client is selected from a pool of ports that are above the system-reserved ports. The list of all reserved ports can be found at<br/>
<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers">https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers</a>.<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers"/></p>
<p>The full code of the chat client can be found in <kbd>9.10_chat_client.py</kbd>. The chat is now functional, but note that we have not coded the logic for removing users from the <kbd>clients_list</kbd> in <kbd>ChatServer.</kbd> This means that even if you close a chat window, the chat server will still try to send a chat message to the closed client as we have not removed the client from the server. We will not implement it here, but should you wish to implement this, you can easily override the window's <kbd>close</kbd> method and send a message to <kbd>ChatServer</kbd> to delete the client from the client list.</p>
<p>That concludes the chat application project.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a phone book application</h1>
                
            
            
                
<p>Let's now build a simple phone book application that allows the user to store names and phone numbers.</p>
<p>The main learning objective for this project relates to being able to use a relational database with Tkinter to store and manipulate records. We have already seen some basic examples of object persistence with serialization. Relational databases extend this persistence using rules of relational algebra to store data in tables.</p>
<p>Python provides database interfaces for a wide range of database engines. Some of the commonly used database engines include MySQL, SQLite, PostgreSQL, Oracle, Ingres, SAP DB, Informix, Sybase, Firebird, IBM DB2, Microsoft SQL Server, and Microsoft Access.</p>
<p>We will use SQLite to store data for our phone book application.</p>
<p>SQLite is a serverless, zero-configuration, self-contained SQL database engine suitable for developing embedded applications. The source code for SQLite is in the public domain, which makes it freely available for use in all sorts of commercial and non-commercial projects.</p>
<p>Unlike many other SQL databases, SQLite does not require running a separate server process. Instead, SQLite stores all the data directly onto flat files that get stored on a computer disk. These files are easily portable across different platforms, making it a very popular choice for smaller and simpler database implementation requirements.</p>
<p>Python comes with a built-in standard library for SQLite3 support. However, we need to download the SQLite3 command-line tool that lets us create, modify, and access the database using a command line. The command-line shell for Windows, Linux, and macOS can be downloaded from <a href="http://sqlite.org/download.html">http://sqlite.org/download.html</a>.</p>
<p>Following the instructions on the website, install the SQLite command shell into any location of your choice.</p>
<p>Let's now implement our phone book application. The application will look as follows:</p>
<div><img src="img/fd1eb5ff-d1ad-4084-b7c9-c7bf7891be10.png"/></div>
<p>The application will demonstrate some of the common operations involved in database programming. The user should be able to create new records, read existing records, update existing records, and delete records from the database using this application. Together, these activities constitute what are known as <strong>CRUD</strong> (<strong>Create, Read, Update, and Delete</strong>) operations on a database.</p>
<p>In order to create the database, we open the command-line tool of our operating system. Within the command line, we first navigate to the directory where we need to create the new database file. In order to create the database, we simply use this command:</p>
<pre>sqlite3 phonebook.db</pre>
<p>This creates a database file named <kbd>phonebook.db</kbd> in the folder from which we execute the command. It also displays a message similar to the following: </p>
<pre>SQLite version 3.7.17 2018-01-31 00:56:22<br/>Enter ".help" for instructions<br/>Enter SQL statements terminated with a ";"<br/>sqlite&gt;</pre>
<p>We have now created a database named <kbd>phonebook.db</kbd>. However, the database file is currently empty. It does not contain any tables or any data. So, we get no results if we run this command:</p>
<pre>sqlite&gt; .tables</pre>
<p>For now, let's exit the command-line tool by typing this:</p>
<pre>sqlite&gt; .exit</pre>
<p>We want to store contacts in our database, and that is why we will create the <kbd>contacts</kbd> table. Our database table should store a person's name and phone number. In addition, it is good practice to keep a unique identification number for each person or each entry in the table. This is because multiple people might have the same name or same contact number.</p>
<p>To create a table within our <kbd>phonebook.db</kbd> database, we again open the command-line tool and navigate to the directory where we had created the database. We again get into the SQLite3 terminal by typing this:</p>
<pre>sqlite3 phonebook.db</pre>
<p>This time, a new database is not created. Rather, the command now opens the existing <kbd>phonebook.db</kbd> database because it is already present on the disk.</p>
<p>Next, we create a table named contacts, and add three columns to the table from the command line:</p>
<pre>sqlite&gt; CREATE TABLE contacts<br/>(<br/>contactid INTEGER PRIMARY KEY AUTOINCREMENT,<br/>name STRING NOT NULL,<br/>contactnumber INTEGER NOT NULL<br/>);</pre>
<p>You can verify the contacts table was created by typing the following command:</p>
<pre>sqlite&gt;.table</pre>
<p>This prints the name of all the tables present in the currently open database. You will get the following output:</p>
<pre>sqlite&gt;.table<br/>contacts</pre>
<p>Let's first create a basic GUI that will let us add, view, delete, and modify the records. We create a class named <kbd>phoneBook</kbd> and create all GUI widgets within it.</p>
<p>We do not discuss the entire code that creates the GUI as we have coded similar structures in the past. However, we use a new ttk widget named <kbd>Treeview</kbd>. The code for creating <kbd>Treeview</kbd> is as follows (<kbd>9.11_phonebook.py</kbd>):</p>
<pre>def create_tree_view(self):<br/> self.tree = ttk.Treeview(height=5, columns=2)<br/> self.tree.grid(row=4, column=0, columnspan=2)<br/> self.tree.heading('#0', text='Name', anchor=W)<br/> self.tree.heading(2, text='Phone Number', anchor=W)</pre>
<p>To add items to <kbd>Treeview</kbd>, we use the following code:</p>
<pre>self.tree.insert('', 0, text=row[1], values=row[2])</pre>
<p>To get all items in <kbd>Treeview</kbd>, we use the code:</p>
<pre>items = self.tree.get_children()</pre>
<p>To delete items from <kbd>Treeview</kbd>, we use the code:</p>
<pre>self.tree.delete(item)</pre>
<p>Next, let's prepare the code to query our database:</p>
<pre>db_filename = 'phonebook.db'<br/><br/>def execute_db_query(self, query, parameters=()):<br/>  with sqlite3.connect(self.db_filename) as conn:<br/>    cursor = conn.cursor()<br/>    query_result = cursor.execute(query, parameters)<br/>    conn.commit()<br/>  return query_result</pre>
<p>The code description is as follows:</p>
<ul>
<li>The method establishes a connection to the <kbd>phonebook.db</kbd> database we created earlier.</li>
<li>The next line, <kbd>cursor = conn.cursor()</kbd>, creates a cursor object. The cursor is a control structure that is required as per SQL standards, and it enables us to traverse the records in a database.</li>
<li>The next line, <kbd>cursor.execute(query)</kbd>, executes the query against the database.</li>
<li>The line <kbd>conn.commit()</kbd> actually commits/saves these changes to the database.</li>
</ul>
<p>We can now use the preceding method to execute CRUD queries on the database.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a new record</h1>
                
            
            
                
<p>A new record needs to be created every time a user enters a new name and a phone number in the entry widgets provided, and then clicks on the Add Record button. </p>
<p>The database query for adding a new record is as follows:</p>
<pre>query = 'INSERT INTO contacts VALUES(NULL,?, ?)'<br/>parameters = (self.namefield.get(), self.numfield.get())<br/>self.execute_db_query(query, parameters)</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Reading from the database</h1>
                
            
            
                
<p>The database query for reading all records from the database is as follows:</p>
<pre>query = 'SELECT * FROM contacts ORDER BY name desc'<br/>phone_book_entries = self.execute_db_query(query)</pre>
<p>The preceding variable, <kbd>phone_book_entries</kbd>, contains a list of all the records from the database.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Updating records</h1>
                
            
            
                
<p>To update the phone number of an existing contact, we use the following code:</p>
<pre>query = 'UPDATE contacts SET contactnumber=? WHERE contactnumber=? AND name=?'<br/>parameters = (newphone, old_phone_number, name)<br/>self.execute_db_query(query, parameters)</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Deleting records</h1>
                
            
            
                
<p>To delete the phone number of an existing contact, we use the following code:</p>
<pre>query = 'DELETE FROM contacts WHERE name = ?'<br/>self.execute_db_query(query, (name,))</pre>
<p>The rest of the code is the supporting GUI. See <kbd>9.11_phonebook.py</kbd> for the complete code. We have now completed coding a basic phone book application.</p>
<p>We have seen how to create a database, add tables to the database, and query the database to add, modify, delete, and view items in the database. Our phone book application has demonstrated how to execute basic CRUD operations on a database.</p>
<p>Furthermore, due to the similarity of basic database operations, you can now consider working with other database systems, such as MySQL, PostgreSQL, Oracle, Ingres, SAP DB, Informix, Sybase, Firebird, IBM DB2, Microsoft SQL Server, and Microsoft Access. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using asyncio with Tkinter</h1>
                
            
            
                
<p>Starting with Python 3.4, a new module named <kbd>asyncio</kbd> was introduced as a Python standard module.</p>
<p>The term <strong>Asyncio</strong> is made by adding two words: async + I/O.  Async is about concurrency, which means doing more than one thing at a time. I/O, on the other hand, refers to handling I/O bound tasks. A <strong>bound task</strong> means the thing that keeps your program busy.  If, for instance, you are doing computation-intensive math processing, the processor is taking most of the time—and it is, therefore, a <strong>CPU bound task</strong>. On the contrary, if you are waiting for a result from the network, result from the database, or an input from the user, the task is <strong>I/O bound</strong>.</p>
<p class="mce-root">So in a nutshell, the <kbd>asyncio</kbd> module provides concurrency, particularly for I/O bound tasks. Concurrency ensures that you do not have to wait for I/O bound results.</p>
<p class="mce-root">Let's say you have to fetch content from multiple URLs, then process the fetched content to extract the title and display it in a Tkinter window. Now you obviously cannot fetch the content in the same thread that runs the Tkinter main loop, as that would make the root window unresponsive while the content is fetched.</p>
<p class="mce-root">So one of the options is to spawn a new thread for each URL. While this can be an option, it is not a very scalable one as spawning thousands or more threads at a time can lead to a lot of code complexity. We already saw a demo of a race condition in the beginning of the current chapter (<kbd>9.01_race_condition.py</kbd>), where running multiple threads can make it difficult to control the shared state. Furthermore, as context switching is an expensive and time-consuming affair, the program can become laggy after spawning just a few threads.</p>
<p class="mce-root">Here's where <kbd>asyncio</kbd> comes to our rescue. In contrast to multithreading, which relies on threading, <kbd>asyncio</kbd> uses a concept of event loops.</p>
<p class="mce-root">To demonstrate, here is a Tkinter program that on the click of a button simulates fetching 10 URLs:</p>
<pre>from tkinter import Tk, Button<br/>import asyncio<br/>import threading<br/>import random<br/><br/>def asyncio_thread(event_loop):<br/>  print('The tasks of fetching multiple URLs begins')<br/>  event_loop.run_until_complete(simulate_fetch_all_urls())<br/><br/>def execute_tasks_in_a_new_thread(event_loop):<br/>  """ Button-Event-Handler starting the asyncio part. """<br/>  threading.Thread(target=asyncio_thread, args=(<strong>event_loop</strong>, )).start()<br/><br/><strong>async</strong> def simulate_fetch_one_url(url):<br/>  """ We simulate fetching of URL by sleeping for a random time """<br/>  seconds = random.randint(1, 8)<br/>  await asyncio.sleep(seconds)<br/>  return 'url: {}\t fetched in {} seconds'.format(url, seconds)<br/><br/><strong>async</strong> def simulate_fetch_all_urls():<br/>  """ Creating and starting 10 i/o bound tasks. """<br/>  all_tasks = [simulate_fetch_one_url(url) for url in range(10)]<br/>  completed, pending = <strong>await asyncio.wait(all_tasks)</strong><br/>  results = [<strong>task.result()</strong> for task in completed]<br/>  print('\n'.join(results))<br/><br/>def check_if_button_freezed():<br/>  print('This button is responsive even when a list of i/o tasks are in progress')<br/><br/>def main(<strong>event_loop</strong>):<br/>  root = Tk()<br/>  Button( master=root, text='Fetch All URLs',<br/>        command=lambda: execute_tasks_in_a_new_thread(<strong>event_loop</strong>)).pack()<br/>  Button(master=root, text='This will not Freeze',  <br/>                      command=check_if_button_freezed).pack()<br/>  root.mainloop()<br/><br/>if __name__ == '__main__':<br/>  <strong>event_loop = asyncio.get_event_loop()</strong><br/>  main(<strong>event_loop</strong>)</pre>
<p>Here's a brief description of the code (<kbd>9.12_async_demo.py</kbd>):</p>
<ul>
<li>The first step in using the <kbd>asyncio</kbd> module is to construct an event loop using the code <kbd>event_loop = asyncio.get_event_loop()</kbd>. Internally, this <kbd>event_loop</kbd> will schedule all tasks assigned to it using coroutines and futures to do the I/O bound tasks in an asynchronous manner.</li>
<li>We pass this <kbd>event_loop</kbd> as an argument to the Tkinter root window, so that it can use this event loop for scheduling async tasks.</li>
<li>The method that is in charge of doing the I/O bound task is then defined by appending the keyword <kbd>async</kbd> in front of the method definition. Essentially, any method that is to be executed from the event loop must be appended with the keyword <kbd>async</kbd>.</li>
<li>The method simulates a time-taking I/O blocking task using <kbd>await asyncio.sleep(sec)</kbd>. In a real case, you will perhaps use this to fetch the contents of a URL or perform a similar I/O blocking task.</li>
<li>We start executing the async tasks in a new thread. This single thread executes the list of tasks using the <kbd>event_loop.run_until_complete(simulate_fetch_all_urls())</kbd> command. Note that this is different from creating one thread each for each of the tasks. In this case, we are only creating a single thread to isolate it from the Tkinter main loop.</li>
<li>The line <kbd>all_tasks = [simulate_fetch_one_url(url) for url in range(10)]</kbd> combines all the async tasks into a list. This list of all I/O bound tasks is then passed on to <kbd>completed, pending = await asyncio.wait(all_tasks)</kbd>, which waits for all tasks to be completed in a non-blocking manner. Once all the tasks are completed, the results are populated in the <kbd>completed </kbd>variable.</li>
<li>We get the results of individual tasks using <kbd>results = [task.result() for task in completed]</kbd>.</li>
<li>We finally print out all the results to the console.</li>
</ul>
<p class="mce-root">The benefit of using <kbd>asyncio</kbd> is that we do not have to spawn one thread for each task and as a result, the code does not have to context switch for each individual task.  Thus, using <kbd>asyncio</kbd> we can scale up to fetch thousands of URLs without slowing down our program and without worrying about managing results from each thread individually. </p>
<p>This concludes our brief discussion on using the <kbd>asyncio</kbd> module with Tkinter.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Interfacing with hardware/serial communication</h1>
                
            
            
                
<p>The <strong>internet of things</strong> (<strong>IoT</strong>) is now becoming a reality. We are seeing a glimpse of IoT in smart medical devices, driverless cars, smart factories, and smart homes. A large number of such IoT applications are built around the idea of capturing data with sensors and actuators.</p>
<p class="mce-root">The rise of IoT can largely be attributed to the rise in popularity of microcontrollers, which make it very easy to test and build product prototypes for such embedded systems.  A microcontroller is a self-contained device with a built-in processor and a programmable memory. Most typical microcontrollers provide general purpose input/output pins which can be used either to receive data from sensors or to send data based on some program that is uploaded to the microcontoller.</p>
<p>In this project, we will use one of the most popular microcontrollers—the Arduino Uno—to demonstrate how to build an application that can read data from an external device. We will build an Ultrasonic Range Finder. If you find this project interesting, you can buy the hardware and build it as well—the total cost of this project is less than five dollars. However, if you do not intend to implement it, you can merely read through this section. Our primary objective here is to show how to get data from external hardware into Tkinter using what is known as serial communication.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Hardware</h1>
                
            
            
                
<p>To begin with, we need an Arduino Uno board (or any other Arduino board). We also need an ultrasonic range finder sensor. A quick web search shows hundreds of rangefinder sensors for less than a quarter of a dollar. We use a sensor named HC-SR04-Ultrasonic Range Finder, but just about any other sensor would do. The sensor we have chosen provides a range-finding capability for distances in a 2 cm - 300 cm range, with an accuracy of up to 3 mm.</p>
<p>These sensors use sonar to determine the distance to an object, just as dolphins and bats do. Here's how the sensor calculates the distance. The module has two units. The transmitter transmits ultrasound, while a receiver reads any ultrasound that reflects back. Since the speed of ultrasound is fixed and known, by calculating the time between transmission and reflection, we can calculate the distance of the object that reflected the ultrasound.</p>
<p>Here's how the hardware is set up:</p>
<div><img src="img/e78fab2f-360c-4a2c-99cd-12054b1aa674.png"/></div>
<p>To the left is the Arduino Uno board. The ultrasound sensor is towards the right. As you can see the sensor has four pins marked VCC, Trig, Echo, and GND. The specifications of the sensor states that it needs 5 volts to run. Accordingly, we connect the VCC pin to a pin that reads 5V on the Arduino pin. Similarly, the ground pin (GND) from the sensor is connected to a GND pin on the Arduino board. Now the sensor is powered up. We connect the Trig pin to pin number 8 and the Echo pin to pin number 7 on the Arduino board. Every time we provide a high pulse on Pin 8, the sensor will trigger an ultrasound and then the Echo pin will return the time it took for the ultrasound to reflect back, which we will read into the Arduino on Pin 7.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Writing the Arduino sketch</h1>
                
            
            
                
<p>In the Arduino world, programs that you upload to the microcontroller are called sketches. You can write these sketches in a free <strong>integrated development environment</strong> (<strong>IDE</strong>) which can be downloaded from here:<br/>
<a href="https://www.arduino.cc/en/Main/Software">https://www.arduino.cc/en/Main/Software</a></p>
<p>Once you finalize a program, you upload it to your Arduino board using the upload button on the IDE and voila: your board starts doing what you asked it to do.</p>
<p class="mce-root">Every Arduino sketch will have two methods where you get to define the logic of your program:</p>
<ul>
<li class="mce-root"><kbd>setup()</kbd>: For one-time initialization</li>
<li class="mce-root"><kbd>loop()</kbd>: For things that the board keeps doing forever until it runs out of power</li>
</ul>
<p>Here's the code that we upload to the Arduino (see <kbd>9.13.arduino_sketch.ino</kbd>):</p>
<pre>const int triggerPin = 8;<br/>const int echoBackPin = 7;<br/><br/>void setup() {<br/> Serial.begin(9600);<br/> pinMode(triggerPin, OUTPUT);<br/> pinMode(echoBackPin, INPUT);<br/>}<br/><br/>void loop() {<br/>  long duration, distanceIncm;<br/>  // trigger ultrasound ping<br/>  digitalWrite(triggerPin, LOW);<br/>  delayMicroseconds(2);<br/>  digitalWrite(triggerPin, HIGH);<br/>  delayMicroseconds(5);<br/>  digitalWrite(triggerPin, LOW);<br/>  // receive input from the sensor<br/>  duration = pulseIn(echoBackPin, HIGH);<br/> <br/>  //calculate distance<br/>  distanceIncm = duration / 29 / 2;<br/><br/>  // send data over serial port<br/>  Serial.print(distanceIncm);<br/>  Serial.println();<br/>  delay(100);<br/>}</pre>
<p>The code description is as follows:</p>
<ul>
<li>The first two lines indicates that we will use pin numbers <kbd>7</kbd> and <kbd>8</kbd> on the Arduino board and we assign them the variable names <kbd>triggerPin</kbd> and <kbd>echoBackPin</kbd>.</li>
<li>The <kbd>setup</kbd> function initializes the serial port and fixes its baud rate at 9600. Baud rate is defined as the number of signal changes that occur in a second. We will use the same rate when reading data in Tkinter with Python.</li>
<li>The code <kbd>pinMode(triggerPin, OUTPUT)</kbd> means that we will now use Pin <kbd>8</kbd> to send an output pulse to the sensor. </li>
<li>Similarly, the code <kbd>pinMode(echoBackPin, INPUT);</kbd> declares that we will use Pin <kbd>7</kbd> to receive input from the sensor.</li>
<li>Within the loop, we start by setting pin <kbd>triggerPin</kbd> to low pulse.  We then trigger the sensor to emit ultrasound by triggering a high voltage pulse of <kbd>2</kbd> microseconds. This triggers the sensor to emit an ultrasound for 5 microseconds. We then mark the pin <kbd>LOW</kbd> to stop triggering the ultrasound pulse.</li>
<li>We then time the signal received on <kbd>echoBackPin</kbd> using <kbd>duration = pulseIn(ioPin, HIGH)</kbd>. This gives us the time (in microseconds) it took for the ultrasound to reflect back.</li>
<li>Given that the speed of sound is 340 m/s or 29 microseconds per centimeter, we find the distance using the formula <kbd>distance = speed * time</kbd>. But since this is the time it took for a reflected sound to travel out and back, the actual distance is half this value. Perhaps the math should be done by Python instead? Doing division here using a <kbd>long</kbd> method will result in a whole number and so will not be precise. Note that we could have also offloaded this calculation from Arduino to our Python code, as most Arduino processors do not directly support floats in hardware, and doing so in software on such a limited processor could bog it down. </li>
<li>The line <kbd>delay(100)</kbd> ensures that the previous code runs every <kbd>100</kbd> milliseconds, sending pulses of ultrasound and measuring the distance to whatever the sensor is pointed at.</li>
</ul>
<p>The moment this code is uploaded to the Arduino board, it starts sending <kbd>5</kbd>-microsecond pulses of ultrasound after a delay of 100 milliseconds. It also sends a message to the serial port of your computer in every one of these loops.</p>
<p>Now it's time to read this using Python and then display it in a Tkinter widget.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Reading serial data</h1>
                
            
            
                
<p>We will use the <kbd>pyserial</kbd><strong> </strong>module to read data from the serial port. However, this is not a standard Python module and needs to be installed. We can install it using the following pip command:</p>
<pre class="lang-py prettyprint prettyprinted"><strong>pip install pyserial</strong><br/></pre>
<p>Once we are able to get data from the Arduino board, we can further process it or plot it in the way we want. However, the goal here is to simply display whatever data is sent by the Arduino board over the serial port, as shown in the following Tkinter window (<kbd>9.14_read_from_serial_port.py</kbd>):</p>
<div><img height="120" src="img/d692b435-0152-414c-bf42-6d97a22351f0.png" width="177"/></div>
<p>In order to read the serial port, we first need to identify the port on which this message is being sent. There are two ways you can do this.</p>
<p>Firstly, you can find the name of the port from your Arduino IDE under the Tools menu, as shown here:</p>
<div><img src="img/ec5b64a4-9b65-44a5-8356-e135fda0a058.png"/></div>
<p>Alternatively, you can run the following command from the command line:</p>
<pre><strong>python -m serial.tools.list_ports</strong></pre>
<p>This will print a list of all active serial ports. Once you have the port name at hand, data reading is done using the following code:</p>
<pre>from tkinter import Tk, Label<br/>import serial<br/><br/>ser = serial.Serial()<br/>ser.port = "/dev/ttyUSB0"<br/>ser.baudrate = 9600<br/>try:<br/> ser.open()<br/>except serial.SerialException:<br/> print("Could not open serial port: " + ser.port)<br/><br/>root = Tk()<br/>root.geometry('{}x{}'.format(200, 100))<br/>label = Label(root, font=("Helvetica", 26))<br/>label.pack(fill='both')<br/><br/>def read_serial_data():<br/> if ser.isOpen():<br/>   try:<br/>     response = ser.readline()<br/>     label.config(text='Distance : \n' + response.decode("utf-8").rstrip() + ' cm')<br/>   except serial.SerialException:<br/>     print("no message received")<br/><br/>root.after(100, read_serial_data)<br/>read_serial_data()<br/>root.mainloop()</pre>
<p>The description of the code is as follows:</p>
<ul>
<li>We first get an instance of the <kbd>Serial</kbd> class by calling <kbd>ser = serial.Serial()</kbd>. We then specify the port name and the baud rate. This is the same baud rate that we used earlier in our Arduino code.</li>
<li>We then open the serial port by calling <kbd>ser.open()</kbd> and read the data using <kbd>ser.readline()</kbd>.</li>
<li>The rest of the code is Tkinter-specific and creates the GUI and displays the results in a <kbd>Label</kbd> widget.</li>
</ul>
<p>This concludes the section and the chapter.</p>
<p>In the next chapter, we will conclude the book with discussions on miscellaneous issues that you may encounter when writing GUI programs.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>Let's summarize the concepts we discussed in this chapter.</p>
<p>We learned about the perils of spawning threads and the resulting race condition.</p>
<p>We learned how to use the queue data structure to program a multithreaded application, without having to worry about synchronization between multiple threads trying to access the same memory, and without using complicated synchronization primitives.</p>
<p>The Weather Reporter application introduced us to the basics of network programming and how to tap into the internet to get data. We discussed two popular structures used for data exchange, namely XML and JSON.</p>
<p>The port scanner and the chat program discussed the basics of socket programming for interprocess and remote communication. We used the TCP/IP protocol to send and receive messages in our chat program. We also saw a basic example of client-server architecture.</p>
<p>We saw how all forms of communication over a network occur in bytes and how we can convert data to bytes and back from bytes to data in the required format.</p>
<p>The phone book application showed us how to work with databases. We saw how to perform basic CRUD operations on a database.</p>
<p>Next, we saw how to use the <kbd>asyncio</kbd> module to fetch I/O bound tasks in a non-blocking and scalable manner, without having to worry about managing the states of a large number of threads at once.</p>
<p>Finally, we saw how to interface with external hardware to collect data from sensors using serial communication.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">QA section</h1>
                
            
            
                
<p>Here are a few questions to reflect upon:</p>
<ul>
<li>What is a race condition? How can you avoid a race condition?</li>
<li>What are the benefits of using the queue data structure?</li>
<li>What are the most popular open source databases available in the market?</li>
<li>What are the most common modes of interprocess communication?</li>
<li>When would you use the <kbd>asyncio</kbd> module?</li>
<li> What are some of the advantages and disadvantages of using serial communication? What are some of its alternatives?</li>
<li> What are the JSON and XML file formats used for? What are their advantages and disadvantages when compared to using a database?</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Further reading</h1>
                
            
            
                
<p>We used Python code to perform basic CRUD operations on our database.  It would be worthwhile to note that as applications get larger and more complex, the programmer should consider making use of an <strong>ORM</strong> (<strong>object-relational mapping</strong>) library instead of direct CRUD operations. Read more about ORM and its benefits at <a href="http://blogs.learnnowonline.com/2012/08/28/4-benefits-of-object-relational-mapping-orm/">http://blogs.learnnowonline.com/2012/08/28/4-benefits-of-object-relational-mapping-orm/.</a></p>
<p>We used a thread lock as a synchronization primitive in <kbd>9.02_lock_demo.py</kbd>. There are several other synchronization primitives that could have been used instead. Learn about other synchronization primitives at <a href="https://www.usenix.org/legacy/publications/library/proceedings/bsdcon02/full_papers/baldwin/baldwin_html/node5.html">https://www.usenix.org/legacy/publications/library/proceedings/bsdcon02/full_papers/baldwin/baldwin_html/node5.html.</a></p>
<p><strong>Python Enhancement Proposals</strong> (<strong>PEPs</strong>) are official design documents or technical specifications in the Python community that describe a new feature that has been introduced in Python. For instance, PEP 3156 is the specification dealing with and explaining the rationale behind the introduction of the <kbd>asyncio</kbd> module. You can read this PEP document here:<br/>
<a href="https://www.python.org/dev/peps/pep-3156/">https://www.python.org/dev/peps/pep-3156/</a></p>
<p>The event loop in <kbd>asyncio</kbd> internally uses coroutines and futures to implement asynchronous behavior. Learning how to use coroutines and futures can be a valuable tool for writing more efficient and scalable programs.</p>
<p>Sockets are commonly used for interprocess communication. However, there are many other methods for interprocess communication. A brief read of <a href="http://nptel.ac.in/courses/106108101/pdf/Lecture_Notes/Mod%207_LN.pdf">http://nptel.ac.in/courses/106108101/pdf/Lecture_Notes/Mod%207_LN.pdf </a>is well worth the effort.</p>


            

            
        
    </body></html>