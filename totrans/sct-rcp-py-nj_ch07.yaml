- en: Python Enhancement Proposals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will look at **P****ython Enhancement Proposals (PEPs)**.
    PEPs are like **Requests for Comments** (**RFCs**); they allow interested parties
    to provide input on the path Python should take in the future. In this chapter,
    we will discuss the following:'
  prefs: []
  type: TYPE_NORMAL
- en: What are PEPs?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PEP 556 – Threaded garbage collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PEP 554 – Multiple subinterpreters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PEP 551 – Security transparency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PEP 543 – Unified TLS API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any programming language that is maintained requires regular updates to patch
    problems, as well as to provide new features. Python uses PEPs to propose new
    features, collect community input, and document design decisions. Thus, it is
    important to understand how the PEP process works, and to also look at some PEPs
    to see what they involve and their possible ramifications for the language.
  prefs: []
  type: TYPE_NORMAL
- en: What are PEPs?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PEPs are design documents that provide information to the Python community,
    describing new features (or proposed new features) for Python, its processes,
    or its environment. PEPs provide technical information, as well as the rationale
    for the document.
  prefs: []
  type: TYPE_NORMAL
- en: As used by the Python foundation, PEPs are the primary mechanism for communicating
    with the Python community as a whole. One requirement for PEP authorship is to
    build a consensus among the community members and document any dissenting opinions.
  prefs: []
  type: TYPE_NORMAL
- en: PEPs are kept as text files by the Python foundation, in a **content versioning
    system** (**CVS**). This versioning system acts as the historical record for each
    PEP, documenting the changes to the document, from first draft to final acceptance.
    As the CVS is based on GitHub, normal Git commands can be used to access documents,
    or they can be viewed via a browser at [https://github.com/python/peps.](https://github.com/python/peps)
  prefs: []
  type: TYPE_NORMAL
- en: 'Three types of PEP are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Standard track**: These describe a new feature or implementation for Python.
    They are also used to describe standards for interoperability outside of the standard
    Python library for current versions; later PEPs will provide for support within
    the standard library. A good example of this is the `from __future__` module for
    Python 2, from when Python 3 was being developed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Information track**: These describe Python design issues, or provide guidelines/information
    to the community, but they don''t discuss new feature proposals. These PEPs don''t
    require community consensus, nor are they official recommendations, so Python
    users are free to use or ignore informational PEPs, as desired.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Process tracks**: These describe a Python process or propose a change to
    a process. They are similar to Standard PEPs, but are applicable to areas outside
    of the Python language itself. They frequently require community consensus before
    implementation, and, because they are more than just informational, they generally
    require adherence. They make changes to the Python ecosystem, not the language,
    so the implications can affect how the language is used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As this is more of a procedural chapter than a coding chapter, this section
    will discuss the process of creating, submitting, and maintaining a PEP:'
  prefs: []
  type: TYPE_NORMAL
- en: Like many great things, the first step to creating a PEP is developing a new
    idea for Python. Just like the Unix environment expects programs to do one thing
    only, PEPs should only explain one key idea. Small improvements, such as enhancements
    or patches, typically don't need a full PEP, and can be submitted into the Python
    development process through a ticket submission.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The most successful PEPs hone in on one focused topic, and PEP editors have
    the right to reject PEPs that they consider too broad in topic or unfocused in
    their proposal. If a submitter has any doubts, it is better to submit multiple
    PEPs than try to discuss many overlapping ideas.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Every PEP must have a champion—the person who will write the PEP using the prescribed
    format, monitor and manage discussions about the PEP, and build the community
    consensus for the PEP. While the PEP champion is normally the author, it doesn't
    have to be, as in the case of an organization making a PEP; the champion is simply
    the person who advocates for the PEP the most.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Prior to drafting a PEP, interest in the idea should be determined; obviously,
    trying to champion an unwanted idea is an uphill battle and could potentially
    lead to backlash. The best way to solicit interest is by posting to some of the
    core Python contact groups via `python-list@python.org` or `python-ideas@python.org`.
    Obviously, there are many other Python forums, blogs, and other community locales
    online, but those are considered the official solicitation sites.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One of the benefits of judging community interest prior to drafting the PEP
    is to ensure the idea hasn't already been rejected before; internet searches aren't
    guaranteed to find all of the ideas that have been proposed in the past. It also
    ensures that the idea has merit within the community and isn't just a pet-project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the community has been canvassed and the idea is deemed good enough for
    a PEP, a draft PEP should be created and submitted to the `python-ideas` mailgroup.
    This allows the author to ensure the document is properly formatted and gain feedback
    prior to formal submission.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To actually submit a PEP to the Python GitHub site, a pull request must be
    made:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First, fork the PEP repository and create a file named `pep-9999.rst`. This
    is the file that will contain your PEP document.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: Push this to your GitHub fork and submit a pull request.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The PEP will be reviewed by the editors for formatting and structure.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If approved, the PEP will receive a formal PEP number and be assigned to one
    of the three tracks, as appropriate. It will also receive the *Draft* status.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Reasons for a PEP not being approved include duplicate submission (normally,
    a similar idea was submitted by someone else), being deemed technically unsound
    or unfeasible, insufficient motivation for the PEP, lack of backwards compatibility
    (obviously, this is not relevant between Python 2 and Python 3), or not keeping
    with the Python philosophy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As updates are made to a PEP, the changes can be checked in by a developer with
    git push permissions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After an official PEP number has been assigned, the draft PEP can be discussed
    on the `python-ideas` mailgroup. Eventually, however, standard track PEPs must
    be sent to the `python-dev` list for review.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Standard track PEPs comprise two parts: a design document, and a reference
    implementation. It is suggested that a prototype implementation be submitted with
    the PEP as a sanity check, to show that the idea is feasible.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the PEP is complete and ready for final submission, final consideration
    is made by Guido van Rossum, the leader of the Python Foundation, or one of his
    selected cadre. For a PEP to be accepted, it must have a complete description
    of the proposal, the proposed enhancement must be an improvement for the Python
    language or ecosystem, any interpreter implementations must not affect performance
    or capabilities or otherwise interfere with operations, and the implementation
    must meet the pythonic sensibilities of Guido van Rossum.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once a PEP has been accepted, the reference implementation is completed and
    incorporated into the main Python code repository. At that point, the PEP will
    be labeled *Finished*. Other status markers include: *Deferred* (PEP progress
    is put on hold), *Rejected* (PEP is declined by Van Rossum), and *Withdrawn* (PEP
    is removed from the pipeline by the author).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The required parts for a PEP to be accepted include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**A preamble**: This includes the PEP number, a short title, the names of others,
    and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Abstract**: A short description of the issue addressed in the PEP.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**License**: Each PEP must be either placed in the public domain or licensed
    under the Open Publication License.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Specification**: Technical specs that describe the syntax and semantics of
    new language features, detailed enough to allow interoperable implementations
    in alternate Python implementations, that is, CPython, Jython, IronPython, PyPy,
    and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Motivation**: Why the author created the PEP, and what inadequacies currently
    exist in the Python ecosystem.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rationale**: This expands on the specification by describing the motivation
    behind the PEP and why certain decisions were made regarding the implementation.
    It includes a discussion of alternative designs considered and related work, such
    as how this feature is implemented in other languages. There should also be evidence
    of community consensus and important issues raised within the community during
    the discussion process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Backwards compatibility**: Any known issues regarding backwards compatibility
    are addressed in this section. Proposed fixes for these incompatibilities must
    be included; not accounting for (or including insufficient) methods may result
    in immediate rejection of the PEP.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reference implementation**: Although it is not necessary during the draft
    and comments period, a final implementation must be provided prior to a PEP receiving
    *Final* status. The implementation must include all relevant test code and documentation
    for inclusion in the Python language reference or standard library reference.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PEPs are written in reStructuredText (such as Python docstrings), which allows
    them to be human-readable, yet easily parsed into HTML.
  prefs: []
  type: TYPE_NORMAL
- en: PEP 556 – Threaded garbage collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PEP 556 and the following PEPs are included to show recent PEP submissions that
    are potentially interesting, due to their impact on the Python ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: PEP 556 was created in September, 2017, and is currently in *Draft* status.
    It is expected to be included in Python v3.7\. It proposes a new mode of operation
    for Python's garbage collection. The new mode would allow implicit collection
    to occur within a dedicated thread, rather than synchronously with the CPU.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To discuss this PEP, we need to have a discussion about how garbage collection
    works within Python.
  prefs: []
  type: TYPE_NORMAL
- en: Garbage collection is handled by the `gc` module. While garbage collection is
    provided by Python by default, it is actually an optional feature. Using the module,
    garbage collection can be turned off, or the collection frequency can be modified;
    it also allows for debugging options. Further, it provides the ability to access
    objects that the collector identified, but cannot directly de-allocate. Python's
    garbage collector acts in conjunction with reference counting, which is one reason
    why it can be turned off.
  prefs: []
  type: TYPE_NORMAL
- en: Implicit garbage collection occurs based on the system determining that resources
    are over-allocated. When a new allocation request is made, the system reviews
    the program stats to determine which objects can be collected to allow the new
    resource to be made.
  prefs: []
  type: TYPE_NORMAL
- en: Explicit garbage collection occurs when a programmatic collection call is made
    via the Python API, for example, `gc.collect`. While this can be done by the programmer,
    such as when a file is explicitly closed, it can also occur from the underlying
    interpreter when an object is no longer being referenced.
  prefs: []
  type: TYPE_NORMAL
- en: Historically, the Python garbage collector has operated synchronously when performing
    implicit collections. This results in the program execution pausing within the
    current thread and running the garbage collector.
  prefs: []
  type: TYPE_NORMAL
- en: The problem comes from the fact that, when reclaiming resources, finalization
    code within the objects may be executed, such as `__del__` methods and weak references.
    Weak references to objects do not keep these objects *alive* enough to prevent
    garbage collection. If the only remaining references to an object are weak, then
    the garbage collector is free to destroy the object and reallocate its resources.
    Until the object is destroyed, any weak references can call and return the referenced
    object, regardless of whether there are strong references available.
  prefs: []
  type: TYPE_NORMAL
- en: Weak references are commonly used to implement a cache or map of large objects,
    when the need to keep the large object around just because it is referenced by
    the cache or map isn't necessary. In other words, weak references allow large
    objects to be removed from memory once they are no longer actively used; if the
    object is cached or mapped to associations, there is no need to keep it around,
    as those references don't have a primary affect on the object.
  prefs: []
  type: TYPE_NORMAL
- en: When finalization code exists to clean up the system when an object is closed
    and dereferenced, the active thread is paused until the finalization process is
    complete; for example, notifying other objects, or even other systems, that the
    object is no longer available. Pausing running code to handle these housekeeping
    chores can result in an internal state that causes problems when the code is restarted.
  prefs: []
  type: TYPE_NORMAL
- en: Hence, this PEP is aimed at this thread-state problem. When the running thread
    is paused and then restarted, it is fundamentally more difficult to deal with,
    rather than in multithreaded synchronization, where control is just switched between
    threads. Rather than forcing the developer to deal with problems that crop up
    when reentering the original thread, every time the thread is paused, this PEP
    addresses the issue by allowing garbage collection to occur in a separate thread,
    thus allowing the use of well-established multithreading principles.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As this is a PEP, there is no real code to create, unlike in previous chapters.
    What we will do is cover the details of the proposal and how they are intended
    to be implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Two new APIs would be added to the `gc` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `gc.set_mode(mode)` API configures the garbage-collection mode between serial
    and threaded. If it is currently set to threaded, but the setting is switched
    to serial, the function waits for the garbage collection thread to complete before
    changing.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `gc.get_mode()` API returns the current mode of operation.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The collection mode can be switched between the two options, so it is recommended
    that it be set at the beginning of a program, or when child processes are created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The actual implementation happens through adding the flag `gc_is_threaded` to
    the `gc` module; internally, a thread lock is added, to prevent multiple garbage
    collection instances from running simultaneously.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In addition, two private functions, `threading._ensure_dummy_thread(name)` and
    `threading._remove_dummy_thread(thread)`, are added to the `threading` module.
    The former creates a thread with the provided name, whereas the latter removes
    the thread from the module's internal state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These functions allow the current thread to provide the name of the garbage
    collection thread when called within a finalization callback.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Pseudocode is provided, demonstrating how the actual code would be implemented
    in the `gc` Python module as C code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`callback_collect.txt` simply enhances the current function by running garbage
    collection, up to the current object generation:'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`collect_gens.txt` is much the same, as it doesn''t modify the existing functionality.
    It is designed to collect all objects, as determined by the heuristic algorithm:'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`lock_collect.txt` demonstrates how garbage collection will be handled in a
    thread-safe manner; that is, the thread is locked during collection:'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`sched_gc.txt` ensures that garbage collection is in the threaded mode, and
    then requests the collection of resources, when available:'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`implicit_gc.txt` doesn''t modify the existing code. It simply calls for collection
    if the heuristic algorithm determines it is necessary:'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`gc_malloc.txt` allocates the memory resources to support a garbage collection
    object:'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`gc_thread.txt` spawns the garbage collection thread when called for:'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`gc_set_mode.txt` actually sets the garbage collection mode, between serial
    and threaded:'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`gc_get_mode.txt` is a getter function that simply reports whether the garbage
    collector is threaded or serial:'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`gc_collect.txt` represents a simple function that locks the thread and calls
    for garbage collection of the current object generation:'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Again, all of the preceding code is just pseudocode, representing how the C
    code would be implemented in the Python interpreter. It is not production code,
    and any attempt to use it as-is will fail.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The reason the default mode for garbage collection isn't changed to handle threads
    is because, while it would work for programs that are already multithreaded, single-threaded
    programs see finalization calls within the main thread. Changing this behavior
    may result in bugs in the program, related to finalizers existing outside of the
    main thread.
  prefs: []
  type: TYPE_NORMAL
- en: It also causes problems if the program is written to use forking for concurrency.
    Forking from a single-threaded program is fine, as that is its intended use, but
    when forking from a multithreaded program, errors can creep into the system.
  prefs: []
  type: TYPE_NORMAL
- en: Due to compatibility issues, garbage collection currently waits for the collection
    process to end before the main thread is recalled. Thus, while it may make sense
    to have explicit collection on a separate thread as well as implicit collection,
    it wouldn't really alleviate any synchronization issues when the thread restarts.
  prefs: []
  type: TYPE_NORMAL
- en: Inherent in the nature of multithreading, using a threaded garbage collector
    results in a slight delay for implicit collections when compared to serial collection.
    This delay may affect the system's memory allocation profile for some applications,
    but is expected to be minimal.
  prefs: []
  type: TYPE_NORMAL
- en: Since the pseudocode shows thread locking in several places, there could be
    implications for CPU usage. However, it is far more expensive, in terms of processing
    power, to crawl the chain of object pointers during the garbage collection process
    itself. Such crawling is almost a brute-force process, and doesn't lend itself
    easily to CPU speculation, superscalar execution, and other marvels of modern
    CPU design.
  prefs: []
  type: TYPE_NORMAL
- en: PEP 554 – Multiple subinterpreters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PEP 554 was created in September, 2017, and is currently in *Draft* status.
    It is projected for inclusion in Python v3.8\. This PEP discusses the potential
    of creating an `interpreters` module, allowing access to multiple interpreters
    within the same process.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple interpreters, also known as subinterpreters, have been a feature of
    Python since version 1.5\. While most developers are aware of the normal Python
    interpreter, either through the interactive Python console or simply by executing
    code, there is the ability to support multiple, independent interpreters within
    the same process, and, if needed, within the same thread. The subinterpreters
    can be switched between by using the `PyThreadState_Swap()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Each subinterpreter is a nearly complete, separate Python environment for code
    execution. Each interpreter has separate and independent versions of all import
    modules, system paths, and even `STDIN`, `STDOUT`, and `STDERR` streams. Extension
    modules can be shared between subinterpreters by making shallow copies of the
    module's initialization dictionary; that is, the module is effectively a single,
    copied instance between the subinterpreters, rather than re-initialized each time.
  prefs: []
  type: TYPE_NORMAL
- en: What this PEP aims to accomplish is to make subinterpreters a part of the Python
    standard library by providing high-level interfaces to the subinterpreters, much
    like the current `threading` module. The module will also allow for data sharing
    between each interpreter, rather than object sharing; that is, while objects are
    independent in each interpreter, they can still share data between themselves,
    (again, like threads).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Again, this section will present pseudocode provided in the PEP, though it
    looks like Python code, to demonstrate how the PEP would work:'
  prefs: []
  type: TYPE_NORMAL
- en: '`interpreter_isolate.txt` demonstrates running code in an isolated manner within
    an interpreter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`interpreter_spawn_thread.txt` shows an interpreter spawning a thread to run
    Python code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In `interpreter_prepopulate.txt`, an interpreter is pre-populated with imported
    modules, which are initialized; then, the interpreter waits for a call to actually
    do the work:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`interpreter_exception.txt` shows an interpreter handling an exception, which
    isn''t much different from normal operation, other than having a new interpreter
    created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '`interpreter_synch.txt` demonstrates the creation of two subinterpreters, and
    synchronizing between them with a data channel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`interpreter_data_share.txt` shows several interpreters being created and sharing
    file data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`interpreter_marshal.txt` demonstrates object passing via `marshal`. Marshaling
    data is similar to pickling or shelving, but, whereas those two modules are designed
    for general objects, `marshal` is designed for Python-compiled code in `.pyc`
    files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '`interpreter_pickle.txt` shows subinterpreters sharing serialized data using
    `pickle`*:*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '`subinterpreter_module.txt` simply shows how to use a subinterpreter to run
    a module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '`subinterpreter_script.txt`, similar to `subinterpreter_module.txt` in the
    preceding code, has an interpreter running a script. This could also be used for
    zip archives and directories:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '`subinterpreter_pool.txt` shows several subinterpreters being spawned to create
    a pool, then executing code using a thread executor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The concept of multiple interpreters is not dissimilar to multiprocessing. Each
    interpreter is (relatively) isolated from the others, like multiple processes;
    yet, externally, the system appears to be running just a single process. This
    means that system performance and resource use are significantly better than in
    true multiprocessing.
  prefs: []
  type: TYPE_NORMAL
- en: It also increases the security profile of the system, because there is some
    leakage between the different interpreters, such as file descriptors, built-in
    types, singletons, and underlying static module data. They don't require modifications
    to the isolation of processes to pass data or otherwise interact with the system.
  prefs: []
  type: TYPE_NORMAL
- en: Another benefit of subinterpreters is that they provide a method of Python concurrency
    that allows for the simultaneous use of multiple CPUs (like multiprocessing) while
    functioning like independent, isolated threads, which is currently prevented,
    due to the GIL. Hence, while there is some overlap with existing programming methods,
    it could provide an alternate form of concurrency, without the problems of other
    parallel processing paradigms.
  prefs: []
  type: TYPE_NORMAL
- en: Subinterpreters provide improved security because, by nature, they are isolated
    from each other, with each interpreter having its own memory block to play with.
    This contrasts with threads, which have a shared memory pool, by design, to facilitate
    data communications.
  prefs: []
  type: TYPE_NORMAL
- en: Channels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Subinterpreters are able to share data via channels; the Go language does this
    as well, as the concept comes from **Communicating Sequential Processes** (CSP),
    which describes interactions within concurrent systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Channels provide two modes: send and receive. In Python''s case, one interpreter
    opens a channel to another. When data is sent, it is actually data derived from
    an object; when it is received, that data is converted back into the original
    object. In this way, objects can be passed between different interpreters without
    actually having access to the objects themselves.'
  prefs: []
  type: TYPE_NORMAL
- en: Implicit calls to channels are accomplished via `send()`, `recv()`*,* and `close()`
    calls. This eliminates the need for explicit functions such as `add_channel()`
    and `remove_channel()` on an interpreter object, which would just add extraneous
    functionality to the Python API.
  prefs: []
  type: TYPE_NORMAL
- en: Channels allow many-to-many connections between interpreters, whereas normal
    data pipes only support one-to-one connections. Both are FIFO data transfers,
    so the simplicity of using pipes eliminates the ability to handle simultaneous
    data transfers between multiple interpreters. Pipes also require naming the pipes,
    whereas channels are simply available for use.
  prefs: []
  type: TYPE_NORMAL
- en: Data queues and channels are very similar, with the main difference being that
    queues allow data buffering. However, this would cause problems with the sending
    and receiving of channel data, as channels support process blocking, so queues
    were determined to not be a viable solution for subinterpreter communications.
    Plus, queues can be built using channels, if their functionality is necessary.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The only documented use of subinterpreters is in `mod_wsgi` and **Java Embedded
    Python (JEP)**. This is possibly due to their hidden nature. Though multiple interpreters
    have been available since the early days of Python, and they provide a number
    of features comparable to multithreading and multiprocessing, they simply aren't
    commonly used. To be honest, this author wasn't aware of them until finding this
    PEP, but they sound very useful for certain parallel-processing projects.
  prefs: []
  type: TYPE_NORMAL
- en: PEP 551 – Security transparency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PEP 551 is from August, 2017, and is in *Draft *status; it is also expected
    to be implemented in version 3.7\. It is designed to improve visibility into Python's
    behavior through security tools. Specifically, it attempts to prevent malicious
    uses of Python, to detect and report malicious use, and to detect attempts to
    bypass detection. The caveat is that this PEP would require user intervention,
    in the sense that they would be responsible for customizing and building Python
    for their particular environment.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some discussion of software security is required before delving into the specifics
    of this PEP. This ensures that a common level of knowledge is available to readers.
  prefs: []
  type: TYPE_NORMAL
- en: General security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In software, many vulnerabilities are due to bugs that allow remote code execution
    or privilege escalation. One of the worst vulnerabilities is the **advanced persistent
    threat** (**APT**). An APT occurs when an attacker gains access to a network,
    installs software on one or more systems, then uses that software to retrieve
    data from the network, such as passwords, financial information, and so on. While
    most APTs attempt to hide their activity, ransomware and hardware attacks are
    notable for being very *loud and proud* in announcing that they are on the network.
  prefs: []
  type: TYPE_NORMAL
- en: The systems that are infected first are often not the end targets; they are
    simply the most accessible. However, these infected systems act as pivot points
    to greater prizes within the network. For example, a developer's computer, connected
    to the internet as well as internal networks, may provide direct access for an
    attacker to get into production systems. As many low-grade systems as possible
    may be infected, just to make complete eradication more difficult.
  prefs: []
  type: TYPE_NORMAL
- en: The biggest problem with detecting such malware is an inability to see exactly
    what is happening to systems on the network. While most systems have logging capabilities,
    capturing everything overloads system administrators with data, trying to find
    the needles in a progressively larger haystack. In addition, logs take up space
    very quickly, and there is only so much space that can be allocated to log files.
  prefs: []
  type: TYPE_NORMAL
- en: Not only that, but logs are frequently filtered to display only errors and similar
    problems, not minor discrepancies. A properly written APT program shouldn't be
    causing such errors, so they wouldn't be detected by a normal log review. One
    possible way to do this is to write the malware to use the tools that are already
    installed on the target system, so malware use will be hidden within the normal,
    expected traffic.
  prefs: []
  type: TYPE_NORMAL
- en: Python and security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Python is popular for security purposes, both positive and negative, as it
    is commonly found on servers, as well as developer machines. It allows for the
    ability to execute code without having to use pre-compiled binaries, and it has
    zero internal auditing. For example, `launch_malware.py` (provided within the
    PEP) shows how easy it is to download, decrypt, and execute malicious software
    using a single Python command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This code tells the Python interpeter to execute the command that is provided.
    That command imports two libraries (`urllib.request` and `base64`*)*, then tells
    the system to execute a command that was decoded from a `base64`-encoded file
    that is downloaded from a web site.
  prefs: []
  type: TYPE_NORMAL
- en: Currently, most security-scanning tools that rely on signature files or otherwise
    recognizable code will not register this command as malicious, as `base64` encoding
    is frequently good enough to fool these systems. Because there is no file access,
    and assuming that Python is listed as an approved system application that is allowed
    to access the network and internet, this command would bypass any checks to block
    file access, check permissions, automated auditing and login, and verification
    of approved applications.
  prefs: []
  type: TYPE_NORMAL
- en: Because no system is 100% secure, especially if it has to communicate to other
    systems, many security professionals assume their systems have been attacked but
    they just haven't discovered the attacks yet. Hence, detection, tracking, and
    removal of malware is the main focus of security activities. This is where Python
    comes in; the ability to see what the Python runtime interpreter is doing at any
    given time can help indicate whether malicious, or at least unusual, activity
    is occurring.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The core part of this PEP is the introduction of two APIs that enable sysadmins
    to integrate Python into their security setup. The key factor is that these APIs
    don''t impose certain restrictions on how the systems should be configured, or
    their behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: The audit hook API allows operations to generate messages and pass them up the
    stack to the operator. These operations are normally buried within the Python
    runtime or standard library, preventing normal access to them, such as module
    imports, DNS resolution, or dynamic code compilation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following code shows how the PEP defines the API in the C code underlying
    Python. The new Python APIs for audit hooks are shown in `audit_hook_api.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'An audit hook is added by calling `sys.addaudithook()` in Python code, or `PySys_AddAuditHook()`
    for a lower-level call to the C code. Hooks cannot be deleted or replaced. Existing
    hooks are cognizant of auditing, so adding a new hook (which is audited) can cause
    an existing hook to raise an exception if it is attempted to add a new hook:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When something of interest occurs, `sys.audit()` is called. The string argument
    is the name of the event, and the remaining arguments are whatever the developer
    determines to be necessary to provide for auditing.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: During auditing, each hook is reviewed in a FIFO manner. If a hook returns an
    exception, later hooks are ignored, and the Python interpreter should quit (generally
    speaking). Of course, the developer is free to determine what happens when an
    exception occurs, such as logging the event, aborting the operation, or killing
    the process.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If no hooks have been set when an audit occurs, nothing much should happen.
    The audit call should have a minimal effect on the system, as the arguments should
    just be references to existing data, rather than calculations.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Since hooks may be Python objects, they need to be freed when the `finalize`
    function is called. In addition to releasing hooks, `finalize` will also relinquish
    any heap memory used. While it is a private function, it does trigger an event
    for all audit hooks, to ensure unexpected calls are logged.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The verified open hook API is designed to provide a way to identify files that
    can be executed versus those that cannot. Obviously, this is an important feature
    for security systems to prevent executing commands, code, or data that shouldn't
    be allowed to run in a particular environment. The following code defines the
    C code for the API.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The Python API for the verified open hook is shown in `hook_handler_api.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The Python API function is designed to be a complete replacement for `open(str(path),
    "rb")`, and its default behavior is to open a file for binary read-only access.
    When the function is called with a hook that is set, the hook will receive the
    path argument and immediately return its value, which should be an open, file-like
    object that reads raw bytes.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: This design is to allow a `BytesIO` instance if the file has already been read
    into memory, to perform any necessary verification regarding whether the file
    content is allowed to be executed. If it is determined that the file shouldn't
    be executed, an exception is raised by the hook, as well as any additional auditing
    messages.
  prefs: []
  type: TYPE_NORMAL
- en: All import and execution functionality involving code files will be changed
    to use `open_for_import()`. However, it is important to note that any calls to
    `compile()`*,* `exec()`*,* and `eval()` will not use this function; a specific
    audit hook, including the code from these calls, is necessary to validate the
    code. Most imported code will go through the API for `compile()`, so redundant
    verification should be avoided.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: PEP 543 – Unified TLS API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PEP 543 was introduced in October, 2016, for Python version 3.7, and is still
    in *Draft* status. Its goal is to define a standard TLS interface for Python,
    as a collection of abstract base classes. This interface would allow Python to
    bind to TLS libraries other than OpenSSL, to reduce dependence on the OpenSSL
    environment. By using abstract classes, programs can still use the Python interface
    for the standard `ssl` module, while actually using a different security library.
  prefs: []
  type: TYPE_NORMAL
- en: With the `ssl` module as a part of the Python standard library, it naturally
    has become the go-to tool for TLS encryption. However, some developers would prefer
    to use a different library other than OpenSSL, and incorporating these alternate
    libraries into their programs requires them to learn how to do it effectively,
    while maintaining a cohesive experience for the target platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a list of problems with the current Python TLS configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: Improvements in OpenSSL, such as higher-security TLS, cannot be easily accomplished
    without recompiling Python to use the new OpenSSL version. There are third-party
    bindings to OpenSSL, but using them requires adding another level of compatibility
    into a program.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Windows OS does not include a copy of OpenSSL, so any Python distributions
    need to include OpenSSL to ensure its availability to developers and users. This
    turns the Python dev team into OpenSSL redistributors, with all the responsibilities
    associated with that role, such as ensuring security updates are delivered when
    OpenSSL vulnerabilities are discovered.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: macOS is in a similar situation. Python distributions either need OpenSSL included
    with them, like Windows, or need to be linked to the OS-level OpenSSL library.
    Unfortunately, Apple has deprecated linking to the OS library, and the library
    itself has been unsupported for several years. At this point, the only thing to
    do is provide OpenSSL with Python for macOS, which leads to the same problems
    as on Windows.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many OSes do not allow their system encryption certificate databases to be accessed
    by OpenSSL. This requires users to either look for alternate locations to get
    their root-level trust certificates, or to export the OS certificates to OpenSSL.
    Even if OpenSSL is able to access the system-level certs, validation checks may
    be different between the libraries, resulting in unexpected behavior when using
    native tools.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For users and developers who would prefer to use alternative TLS libraries,
    such as for support for TLS 1.3 or for embedded implementations of Python, the
    primary option is to use third-party libraries to interface with their TLS library
    of choice, or to figure out how to force their selected library into Python's
    `ssl` module API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The PEP proposes several new abstract base classes, and an interface that accesses
    these classes. They can be used to access TLS functionality without being tightly
    linked to OpenSSL:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following interfaces, currently used by Python, require standardization:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configuring TLS, currently set by the `ssl.SSLContext` class.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In-memory buffer for encryption/decryption without actual I/O, currently set
    by the `ssl.SSLObject` class.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Wrapping a socket object, currently done via `ssl.SSLSocket`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Putting the TLS configuration to the wrapper objects indicated previously, currently
    done by `ssl.SSLContext`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Specifying the TLS cipher suites, currently handled by using the OpenSSL cipher
    suite strings.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Specifying application-layer protocols for the TLS handshake.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Specifying TLS versions.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Reporting errors to the calling function, currently done via `ssl.SSLError`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Specifying the client/server certificates to load.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Specifying the trust database to use when validating certificates.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing these interfaces at runtime.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In light of the buffers and sockets mentioned in the preceding list, the PEP
    aims to provide an abstract base class for wrapped buffers, but a concrete class
    for wrapped sockets.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This creates the problem that a small number of TLS libraries won't be able
    to be bound to the abstract class, because those libraries can't provide a wrapped
    buffer implementation, such as an I/O abstraction layer.
  prefs: []
  type: TYPE_NORMAL
- en: When specifying TLS cipher suites, abstract classes won't work. So, this PEP
    aims to provide a better API for cipher suite configuration, which can be updated
    to support different cipher suites based on the necessary implementation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When specifying the client/server certificates to load, a problem comes from
    the possibility that the private certificate key could become available in memory;
    that is, it could potentially be extracted from process memory. Thus, the certificate
    model needs to allow for implementations to provide a higher level of security
    by preventing key extraction, while also allowing for implementations that cannot
    meet the same requirements. The lower standard would simply maintain the current
    methodology: loading the certificate from in-memory buffer or from a file.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Specifying a trust database is difficult, because different TLS implementations
    vary in how they allow users to select their trust stores. Some implementations
    use specified formats only used by that particular implementation, while others
    may not allow for specifying stores that don't include their default trust store.
    Therefore, this PEP defines a trust store model that requires little information
    regarding the form of the store.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because `ssl.SSLContext` manages different features (holding and managing configurations,
    as well as using configurations to build wrappers), it is proposed to split these
    responsibilities into separate objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `ssl` module provides a server with the ability to modify the TLS configuration
    in response to a client's request for a hostname. This allows the server to change
    the certificate chain to match the chain needed for the hostname.
  prefs: []
  type: TYPE_NORMAL
- en: However, this method doesn't work for other TLS implementations. Those ones
    frequently provide a return value from the callback, indicating which configuration
    changes need to be made. This requires an object that can accept and hold the
    TLS configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, the PEP proposes splitting `SSLContext` into separate objects: `TLSConfiguration`
    acts as a container for the configuration, while the `ClientContext` and `ServerContext`
    objects are instantiated by `TLSConfiguration`*.*'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The PEP goes into further detail on how the API would actually be implemented,
    examples of how different TLS libraries provide the same functionality, and so
    on. There are a lot of details that aren't relevant to this book, but for those
    readers interested in utilizing TLS libraries in their projects, the details are
    worth reviewing, as the changes should be showing up in a future version of Python.
  prefs: []
  type: TYPE_NORMAL
- en: Documenting with LyX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter will cover Python documentation. Specifically, we will discuss
    how to document code, both within your program and through external documents.
    We will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Python documentation tools and techniques
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In-line comments and the `dir` command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using docstrings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using PyDoc help
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTML reports
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `reStructuredText` files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Sphinx documentation program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the LaTeX and LyX document preparation programs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Documenting code is the bane of many a programmer's existence. While code documentation
    is important, some programmers prefer to leave that work to technical writers.
    Others will provide a bare minimum of information, sometimes as README files or
    other external documents. Generally speaking, unless a program is supported by
    a company or organization, homebrew software has just enough information to tell
    you how to use it.
  prefs: []
  type: TYPE_NORMAL
- en: To be honest, some documentation comes across as being notes from the development
    timeline, rather than useful documentation. Many authors give up on installing
    a program because the documentation is inadequate, particularly when troubleshooting
    a bad install.
  prefs: []
  type: TYPE_NORMAL
- en: Python documentation tools and techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When writing code documentation, there are a number of tools and techniques
    to choose from. In this section, we will discuss some of the most common methods
    used by developers.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Code obfuscation**: First, a quick diversion into how to make your code difficult
    to read. There are valid reasons to obfuscate your code and make it difficult
    to read, such as attempting to prevent reverse-engineering. Other people just
    like the challenge; consider the International Obfuscated C Code Contest ([http://ioccc.org](http://ioccc.org)).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the other hand, making your code difficult to read can be an attempt to create
    malware that can bypass detection programs. One example is `JSF**k`, which converts
    JavaScript code into the atomic parts of JavaScript using only six different symbols,
    as shown in `jsf.js` from [http://www.jsfuck.com](http://www.jsfuck.com). The
    file demonstrates the obfuscated equivalent of `alert("This was a hidden message")`,
    but any valid JavaScript code can be replicated using the `JSF**k` utility. As
    a matter of fact, jQuery has been encoded into a fully-functional, drop-in replacement
    `JSF**k` version (jQuery Screwed), using only the six characters available.
  prefs: []
  type: TYPE_NORMAL
- en: '**Code as documentation**: Code as documentation is probably the most basic
    level of documentation available, as it requires no additional information to
    be included, besides the code itself. Naturally, this requires the code to be
    written in a manner that makes it readily apparent what the code is doing and
    how it does it.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'While every language, theoretically, is capable of self-documenting itself,
    some are worse than others. Perl is commonly cited as a bad language, as it was
    designed to be quick to write scripts, but in a very concise manner; if a lot
    of effort was made initially, it will pay off later by making it easier to write
    programs (compared to writing a simple script in C). As such, if you aren''t familiar
    with Perl, even a non-obfuscated script can be nearly impossible to read; see
    this example of Perl code (`perl_interactive.pl`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code creates a Perl interactive shell. Because Perl doesn't have
    an interactive interpreter like Python, you have to coerce the system to create
    one for you. As mentioned, if you don't know how to read Perl, it doesn't provide
    you with any help.
  prefs: []
  type: TYPE_NORMAL
- en: Source code should be easily readable on its own, as it is the only true representation
    of your program; everything else is subject to human forgetfulness, as it is more
    likely to not be updated when the code is modified. This means using intelligent
    names for variables, functions, and so on; they should be indicative of what they
    do. This way, even with no other information, someone reading it can at least
    make a guess as to what the code is supposed to do.
  prefs: []
  type: TYPE_NORMAL
- en: '**Comments**: To this author, in-line comments are the minimum level of effort
    when it comes to documenting code. Unfortunately, too many online code samples
    don''t have comments, forcing the reader to either look at external documentation
    or manually parse out what the code is doing.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Online debates have occurred regarding comments, as some other programmers don't
    believe in comments, thinking that code should be self-documenting. Others feel
    that a simple, one-line comment explaining what a function is supposed to be doing
    is much easier and quicker to read and understand than spending ten minutes walking
    the code, especially if the original developer aimed to get the job done in as
    few lines as possible.
  prefs: []
  type: TYPE_NORMAL
- en: '**dir command**: While not something a programmer does directly, Python allows
    the use of the `dir` command to list all of the functions and attributes available
    for a given module. Thus, using intelligent names for these items means that a
    simple `dir` call can provide a lot of information quickly.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Docstrings**: Docstrings are the lifeblood of Python documentation. They
    provide in-code documentation about the code, such as specifications of what parameters
    a function receives and what it returns when called. They also provide a brief
    synopsis of what each part of the code is supposed to do, in plain language.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**PyDoc**: PyDoc is a built-in Python tool-set that leverages docstrings to
    provide useful information to the user. It is most easily utilized when calling
    `help(<object>)`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The preceding list isn't all-inclusive, but it does cover the features we will
    discuss in the rest of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Inline comments and the dir command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The simplest and most common way to document code is to simply add comments
    while writing the code. This can range from simple `TODO` reminders for the developers,
    to an explanation of why the developer coded something in a particular way.
  prefs: []
  type: TYPE_NORMAL
- en: As seen previously, comments in Python code start with a hash mark, `#`, and
    continue to the end of the line. Multi-line comments can be made by adding a hash
    mark at the beginning of each line, or triple quotation marks can be used instead.
    Keep in mind, though, that certain tools don't know about triple-quoted comments,
    so it's better to use them sparingly.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with in-line comments is that they can only be seen if you are actively
    looking at the code. While we will discuss ways to access in-code comments, these
    basic one-liners are not actively culled by documentation parsers.
  prefs: []
  type: TYPE_NORMAL
- en: 'If, however, you want to see what functions a module provides to the developer,
    using the `dir()` function is one easy way of doing that. The following is information
    about what the `dir()` function provides:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/12509504-eb12-4004-aab4-cc88734aa852.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following example shows `dir()` being used to show all of the functions
    available within the `math` module (which must be imported first):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f7378978-e599-4083-800d-9f225208a10a.png)'
  prefs: []
  type: TYPE_IMG
- en: There isn't a lot of extremely useful information when using `dir()`, but it
    can help if you only need to know what functions and attributes are available
    to you, without having to dig into more detailed documentation.
  prefs: []
  type: TYPE_NORMAL
- en: This is a good time to review how Python uses underscores. Entries with two
    leading underscores, such as `__doc__` from the screenshot, are attributes associated
    with the Python interpreter, and should not normally be directly called by the
    developer. Also, since they are predefined for Python's use, their names shouldn't
    be reused for a different purpose within a program. For example, using `__name__`
    as a variable name can result in program errors.
  prefs: []
  type: TYPE_NORMAL
- en: Single leading underscores indicate pseudo-private items. Because Python doesn't
    have public/private attributes like other languages, programmers have to be a
    little more cognizant of what they are trying to do. Pseudo-private items can
    be used like normal items; the underscore simply tells anyone looking at the code
    that the pseudo-private items shouldn't be used outside their intended area.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, pseudo-private items won''t be imported when using `from <module>
    import *`. This is part of their private nature. They will, however, be imported
    when using `import <module>`. Thus, to ensure all functions and attributes are
    available to you when importing a module, you need to use the regular `import`.
    Of course, accessing those items will require you to clarify them using dot-nomenclature:
    `<module>.<item>`.'
  prefs: []
  type: TYPE_NORMAL
- en: Using docstrings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docstrings are triple-quoted strings that have special significance within Python.
    When used, they form the `__doc__` attribute of an object. While not using docstrings
    is fine, and there are many examples of projects that don't have them if you do
    use them, it is worth looking at PEP 257 to see how to do them right. While violating
    the guidelines in the PEP won't hurt your code but may make other programmers
    question you, it will really hurt if you try to use tools such as Docutils, as
    they expect docstrings to be properly formatted.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docstrings are the very first items in a module, function, class, or method;
    if they are put elsewhere, chances are, tools that won't recognize them as docstrings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Docstrings can be single or multi-line, as shown in the following, `docstring_example.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: By convention, single-line docstrings are for obvious use cases. The reason
    triple quotes are used, even for one line, is to easily allow for future expansion
    of the docstring, if needed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A single-line docstring should be considered a summary statement of the object
    and should end with a period, as it should describe what the object does, that
    is, *Does this* or *Returns this*. They shouldn't be a description of the action;
    for example, *Returns the pathname of the root-level object*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You'll note that, in the preceding example, both docstrings failed to follow
    this guidance. As these are guidelines and not hard-and-fast rules, this is allowed.
    This author just feels more comfortable explaining what is going on within the
    docstring, even if it is redundant to the actual code. This comes back to the
    fact that it is easier to read what something does and then see the code that
    implements it, than having to decipher exactly what the code is supposed to do.
  prefs: []
  type: TYPE_NORMAL
- en: 'Multi-line docstrings have the summary statement, just like single-line docstrings,
    but then they continue with more information. The additional information can be
    anything the programmer feels is important, though PEP 257 provides guidelines
    for different objects. These are paraphrased in the following for one-stop-shopping:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Class docstrings should have one blank line between the end of the docstring
    and the first method. They should summarize the class's behavior, and list both
    public methods and instance variables.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If the class will be subclassed, and there is an interface for the subclasses,
    the subclass interface should be listed separately in the docstring. The class
    constructor should have its own docstring in the `__init__` method.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If a class is a subclass of another and primarily inherits its behavior, the
    subclass's docstring should indicate this and show the differences. The word `override`
    should be used to indicate where a subclass method replaces an inherited method.
    The word `extend` should indicate where a subclass method calls an inherited method
    and adds functionality.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Module docstrings should list the classes, exceptions, functions, and other
    objects that are exportable, with a one-line summary of each.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Package docstrings (located in the `__init__.py` module for the package) should
    list the modules and subpackages exported by the package.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Function/method docstrings should summarize behavior and document all arguments
    (required and optional), return values, side-effects, exceptions, and restrictions
    on when the function or method can be called. Any keyword arguments should also
    be noted.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Another related part of docstrings are doctests. Doctests are actually handled
    by the `doctest` module, and look for texts within a docstring that look like
    interactive Python sessions, complete with the `>>>` prompt. Any such code is
    executed as it was entered by the user within an interactive shell, and compared
    to the expected results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Doctests are commonly used to ensure docstrings are kept up-to-date by testing
    that the examples work with any changes to the code itself—for regression testing
    by checking that test files still work, and in tutorial development that includes
    input/output examples. The following is an example of a doctest (`doctest.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'One of the hardest parts is writing tests to simulate an interactive session,
    as the following screenshot demonstrates:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/42761ba9-f9ba-4636-8cc4-683a5f68cc79.png)'
  prefs: []
  type: TYPE_IMG
- en: 'At first glance, it looks like it should be the same answer. The problem comes
    in lining up the `doctest` output with where it would be if the command was manually
    typed in. However, when the test is correctly written, an uninformative response
    is provided by the system, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f3051b4c-cbcd-4cea-bad5-be7a77f90ffa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This just means that all of the tests passed, much like how using the `unittest`
    module to create tests returns only a `.` for a successful test. To get something
    more meaningful, or to see how the test was conducted, you have to provide the
    `-v` option to the command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4f31df96-1e60-45ed-b110-c66ce86dfae1.png)'
  prefs: []
  type: TYPE_IMG
- en: There's a lot more to doctests than could be covered here, but what we covered
    is sufficient for most needs. The documentation goes into things such as pulling
    tests from external test files, rather than directly in line with the code; how
    to deal with exceptions; and similar material, as well as the backend details
    of how the doctest engine works.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following is a screenshot of the docstring for Python''s `random` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a38f6110-6d85-4f9b-ae72-9aa3f9c43462.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This information doesn''t really tell you a lot about the module, as it is
    simply a description of it. To get more comprehensive information, you would have
    to use `help(random)`*,* as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3565ab9f-5817-442a-abb6-779a4451e062.png)'
  prefs: []
  type: TYPE_IMG
- en: This listing actually continues on for more than 20 pages of formatted text,
    much like Unix `man` pages. But this is everything you need to know about a module
    and what it contains; so, if you happen to not have internet access but need to
    know how to use a Python module, this is one way of doing it.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also do this with individual elements within a module. For example,
    the following screenshot shows the results of `help(random.seed)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1723dfae-a334-45c4-8bbb-8e402d3467a1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This same information is available by using `print(random.seed.__doc__)`, if
    you prefer that route:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/036bc2b0-f510-48d8-bc4d-df127fb0fd8f.png)'
  prefs: []
  type: TYPE_IMG
- en: Using PyDoc help
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you use docstrings appropriately, you can harness the power of PyDoc, which
    is a built-in Python toolset that can extract docstrings and other information
    and format them into easy-to-read text. While there are many other tools available,
    PyDoc comes with Python, so you can be sure of it being available (as long as
    you have access to the Python standard library).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PyDoc is accessed by using the `help()` function, as seen previously. While
    built-in objects can have multiple pages of information, your code doesn't have
    to be as elaborate, unless you want it to be. Depending on the Python version
    being used, you don't have to import the module you want help on, but it is generally
    better to import it, just to make sure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Looking back at the preceding `random()` example, you can see that a lot of
    information is available via `help()`; of course, it is all dependent on how much
    information the developer decides to put into the docstrings. Functionally, the
    output is very much like using the Unix `man` command to view online command manuals.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'One of the great things about `help()` is that it can be used on any Python
    object, not just modules, when calling `help(list)`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a2829ffb-75b0-42b6-be9a-d30f9892cebd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can even look at the functions and methods that are included with a Python
    object, such as `help(list.pop)`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b058342b-d126-4e4f-96f8-e8169357ee11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In addition to using the name of the object type (for example, `list`), you
    can even use the actual object structure, as shown with `help([].sort)`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c1dc3e3b-64cc-4fd2-b01c-fd94643352d2.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding examples show why following the recommended docstring guidelines
    is so important. There is an expected way for the information to be displayed,
    and, as a developer, you don't know what methods users of your code will use to
    access the help features available for Python. At a minimum, internal consistency
    within your project is important, even if you don't follow the official Python
    guidelines.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: HTML reports
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For people who prefer a more visual help tool, or prefer to keep a browser open,
    PyDoc includes the ability to create HTML files from the official Python documentation.
    Depending on the version of Python being used, there are several different ways
    to access the HTML information.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Starting in Python 3.2, help web pages can be opened by using `python -m pydoc
    -b`. If you have both Python 2 and 3 installed, you can specify which Python version
    you desire to work with; for example, `python3 -m pydoc -b`*.* If you are using
    Python 2, then use the command `python -m pydoc -p <port>`. The port number can
    be 0, which will pick a random, unused port address for the web server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Regardless of which version you use, it should open up a web page similar to
    the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1fc57159-1c5b-4926-9739-bf58db8746df.png)'
  prefs: []
  type: TYPE_IMG
- en: 'All of the modules available in Python are shown as hyperlinks. You can also
    search for entries via the *Search* box; alternatively, if you know the name of
    the module you''re interested in, enter it directly into the Get box. When clicking
    on the hyperlinks, you will get the same information provided on the Python website
    or by using the `help()` command, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4ed1b35e-7a5c-402f-ba78-d411e4f9aa27.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In addition to the built-in modules, if you run PyDoc from a virtual environment,
    you''ll receive information about the virtual environment, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3d2ce927-264a-4a99-a416-5ad997cfe50e.png)'
  prefs: []
  type: TYPE_IMG
- en: This way, you can not only view the default modules available within Python,
    but you can see what has has been placed in your virtual environment, if desired.
  prefs: []
  type: TYPE_NORMAL
- en: 'An alternative way to access the help files is by using the command `python
    -m pydoc -g`, which opens up a generic-looking window to launch the browser window
    or to search it directly, shown as follows (you will need to have the `python-tk`
    package installed for this to run):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/67dec03a-c990-4934-a29f-43284875e116.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you enter information in the search bar, you will get a little information,
    but not much, shown as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ab7087ce-97de-4383-807e-4e1ee5e6da4f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In this case, if we go to `multiprocessing.pool`, as in step 3 earlier, we
    can see that the information is presented in a similar web page; obviously, however,
    the information is different, because this is Python 2.7, whereas the previous
    example was Python 3.6.5:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2dc4bc3c-d8e1-4789-8422-bb7755ba7dc6.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot shows the same information as in step 3 above, but
    the formatting is different because it is for Python 2.7.
  prefs: []
  type: TYPE_NORMAL
- en: Using reStructuredText files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Plain text, by definition, is limited in what information it can provide; that
    is, there is no metadata inherent in a text file (apart from what is provided
    by the filesystem). In other words, there is no way to bold, italicize, or otherwise
    augment raw text, to provide some sort of contextual information.
  prefs: []
  type: TYPE_NORMAL
- en: A number of markup languages have been developed over the years, with HTML being
    a prime example this. However, HTML is a little heavy for in-code documentation
    purposes. Something more like Wikitext ([https://en.wikipedia.org/wiki/Help:Wikitext](https://en.wikipedia.org/wiki/Help:Wikitext))
    would make more sense, as it uses simple ASCII characters to provide context to
    raw text. Hence, PEP 287 proposes the **reStructuredText** (**reST**) markup be
    used for structured text documentation within Python docstrings, PEPs, and other
    documents that require structured markup. Of course, plain text docstrings are
    not deprecated; reST simply provides more options, for developers who want to
    be more expressive in their documentation[.](https://en.wikipedia.org/wiki/Help:Wikitext)
  prefs: []
  type: TYPE_NORMAL
- en: The official location for reST documentation can be found at [http://docutils.sourceforge.net/rst.html](http://docutils.sourceforge.net/rst.html).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you want to work with reST on its own, you can install the Docutils program
    ([http://docutils.sourceforge.net/index.html)](http://docutils.sourceforge.net/index.html).
    [This tool allows you to convert reST into HTML, LaTeX, man pages, XML, or other
    formats.](http://docutils.sourceforge.net/index.html)
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you just want to include reST in your Python documentation, the following
    is a quick introduction on how the basic syntax works; at the end are screenshots
    of how all of these look in practice (a more thorough demonstration is available
    at [http://docutils.sourceforge.net/docs/user/rst/demo.html](http://docutils.sourceforge.net/docs/user/rst/demo.html)):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The paragraph is the most basic pattern in reST. It is simply a block of text
    separated from other text blocks by a single, blank line. The blocks must have
    the same indentation, starting at the left edge. Indenting paragraphs results
    in offset paragraphs, typically used to show quoted text.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Inline markup can be performed by using asterisks, that is, `*italics*` and
    `**bold**`. Monospaced, literal text is denoted with double-backticks: [PRE27].
    Note that any special characters that would normally mark up text are expressed
    literally, and not interpreted as markup.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: To use special characters, reST is semi-intelligent. Using a single asterisk
    will not cause any markup to occur. To mark-off text with asterisks without it
    being marked up, use double-backticks, or escape the asterisk by using `\*`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Lists can be created in three ways: enumerated, bulleted, or definitions. Enumerated
    lists start with either a number or a letter, followed by a `.`, `)`, or `()`;
    that is, `1.`, `A)`, and `(i)` are all valid.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Bullets are created using either `*`, `+`, or `-`. The symbol that appears depends
    on the character used. Sub-bullets need two spaces from the original to be recognized.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Definition lists, while classified as lists, are more like special-purpose paragraphs.
    They consist of a term and, on the following line, an intended definition block.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Preformatted code samples can be indicated by using `::`. The `::` symbol appears
    on the line prior to the indented code block; think of a quoted paragraph preceded
    by a line that ends in `::`. The preformatting ends when the indentation returns
    to normal.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Section headers are indicated by using a series of characters directly underneath
    a line of text. The characters must be of the same length as the text. Each set
    of characters is assumed to be at the same heading level, so don''t just pick
    characters randomly. Any of the following characters are allowed: ``- _ : ` ~
    '' " ^ * + = # < >``.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The title and subtitle are designated similarly to section headers, except that
    both the lines above and below the text have a series of characters, rather than
    just the line below, as in headers.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Images are included by using `.. image::`, followed by the image location. The
    image can be on a local drive or on the internet.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is an example of all of the items discussed earlier, with the
    raw ST and the output next to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a8fcb46a-2cd9-4056-8458-63741a392ba6.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot shows the generic HTML template for the online reST
    editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows how the exact same reST markup can be converted
    into a completely different look by the parsing engine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ce830d3b-52f6-419e-b68e-5c960599bd7c.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot shows an alternate HTML template that can be used with
    the online reST editor.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Sphinx documentation program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sphinx was written for Python documentation and is used extensively in official
    document creation. As a matter of fact, all of the documentation on the Python
    site is generated by Sphinx. Even the Sphinx website is written in reST and converted
    to HTML.
  prefs: []
  type: TYPE_NORMAL
- en: Sphinx can convert reST into HTML, PDF, ePub, Texinfo, and man pages. The program
    is also extensible, for example, via plugins, to generate mathematical notations
    from formulas or highlight source code.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Download Sphinx via `pip` or system installation, such as with `apt install`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once installed, it is suggested you move to the project directory, as the program
    defaults to looking for files in the current directory. This is not required,
    however, as you can always change the configuration later.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the following command at the command prompt: `sphinx-quickstart`. You will
    walk through an interactive configuration session, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f27daa9d-5634-4c9f-a44d-41c61753e995.png)'
  prefs: []
  type: TYPE_IMG
- en: The questions are generally self-explanatory, but be sure to check the documentation
    if something doesn't make sense. Don't panic, however, if you just pick the defaults
    and don't get the results expected. This process is simply creating the default
    configuration files, which can be manually modified later.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A key thing to point out is that, if you want to use your docstrings to generate
    your documentation, ensure that you select `autodoc` for installation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In your directory, you should now see some new files, specifically `conf.py`
    and `index.rst`. These are used to allow Sphinx to operate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`conf.py`, naturally enough, is the config file for Sphinx. It is the primary
    location for setting up Sphinx, and entries made during the quickstart process
    are stored here.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`index.rst` is the primary file for telling Sphinx how to create the final
    documentation. It basically tells Sphinx which modules, classes, and so on, to
    include in the documentation.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By default, `conf.py` looks for files in `PYTHONPATH`; if you are looking to
    use files in another location, make sure that you set it up correctly, at the
    top of the file. Specifically, remove the comments from `import os`, `import sys`,
    and the `sys.path.insert()` line (and update the path as needed), as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/96eda21f-a2a7-49d8-982d-b81180bafa42.png)'
  prefs: []
  type: TYPE_IMG
- en: As this example has Sphinx running in the same directory as the module, there
    was no need to change the path.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you set up `conf.py` to use `autodoc`, the next step is relatively easy.
    Go to `index.rst` and tell Sphinx to automatically find the information for the
    documentation. The easiest way to do this is to take a look at [http://www.sphinx-doc.org/en/stable/ext/autodoc.html#module-sphinx.ext.autodoc](http://www.sphinx-doc.org/en/stable/ext/autodoc.html#module-sphinx.ext.autodoc),
    which explains how to automatically import all desired modules and retrieve the
    docstrings from them. The following is a screenshot of the entries made for this
    example; specifically, the `automodule` and sub-entries were added. Everything
    else is at its default value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/78c2613d-3c7b-4423-b617-2b070dd7a514.png)'
  prefs: []
  type: TYPE_IMG
- en: The `automodule` object (and the module name) tells Sphinx the name of the Python
    module to import. As a reminder, the module name is simply the Python filename,
    without the `.py` extension.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: The `members` object automatically gathers documentation for all public classes,
    methods, and functions that have docstrings. If you don't use it, only the docstring
    for the main object (a module, in this case) will be imported.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `undoc-members` object does the same thing, except it will get objects that
    don't have docstrings. Obviously, the information for these items will be limited,
    as compared to a docstring.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `show-inheritance` object specifies that the inheritance tree for the module
    will be included. Needless to say, if you aren't using inheritance, this won't
    do much good.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once you have the configuration and index files set, you can run the command
    `make html`, to generate the HTML files for your project. You may run into errors,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e78e2d57-254e-49f0-9f13-e2417511f4d2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'These errors actually mean that the source code doesn''t have the spacing requirements
    expected by reST. The following screenshot is part of the code used in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3aca498a-650c-4a74-ae92-3630b5111ca5.png)'
  prefs: []
  type: TYPE_IMG
- en: Specifically, a blank line is required between each grouping within the docstring;
    that is, the `param` entries are separate from `except`, which is separated from
    `return`*.* When the HTML command was run, the blank lines between these items
    were not present.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you finally correct all of the problems, you should get a successful make,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0e0a578b-d4b9-4761-a2d7-a506a4a0a1ab.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, you can go into the target directory and look for `index.html` in the `_build/html`
    directory (assuming that you used the default values).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When you open it, you should see something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/bebb963d-7149-43ff-bd1f-9337e5bc3fcf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you don''t like the default theme, there are a number of other themes included
    with Sphinx. Obviously, given that it is HTML, you can make your own, as well.
    Here is the included theme, *scrolls*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/17933854-5138-488a-96e0-cb4cf371a278.png)'
  prefs: []
  type: TYPE_IMG
- en: Using LaTeX and LyX document preparation programs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When preparing external documentation (not docstrings or other in-code documentation),
    most people resort to Microsoft Word or another word processor, though nowadays
    HTML is a viable option, as well.
  prefs: []
  type: TYPE_NORMAL
- en: This final section will discuss an alternative to word processors. Word processors
    are **WYSIWYG**, which stands for **What You See Is What You Get**; in other words,
    what you see on the screen is essentially what you'll see in the finished product.
  prefs: []
  type: TYPE_NORMAL
- en: One alternative that we will discuss here is document processors. While they
    tend to look similar to word processors, document processors emphasize the layout
    of the document's components, rather than formatting text. In other words, document
    processors are **WYSIWYM **(**What You See Is What You Mean**). With these programs,
    what is seen on the screen is not representative of how the final product will
    look.
  prefs: []
  type: TYPE_NORMAL
- en: LyX (pronounced *licks*) is one of the more popular document processors. It
    acts as a graphical frontend to the LaTeX typesetting system, and can be used
    for documents ranging from books and notes to letters and academic papers.
  prefs: []
  type: TYPE_NORMAL
- en: LyX allows the user to state what type of component a particular part of the
    paper is; for example, a chapter, heading, paragraph, and so on. Then, the backend
    software handles formatting it. This enables the user to simply write the document
    and not worry about how the document will look.
  prefs: []
  type: TYPE_NORMAL
- en: LyX relies on LaTeX (pronounced *lateck*, as the X is actually the Greek letter
    Chi), which is a typesetting and document preparation system. When using LaTeX
    directly, the user writes a document in plain text, using markup tags to identify
    what different parts should be in the final document.
  prefs: []
  type: TYPE_NORMAL
- en: LaTeX is widely used in Academia, as it has support for mathematical equations,
    creates print-ready documents, supports multiple languages, and doesn't have the
    memory problems a word processor has, meaning that a user is less likely to have
    a system crash when writing large documents with graphics.
  prefs: []
  type: TYPE_NORMAL
- en: 'LyX and LaTeX are properly written in camelCase, as the *T* and *X* are actually
    Greek letters: *T = tau* and *X = chi*.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To use LyX, you can download the binary installer from the LyX website ( [https://www.lyx.org/Download](https://www.lyx.org/Download))
    or use a Linux package manager to download it; for example, `apt install lyx`.
  prefs: []
  type: TYPE_NORMAL
- en: You can install LaTeX separately, but it is recommended to just install LyX,
    as LaTeX is included with it, and you gain access to a LaTeX GUI, as well.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you first open LyX, you are presented with a window very similar to a
    word processor, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6725fa83-91f5-47a3-ac20-9de99ff81b57.png)'
  prefs: []
  type: TYPE_IMG
- en: It is highly recommended you take a look at the documents under the Help menu,
    particularly the Introduction and Tutorial. Doing so will only take a few hours,
    at most, but they explains the majority of the basic features of LyX.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Of special note is the drop-down box in the top-left corner, labeled Standard
    in the screenshot. This is the Environment interface for determining what a text
    component is. The following options are available through this menu:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Standard`: Normal paragraph.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LyX-Code`: LyX-specific commands.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Quotation`: Always indents the first line of a paragraph, and uses the same
    line spacing throughout.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Quote`: Uses extra spacing to separate paragraphs, and never indents the first
    line.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Verse`: Used for poetry or songwriting.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Verbatim`: Preformatted, monospace text.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Separator`: Allows for splitting lists.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Labeling`: Assigns a definition to a word.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Itemize`: Bulleted list.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Enumerate`: Sequential list.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Description`: Similar to Labeling, but with a different format.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Part/Part*`: Equivalent to a chapter. For this, and the following items, `<name>*`
    indicates that no number is included; otherwise, the number of the item is included
    by default.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Section/Section*`: Section within a chapter.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Subsection/Subsection*`: Part of a section.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Subsubsection/Subsubsection*`: Part of a subsection.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Paragraph/Paragraph*`: Bolds a paragraph.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Subparagraph/Subparagraph*`: Indented version of Paragraph.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Title/Author/Date`: Self-explanatory.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Address/Right Address`: Primarily used for letters; the only difference is
    the justification of the address.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Abstract`: Executive-style summary of the document.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Bibliography`: Manually creates a reference section.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition to these, LyX provides for the auto-creation of a table of contents,
    index, and bibliography. It can also handle text wrapping around graphics, the
    captioning of graphics, programming code, tables, floating text boxes, colorizing
    text, rotated text, and so on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following is a screenshot of the LyX Tutorial section, as written within
    the editor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f2f3cd24-6304-43f3-acf2-37b202255c4e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is the same section, when converted to a PDF:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5c307ed9-aa57-47cb-8e30-03b0615703ae.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is the same section in raw LaTeX markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d4d51b3b-6747-4645-a586-fc397c2ec695.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As a final example, more relevant to programmers, here is a screenshot of this
    author''s first book, *Learning to Program Using Python*, which was written entirely
    in LyX:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/13501f74-2d4c-4e5a-965b-92d1338ce079.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following is that same section in a PDF:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6a885e0f-e053-4217-8b2e-930162f49270.png)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like many Unix-oriented tools, LaTeX can be difficult to work with, especially
    when it comes to troubleshooting. LyX itself is fairly straightforward, as it
    is essentially just a graphical wrapper around LaTeX. Therefore, if problems are
    going to develop, it will be within the underlying TeX environment.
  prefs: []
  type: TYPE_NORMAL
- en: Problems will occur when attempting to generate PDF files or otherwise export
    your LyX file to another file format. Frequently, these issues can be resolved
    by installing additional software, which can sometimes be identified within the
    error message.
  prefs: []
  type: TYPE_NORMAL
- en: For example, during the creation of this book, this author had a problem creating
    a PDF copy of the Tutorial, because an error kept occurring when converting the
    EPS images to PDF images. This was ultimately resolved by using `apt-cache search
    epstopdf`, as determined by the error message. This revealed that the required
    tool is located in `texlive-font-utils`, which would not have been immediately
    apparent. Fortunately, after installation, the PDF export worked.
  prefs: []
  type: TYPE_NORMAL
- en: All of this discussion is to emphasize that, while LyX and LaTeX are extremely
    powerful and useful tools, it takes a significant commitment to use them. A basic
    installation may not provide the tools necessary for your project. However, if
    you make that commitment, it can be a very useful environment not only for code
    documentation, but also for the creation of any document. There are even a number
    of Python tools listed in PyPI that can interact with the core TeX language.
  prefs: []
  type: TYPE_NORMAL
