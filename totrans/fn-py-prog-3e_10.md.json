["```py\nfrom functools import lru_cache \n\n@lru_cache(128) \ndef fibc(n: int) -> int: \n    if n == 0: return 0 \n    if n == 1: return 1 \n    return fibc(n-1) + fibc(n-2)\n```", "```py\nfrom functools import cache \nfrom math import factorial \n\nfactorial = cache(factorial)\n```", "```py\nfrom typing import NamedTuple \n\nclass Card1(NamedTuple): \n    rank: int \n    suit: str\n```", "```py\n>>> c2s = Card1(2, ’\\u2660’) \n>>> c2h = Card1(2, ’\\u2665’) \n>>> c2s \nCard1(rank=2, suit=’♠’) \n>>> c2h \nCard1(rank=2, suit=’♡’) \n\n# The following is undesirable for some games: \n\n>>> c2h == c2s \nFalse\n```", "```py\nfrom functools import total_ordering \nfrom typing import NamedTuple \n\n@total_ordering \nclass Card2(NamedTuple): \n    rank: int \n    suit: str \n\n    def __str__(self) -> str: \n        return f\"{self.rank:2d}{self.suit}\" \n    def __eq__(self, other: Any) -> bool: \n        match other: \n            case Card2(): \n                return self.rank == other.rank \n            case int(); \n                return self.rank == other \n            case _: \n                return NotImplemented \n    def __lt__(self, other: Any) -> bool: \n        match other: \n            case Card2(): \n                return self.rank < other.rank \n            case int(); \n                return self.rank < other \n            case _: \n                return NotImplemented\n```", "```py\n>>> c2s = Card2(2, ’\\u2660’) \n>>> c2h = Card2(2, ’\\u2665’) \n>>> c2h == c2s \nTrue \n\n>>> c2h == 2 \nTrue \n>>> 2 == c2h \nTrue\n```", "```py\n>>> c2s = Card2(2, ’\\u2660’) \n>>> c3h = Card2(3, ’\\u2665’) \n>>> c4c = Card2(4, ’\\u2663’) \n>>> c2s <= c3h < c4c \nTrue\n```", "```py\n>>> exp2 = partial(pow, 2)\n>>> exp2(12)\n4096\n>>> exp2(17)-1\n131071\n\n```", "```py\n>>> exp2 = lambda y: pow(2, y)\n```", "```py\n>>> m = mean(some_data) \n>>> std = stdev(some_data) \n>>> z_value = partial(z, m, std) \n>>> normalized_some_data = [z_value(x) for x in some_data]\n```", "```py\n>>> d = [2, 4, 4, 4, 5, 5, 7, 9]\n```", "```py\n>>> from functools import reduce \n\n>>> reduce(lambda x, y: x+y, d) \n40 \n>>> 2+4+4+4+5+5+7+9 \n40\n```", "```py\n>>> ((((((2+4)+4)+4)+5)+5)+7)+9 \n40\n```", "```py\n>>> reduce(lambda x, y: x+y**2, d, 0) \n232\n```", "```py\n>>> 0 + 2**2 + 4**2 + 4**2 + 4**2 + 5**2 + 5**2 + 7**2 + 9**2 \n232\n```", "```py\n>>> 2 + 4**2 + 4**2 + 4**2 + 5**2 + 5**2 + 7**2 + 9**2 \n230\n```", "```py\nfrom collections.abc import Callable \nfrom functools import reduce \nfrom typing import cast, TypeAlias \n\nFloatFT: TypeAlias = Callable[[float, float], float] \n\nsum2 = lambda data: reduce(cast(FloatFT, lambda x, y: x+y**2), data, 0.0) \nsum = lambda data: reduce(cast(FloatFT, lambda x, y: x+y), data, 0.0) \ncount = lambda data: reduce(cast(FloatFT, lambda x, y: x+1), data, 0.0) \nmin = lambda data: reduce(cast(FloatFT, lambda x, y: x if x < y else y), data) \nmax = lambda data: reduce(cast(FloatFT, lambda x, y: x if x > y else y), data)\n```", "```py\nfrom collections.abc import Callable, Iterable \nfrom functools import reduce \nfrom typing import TypeVar, cast \n\nST = TypeVar(\"ST\") \n\ndef map_reduce( \n    map_fun: Callable[[ST], float], \n    reduce_fun: Callable[[float, float], float], \n    source: Iterable[ST], \n    initial: float = 0 \n) -> float: \n    return reduce(reduce_fun, map(map_fun, source), initial)\n```", "```py\nfrom collections.abc import Iterable \n\ndef sum2_mr(source_iter: Iterable[float]) -> float: \n    return map_reduce( \n        map_fun=lambda y: y**2, \n        reduce_fun=lambda x, y: x+y, \n        source=source_iter, \n        initial=0)\n```", "```py\nfrom collections.abc import Iterable \nimport operator \n\ndef sum2_mr2(source: Iterable[float]) -> float: \n    return map_reduce( \n        lambda y: y**2, \n        operator.add, \n        source, \n        0)\n```", "```py\ndef count_mr(source: Iterable[float]) -> float: \n    return map_reduce( \n        lambda y: 1, \n        lambda x, y: x+y, \n        source, \n        0)\n```", "```py\n>>> import operator \n>>> from functools import reduce \n>>> d = [] \n>>> reduce(operator.add, d, \"hello world\") \n’hello world’\n```", "```py\nfrom functools import partial, reduce \n\npsum2 = partial(reduce, lambda x, y: x+y**2) \npcount = partial(reduce, lambda x, y: x+1)\n```", "```py\n>>> d = [2, 4, 4, 4, 5, 5, 7, 9] \n>>> sum2(d) \n232.0 \n>>> psum2(d) \n230 \n\n>>> count(d) \n8.0 \n>>> pcount(d) \n9\n```", "```py\nfrom collections.abc import Callable, Iterable \nfrom functools import reduce \n\ndef comma_fix(data: str) -> float: \n    try: \n        return float(data) \n    except ValueError: \n        return float(data.replace(\",\", \"\")) \n\ndef clean_sum( \n    cleaner: Callable[[str], float], \n    data: Iterable[str] \n) -> float: \n    return reduce(operator.add, map(cleaner, data))\n```", "```py\n>>> d = (’1,196’, ’1,176’, ’1,269’, ’1,240’, ’1,307’, \n... ’1,435’, ’1,601’, ’1,654’, ’1,803’, ’1,734’) \n\n>>> clean_sum(comma_fix, d) \n14415.0\n```", "```py\n>>> sum = clean_sum(comma_fix, d)\n>>> comma_fix_squared = lambda x: comma_fix(x)**2\n>>> sum_2 = clean_sum(comma_fix_squared, d)\n\n```", "```py\n>>> data = [(’4’, 6.1), (’1’, 4.0), (’2’, 8.3), (’2’, 6.5), \n... (’1’, 4.6), (’2’, 6.8), (’3’, 9.3), (’2’, 7.8), \n... (’2’, 9.2), (’4’, 5.6), (’3’, 10.5), (’1’, 5.8), \n... (’4’, 3.8), (’3’, 8.1), (’3’, 8.0), (’1’, 6.9), \n... (’3’, 6.9), (’4’, 6.2), (’1’, 5.4), (’4’, 5.8)]\n```", "```py\nfrom collections import defaultdict \nfrom collections.abc import Iterable, Callable, Iterator \nfrom typing import Any, TypeVar, Protocol, cast \nDT = TypeVar(\"DT\") \n\nclass Comparable(Protocol): \n    def __lt__(self, __other: Any) -> bool: ... \n    def __gt__(self, __other: Any) -> bool: ... \n    def __hash__(self) -> int: ... \nKT = TypeVar(\"KT\", bound=Comparable) \n\ndef partition( \n    source: Iterable[DT], \n    key: Callable[[DT], KT] = cast(Callable[[DT], KT], lambda x: x) \n) -> Iterator[tuple[KT, Iterator[DT]]]: \n    \"\"\"Sorting deferred.\"\"\" \n    pd: dict[KT, list[DT]] = defaultdict(list) \n    for item in source: \n        pd[key(item)].append(item) \n    for k in sorted(pd): \n        yield k, iter(pd[k])\n```", "```py\nfrom itertools import groupby \nfrom collections.abc import Iterable, Callable, Iterator \n\ndef partition_s( \n    source: Iterable[DT], \n    key: Callable[[DT], KT] = cast(Callable[[DT], KT], lambda x: x) \n) -> Iterable[tuple[KT, Iterator[DT]]]: \n    \"\"\"Sort source data\"\"\" \n    return groupby(sorted(source, key=key), key)\n```", "```py\n>>> for key, group_iter in partition(data, key=lambda x: x[0]): \n...     print(key, tuple(group_iter)) \n1 ((’1’, 4.0), (’1’, 4.6), (’1’, 5.8), (’1’, 6.9), (’1’, 5.4)) \n2 ((’2’, 8.3), (’2’, 6.5), (’2’, 6.8), (’2’, 7.8), (’2’, 9.2)) \n3 ((’3’, 9.3), (’3’, 10.5), (’3’, 8.1), (’3’, 8.0), (’3’, 6.9)) \n4 ((’4’, 6.1), (’4’, 5.6), (’4’, 3.8), (’4’, 6.2), (’4’, 5.8))\n```", "```py\nfrom collections.abc import Iterable, Sequence \n\ndef summarize( \n    key: KT, \n    item_iter: Iterable[tuple[KT, float]] \n) -> tuple[KT, float, float]: \n    # mean = lambda seq: sum(seq) / len(seq) \n    def mean(seq: Sequence[float]) -> float: \n        return sum(seq) / len(seq) \n    # var = lambda mean, seq: sum(...) \n    def var(mean: float, seq: Sequence[float]) -> float: \n        return sum((x - mean) ** 2 / (len(seq)-1) for x in seq) \n\n    values = tuple(v for k, v in item_iter) \n    m = mean(values) \n    return key, m, var(m, values)\n```", "```py\n>>> from itertools import starmap \n>>> partition1 = partition(data, key=lambda x: x[0]) \n>>> groups1 = starmap(summarize, partition1)\n```", "```py\n>>> partition2 = partition_s(data, key=lambda x: x[0]) \n>>> groups2 = starmap(summarize, partition2)\n```", "```py\n1 5.34 1.25 \n2 7.72 1.22 \n3 8.56 1.9 \n4 5.5 0.96\n```", "```py\nreduce(operator.add, list_of_strings, \"\")\n```", "```py\nfrom functools import singledispatch \nfrom typing import Any \n\n@singledispatch \ndef zip_format(zip: Any) -> str: \n    raise NotImplementedError(f\"unsupported {type(zip)} for zip_format()\")\n```", "```py\n@zip_format.register \ndef _(zip: int) -> str: \n    return f\"{zip:05d}\" \n\n@zip_format.register \ndef _(zip: float) -> str: \n    return f\"{zip:05.0f}\" \n\n@zip_format.register \ndef _(zip: str) -> str: \n    if \"-\" in zip: \n        zip, box = zip.split(\"-\") \n    return f\"{zip:0>5s}\"\n```"]