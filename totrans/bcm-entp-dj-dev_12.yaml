- en: '*Chapter 9*: Django Testing'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 9 章*：Django 测试'
- en: This chapter is dedicated to testing and debugging a Django project. Django
    has a wide range of test classes built into its framework that are used to write
    automated test scripts. As we build each app and/or component of a project, we
    can run one command at any time to ensure that every component still works as
    it should. This is great for **regression testing**, which means testing a new
    or changed component, making sure that it does not affect the intended behavior
    of existing components or the entire system as a whole. For most of what we will
    cover in this chapter, we do not need to install any third-party packages. The
    last thing we will cover is the **Django Debug Toolbar** (**DjDT**), which does
    require us to install a third-party package to use.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章致力于测试和调试 Django 项目。Django 在其框架中内置了广泛的测试类，用于编写自动化测试脚本。随着我们构建每个应用程序和/或项目的每个组件，我们可以在任何时候运行一个命令来确保每个组件仍然按预期工作。这对于
    **回归测试** 非常有用，这意味着测试新的或更改的组件，确保它不会影响现有组件或整个系统的预期行为。在本章中我们将涵盖的大部分内容中，我们不需要安装任何第三方包。我们将最后涵盖的是
    **Django 调试工具栏**（**DjDT**），它确实需要我们安装一个第三方包才能使用。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Writing automated test scripts
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写自动化测试脚本
- en: Creating unit test cases
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建单元测试用例
- en: Testing view classes and their get and post methods
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试视图类及其 get 和 post 方法
- en: Testing view classes that require user authentication
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试需要用户认证的视图类
- en: Testing Django REST API endpoints
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试 Django REST API 端点
- en: Installing the DjDT, a tool used for debugging
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 DjDT，一个用于调试的工具
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To work with the code in this chapter, the following tools will need to be
    installed on your local machine:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用本章中的代码，你需要在本地机器上安装以下工具：
- en: Python version 3.9 – used as the underlying programming language for the project
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 版本 3.9 – 作为项目的底层编程语言
- en: Django version 4.0 – used as the backend framework of the project
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Django 版本 4.0 – 作为项目的后端框架
- en: pip package manager – used to manage third-party Python/Django packages
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: pip 包管理器 – 用于管理第三方 Python/Django 包
- en: We will continue to work with the solution created in [*Chapter 2*](B17243_02_ePub.xhtml#_idTextAnchor037),
    *Project Configuration*. However, it is not necessary to use the Visual Studio
    IDE. The main project itself can be run using another IDE or run independently
    using a terminal or command-line window from within the project root folder, which
    is where the `manage.py` file resides. Whatever editor or IDE you are using, a
    virtual environment will also be needed to work with the Django project. Instructions
    for how to create a project and virtual environment can be found in [*Chapter
    2*](B17243_02_ePub.xhtml#_idTextAnchor037), *Project Configuration*. You will
    need a database to store the data contained in your project. PostgreSQL was chosen
    for the examples in the previous chapters; however, any database type that you
    choose for your project can be used to work with the examples in this chapter.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续使用在 [*第 2 章*](B17243_02_ePub.xhtml#_idTextAnchor037) 中创建的解决方案，*项目配置*。然而，使用
    Visual Studio IDE 并非必需。主要项目本身可以使用其他 IDE 运行，或者从项目根目录（其中包含 `manage.py` 文件）独立使用终端或命令行窗口运行。无论你使用什么编辑器或
    IDE，都需要一个虚拟环境来与 Django 项目一起工作。如何创建项目和虚拟环境的说明可以在 [*第 2 章*](B17243_02_ePub.xhtml#_idTextAnchor037)
    的 *项目配置* 中找到。你需要一个数据库来存储项目中的数据。前几章的示例选择了 PostgreSQL；然而，你可以为你的项目选择任何数据库类型来与本章的示例一起工作。
- en: 'We will also be using data that is in the form of a Django fixture, provided
    in [*Chapter 3*](B17243_03_ePub.xhtml#_idTextAnchor077), *Models, Relations, and
    Inheritance*, in the subsection titled *Loading the chapter_3 data fixture*. Make
    sure the `chapter_3` fixture is loaded into your database. If this has already
    been done, then you may skip the next command. If you have already created the
    tables found in [*Chapter 3*](B17243_03_ePub.xhtml#_idTextAnchor077), *Models,
    Relations, and Inheritance*, and have not loaded that fixture yet, then run the
    following command, after activating your virtual environment:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用在 [*第 3 章*](B17243_03_ePub.xhtml#_idTextAnchor077) 的 *模型、关系和继承* 部分提供的
    Django 固件数据，标题为 *加载 chapter_3 数据固件*。请确保 `chapter_3` 固件已加载到你的数据库中。如果这已经完成，则可以跳过下一个命令。如果你已经创建了在
    [*第 3 章*](B17243_03_ePub.xhtml#_idTextAnchor077) 的 *模型、关系和继承* 中找到的表，并且尚未加载该固件，那么在激活你的虚拟环境后，运行以下命令：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'All of the code created in this chapter can be found in the GitHub repository
    for this book: [https://github.com/PacktPublishing/Becoming-an-Enterprise-Django-Developer](https://github.com/PacktPublishing/Becoming-an-Enterprise-Django-Developer).
    The bulk of the code depicted in this chapter can be found in the `/becoming_a_django_entdev/becoming_a_django_entdev/chapter_9/`
    directory.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章创建的所有代码都可以在本书的GitHub仓库中找到：[https://github.com/PacktPublishing/Becoming-an-Enterprise-Django-Developer](https://github.com/PacktPublishing/Becoming-an-Enterprise-Django-Developer)。本章中展示的大部分代码可以在`/becoming_a_django_entdev/becoming_a_django_entdev/chapter_9/`目录中找到。
- en: 'Check out the following video to see the *Code in Action*: [https://bit.ly/3yh0tW6](https://bit.ly/3yh0tW6).'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，了解*代码的实际应用*：[https://bit.ly/3yh0tW6](https://bit.ly/3yh0tW6)。
- en: Preparing for this chapter
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备本章内容
- en: Start by creating a new app in your project called `chapter_9` by following
    the steps discussed in [*Chapter 2*](B17243_02_ePub.xhtml#_idTextAnchor037), *Project
    Configuration*, in the subsection titled *Creating a Django app*. As discussed
    in that section, don't forget to change the value of the `name =` variable for
    your app class found in the `/becoming_a_django_entdev/becoming_a_django_entdev/chapter_9/apps.py`
    file to now point to the path where you installed your app. Be sure to also include
    this app in the `INSTALLED_APPS` variable found in the `settings.py` file as well.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，按照[*第2章*](B17243_02_ePub.xhtml#_idTextAnchor037)，*项目配置*中标题为*创建Django应用*的小节中讨论的步骤，在你的项目中创建一个名为`chapter_9`的新应用。正如该节所述，不要忘记将`/becoming_a_django_entdev/becoming_a_django_entdev/chapter_9/apps.py`文件中你的应用类的`name
    =`变量的值更改为指向你安装应用的位置。务必还将此应用包含在`settings.py`文件中的`INSTALLED_APPS`变量中。
- en: 'In the main `urls.py` file of the site, add the following two paths:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在网站的主要`urls.py`文件中，添加以下两个路径：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: These point to the [*Chapter 9*](B17243_09_ePub.xhtml#_idTextAnchor272) URL
    patterns that we will be creating for this chapter and includes all of the URL
    patterns that we created for [*Chapter 8*](B17243_08_ePub.xhtml#_idTextAnchor239),
    *Working with the Django REST Framework*. We will need the API endpoints that
    we created in the previous chapter for some of the REST API test exercises. Make
    sure the [*Chapter 9*](B17243_09_ePub.xhtml#_idTextAnchor272) URLs take precedence
    over the other by placing them first in this list.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指向我们将为本章创建的[*第9章*](B17243_09_ePub.xhtml#_idTextAnchor272) URL模式，并包括我们为[*第8章*](B17243_08_ePub.xhtml#_idTextAnchor239)，*使用Django
    REST框架*创建的所有URL模式。我们将需要上一章中创建的API端点来进行一些REST API测试练习。确保将[*第9章*](B17243_09_ePub.xhtml#_idTextAnchor272)的URL放在列表的第一位，以便它们优先于其他URL。
- en: 'In your `/chapter_9/urls.py` file, you should add the following paths. These
    paths were used in the exercises in [*Chapter 4*](B17243_04_ePub.xhtml#_idTextAnchor116),
    *URLs, Views, and Templates*:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的`/chapter_9/urls.py`文件中，你应该添加以下路径。这些路径在第4章的练习中使用了，[*第4章*](B17243_04_ePub.xhtml#_idTextAnchor116)，*URLs,
    Views, and Templates*：
- en: '[PRE17]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Instead of including all of the URLs from [*Chapter 4*](B17243_04_ePub.xhtml#_idTextAnchor116),
    *URLs, Views, and Templates*, we are only providing you with the ones that are
    needed. The reason behind this is that in [*Chapter 4*](B17243_04_ePub.xhtml#_idTextAnchor116),
    *URLs, Views, and Templates*, we discussed several variations of writing the same
    paths for learning purposes. To prevent confusion, only the variation of the URL
    patterns that are needed to satisfy the type of tests that we are about to perform
    is included in the preceding code.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有包括来自[*第4章*](B17243_04_ePub.xhtml#_idTextAnchor116)，*URLs, Views, and Templates*的所有URL，而是只提供所需的那些。这样做的原因是，在第4章中，我们讨论了为了学习目的而编写相同路径的几种变体。为了避免混淆，仅包括满足即将进行的测试类型所需的URL模式变体，这些变体包含在上面的代码中。
- en: Copy the `index.html` file from the code of the book found in the `/chapter_9/templates/chapter_9`
    directory into your project in the same directory. Also, copy the `chapter_9`
    CSS and JavaScript files from the code of the book into your project.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 将位于`/chapter_9/templates/chapter_9`目录中的`index.html`文件从本书的代码中复制到你的项目中相同的目录下。同时，将本书代码中的`chapter_9`
    CSS和JavaScript文件复制到你的项目中。
- en: Note
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you cloned the entire repository of code provided with this book and the
    DjDT is already turned on/enabled, please disable it before running any of the
    test cases that we will soon create. Look for the **Turn Off/Comment Out For the
    First Half of Chapter 9** comments throughout the settings and URL files. That
    tool will be discussed after working through some test cases.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你克隆了本书提供的整个代码库，并且 DjDT 已经开启/启用，请在运行我们即将创建的任何测试用例之前将其禁用。在整个设置和 URL 文件中查找 **Turn
    Off/Comment Out For the First Half of Chapter 9** 的注释。该工具将在处理一些测试用例之后讨论。
- en: Next, let's discuss what automated testing is in Django and how it is used.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们讨论一下在 Django 中自动化测试是什么以及它是如何被使用的。
- en: Understanding automated testing in Django
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Django 中的自动化测试
- en: 'Automated testing is helpful for a number of reasons. Developers use it when
    refactoring old components that need to be modified. Test scripts are used to
    regression test older components to see whether they were affected negatively
    by any new additions. Django offers several test classes that are an extension
    of the standard Python library called `unittest`. You can learn more about this
    package here: [https://docs.python.org/3/library/unittest.html](https://docs.python.org/3/library/unittest.html).
    The Django test classes are all found in the `django.test` library. The most commonly
    used class is `TestCase`.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化测试有很多好处。开发者在重构需要修改的旧组件时使用它。测试脚本用于回归测试旧组件，以查看它们是否受到任何新添加内容的负面影响。Django 提供了几个测试类，这些类是标准
    Python 库 `unittest` 的扩展。您可以在以下链接中了解更多关于此包的信息：[https://docs.python.org/3/library/unittest.html](https://docs.python.org/3/library/unittest.html)。Django
    测试类都位于 `django.test` 库中。最常用的类是 `TestCase`。
- en: 'The following list depicts all of the test classes that are available in the
    `django.test` library:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表描述了 `django.test` 库中可用的所有测试类：
- en: '`unittest` library. This class will not interact with a database.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unittest` 库。这个类不会与数据库交互。'
- en: '`SimpleTestCase` class and allows for database transactions.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SimpleTestCase` 类并允许进行数据库事务。'
- en: '`TransactionTestCase` class and includes features that allow for better interactions
    with a database. It is the most commonly used test class.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TransactionTestCase` 类并包含允许与数据库更好交互的功能。这是最常用的测试类。'
- en: '`TransactionTestCase` class and allows the use of test clients other than the
    test client provided by Django, such as Appium, Cypress, Selenium, Serenity, or
    any of the dozens of other ones available. It will actually spin up a live Django
    server in the background to run the test and then destroy that server upon completion.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TransactionTestCase` 类允许使用除 Django 提供的测试客户端以外的测试客户端，例如 Appium、Cypress、Selenium、Serenity
    或其他数十种可用的客户端。它实际上会在后台启动一个 live Django 服务器来运行测试，并在测试完成后销毁该服务器。'
- en: '`LiveServerTestCase` class. This class is built specifically for using the
    Selenium test framework as the test client due to how popular it is.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LiveServerTestCase` 类。这个类专门为使用 Selenium 测试框架作为测试客户端而构建，因为它的流行。'
- en: Writing test classes is just like writing any other Python class. They must
    consist of at least a test method, and they usually contain a `setUp()` method,
    but this method is not required. Test methods have the word `test_` prepended
    to their name, for example, `test_one()` and `test_two()`. The `setUp()` method
    is used to prepare your environment and/or database for any of the test methods
    in that class. If a class has more than one test method, an object created in
    one test method will not be accessible in the other test method. If you need an
    object in both test methods of a class, you need to place that logic in the `setUp()`
    method.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 编写测试类就像编写任何其他 Python 类一样。它们必须至少包含一个测试方法，并且通常包含一个 `setUp()` 方法，但这个方法不是必需的。测试方法的名字前缀为
    `test_`，例如 `test_one()` 和 `test_two()`。`setUp()` 方法用于为该类中的任何测试方法准备环境或数据库。如果一个类有多个测试方法，一个测试方法中创建的对象将无法在另一个测试方法中使用。如果你需要在类的两个测试方法中都需要一个对象，你需要将这个逻辑放在
    `setUp()` 方法中。
- en: 'Test classes may also have a `tearDown()` method, which will perform any cleanup
    tasks necessary after a test has been performed and before moving on to the next
    test. `tearDown()` is not used very often seeing as Django will automatically
    destroy any servers and databases created during the test after the test has completed.
    Other methods are available as well and you can learn more about them here: [https://docs.djangoproject.com/en/4.0/topics/testing/tools/](https://docs.djangoproject.com/en/4.0/topics/testing/tools/).'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 测试类还可以有一个`tearDown()`方法，该方法将在执行测试后并在进行下一个测试之前执行任何必要的清理任务。由于Django会在测试完成后自动销毁测试期间创建的任何服务器和数据库，所以`tearDown()`方法并不常用。还有其他方法可用，你可以在[https://docs.djangoproject.com/en/4.0/topics/testing/tools/](https://docs.djangoproject.com/en/4.0/topics/testing/tools/)了解更多关于它们的信息。
- en: Tip
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Selenium is a third-party library of tools that simulates actual browsers, allowing
    you to run automated tests in many different browser types and versions. It is
    not necessary to perform basic/standard test cases and this is considered an advanced
    topic beyond the scope of this book. To learn more about Selenium, visit [https://www.selenium.dev/](https://www.selenium.dev/),
    [https://pypi.org/project/selenium/](https://pypi.org/project/selenium/), and
    [https://django-selenium.readthedocs.io/en/latest/](https://django-selenium.readthedocs.io/en/latest/).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Selenium是一个第三方工具库，它模拟实际浏览器，允许你在许多不同的浏览器类型和版本上运行自动化测试。执行基本/标准测试用例并不需要Selenium，这被认为是本书范围之外的进阶主题。要了解更多关于Selenium的信息，请访问[https://www.selenium.dev/](https://www.selenium.dev/)、[https://pypi.org/project/selenium/](https://pypi.org/project/selenium/)和[https://django-selenium.readthedocs.io/en/latest/](https://django-selenium.readthedocs.io/en/latest/)。
- en: Every time a new app is created in Django, such as when all of the chapter apps
    were created prior to this chapter, you may have noticed that a `tests.py` file
    was automatically created for you in that app directory. This file is created
    whether you are using the IDE or command line to create the new app. We have just
    been disregarding this file as it served no purpose to us, until now. The code
    in this chapter will live almost entirely within the `tests.py` file. If you are
    using the Visual Studio IDE, you may have also noticed that it created a `SimpleTest(TestCase)`
    class in your `tests.py` file. Apps created through the command-line window or
    terminal will not have created this class for you. Go ahead and comment this out
    or delete it before proceeding so that we only see the results pertaining to the
    test(s) at hand.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 每次在Django中创建新应用时，例如在本章之前创建的所有章节应用，你可能已经注意到在那个应用目录中自动为你创建了一个`tests.py`文件。无论你是使用IDE还是命令行创建新应用，这个文件都会被创建。我们之前一直忽略这个文件，因为它对我们没有任何作用，直到现在。本章的代码几乎全部位于`tests.py`文件中。如果你使用的是Visual
    Studio IDE，你可能也注意到它已经在你的`tests.py`文件中创建了一个`SimpleTest(TestCase)`类。通过命令行窗口或终端创建的应用不会为你创建这个类。在继续之前，请先注释掉或删除它，这样我们只看到与当前测试相关的结果。
- en: Now that we have a better understanding of how tests are performed, let's dive
    in and begin testing next.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经更好地理解了测试是如何执行的，让我们深入探讨并开始测试。
- en: Getting started with unit testing
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始单元测试
- en: '`SimpleTest` class that the Visual Studio IDE created for us is actually testing
    for. These can be utility methods, conditional or comparison statements, Django
    models, forms, email messages, and so on.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio IDE为我们创建的`SimpleTest`类实际上是在测试的。这些可以是实用方法、条件或比较语句、Django模型、表单、电子邮件消息等等。
- en: Let's practice writing a simple test script and then write another to include
    our models.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们练习编写一个简单的测试脚本，然后编写另一个包含我们模型的脚本。
- en: Basic unit test script
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本单元测试脚本
- en: In this exercise, we will write a very basic test class that executes two different
    test methods. These tests will not interact with a database and are only used
    to compare `True` and `False` statements. The class as a whole can be used as
    a boilerplate when creating new test classes and modified as needed.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将编写一个非常基础的测试类，该类执行两种不同的测试方法。这些测试不会与数据库交互，仅用于比较`True`和`False`语句。整个类可以作为创建新测试类时的模板，并根据需要修改。
- en: 'Follow these steps:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤操作：
- en: 'In your `/chapter_9/tests.py` file, add the structure of the class, as shown:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的`/chapter_9/tests.py`文件中，添加类的结构，如下所示：
- en: '[PRE44]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `test_pass(self)` method is used to compare whether `True` actually equals
    `True` when `True` is passed into the function; it is intended to be a successful
    test. The `test_fail(self)` method is used to compare whether `False` equals `False`
    when `True` is passed into the function; it is intended to produce a failure.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`test_pass(self)` 方法用于比较当将 `True` 传递给函数时，`True` 是否实际上等于 `True`；它旨在进行一次成功的测试。`test_fail(self)`
    方法用于比较当将 `True` 传递给函数时，`False` 是否等于 `False`；它旨在产生一个失败。'
- en: 'Now, in your command-line window or terminal, navigate to your project''s root
    directory and activate your virtual environment but do not run the project at
    this time. Instead, execute the Django test command depicted in the following
    code, which will only execute the tests found in your `chapter_9` app:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在你的命令行窗口或终端中，导航到你的项目根目录并激活你的虚拟环境，但此时不要运行项目。相反，执行以下代码中的 Django 测试命令，这将仅执行
    `chapter_9` 应用中找到的测试：
- en: '[PRE45]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'If everything runs as intended in this exercise, it should tell you in your
    command-line window that two tests were performed and which one failed, as shown:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在这个练习中一切按预期进行，它应该在命令行窗口中告诉你进行了两次测试，以及哪个失败了，如下所示：
- en: '[PRE46]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: On the third line in the preceding output, it printed `F.`. The capital `F`
    represents one test was a failure and the period represents one test was a success.
    It then prints each of the tests that failed below that line. For each test that
    it prints out, Django includes the comment written for that test case, such as
    `'''Checks if False == False, Value set to True'''`. Make use of the triple double-quote
    or single-quote comment notation to include helpful information when your test
    does fail. It then provides traceback information, indicating the cause and location
    of the error or failure. You can also include `print()` statements within these
    test methods if you want to provide additional information regarding a particular
    test.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中的第三行，它打印了 `F.`。大写 `F` 代表有一个测试失败了，而点代表有一个测试成功了。然后它打印出下面那一行中失败的每个测试。对于它打印出的每个测试，Django
    会包含为该测试用例编写的注释，例如 `'''Checks if False == False, Value set to True'''`。当你的测试失败时，请使用三重双引号或单引号注释记号来包含有用的信息。然后它提供跟踪信息，指示错误或失败的原因和位置。如果你想在测试方法中提供有关特定测试的额外信息，你还可以在这些测试方法中包含
    `print()` 语句。
- en: Tip
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: To run the tests for all of the apps included in your project, run the following
    command:`(virtual_env) PS > python manage.py test`
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行项目中包含的所有应用的测试，请运行以下命令：（虚拟环境）PS > python manage.py test
- en: Also, if you break your single-line double-quote or single-quote comment into
    a multiline comment, only the first line of that comment will appear in your command-line
    window.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你将单行双引号或单引号注释拆分成多行注释，那么在你的命令行窗口中只会显示该注释的第一行。
- en: Now, comment out or delete the `TestingCalibrator` class before moving on to
    the next exercise.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在继续下一个练习之前，先注释掉或删除 `TestingCalibrator` 类。
- en: Testing Django models
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试 Django 模型
- en: 'In this exercise, we will use the `TestCase` class because we will be connecting
    to a database. The database that the test client spins up for us will not affect
    any of the data found in all local or remote databases. Follow these steps:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用 `TestCase` 类，因为我们将会连接到数据库。测试客户端为我们启动的数据库将不会影响所有本地或远程数据库中找到的任何数据。请按照以下步骤操作：
- en: 'In your `/chapter_3/models.py` file, make sure the (8, ''Jeep'') value exists
    in the `MAKE_CHOICES` list of choices:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 `/chapter_3/models.py` 文件中，确保 `(8, 'Jeep')` 值存在于 `MAKE_CHOICES` 列表的选择中：
- en: '[PRE47]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In your `/chapter_9/tests.py` file, add the following `import` statements:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 `/chapter_9/tests.py` 文件中，添加以下 `import` 语句：
- en: '[PRE48]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In that same file, add the following class and `setUp()` method:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在相同的文件中，添加以下类和 `setUp()` 方法：
- en: '[PRE49]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In that same `ModelUnitTestCase` class, add the following test method:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在相同的 `ModelUnitTestCase` 类中，添加以下测试方法：
- en: '[PRE50]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The preceding `setUp(self)` method will create a `VehicleModel`, `Engine`, `Vehicle`,
    and `Seller` model object that we imported from the `chapter_3` app. The `setUp()`
    method creates these objects before any of the test cases in that class are executed.
    We create each related object as a variable and then use that variable to assign
    as the related object of the next object that we create. The `Seller` object uses
    the same `create_user()` method that was introduced in [*Chapter 6*](B17243_06_ePub.xhtml#_idTextAnchor190),
    *Exploring the Django Admin Site*, to create a new `Seller` with the hashed password
    and date fields formatted for us. We created only one test, called `test_full_vehicle_name()`,
    which looks up the vehicle that was created upon setup by the vin field value
    specified. It uses the `full_vehicle_name()` method that we created in [*Chapter
    3*](B17243_03_ePub.xhtml#_idTextAnchor077), *Models, Relations, and Inheritance*,
    to return to us the custom-formatted name of that newly created vehicle. The expected
    value is `Jeep Grand Cherokee Laredo 4WD - 3.6L FI FFV DO`, which is in the format
    `{{ make }} {{ model }} – {{ engine }}`. If the resulting value does not match
    that value, the test will fail.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的 `setUp(self)` 方法将创建一个 `VehicleModel`、`Engine`、`Vehicle` 和 `Seller` 模型对象，这些对象是从
    `chapter_3` 应用程序中导入的。`setUp()` 方法在执行该类中的任何测试用例之前创建这些对象。我们创建每个相关对象作为变量，然后使用该变量将下一个创建的对象的相关对象分配给它。`Seller`
    对象使用在 [*第6章*](B17243_06_ePub.xhtml#_idTextAnchor190)，*Exploring the Django Admin
    Site* 中引入的相同的 `create_user()` 方法来创建一个新的 `Seller`，带有为我们格式化的散列密码和日期字段。我们只创建了一个测试，名为
    `test_full_vehicle_name()`，它通过 vin 字段值查找在设置时创建的车辆。它使用我们在 [*第3章*](B17243_03_ePub.xhtml#_idTextAnchor077)，*Models,
    Relations, and Inheritance* 中创建的 `full_vehicle_name()` 方法，返回新创建车辆的定制格式化名称。预期值是
    `Jeep Grand Cherokee Laredo 4WD - 3.6L FI FFV DO`，其格式为 `{{ make }} {{ model }}
    – {{ engine }}`。如果返回的值与该值不匹配，测试将失败。
- en: 'Now, execute the run test command shown here:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，执行这里显示的运行测试命令：
- en: '[PRE51]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'If you commented out all the other tests prior to this one, you should see
    the results shown here:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你注释掉了之前的所有测试，你应该会看到这里显示的结果：
- en: '[PRE52]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Go ahead and change the expected value found in the `self.assertEqual()` function
    of *step 4* previously to something that doesn''t exist, and then rerun your test
    command one more time. Now, you should see a failure message, as depicted here:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在之前步骤 4 中的 `self.assertEqual()` 函数中找到的预期值更改为一个不存在的值，然后再次运行你的测试命令。现在，你应该会看到一个失败消息，如图所示：
- en: '[PRE53]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Go ahead and comment out the `ModelUnitTestCase` class before proceeding to
    the next exercise. Now that we have an understanding of how to write simple test
    cases and cases that test model CRUD actions, next, we will test a custom view
    class that was written in [*Chapter 4*](B17243_04_ePub.xhtml#_idTextAnchor116),
    *URLs, Views, and Templates*.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行下一个练习之前，先注释掉 `ModelUnitTestCase` 类。现在我们已经了解了如何编写简单的测试用例以及测试模型 CRUD 操作的用例，接下来，我们将测试一个在
    [*第4章*](B17243_04_ePub.xhtml#_idTextAnchor116)，*URLs, Views, and Templates* 中编写的自定义视图类。
- en: Testing HTTP view requests
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试 HTTP 视图请求
- en: In this section, we will expand on the basic test cases that we previously wrote
    to include HTTP view requests. When testing view classes, whether they are a method-based
    view or a class-based view, they will both use the same `TestCase` class that
    we have been using so far.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将扩展我们之前编写的基线测试用例，以包括 HTTP 视图请求。在测试视图类时，无论是基于方法的视图还是基于类的视图，它们都将使用我们迄今为止一直在使用的相同的
    `TestCase` 类。
- en: In the following subsections, we will perform two tests, one for a method-based
    view and the other for a class-based view.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的子节中，我们将执行两个测试，一个基于方法的视图测试，另一个基于类的视图测试。
- en: Testing method-based views
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试基于方法的视图
- en: In this exercise, we will test the `practice_year_view()` method, written in
    [*Chapter 4*](B17243_04_ePub.xhtml#_idTextAnchor116), *URLs, Views, and Templates*.
    What we are comparing in this test is whether the response code that gets returned
    equals the value of `200`, which means a successful response.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将测试在 [*第4章*](B17243_04_ePub.xhtml#_idTextAnchor116)，*URLs, Views, and
    Templates* 中编写的 `practice_year_view()` 方法。在这个测试中，我们比较的是返回的响应代码是否等于 `200` 的值，这意味着成功的响应。
- en: 'Follow these steps to create your test case:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建你的测试用例：
- en: 'In your `/chapter_9/tests.py` file, add the following `YearRequestTestCase`
    class and methods:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 `/chapter_9/tests.py` 文件中，添加以下 `YearRequestTestCase` 类和方法：
- en: '[PRE54]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This test uses a `RequestFactory()` object saved as the `self.factory` variable.
    It then uses that factory to construct an actual `request` object. The path that
    we want to test is passed into the `self.factory.get()` method as `/my_year_path/2022/`.
    Since we are not requiring authentication within `practice_year_view()`, we are
    setting the `request.user` object to an `AnonymousUser()` class object provided
    in the `django.contrib.auth.models` library. The response is constructed using
    the `practice_year_view(request, 2022)` method. Here, we pass in the `request`
    object and the value of the year keyword argument that we are attempting to access.
    The last line checks whether `response.status_code` actually equals a value of
    `200`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试使用了一个保存为`self.factory`变量的`RequestFactory()`对象。然后使用该工厂构建一个实际的`request`对象。我们想要测试的路径是通过`self.factory.get()`方法传入的`/my_year_path/2022/`。由于我们在`practice_year_view()`中不需要认证，我们将`request.user`对象设置为`django.contrib.auth.models`库中提供的`AnonymousUser()`类对象。响应是通过`practice_year_view(request,
    2022)`方法构建的。在这里，我们传入`request`对象和我们试图访问的年份关键字参数的值。最后一行检查`response.status_code`是否实际上等于`200`。
- en: 'Next, run the following test command for the `chapter_9` app test cases:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，运行以下测试命令以执行`chapter_9`应用测试用例：
- en: '[PRE55]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'If successful, you should see the following message:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果成功，你应该会看到以下信息：
- en: '[PRE56]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Go back to *step 1* and change all instances of the year `2022` to `12` (found
    in two spots), and then rerun your test command. You should see the failure/error
    message shown here:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到*步骤1*，将所有年份`2022`的实例更改为`12`（在两个地方找到），然后重新运行你的测试命令。你应该会看到这里显示的失败/错误信息：
- en: '[PRE57]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This test case failed because of the condition that we wrote in the `practice_year_view()`
    method in [*Chapter 4*](B17243_04_ePub.xhtml#_idTextAnchor116), *URLs, Views,
    and Templates*, which checks to make sure the user enters a year greater than
    or equal to `1900`. You will also see that instead of printing an `F` or period
    for this test, it printed the capital letter `E`, which stands for error. The
    error versus a failure is a result of the custom parameters that we are checking
    for, meaning the URL pattern is correct but the view itself performs additional
    logic that triggers the page-not-found error.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试用例失败是因为我们在[*第4章*](B17243_04_ePub.xhtml#_idTextAnchor116)中编写的`practice_year_view()`方法中写入了条件，该条件检查用户是否输入了一个大于或等于`1900`的年份。你还会看到，对于这个测试，它没有打印`F`或句点，而是打印了大写字母`E`，代表错误。错误与失败的区别在于我们正在检查的自定义参数，这意味着URL模式是正确的，但视图本身执行了额外的逻辑，触发了页面找不到错误。
- en: Go ahead and comment out the `YearRequestTestCase` class before proceeding to
    the next exercise.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行下一个练习之前，请先注释掉`YearRequestTestCase`类。
- en: Let's test a class-based view in the next section.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一节测试基于类的视图。
- en: Testing class-based views
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试基于类的视图
- en: In this exercise, we will test the `VehicleView` class, written in [*Chapter
    4*](B17243_04_ePub.xhtml#_idTextAnchor116), *URLs, Views, and Templates*. We will
    be loading the `chapter_3` data fixture instead of creating objects in the `setUp()`
    method, as we have done in the `ModelUnitTestCase` class. We already performed
    a test to see whether creating objects was a success. We can save time and effort
    now by just loading a fixture for all other tests that we write.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将测试在[*第4章*](B17243_04_ePub.xhtml#_idTextAnchor116)中编写的`VehicleView`类，*URLs,
    Views, and Templates*。我们将加载`chapter_3`数据固定文件，而不是在`setUp()`方法中创建对象，就像我们在`ModelUnitTestCase`类中所做的那样。我们已经在创建对象是否成功方面进行了测试。现在我们可以通过只加载固定文件来节省时间和精力。
- en: 'Follow these steps to create your test case:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建你的测试用例：
- en: 'In your `/chapter_9/tests.py` file, add the `VehicleRequestTestCase` class
    and methods, as shown:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的`/chapter_9/tests.py`文件中，添加`VehicleRequestTestCase`类和方法，如下所示：
- en: '[PRE58]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: We still need the `RequestFactory()` object and `AnonymousUser()` as we used
    before, because the `VehicleView` class does not require authentication as well.
    We created the response object for this test using `VehicleView.as_view()(request,
    1)`. It looks similar to a URL pattern mapping to a view class, using the `.as_view()`
    method, found in any `urls.py` file. We again check to see whether `response.status_code`
    equals a value of `200`, indicating success.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要之前使用的`RequestFactory()`对象和`AnonymousUser()`，因为`VehicleView`类也不需要认证。我们使用`VehicleView.as_view()(request,
    1)`创建了此测试的响应对象。它看起来类似于任何`urls.py`文件中找到的URL模式映射到视图类的`.as_view()`方法。我们再次检查`response.status_code`是否等于`200`，表示成功。
- en: 'Now, run the test command shown in the following code and you should once again
    see a successful test:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，运行以下代码中的测试命令，你应该再次看到成功的测试：
- en: '[PRE59]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Now, change the number `1` found in *step 1* in `''/vehicle/1/''` and `(request,
    1)` to `99`. This number represents the index of the vehicle that we are trying
    to access, an index that should not currently exist. Then, rerun your `test` command
    and you should see the following message:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将`'/vehicle/1/'`和`(request, 1)`中的*步骤1*中的数字`1`更改为`99`。这个数字代表我们试图访问的车辆的索引，这个索引目前不应该存在。然后，重新运行你的`test`命令，你应该看到以下消息：
- en: '[PRE60]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: You'll notice, inside the preceding traceback message, that it indicates that
    an object with that ID was not found. The bottom of your traceback is where you
    will likely find your answer as to what caused the problem to occur, but that
    is not always the case. This is because we have less than 10 vehicle items found
    in the `chapter_3` fixture.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，在前面的跟踪消息中，它表明没有找到具有该ID的对象。你的跟踪消息底部是你可能找到关于问题原因答案的地方，但这并不总是如此。这是因为我们在`chapter_3`固定中找到的车辆项目少于10个。
- en: Comment out the `VehicleRequestTestCase` class before proceeding to the next
    exercise.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行下一个练习之前，请注释掉`VehicleRequestTestCase`类。
- en: Now that we have learned how to test request responses and load data fixtures
    into a test case, let's build on that by adding authentication measures next.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何测试请求响应并将数据固定加载到测试用例中，让我们在此基础上添加身份验证措施。
- en: Testing authenticated view requests
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试已验证的视图请求
- en: In this section, we will be building on the same request test cases that we
    just built to remove the `AnonymousUser` class and perform our own authentication,
    requiring only permitted users. We have a few view classes that we wrote in [*Chapter
    8*](B17243_08_ePub.xhtml#_idTextAnchor239), *Working with the Django REST Framework*,
    that require user authentication. Let's create test scripts that allow us to authenticate
    with an actual user when performing an automated test. This is where loading the
    `chapter_8/urls.py` file when preparing for this chapter comes into play. Django
    provides a class called `Client` found in the `django.test` library that lets
    us perform user authentication when testing a view class.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将基于我们刚刚构建的相同请求测试用例来移除`AnonymousUser`类并执行我们自己的身份验证，只要求允许的用户。我们编写了一些在[*第8章*](B17243_08_ePub.xhtml#_idTextAnchor239)中，*使用Django
    REST框架*中需要用户身份验证的视图类。让我们创建测试脚本，以便在执行自动化测试时使用实际用户进行身份验证。这正是我们在准备本章时加载`chapter_8/urls.py`文件的原因。Django提供了一个名为`Client`的类，位于`django.test`库中，它允许我们在测试视图类时执行用户身份验证。
- en: In the following subsection, we will implement the `Client` class when performing
    authentication.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的子节中，我们将实现`Client`类以进行身份验证。
- en: Using the Client() class
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Client()类
- en: In this exercise, we will test the custom API endpoint written in [*Chapter
    8*](B17243_08_ePub.xhtml#_idTextAnchor239), *Working with the Django REST Framework*,
    in the `GetSellerHTMLView` class. This is the class we wrote to query a seller
    by ID and return preformatted HTML instead of the expected JSON, from a traditional
    API endpoint. What we will be testing for is whether or not the `seller` context
    object has the business name that is expected for the ID that we are looking up.
    When using the `Client` class, the `RequestFactory` class is no longer needed,
    and neither is the `AnonymousUser` class.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将测试在[*第8章*](B17243_08_ePub.xhtml#_idTextAnchor239)中编写的自定义API端点，即`GetSellerHTMLView`类。这是我们编写的用于通过ID查询卖家并返回预格式化的HTML而不是预期的JSON的传统API端点。我们将测试的是`seller`上下文对象是否具有我们正在查找的ID所期望的商号。当使用`Client`类时，不再需要`RequestFactory`类，也不需要`AnonymousUser`类。
- en: 'Follow these steps to implement your own authentication:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现自己的身份验证：
- en: 'In your `/chapter_9/tests.py` file, add the `SellerClientTestCase` class and
    `setUp()` method shown here:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的`/chapter_9/tests.py`文件中，添加这里显示的`SellerClientTestCase`类和`setUp()`方法：
- en: '[PRE61]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: We first set the `self.user` value to equal a single `Seller`. The ID provided
    is the number `1`, relating to the first superuser created with the username of
    `admin`. This is the only seller object that has been provided in the `chapter_3`
    fixture for you. Next, we set the `self.client` value to be a newly created `Client()`
    object. The last line of the `setUp(self)` method is where we simulate logging
    into the system. We use `self.user.username` to grab the username of the `Seller`
    that we queried. Do not use `self.user.password` as the password; instead, use
    the unhashed password as a string manually written into the code. This is because
    there is no way to retrieve the unhashed password of a user and that is by design
    for security reasons.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将 `self.user` 值设置为等于一个单独的 `Seller`。提供的 ID 是数字 `1`，与使用用户名 `admin` 创建的第一个超级用户相关联。这是在
    `chapter_3` 固件中为你提供的唯一卖家对象。接下来，我们将 `self.client` 值设置为一个新的 `Client()` 对象。`setUp(self)`
    方法的最后一行是我们模拟登录系统的地方。我们使用 `self.user.username` 来获取我们查询的 `Seller` 的用户名。不要使用 `self.user.password`
    作为密码；相反，使用手动写入代码中的未散列密码作为字符串。这是因为没有方法可以检索用户的未散列密码，这是出于安全原因的设计。
- en: Note
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: When writing your own test cases, it would be wise to keep test user credentials
    stored in a `.env` file and imported into your project as a `settings.py` variable,
    which can then be referenced instead of hardcoding the password, as was done previously.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写自己的测试用例时，明智的做法是将测试用户凭据存储在 `.env` 文件中，并将其导入项目作为 `settings.py` 变量，这样就可以引用它，而不是像之前那样硬编码密码。
- en: 'In that same `SellerClientTestCase` class, add the following test method:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在相同的 `SellerClientTestCase` 类中，添加以下测试方法：
- en: '[PRE62]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: self.assertEqual(**seller.name**, **'Test Biz Name'**)
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: self.assertEqual(**seller.name**, **'Test Biz Name'**)
- en: In the preceding `test_get(self)` method, we created the response object using
    `self.client.get()`. Inside that method, we are passing in the path that we are
    testing, of http://localhost:8000/chapter-8/seller/1/. We are performing two checks
    instead of one within this test case; the first checks whether `response.status_code`
    actually equals `200`, to indicate success. The other checks whether or not the
    seller's business name is what is expected for the object that we are looking
    up, that being `Test Biz Name`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的 `test_get(self)` 方法中，我们使用 `self.client.get()` 创建了响应对象。在该方法内部，我们传递了我们要测试的路径，即
    http://localhost:8000/chapter-8/seller/1/。在这个测试用例中，我们执行了两个检查而不是一个；第一个检查 `response.status_code`
    是否实际上等于 `200`，以指示成功。另一个检查卖家业务名称是否是我们正在查找的对象所期望的，即 `Test Biz Name`。
- en: This is why we are creating the lowercase `seller` variable, which grabs the
    `seller` from the context returned with the request. It is also important that
    we add the `self.assertEqual(response.status_code, 200)` statement before we create
    the lowercase `seller` variable. If we do not have a successful response for any
    reason, the `seller` object will obviously not exist and so the test will fail.
    When that happens, it could point you in the wrong direction as to what the real
    problem could be.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么我们要创建小写的 `seller` 变量，它从请求返回的上下文中获取 `seller`。在创建小写的 `seller` 变量之前添加 `self.assertEqual(response.status_code,
    200)` 语句也很重要。如果我们由于任何原因没有得到成功的响应，显然 `seller` 对象将不存在，因此测试将失败。当这种情况发生时，它可能会将你引向错误的方向，告诉你真正的问题可能是什么。
- en: 'Now, run the following `test` command and you should once again see a successful
    test:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，运行以下 `test` 命令，你应该再次看到成功的测试：
- en: '[PRE63]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Next, change the `password` value found in *step 1* to an incorrect password,
    such as `mynewpassword1`, which will force a failed response. Rerun your `test`
    command and you should see the following message:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将 *步骤 1* 中找到的 `password` 值更改为一个错误的密码，例如 `mynewpassword1`，这将强制产生失败的响应。重新运行
    `test` 命令，你应该看到以下消息：
- en: '[PRE64]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We can see the reason why a failure occurred is due to **AssertionError: 401
    != 200**. A **401** response means an unauthorized response, which means the requested
    resource does not have valid authentication credentials and access will not be
    granted.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '我们可以看到失败的原因是 **AssertionError: 401 != 200**。一个 **401** 响应表示未授权的响应，这意味着请求的资源没有有效的认证凭据，访问将不会获得批准。'
- en: Change your password back to the correct password of `mynewpassword` and then,
    returning to *step 2*, change the business name in the last line to something
    incorrect, such as `Test Biz Name1`.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将密码改回正确的 `mynewpassword`，然后返回到 *步骤 2*，将最后一行中的业务名称更改为不正确的名称，例如 `Test Biz Name1`。
- en: 'Rerun the `test` command one more time and now you should see the following
    failed message:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次重新运行 `test` 命令，现在你应该看到以下失败的错误信息：
- en: '[PRE65]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: This also indicates that we achieved a **200** successful response code seeing
    that this is the second assertion that failed and not the first one.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这也表明我们实现了**200**成功响应代码，因为这是第二个失败的断言，而不是第一个。
- en: You may now comment out the `SellerClientTestCase` class before proceeding to
    the next exercise. Now that we have a better understanding of how to add authentication
    measures to our test cases, we will test Django REST API endpoints with authentication
    next.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行下一个练习之前，您可以取消注释`SellerClientTestCase`类。现在，我们已经更好地了解了如何将身份验证措施添加到我们的测试用例中，我们将使用身份验证测试Django
    REST API端点。
- en: Testing Django REST API endpoints
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试Django REST API端点
- en: This section will introduce writing test cases that test Django REST framework
    endpoints. When testing any REST API endpoints created using the Django REST framework,
    we need to use the `APITestCase` class provided by the `rest_framework.test` library.
    We also should use the `APIClient()` class provided by that same library when
    requiring authentication, instead of using the `Client()` class as we did before.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将介绍编写测试用例以测试Django REST框架端点。当测试使用Django REST框架创建的任何REST API端点时，我们需要使用`rest_framework.test`库提供的`APITestCase`类。我们还应该在需要身份验证时使用该库提供的`APIClient()`类，而不是像之前那样使用`Client()`类。
- en: 'In the following exercises, we will create one test class that performs two
    tests: the first will create an engine object and the other will update an object.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下练习中，我们将创建一个测试类，该类执行两个测试：第一个将创建一个引擎对象，另一个将更新一个对象。
- en: Creating an object test case
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建对象测试用例
- en: This test will use the `POST` request method to send data to the [http://localhost:8000/chapter-8/engines/](http://localhost:8000/chapter-8/engines/)
    endpoint and create an engine object in the database. Since we are loading a data
    fixture that contains only two engine objects with the IDs `1` and `2`, we should
    expect the new object to be created at index `3`, but your results may vary. We
    will refer back to this in the *Updating an object test case* subsection.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 此测试将使用`POST`请求方法向[http://localhost:8000/chapter-8/engines/](http://localhost:8000/chapter-8/engines/)端点发送数据并在数据库中创建一个引擎对象。由于我们正在加载一个只包含ID为`1`和`2`的两个引擎对象的数据固定文件，我们应该期望新对象在索引`3`处创建，但您的结果可能会有所不同。我们将在*更新对象测试用例*子节中回过头来讨论这一点。
- en: 'Follow these steps to create your test case:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建您的测试用例：
- en: 'In your `/chapter_9/tests.py` file, add the following `EngineAPITestCase` class,
    the `setUp()` method, and the `import` statement:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的`/chapter_9/tests.py`文件中，添加以下`EngineAPITestCase`类、`setUp()`方法和`import`语句：
- en: '[PRE66]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The structure of the preceding class follows a very similar pattern to what
    was done in the subsection titled *Using the Client() class*. Here, we set the
    value of `self.client` to use the `rest_framework.test` library-provided `APIClient`
    class. Login is done the same as before, in the `self.client.login()` declaration.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 上述类的结构非常类似于标题为*使用Client()类*的子节中执行的模式。在这里，我们将`self.client`的值设置为使用`rest_framework.test`库提供的`APIClient`类。登录与之前相同，在`self.client.login()`声明中完成。
- en: 'In that same `EngineAPITestCase` class, add the following `test_post()` method:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在相同的`EngineAPITestCase`类中，添加以下`test_post()`方法：
- en: '[PRE67]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: For the response object, instead of using `self.client.get()`, we are using
    `self.client.post()` because we want to send information to the test client server.
    Inside is the data we are sending, noting that the last argument is the format
    of the data, which is set to JSON format in this example. We then check the `response.status_code`
    value, this time to see whether it equals `201` and not `200`. A `201` response
    code indicates that an object was created successfully. The last line checks whether
    the data that was returned to us, which is the object that was created, has the
    engine name that we expect. In this case, the new engine name we are expecting
    is `New Engine`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 对于响应对象，我们不是使用`self.client.get()`，而是使用`self.client.post()`，因为我们想向测试客户端服务器发送信息。内部是我们要发送的数据，注意最后一个参数是数据的格式，在这个例子中设置为JSON格式。然后我们检查`response.status_code`值，这次是要看它是否等于`201`而不是`200`。`201`响应代码表示对象已成功创建。最后一行检查返回给我们的数据，即创建的对象，是否具有我们期望的引擎名称。在这种情况下，我们期望的新引擎名称是`New
    Engine`。
- en: 'Now, run the following `test` command and you should once again see a successful
    test:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，运行以下`test`命令，您应该再次看到成功的测试：
- en: '[PRE68]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Next, go back to *step 1* and add an incorrect password, such as `mynewpassword1`,
    and then run your `test` command again. You should see the following message:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，回到*步骤1*并添加一个错误的密码，例如`mynewpassword1`，然后再次运行你的`test`命令。你应该会看到以下消息：
- en: '[PRE69]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'We can see in this test that we are being warned of `AssertionError: 401 !=
    201` and not `200` this time. You can `achieve` the same by changing the expected
    value of the engine name and you will see it warn you of that assertion.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '在这个测试中，我们可以看到我们被警告`AssertionError: 401 != 201`而不是这次`200`。你可以通过更改引擎名称的预期值来实现相同的效果，你会看到它警告你那个断言。'
- en: Next, let's add to this class to allow us to test updating an object.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们添加到这个类中，以便我们可以测试更新对象。
- en: Updating an object test case
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新对象测试用例
- en: This test will use the `PUT` request method to send data to the [http://localhost:8000/chapter-8/engines/1/](http://localhost:8000/chapter-8/engines/1/)
    endpoint, a specific engine object to update within the database.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 此测试将使用`PUT`请求方法向[http://localhost:8000/chapter-8/engines/1/](http://localhost:8000/chapter-8/engines/1/)端点发送数据，这是数据库中要更新的特定引擎对象。
- en: 'Follow these steps to update your class for this test case:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤更新你的类以适应此测试用例：
- en: 'Inside the same `EngineAPITestCase` class, add the following `test_put()` method:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一个`EngineAPITestCase`类中，添加以下`test_put()`方法：
- en: '[PRE70]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Please leave the `setUp()` and `test_post()` methods as they are. In the preceding
    `test_put()` method, we are using the `self.client.put()` method to create the
    response object. The data that we are sending is in the same JSON format. Note
    that in the preceding example, we are specifying the path as `'/chapter-8/engines/1/'`,
    which refers to the first engine object with an ID index of `1`. That object is
    being inserted into the dummy database that gets created through the `chapter_3`
    fixture that is still being used in this class. We once again are checking that
    `response.status_code` equals `200`, success. We don't need to check for `201`
    because nothing is being created currently, only updated. We then check to make
    sure that the expected object's name equals `My Changed Engine Name`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 请保持`setUp()`和`test_post()`方法不变。在先前的`test_put()`方法中，我们使用`self.client.put()`方法来创建响应对象。我们发送的数据是相同的JSON格式。注意，在先前的示例中，我们指定路径为`'/chapter-8/engines/1/'`，这指的是ID索引为`1`的第一个引擎对象。该对象被插入通过`chapter_3`固定值创建的虚拟数据库中，该固定值仍在本类中使用。我们再次检查`response.status_code`是否等于`200`，成功。我们不需要检查`201`，因为没有创建任何内容，只是更新。然后我们检查确保预期的对象名称等于`My
    Changed Engine Name`。
- en: 'Now, run the following test command and you should see that both tests are
    a success:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，运行以下测试命令，你应该会看到两个测试都成功了：
- en: '[PRE71]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: To demonstrate how creating an item in one test cannot be retrieved from another
    test within the same class, change the ID of `1` to `3` within the `test_put()`
    method, as in `'/chapter-8/engines/3/'`.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了演示在一个测试中创建的项目不能从同一个类中的另一个测试中检索，请在`test_put()`方法中将ID的`1`改为`3`，如`'/chapter-8/engines/3/'`。
- en: When we created an object in the `test_post(self)` method, you might expect
    the newly created object to have had an ID index of `3` since the `chapter_3`
    fixture only has two objects. The reason we won't find the new object to update
    that object is that when the `test_post(self)` method is complete, anything created
    during that operation gets destroyed upon completion.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在`test_post(self)`方法中创建对象时，你可能会期望新创建的对象具有ID索引`3`，因为`chapter_3`固定值中只有两个对象。我们找不到更新该对象的新对象的原因是，当`test_post(self)`方法完成时，在该操作期间创建的任何内容都会在完成时被销毁。
- en: 'Rerun your `test` command and now you should see the failure message shown
    here:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新运行你的`test`命令，现在你应该会看到这里显示的失败消息：
- en: '[PRE72]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The reason we are seeing a failure is that Django does not keep objects created
    between other test cases within the same test class. Django will keep a counter
    of the last object ID created, which means if or when a test case completes and
    an object gets destroyed, the counter will continue to count. This could make
    for a frustrating time testing and, as such, is the reason we are loading a fixture,
    so that we know for sure that the ID is what it should be for the object that
    we are testing.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到失败的原因是Django不会在同一个测试类中保留其他测试用例之间创建的对象。Django会保留最后创建的对象ID的计数器，这意味着如果或当测试用例完成并且对象被销毁时，计数器将继续计数。这可能会在测试时造成挫败感，因此，我们加载了一个固定值，这样我们就可以确信ID是我们正在测试的对象应有的ID。
- en: Now that we have a better understanding of how automated testing works in Django,
    let's introduce the DjDT next, a powerful set of tools that helps developers to
    debug during development.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对 Django 中的自动化测试工作方式有了更好的理解，接下来介绍 DjDT，这是一套强大的工具，帮助开发者在开发过程中进行调试。
- en: Using the DjDT
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 DjDT
- en: The DjDT is a third-party package that integrates a set of configurable panels
    that display debug information in real time to the developer. Other third-party
    packages can be installed to add additional panels to this toolbar. With that
    in mind, you could also build your own panels too. We will only be installing
    the DjDT package by itself and then explaining each of its most common features,
    guiding you through using it, interpreting what it is showing you. To learn more
    about all of its capabilities, visit [https://pypi.org/project/django-debug-toolbar/](https://pypi.org/project/django-debug-toolbar/)
    and [https://django-debug-toolbar.readthedocs.io/en/latest/](https://django-debug-toolbar.readthedocs.io/en/latest/).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: DjDT 是一个第三方包，它集成了可配置的面板，可以实时向开发者显示调试信息。可以安装其他第三方包以向此工具栏添加更多面板。考虑到这一点，您也可以构建自己的面板。我们只将安装
    DjDT 包本身，然后解释其最常见功能，指导您使用它，解释它向您展示的内容。要了解更多关于其所有功能的信息，请访问 [https://pypi.org/project/django-debug-toolbar/](https://pypi.org/project/django-debug-toolbar/)
    和 [https://django-debug-toolbar.readthedocs.io/en/latest/](https://django-debug-toolbar.readthedocs.io/en/latest/)。
- en: Installing the DjDT
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 DjDT
- en: 'To get started with installing the DjDT, follow these steps:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始安装 DjDT，请按照以下步骤操作：
- en: 'Add the `django-debug-toolbar` package to your `requirements.txt` file and
    install it into your virtual environment via that file or run the following `pip`
    command, making sure your virtual environment is already active:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `django-debug-toolbar` 包添加到您的 `requirements.txt` 文件中，并通过该文件或运行以下 `pip` 命令将其安装到您的虚拟环境中，确保您的虚拟环境已经激活：
- en: '[PRE73]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'In your `settings.py` file, add the following items to your `INSTALLED_APPS`
    list:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的 `settings.py` 文件中，将以下项目添加到您的 `INSTALLED_APPS` 列表中：
- en: '[PRE74]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'In the same `settings.py` file, add the following middleware to the top of
    your `MIDDLEWARE` list:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在相同的 `settings.py` 文件中，将以下中间件添加到您的 `MIDDLEWARE` 列表顶部：
- en: '[PRE75]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The `debug_toolbar` app and the `MIDDLEWARE` item should be the only new items
    that you are adding to this file.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 应该只将 `debug_toolbar` 应用和 `MIDDLEWARE` 项目添加到该文件中。
- en: 'The `django.contrib.staticfiles` app, the `INTERNAL_IPS` list, and the `STATIC_URL`
    variable should have already been added in [*Chapter 2*](B17243_02_ePub.xhtml#_idTextAnchor037),
    *Project Configuration*, when we created and configured the project for the first
    time. Note that they are required for this toolbar to work. Should you be working
    on a project of your own that does not follow the `settings.py` specifications
    of this book, make sure that these items are included:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 *第 2 章* 中，当我们在创建和配置项目时，已经添加了 `django.contrib.staticfiles` 应用、`INTERNAL_IPS`
    列表和 `STATIC_URL` 变量，即 [*Chapter 2*](B17243_02_ePub.xhtml#_idTextAnchor037)，*项目配置*。请注意，它们对于此工具栏的正常工作是必需的。如果您正在处理一个不遵循本书
    `settings.py` 规范的自己的项目，请确保包含这些项目：
- en: '[PRE76]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Next, you will need to import the URL patterns relative to this third-party
    app. To make sure this toolbar can be used in all chapters throughout this book,
    in your main `urls.py` file, add the following `include` pattern:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，您需要导入与该第三方应用相关的 URL 模式。为了确保此工具栏可以在本书的所有章节中使用，请在您的主 `urls.py` 文件中添加以下 `include`
    模式：
- en: '[PRE77]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Note that in the preceding example, we are placing the import under the `settings.DEBUG`
    conditional statement, checking whether our environment is the `DEBUG` environment.
    We don't ever want this toolbar to appear in a production or production-like test
    environment, such as staging. The development environment is usually acceptable.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在前面的示例中，我们将导入放在 `settings.DEBUG` 条件语句下，检查我们的环境是否是 `DEBUG` 环境。我们绝对不希望这个工具栏出现在生产或类似生产的环境，如预发布环境。开发环境通常是可接受的。
- en: That's it; by now, this toolbar should be installed and working properly. Next,
    let's discuss making an adjustment to work with our remote environments.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样；到目前为止，这个工具栏应该已经安装并正常工作。接下来，让我们讨论如何调整以与我们的远程环境一起使用。
- en: Adjusting DjDT settings
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调整 DjDT 设置
- en: Any of the panels that you are about to learn about have behavioral settings
    that can be defined in your `settings.py` file. A common example of this is how
    we need to use the `SHOW_TOOLBAR_CALLBACK` setting to allow us to see the DjDT
    in a Heroku environment. To learn more about all of the settings available, visit
    [https://django-debug-toolbar.readthedocs.io/en/latest/configuration.html#debug-toolbar-config](https://django-debug-toolbar.readthedocs.io/en/latest/configuration.html#23debug-toolbar-config).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 你即将了解的任何面板都有可以在你的`settings.py`文件中定义的行为设置。一个常见的例子是我们需要使用`SHOW_TOOLBAR_CALLBACK`设置来允许我们在Heroku环境中看到DjDT。要了解更多关于所有可用设置的信息，请访问[https://django-debug-toolbar.readthedocs.io/en/latest/configuration.html#debug-toolbar-config](https://django-debug-toolbar.readthedocs.io/en/latest/configuration.html#23debug-toolbar-config)。
- en: 'Follow these steps to activate this setting:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤激活此设置：
- en: 'In the `settings.py` file, add the following code:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`settings.py`文件中，添加以下代码：
- en: '[PRE78]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: We have to use a callable and a variable in the `.env` file because using the
    `DEBUG_TOOLBAR_CONFIG` dictionary and running your automated Django test command
    locally will result in an error due to the DjDT package. Using either the toolbar
    or the Django testing commands separately will be fine without the preceding code,
    but when used together, this code is required.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须在`.env`文件中使用一个可调用对象和一个变量，因为使用`DEBUG_TOOLBAR_CONFIG`字典并本地运行你的自动化Django测试命令会导致由于DjDT包的错误。单独使用工具栏或Django测试命令时，没有前面的代码也可以，但当它们一起使用时，这个代码是必需的。
- en: 'To show this toolbar in your Heroku-hosted environments, set the following
    value to `True` in your `.env` file. Refer to the subsection titled *Remote variables*
    found in [*Chapter 2*](B17243_02_ePub.xhtml#_idTextAnchor037), *Project Configuration*:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在你的Heroku托管环境中显示此工具栏，请在`.env`文件中将以下值设置为`True`。请参阅位于[*第2章*](B17243_02_ePub.xhtml#_idTextAnchor037)，“项目配置”中标题为*远程变量*的子部分：
- en: '[PRE79]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Leave this value as `False` in your local environment.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的本地环境中，将此值保留为`False`。
- en: Now, let's use this toolbar.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用这个工具栏。
- en: How to use the DjDT
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何使用DjDT
- en: 'Make sure your virtual environment is activated and then take the following
    steps to use the DjDT:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你的虚拟环境已激活，然后按照以下步骤使用DjDT：
- en: 'Run your project using the following command, or you can use the IDE, as discussed
    in [*Chapter 2*](B17243_02_ePub.xhtml#_idTextAnchor037), *Project Configuration*:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行你的项目，或者你可以使用IDE，如[*第2章*](B17243_02_ePub.xhtml#_idTextAnchor037)，“项目配置”中讨论的那样：
- en: '[PRE80]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'In your browser, navigate to your home page at [http://localhost:8000/](http://localhost:8000/)
    and you should see the classic home page image with the **Chapter 9** subtitle
    and now, a tab in the top right of the window, as shown in the following screenshot,
    with the arrow pointing to it:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的浏览器中，导航到你的主页[http://localhost:8000/](http://localhost:8000/)，你应该看到带有**第9章**副标题的经典主页图片，现在，在窗口右上角有一个选项卡，如下面的截图所示，箭头指向它：
- en: '![Figure 9.1 – DjDT – tab'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.1 – DjDT – 选项卡'
- en: '](img/Figure_9.01_B17243.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.01_B17243.jpg)'
- en: Figure 9.1 – DjDT – tab
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – DjDT – 选项卡
- en: 'Click on this toolbar to open it and see what mysteries behold, as shown in
    the following screenshot:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击这个工具栏以打开它，看看隐藏的秘密，如下面的截图所示：
- en: '![Figure 9.2 – DjDT – opened'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.2 – DjDT – 打开'
- en: '](img/Figure_9.02_B17243.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.02_B17243.jpg)'
- en: Figure 9.2 – DjDT – opened
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 – DjDT – 打开
- en: Each item in this toolbar can be clicked on to expand it even further. The following
    subsections give you a breakdown of what each panel actually shows you.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 工具栏中的每个项目都可以点击以进一步展开。以下子部分为你分解了每个面板实际上显示的内容。
- en: History
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 历史
- en: 'The **History** panel shows us a list of every request that was made within
    this browser tab. Every time you refresh the page or navigate to a new path within
    your site, that information will be logged within this panel. For each item within
    this panel, there is a **Switch** button. When that button is clicked, debug information
    will update in the other tabs relative to that request, highlighted with arrows
    in the following screenshot:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '**历史**面板显示在这个浏览器选项卡内发出的每个请求的列表。每次你刷新页面或在你网站上导航到新的路径时，这些信息都会在这个面板中记录。在这个面板中的每个项目都有一个**切换**按钮。当点击该按钮时，与该请求相关的其他选项卡中的调试信息将更新，如下面的截图所示，其中用箭头突出显示：'
- en: '![Figure 9.3 – DjDT – History tab'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.3 – DjDT – 历史选项卡'
- en: '](img/Figure_9.03_B17243.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.03_B17243.jpg)'
- en: Figure 9.3 – DjDT – History tab
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3 – DjDT – 历史选项卡
- en: When you click the `chapter_8` app URL patterns in preparation for this chapter.
    In this example, I am actually logged into my admin panel, showing in the **SQL**
    tab that there are three queries, then when I switch to one of the home page URLs,
    the **SQL** tab updates to tell me I now have two queries. I'll explain what these
    queries mean in the *SQL* subsection that follows. For now, you can at least see
    how this data is changing.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 当你点击准备本章的`chapter_8`应用URL模式时。在这个例子中，我实际上登录到了我的管理面板，在**SQL**标签页中显示有三个查询，然后当我切换到主页面的一个URL时，**SQL**标签页更新并告诉我现在有两个查询。我将在接下来的*SQL*子节中解释这些查询的含义。现在，你至少可以看到这些数据是如何变化的。
- en: Versions
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 版本
- en: 'The `requirements.txt` file is shared with developers to automate the installation
    of the required packages and versions of your project. The following screenshot
    shows what this tab looks like, verifying that we are indeed using Django 4.0:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`requirements.txt`文件与开发者共享，用于自动化安装项目所需的包及其版本。以下截图显示了此标签页的外观，验证我们确实在使用Django
    4.0：'
- en: '![Figure 9.4 – DjDT – Versions tab'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.4 – DjDT – 版本标签页'
- en: '](img/Figure_9.04_B17243.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.04_B17243.jpg)'
- en: Figure 9.4 – DjDT – Versions tab
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4 – DjDT – 版本标签页
- en: Time
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 时间
- en: The **Time** tab only displays the time it took to execute the current request.
    It doesn't actually open a new panel like the first two tabs. It's just a placeholder
    tab that displays useful information.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '**时间**标签页仅显示执行当前请求所需的时间。它实际上并没有像前两个标签页那样打开一个新的面板。它只是一个占位符标签页，显示有用的信息。'
- en: Settings
  id: totrans-264
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置
- en: 'The `settings.py` variables and their computed values. This is handy if you
    have methods calculating values, or if you are linking many different `settings.py`
    files together from other packages that override or change the values in your
    parent file, they can all be viewed from here. The following screenshot shows
    you what that looks like:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`settings.py`变量及其计算值。如果你有计算值的函数，或者如果你正在将许多不同的`settings.py`文件链接到其他包中，这些包覆盖或更改了父文件中的值，它们都可以在这里查看。以下截图显示了它的样子：'
- en: '![Figure 9.5 – DjDT – Settings tab'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.5 – DjDT – 设置标签页'
- en: '](img/Figure_9.05_B17243.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.05_B17243.jpg)'
- en: Figure 9.5 – DjDT – Settings tab
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5 – DjDT – 设置标签页
- en: Headers
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标题
- en: 'The **Headers** panel displays all of the information pertaining to your HTTP
    request and response headers. It also displays your WSGI or ASGI environment variables
    at the bottom of this panel. This can be very helpful when you are working with
    API endpoints and you need to make sure the information in your request and response
    headers is as what you would expect it to be. The following screenshot shows you
    what this looks like:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '**标题**面板显示与你的HTTP请求和响应头相关的所有信息。它还在此面板的底部显示你的WSGI或ASGI环境变量。当你与API端点一起工作时，这非常有帮助，你需要确保请求和响应头中的信息是你预期的。以下截图显示了它的样子：'
- en: '![Figure 9.6 – DjDT – Headers tab'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.6 – DjDT – 标题标签页'
- en: '](img/Figure_9.06_B17243.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.06_B17243.jpg)'
- en: Figure 9.6 – DjDT – Headers tab
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6 – DjDT – 标题标签页
- en: Request
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 请求
- en: 'The **Request** panel shows you all of the data related to your request, such
    as keyword arguments and cookie and session data. This tab is very useful for
    checking to make sure this information is what it is expected to be. The following
    screenshot shows what this panel looks like:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '**请求**面板显示了与你的请求相关的所有数据，例如关键字参数和cookie和会话数据。此标签页非常有用，可以检查确保这些信息是你预期的。以下截图显示了此面板的样子：'
- en: '![Figure 9.7 – DjDT – Request tab'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.7 – DjDT – 请求标签页'
- en: '](img/Figure_9.07_B17243.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.07_B17243.jpg)'
- en: Figure 9.7 – DjDT – Request tab
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7 – DjDT – 请求标签页
- en: SQL
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SQL
- en: 'The **SQL** panel shows you a very detailed and broken-down look of what each
    query is doing, as well as showing you all of the queries involved in a particular
    request. For example, if you are visiting the home page while not logged into
    the Django admin site, the **SQL** tab will tell you there are zero queries, as
    depicted in *Figure 9.2*. However, if you are logged into the Django admin site
    and are visiting the home page, you should see at least two queries under the
    **SQL** tab. When you click on this tab, you will see what those two queries are,
    as shown in the following screenshot:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '**SQL**面板展示了每个查询的非常详细和分解的视图，以及显示特定请求中涉及的所有查询。例如，如果你在未登录Django管理站点的情况下访问主页，**SQL**标签页将告诉你没有查询，如图*图9.2*所示。然而，如果你已登录Django管理站点并访问主页，你应该在**SQL**标签页下看到至少两个查询。当你点击此标签页时，你会看到这两个查询是什么，如下面的截图所示：'
- en: '![Figure 9.8 – DjDT – SQL tab'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.8 – DjDT – SQL标签页'
- en: '](img/Figure_9.08_B17243.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 9.08](img/Figure_9.08_B17243.jpg)'
- en: Figure 9.8 – DjDT – SQL tab
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.8 – DjDT – SQL 标签页
- en: 'Here, we can see the first query establishes a session for the current request
    and then queries the object of the user logged into the system. That user object
    is a `Seller` model object because of how we extended the `User` model in [*Chapter
    3*](B17243_03_ePub.xhtml#_idTextAnchor077), *Models, Relations, and Inheritance*.
    Each query also has a **Sel** and **Expl** button, which provide other details
    about that query. Clicking the plus sign, found to the left of any one of these
    queries expands even more, giving you information about that query, including
    traceback information, as shown:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到第一个查询为当前请求建立了一个会话，然后查询了系统登录用户的对象。由于我们在 [*第 3 章*](B17243_03_ePub.xhtml#_idTextAnchor077)，*模型、关系和继承*
    中扩展了 `User` 模型，该用户对象是一个 `Seller` 模型对象。每个查询都有一个 **Sel** 和 **Expl** 按钮，它们提供了有关该查询的其他详细信息。点击任何这些查询左侧的加号，可以进一步展开，显示有关该查询的信息，包括跟踪信息，如下所示：
- en: '![Figure 9.9 – DjDT – SQL tab expanded'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.9 – DjDT – SQL 标签页展开'
- en: '](img/Figure_9.09_B17243.jpg)'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 9.09](img/Figure_9.09_B17243.jpg)'
- en: Figure 9.9 – DjDT – SQL tab expanded
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.9 – DjDT – SQL 标签页展开
- en: Static files
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 静态文件
- en: 'The **Static files** panel displays all of the apps installed that actually
    contain static files. The middle section lists all of the static files related
    to the current request. You can actually click on them to open and view them in
    the current or a new tab. The last section in this panel displays a list of all
    of the static files found in all of the apps that are installed. This can sometimes
    be helpful if you are comparing a static file that overrides the same static file
    of another app, you can see which one is used and which ones are ignored. The
    following screenshot shows you what this panel looks like:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '**静态文件**面板显示所有已安装且实际包含静态文件的程序。中间部分列出与当前请求相关的所有静态文件。您实际上可以点击它们以在当前标签页或新标签页中打开和查看它们。此面板的最后部分显示所有已安装的应用程序中找到的所有静态文件的列表。如果您正在比较覆盖另一个应用程序相同静态文件的静态文件，这可能有时很有帮助，您可以看到哪个被使用，哪些被忽略。以下截图显示了此面板的外观：'
- en: '![Figure 9.10 – DjDT – Static files tab'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.10 – DjDT – 静态文件标签页'
- en: '](img/Figure_9.10_B17243.jpg)'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 9.10](img/Figure_9.10_B17243.jpg)'
- en: Figure 9.10 – DjDT – Static files tab
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.10 – DjDT – 静态文件标签页
- en: Here, we can see that the only static file being used on this page is the `home_page.jpg`
    file. Since the `index.html` file is not extending the `base_template_1.html`
    file, we don't have any CSS or JavaScript files used on this page; they do not
    get loaded. Should you activate the DjDT and go back to previous chapters, you
    will likely see those additional assets because we were using the `base_template_1.html`
    file. Any debug tools, such as CSS and JavaScript files related to the DjDT, will
    not be shown in the middle section. The idea is that those are debug-related assets
    and we don't need to know that on the page that we are debugging. Should you inspect
    a page using your browser tools, you will see assets related to the DjDT; they
    will not appear in production.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到该页面上正在使用的唯一静态文件是 `home_page.jpg` 文件。由于 `index.html` 文件没有扩展 `base_template_1.html`
    文件，因此我们在这个页面上没有使用任何 CSS 或 JavaScript 文件；它们不会被加载。如果您激活 DjDT 并返回到前面的章节，您可能会看到那些额外的资源，因为我们使用了
    `base_template_1.html` 文件。任何与 DjDT 相关的调试工具，如 CSS 和 JavaScript 文件，都不会显示在中间部分。我们的想法是这些是调试相关的资源，我们不需要在调试的页面上知道这些。如果您使用浏览器工具检查页面，您将看到与
    DjDT 相关的资源；它们不会出现在生产环境中。
- en: Templates
  id: totrans-294
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模板
- en: 'The **Templates** panel displays information related to the templates used
    and the context that is available. The middle section displays all of the templates.
    If you had partial HTML files using includes or extends, each one of those templates
    would appear in this list in the order that they are used. When you click on the
    **Toggle context** arrow, shown in the following screenshot, it will display a
    list of all of the context variables and their values related to that file:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '**模板**面板显示与使用的模板和可用上下文相关的信息。中间部分显示所有模板。如果您使用了包含或扩展的局部 HTML 文件，则每个模板都会按使用顺序出现在此列表中。当您点击下面的截图所示的**切换上下文**箭头时，它将显示与该文件相关的所有上下文变量及其值的列表：'
- en: '![Figure 9.11 – DjDT – Templates tab'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.11 – DjDT – 模板标签页'
- en: '](img/Figure_9.11_B17243.jpg)'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 9.11](img/Figure_9.11_B17243.jpg)'
- en: Figure 9.11 – DjDT – Templates tab
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.11 – DjDT – 模板标签页
- en: 'The following screenshot depicts what clicking the **Toggle context** button
    looks like, showing us the context available in that particular template or partial
    file:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了点击 **切换上下文** 按钮的样子，显示了在该特定模板或部分文件中可用的上下文：
- en: '![Figure 9.12 – DjDT – Templates tab showing context'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.12 – DjDT – 显示上下文的模板选项卡'
- en: '](img/Figure_9.12_B17243.jpg)'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.12_B17243.jpg)'
- en: Figure 9.12 – DjDT – Templates tab showing context
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.12 – DjDT – 显示上下文的模板选项卡
- en: At the bottom of this panel is where all of the context processors are located.
    You can view the context available in each of the context processors available.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在此面板的底部是所有上下文处理器所在的位置。你可以查看每个上下文处理器中可用的上下文。
- en: Cache
  id: totrans-304
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 缓存
- en: The **Cache** panel displays all of the cached objects involved with this page.
    This is if you are using tools that help enhance the performance of your database.
    This is considered an advanced topic beyond the scope of this book.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '**缓存**面板显示了与该页面相关的所有缓存对象。这是如果你正在使用帮助提高数据库性能的工具时。这被认为是一个超出本书范围的进阶主题。'
- en: Note
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The DjDT publisher also notes in their own documentation that this panel is
    incompatible with Django's per-site caching.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: DjDT 发布者也在他们的文档中指出，此面板与 Django 的按站点缓存不兼容。
- en: Signals
  id: totrans-308
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 信号
- en: The **Signals** panel displays the notifiers and receivers within an application
    that are communicating with each other. These can be closely compared to what
    **WebSocket** is. This is also considered an advanced topic beyond the scope of
    this book.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '**信号**面板显示了应用程序内相互通信的通知者和接收者。这些可以与 **WebSocket** 进行紧密比较。这被认为是一个超出本书范围的进阶主题。'
- en: Logging
  id: totrans-310
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 记录
- en: The `logging` library. Before showing how this panel looks, let's wire up an
    actual log to view. As with the Django messages framework, the logging system
    has different levels of messages. The default minimum log level is `WARNING` but
    you can show `DEBUG`- and `INFO`-level logs the same way, either by setting it
    in your `settings.py` file or by declaring it inline where your log is set, as
    we are going to do in the following steps. To learn more about all of the capabilities
    of using the logging system, visit [https://docs.djangoproject.com/en/4.0/topics/logging/](https://docs.djangoproject.com/en/4.0/topics/logging/)
    and [https://docs.python.org/3/library/logging.html](https://docs.python.org/3/library/logging.html).
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '`logging` 库。在展示此面板的外观之前，让我们连接一个实际的日志来查看。与 Django 消息框架一样，日志系统有不同的消息级别。默认的最小日志级别是
    `WARNING`，但你也可以以相同的方式显示 `DEBUG` 和 `INFO` 级别的日志，无论是通过在 `settings.py` 文件中设置它，还是通过在设置日志的地方声明它，就像我们将在以下步骤中做的那样。要了解更多关于使用日志系统所有功能的信息，请访问
    [https://docs.djangoproject.com/en/4.0/topics/logging/](https://docs.djangoproject.com/en/4.0/topics/logging/)
    和 [https://docs.python.org/3/library/logging.html](https://docs.python.org/3/library/logging.html)。'
- en: 'Take the following steps to practice using the logging system:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 按以下步骤练习使用日志系统：
- en: 'In your `/chapter_4/views.py` file, add the following log statements at the
    beginning of the existing `practice_year_view()`:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 `/chapter_4/views.py` 文件中，在现有的 `practice_year_view()` 函数开始处添加以下日志语句：
- en: '[PRE81]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The first two lines lower the logging level to show all `INFO`-level logs and
    higher, allowing us to use the `logger.info()` method to create the log message.
    Otherwise, the lowest level we could use by default would be the `logger.warning()`
    level method. The log message we are expecting to see should be `The Requested
    Year Is: 2022` when visiting the URL.'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '前两行将日志级别降低，以显示所有 `INFO` 级别及以上的日志，允许我们使用 `logger.info()` 方法创建日志消息。否则，默认情况下我们能够使用的最低级别将是
    `logger.warning()` 方法。当我们访问 URL 时，期望看到的日志消息应该是 `The Requested Year Is: 2022`。'
- en: 'Now, navigate to [http://localhost:8000/my_year_path/2022/](http://localhost:8000/my_year_path/2022/)
    in your browser and expand the debug toolbar. Open the **Logging** tab and now
    you should see the log that we created, as depicted in the following screenshot:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在浏览器中导航到 [http://localhost:8000/my_year_path/2022/](http://localhost:8000/my_year_path/2022/)
    并展开调试工具栏。打开 **记录** 选项卡，现在你应该能看到我们创建的日志，如以下截图所示：
- en: '![Figure 9.13 – DjDT – Logging tab'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.13 – DjDT – 记录选项卡'
- en: '](img/Figure_9.13_B17243.jpg)'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.13_B17243.jpg)'
- en: Figure 9.13 – DjDT – Logging tab
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.13 – DjDT – 记录选项卡
- en: Intercept redirects
  id: totrans-320
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 拦截重定向
- en: The **Intercept redirects** checkbox is used to display an intermediary page
    whenever a redirect is performed to display information about that redirect, before
    the browser is updated with the redirected page.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '**拦截重定向**复选框用于在执行重定向时显示一个中间页面，以显示有关该重定向的信息，在浏览器更新重定向页面之前。'
- en: Profiling
  id: totrans-322
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 性能分析
- en: 'The **Profiling** checkbox enables the gathering of extra data on page load.
    It is a detailed analysis of memory and CPU processes taking place. Each process
    is broken down into the smallest measurements possible. By default, this checkbox
    is left unchecked. An example of what this looks like is shown in the following
    screenshot:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '**配置文件**复选框允许在页面加载时收集额外数据。它是对内存和CPU进程的详细分析。每个进程都被分解成可能的最小测量值。默认情况下，此复选框保持未选中状态。以下截图展示了其外观示例：'
- en: '![Figure 9.14 – DjDT – Profiling tab'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.14 – DjDT – 配置文件选项卡'
- en: '](img/Figure_9.14_B17243.jpg)'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.14_B17243.jpg)'
- en: Figure 9.14 – DjDT – Profiling tab
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.14 – DjDT – 配置文件选项卡
- en: We now have a deeper understanding of all of the tabs available within the DjDT
    and what they are used for. This now adds a wealth of tools to our toolbox to
    help us make world-class applications with ease.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们对 DjDT 中所有可用的选项卡及其用途有了更深入的了解。这为我们提供了丰富的工具，帮助我们轻松地制作世界级的应用程序。
- en: Summary
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: By now, we have developed a solid understanding of how automated testing in
    Django is performed. We wrote several test cases that test many of the exercises
    done in previous chapters. We practiced writing test cases that simulate success
    and others that deliberately trigger a failure to better understand what is happening.
    We even discovered how to write test cases that work with the Django REST framework.
    After we worked with automated testing, we then installed what I would consider
    the most powerful tool of them all, the DjDT. The DjDT is used for real-time debugging
    of developers' code as they write that code and run their projects locally.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经对Django中自动测试的执行方式有了坚实的理解。我们编写了几个测试用例，测试了前几章中完成的许多练习。我们练习编写模拟成功的测试用例和其他故意触发失败的测试用例，以更好地理解正在发生的事情。我们甚至发现了如何编写与Django
    REST框架一起工作的测试用例。在处理自动测试后，我们安装了我认为所有工具中最强大的工具，即DjDT。DjDT用于开发者在编写代码和本地运行项目时进行实时调试。
- en: In the next chapter, we will learn how to use the DjDT to monitor performance
    as we learn how to optimize database queries.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用 DjDT 来监控性能，同时学习如何优化数据库查询。
