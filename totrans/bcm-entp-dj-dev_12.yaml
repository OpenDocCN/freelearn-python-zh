- en: '*Chapter 9*: Django Testing'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is dedicated to testing and debugging a Django project. Django
    has a wide range of test classes built into its framework that are used to write
    automated test scripts. As we build each app and/or component of a project, we
    can run one command at any time to ensure that every component still works as
    it should. This is great for **regression testing**, which means testing a new
    or changed component, making sure that it does not affect the intended behavior
    of existing components or the entire system as a whole. For most of what we will
    cover in this chapter, we do not need to install any third-party packages. The
    last thing we will cover is the **Django Debug Toolbar** (**DjDT**), which does
    require us to install a third-party package to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Writing automated test scripts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating unit test cases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing view classes and their get and post methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing view classes that require user authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing Django REST API endpoints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing the DjDT, a tool used for debugging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To work with the code in this chapter, the following tools will need to be
    installed on your local machine:'
  prefs: []
  type: TYPE_NORMAL
- en: Python version 3.9 – used as the underlying programming language for the project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Django version 4.0 – used as the backend framework of the project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: pip package manager – used to manage third-party Python/Django packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will continue to work with the solution created in [*Chapter 2*](B17243_02_ePub.xhtml#_idTextAnchor037),
    *Project Configuration*. However, it is not necessary to use the Visual Studio
    IDE. The main project itself can be run using another IDE or run independently
    using a terminal or command-line window from within the project root folder, which
    is where the `manage.py` file resides. Whatever editor or IDE you are using, a
    virtual environment will also be needed to work with the Django project. Instructions
    for how to create a project and virtual environment can be found in [*Chapter
    2*](B17243_02_ePub.xhtml#_idTextAnchor037), *Project Configuration*. You will
    need a database to store the data contained in your project. PostgreSQL was chosen
    for the examples in the previous chapters; however, any database type that you
    choose for your project can be used to work with the examples in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will also be using data that is in the form of a Django fixture, provided
    in [*Chapter 3*](B17243_03_ePub.xhtml#_idTextAnchor077), *Models, Relations, and
    Inheritance*, in the subsection titled *Loading the chapter_3 data fixture*. Make
    sure the `chapter_3` fixture is loaded into your database. If this has already
    been done, then you may skip the next command. If you have already created the
    tables found in [*Chapter 3*](B17243_03_ePub.xhtml#_idTextAnchor077), *Models,
    Relations, and Inheritance*, and have not loaded that fixture yet, then run the
    following command, after activating your virtual environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'All of the code created in this chapter can be found in the GitHub repository
    for this book: [https://github.com/PacktPublishing/Becoming-an-Enterprise-Django-Developer](https://github.com/PacktPublishing/Becoming-an-Enterprise-Django-Developer).
    The bulk of the code depicted in this chapter can be found in the `/becoming_a_django_entdev/becoming_a_django_entdev/chapter_9/`
    directory.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the *Code in Action*: [https://bit.ly/3yh0tW6](https://bit.ly/3yh0tW6).'
  prefs: []
  type: TYPE_NORMAL
- en: Preparing for this chapter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Start by creating a new app in your project called `chapter_9` by following
    the steps discussed in [*Chapter 2*](B17243_02_ePub.xhtml#_idTextAnchor037), *Project
    Configuration*, in the subsection titled *Creating a Django app*. As discussed
    in that section, don't forget to change the value of the `name =` variable for
    your app class found in the `/becoming_a_django_entdev/becoming_a_django_entdev/chapter_9/apps.py`
    file to now point to the path where you installed your app. Be sure to also include
    this app in the `INSTALLED_APPS` variable found in the `settings.py` file as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the main `urls.py` file of the site, add the following two paths:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: These point to the [*Chapter 9*](B17243_09_ePub.xhtml#_idTextAnchor272) URL
    patterns that we will be creating for this chapter and includes all of the URL
    patterns that we created for [*Chapter 8*](B17243_08_ePub.xhtml#_idTextAnchor239),
    *Working with the Django REST Framework*. We will need the API endpoints that
    we created in the previous chapter for some of the REST API test exercises. Make
    sure the [*Chapter 9*](B17243_09_ePub.xhtml#_idTextAnchor272) URLs take precedence
    over the other by placing them first in this list.
  prefs: []
  type: TYPE_NORMAL
- en: 'In your `/chapter_9/urls.py` file, you should add the following paths. These
    paths were used in the exercises in [*Chapter 4*](B17243_04_ePub.xhtml#_idTextAnchor116),
    *URLs, Views, and Templates*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Instead of including all of the URLs from [*Chapter 4*](B17243_04_ePub.xhtml#_idTextAnchor116),
    *URLs, Views, and Templates*, we are only providing you with the ones that are
    needed. The reason behind this is that in [*Chapter 4*](B17243_04_ePub.xhtml#_idTextAnchor116),
    *URLs, Views, and Templates*, we discussed several variations of writing the same
    paths for learning purposes. To prevent confusion, only the variation of the URL
    patterns that are needed to satisfy the type of tests that we are about to perform
    is included in the preceding code.
  prefs: []
  type: TYPE_NORMAL
- en: Copy the `index.html` file from the code of the book found in the `/chapter_9/templates/chapter_9`
    directory into your project in the same directory. Also, copy the `chapter_9`
    CSS and JavaScript files from the code of the book into your project.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you cloned the entire repository of code provided with this book and the
    DjDT is already turned on/enabled, please disable it before running any of the
    test cases that we will soon create. Look for the **Turn Off/Comment Out For the
    First Half of Chapter 9** comments throughout the settings and URL files. That
    tool will be discussed after working through some test cases.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's discuss what automated testing is in Django and how it is used.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding automated testing in Django
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Automated testing is helpful for a number of reasons. Developers use it when
    refactoring old components that need to be modified. Test scripts are used to
    regression test older components to see whether they were affected negatively
    by any new additions. Django offers several test classes that are an extension
    of the standard Python library called `unittest`. You can learn more about this
    package here: [https://docs.python.org/3/library/unittest.html](https://docs.python.org/3/library/unittest.html).
    The Django test classes are all found in the `django.test` library. The most commonly
    used class is `TestCase`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following list depicts all of the test classes that are available in the
    `django.test` library:'
  prefs: []
  type: TYPE_NORMAL
- en: '`unittest` library. This class will not interact with a database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SimpleTestCase` class and allows for database transactions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TransactionTestCase` class and includes features that allow for better interactions
    with a database. It is the most commonly used test class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TransactionTestCase` class and allows the use of test clients other than the
    test client provided by Django, such as Appium, Cypress, Selenium, Serenity, or
    any of the dozens of other ones available. It will actually spin up a live Django
    server in the background to run the test and then destroy that server upon completion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LiveServerTestCase` class. This class is built specifically for using the
    Selenium test framework as the test client due to how popular it is.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing test classes is just like writing any other Python class. They must
    consist of at least a test method, and they usually contain a `setUp()` method,
    but this method is not required. Test methods have the word `test_` prepended
    to their name, for example, `test_one()` and `test_two()`. The `setUp()` method
    is used to prepare your environment and/or database for any of the test methods
    in that class. If a class has more than one test method, an object created in
    one test method will not be accessible in the other test method. If you need an
    object in both test methods of a class, you need to place that logic in the `setUp()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Test classes may also have a `tearDown()` method, which will perform any cleanup
    tasks necessary after a test has been performed and before moving on to the next
    test. `tearDown()` is not used very often seeing as Django will automatically
    destroy any servers and databases created during the test after the test has completed.
    Other methods are available as well and you can learn more about them here: [https://docs.djangoproject.com/en/4.0/topics/testing/tools/](https://docs.djangoproject.com/en/4.0/topics/testing/tools/).'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Selenium is a third-party library of tools that simulates actual browsers, allowing
    you to run automated tests in many different browser types and versions. It is
    not necessary to perform basic/standard test cases and this is considered an advanced
    topic beyond the scope of this book. To learn more about Selenium, visit [https://www.selenium.dev/](https://www.selenium.dev/),
    [https://pypi.org/project/selenium/](https://pypi.org/project/selenium/), and
    [https://django-selenium.readthedocs.io/en/latest/](https://django-selenium.readthedocs.io/en/latest/).
  prefs: []
  type: TYPE_NORMAL
- en: Every time a new app is created in Django, such as when all of the chapter apps
    were created prior to this chapter, you may have noticed that a `tests.py` file
    was automatically created for you in that app directory. This file is created
    whether you are using the IDE or command line to create the new app. We have just
    been disregarding this file as it served no purpose to us, until now. The code
    in this chapter will live almost entirely within the `tests.py` file. If you are
    using the Visual Studio IDE, you may have also noticed that it created a `SimpleTest(TestCase)`
    class in your `tests.py` file. Apps created through the command-line window or
    terminal will not have created this class for you. Go ahead and comment this out
    or delete it before proceeding so that we only see the results pertaining to the
    test(s) at hand.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a better understanding of how tests are performed, let's dive
    in and begin testing next.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with unit testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`SimpleTest` class that the Visual Studio IDE created for us is actually testing
    for. These can be utility methods, conditional or comparison statements, Django
    models, forms, email messages, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's practice writing a simple test script and then write another to include
    our models.
  prefs: []
  type: TYPE_NORMAL
- en: Basic unit test script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will write a very basic test class that executes two different
    test methods. These tests will not interact with a database and are only used
    to compare `True` and `False` statements. The class as a whole can be used as
    a boilerplate when creating new test classes and modified as needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In your `/chapter_9/tests.py` file, add the structure of the class, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `test_pass(self)` method is used to compare whether `True` actually equals
    `True` when `True` is passed into the function; it is intended to be a successful
    test. The `test_fail(self)` method is used to compare whether `False` equals `False`
    when `True` is passed into the function; it is intended to produce a failure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in your command-line window or terminal, navigate to your project''s root
    directory and activate your virtual environment but do not run the project at
    this time. Instead, execute the Django test command depicted in the following
    code, which will only execute the tests found in your `chapter_9` app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If everything runs as intended in this exercise, it should tell you in your
    command-line window that two tests were performed and which one failed, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: On the third line in the preceding output, it printed `F.`. The capital `F`
    represents one test was a failure and the period represents one test was a success.
    It then prints each of the tests that failed below that line. For each test that
    it prints out, Django includes the comment written for that test case, such as
    `'''Checks if False == False, Value set to True'''`. Make use of the triple double-quote
    or single-quote comment notation to include helpful information when your test
    does fail. It then provides traceback information, indicating the cause and location
    of the error or failure. You can also include `print()` statements within these
    test methods if you want to provide additional information regarding a particular
    test.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: To run the tests for all of the apps included in your project, run the following
    command:`(virtual_env) PS > python manage.py test`
  prefs: []
  type: TYPE_NORMAL
- en: Also, if you break your single-line double-quote or single-quote comment into
    a multiline comment, only the first line of that comment will appear in your command-line
    window.
  prefs: []
  type: TYPE_NORMAL
- en: Now, comment out or delete the `TestingCalibrator` class before moving on to
    the next exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Testing Django models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will use the `TestCase` class because we will be connecting
    to a database. The database that the test client spins up for us will not affect
    any of the data found in all local or remote databases. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In your `/chapter_3/models.py` file, make sure the (8, ''Jeep'') value exists
    in the `MAKE_CHOICES` list of choices:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In your `/chapter_9/tests.py` file, add the following `import` statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In that same file, add the following class and `setUp()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In that same `ModelUnitTestCase` class, add the following test method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding `setUp(self)` method will create a `VehicleModel`, `Engine`, `Vehicle`,
    and `Seller` model object that we imported from the `chapter_3` app. The `setUp()`
    method creates these objects before any of the test cases in that class are executed.
    We create each related object as a variable and then use that variable to assign
    as the related object of the next object that we create. The `Seller` object uses
    the same `create_user()` method that was introduced in [*Chapter 6*](B17243_06_ePub.xhtml#_idTextAnchor190),
    *Exploring the Django Admin Site*, to create a new `Seller` with the hashed password
    and date fields formatted for us. We created only one test, called `test_full_vehicle_name()`,
    which looks up the vehicle that was created upon setup by the vin field value
    specified. It uses the `full_vehicle_name()` method that we created in [*Chapter
    3*](B17243_03_ePub.xhtml#_idTextAnchor077), *Models, Relations, and Inheritance*,
    to return to us the custom-formatted name of that newly created vehicle. The expected
    value is `Jeep Grand Cherokee Laredo 4WD - 3.6L FI FFV DO`, which is in the format
    `{{ make }} {{ model }} – {{ engine }}`. If the resulting value does not match
    that value, the test will fail.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, execute the run test command shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you commented out all the other tests prior to this one, you should see
    the results shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Go ahead and change the expected value found in the `self.assertEqual()` function
    of *step 4* previously to something that doesn''t exist, and then rerun your test
    command one more time. Now, you should see a failure message, as depicted here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Go ahead and comment out the `ModelUnitTestCase` class before proceeding to
    the next exercise. Now that we have an understanding of how to write simple test
    cases and cases that test model CRUD actions, next, we will test a custom view
    class that was written in [*Chapter 4*](B17243_04_ePub.xhtml#_idTextAnchor116),
    *URLs, Views, and Templates*.
  prefs: []
  type: TYPE_NORMAL
- en: Testing HTTP view requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will expand on the basic test cases that we previously wrote
    to include HTTP view requests. When testing view classes, whether they are a method-based
    view or a class-based view, they will both use the same `TestCase` class that
    we have been using so far.
  prefs: []
  type: TYPE_NORMAL
- en: In the following subsections, we will perform two tests, one for a method-based
    view and the other for a class-based view.
  prefs: []
  type: TYPE_NORMAL
- en: Testing method-based views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will test the `practice_year_view()` method, written in
    [*Chapter 4*](B17243_04_ePub.xhtml#_idTextAnchor116), *URLs, Views, and Templates*.
    What we are comparing in this test is whether the response code that gets returned
    equals the value of `200`, which means a successful response.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to create your test case:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In your `/chapter_9/tests.py` file, add the following `YearRequestTestCase`
    class and methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This test uses a `RequestFactory()` object saved as the `self.factory` variable.
    It then uses that factory to construct an actual `request` object. The path that
    we want to test is passed into the `self.factory.get()` method as `/my_year_path/2022/`.
    Since we are not requiring authentication within `practice_year_view()`, we are
    setting the `request.user` object to an `AnonymousUser()` class object provided
    in the `django.contrib.auth.models` library. The response is constructed using
    the `practice_year_view(request, 2022)` method. Here, we pass in the `request`
    object and the value of the year keyword argument that we are attempting to access.
    The last line checks whether `response.status_code` actually equals a value of
    `200`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, run the following test command for the `chapter_9` app test cases:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If successful, you should see the following message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Go back to *step 1* and change all instances of the year `2022` to `12` (found
    in two spots), and then rerun your test command. You should see the failure/error
    message shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: This test case failed because of the condition that we wrote in the `practice_year_view()`
    method in [*Chapter 4*](B17243_04_ePub.xhtml#_idTextAnchor116), *URLs, Views,
    and Templates*, which checks to make sure the user enters a year greater than
    or equal to `1900`. You will also see that instead of printing an `F` or period
    for this test, it printed the capital letter `E`, which stands for error. The
    error versus a failure is a result of the custom parameters that we are checking
    for, meaning the URL pattern is correct but the view itself performs additional
    logic that triggers the page-not-found error.
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and comment out the `YearRequestTestCase` class before proceeding to
    the next exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Let's test a class-based view in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Testing class-based views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will test the `VehicleView` class, written in [*Chapter
    4*](B17243_04_ePub.xhtml#_idTextAnchor116), *URLs, Views, and Templates*. We will
    be loading the `chapter_3` data fixture instead of creating objects in the `setUp()`
    method, as we have done in the `ModelUnitTestCase` class. We already performed
    a test to see whether creating objects was a success. We can save time and effort
    now by just loading a fixture for all other tests that we write.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to create your test case:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In your `/chapter_9/tests.py` file, add the `VehicleRequestTestCase` class
    and methods, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We still need the `RequestFactory()` object and `AnonymousUser()` as we used
    before, because the `VehicleView` class does not require authentication as well.
    We created the response object for this test using `VehicleView.as_view()(request,
    1)`. It looks similar to a URL pattern mapping to a view class, using the `.as_view()`
    method, found in any `urls.py` file. We again check to see whether `response.status_code`
    equals a value of `200`, indicating success.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, run the test command shown in the following code and you should once again
    see a successful test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, change the number `1` found in *step 1* in `''/vehicle/1/''` and `(request,
    1)` to `99`. This number represents the index of the vehicle that we are trying
    to access, an index that should not currently exist. Then, rerun your `test` command
    and you should see the following message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You'll notice, inside the preceding traceback message, that it indicates that
    an object with that ID was not found. The bottom of your traceback is where you
    will likely find your answer as to what caused the problem to occur, but that
    is not always the case. This is because we have less than 10 vehicle items found
    in the `chapter_3` fixture.
  prefs: []
  type: TYPE_NORMAL
- en: Comment out the `VehicleRequestTestCase` class before proceeding to the next
    exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have learned how to test request responses and load data fixtures
    into a test case, let's build on that by adding authentication measures next.
  prefs: []
  type: TYPE_NORMAL
- en: Testing authenticated view requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will be building on the same request test cases that we
    just built to remove the `AnonymousUser` class and perform our own authentication,
    requiring only permitted users. We have a few view classes that we wrote in [*Chapter
    8*](B17243_08_ePub.xhtml#_idTextAnchor239), *Working with the Django REST Framework*,
    that require user authentication. Let's create test scripts that allow us to authenticate
    with an actual user when performing an automated test. This is where loading the
    `chapter_8/urls.py` file when preparing for this chapter comes into play. Django
    provides a class called `Client` found in the `django.test` library that lets
    us perform user authentication when testing a view class.
  prefs: []
  type: TYPE_NORMAL
- en: In the following subsection, we will implement the `Client` class when performing
    authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Client() class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will test the custom API endpoint written in [*Chapter
    8*](B17243_08_ePub.xhtml#_idTextAnchor239), *Working with the Django REST Framework*,
    in the `GetSellerHTMLView` class. This is the class we wrote to query a seller
    by ID and return preformatted HTML instead of the expected JSON, from a traditional
    API endpoint. What we will be testing for is whether or not the `seller` context
    object has the business name that is expected for the ID that we are looking up.
    When using the `Client` class, the `RequestFactory` class is no longer needed,
    and neither is the `AnonymousUser` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to implement your own authentication:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In your `/chapter_9/tests.py` file, add the `SellerClientTestCase` class and
    `setUp()` method shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We first set the `self.user` value to equal a single `Seller`. The ID provided
    is the number `1`, relating to the first superuser created with the username of
    `admin`. This is the only seller object that has been provided in the `chapter_3`
    fixture for you. Next, we set the `self.client` value to be a newly created `Client()`
    object. The last line of the `setUp(self)` method is where we simulate logging
    into the system. We use `self.user.username` to grab the username of the `Seller`
    that we queried. Do not use `self.user.password` as the password; instead, use
    the unhashed password as a string manually written into the code. This is because
    there is no way to retrieve the unhashed password of a user and that is by design
    for security reasons.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: When writing your own test cases, it would be wise to keep test user credentials
    stored in a `.env` file and imported into your project as a `settings.py` variable,
    which can then be referenced instead of hardcoding the password, as was done previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'In that same `SellerClientTestCase` class, add the following test method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: self.assertEqual(**seller.name**, **'Test Biz Name'**)
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding `test_get(self)` method, we created the response object using
    `self.client.get()`. Inside that method, we are passing in the path that we are
    testing, of http://localhost:8000/chapter-8/seller/1/. We are performing two checks
    instead of one within this test case; the first checks whether `response.status_code`
    actually equals `200`, to indicate success. The other checks whether or not the
    seller's business name is what is expected for the object that we are looking
    up, that being `Test Biz Name`.
  prefs: []
  type: TYPE_NORMAL
- en: This is why we are creating the lowercase `seller` variable, which grabs the
    `seller` from the context returned with the request. It is also important that
    we add the `self.assertEqual(response.status_code, 200)` statement before we create
    the lowercase `seller` variable. If we do not have a successful response for any
    reason, the `seller` object will obviously not exist and so the test will fail.
    When that happens, it could point you in the wrong direction as to what the real
    problem could be.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, run the following `test` command and you should once again see a successful
    test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, change the `password` value found in *step 1* to an incorrect password,
    such as `mynewpassword1`, which will force a failed response. Rerun your `test`
    command and you should see the following message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can see the reason why a failure occurred is due to **AssertionError: 401
    != 200**. A **401** response means an unauthorized response, which means the requested
    resource does not have valid authentication credentials and access will not be
    granted.'
  prefs: []
  type: TYPE_NORMAL
- en: Change your password back to the correct password of `mynewpassword` and then,
    returning to *step 2*, change the business name in the last line to something
    incorrect, such as `Test Biz Name1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Rerun the `test` command one more time and now you should see the following
    failed message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This also indicates that we achieved a **200** successful response code seeing
    that this is the second assertion that failed and not the first one.
  prefs: []
  type: TYPE_NORMAL
- en: You may now comment out the `SellerClientTestCase` class before proceeding to
    the next exercise. Now that we have a better understanding of how to add authentication
    measures to our test cases, we will test Django REST API endpoints with authentication
    next.
  prefs: []
  type: TYPE_NORMAL
- en: Testing Django REST API endpoints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section will introduce writing test cases that test Django REST framework
    endpoints. When testing any REST API endpoints created using the Django REST framework,
    we need to use the `APITestCase` class provided by the `rest_framework.test` library.
    We also should use the `APIClient()` class provided by that same library when
    requiring authentication, instead of using the `Client()` class as we did before.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following exercises, we will create one test class that performs two
    tests: the first will create an engine object and the other will update an object.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating an object test case
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This test will use the `POST` request method to send data to the [http://localhost:8000/chapter-8/engines/](http://localhost:8000/chapter-8/engines/)
    endpoint and create an engine object in the database. Since we are loading a data
    fixture that contains only two engine objects with the IDs `1` and `2`, we should
    expect the new object to be created at index `3`, but your results may vary. We
    will refer back to this in the *Updating an object test case* subsection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to create your test case:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In your `/chapter_9/tests.py` file, add the following `EngineAPITestCase` class,
    the `setUp()` method, and the `import` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The structure of the preceding class follows a very similar pattern to what
    was done in the subsection titled *Using the Client() class*. Here, we set the
    value of `self.client` to use the `rest_framework.test` library-provided `APIClient`
    class. Login is done the same as before, in the `self.client.login()` declaration.
  prefs: []
  type: TYPE_NORMAL
- en: 'In that same `EngineAPITestCase` class, add the following `test_post()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For the response object, instead of using `self.client.get()`, we are using
    `self.client.post()` because we want to send information to the test client server.
    Inside is the data we are sending, noting that the last argument is the format
    of the data, which is set to JSON format in this example. We then check the `response.status_code`
    value, this time to see whether it equals `201` and not `200`. A `201` response
    code indicates that an object was created successfully. The last line checks whether
    the data that was returned to us, which is the object that was created, has the
    engine name that we expect. In this case, the new engine name we are expecting
    is `New Engine`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, run the following `test` command and you should once again see a successful
    test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, go back to *step 1* and add an incorrect password, such as `mynewpassword1`,
    and then run your `test` command again. You should see the following message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can see in this test that we are being warned of `AssertionError: 401 !=
    201` and not `200` this time. You can `achieve` the same by changing the expected
    value of the engine name and you will see it warn you of that assertion.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's add to this class to allow us to test updating an object.
  prefs: []
  type: TYPE_NORMAL
- en: Updating an object test case
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This test will use the `PUT` request method to send data to the [http://localhost:8000/chapter-8/engines/1/](http://localhost:8000/chapter-8/engines/1/)
    endpoint, a specific engine object to update within the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to update your class for this test case:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the same `EngineAPITestCase` class, add the following `test_put()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Please leave the `setUp()` and `test_post()` methods as they are. In the preceding
    `test_put()` method, we are using the `self.client.put()` method to create the
    response object. The data that we are sending is in the same JSON format. Note
    that in the preceding example, we are specifying the path as `'/chapter-8/engines/1/'`,
    which refers to the first engine object with an ID index of `1`. That object is
    being inserted into the dummy database that gets created through the `chapter_3`
    fixture that is still being used in this class. We once again are checking that
    `response.status_code` equals `200`, success. We don't need to check for `201`
    because nothing is being created currently, only updated. We then check to make
    sure that the expected object's name equals `My Changed Engine Name`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, run the following test command and you should see that both tests are
    a success:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To demonstrate how creating an item in one test cannot be retrieved from another
    test within the same class, change the ID of `1` to `3` within the `test_put()`
    method, as in `'/chapter-8/engines/3/'`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When we created an object in the `test_post(self)` method, you might expect
    the newly created object to have had an ID index of `3` since the `chapter_3`
    fixture only has two objects. The reason we won't find the new object to update
    that object is that when the `test_post(self)` method is complete, anything created
    during that operation gets destroyed upon completion.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rerun your `test` command and now you should see the failure message shown
    here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The reason we are seeing a failure is that Django does not keep objects created
    between other test cases within the same test class. Django will keep a counter
    of the last object ID created, which means if or when a test case completes and
    an object gets destroyed, the counter will continue to count. This could make
    for a frustrating time testing and, as such, is the reason we are loading a fixture,
    so that we know for sure that the ID is what it should be for the object that
    we are testing.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a better understanding of how automated testing works in Django,
    let's introduce the DjDT next, a powerful set of tools that helps developers to
    debug during development.
  prefs: []
  type: TYPE_NORMAL
- en: Using the DjDT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The DjDT is a third-party package that integrates a set of configurable panels
    that display debug information in real time to the developer. Other third-party
    packages can be installed to add additional panels to this toolbar. With that
    in mind, you could also build your own panels too. We will only be installing
    the DjDT package by itself and then explaining each of its most common features,
    guiding you through using it, interpreting what it is showing you. To learn more
    about all of its capabilities, visit [https://pypi.org/project/django-debug-toolbar/](https://pypi.org/project/django-debug-toolbar/)
    and [https://django-debug-toolbar.readthedocs.io/en/latest/](https://django-debug-toolbar.readthedocs.io/en/latest/).
  prefs: []
  type: TYPE_NORMAL
- en: Installing the DjDT
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To get started with installing the DjDT, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `django-debug-toolbar` package to your `requirements.txt` file and
    install it into your virtual environment via that file or run the following `pip`
    command, making sure your virtual environment is already active:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In your `settings.py` file, add the following items to your `INSTALLED_APPS`
    list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the same `settings.py` file, add the following middleware to the top of
    your `MIDDLEWARE` list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `debug_toolbar` app and the `MIDDLEWARE` item should be the only new items
    that you are adding to this file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `django.contrib.staticfiles` app, the `INTERNAL_IPS` list, and the `STATIC_URL`
    variable should have already been added in [*Chapter 2*](B17243_02_ePub.xhtml#_idTextAnchor037),
    *Project Configuration*, when we created and configured the project for the first
    time. Note that they are required for this toolbar to work. Should you be working
    on a project of your own that does not follow the `settings.py` specifications
    of this book, make sure that these items are included:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, you will need to import the URL patterns relative to this third-party
    app. To make sure this toolbar can be used in all chapters throughout this book,
    in your main `urls.py` file, add the following `include` pattern:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that in the preceding example, we are placing the import under the `settings.DEBUG`
    conditional statement, checking whether our environment is the `DEBUG` environment.
    We don't ever want this toolbar to appear in a production or production-like test
    environment, such as staging. The development environment is usually acceptable.
  prefs: []
  type: TYPE_NORMAL
- en: That's it; by now, this toolbar should be installed and working properly. Next,
    let's discuss making an adjustment to work with our remote environments.
  prefs: []
  type: TYPE_NORMAL
- en: Adjusting DjDT settings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Any of the panels that you are about to learn about have behavioral settings
    that can be defined in your `settings.py` file. A common example of this is how
    we need to use the `SHOW_TOOLBAR_CALLBACK` setting to allow us to see the DjDT
    in a Heroku environment. To learn more about all of the settings available, visit
    [https://django-debug-toolbar.readthedocs.io/en/latest/configuration.html#debug-toolbar-config](https://django-debug-toolbar.readthedocs.io/en/latest/configuration.html#23debug-toolbar-config).
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to activate this setting:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `settings.py` file, add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have to use a callable and a variable in the `.env` file because using the
    `DEBUG_TOOLBAR_CONFIG` dictionary and running your automated Django test command
    locally will result in an error due to the DjDT package. Using either the toolbar
    or the Django testing commands separately will be fine without the preceding code,
    but when used together, this code is required.
  prefs: []
  type: TYPE_NORMAL
- en: 'To show this toolbar in your Heroku-hosted environments, set the following
    value to `True` in your `.env` file. Refer to the subsection titled *Remote variables*
    found in [*Chapter 2*](B17243_02_ePub.xhtml#_idTextAnchor037), *Project Configuration*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Leave this value as `False` in your local environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, let's use this toolbar.
  prefs: []
  type: TYPE_NORMAL
- en: How to use the DjDT
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Make sure your virtual environment is activated and then take the following
    steps to use the DjDT:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run your project using the following command, or you can use the IDE, as discussed
    in [*Chapter 2*](B17243_02_ePub.xhtml#_idTextAnchor037), *Project Configuration*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In your browser, navigate to your home page at [http://localhost:8000/](http://localhost:8000/)
    and you should see the classic home page image with the **Chapter 9** subtitle
    and now, a tab in the top right of the window, as shown in the following screenshot,
    with the arrow pointing to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.1 – DjDT – tab'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.01_B17243.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.1 – DjDT – tab
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on this toolbar to open it and see what mysteries behold, as shown in
    the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.2 – DjDT – opened'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.02_B17243.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.2 – DjDT – opened
  prefs: []
  type: TYPE_NORMAL
- en: Each item in this toolbar can be clicked on to expand it even further. The following
    subsections give you a breakdown of what each panel actually shows you.
  prefs: []
  type: TYPE_NORMAL
- en: History
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The **History** panel shows us a list of every request that was made within
    this browser tab. Every time you refresh the page or navigate to a new path within
    your site, that information will be logged within this panel. For each item within
    this panel, there is a **Switch** button. When that button is clicked, debug information
    will update in the other tabs relative to that request, highlighted with arrows
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3 – DjDT – History tab'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.03_B17243.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.3 – DjDT – History tab
  prefs: []
  type: TYPE_NORMAL
- en: When you click the `chapter_8` app URL patterns in preparation for this chapter.
    In this example, I am actually logged into my admin panel, showing in the **SQL**
    tab that there are three queries, then when I switch to one of the home page URLs,
    the **SQL** tab updates to tell me I now have two queries. I'll explain what these
    queries mean in the *SQL* subsection that follows. For now, you can at least see
    how this data is changing.
  prefs: []
  type: TYPE_NORMAL
- en: Versions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `requirements.txt` file is shared with developers to automate the installation
    of the required packages and versions of your project. The following screenshot
    shows what this tab looks like, verifying that we are indeed using Django 4.0:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.4 – DjDT – Versions tab'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.04_B17243.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.4 – DjDT – Versions tab
  prefs: []
  type: TYPE_NORMAL
- en: Time
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Time** tab only displays the time it took to execute the current request.
    It doesn't actually open a new panel like the first two tabs. It's just a placeholder
    tab that displays useful information.
  prefs: []
  type: TYPE_NORMAL
- en: Settings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `settings.py` variables and their computed values. This is handy if you
    have methods calculating values, or if you are linking many different `settings.py`
    files together from other packages that override or change the values in your
    parent file, they can all be viewed from here. The following screenshot shows
    you what that looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.5 – DjDT – Settings tab'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.05_B17243.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.5 – DjDT – Settings tab
  prefs: []
  type: TYPE_NORMAL
- en: Headers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The **Headers** panel displays all of the information pertaining to your HTTP
    request and response headers. It also displays your WSGI or ASGI environment variables
    at the bottom of this panel. This can be very helpful when you are working with
    API endpoints and you need to make sure the information in your request and response
    headers is as what you would expect it to be. The following screenshot shows you
    what this looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.6 – DjDT – Headers tab'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.06_B17243.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.6 – DjDT – Headers tab
  prefs: []
  type: TYPE_NORMAL
- en: Request
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The **Request** panel shows you all of the data related to your request, such
    as keyword arguments and cookie and session data. This tab is very useful for
    checking to make sure this information is what it is expected to be. The following
    screenshot shows what this panel looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.7 – DjDT – Request tab'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.07_B17243.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.7 – DjDT – Request tab
  prefs: []
  type: TYPE_NORMAL
- en: SQL
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The **SQL** panel shows you a very detailed and broken-down look of what each
    query is doing, as well as showing you all of the queries involved in a particular
    request. For example, if you are visiting the home page while not logged into
    the Django admin site, the **SQL** tab will tell you there are zero queries, as
    depicted in *Figure 9.2*. However, if you are logged into the Django admin site
    and are visiting the home page, you should see at least two queries under the
    **SQL** tab. When you click on this tab, you will see what those two queries are,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.8 – DjDT – SQL tab'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.08_B17243.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.8 – DjDT – SQL tab
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we can see the first query establishes a session for the current request
    and then queries the object of the user logged into the system. That user object
    is a `Seller` model object because of how we extended the `User` model in [*Chapter
    3*](B17243_03_ePub.xhtml#_idTextAnchor077), *Models, Relations, and Inheritance*.
    Each query also has a **Sel** and **Expl** button, which provide other details
    about that query. Clicking the plus sign, found to the left of any one of these
    queries expands even more, giving you information about that query, including
    traceback information, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.9 – DjDT – SQL tab expanded'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.09_B17243.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.9 – DjDT – SQL tab expanded
  prefs: []
  type: TYPE_NORMAL
- en: Static files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The **Static files** panel displays all of the apps installed that actually
    contain static files. The middle section lists all of the static files related
    to the current request. You can actually click on them to open and view them in
    the current or a new tab. The last section in this panel displays a list of all
    of the static files found in all of the apps that are installed. This can sometimes
    be helpful if you are comparing a static file that overrides the same static file
    of another app, you can see which one is used and which ones are ignored. The
    following screenshot shows you what this panel looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.10 – DjDT – Static files tab'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.10_B17243.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.10 – DjDT – Static files tab
  prefs: []
  type: TYPE_NORMAL
- en: Here, we can see that the only static file being used on this page is the `home_page.jpg`
    file. Since the `index.html` file is not extending the `base_template_1.html`
    file, we don't have any CSS or JavaScript files used on this page; they do not
    get loaded. Should you activate the DjDT and go back to previous chapters, you
    will likely see those additional assets because we were using the `base_template_1.html`
    file. Any debug tools, such as CSS and JavaScript files related to the DjDT, will
    not be shown in the middle section. The idea is that those are debug-related assets
    and we don't need to know that on the page that we are debugging. Should you inspect
    a page using your browser tools, you will see assets related to the DjDT; they
    will not appear in production.
  prefs: []
  type: TYPE_NORMAL
- en: Templates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The **Templates** panel displays information related to the templates used
    and the context that is available. The middle section displays all of the templates.
    If you had partial HTML files using includes or extends, each one of those templates
    would appear in this list in the order that they are used. When you click on the
    **Toggle context** arrow, shown in the following screenshot, it will display a
    list of all of the context variables and their values related to that file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.11 – DjDT – Templates tab'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.11_B17243.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.11 – DjDT – Templates tab
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot depicts what clicking the **Toggle context** button
    looks like, showing us the context available in that particular template or partial
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.12 – DjDT – Templates tab showing context'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.12_B17243.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.12 – DjDT – Templates tab showing context
  prefs: []
  type: TYPE_NORMAL
- en: At the bottom of this panel is where all of the context processors are located.
    You can view the context available in each of the context processors available.
  prefs: []
  type: TYPE_NORMAL
- en: Cache
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Cache** panel displays all of the cached objects involved with this page.
    This is if you are using tools that help enhance the performance of your database.
    This is considered an advanced topic beyond the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The DjDT publisher also notes in their own documentation that this panel is
    incompatible with Django's per-site caching.
  prefs: []
  type: TYPE_NORMAL
- en: Signals
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Signals** panel displays the notifiers and receivers within an application
    that are communicating with each other. These can be closely compared to what
    **WebSocket** is. This is also considered an advanced topic beyond the scope of
    this book.
  prefs: []
  type: TYPE_NORMAL
- en: Logging
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `logging` library. Before showing how this panel looks, let's wire up an
    actual log to view. As with the Django messages framework, the logging system
    has different levels of messages. The default minimum log level is `WARNING` but
    you can show `DEBUG`- and `INFO`-level logs the same way, either by setting it
    in your `settings.py` file or by declaring it inline where your log is set, as
    we are going to do in the following steps. To learn more about all of the capabilities
    of using the logging system, visit [https://docs.djangoproject.com/en/4.0/topics/logging/](https://docs.djangoproject.com/en/4.0/topics/logging/)
    and [https://docs.python.org/3/library/logging.html](https://docs.python.org/3/library/logging.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Take the following steps to practice using the logging system:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In your `/chapter_4/views.py` file, add the following log statements at the
    beginning of the existing `practice_year_view()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The first two lines lower the logging level to show all `INFO`-level logs and
    higher, allowing us to use the `logger.info()` method to create the log message.
    Otherwise, the lowest level we could use by default would be the `logger.warning()`
    level method. The log message we are expecting to see should be `The Requested
    Year Is: 2022` when visiting the URL.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, navigate to [http://localhost:8000/my_year_path/2022/](http://localhost:8000/my_year_path/2022/)
    in your browser and expand the debug toolbar. Open the **Logging** tab and now
    you should see the log that we created, as depicted in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.13 – DjDT – Logging tab'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.13_B17243.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.13 – DjDT – Logging tab
  prefs: []
  type: TYPE_NORMAL
- en: Intercept redirects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Intercept redirects** checkbox is used to display an intermediary page
    whenever a redirect is performed to display information about that redirect, before
    the browser is updated with the redirected page.
  prefs: []
  type: TYPE_NORMAL
- en: Profiling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The **Profiling** checkbox enables the gathering of extra data on page load.
    It is a detailed analysis of memory and CPU processes taking place. Each process
    is broken down into the smallest measurements possible. By default, this checkbox
    is left unchecked. An example of what this looks like is shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.14 – DjDT – Profiling tab'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.14_B17243.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.14 – DjDT – Profiling tab
  prefs: []
  type: TYPE_NORMAL
- en: We now have a deeper understanding of all of the tabs available within the DjDT
    and what they are used for. This now adds a wealth of tools to our toolbox to
    help us make world-class applications with ease.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By now, we have developed a solid understanding of how automated testing in
    Django is performed. We wrote several test cases that test many of the exercises
    done in previous chapters. We practiced writing test cases that simulate success
    and others that deliberately trigger a failure to better understand what is happening.
    We even discovered how to write test cases that work with the Django REST framework.
    After we worked with automated testing, we then installed what I would consider
    the most powerful tool of them all, the DjDT. The DjDT is used for real-time debugging
    of developers' code as they write that code and run their projects locally.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to use the DjDT to monitor performance
    as we learn how to optimize database queries.
  prefs: []
  type: TYPE_NORMAL
