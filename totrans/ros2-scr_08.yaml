- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Services – Client/Server Interaction between Nodes
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务 – 节点之间的客户端/服务器交互
- en: 'Nodes can communicate with each other using one of three communication types.
    You discovered topics in the previous chapter. Now is the time to switch to the
    second most used communication: ROS 2 services.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 节点可以使用三种通信类型之一相互通信。你在上一章中发现了主题。现在是时候转向第二常用的通信方式：ROS 2服务。
- en: As we did for topics, we will first understand services with the help of a real-life
    analogy. I will also share more thoughts on when to use topics versus services.
    After that, you will dive into the code and write a service server and client
    inside nodes using custom service interfaces. You will also explore additional
    tools to handle services from the Terminal.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在主题部分所做的那样，我们将首先通过现实生活中的类比来理解服务。我还会分享更多关于何时使用主题与服务的思考。之后，你将深入代码，在节点中使用自定义服务接口编写服务服务器和客户端。你还将探索从终端处理服务的额外工具。
- en: All the code we’ll write in this chapter starts from the final code of the previous
    chapter. We will improve the number application to learn how to use services,
    and then work on the turtle controller application with an additional challenge.
    If you want to have the same starting point as me, you can download the code from
    GitHub ([https://github.com/PacktPublishing/ROS-2-from-Scratch](https://github.com/PacktPublishing/ROS-2-from-Scratch)),
    in the **ch5** folder, and use it as a starting point. The final code can be found
    in the **ch6** folder.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将编写的所有代码都从上一章的最终代码开始。我们将改进数字应用来学习如何使用服务，然后处理带有额外挑战的海龟控制器应用。如果你想和我有相同的起点，你可以从GitHub
    ([https://github.com/PacktPublishing/ROS-2-from-Scratch](https://github.com/PacktPublishing/ROS-2-from-Scratch))下载代码，在**ch5**文件夹中，并将其作为起点。最终代码可以在**ch6**文件夹中找到。
- en: By the end of this chapter, you will understand how services work, and you will
    be able to create your own service interfaces, service servers, and service clients.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将理解服务的工作原理，并且能够创建自己的服务接口、服务服务器和服务客户端。
- en: Becoming confident with topics and services is one of the most important things
    when starting with ROS 2\. With this, you will be able to write custom code for
    your projects and interact with most of the existing ROS 2 applications.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始使用ROS 2时，对主题和服务的信心是最重要的事情之一。有了这个，你将能够为你的项目编写自定义代码，并与大多数现有的ROS 2应用进行交互。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: What is a ROS 2 service?
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ROS 2服务是什么？
- en: Creating a custom service interface
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义服务接口
- en: Writing a service server
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写服务服务器
- en: Writing a service client
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写服务客户端
- en: Additional tools to handle services
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理服务的额外工具
- en: Service challenge – client and server
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务挑战 – 客户端和服务器
- en: What is a ROS 2 service?
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ROS 2服务是什么？
- en: You discovered the concept of ROS 2 services in [*Chapter 3*](B22403_03.xhtml#_idTextAnchor092),
    in the *Services* section, where you ran your first service server and client
    to get an intuition of how they work. You also became familiar with the **ros2**
    command-line tool for handling services from the Terminal.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你在[*第3章*](B22403_03.xhtml#_idTextAnchor092)的*服务*部分发现了ROS 2服务的概念，在那里你运行了第一个服务服务器和客户端，以获得它们如何工作的直观感受。你也熟悉了用于从终端处理服务的**ros2**命令行工具。
- en: From here, I will start from scratch again and explain what services are, using
    a real-life analogy. We will build an example, step by step, and then recap the
    most important points.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，我将从头开始再次解释服务是什么，使用现实生活中的类比。我们将逐步构建一个示例，然后总结最重要的要点。
- en: A server and a client
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务器和客户端
- en: To start, I will use an online weather service as an analogy.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我将使用在线天气服务作为类比。
- en: This online weather service can tell us the local weather after we send our
    location. To get the weather report for your city, you will need to interact with
    this service. You can use your computer to send a web request with the URL provided
    by the service.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们发送我们的位置后，这个在线天气服务可以告诉我们当地的天气。为了获取你所在城市的天气预报，你需要与这个服务进行交互。你可以使用你的电脑通过服务提供的URL发送一个网络请求。
- en: 'What’s going to happen? First, your computer will send a request to the weather
    service. The request contains your location. The service will receive the request,
    process it, and if the location is valid, it will return the weather for that
    location. Your computer then receives a response containing the weather information.
    That’s the end of the communication. Here’s an illustration of this process:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 会发生什么？首先，你的电脑将向天气服务发送一个请求。请求中包含你的位置。服务将接收请求，处理它，如果位置有效，它将返回该位置的天气。然后，你的电脑接收一个包含天气信息的响应。这就是通信的结束。以下是这个过程的说明：
- en: '![Figure 6.1 – Client/server interaction](img/B22403_06_1.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图6.1 – 客户端/服务器交互](img/B22403_06_1.jpg)'
- en: Figure 6.1 – Client/server interaction
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 – 客户端/服务器交互
- en: This is basically how a ROS 2 service works. On one side, you have a **service
    server** inside a node, and on the other side, you have a **service client** inside
    another node.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上就是ROS 2服务的工作方式。在一侧，你有一个节点内的**服务服务器**，在另一侧，你有一个节点内的**服务客户端**。
- en: To start the communication, the service **Client** needs to send a **request**
    to the **Server**. The **Server** will then process the request, do any appropriate
    actions or computations, and return a **response** to the **Client**.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始通信，服务**客户端**需要向**服务器**发送一个**请求**。然后，服务器将处理该请求，执行任何适当的操作或计算，并将**响应**返回给客户端。
- en: 'As you can see, a service, just like for topics, has a name and an interface.
    The interface is not just one message, it’s a pair of messages: a request and
    a response. Both the client and server must use the same name and interface to
    successfully communicate with each other.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，服务，就像对于主题一样，有一个名称和一个接口。接口不仅仅是一条消息，它是一对消息：请求和响应。客户端和服务器必须使用相同的名称和接口才能成功相互通信。
- en: With this example, the HTTP URL is the service name, and the pair (location,
    weather) is the service interface (request, response).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，HTTP URL是服务名称，而这对（位置，天气）是服务接口（请求，响应）。
- en: Multiple clients for one service
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个服务的多个客户端
- en: 'In real life, many people will try to get the weather from this online service
    (at different times or at the same time). That’s not a problem: each client will
    send a request with a location to the server through the HTTP URL. The server
    will process each request individually and return the appropriate weather information
    to each client.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实生活中，许多人将尝试从这个在线服务（在不同时间或同一时间）获取天气。这不是问题：每个客户端都会通过HTTP URL向服务器发送带有位置的请求。服务器将单独处理每个请求，并将适当的天气信息返回给每个客户端。
- en: 'Now, this is very important: there can be only one server. One URL only goes
    to one server, just like one physical mail address is unique. Imagine if you send
    a package to someone and there are two places with the same address. How can the
    mail delivery person know where to deliver the package?'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在非常重要的一点是：只能有一个服务器。一个URL只对应一个服务器，就像一个物理地址是唯一的。想象一下，如果你向某人发送包裹，有两个地方有相同的地址。邮递员怎么知道把包裹送到哪里？
- en: 'This will be the same for ROS 2 services. You can have several clients send
    a request to the same service. However, for one service, only one server can exist.
    See the following figure:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于ROS 2服务也是一样的。你可以让多个客户端向同一服务发送请求。然而，对于一项服务，只能存在一个服务器。参见以下图示：
- en: '![Figure 6.2 – Service server with multiple clients](img/B22403_06_2.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图6.2 – 具有多个客户端的服务服务器](img/B22403_06_2.jpg)'
- en: Figure 6.2 – Service server with multiple clients
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 – 具有多个客户端的服务服务器
- en: Here, you can see some boxes, each box representing a node. Thus, we have four
    nodes. Three nodes contain a service **Client** and talk to the **Weather service**
    node, which contains a service **Server**.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，你可以看到一些方框，每个方框代表一个节点。因此，我们有四个节点。三个节点包含一个服务**客户端**并与**天气服务**节点通信，该节点包含一个服务**服务器**。
- en: One thing to note here is that the clients don’t know exactly which node to
    communicate with. They must go through the URL (service name). In this example,
    the clients aren’t aware of the IP address of the server—they just know they have
    to use the URL to connect to the server.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的是，客户端不知道确切要通信的节点。他们必须通过URL（服务名称）进行通信。在这个例子中，客户端并不知道服务器的IP地址——他们只知道他们必须使用URL来连接到服务器。
- en: Also, no client is aware of the other clients. When you try to get the weather
    information from this service, you don’t know who is also trying to access the
    service, or even how many people are sending a request.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，没有任何客户端知道其他客户端的存在。当你尝试从这个服务获取天气信息时，你不知道谁也在尝试访问该服务，甚至不知道有多少人在发送请求。
- en: Another service example with robotics
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另一个与机器人相关的服务示例
- en: Let’s use another example that could be part of a ROS application.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再举一个可能是 ROS 应用程序一部分的例子。
- en: Imagine that you have a node responsible for controlling an LED panel (three
    LEDs). This node could contain a service server that allows other nodes to request
    turning an LED on or off.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个负责控制 LED 面板（三个 LED）的节点。这个节点可以包含一个服务服务器，允许其他节点请求打开或关闭 LED。
- en: You also have a node monitoring a battery. In your application, what you want
    to do is turn on one LED when the battery is low, and then turn it off when the
    battery is high again.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你还有一个监控电池的节点。在你的应用程序中，你想做的是当电池电量低时打开一个 LED，然后当电池电量再次变高时关闭它。
- en: You can do that using a ROS 2 service. The LED panel node would contain a service
    server named **set_led**. To send a request to this server, you must provide the
    LED number and the state of that LED (on or off). Then, you receive a response
    containing a boolean value to see if the request was successfully processed by
    the server.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 ROS 2 服务来实现这一点。LED 面板节点将包含一个名为 **set_led** 的服务服务器。要向该服务器发送请求，你必须提供 LED
    号码和该 LED 的状态（开启或关闭）。然后，你将收到一个包含布尔值的响应，以查看请求是否被服务器成功处理。
- en: 'So, the battery is now running low. Here’s what’s going to happen:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，电池现在电量不足。下面将要发生的事情：
- en: '![Figure 6.3 – Client asking to turn on LED number 3](img/B22403_06_3.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.3 – 客户端请求打开 LED 号码 3](img/B22403_06_3.jpg)'
- en: Figure 6.3 – Client asking to turn on LED number 3
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.3 – 客户端请求打开 LED 号码 3
- en: Here, **Battery node** will send a **Request** to the **set_led** service. The
    **Request** contains the **LED number 3** and **state on** details so that it
    can turn on LED **3** of the panel.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，**电池节点** 将向 **set_led** 服务发送一个 **请求**。**请求** 包含 **LED 号码 3** 和 **状态开启**
    的详细信息，以便它可以打开面板上的 LED **3**。
- en: The **Service** server, in the **LED panel node**, receives the **Request**.
    The server may decide to validate the **Request** (for example, if the LED number
    is 4, this is not valid) and process it. Processing the **Request** here means
    turning on the third LED. After that, the server sends a **Response** back to
    the **Client**, with a boolean flag. The **Client** receives this **Response**,
    and the communication ends.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **LED 面板节点** 中的 **服务** 服务器接收 **请求**。服务器可能会决定验证 **请求**（例如，如果 LED 号码是 4，则这不是有效的）并处理它。在这里处理
    **请求** 意味着打开第三个 LED。之后，服务器向 **客户端** 发送一个 **响应**，包含一个布尔标志。**客户端** 接收这个 **响应**，通信结束。
- en: 'Then, when the battery is fully charged, the **Battery node** sends another
    **Request** this time to turn off **LED 3**:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当电池完全充电时，**电池节点** 发送另一个 **请求**，这次是关闭 **LED 3**：
- en: '![Figure 6.4 – Client asking to turn off LED number 3](img/B22403_06_4.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.4 – 客户端请求关闭 LED 号码 3](img/B22403_06_4.jpg)'
- en: Figure 6.4 – Client asking to turn off LED number 3
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.4 – 客户端请求关闭 LED 号码 3
- en: The process is the same. The **Client** sends a **Request**, this time with
    **state off** for **LED 3**. The **Server**, inside the **LED panel node**, receives
    that **Request** and turns off the third LED. Then, the **Server** sends a **Response**
    back to the **Client**.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 过程相同。**客户端** 发送一个 **请求**，这次为 **LED 3** 的 **状态关闭**。位于 **LED 面板节点** 内部的 **服务器**
    接收这个 **请求** 并关闭第三个 LED。然后，**服务器** 向 **客户端** 发送一个 **响应**。
- en: Wrapping things up
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: On top of topics, ROS 2 nodes can use services to communicate with each other.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在主题之上，ROS 2 节点可以使用服务相互通信。
- en: When should you use topics versus services? You should use topics to publish
    unidirectional data streams and services when you want to have a client/server
    type of communication.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在何时使用主题而不是服务？你应该使用主题来发布单向数据流，当你想有客户端/服务器类型的通信时使用服务。
- en: For example, if you want to continuously send a velocity command to a robot
    10 times per second, or send the data you read from a sensor, you will use topics.
    If you want to have a node perform quick computations or do some actions on demand
    (enabling/disabling a motor, starting/stopping a robot), then you would use services.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你想每秒连续发送 10 次速度命令给机器人，或者发送从传感器读取的数据，你将使用主题。如果你想让节点执行快速计算或按需执行某些操作（启用/禁用电机，启动/停止机器人），那么你应该使用服务。
- en: It can be hard to give a definitive answer to that question. Each application
    is different. Most of the time, the choice will be obvious, but sometimes, you
    have to go one way only to realize that that was the wrong way. The more experience
    you get with ROS 2, the more you will be able to make the best design decisions.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 给出明确的答案可能会有点困难。每个应用程序都是不同的。大多数时候，选择将是显而易见的，但有时你必须走一条路才能意识到那是错误的方向。随着你对ROS 2经验的增加，你将能够做出更好的设计决策。
- en: 'Here are some important points about how services work:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些关于服务如何工作的重要点：
- en: A service is defined by a name and an interface.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务由名称和接口定义。
- en: The name of a service follows the same rules as for topics. It must start with
    a letter and can be followed by other letters, numbers, underscores, tildes, and
    slashes.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务的名称遵循与主题相同的规则。它必须以字母开头，后面可以跟其他字母、数字、下划线、波浪线和斜杠。
- en: 'The interface contains two things: a request and a response. Both the client
    and server must use the same interface to be able to communicate with each other.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口包含两个东西：一个请求和一个响应。客户端和服务器必须使用相同的接口才能相互通信。
- en: A service server can only exist once but can have multiple clients.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务服务器只能存在一次，但可以有多个客户端。
- en: Service clients are not aware of each other and are not aware of the server
    node. To reach the server, they just know that they must use the service name
    and provide the correct interface.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务客户端不知道彼此，也不知道服务器节点。为了到达服务器，他们只知道他们必须使用服务名称并提供正确的接口。
- en: One node can contain multiple service servers and clients, each with a different
    service name.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个节点可以包含多个服务服务器和客户端，每个服务名称不同。
- en: Now, how can you write a service client and server?
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你该如何编写服务客户端和服务器？
- en: Just as for nodes and topics, you will find everything you need in the **rclpy**
    and **rclcpp** libraries. With those libraries, you can write a service server
    and client inside nodes. That’s what we are going to do now.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 正如节点和主题一样，你将在**rclpy**和**rclcpp**库中找到你需要的一切。使用这些库，你可以在节点内编写服务服务器和客户端。这正是我们现在要做的。
- en: As we can’t test a client without a server, let’s start with the server side.
    But before we even start writing the server, what interface will we need to use
    for the service?
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 由于没有服务器就无法测试客户端，让我们先从服务器端开始。但在我们开始编写服务器之前，我们将需要使用什么接口来为服务？
- en: Creating a custom service interface
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义服务接口
- en: In [*Chapter 5*](B22403_05.xhtml#_idTextAnchor211), when we created the ROS
    2 application with the **number_publisher** and **number_counter** nodes, we used
    an existing interface for the **number** topic. Since we wanted to publish an
    integer number, the **example_interfaces/msg/Int64** interface seemed to be exactly
    what we needed. At this point, you know that you must avoid using the **example_interfaces**
    package for real applications, but for a first test, that wasn’t a problem.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第五章*](B22403_05.xhtml#_idTextAnchor211)中，当我们使用**number_publisher**和**number_counter**节点创建ROS
    2应用程序时，我们使用了现有的**number**主题接口。由于我们想要发布一个整数，因此**example_interfaces/msg/Int64**接口似乎正是我们所需要的。此时，你知道你必须避免在实际应用中使用**example_interfaces**包，但在第一次测试中，这并不是问题。
- en: We’re going to continue working on this application and add more functionalities
    so that we can practice with services. Here, we will focus on the **number_counter**
    node. For now now, in this node, every time we receive a message from the **number**
    topic, we’ll add this number to a counter and print the counter.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续在这个应用程序上工作并添加更多功能，以便我们可以练习使用服务。在这里，我们将重点关注**number_counter**节点。目前，在这个节点中，每次我们从**number**主题接收到消息时，我们将把这个数字加到计数器上并打印计数器。
- en: What we want to do is allow the **number_counter** node to reset the counter
    to a given number when we ask it to. For that, we will add a service server inside
    the node. Then, any other node can send a request, specifying the reset value
    for the counter. For example, let’s say the counter is currently at 76, and you
    send a request to reset it to 20\. If the request is accepted by the service server,
    the counter will now become 20 and continue to increment from that value.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要做的是允许**number_counter**节点在我们请求时将计数器重置为指定的数字。为此，我们将在节点内添加一个服务服务器。然后，任何其他节点都可以发送一个请求，指定计数器的重置值。例如，假设计数器当前为76，你发送一个请求将其重置为20。如果请求被服务服务器接受，计数器现在将变为20并从该值开始递增。
- en: Great—we know what we must do. Now, which interface should we use? Can we find
    an existing interface for what we need, or will we have to create a custom one?
    As per the title of this section, you can already guess the answer to that question.
    Nonetheless, let’s see what we could find if we were looking at existing interfaces.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了——我们知道我们必须做什么。现在，我们应该使用哪个接口？我们能找到一个现有的接口来满足我们的需求，还是我们必须创建一个自定义的接口？根据本节的标题，你大概已经猜到了答案。不过，让我们看看如果我们查看现有的接口，我们能找到什么。
- en: Finding an existing interface for our service
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为我们的服务寻找现有的接口
- en: 'When it comes to a service interface, we need to think about two things: the
    request and the response.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到服务接口时，我们需要考虑两件事：请求和响应。
- en: In our application, the request, which is sent from the client to the server,
    should contain an integer number. This is the reset value for the counter.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用中，从客户端发送到服务器的请求应该包含一个整数。这是计数器的重置值。
- en: For the response, which is sent from the server to the client, we can decide
    to use a boolean flag, to specify whether we were able to perform the request,
    and a message to explain what went wrong if something went wrong.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 对于从服务器发送到客户端的响应，我们可以决定使用一个布尔标志来指定我们是否能够执行请求，如果出了问题，还可以发送一条消息来解释发生了什么。
- en: 'The question is, will we find an existing interface that matches our needs?
    Unfortunately, this time, it seems that there is no matching interface. We can
    check the **example_interfaces** package:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，我们会找到一个与我们的需求相匹配的现有接口吗？不幸的是，这次似乎没有匹配的接口。我们可以检查**example_interfaces**包：
- en: '[PRE0]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can even check the **std_srvs** package:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以检查**std_srvs**包：
- en: '[PRE1]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: As you can see, service interfaces are placed inside a `srv` folder, inside
    the package. For topics, we had a `msg` folder. This is a good way to differentiate
    both types of interfaces easily.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，服务接口被放置在包内的`srv`文件夹中。对于主题，我们有一个`msg`文件夹。这是一种很容易区分两种接口类型的好方法。
- en: 'If you look more closely at those interfaces, especially **SetBool** and **Trigger**,
    you’ll see that there is no way to send an integer number in the request. Here’s
    an example where we’re trying to use **SetBool**:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更仔细地查看这些接口，特别是**SetBool**和**Trigger**，你会发现没有办法在请求中发送一个整数。这里有一个我们尝试使用**SetBool**的例子：
- en: '[PRE2]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When looking at the interface definition, you can see that the request and response
    are separated by three dashes (**---**). In the response, we can find a boolean
    and a string, which is what we want. However, the request only contains a boolean,
    not an integer.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当查看接口定义时，你可以看到请求和响应由三个短横线（**---**）分隔。在响应中，我们可以找到一个布尔值和一个字符串，这是我们想要的。然而，请求只包含一个布尔值，没有整数。
- en: You could have a look at other interfaces in the common interfaces GitHub repository
    ([https://github.com/ros2/common_interfaces](https://github.com/ros2/common_interfaces))
    but you won’t find exactly what we are looking for.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以查看GitHub上常见的接口仓库中的其他接口（[https://github.com/ros2/common_interfaces](https://github.com/ros2/common_interfaces)），但你不会找到我们正在寻找的精确匹配。
- en: Thus, we will create our own service interface before writing the code for the
    service. For the **number** topic, we were lucky enough to find an interface that
    we could directly use in the code (even though for real applications, the best
    practice is to avoid using **example_interfaces** and **std_srvs** anyway). Here,
    we need to create the interface first.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在为服务编写代码之前，我们将创建我们自己的服务接口。对于**number**主题，我们足够幸运，找到了一个可以直接在代码中使用的接口（尽管对于实际应用，最佳实践是尽量避免使用**example_interfaces**和**std_srvs**）。在这里，我们首先需要创建接口。
- en: Creating a new service interface
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个新的服务接口
- en: To create a service interface, just like for a topic interface, you need to
    create and configure a package dedicated to interfaces.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建服务接口，就像为主题接口一样，你需要创建并配置一个专门用于接口的包。
- en: 'Good news: we did that in [*Chapter 5*](B22403_05.xhtml#_idTextAnchor211) in
    the *Creating a custom interface for a topic* section. Since we’re working on
    the same application, we will put all the topic and service interfaces in the
    same package: **my_robot_interfaces** (if you don’t already have this package,
    go back to the previous chapter and set it up).'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息：我们在[*第五章*](B22403_05.xhtml#_idTextAnchor211)的*为主题创建自定义接口*部分已经做了这件事。由于我们正在处理同一个应用，我们将所有主题和服务接口放在同一个包中：**my_robot_interfaces**（如果你还没有这个包，请回到上一章并设置它）。
- en: We can create a new service interface inside that package directly; there’s
    nothing else to do. So, the process will be quite quick.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以直接在那个包内部创建一个新的服务接口；没有其他事情要做。所以，这个过程将会非常快。
- en: 'First, navigate inside the **my_robot_interfaces** package (where you already
    have a **msg** folder) and create a new **srv** folder:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，导航到**my_robot_interfaces**包内部（你已经有了一个**msg**文件夹）并创建一个新的**srv**文件夹：
- en: '[PRE3]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this new folder, you will put all the service interfaces that are specific
    to your application (or robot).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个新文件夹中，你需要放置所有特定于你的应用程序（或机器人）的服务接口。
- en: 'Now, create a new file for a service. Here are the rules to follow regarding
    the filename:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为服务创建一个新文件。以下是关于文件名的规则：
- en: Use UpperCamelCase (PascalCase)—for example, `ActivateMotor`.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用UpperCamelCase（PascalCase）——例如，`ActivateMotor`。
- en: Don’t write `Srv` or `Interface` in the name as this would add unnecessary redundancy.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要在名称中写`Srv`或`Interface`，因为这会添加不必要的冗余。
- en: Use `.srv` for the file extension.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`.srv`作为文件扩展名。
- en: As a best practice, use a verb in the interface name—for example, `TriggerSomething`,
    `ActivateMotor`, or `ComputeDistance`. Services are about doing an action or computation,
    so by using a verb, you make it very clear what the service is doing.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为最佳实践，在接口名称中使用一个动词——例如，`TriggerSomething`，`ActivateMotor`或`ComputeDistance`。服务是关于执行一个动作或计算，所以通过使用动词，你可以非常清楚地知道服务正在做什么。
- en: 'Since we want to reset the counter, let’s simply call the interface **ResetCounter**:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们想要重置计数器，所以我们可以简单地称这个接口为**ResetCounter**：
- en: '[PRE4]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Open this file and write the definition for the service interface. One very
    important thing to do here is add three dashes (**---**) and put the request definition
    on top, and then the response definition below the dashes.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 打开这个文件并编写服务接口的定义。在这里要做的一件非常重要的事情是添加三个短横线（**---**），并将请求定义放在顶部，然后响应定义放在短横线下方。
- en: 'For the request and response, you can use the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 对于请求和响应，你可以使用以下内容：
- en: Built-in types (`bool`, `byte`, `int64`, and so on).
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置类型（`bool`，`byte`，`int64`等等）。
- en: Existing message interfaces. For example, the request of the service could contain
    `geometry_msgs/Twist`.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现有的消息接口。例如，服务的请求可以包含`geometry_msgs/Twist`。
- en: Note
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can’t include a service definition inside another service definition. You
    can only include a message (topic definition) inside the request or the response
    of the service. The request and response can be seen as two independent messages.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能在另一个服务定义中包含服务定义。你只能在服务的请求或响应中包含一个消息（主题定义）。请求和响应可以被视为两个独立的消息。
- en: 'Let’s write our service interface. As it’s not too complex, we can use simple
    built-in types:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写我们的服务接口。由于它并不复杂，我们可以使用简单的内置类型：
- en: '[PRE5]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: With this, the client will send a request with one integer value, and the response
    will contain a boolean flag as well as a string. All the fields inside the definition
    must follow the snake_case convention (use underscores between words, all letters
    lowercase, and no space).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，客户端将发送一个包含一个整数值的请求，响应将包含一个布尔标志以及一个字符串。定义内部的所有字段都必须遵循snake_case约定（单词之间使用下划线，所有字母小写，没有空格）。
- en: Note
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Make sure you always have three dashes in all your service definitions, even
    if the request or the response is empty.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你所有的服务定义中都有三个短横线，即使请求或响应为空。
- en: Now that we’ve written our interface, we need to build it so that we can use
    it in our code.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经编写了接口，我们需要构建它，以便我们可以在代码中使用它。
- en: 'Go back to the **CMakeLists.txt** of **my_robot_interfaces** package. Since
    the package has already been configured, we just need to add one line. Add the
    relative path to the interface on a new line inside the **rosidl_generate_interfaces()**
    function. Don’t use any commas between the lines:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到**my_robot_interfaces**包的**CMakeLists.txt**。由于包已经配置好了，我们只需要添加一行。在**rosidl_generate_interfaces()**函数中添加接口的相对路径，并在新行中添加：
- en: '[PRE6]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'After this, save all files and build the **my_robot_interfaces** package:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，保存所有文件并构建**my_robot_interfaces**包：
- en: '[PRE7]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Once built, source the environment. You should be able to find your new interface:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦构建，源环境。你应该能够找到你的新接口：
- en: '[PRE8]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If you see that, you know that the service interface has been built successfully,
    and you can use it in your code. So, let’s do that and write a service server.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到这个，你就知道服务接口已经成功构建，你可以在你的代码中使用它。所以，让我们来做这件事，写一个服务服务器。
- en: Writing a service server
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写服务服务器
- en: You will now write your first service server. As mentioned previously, we will
    continue with the number application we started in the previous chapter. What
    we want to do here is allow **number_counter** to reset the counter to a given
    number when we ask it to do so. This is a perfect example of when to use a service.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将编写你的第一个服务服务器。如前所述，我们将继续使用上一章开始的数量应用程序。我们在这里想要做的是允许 **number_counter** 在我们要求它这样做时将计数器重置到指定的数字。这是一个使用服务的完美例子。
- en: The first thing to think about when creating a new service is what service interface
    you need. We’ve just done that, so we can now focus on the code.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新的服务时首先要考虑的是你需要什么服务接口。我们已经做到了这一点，所以现在我们可以专注于代码。
- en: To write a service server, you will need to import the interface and then create
    a new service in the node’s constructor. You will also need to add a callback
    to be able to process the request, do the required action or computation, and
    return a response to the client.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写服务服务器，你需要导入接口，然后在节点的构造函数中创建一个新的服务。你还需要添加一个回调函数，以便能够处理请求，执行所需的操作或计算，并向客户端返回响应。
- en: As always, let’s start with a fully detailed explanation with Python, after
    which we will see how to do the same with C++.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，让我们先用 Python 进行详细解释，然后我们将看到如何用 C++ 完成同样的操作。
- en: Writing a Python service server
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写 Python 服务服务器
- en: To write a Python service server, we first need to have a Python node. We won’t
    create a new node here since we’re adding functionality to an existing one (**number_counter**).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写 Python 服务服务器，我们首先需要一个 Python 节点。由于我们正在向现有的节点（**number_counter**）添加功能，所以这里不会创建一个新的节点。
- en: Note
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can have any number of publishers, subscribers, and services inside a node.
    So long as you keep things clean, that will not be a problem.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在一个节点内部拥有任意数量的发布者、订阅者和服务。只要保持整洁，这不会成为问题。
- en: Let’s get started. As always, you can find the complete code in this book’s
    GitHub repository. I will not display the full code for the node here, just the
    new lines that are required for the service we are adding.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。像往常一样，你可以在本书的 GitHub 仓库中找到完整的代码。在这里，我不会展示节点的完整代码，只展示添加服务所需的新行。
- en: Importing a service interface
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 导入服务接口
- en: The first big part of creating a service is to find an existing interface or
    create a new one. That’s what we just did, so let’s use the **ResetCounter** interface
    from the **my_robot_interfaces** package.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 创建服务的第一个重要部分是找到一个现有的接口或创建一个新的接口。这正是我们刚才做的，所以让我们使用 **my_robot_interfaces** 包中的
    **ResetCounter** 接口。
- en: 'First, we need to add the dependency to this interface package inside the package
    where we write the node with the service. Open the **package.xml** file from **my_py_pkg**
    and add the new dependency:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要将依赖项添加到我们编写带有服务的节点的包内部。打开 **my_py_pkg** 中的 **package.xml** 文件并添加新的依赖项：
- en: '[PRE9]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This will ensure that the interfaces package is installed when you build the
    **my_py_pkg** package with **colcon**. Now, import the dependency into your code
    (**number_counter.py**):'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保在用 **colcon** 构建包含 **my_py_pkg** 包时安装接口包。现在，将依赖项导入到你的代码中（**number_counter.py**）：
- en: '[PRE10]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: To import a service, we must specify the package name (**my_robot_interfaces**),
    followed by the folder name for services (**srv**), and finally the class for
    the interface (**ResetCounter**).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要导入服务，我们必须指定包名（**my_robot_interfaces**），然后是服务文件夹的名称（**srv**），最后是接口的类（**ResetCounter**）。
- en: Note
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: I’ve already mentioned this, but if you’re using VS Code and auto-completion
    doesn’t work, or the service isn’t recognized (import error), follow the process
    below.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经提到过这一点，但如果你使用 VS Code 并且自动完成不起作用，或者服务没有被识别（导入错误），请按照以下过程操作。
- en: 'Close VS code. Then, open a new Terminal, make sure the environment is correctly
    sourced, and find the interface (`ros2 interface show <interface_name>`). After,
    navigate to the `src` directory of the ROS 2 workspace and open VS Code with:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭 VS code。然后，打开一个新的终端，确保环境已正确设置，并找到接口（`ros2 interface show <interface_name>`）。之后，导航到
    ROS 2 工作空间的 `src` 目录，并使用以下命令打开 VS Code：
- en: '**$** **code .**'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**$** **code .**'
- en: Adding a service server to the node
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将服务服务器添加到节点
- en: Now that you’ve correctly imported the service interface, you can create the
    service server.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经正确地导入了服务接口，你可以创建服务服务器。
- en: As you did for publishers and subscribers, you will add your service servers
    to the node’s constructor.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 就像为发布者和订阅者做的那样，你将在节点的构造函数中添加你的服务服务器。
- en: 'Here’s the constructor of the **NumberCounterNode** class, which contains the
    previously created subscriber and the new service server:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这是**NumberCounterNode**类的构造函数，其中包含之前创建的订阅者和新的服务服务器：
- en: '[PRE11]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We add the service server at the same time as the number subscriber and just
    before the ending log.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在添加用户数量和结束日志之前同时添加服务服务器。
- en: 'To create the service server, we use the **create_service()** method from the
    **Node** class. Once again, you can see that by inheriting from this class, we
    get access to all ROS 2 functionalities easily. In this method, you must provide
    three arguments:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建服务服务器，我们使用**Node**类的**create_service()**方法。再次说明，通过从该类继承，我们可以轻松地访问所有ROS 2功能。在这个方法中，你必须提供三个参数：
- en: '`ResetCounter` class we have imported.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们导入的`ResetCounter`类。
- en: '`reset_counter`.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reset_counter`。'
- en: '**Service callback**: The service server, as its name suggests, is a server.
    This means that it won’t do anything by itself. You will need to have a client
    send a request so that the server does something. So, while the node is spinning,
    the server will be in “waiting mode.” Upon reception of a request, the service
    callback will be triggered, and the request will be passed to this callback.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务回调**：正如其名称所暗示的，服务服务器是一个服务器。这意味着它不会自己执行任何操作。你需要有一个客户端发送请求，以便服务器执行某些操作。因此，当节点正在旋转时，服务器将处于“等待模式”。在接收到请求后，服务回调将被触发，并将请求传递给这个回调。'
- en: 'Now, we need to implement this callback. First, let’s write a minimal code
    example:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要实现这个回调。首先，让我们写一个最小化的代码示例：
- en: '[PRE12]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In a service callback, we receive two things: an object for the request and
    an object for the response. The request object contains all the data sent by the
    client. The response object is empty, and we will need to fill it, as well as
    return it.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务回调中，我们接收两个东西：一个是请求的对象，另一个是响应的对象。请求对象包含客户端发送的所有数据。响应对象为空，我们需要填充它以及返回它。
- en: To name the callback, I usually write **callback_** followed by the service
    name. This makes it easier to recognize in the code and will prevent future mistakes
    as you want to make sure you don’t call this method directly. It should only be
    called while the node is spinning and when a client sends a request from another
    node.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 为了命名回调，我通常会在服务名称前写上**callback_**。这样做使得在代码中更容易识别，并且可以防止未来犯错误，因为你想要确保不要直接调用这个方法。它应该只在节点正在旋转并且客户端从另一个节点发送请求时调用。
- en: Note
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In the method’s arguments, I have also specified the type for the two arguments.
    This way, we make the code more robust, and we can use auto-completion features
    from IDEs such as VS Code.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法参数中，我还指定了两个参数的类型。这样，我们使代码更加健壮，并且可以使用IDE（如VS Code）的自动完成功能。
- en: 'When you create an interface for a topic, you only get one class for that interface
    (for example, `Int64`). As you can see, in a service, we get two classes: one
    for the request (`Interface.Request`) and one for the response (`Interface.Response`).'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当你为话题创建接口时，你只会得到一个该接口的类（例如，`Int64`）。正如你所看到的，在服务中，我们得到两个类：一个用于请求（`Interface.Request`）和一个用于响应（`Interface.Response`）。
- en: In this callback, we get **reset_value** from the request and modify the **counter_**
    variable accordingly. Then, we fill the success and message fields from the response
    and return the response.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个回调中，我们从请求中获取**reset_value**并根据需要修改**counter_**变量。然后，我们从响应中填充成功和消息字段并返回响应。
- en: This is a very minimal piece of code for a service server. In real life, you’ll
    probably want to check if the request is valid before you use the values from
    it. For example, if you have a service that will modify the maximum velocity of
    a mobile robot, you might want to be sure the value you receive is not too high,
    to prevent the robot from becoming uncontrolled and damaging itself or the environment.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的服务服务器代码片段。在现实生活中，你可能想在使用请求中的值之前检查请求是否有效。例如，如果你有一个将修改移动机器人的最大速度的服务，你可能想确保你收到的值不是太高，以防止机器人失控并损坏自己或环境。
- en: Let’s improve the callback so that we can validate **reset_value** before we
    modify the **counter_** variable.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们改进回调，以便在修改**counter_**变量之前验证**reset_value**。
- en: Validating the request
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 验证请求
- en: 'Let’s say we want to add those two validation rules: the reset value must be
    a positive number, and it cannot be higher than the current counter value.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要添加这两个验证规则：重置值必须是一个正数，并且不能高于当前计数器的值。
- en: 'Modify the code in the **callback_reset_counter** method, like so:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 修改**callback_reset_counter**方法中的代码，如下所示：
- en: '[PRE13]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: First, we check if the value is negative. If so, we don’t do anything with the
    **counter_** variable. We set the boolean flag to **False** and provide an appropriate
    error message.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检查值是否为负。如果是，我们不对**counter_**变量做任何操作。我们将布尔标志设置为**False**，并提供适当的错误信息。
- en: Then, we check if the value is greater than the current **counter_** value.
    If that’s the case, we do the same thing as before, with a different error message.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们检查值是否大于当前的**counter_**值。如果是这样，我们就像之前一样做，但错误信息不同。
- en: Finally, if none of those conditions are true (which means we’ve validated the
    request), then we process the request and modify the **counter_** variable.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果这些条件都不成立（这意味着我们已经验证了请求），那么我们处理请求并修改**counter_**变量。
- en: 'Here’s a recap of the steps for a service server callback:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是服务服务器回调步骤的回顾：
- en: (Optional but recommended) Validate the request, or validate that external conditions
    are met for the callback to be processed. For example, if the service is about
    activating a motor, but the communication with the motor hasn’t been started yet,
    then you can’t activate the motor.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: （可选但推荐）验证请求，或者验证回调处理所需的外部条件是否满足。例如，如果服务是激活电机，但与电机的通信尚未开始，那么你无法激活电机。
- en: Process the action or computation using the data from the request if needed.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要，使用请求中的数据处理动作或计算。
- en: Fill in the appropriate field for the response. It’s not mandatory to fill in
    all the fields. If you omit some of them, default values will be used (`0` for
    numbers and `""` for strings).
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填写响应的适当字段。不是必须填写所有字段。如果你省略了一些，将使用默认值（数字为`0`，字符串为`""`）。
- en: Return the response. This is quite an important step that many people forget
    at the beginning. If you don’t return the response, you will get an error at runtime.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回响应。这是一个非常重要的一步，很多人在开始时都会忘记。如果你不返回响应，你将在运行时遇到错误。
- en: All you must do now is build your package where the node is, source, and run
    the node.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在必须做的就是构建包含节点的包，source，并运行节点。
- en: 'When you run the **number_counter** node, you’ll see the following:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行**number_counter**节点时，你会看到以下内容：
- en: '[PRE14]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The service server has been started within the node, but of course, nothing
    will happen as you need to send a request from a client to try the server.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 服务服务器已经在节点内部启动，但当然，除非你从客户端发送请求来尝试服务器，否则什么都不会发生。
- en: That’s what we will do in a minute, but before that, let’s learn how to write
    the service server in C++. If you don’t want to learn ROS 2 with C++ for now,
    you can skip this and go to the next section in this chapter.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一分钟做这件事，但在那之前，让我们学习如何编写C++中的服务服务器。如果你现在不想用C++学习ROS 2，你可以跳过这部分，直接进入本章的下一节。
- en: Writing a C++ service server
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写C++服务服务器
- en: 'Let’s add a service server inside our C++ **number_counter** node using the
    same name and interface that we used for the one we created with Python. The process
    is the same: import the interface, create a service server, and add a callback
    function.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的C++ **number_counter**节点内部添加一个服务服务器，使用与Python创建的那个相同的名称和接口。过程是相同的：导入接口，创建服务服务器，并添加回调函数。
- en: As mentioned previously in this book, make sure you follow all C++ explanations
    while keeping the GitHub code open on the side.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如本书之前所述，确保在GitHub代码旁边打开的情况下，遵循所有C++解释。
- en: Importing a service interface
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 导入服务接口
- en: 'First, since we’ll have a dependency on **my_robot_interfaces**, open the **package.xml**
    file of the **my****_cpp_pkg** package and add the following one line:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，由于我们将依赖于**my_robot_interfaces**，请打开**my****_cpp_pkg**包的**package.xml**文件，并添加以下一行：
- en: '[PRE15]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, open the **number_counter.cpp** file and include the **ResetCounter**
    interface:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，打开**number_counter.cpp**文件并包含**ResetCounter**接口：
- en: '[PRE16]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: To import a service interface in C++, you must use **#****include "<package_name>/srv/<service_name>.hpp"**.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 要在C++中导入服务接口，你必须使用**#****include "<package_name>/srv/<service_name>.hpp"**。
- en: Note
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'As a reminder, for this `include` to be recognized by VS Code, make sure you
    add the following to the `c_cpp_properties.json` file, in the `.vscode` folder
    that was generated when you opened VS Code: `"/home/<user>/ros2_ws/install/my_robot_interfaces/include/**"`.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提醒，为了使VS Code能够识别这个`include`，请确保你将以下内容添加到`.vscode`文件夹中，该文件夹是在你打开VS Code时生成的`c_cpp_properties.json`文件中：`"/home/<user>/ros2_ws/install/my_robot_interfaces/include/**"`。
- en: 'After this, I added an extra line with the **using** keyword so that we can
    just write **ResetCounter** in the code, instead of **my_robot_interfaces::srv::ResetCounter**:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我添加了一条额外的行，使用了**using**关键字，这样我们就可以在代码中直接写**ResetCounter**，而不是**my_robot_interfaces::srv::ResetCounter**：
- en: '[PRE17]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This will help us make the code more readable. With C++, you can quickly end
    up with very long types that almost take more than one line to write. Since we
    will need to use the service interface quite often, adding this **using** line
    is a best practice to keep things simple.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这将帮助我们使代码更易于阅读。使用C++，你很快就会得到非常长的类型，几乎需要多行来编写。由于我们经常需要使用服务接口，添加这条**using**行是一个最佳实践，以保持事情简单。
- en: I didn’t do it previously with **example_interfaces::msg::Int64** when we worked
    on topics, but if you want, you can also write **using Int64 = example_interfaces::msg::Int64;**
    and then reduce the code for the subscriber.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我在之前处理主题时没有用**example_interfaces::msg::Int64**做这件事，但如果你想，你也可以写**using Int64
    = example_interfaces::msg::Int64;**然后减少订阅者的代码。
- en: Adding a service server to the node
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将服务服务器添加到节点
- en: 'Now that we’ve included the interface, let’s create the service server. We
    will store it as a private attribute in the class:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经包含了接口，让我们创建服务服务器。我们将将其存储为类中的私有属性：
- en: '[PRE18]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see, we use the **rclcpp::Service** class, and then, as always, we
    make it a shared pointer with **::SharedPtr**.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们使用了**rclcpp::Service**类，然后，一如既往地，我们使用**::SharedPtr**将其转换为共享指针。
- en: 'Now, we can initialize the service in the constructor:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在构造函数中初始化服务：
- en: '[PRE19]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: To create the service, we must use the **create_service()** method from the
    **rclcpp::Node** class. As for Python, we need to provide the service interface,
    the service name, and a callback to process the incoming requests. For **_1**
    and **_2** to work, don’t forget to add **using namespace** **std::placeholders;**
    beforehand.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建服务，我们必须使用**rclcpp::Node**类的**create_service()**方法。对于Python，我们需要提供服务接口、服务名称以及处理传入请求的回调。为了使**_1**和**_2**工作，别忘了事先添加**using
    namespace** **std::placeholders;**。
- en: 'Here’s the callback method, including the code to validate the request:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是回调方法，包括验证请求的代码：
- en: '[PRE20]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the callback, we receive two arguments—the request and the response. Both
    are **const** shared pointers.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在回调中，我们接收两个参数——请求和响应。两者都是**const**共享指针。
- en: What we do in this callback is the same as for Python. The biggest difference
    here is that we don’t return anything (in Python, we had to return the response)
    as the return type for the callback is **void**.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个回调中我们做的事情与Python相同。这里最大的不同之处在于我们不需要返回任何东西（在Python中，我们必须返回响应），因为回调的返回类型是**void**。
- en: Now, we can build the package to compile and install the node. However, before
    we run **colcon build**, we have to modify the **CMakeLists.txt** file of the
    **my_cpp_pkg** package. Since we have a new dependency on **my_robot_interfaces**,
    we need to link the **number_counter** executable with that dependency.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以构建包以编译和安装节点。然而，在我们运行**colcon build**之前，我们必须修改**my_cpp_pkg**包的**CMakeLists.txt**文件。由于我们对**my_robot_interfaces**有新的依赖，我们需要将**number_counter**可执行文件与该依赖项链接。
- en: 'First, add a line under all the **find_package()** lines:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在所有**find_package()**行下面添加一行：
- en: '[PRE21]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then, add **my_robot_interfaces** to the **ament_target_dependencies()** function,
    for the **number_counter** executable:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将**my_robot_interfaces**添加到**ament_target_dependencies()**函数中，用于**number_counter**可执行文件：
- en: '[PRE22]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: For every new dependency you’re using in this executable, you will have to link
    to it before you build.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 对于你在本可执行文件中使用的每个新依赖项，你必须在构建之前将其链接。
- en: 'If you forget about this, then you will get this kind of error when you run
    **colcon build**:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你忘记了这一点，那么当你运行**colcon build**时，你会得到这种错误：
- en: '[PRE23]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now you can build the C++ package, source, and run the **number_counter** node.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以构建C++包、源代码并运行**number_counter**节点。
- en: '[PRE24]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We are now at the same point as when we finished the Python service server.
    The next step is to try the service server. To do that, we need a service client.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在处于与完成Python服务服务器相同的点。下一步是尝试服务服务器。为了做到这一点，我们需要一个服务客户端。
- en: Writing a service client
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写服务客户端
- en: For service communication to work, you need a service server and a service client.
    As a reminder, you can only have one service server but multiple clients.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使服务通信工作，你需要一个服务服务器和一个服务客户端。作为提醒，你只能有一个服务服务器，但可以有多个客户端。
- en: So far, we’ve finished our service server inside the **number_counter** node.
    Now, let’s create a service client inside another node so that you can try the
    service.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经在**number_counter**节点内部完成了我们的服务服务器。现在，让我们在另一个节点内部创建一个服务客户端，以便您可以尝试该服务。
- en: Where will you write the code for the client? In a real application, you will
    create a service client in a node that needs to call the service. In terms of
    the battery and LED example from the beginning of this chapter, the LED panel
    node contains a service server. The battery node, which is responsible for monitoring
    the battery state, contains a service client that can send some requests to the
    server.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在哪里编写客户端的代码？在实际应用中，您将在需要调用服务的节点中创建服务客户端。就本章开头提到的电池和LED示例而言，LED面板节点包含服务服务器。负责监控电池状态的电池节点包含一个服务客户端，可以向服务器发送一些请求。
- en: Then, when to send a request depends on the application. With the previous example,
    we decided that when the battery gets full or empty, we use the service client
    inside the node to send a request to the server so that we can turn an LED on/off.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，何时发送请求取决于应用。在先前的例子中，我们决定当电池充满或放空时，我们使用节点内的服务客户端向服务器发送请求，以便我们可以打开/关闭LED。
- en: 'To keep things simple for now, we will create a new node named **reset_counter_client**.
    This node will only do one thing: send a request to the service server and get
    the response. With this, we will be able to focus only on writing the service
    client. As usual, we’ll start with Python and then see the C++ code as well.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 为了现在使事情简单，我们将创建一个名为**reset_counter_client**的新节点。此节点只会做一件事：向服务服务器发送请求并获取响应。有了这个，我们就可以只专注于编写服务客户端。像往常一样，我们首先从Python开始，然后查看C++代码。
- en: Writing a Python service client
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写Python服务客户端
- en: Create a new file, named **reset_counter_client.py**, inside the **my_py_pkg**
    package. Make this file executable. The file should be placed with all the other
    Python files you created previously.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在**my_py_pkg**包内部创建一个名为**reset_counter_client.py**的新文件。使此文件可执行。该文件应放置在与您之前创建的所有其他Python文件相同的目录中。
- en: 'Open the file and start by importing the interface:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 打开文件，首先导入接口：
- en: '[PRE25]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the node’s constructor, create a service client:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在节点的构造函数中创建一个服务客户端：
- en: '[PRE26]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: To create a service client, we use the **create_client()** method from the **Node**
    class. We need to provide the service interface and service name. Make sure you
    use the same name and interface you defined in the server.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建服务客户端，我们使用**Node**类的**create_client()**方法。我们需要提供服务接口和服务名称。确保您使用与服务器中定义的相同名称和接口。
- en: 'Then, to call the service, we create a new method:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为了调用服务，我们创建一个新的方法：
- en: '[PRE27]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Here are the steps to make a service call:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 制作服务调用的步骤如下：
- en: Make sure the service is up and running with `wait_for_service()`. This function
    will return `True` as soon as the service has been found, or return `False` after
    the provided timeout, which is `1.0` seconds here.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保服务正在运行，使用`wait_for_service()`。此函数将在找到服务后立即返回`True`，或者在提供的超时后返回`False`，这里为`1.0`秒。
- en: Create a request object from the service interface.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从服务接口创建一个请求对象。
- en: Fill in the request fields.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填写请求字段。
- en: Send the request with `call_async()`. This will give you a Python `Future` object.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`call_async()`发送请求。这将给您一个Python `Future`对象。
- en: Register a callback for when the node receives the response from the server.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为节点收到服务器响应时注册回调。
- en: 'To process the response from the service, add a callback method:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理服务响应，添加一个回调方法：
- en: '[PRE28]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the callback, we get the response with **future.result()**, and we can access
    each field of the response. In this example, we simply print the response with
    a log.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在回调中，我们使用**future.result()**获取响应，并且可以访问响应的每个字段。在这个例子中，我们简单地使用日志打印响应。
- en: So, what’s going to happen? After you send the request with **call_async()**,
    the server will receive and process the request. Upon completion of the task,
    the server will return a response to the node where the client is. When the client
    node receives the response, it will process it in the callback that you’ve written.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，会发生什么？在您使用**call_async()**发送请求后，服务器将接收并处理请求。任务完成后，服务器将向客户端所在的节点返回响应。当客户端节点收到响应时，它将在您编写的回调中处理它。
- en: Note
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You might be wondering, why do we need a callback? Why can’t we just wait for
    the response in the same method where we send the request? That’s because if you
    block this method (or in other words, this thread), then the node won’t be able
    to spin. If the spin is blocked, then any response you get for this node won’t
    be processed, and you have what is called a deadlock.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想知道，为什么我们需要回调？为什么我们不能只在发送请求的同一种方法中等待响应？这是因为如果您阻塞此方法（换句话说，这个线程），那么节点将无法旋转。如果旋转被阻塞，那么您为此节点收到的任何响应都不会被处理，这就是所谓的死锁。
- en: 'The only thing left to do is call the **call_reset_counter()** method. If we
    don’t call it, nothing will happen. In a real application, you would call this
    method whenever you need it (it could be from a timer callback, a subscriber callback,
    and so on). Here, to make a test, we just call the method after creating the node,
    and before spinning, in the **main()** function:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的唯一事情就是调用**call_reset_counter()**方法。如果我们不调用它，什么都不会发生。在实际应用中，您会在需要时调用此方法（它可能来自计时器回调、订阅者回调等）。在这里，为了进行测试，我们只是在创建节点后、旋转前在**main()**函数中调用该方法：
- en: '[PRE29]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The service client will send a request and register a callback for the response.
    After that, the **call_reset_counter()** method exits, and the node starts to
    spin.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 服务客户端将发送一个请求并为响应注册一个回调。之后，**call_reset_counter()**方法退出，节点开始旋转。
- en: That’s it for the code. You can use this structure for the client (one method
    to send the request and one callback to process the response) in any other node.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 代码部分到此结束。您可以将此结构用于任何其他节点中的客户端（一个用于发送请求的方法和一个用于处理响应的回调）。
- en: Now, let’s test the client/server communication.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们测试客户端/服务器通信。
- en: Running the client and server nodes together
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同时运行客户端和服务器节点
- en: Create an executable in the **setup.py** file named **reset_counter_client**,
    for example.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在**setup.py**文件中创建一个名为**reset_counter_client**的可执行文件，例如。
- en: Then, build the workspace and open three Terminals. In Terminals 1 and 2, start
    **number_publisher** and **number_counter**. The latter will start the **reset_counter**
    service server.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，构建工作空间并打开三个终端。在终端1和2中启动**number_publisher**和**number_counter**。后者将启动**reset_counter**服务服务器。
- en: 'In Terminal 3, start the **reset_counter_client** node. Since we want to reset
    the counter to 20, if the counter inside the **number_counter** node is less than
    20 at the moment of sending the request, you will get the following response:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端3中启动**reset_counter_client**节点。由于我们希望将计数器重置为20，如果发送请求时**number_counter**节点内的计数器小于20，您将得到以下响应：
- en: '[PRE30]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If the counter is 20 or more, you will get the following response instead:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如果计数器是20或更多，您将得到以下响应：
- en: '[PRE31]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Also, just after you start the node, the client sometimes needs a bit of time
    to find the service. In this case, you might see this log as well:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在启动节点后，客户端有时需要一点时间来找到服务。在这种情况下，您可能还会看到以下日志：
- en: '[PRE32]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'On the server side (the **number_counter** node), if the counter is being reset,
    you will see this log:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器端（**number_counter**节点），如果计数器正在重置，您将看到以下日志：
- en: '[PRE33]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'With that, we have tested two cases: when the counter is less than the requested
    reset value and when the counter is more than the requested reset value. If you
    want, you can also test the third case: when the requested reset value is lower
    than 0.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经测试了两种情况：当计数器小于请求的重置值时，以及当计数器大于请求的重置值时。如果您愿意，也可以测试第三种情况：当请求的重置值小于0。
- en: Now that we’ve finalized the client/server communication between the two nodes,
    let’s switch to C++.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了两个节点之间的客户端/服务器通信，让我们转向C++。
- en: Writing a C++ service client
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写C++服务客户端
- en: The C++ code follows the same logic as the Python code.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: C++代码遵循与Python代码相同的逻辑。
- en: 'First, we include the interface:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们包含接口：
- en: '[PRE34]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Then, we add a few **using** lines to reduce the code later:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们添加一些**using**行以减少后续代码：
- en: '[PRE35]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Next, we declare the service client as a private attribute in the class:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将服务客户端声明为类中的私有属性：
- en: '[PRE36]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'After, we initialize the client in the constructor:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在构造函数中初始化客户端：
- en: '[PRE37]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Then, as we did for Python, we add a method to call the service:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，就像Python一样，我们添加一个方法来调用服务：
- en: '[PRE38]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In this method, we wait for the service (don’t forget the exclamation mark in
    front of **client->wait_for_service(1s)**), create a request, fill in the request,
    and send it with **async_send_request()**. We pass the callback method as an argument,
    which will register the callback when the node is spinning.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，我们等待服务（别忘了在 **client->wait_for_service(1s)** 前面的感叹号），创建一个请求，填写请求，然后使用
    **async_send_request()** 发送它。我们将回调方法作为参数传递，这将注册当节点正在旋转时的回调。
- en: 'Here’s the callback method for the response:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是响应的回调方法：
- en: '[PRE39]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Finally, to be able to send a request, we call the **callResetCounter()** method
    just after creating the node, and before spinning:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了能够发送请求，我们在创建节点后立即调用 **callResetCounter()** 方法，在旋转之前：
- en: '[PRE40]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Now, create a new executable in **CMakeLists.txt**. Build the package, open
    a few Terminals, and start the **number_publisher** and **number_counter** nodes.
    Then, start the **reset_counter_client** node to try the service communication.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在 **CMakeLists.txt** 中创建一个新的可执行文件。构建包，打开几个终端，并启动 **number_publisher** 和 **number_counter**
    节点。然后，启动 **reset_counter_client** 节点以尝试服务通信。
- en: Now that you’ve written the code for both the service server and client, let’s
    explore what you can do with the ROS 2 tools. For services with a simple interface,
    you will be able to test them directly from the Terminal, even before writing
    the code for a client.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经编写了服务服务器和客户端的代码，让我们来看看你可以使用 ROS 2 工具做什么。对于具有简单接口的服务，你将能够直接从终端测试它们，甚至在编写客户端代码之前。
- en: Additional tools to handle services
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理服务的附加工具
- en: We’ve already used the **ros2** command-line tool a lot in this book. With this
    tool, each core ROS 2 concept gets additional functionalities in the Terminal.
    This is no exception for services.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这本书中已经大量使用了 **ros2** 命令行工具。使用这个工具，每个核心 ROS 2 概念在终端中都会获得额外的功能。这对于服务也不例外。
- en: We’re now going to explore **ros2 service** a bit more so that we can introspect
    services and send a request from the Terminal. We will also learn how to change
    a service name at runtime (**ros2 run**).
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将更深入地探索 **ros2 service**，这样我们就可以从终端检查服务和发送请求。我们还将学习如何在运行时更改服务名称（**ros2 run**）。
- en: To see all commands for ROS 2 services, type **ros2** **service -h**.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看 ROS 2 服务的所有命令，请输入 **ros2 service -h**。
- en: Listing and introspecting services
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列出和检查服务
- en: First, **rqt_graph** does not support services (yet—there are plans to maybe
    add this in a future ROS 2 distribution), so we won’t use it here. We will only
    use the **ros2** command-line tool.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，**rqt_graph** 不支持服务（目前还不支持——计划在未来的 ROS 2 发行版中可能添加此功能），所以我们在这里不会使用它。我们只会使用
    **ros2** 命令行工具。
- en: 'Stop all nodes and start the **number_counter** node. Then, to list all services,
    run the following command:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 停止所有节点并启动 **number_counter** 节点。然后，要列出所有服务，运行以下命令：
- en: '[PRE41]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: For each node you start, you will get seven additional services, mostly related
    to parameters. You can ignore those. If you look at the list, apart from those
    seven services, we can retrieve our **/****reset_counter** service.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 对于你启动的每个节点，你将得到七个额外的服务，大多数与参数相关。你可以忽略那些。如果你查看列表，除了那七个服务之外，我们可以检索我们的 **/****reset_counter**
    服务。
- en: Note
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Note that there is an additional leading slash in front of the service name.
    Service names follow the same rules as nodes and topics. If you don’t provide
    any namespace (for example, `/abc/reset_counter`), you’re in the “global” namespace,
    and a slash is added at the beginning.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，服务名称前面有一个额外的斜杠。服务名称遵循与节点和主题相同的规则。如果你没有提供任何命名空间（例如，`/abc/reset_counter`），你处于“全局”命名空间，并且会在前面添加一个斜杠。
- en: 'Once you have the service name you want, you can get the service interface
    with **ros2 service** **type <service_name>**:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你得到了想要的服务名称，你可以使用 **ros2 service** **type <service_name>** 来获取服务接口：
- en: '[PRE42]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'From this, you can see the details inside the interface:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，你可以看到接口内部的详细信息：
- en: '[PRE43]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This process is extremely useful when you need to create a service client for
    an existing server. There’s no need to even read the server code—you can get all
    the information you need from the Terminal.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要为现有的服务器创建服务客户端时，这个过程非常有用。你甚至不需要阅读服务器代码——你可以从终端获取所有你需要的信息。
- en: Sending a service request
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发送服务请求
- en: To test a service server, you usually have to write a service client.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试服务服务器，你通常需要编写服务客户端。
- en: 'Good news: instead of writing a client, you can call the service from the Terminal
    directly. This can save you some development time.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息：你不需要编写客户端，可以直接从终端调用服务。这可以节省你一些开发时间。
- en: 'First, you must know the service name and interface. Then, use the **ros2 call
    <service_name> <interface_name> "<request_in_json>"** command. Let’s try this
    with our **reset_counter** service:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你必须知道服务名称和接口。然后，使用 **ros2 call <service_name> <interface_name> "<request_in_json>"**
    命令。让我们用我们的 **reset_counter** 服务试一试：
- en: '[PRE44]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: You can see the request being sent, followed by the response. Then, the command
    exits. This is practical and in this case, we save a lot of time.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到请求被发送，然后是响应。然后，命令退出。这很实用，在这种情况下，我们节省了很多时间。
- en: 'We can also easily test the different cases. For example, let’s send a negative
    value for the reset number:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以轻松地测试不同的案例。例如，让我们发送一个负值作为重置数字：
- en: '[PRE45]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: With this example, it’s quite easy as the request is very simple (only one integer
    number). For more complex service requests that contain lots of nested fields
    and arrays, writing the full request in the Terminal can become quite cumbersome,
    and you will spend a lot of time trying to get it right.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，由于请求非常简单（只有一个整数），所以很容易。对于包含大量嵌套字段和数组的更复杂的服务请求，在终端中编写完整的请求可能会变得相当繁琐，你将花费大量时间来确保它正确无误。
- en: 'So, for simple interfaces, use **ros2 service call** to try the service first.
    For more complex interfaces, you’ll have to write a client code first. This isn’t
    really a problem: you can use the code we used for **ResetCounterClientNode**
    as a template for any other client. In the end, both methods allow you to test
    a service server quite quickly.'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于简单的接口，使用 **ros2 service call** 首先尝试服务。对于更复杂的接口，你首先需要编写客户端代码。这并不是真正的问题：你可以使用我们用于
    **ResetCounterClientNode** 的代码作为任何其他客户端的模板。最终，这两种方法都允许你快速测试服务服务器。
- en: Changing a service name at runtime
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在运行时更改服务名称
- en: When you start a node with **ros2 run**, you can change the node name and any
    topic name inside the node. You can do the same for services.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 **ros2 run** 启动一个节点时，你可以更改节点名称以及节点内的任何主题名称。你也可以对服务做同样的操作。
- en: As a reminder, for any additional argument you pass after **ros2 run**, add
    **--ros-args**, but only once.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 提醒一下，对于你传递给 **ros2 run** 的任何额外参数，添加 **--ros-args**，但只需添加一次。
- en: Then, to rename a service, add **-r** followed by **<service_name>:=<new_service_name>**.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为了重命名服务，添加 **-r** 后跟 **<service_name>:=<new_service_name>**。
- en: 'For example, let’s rename the **reset_counter** service to **reset_counter1**
    when we start the **number_counter** node:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当启动 **number_counter** 节点时，让我们将 **reset_counter** 服务重命名为 **reset_counter1**：
- en: '[PRE46]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now, let’s verify this with **ros2** **service list**:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们用 **ros2 service list** 来验证这一点：
- en: '[PRE47]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The service name is now **/reset_counter1**. If we start a node with a service
    client, we need to modify the name as well; otherwise, the nodes won’t be able
    to communicate with each other:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 现在服务名称是 **/reset_counter1**。如果我们启动一个带有服务客户端的节点，我们也需要修改名称；否则，节点之间将无法相互通信：
- en: '[PRE48]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Doing this is quite useful, especially when you want to run several nodes (written
    by yourself or others) that use a slightly different service name, or that are
    in different namespaces.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 做这件事非常有用，尤其是当你想运行几个节点（自己写的或别人的）时，这些节点使用略微不同的服务名称，或者位于不同的命名空间中。
- en: You are now able to write a service server/client and introspect/test them from
    the Terminal. Before moving on to the next chapter, let’s practice more with an
    additional challenge.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你能够编写服务服务器/客户端，并从终端对其进行内省/测试。在进入下一章之前，让我们通过一个额外的挑战来进一步练习。
- en: Service challenge – client and server
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务挑战 – 客户端和服务器
- en: 'With this new challenge, you will practice everything that was covered in this
    chapter: custom service interfaces, service servers, and service clients.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个新的挑战中，你将练习本章涵盖的所有内容：自定义服务接口、服务服务器和服务客户端。
- en: We will use the **turtle_controller** node we wrote in the previous chapter’s
    challenge as a starting point. We won’t create a new node here; instead, we will
    improve the existing code. You can either start from the code you wrote or from
    the code I provided in the **ch5** folder of this book’s GitHub repository.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以我们在上一章挑战中编写的 **turtle_controller** 节点作为起点。我们在这里不会创建一个新的节点；相反，我们将改进现有的代码。你可以从你写的代码开始，或者从我在本书GitHub仓库的
    **ch5** 文件夹中提供的代码开始。
- en: As always, I will explain what you need to do to complete the challenge, and
    then detail the most important points for the Python solution. You can find the
    complete solution code on GitHub for both Python and C++.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我会解释你需要做什么来完成挑战，然后详细说明Python解决方案最重要的要点。你可以在GitHub上找到Python和C++的完整解决方案代码。
- en: Challenge
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 挑战
- en: This challenge is divided into two parts. I suggest following them in order.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 这个挑战分为两部分。我建议你按顺序进行。
- en: Challenge 1 – service client
  id: totrans-321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 挑战1 – 服务客户端
- en: So far, our **turtle_controller** node is subscribing to the **/turtle1/pose**
    topic. In the subscriber callback, we send a velocity command to the **/****turtle1/cmd_vel**
    topic.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的**turtle_controller**节点正在订阅**/turtle1/pose**主题。在订阅者回调中，我们向**/turtle1/cmd_vel**主题发送速度命令。
- en: The result of this is the turtle drawing a circle on the screen, with a different
    velocity depending on if it is on the right or left of the screen.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是海龟在屏幕上画圆，速度取决于它是在屏幕的右侧还是左侧。
- en: What we want to do now is change the color of the pen, depending on where the
    turtle is. If the turtle is on the right of the screen, we want the pen color
    to be red. On the left, the color should be green.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在想要根据海龟所在的位置改变笔的颜色。如果海龟在屏幕的右侧，我们希望笔的颜色是红色。在左侧，颜色应该是绿色。
- en: To do that, we will need to add a service client in the node so that we can
    call the service to change the pen’s color in the **turtlesim** node (I won’t
    give you the service name—that’s part of the challenge).
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们需要在节点中添加一个服务客户端，以便我们可以调用服务来在**turtlesim**节点中更改笔的颜色（我不会给你服务名称——这是挑战的一部分）。
- en: 'Here are the steps you can take to get started:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一些你可以采取的起步步骤：
- en: 'Start the `turtlesim` node and use the `ros2 service` command line to find
    which service to call, as well as what interface to import (optional: at that
    point, you can also test the service with `ros2 service call`, directly from the
    Terminal).'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动`turtlesim`节点，并使用`ros2 service`命令行来查找要调用的服务以及要导入的接口（可选：在那个阶段，你也可以直接从终端使用`ros2
    service call`测试该服务）。
- en: In the `turtle_controller` node, add a service client for that service.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`turtle_controller`节点中，添加该服务的服务客户端。
- en: Create a method that will call the service.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个调用服务的方法。
- en: Call this method from the existing subscriber callback. After you publish the
    new command velocity, check whether the turtle is on the right or left of the
    screen. When the turtle switches to a different side, call the service with the
    updated color.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从现有的订阅者回调中调用此方法。在你发布新的速度命令后，检查海龟是在屏幕的右侧还是左侧。当海龟切换到不同的侧面时，调用服务并更新颜色。
- en: Challenge 2 – custom interface and service server
  id: totrans-331
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 挑战2 – 自定义接口和服务服务器
- en: Once you’re done with the first challenge, try this one. This time, you’ll practice
    on the server side of services.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 完成第一个挑战后，尝试这个挑战。这次，你将在服务的服务器端进行练习。
- en: Here, we want to allow the **turtle_controller** node to activate or deactivate
    the turtle (meaning to start or stop the turtle), depending on an external request.
    For that, we will create a service server.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们希望允许**turtle_controller**节点根据外部请求激活或停用海龟（意味着启动或停止海龟），为此，我们将创建一个服务服务器。
- en: 'Here are the steps you can take to get started:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一些你可以采取的起步步骤：
- en: Define a service name and interface for that service.
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个服务名称和该服务的接口。
- en: 'If no existing interface matches your needs, you will need to create and build
    a new one (hint: that’s what we will do here).'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果没有现有的接口符合你的需求，你需要创建并构建一个新的接口（提示：这正是我们在这里要做的）。
- en: 'In the `turtle_controller` node, add a service server and a callback, in which
    you activate or deactivate the turtle. Tip: you can use a simple boolean attribute
    in the class to store the activated state for the turtle.'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`turtle_controller`节点中，添加一个服务服务器和一个回调，在其中激活或停用海龟。提示：你可以在类中使用一个简单的布尔属性来存储海龟的激活状态。
- en: If the turtle is activated, then in the subscriber callback, you can keep sending
    additional velocity commands. If it is not activated, you don’t send any commands.
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果海龟被激活，那么在订阅者回调中，你可以继续发送额外的速度命令。如果没有激活，则不发送任何命令。
- en: With those instructions, you should be able to get started. Taking the time
    to do this exercise is probably the best investment you can make to learn ROS
    faster.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这些说明，你应该能够开始操作。花时间做这个练习可能是你为了更快学习ROS所能做的最佳投资。
- en: Solution
  id: totrans-340
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Let’s start with the first challenge.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第一个挑战开始。
- en: Challenge 1
  id: totrans-342
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 挑战1
- en: For this challenge, we are on the client side, which means that we need to find
    out which service we need to call. I will do a quick recap of the steps for finding
    the service name and interface.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个挑战，我们处于客户端，这意味着我们需要找出需要调用哪个服务。我将快速回顾一下查找服务名称和接口的步骤。
- en: Start the **turtlesim** node and list all services. You should see a **/turtle1/set_pen**
    service with **ros2** **service list**.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 启动**turtlesim**节点并列出所有服务。你应该看到**/turtle1/set_pen**服务通过**ros2 service list**。
- en: 'Now, get the type for this service and see what’s inside the interface:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，获取此服务的类型并查看接口中的内容：
- en: '[PRE49]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In the service request, we can send an (**r**,**g**,**b**) value (red, green,
    blue). There are also **width** and **off** attributes, but we won’t use them.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务请求中，我们可以发送一个（**r**、**g**、**b**）值（红色、绿色、蓝色）。还有**width**和**off**属性，但我们不会使用它们。
- en: 'At this point, before you even write the code for the client, you can try the
    service from the Terminal:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在此阶段，在你甚至开始编写客户端代码之前，你可以从终端尝试使用服务：
- en: '[PRE50]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Then, execute **ros2 run turtlesim turtle_teleop_key** and move the turtle around.
    You’ll see that the pen is now using a red color.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，执行**ros2 run turtlesim turtle_teleop_key**并移动乌龟。你会看到笔现在使用红色。
- en: 'Back to the code, inside the **turtle_controller.py** file, import the interface:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 回到代码，在**turtle_controller.py**文件中，导入接口：
- en: '[PRE51]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Since we’ve already added the dependency for **turtlesim** in the **package.xml**
    file of the **turtle_controller** package (in the previous chapter), there’s no
    need to do it again.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经在**turtle_controller**包的**package.xml**文件中添加了对**turtlesim**的依赖（在上一章中），因此不需要再次添加。
- en: 'Then, create the service client in the constructor:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在构造函数中创建服务客户端：
- en: '[PRE52]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Write the method that will call the service, as well as the callback for the
    response:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 编写调用服务的方法以及响应的回调：
- en: '[PRE53]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: We only send the **r**, **g**, and **b** parts of the request. The other values
    (**width** and **off**) will be kept as-is.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只发送请求的**r**、**g**和**b**部分。其他值（**width**和**off**）将保持不变。
- en: As you can see, in the callback for the response, we don’t check what’s inside
    the response since the response is empty (it exists but it doesn’t contain a field).
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在响应的回调中，我们不会检查响应内部的内容，因为响应是空的（它存在，但不包含字段）。
- en: The only thing we need to do now is call this new **call_set_pen()** method.
    We will do that from within the subscriber callback since this is where we have
    access to the *X* position of the turtle.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在唯一需要做的就是调用这个新的**call_set_pen()**方法。我们将从订阅者回调中这样做，因为这是我们能够访问乌龟的*X*位置的地方。
- en: 'Inside the **callback_pose()** method, and after the code to publish on the
    topic, add the code to handle the pen color:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在**callback_pose()**方法中，并在发布到主题的代码之后，添加处理笔颜色的代码：
- en: '[PRE54]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: If the turtle is on the right, we set the color to red (**255, 0, 0**), and
    if it’s on the left, we set the color to green (**0,** **255, 0**).
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 如果乌龟在右侧，我们将颜色设置为红色（**255, 0, 0**），如果它在左侧，我们将颜色设置为绿色（**0, 255, 0**）。
- en: 'On top of that, we also define a new attribute in the constructor so that we
    can keep track of the previous *X* coordinate:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还在构造函数中定义了一个新的属性，以便我们可以跟踪之前的*X*坐标：
- en: '[PRE55]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: We use this to only call the service when the turtle switches from one side
    to the other. Why do we do that? We could send a service request every time, even
    if the color would be the same as the previous one. Why “optimize” the code?
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用这个来仅在乌龟从一侧切换到另一侧时调用服务。我们为什么要这样做？即使颜色与上一个相同，我们也可以每次都发送服务请求。为什么要“优化”代码？
- en: 'The reason is that the **callback_pose()** method will be called a lot. Check
    the frequency for the **/turtle1/pose** topic in the Terminal:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是**callback_pose()**方法会被频繁调用。在终端检查**/turtle1/pose**主题的频率：
- en: '[PRE56]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This means that we execute **callback_pose()** about 62 times per second. This
    is not really a problem. We also publish on the **/turtle1/cmd_vel** topic at
    62 Hz. Again, that’s not a problem. Publishers and subscribers can sustain a high
    frequency (with a bigger message size, this could become complicated, but here,
    the messages are really small).
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们大约每秒执行**callback_pose()**约62次。这并不是真正的问题。我们也在**/turtle1/cmd_vel**主题上以62
    Hz的频率发布。同样，这也不是问题。发布者和订阅者可以承受高频率（如果消息大小更大，这可能会变得复杂，但在这里，消息非常小）。
- en: Now, what if we send a request to a service 62 times per second? This is where
    the problem is. Services are not made for high-frequency requests, and this could
    seriously affect the performance of the application. Also, if you find yourself
    having to call a service at 62 Hz, then you probably have a design problem, and
    you either need to modify your code to reduce the frequency or use a publish/subscribe
    mechanism instead.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们每秒向服务发送62次请求会怎样？问题就在这里。服务不是为高频请求设计的，这可能会严重影响应用程序的性能。此外，如果你发现自己需要以62 Hz的频率调用服务，那么你可能有一个设计问题，你可能需要修改代码以降低频率或使用发布/订阅机制。
- en: So, what we do in the code is make sure we only call the service when it’s needed—that
    is, when the turtle switches from one side to the other.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们在代码中确保只有在需要时才调用服务——也就是说，当海龟从一边切换到另一边时。
- en: The code is now complete! At this point, you can build your **turtle_controller**
    package again (unless you have already built it with **--symlink-install**), source
    the environment, and then start both the **turtlesim** and **turtle_controller**
    nodes to see the result.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 代码现在已完成！在这个时候，你可以再次构建你的**turtle_controller**包（除非你已经使用**--symlink-install**构建了它），源环境，然后启动**turtlesim**和**turtle_controller**节点以查看结果。
- en: Challenge 2
  id: totrans-373
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 挑战2
- en: 'Now, we want to add a service server inside our node so that we can activate
    or deactivate the turtle. Since we’re defining the server, we need to come up
    with a name and an interface:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们想在节点内部添加一个服务服务器，以便我们可以激活或停用海龟。由于我们正在定义服务器，我们需要想出一个名称和一个接口：
- en: '`activate_turtle`. We’ll start with a verb and try to make the name as explicit
    as possible.'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`activate_turtle`。我们将从一个动词开始，并尝试使名称尽可能明确。'
- en: '`SetBool` service from `example_interfaces`. It contains a boolean in the request
    and a string in the response. However, as stated previously, the best practice
    is to avoid using the `std_srvs` and `example_interfaces` packages if your application
    is any serious. So, in this case, we’ll create our own interface.'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自`example_interfaces`的`SetBool`服务。它包含请求中的布尔值和响应中的字符串。然而，如前所述，如果你的应用程序是严肃的，最好避免使用`std_srvs`和`example_interfaces`包。因此，在这种情况下，我们将创建我们自己的接口。
- en: Let’s create a new interface for our service. This will be quite quick and easy
    as we already have the **my_robot_interfaces** package fully configured.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的服务创建一个新的接口。由于我们已经有**my_robot_interfaces**包完全配置，这将非常快且简单。
- en: 'Inside the **srv** folder of the **my_robot_interfaces** package, create a
    new service file named **ActivateTurtle.srv**. In this file, write the service
    definition:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在**my_robot_interfaces**包的**srv**文件夹中，创建一个名为**ActivateTurtle.srv**的新服务文件。在这个文件中，编写服务定义：
- en: '[PRE57]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'This is all we need in the request: a boolean to activate or deactivate the
    turtle. We also added a string in the response so that we get to know what happened,
    but you could also decide to have an empty response.'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 请求中我们需要的所有内容就是一个布尔值来激活或停用海龟。我们还添加了一个字符串在响应中，以便我们知道发生了什么，但你也可以选择有一个空响应。
- en: 'After this, add the interface to the **CMakeLists.txt** file of the **my_robot_interfaces**
    package, and build the package. Source the environment, and make sure you can
    see the interface with:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将接口添加到**my_robot_interfaces**包的**CMakeLists.txt**文件中，并构建该包。源环境，并确保你可以通过以下方式看到接口：
- en: '[PRE58]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Now, let’s go back to the **turtle_controller** package.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到**turtle_controller**包。
- en: 'Since we will have a dependency on **my_robot_interfaces**, add a new line
    to the **package.xml** file of the **turtle_controller** package:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将依赖于**my_robot_interfaces**，请在**turtle_controller**包的**package.xml**文件中添加新行：
- en: '[PRE59]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Now, it’s time to write the code inside **turtle_controller.py**. Import the
    interface:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候在**turtle_controller.py**中编写代码了。导入接口：
- en: '[PRE60]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'In the constructor, add a boolean flag to keep track of the activated status
    for the turtle, and create a new service server:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，添加一个布尔标志来跟踪海龟的激活状态，并创建一个新的服务服务器：
- en: '[PRE61]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Implement the callback method for that service:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 实现该服务的回调方法：
- en: '[PRE62]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: What we do is simple—we just set the **is_active_** boolean with the value we
    get from the boolean in the request. Now, whenever you call this service, the
    **is_active_** boolean will be updated with the value you send.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的是简单的——我们只是将**is_active_**布尔值设置为从请求中的布尔值得到的值。现在，每次你调用这个服务时，**is_active_**布尔值都会更新为你发送的值。
- en: 'The last step, to make the turtle start or stop when activated or deactivated,
    is to modify the code inside the **callback_pose()** method:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步，要使海龟在激活或停用时开始或停止，需要修改**callback_pose()**方法中的代码：
- en: '[PRE63]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: This way, we only publish a new command velocity if the turtle is activated.
    If not, we publish nothing. Also, the service request will only work when the
    turtle is activated.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，只有当海龟被激活时，我们才会发布新的命令速度。如果没有，我们则不发布任何内容。此外，只有当海龟被激活时，服务请求才会生效。
- en: 'To try this new service, start the **turtlesim** node and **turtle_controller**
    nodes. In a third Terminal, send a service request with the **ros2** command-line
    tool. Here’s an example:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试这个新服务，请启动**turtlesim**节点和**turtle_controller**节点。在第三个终端中，使用**ros2**命令行工具发送一个服务请求。以下是一个示例：
- en: '[PRE64]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'This should make the turtle stop. You can send a request again, this time with
    **"{activate: true}"**, which should make the turtle move again.'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '这应该会使海龟停止。你可以再次发送请求，这次使用**"{activate: true}"**，这将使海龟再次移动。'
- en: That’s the end of this challenge on services. If you managed to finish this
    challenge by yourself, you have a good understanding of services. No worries if
    you couldn’t do it without having to look at the solution. Come back to it in
    a few days and see if you can solve the challenge again.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是关于服务的挑战的结束。如果你自己完成了这个挑战，你对服务有很好的理解。如果你没有查看解决方案就完成了它，也不要担心。几天后再回来看看你是否能再次解决这个挑战。
- en: Summary
  id: totrans-400
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you worked on ROS 2 services, which is another ROS 2 communication
    you can use alongside topics.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了ROS 2服务，这是你可以与主题一起使用的另一种ROS 2通信方式。
- en: With services, nodes can talk to each other using a client/server type of communication.
    Only one server can exist for a service, but you can send multiple requests from
    several clients.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 使用服务，节点可以通过客户端/服务器类型的通信相互交谈。对于服务，只能存在一个服务器，但你可以从多个客户端发送多个请求。
- en: You can implement service servers and clients directly in your nodes using **rclpy**
    for Python and **rclcpp** for C++.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以直接在你的节点中使用**rclpy**（Python）和**rclcpp**（C++）实现服务服务器和客户端。
- en: 'To write a service server, you must do the following:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写服务服务器，你必须执行以下操作：
- en: As the name and interface are defined by the server, you have to choose them
    here. As a best practice, use a verb as the first word in the name.
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于名称和接口由服务器定义，你必须在这里选择它们。作为一个最佳实践，使用动词作为名称的第一个单词。
- en: Import the interface in your code and create the service server in the constructor.
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的代码中导入接口，并在构造函数中创建服务服务器。
- en: Add a callback method to process any received request.
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个回调方法来处理任何接收到的请求。
- en: 'When choosing a service interface, if you can’t find an existing one that perfectly
    matches what you need, then you have to create and build your own. To do that,
    you must do the following:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择服务接口时，如果你找不到一个完全符合你需求的现有接口，那么你必须创建并构建自己的接口。为此，你必须执行以下操作：
- en: Create and set up a package dedicated to interfaces. If you already have one
    for your application, use it.
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并设置一个专门用于接口的包。如果你已经有了为你的应用程序创建的一个包，请使用它。
- en: Add the new service interface to the package and build it.
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新的服务接口添加到包中并构建它。
- en: Now, you can use this interface in your service server.
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你可以在你的服务服务器中使用这个接口。
- en: 'To write a service client, do the following:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写服务客户端，请执行以下操作：
- en: If you’re writing a client, it means that there is an existing server on the
    other side. Find which name and interface you need to use.
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你正在编写客户端，这意味着在另一边有一个现有的服务器。找出你需要使用的名称和接口。
- en: Import the interface into your code and create the service client in the constructor.
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将接口导入到你的代码中，并在构造函数中创建服务客户端。
- en: Create a method to call the service. In this method, you send the request asynchronously,
    and then register a callback to process the response.
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个调用服务的方法。在这个方法中，你异步发送请求，然后注册一个回调来处理响应。
- en: You can call the service from anywhere in your code.
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以在代码的任何地方调用服务。
- en: With the **ros2 service** command line, you can introspect the services in your
    nodes and see what interface they’re using.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**ros2 service**命令行，你可以检查你节点中的服务，并查看它们使用的是什么接口。
- en: To try a service server, you can either write a corresponding service client
    inside another node or, if the request is simple, call the service directly from
    the Terminal with **ros2** **service call**.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试服务服务器，你可以在另一个节点内部编写相应的服务客户端，或者如果请求很简单，可以直接从终端使用**ros2** **service call**调用服务。
- en: 'You have now seen the two most common ROS 2 communication types: topics and
    services. In the next chapter, we will work with the third and last one: actions.'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经看到了ROS 2中最常见的两种通信类型：主题和服务。在下一章中，我们将处理第三种和最后一种：动作。
