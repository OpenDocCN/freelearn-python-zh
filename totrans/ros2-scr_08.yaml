- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Services – Client/Server Interaction between Nodes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Nodes can communicate with each other using one of three communication types.
    You discovered topics in the previous chapter. Now is the time to switch to the
    second most used communication: ROS 2 services.'
  prefs: []
  type: TYPE_NORMAL
- en: As we did for topics, we will first understand services with the help of a real-life
    analogy. I will also share more thoughts on when to use topics versus services.
    After that, you will dive into the code and write a service server and client
    inside nodes using custom service interfaces. You will also explore additional
    tools to handle services from the Terminal.
  prefs: []
  type: TYPE_NORMAL
- en: All the code we’ll write in this chapter starts from the final code of the previous
    chapter. We will improve the number application to learn how to use services,
    and then work on the turtle controller application with an additional challenge.
    If you want to have the same starting point as me, you can download the code from
    GitHub ([https://github.com/PacktPublishing/ROS-2-from-Scratch](https://github.com/PacktPublishing/ROS-2-from-Scratch)),
    in the **ch5** folder, and use it as a starting point. The final code can be found
    in the **ch6** folder.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will understand how services work, and you will
    be able to create your own service interfaces, service servers, and service clients.
  prefs: []
  type: TYPE_NORMAL
- en: Becoming confident with topics and services is one of the most important things
    when starting with ROS 2\. With this, you will be able to write custom code for
    your projects and interact with most of the existing ROS 2 applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is a ROS 2 service?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a custom service interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a service server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a service client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional tools to handle services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service challenge – client and server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is a ROS 2 service?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You discovered the concept of ROS 2 services in [*Chapter 3*](B22403_03.xhtml#_idTextAnchor092),
    in the *Services* section, where you ran your first service server and client
    to get an intuition of how they work. You also became familiar with the **ros2**
    command-line tool for handling services from the Terminal.
  prefs: []
  type: TYPE_NORMAL
- en: From here, I will start from scratch again and explain what services are, using
    a real-life analogy. We will build an example, step by step, and then recap the
    most important points.
  prefs: []
  type: TYPE_NORMAL
- en: A server and a client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To start, I will use an online weather service as an analogy.
  prefs: []
  type: TYPE_NORMAL
- en: This online weather service can tell us the local weather after we send our
    location. To get the weather report for your city, you will need to interact with
    this service. You can use your computer to send a web request with the URL provided
    by the service.
  prefs: []
  type: TYPE_NORMAL
- en: 'What’s going to happen? First, your computer will send a request to the weather
    service. The request contains your location. The service will receive the request,
    process it, and if the location is valid, it will return the weather for that
    location. Your computer then receives a response containing the weather information.
    That’s the end of the communication. Here’s an illustration of this process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – Client/server interaction](img/B22403_06_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 – Client/server interaction
  prefs: []
  type: TYPE_NORMAL
- en: This is basically how a ROS 2 service works. On one side, you have a **service
    server** inside a node, and on the other side, you have a **service client** inside
    another node.
  prefs: []
  type: TYPE_NORMAL
- en: To start the communication, the service **Client** needs to send a **request**
    to the **Server**. The **Server** will then process the request, do any appropriate
    actions or computations, and return a **response** to the **Client**.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, a service, just like for topics, has a name and an interface.
    The interface is not just one message, it’s a pair of messages: a request and
    a response. Both the client and server must use the same name and interface to
    successfully communicate with each other.'
  prefs: []
  type: TYPE_NORMAL
- en: With this example, the HTTP URL is the service name, and the pair (location,
    weather) is the service interface (request, response).
  prefs: []
  type: TYPE_NORMAL
- en: Multiple clients for one service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In real life, many people will try to get the weather from this online service
    (at different times or at the same time). That’s not a problem: each client will
    send a request with a location to the server through the HTTP URL. The server
    will process each request individually and return the appropriate weather information
    to each client.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, this is very important: there can be only one server. One URL only goes
    to one server, just like one physical mail address is unique. Imagine if you send
    a package to someone and there are two places with the same address. How can the
    mail delivery person know where to deliver the package?'
  prefs: []
  type: TYPE_NORMAL
- en: 'This will be the same for ROS 2 services. You can have several clients send
    a request to the same service. However, for one service, only one server can exist.
    See the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2 – Service server with multiple clients](img/B22403_06_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.2 – Service server with multiple clients
  prefs: []
  type: TYPE_NORMAL
- en: Here, you can see some boxes, each box representing a node. Thus, we have four
    nodes. Three nodes contain a service **Client** and talk to the **Weather service**
    node, which contains a service **Server**.
  prefs: []
  type: TYPE_NORMAL
- en: One thing to note here is that the clients don’t know exactly which node to
    communicate with. They must go through the URL (service name). In this example,
    the clients aren’t aware of the IP address of the server—they just know they have
    to use the URL to connect to the server.
  prefs: []
  type: TYPE_NORMAL
- en: Also, no client is aware of the other clients. When you try to get the weather
    information from this service, you don’t know who is also trying to access the
    service, or even how many people are sending a request.
  prefs: []
  type: TYPE_NORMAL
- en: Another service example with robotics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s use another example that could be part of a ROS application.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that you have a node responsible for controlling an LED panel (three
    LEDs). This node could contain a service server that allows other nodes to request
    turning an LED on or off.
  prefs: []
  type: TYPE_NORMAL
- en: You also have a node monitoring a battery. In your application, what you want
    to do is turn on one LED when the battery is low, and then turn it off when the
    battery is high again.
  prefs: []
  type: TYPE_NORMAL
- en: You can do that using a ROS 2 service. The LED panel node would contain a service
    server named **set_led**. To send a request to this server, you must provide the
    LED number and the state of that LED (on or off). Then, you receive a response
    containing a boolean value to see if the request was successfully processed by
    the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the battery is now running low. Here’s what’s going to happen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3 – Client asking to turn on LED number 3](img/B22403_06_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.3 – Client asking to turn on LED number 3
  prefs: []
  type: TYPE_NORMAL
- en: Here, **Battery node** will send a **Request** to the **set_led** service. The
    **Request** contains the **LED number 3** and **state on** details so that it
    can turn on LED **3** of the panel.
  prefs: []
  type: TYPE_NORMAL
- en: The **Service** server, in the **LED panel node**, receives the **Request**.
    The server may decide to validate the **Request** (for example, if the LED number
    is 4, this is not valid) and process it. Processing the **Request** here means
    turning on the third LED. After that, the server sends a **Response** back to
    the **Client**, with a boolean flag. The **Client** receives this **Response**,
    and the communication ends.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, when the battery is fully charged, the **Battery node** sends another
    **Request** this time to turn off **LED 3**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4 – Client asking to turn off LED number 3](img/B22403_06_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.4 – Client asking to turn off LED number 3
  prefs: []
  type: TYPE_NORMAL
- en: The process is the same. The **Client** sends a **Request**, this time with
    **state off** for **LED 3**. The **Server**, inside the **LED panel node**, receives
    that **Request** and turns off the third LED. Then, the **Server** sends a **Response**
    back to the **Client**.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping things up
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On top of topics, ROS 2 nodes can use services to communicate with each other.
  prefs: []
  type: TYPE_NORMAL
- en: When should you use topics versus services? You should use topics to publish
    unidirectional data streams and services when you want to have a client/server
    type of communication.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if you want to continuously send a velocity command to a robot
    10 times per second, or send the data you read from a sensor, you will use topics.
    If you want to have a node perform quick computations or do some actions on demand
    (enabling/disabling a motor, starting/stopping a robot), then you would use services.
  prefs: []
  type: TYPE_NORMAL
- en: It can be hard to give a definitive answer to that question. Each application
    is different. Most of the time, the choice will be obvious, but sometimes, you
    have to go one way only to realize that that was the wrong way. The more experience
    you get with ROS 2, the more you will be able to make the best design decisions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some important points about how services work:'
  prefs: []
  type: TYPE_NORMAL
- en: A service is defined by a name and an interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The name of a service follows the same rules as for topics. It must start with
    a letter and can be followed by other letters, numbers, underscores, tildes, and
    slashes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The interface contains two things: a request and a response. Both the client
    and server must use the same interface to be able to communicate with each other.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A service server can only exist once but can have multiple clients.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service clients are not aware of each other and are not aware of the server
    node. To reach the server, they just know that they must use the service name
    and provide the correct interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One node can contain multiple service servers and clients, each with a different
    service name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, how can you write a service client and server?
  prefs: []
  type: TYPE_NORMAL
- en: Just as for nodes and topics, you will find everything you need in the **rclpy**
    and **rclcpp** libraries. With those libraries, you can write a service server
    and client inside nodes. That’s what we are going to do now.
  prefs: []
  type: TYPE_NORMAL
- en: As we can’t test a client without a server, let’s start with the server side.
    But before we even start writing the server, what interface will we need to use
    for the service?
  prefs: []
  type: TYPE_NORMAL
- en: Creating a custom service interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 5*](B22403_05.xhtml#_idTextAnchor211), when we created the ROS
    2 application with the **number_publisher** and **number_counter** nodes, we used
    an existing interface for the **number** topic. Since we wanted to publish an
    integer number, the **example_interfaces/msg/Int64** interface seemed to be exactly
    what we needed. At this point, you know that you must avoid using the **example_interfaces**
    package for real applications, but for a first test, that wasn’t a problem.
  prefs: []
  type: TYPE_NORMAL
- en: We’re going to continue working on this application and add more functionalities
    so that we can practice with services. Here, we will focus on the **number_counter**
    node. For now now, in this node, every time we receive a message from the **number**
    topic, we’ll add this number to a counter and print the counter.
  prefs: []
  type: TYPE_NORMAL
- en: What we want to do is allow the **number_counter** node to reset the counter
    to a given number when we ask it to. For that, we will add a service server inside
    the node. Then, any other node can send a request, specifying the reset value
    for the counter. For example, let’s say the counter is currently at 76, and you
    send a request to reset it to 20\. If the request is accepted by the service server,
    the counter will now become 20 and continue to increment from that value.
  prefs: []
  type: TYPE_NORMAL
- en: Great—we know what we must do. Now, which interface should we use? Can we find
    an existing interface for what we need, or will we have to create a custom one?
    As per the title of this section, you can already guess the answer to that question.
    Nonetheless, let’s see what we could find if we were looking at existing interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Finding an existing interface for our service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When it comes to a service interface, we need to think about two things: the
    request and the response.'
  prefs: []
  type: TYPE_NORMAL
- en: In our application, the request, which is sent from the client to the server,
    should contain an integer number. This is the reset value for the counter.
  prefs: []
  type: TYPE_NORMAL
- en: For the response, which is sent from the server to the client, we can decide
    to use a boolean flag, to specify whether we were able to perform the request,
    and a message to explain what went wrong if something went wrong.
  prefs: []
  type: TYPE_NORMAL
- en: 'The question is, will we find an existing interface that matches our needs?
    Unfortunately, this time, it seems that there is no matching interface. We can
    check the **example_interfaces** package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We can even check the **std_srvs** package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, service interfaces are placed inside a `srv` folder, inside
    the package. For topics, we had a `msg` folder. This is a good way to differentiate
    both types of interfaces easily.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look more closely at those interfaces, especially **SetBool** and **Trigger**,
    you’ll see that there is no way to send an integer number in the request. Here’s
    an example where we’re trying to use **SetBool**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: When looking at the interface definition, you can see that the request and response
    are separated by three dashes (**---**). In the response, we can find a boolean
    and a string, which is what we want. However, the request only contains a boolean,
    not an integer.
  prefs: []
  type: TYPE_NORMAL
- en: You could have a look at other interfaces in the common interfaces GitHub repository
    ([https://github.com/ros2/common_interfaces](https://github.com/ros2/common_interfaces))
    but you won’t find exactly what we are looking for.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, we will create our own service interface before writing the code for the
    service. For the **number** topic, we were lucky enough to find an interface that
    we could directly use in the code (even though for real applications, the best
    practice is to avoid using **example_interfaces** and **std_srvs** anyway). Here,
    we need to create the interface first.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new service interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To create a service interface, just like for a topic interface, you need to
    create and configure a package dedicated to interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'Good news: we did that in [*Chapter 5*](B22403_05.xhtml#_idTextAnchor211) in
    the *Creating a custom interface for a topic* section. Since we’re working on
    the same application, we will put all the topic and service interfaces in the
    same package: **my_robot_interfaces** (if you don’t already have this package,
    go back to the previous chapter and set it up).'
  prefs: []
  type: TYPE_NORMAL
- en: We can create a new service interface inside that package directly; there’s
    nothing else to do. So, the process will be quite quick.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, navigate inside the **my_robot_interfaces** package (where you already
    have a **msg** folder) and create a new **srv** folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this new folder, you will put all the service interfaces that are specific
    to your application (or robot).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, create a new file for a service. Here are the rules to follow regarding
    the filename:'
  prefs: []
  type: TYPE_NORMAL
- en: Use UpperCamelCase (PascalCase)—for example, `ActivateMotor`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don’t write `Srv` or `Interface` in the name as this would add unnecessary redundancy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `.srv` for the file extension.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a best practice, use a verb in the interface name—for example, `TriggerSomething`,
    `ActivateMotor`, or `ComputeDistance`. Services are about doing an action or computation,
    so by using a verb, you make it very clear what the service is doing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Since we want to reset the counter, let’s simply call the interface **ResetCounter**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Open this file and write the definition for the service interface. One very
    important thing to do here is add three dashes (**---**) and put the request definition
    on top, and then the response definition below the dashes.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the request and response, you can use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Built-in types (`bool`, `byte`, `int64`, and so on).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Existing message interfaces. For example, the request of the service could contain
    `geometry_msgs/Twist`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can’t include a service definition inside another service definition. You
    can only include a message (topic definition) inside the request or the response
    of the service. The request and response can be seen as two independent messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s write our service interface. As it’s not too complex, we can use simple
    built-in types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: With this, the client will send a request with one integer value, and the response
    will contain a boolean flag as well as a string. All the fields inside the definition
    must follow the snake_case convention (use underscores between words, all letters
    lowercase, and no space).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you always have three dashes in all your service definitions, even
    if the request or the response is empty.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve written our interface, we need to build it so that we can use
    it in our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go back to the **CMakeLists.txt** of **my_robot_interfaces** package. Since
    the package has already been configured, we just need to add one line. Add the
    relative path to the interface on a new line inside the **rosidl_generate_interfaces()**
    function. Don’t use any commas between the lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'After this, save all files and build the **my_robot_interfaces** package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Once built, source the environment. You should be able to find your new interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If you see that, you know that the service interface has been built successfully,
    and you can use it in your code. So, let’s do that and write a service server.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a service server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will now write your first service server. As mentioned previously, we will
    continue with the number application we started in the previous chapter. What
    we want to do here is allow **number_counter** to reset the counter to a given
    number when we ask it to do so. This is a perfect example of when to use a service.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing to think about when creating a new service is what service interface
    you need. We’ve just done that, so we can now focus on the code.
  prefs: []
  type: TYPE_NORMAL
- en: To write a service server, you will need to import the interface and then create
    a new service in the node’s constructor. You will also need to add a callback
    to be able to process the request, do the required action or computation, and
    return a response to the client.
  prefs: []
  type: TYPE_NORMAL
- en: As always, let’s start with a fully detailed explanation with Python, after
    which we will see how to do the same with C++.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a Python service server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To write a Python service server, we first need to have a Python node. We won’t
    create a new node here since we’re adding functionality to an existing one (**number_counter**).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can have any number of publishers, subscribers, and services inside a node.
    So long as you keep things clean, that will not be a problem.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s get started. As always, you can find the complete code in this book’s
    GitHub repository. I will not display the full code for the node here, just the
    new lines that are required for the service we are adding.
  prefs: []
  type: TYPE_NORMAL
- en: Importing a service interface
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first big part of creating a service is to find an existing interface or
    create a new one. That’s what we just did, so let’s use the **ResetCounter** interface
    from the **my_robot_interfaces** package.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to add the dependency to this interface package inside the package
    where we write the node with the service. Open the **package.xml** file from **my_py_pkg**
    and add the new dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This will ensure that the interfaces package is installed when you build the
    **my_py_pkg** package with **colcon**. Now, import the dependency into your code
    (**number_counter.py**):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: To import a service, we must specify the package name (**my_robot_interfaces**),
    followed by the folder name for services (**srv**), and finally the class for
    the interface (**ResetCounter**).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: I’ve already mentioned this, but if you’re using VS Code and auto-completion
    doesn’t work, or the service isn’t recognized (import error), follow the process
    below.
  prefs: []
  type: TYPE_NORMAL
- en: 'Close VS code. Then, open a new Terminal, make sure the environment is correctly
    sourced, and find the interface (`ros2 interface show <interface_name>`). After,
    navigate to the `src` directory of the ROS 2 workspace and open VS Code with:'
  prefs: []
  type: TYPE_NORMAL
- en: '**$** **code .**'
  prefs: []
  type: TYPE_NORMAL
- en: Adding a service server to the node
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you’ve correctly imported the service interface, you can create the
    service server.
  prefs: []
  type: TYPE_NORMAL
- en: As you did for publishers and subscribers, you will add your service servers
    to the node’s constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the constructor of the **NumberCounterNode** class, which contains the
    previously created subscriber and the new service server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We add the service server at the same time as the number subscriber and just
    before the ending log.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the service server, we use the **create_service()** method from the
    **Node** class. Once again, you can see that by inheriting from this class, we
    get access to all ROS 2 functionalities easily. In this method, you must provide
    three arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ResetCounter` class we have imported.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reset_counter`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service callback**: The service server, as its name suggests, is a server.
    This means that it won’t do anything by itself. You will need to have a client
    send a request so that the server does something. So, while the node is spinning,
    the server will be in “waiting mode.” Upon reception of a request, the service
    callback will be triggered, and the request will be passed to this callback.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, we need to implement this callback. First, let’s write a minimal code
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In a service callback, we receive two things: an object for the request and
    an object for the response. The request object contains all the data sent by the
    client. The response object is empty, and we will need to fill it, as well as
    return it.'
  prefs: []
  type: TYPE_NORMAL
- en: To name the callback, I usually write **callback_** followed by the service
    name. This makes it easier to recognize in the code and will prevent future mistakes
    as you want to make sure you don’t call this method directly. It should only be
    called while the node is spinning and when a client sends a request from another
    node.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In the method’s arguments, I have also specified the type for the two arguments.
    This way, we make the code more robust, and we can use auto-completion features
    from IDEs such as VS Code.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you create an interface for a topic, you only get one class for that interface
    (for example, `Int64`). As you can see, in a service, we get two classes: one
    for the request (`Interface.Request`) and one for the response (`Interface.Response`).'
  prefs: []
  type: TYPE_NORMAL
- en: In this callback, we get **reset_value** from the request and modify the **counter_**
    variable accordingly. Then, we fill the success and message fields from the response
    and return the response.
  prefs: []
  type: TYPE_NORMAL
- en: This is a very minimal piece of code for a service server. In real life, you’ll
    probably want to check if the request is valid before you use the values from
    it. For example, if you have a service that will modify the maximum velocity of
    a mobile robot, you might want to be sure the value you receive is not too high,
    to prevent the robot from becoming uncontrolled and damaging itself or the environment.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s improve the callback so that we can validate **reset_value** before we
    modify the **counter_** variable.
  prefs: []
  type: TYPE_NORMAL
- en: Validating the request
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s say we want to add those two validation rules: the reset value must be
    a positive number, and it cannot be higher than the current counter value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the code in the **callback_reset_counter** method, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: First, we check if the value is negative. If so, we don’t do anything with the
    **counter_** variable. We set the boolean flag to **False** and provide an appropriate
    error message.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we check if the value is greater than the current **counter_** value.
    If that’s the case, we do the same thing as before, with a different error message.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, if none of those conditions are true (which means we’ve validated the
    request), then we process the request and modify the **counter_** variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a recap of the steps for a service server callback:'
  prefs: []
  type: TYPE_NORMAL
- en: (Optional but recommended) Validate the request, or validate that external conditions
    are met for the callback to be processed. For example, if the service is about
    activating a motor, but the communication with the motor hasn’t been started yet,
    then you can’t activate the motor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Process the action or computation using the data from the request if needed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fill in the appropriate field for the response. It’s not mandatory to fill in
    all the fields. If you omit some of them, default values will be used (`0` for
    numbers and `""` for strings).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return the response. This is quite an important step that many people forget
    at the beginning. If you don’t return the response, you will get an error at runtime.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All you must do now is build your package where the node is, source, and run
    the node.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run the **number_counter** node, you’ll see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The service server has been started within the node, but of course, nothing
    will happen as you need to send a request from a client to try the server.
  prefs: []
  type: TYPE_NORMAL
- en: That’s what we will do in a minute, but before that, let’s learn how to write
    the service server in C++. If you don’t want to learn ROS 2 with C++ for now,
    you can skip this and go to the next section in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a C++ service server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s add a service server inside our C++ **number_counter** node using the
    same name and interface that we used for the one we created with Python. The process
    is the same: import the interface, create a service server, and add a callback
    function.'
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned previously in this book, make sure you follow all C++ explanations
    while keeping the GitHub code open on the side.
  prefs: []
  type: TYPE_NORMAL
- en: Importing a service interface
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, since we’ll have a dependency on **my_robot_interfaces**, open the **package.xml**
    file of the **my****_cpp_pkg** package and add the following one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, open the **number_counter.cpp** file and include the **ResetCounter**
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: To import a service interface in C++, you must use **#****include "<package_name>/srv/<service_name>.hpp"**.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'As a reminder, for this `include` to be recognized by VS Code, make sure you
    add the following to the `c_cpp_properties.json` file, in the `.vscode` folder
    that was generated when you opened VS Code: `"/home/<user>/ros2_ws/install/my_robot_interfaces/include/**"`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'After this, I added an extra line with the **using** keyword so that we can
    just write **ResetCounter** in the code, instead of **my_robot_interfaces::srv::ResetCounter**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This will help us make the code more readable. With C++, you can quickly end
    up with very long types that almost take more than one line to write. Since we
    will need to use the service interface quite often, adding this **using** line
    is a best practice to keep things simple.
  prefs: []
  type: TYPE_NORMAL
- en: I didn’t do it previously with **example_interfaces::msg::Int64** when we worked
    on topics, but if you want, you can also write **using Int64 = example_interfaces::msg::Int64;**
    and then reduce the code for the subscriber.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a service server to the node
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we’ve included the interface, let’s create the service server. We
    will store it as a private attribute in the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we use the **rclcpp::Service** class, and then, as always, we
    make it a shared pointer with **::SharedPtr**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can initialize the service in the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: To create the service, we must use the **create_service()** method from the
    **rclcpp::Node** class. As for Python, we need to provide the service interface,
    the service name, and a callback to process the incoming requests. For **_1**
    and **_2** to work, don’t forget to add **using namespace** **std::placeholders;**
    beforehand.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the callback method, including the code to validate the request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the callback, we receive two arguments—the request and the response. Both
    are **const** shared pointers.
  prefs: []
  type: TYPE_NORMAL
- en: What we do in this callback is the same as for Python. The biggest difference
    here is that we don’t return anything (in Python, we had to return the response)
    as the return type for the callback is **void**.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can build the package to compile and install the node. However, before
    we run **colcon build**, we have to modify the **CMakeLists.txt** file of the
    **my_cpp_pkg** package. Since we have a new dependency on **my_robot_interfaces**,
    we need to link the **number_counter** executable with that dependency.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, add a line under all the **find_package()** lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add **my_robot_interfaces** to the **ament_target_dependencies()** function,
    for the **number_counter** executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: For every new dependency you’re using in this executable, you will have to link
    to it before you build.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you forget about this, then you will get this kind of error when you run
    **colcon build**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Now you can build the C++ package, source, and run the **number_counter** node.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We are now at the same point as when we finished the Python service server.
    The next step is to try the service server. To do that, we need a service client.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a service client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For service communication to work, you need a service server and a service client.
    As a reminder, you can only have one service server but multiple clients.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve finished our service server inside the **number_counter** node.
    Now, let’s create a service client inside another node so that you can try the
    service.
  prefs: []
  type: TYPE_NORMAL
- en: Where will you write the code for the client? In a real application, you will
    create a service client in a node that needs to call the service. In terms of
    the battery and LED example from the beginning of this chapter, the LED panel
    node contains a service server. The battery node, which is responsible for monitoring
    the battery state, contains a service client that can send some requests to the
    server.
  prefs: []
  type: TYPE_NORMAL
- en: Then, when to send a request depends on the application. With the previous example,
    we decided that when the battery gets full or empty, we use the service client
    inside the node to send a request to the server so that we can turn an LED on/off.
  prefs: []
  type: TYPE_NORMAL
- en: 'To keep things simple for now, we will create a new node named **reset_counter_client**.
    This node will only do one thing: send a request to the service server and get
    the response. With this, we will be able to focus only on writing the service
    client. As usual, we’ll start with Python and then see the C++ code as well.'
  prefs: []
  type: TYPE_NORMAL
- en: Writing a Python service client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new file, named **reset_counter_client.py**, inside the **my_py_pkg**
    package. Make this file executable. The file should be placed with all the other
    Python files you created previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the file and start by importing the interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In the node’s constructor, create a service client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: To create a service client, we use the **create_client()** method from the **Node**
    class. We need to provide the service interface and service name. Make sure you
    use the same name and interface you defined in the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, to call the service, we create a new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the steps to make a service call:'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure the service is up and running with `wait_for_service()`. This function
    will return `True` as soon as the service has been found, or return `False` after
    the provided timeout, which is `1.0` seconds here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a request object from the service interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fill in the request fields.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Send the request with `call_async()`. This will give you a Python `Future` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Register a callback for when the node receives the response from the server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To process the response from the service, add a callback method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In the callback, we get the response with **future.result()**, and we can access
    each field of the response. In this example, we simply print the response with
    a log.
  prefs: []
  type: TYPE_NORMAL
- en: So, what’s going to happen? After you send the request with **call_async()**,
    the server will receive and process the request. Upon completion of the task,
    the server will return a response to the node where the client is. When the client
    node receives the response, it will process it in the callback that you’ve written.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You might be wondering, why do we need a callback? Why can’t we just wait for
    the response in the same method where we send the request? That’s because if you
    block this method (or in other words, this thread), then the node won’t be able
    to spin. If the spin is blocked, then any response you get for this node won’t
    be processed, and you have what is called a deadlock.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only thing left to do is call the **call_reset_counter()** method. If we
    don’t call it, nothing will happen. In a real application, you would call this
    method whenever you need it (it could be from a timer callback, a subscriber callback,
    and so on). Here, to make a test, we just call the method after creating the node,
    and before spinning, in the **main()** function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The service client will send a request and register a callback for the response.
    After that, the **call_reset_counter()** method exits, and the node starts to
    spin.
  prefs: []
  type: TYPE_NORMAL
- en: That’s it for the code. You can use this structure for the client (one method
    to send the request and one callback to process the response) in any other node.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s test the client/server communication.
  prefs: []
  type: TYPE_NORMAL
- en: Running the client and server nodes together
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create an executable in the **setup.py** file named **reset_counter_client**,
    for example.
  prefs: []
  type: TYPE_NORMAL
- en: Then, build the workspace and open three Terminals. In Terminals 1 and 2, start
    **number_publisher** and **number_counter**. The latter will start the **reset_counter**
    service server.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Terminal 3, start the **reset_counter_client** node. Since we want to reset
    the counter to 20, if the counter inside the **number_counter** node is less than
    20 at the moment of sending the request, you will get the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'If the counter is 20 or more, you will get the following response instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, just after you start the node, the client sometimes needs a bit of time
    to find the service. In this case, you might see this log as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'On the server side (the **number_counter** node), if the counter is being reset,
    you will see this log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'With that, we have tested two cases: when the counter is less than the requested
    reset value and when the counter is more than the requested reset value. If you
    want, you can also test the third case: when the requested reset value is lower
    than 0.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve finalized the client/server communication between the two nodes,
    let’s switch to C++.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a C++ service client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The C++ code follows the same logic as the Python code.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we include the interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we add a few **using** lines to reduce the code later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we declare the service client as a private attribute in the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'After, we initialize the client in the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, as we did for Python, we add a method to call the service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: In this method, we wait for the service (don’t forget the exclamation mark in
    front of **client->wait_for_service(1s)**), create a request, fill in the request,
    and send it with **async_send_request()**. We pass the callback method as an argument,
    which will register the callback when the node is spinning.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the callback method for the response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, to be able to send a request, we call the **callResetCounter()** method
    just after creating the node, and before spinning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Now, create a new executable in **CMakeLists.txt**. Build the package, open
    a few Terminals, and start the **number_publisher** and **number_counter** nodes.
    Then, start the **reset_counter_client** node to try the service communication.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve written the code for both the service server and client, let’s
    explore what you can do with the ROS 2 tools. For services with a simple interface,
    you will be able to test them directly from the Terminal, even before writing
    the code for a client.
  prefs: []
  type: TYPE_NORMAL
- en: Additional tools to handle services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve already used the **ros2** command-line tool a lot in this book. With this
    tool, each core ROS 2 concept gets additional functionalities in the Terminal.
    This is no exception for services.
  prefs: []
  type: TYPE_NORMAL
- en: We’re now going to explore **ros2 service** a bit more so that we can introspect
    services and send a request from the Terminal. We will also learn how to change
    a service name at runtime (**ros2 run**).
  prefs: []
  type: TYPE_NORMAL
- en: To see all commands for ROS 2 services, type **ros2** **service -h**.
  prefs: []
  type: TYPE_NORMAL
- en: Listing and introspecting services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, **rqt_graph** does not support services (yet—there are plans to maybe
    add this in a future ROS 2 distribution), so we won’t use it here. We will only
    use the **ros2** command-line tool.
  prefs: []
  type: TYPE_NORMAL
- en: 'Stop all nodes and start the **number_counter** node. Then, to list all services,
    run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: For each node you start, you will get seven additional services, mostly related
    to parameters. You can ignore those. If you look at the list, apart from those
    seven services, we can retrieve our **/****reset_counter** service.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Note that there is an additional leading slash in front of the service name.
    Service names follow the same rules as nodes and topics. If you don’t provide
    any namespace (for example, `/abc/reset_counter`), you’re in the “global” namespace,
    and a slash is added at the beginning.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have the service name you want, you can get the service interface
    with **ros2 service** **type <service_name>**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'From this, you can see the details inside the interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This process is extremely useful when you need to create a service client for
    an existing server. There’s no need to even read the server code—you can get all
    the information you need from the Terminal.
  prefs: []
  type: TYPE_NORMAL
- en: Sending a service request
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To test a service server, you usually have to write a service client.
  prefs: []
  type: TYPE_NORMAL
- en: 'Good news: instead of writing a client, you can call the service from the Terminal
    directly. This can save you some development time.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you must know the service name and interface. Then, use the **ros2 call
    <service_name> <interface_name> "<request_in_json>"** command. Let’s try this
    with our **reset_counter** service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: You can see the request being sent, followed by the response. Then, the command
    exits. This is practical and in this case, we save a lot of time.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also easily test the different cases. For example, let’s send a negative
    value for the reset number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: With this example, it’s quite easy as the request is very simple (only one integer
    number). For more complex service requests that contain lots of nested fields
    and arrays, writing the full request in the Terminal can become quite cumbersome,
    and you will spend a lot of time trying to get it right.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, for simple interfaces, use **ros2 service call** to try the service first.
    For more complex interfaces, you’ll have to write a client code first. This isn’t
    really a problem: you can use the code we used for **ResetCounterClientNode**
    as a template for any other client. In the end, both methods allow you to test
    a service server quite quickly.'
  prefs: []
  type: TYPE_NORMAL
- en: Changing a service name at runtime
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you start a node with **ros2 run**, you can change the node name and any
    topic name inside the node. You can do the same for services.
  prefs: []
  type: TYPE_NORMAL
- en: As a reminder, for any additional argument you pass after **ros2 run**, add
    **--ros-args**, but only once.
  prefs: []
  type: TYPE_NORMAL
- en: Then, to rename a service, add **-r** followed by **<service_name>:=<new_service_name>**.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let’s rename the **reset_counter** service to **reset_counter1**
    when we start the **number_counter** node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s verify this with **ros2** **service list**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The service name is now **/reset_counter1**. If we start a node with a service
    client, we need to modify the name as well; otherwise, the nodes won’t be able
    to communicate with each other:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Doing this is quite useful, especially when you want to run several nodes (written
    by yourself or others) that use a slightly different service name, or that are
    in different namespaces.
  prefs: []
  type: TYPE_NORMAL
- en: You are now able to write a service server/client and introspect/test them from
    the Terminal. Before moving on to the next chapter, let’s practice more with an
    additional challenge.
  prefs: []
  type: TYPE_NORMAL
- en: Service challenge – client and server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With this new challenge, you will practice everything that was covered in this
    chapter: custom service interfaces, service servers, and service clients.'
  prefs: []
  type: TYPE_NORMAL
- en: We will use the **turtle_controller** node we wrote in the previous chapter’s
    challenge as a starting point. We won’t create a new node here; instead, we will
    improve the existing code. You can either start from the code you wrote or from
    the code I provided in the **ch5** folder of this book’s GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: As always, I will explain what you need to do to complete the challenge, and
    then detail the most important points for the Python solution. You can find the
    complete solution code on GitHub for both Python and C++.
  prefs: []
  type: TYPE_NORMAL
- en: Challenge
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This challenge is divided into two parts. I suggest following them in order.
  prefs: []
  type: TYPE_NORMAL
- en: Challenge 1 – service client
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So far, our **turtle_controller** node is subscribing to the **/turtle1/pose**
    topic. In the subscriber callback, we send a velocity command to the **/****turtle1/cmd_vel**
    topic.
  prefs: []
  type: TYPE_NORMAL
- en: The result of this is the turtle drawing a circle on the screen, with a different
    velocity depending on if it is on the right or left of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: What we want to do now is change the color of the pen, depending on where the
    turtle is. If the turtle is on the right of the screen, we want the pen color
    to be red. On the left, the color should be green.
  prefs: []
  type: TYPE_NORMAL
- en: To do that, we will need to add a service client in the node so that we can
    call the service to change the pen’s color in the **turtlesim** node (I won’t
    give you the service name—that’s part of the challenge).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the steps you can take to get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start the `turtlesim` node and use the `ros2 service` command line to find
    which service to call, as well as what interface to import (optional: at that
    point, you can also test the service with `ros2 service call`, directly from the
    Terminal).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `turtle_controller` node, add a service client for that service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a method that will call the service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call this method from the existing subscriber callback. After you publish the
    new command velocity, check whether the turtle is on the right or left of the
    screen. When the turtle switches to a different side, call the service with the
    updated color.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Challenge 2 – custom interface and service server
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once you’re done with the first challenge, try this one. This time, you’ll practice
    on the server side of services.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we want to allow the **turtle_controller** node to activate or deactivate
    the turtle (meaning to start or stop the turtle), depending on an external request.
    For that, we will create a service server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the steps you can take to get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Define a service name and interface for that service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If no existing interface matches your needs, you will need to create and build
    a new one (hint: that’s what we will do here).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `turtle_controller` node, add a service server and a callback, in which
    you activate or deactivate the turtle. Tip: you can use a simple boolean attribute
    in the class to store the activated state for the turtle.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the turtle is activated, then in the subscriber callback, you can keep sending
    additional velocity commands. If it is not activated, you don’t send any commands.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With those instructions, you should be able to get started. Taking the time
    to do this exercise is probably the best investment you can make to learn ROS
    faster.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s start with the first challenge.
  prefs: []
  type: TYPE_NORMAL
- en: Challenge 1
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For this challenge, we are on the client side, which means that we need to find
    out which service we need to call. I will do a quick recap of the steps for finding
    the service name and interface.
  prefs: []
  type: TYPE_NORMAL
- en: Start the **turtlesim** node and list all services. You should see a **/turtle1/set_pen**
    service with **ros2** **service list**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, get the type for this service and see what’s inside the interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: In the service request, we can send an (**r**,**g**,**b**) value (red, green,
    blue). There are also **width** and **off** attributes, but we won’t use them.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, before you even write the code for the client, you can try the
    service from the Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Then, execute **ros2 run turtlesim turtle_teleop_key** and move the turtle around.
    You’ll see that the pen is now using a red color.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back to the code, inside the **turtle_controller.py** file, import the interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Since we’ve already added the dependency for **turtlesim** in the **package.xml**
    file of the **turtle_controller** package (in the previous chapter), there’s no
    need to do it again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, create the service client in the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Write the method that will call the service, as well as the callback for the
    response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: We only send the **r**, **g**, and **b** parts of the request. The other values
    (**width** and **off**) will be kept as-is.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, in the callback for the response, we don’t check what’s inside
    the response since the response is empty (it exists but it doesn’t contain a field).
  prefs: []
  type: TYPE_NORMAL
- en: The only thing we need to do now is call this new **call_set_pen()** method.
    We will do that from within the subscriber callback since this is where we have
    access to the *X* position of the turtle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the **callback_pose()** method, and after the code to publish on the
    topic, add the code to handle the pen color:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: If the turtle is on the right, we set the color to red (**255, 0, 0**), and
    if it’s on the left, we set the color to green (**0,** **255, 0**).
  prefs: []
  type: TYPE_NORMAL
- en: 'On top of that, we also define a new attribute in the constructor so that we
    can keep track of the previous *X* coordinate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: We use this to only call the service when the turtle switches from one side
    to the other. Why do we do that? We could send a service request every time, even
    if the color would be the same as the previous one. Why “optimize” the code?
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason is that the **callback_pose()** method will be called a lot. Check
    the frequency for the **/turtle1/pose** topic in the Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: This means that we execute **callback_pose()** about 62 times per second. This
    is not really a problem. We also publish on the **/turtle1/cmd_vel** topic at
    62 Hz. Again, that’s not a problem. Publishers and subscribers can sustain a high
    frequency (with a bigger message size, this could become complicated, but here,
    the messages are really small).
  prefs: []
  type: TYPE_NORMAL
- en: Now, what if we send a request to a service 62 times per second? This is where
    the problem is. Services are not made for high-frequency requests, and this could
    seriously affect the performance of the application. Also, if you find yourself
    having to call a service at 62 Hz, then you probably have a design problem, and
    you either need to modify your code to reduce the frequency or use a publish/subscribe
    mechanism instead.
  prefs: []
  type: TYPE_NORMAL
- en: So, what we do in the code is make sure we only call the service when it’s needed—that
    is, when the turtle switches from one side to the other.
  prefs: []
  type: TYPE_NORMAL
- en: The code is now complete! At this point, you can build your **turtle_controller**
    package again (unless you have already built it with **--symlink-install**), source
    the environment, and then start both the **turtlesim** and **turtle_controller**
    nodes to see the result.
  prefs: []
  type: TYPE_NORMAL
- en: Challenge 2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, we want to add a service server inside our node so that we can activate
    or deactivate the turtle. Since we’re defining the server, we need to come up
    with a name and an interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '`activate_turtle`. We’ll start with a verb and try to make the name as explicit
    as possible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SetBool` service from `example_interfaces`. It contains a boolean in the request
    and a string in the response. However, as stated previously, the best practice
    is to avoid using the `std_srvs` and `example_interfaces` packages if your application
    is any serious. So, in this case, we’ll create our own interface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s create a new interface for our service. This will be quite quick and easy
    as we already have the **my_robot_interfaces** package fully configured.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the **srv** folder of the **my_robot_interfaces** package, create a
    new service file named **ActivateTurtle.srv**. In this file, write the service
    definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'This is all we need in the request: a boolean to activate or deactivate the
    turtle. We also added a string in the response so that we get to know what happened,
    but you could also decide to have an empty response.'
  prefs: []
  type: TYPE_NORMAL
- en: 'After this, add the interface to the **CMakeLists.txt** file of the **my_robot_interfaces**
    package, and build the package. Source the environment, and make sure you can
    see the interface with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Now, let’s go back to the **turtle_controller** package.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we will have a dependency on **my_robot_interfaces**, add a new line
    to the **package.xml** file of the **turtle_controller** package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it’s time to write the code inside **turtle_controller.py**. Import the
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'In the constructor, add a boolean flag to keep track of the activated status
    for the turtle, and create a new service server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the callback method for that service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: What we do is simple—we just set the **is_active_** boolean with the value we
    get from the boolean in the request. Now, whenever you call this service, the
    **is_active_** boolean will be updated with the value you send.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last step, to make the turtle start or stop when activated or deactivated,
    is to modify the code inside the **callback_pose()** method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: This way, we only publish a new command velocity if the turtle is activated.
    If not, we publish nothing. Also, the service request will only work when the
    turtle is activated.
  prefs: []
  type: TYPE_NORMAL
- en: 'To try this new service, start the **turtlesim** node and **turtle_controller**
    nodes. In a third Terminal, send a service request with the **ros2** command-line
    tool. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'This should make the turtle stop. You can send a request again, this time with
    **"{activate: true}"**, which should make the turtle move again.'
  prefs: []
  type: TYPE_NORMAL
- en: That’s the end of this challenge on services. If you managed to finish this
    challenge by yourself, you have a good understanding of services. No worries if
    you couldn’t do it without having to look at the solution. Come back to it in
    a few days and see if you can solve the challenge again.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you worked on ROS 2 services, which is another ROS 2 communication
    you can use alongside topics.
  prefs: []
  type: TYPE_NORMAL
- en: With services, nodes can talk to each other using a client/server type of communication.
    Only one server can exist for a service, but you can send multiple requests from
    several clients.
  prefs: []
  type: TYPE_NORMAL
- en: You can implement service servers and clients directly in your nodes using **rclpy**
    for Python and **rclcpp** for C++.
  prefs: []
  type: TYPE_NORMAL
- en: 'To write a service server, you must do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: As the name and interface are defined by the server, you have to choose them
    here. As a best practice, use a verb as the first word in the name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import the interface in your code and create the service server in the constructor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a callback method to process any received request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When choosing a service interface, if you can’t find an existing one that perfectly
    matches what you need, then you have to create and build your own. To do that,
    you must do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create and set up a package dedicated to interfaces. If you already have one
    for your application, use it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the new service interface to the package and build it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, you can use this interface in your service server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To write a service client, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: If you’re writing a client, it means that there is an existing server on the
    other side. Find which name and interface you need to use.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import the interface into your code and create the service client in the constructor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a method to call the service. In this method, you send the request asynchronously,
    and then register a callback to process the response.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can call the service from anywhere in your code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the **ros2 service** command line, you can introspect the services in your
    nodes and see what interface they’re using.
  prefs: []
  type: TYPE_NORMAL
- en: To try a service server, you can either write a corresponding service client
    inside another node or, if the request is simple, call the service directly from
    the Terminal with **ros2** **service call**.
  prefs: []
  type: TYPE_NORMAL
- en: 'You have now seen the two most common ROS 2 communication types: topics and
    services. In the next chapter, we will work with the third and last one: actions.'
  prefs: []
  type: TYPE_NORMAL
