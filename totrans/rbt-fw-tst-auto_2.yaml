- en: Chapter 2. Configuring a Test Project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, exclusive focus is on the structure and files contained in
    test. The topic has already been touched upon briefly in the first chapter, but
    a closer look at them would help set the background for further exploration as
    tests are the most important feature of the Robot Framework. The following major
    topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Robot Framework test file and a testsuite.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding differences in syntax across different file formats used in configuration.
    Gaining knowledge about the different configuration files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding and utilizing setup and teardown operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increasing automation through test re-use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will start by explaining, what a test is and how it can be defined. Different
    type of tests and common naming conventions along with examples will be explained
    thereafter. Test file structure and their supported formats will be understood
    by the end of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The Robot Framework makes it very easy to change the test configuration used
    in a project once the project has properly been set up. However, it is best to
    understand what tests really are, and how should they be organized before diving
    deep into specific implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to the development of conventional software, tests can either be created
    in top-down manner with the big picture upfront or a bottoms-up approach, where
    the tests are created first and integrated later.
  prefs: []
  type: TYPE_NORMAL
- en: In the Robot Framework, you are encouraged to follow the top-down approach where
    the test structure is created first, before creating and writing down the actual
    implementation. While this is not enforced, it is useful towards writing big and
    sustainable tests and is the recommended way of creating a test.
  prefs: []
  type: TYPE_NORMAL
- en: Tests are organized in a tree-style structure that consists of testsuite, testcase,
    and testaction. This convention has been followed in most of the structured testing
    and is a widely followed convention. A testsuite is a collection of different
    tests and other testsuites, and provides a logical unit for a set to perform tests.
    A testcase is a complete test for a particular task. A testaction is the smallest
    element in any test and is atomic in nature, which only validates a given condition.
  prefs: []
  type: TYPE_NORMAL
- en: Test naming conventions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Test naming conventions are important for the standardization and coherence
    of the tests. It also indicative of the quality of tests as the naming and placement
    of tests; and the use case scenarios indicate their order and relevance, which
    can be very useful when the tests are maintained in future.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an execution order
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to name tests, the Robot Framework is very peculiar; it uses the configuration
    file and folder names to determine the execution order and test naming.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider the following arrangement of different test files and
    folders in the test project in the file system:'
  prefs: []
  type: TYPE_NORMAL
- en: application/
  prefs: []
  type: TYPE_NORMAL
- en: '`tests/`'
  prefs: []
  type: TYPE_NORMAL
- en: '`Test1.txt`'
  prefs: []
  type: TYPE_NORMAL
- en: '`Other tests/`'
  prefs: []
  type: TYPE_NORMAL
- en: '`Another test.txt`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the pybot in the application folder will result in creation of different
    testsuites in the report based on the order of their presence in the file system.
    The following screenshot shows the file structure of a Robot Framework test:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating an execution order](img/3033OS_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'After running, the tree command lists out the file/folder hierarchy. Here,
    the Robot Framework will infer the test hierarchy, group the tests, and nest test
    suites in form of files and folders. From this example, you can observe the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `testsuites` folder will be the root test suite.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The folders such as `1__first_test` beneath the `testsuites` folder will act
    as nested test suites.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The test files contained within these folders will be the further nested test
    suites.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, tests contained in `testsuites/2__different_file_formats/2__a_tsv_file_test.txt`
    will be nested, which can better be explained from the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating an execution order](img/3033OS_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Test suite hierarchy is detailed in the log file. In order to organize the results,
    it is important to ensure proper naming. So, instead of using spaces, underscore
    "_" should be used (as demonstrated in the preceding example).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to get proper ordering irrespective of the test names, prefixing the
    test configuration with numbers can be done.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test randomization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sometimes, there may be requirement to explicitly disregard the execution order
    and run tests in random order. In that case, you can use the randomize option
    in the pybot command. This has the following options:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To randomize all the test suites as well as the tests contained within them:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To randomize suites without affecting the tests contained within the lowest
    level suite:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To randomize only the tests within the suites, the suite execution order is
    unchanged:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To remove any randomization, if set in the command line:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The command arguments are read from left to right, and randomize option can
    come more than once.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In case of applying proper naming conventions like the following example, the
    example''s test hierarchy will result in more understandable tests and the execution
    order of the tests can be easily predetermined. You can now easily infer the order
    of execution and hierarchy that will be present in the following order:'
  prefs: []
  type: TYPE_NORMAL
- en: '`application/`'
  prefs: []
  type: TYPE_NORMAL
- en: '`testsuites/`'
  prefs: []
  type: TYPE_NORMAL
- en: '`1__Software_initialization.txt`'
  prefs: []
  type: TYPE_NORMAL
- en: '`2__main_screen_checks.txt`'
  prefs: []
  type: TYPE_NORMAL
- en: '`3__test_aux_controls/`'
  prefs: []
  type: TYPE_NORMAL
- en: '`1__check_user_details.txt`'
  prefs: []
  type: TYPE_NORMAL
- en: '`2__check_aux_control.txt`'
  prefs: []
  type: TYPE_NORMAL
- en: '`4__check_values/`'
  prefs: []
  type: TYPE_NORMAL
- en: '`1__primary_values.txt`'
  prefs: []
  type: TYPE_NORMAL
- en: '`2__footer.txt`'
  prefs: []
  type: TYPE_NORMAL
- en: '`3__links_to_other_controls.txt`'
  prefs: []
  type: TYPE_NORMAL
- en: '`....`'
  prefs: []
  type: TYPE_NORMAL
- en: It is noteworthy that the only exception to this naming rule is in form of initialization
    files, which are named as `__init__` followed by the extension as used in other
    test files. As there is only one `init` file per folder, it is clear that such
    a file contains information about its folder and the information contained in
    it pertains to the test suite itself.
  prefs: []
  type: TYPE_NORMAL
- en: Test file structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, it has been demonstrated that whitespaces play an important role in
    configuration files. The test configuration is written in a tabular format with
    each column having separate elements such as test element. The Robot Framework
    allows flexibility in specifying the separations among the different columns in
    a test file as well as supporting different formats for the test files, which
    you can choose at your discretion. Note that depending upon the file extension;
    a suitable parser is selected during runtime. Some of the supported formats are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: HTML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TSV
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plaintext
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Piped text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RestructuredText
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTML format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In an HTML format, the HTML is read, which comprises of different tables for
    different portions of the test configuration. For each table, the first heading
    element is read and based on this information; the rest of the table is understood.
    A word of caution! Any data that is outside the recognized table is discarded.
    You can understand this better with the help of following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: Note that in the first column of table heading denotes the table name and it
    decides the subsequent execution of all elements contained in that table. This
    is followed by other headings that signify the position and order of other data.
    The rest of table contents populate the desired information in the specified order.
    Here, instead of delimiting the data by two spaces, it is present in different
    columns of the table. This method needs most overhead and verbose metadata, but
    the tests are very viewer-friendly and confusion of how much space to keep is
    also reduced as you can view these files easily in web browsers as well as edit
    in HTML editors.
  prefs: []
  type: TYPE_NORMAL
- en: TSV format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the tab separated value format, one can specify the different columns by
    passing the values separated by single tabs. One of the astounding features of
    this format is that it can be opened in any spreadsheet application, which gives
    you and other users greater control over the test configuration files. If the
    text editor in use supports viewing of whitespace (spaces and tabs), then it is
    a good idea to enable it in order to keep the tab separated test without any errors,
    as users can invariably mix the two, causing the tests to malfunction. Another
    appropriate way to create and maintain these tests is to use the spreadsheet application
    alone, which will reduce the chances of corrupting the test. On a spreadsheet
    (as shown in the following screenshot), the test file is more natural and intuitive
    to use as the columns are properly differentiated. If you are having prior experience
    in developing spreadsheet solutions but are new to the Robot Framework, your learning
    curve is considerably reduced and you may feel at ease while writing and maintaining
    tests in spreadsheets, which can also be formatted for better visibility and ease
    of use.
  prefs: []
  type: TYPE_NORMAL
- en: '![TSV format](img/3033OS_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Plaintext format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If test configuration file display is not an issue, then plaintext file is the
    best option as it is most readable and contains much less metadata, which makes
    version control easier. This method is the most widely used in this framework.
    However, you have to take care to ensure that the elements are properly separated
    and the column elements are delimited by two whitespace characters. If the arguments
    used in tests are small and have limited columns, then this is the appropriate
    display format. The syntax and placement of the elements in this way first require
    some acclimatization, but it becomes easier to create and modify test cases in
    this format as you do not need anything apart from a text editor for creating
    and updating the tests. Since the whitespaces need to be at least two or more,
    there is no way that more than a single empty column can be left in place. This
    might not seem problematic, but is quite handy, especially in situations where
    there is a need to provide for explicit whitespace separation for more than a
    single column.
  prefs: []
  type: TYPE_NORMAL
- en: Pipe-separated format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Very closely resembling the previous format is the pipe separated format that
    uses pipe characters within the document to delimit the different columns. This
    is used where different lines contain varying number of arguments that are hard
    to spot. Consider the following snippet of a test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The verbosity of the test, in this case, makes it harder to read and understand
    the test. Even worse, if someone is modifying it, he can introduce errors by accident.
    For instance, the documentation has been updated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If you observe the whitespace at the end of `[Documentation]`, there is only
    a single space, which clubs both the `Documentation` keyword and its argument
    into one and the Robot Framework cannot understand this, causing it to fail.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to rectify in the same text file itself, the Robot Framework offers
    the flexibility to use a pipe symbol ( `|` ) instead of two spaces. Barring the
    first character of line, this symbol is surrounded by spaces on both sides, so
    the preceding test becomes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This is more readable as the columns are now separated by the pipe. Note that
    the ending pipe at third line is not present as placement of pipe at the end of
    last column at any line is optional. If required within any column as a normal
    text, the pipe can be escaped using the backspace character. The escape string
    being (`\|`). Another advantage that this format offers over the plaintext format
    is that multiple columns can explicitly be declared empty and the test can still
    run correctly. This coupled with specific placement of the text in exactly the
    desired columns leads to creation of tests having very specific structure. Pipelines
    are also required to nest test structure in the presence of loops within the tests,
    which is similar to the indentation found in Python programming but is impossible
    in the Robot Framework as more than two whitespaces do not constitute an empty
    column or an indent in the test code (more on this later while discussing iteration
    within tests).
  prefs: []
  type: TYPE_NORMAL
- en: Restructured text format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **ReStructuredText** (**reST**) text format is familiar with any Python
    developer as it is used in Python documentation. It is a plaintext based markup
    that can easily be used to create highly formatted documents, tables, and so on
    using only a simple text file and a predefined set of markers. The advantage that
    it offers is very lesser metadata is used and the file contains majority of text
    that can easily be version controller, edited, differentiated, and well as searched.
    The rest mark-up offers advantages of both the HTML as well as plaintext file.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to the HTML format, the test data is defined within tables and the Robot
    Framework looks up for the first element of the table to determine whether or
    not the table is a valid test table and, if this is correct, then its type is
    determined and the rest of the elements are processed accordingly. In this format,
    empty cells in the first column need to have a `\` or a `..` symbol.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As tools to process rest markup are part of the docutils project, you will need
    to have Python docutils module installed in the Python instance that is executing
    the tests. The Robot Framework internally converts the rest files into HTML documents
    and in case of problems with this format; other tools can be used to convert rest
    structured documents into HTML, which can be used to run the tests.
  prefs: []
  type: TYPE_NORMAL
- en: This is the flexibility of the Robot Framework, which allows you to have different
    file formats and structures. There is more to such flexibility in the style of
    writing tests, which will be covered in further chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Test configuration files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned before, the tests are stored in files and are clubbed in folders
    that act as test suite for the files. A test file can contain different sections,
    which can optionally be moved into other files dedicated specifically towards
    the work of that particular section. Thus reducing the length and complexity of
    the actual test file, which is helpful if the test size is very large.
  prefs: []
  type: TYPE_NORMAL
- en: 'The test configuration files apart from the actual test files and folders are:'
  prefs: []
  type: TYPE_NORMAL
- en: Suite initialization files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A folder in the Robot Framework denotes a test suite for all the files and subfolders
    contained in it. As there is no way to specify metadata of the test suite except
    for the folder name, there is a provision for special files that pertain to the
    folder in which they are placed. As with specifying a directory as a module in
    Python, initialization files have to be named as `__init__` and their extension
    can be any valid extensions allowed by the Robot Framework. The format of these
    files is the same as test case files, but apart from few exceptions, the test
    case options are not allowed.
  prefs: []
  type: TYPE_NORMAL
- en: The configuration specified here overlaps with the allowable configuration in
    test case files as well in case of defining tags, setup, and teardown actions
    as well as test case timeouts. However, the changes overridden in these files
    are applicable to the entire test suite in which this initialization file exists.
  prefs: []
  type: TYPE_NORMAL
- en: 'One setting that deserves a considerable mention is the presence of suite `setup`
    and `teardown`. These only get executed once before and after the execution of
    all the tests present in the given test suite as well as in any sub-test suites
    as well. Also, if there are any sub test suites within the test suite, then the
    initialization files of these will be run likewise too. An example for this could
    be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`| Setting | Value | Value |`'
  prefs: []
  type: TYPE_NORMAL
- en: '`| Documentation | suite init file |`'
  prefs: []
  type: TYPE_NORMAL
- en: '`| Suite Setup | Log | This is the setup method for the entire suite |`'
  prefs: []
  type: TYPE_NORMAL
- en: '`| Force Tags | example |`'
  prefs: []
  type: TYPE_NORMAL
- en: '`| Suite Teardown | Log | This suite has ended |`'
  prefs: []
  type: TYPE_NORMAL
- en: External variable files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These are the files that contain the variables used in the test cases. The main
    purpose of specifying the variables in an external file is to follow the **DRY**
    (**Don't Repeat Yourself**) principle to minimize duplication as well as make
    changes into the variables at a single place without changing the rest of the
    test. These files provide the variables that they create to other files that require
    variable information, which is different from the variable section of the test,
    or the variable table which is only applicable for the test case in which it is
    defined.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that variable names are case-sensitive. In order to differentiate between
    variables and other keywords, keep in mind that generally the variables are kept
    in uppercase but there is no such rule.
  prefs: []
  type: TYPE_NORMAL
- en: The variables are defined as `${Variable Name}` for normal, single-valued variables
    and as `@{Variable Name}` for a variable containing a list of different values.
  prefs: []
  type: TYPE_NORMAL
- en: In a test configuration file, when only the variable table is specified, then
    the test file becomes a variable file and on its usage, only the table starting
    with variables will be considered.
  prefs: []
  type: TYPE_NORMAL
- en: Structure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A variable file can typically store a large amount and type of variables. For
    example a variable file can have the following structure that declares various
    types of variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Python/Java files containing variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The variables can also be created in a Python or a Java file as in certain cases
    a Python or a Java class might need to save some dynamic data value at runtime,
    which can be passed to the tests in need. Only restrictive thing is that the python
    class name should be the same as its module and the Java class must not be in
    any kind of package. The easiest way to do this is to place the Python/ Java source
    in the same location as the test file itself (but is not recommended if you are
    having a separate application or a large number of tests/scripts). If you need
    to refer some value from external service or application, then the source file
    used can be referred to populate its variables which can be used in the tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, a hash can be set/modified as variable in the Python file as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'And in a Java file it can be modified as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, it can be used in the tests as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Just as with any other variable defined in the test itself the variables specified
    in these programs can be used.
  prefs: []
  type: TYPE_NORMAL
- en: In a similar manner, there is a provision for getting variables from a special
    function in the Python/Java code as `get_variables`/`getVariables`. The variables
    have to be prefixed with `LIST` keyword failing, which they will be assumed as
    scalars and can only have a single value.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The variables as well as function setting these variable are visible to the
    Robot Framework tests if they have default or higher scope in the classes.
  prefs: []
  type: TYPE_NORMAL
- en: While the variable defined in Java is usable only with Jython runtime, one can
    use the Python file in any Robot Framework runtime, as all runtimes basically
    descend from Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the variables present in a resource file into a test case, variables
    keyword followed by the absolute or relative path to the variable file (the `.class`
    or `.py` as the case may be) can be given. And the variables defined in the variable
    file can be used as they were defined in the variables table within the file itself
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Resource files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Resource files are necessity when there is need to save the variable data as
    well as higher level user keywords. The term user keyword will be explained in
    this book later on, but it is suffice to say that a user keyword is basically
    a keyword that is not present in any library but in the same file or an external
    resource file.
  prefs: []
  type: TYPE_NORMAL
- en: Structure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The resource file cannot have test cases. Apart from this, it is the same as
    the test case file. In the actual test case file, this file will have to be imported
    by the name of Resource under the settings table. After specifying the resource,
    the file path has to be submitted, which can be absolute or relative to the test
    case in question.
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned, the resource files specify the variables and custom user keywords,
    so it contain the tables for the variable definition and keyword definition along
    with the settings table that can allow for import of some external library as
    the user keywords might be there to act as an alias for some external library.
    An example of resource file can be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The creation of keywords adds to the available syntax in the tests and inside
    the test file, this can easily be used.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Test setup and teardown
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: During testing, there is a need for performing certain tasks that have to be
    carried out at specific times during the execution of the tests. These operations
    are typically carried out before and after the tests. These are known as test
    setup and teardown (often known as pre-conditions and post-condition) and are
    present universally across different structured tests, such as unit, functional,
    and even acceptance testing.
  prefs: []
  type: TYPE_NORMAL
- en: A test setup occurs before the beginning of a test and a test teardown occurs
    after the execution of a test. It is worth mentioning that a test teardown runs
    after the test irrespective of whether it is a success or a failure. The only
    condition when it will not execute is the unconditional termination of the test,
    which occurs during a test error. These portions of test contain pre-conditions
    needed for tests such as opening of the web browser to a particular page, setting
    up a database connection and so on. And when the test gets completed, closing
    the opened connections, browsers, or resources and ensuring any further operation
    do not carry any repercussions of the actions undertaken during the tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Role of setup/teardown in automated testing are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Setup Test Environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create test environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Load initial test data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Repeat for each test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set up individual test requirements
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Perform operations and assert conditions
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Clean up resources used for test
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Summarize/save useful information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Restore environment state to its initial condition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analysis of the test execution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The setup and teardown operations can be applied to both test as well as test
    suite level. It is not applicable within the tests. If there is a need to insert
    it between different statements in the tests, there are chances that the tests
    are not written correctly and the test structure needs to be relooked and refactored
    into smaller tests and parameterized according to the requirements pertain to
    stories for individual tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Being a robust framework in itself, the Robot Framework offers the capabilities
    of using these operations under both test suites as well as individual tests.
    For test suite, one can use the initialization file and for individual tests.
    The settings table in the test file itself can be utilized that can contain test
    setup and test teardown settings or even inside the test case itself in form of
    setup and teardown action. Using `None` after specifying a condition signifies
    that particular operation is not possible. A brief overview of some feature is
    provided as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The test setup and teardown thus offer a way for us to take the repetitive portions
    of tests at a single place and do not repeat same set of instructions all over
    the place, thus setting up scene for test automation and re-use through test parameterization.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, various files involved in the Robot Framework test creation
    and configuration together with the test naming conventions for different components
    such as, test suite, test case, and test action were discussed and the execution
    order management was detailed. As the test file format is quite different from
    any other test, it was exhaustively discussed as well. The use of variables as
    well as extra files are also discussed as these promote test code re-use and separate
    the test contents. Finally, the test environment management through test setup
    and teardown was discussed, which is essential if the tests require any prior
    dependency.
  prefs: []
  type: TYPE_NORMAL
- en: This serves as the groundwork for further work over the framework and as the
    basic syntaxes mentioned here are covered, the test automation and re-use will
    be discussed in the next chapter that continues from the work that has been covered
    here in order to automate and re-use existing tests.
  prefs: []
  type: TYPE_NORMAL
