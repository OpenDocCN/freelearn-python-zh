<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Working with Class-Based Views and Hyperlinked APIs in Django 2.1</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will expand the capabilities of the RESTful API that we started in the previous chapter. We will change the ORM settings to work with a more powerful PostgreSQL 10.5 database and we will take advantage of advanced features included in <strong>Django REST Framework</strong> (<strong>DRF</strong>) that allow us to reduce boilerplate code for complex APIs, such as class-based views. We will look at the following:</p>
<ul>
<li>Use model serializers to eliminate duplicate code</li>
<li>Work with wrappers to write API views</li>
<li>Use the default parsing and rendering options and move beyond JSON</li>
<li>Browse the API</li>
<li>Design a RESTful API to interact with a complex PostgreSQL 10.5 database</li>
<li>Understand the tasks performed by each HTTP method</li>
<li>Declare relationships with the models</li>
<li>Install packages with the requirements file to work with PostgreSQL</li>
<li>Configure the database</li>
<li>Run migrations</li>
<li>Verify the contents of the PostgreSQL database</li>
<li>Manage serialization and deserialization with relationships and hyperlinks</li>
<li>Create class-based views and use generic classes</li>
<li>Take advantage of generic class-based views</li>
<li>Work with endpoints for the API</li>
<li>Browse an API with relationships</li>
<li>Create and retrieve related resources</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Using model serializers to eliminate duplicate code</h1>
                </header>
            
            <article>
                
<p>The <kbd>GameSerializer</kbd> class we coded in <a href="e8d188a7-452a-4ce2-8e00-37eeeaabb879.xhtml" target="_blank">Chapter 5</a>, <em>Developing RESTful APIs with Django 2.1</em>, declares many attributes with the same names that we used in the <kbd>Game</kbd> model and repeats information such as the field types and the <kbd>max_length</kbd> values. The <kbd>GameSerializer</kbd> class is a subclass of the <kbd>rest_framework.serializers.Serializer</kbd> superclass and it declares attributes that we manually mapped to the appropriate types, and overrides the <kbd>create</kbd> and <kbd>update</kbd> methods.</p>
<p>Now we will create a new version of the <kbd>GameSerializer</kbd> class that will inherit from the <kbd>rest_framework.serializers.ModelSerializer</kbd> superclass. The <kbd>ModelSerializer</kbd> class automatically populates both a set of default fields and a set of default ...</p></article></section></div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Working with wrappers to write API views</h1>
                </header>
            
            <article>
                
<p>Our code in the <kbd>games_service/games/views.py</kbd> file declared a <kbd>JSONResponse</kbd> class and two function-based views. These functions returned <kbd>JSONResponse</kbd> when it was necessary to return JSON data and a <kbd>django.Http.Response.HttpResponse</kbd> instance when the response was just an HTTP status code. Hence, no matter what the accepted content type that's specified in the HTTP request header, the view functions always provide the same content in the response body—JSON.</p>
<p>Run the following two commands to retrieve all the games with different values for the <kbd>Accept</kbd> request header: <kbd>text/html</kbd> and <kbd>application/json</kbd>. The code file for the sample is included in the <kbd>restful_python_2_06_01</kbd> folder, in the <kbd>Django01/cmd/cmd601.txt</kbd> file:</p>
<pre>    <strong>http -v ":8000/games/" "Accept:text/html"</strong>
    <strong>http -v ":8000/games/" "Accept:application/json"</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The following are the equivalent <kbd>curl</kbd> commands. The code file for the sample is included in the <kbd>restful_python_2_06_01</kbd> folder, in the <kbd>Django01/cmd/cmd602.txt</kbd> file:</p>
<pre>    <strong>curl -H "Accept: text/html" -viX GET "localhost:8000/games/"</strong>
    <strong>curl -H "Accept: application/json" -viX GET "localhost:8000/games/"</strong></pre>
<p>The previous commands will compose and send the following HTTP request: <kbd>GET http://localhost:8000/games/</kbd>. We have requested both <kbd>http</kbd> and <kbd>curl</kbd> to enable the verbose mode with the <kbd>-v</kbd> option in which they specify more details about the operation and display the whole request, including the request header.</p>
<p>The first command defines the <kbd>text/html</kbd> value for the <kbd>Accept</kbd> request header. The second command defines the <kbd>application/json</kbd> value for the <kbd>Accept</kbd> request header. You will notice that both commands produce the same results, and therefore, the view functions don't take into account the value specified for the <kbd>Accept</kbd> request header in the HTTP requests. The header response for both commands will include the following line:</p>
<pre>    <strong>Content-Type: application/json</strong></pre>
<p>The second request specified that it will only accept <kbd>text/html</kbd>, but the response included a JSON body, that is, <kbd>application/json</kbd> content. Thus, our first version of the RESTful API is not prepared to render content other from JSON. We will make some changes to enable the API to render other contents.</p>
<p>Whenever we have doubts about the methods supported by a resource or resource collection in a RESTful API, we can compose and send an HTTP request with the <kbd>OPTIONS</kbd> HTTP verb and the URL for the resource or resource collection. If the RESTful API implements the <kbd>OPTIONS</kbd> HTTP verb for a resource or resource collection, it provides a comma-separated list of HTTP verbs or methods that it supports as a value for the <kbd>Allow</kbd> header in the response. In addition, the response header will include additional information about other supported options, such as the content type it is capable of parsing from the request and the content type it is capable of rendering on the response.</p>
<p>For example, if we want to know which HTTP verbs the games collection supports, we can run the following command. The code file for the sample is included in the <kbd>restful_python_2_06_01</kbd> folder, in the <kbd>Django01/cmd/cmd603.txt</kbd> file:</p>
<pre>    <strong>http OPTIONS ":8000/games/"</strong></pre>
<p>The following is the equivalent <kbd>curl</kbd> command. The code file for the sample is included in the <kbd>restful_python_2_06_01</kbd> folder, in the <kbd>Django01/cmd/cmd604.txt</kbd> file:</p>
<pre>    <strong>curl -iX OPTIONS "localhost:8000/games/"</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>The previous command will compose and send the following HTTP request: <kbd>OPTIONS http://localhost:8000/games/</kbd>. The request will match and run the <kbd>views.game_collection</kbd> function, that is, the <kbd>game_collection</kbd> function declared within the <kbd>game_service/games/views.py</kbd> file. This function only runs code when the <kbd>request.method</kbd> is equal to <kbd>'GET'</kbd> or <kbd>'POST'</kbd>. In this case, <kbd>request.method</kbd> is equal to <kbd>'OPTIONS'</kbd>, and therefore, the function won't run any code and won't return any response, specifically, it won't return an <kbd>HttpResponse</kbd> instance. As a result, we will see the <kbd>Internal Server Error</kbd> shown in the next screenshot listed in Django's development server console output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/fdfed8ed-cf45-47a3-b169-94087e6098d3.png" width="1220" height="335"/></p>
<p>The following lines show the header for the output that also includes a huge HTML document with detailed information about the error because the debug mode is activated for Django. We receive a <kbd>500 Internal Server Error</kbd> status code. Notice that you will have to scroll up in the Terminal or Command Prompt to find these lines:</p>
<pre>    <strong>HTTP/1.1 500 Internal Server Error</strong>
    <strong>Content-Length: 51566</strong>
    <strong>Content-Type: text/html</strong>
    <strong>Date: Thu, 25 Oct 2018 04:14:09 GMT</strong>
    <strong>Server: WSGIServer/0.2 CPython/3.7.1</strong>
    <strong>Vary: Cookie</strong>
    <strong>X-Frame-Options: SAMEORIGIN</strong></pre>
<p>Obviously, we want to provide a more consistent API and we want to provide an accurate response when we receive a request with the <kbd>OPTIONS</kbd> verbs for either a game resource or the games collection.</p>
<p>If we compose and send an HTTP request with the <kbd>OPTIONS</kbd> verb for a game resource, we will see the same error and we will have a similar response because the <kbd>views.game_detail</kbd> function only runs code when <kbd>request.method</kbd> is equal to <kbd>'GET'</kbd>, <kbd>'PUT'</kbd>, or <kbd>'DELETE'</kbd>.</p>
<p class="mce-root"/>
<p>The following commands will produce the explained error when we try to see the options offered for the game resource whose ID is equal to <kbd>2</kbd>. Don't forget to replace <kbd>2</kbd> with a primary key value of an existing game in your configuration. The code file for the sample is included in the <kbd>restful_python_2_06_01</kbd> folder, in the <kbd>Django01/cmd/cmd605.txt</kbd> file:</p>
<pre>    <strong>http OPTIONS ":8000/games/3/"</strong></pre>
<p>The following is the equivalent <kbd>curl</kbd> command. The code file for the sample is included in the <kbd>restful_python_2_06_01</kbd> folder, in the <kbd>Django01/cmd/cmd606.txt</kbd> file:</p>
<pre>    <strong>curl -iX OPTIONS "localhost:8000/games/3/"</strong></pre>
<p>We just need to make a few small changes in the <kbd>games_service/games/views.py</kbd> file to solve the issues we have been analyzing for our RESTful API. We will use the useful <kbd>@api_view</kbd> decorator, declared in the <kbd>rest_framework.decorators</kbd> module, for our function-based views. This decorator allows us to specify which are the HTTP verbs that our function can process. If the request that has to be processed by the view function has an HTTP verb that isn't included in the string list specified as the <kbd>http_method_names</kbd> argument for the <kbd>@api_view</kbd> decorator, the default behavior returns a <kbd>405 Method Not Allowed</kbd> status code. This way, we make sure that whenever we receive an HTTP verb that isn't considered within our function view, we won't generate an unexpected error as the decorator handles the response for the unsupported HTTP verbs or methods.</p>
<div class="packt_tip">Under the hood, the <kbd>@api_view</kbd> decorator is a wrapper that converts a function-based view into a subclass of the <kbd>rest_framework.views.APIView</kbd> class. This class is the base class for all view in Django REST Framework. As we might guess, if we want to work with class-based views, we can create classes that inherit from this class and we will have the same benefits we have analyzed for the function-based views that use the decorator. We will start working with class-based views in the forthcoming examples in this chapter.</div>
<p>In addition, as we specify a string list with the supported HTTP verbs, the decorator automatically builds the response for the <kbd>OPTIONS</kbd> HTTP verb with the supported methods, parser, and rendering capabilities. Our actual version of the API is just capable of rendering JSON as its output. The usage of the decorator makes sure that we always receive an instance of the <kbd>rest_framework.request.Request</kbd> class in the <kbd>request</kbd> argument when Django calls our view function. The decorator also handles the <kbd>ParserError</kbd> exceptions when our function views access the <kbd>request.data</kbd> attribute that might cause parsing problems.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Using the default parsing and rendering options and moving beyond JSON</h1>
                </header>
            
            <article>
                
<p>The <kbd>APIView</kbd> class specifies default settings for each view that we can override by specifying appropriate values in the <kbd>games_service/settings.py</kbd> file or by overriding the class attributes in subclasses of the <kbd>APIView</kbd> superclass. As we learned, the usage of the <kbd>APIView</kbd> class under the hoods makes the decorator apply these default settings. Thus, whenever we use the decorator, the default parser classes and the default renderer classes will be associated with the function views.</p>
<p>By default, the value for the <kbd>DEFAULT_PARSER_CLASSES</kbd> configuration variable is the following tuple of strings with three parser class names:</p>
<pre>( 'rest_framework.parsers.JSONParser', 'rest_framework.parsers.FormParser', ...</pre></article></section></div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Browsing the API</h1>
                </header>
            
            <article>
                
<p>With the recent edits, we made it possible for our API to use the default content renderers configured in Django REST Framework, and therefore, our API is capable of rendering <kbd>text/html</kbd> content. We can take advantage of the browsable API, a feature included in Django REST Framework that generates human-friendly HTML output for each resource whenever the request specifies <kbd>text/html</kbd> as the value for the <kbd>Content-type</kbd> key in the request header.</p>
<p>Whenever we enter a URL for an API resource in a web browser, the browser will require an HTML response, and therefore, Django REST Framework will provide an HTML response built with the Bootstrap popular frontend component library. You can read more about Bootstrap here: <a href="http://getbootstrap.com"><span class="URLPACKT">http://getbootstrap.com</span></a>. This response will include a section that displays the resource content in JSON, buttons to perform different requests, and forms to submit data to the resources. As with everything in Django REST Framework, we can customize the templates and themes used to generate the browsable API.</p>
<p>Open a web browser and enter <kbd>http://localhost:8000/games/</kbd>. The browsable API will compose and send an HTTP <kbd>GET</kbd> request to <kbd>/games/</kbd> and will display the results of its execution, that is, the headers and the JSON games list. The following screenshot shows the rendered web page after entering the URL in a web browser with the resource description of <span class="ScreenTextPACKT0"><span class="packt_screen">Game List</span></span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/94318302-64a2-40ae-9313-6d009f2fde7b.png" width="1052" height="755"/></p>
<div class="packt_tip">If you decide to browse the API in a web browser running on another computer or device connected to the LAN, remember that you have to use the development computer's assigned IP address, instead of localhost. For example, if the computer's assigned IPv4 IP address is <kbd>192.168.1.103</kbd>, instead of <kbd>http://localhost:8000/games/</kbd>, you should use <kbd>http://192.168.1.103:8000/games/</kbd>. Of course, you can also use the hostname instead of the IP address.</div>
<p>The browsable API uses information about the allowed methods for a resource to provide us with buttons to run these methods. At the right-hand side of the resource description, the browsable API shows an <span class="packt_screen"><span class="ScreenTextPACKT0">OPTIONS</span></span> button and a <span class="packt_screen"><span class="ScreenTextPACKT0">GET</span></span> drop-down button. The <span class="packt_screen"><span class="ScreenTextPACKT0">OPTIONS</span></span> button allows us to make an <kbd>OPTIONS</kbd> request to <kbd>/games/</kbd>, that is, to the current resource. The <span class="packt_screen"><span class="ScreenTextPACKT0">GET</span></span> drop-down button allows us to make a <kbd>GET</kbd> request to <kbd>/games/</kbd> again. If we click or tap the down arrow, we can select the <span class="packt_screen"><span class="ScreenTextPACKT0">json</span></span> option and the browsable API will display the raw JSON results of a <kbd>GET</kbd> request to <kbd>/games/</kbd> without the headers.</p>
<p>At the bottom of the rendered web page, the browsable API provides us some controls to generate a <kbd>POST</kbd> request to <kbd>/games/</kbd>. The <span class="ScreenTextPACKT0"><span class="packt_screen">Media type</span></span> drop-down allows us to select between the configured supported parsers for our API:</p>
<ul>
<li><kbd>application/json</kbd></li>
<li><kbd>application/x-www-form-urlencoded</kbd></li>
<li><kbd>multipart/form-data</kbd></li>
</ul>
<p>The <span class="packt_screen"><span class="ScreenTextPACKT0">Content</span></span> textbox allows us to specify the data to be sent to the <kbd>POST</kbd> request formatted as specified in the <span class="ScreenTextPACKT0"><span class="packt_screen">Media type</span></span> drop-down. Select <span class="ScreenTextPACKT0"><span class="packt_screen">application/json</span></span> in the <span class="packt_screen"><span class="ScreenTextPACKT0">Media type</span></span> drop-down and enter the following JSON content in the <span class="packt_screen"><span class="ScreenTextPACKT0">Content</span></span> textbox:</p>
<pre>{ 
    "name": "Assassin's Creed Origins", 
    "release_date": "2018-01-10T03:02:00.776594Z", 
    "esrb_rating": "M (Mature)" 
}</pre>
<p>Click or tap <span class="packt_screen"><span class="ScreenTextPACKT0">POST</span></span>. The browsable API will compose and send a <kbd>POST</kbd> request to <kbd>/games/</kbd> with the previously specified data as JSON and we will see the results of the call in the web browser. The following screenshot shows a web browser displaying the HTTP status code <kbd>201 Created</kbd> in the response and the previously explained drop-down and textbox with the <span class="packt_screen"><span class="ScreenTextPACKT0">POST</span></span> button to allow us to continue composing and sending <kbd>POST</kbd> requests to <kbd>/games/</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/d865074b-cbfb-4b1a-9c29-f5aeb3f8a59f.png" style="width:35.25em;height:39.67em;" width="848" height="953"/></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Now enter the URL for an existing game resource, such as <kbd>http://localhost:8000/games/7/</kbd>. Make sure you replace <kbd>7</kbd> with the ID of an existing game in the previously rendered <span class="ScreenTextPACKT0"><span class="packt_screen">Games List</span></span>. The browsable API will compose and send an HTTP <kbd>GET</kbd> request to <kbd>/games/7/</kbd> and will display the results of its execution, that is, the headers and the JSON data for the game. The following screenshot shows the rendered web page after entering the URL in a web browser with the resource description of <span class="ScreenTextPACKT0"><span class="packt_screen">Game Detail</span></span>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/927c7515-dc6b-4c7e-82af-4ed4ac9ee68e.png" style="width:59.75em;height:43.25em;" width="816" height="590"/></p>
<div class="packt_tip">The browsable API feature allows us to easily check how the API works and to compose and send HTTP requests with different methods in any web browser that has access to our LAN. We will take advantage of additional features included in the browsable API, such as HTML forms that allow us to easily create new resources later after we build a new more complex RESTful API with Python and Django REST Framework.</div>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Designing a RESTful API to interact with a complex PostgreSQL 10.5 database</h1>
                </header>
            
            <article>
                
<p>So far, our Django-based RESTful API performed CRUD operations on a single database table in an SQLite database. Now, we want to create a more complex RESTful API with Django REST Framework to interact with a complex database model that has to allow us to register player scores for playing games that are grouped into ESRB ratings. In our previous RESTful API, we used a string field to specify the ESRB rating for a game. In this case, we want to be able to easily retrieve all the games that have a specific ESRB rating, and therefore, we will have a relationship between a game and an ESRB rating.</p>
<p>We must be able to perform CRUD operations on different related resources ...</p></article></section></div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Understanding the tasks performed by each HTTP method</h1>
                </header>
            
            <article>
                
<p>The following table shows the HTTP verbs, the scope, and the semantics for the methods that our API must support. Each method is composed by an HTTP verb and a scope and all the methods have well-defined meanings for all the resources and collections:</p>
<table style="border-collapse: collapse" border="1">
<tbody>
<tr>
<td>
<p>HTTP verb</p>
</td>
<td>
<p>Scope</p>
</td>
<td>
<p>Semantics</p>
</td>
</tr>
<tr>
<td>
<p><kbd>GET</kbd></p>
</td>
<td>
<p>Collection of ESRB ratings</p>
</td>
<td>
<p>Retrieve all the stored ESRB ratings in the collection, sorted by their description in ascending order. Each ESRB rating must include a list of URLs for each game resource that belongs to the rating.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>GET</kbd></p>
</td>
<td>
<p>ESRB rating</p>
</td>
<td>
<p>Retrieve a single ESRB rating. The ESRB rating must include a list of URLs for each game resource that belongs to the rating.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>POST</kbd></p>
</td>
<td>
<p>Collection of ESRB ratings</p>
</td>
<td>
<p>Create a new ESRB rating in the collection.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>PUT</kbd></p>
</td>
<td>
<p>ESRB rating</p>
</td>
<td>
<p>Update an existing ESRB rating.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>PATCH</kbd></p>
</td>
<td>
<p>ESRB rating</p>
</td>
<td>
<p>Update one or more fields of an existing ESRB rating.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>DELETE</kbd></p>
</td>
<td>
<p>ESRB rating</p>
</td>
<td>
<p>Delete an existing ESRB rating.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>GET</kbd></p>
</td>
<td>
<p>Collection of games</p>
</td>
<td>
<p>Retrieve all the stored games in the collection, sorted by their name in ascending order. Each game must include its ESRB rating description.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>GET</kbd></p>
</td>
<td>
<p>Game</p>
</td>
<td>
<p>Retrieve a single game. The game must include its ESRB rating description.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>POST</kbd></p>
</td>
<td>
<p>Collection of games</p>
</td>
<td>
<p>Create a new game in the collection.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>PUT</kbd></p>
</td>
<td>
<p>ESRB rating</p>
</td>
<td>
<p>Update an existing game.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>PATCH</kbd></p>
</td>
<td>
<p>ESRB rating</p>
</td>
<td>
<p>Update one or more fields of an existing game.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>DELETE</kbd></p>
</td>
<td>
<p>ESRB rating</p>
</td>
<td>
<p>Delete an existing game.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>GET</kbd></p>
</td>
<td>
<p>Collection of players</p>
</td>
<td>
<p>Retrieve all the stored players in the collection, sorted by their name in ascending order. Each player must include a list of the registered scores, sorted by score in descending order. The list must include all the details for the score achieved by the player and its related game.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>GET</kbd></p>
</td>
<td>
<p>Player</p>
</td>
<td>
<p>Retrieve a single player. The player must include a list of the registered scores, sorted by score in descending order. The list must include all the details for the score achieved by the player and its related game.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>POST</kbd></p>
</td>
<td>
<p>Collection of players</p>
</td>
<td>
<p>Create a new player in the collection.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>PUT</kbd></p>
</td>
<td>
<p>Player</p>
</td>
<td>
<p>Update an existing player.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>PATCH</kbd></p>
</td>
<td>
<p>Player</p>
</td>
<td>
<p>Update one or more fields of an existing player.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>DELETE</kbd></p>
</td>
<td>
<p>Player</p>
</td>
<td>
<p>Delete an existing player.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>GET</kbd></p>
</td>
<td>
<p>Collection of scores</p>
</td>
<td>
<p>Retrieve all the stored scores in the collection, sorted by score in descending order. Each score must include the player's name that achieved the score and the game's name.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>GET</kbd></p>
</td>
<td>
<p>Score</p>
</td>
<td>
<p>Retrieve a single score. The score must include the player's name that achieved the score and the game's name.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>POST</kbd></p>
</td>
<td>
<p>Collection of scores</p>
</td>
<td>
<p>Create a new score in the collection. The score must be related to an existing player and an existing game.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>PUT</kbd></p>
</td>
<td>
<p>Score</p>
</td>
<td>
<p>Update an existing score.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>PATCH</kbd></p>
</td>
<td>
<p>Score</p>
</td>
<td>
<p>Update one or more fields of an existing score.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>DELETE</kbd></p>
</td>
<td>
<p>Score</p>
</td>
<td>
<p>Delete an existing score.</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>We want our API to be able to update a single field for an existing resource, and therefore, we will provide an implementation for the <kbd>PATCH</kbd> method. In addition, our RESTful API must support the <kbd>OPTIONS</kbd> method for all the resources and collection of resources.</p>
<p>We will use all the features and reusable elements included in Django REST Framework to make it easy to build our API. We will work with a PostgreSQL 10.5 database. In case you don't want to spend time installing PostgreSQL, you can skip the changes we make in the Django REST Framework ORM configuration and continue working with the default SQLite database. However, it is highly recommended to work with PostgreSQL as the database engine.</p>
<p>In the previous table, we have a huge number of methods and scopes. The following list enumerates the URIs for each scope mentioned in the previous table, where <kbd>{id}</kbd> has to be replaced with the numeric id of the resource:</p>
<ul>
<li><strong>Collection of ESRB ratings</strong>: <kbd>/esrb-ratings/</kbd></li>
<li><strong>ESRB rating</strong>: <kbd>/esrb-rating/{id}/</kbd></li>
<li><strong>Collection of games</strong>: <kbd>/games/</kbd></li>
<li><strong>Game</strong>: <kbd>/game/{id}/</kbd></li>
<li><strong>Collection of players</strong>: <kbd>/players/</kbd></li>
<li><strong>Player</strong>: <kbd>/player/{id}/</kbd></li>
<li><strong>Collection of scores</strong>: <kbd>/player-scores/</kbd></li>
<li><strong>Score</strong>: <kbd>/player-score/{id}/</kbd></li>
</ul>
<p>Let's consider that <kbd>http://localhost:8000/</kbd> is the URL for the API running on the Django development server. We have to compose and send an HTTP request with the following HTTP verb (<kbd>GET</kbd>) and request URL (<kbd>http://localhost:8000/esrb-ratings/</kbd>) to retrieve all the stored ESRB ratings in the collection:</p>
<pre>GET http://localhost:8000/esrb-ratings/</pre>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Declaring relationships with the models</h1>
                </header>
            
            <article>
                
<p>Make sure you quit the Django's development server. Remember that you just need to press <span class="KeyPACKT"><em>Ctrl</em> + <em>C</em></span> in the Terminal or Command Prompt window in which it is running. Now we will create the models that we will use to represent and persist the ESRB ratings, games, players and scores, and their relationships.</p>
<p>Open the <kbd>models.py</kbd> file in the <kbd>games_service/games</kbd> folder. Replace the code in this file with the following lines. The lines that declare fields related to other models are highlighted in the code listing. The code file for the sample is included in the <kbd>restful_python_2_06_01</kbd> folder, in the <kbd>Django01/games-service/games/models.py</kbd> file:</p>
<pre>from django.db import models class EsrbRating(models.Model): description ...</pre></article></section></div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Installing packages with the requirements.txt file to work with PostgreSQL</h1>
                </header>
            
            <article>
                
<p>Make sure you quit Django development server. You just need to press <span class="KeyPACKT"><em>Ctrl</em> +</span> <span class="KeyPACKT"><em>C</em></span> in the Terminal or Command Prompt window in which it is running.</p>
<p>Now we will install an additional package. Make sure you have activated the virtual environment we have created in the previous chapter and we named <kbd>Django01</kbd>. After you activate the virtual environment, it is time to run many commands, which will be the same for either macOS, Linux, or Windows.</p>
<p>Now we will edit the existing <kbd>requirements.txt</kbd> file to specify the additional package that our application requires to be installed on any supported platform. This way, it will be extremely easy to repeat the installation of the specified packages with their versions in any new virtual environment.</p>
<p>Use your favorite editor to edit the existing text file named <kbd>requirements.txt</kbd> within the root folder for the virtual environment. Add the following lines after the last line to declare the additional package and the version that our new version of the API requires: <kbd>psycopg2</kbd> version 2.7.5. The code file for the sample is included in the <kbd>restful_python_2_06_01</kbd> folder, in the <kbd>Django01/requirements.txt</kbd> file:</p>
<pre>psycopg2==2.7.5 </pre>
<p>Psycopg 2 (<kbd>psycopg2</kbd>) is a Python-PostgreSQL database adapter and Django's integrated ORM will use it to interact with our recently created PostgreSQL database. Again, it is very important to make sure that the PostgreSQL <kbd>bin</kbd> folder is included in the <kbd>PATH</kbd> environmental variable before we run the installation for this package.</p>
<p>Now we must run the following command on macOS, Linux, or Windows to install the additional packages and the versions explained in the previous table with <kbd>pip</kbd> by using the recently edited <kbd>requirements.txt</kbd> file. Make sure you are in the folder that has the <kbd>requirements.txt</kbd> file (<kbd>Django01</kbd>) before running the command:</p>
<pre><strong>pip install -r requirements.txt</strong> </pre>
<p>The last lines for the output will indicate the new package has been successfully installed. If you downloaded the source code for the example and you didn't work with the previous version of the API, <kbd>pip</kbd> will also install the other packages included in the <kbd>requirements.txt</kbd> file:</p>
<pre>    <strong>Installing collected packages: psycopg2</strong>
    <strong>Successfully installed psycopg2-2.7.5</strong></pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Configuring the database</h1>
                </header>
            
            <article>
                
<p>The default SQLite database engine and the database file name are specified in the <kbd>games_service/games_service/settings.py</kbd> Python file. In order to work with PostgreSQL 10.5 instead of SQLite for this example, replace the declaration of the <kbd>DATABASES</kbd> dictionary in this file with the following lines. The nested dictionary maps the database named <kbd>default</kbd> with the <kbd>django.db.backends.postgresql</kbd> database engine, the desired database name, and its settings. In this case, we will create a database named games.</p>

<p>Make sure you specify the desired database name in the value for the <kbd>'NAME'</kbd> key and that you configure the user, password, host, and port based on the user you recently created and your PostgreSQL 10.5 configuration. ...</p></article></section></div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Running migrations</h1>
                </header>
            
            <article>
                
<p>Now run the following Python script to generate the migrations that will allow us to synchronize the database for the first time. Make sure you are in the <kbd>games_service</kbd> folder within the root folder for the virtual environment (<kbd>Django01</kbd>). Notice that we use the Django app name, <kbd>games</kbd>, and not the PostgreSQL database name, <kbd>django_games</kbd> in the next script:</p>
<pre>    <strong>python manage.py makemigrations games</strong></pre>
<p>The following lines show the output generated after running the previous command:</p>
<pre>    <strong>Migrations for 'games':</strong>
    <strong>  games/migrations/0001_initial.py</strong>
    <strong>    - Create model EsrbRating</strong>
    <strong>    - Create model Game</strong>
    <strong>    - Create model Player</strong>
    <strong>    - Create model PlayerScore</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The output indicates that the <kbd>games_service/games/migrations/0001_initial.py</kbd> file includes the code to create the <kbd>EsrbRating</kbd>, <kbd>Game</kbd>, <kbd>Player</kbd>, and <kbd>PlayerScore</kbd> models. The following lines show the code for this file that was automatically generated by Django and its integrated ORM. The code file for the sample is included in the <kbd>restful_python_2_06_01</kbd> folder, in the <kbd>Django01/games-service/games/migrations/0001_initial.py</kbd> file:</p>
<pre># Generated by Django 2.1.2 on 2018-10-25 20:15 
 
from django.db import migrations, models 
import django.db.models.deletion 
 
 
class Migration(migrations.Migration): 
 
    initial = True 
 
    dependencies = [ 
    ] 
 
    operations = [ 
        migrations.CreateModel( 
            name='EsrbRating', 
            fields=[ 
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')), 
                ('description', models.CharField(max_length=200)), 
            ], 
            options={ 
                'ordering': ('description',), 
            }, 
        ), 
        migrations.CreateModel( 
            name='Game', 
            fields=[ 
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')), 
                ('created', models.DateTimeField(auto_now_add=True)), 
                ('name', models.CharField(max_length=200)), 
                ('release_date', models.DateTimeField()), 
                ('played_once', models.BooleanField(default=False)), 
                ('played_times', models.IntegerField(default=0)), 
                ('esrb_rating', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='games', to='games.EsrbRating')), 
            ], 
            options={ 
                'ordering': ('name',), 
            }, 
        ), 
        migrations.CreateModel( 
            name='Player', 
            fields=[ 
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')), 
                ('created', models.DateTimeField(auto_now_add=True)), 
                ('name', models.CharField(max_length=50)), 
                ('gender', models.CharField(choices=[('M', 'Male'), ('F', 'Female')], default='M', max_length=2)), 
            ], 
            options={ 
                'ordering': ('name',), 
            }, 
        ), 
        migrations.CreateModel( 
            name='PlayerScore', 
            fields=[ 
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')), 
                ('score', models.IntegerField()), 
                ('score_date', models.DateTimeField()), 
                ('game', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='games.Game')), 
                ('player', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='scores', to='games.Player')), 
            ], 
            options={ 
                'ordering': ('-score',), 
            }, 
        ), 
    ] </pre>
<p>The code defines a subclass of the <kbd>django.db.migrations.Migration</kbd> class named <kbd>Migration</kbd> that defines an <kbd>operations</kbd> list with many <kbd>migrations.CreateModel</kbd>. Each <kbd>migrations.CreateModel</kbd> method will create the table for each of the related models. Notice that Django has automatically added an <kbd>id</kbd> field for each of the models.</p>
<p>The <kbd>operations</kbd> are executed in the same order in which they appear in the list. The code creates <kbd>EsrbRating</kbd>, <kbd>Game</kbd>, <kbd>Player</kbd>, and <kbd>PlayerScore</kbd>. The code creates the foreign keys for <kbd>Game</kbd> and <kbd>PlayerScore</kbd> when it creates these models.</p>
<p class="mce-root"/>
<p>Now run the following Python script to apply all the generated migrations:</p>
<pre>    <strong>python manage.py migrate</strong></pre>
<p>The following lines show the output generated after running the previous command:</p>
<pre>    <strong>Operations to perform:</strong>
    <strong>  Apply all migrations: admin, auth, contenttypes, games, sessions</strong>
    <strong>Running migrations:</strong>
    <strong>  Applying contenttypes.0001_initial... OK</strong>
    <strong>  Applying auth.0001_initial... OK</strong>
    <strong>  Applying admin.0001_initial... OK</strong>
    <strong>  Applying admin.0002_logentry_remove_auto_add... OK</strong>
    <strong>  Applying admin.0003_logentry_add_action_flag_choices... OK</strong>
    <strong>  Applying contenttypes.0002_remove_content_type_name... OK</strong>
    <strong>  Applying auth.0002_alter_permission_name_max_length... OK</strong>
    <strong>  Applying auth.0003_alter_user_email_max_length... OK</strong>
    <strong>  Applying auth.0004_alter_user_username_opts... OK</strong>
    <strong>  Applying auth.0005_alter_user_last_login_null... OK</strong>
    <strong>  Applying auth.0006_require_contenttypes_0002... OK</strong>
    <strong>  Applying auth.0007_alter_validators_add_error_messages... OK</strong>
    <strong>  Applying auth.0008_alter_user_username_max_length... OK</strong>
    <strong>  Applying auth.0009_alter_user_last_name_max_length... OK</strong>
    <strong>  Applying games.0001_initial... OK</strong>
    <strong>  Applying sessions.0001_initial... OK</strong>
  </pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Verifying the contents of the PostgreSQL database</h1>
                </header>
            
            <article>
                
<p>After we run the previous command, we can use the PostgreSQL command line or any other application that allows us to easily check the contents of the PostgreSQL 10.5 database to check the tables that Django generated.</p>
<p>Run the following command to list the generated tables. If the database name you are using is not named <kbd>django_games</kbd>, make sure you use the appropriate database name. The code file for the sample is included in the <kbd>restful_python_2_06_01</kbd> folder, in the <kbd>Django01/cmd/list_database_tables.sql</kbd> file:</p>
<pre>    <strong>psql --username=your_games_user_name --dbname=django_games --    command="\dt"</strong>
  </pre>


<p>The following lines show the output with all the generated table names:</p>
<pre>    <strong>                         List of relations</strong>
    <strong> Schema | Name ...</strong></pre></article></section></div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Managing serialization and deserialization with relationships and hyperlinks</h1>
                </header>
            
            <article>
                
<p>Our new RESTful Web API has to be able to serialize and deserialize the <kbd>EsrbRating</kbd>, <kbd>Game</kbd>, <kbd>Player</kbd>, and <kbd>PlayerScore</kbd> instances into JSON representations. In this case, we also have to pay special attention to the relationships between the different models when we create the serializer classes to manage serialization to JSON and deserialization from JSON.</p>
<p>In our last version of the previous API, we created a subclass of the <kbd>rest_framework.serializers.ModelSerializer</kbd> class to make it easier to generate a serializer and reduce boilerplate code. In this case, we will also declare a class that inherits from <kbd>ModelSerializer</kbd> but three classes will inherit from the <kbd>rest_framework.serializers.HyperlinkedModelSerializer</kbd> class.</p>
<p><kbd>HyperlinkedModelSerializer</kbd> is a type of <kbd>ModelSerializer</kbd> that uses hyperlinked relationships instead of primary key relationships, and therefore, it represents the relationships to other model instances with hyperlinks instead of primary key values. In addition, <kbd>HyperlinkedModelSerializer</kbd> generates a field named <kbd>url</kbd> with the URL for the resource as its value. As happens with <kbd>ModelSerializer</kbd>, the <kbd>HyperlinkedModelSerializer</kbd> class provides default implementations for the <kbd>create</kbd> and <kbd>update</kbd> methods.</p>
<p>Open the <kbd>serializers.py</kbd> file in the <kbd>games_service/games</kbd> folder. Replace the code in this file with the following lines. The new code declares the required imports and the <kbd>EsrbRatingSerializer</kbd> class. We will add more classes to this file later. The code file for the sample is included in the <kbd>restful_python_2_06_01</kbd> folder, in the <kbd>Django01/games-service/games/serializers.py</kbd> file:</p>
<pre>from rest_framework import serializers 
from games.models import EsrbRating 
from games.models import Game 
from games.models import Player 
from games.models import PlayerScore 
import games.views 
 
 
class EsrbRatingSerializer(serializers.HyperlinkedModelSerializer): 
    games = serializers.HyperlinkedRelatedField( 
        many=True, 
        read_only=True, 
        view_name='game-detail') 
 
    class Meta: 
        model = EsrbRating 
        fields = ( 
            'url', 
            'id', 
            'description', 
            'games') </pre>
<p>The <kbd>EsrbRatingSerializer</kbd> class is a subclass of the <kbd>HyperlinkedModelSerializer</kbd> superclass. The <kbd>EsrbRatingSerializer</kbd> class declares a <kbd>games</kbd> attribute as an instance of <kbd>serializers.HyperlinkedRelatedField</kbd> with <kbd>many</kbd> and <kbd>read_only</kbd> equal to <kbd>True</kbd> because it is a one-to-many relationship and it is read-only. We use the <kbd>games</kbd> name that we specified as the <kbd>related_name</kbd> string value when we created the <kbd>esrb_rating</kbd> field as a <kbd>models.ForeignKey</kbd> instance in the <kbd>Game</kbd> model. This way, the <kbd>games</kbd> field will provide us with an array of hyperlinks to each game that belongs to the ESRB rating. The <kbd>view_name</kbd> value is <kbd>'game-detail'</kbd> because we want the browsable API feature to use the game detail view to render the hyperlink when the user clicks or taps on it.</p>
<p>The <kbd>EsrbRatingSerializer</kbd> class declares a <kbd>Meta</kbd> inner class that declares the following two attributes:</p>
<ul>
<li><kbd>model</kbd>: This attribute specifies the model related to the serializer, that is, the <kbd>EsrbRating</kbd> class.</li>
<li><kbd>fields</kbd>: This attribute specifies a tuple of the string whose values indicate the field names that we want to include in the serialization from the related model. We want to include both the primary key and the URL, and therefore, the code specifies both <kbd>'id'</kbd> and <kbd>'url'</kbd> as members of the tuple.</li>
</ul>
<p>There is no need to override either the <kbd>create</kbd> or <kbd>update</kbd> methods because the generic behavior will be enough in this case. The <kbd>HyperlinkedModelSerializer</kbd> superclass provides implementations for both methods.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Open the <kbd>serializers.py</kbd> file in the <kbd>games_service/games</kbd> folder and add the following lines after the last line to declare the <kbd>GameSerializer</kbd> class. The code file for the sample is included in the <kbd>restful_python_2_06_01</kbd> folder, in the <kbd>Django01/games-service/games/serializers.py</kbd> file:</p>
<pre>class GameSerializer(serializers.HyperlinkedModelSerializer): 
    # We want to display the game ESRB rating description instead of its id 
    esrb_rating = serializers.SlugRelatedField( 
        queryset=EsrbRating.objects.all(),  
        slug_field='description') 
 
    class Meta: 
        model = Game 
        fields = ( 
            'url', 
            'esrb_rating', 
            'name', 
            'release_date', 
            'played_once', 
            'played_times') </pre>
<p>The <kbd>GameSerializer</kbd> class is a subclass of the <kbd>HyperlinkedModelSerializer</kbd> superclass. The <kbd>GameSerializer</kbd> class declares an <kbd>esrb_rating</kbd> attribute as an instance of the <kbd>serializers.SlugRelatedField</kbd> class with its <kbd>queryset</kbd> argument set to <kbd>EsrbRating.objects.all()</kbd> and its <kbd>slug_field</kbd> argument set to <kbd>'description'</kbd>.</p>
<div class="packt_tip"><kbd>SlugRelatedField</kbd> is a read-write field that represents the target of the relationship by a unique slug attribute, that is, the description.</div>
<p>We created the <kbd>esrb_rating</kbd> field as a <kbd>models.ForeignKey</kbd> instance in the <kbd>Game</kbd> model and we want to display the ESRB rating's <kbd>description</kbd> value as the description (slug field) for the related <kbd>EsrbRating</kbd>. Hence, we specified <kbd>'description'</kbd> as the <kbd>slug_field</kbd>. If it is necessary to display the possible options for the related ESRB rating in a form in the browsable API, Django will use the expression specified in the <kbd>queryset</kbd> argument to retrieve all the possible instances and display their specified slug field.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The <kbd>EsrbRatingSerializer</kbd> class declares a <kbd>Meta</kbd> inner class that declares the following two attributes:</p>
<ul>
<li><kbd>model</kbd>: This attribute specifies the model related to the serializer, that is, the <kbd>Game</kbd> class.</li>
<li><kbd>fields</kbd>: This attribute specifies a tuple of the string whose values indicate the field names that we want to include in the serialization from the related model. We just want to include the URL, and therefore, the code specifies <kbd>'url'</kbd> as a member of the tuple but doesn't specify <kbd>'id'</kbd>. The <kbd>esrb_rating</kbd> field will specify the <kbd>description</kbd> field for the related <kbd>EsrbRating</kbd>.</li>
</ul>
<p>Open the <kbd>serializers.py</kbd> file in the <kbd>games_service/games</kbd> folder and add the following lines after the last line to declare the <kbd>ScoreSerializer</kbd> class. The code file for the sample is included in the <kbd>restful_python_2_06_01</kbd> folder, in the <kbd>Django01/games-service/games/serializers.py</kbd> file:</p>
<pre>class ScoreSerializer(serializers.HyperlinkedModelSerializer): 
    # We want to display all the details for the related game 
    game = GameSerializer() 
    # We don't include the player because a score will be nested in the player 
 
    class Meta: 
        model = PlayerScore 
        fields = ( 
            'url', 
            'id', 
            'score', 
            'score_date', 
            'game') </pre>
<p>The <kbd>ScoreSerializer</kbd> class is a subclass of the <kbd>HyperlinkedModelSerializer</kbd> superclass. We will use the <kbd>ScoreSerializer</kbd> class to serialize <kbd>PlayerScore</kbd> instances related to a <kbd>Player</kbd>, that is, to display all the scores for a specific player when we serialize a <kbd>Player</kbd>. We want to display all the details for the related <kbd>Game</kbd> but we don't include the related <kbd>Player</kbd> because <kbd>Player</kbd> will use this <kbd>ScoreSerializer</kbd> serializer.</p>
<p>The <kbd>ScoreSerializer</kbd> class declares a <kbd>game</kbd> attribute as an instance of the previously coded <kbd>GameSerializer</kbd> class. We created the <kbd>game</kbd> field as a <kbd>models.ForeignKey</kbd> instance in the <kbd>PlayerScore</kbd> model and we want to serialize the same data for the game that we coded in the <kbd>GameSerializer</kbd> class.</p>
<p class="mce-root"/>
<p>The <kbd>ScoreSerializer</kbd> class declares a <kbd>Meta</kbd> inner class that declares the following two attributes:</p>
<ul>
<li><kbd>model</kbd>: This attribute specifies the model related to the serializer, that is, the <kbd>PlayerScore</kbd> class.</li>
<li><kbd>fields</kbd>: This attribute specifies a tuple of the string whose values indicate the field names that we want to include in the serialization from the related model. In this case, we include both the <kbd>'url'</kbd> and the <kbd>'id'</kbd>. As previously explained, we don't include the <kbd>'player'</kbd> field name in this tuple of string to avoid serializing the player again.</li>
</ul>
<div class="packt_tip">We will use <kbd>PlayerSerializer</kbd> as a master and <kbd>ScoreSerializer</kbd> as the detail.</div>
<p>Open the <kbd>serializers.py</kbd> file in the <kbd>games_service/games</kbd> folder and add the following lines after the last line to declare the <kbd>PlayerSerializer</kbd> class. The code file for the sample is included in the <kbd>restful_python_2_06_01</kbd> folder, in the <kbd>Django01/games-service/games/serializers.py</kbd> file:</p>
<pre>class PlayerSerializer(serializers.HyperlinkedModelSerializer): 
    scores = ScoreSerializer(many=True, read_only=True) 
    gender = serializers.ChoiceField( 
        choices=Player.GENDER_CHOICES) 
    gender_description = serializers.CharField( 
        source='get_gender_display',  
        read_only=True) 
 
    class Meta: 
         model = Player 
         fields = ( 
               'url', 
               'name', 
               'gender', 
               'gender_description', 
               'scores') </pre>
<p>The <kbd>PlayerSerializer</kbd> class is a subclass of the <kbd>HyperlinkedModelSerializer</kbd> superclass. We will use the <kbd>PlayerSerializer</kbd> class to serialize <kbd>Player</kbd> instances and we will use the previously declared <kbd>ScoreSerializer</kbd> class to serialize all the <kbd>PlayerScore</kbd> instances related to <kbd>Player</kbd>.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The <kbd>PlayerSerializer</kbd> class declares a <kbd>scores</kbd> attribute as an instance of the previously coded <kbd>ScoreSerializer</kbd> class. The <kbd>many</kbd> argument is set to <kbd>True</kbd> because it is a one-to-many relationship. We use the <kbd>scores</kbd> name that we specified as the <kbd>related_name</kbd> string value when we created the <kbd>player</kbd> field as a <kbd>models.ForeignKey</kbd> instance in the <kbd>PlayerScore</kbd> model. This way, the <kbd>scores</kbd> field will render each <kbd>PlayerScore</kbd> that belongs to the <kbd>Player</kbd> by using the previously declared <kbd>ScoreSerializer</kbd>.</p>
<p>The <kbd>Player</kbd> model declared <kbd>gender</kbd> as an instance of <kbd>models.CharField</kbd> with the <kbd>choices</kbd> attribute set to the <kbd>Player.GENDER_CHOICES</kbd> string tuple. The <kbd>ScoreSerializer</kbd> class declares a <kbd>gender</kbd> attribute as an instance of <kbd>serializers.ChoiceField</kbd> with the <kbd>choices</kbd> argument set to the <kbd>Player.GENDER_CHOICES</kbd> string tuple. In addition, the class declares a <kbd>gender_description</kbd> attribute with <kbd>read_only</kbd> set to <kbd>True</kbd> and the <kbd>source</kbd> argument set to <kbd>'get_gender_display'</kbd>. The <kbd>source</kbd> string is built with <kbd>get_</kbd> followed by the field name, <kbd>gender</kbd>, and <kbd>_display</kbd>. This way, the read-only <kbd>gender_description</kbd> attribute will render the description for the gender choices instead of the single char stored values. The <kbd>ScoreSerializer</kbd> class declares a <kbd>Meta</kbd> inner class that declares the <kbd>model</kbd> and <kbd>fields</kbd> attributes. The <kbd>model</kbd> attribute specifies the <kbd>Player</kbd> class.</p>
<p>Open the <kbd>serializers.py</kbd> file in the <kbd>games_service/games</kbd> folder and add the following lines after the last line to declare the <kbd>PlayerScoreSerializer</kbd> class. The code file for the sample is included in the <kbd>restful_python_2_06_01</kbd> folder, in the <kbd>Django01/games-service/games/serializers.py</kbd> file:</p>
<pre>class PlayerScoreSerializer(serializers.ModelSerializer): 
    # We want to display the players's name instead of its id 
   player = serializers.SlugRelatedField(queryset=Player.objects.all(), slug_field='name') 
   # We want to display the game's name instead of its id 
   game = serializers.SlugRelatedField(queryset=Game.objects.all(), slug_field='name') 
 
   class Meta: 
         model = PlayerScore 
         fields = ( 
               'url', 
               'id', 
               'score', 
               'score_date', 
               'player', 
               'game')</pre>
<p class="mce-root"/>
<p>The <kbd>PlayerScoreSerializer</kbd> class is a subclass of the <kbd>HyperlinkedModelSerializer</kbd> superclass. We will use the <kbd>PlayerScoreSerializer</kbd> class to serialize <kbd>PlayerScore</kbd> instances. Previously, we created the <kbd>ScoreSerializer</kbd> class to serialize <kbd>PlayerScore</kbd> instances as the detail of a player. We will use the new <kbd>PlayerScoreSerializer</kbd> class when we want to display the related player's name and the related game's name. In the other serializer class, we didn't include any information related to the player and we included all the details for the game.</p>
<p>The <kbd>PlayerScoreSerializer</kbd> class declares a <kbd>player</kbd> attribute as an instance of <kbd>serializers.SlugRelatedField</kbd> with its <kbd>queryset</kbd> argument set to <kbd>Player.objects.all()</kbd> and its <kbd>slug_field</kbd> argument set to <kbd>'name'</kbd>. We created the <kbd>player</kbd> field as a <kbd>models.ForeignKey</kbd> instance in the <kbd>PlayerScore</kbd> model, and we want to display the player's name as the description (slug field) for the related <kbd>Player</kbd>. Thus, we specified <kbd>'name'</kbd> as the <kbd>slug_field</kbd> argument. If it is necessary to display the possible options for the related player in a form in the browsable API, Django will use the expression specified in the <kbd>queryset</kbd> argument to retrieve all the possible players and display their specified slug field.</p>
<p>The <kbd>PlayerScoreSerializer</kbd> class declares a <kbd>game</kbd> attribute as an instance of <kbd>serializers.SlugRelatedField</kbd> with its <kbd>queryset</kbd> argument set to <kbd>Game.objects.all()</kbd> and its <kbd>slug_field</kbd> argument set to <kbd>'name'</kbd>. We created the <kbd>game</kbd> field as a <kbd>models.ForeignKey</kbd> instance in the <kbd>PlayerScore</kbd> model and we want to display the game's name as the description (slug field) for the related <kbd>Game</kbd>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating class-based views and using generic classes</h1>
                </header>
            
            <article>
                
<p>This time, we will write our API views by declaring class-based views, instead of function-based views. We might code classes that inherit from the <kbd>rest_framework.views.APIView</kbd> class and declare methods with the same names than the HTTP verbs we want to process: <kbd>get</kbd>, <kbd>post</kbd>, <kbd>put</kbd>, <kbd>patch</kbd>, <kbd>delete</kbd>, and so on. These methods receive a <kbd>request</kbd> argument as happened with the functions that we created for the views. However, this approach would require us to write a lot of code. Instead, we can take advantage of a set of generic views that we can use as our base classes for our class-based views to reduce the required code to the minimum and take advantage of the behavior that has been generalized ...</p></article></section></div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Taking advantage of generic class-based views</h1>
                </header>
            
            <article>
                
<p>Open the <kbd>views.py</kbd> file in the <kbd>games_service/games</kbd> folder. Replace the code in this file with the following lines. The new code declares the required imports and the class-based views. We will add more classes to this file later. The code file for the sample is included in the <kbd>restful_python_2_06_01</kbd> folder, in the <kbd>Django01/games-service/games/views.py</kbd> file:</p>
<pre>from games.models import EsrbRating 
from games.models import Game 
from games.models import Player 
from games.models import PlayerScore 
from games.serializers import EsrbRatingSerializer 
from games.serializers import GameSerializer 
from games.serializers import PlayerSerializer 
from games.serializers import PlayerScoreSerializer 
from rest_framework import generics 
from rest_framework.response import Response 
from rest_framework.reverse import reverse 
 
 
<strong>class EsrbRatingList(generics.ListCreateAPIView): 
</strong>    queryset = EsrbRating.objects.all() 
    serializer_class = EsrbRatingSerializer 
    name = 'esrbrating-list' 
 
 
<strong>class EsrbRatingDetail(generics.RetrieveUpdateDestroyAPIView): 
</strong>    queryset = EsrbRating.objects.all() 
    serializer_class = EsrbRatingSerializer 
    name = 'esrbrating-detail' 
 
 
<strong>class GameList(generics.ListCreateAPIView): 
</strong>    queryset = Game.objects.all() 
    serializer_class = GameSerializer 
    name = 'game-list' 
 
 
<strong>class GameDetail(generics.RetrieveUpdateDestroyAPIView): 
</strong>    queryset = Game.objects.all() 
    serializer_class = GameSerializer 
    name = 'game-detail' 
 
 
<strong>class PlayerList(generics.ListCreateAPIView): 
</strong>    queryset = Player.objects.all() 
    serializer_class = PlayerSerializer 
    name = 'player-list' 
 
 
<strong>class PlayerDetail(generics.RetrieveUpdateDestroyAPIView): 
</strong>    queryset = Player.objects.all() 
    serializer_class = PlayerSerializer 
    name = 'player-detail' 
 
 
<strong>class PlayerScoreList(generics.ListCreateAPIView): 
</strong>    queryset = PlayerScore.objects.all() 
    serializer_class = PlayerScoreSerializer 
    name = 'playerscore-list' 
 
 
<strong>class PlayerScoreDetail(generics.RetrieveUpdateDestroyAPIView): 
</strong>    queryset = PlayerScore.objects.all() 
    serializer_class = PlayerScoreSerializer 
    name = 'playerscore-detail' </pre>
<p>The following table summarizes the methods that each class-based view is going to process:</p>
<table style="border-collapse: collapse" border="1">
<tbody>
<tr>
<td>
<p>Scope</p>
</td>
<td>
<p>Class-based view name</p>
</td>
<td>
<p>HTTP verbs that it will process</p>
</td>
</tr>
<tr>
<td>
<p>Collection of ESRB ratings: <kbd>/esrb-ratings/</kbd></p>
</td>
<td>
<p><kbd>EsrbRatingList</kbd></p>
</td>
<td>
<p><kbd>GET</kbd>, <kbd>POST</kbd>, and <kbd>OPTIONS</kbd></p>
</td>
</tr>
<tr>
<td>
<p>ESRB rating: <kbd>/esrb-rating/{id}/</kbd></p>
</td>
<td>
<p><kbd>EsrbRatingDetail</kbd></p>
</td>
<td>
<p><kbd>GET</kbd>, <kbd>PUT</kbd>, <kbd>PATCH</kbd>, <kbd>DELETE</kbd>, and <kbd>OPTIONS</kbd></p>
</td>
</tr>
<tr>
<td>
<p>Collection of games: <kbd>/games/</kbd></p>
</td>
<td>
<p><kbd>GameList</kbd></p>
</td>
<td>
<p><kbd>GET</kbd>, <kbd>POST</kbd>, and <kbd>OPTIONS</kbd></p>
</td>
</tr>
<tr>
<td>
<p>Game: <kbd>/game/{id}/</kbd></p>
</td>
<td>
<p><kbd>GameDetail</kbd></p>
</td>
<td>
<p><kbd>GET</kbd>, <kbd>PUT</kbd>, <kbd>PATCH</kbd>, <kbd>DELETE</kbd>, and <kbd>OPTIONS</kbd></p>
</td>
</tr>
<tr>
<td>
<p>Collection of players: <kbd>/players/</kbd></p>
</td>
<td>
<p><kbd>PlayerList</kbd></p>
</td>
<td>
<p><kbd>GET</kbd>, <kbd>POST</kbd>, and <kbd>OPTIONS</kbd></p>
</td>
</tr>
<tr>
<td>
<p>Player: <kbd>/player/{id}/</kbd></p>
</td>
<td>
<p><kbd>PlayerDetail</kbd></p>
</td>
<td>
<p><kbd>GET</kbd>, <kbd>PUT</kbd>, <kbd>PATCH</kbd>, <kbd>DELETE</kbd>, and <kbd>OPTIONS</kbd></p>
</td>
</tr>
<tr>
<td>
<p>Collection of scores: <kbd>/player-scores/</kbd></p>
</td>
<td>
<p><kbd>PlayerScoreList</kbd></p>
</td>
<td>
<p><kbd>GET</kbd>, <kbd>POST</kbd>, and <kbd>OPTIONS</kbd></p>
</td>
</tr>
<tr>
<td>
<p>Score: <kbd>/player-score/{id}/</kbd></p>
</td>
<td>
<p><kbd>PlayerScoreDetail</kbd></p>
</td>
<td>
<p><kbd>GET</kbd>, <kbd>PUT</kbd>, <kbd>PATCH</kbd>, <kbd>DELETE</kbd>, and <kbd>OPTIONS</kbd></p>
</td>
</tr>
</tbody>
</table>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Working with endpoints for the API</h1>
                </header>
            
            <article>
                
<p>We will create an endpoint for the root of our API to make it easier to browse the API with the browsable API feature and understand how everything works. Open the <kbd>views.py</kbd> file in the <kbd>games_service/games</kbd> folder and add the following code after the last line to declare the <kbd>ApiRoot</kbd> class. The code file for the sample is included in the <kbd>restful_python_2_06_01</kbd> folder, in the <kbd>Django01/games-service/games/serializers.py</kbd> file:</p>
<pre>class ApiRoot(generics.GenericAPIView): name = 'api-root' def get(self, request, *args, **kwargs): return Response({ 'players': reverse(PlayerList.name, request=request), 'esrb-ratings': reverse(EsrbRatingList.name, request=request), 'games': reverse(GameList.name, request=request), 'scores': ...</pre></article></section></div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Browsing an API with relationships</h1>
                </header>
            
            <article>
                
<p>Now we can launch Django's development server to compose and send HTTP requests to our still unsecured, yet much more complex, web API (we will definitely add security later). Execute any of the following two commands based on your needs to access the API in other devices or computers connected to your LAN. Remember that we analyzed the difference between them in the previous chapter:</p>
<pre>    <strong>python manage.py runserver</strong>
    <strong>python manage.py runserver 0.0.0.0:8000</strong></pre>
<p>After we run any of the previous commands, the development server will start listening at port <kbd>8000</kbd>.</p>
<p class="mce-root"/>
<p>Open a web browser and enter <kbd>http://localhost:8000/</kbd> or the appropriate URL if you are using another computer or device to access the browsable API. The browsable API will compose and send a <kbd>GET</kbd> request to <kbd>/</kbd> and will display the results of its execution, that is, the headers and the JSON response from the execution of the <kbd>get</kbd> method defined in the <kbd>ApiRoot</kbd> class within the <kbd>views.py</kbd> file. The following screenshot shows the rendered web page after entering the URL in a web browser with the resource description of <span class="ScreenTextPACKT0"><span class="packt_screen">api-root</span></span>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/4f42ccb1-8ca3-4c9a-946d-a578083f8015.png" style="width:53.08em;height:33.58em;" width="1128" height="713"/></p>
<p>The <span class="packt_screen">api-root</span> provides us with hyperlinks to see the list of ESRB ratings, games, players, and scores. This way, it becomes extremely easy to access the lists and perform operations on the different resources through the browsable API. In addition, when we visit the other URLs, the breadcrumb will allow us to go back to the <span class="ScreenTextPACKT0"><span class="packt_screen">api-root</span></span>.</p>
<p>In this new version of the API, we worked with the generic views that provide many functions under the hood, and therefore, the browsable API will provide us additional features compared with the previous version. Click or tap on the URL at the right-hand side of <span class="ScreenTextPACKT0"><span class="packt_screen">"esrb-ratings"</span></span>. If you are browsing in localhost, the URL will be <kbd>http://localhost:8000/esrb-ratings/</kbd>. The browsable API will render the web page for the <span class="ScreenTextPACKT0">ESRB rating List</span>.</p>
<p class="mce-root"/>
<p>At the bottom of the rendered web page, the browsable API provides us some controls to generate a <kbd>POST</kbd> request to <kbd>/esrb-ratings/</kbd>. In this case, by default, the browsable API displays the HTML form tab with an automatically generated form that we can use to generate a POST request without having to deal with the raw data as we did in our previous version. The HTML forms make it easy to generate requests to test our API. The following screenshot shows the HTML form to create a new ESRB rating:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/a35bb0da-012c-493d-b11f-2dfc95798263.png" style="width:35.67em;height:30.33em;" width="1436" height="1222"/></div>
<p>We just need to enter the desired name, <kbd>AO (Adults Only)</kbd>, in the <span class="ScreenTextPACKT0">Name</span> textbox and click or tap <span class="ScreenTextPACKT0">POST</span> to create a new ESRB rating. The browsable API will compose and send a <kbd>POST</kbd> request to <kbd>/esrb-ratings/</kbd> with the previously specified data and we will see the results of the call in the web browser. The following screenshot shows a web browser displaying the HTTP status code <kbd>201 Created</kbd> in the response and the previously explained HTML form with the <span class="ScreenTextPACKT0">POST</span> button to allow us to continue composing and sending <kbd>POST</kbd> requests to <kbd>/esrb-ratings/</kbd>:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/e63e1938-6e43-44be-b23b-51834dc775d9.png" style="width:31.58em;height:29.67em;" width="1430" height="1340"/></div>
<p>Now click on the URL displayed as a value for the <kbd>"url"</kbd> key in the JSON data displayed for the ESRB rating, such as <kbd>http://localhost:8000/esrb-ratings/1/</kbd>. Make sure you replace <kbd>1</kbd> with the ID of an existing ESRB rating in the previously rendered <span class="ScreenTextPACKT0">esrbrating-list</span>. The browsable API will compose and send a <kbd>GET</kbd> request to <kbd>/esrb-ratings/1/</kbd> and will display the results of its execution, that is, the headers and the JSON data for the ESRB rating. The web page will display a <span class="packt_screen"><span class="ScreenTextPACKT0">DELETE</span></span> button because we are working with the <span class="ScreenTextPACKT0">ESRB rating</span> <span class="packt_screen"><span class="ScreenTextPACKT0">Detail</span></span> view.</p>
<div class="packt_tip">We can use the breadcrumb to go back to the API root and start creating games related to an ESRB rating, players, and finally, scores related to a game and a player. We can do all this with easy-to-use HTML forms and the browsable API feature. This feature is extremely useful for testing CRUD operations with a RESTful API.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating and retrieving related resources</h1>
                </header>
            
            <article>
                
<p>Now we will use the HTTP command or its <kbd>curl</kbd> equivalents to compose and send HTTP requests to the API. We will use JSON for the requests that require additional data. Remember that you can perform the same tasks as your favorite GUI-based tool or with the browsable API.</p>
<p>First, we will run the following command to compose and send an HTTP <kbd>POST</kbd> request to create a new ESRB rating. Remember that we used the browsable API to create an ESRB rating with the following description: <kbd>'AO (Adults Only)'</kbd>. The code file for the sample is included in the <kbd>restful_python_2_06_01</kbd> folder, in the <kbd>Django01/cmd/cmd615.txt</kbd> file:</p>
<pre>    <strong>http POST ":8000/esrb-ratings/" description='T (Teen)'</strong>
  </pre>
<p>The following is the equivalent </p></article></section></div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Test your knowledge</h1>
                </header>
            
            <article>
                
<p>Let's see whether you can answer the following questions correctly:</p>
<ol>
<li>Under the hood, the <kbd>@api_view</kbd> decorator is:
<ol>
<li>A wrapper that converts a function-based view into a subclass of the <kbd>rest_framework.views.APIView</kbd> <span>class</span></li>
<li>A wrapper that converts a function-based view into a serializer</li>
<li>A wrapper that converts a function-based view into a subclass of the <kbd>rest_framework.views.api_view</kbd> <span>class</span></li>
</ol>
</li>
</ol>
<p class="mce-root"/>
<p class="mce-root"/>
<ol start="2">
<li>The <kbd>Serializer</kbd> and <kbd>ModelSerializer</kbd> classes in Django REST Framework are similar to which of the following two classes in Django Web framework?
<ol>
<li> <kbd>Form</kbd> <span>and</span> <kbd>ModelForm</kbd></li>
<li><kbd>View</kbd> <span>and</span> <kbd>ModelView</kbd></li>
<li><kbd>Controller</kbd> <span>and</span> <kbd>ModelController</kbd></li>
</ol>
</li>
</ol>
<ol start="3">
<li>Which of the following classes is a read-write field that represents the target of the relationship by a unique slug attribute, that is, the description?
<ol>
<li><kbd>SlugLinkedField</kbd></li>
<li><kbd>HyperlinkedRelatedField</kbd></li>
<li><kbd>SlugRelatedField</kbd></li>
</ol>
</li>
</ol>
<ol start="4">
<li>Which of the following classes renders the URL for a related object?
<ol>
<li><kbd>SlugLinkedField</kbd></li>
<li><kbd>HyperlinkedRelatedField</kbd></li>
<li><kbd>SlugRelatedField</kbd></li>
</ol>
</li>
</ol>
<ol start="5">
<li>The browsable API is a feature included in Django REST Framework that:
<ol>
<li>Generates human-friendly JSON output for each resource whenever the request specifies <kbd>application/json</kbd> <span>as the value for the</span> <kbd>Content-type</kbd> <span>key in the request header</span></li>
<li>Generates human-friendly HTML output for each resource whenever the request specifies <kbd>text/html</kbd> <span>as the value for the</span> <kbd>Content-type</kbd> <span>key in the request header</span></li>
<li>. Generates human-friendly HTML output for each resource whenever the request specifies <kbd>application/json</kbd> <span>as the value for the</span> <kbd>Content-type</kbd> <span>key in the request header</span></li>
</ol>
</li>
</ol>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we took advantage of many features included in Django REST Framework that allow us to eliminate duplicate code and build our API reusing generalized behaviors. We used model serializers, wrappers, default parsing and rendering options, class-based views, and generic classes.</p>
<p>We used the browsable API feature and we designed a RESTful API that interacted with a complex PostgreSQL 10.5 database. We declared relationships with the models, and we configured serialization and deserialization with hyperlinks. Finally, we created and retrieved related resources and understood how things work under the hood.</p>
<p>Now that we built a complex API with Django REST Framework that we can encapsulate in a microservice, we will use additional ...</p></article></section></div>



  </body></html>