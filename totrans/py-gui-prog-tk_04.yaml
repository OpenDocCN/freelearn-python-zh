- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Organizing Our Code with Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Things are going great with your data entry form! Your boss and coworkers and
    excited to see the progress you've made and are already coming up with some ideas
    of what other features could be added. This makes you a little nervous, to be
    honest! While they see a professional-looking form, you know that the code underneath
    is getting bulky and repetitive. You've got some warts in there too, like a global
    variable and a very cluttered global namespace. Before you start adding more features,
    you'd like to get a handle on this code and start breaking it down into some manageable
    chunks. For this, you'll need to create **classes**.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: In *A primer on Python classes*, we'll review how to create Python classes and
    subclasses.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In *Using classes with Tkinter*, we'll discover ways to utilize classes effectively
    in Tkinter code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In *Rewriting our application using classes*, we'll apply these techniques to
    the ABQ Data Entry application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A primer on Python classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While the concept of a class is simple enough on the surface, classes bring
    with them a number of terms and concepts that confuse many beginners. In this
    section, we'll discuss the advantages of using classes, explore the different
    features of classes, and review the syntax for creating classes in Python.
  prefs: []
  type: TYPE_NORMAL
- en: The advantages of using classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many beginners and even intermediate Python coders avoid or dismiss the use
    of classes in Python; unlike functions or variables, classes do not have obvious
    uses in short, simple scripts. As our application code grows, however, classes
    become an indispensable tool for organizing our code into manageable units. Let's
    look at some ways classes can help us build cleaner code.
  prefs: []
  type: TYPE_NORMAL
- en: Classes are an integral part of Python
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A class is essentially a blueprint for creating an **object**. What is an object?
    In Python, *everything* is an object: integers, strings, floats, lists, dictionaries,
    Tkinter widgets, and even functions are all objects. Each of these types of objects
    is defined by a class. You can see this easily at a Python prompt if you use the
    `type` command, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `type` function shows you what class was used to construct the object in
    question. When an object is built from a particular class, we say it is an **instance**
    of that class.
  prefs: []
  type: TYPE_NORMAL
- en: '*Instance* and *object* are often used interchangeably, because every object
    is an instance of some class.'
  prefs: []
  type: TYPE_NORMAL
- en: Because everything in Python is a class, creating our own classes allows us
    to work with custom objects using the same syntax we use with built-in objects.
  prefs: []
  type: TYPE_NORMAL
- en: Classes make relationships between data and functions explicit
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Often, in code, we have a set of data that all relates to the same thing. For
    example, in a multiplayer game, you might have variables for each player's score,
    health, or progress. Functions that operate on these variables would need to be
    sure to operate on the variables that refer to the same player. Classes would
    allow us to create an explicit relationship between these variables and the functions
    that operate on them, so that we can more easily keep them organized as a unit.
  prefs: []
  type: TYPE_NORMAL
- en: Classes help create reusable code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Classes are a great tool for reducing code redundancy. Suppose we have a set
    of forms that have similar behavior on submission, but different input fields.
    Using class inheritance, we can create a base form with the desired common behaviors;
    then, we can derive the individual form classes from that, only having to implement
    what is unique in each form.
  prefs: []
  type: TYPE_NORMAL
- en: Syntax of class creation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Creating a class is very similar to creating a function, except that we use
    the `class` keyword, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note that we've also included a **docstring**, which is used by Python tools
    (such as the built-in `help` function) to generate documentation about the class.
    Class names in Python traditionally use **Pascal Case**, meaning the first letter
    of each word is capitalized; sometimes, third-party libraries will use other conventions,
    however.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have defined a class, we can create instances of the class by calling
    it, just like a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this case, `my_banana` is an object that is an instance of the `Banana` class.
    Of course, a more useful class will have some things defined inside the class
    body; specifically, we can define **attributes** and **methods**, which are collectively
    known as **members**.
  prefs: []
  type: TYPE_NORMAL
- en: Attributes and methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Attributes are simply variables, and they can be either **class attributes**
    or **instance attributes**. A class attribute is defined in the top scope of the
    class body, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Class attributes are shared by all instances of the class, and are usually used
    for setting defaults, constants, and other read-only values.
  prefs: []
  type: TYPE_NORMAL
- en: Note that unlike class names, member names, by convention, use **snake case**,
    where lowercase words are separated by underscores.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instance attributes store values specific to a single instance of the class;
    to create one, we need access to an instance. We could do it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: However, it would be more ideal if we could define some instance attributes
    inside our class definition, instead of doing it externally like that. In order
    to do so, we need a reference to the instance of the class inside the class definition.
    This can be done with an **instance method**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Methods are simply functions attached to the class. An instance method is a
    method that automatically receives a reference to the instance as its first argument.
    We can define one like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, defining an instance method is simply defining a function inside
    the class body. The first argument that this function will receive is a reference
    to the instance of the class; it can be called anything you like, but by long-standing
    Python convention, we name it `self`. Inside the function, `self` can be used
    to do operations on the instance, such as assigning an instance attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the instance (`self`) also has access to class attributes (for example,
    `self.colors`), as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'When we use an instance method, we do not explicitly pass `self`; it''s passed
    implicitly, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The implicit passing of `self` often leads to confusing error messages when
    you pass the wrong number of arguments. For example, if you called `my_banana.peel(True)`,
    you'd get an exception saying that one argument was expected but two were passed.
    From your point of view, you only passed one argument, but the method got two
    because the instance reference was automatically added.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to instance methods, classes can have **class methods** and **static
    methods**. Unlike instance methods, these methods do not have access to the instance
    of the class and cannot read or write instance attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Class methods are created using a **decorator** just before the method definition,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Just as an instance method is implicitly passed a reference to the instance,
    a class method is implicitly passed a reference to the class as the first argument.
    Once again, you can call that argument anything you like, but conventionally it
    is called `cls`. Class methods are usually used for interaction with class variables.
    For example, in the `check_color()` method above, the method needs a reference
    to the class variable `colors`. Class methods are also used as convenience functions
    for geneating specifically configured instances of the class; for example, the
    `make_greenie()` method above uses its class reference to create instances of
    `Banana` with the color pre-set to `green`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A **static method** is also a function that''s attached to the class, but it
    does not get any implicit arguments, and the code within the method has no access
    to the class or instance. Just like the class methods, we use a decorator to define
    a static method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Static methods are often used for defining algorithms or utility functions used
    internally by the class.
  prefs: []
  type: TYPE_NORMAL
- en: Class and static methods can be called on the class itself; for example, we
    could call `Banana.estimate_calories()` or `Banana.check_color()` without actually
    creating an instance of `Banana`. Instance methods, however, *must* be called
    on an instance of the class. It would make no sense to call `Banana.set_color()`
    or `Banana.peel()`, since these methods are meant to operate on an instance. Instead,
    we should create an instance and call those methods on it (for example, `my_banana.peel()`).
  prefs: []
  type: TYPE_NORMAL
- en: Magic attributes and methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All Python objects automatically get a set of attributes called **magic attributes**
    and a set of methods called **magic methods**, also called special methods or
    *dunder methods*, because they are indicated by double underscores around the
    attribute or method name ("dunder" is a portmanteau of "double under").
  prefs: []
  type: TYPE_NORMAL
- en: 'Magic attributes generally store metadata about the object. For example, the
    `__class__` attribute of any object stores a reference to the object''s class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Magic methods define how a Python object responds to operators (like `+`, `%`,
    or `[]`) or built-in functions (like `dir()` or `setattr()`). For example, the
    `__str__()` method defines what an object returns when passed to the `str()` function
    (either explicitly or implicitly, by being passed to `print()`, for example):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Here, we're not only accessing the instance's `color` attribute, but using the
    `__class__` attribute to retrieve its class, and then using the class object's
    `__name__` attribute to get the class name.
  prefs: []
  type: TYPE_NORMAL
- en: As confusing as it is, the *class* is also an *object*. It's an instance of
    the `type` class. Remember, everything in Python is an object, and all objects
    are instances of some class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, when a `Banana` object is printed, it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'By far the most important magic method is the **initializer** method, `__init__()`.
    This method is executed whenever we call the class object to create an instance,
    and the arguments we define for it become the arguments we can pass in when creating
    the instance. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we''ve created the initializer with an optional argument called `color`,
    allowing us to set the `Banana` object''s color value when creating the object.
    Thus, we can create a new `Banana` like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Ideally, any instance attributes used in the class should be created within
    `__init__()`, so that we can ensure they exist for all instances of the class.
    For example, we should create our `peeled` attribute like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: If we didn't define this attribute here, it would not exist until the `peel()`
    method is called. Code looking for the value of `my_banana.peel` before that method
    was called would raise an exception.
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, the initializer should leave the object in a state where it is ready
    to be used by the program.
  prefs: []
  type: TYPE_NORMAL
- en: In other object-oriented languages, the method that sets up a class object is
    known as the **constructor**, which not only initializes the new object but returns
    it as well. Sometimes, Python developers will casually refer to `__init__()` as
    a constructor. However, the actual constructor method for Python objects is `__new__()`,
    which we generally leave untouched in Python classes.
  prefs: []
  type: TYPE_NORMAL
- en: Public, private, and protected members
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Classes are a powerful tool for *abstraction* – that is, taking a complicated
    object or process and providing a simple, high-level interface to the rest of
    the application. To help them do that, Python programmers use some naming conventions
    to distinguish between public, private, and protected members:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Public members** are those intended to be read or called by code outside
    the class. They use ordinary member names.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Protected members** are meant only for use inside the class or its subclasses.
    They are prefixed with a single underscore.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Private members** are meant only for use within the class. They''re prefixed
    with double underscores.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python does not actually enforce any distinction between public, protected,
    and private members; these are merely conventions that are understood by other
    programmers to indicate which parts of the class can be accessed externally, and
    which ones are part of the internal implementation and not meant for use outside
    the class.
  prefs: []
  type: TYPE_NORMAL
- en: Python *will* assist in enforcing private members by automatically changing
    their names to `_classname__member_name`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s add this code to the `Banana` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Here, `__ripe_colors` is a private attribute. If you tried to access `my_banana.__ripe_colors`,
    Python would raise an `AttributeError` exception because it has implicitly renamed
    this property to `my_banana._Banana__ripe_colors`. The method `_is_ripe()` is
    a protected member but, unlike the private member, Python does not alter its name.
    It could be executed as `my_banana._is_ripe()`, but programmers using your class
    would understand that this method is meant for internal use and not to be relied
    upon in external code. Instead, the `can_eat()` method, which is public, should
    be called.
  prefs: []
  type: TYPE_NORMAL
- en: There are a variety of reasons why you'd want to indicate a member as private
    or protected, but in general, it's because the member is part of some internal
    process and would be either meaningless, unreliable, or lacking in context for
    use in outside code.
  prefs: []
  type: TYPE_NORMAL
- en: Although the words *private* and *protected* seem to indicate a security feature,
    that is not their intention, and using them does not provide any security to the
    class. The intention is simply to distinguish the public interface of the class
    (which outside code should use) from the internal machinery of the class (which
    should be left alone).
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance and subclasses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Building our own classes is a powerful tool indeed, but since everything in
    Python is an object built from a class, wouldn't it be nice if we could take one
    of those existing classes and simply alter it to fit our needs? That way, we wouldn't
    have to start from scratch every time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, we can! When we create a class, Python allows us to derive it
    from an existing class, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve created the class `RedBanana` as a **child class** or **subclass** of
    `Banana`. `Banana` is known as the **parent class** or **superclass** in this
    case. Initially, `RedBanana` is an exact copy of `Banana` and will behave identically,
    but we can modify it by simply defining members, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Specifying existing members, like `colors` and `set_color`, will mask the superclass
    versions of those members. Thus, calling `set_color()` on a `RedBanana` instance
    will call the `RedBanana` version of the method, which, in turn, will consult
    the `RedBanana` version of `colors` when `self.colors` is referenced. We can also
    add new members, such as the `botanical_name` a ttribute, which will only exist
    in the subclass.
  prefs: []
  type: TYPE_NORMAL
- en: 'In some cases, we might want our subclass method to add to the superclass method,
    but still execute the code in the superclass version of the method. We could copy
    the superclass code into our subclass code, but there''s a better way: using `super()`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside an instance method, `super()` gives us a reference to the superclass
    version of our instance, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In this case, calling `super().peel()` causes the code in `Banana.peel()` to
    be executed on our `RedBanana` instance. Then, we can add additional code to our
    subclass version of `peel()`.
  prefs: []
  type: TYPE_NORMAL
- en: As you'll see in the next section, `super()` is often used in the `__init__()`
    method to run the superclass's initializer. This is especially true for Tkinter
    GUI classes, which do a lot of critical external setup in their initializer methods.
  prefs: []
  type: TYPE_NORMAL
- en: There is much more to Python classes than we have discussed here, including
    the concept of **multiple inheritance**, which we will learn about in *Chapter
    5*, *Reducing User Error with Validation and Automation*. What we've learned so
    far, however, is more than enough to apply to our Tkinter code. Let's see how
    classes can help us in a GUI context.
  prefs: []
  type: TYPE_NORMAL
- en: Using classes with Tkinter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'GUI frameworks and object-oriented code go hand in hand. While Tkinter, more
    than most frameworks, allows you to create GUIs using procedural programming,
    we miss out on a great deal of organizational power in doing so. Although we''ll
    find many ways to use classes in our Tkinter code throughout this book, we''ll
    look at three primary ways of using them here:'
  prefs: []
  type: TYPE_NORMAL
- en: Improving or expanding Tkinter classes for more power
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating **compound widgets** to save repetitive typing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Organizing our application into self-contained **comp****onents**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving Tkinter classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s face it: some Tkinter objects are a little lacking in functionality.
    We can fix that by subclassing Tkinter classes and making our own improved versions.
    For instance, while we''ve seen that Tkinter control variable classes are useful,
    hey are limited to string, integer, double, and Boolean types. What if we wanted
    the functionality of these variables, but for more complex objects like dictionaries
    or lists? We can, with subclassing and some help from JSON.'
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript Object Notation** (**JSON**) is a standardized format for representing
    lists, dictionaries, and other compound objects as strings. The Python standard
    library comes with a `json` library, which allows us to convert such objects to
    string format and back again. We''ll use JSON more in *Chapter 7*, *Creating Menus
    with Menu and Tkinter Dialogs*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a new script called `tkinter_classes_demo.py`, and let''s begin with some
    imports, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to Tkinter, we''ve imported the standard library `json` module.
    This module contains two functions that we''ll use to implement our variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '`json.dumps()` takes a Python object like a list, dictionary, string, int,
    or float, and returns a string in JSON format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`json.loads()` takes a JSON string and returns a Python object like a list,
    dict, or string, depending on what was stored in the JSON string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Begin the new variable class by creating a subclass of `tk.StringVar` called
    `JSONVar`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'To make our `JSONVar` work, we need to intercept the `value` argument wherever
    it is passed to the object and convert it into a JSON string using the `json.dumps()`
    method. The first such place is in `__init__()`, which we''ll override like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here, we're simply retrieving the `value` argument from the keywords and converting
    it into a string using `json.dumps()`. The converted string will overwrite the
    `value` argument, which will then be passed to the superclass initializer. In
    the event that a `value` argument isn't provided (remember, it is an optional
    argument), `kwargs.get()` will return `None`, which will be converted into a JSON
    `null` value.
  prefs: []
  type: TYPE_NORMAL
- en: When overriding methods in a class you didn't write, it's always a good idea
    to include `*args` and `**kwargs` to catch any arguments that you don't explicitly
    list. That way, the method will continue to allow all the arguments that the superclass
    version did, but you won't have to explicitly enumerate them all.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next place we need to intercept the value is in the `set()` method, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Once again, we've intercepted the `value` argument and converted it into a JSON
    string before passing it to the superclass version of `set()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Last of all, let''s fix `get()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we''ve done the opposite of the other two methods: first, we got the
    string from the superclass, and then converted it back into an object using `json.loads()`.
    With that done, we''re ready! What we now have is a variable that can store and
    retrieve a list or dictionary, just like any other Tkinter variable.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s test it out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, subclassing Tkinter objects opens up a whole new range of possibilities
    for our code. We'll apply this same concept to widget classes both later in this
    chapter and more extensively in *Chapter 5*, *Reducing User Error with Validation
    and Automation**.* First, though, let's look at two more ways we can use classes
    with Tkinter code.
  prefs: []
  type: TYPE_NORMAL
- en: Creating compound widgets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many GUIs (particularly data entry forms) contain patterns that require a lot
    of repetitive boilerplate code. For example, input widgets usually have an accompanying
    label to tell the user what they need to enter. This often requires several lines
    of code to create and configure each object and add them to the form. We can not
    only save time, but ensure better consistency of output by creating a reusable
    **compound widget** that combines both into a single class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s combine an input widget and label by creating a `LabelInput` class,
    starting with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `tk.Frame` widget, a bare widget with nothing on it, is an ideal class to
    subclass for a compound widget. After starting our class definition, the next
    thing we need to do is think through all the pieces of data our widget will need,
    and make sure those can be passed into the `__init__()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a basic widget, the minimal set of arguments might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: The parent widget
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The text for the label
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The type of input widget to use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A dictionary of arguments to pass to the input widget
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s implement that in our `LabelInput` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we do here is call the superclass initializer so that the `Frame`
    widget can be constructed. Note that we pass along the `parent` argument, since
    that will be the parent widget of the `Frame` itself; the parent widget for the
    `Label` and input widget is `self` – that is, the `LabelInput` object itself.
  prefs: []
  type: TYPE_NORMAL
- en: Don't confuse "parent class" and "parent widget." "Parent class" refers to the
    superclass from which our subclass inherits its members. "Parent widget" refers
    to the widget (of a probably unrelated class) to which our widget is attached.
    To help avoid confusion, we'll stick to the super/subclass terminology in this
    book when speaking of class inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: 'After creating our `label` and `input` widgets, we can arrange them on the
    `Frame` however we wish; for example, we might want labels next to the input,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, we might prefer labels above our input widgets, as implemented here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In either case, if we create all the inputs on our form using a `LabelInput`,
    we have the power to change the layout of *the entire form* using only three lines
    of code. We could conceivably add an initializer argument to configure the layout
    individually for each instance as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see this class in action. Since our `inp_args` argument is going to
    be expanded directly into our call to the `inp_cls` initializer, we can populate
    it with any arguments we''d like our input widget to receive, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We can even pass in a variable to bind to the widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The compound widget saves us a few lines of code, but more importantly, it raises
    our input form code to a higher-level description of what's going on. Instead
    of being full of details about how each label is placed in relation to each widget,
    we can think about the form in terms of these larger components.
  prefs: []
  type: TYPE_NORMAL
- en: Building encapsulated components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating compound widgets is useful for structures we plan to reuse in our application,
    but the same concept can be applied beneficially to larger pieces of our application,
    even if they only appear once.
  prefs: []
  type: TYPE_NORMAL
- en: Doing so allows us to attach methods to the components of our application to
    build self-contained units of functionality that are more easily managed.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s create a `MyForm` class to hold a simple form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Just as we did with the compound wiget, we've subclassed `tk.Frame` and defined
    a new initializer method. The `parent`, `*args`, and `**kwargs` arguments will
    get passed on to the superclass's initializer, but we'll also take a `data_var`
    argument, which will be an instance of our new `JSONVar` type. We'll use this
    argument to communicate the form data back out of the form.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll create some internal control variables to bind to our form widgets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: As we've already seen in our data entry application, keeping our form data variables
    in a dictionary will make it simple to extract data from them later. Rather than
    using a global variable, however, we've created the dictionary as a protected
    instance variable by adding it to `self` and prefixing it with an underscore.
    That's because this dictionary is meant for our form's internal use only.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s put our `LabelInput` class to work to create the actual widgets
    for our form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see that `LabelInput` has trimmed our GUI-building code considerably!
    Now, let''s add a submit button for our form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The submit button is configured to call a protected instance method named `_on_submit`.
    This shows us a powerful feature of using classes for our GUI components: by binding
    our button to an instance method, that method will have access to all the other
    instance members. For example, it can access our `_vars` dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Without using a class, we would have had to rely on global variables, such as
    we did in the `data_entry_app.py` application we wrote in *Chapter 3*, *Creating
    Basic Forms with Tkinter and Ttk Widgets*. Instead, our callback method needs
    only the implicitly passed `self` object to have access to all the objects that
    it needs. In this case, we're using a **dictionary comprehension** to extract
    all the data frm our widgets and, then storing the resulting dictionary in our
    `JSONVar` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'A dictionary comprehension is similar to a list comprehension, but creates
    a dictionary instead; the syntax is `{ key: value for expression in iterator }`.
    For example, if you wanted to create a dictionary of numbers with their squares,
    you could write `{ n: n**2 for n in range(100) }`.'
  prefs: []
  type: TYPE_NORMAL
- en: Thus, whenever the submit button is clicked, the `data_var` object will be updated
    with the current contents of the input widgets.
  prefs: []
  type: TYPE_NORMAL
- en: Subclassing Tk
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can extend this concept of component building all the way up to our top window,
    the `Tk` object. By subclassing `Tk` and building our other application components
    in their own classes, we can compose our application's layout and behavior in
    a high-level way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try this with our current demo script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Remember that the `Tk` object is not just our top-level window, but also represents
    the core of our application itself. Therefore we've named our subclass `Application`
    to indicate that it represents the foundation of our entire application. Our initializer
    method begins with the obligatory call to `super().__init__()`, passing along
    any arguments to the `Application.__init__()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll create some variables to keep track of the data in our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The `JSONVar`, as you might expect, will be passed into our `MyForm` object
    to handle its data. The `output_var` is just a `StringVar` we''ll use to display
    some output. Let''s next add some widgets to our window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Here, we've added a simple header label for the form, a `MyForm` object, and
    another label to display the output. We've also configured the frame so that the
    first (and only) column expands into the extra space, and the second row (the
    one containing the form) expands into extra vertical space.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since a submission of `MyForm` updates the `JSONVar` object we passed to it,
    we''ll need a way to execute a submission-handling callback whenever the variable
    contents are changed. We can do this by setting a **trace** on `jsonvar`, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The `trace_add()` method can be used on any Tkinter vaiable (or variable subclass)
    to execute a callback function whenever a variable-related event occurs. Let's
    take a moment to examine it in more detail
  prefs: []
  type: TYPE_NORMAL
- en: 'The first argument to `trace_add()` specifies the event that the trace will
    trigger on; it can be one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`read`: The variable value is read (by a `get()` call, for example).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`write`: The variable value is modified (by a `set()` call, for example).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unset`: The variable is deleted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`array`: This is an artifact of Tcl/Tk, not really meaningful in Python, but
    still valid syntax. You will likely never use it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The second argument specifies a callback for the event, which, in this case,
    is the instance method `_on_data_change()`, which will be triggered whenever `jsonvar`
    is updated. We''ll handle it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This method simply iterates through the values in the dictionary retrieved from
    `jsonvar`, and then joins them together into a single formatted string. Finally,
    the formatted string is passed into `output_var`, which will update the label
    at the bottom of the main window to display our values from the form. In a real
    application, you might save the retrieved data to a file or use them as parameters
    to a batch operation, for example.
  prefs: []
  type: TYPE_NORMAL
- en: When should you use an instance variable (for example, `self.jsonvar`), and
    when should you use regular variables (for example, `data`), in an instance method?
    Regular variables in a method are **local** in their scope, meaning they are destroyed
    as soon as the method returns. In addition, they cannot be referenced by other
    methods in the class. Instance variables stay in scope for the lifetime of the
    instance itself, and are available for any other instance method to read or write.
    In the case of the `Application` class, the `data` variable was only needed inside
    the `_on_data_change()` method, whereas `jsonvar` needed to be accessed in both
    `__init__()` and `_on_datachange()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we''ve subclassed `Tk`, we should no longer start our script with the
    line `root = tk.Tk()`. Make sure to delete that line, and also to delete the previous
    lines of the code that reference `root`. Instead, we''ll execute our application
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Note that these lines, our class definitions, and our imports are the only top-level
    code we're executing. That cleans up our global scope considerably, isolating
    the finer details of our code to a more limited scope.
  prefs: []
  type: TYPE_NORMAL
- en: In Python, `if __name__ == "__main__":` is a common idiom to check if a script
    is being run directly, such as when we type `python3 tkinter_classes_demo.py`
    at a command prompt. If we were to import this file as a module into another Python
    script, this check would be false and the code inside the block would not be run.
    It's a good practice to put your program's main execution code below this check
    so that you can safely reuse your classes and functions in larger applications.
  prefs: []
  type: TYPE_NORMAL
- en: Rewriting our application using classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we''ve learned these techniques for using classes in our code, let''s
    apply it to our ABQ Data Entry application. We''ll start with a fresh file called
    `data_entry_app.py` and add in our import statements, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's see how we can apply some class-based techniques to rewrite a cleaner
    version of our application code.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a StringVar to the Text widget
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One annoyance we discovered in creating our application was that the `Text`
    widget does not allow the use of a `StringVar` to store its content, requiring
    us to treat it differently than all our other widgets. There *is* a good reason
    for this: the Tkinter `Text` widget is far more than just a multi-line `Entry`
    widget, capable of containing rich text, images, and other things that a lowly
    `StringVar` cannot store. That said, we''re not using any of those features, so
    it would be better for us to have a more limited `Text` widget that can be bound
    to a variable.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a subclass called `BoundText` to solve this problem; start with
    this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Our class needs to add three things to the `Text` class:'
  prefs: []
  type: TYPE_NORMAL
- en: It needs to allow us to pass in a `StringVar`, which it will be bound to.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It needs to update the widget contents whenever the variable is updated; for
    example, if it were loaded in from a file or changed by another widget.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It needs to update the variable contents whenever the widget is updated; for
    example, when the user types or pastes content into the widget.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing in a variable
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We''ll begin by overriding the initializer to allow a control variable to be
    passed in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: In keeping with Tkinter convention, we'll use the `textvariable` argument to
    pass in the `StringVar` object. Having passed the remaining arguments to `super().__init__()`,
    we store the variable as a protected member of the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, if the user has provided a variable, we''ll go ahead and insert its contents
    into the widget (this takes care of any default value assigned to the variable):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Note that, if a variable was not passed in, `textvariable` (and consequently
    `self._variable`) will be `None`.
  prefs: []
  type: TYPE_NORMAL
- en: Synchronizing the widget to the variable
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next thing we need to do is bind modifications of the control variable to
    an instance method that will update the widget.
  prefs: []
  type: TYPE_NORMAL
- en: 'Still working in the `__init__()` method, let''s add a trace inside the `if`
    block we just created, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The callback for our trace is a protected member function called `_set_content()`,
    which will update the content of the widget with the contents of the variable.
    Let''s go ahead and create that callback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: First, note that the argument list of our callback includes `*_`. This notation
    simply wraps up any positional arguments passed to the function in a variable
    called `_` (underscore). A single underscore, or series of underscores, is a conventional
    way of naming Python variables that we need to provide but don't intend to use.
    In this case, we're using it to consume any additional arguments that Tkinter
    will pass to this function when it calls it in response to an event. You'll see
    this same technique used in other callback methods whenever we intend to bind
    them to Tkinter events.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the method, we'll simply modify the widget contents using its `delete()`
    and `insert()` methods.
  prefs: []
  type: TYPE_NORMAL
- en: Synchronizing the variable to the widget
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Updating the variable when the widget is modified is slightly more involved.
    We need to find an event that will fire whenever the `Text` widget is edited to
    bind to our callback. We could use the `<Key>` event, which fires whenever a key
    is pressed, but it won't capture mouse-based edits such as a paste operation.
    The `Text` widget does, however, have a `<<Modified>>` event that is emitted when
    it is first modified.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can start with that; add another line to the end of our `if` statement in
    `__init__()`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Rather unintuitively, though, `<<Modified>>` only fires the first time the widget
    is modified. After that, we'll need to reset the event by changing the widget's
    modified flag. We can do this using the `Text` widget's `edit_modified()` method,
    which also allows us to retrieve the state of the modified flag.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how this will work, let''s write the `_set_var()` callback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: In this method, we begin by checking if the widget has been modified by calling
    `edit_modified()`. If it has, we'll retrieve the content using the widget's `get()`
    method. Notice that the ending index for get is `end-1chars`. This means "one
    character before the end of the content." Recall that the `Text` widget's `get()`
    method automatically appends a newline to the end of the content, so by using
    this index, we can eliminate the extra newline.
  prefs: []
  type: TYPE_NORMAL
- en: After retrieving the contents of the widget, we need to reset the modified flag
    by passing `False` into the `edit_modified()` method. That way, it is ready to
    fire the `<<Modified>>` event the next time the user interacts with the widget.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a more advanced LabelInput()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `LabelInput` class we created earlier under *Creating compound widgets*
    seems useful, but if we want to use it in our program, it's going to require some
    more fleshing out.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start, once again, with our class definition and initializer method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: As before, we've got arguments for the parent widget, label text, input class,
    and input arguments. Since every widget we want to use can now have a variable
    bound to it, we'll also go ahead and accept that as a required argument, and we'll
    add an optional argument for a dictionary of arguments to pass to the label widget,
    should we need that. We're defaulting `input_class` to `ttk.Entry`, since we have
    several of those.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the default values for the `input_args` and `label_args` arguments
    are `None`, and that we make them dictionaries inside the method if they are `None`.
    Why not just use empty dictionaries as default arguments? In Python, default arguments
    are evaluated when the function definition is first run. This means that a dictionary
    object created in the function signature will be the same object every time the
    function is run, rather than a fresh, empty dictionary each time. Since we want
    a fresh, empty dictionary each time, we create the dictionaries inside the function
    body rather than the argument list. The same holds for lists and other mutable
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the method, we call `super().__init__()` as usual, and then ensure that
    `input_args` and `label_args` are dictionaries. Finally, we'll save the `input_var`
    to an instance variable, and save the label widget itself as a property of the
    variable object. Doing this means we won't have to store references to our `LabelInput`
    objects; we can just access them through the variable object if we need to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, it''s time to set up the label, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '`Checkbutton` and `Button` widgets have a label built into them, so we don''t
    want to have a separate label hanging around. Instead, we''ll just set the `text`
    argument of the widget to whatever is passed in. (`Radiobutton` objects also have
    a label built in, but we''ll handle those slightly differently, as you''ll see
    in a moment). For all other widgets, we''ll add a `Label` widget to the first
    row and column of the `LabelInput`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to set up the input arguments so that the input''s control variable
    will be passed in with the correct argument name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Recall that button classes use `variable` as the argument name, while all others
    use `textvariable`. By handling this inside the class, we won't need to worry
    about that distinction when building our form.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's set up the input widget. Most widgets will be simple to set up, but
    for `Radiobutton`, we need to do something different. We need to create a `Radiobutton`
    widget for each possible value that's passed in (using the `values` key in `input_args`).
    Remember that we link the buttons by having them share the same variable, which
    we'll do here.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll add it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: First, we create a `Frame` object to hold the buttons; then, for each value
    passed into `values`, we add a `Radiobutton` widget to the `Frame` layout. Note
    that we call the `pop()` method to get the `values` item from the `input_args`
    dict. `dict.pop()` is nearly identical to `dict.get()`, returning the value of
    the given key if it exists, or the second argument if it does not. The difference
    is that `pop()` also deletes the retrieved item from the dictionary. We're doing
    this because `values` isn't a valid argument for `Radiobutton`, so we need to
    remove it before passing `input_args` to the `Radiobutton` initializer. The remaining
    items in `input_args` should be valid keyword arguments to the widget.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of non-`Radiobutton` widgets, it''s pretty straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'We simply call whatever `input_class` class has been passed in with the `input_args`.
    Now that we have `self.input` created, we just need to add it to the `LabelInput`
    layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The final call to `columnconfigure` tells the `LabelWidget` widget to fill its
    entire width with column `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'One convenient thing we can do when creating our own widgets (either a custom
    subclass or compound widget) is to set some reasonable defaults for the geometry
    layout. For example, we''re going to want all our `LabelInput` widgets to stick
    to the left- and right-hand sides of their container so that they fill the maximum
    width available. Rather than having to pass in `sticky=(tk.E + tk.W)` every single
    time we position a `LabelInput` widget, let''s make it the default, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: We've overridden `grid` and simply passed on the arguments to the superclass
    version but added a default for `sticky`. We can still override it if needed,
    but it will save us a lot of clutter to make that default.
  prefs: []
  type: TYPE_NORMAL
- en: Our `LabelInput` is fairly robust now; time to put it to work!
  prefs: []
  type: TYPE_NORMAL
- en: Creating a form class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that our building blocks are ready, it''s time to build the major components
    of our application. Breaking the application into sensible components requires
    some thinking about what might constitute a reasonable division of responsibilities.
    Initially, it seems like our application could be broken into two components:
    the data entry form and the root application itself. But which features go where?'
  prefs: []
  type: TYPE_NORMAL
- en: 'One reasonable assessment might be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The data entry form itself should contain all the widgets, of course. It should
    also hold the Save and Reset buttons, since these make no sense being separate
    from the form.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The application title and status bar belong at a universal level, since they
    will apply to all parts of the application. File saving could go with the form,
    but it also has to interact with some application-level items like the status
    bar or `records_saved` variable. It's a tricky call, but we'll put it with the
    application object for now.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s begin by building our data entry form class, `DataRecordForm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: As always, we begin by subclassing `Frame` and calling the superclass's initializer
    method. We don't really need to add any custom arguments at this point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s create a dictionary to hold all our variable objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'This is just straight out of our data dictionary. Note that, thanks to our
    `BoundText` class, we can assign a `StringVar` object to Notes. Now, we''re ready
    to start adding widgets to our GUI. In the current version of our application,
    we added a `LabelFrame` widget for each section of the application using a chunk
    of code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'This code was repeated for each frame, with only a change to the variable name
    and label text. To avoid this repetition, we can abstract this process into an
    instance method. Let''s create a method that can add a new label frame for us;
    add this code just above the `__init__()` definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'This method simply redefines the earlier code in a generic way, so we can just
    pass in the label text and, optionally, a number of columns. Scroll back down
    to where we were in the `DataRecordForm.__init__()` method, and let''s put this
    method to use by making a Record Information section, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our frame, let''s give `LabelInput` a try and start building
    the first section of the form, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `LabelInput` has saved us a lot of redundant clutter already!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s continue with the second line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember that to use `RadioButton` widgets with `LabelInput`, we need to pass
    in a list of values to the input arguments, just as we do for `Combobox`. Having
    finished the `Record Information` section, let''s continue with the next section,
    `Environmental Data`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Again, we have added and configured a `LabelFrame` using our `_add_frame()`
    method, populating it with the four `LabelInput` widgets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s add the `Plant Data` sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re almost done; let''s add our `Notes` section next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Here, we're taking advantage of our `BoundText` object so we can attach a variable.
    Otherwise, this looks like all the other calls to `LabelInput`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it''s time for the buttons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: As before, we've added our button widgets on a `Frame`. This time, though, we're
    going to pass in some instance methods as callback commands for the buttons. The
    `Reset` button will get an instance method we'll define in this class, but since
    we decided that saving a file was the application object's responsibility, we're
    binding the `Save` button to an instance method on the parent object (accessed
    through this object's `master` attribute).
  prefs: []
  type: TYPE_NORMAL
- en: Binding GUI objects directly to commands on other objects is not a good way
    to approach the problem of inter-object communication, but for now it will do
    the job. In *Chapter 6*, *Planning for the Expansion of Our Application*, we'll
    learn a more elegant way to accomplish this.
  prefs: []
  type: TYPE_NORMAL
- en: 'That wraps up our `__init__()` method, but we''re going to need a couple more
    methods on this class before we''re done. First, we need to implement the `reset()`
    method that handles our form reset; it will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Essentially, we just need to set all our variables to an empty string. In the
    case of `BooleanVar` objects, though, this will raise an exception, so we need
    to set it to `False` to uncheck our checkbox.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we need a method that will allow the application object to retrieve
    data from the form so that it can save the data. In keeping with Tkinter convention,
    we''ll call this method `get()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The code here is very similar to the data retrieval code in the `on_save()`
    function of our previous version of the application, with a couple of differences.
    First, we're retrieving data from `self._vars` rather than a global variables
    dictionary. Secondly, in the event of an error, we're creating an error message
    and re-raising a `ValueError` rather than directly updating the GUI. We'll have
    to make sure that code that calls this method is written to handle a `ValueError`
    exception. Finally, rather than saving the data as we did in the previous version
    of the application, we're merely returning it.
  prefs: []
  type: TYPE_NORMAL
- en: That completes the form class! Now all that remains is to code an application
    to keep it in.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an application class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our application class is going to handle application-level functionality as
    well as being our top-level window. GUI-wise, it needs to contain:'
  prefs: []
  type: TYPE_NORMAL
- en: A title label
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An instance of our `DataRecordForm` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A status bar
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will also need a method to save the data in the form to a CSV.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin our class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Nothing new here, except that now we're subclassing `Tk` instead of `Frame`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s set up some window parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'As with the procedural version of the program, we''ve set the window title
    and configured the first column of the grid to expand. Now, we''ll create the
    title label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Nothing is really different here, except note that the parent object is now
    `self` – there isn't going to be a `root` object anymore; `self` is our `Tk` instance
    inside this class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a record form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Despite the size and complexity of `DataRecordForm`, adding it to the application
    is just like adding any other widget.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, for the status bar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Again, this is just like the procedural version, except that our `status` variable
    is an instance variable. This means it will be accessible to any of the methods
    in our class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s create a protected instance variable to hold the number of
    records saved:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'With `__init__()` finished up, we can now write the last method: _`on_save()`.
    This method will be very close to the procedural function we wrote previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Once again, this function generates the filename using the current date, and
    then opens the file in append mode. This time, though, we can get our data by
    simply calling `self.recordform.get()`, which abstracts the process of getting
    data from its variables. Remember that we do have to handle `ValueError` exceptions
    in case there is bad data in the form, which we've done here. In the case of bad
    data, we simply display the error in the status bar and exit before the method
    attempts to save the data. If there is no exception, the data is saved, so we
    increment the `_records_saved` attribute and update the status.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final thing we need to make this application run is to create an instance
    of our `Application` object and start its `mainloop`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Note that, other than our class definitions and module imports, these two lines
    are the only ones being executed in the top-level scope. Also, because `Application`
    takes care of building the GUI and other objects, we can execute it and the `mainloop()`
    call together at the end of the application using the `if __name__ == "__main__"`
    guard.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned to take advantage of the power of Python classes.
    You learned to create your own classes, to define attributes and methods, and
    the function of magic methods. You also learned how to extend the functionality
    of existing classes with subclassing.
  prefs: []
  type: TYPE_NORMAL
- en: We explored how these techniques can be applied powerfully to Tkinter classes,
    to extend their functionality, build compound widgets, and organize our application
    into components.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll learn about Tkinter's validation features, and further
    employ subclassing to make our widgets more intuitive and robust. We'll also learn
    how to automate input to save users time and ensure consistent data entry.
  prefs: []
  type: TYPE_NORMAL
