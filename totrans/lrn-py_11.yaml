- en: Chapter 11. Debugging and Troubleshooting
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章。调试和故障排除
- en: '|   | *"If debugging is the process of removing software bugs, then programming
    must be the process of putting them in."* |   |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '|   | *"如果调试是移除软件错误的过程，那么编程就必须是引入它们的过程。"* |   |'
- en: '|   | --*Edsger W. Dijkstra* |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|   | --*埃德加·W·迪杰斯特拉* |'
- en: In the life of a professional coder, debugging and troubleshooting take up a
    significant amount of time. Even if you work on the most beautiful codebase ever
    written by man, there will still be bugs in it, that is guaranteed.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在专业程序员的生涯中，调试和故障排除占据了相当多的时间。即使你从事的是人类写过的最漂亮的代码库，其中仍然会有错误，这是肯定的。
- en: We spend an awful lot of time reading other people's code and, in my opinion,
    a good software developer is someone who keeps their attention high, even when
    they're reading code that is not reported to be wrong or buggy.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们花了很多时间阅读别人的代码，在我看来，一个优秀的软件开发者即使在阅读的不是报告为错误或存在错误的代码时，也能保持高度的关注。
- en: Being able to debug code efficiently and quickly is a skill that any coder needs
    to keep improving. Some think that because they have read the manual, they're
    fine, but the reality is, the number of variables in the game is so big that there
    is no manual. There are guidelines that one can follow, but there is no magic
    book that will teach you everything you need to know in order to become good at
    this.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 能够高效快速地调试代码是任何程序员都需要不断改进的技能。有些人认为，因为他们已经阅读了手册，所以他们没问题，但现实是，游戏中的变量数量如此之大，以至于没有手册。有一些可以遵循的指南，但没有一本魔法书能教你成为调试高手所需知道的一切。
- en: I feel that on this particular subject, I have learned the most from my colleagues.
    It amazes me to observe someone very skilled attacking a problem. I enjoy seeing
    the steps they take, the things they verify to exclude possible causes, and the
    way they consider the suspects that eventually lead them to the solution to the
    problem.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我觉得，在这个特定的问题上，我从我的同事那里学到了最多的东西。看到一个非常熟练的人攻击问题让我感到惊讶。我喜欢看到他们采取的步骤，他们验证的事情，以排除可能的原因，以及他们考虑的嫌疑人，最终引导他们找到问题的解决方案。
- en: Every colleague we work with can teach us something, or surprise us with a fantastic
    guess that turns out to be the right one. When that happens, don't just remain
    in wonderment (or worse, in envy), but seize the moment and ask them how they
    got to that guess and why. The answer will allow you to see if there is something
    you can study in deep later on so that, maybe next time, you'll be the one who
    will catch the bug.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们与每一个同事合作都能学到一些东西，或者用他们那惊人的猜测来让我们感到惊讶，而这些猜测最终被证明是正确的。当这种情况发生时，不要只是感到惊奇（或者更糟，感到嫉妒），而要抓住这个机会，问他们是如何得出这个猜测的，为什么。这个答案将让你看到，你能否在以后深入研究，以便下次，你将成为那个抓住错误的人。
- en: Some bugs are very easy to spot. They come out of coarse mistakes and, once
    you see the effects of those mistakes, it's easy to find a solution that fixes
    the problem.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 有些错误很容易发现。它们来自粗心大意的错误，一旦你看到这些错误的影响，就很容易找到解决问题的解决方案。
- en: But there are other bugs which are much more subtle, much more slippery, and
    require true expertise, and a great deal of creativity and out-of-the-box thinking,
    to be dealt with.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 但还有其他一些错误更加微妙，更加难以捉摸，需要真正的专业知识，以及大量的创造性和跳出思维，才能解决。
- en: The worst of all, at least for me, are the nondeterministic ones. These sometimes
    happen, and sometimes don't. Some happen only in environment A but not in environment
    B, even though A and B are supposed to be exactly the same. Those bugs are the
    true evil ones, and they can drive you crazy.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我来说，最糟糕的是那些非确定性的问题。这些有时会发生，有时不会。有些问题只发生在环境A中，而不发生在环境B中，尽管A和B应该完全相同。这些错误是真正的邪恶，它们可以让你发疯。
- en: And of course, bugs don't just happen in the sandbox, right? With your boss
    telling you "*don't worry! take your time to fix this, have lunch first!*". Nope.
    They happen on a Friday at half past five, when your brain is cooked and you just
    want to go home. It's in those moments, when everyone is getting upset in a split
    second, when your boss is breathing on your neck, that you have to be able to
    keep calm. And I do mean it. That's the most important skill to have if you want
    to be able to fight bugs effectively. If you allow your mind to get stressed,
    say goodbye to creative thinking, to logic deduction, and to everything you need
    at that moment. So take a deep breath, sit properly, and focus.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，错误不仅仅发生在沙盒中，对吧？当你的老板告诉你“*别担心！慢慢来修复这个问题，先吃午饭吧!*”。不。它们发生在周五下午五点半，那时你的大脑已经疲惫，你只想回家。就在那一刻，当每个人都瞬间变得焦躁不安，当你的老板在你耳边喘息时，你必须能够保持冷静。我确实是这么说的。如果你让大脑紧张，那么就告别创造性思维、逻辑推理以及你当时需要的所有东西。所以深呼吸，坐好，集中注意力。
- en: In this chapter, I will try to demonstrate some useful techniques that you can
    employ according to the severity of the bug, and a few suggestions that will hopefully
    boost your weapons against bugs and issues.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我将尝试展示一些有用的技巧，你可以根据错误的严重程度来使用它们，以及一些希望有助于增强你对错误和问题的武器的建议。
- en: Debugging techniques
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试技巧
- en: In this part, I'll present you with the most common techniques, the ones I use
    most often, however, please don't consider this list to be exhaustive.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分，我将向你展示最常用的技术，我最常用的技术，然而，请不要认为这个列表是详尽的。
- en: Debugging with print
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`print`进行调试
- en: This is probably the easiest technique of all. It's not very effective, it cannot
    be used everywhere and it requires access to both the source code and a terminal
    that will run it (and therefore show the results of the print function calls).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是所有技巧中最简单的一个。它并不非常有效，不能在所有地方使用，并且需要访问源代码以及运行它的终端（因此可以显示`print`函数调用的结果）。
- en: However, in many situations, this is still a quick and useful way to debug.
    For example, if you are developing a Django website and what happens in a page
    is not what would you expect, you can fill the view with prints and keep an eye
    on the console while you reload the page. I've probably done it a million times.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在许多情况下，这仍然是一种快速且有用的调试方法。例如，如果你正在开发一个Django网站，页面上的情况并不是你所期望的，你可以在视图中添加`print`语句，并在重新加载页面时留意控制台。我可能已经做过无数次了。
- en: When you scatter calls to `print` in your code, you normally end up in a situation
    where you duplicate a lot of debugging code, either because you're printing a
    timestamp (like we did when we were measuring how fast list comprehensions and
    generators were), or because you have to somehow build a string of some sort that
    you want to display.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在代码中分散`print`调用时，你通常最终会陷入一个重复大量调试代码的情况，要么是因为你在打印时间戳（就像我们测量列表解析和生成器速度时做的那样），要么是因为你必须以某种方式构建一个你想要显示的字符串。
- en: Another issue is that it's extremely easy to forget calls to `print` in your
    code.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题是在你的代码中很容易忘记调用`print`。
- en: So, for these reasons, rather than using a bare call to `print`, I sometimes
    prefer to code a custom function. Let's see how.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，与其使用裸露的`print`调用，我有时更喜欢编写一个自定义函数。让我们看看怎么做。
- en: Debugging with a custom function
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用自定义函数进行调试
- en: Having a custom function in a snippet that you can quickly grab and paste into
    the code, and then use to debug, can be very useful. If you're fast, you can always
    code one on the fly. The important thing is to code it in a way that it won't
    leave stuff around when you eventually remove the calls and its definition, therefore
    *it's important to code it in a way that is completely self-contained*. Another
    good reason for this requirement is that it will avoid potential name clashes
    with the rest of the code.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码片段中有一个自定义函数，你可以快速抓取并粘贴到代码中，然后用来调试，这可以非常有用。如果你动作快，你总是可以即兴编写一个。重要的是要以一种方式编写代码，这样在你最终移除调用和定义时不会留下任何东西，因此*重要的是要以一种完全自包含的方式编写代码*。这个要求的好另一个原因是它可以避免与代码中其他部分的潜在名称冲突。
- en: Let's see an example of such a function.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这样一个函数的例子。
- en: '`custom.py`'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`custom.py`'
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this case, I am using a keyword-only argument to be able to print a separator,
    which is a line of 40 dashes.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我使用关键字参数来能够打印一个分隔符，即一串40个短横线。
- en: 'The function is very simple, I just redirect whatever is in `msg` to a call
    to `print` and, if `print_separator` is `True`, I print a line separator. Running
    the code will show:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数非常简单，我只是将`msg`中的任何内容重定向到`print`的调用，如果`print_separator`为`True`，我打印一个行分隔符。运行代码将显示：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, there is no separator after the last line.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，最后一行后面没有分隔符。
- en: This is just one easy way to somehow augment a simple call to the `print` function.
    Let's see how we can calculate a time difference between calls, using one of Python's
    tricky features to our advantage.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是增加简单调用`print`函数的一种简单方法。让我们看看我们如何利用Python的一个巧妙特性来计算调用之间的时间差。
- en: '`custom_timestamp.py`'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`custom_timestamp.py`'
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is a bit trickier, but still quite simple. First notice we import the `time`
    function from the `time` module from the `debug` function. This allows us to avoid
    having to add that import outside of the function, and maybe forget it there.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这有点棘手，但仍然相当简单。首先注意我们是从`debug`函数中导入`time`模块的`time`函数。这允许我们避免在函数外部添加该导入，也许会忘记它。
- en: Take a look at how I defined `timestamp`. It's a list, of course, but what's
    important here is that it is a *mutable* object. This means that it will be set
    up when Python parses the function and it will retain its value throughout different
    calls. Therefore, if we put a timestamp in it after each call, we can keep track
    of time without having to use an external global variable. I borrowed this trick
    from my studies on **closures**, a technique that I encourage you to read about
    because it's very interesting.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 看看我是如何定义`timestamp`的。它当然是一个列表，但这里重要的是它是一个*可变*对象。这意味着当Python解析函数时，它将被设置，并且在整个不同的调用过程中保持其值。因此，如果我们每次调用后都在其中放入一个时间戳，我们就可以在不使用外部全局变量的情况下跟踪时间。我从对**闭包**的研究中借用了这个技巧，这是一个我鼓励你阅读的非常有意思的技术。
- en: Right, so, after having printed whatever message we had to print and importing
    time, we then inspect the content of the only item in `timestamp`. If it is `None`,
    we have no previous reference, therefore we set the value to the current time
    (`#1`).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 对了，所以，在打印了我们必须打印的任何消息并导入时间后，我们检查`timestamp`中唯一项的内容。如果它是`None`，那么我们没有先前的引用，因此我们将值设置为当前时间（`#1`）。
- en: On the other hand, if we have a previous reference, we can calculate a difference
    (which we nicely format to three decimal digits) and then we finally put the current
    time again in `timestamp` (`#2`). It's a nice trick, isn't it?
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果我们有一个先前的引用，我们可以计算一个差值（我们将其格式化为三位小数），然后我们最终再次在`timestamp`中放入当前时间（`#2`）。这是一个很好的技巧，不是吗？
- en: 'Running this code shows this result:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码会显示此结果：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Whatever is your situation, having a self contained function like this can be
    very useful.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你的情况如何，拥有这样一个自包含的函数非常有用。
- en: Inspecting the traceback
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查traceback
- en: 'We briefly talked about the traceback in [Chapter 7](ch07.html "Chapter 7. Testing,
    Profiling, and Dealing with Exceptions"), *Testing, Profiling, and Dealing with
    Exceptions* when we saw several different kinds of exceptions. The traceback gives
    you information about what happened in your application that went wrong. You get
    a great help from reading it. Let''s see a very small example:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第7章](ch07.html "第7章。测试、分析和处理异常")中简要介绍了traceback，*测试、分析和处理异常*，当我们看到几种不同类型的异常时。traceback提供了关于你的应用程序中发生错误的信息。阅读它将给你很大的帮助。让我们看一个非常小的例子：
- en: '`traceback_simple.py`'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`traceback_simple.py`'
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We have a dict and we have tried to access a key which isn''t in it. You should
    remember that this will raise a `KeyError` exception. Let''s run the code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个字典，我们尝试访问其中不存在的键。你应该记住这将引发一个`KeyError`异常。让我们运行代码：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You can see that we get all the information we need: the module name, the line
    that caused the error (both the number and the instruction), and the error itself.
    With this information, you can go back to the source code and try and understand
    what''s going wrong.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到我们得到了我们需要的所有信息：模块名称、导致错误的行（编号和指令），以及错误本身。有了这些信息，你可以回到源代码并尝试理解出了什么问题。
- en: 'Let''s now create a more interesting example that builds on this, and exercises
    a feature that is only available in Python 3\. Imagine that we''re validating
    a dict, working on mandatory fields, therefore we expect them to be there. If
    not, we need to raise a custom `ValidationError`, that we will trap further upstream
    in the process that runs the validator (which is not shown here, it could be anything,
    really). It should be something like this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来创建一个更有趣的例子，这个例子基于这个例子，并练习一个仅在 Python 3 中可用的功能。想象一下，我们正在验证一个字典，处理必填字段，因此我们期望它们存在。如果不存在，我们需要引发一个自定义的
    `ValidationError`，我们将在运行验证器的流程中进一步捕获它（这里没有展示，它可以是任何东西）。它应该像这样：
- en: '`traceback_validator.py`'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`traceback_validator.py`'
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We define a custom exception that is raised when the mandatory key isn't there.
    Note that its body consists of its documentation string so we don't need to add
    any other statements.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义一个自定义异常，当必填键不存在时引发。请注意，其主体由其文档字符串组成，因此我们不需要添加任何其他语句。
- en: Very simply, we define a dummy dict and try to access it using `mandatory_key`.
    We trap the `KeyError` and raise `ValidatorError` when that happens. The purpose
    of doing this is that we may also want to raise `ValidatorError` in other circumstances,
    not necessarily as a consequence of a mandatory key being missing. This technique
    allows us to run the validation in a simple `try`/`except` that only cares about
    `ValidatorError`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 非常简单，我们定义一个虚拟字典并尝试使用 `mandatory_key` 访问它。当发生这种情况时，我们捕获 `KeyError` 并引发 `ValidatorError`。这样做的原因是，我们可能还希望在其他情况下引发
    `ValidatorError`，而不仅仅是由于缺少必填键。这种技术允许我们在简单的 `try`/`except` 中运行验证，它只关心 `ValidatorError`。
- en: 'The thing is, in Python 2, this code would just display the last exception
    (`ValidatorError`), which means we would lose the information about the `KeyError`
    that precedes it. In Python 3, this behavior has changed and exceptions are now
    chained so that you have a much better information report when something happens.
    The code produces this result:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是，在 Python 2 中，这段代码只会显示最后一个异常（`ValidatorError`），这意味着我们会失去关于其前面的 `KeyError`
    的信息。在 Python 3 中，这种行为已经改变，异常现在是链式的，因此当发生问题时，你会得到更好的信息报告。代码产生以下结果：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is brilliant, because we can see the traceback of the exception that led
    us to raise `ValidationError`, as well as the traceback for the `ValidationError`
    itself.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这很棒，因为我们可以看到导致我们引发 `ValidationError` 的异常的堆栈跟踪，以及 `ValidationError` 本身的堆栈跟踪。
- en: I had a nice discussion with one of my reviewers about the traceback you get
    from the `pip` installer. He was having trouble setting everything up in order
    to review the code for [Chapter 9](ch09.html "Chapter 9. Data Science"), *Data
    Science*. His fresh Ubuntu installation was missing a few libraries that were
    needed by the `pip` packages in order to run correctly.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我和我的一个审稿人关于从 `pip` 安装程序获得的堆栈跟踪进行了愉快的讨论。他在设置一切以便审查 [第 9 章](ch09.html "第 9 章。数据科学")
    的代码时遇到了麻烦，*数据科学*。他的新 Ubuntu 安装缺少一些库，这些库是 `pip` 包正常运行所必需的。
- en: The reason he was blocked was that he was trying to fix the errors displayed
    in the traceback starting from the top one. I suggested that he started from the
    bottom one instead, and fix that. The reason was that, if the installer had gotten
    to that last line, I guess that before that, whatever error may have occurred,
    it was still possible to recover from it. Only after the last line, `pip` decided
    it wasn't possible to continue any further, and therefore I started fixing that
    one. Once the libraries required to fix that error had been installed, everything
    else went smoothly.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 他受阻的原因是他试图从堆栈跟踪的顶部开始修复显示的错误。我建议他从底部开始修复。原因是，如果安装程序已经到达最后一行，我猜在那之前，无论发生什么错误，都有可能恢复。只有当
    `pip` 决定无法继续进行时，才会到达最后一行，因此我开始修复那一行。一旦安装了修复该错误所需的库，其他一切都会顺利。
- en: Reading a traceback can be tricky, and my friend was lacking the necessary experience
    to address this problem correctly, therefore, if you end up in the same situation,
    don't be discouraged, and try to shake things up a bit, don't take anything for
    granted.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读堆栈跟踪可能很棘手，我的朋友缺乏处理这个问题的必要经验，因此，如果你陷入同样的情况，不要气馁，试着稍微改变一下，不要想当然。
- en: Python has a huge and wonderful community and it's very unlikely that, when
    you encounter a problem, you're the first one to see it, so open a browser and
    search. By doing so, your searching skills will also improve because you will
    have to trim the error down to the minimum but essential set of details that will
    make your search effective.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Python 拥有一个庞大而精彩的社区，当你遇到问题时，你不太可能是第一个看到它的人，所以打开浏览器并搜索。通过这样做，你的搜索技巧也会提高，因为你必须将错误缩减到最小但最关键的细节集，这将使你的搜索变得有效。
- en: If you want to play and understand the traceback a bit better, in the standard
    library there is a module called, surprise surprise, `traceback` that you can
    use. It provides a standard interface to extract, format, and print stack traces
    of Python programs, mimicking exactly the behavior of the Python interpreter when
    it prints a stack trace.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要更好地玩耍和理解回溯，在标准库中有一个名为 `traceback` 的模块，你可以使用它。它提供了一个标准的接口来提取、格式化和打印 Python
    程序的堆栈跟踪，这与 Python 解释器打印堆栈跟踪时的行为完全一致。
- en: Using the Python debugger
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Python 调试器
- en: 'Another very effective way of debugging Python is to use the Python debugger:
    **pdb**. If you are addicted to the IPython console, like me, you should definitely
    check out the **ipdb** library. *ipdb* augments the standard *pdb* interface like
    IPython does with the Python console.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种非常有效的调试 Python 的方法是使用 Python 调试器：**pdb**。如果你像我一样沉迷于 IPython 控制台，那么你绝对应该检查一下
    **ipdb** 库。*ipdb* 增强了标准的 *pdb* 接口，就像 IPython 对 Python 控制台所做的那样。
- en: There are several different ways of using this debugger (whichever version,
    it is not important), but the most common one consists of simply setting a breakpoint
    and running the code. When Python reaches the breakpoint, execution is suspended
    and you get console access to that point so that you can inspect all the names,
    and so on. You can also alter data on the fly to change the flow of the program.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个调试器的几种不同方法（无论哪个版本，这并不重要），但最常见的一种方法就是简单地设置一个断点并运行代码。当 Python 达到断点时，执行会暂停，你将获得对该点的控制台访问权限，以便你可以检查所有名称等。你还可以动态地更改数据以改变程序的流程。
- en: As a toy example, let's pretend we have a parser that is raising a `KeyError`
    because a key is missing in a dict. The dict is from a JSON payload that we cannot
    control, and we just want, for the time being, to cheat and pass that control,
    since we're interested in what comes afterwards. Let's see how we could intercept
    this moment, inspect the data, fix it and get to the bottom, with *ipdb*.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个小例子，让我们假装我们有一个解析器，它因为字典中缺少键而引发 `KeyError`。这个字典来自我们无法控制的 JSON 有效载荷，而我们目前只想暂时欺骗并传递这个控制权，因为我们对之后发生的事情感兴趣。让我们看看我们如何能够拦截这个时刻，检查数据，修复它，并使用
    *ipdb* 到达底部。
- en: '`ipdebugger.py`'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`ipdebugger.py`'
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As you can see, this code will break when `key` gets the value `''third''`,
    which is missing in the dict. Remember, we''re pretending that both `d` and `keys`
    come dynamically from a JSON payload we don''t control, so we need to inspect
    them in order to fix `d` and pass the `for` loop. If we run the code as it is,
    we get the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，当 `key` 获取到字典中缺失的值 `'third'` 时，这段代码将会中断。记住，我们假装 `d` 和 `keys` 都是从我们无法控制的
    JSON 有效载荷中动态获取的，因此我们需要检查它们以修复 `d` 并通过 `for` 循环。如果我们按原样运行代码，我们会得到以下结果：
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: So we see that that `key` is missing from the dict, but since every time we
    run this code we may get a different dict or `keys` tuple, this information doesn't
    really help us. Let's inject a call to *ipdb*.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 因此我们看到 `key` 在字典中缺失，但由于每次我们运行这段代码时我们可能得到不同的字典或 `keys` 元组，这个信息实际上并没有真正帮助我们。让我们注入一个对
    *ipdb* 的调用。
- en: '`ipdebugger_ipdb.py`'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`ipdebugger_ipdb.py`'
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If we now run this code, things get interesting (note that your output may
    vary a little and that all the comments in this output were added by me):'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行这段代码，事情会变得有趣（请注意，你的输出可能略有不同，并且这个输出中的所有注释都是我添加的）：
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This is very interesting. First, note that, when you reach a breakpoint, you're
    served a console that tells you where you are (the Python module) and which line
    is the next one to be executed. You can, at this point, perform a bunch of exploratory
    actions, such as inspecting the code before and after the next line, printing
    a stacktrace, interacting with the objects, and so on. Please consult the official
    Python documentation on *pdb* to learn more about this. In our case, we first
    inspect the `keys` tuple. After that, we inspect the keys of `d`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常有趣。首先，请注意，当你达到断点时，你会得到一个控制台，告诉你你在哪里（Python 模块）以及下一行要执行的哪一行。此时，你可以执行一系列探索性操作，例如检查下一行之前和之后的代码，打印堆栈跟踪，与对象交互等。请查阅官方
    Python 文档中的 *pdb* 了解更多。在我们的例子中，我们首先检查 `keys` 元组。之后，我们检查 `d` 的键。
- en: Have you noticed that exclamation mark I prepended to `d`? It's needed because
    `d` is a command in the *pdb* interface that moves the frame (*d*)own.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到我在 `d` 前面加上的感叹号了吗？这是必需的，因为 `d` 是 *pdb* 接口中的一个命令，用于将帧 (*d*)own 移动。
- en: Note
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'I indicate commands within the *ipdb* shell with this notation: each command
    is activated by one letter, which typically is the first letter of the command
    name. So, *d* for *down*, *n* for *next*, and *s* for *step* become, more concisely,
    (*d*)own, (*n*)ext and (*s*)tep.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我在 *ipdb* 壳中使用这种符号表示命令：每个命令通过一个字母激活，通常是命令名称的第一个字母。所以，*d* 对应 *down*，*n* 对应 *next*，*s*
    对应 *step*，更简洁地表示为 (*d*)own，(*n*)ext 和 (*s*)tep。
- en: I guess this is a good enough reason to have better names, right? Indeed, but
    I needed to show you this, so I chose to use `d`. In order to tell *pdb* that
    we're not yielding a (*d*)own command, we put "`!`" in front of `d` and we're
    fine.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我想这足够成为有一个更好的名字的理由，对吧？确实如此，但我需要向你展示这一点，所以我选择了使用 `d`。为了告诉 *pdb* 我们不是要执行 (*d*)own
    命令，我们在 `d` 前面加上 "`!`"，这样我们就没问题了。
- en: After seeing the keys of `d`, we see that `'third'` is missing, so we put it
    in ourselves (could this be dangerous? think about it). Finally, now that all
    the keys are in, we type `c`, which means (*c*)ontinue.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看 `d` 的键之后，我们发现 `'third'` 缺失，所以我们自己添加了它（这可能会很危险？想想看）。最后，现在所有的键都已经添加完毕，我们输入
    `c`，这意味着 (*c*)ontinue。
- en: '*pdb* also gives you the ability to proceed with your code one line at a time
    using (*n*)ext, to (*s*)tep into a function for deeper analysis, or handling breaks
    with (*b*)reak. For a complete list of commands, please refer to the documentation
    or type (*h*)elp in the console.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*pdb* 还能让你使用 (*n*)ext 逐行执行代码，(*s*)tep 进入函数进行深入分析，或使用 (*b*)reak 处理中断。有关命令的完整列表，请参阅文档或在控制台中输入
    (*h*)elp。'
- en: You can see from the output that we could finally get to the end of the validation.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中你可以看到，我们最终到达了验证的末尾。
- en: '*pdb* (or *ipdb*) are invaluable tools that I use every day, I couldn''t live
    without them. So, go and have fun, set a breakpoint somewhere and try and inspect,
    follow the official documentation and try the commands in your code to see their
    effect and learn them well.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*pdb*（或 *ipdb*）是我每天都会使用的无价工具，没有它们我无法生活。所以，去享受吧，在某个地方设置一个断点，尝试检查，遵循官方文档，并在你的代码中尝试命令以查看它们的效果并熟练掌握它们。'
- en: Inspecting log files
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查日志文件
- en: Another way of debugging a misbehaving application is to inspect its log files.
    **Log files** are special files in which an application writes down all sorts
    of things, normally related to what's going on inside of it. If an important procedure
    is started, I would typically expect a line for that in the logs. It is the same
    when it finishes, and possibly for what happens inside of it.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种调试表现不佳的应用程序的方法是检查其日志文件。**日志文件**是特殊文件，其中应用程序记录了各种信息，通常与它内部发生的事情有关。如果启动了重要的程序，我通常会期望在日志中有一条记录。当它完成时，以及可能在其内部发生的事情，情况也是如此。
- en: Errors need to be logged so that when a problem happens we can inspect what
    went wrong by taking a look at the information in the log files.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 需要将错误记录下来，这样当出现问题的时候，我们可以通过查看日志文件中的信息来检查发生了什么。
- en: 'There are many different ways to set up a logger in Python. Logging is very
    malleable and you can configure it. In a nutshell, there are normally four players
    in the game: loggers, handlers, filters, and formatters:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中设置记录器有许多不同的方法。日志记录非常灵活，你可以配置它。简而言之，游戏中通常有四个参与者：记录器、处理器、过滤器、和格式化器：
- en: '**Loggers** expose the interface that the application code uses directly'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**记录器**暴露了应用程序代码直接使用的接口'
- en: '**Handlers** send the log records (created by loggers) to the appropriate destination'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理器**将日志记录（由记录器创建）发送到适当的目的地'
- en: '**Filters** provide a finer grained facility for determining which log records
    to output'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过滤器**提供了更细粒度的功能，用于确定要输出的日志记录'
- en: '**Formatters** specify the layout of the log records in the final output'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**格式化器**指定最终输出中日志记录的布局'
- en: 'Logging is performed by calling methods on instances of the `Logger` class.
    Each line you log has a level. The levels normally used are: `DEBUG`, `INFO`,
    `WARNING`, `ERROR`, and `CRITICAL`. You can import them from the `logging` module.
    They are in order of severity and it''s very important to use them properly because
    they will help you filter the contents of a log file based on what you''re searching
    for. Log files usually become extremely big so it''s very important to have the
    information in them written properly so that you can find it quickly when it matters.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 日志是通过调用`Logger`类实例的方法来执行的。您记录的每一行都有一个级别。通常使用的级别有：`DEBUG`、`INFO`、`WARNING`、`ERROR`和`CRITICAL`。您可以从`logging`模块导入它们。它们按照严重性顺序排列，并且正确使用它们非常重要，因为它们将帮助您根据您正在搜索的内容过滤日志文件的内容。日志文件通常变得非常大，因此确保其中的信息被正确写入非常重要，这样在需要时您可以快速找到它们。
- en: You can log to a file but you can also log to a network location, to a queue,
    to a console, and so on. In general, if you have an architecture that is deployed
    on one machine, logging to a file is acceptable, but when your architecture spans
    over multiple machines (such as in the case of **service-oriented architectures**),
    it's very useful to implement a centralized solution for logging so that all log
    messages coming from each service can be stored and investigated in a single place.
    It helps a lot, otherwise you can really go crazy trying to correlate giant files
    from several different sources to figure out what went wrong.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将日志记录到文件中，但您也可以将日志记录到网络位置、队列、控制台等。一般来说，如果您有一个部署在单个机器上的架构，将日志记录到文件是可以接受的，但当您的架构跨越多个机器（例如在**面向服务的架构**的情况下），实现一个集中式的日志解决方案非常有用，这样所有来自每个服务的日志消息都可以存储和调查在一个地方。这非常有帮助，否则您真的会疯狂地尝试关联来自几个不同来源的巨大文件，以找出出了什么问题。
- en: Note
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A **service-oriented architecture** (**SOA**) is an architectural pattern in
    software design in which application components provide services to other components
    via a communications protocol, typically over a network. The beauty of this system
    is that, when coded properly, each service can be written in the most appropriate
    language to serve its purpose. The only thing that matters is the communication
    with the other services, which needs to happen via a common format so that data
    exchange can be done.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**面向服务的架构**（**SOA**）是软件设计中的一个架构模式，其中应用程序组件通过通信协议（通常是网络）向其他组件提供服务。这个系统的美妙之处在于，当代码编写得当，每个服务都可以用最合适的语言来编写以实现其目的。唯一重要的是与其他服务的通信，这需要通过一个公共格式来实现，以便进行数据交换。'
- en: 'Here, I will present you with a very simple logging example. We will log a
    few messages to a file:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我将向您展示一个非常简单的日志示例。我们将记录几条消息到一个文件中：
- en: '`log.py`'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`log.py`'
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Let's go through it line by line. First, we import the `logging` module, then
    we set up a basic configuration. In general, a production logging configuration
    is much more complicated than this, but I wanted to keep things as easy as possible.
    We specify a filename, the minimum logging level we want to capture in the file,
    and the message format. We'll log the date and time information, the level, and
    the message.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一行一行地过一遍。首先，我们导入`logging`模块，然后设置基本配置。一般来说，生产环境的日志配置比这要复杂得多，但我希望尽可能保持简单。我们指定一个文件名，我们希望在文件中捕获的最小日志级别，以及消息格式。我们将记录日期和时间信息，日志级别和消息内容。
- en: I will start by logging an `info` message that tells me we're about to process
    our list. Then, I will log (this time using the `DEBUG` level, by using the `debug`
    function) which is the value at some position. I'm using `debug` here because
    I want to be able to filter out these logs in the future (by setting the minimum
    level to `logging.INFO` or more), because I might have to handle very big lists
    and I don't want to log all the values.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我将首先记录一个`info`消息，告诉我我们即将处理我们的列表。然后，我将记录（这次使用`DEBUG`级别，通过使用`debug`函数）某个位置上的值。我在这里使用`debug`是因为我希望将来能够过滤掉这些日志（通过将最小级别设置为`logging.INFO`或更高），因为我可能需要处理非常大的列表，并且我不想记录所有值。
- en: If we get an `IndexError` (and we do, since I'm looping over `range(4)`), we
    call `logging.exception()`, which is the same as `logging.error()`, but it also
    prints the traceback.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们得到一个`IndexError`（我们确实得到了，因为我正在遍历`range(4)`），我们调用`logging.exception()`，它与`logging.error()`相同，但它也会打印跟踪信息。
- en: 'At the end of the code, I log another `info` message saying we''re done. The
    result is this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的末尾，我记录了一条`info`消息，说明我们已经完成。结果是这个：
- en: '[PRE13]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This is exactly what we need to be able to debug an application that is running
    on a box, and not on our console. We can see what went on, the traceback of any
    exception raised, and so on.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们能够调试在机器上运行的应用程序而不是在控制台上的应用程序所需要的。我们可以看到发生了什么，任何抛出的异常的跟踪信息，等等。
- en: Note
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The example presented here only scratches the surface of logging. For a more
    in-depth explanation, you can find a very nice introduction in the how to ([https://docs.python.org/3.4/howto/logging.html](https://docs.python.org/3.4/howto/logging.html))
    section of the official Python documentation.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这里提供的示例只是对日志记录的表面了解。对于更深入的解释，你可以在官方Python文档的如何（[https://docs.python.org/3.4/howto/logging.html](https://docs.python.org/3.4/howto/logging.html)）部分找到一个非常好的介绍。
- en: Logging is an art, you need to find a good balance between logging everything
    and logging nothing. Ideally, you should log anything that you need to make sure
    your application is working correctly, and possibly all errors or exceptions.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 日志记录是一种艺术，你需要在记录一切和记录什么都不记录之间找到一个好的平衡。理想情况下，你应该记录任何你需要确保应用程序正确运行的信息，以及可能的所有错误或异常。
- en: Other techniques
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他技术
- en: In this final section, I'd like to demonstrate briefly a couple of techniques
    that you may find useful.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的最后，我想简要演示一些你可能觉得有用的技术。
- en: Profiling
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 性能分析
- en: We talked about profiling in [Chapter 7](ch07.html "Chapter 7. Testing, Profiling,
    and Dealing with Exceptions"), *Testing, Profiling, and Dealing with Exceptions*,
    and I'm only mentioning it here because profiling can sometimes explain weird
    errors that are due to a component being too slow. Especially when networking
    is involved, having an idea of the timings and latencies your application has
    to go through is very important in order to understand what may be going on when
    problems arise, therefore I suggest you get acquainted with profiling techniques
    also for a troubleshooting perspective.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第7章](ch07.html "第7章。测试、性能分析和处理异常")中讨论了性能分析，*测试、性能分析和处理异常*，我在这里只是提到它，因为性能分析有时可以解释由于组件运行太慢而导致的奇怪错误。特别是当涉及到网络时，了解你的应用程序必须经历的时间和时间延迟对于理解问题出现时可能发生的情况非常重要，因此我建议你也从故障排除的角度熟悉性能分析技术。
- en: Assertions
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 断言
- en: 'Assertions are a nice way to make your code ensure your assumptions are verified.
    If they are, all proceeds regularly but, if they are not, you get a nice exception
    that you can work with. Sometimes, instead of inspecting, it''s quicker to drop
    a couple of assertions in the code just to exclude possibilities. Let''s see an
    example:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 断言是确保你的假设得到验证的好方法。如果它们是，一切都会按常规进行，但如果它们不是，你会得到一个很好的异常，你可以处理它。有时，与其检查，不如在代码中添加几个断言来排除可能性。让我们看看一个例子：
- en: '`assertions.py`'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`assertions.py`'
- en: '[PRE14]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This code simulates a situation in which `mylist` isn''t defined by us like
    that, of course, but we''re assuming it has four elements. So we put an assertion
    there, and the result is this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码模拟了一个情况，其中`mylist`当然不是由我们这样定义的，但我们假设它有四个元素。所以我们那里放了一个断言，结果是这个：
- en: '[PRE15]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This tells us exactly where the problem is.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们问题确实在哪里。
- en: Where to find information
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 去哪里寻找信息
- en: In the Python official documentation, there is a section dedicated to debugging
    and profiling, where you can read up about the `bdb` debugger framework, and about
    modules such as `faulthandler`, `timeit`, `trace`, `tracemallock`, and of course
    *pdb*. Just head to the standard library section in the documentation and you'll
    find all this information very easily.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python官方文档中，有一个专门介绍调试和性能分析的章节，你可以阅读有关`bdb`调试框架以及`faulthandler`、`timeit`、`trace`、`tracemalloc`和当然还有*pdb*等模块的内容。只需前往文档中的标准库部分，你就可以很容易地找到所有这些信息。
- en: Troubleshooting guidelines
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 故障排除指南
- en: In this short section, I'll like to give you a few tips that come from my troubleshooting
    experience.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简短的章节中，我想分享一些来自我的故障排除经验的技巧。
- en: Using console editors
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用控制台编辑器
- en: First, get comfortable using **vim** or **nano** as an editor, and learn the
    basics of the console. When things break bad you don't have the luxury of your
    editor with all the bells and whistles there. You have to connect to a box and
    work from there. So it's a very good idea to be comfortable browsing your production
    environment with console commands, and be able to edit files using console-based
    editors such as vi, vim, or nano. Don't let your usual development environment
    spoil you, because you'll have to pay a price if you do.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，熟悉使用**vim**或**nano**作为编辑器，并学习控制台的基本知识。当事情变得糟糕时，你没有使用带有所有铃声和哨声的编辑器的奢侈。你必须连接到一个盒子并在那里工作。所以，熟悉使用控制台命令浏览你的生产环境，并能够使用基于控制台的编辑器（如vi、vim或nano）编辑文件是非常好的主意。不要让你的常规开发环境宠坏你，因为如果你这样做，你将不得不付出代价。
- en: Where to inspect
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查的位置
- en: My second suggestion is on where to place your debugging breakpoints. It doesn't
    matter if you are using `print`, a custom function, or *ipdb*, you still have
    to choose where to place the calls that provide you with the information, right?
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我的第二个建议是关于在哪里放置调试断点。无论你是在使用`print`、自定义函数还是*ipdb*，你仍然需要选择放置提供信息的调用位置，对吧？
- en: Well, some places are better than others, and there are ways to handle the debugging
    progression that are better than others.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，有些地方比其他地方更好，而且有一些处理调试进度的方法比其他方法更好。
- en: I normally avoid placing a breakpoint in an `if` clause because, if that clause
    is not exercised, I lose the chance of getting the information I wanted. Sometimes
    it's not easy or quick to get to the breakpoint, so think carefully before placing
    them.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我通常避免在`if`子句中放置断点，因为如果这个子句没有被执行，我就失去了获取所需信息的机会。有时候到达断点并不容易或快速，所以在放置它们之前要仔细思考。
- en: Another important thing is where to start. Imagine that you have 100 lines of
    code that handle your data. Data comes in at line 1, and somehow it's wrong at
    line 100\. You don't know where the bug is, so what do you do? You can place a
    breakpoint at line 1 and patiently go through all the lines, checking your data.
    In the worst case scenario, 99 lines later (and many coffee cups) you spot the
    bug. So, consider using a different approach.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的事情是确定从哪里开始。想象一下，你有100行代码来处理你的数据。数据从第1行开始，不知为何在第100行出现了错误。你不知道错误在哪里，所以你该怎么办？你可以在第1行设置一个断点，并耐心地逐行检查你的数据。在最坏的情况下，99行之后（以及许多咖啡杯）你才发现了错误。所以，考虑使用不同的方法。
- en: You start at line 50, and inspect. If the data is good, it means the bug happens
    later, in which case you place your next breakpoint at line 75\. If the data at
    line 50 is already bad, you go on by placing a breakpoint at line 25\. Then, you
    repeat. Each time, you move either backwards or forwards, by half the jump you
    did last time.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你从第50行开始检查。如果数据是好的，这意味着错误发生在后面，在这种情况下，你将在第75行放置下一个断点。如果第50行的数据已经不好，你将继续通过在第25行放置断点。然后，你重复这个过程。每次，你要么向后移动，要么向前移动，移动的距离是上一次跳跃距离的一半。
- en: In our worst case scenario, your debugging would go from 1, 2, 3, ..., 99 to
    50, 75, 87, 93, 96, ..., 99 which is way faster. In fact, it's logarithmic. This
    searching technique is called **binary search**, it's based on a divide and conquer
    approach and it's very effective, so try to master it.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们最坏的情况下，你的调试将从1, 2, 3, ..., 99变为50, 75, 87, 93, 96, ..., 99，这要快得多。事实上，这是对数级的。这种搜索技术被称为**二分搜索**，它基于分而治之的方法，并且非常有效，所以尽量掌握它。
- en: Using tests to debug
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用测试进行调试
- en: Do you remember [Chapter 7](ch07.html "Chapter 7. Testing, Profiling, and Dealing
    with Exceptions"), *Testing, Profiling, and Dealing with Exceptions*, about tests?
    Well, if we have a bug and all tests are passing, it means something is wrong
    or missing in our test codebase. So, one approach is to modify the tests in such
    a way that they cater for the new edge case that has been spotted, and then work
    your way through the code. This approach can be very beneficial, because it makes
    sure that your bug will be covered by a test when it's fixed.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得第7章[测试、性能分析和处理异常](ch07.html "Chapter 7. Testing, Profiling, and Dealing
    with Exceptions")，关于测试的内容吗？嗯，如果我们有一个错误，并且所有测试都通过了，这意味着我们的测试代码库中存在问题或遗漏。所以，一种方法是对测试进行修改，使其能够应对新发现的边缘情况，然后逐步检查代码。这种方法非常有用，因为它确保了当你修复错误时，你的错误将被测试覆盖。
- en: Monitoring
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 监控
- en: Monitoring is also very important. Software applications can go completely crazy
    and have non-deterministic hiccups when they encounter edge case situations such
    as the network being down, a queue being full, an external component being unresponsive,
    and so on. In these cases, it's important to have an idea of what was the big
    picture when the problem happened and be able to correlate it to something related
    to it in a subtle, perhaps mysterious way.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 监控也非常重要。当软件应用遇到边缘情况，如网络中断、队列满、外部组件无响应等情况时，它们可能会完全失控并出现非确定性的故障。在这些情况下，了解问题发生时的大致情况，并能以微妙、甚至神秘的方式将其与相关事物联系起来，这一点非常重要。
- en: You can monitor API endpoints, processes, web pages availability and load time,
    and basically almost everything that you can code. In general, when starting an
    application from scratch, it can be very useful to design it keeping in mind how
    you want to monitor it.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以监控API端点、进程、网页可用性和加载时间，以及基本上你可以编码的几乎所有东西。一般来说，当你从头开始构建一个应用程序时，考虑你想要如何监控它是非常有用的。
- en: Summary
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this short chapter, we saw different techniques and suggestions to debug
    and troubleshoot our code. Debugging is an activity that is always part of a software
    developer's work, so it's important to be good at it.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一简短的章节中，我们看到了调试和排查代码问题的不同技术和建议。调试是软件开发者工作中始终不可或缺的一部分，因此掌握它非常重要。
- en: If approached with the correct attitude, it can be fun and rewarding.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果以正确的心态去对待，这可以是一件有趣且有益的事情。
- en: We saw techniques to inspect our code base on functions, logging, debuggers,
    traceback information, profiling, and assertions. We saw simple examples of most
    of them and we also talked about a set of guidelines that will help when it comes
    to face the fire.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了如何通过函数、日志、调试器、跟踪信息、性能分析和断言来检查我们的代码库。我们看到了其中大多数技术的简单示例，并且还讨论了一套有助于应对挑战的指导原则。
- en: Just *remember to always stay calm and focused*, and debugging will be easier
    already. This too, is a skill that needs to be learned and it's the most important.
    An agitated and stressed mind cannot work properly, logically and creatively,
    therefore, if you don't strengthen it, it will be hard for you to put all of your
    knowledge to good use.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 只需**记住始终保持冷静和专注**，调试就会变得更容易。这也是一种需要学习并认为最重要的技能。一个焦虑和紧张的大脑无法正常、逻辑和创造性地工作，因此，如果你不加强它，将很难将你的所有知识有效利用。
- en: In the next chapter, we will end the book with another small project whose goal
    is to leave you more thirsty than you were when you started this journey with
    me.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将以另一个小型项目结束本书，其目标是让你在跟随我的旅程开始时更加渴望。
- en: Ready?
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好了吗？
