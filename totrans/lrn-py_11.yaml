- en: Chapter 11. Debugging and Troubleshooting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '|   | *"If debugging is the process of removing software bugs, then programming
    must be the process of putting them in."* |   |'
  prefs: []
  type: TYPE_TB
- en: '|   | --*Edsger W. Dijkstra* |'
  prefs: []
  type: TYPE_TB
- en: In the life of a professional coder, debugging and troubleshooting take up a
    significant amount of time. Even if you work on the most beautiful codebase ever
    written by man, there will still be bugs in it, that is guaranteed.
  prefs: []
  type: TYPE_NORMAL
- en: We spend an awful lot of time reading other people's code and, in my opinion,
    a good software developer is someone who keeps their attention high, even when
    they're reading code that is not reported to be wrong or buggy.
  prefs: []
  type: TYPE_NORMAL
- en: Being able to debug code efficiently and quickly is a skill that any coder needs
    to keep improving. Some think that because they have read the manual, they're
    fine, but the reality is, the number of variables in the game is so big that there
    is no manual. There are guidelines that one can follow, but there is no magic
    book that will teach you everything you need to know in order to become good at
    this.
  prefs: []
  type: TYPE_NORMAL
- en: I feel that on this particular subject, I have learned the most from my colleagues.
    It amazes me to observe someone very skilled attacking a problem. I enjoy seeing
    the steps they take, the things they verify to exclude possible causes, and the
    way they consider the suspects that eventually lead them to the solution to the
    problem.
  prefs: []
  type: TYPE_NORMAL
- en: Every colleague we work with can teach us something, or surprise us with a fantastic
    guess that turns out to be the right one. When that happens, don't just remain
    in wonderment (or worse, in envy), but seize the moment and ask them how they
    got to that guess and why. The answer will allow you to see if there is something
    you can study in deep later on so that, maybe next time, you'll be the one who
    will catch the bug.
  prefs: []
  type: TYPE_NORMAL
- en: Some bugs are very easy to spot. They come out of coarse mistakes and, once
    you see the effects of those mistakes, it's easy to find a solution that fixes
    the problem.
  prefs: []
  type: TYPE_NORMAL
- en: But there are other bugs which are much more subtle, much more slippery, and
    require true expertise, and a great deal of creativity and out-of-the-box thinking,
    to be dealt with.
  prefs: []
  type: TYPE_NORMAL
- en: The worst of all, at least for me, are the nondeterministic ones. These sometimes
    happen, and sometimes don't. Some happen only in environment A but not in environment
    B, even though A and B are supposed to be exactly the same. Those bugs are the
    true evil ones, and they can drive you crazy.
  prefs: []
  type: TYPE_NORMAL
- en: And of course, bugs don't just happen in the sandbox, right? With your boss
    telling you "*don't worry! take your time to fix this, have lunch first!*". Nope.
    They happen on a Friday at half past five, when your brain is cooked and you just
    want to go home. It's in those moments, when everyone is getting upset in a split
    second, when your boss is breathing on your neck, that you have to be able to
    keep calm. And I do mean it. That's the most important skill to have if you want
    to be able to fight bugs effectively. If you allow your mind to get stressed,
    say goodbye to creative thinking, to logic deduction, and to everything you need
    at that moment. So take a deep breath, sit properly, and focus.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I will try to demonstrate some useful techniques that you can
    employ according to the severity of the bug, and a few suggestions that will hopefully
    boost your weapons against bugs and issues.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this part, I'll present you with the most common techniques, the ones I use
    most often, however, please don't consider this list to be exhaustive.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging with print
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is probably the easiest technique of all. It's not very effective, it cannot
    be used everywhere and it requires access to both the source code and a terminal
    that will run it (and therefore show the results of the print function calls).
  prefs: []
  type: TYPE_NORMAL
- en: However, in many situations, this is still a quick and useful way to debug.
    For example, if you are developing a Django website and what happens in a page
    is not what would you expect, you can fill the view with prints and keep an eye
    on the console while you reload the page. I've probably done it a million times.
  prefs: []
  type: TYPE_NORMAL
- en: When you scatter calls to `print` in your code, you normally end up in a situation
    where you duplicate a lot of debugging code, either because you're printing a
    timestamp (like we did when we were measuring how fast list comprehensions and
    generators were), or because you have to somehow build a string of some sort that
    you want to display.
  prefs: []
  type: TYPE_NORMAL
- en: Another issue is that it's extremely easy to forget calls to `print` in your
    code.
  prefs: []
  type: TYPE_NORMAL
- en: So, for these reasons, rather than using a bare call to `print`, I sometimes
    prefer to code a custom function. Let's see how.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging with a custom function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Having a custom function in a snippet that you can quickly grab and paste into
    the code, and then use to debug, can be very useful. If you're fast, you can always
    code one on the fly. The important thing is to code it in a way that it won't
    leave stuff around when you eventually remove the calls and its definition, therefore
    *it's important to code it in a way that is completely self-contained*. Another
    good reason for this requirement is that it will avoid potential name clashes
    with the rest of the code.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see an example of such a function.
  prefs: []
  type: TYPE_NORMAL
- en: '`custom.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this case, I am using a keyword-only argument to be able to print a separator,
    which is a line of 40 dashes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function is very simple, I just redirect whatever is in `msg` to a call
    to `print` and, if `print_separator` is `True`, I print a line separator. Running
    the code will show:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, there is no separator after the last line.
  prefs: []
  type: TYPE_NORMAL
- en: This is just one easy way to somehow augment a simple call to the `print` function.
    Let's see how we can calculate a time difference between calls, using one of Python's
    tricky features to our advantage.
  prefs: []
  type: TYPE_NORMAL
- en: '`custom_timestamp.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This is a bit trickier, but still quite simple. First notice we import the `time`
    function from the `time` module from the `debug` function. This allows us to avoid
    having to add that import outside of the function, and maybe forget it there.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at how I defined `timestamp`. It's a list, of course, but what's
    important here is that it is a *mutable* object. This means that it will be set
    up when Python parses the function and it will retain its value throughout different
    calls. Therefore, if we put a timestamp in it after each call, we can keep track
    of time without having to use an external global variable. I borrowed this trick
    from my studies on **closures**, a technique that I encourage you to read about
    because it's very interesting.
  prefs: []
  type: TYPE_NORMAL
- en: Right, so, after having printed whatever message we had to print and importing
    time, we then inspect the content of the only item in `timestamp`. If it is `None`,
    we have no previous reference, therefore we set the value to the current time
    (`#1`).
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, if we have a previous reference, we can calculate a difference
    (which we nicely format to three decimal digits) and then we finally put the current
    time again in `timestamp` (`#2`). It's a nice trick, isn't it?
  prefs: []
  type: TYPE_NORMAL
- en: 'Running this code shows this result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Whatever is your situation, having a self contained function like this can be
    very useful.
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting the traceback
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We briefly talked about the traceback in [Chapter 7](ch07.html "Chapter 7. Testing,
    Profiling, and Dealing with Exceptions"), *Testing, Profiling, and Dealing with
    Exceptions* when we saw several different kinds of exceptions. The traceback gives
    you information about what happened in your application that went wrong. You get
    a great help from reading it. Let''s see a very small example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`traceback_simple.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We have a dict and we have tried to access a key which isn''t in it. You should
    remember that this will raise a `KeyError` exception. Let''s run the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see that we get all the information we need: the module name, the line
    that caused the error (both the number and the instruction), and the error itself.
    With this information, you can go back to the source code and try and understand
    what''s going wrong.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now create a more interesting example that builds on this, and exercises
    a feature that is only available in Python 3\. Imagine that we''re validating
    a dict, working on mandatory fields, therefore we expect them to be there. If
    not, we need to raise a custom `ValidationError`, that we will trap further upstream
    in the process that runs the validator (which is not shown here, it could be anything,
    really). It should be something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`traceback_validator.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We define a custom exception that is raised when the mandatory key isn't there.
    Note that its body consists of its documentation string so we don't need to add
    any other statements.
  prefs: []
  type: TYPE_NORMAL
- en: Very simply, we define a dummy dict and try to access it using `mandatory_key`.
    We trap the `KeyError` and raise `ValidatorError` when that happens. The purpose
    of doing this is that we may also want to raise `ValidatorError` in other circumstances,
    not necessarily as a consequence of a mandatory key being missing. This technique
    allows us to run the validation in a simple `try`/`except` that only cares about
    `ValidatorError`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The thing is, in Python 2, this code would just display the last exception
    (`ValidatorError`), which means we would lose the information about the `KeyError`
    that precedes it. In Python 3, this behavior has changed and exceptions are now
    chained so that you have a much better information report when something happens.
    The code produces this result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This is brilliant, because we can see the traceback of the exception that led
    us to raise `ValidationError`, as well as the traceback for the `ValidationError`
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: I had a nice discussion with one of my reviewers about the traceback you get
    from the `pip` installer. He was having trouble setting everything up in order
    to review the code for [Chapter 9](ch09.html "Chapter 9. Data Science"), *Data
    Science*. His fresh Ubuntu installation was missing a few libraries that were
    needed by the `pip` packages in order to run correctly.
  prefs: []
  type: TYPE_NORMAL
- en: The reason he was blocked was that he was trying to fix the errors displayed
    in the traceback starting from the top one. I suggested that he started from the
    bottom one instead, and fix that. The reason was that, if the installer had gotten
    to that last line, I guess that before that, whatever error may have occurred,
    it was still possible to recover from it. Only after the last line, `pip` decided
    it wasn't possible to continue any further, and therefore I started fixing that
    one. Once the libraries required to fix that error had been installed, everything
    else went smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: Reading a traceback can be tricky, and my friend was lacking the necessary experience
    to address this problem correctly, therefore, if you end up in the same situation,
    don't be discouraged, and try to shake things up a bit, don't take anything for
    granted.
  prefs: []
  type: TYPE_NORMAL
- en: Python has a huge and wonderful community and it's very unlikely that, when
    you encounter a problem, you're the first one to see it, so open a browser and
    search. By doing so, your searching skills will also improve because you will
    have to trim the error down to the minimum but essential set of details that will
    make your search effective.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to play and understand the traceback a bit better, in the standard
    library there is a module called, surprise surprise, `traceback` that you can
    use. It provides a standard interface to extract, format, and print stack traces
    of Python programs, mimicking exactly the behavior of the Python interpreter when
    it prints a stack trace.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Python debugger
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another very effective way of debugging Python is to use the Python debugger:
    **pdb**. If you are addicted to the IPython console, like me, you should definitely
    check out the **ipdb** library. *ipdb* augments the standard *pdb* interface like
    IPython does with the Python console.'
  prefs: []
  type: TYPE_NORMAL
- en: There are several different ways of using this debugger (whichever version,
    it is not important), but the most common one consists of simply setting a breakpoint
    and running the code. When Python reaches the breakpoint, execution is suspended
    and you get console access to that point so that you can inspect all the names,
    and so on. You can also alter data on the fly to change the flow of the program.
  prefs: []
  type: TYPE_NORMAL
- en: As a toy example, let's pretend we have a parser that is raising a `KeyError`
    because a key is missing in a dict. The dict is from a JSON payload that we cannot
    control, and we just want, for the time being, to cheat and pass that control,
    since we're interested in what comes afterwards. Let's see how we could intercept
    this moment, inspect the data, fix it and get to the bottom, with *ipdb*.
  prefs: []
  type: TYPE_NORMAL
- en: '`ipdebugger.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, this code will break when `key` gets the value `''third''`,
    which is missing in the dict. Remember, we''re pretending that both `d` and `keys`
    come dynamically from a JSON payload we don''t control, so we need to inspect
    them in order to fix `d` and pass the `for` loop. If we run the code as it is,
    we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: So we see that that `key` is missing from the dict, but since every time we
    run this code we may get a different dict or `keys` tuple, this information doesn't
    really help us. Let's inject a call to *ipdb*.
  prefs: []
  type: TYPE_NORMAL
- en: '`ipdebugger_ipdb.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If we now run this code, things get interesting (note that your output may
    vary a little and that all the comments in this output were added by me):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This is very interesting. First, note that, when you reach a breakpoint, you're
    served a console that tells you where you are (the Python module) and which line
    is the next one to be executed. You can, at this point, perform a bunch of exploratory
    actions, such as inspecting the code before and after the next line, printing
    a stacktrace, interacting with the objects, and so on. Please consult the official
    Python documentation on *pdb* to learn more about this. In our case, we first
    inspect the `keys` tuple. After that, we inspect the keys of `d`.
  prefs: []
  type: TYPE_NORMAL
- en: Have you noticed that exclamation mark I prepended to `d`? It's needed because
    `d` is a command in the *pdb* interface that moves the frame (*d*)own.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'I indicate commands within the *ipdb* shell with this notation: each command
    is activated by one letter, which typically is the first letter of the command
    name. So, *d* for *down*, *n* for *next*, and *s* for *step* become, more concisely,
    (*d*)own, (*n*)ext and (*s*)tep.'
  prefs: []
  type: TYPE_NORMAL
- en: I guess this is a good enough reason to have better names, right? Indeed, but
    I needed to show you this, so I chose to use `d`. In order to tell *pdb* that
    we're not yielding a (*d*)own command, we put "`!`" in front of `d` and we're
    fine.
  prefs: []
  type: TYPE_NORMAL
- en: After seeing the keys of `d`, we see that `'third'` is missing, so we put it
    in ourselves (could this be dangerous? think about it). Finally, now that all
    the keys are in, we type `c`, which means (*c*)ontinue.
  prefs: []
  type: TYPE_NORMAL
- en: '*pdb* also gives you the ability to proceed with your code one line at a time
    using (*n*)ext, to (*s*)tep into a function for deeper analysis, or handling breaks
    with (*b*)reak. For a complete list of commands, please refer to the documentation
    or type (*h*)elp in the console.'
  prefs: []
  type: TYPE_NORMAL
- en: You can see from the output that we could finally get to the end of the validation.
  prefs: []
  type: TYPE_NORMAL
- en: '*pdb* (or *ipdb*) are invaluable tools that I use every day, I couldn''t live
    without them. So, go and have fun, set a breakpoint somewhere and try and inspect,
    follow the official documentation and try the commands in your code to see their
    effect and learn them well.'
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting log files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another way of debugging a misbehaving application is to inspect its log files.
    **Log files** are special files in which an application writes down all sorts
    of things, normally related to what's going on inside of it. If an important procedure
    is started, I would typically expect a line for that in the logs. It is the same
    when it finishes, and possibly for what happens inside of it.
  prefs: []
  type: TYPE_NORMAL
- en: Errors need to be logged so that when a problem happens we can inspect what
    went wrong by taking a look at the information in the log files.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many different ways to set up a logger in Python. Logging is very
    malleable and you can configure it. In a nutshell, there are normally four players
    in the game: loggers, handlers, filters, and formatters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Loggers** expose the interface that the application code uses directly'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Handlers** send the log records (created by loggers) to the appropriate destination'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Filters** provide a finer grained facility for determining which log records
    to output'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Formatters** specify the layout of the log records in the final output'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Logging is performed by calling methods on instances of the `Logger` class.
    Each line you log has a level. The levels normally used are: `DEBUG`, `INFO`,
    `WARNING`, `ERROR`, and `CRITICAL`. You can import them from the `logging` module.
    They are in order of severity and it''s very important to use them properly because
    they will help you filter the contents of a log file based on what you''re searching
    for. Log files usually become extremely big so it''s very important to have the
    information in them written properly so that you can find it quickly when it matters.'
  prefs: []
  type: TYPE_NORMAL
- en: You can log to a file but you can also log to a network location, to a queue,
    to a console, and so on. In general, if you have an architecture that is deployed
    on one machine, logging to a file is acceptable, but when your architecture spans
    over multiple machines (such as in the case of **service-oriented architectures**),
    it's very useful to implement a centralized solution for logging so that all log
    messages coming from each service can be stored and investigated in a single place.
    It helps a lot, otherwise you can really go crazy trying to correlate giant files
    from several different sources to figure out what went wrong.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A **service-oriented architecture** (**SOA**) is an architectural pattern in
    software design in which application components provide services to other components
    via a communications protocol, typically over a network. The beauty of this system
    is that, when coded properly, each service can be written in the most appropriate
    language to serve its purpose. The only thing that matters is the communication
    with the other services, which needs to happen via a common format so that data
    exchange can be done.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, I will present you with a very simple logging example. We will log a
    few messages to a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '`log.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Let's go through it line by line. First, we import the `logging` module, then
    we set up a basic configuration. In general, a production logging configuration
    is much more complicated than this, but I wanted to keep things as easy as possible.
    We specify a filename, the minimum logging level we want to capture in the file,
    and the message format. We'll log the date and time information, the level, and
    the message.
  prefs: []
  type: TYPE_NORMAL
- en: I will start by logging an `info` message that tells me we're about to process
    our list. Then, I will log (this time using the `DEBUG` level, by using the `debug`
    function) which is the value at some position. I'm using `debug` here because
    I want to be able to filter out these logs in the future (by setting the minimum
    level to `logging.INFO` or more), because I might have to handle very big lists
    and I don't want to log all the values.
  prefs: []
  type: TYPE_NORMAL
- en: If we get an `IndexError` (and we do, since I'm looping over `range(4)`), we
    call `logging.exception()`, which is the same as `logging.error()`, but it also
    prints the traceback.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of the code, I log another `info` message saying we''re done. The
    result is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This is exactly what we need to be able to debug an application that is running
    on a box, and not on our console. We can see what went on, the traceback of any
    exception raised, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The example presented here only scratches the surface of logging. For a more
    in-depth explanation, you can find a very nice introduction in the how to ([https://docs.python.org/3.4/howto/logging.html](https://docs.python.org/3.4/howto/logging.html))
    section of the official Python documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Logging is an art, you need to find a good balance between logging everything
    and logging nothing. Ideally, you should log anything that you need to make sure
    your application is working correctly, and possibly all errors or exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Other techniques
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this final section, I'd like to demonstrate briefly a couple of techniques
    that you may find useful.
  prefs: []
  type: TYPE_NORMAL
- en: Profiling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We talked about profiling in [Chapter 7](ch07.html "Chapter 7. Testing, Profiling,
    and Dealing with Exceptions"), *Testing, Profiling, and Dealing with Exceptions*,
    and I'm only mentioning it here because profiling can sometimes explain weird
    errors that are due to a component being too slow. Especially when networking
    is involved, having an idea of the timings and latencies your application has
    to go through is very important in order to understand what may be going on when
    problems arise, therefore I suggest you get acquainted with profiling techniques
    also for a troubleshooting perspective.
  prefs: []
  type: TYPE_NORMAL
- en: Assertions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Assertions are a nice way to make your code ensure your assumptions are verified.
    If they are, all proceeds regularly but, if they are not, you get a nice exception
    that you can work with. Sometimes, instead of inspecting, it''s quicker to drop
    a couple of assertions in the code just to exclude possibilities. Let''s see an
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`assertions.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This code simulates a situation in which `mylist` isn''t defined by us like
    that, of course, but we''re assuming it has four elements. So we put an assertion
    there, and the result is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This tells us exactly where the problem is.
  prefs: []
  type: TYPE_NORMAL
- en: Where to find information
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the Python official documentation, there is a section dedicated to debugging
    and profiling, where you can read up about the `bdb` debugger framework, and about
    modules such as `faulthandler`, `timeit`, `trace`, `tracemallock`, and of course
    *pdb*. Just head to the standard library section in the documentation and you'll
    find all this information very easily.
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting guidelines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this short section, I'll like to give you a few tips that come from my troubleshooting
    experience.
  prefs: []
  type: TYPE_NORMAL
- en: Using console editors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, get comfortable using **vim** or **nano** as an editor, and learn the
    basics of the console. When things break bad you don't have the luxury of your
    editor with all the bells and whistles there. You have to connect to a box and
    work from there. So it's a very good idea to be comfortable browsing your production
    environment with console commands, and be able to edit files using console-based
    editors such as vi, vim, or nano. Don't let your usual development environment
    spoil you, because you'll have to pay a price if you do.
  prefs: []
  type: TYPE_NORMAL
- en: Where to inspect
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: My second suggestion is on where to place your debugging breakpoints. It doesn't
    matter if you are using `print`, a custom function, or *ipdb*, you still have
    to choose where to place the calls that provide you with the information, right?
  prefs: []
  type: TYPE_NORMAL
- en: Well, some places are better than others, and there are ways to handle the debugging
    progression that are better than others.
  prefs: []
  type: TYPE_NORMAL
- en: I normally avoid placing a breakpoint in an `if` clause because, if that clause
    is not exercised, I lose the chance of getting the information I wanted. Sometimes
    it's not easy or quick to get to the breakpoint, so think carefully before placing
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Another important thing is where to start. Imagine that you have 100 lines of
    code that handle your data. Data comes in at line 1, and somehow it's wrong at
    line 100\. You don't know where the bug is, so what do you do? You can place a
    breakpoint at line 1 and patiently go through all the lines, checking your data.
    In the worst case scenario, 99 lines later (and many coffee cups) you spot the
    bug. So, consider using a different approach.
  prefs: []
  type: TYPE_NORMAL
- en: You start at line 50, and inspect. If the data is good, it means the bug happens
    later, in which case you place your next breakpoint at line 75\. If the data at
    line 50 is already bad, you go on by placing a breakpoint at line 25\. Then, you
    repeat. Each time, you move either backwards or forwards, by half the jump you
    did last time.
  prefs: []
  type: TYPE_NORMAL
- en: In our worst case scenario, your debugging would go from 1, 2, 3, ..., 99 to
    50, 75, 87, 93, 96, ..., 99 which is way faster. In fact, it's logarithmic. This
    searching technique is called **binary search**, it's based on a divide and conquer
    approach and it's very effective, so try to master it.
  prefs: []
  type: TYPE_NORMAL
- en: Using tests to debug
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Do you remember [Chapter 7](ch07.html "Chapter 7. Testing, Profiling, and Dealing
    with Exceptions"), *Testing, Profiling, and Dealing with Exceptions*, about tests?
    Well, if we have a bug and all tests are passing, it means something is wrong
    or missing in our test codebase. So, one approach is to modify the tests in such
    a way that they cater for the new edge case that has been spotted, and then work
    your way through the code. This approach can be very beneficial, because it makes
    sure that your bug will be covered by a test when it's fixed.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Monitoring is also very important. Software applications can go completely crazy
    and have non-deterministic hiccups when they encounter edge case situations such
    as the network being down, a queue being full, an external component being unresponsive,
    and so on. In these cases, it's important to have an idea of what was the big
    picture when the problem happened and be able to correlate it to something related
    to it in a subtle, perhaps mysterious way.
  prefs: []
  type: TYPE_NORMAL
- en: You can monitor API endpoints, processes, web pages availability and load time,
    and basically almost everything that you can code. In general, when starting an
    application from scratch, it can be very useful to design it keeping in mind how
    you want to monitor it.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this short chapter, we saw different techniques and suggestions to debug
    and troubleshoot our code. Debugging is an activity that is always part of a software
    developer's work, so it's important to be good at it.
  prefs: []
  type: TYPE_NORMAL
- en: If approached with the correct attitude, it can be fun and rewarding.
  prefs: []
  type: TYPE_NORMAL
- en: We saw techniques to inspect our code base on functions, logging, debuggers,
    traceback information, profiling, and assertions. We saw simple examples of most
    of them and we also talked about a set of guidelines that will help when it comes
    to face the fire.
  prefs: []
  type: TYPE_NORMAL
- en: Just *remember to always stay calm and focused*, and debugging will be easier
    already. This too, is a skill that needs to be learned and it's the most important.
    An agitated and stressed mind cannot work properly, logically and creatively,
    therefore, if you don't strengthen it, it will be hard for you to put all of your
    knowledge to good use.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will end the book with another small project whose goal
    is to leave you more thirsty than you were when you started this journey with
    me.
  prefs: []
  type: TYPE_NORMAL
- en: Ready?
  prefs: []
  type: TYPE_NORMAL
