- en: Chapter 21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Tips and Tricks with Decision Control Structures
  prefs: []
  type: TYPE_NORMAL
- en: 21.1 Introduction
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter is dedicated to teaching you some useful tips and tricks that can
    help you write “better” code. You should always keep them in mind when you design
    your own algorithms, or even your own Python programs.
  prefs: []
  type: TYPE_NORMAL
- en: These tips and tricks can help you increase your code's readability and help
    make the code shorter or even faster. Of course there is no single perfect methodology
    because on one occasion the use of a specific tip or trick may help, but on another
    occasion the same tip or trick may have exactly the opposite result. Most of the
    time, code optimization is a matter of programming experience.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/remember.jpg)Smaller algorithms are not always the best solution to
    a given problem. In order to solve a specific problem, you might write a very
    short algorithm that unfortunately proves to consume a lot of CPU time. On the
    other hand, you may solve the same problem with another algorithm which, even
    though it seems longer, calculates the result much faster.'
  prefs: []
  type: TYPE_NORMAL
- en: 21.2 Choosing a Decision Control Structure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following diagram can help you decide which decision control structure is
    a better choice for a given problem depending on the number of variables checked.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter21-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/notice.jpg)This diagram recommends the best option, not the only option.
    For example, when there are more than two cases for one variable, it is not wrong
    to use a nested decision control structure instead. The proposed multiple-alternative
    decision structure, though, is more convenient.'
  prefs: []
  type: TYPE_NORMAL
- en: 21.3 Streamlining the Decision Control Structure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Look carefully at the following flowchart fragment given in general form.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter21-02.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, two identical statements or blocks of statements exist at the
    beginning and two other identical statements or blocks of statements exist at
    the end of both paths of the dual-alternative decision structure. This means that,
    regardless of the result of Boolean_Expression, these statements are executed
    either way. Thus, you can simply move them outside and (respectively) right before
    and right after the dual-alternative decision structure, as shown in this equivalent
    structure.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter21-03.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/notice.jpg)The same tip can be applied to any decision control structure,
    as long as an identical statement or block of statements exists in all paths.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)There are cases where this tip cannot be applied. For instance,
    you cannot move a statement (or block of statements) right before the decision
    control structure if this statement affects the Boolean expression of the structure.'
  prefs: []
  type: TYPE_NORMAL
- en: Are you still confused? Next, you will find some exercises that can help you
    to understand better.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 21.3-1 “Shrinking” the Algorithm
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Redesign the following flowchart using fewer statements.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter21-04.png)'
  prefs: []
  type: TYPE_IMG
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the statement y ← a * 2 exists in both paths of the dual-alternative
    decision structure. This means that, regardless of the result of the Boolean expression,
    this statement is executed either way. Therefore, you can simply move the statement
    outside and right before the dual-alternative decision structure, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter21-05.png)'
  prefs: []
  type: TYPE_IMG
- en: Exercise 21.3-2 “Shrinking” the Python Program
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Rewrite the following Python program using fewer statements.
  prefs: []
  type: TYPE_NORMAL
- en: a = int(input())
  prefs: []
  type: TYPE_NORMAL
- en: 'if a > 0:'
  prefs: []
  type: TYPE_NORMAL
- en: y = a * 4
  prefs: []
  type: TYPE_NORMAL
- en: print(y)
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: y = a * 3
  prefs: []
  type: TYPE_NORMAL
- en: print(y)
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the statement print(y) exists in both paths of the dual-alternative
    decision structure. This means that, regardless of the result of the Boolean expression,
    this statement is executed either way. Therefore, you can simply move the statement
    outside and right after the dual-alternative decision structure, as shown here.
  prefs: []
  type: TYPE_NORMAL
- en: a = int(input())
  prefs: []
  type: TYPE_NORMAL
- en: 'if a > 0:'
  prefs: []
  type: TYPE_NORMAL
- en: y = a * 4
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: y = a * 3
  prefs: []
  type: TYPE_NORMAL
- en: print(y)
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 21.3-3 “Shrinking” the Algorithm
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Redesign the following flowchart using fewer statements and then write the corresponding
    Python program.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter21-06.png)'
  prefs: []
  type: TYPE_IMG
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: If you try to move the Write y statement outside of the multiple-alternative
    decision structure, the resulting flowchart that follows is definitely not equivalent
    to the initial one.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter21-07.png)'
  prefs: []
  type: TYPE_IMG
- en: This is because of the last path on the right side which, in the initial flowchart,
    didn't include the Write y statement.
  prefs: []
  type: TYPE_NORMAL
- en: Examine both flowcharts to see whether they produce the same result. For example,
    suppose a user enters a wrong number. In both flowcharts, the flow of execution
    goes to the Write "Wrong Number" statement. After that, the initial flowchart
    executes no other statements whereas, the second flowchart executes an extra Write
    y statement.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/remember.jpg)You cannot move a statement or block of statements outside
    of a decision control structure if it does not exist in all paths.'
  prefs: []
  type: TYPE_NORMAL
- en: You may now wonder whether there is any other way to move the Write y statement
    outside of the multiple-alternative decision structure. The answer is “yes”, but
    you need to slightly rearrange the flowchart. You need to completely remove the
    last path on the right and use a brand new decision control structure in the beginning
    to check whether or not the user-provided number is wrong. One possible solution
    is shown here.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter21-08.png)'
  prefs: []
  type: TYPE_IMG
- en: and the Python program is
  prefs: []
  type: TYPE_NORMAL
- en: a = float(input())
  prefs: []
  type: TYPE_NORMAL
- en: 'if a >= 30:'
  prefs: []
  type: TYPE_NORMAL
- en: print("Wrong Number")
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if a < 10:'
  prefs: []
  type: TYPE_NORMAL
- en: y = a * 2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'elif a < 20:'
  prefs: []
  type: TYPE_NORMAL
- en: y = a / 2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: y = a + 2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: print(y)
  prefs: []
  type: TYPE_NORMAL
- en: '21.4 Logical Operators – to Use, or not to Use: That is the Question!'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are some cases in which you can use a logical operator instead of nested
    decision control structures, and this can lead to increased readability. Take
    a look at the following flowchart fragment given in general form.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter21-09.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the statement or block of statements 1 is executed only when
    both Boolean expressions evaluate to True. The statement or block of statements
    2 is executed in all other cases. Therefore, this flowchart fragment can be redesigned
    using the AND logical operator.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter21-10.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, let's take a look at another flowchart fragment given in general form.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter21-11.png)'
  prefs: []
  type: TYPE_IMG
- en: In this flowchart fragment, the statement or block of statements 2 is executed
    when either Boolean_Expression_1 evaluates to True or Boolean_Expression_2 evaluates
    to True. Therefore, you can redesign this flowchart fragment using the OR logical
    operator as shown here.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter21-12.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/notice.jpg)Obviously, these methodologies can be adapted to be used
    on nested decision control structures as well.'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 21.4-1 Rewriting the Code
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Rewrite the following Python program using logical operators.
  prefs: []
  type: TYPE_NORMAL
- en: today = input()
  prefs: []
  type: TYPE_NORMAL
- en: name = input()
  prefs: []
  type: TYPE_NORMAL
- en: 'if today == "February 16":'
  prefs: []
  type: TYPE_NORMAL
- en: 'if name == "Loukia":'
  prefs: []
  type: TYPE_NORMAL
- en: print("Happy Birthday!!!")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: print("No match!")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: print("No match!")
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: The print("Happy Birthday!!!") statement is executed only when both Boolean
    expressions evaluate to True. The statement print("No match!") is executed in
    all other cases. Therefore, you can rewrite the Python program using the and logical
    operator.
  prefs: []
  type: TYPE_NORMAL
- en: today = input()
  prefs: []
  type: TYPE_NORMAL
- en: name = input()
  prefs: []
  type: TYPE_NORMAL
- en: 'if today == "February 16" and name == "Loukia":'
  prefs: []
  type: TYPE_NORMAL
- en: print("Happy Birthday!!!")
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: print("No match!")
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 21.4-2 Rewriting the Code
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Rewrite the following Python program using logical operators.
  prefs: []
  type: TYPE_NORMAL
- en: a = int(input())
  prefs: []
  type: TYPE_NORMAL
- en: b = int(input())
  prefs: []
  type: TYPE_NORMAL
- en: y = 0
  prefs: []
  type: TYPE_NORMAL
- en: 'if a > 10:'
  prefs: []
  type: TYPE_NORMAL
- en: y += 1
  prefs: []
  type: TYPE_NORMAL
- en: 'elif b > 20:'
  prefs: []
  type: TYPE_NORMAL
- en: y += 1
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: y -= 1
  prefs: []
  type: TYPE_NORMAL
- en: print(y)
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: The y += 1 statement is executed when either variable a is greater than 10 or
    variable b is greater than 20\. Therefore, you can rewrite the Python program
    using the or logical operator.
  prefs: []
  type: TYPE_NORMAL
- en: a = int(input())
  prefs: []
  type: TYPE_NORMAL
- en: b = int(input())
  prefs: []
  type: TYPE_NORMAL
- en: y = 0
  prefs: []
  type: TYPE_NORMAL
- en: 'if a > 10 or b > 20:'
  prefs: []
  type: TYPE_NORMAL
- en: y += 1
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: y -= 1
  prefs: []
  type: TYPE_NORMAL
- en: print(y)
  prefs: []
  type: TYPE_NORMAL
- en: 21.5 Merging Two or More Single-Alternative Decision Structures
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes, you may design an algorithm that contains two or more single-alternative
    decision structures in a row, each of which evaluates the same Boolean expression.
    An example is shown here.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter21-13.png)'
  prefs: []
  type: TYPE_IMG
- en: When a situation like this occurs, you can just merge all single-alternative
    decision structures to a single one, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter21-14.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/remember.jpg)The single-alternative decision structures need to be
    adjacent to each other. If any statement exists between them, you can''t merge
    them unless you are able to move this statement to somewhere else in your code.'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 21.5-1 Merging the Decision Control Structures
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the following Python program, merge the single-alternative decision structures.
  prefs: []
  type: TYPE_NORMAL
- en: a = int(input())
  prefs: []
  type: TYPE_NORMAL
- en: 'if a > 0:'
  prefs: []
  type: TYPE_NORMAL
- en: print("Hello")
  prefs: []
  type: TYPE_NORMAL
- en: 'if a > 0:'
  prefs: []
  type: TYPE_NORMAL
- en: print("Hermes")
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: The first and second decision control structures are evaluating exactly the
    same Boolean expressions, so they can simply be merged into a single one.
  prefs: []
  type: TYPE_NORMAL
- en: The Python program becomes
  prefs: []
  type: TYPE_NORMAL
- en: a = int(input())
  prefs: []
  type: TYPE_NORMAL
- en: 'if a > 0:'
  prefs: []
  type: TYPE_NORMAL
- en: print("Hello")
  prefs: []
  type: TYPE_NORMAL
- en: print("Hermes")
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 21.5-2 Merging the Decision Control Structures
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the following Python program, merge as many single-alternative decision structures
    as possible.
  prefs: []
  type: TYPE_NORMAL
- en: a = int(input())
  prefs: []
  type: TYPE_NORMAL
- en: y = 0
  prefs: []
  type: TYPE_NORMAL
- en: 'if a > 0:'
  prefs: []
  type: TYPE_NORMAL
- en: y += a + 1
  prefs: []
  type: TYPE_NORMAL
- en: b = int(input())     [[More…]](more.html#more_21_5_2_1)
  prefs: []
  type: TYPE_NORMAL
- en: 'if not(a <= 0):'
  prefs: []
  type: TYPE_NORMAL
- en: print("Hello Hera")
  prefs: []
  type: TYPE_NORMAL
- en: a += 1     [[More…]](more.html#more_21_5_2_2)
  prefs: []
  type: TYPE_NORMAL
- en: 'if a > 0:'
  prefs: []
  type: TYPE_NORMAL
- en: print("Hallo Welt")
  prefs: []
  type: TYPE_NORMAL
- en: print(y)
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: Upon closer examination, it's evident that the first and second decision control
    structures are evaluating exactly the same Boolean expression. Specifically, negating
    a > 0 gives a <= 0, and a second negation of a <= 0 (using the not operator this
    time) yields not(a <= 0). Thus, a > 0 is in fact equivalent to not(a <= 0).
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/remember.jpg)Two negations result in an affirmative.'
  prefs: []
  type: TYPE_NORMAL
- en: However, between the first and second decision control structures there is the
    statement b = int(input()), which prevents you from merging them into a single
    one. Fortunately, this statement can be moved to the beginning of the program
    since it doesn't really affect the rest of the flow of execution.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, between the second and third decision control structures
    there is the statement a += 1, which also prevents you from merging; unfortunately,
    this statement cannot be moved anywhere else because it does affect the rest of
    the flow of execution (the second and third decision control structures are dependent
    upon this statement). Thus, the third decision control structure cannot be merged
    with the first and second ones!
  prefs: []
  type: TYPE_NORMAL
- en: The final Python program looks like this.
  prefs: []
  type: TYPE_NORMAL
- en: a = int(input())
  prefs: []
  type: TYPE_NORMAL
- en: b = int(input())
  prefs: []
  type: TYPE_NORMAL
- en: y = 0
  prefs: []
  type: TYPE_NORMAL
- en: 'if a > 0:'
  prefs: []
  type: TYPE_NORMAL
- en: y += a + 1
  prefs: []
  type: TYPE_NORMAL
- en: print("Hello Hera")
  prefs: []
  type: TYPE_NORMAL
- en: a += 1
  prefs: []
  type: TYPE_NORMAL
- en: 'if a > 0:'
  prefs: []
  type: TYPE_NORMAL
- en: print("Hallo Welt")
  prefs: []
  type: TYPE_NORMAL
- en: print(y)
  prefs: []
  type: TYPE_NORMAL
- en: 21.6 Replacing Two Single-Alternative Decision Structures with a Dual-Alternative
    One
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Take a look at the next example.
  prefs: []
  type: TYPE_NORMAL
- en: 'if x > 40:'
  prefs: []
  type: TYPE_NORMAL
- en: '#Do something'
  prefs: []
  type: TYPE_NORMAL
- en: 'if x <= 40:'
  prefs: []
  type: TYPE_NORMAL
- en: '#Do something else'
  prefs: []
  type: TYPE_NORMAL
- en: The first decision control structure evaluates variable x to test if it is bigger
    than 40, and right after that, a second decision control structure evaluates the
    same variable again to test if it is less than or equal to 40!
  prefs: []
  type: TYPE_NORMAL
- en: This is a very common “mistake” that novice programmers make. They use two single-alternative
    decision structures even though one dual-alternative decision structure can accomplish
    the same thing.
  prefs: []
  type: TYPE_NORMAL
- en: The previous example can be rewritten using only one dual-alternative decision
    structure, as shown here.
  prefs: []
  type: TYPE_NORMAL
- en: 'if x > 40:'
  prefs: []
  type: TYPE_NORMAL
- en: '#Do something'
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: '#Do something else'
  prefs: []
  type: TYPE_NORMAL
- en: Even though both examples are absolutely correct and work perfectly well, the
    second alternative is better. The CPU needs to evaluate only one Boolean expression,
    which results in faster execution time.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)The two single-alternative decision structures must be adjacent
    to each other. If any statement exists between them, you can''t “merge” them (that
    is, replace them with a dual-alternative decision structure) unless you can move
    this statement to somewhere else in your code.'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 21.6-1 “Merging” the Decision Control Structures
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the following Python program, “merge” as many single-alternative decision
    structures as possible.
  prefs: []
  type: TYPE_NORMAL
- en: a = int(input())
  prefs: []
  type: TYPE_NORMAL
- en: y = 0
  prefs: []
  type: TYPE_NORMAL
- en: 'if a > 0:'
  prefs: []
  type: TYPE_NORMAL
- en: y += a
  prefs: []
  type: TYPE_NORMAL
- en: b = int(input())
  prefs: []
  type: TYPE_NORMAL
- en: 'if not(a > 0):'
  prefs: []
  type: TYPE_NORMAL
- en: print("Hello Zeus")
  prefs: []
  type: TYPE_NORMAL
- en: 'if y > 0:'
  prefs: []
  type: TYPE_NORMAL
- en: print(y + 5)
  prefs: []
  type: TYPE_NORMAL
- en: y += a
  prefs: []
  type: TYPE_NORMAL
- en: 'if y <= 0:'
  prefs: []
  type: TYPE_NORMAL
- en: print(y + 12)
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: The first decision control structure evaluates variable a to test if it is greater
    than zero, and just right after that the second decision control structure evaluates
    variable a again to test if it is not greater than zero. Even though there is
    the statement b = int(input()) between them, this statement can be moved somewhere
    else because it doesn't really affect the rest of the flow of execution. Therefore,
    the first and second decision control structures can be merged!
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, between the third and fourth decision control structures
    there is the statement y += a which prevents you from merging. This statement
    cannot be moved anywhere else because it does affect the rest of the flow of execution
    (the third and fourth decision control structures are dependent upon this statement).
    Therefore, the third and fourth decision control structures cannot be merged!
  prefs: []
  type: TYPE_NORMAL
- en: The final Python program becomes
  prefs: []
  type: TYPE_NORMAL
- en: a = int(input())
  prefs: []
  type: TYPE_NORMAL
- en: b = int(input())
  prefs: []
  type: TYPE_NORMAL
- en: y = 0
  prefs: []
  type: TYPE_NORMAL
- en: 'if a > 0:'
  prefs: []
  type: TYPE_NORMAL
- en: y += a
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: print("Hello Zeus")
  prefs: []
  type: TYPE_NORMAL
- en: 'if y > 0:'
  prefs: []
  type: TYPE_NORMAL
- en: print(y + 5)
  prefs: []
  type: TYPE_NORMAL
- en: y += a
  prefs: []
  type: TYPE_NORMAL
- en: 'if y <= 0:'
  prefs: []
  type: TYPE_NORMAL
- en: print(y + 12)
  prefs: []
  type: TYPE_NORMAL
- en: 21.7 Put the Boolean Expressions Most Likely to be True First
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The multiple-alternative decision structure often needs to check several Boolean
    expressions before deciding which statement or block of statements to execute.
    In the next decision control structure,
  prefs: []
  type: TYPE_NORMAL
- en: 'if Boolean_Expression_1:'
  prefs: []
  type: TYPE_NORMAL
- en: A statement or block of statements 1
  prefs: []
  type: TYPE_NORMAL
- en: 'elif Boolean_Expression_2:'
  prefs: []
  type: TYPE_NORMAL
- en: A statement or block of statements 2
  prefs: []
  type: TYPE_NORMAL
- en: 'elif Boolean_Expression_3:'
  prefs: []
  type: TYPE_NORMAL
- en: A statement or block of statements 3
  prefs: []
  type: TYPE_NORMAL
- en: the program first tests if Boolean_Expression_1 is True. If not, it tests if
    Boolean_Expression_2 is True, and if not, it tests Boolean_Expression_3\. However,
    what if Boolean_Expression_1 is False most of the time and Boolean_Expression_3
    is True most of the time? This means that time is wasted testing Boolean_Expression_1,
    which is usually False, before testing Boolean_Expression_3, which is usually
    True.
  prefs: []
  type: TYPE_NORMAL
- en: To make your programs more efficient, you can put the Boolean expressions that
    are most likely to be True at the beginning, and the Boolean expressions that
    are most likely to be False at the end, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'if Boolean_Expression_3:'
  prefs: []
  type: TYPE_NORMAL
- en: A statement or block of statements 3
  prefs: []
  type: TYPE_NORMAL
- en: 'elif Boolean_Expression_2:'
  prefs: []
  type: TYPE_NORMAL
- en: A statement or block of statements 2
  prefs: []
  type: TYPE_NORMAL
- en: 'elif Boolean_Expression_1:'
  prefs: []
  type: TYPE_NORMAL
- en: A statement or block of statements 1
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/remember.jpg)Although this change may seem nonessential, every little
    bit of time that you save can add up to make your programs run faster and more
    efficiently.'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 21.7-1 Rearranging the Boolean Expressions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: According to research, America's favorite pets are dogs, with cats at second
    place, guinea pigs next, and parrots coming in last. In the following Python program,
    rearrange the Boolean expressions to make the program run faster and more efficiently
    for most of the cases.
  prefs: []
  type: TYPE_NORMAL
- en: kind = input("What is your favorite pet? ")
  prefs: []
  type: TYPE_NORMAL
- en: 'if kind == "Parrots":'
  prefs: []
  type: TYPE_NORMAL
- en: print("It screeches!")
  prefs: []
  type: TYPE_NORMAL
- en: 'elif kind == "Guinea pig":'
  prefs: []
  type: TYPE_NORMAL
- en: print("It squeaks")
  prefs: []
  type: TYPE_NORMAL
- en: 'elif kind == "Dog":'
  prefs: []
  type: TYPE_NORMAL
- en: print("It barks")
  prefs: []
  type: TYPE_NORMAL
- en: 'elif kind == "Cat":'
  prefs: []
  type: TYPE_NORMAL
- en: print("It meows")
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: For this research, you can rearrange the Python program to make it run a little
    bit faster for most of the cases.
  prefs: []
  type: TYPE_NORMAL
- en: kind = input("What is your favorite pet? ")
  prefs: []
  type: TYPE_NORMAL
- en: 'if kind == "Dog":'
  prefs: []
  type: TYPE_NORMAL
- en: print("It barks")
  prefs: []
  type: TYPE_NORMAL
- en: 'elif kind == "Cat":'
  prefs: []
  type: TYPE_NORMAL
- en: print("It meows")
  prefs: []
  type: TYPE_NORMAL
- en: 'elif kind == "Guinea pig":'
  prefs: []
  type: TYPE_NORMAL
- en: print("It squeaks")
  prefs: []
  type: TYPE_NORMAL
- en: 'elif kind == "Parrots":'
  prefs: []
  type: TYPE_NORMAL
- en: print("It screeches!")
  prefs: []
  type: TYPE_NORMAL
- en: '21.8 Review Questions: True/False'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Choose true or false for each of the following statements.
  prefs: []
  type: TYPE_NORMAL
- en: 1)Smaller algorithms are always the best solution to a given problem.
  prefs: []
  type: TYPE_NORMAL
- en: 2)You can always move a statement outside, and right before, a dual-alternative
    decision structure as long as it exists at the beginning of both paths of the
    decision structure.
  prefs: []
  type: TYPE_NORMAL
- en: 3)You can always use a logical operator instead of nested decision control structures
    to increase readability.
  prefs: []
  type: TYPE_NORMAL
- en: 4)Two single-alternative decision structures can be merged into one single-alternative
    decision only when they are in a row and when they evaluate equivalent Boolean
    expressions.
  prefs: []
  type: TYPE_NORMAL
- en: 5)Conversion from a dual-alternative decision structure to two single-alternative
    decision structures is always possible.
  prefs: []
  type: TYPE_NORMAL
- en: 6)Two single-alternative decision structures can be replaced by one dual-alternative
    decision only when they are in a row and only when they evaluate the same Boolean
    expression.
  prefs: []
  type: TYPE_NORMAL
- en: '21.9 Review Questions: Multiple Choice'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Select the correct answer for each of the following statements.
  prefs: []
  type: TYPE_NORMAL
- en: 1)The following two programs
  prefs: []
  type: TYPE_NORMAL
- en: a = int(input())
  prefs: []
  type: TYPE_NORMAL
- en: 'if a > 40:'
  prefs: []
  type: TYPE_NORMAL
- en: print(a * 2)
  prefs: []
  type: TYPE_NORMAL
- en: a += 1
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: print(a * 2)
  prefs: []
  type: TYPE_NORMAL
- en: a += 5
  prefs: []
  type: TYPE_NORMAL
- en: a = int(input())
  prefs: []
  type: TYPE_NORMAL
- en: print(a * 2)
  prefs: []
  type: TYPE_NORMAL
- en: 'if a > 40:'
  prefs: []
  type: TYPE_NORMAL
- en: a += 1
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: a += 5
  prefs: []
  type: TYPE_NORMAL
- en: a)produce the same result.
  prefs: []
  type: TYPE_NORMAL
- en: b)do not produce the same result.
  prefs: []
  type: TYPE_NORMAL
- en: c)none of the above
  prefs: []
  type: TYPE_NORMAL
- en: 2)The following two programs
  prefs: []
  type: TYPE_NORMAL
- en: a = int(input())
  prefs: []
  type: TYPE_NORMAL
- en: 'if a > 40:'
  prefs: []
  type: TYPE_NORMAL
- en: print(a * 2)
  prefs: []
  type: TYPE_NORMAL
- en: 'if a > 40:'
  prefs: []
  type: TYPE_NORMAL
- en: print(a * 3)
  prefs: []
  type: TYPE_NORMAL
- en: a = int(input())
  prefs: []
  type: TYPE_NORMAL
- en: 'if a > 40:'
  prefs: []
  type: TYPE_NORMAL
- en: print(a * 2)
  prefs: []
  type: TYPE_NORMAL
- en: print(a * 3)
  prefs: []
  type: TYPE_NORMAL
- en: a)produce the same results, but the left program is faster.
  prefs: []
  type: TYPE_NORMAL
- en: b)produce the same results, but the right program is faster.
  prefs: []
  type: TYPE_NORMAL
- en: c)do not produce the same results.
  prefs: []
  type: TYPE_NORMAL
- en: d)none of the above
  prefs: []
  type: TYPE_NORMAL
- en: 3)The following two programs
  prefs: []
  type: TYPE_NORMAL
- en: a = int(input())
  prefs: []
  type: TYPE_NORMAL
- en: 'if a > 40:'
  prefs: []
  type: TYPE_NORMAL
- en: print(a * 2)
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: print(a * 3)
  prefs: []
  type: TYPE_NORMAL
- en: a = int(input())
  prefs: []
  type: TYPE_NORMAL
- en: 'if a > 40:'
  prefs: []
  type: TYPE_NORMAL
- en: print(a * 2)
  prefs: []
  type: TYPE_NORMAL
- en: 'if a <= 40:'
  prefs: []
  type: TYPE_NORMAL
- en: print(a * 3)
  prefs: []
  type: TYPE_NORMAL
- en: a)produce the same result(s), but the left program is faster.
  prefs: []
  type: TYPE_NORMAL
- en: b)produce the same result(s), but the right program is faster.
  prefs: []
  type: TYPE_NORMAL
- en: c)do not produce the same result(s).
  prefs: []
  type: TYPE_NORMAL
- en: d)none of the above
  prefs: []
  type: TYPE_NORMAL
- en: 21.10 Review Exercises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Complete the following exercises.
  prefs: []
  type: TYPE_NORMAL
- en: 1)Rewrite the following Python program using fewer statements.
  prefs: []
  type: TYPE_NORMAL
- en: y = int(input())
  prefs: []
  type: TYPE_NORMAL
- en: 'if y > 0:'
  prefs: []
  type: TYPE_NORMAL
- en: x = int(input())
  prefs: []
  type: TYPE_NORMAL
- en: a = x * 4 * y
  prefs: []
  type: TYPE_NORMAL
- en: print(y)
  prefs: []
  type: TYPE_NORMAL
- en: a += 1
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: x = int(input())
  prefs: []
  type: TYPE_NORMAL
- en: a = x * 2 * y + 7
  prefs: []
  type: TYPE_NORMAL
- en: print(y)
  prefs: []
  type: TYPE_NORMAL
- en: a -= 1
  prefs: []
  type: TYPE_NORMAL
- en: print(a)
  prefs: []
  type: TYPE_NORMAL
- en: 2)Redesign the following flowchart using fewer statements.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter21-15.png)'
  prefs: []
  type: TYPE_IMG
- en: 3)Rewrite the following Python program using fewer statements.
  prefs: []
  type: TYPE_NORMAL
- en: a = float(input())
  prefs: []
  type: TYPE_NORMAL
- en: 'if a < 1:'
  prefs: []
  type: TYPE_NORMAL
- en: y = 5 + a
  prefs: []
  type: TYPE_NORMAL
- en: print(y)
  prefs: []
  type: TYPE_NORMAL
- en: 'elif a < 5:'
  prefs: []
  type: TYPE_NORMAL
- en: y = 23 / a
  prefs: []
  type: TYPE_NORMAL
- en: print(y)
  prefs: []
  type: TYPE_NORMAL
- en: 'elif a < 10:'
  prefs: []
  type: TYPE_NORMAL
- en: y = 5 * a
  prefs: []
  type: TYPE_NORMAL
- en: print(y)
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: print("Error!")
  prefs: []
  type: TYPE_NORMAL
- en: 4)Rewrite the following Python program using logical operators.
  prefs: []
  type: TYPE_NORMAL
- en: day = int(input())
  prefs: []
  type: TYPE_NORMAL
- en: month = int(input())
  prefs: []
  type: TYPE_NORMAL
- en: name = input()
  prefs: []
  type: TYPE_NORMAL
- en: 'if day == 16:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if month == 2:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if name == "Loukia":'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: print("Happy Birthday!!!")
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'else:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: print("No match!")
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: print("No match!")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: print("No match!")
  prefs: []
  type: TYPE_NORMAL
- en: 5)A teacher asks her students to rewrite the following Python program without
    using logical operators.
  prefs: []
  type: TYPE_NORMAL
- en: a = float(input())
  prefs: []
  type: TYPE_NORMAL
- en: b = float(input())
  prefs: []
  type: TYPE_NORMAL
- en: c = float(input())
  prefs: []
  type: TYPE_NORMAL
- en: 'if a > 10 and c < 2000:'
  prefs: []
  type: TYPE_NORMAL
- en: d = (a + b + c) / 12
  prefs: []
  type: TYPE_NORMAL
- en: print("The result is:", d)
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: print("Error!")
  prefs: []
  type: TYPE_NORMAL
- en: 'One student wrote the following Python program:'
  prefs: []
  type: TYPE_NORMAL
- en: a = float(input())
  prefs: []
  type: TYPE_NORMAL
- en: b = float(input())
  prefs: []
  type: TYPE_NORMAL
- en: c = float(input())
  prefs: []
  type: TYPE_NORMAL
- en: 'if a > 10:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if c < 2000:'
  prefs: []
  type: TYPE_NORMAL
- en: d = (a + b + c) / 12
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: print("The result is:", d)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: print("Error!")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Determine if the program operates the same way for all possible paths as the
    one provided by the teacher. If not, try to modify it and make it work the same
    way.
  prefs: []
  type: TYPE_NORMAL
- en: 6)Rewrite the following Python program using only single-alternative decision
    structures.
  prefs: []
  type: TYPE_NORMAL
- en: a = float(input())
  prefs: []
  type: TYPE_NORMAL
- en: b = float(input())
  prefs: []
  type: TYPE_NORMAL
- en: c = float(input())
  prefs: []
  type: TYPE_NORMAL
- en: 'if a > 10:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if b < 2000:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if c != 10:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: d = (a + b + c) / 12
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: print("The result is:", d)
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: print("Error!")
  prefs: []
  type: TYPE_NORMAL
- en: 7)In the following Python program, replace the two single-alternative decision
    structures by one dual-alternative decision structure.
  prefs: []
  type: TYPE_NORMAL
- en: a = int(input())
  prefs: []
  type: TYPE_NORMAL
- en: y = 3
  prefs: []
  type: TYPE_NORMAL
- en: 'if a > 0:'
  prefs: []
  type: TYPE_NORMAL
- en: y = y * a
  prefs: []
  type: TYPE_NORMAL
- en: b = int(input())
  prefs: []
  type: TYPE_NORMAL
- en: 'if not(a <= 0):'
  prefs: []
  type: TYPE_NORMAL
- en: print("Hello Zeus")
  prefs: []
  type: TYPE_NORMAL
- en: print(y, b)
  prefs: []
  type: TYPE_NORMAL
- en: 8)Rewrite the following Python program, using only one dual-alternative decision
    structure.
  prefs: []
  type: TYPE_NORMAL
- en: a = float(input())
  prefs: []
  type: TYPE_NORMAL
- en: y = 0
  prefs: []
  type: TYPE_NORMAL
- en: 'if a > 0:'
  prefs: []
  type: TYPE_NORMAL
- en: y = y + 7
  prefs: []
  type: TYPE_NORMAL
- en: b = float(input())
  prefs: []
  type: TYPE_NORMAL
- en: 'if not(a > 0):'
  prefs: []
  type: TYPE_NORMAL
- en: print("Hello Zeus")
  prefs: []
  type: TYPE_NORMAL
- en: 'if a <= 0:'
  prefs: []
  type: TYPE_NORMAL
- en: print(abs(a))
  prefs: []
  type: TYPE_NORMAL
- en: print(y)
  prefs: []
  type: TYPE_NORMAL
- en: 9)According to research from 2013, the most popular operating system on tablet
    computers was iOS, with Android being in second place and Microsoft Windows in
    last place. In the following Python program, rearrange the Boolean expressions
    to make the program run more efficiently for most of the cases.
  prefs: []
  type: TYPE_NORMAL
- en: os = input("What is your tablet's OS? ")
  prefs: []
  type: TYPE_NORMAL
- en: 'if os == "Windows":'
  prefs: []
  type: TYPE_NORMAL
- en: print("Microsoft")
  prefs: []
  type: TYPE_NORMAL
- en: 'elif os == "iOS":'
  prefs: []
  type: TYPE_NORMAL
- en: print("Apple")
  prefs: []
  type: TYPE_NORMAL
- en: 'elif os == "Android":'
  prefs: []
  type: TYPE_NORMAL
- en: print("Google")
  prefs: []
  type: TYPE_NORMAL
