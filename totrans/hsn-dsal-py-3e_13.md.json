["```py\nstring = \"this is data structures book by packt publisher\"\nsuffix = \"publisher\"\nprefix = \"this\"\nprint(string.endswith(suffix))  #Check if string contains given suffix. \nprint(string.startswith(prefix)) #Check if string starts with given prefix. \n```", "```py\nTrue\nTrue \n```", "```py\ndef brute_force(text, pattern):\n    l1 = len(text)      # The length of the text string\n    l2 = len(pattern)   # The length of the pattern \n    i = 0\n    j = 0               # looping variables are set to 0\n    flag = False        # If the pattern doesn't appear at all, then set this to false and execute the last if statement\n    while i < l1:         # iterating from the 0th index of text\n        j = 0\n        count = 0    \n        # Count stores the length upto which the pattern and the text have matched\n        while j < l2:\n            if i+j < l1 and text[i+j] == pattern[j]:  \n        # statement to check if a match has occurred or not\n                count += 1     # Count is incremented if a character is matched \n            j += 1\n        if count == l2:   # it shows a matching of pattern in the text \n                print(\"\\nPattern occurs at index\", i) \n                # print the starting index of the successful match\n                flag = True \n                # flag is True as we wish to continue looking for more matching of pattern in the text. \n        i += 1\n    if not flag: \n        # If the pattern doesn't occur at all, means no match of pattern in the text string\n        print('\\nPattern is not at all present in the array') \n'acbcac' in the given string:\n```", "```py\nbrute_force('acbcabccababcaacbcac','acbcac')         # function call \n```", "```py\nPattern occurs at index 14 \n```", "```py\nif i+j<l1 and text[i+j] == pattern[j]: \n```", "```py\ndef generate_hash(text, pattern):\n    ord_text = [ord(i) for i in text]       # stores unicode value of each character in text\n    ord_pattern = [ord(j) for j in pattern] # stores unicode value of each character in pattern\n    len_text = len(text)                    # stores length of the text \n    len_pattern = len(pattern)              # stores length of the pattern\n    len_hash_array = len_text - len_pattern + 1 # stores the length of new array that will contain the hash values of text\n    hash_text = [0]*(len_hash_array)        # Initialize all the values in the array to 0.\n    hash_pattern = sum(ord_pattern)                                                \n    for i in range(0,len_hash_array):       # step size of the loop will be the size of the pattern\n        if i == 0:                          # Base condition \n            hash_text[i] = sum(ord_text[:len_pattern])   # initial value of hash function\n        else:\n            hash_text[i] = ((hash_text[i-1] - ord_text[i-1]) + ord\n[i+len_pattern-1])   # calculating next hash value using previous value\n    return [hash_text, hash_pattern]                 # return the hash values \n```", "```py\n len_hash_array = len_text - len_pattern + 1        \n    hash_text = [0]*(len_hash_array) \n```", "```py\n hash_pattern = sum(ord_pattern) \n```", "```py\n hash_text[i] = ((hash_text[i-1] - ord_text[i-1]) + ord_text[i+len_pattern-1]) \n```", "```py\ndef Rabin_Karp_Matcher(text, pattern):\n    text = str(text)                            # convert text into string format\n    pattern = str(pattern)                 # convert pattern into string format\n    hash_text, hash_pattern = generate_hash(text, pattern) # generate hash values using generate_hash function\n    len_text = len(text)          # length of text\n    len_pattern = len(pattern)    # length of pattern \n    flag = False                  # checks if pattern is present atleast once or not at all \n    for i in range(len(hash_text)):                         \n        if hash_text[i] == hash_pattern:   # if the hash value matches\n            count = 0                      # count the total characters upto which both are similar\n            for j in range(len_pattern):                                 \n                if pattern[j] == text[i+j]: # checking equality for each character\n                    count += 1              # if value is equal, then update the count value\n                else:\n                    break\n            if count == len_pattern:        # if count is equal to length of pattern, it means there is a match\n                    flag = True             # update flag accordingly\n                    print('Pattern occurs at index',i)\n    if not flag:                            # if pattern doesn't match even once, then this if statement is executed\n        print('Pattern is not at all present in the text') \n```", "```py\n Rabin_Karp_Matcher(\"101110000011010010101101\",\"1011\")\n  Rabin_Karp_Matcher(\"ABBACCADABBACCEDF\",\"ACCE\") \n```", "```py\n Pattern occurs at index 0\n   Pattern occurs at index 18\n   Pattern occurs at index 11 \n```", "```py\ndef pfun(pattern):              # function to generate prefix function for the given pattern,  \n    n = len(pattern)            # length of the pattern \n    prefix_fun = [0]*(n)        # initialize all elements of the list to 0 \n    k = 0 \n    for q in range(2,n):\n        while k>0 and pattern[k+1] != pattern[q]: \n            k = prefix_fun[k] \n        if pattern[k+1] == pattern[q]:     # If the kth element of the pattern is equal to the qth element \n            k += 1                       # update k accordingly \n        prefix_fun[q] = k \n    return prefix_fun           # return the prefix function \n```", "```py\ndef KMP_Matcher(text,pattern):   # KMP matcher function\n    m = len(text)\n    n = len(pattern)\n    flag = False\n    text = '-' + text   # append dummy character to make it 1-based indexing\n    pattern = '-' + pattern # append dummy character to the pattern also\n    prefix_fun = pfun(pattern) # generate prefix function for the pattern\n    q = 0\n    for i in range(1,m+1):\n        while q>0 and pattern[q+1] != text[i]: # while pattern and text are not equal, decrement the value of q if it is > 0\n            q = prefix_fun[q]\n        if pattern[q+1] == text[i]:                 # if pattern and text are equal, update value of q\n            q += 1\n        if q == n:                                      # if q is equal to the length of the pattern, it means that the pattern has been found.\n            print(\"Pattern occurs at positions \",i-n)     # print the index, where first match occurs.\n            flag = True\n            q = prefix_fun[q]\n    if not flag:\n        print('\\nNo match found') \n```", "```py\n KMP_Matcher('aabaacaadaabaaba','aabaa')   # function call, with two parameters, text and pattern \n```", "```py\n Pattern occurs at positions 0\n   Pattern occurs at positions 9 \n```", "```py\ntext = \"acbaacacababacacac\"\npattern = \"acacac\"\n\nmatched_indexes = []\n\ni=0\nflag = True\nwhile i<=len(text)-len(pattern):\n    for j in range(len(pattern)-1, -1, -1):     #reverse searching\n        if pattern[j] != text[i+j]:\n            flag = False    #indicates there is a mismatch\n            if j == len(pattern)-1:     #if good-suffix is not present, we test bad character \n                if text[i+j] in pattern[0:j]:\n                    i=i+j-pattern[0:j].rfind(text[i+j])   \n                    #i+j is index of bad character, this line is used for jumping pattern to match bad character of text with same character in pattern\n                else:\n                    i=i+j+1     #if bad character is not present, jump pattern next to it\n            else:\n                k=1\n                while text[i+j+k:i+len(pattern)] not in pattern[0:len(pattern)-1]:     \n                    #used for finding sub part of a good-suffix\n                    k=k+1\n                if len(text[i+j+k:i+len(pattern)]) != 1:    #good-suffix should not be of one character\n                    gsshift=i+j+k-pattern[0:len(pattern)-1].rfind(text[i+j+k:i+len(pattern)])    \n                    #jumps pattern to a position where good-suffix of pattern matches with good-suffix of text\n                else:\n                    #gsshift=i+len(pattern)\n                    gsshift=0   #when good-suffix heuristic is not applicable, \n                                #we prefer bad character heuristic\n                if text[i+j] in pattern[0:j]:\n                    bcshift=i+j-pattern[0:j].rfind(text[i+j])  \n                    #i+j is index of bad character, this line is used for jumping pattern to match bad character of text with same character in pattern\n                else:\n                    bcshift=i+j+1\n                i=max((bcshift, gsshift))\n            break\n    if flag:    #if pattern is found then normal iteration\n        matched_indexes.append(i)\n        i = i+1\n    else:   #again set flag to True so new string in text can be examined\n        flag = True\n\nprint (\"Pattern found at\", matched_indexes) \n```", "```py\ntext[i+j+k:i+len(pattern)] not in pattern[0:len(pattern)-1] \n```"]