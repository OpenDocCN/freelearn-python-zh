- en: Fast Array Operations with NumPy and Pandas
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 NumPy 和 Pandas 进行快速数组操作
- en: NumPy is the *de facto* standard for scientific computing in Python. It extends
    Python with a flexible multidimensional array that allows fast and concise mathematical
    calculations.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 是 Python 中科学计算的 **de facto** 标准。它通过提供灵活的多维数组扩展了 Python，允许快速简洁的数学计算。
- en: NumPy provides common data structures and algorithms designed to express complex
    mathematical operations using a concise syntax. The multidimensional array, `numpy.ndarray`, is
    internally based on C arrays. Apart from the performance benefits, this choice
    allows NumPy code to easily interface with the existing C and FORTRAN routines;
    NumPy is helpful in bridging the gap between Python and the legacy code written
    using those languages.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 提供了旨在使用简洁语法表达复杂数学运算的常见数据结构和算法。多维数组 `numpy.ndarray` 在内部基于 C 数组。除了性能优势外，这种选择还允许
    NumPy 代码轻松地与现有的 C 和 FORTRAN 例程接口；NumPy 有助于弥合 Python 和使用这些语言编写的旧代码之间的差距。
- en: In this chapter, we will learn how to create and manipulate NumPy arrays. We
    will also explore the NumPy broadcasting feature used to rewrite complex mathematical
    expressions in an efficient and succinct manner.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何创建和操作 NumPy 数组。我们还将探索用于以高效和简洁的方式重写复杂数学表达式的 NumPy 广播功能。
- en: Pandas is a tool that relies heavily on NumPy and provides additional data structures
    and algorithms targeted toward data analysis. We will introduce the main Pandas
    features and its usage.  We will also learn how to achieve high performance from
    Pandas data structures and vectorized operations.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Pandas 是一个高度依赖 NumPy 的工具，它提供了针对数据分析的额外数据结构和算法。我们将介绍 Pandas 的主要功能和用法。我们还将学习如何从
    Pandas 数据结构和矢量化操作中获得高性能。
- en: 'The topics covered in this chapter are as follows:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主题如下：
- en: Creating and manipulating NumPy arrays
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和操作 NumPy 数组
- en: Mastering NumPy's broadcasting feature for fast and succinct vectorized operations
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 掌握 NumPy 的广播功能以实现快速简洁的矢量化操作
- en: Improving our particle simulator with NumPy
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 NumPy 提高我们的粒子模拟器
- en: Reaching optimal performance with `numexpr`
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `numexpr` 达到最佳性能
- en: Pandas fundamentals
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pandas 基础知识
- en: Database-style operations with Pandas
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Pandas 进行数据库式操作
- en: Getting started with NumPy
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 NumPy 入门
- en: The NumPy library revolves around its multidimensional array object, `numpy.ndarray`.
    NumPy arrays are collections of elements of the same data type; this fundamental
    restriction allows NumPy to pack the data in a way that allows for high-performance
    mathematical operations.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 库围绕其多维数组对象 `numpy.ndarray` 展开。NumPy 数组是相同数据类型元素的集合；这种基本限制允许 NumPy 以一种允许高性能数学运算的方式打包数据。
- en: Creating arrays
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建数组
- en: 'You can create NumPy arrays using the `numpy.array` function. It takes a list-like
    object (or another array) as input and, optionally, a string expressing its data
    type. You can interactively test array creation using an IPython shell, as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `numpy.array` 函数创建 NumPy 数组。它接受一个类似列表的对象（或另一个数组）作为输入，并可选地接受一个表示其数据类型的字符串。您可以使用
    IPython shell 交互式测试数组创建，如下所示：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Every NumPy array has an associated data type that can be accessed using the `dtype`
    attribute. If we inspect the `a` array, we find that its  `dtype` is `int64`,
    which stands for 64-bit integer:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 NumPy 数组都有一个关联的数据类型，可以使用 `dtype` 属性访问。如果我们检查 `a` 数组，我们会发现其 `dtype` 是 `int64`，代表
    64 位整数：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We may decide to convert those integer numbers to `float` type. To do this, we
    can either pass the `dtype` argument at array initialization or cast the array
    to another data type using the `astype` method. The two ways to select a data
    type are shown in the following code:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能决定将这些整数数字转换为 `float` 类型。为此，我们可以在数组初始化时传递 `dtype` 参数，或者使用 `astype` 方法将数组转换为另一种数据类型。以下代码显示了选择数据类型的两种方法：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To create an array with two dimensions (an array of arrays), we can perform
    the initialization using a nested sequence, as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个具有两个维度（数组数组）的数组，我们可以使用嵌套序列进行初始化，如下所示：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The array created in this way has two dimensions, which are called **axes** in
    NumPy''s jargon. An array formed in this way is like a table that contains two
    rows and three columns. We can access the axes using the `ndarray.shape` attribute:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式创建的数组具有两个维度，在 NumPy 的术语中称为 **轴**。以这种方式形成的数组就像一个包含两行三列的表格。我们可以使用 `ndarray.shape`
    属性来访问轴：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Arrays can also be reshaped as long as the product of the shape dimensions
    is equal to the total number of elements in the array (that is, the total number
    of elements is conserved). For example, we can reshape an array containing 16
    elements in the following ways: `(2, 8)`, `(4, 4)`, or `(2, 2, 4)`. To reshape
    an array, we can either use the `ndarray.reshape` method or assign a new value
    to the `ndarray.shape` tuple. The following code illustrates the use of the `ndarray.reshape`
    method:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 只要形状维度的乘积等于数组中的总元素数（即，总元素数保持不变），数组也可以被重塑。例如，我们可以以下列方式重塑包含 16 个元素的数组：`(2, 8)`、`(4,
    4)` 或 `(2, 2, 4)`。要重塑数组，我们可以使用 `ndarray.reshape` 方法或给 `ndarray.shape` 元组赋新值。以下代码说明了
    `ndarray.reshape` 方法的使用：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Thanks to this property, you can freely add dimensions of size one. You can
    reshape an array with 16 elements to `(16, 1)`, `(1, 16)`, `(16, 1, 1)`, and so
    on. In the next section, we will extensively use this feature to implement complex
    operations through *broadcasting*.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了这一特性，你可以自由地添加大小为 1 的维度。你可以将包含 16 个元素的数组重塑为 `(16, 1)`、`(1, 16)`、`(16, 1, 1)`
    等等。在下一节中，我们将广泛使用这一特性通过 *广播* 实现复杂操作。
- en: 'NumPy provides convenience functions, shown in the following code, to create
    arrays filled with zeros, ones, or with no initial value (in this case, their
    actual value is meaningless and depends on the memory state). Those functions
    take the array shape as a tuple and, optionally, its `dtype`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 提供了一些便利函数，如下面的代码所示，用于创建填充零、一或无初始值（在这种情况下，其实际值没有意义且取决于内存状态）的数组。这些函数接受数组形状作为元组，并且可选地接受其
    `dtype`：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In our examples, we will use the `numpy.random` module to generate random floating
    point numbers in the `(0, 1)` interval. The `numpy.random.rand` will take a shape
    and return an array of random numbers with that shape:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们将使用 `numpy.random` 模块在 `(0, 1)` 区间内生成随机浮点数。`numpy.random.rand` 将接受一个形状并返回具有该形状的随机数数组：
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Sometimes it is convenient to initialize arrays that have the same shape as
    that of some other array. For that purpose, NumPy provides some handy functions,
    such as `zeros_like`, `empty_like`, and `ones_like`. These functions can be used
    as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 有时初始化与某个其他数组形状相同的数组很方便。为此目的，NumPy 提供了一些实用的函数，例如 `zeros_like`、`empty_like` 和
    `ones_like`。这些函数可以按如下方式使用：
- en: '[PRE8]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Accessing arrays
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问数组
- en: 'The NumPy array interface is, on a shallow level, similar to that of Python
    lists. NumPy arrays can be indexed using integers and iterated using a `for` loop:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在浅层上，NumPy 数组接口与 Python 列表类似。NumPy 数组可以使用整数索引，并使用 `for` 循环迭代：
- en: '[PRE9]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In NumPy, array elements and sub-arrays can be conveniently accessed by using
    multiple values separated by commas inside the subscript operator, `[]`. If we
    take a `(3,3)` array (an array containing three triplets), and we access the element
    with index `0`, we obtain the first row, as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在 NumPy 中，可以通过在下标操作符 `[]` 内使用多个以逗号分隔的值方便地访问数组元素和子数组。如果我们取一个 `(3,3)` 的数组（包含三个三元组的数组），并且我们访问索引为
    `0` 的元素，我们获得第一行，如下所示：
- en: '[PRE10]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can index the row again by adding another index separated by a comma. To
    get the second element of the first row, we can use the `(0, 1)` index. An important
    observation is that the `A[0, 1]` notation is actually a shorthand for `A[(0,
    1)]`, that is, we are actually indexing using a *tuple*! Both the versions are
    shown in the following snippet:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过添加另一个以逗号分隔的索引来再次索引行。要获取第一行的第二个元素，我们可以使用 `(0, 1)` 索引。一个重要的观察是，`A[0, 1]`
    语法实际上是一个简写，即 `A[(0, 1)]`，也就是说，我们实际上是在使用 *元组* 进行索引！以下代码片段显示了这两种版本：
- en: '[PRE11]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'NumPy allows you to slice arrays into multiple dimensions. If we slice on the
    first dimension, we can obtain a collection of triplets, shown as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 允许你将数组切割成多个维度。如果我们对第一个维度进行切割，我们可以获得一系列三元组，如下所示：
- en: '[PRE12]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If we slice the array again on the second dimension with `0:2`, we are basically
    extracting the first two elements from the collection of triplets shown earlier.
    This results in an array of shape `(2, 2)`, shown in the following code:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次使用 `0:2` 在第二个维度上切割数组，我们基本上是从之前显示的三元组集合中提取前两个元素。这导致了一个形状为 `(2, 2)` 的数组，如下所示：
- en: '[PRE13]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Intuitively, you can update the values in the array using both numerical indexes
    and slices. An example is illustrated in the following code snippet:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 直观地讲，你可以使用数值索引和切片来更新数组中的值。以下代码片段展示了这一点的示例：
- en: '[PRE14]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Indexing with the slicing syntax is very fast because, unlike lists, it doesn''t
    produce a copy of the array. In NumPy''s terminology, it returns a *view* of the
    same memory area. If we take a slice of the original array, and then we change
    one of its values, the original array will be updated as well. The following code
    illustrates an example of this feature:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 使用切片语法进行索引非常快，因为与列表不同，它不会生成数组的副本。在NumPy的术语中，它返回相同内存区域的*视图*。如果我们从原始数组中取一个切片，然后改变其值中的一个，原始数组也会被更新。以下代码展示了这一特性的一个示例：
- en: '[PRE15]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: It is important to be extra careful when mutating NumPy arrays. Since views
    share data, changing the values of a view can result in hard-to-find bugs. To
    prevent side effects, you can set the `a.flags.writeable = False` flag, which
    will prevent accidental mutation of the array or any of its views.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在修改NumPy数组时，需要格外小心。由于视图共享数据，改变视图的值可能会导致难以发现的错误。为了防止副作用，您可以设置`a.flags.writeable
    = False`标志，这将防止意外修改数组或其任何视图。
- en: 'We can take a look at another example that shows how the slicing syntax can
    be used in a real-world setting. We define an `r_i` array, shown in the following
    line of code, which contains a set of 10 coordinates (*x*, *y*). Its shape will
    be `(10, 2)`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看看另一个示例，展示如何在实际场景中使用切片语法。我们定义一个`r_i`数组，如下面的代码行所示，它包含一组10个坐标（*x*，*y*）。它的形状将是`(10,
    2)`：
- en: '[PRE16]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If you have a hard time distinguishing arrays that differ in the axes order,
    for example between an a array of shape `(10, 2)` and `(2, 10)`, it is useful
    to think that every time you say the word *of*, you should introduce a new dimension.
    An array with ten elements *of* size two will be `(10, 2)`. Conversely, an array
    with two elements *of* size ten will be `(2, 10)`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在区分轴顺序不同的数组时遇到困难，例如在形状为`(10, 2)`的数组与`(2, 10)`的数组之间，那么每次您说“*of*”这个词时，都应该引入一个新的维度。一个大小为二的十个元素的数组将是`(10,
    2)`。相反，一个大小为十的两个元素的数组将是`(2, 10)`。
- en: 'A typical operation we may be interested in is the extraction of the *x* component
    from each coordinate. In other words, you want to extract the `(0, 0)`, `(1, 0)`,
    `(2, 0)`, and so on items, resulting in an array with shape `(10,)`. It is helpful
    to think that the first index is *moving* while the second one is *fixed* (at
    `0`). With this in mind, we will slice every index on the first axis (the moving
    one) and take the first element (the fixed one) on the second axis, as shown in
    the following line of code:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能感兴趣的一个典型操作是从每个坐标中提取*x*分量。换句话说，您想要提取`(0, 0)`、`(1, 0)`、`(2, 0)`等等项，结果得到一个形状为`(10,)`的数组。有助于思考的是，第一个索引是*移动的*，而第二个索引是*固定的*（在`0`处）。带着这个想法，我们将第一个轴（移动的轴）上的每个索引进行切片，并在第二个轴上取第一个元素（固定的元素），如下面的代码行所示：
- en: '[PRE17]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'On the other hand, the following expression will keep the first index fixed
    and the second index moving, returning the first (*x*, *y*) coordinate:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，以下表达式将保持第一个索引固定，第二个索引移动，返回第一个(*x*，*y*)坐标：
- en: '[PRE18]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Slicing all the indexes over the last axis is optional; using `r_i[0]` has the
    same effect as `r_i[0, :]`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一个轴上对所有的索引进行切片是可选的；使用`r_i[0]`与`r_i[0, :]`具有相同的效果。
- en: NumPy allows you to index an array using another NumPy array made of either
    integer or Boolean values--a feature called *fancy indexing*.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy允许您使用另一个由整数或布尔值组成的NumPy数组来索引数组，这是一个称为*花式索引*的特性。
- en: 'If you index an array (say, `a`) with another array of integers (say, `idx`),
    NumPy will interpret the integers as indexes and will return an array containing
    their corresponding values. If we index an array containing 10 elements with `np.array([0,
    2, 3])`, we obtain an array of shape `(3,)` containing the elements at positions
    `0`, `2`, and `3`. The following code gives us an illustration of this concept:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用另一个整数数组（例如，`idx`）来索引数组（例如，`a`），NumPy将解释这些整数为索引，并返回一个包含它们对应值的数组。如果我们使用`np.array([0,
    2, 3])`来索引包含10个元素的数组，我们将得到一个形状为`(3,)`的数组，包含位置`0`、`2`和`3`的元素。以下代码为我们展示了这一概念：
- en: '[PRE19]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You can use fancy indexing on multiple dimensions by passing an array for each
    dimension. If we want to extract the `(0, 2)` and `(1, 3)` elements, we have to
    pack all the indexes acting on the first axis in one array, and the ones acting
    on the second axis in another. This can be seen in the following code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过为每个维度传递一个数组来实现多维度的花式索引。如果我们想提取`(0, 2)`和`(1, 3)`元素，我们必须将作用于第一个轴的所有索引打包在一个数组中，而将作用于第二个轴的索引放在另一个数组中。这可以在以下代码中看到：
- en: '[PRE20]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You can also use normal lists as index arrays, but not tuples. For example,
    the following two statements are equivalent:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用正常的列表作为索引数组，但不能使用元组。例如，以下两个语句是等价的：
- en: '[PRE21]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'However, if you use a tuple, NumPy will interpret the following statement as
    an index on multiple dimensions:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你使用元组，NumPy 将以下语句解释为对多个维度的索引：
- en: '[PRE22]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The index arrays are not required to be one-dimensional; we can extract elements
    from the original array in any shape. For example, we can select elements from
    the original array to form a `(2,2)` array, as shown:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 索引数组不需要是一维的；我们可以以任何形状从原始数组中提取元素。例如，我们可以从原始数组中选择元素来形成一个 `(2,2)` 的数组，如下所示：
- en: '[PRE23]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The array slicing and fancy-indexing features can be combined. This is useful,
    for instance, when we want to swap the *x* and *y* columns in a coordinate array.
    In the following code, the first index will be running over all the elements (a
    slice) and, for each of those, we extract the element in position `1` (the *y*)
    first and then the one in position `0` (the *x*):'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 数组切片和花式索引功能可以组合使用。这在例如我们想要交换坐标数组中的 *x* 和 *y* 列时很有用。在下面的代码中，第一个索引将遍历所有元素（一个切片），对于这些元素中的每一个，我们首先提取位置
    `1`（*y*）的元素，然后是位置 `0`（*x*）的元素：
- en: '[PRE24]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'When the index array is of the `bool` type, the rules are slightly different.
    The `bool` array will act like a *mask*; every element corresponding to `True`
    will be extracted and put in the output array. This procedure is shown in the
    following code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当索引数组是 `bool` 类型时，规则略有不同。`bool` 数组将像 *掩码* 一样工作；每个对应于 `True` 的元素将被提取并放入输出数组中。这个过程在下面的代码中显示：
- en: '[PRE25]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The same rules apply when dealing with multiple dimensions. Furthermore, if
    the index array has the same shape as the original array, the elements corresponding
    to `True` will be selected and put in the resulting array.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理多个维度时，相同的规则适用。此外，如果索引数组的形状与原始数组相同，对应于 `True` 的元素将被选中并放入结果数组中。
- en: 'Indexing in NumPy is a reasonably fast operation. Anyway, when speed is critical,
    you can use the slightly faster `numpy.take` and `numpy.compress` functions to
    squeeze out a little more performance. The first argument of `numpy.take` is the
    array we want to operate on, and the second is the list of indexes we want to
    extract. The last argument is `axis`; if not provided, the indexes will act on
    the flattened array; otherwise, they will act along the specified axis:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 中的索引是一个相对快速的运算。无论如何，当速度至关重要时，你可以使用稍微快一点的 `numpy.take` 和 `numpy.compress`
    函数来挤出更多性能。`numpy.take` 的第一个参数是我们想要操作的数组，第二个参数是我们想要提取的索引列表。最后一个参数是 `axis`；如果没有提供，索引将作用于展平后的数组；否则，它们将沿着指定的轴进行操作：
- en: '[PRE26]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The similar, but faster version for Boolean arrays is `numpy.compress`, which
    works in the same way. The use of `numpy.compress` is shown as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 对于布尔数组，有一个类似但更快的版本是 `numpy.compress`，它以相同的方式工作。以下是如何使用 `numpy.compress` 的示例：
- en: '[PRE27]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Broadcasting
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 广播
- en: The true power of NumPy lies in its fast mathematical operations. The approach
    used by NumPy is to avoid stepping into the Python interpreter by performing element-wise
    calculation using optimized C code. **Broadcasting** is a clever set of rules
    that enables fast array calculations for arrays of similar (but not equal!) shape.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 的真正力量在于其快速的数学运算。NumPy 使用的策略是通过使用优化的 C 代码进行逐元素计算来避免进入 Python 解释器。**广播**
    是一组巧妙的规则，它使得形状相似（但不完全相同！）的数组能够进行快速数组计算。
- en: 'Whenever you do an arithmetic operation on two arrays (like a product), if
    the two operands have the same shape, the operation will be applied in an element-wise
    fashion. For example, upon multiplying two shape `(2,2)` arrays, the operation
    will be done between pairs of corresponding elements, producing another `(2, 2)`
    array, as shown in the following code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 无论何时你在两个数组（如乘积）上进行算术运算，如果两个操作数具有相同的形状，该运算将以逐元素的方式应用。例如，在乘以两个形状为 `(2,2)` 的数组时，操作将在对应元素对之间进行，产生另一个
    `(2, 2)` 的数组，如下面的代码所示：
- en: '[PRE28]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If the shapes of the operands don''t match, NumPy will attempt to match them
    using broadcasting rules. If one of the operands is a *scalar* (for example, a
    number), it will be applied to every element of the array, as the following code
    illustrates:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果操作数的形状不匹配，NumPy 将尝试使用广播规则来匹配它们。如果一个操作数是 *标量*（例如，一个数字），它将被应用到数组的每个元素上，如下面的代码所示：
- en: '[PRE29]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If the operand is another array, NumPy will try to match the shapes starting
    from the last axis. For example, if we want to combine an array of shape `(3,
    2)` with one of shape `(2,)`, the second array will be repeated three times to
    generate a `(3, 2)` array. In other words, the array is *broadcasted* along a
    dimension to match the shape of the other operand, as shown in the following figure:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果操作数是另一个数组，NumPy将尝试从最后一个轴开始匹配形状。例如，如果我们想将形状为`(3, 2)`的数组与形状为`(2,)`的数组组合，第二个数组将被重复三次以生成一个`(3,
    2)`的数组。换句话说，数组沿着一个维度进行*广播*以匹配另一个操作数的形状，如下面的图所示：
- en: '![](img/B06440_03CHPNO_01-1.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06440_03CHPNO_01-1.png)'
- en: If the shapes mismatch, for example, when combining a `(3, 2)` array with a
    `(2, 2)` array, NumPy will throw an exception.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果形状不匹配，例如，当将`(3, 2)`的数组与`(2, 2)`的数组组合时，NumPy将抛出异常。
- en: 'If one of the axis''s size is 1, the array will be repeated over this axis
    until the shapes match. To illustrate that point, consider that we have an array
    of the following shape:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果轴的大小为1，数组将在这个轴上重复，直到形状匹配。为了说明这一点，考虑以下形状的数组：
- en: '[PRE30]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, consider that we want to broadcast it with an array of shape `(5, 1, 2)`;
    the array will be repeated on the second axis 10 times, which is shown as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们想要与形状为`(5, 1, 2)`的数组进行广播；数组将在第二个轴上重复10次，如下所示：
- en: '[PRE31]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Earlier, we saw that it is possible to freely reshape arrays to add axes of
    size 1\. Using the `numpy.newaxis` constant while indexing will introduce an extra
    dimension. For instance, if we have a `(5, 2)` array and we want to combine it
    with one of shape `(5, 10, 2)`, we can add an extra axis in the middle, as shown
    in the following code, to obtain a compatible `(5, 1, 2)` array:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们看到了可以自由重塑数组以添加大小为1的轴。在索引时使用`numpy.newaxis`常量将引入一个额外的维度。例如，如果我们有一个`(5, 2)`的数组，我们想要与形状为`(5,
    10, 2)`的数组组合，我们可以在中间添加一个额外的轴，如下面的代码所示，以获得兼容的`(5, 1, 2)`数组：
- en: '[PRE32]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This feature can be used, for example, to operate on all possible combinations
    of the two arrays. One of these applications is the *outer product*. Consider
    that we have the following two arrays:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 此功能可用于操作两个数组所有可能的组合。其中一种应用是*外积*。考虑以下两个数组：
- en: '[PRE33]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The outer product is a matrix containing the product of all the possible combinations
    (i, j) of the two array elements, as shown in the following snippet:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 外积是一个矩阵，包含两个数组元素所有可能的组合（i, j）的乘积，如下面的代码片段所示：
- en: '[PRE34]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'To calculate this using NumPy, we will repeat the `[a1, a2, a3]` elements in
    one dimension, the `[b1, b2, b3]` elements in another dimension, and then take
    their element-wise product, as shown in the following figure:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用NumPy计算此操作，我们将重复`[a1, a2, a3]`元素在一个维度上，`[b1, b2, b3]`元素在另一个维度上，然后取它们的逐元素乘积，如下面的图所示：
- en: '![](img/image_03_002.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_03_002.png)'
- en: 'Using code, our strategy will be to transform the `a` array from shape `(3,)`
    to shape `(3, 1)`, and the `b` array from shape `(3,)` to shape `(1, 3)`. The
    two arrays are broadcasted in the two dimensions and get multiplied together using
    the following code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 使用代码，我们的策略是将`a`数组从形状`(3,)`转换为形状`(3, 1)`，将`b`数组从形状`(3,)`转换为形状`(1, 3)`。两个数组在两个维度上广播并使用以下代码相乘：
- en: '[PRE35]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This operation is very fast and extremely effective as it avoids Python loops
    and is able to process a high number of elements at speeds comparable with pure
    C or FORTRAN code.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 此操作非常快且非常有效，因为它避免了Python循环，并且能够以与纯C或FORTRAN代码相当的速度处理大量元素。
- en: Mathematical operations
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数学运算
- en: 'NumPy includes the most common mathematical operations available for broadcasting,
    by default, ranging from simple algebra to trigonometry, rounding, and logic.
    For instance, to take the square root of every element in the array, we can use `numpy.sqrt`,
    as shown in the following code:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy默认包含了广播中最常见的数学运算，从简单的代数到三角学、舍入和逻辑。例如，要计算数组中每个元素的平方根，我们可以使用`numpy.sqrt`，如下面的代码所示：
- en: '[PRE36]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The comparison operators are useful when trying to filter certain elements
    based on a condition. Imagine that we have an array of random numbers from `0`
    to `1`, and we want to extract all the numbers greater than `0.5`. We can use
    the `>` operator on the array to obtain a `bool` array, as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 比较运算符在尝试根据条件过滤某些元素时很有用。想象一下，我们有一个从`0`到`1`的随机数数组，我们想要提取所有大于`0.5`的数字。我们可以在数组上使用`>`运算符来获得一个`bool`数组，如下所示：
- en: '[PRE37]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The resulting `bool` array can then be reused as an index to retrieve the elements
    greater than `0.5`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以将生成的 `bool` 数组作为索引重用，以检索大于 `0.5` 的元素：
- en: '[PRE38]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'NumPy also implements methods such as `ndarray.sum`, which takes the sum of
    all the elements on an axis. If we have an array of shape `(5, 3)`, we can use
    the `ndarray.sum` method to sum the elements on the first axis, the second axis,
    or over all the elements of the array, as illustrated in the following snippet:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 还实现了 `ndarray.sum` 等方法，该方法对轴上的所有元素求和。如果我们有一个形状为 `(5, 3)` 的数组，我们可以使用 `ndarray.sum`
    方法对第一个轴、第二个轴或整个数组的所有元素求和，如下面的代码片段所示：
- en: '[PRE39]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Note that by summing the elements over an axis, we eliminate that axis. From
    the preceding example, the sum on the axis `0` produces an array of shape `(3,)`,
    while the sum on the axis `1` produces an array of shape `(5,)`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，通过在一个轴上对元素求和，我们消除了该轴。从前面的例子中，轴 `0` 上的求和产生了一个形状为 `(3,)` 的数组，而轴 `1` 上的求和产生了一个形状为
    `(5,)` 的数组。
- en: Calculating the norm
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算范数
- en: 'We can review the basic concepts illustrated in this section by calculating
    the *norm* of a set of coordinates. For a two-dimensional vector, the norm is
    defined as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过计算一组坐标的 *norm* 来回顾本节中展示的基本概念。对于二维向量，范数定义为以下内容：
- en: '[PRE40]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Given an array of 10 coordinates (*x*, *y*), we want to find the norm of each
    coordinate. We can calculate the norm by taking these steps:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个包含 10 个坐标 (*x*, *y*) 的数组，我们想要找到每个坐标的范数。我们可以通过以下步骤来计算范数：
- en: Square the coordinates, obtaining an array that contains `(x**2, y**2)` elements.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将坐标平方，得到一个包含 `(x**2, y**2)` 元素的数组。
- en: Sum those with `numpy.sum` over the last axis.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `numpy.sum` 在最后一个轴上对这些值求和。
- en: Take the square root, element-wise, with `numpy.sqrt`.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `numpy.sqrt` 对每个元素进行平方根运算。
- en: 'The final expression can be compressed in a single line:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的表达式可以压缩成一行：
- en: '[PRE41]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Rewriting the particle simulator in NumPy
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 NumPy 中重写粒子模拟器
- en: 'In this section, we will optimize our particle simulator by rewriting some
    parts of it in NumPy. We found, from the profiling we did in [Chapter 1](4db2c3e6-3485-41a5-8450-07220f6d80ec.xhtml),
    *Benchmarking and Profiling*, that the slowest part of our program is the following
    loop contained in the `ParticleSimulator.evolve` method:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过使用 NumPy 重写粒子模拟器的一些部分来优化我们的粒子模拟器。我们从 [第 1 章](4db2c3e6-3485-41a5-8450-07220f6d80ec.xhtml)
    “*Benchmarking and Profiling*” 中所做的分析中发现，我们程序中最慢的部分是 `ParticleSimulator.evolve`
    方法中包含的以下循环：
- en: '[PRE42]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: You may have noticed that the body of the loop acts solely on the current particle.
    If we had an array containing the particle positions and angular speed, we could
    rewrite the loop using a broadcasted operation. In contrast, the loop's steps
    depend on the previous step and cannot be parallelized in this way.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，循环的主体仅对当前粒子起作用。如果我们有一个包含粒子位置和角速度的数组，我们可以使用广播操作重写循环。相比之下，循环的步骤依赖于前一步，不能以这种方式并行化。
- en: 'It is natural then, to store all the array coordinates in an array of shape
    `(nparticles, 2)` and the angular speed in an array of shape `(nparticles,)`,
    where `nparticles` is the number of particles. We''ll call those arrays `r_i`
    and `ang_vel_i`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，将所有数组坐标存储在形状为 `(nparticles, 2)` 的数组中，并将角速度存储在形状为 `(nparticles,)` 的数组中是很自然的，其中
    `nparticles` 是粒子的数量。我们将这些数组称为 `r_i` 和 `ang_vel_i`：
- en: '[PRE43]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The velocity direction, perpendicular to the vector (*x*, *y*), was defined
    as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 速度方向，垂直于向量 (*x*, *y*)，被定义为以下内容：
- en: '[PRE44]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The norm can be calculated using the strategy illustrated in the *Calculating
    the norm* section under the *Getting started with NumPy* heading:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 范数可以使用在“*Getting started with NumPy*”标题下的“*Calculating the norm*”部分中展示的策略来计算：
- en: '[PRE45]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'For the (*-y*, *x*) components, we first need to swap the x and y columns in
    `r_i` and then multiply the first column by -1, as shown in the following code:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 (*-y*, *x*) 分量，我们首先需要在 `r_i` 中交换 x 和 y 列，然后将第一列乘以 -1，如下面的代码所示：
- en: '[PRE46]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'To calculate the displacement, we need to compute the product of `v_i`, `ang_vel_i`,
    and `timestep`. Since `ang_vel_i` is of shape `(nparticles,)`, it needs a new
    axis in order to operate with `v_i` of shape `(nparticles, 2)`. We will do that
    using `numpy.newaxis`, as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算位移，我们需要计算 `v_i`、`ang_vel_i` 和 `timestep` 的乘积。由于 `ang_vel_i` 的形状为 `(nparticles,)`，它需要一个新轴才能与形状为
    `(nparticles, 2)` 的 `v_i` 操作。我们将使用 `numpy.newaxis` 来实现这一点，如下所示：
- en: '[PRE47]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Outside the loop, we have to update the particle instances with the new coordinates,
    *x* and *y*, as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环外部，我们必须更新粒子实例的新坐标，*x* 和 *y*，如下所示：
- en: '[PRE48]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'To summarize, we will implement a method called `ParticleSimulator.evolve_numpy`
    and benchmark it against the pure Python version, renamed as `ParticleSimulator.evolve_python`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，我们将实现一个名为`ParticleSimulator.evolve_numpy`的方法，并将其与重命名为`ParticleSimulator.evolve_python`的纯Python版本进行基准测试：
- en: '[PRE49]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We also update the benchmark to conveniently change the number of particles
    and the simulation method, as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还更新了基准测试，以便方便地更改粒子数量和模拟方法，如下所示：
- en: '[PRE50]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Let''s run the benchmark in an IPython session:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在IPython会话中运行基准测试：
- en: '[PRE51]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We have some improvement, but it doesn''t look like a huge speed boost. The
    power of NumPy is revealed when handling big arrays. If we increase the number
    of particles, we will note a more significant performance boost:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一些改进，但看起来并不像是一个巨大的速度提升。NumPy的强大之处在于处理大型数组。如果我们增加粒子数量，我们将注意到更显著的性能提升：
- en: '[PRE52]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The plot in the following figure was produced by running the benchmark with
    different particle numbers:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个图中的图是通过运行具有不同粒子数的基准测试产生的：
- en: '![](img/image_03_003.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_03_003.png)'
- en: The plot shows that both the implementations scale linearly with particle size,
    but the runtime in the pure Python version grows much faster than the NumPy version;
    at greater sizes, we have a greater NumPy advantage. In general, when using NumPy,
    you should try to pack things into large arrays and group the calculations using
    the broadcasting feature.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 该图显示，两种实现都与粒子大小成线性关系，但纯Python版本的运行时间增长速度比NumPy版本快得多；在更大的尺寸下，我们有更大的NumPy优势。一般来说，当使用NumPy时，你应该尽量将事物打包成大型数组，并使用广播功能分组计算。
- en: Reaching optimal performance with numexpr
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用numexpr达到最佳性能
- en: When handling complex expressions, NumPy stores intermediate results in memory.
    David M. Cooke wrote a package called `numexpr`, which optimizes and compiles
    array expressions on the fly. It works by optimizing the usage of the CPU cache
    and by taking advantage of multiple processors.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理复杂表达式时，NumPy会在内存中存储中间结果。David M. Cooke编写了一个名为`numexpr`的包，该包在运行时优化和编译数组表达式。它是通过优化CPU缓存的使用并利用多个处理器来工作的。
- en: 'Its usage is generally straightforward and is based on a single function--`numexpr.evaluate`.
    The function takes a string containing an array expression as its first argument.
    The syntax is basically identical to that of NumPy. For example, we can calculate
    a simple `a + b * c` expression in the following way:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 它的使用通常很简单，基于一个单一的功能--`numexpr.evaluate`。该函数将包含数组表达式的字符串作为其第一个参数。语法基本上与NumPy相同。例如，我们可以以下这种方式计算一个简单的`a
    + b * c`表达式：
- en: '[PRE53]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The `numexpr` package increases the performances in almost all cases, but to
    get a substantial advantage, you should use it with large arrays. An application
    that involves a large array is the calculation of a *distance matrix*. In a particle
    system, a distance matrix contains all the possible distances between the particles.
    To calculate it, we should first calculate all the vectors connecting any two
    particles `(i,j)`, as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`numexpr`包几乎在所有情况下都能提高性能，但要获得实质性的优势，你应该使用它来处理大型数组。一个涉及大型数组的应用是计算一个*距离矩阵*。在粒子系统中，距离矩阵包含粒子之间所有可能距离。为了计算它，我们首先应该计算连接任何两个粒子`(i,j)`的所有向量，如下所示：'
- en: '[PRE54]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Then, we calculate the length of this vector by taking its norm, as in the
    following code:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过取其范数来计算这个向量的长度，如下所示：
- en: '[PRE55]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We can write this in NumPy by employing the usual broadcasting rules (the operation
    is similar to the outer product):'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用通常的广播规则（操作类似于外积）在NumPy中编写这个表达式：
- en: '[PRE56]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Finally, we calculate the norm over the last axis using the following line
    of code:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用以下代码行计算最后一个轴上的范数：
- en: '[PRE57]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Rewriting the same expression using the `numexpr` syntax is extremely easy.
    The `numexpr` package doesn''t support slicing in its array expression; therefore,
    we first need to prepare the operands for broadcasting by adding an extra dimension,
    as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`numexpr`语法重写相同的表达式非常简单。`numexpr`包不支持在数组表达式中进行切片；因此，我们首先需要通过添加一个额外的维度来准备广播的操作数，如下所示：
- en: '[PRE58]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: At that point, we should try to pack as many operations as possible in a single
    expression to allow a significant optimization.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个时刻，我们应该尽量在一个表达式中包含尽可能多的操作，以便进行显著的优化。
- en: 'Most of the NumPy mathematical functions are also available in `numexpr`. However,
    there is a limitation--the reduction operations (the ones that reduce an axis,
    such as sum) have to happen last. Therefore, we have to first calculate the sum,
    then step out of `numexpr`, and finally calculate the square root in another expression:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 NumPy 数学函数也存在于 `numexpr` 中。然而，有一个限制——减少操作（如求和）必须在最后发生。因此，我们必须首先计算总和，然后退出
    `numexpr`，最后在另一个表达式中计算平方根：
- en: '[PRE59]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The `numexpr` compiler will avoid redundant memory allocation by not storing intermediate
    results. When possible, it will also distribute the operations over multiple processors.
    In the `distance_matrix.py` file, you will find two functions that implement the
    two versions: `distance_matrix_numpy` and `distance_matrix_numexpr`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`numexpr` 编译器将通过不存储中间结果来避免冗余内存分配。在可能的情况下，它还会将操作分布到多个处理器上。在 `distance_matrix.py`
    文件中，你可以找到实现两个版本的函数：`distance_matrix_numpy` 和 `distance_matrix_numexpr`：'
- en: '[PRE60]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: By simply converting the expressions to use `numexpr`, we were able to obtain
    a 4.5x increase in performance over standard NumPy. The `numexpr` package can
    be used every time you need to optimize a NumPy expression that involves large
    arrays and complex operations, and you can do so with minimal changes in the code.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 通过简单地将表达式转换为使用 `numexpr`，我们能够将性能提高 4.5 倍。`numexpr` 包可以在你需要优化涉及大型数组和复杂操作的 NumPy
    表达式时使用，并且你可以通过代码的最小更改来实现这一点。
- en: Pandas
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pandas
- en: Pandas is a library originally developed by Wes McKinney, which was designed
    to analyze datasets in a seamless and performant way. In recent years, this powerful
    library has seen an incredible growth and huge adoption by the Python community.
    In this section, we will introduce the main concepts and tools provided in this
    library, and we will use it to increase performance of various usecases that can't
    otherwise be addressed with NumPy's vectorized operations and broadcasting.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Pandas 是由 Wes McKinney 开发的库，最初是为了以无缝和高效的方式分析数据集而设计的。近年来，这个强大的库在 Python 社区中看到了令人难以置信的增长和巨大的采用。在本节中，我们将介绍这个库中提供的主要概念和工具，并使用它来提高各种用例的性能，这些用例无法使用
    NumPy 的矢量化操作和广播来解决。
- en: Pandas fundamentals
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pandas 基础知识
- en: While NumPy deals mostly with arrays, Pandas main data structures are `pandas.Series`,
    `pandas.DataFrame`, and `pandas.Panel`. In the rest of this chapter, we will abbreviate
    `pandas` with `pd`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 NumPy 主要处理数组，但 Pandas 的主要数据结构是 `pandas.Series`、`pandas.DataFrame` 和 `pandas.Panel`。在本章的其余部分，我们将用
    `pd` 来缩写 `pandas`。
- en: The main difference between a `pd.Series` object and an `np.array` is that a `pd.Series`
    object associates a specific *key* to each element of an array. Let’s see how
    this works in practice with an example.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`pd.Series` 对象与 `np.array` 的主要区别在于，`pd.Series` 对象将一个特定的 *键* 关联到数组的每个元素。让我们通过一个例子来看看这在实践中是如何工作的。'
- en: Let's assume that we are trying to test a new blood pressure drug, and we want
    to store, for each patient, whether the patient's blood pressure improved after
    administering the drug. We can encode this information by associating to each
    subject ID (represented by an integer),  `True` if the drug was effective, and
    `False` otherwise.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在尝试测试一种新的降压药，并且我们想要存储每个患者在接受药物后血压是否有所改善。我们可以通过将每个受试者 ID（用一个整数表示）与 `True`
    关联来编码此信息，如果药物有效，否则为 `False`。
- en: 'We can create a `pd.Series` object by associating an array of keys, the patients,
    to the array of values that represent the drug effectiveness. The array of keys
    can be passed to the `Series` constructor using the `index` argument, as shown
    in the following snippet:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将表示药物有效性的值数组与键数组（患者）关联来创建一个 `pd.Series` 对象。键数组可以通过 `Series` 构造函数的 `index`
    参数传递给 `Series`，如下面的代码片段所示：
- en: '[PRE61]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Associating a set of integers from 0 to *N* to a set of values can technically
    be implemented with `np.array`, since, in this case, the key will simply be the
    position of the element in the array. In Pandas, keys are not limited to integers
    but can also be strings, floating point numbers, and also generic (hashable) Python
    objects. For example, we can easily turn our IDs into strings with little effort,
    as shown in the following code:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 将一组从 0 到 *N* 的整数与一组值关联，在技术上可以使用 `np.array` 实现，因为在这种情况下，键将简单地是数组中元素的位置。在 Pandas
    中，键不仅限于整数，还可以是字符串、浮点数，甚至是通用的（可哈希的）Python 对象。例如，我们可以轻松地将我们的 ID 转换为字符串，如下面的代码所示：
- en: '[PRE62]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: An interesting observation is that, while NumPy arrays can be thought of as
    a contiguous collection of values similar to Python lists, the Pandas `pd.Series`
    object can be thought of as a structure that maps keys to values, similar to Python
    dictionaries.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有趣的观察是，虽然NumPy数组可以被看作是类似于Python列表的连续值集合，但Pandas的`pd.Series`对象可以被看作是一个将键映射到值的结构，类似于Python字典。
- en: What if you want to store the initial and final blood pressure for each patient?
    In Pandas, one can use a `pd.DataFrame` object to associate multiple data to each
    key.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想存储每个患者的初始和最终血压值怎么办？在Pandas中，可以使用`pd.DataFrame`对象将多个数据关联到每个键。
- en: '`pd.DataFrame` can be initialized, similarly to a `pd.Series` object, by passing
    a dictionary of columns and an index. In the following example, we will see how
    to create a `pd.DataFrame` containing four columns that represent the initial
    and final measurements of systolic and dyastolic blood pressure for our patients:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`pd.DataFrame`可以通过传递列和索引的字典，类似于`pd.Series`对象进行初始化。在以下示例中，我们将看到如何创建包含四个列的`pd.DataFrame`，这些列代表我们患者的收缩压和舒张压的初始和最终测量值：'
- en: '[PRE63]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Equivalently, you can think of a `pd.DataFrame` as a collection of `pd.Series`.
    In fact, it is possible to directly initialize a `pd.DataFrame`, using a dictionary
    of `pd.Series` instances:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，你可以将`pd.DataFrame`视为`pd.Series`集合。实际上，你可以直接使用`pd.Series`实例的字典初始化`pd.DataFrame`：
- en: '[PRE64]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'To inspect the content of a `pd.DataFrame` or `pd.Series` object, you can use
    the `pd.Series.head` and `pd.DataFrame.head` methods, which print the first few
    rows of the dataset:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查`pd.DataFrame`或`pd.Series`对象的内容，你可以使用`pd.Series.head`和`pd.DataFrame.head`方法，这些方法会打印数据集的前几行：
- en: '[PRE65]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Just like a `pd.DataFrame` can be used to store a collection of `pd.Series`,
    you can use a `pd.Panel` to store a collection of `pd.DataFrames`. We will not
    cover the usage of `pd.Panel` as it is not used as often as `pd.Series` and `pd.DataFrame`.
    To learn more about `pd.Panel`, ensure that you refer to the excellent documentation
    at [http://pandas.pydata.org/pandas-docs/stable/dsintro.html#panel](http://pandas.pydata.org/pandas-docs/stable/dsintro.html#panel).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`pd.DataFrame`可以用来存储`pd.Series`集合一样，你可以使用`pd.Panel`来存储`pd.DataFrames`集合。我们不会介绍`pd.Panel`的用法，因为它不像`pd.Series`和`pd.DataFrame`那样常用。要了解更多关于`pd.Panel`的信息，请确保参考优秀的文档[http://pandas.pydata.org/pandas-docs/stable/dsintro.html#panel](http://pandas.pydata.org/pandas-docs/stable/dsintro.html#panel)。
- en: Indexing Series and DataFrame objects
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 索引Series和DataFrame对象
- en: 'Retrieving data from a `pd.Series`, given its *key*, can be done intuitively
    by indexing the `pd.Series.loc` attribute:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 根据其*键*检索`pd.Series`中的数据可以通过索引`pd.Series.loc`属性直观地完成：
- en: '[PRE66]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'It is also possible to access the elements, given its *position* in the underlying
    array, using the `pd.Series.iloc` attribute:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用`pd.Series.iloc`属性，根据其底层数组中的*位置*访问元素：
- en: '[PRE67]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'You can also use the `pd.Series.ix` attribute for mixed access. If the key
    is not an integer, it will try to match by key, otherwise it will extract the
    element at the position indicated by the integer. A similar behavior will take
    place when you access the `pd.Series` directly. The following example demonstrates
    these concepts:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用`pd.Series.ix`属性进行混合访问。如果键不是整数，它将尝试通过键匹配，否则它将提取由整数指示的位置的元素。当你直接访问`pd.Series`时，将发生类似的行为。以下示例演示了这些概念：
- en: '[PRE68]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Note that if the index is made of integers, this method will fall back to the
    key-only method (like `loc`). To index by position in this scenario, the `iloc`
    method is your only option.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果索引由整数组成，此方法将回退到仅键的方法（如`loc`）。在这种情况下，按位置索引的唯一选项是`iloc`方法。
- en: 'Indexing `pd.DataFrame` works in a similar way. For example, you can use `pd.DataFrame.loc`
    to extract a row by key, and you can use `pd.DataFrame.iloc` to extract a row
    by position:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`pd.DataFrame`的索引工作方式类似。例如，你可以使用`pd.DataFrame.loc`通过键提取一行，你也可以使用`pd.DataFrame.iloc`通过位置提取一行：'
- en: '[PRE69]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'An important aspect is that the return type in this case is a `pd.Series`,
    where each column is a new key. In order to retrieve a specific row and column,
    you can use the following code. The `loc` attribute will index both row and column
    by key, while the `iloc` version will index row and column by an integer:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的一个方面是，在这种情况下返回的类型是`pd.Series`，其中每一列都是一个新键。为了检索特定的行和列，你可以使用以下代码。`loc`属性将按键索引行和列，而`iloc`版本将按整数索引行和列：
- en: '[PRE70]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Indexing a `pd.DataFrame` using the `ix` attribute is convenient to mix and
    match index and location-based indexing. For example, retrieving the `"sys_initial"`
    column for the row at position 0 can be accomplished as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `ix` 属性索引 `pd.DataFrame` 便于混合使用索引和基于位置的索引。例如，检索位置为 0 的行的 `"sys_initial"`
    列可以按以下方式完成：
- en: '[PRE71]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Retrieving a column from a `pd.DataFrame` by name can be achieved by regular
    indexing or attribute access.  To retrieve a column by position, you can either
    use `iloc` or use the `pd.DataFrame.column` attribute to retrieve the name of
    the column:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 通过名称从 `pd.DataFrame` 中检索列可以通过常规索引或属性访问实现。要按位置检索列，可以使用 `iloc` 或使用 `pd.DataFrame.column`
    属性来检索列名：
- en: '[PRE72]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The mentioned methods also support more advanced indexing similar to those of
    NumPy, such as `bool`, lists, and `int` arrays.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 提到的这些方法也支持类似于 NumPy 的更高级的索引，例如 `bool`、列表和 `int` 数组。
- en: Now it's time for some performance considerations. There are some differences
    between an index in Pandas and a dictionary. For example, while the keys of a
    dictionary cannot contain duplicates, Pandas indexes can contain repeated elements.
    This flexibility, however, comes at a cost--if we try to access an element in
    a non-unique index, we may incur substantial performance loss--the access will
    be *O*(*N*), like a linear search, rather than *O*(1), like a dictionary.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候考虑一些性能问题。Pandas 中的索引与字典之间有一些区别。例如，虽然字典的键不能包含重复项，但 Pandas 索引可以包含重复元素。然而，这种灵活性是有代价的--如果我们尝试访问非唯一索引中的元素，我们可能会遭受重大的性能损失--访问将是
    *O*(*N*)，类似于线性搜索，而不是 *O*(1)，类似于字典。
- en: 'A way to mitigate this effect is to sort the index; this will allow Pandas
    to use a binary search algorithm with a computational complexity of *O*(*log*(*N*)),
    which is much better. This can be accomplished using the `pd.Series.sort_index`
    function, as in the following code (the same applies for `pd.DataFrame`):'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 减缓这种影响的一种方法是对索引进行排序；这将允许 Pandas 使用计算复杂度为 *O*(*log*(*N*)) 的二分搜索算法，这要好得多。这可以通过使用
    `pd.Series.sort_index` 函数实现，如下面的代码所示（同样适用于 `pd.DataFrame`）：
- en: '[PRE73]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The timings for the different versions are summarized in the following table:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 不同版本的计时总结在下表中：
- en: '| **Index type** | **N=10000** | **N=20000** | **N=30000** | **Time** |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| **索引类型** | **N=10000** | **N=20000** | **N=30000** | **时间** |'
- en: '| Unique | 12.30 | 12.58 | 13.30 | *O*(1) |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| 唯一 | 12.30 | 12.58 | 13.30 | *O*(1) |'
- en: '| Non unique | 494.95 | 814.10 | 1129.95 | *O*(N) |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| 非唯一 | 494.95 | 814.10 | 1129.95 | *O*(N) |'
- en: '| Non unique (sorted) | 145.93 | 145.81 | 145.66 | *O*(*log*(*N*)) |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| 非唯一（排序） | 145.93 | 145.81 | 145.66 | *O*(*log*(*N*)) |'
- en: Database-style operations with Pandas
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Pandas 进行数据库风格的操作
- en: You may have noted that the “tabular” data is similar to what is usually stored
    in a database. A database is usually indexed using a primary key, and the various
    columns can have different data types, just like in a `pd.DataFrame`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，“表格”数据类似于通常存储在数据库中的数据。数据库通常使用主键进行索引，而不同的列可以有不同的数据类型，就像在 `pd.DataFrame`
    中一样。
- en: The efficiency of the index operations in Pandas makes it suitable for database
    style manipulations, such as counting, joining, grouping, and aggregations.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: Pandas 中索引操作的效率使其适合于数据库风格的操作，如计数、连接、分组和聚合。
- en: Mapping
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 映射
- en: 'Pandas supports element-wise operations just like NumPy (after all, `pd.Series`
    stores their data using `np.array`). For example, it is possible to apply transformation
    very easily on both `pd.Series` and `pd.DataFrame`:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: Pandas 支持与 NumPy 类似的元素级操作（毕竟，`pd.Series` 使用 `np.array` 存储其数据）。例如，可以在 `pd.Series`
    和 `pd.DataFrame` 上非常容易地应用转换：
- en: '[PRE74]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'You can also perform element-wise operations between two `pd.Series` in a way
    similar to NumPy. An important difference is that the operands will be matched
    by key, rather than by position; if there is a mismatch in the index, the resulting
    value will be set to `NaN`. Both the scenarios are exemplified in the following
    example:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以以类似于 NumPy 的方式在两个 `pd.Series` 之间执行元素级操作。一个重要的区别是操作数将按键匹配，而不是按位置匹配；如果索引不匹配，结果值将被设置为
    `NaN`。以下示例展示了这两种情况：
- en: '[PRE75]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: For added flexibility, Pandas exposes the `map`, `apply`, and `applymap` methods that
    can be used to apply specific transformations.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 为了增加灵活性，Pandas 提供了 `map`、`apply` 和 `applymap` 方法，可以用来应用特定的转换。
- en: 'The `pd.Series.map` method can be used to execute a function to each value
    and return a `pd.Series` containing each result. In the following example, we
    show how to apply the `superstar` function to each element of a `pd.Series`:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `pd.Series.map` 方法对每个值执行一个函数，并返回一个包含每个结果的 `pd.Series`。在以下示例中，我们展示了如何将 `superstar`
    函数应用于 `pd.Series` 的每个元素：
- en: '[PRE76]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The `pd.DataFrame.applymap` function is the equivalent of `pd.Series.map`,
    but for `DataFrames`:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`pd.DataFrame.applymap` 函数是 `pd.Series.map` 的等价函数，但适用于 `DataFrames`：'
- en: '[PRE77]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Finally, the `pd.DataFrame.apply` function can apply the passed function to
    each column or each row, rather than element-wise. The selection can be performed
    with the argument axis, where a value of `0` (the default) corresponds to columns,
    and `1` corresponds to rows. Also, note that the return value of `apply` is a
    `pd.Series`:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`pd.DataFrame.apply` 函数可以将传递的函数应用于每一列或每一行，而不是逐个元素。选择可以通过 `axis` 参数执行，其中 `0`（默认值）对应于列，`1`
    对应于行。请注意，`apply` 的返回值是一个 `pd.Series`：
- en: '[PRE78]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Pandas also supports efficient `numexpr`-style expressions with the convenient `eval`
    method. For example, if we want to calculate the difference in the final and initial
    blood pressure, we can write the expression as a string, as shown in the following
    code:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: Pandas 还支持使用方便的 `eval` 方法执行高效的 `numexpr`-风格表达式。例如，如果我们想计算最终和初始血压的差异，我们可以将表达式写成字符串，如下面的代码所示：
- en: '[PRE79]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'It is also possible to create new columns using the assignment operator in
    the `pd.DataFrame.eval` expression. Note that, if the `inplace=True` argument
    is used, the operation will be applied directly on the original `pd.DataFrame`;
    otherwise, the function will return a new dataframe. In the next example, we compute
    the difference between `sys_final` and `sys_initial`, and we store it in the `sys_delta`
    column:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `pd.DataFrame.eval` 表达式中的赋值运算符也可以创建新的列。请注意，如果使用 `inplace=True` 参数，操作将直接应用于原始的
    `pd.DataFrame`；否则，函数将返回一个新的数据框。在下一个示例中，我们计算 `sys_final` 和 `sys_initial` 之间的差异，并将其存储在
    `sys_delta` 列中：
- en: '[PRE80]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Grouping, aggregations, and transforms
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分组、聚合和转换
- en: 'One of the most appreciated features of Pandas is the simple and concise expression
    of data analysis pipelines that requires grouping, transforming, and aggregating
    the data. To demonstrate this concept, let''s extend our dataset by adding two
    new patients to whom we didn''t administer the treatment (this is usually called
    a *control group*). We also include a column, `drug_admst`, which records whether the
    patient was administered the treatment:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: Pandas 最受赞赏的功能之一是简单简洁地表达需要分组、转换和聚合数据的分析管道。为了演示这个概念，让我们通过添加两个未接受治疗的新患者来扩展我们的数据集（这通常被称为
    *对照组*）。我们还包含一个列，`drug_admst`，该列记录患者是否接受了治疗：
- en: '[PRE81]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'At this point, we may be interested to know how the blood pressure changed
    between the two groups. You can group the patients according to `drug_amst` using
    the `pd.DataFrame.groupby` function. The return value will be the `DataFrameGroupBy`
    object, which can be iterated to obtain a new `pd.DataFrame` for each value of
    the `drug_admst` column:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们可能想知道两组之间的血压变化情况。您可以使用 `pd.DataFrame.groupby` 函数根据 `drug_amst` 对患者进行分组。返回值将是
    `DataFrameGroupBy` 对象，可以迭代以获取每个 `drug_admst` 列值的新的 `pd.DataFrame`：
- en: '[PRE82]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Iterating on the `DataFrameGroupBy` object is almost never necessary, because,
    thanks to method chaining, it is possible to calculate group-related properties directly.
    For example, we may want to calculate mean, max, or standard deviation for each
    group. All those operations that summarize the data in some way are called aggregations
    and can be performed using the `agg` method. The result of `agg` is another `pd.DataFrame` that
    relates the grouping variables and the result of the aggregation, as illustrated
    in the following code:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `DataFrameGroupBy` 对象上迭代几乎从不必要，因为，多亏了方法链，可以直接计算与组相关的属性。例如，我们可能想要计算每个组的平均值、最大值或标准差。所有以某种方式总结数据的操作都称为聚合，可以使用
    `agg` 方法执行。`agg` 的结果是一个新的 `pd.DataFrame`，它关联了分组变量和聚合结果，如下面的代码所示：
- en: '[PRE83]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '**It is also possible to perform processing on the DataFrame groups that do
    not represent a summarization. One common example of such an operation is filling
    in missing values. Those intermediate steps are called *transforms*.**'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '**还可以对不表示汇总的 DataFrame 组进行处理。这类操作的一个常见例子是填充缺失值。这些中间步骤被称为 *转换*。**'
- en: 'We can illustrate this concept with an example. Let''s assume that we have
    a few missing values in our dataset, and we want to replace those values with
    the average of the other values in the same group. This can be accomplished using
    a transform, as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用一个例子来说明这个概念。假设我们的数据集中有一些缺失值，我们想要用同一组中其他值的平均值来替换这些值。这可以通过以下方式使用转换来完成：
- en: '[PRE84]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Joining
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接
- en: 'Joins are useful to aggregate data that is scattered among different tables.
    Let’s say that we want to include the location of the hospital in which patient
    measurements were taken in our dataset. We can reference the location for each
    patient using the `H1`, `H2`, and `H3` labels, and we can store the address and
    identifier of the hospital in a `hospital` table:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 连接对于聚合分散在不同表中的数据非常有用。假设我们想在数据集中包含患者测量所进行的医院的位置。我们可以使用`H1`、`H2`和`H3`标签来引用每个患者的位置，并将医院的地址和标识符存储在`hospital`表中：
- en: '[PRE85]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Now, we want to find the city where the measure was taken for each patient.
    We need to *map* the keys from the `hospital_id` column to the city stored in
    the `hospitals` table.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们想要找到每个患者所测量的城市。我们需要将`hospital_id`列中的键*映射*到存储在`hospitals`表中的城市。
- en: 'This can surely be implemented in Python using dictionaries:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这肯定可以用Python中的字典来实现：
- en: '[PRE86]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'This algorithm runs efficiently with an *O*(*N*) time complexity, where *N*
    is the size of `hospital_id`. Pandas allows you to encode the same operation using
    simple indexing; the advantage is that the join will be performed in heavily optimized
    Cython and with efficient hashing algorithms. The preceding simple Python expression
    can be easily converted to Pandas in this way:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 此算法以*O*(*N*)的时间复杂度高效运行，其中*N*是`hospital_id`的大小。Pandas允许您使用简单的索引来编码相同的操作；优势在于连接将在高度优化的Cython和高效的哈希算法下执行。前面的简单Python表达式可以很容易地以这种方式转换为Pandas：
- en: '[PRE87]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'More advanced joins can also be performed with the `pd.DataFrame.join` method,
    which will produce a new `pd.DataFrame` that will attach the hospital information
    for each patient:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 更高级的连接也可以使用`pd.DataFrame.join`方法执行，这将生成一个新的`pd.DataFrame`，将为每个患者附加医院信息：
- en: '[PRE88]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Summary
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we learned how to manipulate NumPy arrays and how to write
    fast mathematical expressions using array broadcasting. This knowledge will help
    you write more concise, expressive code and, at the same time, to obtain substantial
    performance gains. We also introduced the `numexpr` library to further speed up
    NumPy calculations with minimal effort.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何操作NumPy数组，以及如何使用数组广播编写快速数学表达式。这些知识将帮助您编写更简洁、更具表现力的代码，同时获得实质性的性能提升。我们还介绍了`numexpr`库，以最小的努力进一步加快NumPy计算的速度。
- en: Pandas implements efficient data structures that are useful when analyzing large
    datasets. In particular, Pandas shines when the data is indexed by non-integer
    keys and provides very fast hashing algorithms.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: Pandas实现了高效的数据结构，这在分析大型数据集时非常有用。特别是，当数据通过非整数键索引时，Pandas表现得尤为出色，并提供了非常快速的哈希算法。
- en: NumPy and Pandas work well when handling large, homogenous inputs, but they
    are not suitable when the expressions grow complex and the operations cannot be
    expressed using the tools provided by these libraries. In such cases, we can leverage
    Python capabilities as a glue language by interfacing it with C using the Cython
    package.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy和Pandas在处理大型、同质输入时表现良好，但当表达式变得复杂且无法使用这些库提供的工具表达时，它们就不太适合了。在这种情况下，我们可以通过使用Cython包与C接口，利用Python作为粘合语言的能力。
