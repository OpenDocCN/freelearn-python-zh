- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Improving Data Storage with SQL
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 SQL 提升数据存储
- en: 'As weeks have passed by, there is a growing problem at the lab: CSV files are
    everywhere! Conflicting copies, missing files, records getting changed by non-data
    entry staff, and other CSV-related frustrations are plaguing the project. Unfortunately,
    the password protection in the application does nothing meaningful to prevent
    anyone from editing the files and corrupting data. It''s clear that the current
    data storage solution is not working out. Something better is needed!'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，实验室出现了一个日益严重的问题：CSV 文件无处不在！冲突的副本、丢失的文件、非数据录入人员更改的记录，以及其他与 CSV 相关的挫折正在困扰着项目。不幸的是，应用程序中的密码保护并没有起到任何有意义的作用，以防止任何人编辑文件和损坏数据。很明显，当前的数据存储解决方案不起作用。需要更好的解决方案！
- en: The facility has an older Linux server with a PostgreSQL database installed.
    You've been asked to update your program so that it stores data in the PostgreSQL
    database rather than in the CSV files, and authenticates users against the database.
    This way there can be one authoritative source of data to which the support staff
    can easily manage access. In addition, the SQL database will help enforce correct
    data types and allow for more complex data relationships than the simple flat
    file. This promises to be a major update to your application!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 该设施有一个安装了 PostgreSQL 数据库的较旧的 Linux 服务器。你被要求更新你的程序，使其将数据存储在 PostgreSQL 数据库中，而不是
    CSV 文件中，并针对数据库进行用户认证。这样就可以有一个权威的数据源，支持人员可以轻松地管理访问权限。此外，SQL 数据库将有助于强制执行正确的数据类型，并允许比简单的平面文件更复杂的数据关系。这将是你的应用程序的一个重大更新！
- en: 'In this chapter, you''ll learn the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章，你将学习以下主题：
- en: In *PostgreSQL*, we'll install and configure the PostgreSQL database system.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *PostgreSQL* 中，我们将安装和配置 PostgreSQL 数据库系统。
- en: In *Modeling relational data*, we'll discuss the art of structuring data in
    a database for good performance and reliability.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *关系数据建模* 中，我们将讨论如何在数据库中结构化数据以实现良好的性能和可靠性。
- en: In *Creating the ABQ database*, we'll build a SQL database for the ABQ Data
    Entry application.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *创建 ABQ 数据库* 中，我们将为 ABQ 数据录入应用程序构建一个 SQL 数据库。
- en: In *Connecting to PostgreSQL with psycopg2*, we'll use the `psycopg2` library
    to connect our program to PostgreSQL.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *使用 psycopg2 连接到 PostgreSQL* 中，我们将使用 `psycopg2` 库将我们的程序连接到 PostgreSQL。
- en: Finally, in *Integrating SQL into our application*, we'll update ABQ Data Entry
    to utilize the new SQL database.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，在 *将 SQL 集成到我们的应用程序中* 中，我们将更新 ABQ 数据录入以利用新的 SQL 数据库。
- en: This chapter assumes you have a basic knowledge of SQL. If you don't, please
    see *Appendix B*, *A Quick SQL Tutorial*.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章假设你具备基本的 SQL 知识。如果你不具备，请参阅 *附录 B*，*快速 SQL 教程*。
- en: PostgreSQL
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PostgreSQL
- en: Python can interact with a wide variety of relational databases, including Microsoft
    SQL Server, Oracle, MariaDB, MySQL, and SQLite; in this book, we're going to focus
    on a very popular choice in the Python world, PostgreSQL. PostgreSQL (usually
    pronounced post-gress, with the "QL" silent) is a free, open source, cross-platform
    relational database system. It runs as a network service with which you can communicate
    using client programs or software libraries. At the time of writing, version 13
    is the current stable.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Python 可以与各种关系型数据库进行交互，包括 Microsoft SQL Server、Oracle、MariaDB、MySQL 和 SQLite；在这本书中，我们将专注于
    Python 世界中一个非常受欢迎的选择，即 PostgreSQL。PostgreSQL（通常发音为 post-gress，其中 "QL" 静音）是一个免费、开源、跨平台的数据库系统。它作为网络服务运行，你可以使用客户端程序或软件库与其通信。在撰写本文时，版本
    13 是当前的稳定版本。
- en: Although ABQ has provided a PostgreSQL server that is already installed and
    configured, you'll need to download and install the software on your workstation
    for development purposes. Let's take a look at how we can get our workstation
    ready for PostgreSQL development.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然ABQ已经提供了一个已经安装和配置好的 PostgreSQL 服务器，但你仍需要在你的工作站上下载和安装软件以进行开发。让我们看看如何让我们的工作站为
    PostgreSQL 开发做好准备。
- en: Shared production resources such as databases and web services should never
    be used for testing or development. Always set up a separate development copy
    of these resources on your own workstation or a separate server machine.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 应该永远不要在测试或开发中使用共享的生产资源，如数据库和 Web 服务。始终在你的工作站或单独的服务器机器上设置这些资源的单独开发副本。
- en: Installing and configuring PostgreSQL
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装和配置 PostgreSQL
- en: To download PostgreSQL, visit [https://www.postgresql.org/download](https://www.postgresql.org/download)
    and download an installation package for your operating system. Installation packages
    are provided for Windows, macOS, Linux, BSD, and Solaris by EnterpriseDB, a commercial
    entity that provides paid support for PostgreSQL. These installers include the
    server, command-line client, and **pgAdmin** graphical client all in one package.
    To install the software, launch the installer using an account with administrative
    rights and follow the screens in the installation wizard. During installation,
    you'll be asked to set a password for the `postgres` superuser account; make sure
    to take note of this password.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要下载 PostgreSQL，请访问 [https://www.postgresql.org/download](https://www.postgresql.org/download)
    并下载适用于您操作系统的安装包。EnterpriseDB（一家为 PostgreSQL 提供付费支持的商业实体）提供了 Windows、macOS、Linux、BSD
    和 Solaris 的安装包。这些安装程序包含服务器、命令行客户端和 **pgAdmin** 图形客户端，全部包含在一个包中。要安装软件，请使用具有管理员权限的账户启动安装程序，并按照安装向导中的屏幕操作。在安装过程中，您将被要求为
    `postgres` 超级用户账户设置密码；请务必记下此密码。
- en: Configuring PostgreSQL using the GUI utility
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用图形实用程序配置 PostgreSQL
- en: 'Once installed, you can configure and interact with PostgreSQL using the **pgAdmin**
    graphical utility. Go ahead and launch pgAdmin from your application menu and
    follow these steps to create a new admin user for yourself:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，您可以使用 **pgAdmin** 图形实用程序配置和与 PostgreSQL 交互。从您的应用程序菜单启动 pgAdmin，并按照以下步骤为自己创建一个新的管理员用户：
- en: Select **Servers** from the **Browser** pane on the left. You'll be prompted
    for your superuser password.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从左侧的 **浏览器** 窗格中选择 **服务器**。您将被提示输入超级用户密码。
- en: Once authenticated, select **Object** | **Create** | **Login/Group Role**. Enter
    a username to use for database access on the **General** tab. Then visit the **Privileges**
    tab to check **Superuser** and **Can Login**, and the **Definition** tab to set
    a password.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦认证，选择 **对象** | **创建** | **登录/组角色**。在 **常规** 选项卡中输入用于数据库访问的用户名。然后访问 **权限**
    选项卡以检查 **超级用户** 和 **可以登录**，以及 **定义** 选项卡以设置密码。
- en: Click the **Save** button at the bottom of the window.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在窗口底部点击 **保存** 按钮。
- en: 'Next, we need to create a database. To do that, follow these steps:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一个数据库。为此，请按照以下步骤操作：
- en: Select **Object** | **Create** | **Database** from the menu.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从菜单中选择 **对象** | **创建** | **数据库**。
- en: Name the database `abq`, and set your new user account as the owner.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数据库命名为 `abq`，并将您的新用户账户设置为所有者。
- en: Click the **Save** button at the bottom of the window.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在窗口底部点击 **保存** 按钮。
- en: Your database is now ready to work with. You can begin entering SQL to run against
    your database by selecting the database in the **Browser** pane and clicking on
    **Tools** | **Query Tool** in the menu.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 您的数据库现在已准备好使用。您可以通过在 **浏览器** 窗格中选择数据库并点击菜单中的 **工具** | **查询工具** 来开始输入 SQL 语句以运行数据库。
- en: Configuring PostgreSQL using the command line
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用命令行配置 PostgreSQL
- en: 'If you prefer to work directly in the command line, PostgreSQL includes several
    command-line utilities, including the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您更喜欢直接在命令行中工作，PostgreSQL 包含几个命令行实用程序，包括以下内容：
- en: '| Command | Description |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| 命令 | 描述 |'
- en: '| `createuser` | Create PostgreSQL user accounts |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `createuser` | 创建 PostgreSQL 用户账户 |'
- en: '| `dropuser` | Delete PostgreSQL user accounts |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `dropuser` | 删除 PostgreSQL 用户账户 |'
- en: '| `createdb` | Create PostgreSQL databases |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `createdb` | 创建 PostgreSQL 数据库 |'
- en: '| `dropdb` | Delete PostgreSQL databases |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `dropdb` | 删除 PostgreSQL 数据库 |'
- en: '| `psql` | Command-line SQL shell |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `psql` | 命令行 SQL shell |'
- en: 'For example, on macOS or Linux, we can complete the configuration of our database
    with the following commands:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在 macOS 或 Linux 上，我们可以使用以下命令完成数据库的配置：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: These three commands create the user, create the database, and open a SQL shell
    where queries can be entered. Note that we use the `sudo` command to run these
    as the `postgres` user. Remember that this is the superuser account you set up
    during installation.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个命令创建用户、创建数据库并打开一个 SQL shell，可以在其中输入查询。请注意，我们使用 `sudo` 命令以 `postgres` 用户身份运行这些命令。请记住，这是您在安装过程中设置的超级用户账户。
- en: Although EnterpriseDB provides binary installers for Linux, most Linux users
    will prefer to use packages supplied by their distribution. You may end up with
    a slightly older version of PostgreSQL, but that won't matter for most basic use
    cases. Be aware that pgAdmin is usually part of a separate package, and also may
    be at a slightly older version. Regardless, you should have no trouble following
    this chapter with the older version.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管EnterpriseDB为Linux提供了二进制安装程序，但大多数Linux用户更愿意使用他们发行版提供的软件包。你可能会得到一个稍微旧一点的PostgreSQL版本，但对于大多数基本用例来说这不会很重要。请注意，pgAdmin通常是一个单独的软件包的一部分，也可能是一个稍微旧一点的版本。无论如何，你应该没有困难地使用较旧版本来跟随这一章节。
- en: Modeling relational data
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关系型数据建模
- en: Our application currently stores data in a single CSV file; a file like this
    is often called a **flat file**, because the data has been flattened to two dimensions.
    While this format works acceptably for our application and could be translated
    directly to a SQL table, a more accurate and useful data model requires more complexity.
    In this section, we're going to go through some concepts of data modeling that
    will help us convert our CSV data into effective relational tables.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序目前将数据存储在一个单一的CSV文件中；这样的文件通常被称为**平面文件**，因为数据已经被展平到二维。虽然这种格式对我们应用程序来说是可接受的，并且可以直接转换为SQL表，但一个更准确和有用的数据模型需要更多的复杂性。在本节中，我们将介绍一些数据建模的概念，这将帮助我们将CSV数据转换为有效的关系表。
- en: Primary keys
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主键
- en: Every table in a relational database should have something called a **primary
    key**. The primary key is a value, or set of values, that uniquely identifies
    a record in the table; as such, it should be a value or set of values that is
    unique and non-null for every row in a table. Other tables in the database can
    use this field to reference particular rows of the table. This is called a **foreign
    key** relationship.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 关系型数据库中的每个表都应该有一个称为**主键**的东西。主键是一个值，或一组值，它唯一地标识表中的记录；因此，它应该是一个值或一组值，对于表中的每一行都是唯一的且非空的。数据库中的其他表可以使用此字段来引用表中的特定行。这被称为**外键**关系。
- en: 'How do we figure out what the primary key is for a set of data? Consider this
    table:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何确定一组数据的主键是什么？考虑这个表格：
- en: '| Fruit | Classification |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 水果 | 分类 |'
- en: '| Banana | Berry |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 香蕉 | 草莓 |'
- en: '| Kiwi | Berry |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 香蕉 | 草莓 |'
- en: '| Orange | Citrus |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 橙子 | 柑橘 |'
- en: '| Lemon | Citrus |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 柠檬 | 柑橘 |'
- en: In this table, each row represents a type of fruit. It would make no sense for
    the `Fruit` column to be empty in this table, or for two rows to have the same
    value for `Fruit`. This makes the column a perfect candidate for a primary key.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个表中，每一行代表一种水果类型。在这个表中，`水果`列是空的就没有意义，或者两行对于`水果`有相同的值也是不合理的。这使得该列成为主键的完美候选者。
- en: 'Now consider a different table:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑一个不同的表格：
- en: '| Fruit | Variety | Quantity |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 水果 | 品种 | 数量 |'
- en: '| Banana | Cavendish | 452 |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 香蕉 | 凯文迪什 | 452 |'
- en: '| Banana | Red | 72 |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 香蕉 | 红色 | 72 |'
- en: '| Orange | Navel | 1023 |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| 橙子 | 橘子 | 1023 |'
- en: '| Orange | Red | 875 |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| 橙子 | 红色 | 875 |'
- en: In this table, each row represents a subvariety of fruit; however, there is
    no one field that uniquely defines a single variety of a single fruit. Instead,
    it requires both the `Fruit` and `Variety` fields. When we need multiple fields
    to determine the primary key, we call this a **composite primary key**. In this
    case, our composite primary key uses both the `Fruit` and `Variety` fields.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个表中，每一行代表一种水果的亚品种；然而，没有单个字段可以唯一地定义单一水果的单一品种。相反，需要`水果`和`品种`字段。当我们需要多个字段来确定主键时，我们称之为**组合主键**。在这种情况下，我们的组合主键使用了`水果`和`品种`字段。
- en: Using surrogate primary keys
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用代理主键
- en: 'Consider this table of `employees`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个`员工`表：
- en: '| First | Last | Title |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| 名字 | 姓氏 | 职位 |'
- en: '| Bob | Smith | Manager |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| 鲍勃 | 史密斯 | 经理 |'
- en: '| Alice | Jones | Analyst |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| 爱丽丝 | 琼斯 | 分析师 |'
- en: '| Pat | Thompson | Developer |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| 帕特 | 汤普森 | 开发者 |'
- en: Suppose this table were to use `First` and `Last` as a composite primary key,
    and suppose that other tables in the database reference rows using the primary
    keys. Leaving aside the obvious problem that two people can have the same first
    and last name, what would happen if Bob Smith decided he would prefer to be called
    Robert, or if Alice Jones married and took a new last name? Remember that other
    tables use the primary key value to reference rows in the table; if we change
    the contents of the primary key field, all the tables referencing these employees
    would either have to be updated as well or they would be unable to locate the
    record in the `employees` table.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 假设这个表使用 `First` 和 `Last` 作为复合主键，并且假设数据库中的其他表使用主键引用行。不考虑两个同名同姓的人显然的问题，如果 Bob
    Smith 决定他更愿意被称为 Robert，或者如果 Alice Jones 结婚并取了新的姓氏，会发生什么？记住，其他表使用主键值来引用表中的行；如果我们更改主键字段的值，引用这些员工的表要么也必须更新，要么将无法在
    `employees` 表中找到记录。
- en: 'While using actual data fields to build a primary key value is arguably the
    most theoretically pure approach, there are two big downsides that come up when
    you start relating tables using foreign keys:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用实际数据字段来构建主键值在理论上可能是最纯粹的方法，但当您开始使用外键关联表时，会出现两个主要的缺点：
- en: You have to duplicate the data in every table that needs to reference your table.
    This can particularly become onerous if you have a composite key of many fields.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您必须在需要引用您的表的每个表中重复数据。如果您有许多字段组成的复合键，这可能会变得特别繁琐。
- en: You can't change the values in the original table without breaking foreign key
    references.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您不能更改原始表中的值，否则会破坏外键引用。
- en: 'For this reason, database engineers may opt for using **surrogate keys**. These
    are typically integer or **globally unique identifier** (**GUID**) values stored
    in an **identity column** that are automatically added to a record when it is
    inserted into a table. In the case of the `employees` table, we could simply add
    an `ID` field containing an auto-incrementing integer value, like so:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，数据库工程师可能会选择使用**代理键**。这些通常是存储在**标识列**中的整数或**全局唯一标识符**（**GUID**）值，当记录被插入到表中时，这些值会自动添加到记录中。在
    `employees` 表的情况下，我们可以简单地添加一个包含自动递增整数值的 `ID` 字段，如下所示：
- en: '| ID | First | Last | Title |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| ID | 首名 | 姓氏 | 职位 |'
- en: '| 1 | Bob | Smith | Manager |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| 1 | Bob | Smith | 经理 |'
- en: '| 2 | Alice | Jones | Analyst |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| 2 | Alice | Jones | 分析师 |'
- en: '| 3 | Pat | Thompson | Developer |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 3 | Pat | Thompson | 开发者 |'
- en: Now other tables can simply refer to `employees.ID=1`, or `employees.ID=2`,
    leaving `Bob` and `Alice` free to change their names without consequence.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，其他表可以简单地引用 `employees.ID=1` 或 `employees.ID=2`，这样 `Bob` 和 `Alice` 就可以自由更改他们的名字而不会产生后果。
- en: The use of surrogate keys arguably breaks the theoretical purity of a database;
    it also may require us to manually specify uniqueness or non-null constraints
    on columns that are implicit when they are used as a primary key. Sometimes, though,
    the practical advantages of surrogate keys outweigh these concerns. You will need
    to evaluate which option works best with your application and its data.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 使用代理键可能会破坏数据库的理论纯粹性；它还可能要求我们手动指定列的唯一性或非空约束，这些约束在它们用作主键时是隐含的。有时，尽管如此，代理键的实用优势可能会超过这些担忧。您需要评估哪种选项最适合您的应用程序及其数据。
- en: 'One rule of thumb in making this determination is to consider whether the data
    you propose to use as a key **describes** or **defines** the item represented
    by the row. For example, a name does not define a person: a person can change
    their name and still be the same person. On the other hand, the plot checks stored
    in our CSV files are defined by the date, time, lab, and plot values. Change any
    one of those values and you are referring to a different plot check.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在做出这种决定的规则之一是考虑您打算用作键的数据是**描述**还是**定义**了由行表示的项目。例如，一个名字并不定义一个人：一个人可以更改他们的名字，但仍然是同一个人。另一方面，存储在我们
    CSV 文件中的检查图是由日期、时间、实验室和检查图值定义的。更改这些值中的任何一个，你就是在引用不同的检查图。
- en: Normalization
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 规范化
- en: The process of breaking out a flat data file into multiple tables is called
    **normalization**. The normalization process is broken into a series of levels
    called **normal forms**, which progressively remove duplication and create a more
    precise model of the data we're storing. Although there are many normal forms,
    most issues encountered in common business data can be handled by conforming to
    the first three.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 将平面数据文件分解成多个表的过程称为**规范化**。规范化过程被分解成一系列称为**范式**的级别，这些级别逐步消除重复并创建一个更精确的数据模型。尽管有许多范式，但大多数常见业务数据中遇到的问题都可以通过遵循前三个范式来解决。
- en: The purpose of conforming data to these forms is to eliminate the potential
    for redundant, conflicting, or undefined data situations. Let's briefly look at
    each of the first three normal forms, and what kind of issues it prevents.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据符合这些形式的目的在于消除冗余、冲突或未定义数据情况的可能性。让我们简要地看一下前三个范式，以及它们能防止哪些问题。
- en: First normal form
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第一范式
- en: 'The **first normal form** requires that each field contains only one value,
    and that repeating columns must be eliminated. For example, suppose we have a
    flat file that looks like this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**第一范式**要求每个字段只包含一个值，并且必须消除重复的列。例如，假设我们有一个看起来像这样的平面文件：'
- en: '| Fruit | Varieties |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| 水果 | 多种品种 |'
- en: '| Banana | Cavendish, Red, Apple |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| 香蕉 | 卡文迪什、红色、苹果 |'
- en: '| Orange | Navel, Valencia, Blood, Cara Cara |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| 橙子 | 柑橘、瓦伦西亚、血橙、卡拉卡拉 |'
- en: 'The `Varieties` field in this table has multiple values in a single column,
    so this table is not in the first normal form. We might try to fix it like so:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表中的`Varieties`字段在一个列中有多个值，所以这个表不在第一范式。我们可能会尝试这样修复它：
- en: '| Fruit | Variety_1 | Variety_2 | Variety_3 | Variety_4 |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| 水果 | 品种_1 | 品种_2 | 品种_3 | 品种_4 |'
- en: '| Banana | Cavendish | Red | Apple |  |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| 香蕉 | 卡文迪什 | 红色 | 苹果 |  |'
- en: '| Orange | Navel | Valencia | Blood | Cara Cara |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 橙子 | 柑橘、瓦伦西亚、血橙、卡拉卡拉 |'
- en: This is an improvement, but it's still not in the first normal form, because
    we have **repeating columns**. All of the `Variety_` columns represent the same
    attribute (the variety of fruit), but have been arbitrarily broken out into distinct
    columns. One way to tell if you have repeating columns is if the data is equally
    valid whether it goes in one column or the other; for example, `Cavendish` could
    just as well go in the `Variety_2`, `Variety_3`, or `Variety_4` columns.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种改进，但它仍然不在第一范式，因为我们有**重复的列**。所有的`Variety_`列代表相同的属性（水果的品种），但被任意地拆分成了不同的列。判断是否有重复列的一种方法是，如果数据无论放入哪一列都是同样有效的；例如，`Cavendish`可以同样地放入`Variety_2`、`Variety_3`或`Variety_4`列。
- en: 'Consider some of the problems with this format:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这种格式的一些问题：
- en: What would it mean if we had the same data in multiple `Variety` fields; for
    example, if the `Banana` row had `Cavendish` for `Variety_1` and `Variety_4`?
    Or what would it indicate for `Variety_1` to be blank, but `Variety_2` to have
    a value? These ambiguous situations are known as **anomalies** and can lead to
    conflicting or confusing data in the database.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们在多个`Variety`字段中有相同的数据意味着什么；例如，如果`Banana`行在`Variety_1`和`Variety_4`中都有`Cavendish`？或者如果`Variety_1`为空，但`Variety_2`有值，这会表明什么？这些模糊的情况被称为**异常**，可能导致数据库中的冲突或混淆数据。
- en: How complex would it be to query the table to see if two fruits share a variety
    name? We would have to check each `Variety_` field against every other `Variety_`
    field. What if we needed more than four varieties for a particular fruit? We would
    have to add columns, meaning our query would get exponentially more complex.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询这个表以查看两种水果是否共享一个品种名称会复杂到什么程度？我们必须检查每个`Variety_`字段与每个其他`Variety_`字段。如果我们需要为某种特定水果超过四种品种怎么办？我们就必须添加列，这意味着我们的查询将变得指数级复杂。
- en: 'To bring this table to the first normal form, we would need to create one `Fruit`
    and one `Variety` column, something like this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要将这个表提升到第一范式，我们需要创建一个`Fruit`列和一个`Variety`列，类似于这样：
- en: '| Fruit | Variety |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| 水果 | 品种 |'
- en: '| Banana | Cavendish |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| 香蕉 | 卡文迪什 |'
- en: '| Banana | Red |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| 香蕉 | 红色 |'
- en: '| Banana | Apple |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| 香蕉 | 苹果 |'
- en: '| Orange | Navel |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| 橙子 | 柑橘 |'
- en: '| Orange | Valencia |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| 橙子 | 瓦伦西亚 |'
- en: '| Orange | Blood |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| 橙子 | 血橙 |'
- en: '| Orange | Cara Cara |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| 橙子 | 卡拉卡拉 |'
- en: Note that this changes the nature of our table, as it's no longer one row per
    `Fruit`, but rather one row per `Fruit-Variety` combination. In other words, the
    primary key has changed from `Fruit` to `Fruit + Variety`. What if there are additional
    fields in the table that relate specifically to the `Fruit` type without respect
    to `Variety`? We'll address that as we look at the second normal form.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这改变了我们表的本质，因为它不再是每 `Fruit` 一行，而是每 `Fruit-Variety` 组合一行。换句话说，主键已从 `Fruit`
    变为 `Fruit + Variety`。如果表中还有其他与 `Fruit` 类型相关但与 `Variety` 无关的字段，我们将在查看第二范式时解决该问题。
- en: Second normal form
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第二范式
- en: 'The **second normal form** requires the first normal form, and additionally
    that *every value must be dependent on the entire primary key*. In other words,
    if a table has primary key fields A, B, and C, and the value of column X depends
    solely on the value of column A without respect to B or C, the table violates
    the second normal form. For example, suppose we added a `Classification` field
    to our table, like so:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**第二范式**要求满足第一范式，并且还要求每个值必须依赖于整个主键。换句话说，如果一个表有主键字段 A、B 和 C，并且列 X 的值仅依赖于列 A
    的值，而不考虑 B 或 C，则该表违反了第二范式。例如，假设我们向我们的表中添加了一个 `Classification` 字段，如下所示：'
- en: '| Fruit | Variety | Classification |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| 水果 | 品种 | 分类 |'
- en: '| Banana | Cavendish | Berry |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| 香蕉 | 卡文迪什 | 草莓 |'
- en: '| Banana | Red | Berry |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| 香蕉 | 红色 | 草莓 |'
- en: '| Orange | Navel | Citrus |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| 橙子 | 柑橘 | 柑橘 |'
- en: '| Orange | Valencia | Citrus |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| 橙子 | 瓜拉尼 | 柑橘 |'
- en: 'In this table, `Fruit` and `Variety` comprise the primary key of each row.
    `Classification` only depends on `Fruit`, though, since all bananas are berries,
    and all oranges are citrus. Consider the problems with this format:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个表中，`Fruit` 和 `Variety` 构成了每一行的主键。然而，`Classification` 只依赖于 `Fruit`，因为所有香蕉都是草莓，所有橙子都是柑橘。考虑这种格式的缺点：
- en: First, we have a data redundancy, since every `Fruit` type is going to have
    its `Classification` listed multiple times (once each time the `Fruit` value is
    repeated).
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们有一个数据冗余，因为每种 `Fruit` 类型都会多次列出其 `Classification`（每次 `Fruit` 值重复时都会列出一次）。
- en: The redundancy creates the potential for an anomaly where the same `Fruit` value
    has a different `Classification` value in different rows. This would make no sense.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种冗余可能导致异常，即相同的 `Fruit` 值在不同的行中有不同的 `Classification` 值。这是没有意义的。
- en: To address this, we'd need to break our table into two tables; one containing
    `Fruit` and `Classification`, with a primary key of `Fruit`, and one containing
    `Fruit` and `Variety`, with both fields comprising the primary key.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们需要将我们的表拆分为两个表；一个包含 `Fruit` 和 `Classification`，主键为 `Fruit`，另一个包含 `Fruit`
    和 `Variety`，这两个字段共同构成主键。
- en: Third normal form
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第三范式
- en: The **third normal form** requires the second normal form, and additionally
    that *every value in the table is dependent only on the primary key*. In other
    words, given a table with primary key A, and data fields X and Y, the value of
    Y can't depend on the value of X. It can only depend on A.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**第三范式**要求满足第二范式，并且还要求表中的每个值只依赖于主键。换句话说，给定一个主键为 A 的表，以及数据字段 X 和 Y，Y 的值不能依赖于
    X 的值，它只能依赖于 A。'
- en: 'For example, consider this table:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑这个表：
- en: '| Fruit | Leading Export Country | Leading Export Continent |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| 水果 | 主要出口国家 | 主要出口大陆 |'
- en: '| Banana | Ecuador | South America |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| 香蕉 | 厄瓜多尔 | 南美洲 |'
- en: '| Orange | Brazil | South America |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| 橙子 | 巴西 | 南美洲 |'
- en: '| Apples | China | Asia |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| 苹果 | 中国 | 亚洲 |'
- en: 'This table complies with the second normal form, because both columns are distinct
    to the primary key – each fruit can only have one leading export country, and
    one leading export continent. However, the `Leading Export Continent` value depends
    on the `Leading Export Country` value (a non-primary key field), because a country
    is on a continent without any respect to its fruit exports. The problems with
    this format are:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表符合第二范式，因为这两列都是相对于主键是唯一的——每种水果只能有一个主要的出口国家，以及一个主要的出口大陆。然而，`Leading Export
    Continent` 的值依赖于 `Leading Export Country` 的值（一个非主键字段），因为一个国家位于一个大陆，与其水果出口无关。这种格式的缺点是：
- en: There is data redundancy, as any country appearing multiple times would result
    in its continent appearing multiple times.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存在数据冗余，因为任何出现多次的国家都会导致其大陆出现多次。
- en: Once again, the redundancy creates the potential for an anomaly, where the same
    country could have two different continents listed. That makes no sense.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 再次，这种冗余可能导致异常，即同一个国家可能会列出两个不同的洲。这是没有意义的。
- en: To bring this to the third normal form, we would need to create a separate table
    of countries that could contain the continent column and any other column that
    depended on the country.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要将此转换为第三范式，我们需要创建一个包含大陆列和任何其他依赖于国家的列的单独的国家表。
- en: More normalization forms
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更多的规范化形式
- en: Database theorists propose other higher normalization forms that can help further
    eliminate ambiguities and redundancies in data, but for this book the first three
    should suffice to organize our data. Be aware that it is possible to **over-normalize**
    data for an application. Deciding what constitutes over-normalization really depends
    on the data and the users.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库理论家提出了其他更高的规范化形式，可以帮助进一步消除数据中的模糊性和冗余，但在这本书中，前三个应该足以组织我们的数据。请注意，对于某个应用来说，数据可能存在过度规范化的问题。决定什么构成过度规范化实际上取决于数据和用户。
- en: For example, if you have a contacts database that contains the columns `telephone_1`
    and `telephone_2`, the first normal form would dictate that you put telephone
    numbers in their own table to eliminate the repeating field. But if your users
    never need more than two fields, rarely use the second one, and never do complex
    queries on the data, it may not be worth complicating your database and application
    to conform to a theoretically pure model.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你有一个包含`telephone_1`和`telephone_2`列的联系人数据库，第一范式会规定你应该将电话号码放在它们自己的表中以消除重复字段。但如果你的用户不需要超过两个字段，很少使用第二个字段，并且永远不会对数据进行复杂查询，那么使数据库和应用复杂化以符合理论上的纯模型可能并不值得。
- en: Entity-relationship diagrams
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实体-关系图
- en: One effective way to help normalize our data and prepare it for a relational
    database is to create an **entity-relationship diagram**, or **ERD**. An ERD is
    a way of diagramming the things that our database is storing information about
    and the relationships between those things.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个有效的方法可以帮助我们规范化数据并为关系数据库做准备，那就是创建一个**实体-关系图**，或**ERD**。ERD是一种图表化我们数据库存储信息的事物及其之间关系的方式。
- en: Those "things" are called **entities**. An entity is a uniquely identifiable
    object; it corresponds to a single row of a single table. Entities have **attributes**,
    which correspond to the columns of a table. Entities also have **relationships**
    with other entities, which correspond to the foreign key relationships we define
    in SQL.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这些“事物”被称为**实体**。实体是一个唯一可识别的对象；它对应于单个表中的一行。实体有**属性**，它们对应于表中的列。实体还与其他实体有**关系**，这对应于我们在SQL中定义的外键关系。
- en: 'Let''s consider the entities in our lab scenario with their attributes and
    relationships:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑我们实验室场景中的实体及其属性和关系：
- en: There are **labs**. Each lab has a name.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有**实验室**。每个实验室都有一个名字。
- en: There are **plots**. Each plot belongs to a lab and has a number. A single seed
    sample is planted in each plot.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有**地块**。每个地块属于一个实验室，并有一个编号。每个地块中种植一个单独的种子样本。
- en: There are **lab technicians**, who each have a name.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有**实验室技术人员**，他们每个人都有一个名字。
- en: There are **lab checks**, which are performed by a lab tech at a given lab.
    Each lab check has a date and time.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有**实验室检查**，这些检查由实验室的技术人员在一个特定的实验室进行。每个实验室检查都有一个日期和时间。
- en: There are **plot checks**, which are the data gathered at a single plot during
    a lab check. Each plot check has various plant and environmental data recorded
    on it.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有**地块检查**，这是在实验室检查期间在单个地块上收集的数据。每个地块检查都记录了各种植物和环境数据。
- en: 'The following diagram shows these entities and their relationships:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图显示了这些实体及其关系：
- en: '![An Entity-relationship diagram of our ABQ data](img/B17578_12_01.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![我们ABQ数据的实体-关系图](img/B17578_12_01.png)'
- en: 'Figure 12.1: An entity-relationship diagram of our ABQ data'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1：我们ABQ数据的实体-关系图
- en: 'In this diagram, the entities are represented by rectangles. We have five entities:
    `Lab`, `Plot`, `Lab Tech`, `Lab Check`, and `Plot Check`. Each entity has attributes,
    represented by the ovals. The relationships between entities are represented by
    diamonds, with the words describing the left-to-right relationship. For example,
    a `Lab Tech` performs a `Lab Check`, and a `Lab Check` is performed in a `Lab`.
    Note the small *1* and *n* characters around the relationship: these show the
    **cardinality** of the relationship. There are three types of cardinality commonly
    seen in a database:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在此图中，实体由矩形表示。我们有五个实体：`Lab`、`Plot`、`Lab Tech`、`Lab Check` 和 `Plot Check`。每个实体都有属性，由椭圆形表示。实体之间的关系由菱形表示，其中的文字描述了从左到右的关系。例如，`Lab
    Tech` 执行 `Lab Check`，并且 `Lab Check` 在 `Lab` 中执行。注意关系周围的小 *1* 和 *n* 字符：这些显示了关系的**基数**。数据库中常见三种基数类型：
- en: A **one-to-many** (1 to n) relationship, where one row in the left table is
    related to many rows in the right table. For example, one `Lab Tech` performs
    many `Lab Checks`.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一对多**（1 到 n）的关系，其中左表中的一行与右表中的多行相关联。例如，一个 `Lab Tech` 执行多个 `Lab Checks`。'
- en: A **many-to-one** (n to 1) relationship, where many rows in the left table are
    related to the same row in the right. For example, multiple `Lab Checks` are performed
    in the same `Lab`.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多对一**（n 到 1）的关系，其中左表中的多行与右表中的同一行相关联。例如，在同一个“实验室”中执行多个“实验室检查”。'
- en: A **many-to-many** (n to n) relationship, where many rows in the left table
    are related to many rows in the right. For example, if we needed to update our
    database to allow more than one tech to work on the same lab check, then one lab
    tech would still perform many checks, but one check would have multiple techs
    (fortunately, we don't need to implement this!).
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多对多**（n 到 n）的关系，其中左表中的多行与右表中的多行相关联。例如，如果我们需要更新我们的数据库以允许一个以上的技术人员在同一实验室检查中工作，那么一个实验室技术人员仍然会执行多个检查，但一个检查会有多个技术人员（幸运的是，我们不需要实现这一点！）。'
- en: 'This diagram represents a reasonably normalized structure for our data. To
    implement it in SQL, we''d just make a table for each entity, a column for each
    attribute, and a foreign key relationship for each relationship. Before we can
    do that, though, let''s consider one more thing: SQL data types.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 此图表示了我们数据的一个合理规范结构。要在 SQL 中实现它，我们只需为每个实体创建一个表，为每个属性创建一个列，并为每个关系创建一个外键关系。但在我们这样做之前，让我们再考虑一件事：SQL
    数据类型。
- en: Assigning data types
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分配数据类型
- en: Standard SQL defines 16 data types, including types for integers and floating-point
    numbers of various sizes, ASCII or Unicode strings of either fixed or variable
    sizes, date and time types, and single-bit types. In addition to implementing
    standard types, nearly every SQL engine extends this list with yet more types
    to accommodate things like binary data, JSON data, currency values, network addresses,
    and other special types of strings or numbers. Many data types seem a little redundant,
    and several have aliases that may be different between implementations. Choosing
    data types for your columns can be surprisingly confusing!
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 标准SQL定义了16种数据类型，包括各种大小的整数和浮点数类型、固定或可变大小的ASCII或Unicode字符串类型、日期和时间类型以及单比特类型。除了实现标准类型外，几乎每个SQL引擎都通过添加更多类型来扩展此列表，以适应二进制数据、JSON数据、货币值、网络地址和其他特殊类型的字符串或数字。许多数据类型似乎有点冗余，并且有几个别名可能在实现之间不同。为您的列选择数据类型可能会令人惊讶地复杂！
- en: 'For PostgreSQL, the following chart provides some reasonable choices:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 PostgreSQL，以下图表提供了一些合理的选择：
- en: '| Data being stored | Recommended type | Notes |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| 存储的数据 | 推荐类型 | 备注 |'
- en: '| Fixed-length strings | `CHAR` | Requires a length, for example, `CHAR(256)`.
    |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| 固定长度字符串 | `CHAR` | 需要长度，例如，`CHAR(256)`。|'
- en: '| Short-to-medium strings | `VARCHAR` | Requires a max length argument, for
    example, `VARCHAR(256)`. |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| 短到中等长度的字符串 | `VARCHAR` | 需要一个最大长度参数，例如，`VARCHAR(256)`。|'
- en: '| Long, freeform text | `TEXT` | Unlimited length, slower performance. |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| 长文本，自由格式 | `TEXT` | 长度无限，性能较慢。|'
- en: '| Smaller integers | `SMALLINT` | Up to ±32,767. |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| 较小的整数 | `SMALLINT` | 范围为 ±32,767。|'
- en: '| Most integers | `INT` | Up to around ±2.1 billion. |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| 大多数整数 | `INT` | 大约 ±2.1 亿。|'
- en: '| Larger integers | `BIGINT` | Up to around ±922 quadrillion. |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| 较大的整数 | `BIGINT` | 大约 ±922 万亿。|'
- en: '| Decimal numbers | `NUMERIC` | Takes optional length and precision arguments.
    |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| 小数数字 | `NUMERIC` | 可选长度和精度参数。|'
- en: '| Integer primary key | `SERIAL, BIGSERIAL` | Auto-incrementing integers or
    big integers. |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| 整数主键 | `SERIAL, BIGSERIAL` | 自动递增的整数或大整数。|'
- en: '| Boolean | `BOOLEAN` | Can be TRUE, FALSE, or NULL. |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| 布尔值 | `BOOLEAN` | 可以是TRUE、FALSE或NULL。 |'
- en: '| Date and time | `TIMESTAMP WITH TIMEZONE` | Stores date, time, and timezone.
    Accurate to 1 µs. |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| 日期和时间 | `TIMESTAMP WITH TIMEZONE` | 存储日期、时间和时区。精确到1 µs。 |'
- en: '| Date without time | `DATE` | Stores date. |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| 日期无时间 | `DATE` | 存储日期。 |'
- en: '| Time without date | `TIME` | Can be with or without time zone. |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| 时间无日期 | `TIME` | 可以带或不带时区。 |'
- en: These types will probably meet the vast majority of your needs in most applications,
    and we'll be using a subset of these for our ABQ database. As we create our tables,
    we'll refer to our data dictionary and choose appropriate data types for our columns.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型可能满足大多数应用中的绝大多数需求，我们将使用这些类型的一个子集来构建我们的ABQ数据库。随着我们创建表格，我们将参考我们的数据字典，并为我们的列选择适当的数据类型。
- en: Be careful not to choose overly specific or restrictive data types. Any data
    can ultimately be stored in a `TEXT` field; the purpose of choosing more specific
    types is mainly to enable the use of operators, functions, or sorting specific
    to that type of data. If those aren't required, consider a more generic type.
    For example, phone numbers and U.S. social security numbers can be represented
    purely with digits, but that's no reason to make them `INTEGER` or `NUMERIC` fields;
    after all, you wouldn't do arithmetic with them!
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意不要选择过于具体或限制性的数据类型。任何数据最终都可以存储在`TEXT`字段中；选择更具体类型的目的是主要为了能够使用特定于该类型数据的运算符、函数或排序。如果那些不是必需的，考虑一个更通用的类型。例如，电话号码和美国社会保障号码可以用纯数字表示，但这并不是将它们做成`INTEGER`或`NUMERIC`字段的原因；毕竟，你不会对它们进行算术运算！
- en: Creating the ABQ database
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建ABQ数据库
- en: Now that we've modeled our data and gotten a feel for the data types available,
    it's time to build our database. Make sure you've installed PostgreSQL and created
    the `abq` database as described in the first section of this chapter, and let's
    begin writing SQL to create our database structure.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经建模了数据，并对可用的数据类型有了感觉，是时候构建我们的数据库了。确保你已经安装了PostgreSQL，并如本章第一部分所述创建了`abq`数据库，然后让我们开始编写SQL来创建我们的数据库结构。
- en: Under your project root folder, create a new directory called `sql`. Inside
    the `sql` folder, create a file called `create_db.sql`. We'll start writing our
    table definition queries in this file.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的项目根目录下，创建一个名为`sql`的新目录。在`sql`目录内，创建一个名为`create_db.sql`的文件。我们将从这里开始编写我们的表定义查询。
- en: Creating our tables
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建我们的表格
- en: The order in which we create our tables is significant. Any table referred to
    in a foreign key relationship will need to exist before the relationship is defined.
    Because of this, it's best to start with your lookup tables and follow the chain
    of one-to-many relationships until all the tables are created. In our ERD, that
    takes us from roughly the upper left to the lower right.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建表格的顺序很重要。任何在外键关系中引用的表格都必须在定义关系之前存在。因此，最好从你的查找表开始，沿着一对一关系的链条继续，直到所有表格都创建完成。在我们的ERD中，这从大致的左上角延伸到右下角。
- en: Creating the lookup tables
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建查找表
- en: 'We need to create the following three lookup tables:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建以下三个查找表：
- en: '`labs`: This lookup table will contain the ID strings for our laboratories.
    Since the names of the labs aren''t going to change, we''ll just use the single-letter
    names as the primary key values.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`labs`：这个查找表将包含我们实验室的ID字符串。由于实验室的名称不会改变，我们将只使用单字母名称作为主键值。'
- en: '`lab_techs`: This lookup table will have the names of the lab technicians.
    Since we don''t want to use employee names for primary keys, we''ll create a column
    for the employee ID number and use it for the primary key.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lab_techs`：这个查找表将包含实验室技术人员的姓名。由于我们不希望使用员工姓名作为主键，我们将创建一个员工ID号码的列，并使用它作为主键。'
- en: '`plots`: This lookup table will have one row for each physical plot, identified
    by lab and plot numbers. It will also keep track of the current seed sample planted
    in the plot.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`plots`：这个查找表将为每个物理地块创建一行，通过实验室和地块编号进行标识。它还将跟踪地块中种植的当前种子样本。'
- en: 'Add the SQL query for creating these tables to `create_db.sql`, as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 将创建这些表格的SQL查询添加到`create_db.sql`文件中，如下所示：
- en: '[PRE1]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Once created, the three tables look something like this:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建，这三个表格看起来可能像这样：
- en: '| lab_id |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| lab_id |'
- en: '| A |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| A |'
- en: '| B |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| B |'
- en: '| C |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| C |'
- en: The labs table
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 实验室表
- en: '| id | name |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| id | name |'
- en: '| 4291 | J Simms |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| 4291 | J Simms |'
- en: '| 4319 | P Taylor |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| 4319 | P Taylor |'
- en: The lab_techs table
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 实验室技术人员表
- en: '| lab_id | plot | current_seed_sample |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| lab_id | plot | current_seed_sample |'
- en: '| A | 1 | AXM477 |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| A | 1 | AXM477 |'
- en: '| A | 2 | AXM478 |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| A | 2 | AXM478 |'
- en: '| A | 3 | AXM479 |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| A | 3 | AXM479 |'
- en: The plots table
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 地块表
- en: While these tables may seem very simple, they will help enforce data integrity
    and make it simple to build an interface dynamically from the database. For example,
    since we'll be populating our `Labs` widget from the database, adding a new lab
    to the application is simply a matter of adding a row to the database.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些表可能看起来非常简单，但它们将有助于强制数据完整性，并使动态从数据库构建接口变得简单。例如，由于我们将从数据库中填充我们的 `Labs` 小部件，因此向应用程序添加一个新的实验室只是向数据库中添加一行的问题。
- en: The lab_checks table
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`lab_checks` 表'
- en: 'The rows of the `lab_checks` table each represent an instance of a technician
    checking all the plots of a lab at a given time on a given date. We will define
    it using the following SQL:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`lab_checks` 表的每一行代表一个技术人员在给定日期的特定时间检查实验室所有图表的一个实例。我们将使用以下 SQL 来定义它：'
- en: '[PRE2]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'When created and populated, the table will look like this:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建并填充时，表将看起来像这样：
- en: '| date | time | lab_id | lab_tech_id |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| 日期 | 时间 | 实验室 ID | 实验室技术人员 ID |'
- en: '| 2021-10-01 | 8:00 | A | 4291 |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| 2021-10-01 | 8:00 | A | 4291 |'
- en: The lab_checks table
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`lab_checks` 表'
- en: The `date`, `time`, and `lab_id` columns together uniquely identify a lab check,
    and so we designate them collectively as the primary key. The ID of the lab technician
    performing the check is the lone attribute in this table, and creates a foreign
    key relationship to the `lab_techs` table.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`date`、`time` 和 `lab_id` 列共同唯一地标识一个实验室检查，因此我们将它们共同指定为主键。进行检查的实验室技术人员的 ID 是这个表中的唯一属性，并创建与
    `lab_techs` 表的外键关系。'
- en: The plot_checks table
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`plot_checks` 表'
- en: Plot checks are the actual data records collected at individual plots. These
    each belong to a lab check, and so must refer back to an existing lab check using
    the three key values, `date`, `time`, and `lab_id`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图表检查是在各个图表收集的实际数据记录。这些每个都属于一个实验室检查，因此必须使用三个键值 `date`、`time` 和 `lab_id` 回指现有的实验室检查。
- en: 'We''ll begin with the primary key columns:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从主键列开始：
- en: '[PRE3]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `plot_checks` primary key is essentially the primary key of a `lab_check`
    table with the addition of a plot number; its key constraints look like this:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`plot_checks` 的主键基本上是 `lab_check` 表的主键，增加了图表编号；其键约束如下所示：'
- en: '[PRE4]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now that we''ve defined the key columns, we can add the attribute columns:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了主键列，我们可以添加属性列：
- en: '[PRE5]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When created and populated, the first several columns of the table look something
    like this:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建并填充时，表的最初几列看起来像这样：
- en: '| date | time | lab | plot | seed_sample | humidity | light | (etc...) |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| 日期 | 时间 | 实验室 | 图表 | 种子样本 | 湿度 | 光照 | （等等...）|'
- en: '| 2021-10-01 | 08:00:00 | A | 1 | AXM477 | 24.19 | 0.97 |  |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| 2021-10-01 | 08:00:00 | A | 1 | AXM477 | 24.19 | 0.97 |  |'
- en: '| 2021-10-01 | 08:00:00 | A | 2 | AXM478 | 23.62 | 1.03 |  |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| 2021-10-01 | 08:00:00 | A | 2 | AXM478 | 23.62 | 1.03 |  |'
- en: The plot_checks table
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`plot_checks` 表'
- en: Notice our use of data types and the `CHECK` constraint to duplicate the limits
    defined in the specification's data dictionary. Using these, we've leveraged the
    power of the database to safeguard against invalid data. This completes our table
    definitions for the ABQ database.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们使用数据类型和 `CHECK` 约束来复制规范的数据字典中定义的限制。使用这些，我们利用了数据库的强大功能来保护无效数据。这完成了我们对 ABQ
    数据库的表定义。
- en: Creating a view
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个视图
- en: Before we finish our database design, we're going to create a **view** that
    will simplify access to our data. A view behaves like a table in most respects,
    but contains no actual data; it's really just a stored `SELECT` query. We'll create
    a view called `data_record_view` to rearrange our data for easier interaction
    with the GUI.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成数据库设计之前，我们将创建一个 **视图**，这将简化我们数据的访问。视图在大多数方面表现得像一张表，但它不包含实际数据；它实际上只是一个存储的
    `SELECT` 查询。我们将创建一个名为 `data_record_view` 的视图，以重新排列我们的数据，以便更容易与 GUI 交互。
- en: 'Views are created using the `CREATE VIEW` command, which begins like this:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 视图是通过使用 `CREATE VIEW` 命令创建的，它开始如下：
- en: '[PRE6]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, inside the parentheses, we put the `SELECT` query that will return the
    table data we want in our view:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在括号内，我们放入将返回我们视图中所需表数据的 `SELECT` 查询：
- en: '[PRE7]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We're selecting the `plot_checks` table, and joining it to `lab_checks` and
    `lab_techs` by way of our foreign key relationships. Notice that we've aliased
    these tables by using the `AS` keyword. Short aliases like this can help make
    a large query more readable. We're also aliasing each field to the name used in
    the application's data structures. These must be enclosed in double quotes to
    allow for the use of spaces and to preserve casing. By making the column names
    match the data dictionary keys in our application, we won't need to translate
    field names in our application code.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在选择 `plot_checks` 表，并通过外键关系将其与 `lab_checks` 和 `lab_techs` 表连接。请注意，我们已使用 `AS`
    关键字对这些表进行了别名设置。这样的简短别名可以帮助使大型查询更易于阅读。我们还将每个字段别名为应用程序数据结构中使用的名称。这些名称必须用双引号括起来，以便使用空格并保留大小写。通过使列名与我们的应用程序中的数据字典键匹配，我们就不需要在应用程序代码中翻译字段名。
- en: 'The first several columns of the view look like this; compare this to the raw
    `plot_checks` table above:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 视图的前几列看起来像这样；将其与上面的原始 `plot_checks` 表进行比较：
- en: '| Date | Time | Technician | Lab | Plot | Seed Sample | Humidity | Light |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| 日期 | 时间 | 技术员 | 实验室 | 图表 | 种子样本 | 湿度 | 光照 |'
- en: '| 2021-10-01 | 8:00 | J Simms | A | 1 | AXM477 | 24.19 | 0.97 |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| 2021-10-01 | 8:00 | J Simms | A | 1 | AXM477 | 24.19 | 0.97 |'
- en: '| 2021-10-01 | 8:00 | J Simms | A | 2 | AXM478 | 23.62 | 1.03 |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| 2021-10-01 | 8:00 | J Simms | A | 2 | AXM478 | 23.62 | 1.03 |'
- en: SQL database engines such as PostgreSQL are highly efficient at joining and
    transforming tabular data. Whenever possible, leverage this power and make the
    database do the work of formatting the data for the convenience of your application.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: SQL 数据库引擎，如 PostgreSQL，在连接和转换表格数据方面非常高效。尽可能利用这种力量，让数据库为您的应用程序方便地格式化数据。
- en: 'This completes our database creation script. Run this script in your PostgreSQL
    client and verify that the four tables and the view have been created. To execute
    the script in pgAdmin, first open the **Query Tool** from **Tools** | **Query
    Tool**, then open the file by clicking the folder icon above the **Query Editor**
    window. Once the file is opened, click the play button icon to execute it. To
    run the script at the command line, execute the following at a terminal:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们的数据库创建脚本。在您的 PostgreSQL 客户端中运行此脚本，并验证是否已创建了四个表和视图。要在 pgAdmin 中执行脚本，首先从
    **工具** | **查询工具** 打开 **查询工具**，然后通过点击 **查询编辑器** 窗口上方的文件夹图标打开文件。文件打开后，点击播放按钮图标来执行它。要在命令行中运行脚本，请在终端执行以下命令：
- en: '[PRE8]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Populating the lookup tables
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 填充查找表
- en: 'Although the tables are all created, the lookup tables will need to be populated
    before we can use them; specifically:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然所有表都已创建，但在我们可以使用它们之前，查找表需要被填充；具体来说：
- en: '`labs` should have values `A` through `C`, representing the three labs.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`labs` 应该有 `A` 到 `C` 的值，代表三个实验室。'
- en: '`lab_techs` needs the name and ID number for our four lab technicians: J Simms
    (4291), P Taylor (4319), Q Murphy (4478), and L Taniff (5607).'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lab_techs` 需要我们四位实验室技术人员的姓名和 ID 号：J Simms（4291）、P Taylor（4319）、Q Murphy（4478）和
    L Taniff（5607）。'
- en: '`plots` needs all 60 of the plots, numbers 1 through 20 for each lab. The seed
    sample rotates between four values such as AXM477, AXM478, AXM479, and AXM480.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`plots` 需要所有 60 个图表，每个实验室的编号从 1 到 20。种子样本在四个值之间旋转，例如 AXM477、AXM478、AXM479 和
    AXM480。'
- en: You can populate these tables by hand using pgAdmin, or by using the `lookup_populate.sql`
    script included with the example code. Execute it just as you did the `create_db.sql`
    script.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 pgAdmin 手动填充这些表，或使用示例代码中包含的 `lookup_populate.sql` 脚本。就像执行 `create_db.sql`
    脚本一样执行它。
- en: Now our database is ready to use with the application. Let's get the application
    ready to work with the database!
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的数据库已准备好与应用程序一起使用。让我们让应用程序准备好与数据库一起工作！
- en: Connecting to PostgreSQL with psycopg2
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 psycopg2 连接到 PostgreSQL
- en: Now that we have a nice database to work with, how do we get our application
    to use it? To make SQL queries from our application, we'll need to install a Python
    library that can talk directly to our database. In Python, each different SQL
    product has one or more libraries available that can be used to integrate with
    it.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个很好的数据库可以与之一起使用，我们如何让我们的应用程序使用它？要从我们的应用程序中执行 SQL 查询，我们需要安装一个可以直接与我们的数据库通信的
    Python 库。在 Python 中，每个不同的 SQL 产品都有一到多个库可用于与之集成。
- en: For PostgreSQL, the most popular choice is `psycopg2`. The `psycopg2` library
    is not a part of the Python standard library, so you'll need to install it on
    any machine running your application. You can find the most current installation
    instructions at [http://initd.org/psycopg/docs/install.html](http://initd.org/psycopg/docs/install.html);
    however, the preferred method is to use `pip`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 对于PostgreSQL，最流行的选择是`psycopg2`。`psycopg2`库不是Python标准库的一部分，因此您需要在运行应用程序的任何机器上安装它。您可以在[http://initd.org/psycopg/docs/install.html](http://initd.org/psycopg/docs/install.html)找到最新的安装说明；然而，首选的方法是使用`pip`。
- en: 'For Windows, macOS, and Linux, the following command should work:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Windows、macOS和Linux，以下命令应该有效：
- en: '[PRE9]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If that doesn't work, or if you'd rather install it from the source, check the
    requirements on the website. Take note that the `psycopg2` library is written
    in C, not Python, so it requires a C compiler and a few other development packages
    to install from source.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这不起作用，或者您宁愿从源代码安装它，请检查网站上的要求。请注意，`psycopg2`库是用C语言编写的，而不是Python，因此需要C编译器和一些其他开发包才能从源代码安装。
- en: Linux users can usually install `psycopg2` from their distribution's package
    management system.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: Linux用户通常可以从其发行版的软件包管理系统中安装`psycopg2`。
- en: psycopg2 basics
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: psycopg2基础知识
- en: 'The essential workflow of using `psycopg2` is as follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`psycopg2`的基本工作流程如下：
- en: First, we create a `Connection` object using `psycopg2.connect()`. This object
    represents our connection to the database engine and is used to manage our login
    session.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们使用`psycopg2.connect()`创建一个`Connection`对象。此对象代表我们与数据库引擎的连接，并用于管理我们的登录会话。
- en: Next, we create a `Cursor` object from our connection using the `Connection`
    object's `cursor()` method. A **cursor** is our point of interaction with the
    database engine.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用`Connection`对象的`cursor()`方法从我们的连接中创建一个`Cursor`对象。**游标**是我们与数据库引擎交互的点。
- en: We can run queries by passing SQL strings to the cursor's `execute()` method.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过将SQL字符串传递给游标的`execute()`方法来运行查询。
- en: If our queries return data, we can retrieve the data using the cursor's `fetchone()`
    or `fetchall()` methods.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们的查询返回数据，我们可以使用游标的`fetchone()`或`fetchall()`方法检索数据。
- en: 'The following script demonstrates the basic use of `psycopg2`:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 以下脚本演示了`psycopg2`的基本用法：
- en: '[PRE10]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We begin by importing `psycopg2` and aliasing it to `pg` for brevity's sake;
    we also import `getpass` for prompting the user for a password. Next, we generate
    a connection object, `cx`, using the `connect()` function, passing in all the
    details required to locate the database server and authenticate to it. These details
    include the host name of the server, the name of the database, and the authentication
    credentials. The `host` argument can be the server name, IP address, or fully
    qualified domain name of the system running the PostgreSQL server. Since we're
    running PostgreSQL on our local system, we've used `localhost` here, which points
    back to our local system.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入`psycopg2`并将其别名为`pg`以简化；我们还导入了`getpass`以提示用户输入密码。接下来，我们使用`connect()`函数生成一个连接对象`cx`，传递所有必要的详细信息以定位数据库服务器并对其进行身份验证。这些详细信息包括服务器的主机名、数据库名称和身份验证凭证。`host`参数可以是运行PostgreSQL服务器的服务器名称、IP地址或完全限定的域名。由于我们在本地系统上运行PostgreSQL，所以我们在这里使用了`localhost`，它指向我们的本地系统。
- en: From the connection, we create a cursor object, `cur`. Finally, we've used the
    cursor's `execute()` method to execute two SQL queries.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 从连接中，我们创建一个游标对象`cur`。最后，我们使用了游标的`execute()`方法来执行两个SQL查询。
- en: 'Now let''s retrieve some data from the database, like so:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们从数据库中检索一些数据，如下所示：
- en: '[PRE11]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You might expect that the data retrieved from the query is found in the return
    value of `execute()`; however, that's not how it works. Instead, we execute the
    query, then use cursor methods and attributes to retrieve the data and the metadata
    about the execution. In this case, we've used `fetchall()` to retrieve all the
    rows of data at once. We have also used the `rowcount` attribute of the cursor
    to see how many rows were returned from the database.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能期望从查询中检索到的数据在`execute()`的返回值中找到；然而，情况并非如此。相反，我们执行查询，然后使用游标的方法和属性来检索数据和执行的相关元数据。在这种情况下，我们使用了`fetchall()`一次性检索所有数据行。我们还使用了游标的`rowcount`属性来查看从数据库返回了多少行。
- en: 'PostgreSQL is a **transactional database**, meaning that modification operations
    (like our `CREATE` and `INSERT` statements) are not automatically saved to disk.
    To do that, we need to **commit** our transaction. We can do this in `psycopg2`
    using the connection object''s `commit()` method, like so:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: PostgreSQL 是一个 **事务型数据库**，这意味着修改操作（如我们的 `CREATE` 和 `INSERT` 语句）不会自动保存到磁盘。为了做到这一点，我们需要
    **提交** 事务。在 `psycopg2` 中，我们可以使用连接对象的 `commit()` 方法来完成，如下所示：
- en: '[PRE12]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If we do not commit, the changes we make will not be saved when our connection
    exits. The connection will exit automatically when our application or script quits,
    but we can also explicitly exit using the connection''s `close()` method, like
    this:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不提交，我们在连接退出时所做的更改将不会被保存。当我们的应用程序或脚本退出时，连接会自动退出，但我们可以使用连接的 `close()` 方法显式退出，如下所示：
- en: '[PRE13]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You can specify `autocommit=True` when creating a `Connection` object to have
    `psycopg2` implicitly commit the transaction after every query. This is a handy
    convenience, especially when working with PostgreSQL in the shell.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建 `Connection` 对象时，您可以指定 `autocommit=True`，这样 `psycopg2` 就会在每次查询后隐式提交事务。这是一个方便的便利功能，尤其是在使用
    shell 中的 PostgreSQL 时。
- en: Parameterized queries
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参数化查询
- en: 'Quite often, we need to include runtime data, such as that entered by our users,
    in a SQL query. You might be tempted to do this using Python''s powerful string-formatting
    capabilities, like this:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 很常见的情况是我们需要在 SQL 查询中包含运行时数据，例如用户输入的数据。您可能会倾向于使用 Python 强大的字符串格式化功能来完成此操作，如下所示：
- en: '[PRE14]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Never, never do this!* While it initially works, it creates a vulnerability
    known as a **SQL injection vulnerability**. In other words, it will allow a user
    of the program to enter any SQL command they wish. For example, we could execute
    our script and add malicious data like this:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '*绝对不要这样做!* 虽然一开始可能有效，但它会创建一个称为 **SQL 注入漏洞** 的漏洞。换句话说，它将允许程序的用户输入他们想要的任何 SQL
    命令。例如，我们可以执行脚本并添加如下恶意数据：'
- en: '[PRE15]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this example, we've executed the program and entered a string that closes
    our coded SQL statement and adds on a `DROP TABLE` statement. It then adds a partial
    `SELECT` statement to avoid a syntax error from the SQL engine. The result is
    that the `test` table is deleted, and we get an exception trying to query data
    from it!
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们执行了程序并输入了一个字符串，该字符串关闭了我们的编码 SQL 语句并添加了一个 `DROP TABLE` 语句。然后它添加了一个部分
    `SELECT` 语句以避免 SQL 引擎的语法错误。结果是 `test` 表被删除，当我们尝试从它查询数据时出现异常！
- en: 'SQL injection vulnerabilities have plagued applications for decades and been
    the source of many high-profile hacking disasters. Fortunately, `psycopg2` gives
    us a way to avoid this by using **parameterized queries**. A parameterized version
    of the previous code looks like this:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: SQL 注入漏洞已经困扰应用程序数十年，并成为许多高调黑客灾难的源头。幸运的是，`psycopg2` 通过使用 **参数化查询** 给我们提供了避免这种情况的方法。前面代码的参数化版本如下所示：
- en: '[PRE16]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: To parameterize a query, we use the `%s` string to stand in for values we want
    to be inserted into the query. The values themselves are passed into `execute()`
    as a second argument. For multiple values, the parameter values should be passed
    in as a list or tuple, and will replace the `%s` occurrences in order.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 要参数化一个查询，我们使用 `%s` 字符串来代替我们想要插入查询中的值。这些值本身作为 `execute()` 方法的第二个参数传入。对于多个值，参数值应该作为列表或元组传入，并将按顺序替换
    `%s` 出现的位置。
- en: 'For complicated queries, we can also give each parameter a name, and pass in
    a dictionary to match up the values; for example:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 对于复杂的查询，我们还可以给每个参数一个名称，并传入一个字典来匹配值；例如：
- en: '[PRE17]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The parameter's name is put in parentheses between the percent sign and `s`
    character. The name will then be matched to a key in the parameters value dictionary
    and substituted when the query is executed by the database.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 参数的名称放在百分号和 `s` 字符之间的括号中。名称将与参数值字典中的键匹配，并在数据库执行查询时进行替换。
- en: The `s` in this parameter string is called a **format specifier**, and derives
    from the original Python syntax for string substitution. It is required and should
    *always* be `s`. If your parameterized query causes an Invalid Format Specifier
    error, it's because you have forgotten the `s` or used a different character.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这个参数字符串中的 `s` 被称为 **格式说明符**，它源自 Python 的原始字符串替换语法。它是必需的，并且应该 *始终* 是 `s`。如果您参数化的查询导致无效格式说明符错误，那是因为您忘记了
    `s` 或使用了不同的字符。
- en: 'Parameterized queries take care of properly escaping and sanitizing our data
    so that SQL injection attacks are largely impossible. For example, if we try our
    previous hack with the parameterized code, we get the following:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 参数化查询负责正确转义和清理我们的数据，从而使得 SQL 注入攻击几乎不可能。例如，如果我们尝试使用参数化代码的先前黑客攻击，我们会得到以下结果：
- en: '[PRE18]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Not only do parameterized queries protect us from SQL injection, but they also
    perform automatic conversion of certain Python types to SQL values; for example,
    Python `date` and `datetime` objects are automatically converted to strings that
    SQL will recognize as dates, and `None` is automatically converted to SQL `NULL`.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅参数化查询可以保护我们免受 SQL 注入攻击，而且它们还会自动将某些 Python 类型转换为 SQL 值；例如，Python `date` 和 `datetime`
    对象会自动转换为 SQL 识别为日期的字符串，而 `None` 会自动转换为 SQL `NULL`。
- en: Note that parameters only work for *data values*; there is no way to parameterize
    other query content like table names or commands.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，参数仅适用于 *数据值*；没有方法可以对其他查询内容进行参数化，如表名或命令。
- en: Special cursor classes
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特殊游标类
- en: By default, `Cursor.fetchall()` returns our query results as a list of tuples.
    This might be acceptable if we have a table of one or two columns, but for large
    tables like those in our ABQ database, it quickly becomes a problem remembering
    which tuple index corresponds to which field. Ideally, we'd like to be able to
    reference a field by name.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`Cursor.fetchall()` 将我们的查询结果作为元组的列表返回。如果我们有一个一列或两列的表，这可能是可以接受的，但对于像我们的
    ABQ 数据库中的大表，很快就会变成一个问题，即记住哪个元组索引对应哪个字段。理想情况下，我们希望能够通过名称引用字段。
- en: 'To accommodate this, `psycopg2` allows us to specify a **cursor factory** class
    for our connection object that allows us to use cursor objects with customized
    behavior. One such custom cursor class included with `psycop2` is the `DictCursor`
    class. We use it like so:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 为了适应这一点，`psycopg2` 允许我们为我们的连接对象指定一个 **游标工厂** 类，允许我们使用具有自定义行为的游标对象。`psycopg2`
    中包含的一个这样的自定义游标类是 `DictCursor` 类。我们这样使用它：
- en: '[PRE19]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`DictCursor` is found in the `psycopg2.extras` module, so we have to import
    it separately from the main module. Once imported, we pass it to the `connect()`
    function''s `cursor_factory` argument. Now, rows will be returned as `DictRow`
    objects, which can be treated just like dictionaries:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '`DictCursor` 在 `psycopg2.extras` 模块中找到，因此我们必须从主模块单独导入它。一旦导入，我们将它传递给 `connect()`
    函数的 `cursor_factory` 参数。现在，行将以 `DictRow` 对象的形式返回，可以像字典一样处理：'
- en: '[PRE20]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This is much handier when dealing with a large number of columns.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理大量列时，这要方便得多。
- en: More information about the use of `psycopg2` can be found in its official documentation
    at [https://www.psycopg.org/docs/](https://www.psycopg.org/docs/).
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `psycopg2` 的更多信息可以在其官方文档中找到：[https://www.psycopg.org/docs/](https://www.psycopg.org/docs/)。
- en: Integrating SQL into our application
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 SQL 集成到我们的应用程序中
- en: Converting our application to a SQL backend will be no small task. The application
    was built around the assumption of the CSV files, and although we've taken care
    to separate our concerns, many things are going to need to change.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的应用程序转换为 SQL 后端将是一项艰巨的任务。应用程序是围绕 CSV 文件假设构建的，尽管我们已经尽力分离关注点，但许多事情都需要改变。
- en: 'Let''s break down the steps we''ll need to take:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解我们需要采取的步骤：
- en: We'll need to create a new model to interface with the SQL database.
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要创建一个新的模型来与 SQL 数据库进行接口。
- en: Our `Application` class will need to use the SQL model, and may need to adjust
    some behaviors as a result.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的 `Application` 类将需要使用 SQL 模型，并且可能需要根据结果调整一些行为。
- en: The record form will need to be reordered to prioritize our key fields, use
    the new lookup tables, and auto-populate using information in the database.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录表单需要重新排序以优先考虑我们的关键字段，使用新的查找表，并使用数据库中的信息自动填充。
- en: The record list will need to be adjusted to work with the new data model and
    primary keys.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录列表需要调整以与新数据模型和主键一起工作。
- en: Let's get started!
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Creating a new model
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个新的模型
- en: 'We''ll start in `models.py` by importing `psycopg2` and `DictCursor`:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 `models.py` 中开始导入 `psycopg2` 和 `DictCursor`：
- en: '[PRE21]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As you learned in the previous section, `DictCursor` will allow us to fetch
    results in a Python dictionary rather than the default tuples, which is easier
    to work with in our application.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一小节所学，`DictCursor` 允许我们以 Python 字典而不是默认的元组形式获取结果，这在我们应用程序中更容易处理。
- en: 'Now, begin a new model class called `SQLModel` and copy over the `fields` property
    from the `CSVModel`, like so:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，开始一个新的模型类 `SQLModel`，并像这样复制 `CSVModel` 的 `fields` 属性：
- en: '[PRE22]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We need to make a few changes to this dictionary, however. First, our valid
    Lab and Plot values are going to be pulled from the database rather than being
    hardcoded here, so we'll specify them as empty lists and populate them in the
    initializer. Also, the Technician field will become a drop-down select, also populated
    from the database, so we need to make it a `string_list` type with an empty list
    for the `values` argument.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们需要对这个字典做一些修改。首先，我们的有效实验室和绘图值将从数据库中提取，而不是在这里硬编码，所以我们将它们指定为空列表，并在初始化器中填充它们。此外，技术人员字段将变成一个下拉选择，也由数据库填充，所以我们需要将其类型改为
    `string_list`，并将 `values` 参数的列表留空。
- en: 'Those three entries should look like this:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个条目应该看起来像这样：
- en: '[PRE23]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Before we write our initializer, let''s create a method to encapsulate a lot
    of the boilerplate code around querying and retrieving data. We''ll call this
    method `query()`; add it to the `SQLModel` class like so:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们编写初始化器之前，让我们创建一个方法来封装查询和检索数据周围的许多样板代码。我们将把这个方法命名为 `query()`；像这样将其添加到 `SQLModel`
    类中：
- en: '[PRE24]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This method takes a query string and, optionally, a sequence of parameters.
    Inside the method, we begin by opening a context block using the `Connection`
    object. Using the connection this way means that `psycopg2` will automatically
    commit the transaction if the query is successful. Next, we generate our `Cursor`
    object, also using a context manager. By using the cursor as a context manager,
    `psycopg2` will automatically **roll back** our transaction if an exception is
    thrown by the `execute()` method. Rolling back is the opposite of committing the
    database: instead of saving the changes, we throw them away and start with the
    database as it was the last time we committed (or the beginning of the session,
    if we haven''t called `commit()` yet). After rolling back, the exception will
    be re-raised so that we can handle it in our calling code, and, in either case,
    the cursor will be closed when the block exits. Essentially, it''s equivalent
    to the following:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法接受一个查询字符串，以及可选的参数序列。在方法内部，我们首先使用 `Connection` 对象打开一个上下文块。以这种方式使用连接意味着如果查询成功，`psycopg2`
    将自动提交事务。接下来，我们生成我们的 `Cursor` 对象，也使用上下文管理器。通过将游标用作上下文管理器，如果 `execute()` 方法抛出异常，`psycopg2`
    将自动 **回滚** 我们的事务。回滚是提交数据库的相反：不是保存更改，而是丢弃它们，并从上次提交（或会话的开始，如果我们还没有调用 `commit()`）时的数据库状态开始。回滚后，异常将被重新抛出，以便我们可以在调用代码中处理它，并且，在任何情况下，当块退出时，游标都将关闭。本质上，它等同于以下内容：
- en: '[PRE25]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If we successfully execute the query and it returns data, the method will need
    to return that data. To determine if data was returned, we check the cursor.`description`
    property. The `cursor.description` property returns a list of the headers for
    the table returned by our query; in the event that our query returns no data (such
    as an `INSERT` query), it is set to `None`. It's important to realize that `fetchall()`
    will raise an exception if there is no data returned from the query, so we should
    check `description` before executing it.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们成功执行查询并且它返回数据，该方法需要返回这些数据。为了确定是否返回了数据，我们检查 `cursor.description` 属性。`cursor.description`
    属性返回由我们的查询返回的表的标题列表；如果我们的查询没有返回数据（例如 `INSERT` 查询），它被设置为 `None`。重要的是要意识到，如果没有从查询返回数据，`fetchall()`
    将引发异常，所以我们应该在执行之前检查 `description`。
- en: 'Now that we have this method, we can easily retrieve results from our database
    like so:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了这个方法，我们可以轻松地从数据库中检索结果，如下所示：
- en: '[PRE26]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To see how we can use the query method, let''s go ahead and add an initializer
    method to this class:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解我们如何使用查询方法，让我们先给这个类添加一个初始化器方法：
- en: '[PRE27]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `__init__()` method takes the database connection details and establishes
    a connection to the database using `psycopg2.connect()`, setting the `cursor_factory`
    to `DictCursor`. Then, we use our new `query()` method to query the database for
    the pertinent columns in our three lookup tables, using a list comprehension to
    flatten the results of each query for the respective `values` list.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init__()` 方法接受数据库连接详情，并使用 `psycopg2.connect()` 建立数据库连接，将 `cursor_factory`
    设置为 `DictCursor`。然后，我们使用我们新的 `query()` 方法查询数据库，获取我们三个查找表中的相关列，使用列表推导来简化每个查询的结果，以形成相应的
    `values` 列表。'
- en: 'Next, we need to write the methods that the application calls to retrieve data
    from the model. We''ll start with `get_all_records()`, which looks like this:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要编写应用程序调用来从模型检索数据的那些方法。我们将从 `get_all_records()` 开始，它看起来像这样：
- en: '[PRE28]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Since our users are used to working with only the current day's data, we'll
    only show that data by default, but add an optional flag should we ever need to
    retrieve all data for all time. To retrieve the current date in PostgreSQL, we
    can use the `CURRENT_DATE` constant, which always holds the current date according
    to the server. Note that we use a prepared query to pass the `all_dates` value
    to the query.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的用户习惯于只处理当前天的数据，我们默认只显示这些数据，但添加一个可选标志，以便我们将来需要检索所有时间的数据。要在PostgreSQL中检索当前日期，我们可以使用`CURRENT_DATE`常量，该常量始终根据服务器持有当前日期。请注意，我们使用预定义查询将`all_dates`值传递到查询中。
- en: 'Next, let''s create `get_record()`:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建`get_record()`：
- en: '[PRE29]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This method represents a change in interface from the `CSVModel` class. We're
    no longer dealing in row numbers; instead, rows are identified by their primary
    key values. In the case of our records (that is, plot checks), we need Date, Time,
    Lab, and Plot to identify a record. For convenience, we'll be passing this value
    around as a tuple in the format (`date`, `time`, `lab`, `plot`). Thus, the first
    thing our method does is extract the `rowkey` tuple into those four values.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法代表了从`CSVModel`类界面上的一个变化。我们不再处理行号；相反，行由其主键值来标识。在我们的记录（即绘图检查）的情况下，我们需要日期、时间、实验室和绘图来标识一个记录。为了方便，我们将以（`日期`，`时间`，`实验室`，`绘图`）的格式将此值作为元组传递。因此，我们的方法首先将`rowkey`元组提取到这四个值中。
- en: Once we have these values, we can use a prepared query to retrieve all the record
    data from the view we created. Keep in mind that, even when the query results
    are a single row, the `query()` method is going to return the results in a list.
    However, our application expects a single dictionary of data from `get_record()`,
    so our `return` statement extracts the first item in `result` if the list is not
    empty, or an empty dictionary if it is.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了这些值，我们可以使用预定义查询从我们创建的视图中检索所有记录数据。请注意，即使查询结果是一行，`query()`方法也将结果作为列表返回。然而，我们的应用程序期望从`get_record()`获取单个数据字典，因此我们的`return`语句在列表不为空时提取`result`中的第一个项目，如果为空，则返回空字典。
- en: 'Retrieving a lab check record is very similar:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 获取实验室检查记录非常相似：
- en: '[PRE30]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In this query, we're using a join to make sure we have the technician name available
    and not just the ID. This method did not exist in `CSVModel`, because we had not
    yet normalized the data; but it will come in handy in our `save_record()` method
    and in our form automation methods.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在此查询中，我们使用连接来确保我们有技术人员名称而不是仅ID。此方法在`CSVModel`中不存在，因为我们尚未规范化数据；但它将在我们的`save_record()`方法和我们的表单自动化方法中派上用场。
- en: Saving data
  id: totrans-319
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 保存数据
- en: 'Saving data in our SQL model is a little more complex than the CSV, since each
    data record is represented by rows in two different tables: the `lab_checks` and
    the `plot_checks` tables. When we try to save a record, there are three possibilities
    that we need to account for:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的SQL模型中保存数据比CSV复杂一些，因为每个数据记录由两个不同的表中的行表示：`lab_checks`和`plot_checks`表。当我们尝试保存记录时，我们需要考虑三种可能性：
- en: Neither a lab check nor a plot check record exists for the given date, time,
    lab, and plot. In this case, both the lab check and plot check records will need
    to be created.
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于给定的日期、时间、实验室和绘图，既没有实验室检查记录也没有绘图检查记录。在这种情况下，需要创建实验室检查和绘图检查记录。
- en: The lab check exists for the given date, time, and lab, but no corresponding
    plot check exists for the given plot. In this case, the lab check record will
    need to be updated (in case the user wants to correct the technician value), and
    the plot check record will need to be added.
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于给定的日期、时间和实验室，实验室检查存在，但对于给定的绘图，没有相应的绘图检查存在。在这种情况下，需要更新实验室检查记录（以防用户想要更正技术人员值），并且需要添加绘图检查记录。
- en: Both the lab check and plot check exist. In this case, both will need to be
    updated with the submitted non-primary key values.
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实验室检查和绘图检查都存在。在这种情况下，都需要使用提交的非主键值进行更新。
- en: The `save_record()` method we implement will need to check for these conditions
    and run the appropriate `INSERT` or `UPDATE` queries on each table.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现的`save_record()`方法需要检查这些条件，并对每个表运行适当的`INSERT`或`UPDATE`查询。
- en: 'We also need to consider the possibility that a user will update one of the
    primary key fields when editing an existing record. What should the model do in
    this case? Let''s consider:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要考虑用户在编辑现有记录时更新主键字段的可能性。在这种情况下，模型应该做什么？让我们考虑：
- en: From the user's point of view, each record they fill out in the application
    corresponds to a plot check.
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从用户的角度来看，他们在应用程序中填写的每一条记录都对应一个图表检查。
- en: A plot check is associated with a lab check on the basis of its date, time,
    and lab.
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图表检查基于其日期、时间和实验室与实验室检查相关联。
- en: Thus, if a user alters one of those key fields, their intention is most likely
    to associate the plot check record with a different lab check, rather than to
    alter the lab check record it is already associated with.
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此，如果用户更改了这些关键字段之一，他们最有可能的意图是将图表检查记录与不同的实验室检查相关联，而不是更改它已经关联的实验室检查记录。
- en: Since, from a GUI standpoint, the user is updating an existing record rather
    than adding a new one, though, it makes sense to update the plot check identified
    by the pre-change date, time, lab, and plot values with the newly entered values
    for those fields.
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于从GUI的角度来看，用户正在更新现有记录而不是添加新记录，因此，更新由更改前的日期、时间、实验室和图表值标识的图表检查，并用新输入的字段值更新这些字段是有意义的。
- en: Therefore, when we're determining whether to run our `INSERT` or `UPDATE` queries,
    we should determine this based on the *entered data* for the lab check, but the
    *key data* for the plot check.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们确定是否运行`INSERT`或`UPDATE`查询时，我们应该根据实验室检查的*输入数据*来决定，但对于图表检查的*关键数据*。
- en: Let's begin implementing this logic by writing our queries, which we will store
    in class variables to keep our `save_record()` method more concise.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过编写我们的查询来实现这个逻辑，我们将把这些查询存储在类变量中，以使`save_record()`方法更加简洁。
- en: 'We''ll start with the lab check queries:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始编写实验室检查查询：
- en: '[PRE31]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: These queries are fairly straightforward, though note our use of a subquery
    to populate `lab_tech_id` in each case. Our application will have no idea what
    a lab tech's ID is, so we'll need to look the ID up by name. Also, take note that
    our parameter names match the names used in our model's `fields` dictionary. This
    will save us from having to reformat the record data acquired from our form.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 这些查询相当直接，但请注意我们在每种情况下都使用了子查询来填充`lab_tech_id`。我们的应用程序将不知道实验室技术人员的ID是什么，因此我们需要通过名称查找ID。此外，请注意我们的参数名称与模型`fields`字典中使用的名称相匹配。这将使我们免于重新格式化从表单获取的记录数据。
- en: 'The plot check queries are longer but not any more complicated:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 图表检查查询更长，但并不更复杂：
- en: '[PRE32]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note that the parameter names used in the `UPDATE` query's `WHERE` clause are
    prefixed with `key_`; this will allow us to update the record identified by the
    date, time, lab, and plot values from the row key, as explained previously.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在`UPDATE`查询的`WHERE`子句中使用的参数名称以`key_`为前缀；这将允许我们根据行键中的日期、时间、实验室和图表值更新由这些值标识的记录，如前所述。
- en: 'With the queries in place, we can start writing the `save_record()` method:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 查询就绪后，我们可以开始编写`save_record()`方法：
- en: '[PRE33]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `CSVModel.save_record()` method took a record dictionary and an integer
    value, `rownum`, to determine which record would be updated (or `None` if it was
    a new record). In our database, we're using a compound key to identify a plot
    check, which we'll expect as a tuple of the date, time, lab, and plot. Therefore,
    if a `rowkey` is passed in, we'll extract its values to variables and add them
    to the record dictionary so that we can pass them to the queries.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '`CSVModel.save_record()`方法接受一个记录字典和一个整数值`rownum`，以确定哪个记录将被更新（如果是新记录，则为`None`）。在我们的数据库中，我们使用复合键来标识图表检查，我们期望它是一个包含日期、时间、实验室和图表的元组。因此，如果传递了`rowkey`，我们将提取其值并将其添加到记录字典中，以便我们可以将它们传递给查询。'
- en: 'Next, we need to determine what kind of query to run for the lab check table:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要确定对实验室检查表运行哪种查询：
- en: '[PRE34]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: If there is an existing lab check record with the entered date, time, and lab,
    we'll just update it (which will really just change the technician value to what
    was entered). If there is not, we'll create one.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在具有输入日期、时间和实验室的现有实验室检查记录，我们将只更新它（这实际上只是将技术人员值更改为输入的值）。如果没有，我们将创建一个新记录。
- en: 'Next, let''s determine which plot check operation to do:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们确定要执行哪种图表检查操作：
- en: '[PRE35]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This time we only need to know if a row key tuple was given to the method. If
    it was, this should be an existing record and we just want to update it. If not,
    we'll need to insert a new record.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们只需要知道是否给方法提供了一个行键元组。如果是，这应该是一个现有记录，我们只想更新它。如果不是，我们需要插入一个新的记录。
- en: 'Now, we finish off the method by just running the two queries, passing in the
    `record` dictionary as the parameter list:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需运行两个查询来完成方法，将`record`字典作为参数列表传递：
- en: '[PRE36]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Note that `psycopg2` has no problem with us passing a dictionary with extra
    parameters that aren't referenced in the query, so we don't need to bother with
    filtering unneeded items from `record`.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`psycopg2`没有问题，我们可以传递一个包含未在查询中引用的额外参数的字典，所以我们不需要从`record`中过滤掉不需要的项目。
- en: Getting the current seed sample for the plot
  id: totrans-350
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取图的当前种子样本
- en: There is one last method this model needs; since our database knows what seed
    sample is currently in each plot, we want our form to populate this automatically
    for the user. We'll need a method that takes a `lab` and `plot_id` and returns
    the seed sample name.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 此模型还需要一个最后的方法；由于我们的数据库知道每个图中的当前种子样本是什么，我们希望我们的表单能够自动为用户填充这个信息。我们需要一个方法，它接受`lab`和`plot_id`作为参数，并返回种子样本名称。
- en: 'We''ll call it `get_current_seed_sample()`:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将其命名为`get_current_seed_sample()`：
- en: '[PRE37]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This time, our `return` statement is not just extracting the first row of results,
    but the value of the `current_seed_sample` column from that first row. If there's
    no result, we return an empty string.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们的`return`语句不仅仅是提取结果的第一行，而是从第一行中提取`current_seed_sample`列的值。如果没有结果，我们返回一个空字符串。
- en: That completes our model class; now let's incorporate it into the application.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了我们的模型类；现在让我们将其集成到应用程序中。
- en: Adjusting the Application class for the SQL backend
  id: totrans-356
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调整Application类以支持SQL后端
- en: 'Before it can create a `SQLModel` instance, the `Application` class will need
    the database connection information to pass to the model: the server name, database
    name, user, and password. The host and database names aren''t going to change
    often, if at all, so we don''t need to make the user enter those each time. Instead,
    we can just add them as settings in the `SettingsModel`:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建`SQLModel`实例之前，`Application`类需要数据库连接信息以传递给模型：服务器名称、数据库名称、用户名和密码。服务器名称和数据库名称不太可能经常更改，所以用户不需要每次都输入这些信息。相反，我们只需将它们添加为`SettingsModel`中的设置：
- en: '[PRE38]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: These can be saved in our JSON config file, which can be edited to switch from
    development to production, but the username and password used for authentication
    will need to be entered by the user. For that, we can use our login dialog.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 这些可以保存在我们的JSON配置文件中，该文件可以编辑以从开发模式切换到生产模式，但用于身份验证的用户名和密码需要用户输入。为此，我们可以使用我们的登录对话框。
- en: Implementing SQL logins
  id: totrans-360
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现SQL登录
- en: 'The login dialog currently authenticates using hardcoded credentials in the
    `Application._simple_login()` method. This is far from ideal, so we''re going
    to use our PostgreSQL server as a production-quality authentication backend. To
    start, let''s create a new `Application` method called `_database_login()`, like
    so:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 登录对话框当前使用`Application._simple_login()`方法中硬编码的凭据进行身份验证。这远远不够理想，因此我们将使用我们的PostgreSQL服务器作为生产质量的身份验证后端。首先，让我们创建一个新的`Application`方法，命名为`_database_login()`，如下所示：
- en: '[PRE39]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This method is analogous to our `_simple_login()` method, in that the `Application._show_login()`
    method will call it to authenticate the credentials entered by the user. Unlike
    `_simple_login()`, however, this method is an instance method, as it needs access
    to the settings and needs to save the `SQLModel` instance that it creates.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法类似于我们的`_simple_login()`方法，因为`Application._show_login()`方法将调用它来验证用户输入的凭据。然而，与`_simple_login()`不同，此方法是一个实例方法，因为它需要访问设置并需要保存它创建的`SQLModel`实例。
- en: The method begins by pulling the database host and database name from the `settings`
    dictionary, then attempts to create a `SQLModel` instance using them. A `psycopg2.OperationalError`
    indicates a failure to connect to the database, most likely due to failed credentials;
    in this case, we'll return `False` from the method. Otherwise, if the connection
    is successful, we'll return `True`.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法首先从`settings`字典中获取数据库主机和数据库名称，然后尝试使用它们创建一个`SQLModel`实例。`psycopg2.OperationalError`表示无法连接到数据库，最可能是因为凭据失败；在这种情况下，我们将从方法中返回`False`。否则，如果连接成功，我们将返回`True`。
- en: Note that we print the error message to the console. Since other problems could
    potentially cause an `OperationalError`, it would be smart to log the exception
    or otherwise make it accessible for debugging, rather than just silencing it.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们将错误信息打印到控制台。由于其他问题可能导致`OperationalError`，记录异常或以其他方式使其可访问进行调试，而不仅仅是静默处理，这将是明智的。
- en: 'To use this login backend, we need only change a single line in the `_show_login()`
    method:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此登录后端，我们只需在`_show_login()`方法中更改一行：
- en: '[PRE40]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The last change we need for SQL logins is in the `Application` class''s initializer.
    We need to make sure that the `settings` dictionary is available *before* we show
    the login dialog, since our database logins depend on the `db_host` and `db_name`
    settings. Simply move the lines that load the settings to the top of `__init__()`,
    just after calling `super().__init__()`, as shown here:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为SQL登录进行的最后一个更改是在`Application`类的初始化器中。我们需要确保在显示登录对话框之前`settings`字典是可用的，因为我们的数据库登录依赖于`db_host`和`db_name`设置。只需将加载设置的行移动到`__init__()`的顶部，就在调用`super().__init__()`之后，如下所示：
- en: '[PRE41]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Updating the Application._on_save() method
  id: totrans-370
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新Application._on_save()方法
- en: Since our record keys have changed from a single integer to a tuple, we need
    to make some small adjustments to our `_on_save()` method. Thanks to our efforts
    to keep the model object's interface intact, the core functionality of this method
    actually works just fine. However, when it comes to saving references to the rows
    that have been changed or updated, we can no longer rely on calculating the row
    numbers; we'll have to rely on the keys instead.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的记录键已从单个整数更改为元组，我们需要对我们的`_on_save()`方法做一些小的调整。感谢我们努力保持模型对象接口的完整性，这个方法的核心功能实际上运行得很好。然而，当涉及到保存已更改或更新的行的引用时，我们不能再依赖于计算行号；我们将不得不依赖于键。
- en: 'Starting in the second half of the `Application._on_save()` method, just after
    the `if errors:` block, change the code as follows:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 从`Application._on_save()`方法的第二部分开始，就在`if errors:`块之后，按照以下方式修改代码：
- en: '[PRE42]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: First, we've changed the `rownum` variable to `rowkey` to make it more descriptive
    of what the variable contains. Second, when we have a new record, we construct
    a new row key using the Date, Time, Lab, and Plot values that were passed in with
    the record. Note that now the contents of the `RecordList` widget's `_updated`
    and `_inserted` lists will be tuples rather than integers, so we'll need to update
    its code as well. We'll do that later in this chapter.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将`rownum`变量改为`rowkey`，使其更能描述变量包含的内容。其次，当我们有一个新记录时，我们使用与记录一起传递的日期、时间、实验室和图表值来构造一个新的行键。请注意，现在`RecordList`小部件的`_updated`和`_inserted`列表的内容将是元组而不是整数，因此我们还需要更新其代码。我们将在本章后面这样做。
- en: Removing file-based code
  id: totrans-375
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 移除基于文件的代码
- en: 'Before we move on from the `Application` class, we need to remove some of the
    file-based code that we''ll no longer need. Delete or comment out the following
    code:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们从`Application`类继续前进之前，我们需要删除一些我们不再需要的基于文件的代码。删除或注释掉以下代码：
- en: In `__init__()`, remove the line that creates the `CSVModel` instance. We no
    longer want to do this.
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`__init__()`中，删除创建`CSVModel`实例的行。我们不再想这样做。
- en: Also in `__init__()`, remove the `<<FileSelect>>` event from the `event_callbacks`
    dictionary.
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同样在`__init__()`中，从`event_callbacks`字典中删除`<<FileSelect>>`事件。
- en: Remove the `self._on_file_select()` method definition.
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除`self._on_file_select()`方法定义。
- en: Finally, over in `mainmenu.py`, we can comment out calls to the `_add_file_open()`
    method in each of our menu classes.
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，在`mainmenu.py`中，我们可以注释掉每个菜单类中调用`_add_file_open()`方法的代码。
- en: Now the `Application` object is ready for SQL, let's check out our view code.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`Application`对象已准备好进行SQL操作，让我们来看看我们的视图代码。
- en: Adjusting the DataRecordForm for SQL data
  id: totrans-382
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调整DataRecordForm以适应SQL数据
- en: Currently our `DataRecordForm` keeps track of its record using a row number.
    This is no longer going to work, since records are identified by a compound primary
    key. We'll need to adjust the way records are loaded, and how the record form
    is labeled, so that we can accurately identify the row we're working on. We also
    need to reorder the fields so that the key values are entered first, which will
    help the auto-populate to work more smoothly.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 目前我们的`DataRecordForm`使用行号来跟踪其记录。这不再有效，因为记录由复合主键识别。我们需要调整记录的加载方式以及记录表单的标签，以便我们可以准确地识别我们正在处理的行。我们还需要重新排序字段，以便首先输入键值，这将有助于自动填充工作得更顺畅。
- en: Also, our database presents us with new possibilities for auto-filling data.
    Once we know enough to identify a Lab Check record, we can auto-fill the Technician
    field, and once we know which plot we're working with, we can auto-fill the Seed
    Sample field.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们的数据库为我们提供了自动填充数据的新可能性。一旦我们知道了足够的信息来识别一个实验室检查记录，我们就可以自动填充技术人员字段；一旦我们知道我们正在处理哪个图表，我们就可以自动填充种子样本字段。
- en: Reordering fields
  id: totrans-385
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重新排序字段
- en: The first change we can make to `DataRecordForm` is the simplest. We just need
    to reorder the fields so that the key fields Date, Time, Lab, and Plot appear
    first.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以对 `DataRecordForm` 进行的第一项更改是最简单的。我们只需要重新排列字段，以便关键字段日期、时间、实验室和绘图出现在最前面。
- en: 'The updated calls (with some arguments left out) should be ordered like so:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 更新后的调用（省略了一些参数）应按如下顺序排列：
- en: '[PRE43]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Note that you need to change the `row` and `column` arguments of the `grid()`
    method calls, not just the ordering of the `LabelInput` calls.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，您需要更改 `grid()` 方法调用中的 `row` 和 `column` 参数，而不仅仅是 `LabelInput` 调用的顺序。
- en: Fixing the load_record() method
  id: totrans-390
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修复 `load_record()` 方法
- en: 'The `load_record()` method only needs two adjustments. First, we''ll replace
    the `rownum` variable with `rowkey`, to be consistent with the `Application` class.
    Second, we need to update the title text generated to identify the record, like
    so:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '`load_record()` 方法只需要进行两项调整。首先，我们将用 `rowkey` 替换 `rownum` 变量，以与 `Application`
    类保持一致。其次，我们需要更新生成的标题文本，以便识别记录，如下所示：'
- en: '[PRE44]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Once again, we have extracted the `date`, `time`, `lab`, and `plot` values from
    the key and used them to identify which record the user is currently editing.
    The remainder of the method can stay the same.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们已经从键中提取了 `date`、`time`、`lab` 和 `plot` 值，并使用它们来识别用户目前正在编辑的记录。方法的其他部分可以保持不变。
- en: Improving auto-fill
  id: totrans-394
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 改进自动填充
- en: There are two auto-population callbacks we want to have for our record form.
    First, when the user enters a `lab` and `plot` value, we want to automatically
    populate the Seed Sample field with the seed value that is currently planted in
    that `plot`. Second, when the `date`, `time`, and `lab` values have been entered,
    and we have an existing lab check that matches, we should populate the name of
    the lab tech who did that check. Of course, if our user prefers not to have data
    auto-filled, we shouldn't do either of these things.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的记录表单，我们希望有两个自动填充回调。首先，当用户输入 `lab` 和 `plot` 值时，我们希望自动填充种子样本字段，以包含当前种植在该
    `plot` 中的种子值。其次，当输入了 `date`、`time` 和 `lab` 值，并且我们有匹配的现有实验室检查时，我们应该填充执行该检查的实验室技术人员姓名。当然，如果我们的用户希望不自动填充数据，我们就不应该执行这两件事。
- en: 'Let''s start with the seed sample callback:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从种子样本回调开始：
- en: '[PRE45]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We begin by checking whether or not the user wants data auto-filled. If not,
    we return from the method. If they do, we fetch the Plot and Lab values from the
    form's control variables dictionary. If we have both, we use them to fetch the
    Seed Sample value from the model and set it in the form accordingly.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先检查用户是否希望自动填充数据。如果不是，我们就从方法中返回。如果是，我们就从表单的控制变量字典中获取 Plot 和 Lab 值。如果我们都有，我们就使用它们从模型中获取种子样本值，并在表单中相应地设置它。
- en: 'We''ll do something similar with the Technician value:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对技术人员值做类似处理：
- en: '[PRE46]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This time, we use the form's `date`, `time`, and `lab` values to fetch the lab
    check record, then set the Technician value from the results (or a blank string
    if there are no results). Note that we've added error handling around the `date`
    value; that's because we plan to trigger these methods from a variable trace.
    `Lab` and `Time` are both selected from `Combobox` widgets, so they will only
    change to a complete value, but `Date` is a text-entry field, so it's possible
    we'll be getting a partially entered date. There's no point in running a SQL query
    (a relatively time-consuming operation) if the `date` string isn't valid, so we've
    used `datetime.fromisoformat()` to determine if the entered `date` string is valid.
    If it's not, we just return from the method since there's nothing more to do.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们使用表单的 `date`、`time` 和 `lab` 值来获取实验室检查记录，然后从结果中设置技术人员值（如果没有结果，则为空字符串）。请注意，我们在
    `date` 值周围添加了错误处理；这是因为我们计划从变量跟踪触发这些方法。`Lab` 和 `Time` 都是从 `Combobox` 小部件中选择的，所以它们只会改变到完整值，但
    `Date` 是文本输入字段，所以我们可能会得到部分输入的日期。如果 `date` 字符串无效，运行 SQL 查询（这是一个相对耗时的操作）就没有意义，所以我们使用了
    `datetime.fromisoformat()` 来确定输入的 `date` 字符串是否有效。如果它无效，我们就从方法中返回，因为没有更多的事情要做。
- en: 'To complete this functionality, we just need to add triggers to run the methods
    whenever the appropriate variables are updated. Add this code to `DataRecordForm.__init__()`:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个功能，我们只需要添加触发器，以便在适当的变量更新时运行这些方法。将以下代码添加到 `DataRecordForm.__init__()` 中：
- en: '[PRE47]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Using a `for` loop, we've added a trace to each variable involved in determining
    the Seed Sample and Technician values. Now, these fields should get auto-populated
    whenever sufficient information is entered to determine their values.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `for` 循环，我们为确定种子样本和技术员值所涉及的每个变量添加了跟踪。现在，当输入足够的信息来确定它们的值时，这些字段应该会自动填充。
- en: Updating the RecordList for the SQLModel
  id: totrans-405
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新 SQLModel 的 RecordList 记录
- en: One of our `RecordList` object's most important features is the ability to select
    a record so that the `Application` object can open it in the `DataRecordForm`
    view. To do this, we have to store each record's key in its respective `Treeview`
    item's IID value. This worked easily with integer row number values, but now there
    is a problem. Recall from *Chapter 8*, *Navigating Records with Treeview and Notebook*,
    that an IID value *must be a string*. We cannot use a tuple.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 我们 `RecordList` 对象最重要的特性之一是能够选择一个记录，以便 `Application` 对象可以在 `DataRecordForm`
    视图中打开它。为此，我们必须将每个记录的键存储在其相应的 `Treeview` 项的 IID 值中。这对于整数行号值来说很容易，但现在出现了问题。回想一下
    *第 8 章*，*使用 Treeview 和 Notebook 导航记录*，IID 值*必须是一个字符串*。我们不能使用元组。
- en: To solve this problem, we just need to come up with a consistent way to connect
    our row key tuple to a string value that can be used as an IID. We'll create a
    dictionary as an instance variable that will map row keys to IID values.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决这个问题，我们只需要想出一个一致的方法来将我们的行键元组连接到一个可以作为 IID 使用的字符串值。我们将创建一个字典作为实例变量，它将映射行键到
    IID 值。
- en: 'In `RecordList.__init__()`, add this line that creates our mapping:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `RecordList.__init__()` 中，添加创建我们映射的这条线：
- en: '[PRE48]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now we need to update the `populate()` method to utilize the dictionary rather
    than integer values. First, at the beginning of the method just after deleting
    the existing rows, let''s clear the dictionary of any current information, like
    so:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要更新 `populate()` 方法以利用字典而不是整数值。首先，在删除现有行之后，方法开始处，让我们清除字典中的任何当前信息，如下所示：
- en: '[PRE49]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Then, find the `for` loop in this method that populates the `Treeview` and
    let''s edit the code as follows:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，找到此方法中填充 `Treeview` 的 `for` 循环，并让我们按如下方式编辑代码：
- en: '[PRE50]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Since row numbers are no longer in the picture, we can remove the `enumerate()`
    call and just deal with the row data. It so happens that the four columns in the
    `cids` list are the same four that make up the key, and in the same order. So,
    we can just convert that list to a `tuple` object to create our `rowkey`. Note
    that we do need to convert each item in the key to a string; they come out of
    the database as Python objects like `date` and `int`, and we need to match them
    against the keys in the _`inserted` and _`updated` lists. Those values, pulled
    from our `DataRecordForm`, are all string values.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 由于行号不再存在，我们可以删除 `enumerate()` 调用，只需处理行数据。碰巧的是，`cids` 列表中的四个列与构成键的四个列相同，并且顺序相同。因此，我们可以直接将此列表转换为
    `tuple` 对象以创建我们的 `rowkey`。请注意，我们确实需要将键中的每个项转换为字符串；它们从数据库中以 Python 对象的形式（如 `date`
    和 `int`）输出，并且我们需要将它们与 `_` `inserted` 和 `_` `updated` 列表中的键匹配。从我们的 `DataRecordForm`
    中提取的这些值都是字符串值。
- en: Once we have the key, we check if it is in one of the lists and set the `tag`
    value appropriately. Then, we'll save the output from `Treeview.insert()` as `iid`.
    When `insert()` is called without an explicit IID value, one is generated automatically
    and returned by the method. We then add our `rowkey` value to the mapping dictionary
    using the generated IID value as a key.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了键，我们就检查它是否在列表之一中，并适当地设置 `tag` 值。然后，我们将 `Treeview.insert()` 的输出保存为 `iid`。当
    `insert()` 被调用而没有显式 IID 值时，会自动生成一个值并由该方法返回。然后我们使用生成的 IID 值作为键将我们的 `rowkey` 值添加到映射字典中。
- en: After the `for` loop, the last part of this method focuses the first row for
    keyboard users. To focus the first row before, we relied on the fact that the
    first IID was always `0`. Now the first IID will be an automatically generated
    value that we cannot predict before the data is loaded, so we'll have to retrieve
    the IID before we can set the selection and focus.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `for` 循环之后，此方法的最后一部分将焦点放在第一行，以便键盘用户使用。要聚焦在第一行之前，我们依赖于第一个 IID 总是 `0` 的这一事实。现在第一个
    IID 将是一个自动生成的值，在数据加载之前我们无法预测，因此我们必须在设置选择和焦点之前检索 IID。
- en: 'We can do this by using the `Treeview.identify_row()` method:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用 `Treeview.identify_row()` 方法来实现这一点：
- en: '[PRE51]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The `identify_row()` method takes a row number and returns the IID of that row.
    Once we have that, we can pass it to `selection_set()` and `focus()`.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '`identify_row()` 方法接受一个行号并返回该行的 IID。一旦我们有了它，我们就可以将其传递给 `selection_set()` 和
    `focus()`。'
- en: 'We''ve taken care of mapping the row keys to our IIDs; now we need to update
    the `selected_id()` property method so that it returns a row key tuple. Update
    that method as follows:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经处理了将行键映射到我们的 IID；现在我们需要更新 `selected_id()` 属性方法，使其返回一个行键元组。按照以下方式更新该方法：
- en: '[PRE52]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Just as before, we're retrieving the selected IID using the `self.treeview.selection()`
    method. This time, though, we need to look up the row key value in the mapping
    dictionary before returning it.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前一样，我们使用 `self.treeview.selection()` 方法检索选定的 IID。不过，这次我们需要在返回之前在映射字典中查找行键值。
- en: The last change to `RecordList` needs to be done in the initializer. Currently,
    our first column, `Row`, displays the IID on the pretext that it is the row number.
    That's no longer the case, and as our updated call to `insert()` did not specify
    a value to display, the column is just empty. So, the best thing we can do is
    remove this column.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '`RecordList` 的最后更改需要在初始化器中完成。目前，我们的第一列 `Row` 显示 IID，理由是它是行号。现在情况已经不再是这样了，因为我们更新
    `insert()` 调用时没有指定要显示的值，所以这一列现在是空的。因此，我们能做的最好的事情就是移除这一列。'
- en: 'However, that''s not possible. The `#0` column is required and cannot be removed.
    It *can*, however, be hidden. To do that, we need to set the `Treeview` widget''s
    `show` property, like so:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这是不可能的。`#0` 列是必需的，不能被移除。但是，它可以被隐藏。为了做到这一点，我们需要设置 `Treeview` 小部件的 `show` 属性，如下所示：
- en: '[PRE53]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The `show` property essentially determines if the `#0` column will be displayed
    or not. It can be set to `tree`, in which case the column will be shown, or `headings`,
    in which case it will be hidden. The default is `tree`, so we've changed this
    to `headings`. Now only our four data columns will be shown.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '`show` 属性基本上决定了 `#0` 列是否会被显示。它可以设置为 `tree`，在这种情况下，列将被显示，或者设置为 `headings`，在这种情况下，它将被隐藏。默认值是
    `tree`，因此我们将它更改为 `headings`。现在只显示我们四个数据列。'
- en: We're done!
  id: totrans-427
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们完成了！
- en: Phew! That was quite a journey, but our SQL conversion is more or less complete.
    You should be able to launch the application, log in using your PostgreSQL credentials,
    and load and save records using the database. This represents a huge improvement
    in the application and a major shift from a simple script to append a file to
    a full-blown database application.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 呼呼！这是一段相当漫长的旅程，但我们的 SQL 转换基本上已经完成。你应该能够启动应用程序，使用你的 PostgreSQL 凭据登录，并使用数据库加载和保存记录。这代表了应用程序的一个巨大改进，从简单的脚本追加文件到完整的数据库应用程序的一个重大转变。
- en: In the real world, of course, we aren't quite done here. Unit tests and documentation
    would all need to be updated to reflect the new model layer and other code changes.
    In addition, existing data may need to be imported into the database and users
    would need retraining to adjust to the move away from flat files. We won't be
    addressing all this in the book, but keep it in mind if you're undertaking a change
    like this in a real production environment!
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在现实世界中，我们在这里还没有完全完成。单元测试和文档都需要更新，以反映新的模型层和其他代码更改。此外，现有数据可能需要导入到数据库中，并且用户需要重新培训以适应从平面文件迁移。我们不会在书中涵盖所有这些，但如果你在真实的生产环境中进行此类更改，请记住这一点！
- en: Summary
  id: totrans-430
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to work with a relational SQL database. You
    installed and configured PostgreSQL. You converted a flat-file dataset into relational
    tables by identifying the primary key fields, choosing correct data types, and
    normalizing the data structure to reduce the possibility of inconsistencies, redundancies,
    and anomalies. You learned how to install and work with the `psycopg2` library
    for retrieving and storing data in PostgreSQL. Finally, you went through the arduous
    task of building a SQL database to hold your ABQ data, building a database model
    class to interface with the database, and converting the application code to use
    the new SQL backend.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何与关系型 SQL 数据库一起工作。你安装并配置了 PostgreSQL。通过识别主键字段、选择正确的数据类型以及将数据结构规范化以减少不一致性、冗余和异常的可能性，将平面文件数据集转换为关系表。你学习了如何安装和使用
    `psycopg2` 库在 PostgreSQL 中检索和存储数据。最后，你完成了构建 SQL 数据库以存储你的 ABQ 数据的艰巨任务，构建了一个数据库模型类以与数据库接口，并将应用程序代码转换为使用新的
    SQL 后端。
- en: In the next chapter, we'll be reaching out to the cloud. We'll need to contact
    some remote servers using different networking protocols to exchange data. You'll
    learn about the Python standard library's module for working with HTTP, as well
    as third-party packages for connecting with REST services and transferring files
    over SFTP.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将接触到云计算。我们需要使用不同的网络协议来联系一些远程服务器以交换数据。你将学习到Python标准库中用于处理HTTP的模块，以及用于连接REST服务和通过SFTP传输文件的第三方包。
