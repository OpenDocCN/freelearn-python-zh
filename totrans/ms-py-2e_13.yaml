- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: asyncio – Multithreading without Threads
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: asyncio – 无线程的多线程
- en: The previous chapter showed us how to track our application performance. In
    this chapter, we will use asynchronous programming to switch between functions
    whenever we have to wait for **input/output** (**I/O**) operations. This effectively
    fakes the effects of multiple threads or processes without introducing the overhead
    that comes with those solutions. In the next chapter, we will also cover multiple
    threads and processes for the cases where I/O is not your bottleneck or where
    `asyncio` is not an option.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章向我们展示了如何跟踪应用程序的性能。在这一章中，我们将使用异步编程在需要等待**输入/输出**（**I/O**）操作时在函数之间切换。这有效地模拟了多线程或多进程的效果，而不会引入这些解决方案带来的开销。在下一章中，我们还将涵盖多线程和多进程的情况，其中I/O不是瓶颈，或者`asyncio`不是一个选项。
- en: Whenever you are dealing with external resources such as reading/writing files,
    interacting with APIs or databases, and other I/O operations, you can achieve
    great benefits from using `asyncio`. Where normally a single stalling remote connection
    can make your entire process hang, with `asyncio,` it will simply switch to a
    different part of your code.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当你处理外部资源，如读取/写入文件、与API或数据库交互以及其他I/O操作时，使用`asyncio`可以带来巨大的好处。在正常情况下，单个阻塞的远程连接可以使整个进程挂起，而使用`asyncio`，它将简单地切换到你的代码的另一个部分。
- en: This chapter will explain how asynchronous functions can be used in Python and
    how code can be restructured in such a way that it still functions, even though
    it doesn’t follow the standard procedural coding pattern of returning the values.
    The potential downside is that, similar to working with multiple threads and multiple
    processes, the possibility exists of your code executing in an unexpected order.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将解释如何在Python中使用异步函数，以及如何重构代码，使其仍然可以工作，即使它不遵循标准的返回值的程序性编码模式。潜在的缺点是，与使用多线程和多进程类似，代码执行可能以意外的顺序进行。
- en: 'The following topics are covered:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节涵盖以下主题：
- en: Introduction to `asyncio`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`asyncio`简介'
- en: '`asyncio` basic concepts, including coroutines, event loops, futures, and tasks'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`asyncio`基本概念，包括协程、事件循环、未来和任务'
- en: Functions using `async def`, `async for`, `async with`, and `await`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`async def`、`async for`、`async with`和`await`的函数
- en: Parallel execution
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并行执行
- en: Examples of implementation with `asyncio`, including clients and servers
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`asyncio`的示例，包括客户端和服务器
- en: Debugging `asyncio`
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试`asyncio`
- en: Introduction to asyncio
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`asyncio`简介'
- en: The `asyncio` library was created to make using asynchronous processing much
    easier and more predictable. It was meant as a replacement for the `asyncore`
    module, which has been available for a very long time (since Python 1.5 even)
    but was not all that usable. The `asyncio` library was officially introduced for
    Python 3.4 and has seen many improvements with each newer Python release since.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`asyncio`库的创建是为了使使用异步处理更加容易和可预测。它原本是作为`asyncore`模块的替代品，该模块已经存在很长时间（自Python
    1.5以来），但并不那么易于使用。《asyncio》库正式引入Python 3.4，并且随着每个新版本的Python发布，它都经历了许多改进。'
- en: In a nutshell, the `asyncio` library allows you to switch to the execution of
    a different function whenever you need to wait for I/O operations. So instead
    of Python waiting for your operating system to finish reading a file for you,
    blocking the entire application in the process, it can do something useful in
    a different function in the meantime.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，`asyncio`库允许你在需要等待I/O操作时切换到执行不同的函数。因此，而不是Python等待操作系统为你完成文件读取，在这个过程中阻塞整个应用程序，它可以在同时执行另一个函数中的有用操作。
- en: Backward compatibility and async/await statements
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向后兼容性和async/await语句
- en: Before we continue with any examples, it is important to know how `asyncio`
    has changed within Python versions. Even though the `asyncio` library was only
    introduced in Python 3.4, a large portion of the generic syntax has been replaced
    in Python 3.5\. Using the old Python 3.4 syntax is still possible, but an easier
    and therefore recommended syntax using `await` has been introduced.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续任何示例之前，了解`asyncio`在Python版本中的变化是很重要的。尽管`asyncio`库是在Python 3.4中引入的，但大部分通用语法在Python
    3.5中已经被替换。使用旧的Python 3.4语法仍然是可能的，但引入了一种更简单、因此更推荐的语法，即使用`await`。
- en: This chapter will assume Python 3.7 or newer in all examples unless specified
    differently. If you are still running an older version, however, please look at
    the following sections, which illustrate how to run `asyncio` on older systems.
    If you have Python 3.7+, feel free to skip to the section titled *A basic example
    of parallel execution*.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有示例中，除非特别说明，否则本章将假设使用 Python 3.7 或更高版本。然而，如果你仍在运行较旧版本，请查看以下部分，这些部分说明了如何在较旧的系统上运行
    `asyncio`。如果你有 Python 3.7+，可以自由跳转到标题为 *并行执行的基本示例* 的部分。
- en: Python 3.4
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Python 3.4
- en: 'For the traditional Python 3.4 usage, a few things need to be considered:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于传统的 Python 3.4 使用，需要考虑以下几点：
- en: Functions should be declared using the `asyncio.coroutine` decorator
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数应该使用 `asyncio.coroutine` 装饰器声明
- en: Asynchronous results should be fetched using `yield from coroutine()`
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该使用 `yield from coroutine()` 来获取异步结果
- en: 'Asynchronous loops are not directly supported, but can be emulated using a
    `while True: yield from coroutine()`'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '异步循环不支持直接使用，但可以使用 `while True: yield from coroutine()` 来模拟'
- en: 'Example:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Python 3.5
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Python 3.5
- en: The Python 3.5 syntax is much more obvious than the Python 3.4 version. While
    the `yield from` is understandable given the origins of coroutines in earlier
    Python versions, it is actually the wrong name for the job. Let `yield` be used
    for generators and `await` be used in coroutines.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3.5 的语法比 Python 3.4 版本更明显。虽然考虑到协程在早期 Python 版本中的起源，`yield from` 是可以理解的，但实际上这个名字并不适合这项工作。让
    `yield` 用于生成器，而 `await` 用于协程。
- en: Functions should be declared using `async def` instead of `def`
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该使用 `async def` 而不是 `def` 来声明函数
- en: Asynchronous results should be fetched using `await coroutine()`
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该使用 `await coroutine()` 来获取异步结果
- en: Asynchronous loops can be created using `async for ... in ...`
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用 `async for ... in ...` 创建异步循环
- en: 'Example:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Python 3.7
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Python 3.7
- en: 'Since Python 3.7 it has become slightly easier and more obvious to run `asyncio`
    code. If you have the luxury of a newer Python version, you can use the following
    to run your `async` function:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 自从 Python 3.7 以来，运行 `asyncio` 代码已经变得稍微容易一些，也更明显。如果你有使用较新 Python 版本的便利，你可以使用以下方法来运行你的
    `async` 函数：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'With older Python versions, we need a fairly advanced bit of code to properly
    replace `asyncio.run()`, but if you are not concerned with potentially reusing
    existing event loops (detailed information about event loops can be found later
    in the chapter) and take care of shutting down your tasks yourself, you can get
    away with the following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 对于较旧的 Python 版本，我们需要一段相当高级的代码来正确地替换 `asyncio.run()`，但如果你不关心可能重用现有的事件循环（关于事件循环的详细信息可以在本章后面找到）并且自己处理任务的关闭，你可以使用以下代码：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Or a shorter version that is certainly not equivalent but will handle many
    of your test cases:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 或者一个更简短的版本，虽然不一定等效，但可以处理许多测试用例：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If at all possible, I would certainly recommend using `asyncio.run()`, of course.
    Even without `asyncio.run()`, you are likely to run into library compatibility
    issues with older versions of Python.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可能的话，我当然会推荐使用 `asyncio.run()`。即使没有 `asyncio.run()`，你也可能会遇到与较旧版本的 Python 的库兼容性问题。
- en: 'If you have to, however, you can find the source for `asyncio.run()` in the
    Python Git so you can implement a simplified version yourself: [https://github.com/python/cpython/blob/main/Lib/asyncio/runners.py](https://github.com/python/cpython/blob/main/Lib/asyncio/runners.py).'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你必须这样做，你可以在 Python Git 中找到 `asyncio.run()` 的源代码，这样你可以自己实现一个简化的版本：[https://github.com/python/cpython/blob/main/Lib/asyncio/runners.py](https://github.com/python/cpython/blob/main/Lib/asyncio/runners.py)。
- en: A basic example of parallel execution
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并行执行的基本示例
- en: 'When it comes to code performance, you will usually encounter one of the two
    following bottlenecks:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到代码性能时，你通常会遇到以下两种瓶颈之一：
- en: Waiting for external I/O such as web servers, the filesystem, a database server,
    anything network-related, and others
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等待外部 I/O，如网络服务器、文件系统、数据库服务器、任何网络相关的内容以及其他
- en: The CPU, in the case of heavy calculations
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在进行大量计算的情况下，CPU
- en: If your CPU is the bottleneck due to heavy calculations, you will need to resort
    to using faster algorithms, faster or more processors, or offloading the calculations
    to dedicated hardware such as video cards. In these cases, the `asyncio` library
    won’t help you much.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的 CPU 由于大量计算而成为瓶颈，你需要求助于使用更快的算法、更快的处理器或将计算卸载到专用硬件（如显卡）。在这些情况下，`asyncio` 库对你帮助不大。
- en: If your code is mostly waiting for the user, the kernel, the filesystem, or
    external servers, `asyncio` can help you a lot while being a fairly easy solution
    with few side effects. As we will see in the *asyncio concepts* section, there
    are some caveats, however. Making existing code `asyncio`-compatible can be a
    lot of work.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的代码大部分时间都在等待用户、内核、文件系统或外部服务器，`asyncio`可以在很大程度上帮助你，同时它是一个相对简单且副作用较少的解决方案。正如我们将在*asyncio
    概念*部分看到的那样，然而也有一些注意事项。使现有代码与`asyncio`兼容可能是一项大量工作。
- en: Let’s start with a very simple example to show the difference between regular
    and `asyncio` code when having to wait.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个非常简单的例子开始，以展示在需要等待时常规代码和`asyncio`代码之间的区别。
- en: 'First, the regular Python version that executes a 1-second `sleep` two times:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，执行两次1秒`sleep`的常规Python版本：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'And now the `asyncio` version that executes a 1-second `sleep` two times:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看执行两次1秒`sleep`的`asyncio`版本：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, it still had to wait 1 second for the actual `sleep`, but it
    could run them in parallel. The `asyncio_sleep()` functions started simultaneously,
    as can be seen by the `before sleep` output.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，它仍然需要等待1秒钟来实际`sleep`，但它可以并行运行它们。`asyncio_sleep()`函数是同时开始的，正如`sleep前`输出所示。
- en: 'Let’s analyze the components used in this example:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析这个例子中使用的组件：
- en: '`async def`: This tells the Python interpreter that our function is a coroutine
    function instead of a regular function.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`async def`: 这告诉Python解释器我们的函数是一个协程函数而不是常规函数。'
- en: '`asyncio.sleep()`: Asynchronous version of `time.sleep()`. The big difference
    between these two is that `time.sleep()` will keep the Python process busy while
    it’s sleeping, while `asyncio.sleep()` will allow switching to a different task
    within the event loop. This process is very similar to the workings of task switching
    in most operating systems.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`asyncio.sleep()`: 这是`time.sleep()`的异步版本。这两个函数之间最大的区别在于，`time.sleep()`在睡眠时会保持Python进程忙碌，而`asyncio.sleep()`则允许在事件循环中切换到不同的任务。这个过程与大多数操作系统中任务切换的工作原理非常相似。'
- en: '`asyncio.run()`: A wrapper that executes a coroutine in the default event loop.
    This is effectively the `asyncio` task switcher; more about this in the next section.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`asyncio.run()`: 这是一个包装器，用于在默认事件循环中执行协程。这实际上是`asyncio`任务切换器；更多关于这一点将在下一节中介绍。'
- en: '`asyncio.gather()`: Wraps a sequence of awaitable objects and gathers the results
    for you. The wait time is configurable, as is the manner of waiting. You can choose
    to wait until the first result, until all results are available, or until the
    first exception occurs.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`asyncio.gather()`: 包装一系列可等待对象，并为你收集结果。等待时间可配置，等待的方式也可配置。你可以选择等待直到第一个结果出现，直到所有结果都可用，或者直到第一个异常发生。'
- en: This immediately demonstrates a few of the caveats and pitfalls of `asyncio`
    code as well.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这立即展示了`asyncio`代码的一些注意事项和陷阱。
- en: If we had accidentally used `time.sleep()` instead of `asyncio.sleep()`, the
    code would have taken 2 seconds to run instead and blocked the entire loop while
    doing so. More about this in the next section.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不小心使用了`time.sleep()`而不是`asyncio.sleep()`，代码将需要2秒钟才能运行，并且在执行过程中会阻塞整个循环。更多关于这一点的内容将在下一节中介绍。
- en: If we had used `await asyncio.sleep()` instead of using `await asyncio.gather()`
    at the end, the code would have run sequentially, and not in parallel, as you
    are probably looking for.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在最后没有使用`await asyncio.gather()`而是使用`await asyncio.sleep()`，代码将按顺序运行，而不是并行运行，正如你可能期望的那样。
- en: Now that we have seen a basic example of `asyncio`, we need to learn more about
    the internals so the limitations become more apparent.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了`asyncio`的一个基本示例，我们需要了解更多关于其内部结构，以便更明显地看到局限性。
- en: asyncio concepts
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: asyncio 概念
- en: The `asyncio` library has several basic concepts that have to be explained before
    venturing further into examples and uses. The example shown in the previous section
    actually uses several of them, but a little explanation about the how and why
    might still be useful.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在进一步探讨示例和用法之前，`asyncio`库有几个基本概念需要解释。上一节中显示的示例实际上使用了其中的一些，但关于如何和为什么的解释可能仍然有用。
- en: The main concepts of `asyncio` are coroutines and event loops. Within those
    there are several helper classes available such as `Streams`, `Futures`, and `Processes`.
    The next few paragraphs will explain the basics of them so we can understand the
    implementations as examples in the later sections.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`asyncio`的主要概念是协程和事件循环。在这些概念中，有几种辅助类可用，例如`Streams`、`Futures`和`Processes`。接下来的几段将解释它们的基本知识，以便我们可以在后面的章节中理解实现示例。'
- en: Coroutines, Futures, and Tasks
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 协程、未来和任务
- en: The `coroutine`, `asyncio.Future`, and `asyncio.Task` objects are essentially
    promises of a result; they return the results if they are available and can be
    used to cancel the execution of the promise if they have not finished processing
    yet. It should be noted that the creation of these objects will not guarantee
    that the code will be executed. The actual execution starts happening when you
    either `await` the results or tell an event loop to execute the promise. This
    is covered in the next section about event loops.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`coroutine`、`asyncio.Future`和`asyncio.Task`对象本质上是对结果的承诺；如果它们可用，则返回结果，并且如果它们尚未完成处理，则可以用来取消承诺的执行。应该注意的是，这些对象的创建并不能保证代码将被执行。实际的执行开始发生在你`await`结果或告诉事件循环执行承诺的时候。这将在下一节关于事件循环的讨论中介绍。'
- en: The most basic object you will encounter when using `asyncio` is the `coroutine`.
    The result of any regular `async def` (such as `asyncio.sleep()`) is a `coroutine`
    object. Once you `await` that `coroutine`, it will be executed and you will get
    the results.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`asyncio`时，你将遇到的最基本对象是`coroutine`。任何常规`async def`（如`asyncio.sleep()`）的结果都是一个`coroutine`对象。一旦你`await`那个`coroutine`，它将被执行，你将得到结果。
- en: The `asyncio.Future` and `asyncio.Task` classes can also be executed through
    `await`, but also allow you to register callback functions that receive the results
    (or exceptions) as soon as they are available. Additionally, they maintain a state
    variable internally, which allows an outside party to cancel the future and stop
    (or prevent) its execution. The API is very similar to the `concurrent.futures.Future`
    class, but they are not fully compatible, so make sure you do not confuse the
    two.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`asyncio.Future`和`asyncio.Task`类也可以通过`await`执行，但还允许你注册回调函数，以便在结果（或异常）可用时接收它们。此外，它们在内部维护一个状态变量，允许外部方取消未来并停止（或防止）其执行。API与`concurrent.futures.Future`类非常相似，但它们并不完全兼容，所以请确保不要混淆这两个。'
- en: 'To clarify a bit further, all of these are awaitable but have different levels
    of abstraction:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步澄清，所有这些都是可等待的，但具有不同的抽象级别：
- en: '`coroutine`: The result of a called `async def` that has not yet been awaited.
    You will mostly use these.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`coroutine`：一个尚未被等待的调用`async def`的结果。你将主要使用这些。'
- en: '`asyncio.Future`: A class that represents an eventual result. It does not need
    to wrap a `coroutine` and the result can be set manually.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`asyncio.Future`：一个表示最终结果的类。它不需要封装`coroutine`，结果可以手动设置。'
- en: '`asyncio.Task`: An implementation of `asyncio.Future` that is meant to wrap
    a `coroutine` to have a convenient and consistent interface.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`asyncio.Task`：`asyncio.Future`的一个实现，旨在封装`coroutine`以提供一个方便且一致的接口。'
- en: Usually the creation of these classes is not something you need to worry about
    directly; instead of creating the class yourself, the recommended way is through
    either `asyncio.create_task()` or `loop.create_task()`. The former actually executes
    `loop.create_task()` internally, but it’s more convenient if you simply want to
    execute it on the running event loop through `asyncio.get_running_loop()` without
    having to specify it. If you need to extend the `Task` class for some reason,
    that is easily possible through the `loop.set_task_factory()` method.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这些类的创建不是你需要直接担心的事情；而不是自己创建类，推荐的方式是通过`asyncio.create_task()`或`loop.create_task()`。前者实际上内部执行`loop.create_task()`，但如果你只想通过`asyncio.get_running_loop()`在运行的事件循环上执行它，而不需要指定它，那么它会更方便。如果你需要出于某种原因扩展`Task`类，那通过`loop.set_task_factory()`方法很容易实现。
- en: Before Python 3.7, `asyncio.create_task()` was called `asyncio.ensure_future()`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python 3.7之前，`asyncio.create_task()`被称为`asyncio.ensure_future()`。
- en: Event loops
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事件循环
- en: 'The event loop concept is actually the most important one within `asyncio`.
    You might suspect that the coroutines themselves are what everything is about,
    but without the event loop they are useless. Event loops function as task switchers,
    similar to how operating systems switch between active tasks on the CPU. Even
    with multicore processors, there still needs to be a main process to tell the
    CPU which tasks to run and which need to wait or sleep for a bit. That is exactly
    what the event loop does: it decides which task to run.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 事件循环的概念实际上是`asyncio`中最重要的一点。你可能怀疑协程本身是关于一切的，但没有事件循环它们是无用的。事件循环充当任务切换器，类似于操作系统在CPU上切换活动任务的方式。即使有多核处理器，仍然需要一个主进程来告诉CPU哪些任务要运行，哪些需要等待或稍作休眠。这正是事件循环所做的：它决定运行哪个任务。
- en: Effectively, every time you do `await`, the event loop will look at the pending
    awaitables and will continue the execution of one that is currently pending. This
    is also where the danger of a single event loop comes in. If, for some reason,
    you have a slow/blocking function in your coroutine, such as accidentally using
    `time.sleep()` instead of `asyncio.sleep()`, it will block the entire event loop
    until it finishes.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，每次你执行`await`时，事件循环都会查看挂起的awaitables，并继续执行当前挂起的那个。这也是单个事件循环危险的地方。如果你在协程中有一个慢速/阻塞函数，例如不小心使用`time.sleep()`而不是`asyncio.sleep()`，它将阻塞整个事件循环，直到它完成。
- en: In practice, this means that `await asyncio.sleep(5)` only guarantees that your
    code will wait *at least* 5 seconds. If, during that `await`, some other coroutine
    blocked the event loop for 10 seconds, the `asyncio.sleep(5)` would take at least
    10 seconds.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这意味着`await asyncio.sleep(5)`只能保证你的代码将等待至少5秒。如果在那个`await`期间，其他协程阻塞了事件循环10秒，那么`asyncio.sleep(5)`将至少需要10秒。
- en: Event loop implementations
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 事件循环实现
- en: 'So far we have only seen `asyncio.run()`, which uses `asyncio.get_event_loop()`
    internally to return the default event loop with the default event loop policy.
    Currently, there are two bundled event loop implementations:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只看到了`asyncio.run()`，它内部使用`asyncio.get_event_loop()`来返回具有默认事件循环策略的默认事件循环。目前有两个捆绑的事件循环实现：
- en: The `asyncio.SelectorEventLoop` implementation, which is used by default on
    Unix and Linux systems
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下在Unix和Linux系统上使用的`asyncio.SelectorEventLoop`实现。
- en: The `asyncio.ProactorEventLoop` implementation, which is only supported (and
    the default) on Windows
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅在Windows上支持（且为默认）的`asyncio.ProactorEventLoop`实现。
- en: Internally, the `asyncio.ProactorEventLoop` implementation uses I/O completion
    ports, a system that is supposedly faster and more efficient than the `select`
    implementation of the `asyncio.SelectorEventLoop` on Windows systems.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 内部，`asyncio.ProactorEventLoop`实现使用I/O完成端口，这是一个据说比Windows系统上`asyncio.SelectorEventLoop`的`select`实现更快更高效的系统。
- en: 'The `asyncio.SelectorEventLoop` is based on selectors, which, since Python
    3.4, are available through the `select` module in the core Python module. There
    are several selectors available: the traditional `selectors.SelectSelector`, which
    uses `select.select` internally, but also more modern solutions such as `selectors.KqueueSelector`,
    `selectors.EpollSelector`, and `selectors.DevpollSelector`. Even though `asyncio.SelectorEventLoop`
    will select the most efficient selector by default, there are cases where the
    most efficient one is not suitable in some way or another.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`asyncio.SelectorEventLoop`是基于选择器的，自Python 3.4以来，通过核心Python模块中的`select`模块提供。有几种选择器可用：传统的`selectors.SelectSelector`，它内部使用`select.select`，但也包括更现代的解决方案，如`selectors.KqueueSelector`、`selectors.EpollSelector`和`selectors.DevpollSelector`。尽管`asyncio.SelectorEventLoop`默认会选择最有效的选择器，但在某些情况下，最有效的选择器可能以某种方式不适用。'
- en: 'The most efficient selector is chosen by process of elimination. If the `select`
    module has a `kqueue` attribute, the `KqueueSelector` will be used. If `kqueue`
    is not available, the next best option will be chosen in the following order:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 最有效的选择器是通过排除法选择的。如果`select`模块具有`kqueue`属性，则将使用`KqueueSelector`。如果`kqueue`不可用，则将按照以下顺序选择下一个最佳选项：
- en: '`KqueueSelector`: `kqueue` is an event notification interface for BSD systems.
    It is currently supported on FreeBSD, NetBSD, OpenBSD, DragonFly BSD, and macOS
    (OS X).'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`KqueueSelector`：`kqueue`是BSD系统的事件通知接口。目前支持FreeBSD、NetBSD、OpenBSD、DragonFly
    BSD和macOS（OS X）。'
- en: '`EpollSelector`: `epoll` is the Linux kernel version of `kqueue`.'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`EpollSelector`：`epoll`是`kqueue`的Linux内核版本。'
- en: '`DevpollSelector`: This selector uses `/dev/poll`, a system that is similar
    to `kqueue` and `epoll` but is supported on Solaris systems.'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`DevpollSelector`：此选择器使用`/dev/poll`，这是一个类似于`kqueue`和`epoll`的系统，但支持在Solaris系统上。'
- en: '`PollSelector`: `poll()` is a system call that will call your function when
    an update is available. The actual implementation depends on the system.'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`PollSelector`：`poll()`是一个系统调用，当有更新可用时将调用你的函数。实际实现取决于系统。'
- en: '`SelectSelector`: Very similar to `poll()`, but `select()` builds a bitmap
    for all file descriptors and walks through that list for every update, which is
    quite a bit less efficient than `poll()`.'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SelectSelector`：与`poll()`非常相似，但`select()`为所有文件描述符构建一个位图，并在每次更新时遍历该列表，这比`poll()`低效得多。'
- en: 'In those cases, the selector event loop allows you to specify a different selector:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，选择器事件循环允许你指定不同的选择器：
- en: '[PRE7]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: It should be noted that the differences between these are generally too small
    to notice in most real-world applications. This is why I would recommend ignoring
    optimizations like these wherever possible, as they will most likely have very
    little effect and might actually cause problems if used incorrectly. The only
    situation I have come across where these would actually matter is when building
    a server that has to handle a lot of simultaneous connections. By “a lot,” I refer
    to over 100,000 concurrent connections on a single server, which is a problem
    only a few people on this planet have to deal with.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，这些之间的差异通常太小，在大多数实际应用中几乎察觉不到。这就是为什么我会建议尽可能忽略这些优化，因为它们可能效果甚微，如果使用不当甚至可能引起问题。我唯一遇到这些差异真正重要的情况是构建一个需要处理大量并发连接的服务器。这里的“大量”指的是单个服务器上超过
    100,000 个并发连接，这是地球上只有少数人需要解决的问题。
- en: If performance is important to you (and you are running Linux/OS X) I would
    recommend looking at `uvloop`, a really fast event loop that is built on `libuv`,
    an asynchronous I/O library written in C that’s supported on most platforms. According
    to the `uvloop` benchmarks, it can make your event loop 2-4 times faster.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认为性能很重要（并且你正在运行 Linux/OS X），我建议查看 `uvloop`，这是一个基于 `libuv` 的非常快速的事件循环，`libuv`
    是一个用 C 编写的异步 I/O 库，支持大多数平台。根据 `uvloop` 的基准测试，它可以让你的事件循环速度提高 2-4 倍。
- en: Event loop policies
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 事件循环策略
- en: 'The event loop policies are merely the constructs that store and create event
    loops for you and have been written with maximum flexibility in mind. The only
    reason I can think of for modifying the event loop policy is if you want to make
    specific event loops run on specific processors and/or systems, such as enabling
    `uvloop` only if you are running Linux or OS X. Beyond that, it offers more flexibility
    than most people will ever need. To make `uvloop` the default loop if installed,
    you could do the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 事件循环策略仅仅是为你存储和创建事件循环的构造，并且考虑到最大程度的灵活性。我能想到修改事件循环策略的唯一原因可能是因为你想让特定的事件循环在特定的处理器和/或系统上运行，例如，如果你正在运行
    Linux 或 OS X，则仅启用 `uvloop`。除此之外，它提供的灵活性比大多数人需要的都要多。如果你想将 `uvloop` 设置为默认循环（如果已安装），可以执行以下操作：
- en: '[PRE8]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Beyond overriding the `new_event_loop()` to customize the creation of new event
    loops, you can also override how the re-use of event loops works by overriding
    the `get_event_loop()` and `set_event_loop()` methods. I have personally never
    had any use for it beyond enabling `uvloop`, however.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 除了覆盖 `new_event_loop()` 来自定义新事件循环的创建之外，你还可以通过覆盖 `get_event_loop()` 和 `set_event_loop()`
    方法来覆盖事件循环的重用方式。我个人从未在启用 `uvloop` 之外使用过它。
- en: Event loop usage
  id: totrans-99
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 事件循环的使用
- en: Now that we know what event loops are, what they do, and how an event loop is
    selected, let’s look at how they can be applied beyond `asyncio.run()`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了事件循环是什么，它们的作用以及如何选择事件循环，让我们看看它们如何在 `asyncio.run()` 之外的应用。
- en: If you get into running your own event loops you will likely use `loop.run_forever()`,
    which, as you might expect, keeps running forever. Or at least until `loop.stop()`
    has been run. But you can also run a single task using `loop.run_until_complete()`.
    The latter is very useful for one-off operations, but can cause bugs in some scenarios.
    If you create a task from a very small/quick coroutine, odds are that the task
    will not have any time to run so it won’t be executed until the next time you
    execute `loop.run_until_complete()` or `loop.run_forever()`. More about that later
    in this chapter, however; for now, we will assume a long-running loop using `loop.run_forever()`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你开始运行自己的事件循环，你可能会使用 `loop.run_forever()`，正如你所期望的，它会永远运行。或者至少直到运行了 `loop.stop()`。但你也可以使用
    `loop.run_until_complete()` 运行单个任务。后者对于一次性操作非常有用，但在某些场景中可能会引起错误。如果你从一个非常小/快速的协程创建任务，那么任务可能没有时间运行，因此它将不会在下次执行
    `loop.run_until_complete()` 或 `loop.run_forever()` 时执行。关于这一点，我们将在本章后面详细讨论；现在，我们将假设使用
    `loop.run_forever()` 的长时间运行循环。
- en: 'Because we have an event loop running forever now, we need to add tasks to
    it – this is where things get interesting. There are quite a few choices available
    within the default event loops:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在有一个永远运行的事件循环，我们需要向其中添加任务——这就是事情变得有趣的地方。默认事件循环中有许多可用的选择：
- en: '`call_soon()`: Add an item to the end of the (FIFO) queue so the functions
    will be executed in the order they were inserted.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`call_soon()`：将一个项目添加到（FIFO）队列的末尾，这样函数将按照它们插入的顺序执行。'
- en: '`call_soon_threadsafe()`: The same as `call_soon()` except for being thread-safe.
    The `call_soon()` method isn’t thread-safe because thread safety requires the
    usage of the **global interpreter lock** (**GIL**), which effectively makes your
    program single-threaded at the moment of thread safety. *Chapter 14, Multiprocessing
    – When a Single CPU Core is Not Enough,* explains both the GIL and thread safety
    in detail.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`call_soon_threadsafe()`: 与 `call_soon()` 相同，但它是线程安全的。`call_soon()` 方法不是线程安全的，因为线程安全需要使用
    **全局解释器锁**（**GIL**），这实际上使得程序在线程安全时变为单线程。*第14章，多进程——当单个CPU核心不够用时* 详细解释了GIL和线程安全。'
- en: '`call_later()`: Call the function after the given number of seconds; if two
    jobs would run at the same time, they will run in an undefined order. If the undefined
    order is an issue, you can also opt to use `asyncio.gather()` or increase the
    `delay` parameter for one of the two tasks slightly. Note that the `delay` is
    a minimum – if the event loop is locked/busy, it could run later.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`call_later()`: 在给定秒数后调用函数；如果两个任务会在同一时间运行，它们将以未定义的顺序执行。如果未定义的顺序是一个问题，你也可以选择使用
    `asyncio.gather()` 或稍微增加两个任务中的一个的 `delay` 参数。请注意，`delay` 是一个最小值——如果事件循环被锁定/忙碌，它可能会稍后运行。'
- en: '`call_at()`: Call a function at a specific time related to the output of `loop.time()`,
    which is the number of seconds since the `loop` started. So, if the current value
    of `loop.time()` is `90` (which means the `loop` started running `90` seconds
    ago), then you could run `loop.call_at(95, ...)` to run after `5` seconds.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`call_at()`: 在与 `loop.time()` 输出相关的特定时间调用函数，`loop.time()` 是 `loop` 开始运行以来的秒数。所以，如果
    `loop.time()` 的当前值为 `90`（这意味着 `loop` 从开始运行已经过去了 `90` 秒），那么你可以运行 `loop.call_at(95,
    ...)` 来在 `5` 秒后执行。'
- en: 'All of these functions return `asyncio.Handle` objects. These objects allow
    the cancelation of the task if it hasn’t been executed yet through the `handle.cancel()`
    function. Be careful with canceling from other threads, however, as cancelation
    is not thread-safe either. To execute it in a thread-safe way, we have to execute
    the cancelation function as a task as well: `loop.call_soon_threadsafe(handle.cancel)`.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些函数都返回 `asyncio.Handle` 对象。这些对象允许通过 `handle.cancel()` 函数取消尚未执行的任务。但是，请注意，从其他线程取消时，取消操作也不是线程安全的。为了以线程安全的方式执行它，我们必须也将取消函数作为一个任务来执行：`loop.call_soon_threadsafe(handle.cancel)`。
- en: 'Example usage:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 示例用法：
- en: '[PRE9]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You might be wondering why we are using `time.sleep()` instead of `asyncio.sleep()`
    here. That is an intentional choice to show how none of these functions offer
    any guarantee of when the function is executed if the `loop` is somehow blocked.
    Even though we specified a `0.1` second delay for the `loop.call_later()` call,
    it took `0.4` seconds to actually start. If we had used `asyncio.sleep()` instead,
    the functions would have run in parallel.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么我们在这里使用 `time.sleep()` 而不是 `asyncio.sleep()`。这是一个有意的选择，以展示这些函数中的任何一个都没有提供任何关于函数执行时间的保证，如果
    `loop` 以某种方式被阻塞。尽管我们为 `loop.call_later()` 调用指定了 `0.1` 秒的延迟，但实际上它花了 `0.4` 秒才开始执行。如果我们使用
    `asyncio.sleep()`，函数将并行运行。
- en: The `call_soon()`, `call_soon_threadsafe()`, and `call_later()` functions are
    all just wrappers for `call_at()`. In the case of `call_soon()`, it just wraps
    `call_later()` with a delay of `0`, and `call_at()` is simply a `call_soon()`
    with `asyncio.time()` added to the delay.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`call_soon()`, `call_soon_threadsafe()` 和 `call_later()` 函数都是 `call_at()` 函数的包装器。在
    `call_soon()` 的情况下，它只是将 `call_later()` 延迟设置为 `0` 进行包装，而 `call_at()` 则是添加了 `asyncio.time()`
    延迟的 `call_soon()`。'
- en: Depending on the type of event loop, there are actually many other methods for
    creating connections, file handlers, and more, similar to `asyncio.create_task()`.
    Those will be explained with examples in the later sections, since they have less
    to do with the event loop and are more about programming with coroutines.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 根据事件循环的类型，实际上还有许多创建连接、文件处理器等其他方法，类似于 `asyncio.create_task()`。这些方法将在后面的章节中通过示例进行解释，因为它们与事件循环的关系较少，更多的是关于使用协程进行编程。
- en: Executors
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 执行器
- en: Since even a simple `time.sleep()` can completely block your event loop, you
    might be wondering what the practical use for `asyncio` is. It would mean you
    have to rewrite your entire code base to be `asyncio`-compatible, right? Ideally
    that would be the best solution, but we can work around this limitation by executing
    sync code from `asyncio` code using executors. An `Executor` creates the other
    type of `Future` (`concurrent.futures.Future` as opposed to `asyncio.Future`)
    we talked about earlier, and runs your code in a separate thread or process to
    provide an `asyncio` interface to synchronous code.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是简单的 `time.sleep()` 也可能完全阻塞你的事件循环，你可能想知道 `asyncio` 的实际用途是什么。这意味着你可能需要重写整个代码库以使其与
    `asyncio` 兼容，对吧？理想情况下，这将是最好的解决方案，但我们可以通过使用执行器从 `asyncio` 代码中执行同步代码来绕过这个限制。`Executor`
    创建了之前提到的另一种类型的 `Future`（`concurrent.futures.Future` 与 `asyncio.Future` 相比），并在单独的线程或进程中运行你的代码，以提供对同步代码的
    `asyncio` 接口。
- en: 'Here is a basic example of the synchronous `time.sleep()` executed through
    an executor to make it asynchronous:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个基本的例子，展示了通过执行器执行的同步 `time.sleep()` 以使其异步：
- en: '[PRE10]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: So, instead of running `executor_sleep()` directly, we are creating a future
    through `loop.run_in_executor()`. This makes `asyncio` execute this function through
    the default executor, which is normally a `concurrent.futures.ThreadPoolExecutor`,
    and return the results when it’s done. You do need to be aware of thread safety
    because it is handled in a separate thread, but more about that topic in the next
    chapter.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们不是直接运行 `executor_sleep()`，而是通过 `loop.run_in_executor()` 创建一个未来。这使得 `asyncio`
    通过默认执行器执行这个函数，这通常是 `concurrent.futures.ThreadPoolExecutor`，并在完成后返回结果。你需要意识到线程安全性，因为它是在单独的线程中处理的，但关于这个话题的更多内容将在下一章中介绍。
- en: 'For operations that are blocking but not CPU-bound (in other words, no heavy
    calculations), the default threading-based executor will work great. For CPU-bound
    operations it will not help you, since the operations will still be limited to
    a single CPU core. For those scenarios, we can use `concurrent.futures.ProcessPoolExecutor()`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 对于阻塞但不是 CPU 密集型操作（换句话说，没有重计算），默认基于线程的执行器将工作得很好。对于 CPU 密集型操作，它不会帮助你，因为操作仍然限制在单个
    CPU 核心上。对于这些场景，我们可以使用 `concurrent.futures.ProcessPoolExecutor()`：
- en: '[PRE11]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'While this example looks nearly identical to the previous example, the internal
    mechanism is quite different and the use of multiple Python processes instead
    of multiple threads comes with several caveats:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个例子看起来几乎与上一个例子相同，但内部机制相当不同，使用多个 Python 进程而不是多个线程带来了几个注意事项：
- en: Memory cannot easily be shared between processes. This means that anything you
    want to pass as an argument and anything that you need to return has to be supported
    by the `pickle` process so Python can send the data, through the network, to the
    other Python process. This is explained in detail in *Chapter 14*.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程之间很难共享内存。这意味着你想传递作为参数的任何东西以及你需要返回的任何东西都必须由 `pickle` 进程支持，这样 Python 才能通过网络发送数据到另一个
    Python 进程。这将在第 14 章中详细解释。
- en: The main script has to be run from an `if __name__ == '__main__'` block, otherwise
    the executor would end up in an infinite loop spawning itself.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主脚本必须从 `if __name__ == '__main__'` 块中运行，否则执行器最终会陷入无限循环，不断繁殖自己。
- en: Most resources cannot be shared between processes. This is similar to not being
    able to share memory, but it goes beyond that. If you have a database connection
    in your main process, that connection cannot be used from the process so it will
    need to have its own connections.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数资源不能在进程之间共享。这类似于无法共享内存，但不仅如此。如果你在主进程中有一个数据库连接，那么这个连接不能从该进程使用，因此它需要自己的连接。
- en: Killing/exiting the process can be more difficult since killing the main process
    is not always a guarantee of killing the child processes.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 终止/退出进程可能更困难，因为终止主进程并不总是能保证终止子进程。
- en: Depending on your operating system, every new process will use its own memory,
    resulting in greatly increased memory usage.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据你的操作系统，每个新的进程都将使用自己的内存，这会导致内存使用量大幅增加。
- en: Creating a new process is generally a far heavier operation than creating a
    new thread, so you have a lot more overhead.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建新进程通常比创建新线程要重得多，所以你有很多开销。
- en: Synchronization between processes is much slower than with threads.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程之间的同步比线程慢得多。
- en: All of these reasons definitely shouldn’t prevent you from using `ProcessPoolExecutor`,
    but you should always ask yourself if you actually need it. It can be an amazing
    solution if you need to run many heavy calculations in parallel. If at all possible,
    I would recommend using functional programming with `ProcessPoolExecutor`. *Chapter
    14*,*Multiprocessing – When a Single CPU Core Is Not Enough*, covers multiprocessing
    in much more detail.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些原因绝对不应该阻止你使用`ProcessPoolExecutor`，但你应该始终问自己你是否真的需要它。如果你需要并行运行许多重量级计算，它可以是一个惊人的解决方案。如果可能的话，我建议使用带有`ProcessPoolExecutor`的功能性编程。第14章，“当单个CPU核心不够用时——多进程”，详细介绍了多进程。
- en: Now that we have a basic grasp of `asyncio`, it is time to continue with some
    examples of where `asyncio` can be useful.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对`asyncio`有了基本的了解，是时候继续一些`asyncio`可能很有用的示例了。
- en: Asynchronous examples
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步示例
- en: One of the most common reasons for stalling scripts and applications is the
    usage of remote resources, where *remote* means any interaction with the network,
    filesystem, or other resources. With `asyncio`, at least a large portion of that
    is easily fixable. Fetching multiple remote resources and serving to multiple
    clients is quite a bit easier and more lightweight than it used to be. While both
    multithreading and multiprocessing can be used for these cases as well, `asyncio`
    is a much lighter alternative that is actually easier to manage in many cases.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 导致脚本和应用程序停滞不前的最常见原因之一是使用远程资源，其中“远程”意味着与网络、文件系统或其他资源的任何交互。使用`asyncio`，至少大部分问题都可以轻松解决。从多个远程资源获取数据并服务于多个客户端比以前容易得多，也轻量得多。虽然在这种情况下也可以使用多线程和多进程，但`asyncio`是一个更轻量级的替代方案，在很多情况下实际上更容易管理。
- en: The next few sections show a few examples of how to implement certain operations
    using `asyncio`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几节将展示一些使用`asyncio`实现某些操作的示例。
- en: Before you start implementing your own code and copying the examples here, I
    would recommend doing a quick search on the web for whichever library you are
    looking for and seeing if there is an `asyncio` version available.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始实现自己的代码并复制这里的示例之前，我建议你在网上快速搜索你正在寻找的库，看看是否有可用的`asyncio`版本。
- en: In general, looking for “asyncio <protocol>” will give you great results. Alternatively,
    many libraries use the `aio` prefix for the library name, such as `aiohttp`, so
    that can help your search as well.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，查找“asyncio <协议>”会给你很好的结果。或者，许多库使用`aio`前缀作为库名称，例如`aiohttp`，这也可以帮助你搜索。
- en: Processes
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进程
- en: So far, we have simply executed simple `async` functions within Python such
    as `asyncio.sleep()`, but some things are a tad more difficult to run asynchronously.
    For example, let’s assume we have some long-running external application that
    we wish to run without blocking our main thread completely.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只是在Python中执行了简单的`async`函数，如`asyncio.sleep()`，但有些事情在异步运行时稍微困难一些。例如，假设我们有一个运行时间较长的外部应用程序，我们希望在不完全阻塞主线程的情况下运行它。
- en: 'The options for running external processes in a non-blocking mode are generally:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在非阻塞模式下运行外部进程的选项通常有：
- en: Threading
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程
- en: Multiprocessing
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多进程
- en: Polling (periodically checking) for output
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 轮询（定期检查）输出
- en: Both threading and multiprocessing are covered in *Chapter 14*.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 第14章涵盖了线程和多进程。
- en: Without resorting to more complex solutions such as threading and multiprocessing,
    which introduce variable synchronization issues, we only have polling remaining.
    With polling, we check if there is new output at an interval, which can slow down
    your results by as much as the poll interval. That is, if your poll interval is
    1 second and the process generates output 0.1 seconds after the last poll, the
    next 0.9 seconds are wasted waiting. To alleviate this, you could reduce the poll
    interval, of course, but with a lower poll interval more time is wasted checking
    to see if there are results.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有求助于更复杂的解决方案，如线程和进程多线程，这些会引入可变同步问题的情况下，我们只剩下轮询。使用轮询，我们会在一定的时间间隔内检查是否有新的输出，这可能会因为轮询间隔而减慢你的结果。也就是说，如果你的轮询间隔是1秒，而进程在最后一次轮询后0.1秒生成输出，那么接下来的0.9秒都是浪费在等待上。为了缓解这种情况，你可以减少轮询间隔，当然，但轮询间隔越小，检查是否有结果所浪费的时间就越多。
- en: With `asyncio`, we can have the advantages of the polling method without the
    time wasted between the poll intervals. Using `asyncio.create_subprocess_shell`
    and `asyncio.create_subprocess_exec`, we can `await` output just like other coroutines.
    The usage of the class is very similar to `subprocess.run` except that the functions
    have been made asynchronous, resulting in the removal of the poll function, of
    course.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`asyncio`，我们可以拥有轮询方法的优势，而无需在轮询间隔之间浪费时间。使用`asyncio.create_subprocess_shell`和`asyncio.create_subprocess_exec`，我们可以像其他协程一样`await`输出。类的使用与`subprocess.run`非常相似，只是函数已被异步化，从而消除了轮询函数，当然。
- en: The examples below expect the `sleep` command to be available in your environment.
    On all Unix/Linux/BSD systems, this is the case by default. On Windows, it is
    not available by default, but can be installed easily. The `timeout` command can
    be used as an alternative.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例期望您的环境中可用`sleep`命令。在所有Unix/Linux/BSD系统中，默认情况下都是这种情况。在Windows上，默认情况下不可用，但可以轻松安装。可以使用`timeout`命令作为替代。
- en: 'If you do wish to use `sleep` and other Unix tools, the easiest method I have
    found is to install Git for Windows and let it install the **optional Unix tools**:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望使用`sleep`和其他Unix工具，我找到的最简单方法是安装Git for Windows，并让它安装**可选的Unix工具**：
- en: '![](img/B15882_13_01.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B15882_13_01.png)'
- en: 'Figure 13.1: Git for Windows installer'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.1：Git for Windows安装程序
- en: 'First, let’s look at the traditional sequential version of a script that runs
    external processes (in this case the `sleep` command) through the `subprocess`
    module:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看通过`subprocess`模块运行外部进程（在这种情况下是`sleep`命令）的传统顺序脚本版本：
- en: '[PRE12]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: After the first `print()`, we use `subprocess.Popen()` to run the `sleep` command
    with argument `0.1` so it will sleep for `0.1` seconds. As opposed to `subprocess.run()`,
    which blocks your Python process and waits until the external process has finished
    running, `subprocess.Popen()` creates and starts the process and returns a reference
    to the running process, but it won’t automatically wait for the output.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次`print()`之后，我们使用`subprocess.Popen()`运行带有参数`0.1`的`sleep`命令，使其睡眠0.1秒。与`subprocess.run()`不同，后者会阻塞您的Python进程并等待外部进程运行完成，`subprocess.Popen()`创建并启动进程并返回对运行进程的引用，但它不会自动等待输出。
- en: This allows us to explicitly call `process.wait()` to wait or poll for the results,
    as we will see in the next example. Internally, `subprocess.run()` is actually
    a convenient shortcut for a common use case of `subprocess.Popen()`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们显式调用`process.wait()`来等待或轮询结果，正如我们将在下一个示例中看到的那样。内部，`subprocess.run()`实际上是一个方便的快捷方式，用于`subprocess.Popen()`的常见用法。
- en: 'When running the code, we get the following output, as you would expect:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行代码时，我们会得到以下输出，正如您所期望的那样：
- en: '[PRE13]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Since everything is executed sequentially, it takes two times the 0.1 seconds
    that the `sleep` command is sleeping for. This is, of course, the worst-case scenario:
    it completely blocks your Python process while it is running.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有操作都是顺序执行的，所以它需要两倍于`sleep`命令睡眠时间的0.1秒。这当然是最坏的情况：它完全阻塞了正在运行的Python进程。
- en: 'Instead of waiting for the `sleep` command immediately after running, we are
    now going to start all processes in parallel and only wait for the results once
    they have all started in the background:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是在运行`sleep`命令后立即等待，我们现在将以并行方式启动所有进程，并且只有在它们都在后台启动后才开始等待结果：
- en: '[PRE14]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see, we are returning the process by returning `subprocess.Popen()`
    without executing `process.wait()`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们通过返回`subprocess.Popen()`而不执行`process.wait()`来返回进程。
- en: 'Now we start all processes immediately and only wait for output after they
    have all started:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们立即启动所有进程，并且只有在它们都启动后才开始等待输出：
- en: '[PRE15]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The processes should be running in the background now, so let’s wait for the
    results:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 进程现在应该在后台运行，所以让我们等待结果：
- en: '[PRE16]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: While that looks a lot better in terms of runtime, it still blocks the main
    process when we run `process.wait()`. It also required restructuring in such a
    way that the teardown (the `Finished` print statement) is not in the same block
    as the start process, as was the case with the earlier example. This means that
    if something were to go wrong with your application, you would manually need to
    keep track of which process was failing, which is a bit inconvenient.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在运行时看起来要好得多，但在我们运行`process.wait()`时，它仍然会阻塞主进程。它还要求以这种方式重新组织结构，即拆解（`Finished`打印语句）不在与启动进程相同的块中，正如早期示例中的情况。这意味着如果您的应用程序出现错误，您需要手动跟踪哪个进程失败，这有点不方便。
- en: 'With the `asyncio` version, we can once again go back to processing everything
    related to the `sleep` command in a single function, very similar to the first
    example with `subprocess.Popen()`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `asyncio` 版本中，我们再次可以回到在一个函数中处理与 `sleep` 命令相关的所有事情，这与第一个例子中的 `subprocess.Popen()`
    非常相似：
- en: '[PRE17]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As you can see, it is trivial to run multiple applications at the same time
    this way. The syntax is essentially the same as it would be with `subprocess`
    without having to block or poll.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，以这种方式同时运行多个应用程序是非常简单的。语法基本上与不阻塞或轮询时的 `subprocess` 相同。
- en: If you are running this from a long-running `asyncio` event loop and you don’t
    need to capture the results, you could skip the entire `asyncio.gather()` step
    and use `asyncio.create_task(async_process_sleep())` instead.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从这个长时间运行的 `asyncio` 事件循环中运行，并且不需要捕获结果，你可以跳过整个 `asyncio.gather()` 步骤，而是使用
    `asyncio.create_task(async_process_sleep())` 代替。
- en: Interactive processes
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 交互式进程
- en: Starting processes is the easy part; the more difficult part is interactive
    input and output with processes. The `asyncio` module has several measures to
    make that part easier, but it can still be difficult when actually working with
    the results.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 启动进程是容易的部分；更困难的部分是与进程进行交互式输入和输出。`asyncio` 模块有几种措施来简化这部分，但在实际处理结果时仍然可能很困难。
- en: 'Here’s an example of calling the Python interpreter as an external subprocess,
    executing some code, and exiting again in a simple one-off fashion:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个将 Python 解释器作为外部子进程调用的例子，执行一些代码，然后以简单的一次性方式退出：
- en: '[PRE18]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this case, we added a pipe to `stdout` (standard output) and `stdin` (standard
    input) so we can read from `stdout` and write to `stdin` manually. After the process
    has started, we can use `process.communicate()` to write to `stdin`, and `process.communicate()`
    will automatically read all output from `stdout` and `stderr` if they are available.
    Since we did not declare what `stderr` is supposed to be, Python will automatically
    send all `process.stderr` output to `sys.stderr` for us, so we can ignore `stderr`
    here as it will be `None`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们向 `stdout`（标准输出）和 `stdin`（标准输入）添加了一个管道，这样我们就可以手动从 `stdout` 读取并写入 `stdin`。一旦进程启动，我们就可以使用
    `process.communicate()` 向 `stdin` 写入，如果 `stdout` 和 `stderr` 可用，`process.communicate()`
    将自动读取所有输出。由于我们没有声明 `stderr` 应该是什么，Python 会自动将所有 `process.stderr` 输出发送到 `sys.stderr`，因此在这里我们可以忽略
    `stderr`，因为它将是 `None`。
- en: 'Now the actual challenge comes when we want interactive subprocesses with two-way
    communication through `stdin`/`stdout`/`stderr` that keep on running for a longer
    time. That is also possible of course, but it can be hard to avoid deadlocks in
    situations where both sides are waiting for input. Here’s a very simple example
    of a Python subprocess that does effectively the same as `communicate()` above,
    but manually, to give you granular control over the input and output of the process:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在真正的挑战在于我们想要具有通过 `stdin`/`stdout`/`stderr` 进行双向通信的交互式子进程，并且可以持续运行更长时间。当然，这也是可能的，但在双方都等待输入的情况下，避免死锁可能很困难。以下是一个非常简单的
    Python 子进程示例，它实际上与上面的 `communicate()` 做的事情相同，但手动进行，以便你可以对进程的输入和输出有更精细的控制：
- en: '[PRE19]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The code might appear largely as you would expect, but there are a few parts
    that are non-obvious to use, yet required to function. While the creation of the
    subprocess is identical to the previous example, the writing of the code to `stdin`
    is slightly different.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 代码可能看起来与你预期的基本相同，但有一些部分在使用时并不明显，但却是必需的。虽然子进程的创建与前面的例子相同，但写入 `stdin` 的代码略有不同。
- en: Instead of using `process.communicate()`, we now write directly to the `process.stdin`
    pipe. When you run `process.stdin.write(),` Python will *try* to write to the
    stream, but might not be able to because the process hasn’t started running yet.
    Because of that, we need to manually flush these buffers by using `process.stdin.drain()`.
    Once that is done, we send an end-of-file (`EOF`) character so the Python subprocess
    knows that no more input is coming.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在不再使用 `process.communicate()`，而是直接写入 `process.stdin` 管道。当你运行 `process.stdin.write()`
    时，Python 将会 *尝试* 向流中写入，但由于进程尚未开始运行，可能无法写入。因此，我们需要手动使用 `process.stdin.drain()`
    清空这些缓冲区。一旦完成，我们发送一个文件结束（`EOF`）字符，这样 Python 子进程就知道没有更多的输入了。
- en: Once the input is written, we need to read the output from the Python subprocess.
    We could use `process.stdout.readline()` in a loop for this, but similar to how
    we can do `for line in open(filename)`, we can also read `process.stdout` line
    by line using an `async for` loop until the stream is closed.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦输入被写入，我们需要从Python子进程读取输出。我们可以使用`process.stdout.readline()`在循环中完成此操作，但类似于我们可以使用`for
    line in open(filename)`，我们也可以使用`async for`循环逐行读取`process.stdout`，直到流关闭。
- en: If at all possible, I would recommend abstaining from using `stdin` to send
    data to subprocesses and instead use some network, pipe, or file communication
    instead. As we will see in the next section covering an echo client and server,
    those are much more convenient to handle and less prone to deadlocks.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可能的话，我建议避免使用`stdin`向子进程发送数据，而应使用某种网络、管道或文件通信。正如我们将在下一节中看到回声客户端和服务器时，这些方法处理起来更加方便，并且不太可能发生死锁。
- en: Echo client and server
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回声客户端和服务器
- en: The most basic kind of server you can get is an “echo” server, which sends all
    messages received back. Since we can run multiple tasks in parallel with `asyncio`,
    we can run both the server and the client from the same script here. Splitting
    them into two processes is also possible, of course.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以得到的最基本的服务器类型是“回声”服务器，它会将接收到的所有消息发送回去。由于我们可以使用`asyncio`并行运行多个任务，因此我们可以在同一个脚本中运行服务器和客户端。当然，将它们分成两个进程也是可能的。
- en: 'Creating a basic client and server is easy to do:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 创建基本的客户端和服务器很容易：
- en: '[PRE20]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In this example, we can see that we sent the server to the background using
    `asyncio.create_task()`. After that, we have to wait just a tiny amount of time
    for the background task to start working, which we are doing using `asyncio.sleep()`.
    The sleep time of `0.01` was chosen arbitrarily (and `0.001` is probably enough
    as well), but it should be enough for most systems to communicate with the kernel
    to create a listening socket. Once the server is running, we start our client
    to send a message and wait for the response.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们可以看到我们使用`asyncio.create_task()`将服务器发送到后台。之后，我们必须等待一小段时间，以便后台任务开始工作，我们使用`asyncio.sleep()`来完成这个操作。`0.01`的睡眠时间是任意选择的（`0.001`可能也足够），但它应该足以让大多数系统与内核通信以创建监听套接字。一旦服务器开始运行，我们就启动客户端发送消息并等待响应。
- en: 'Naturally, this example could have been written in many different ways. Instead
    of `async for`, you could use `reader.readline()` to read until the next newline,
    or you could use `reader.read(number_of_bytes)` to read a specific number of characters.
    It all depends on the protocol you wish to write. In the case of the HTTP/1.1
    protocol, the server expects a `Connection: close`; in the case of the SMTP protocol,
    a `QUIT` message should be sent. In our case, we use the `EOF` character as an
    indicator.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '自然地，这个例子可以用许多不同的方式编写。你不必使用`async for`，你可以使用`reader.readline()`读取到下一个换行符，或者你可以使用`reader.read(number_of_bytes)`读取特定数量的字符。这完全取决于你希望编写的协议。在HTTP/1.1协议的情况下，服务器期望一个`Connection:
    close`；在SMTP协议的情况下，应该发送一个`QUIT`消息。在我们的情况下，我们使用`EOF`字符作为指示符。'
- en: Asynchronous file operations
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步文件操作
- en: One of the operations you would prefer to be asynchronous is file operations.
    Even though storage devices have become much faster over the years, you are not
    always working on fast local storage. If you want to write to a network drive
    over a Wi-Fi connection, for example, you can experience quite a lot of latency.
    By using `asyncio`, you can make sure this won’t stall your entire interpreter.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能更希望某些操作是异步的，比如文件操作。尽管存储设备在近年来变得更快，但你并不总是使用快速的本地存储。例如，如果你想通过Wi-Fi连接写入网络驱动器，你可能会遇到相当多的延迟。通过使用`asyncio`，你可以确保这不会使你的整个解释器停滞不前。
- en: Unfortunately, there is currently no easy way to do file operations through
    `asyncio` in a cross-platform way because most operating systems have no (scalable)
    asynchronous file operations support. Luckily, someone created a workaround for
    this issue. The `aiofiles` library uses the `threading` library internally to
    give you an `asyncio` interface to file operations. While you could easily use
    an `Executor` to handle the file operations for you, the `aiofiles` library is
    a very convenient wrapper that I recommend using.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，目前还没有一种简单的方法可以在跨平台上通过`asyncio`执行文件操作，因为大多数操作系统都没有（可扩展的）异步文件操作支持。幸运的是，有人为这个问题创建了一个解决方案。`aiofiles`库在内部使用`threading`库为你提供一个`asyncio`接口来执行文件操作。虽然你可以轻松地使用`Executor`来为你处理文件操作，但`aiofiles`库是一个非常方便的包装器，我推荐使用它。
- en: 'First, install the library:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，安装库：
- en: '[PRE21]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now we can use `aiofiles` to open, read, and write files in a non-blocking
    manner through `asyncio`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用 `aiofiles` 通过 `asyncio` 以非阻塞方式打开、读取和写入文件：
- en: '[PRE22]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The usage of `aiofiles` is very similar to a regular `open()` call, except with
    the `async` prefix in all cases.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`aiofiles` 的使用与常规的 `open()` 调用非常相似，除了在所有情况下都有 `async` 前缀。'
- en: Creating async generators to support async for
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建异步生成器以支持异步 `for`
- en: 'In the earlier examples, you might have wondered how to support `async for`
    statements. Essentially it is very easy to do so; instead of a regular generator
    that you could create with the `__iter__` and `__next__` magic functions in a
    class, you would now use `__aiter__` and `__anext__` instead:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，你可能想知道如何支持 `async for` 语句。本质上，这样做非常简单；你不再需要使用 `__iter__` 和 `__next__`
    魔法函数在类中创建常规生成器，而是现在使用 `__aiter__` 和 `__anext__`：
- en: '[PRE23]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Effectively, the code is identical to regular generators and `with` statements,
    but you can also access `asyncio` code from the functions. There is really nothing
    special about these methods except that they need the `async` prefix and the `a`
    in the name, so you get `__aiter__` instead of `__iter__`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，代码与常规生成器和 `with` 语句相同，但你也可以从函数中访问 `asyncio` 代码。这些方法真正特殊的地方只是它们需要 `async`
    前缀和名称中的 `a`，因此你得到 `__aiter__` 而不是 `__iter__`。
- en: Creating async context managers to support async with
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 创建异步上下文管理器以支持异步 `with`
- en: Similar to the `async` generator, we can also create an `async` context manager.
    Instead of the `__iter__` method, we now have to replace the `__enter__` and `__exit__`
    methods with `__aenter__` and `__aexit__,` respectively.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 与异步生成器类似，我们也可以创建一个异步上下文管理器。现在，我们不再需要替换 `__iter__` 方法，而是用 `__enter__` 和 `__exit__`
    方法分别替换 `__aenter__` 和 `__aexit__`。
- en: 'Effectively the code is identical to a `with` statement, but you can also access
    `asyncio` code from the functions:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，代码与 `with` 语句相同，但你也可以从函数中访问 `asyncio` 代码：
- en: '[PRE24]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Similar to the `async` generator, there really is nothing special about these
    methods. But the `async` context manager in particular is very useful for setup/teardown
    methods, as we will see in the next section.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 与异步生成器类似，这些方法实际上并没有什么特殊之处。但特别是异步上下文管理器对于设置/清理方法非常有用，我们将在下一节中看到。
- en: Asynchronous constructors and destructors
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步构造函数和析构函数
- en: At some point, you will probably want to run some asynchronous code from your
    constructors and/or destructors, perhaps to initialize a database connection or
    other type of network connection. Unfortunately, that is not really possible.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个时候，你可能想在构造函数和/或析构函数中运行一些异步代码，可能是为了初始化数据库连接或其他类型的网络连接。不幸的是，这实际上是不可能的。
- en: Naturally, using `__await__` or metaclasses, you could hack around this for
    your constructor. And with an `asyncio.run(...)` you could do something similar
    for your destructor. Neither is really a great solution though – I would suggest
    restructuring your code instead.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，使用 `__await__` 或元类，你可以绕过这一点来处理构造函数。并且使用 `asyncio.run(...)` 你可以为析构函数做类似的事情。但这两个都不是很好的解决方案——我建议重新结构化你的代码。
- en: 'Depending on the scenario I would suggest using either:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 根据场景，我建议使用以下任一方法：
- en: Context managers to properly enter/exit using an `async with` statement
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `async with` 语句正确地进入/退出上下文管理器
- en: A Factory pattern where an `async def` generates and initializes the class for
    you, together with an `async def close()` as an async destructor
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在工厂模式中，一个 `async def` 为你生成和初始化类，同时还有一个 `async def close()` 作为异步析构函数
- en: We have already seen the context manager in the previous section, and that would
    be the method I would recommend in most cases, such as creating database connections
    and/or transactions, since you cannot accidentally forget to run the teardown
    using that.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在上一节中看到了上下文管理器，这将是大多数情况下我会推荐的方法，例如创建数据库连接和/或事务，因为使用这种方法你不会意外忘记运行拆解操作。
- en: The Factory design pattern uses a function to facilitate the creation of an
    object. In this case, that means instead of doing `instance = SomeClass(...),`
    you would have `instance = await SomeClass.create(...)` so you can have an asynchronous
    initialization method.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂设计模式使用一个函数来简化对象的创建。在这种情况下，这意味着你将不再执行 `instance = SomeClass(...)`，而是使用 `instance
    = await SomeClass.create(...)`，这样你就可以有一个异步的初始化方法。
- en: 'But a Factory pattern with an explicit create and close method is, of course,
    a good possibility too:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 但当然，具有显式创建和关闭方法的工厂模式也是一个好选择：
- en: '[PRE25]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: With the order of operations as shown before, you can properly create and tear
    down an `asyncio` class that way. As a failsafe (explicitly calling `close()`
    is always the better solution), you can add an `async` destructor to your `__del__`
    by calling the loop.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 按照之前显示的操作顺序，您可以正确地创建和拆除`asyncio`类。作为一个安全措施（明确调用`close()`始终是更好的解决方案），您可以通过调用循环来向您的`__del__`添加一个`async`析构函数。
- en: 'For the next example, we will use the `asyncpg` library, so make sure to install
    it first:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 对于下一个示例，我们将使用`asyncpg`库，所以请确保首先安装它：
- en: '[PRE26]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, an `asyncio` database connection to PostgreSQL could be implemented like
    this:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一个`asyncio`数据库连接到PostgreSQL可以像这样实现：
- en: '[PRE27]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: You could also create a registry to easily close all classes that were created
    so you can’t forget to do so on exit. But if possible, I would still recommend
    the context manager-style solution. You could also make a convenient shortcut
    using a decorator by creating an `async` version of `contextlib.ContextDecorator`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以创建一个注册表，以便轻松关闭所有创建的类，这样您就不会忘记在退出时这样做。但如果可能的话，我仍然建议使用上下文管理器风格的解决方案。您还可以通过创建`contextlib.ContextDecorator`的`async`版本来使用装饰器创建一个方便的快捷方式。
- en: Next up, we will look at how to debug `asyncio` code and how to catch common
    mistakes.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨如何调试`asyncio`代码以及如何捕捉常见的错误。
- en: Debugging asyncio
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试`asyncio`
- en: The `asyncio` module has a few special provisions to make debugging somewhat
    easier. Given the asynchronous nature of functions within `asyncio`, this is a
    very welcome feat. While the debugging of multithreaded/multiprocessing functions
    or classes can be difficult – since concurrent classes can easily change environment
    variables in parallel – with `asyncio`, it’s just as difficult, if not more, because
    `asyncio` background tasks run in the stack of the event loop, not your own stack.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`asyncio`模块有一些特殊规定，使调试变得相对容易。鉴于`asyncio`中函数的异步性质，这是一个非常受欢迎的特性。虽然多线程/多进程函数或类的调试可能很困难——因为并发类可以并行更改环境变量——但使用`asyncio`，这同样困难，甚至更困难，因为`asyncio`后台任务在事件循环的堆栈中运行，而不是您的自己的堆栈。'
- en: If you wish to skip this part of the chapter, I urge you to at least read the
    section on *Exiting before all tasks are done*. That covers a **huge** pitfall
    with `asyncio`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望跳过本章的这一部分，我强烈建议您至少阅读关于*在所有任务完成之前退出*的部分。这涵盖了`asyncio`的一个**巨大的**陷阱。
- en: 'The first and most obvious way of debugging `asyncio` is to use the event loop
    debug mode. We have several options for enabling the debug mode:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 调试`asyncio`的第一种也是最明显的方法是使用事件循环调试模式。我们有几个选项可以启用调试模式：
- en: Set the `PYTHONASYNCIODEBUG` environment variable to `True`
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`PYTHONASYNCIODEBUG`环境变量设置为`True`
- en: Enable the Python development mode using the `PYTHONDEVMODE` environment variable
    or by executing Python with the `-X dev` command-line option
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`PYTHONDEVMODE`环境变量或通过执行带有`-X dev`命令行选项的Python来启用Python开发模式
- en: Pass the `debug=True` argument to `asyncio.run()`
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`debug=True`参数传递给`asyncio.run()`
- en: Call `loop.set_debug()`
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用`loop.set_debug()`
- en: Of these methods, I recommend using the `PYTHONASYNCIODEBUG` or `PYTHONDEVMODE`
    environment variables because these are applied very early and can therefore catch
    several errors that the others might miss. We will see an example of that in the
    next section about forgotten `await` statements.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些方法中，我建议使用`PYTHONASYNCIODEBUG`或`PYTHONDEVMODE`环境变量，因为这些变量应用得非常早，因此可以捕获其他方法可能遗漏的几个错误。我们将在下一节关于忘记`await`语句的例子中看到这一点。
- en: '**Note about setting environment variables**'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于设置环境变量的说明**'
- en: 'Within most Linux/Unix/Mac shell sessions, environment variables can be set
    using `variable=value` as a prefix:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数Linux/Unix/Mac shell会话中，可以使用`variable=value`作为前缀来设置环境变量：
- en: '[PRE28]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Also, environment variables can be configured for the current shell (when using
    ZSH or Bash) session using `export`:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您还可以使用`export`为当前shell（当使用ZSH或Bash）会话配置环境变量：
- en: '[PRE29]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The current value can be fetched using the following line:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 当前值可以使用以下行获取：
- en: '[PRE30]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'On Windows, you can configure an environment variable for your local shell
    session using the `set` command:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上，您可以使用`set`命令为您的本地shell会话配置环境变量：
- en: '[PRE31]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The current value can be fetched using this line:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 当前值可以使用以下行获取：
- en: '[PRE32]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'When the debug mode is enabled, the `asyncio` module will check a few common
    `asyncio` mistakes and issues. Specifically:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 当启用调试模式时，`asyncio`模块将检查一些常见的`asyncio`错误和问题。具体来说：
- en: Coroutines that have not been yielded will raise an exception.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未调用的协程将引发异常。
- en: Calling coroutines from the “wrong” thread raises an exception. This can occur
    if you have code running in different threads from the thread running the current
    event loop. This is effectively a case of thread safety, which is covered in *Chapter
    14*.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从“错误”的线程调用协程会引发异常。这可能会发生，如果你有代码在不同的线程中运行，而当前事件循环是在不同的线程中运行的。这实际上是一个线程安全问题，这在*第14章*中有介绍。
- en: The execution time of the selector will be logged.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择器的执行时间将被记录。
- en: Slow coroutines (more than 100 ms) will be logged. This timeout can be modified
    through `loop.slow_callback_duration`.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 慢速协程（超过100毫秒）将被记录。这个超时可以通过`loop.slow_callback_duration`来修改。
- en: Warnings will be raised when resources are not closed properly.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当资源没有正确关闭时，将引发警告。
- en: Tasks that were destroyed before execution will be logged.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在执行前被销毁的任务将被记录。
- en: Let’s showcase a few of these mistakes.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们展示一些这些错误。
- en: Forgetting to await a coroutine
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 忘记await协程
- en: This is probably the most common `asyncio` bug and it has bitten me many, many
    times. It is so easy to do `some_coroutine()` instead of `await some_coroutine()`
    and you usually find out when it’s already too late.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是最常见的`asyncio`错误，它已经咬了我很多次。做`some_coroutine()`而不是`await some_coroutine()`很容易，你通常会在已经太晚的时候发现它。
- en: 'Luckily, Python can help us with this one, so let’s look at what happens when
    you forget to `await` a coroutine with `PYTHONASYNCIODEBUG` set to `1`:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Python可以帮助我们解决这个问题，所以让我们看看当将`PYTHONASYNCIODEBUG`设置为`1`时忘记`await`协程会发生什么：
- en: '[PRE33]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This results in an error for the `printer` coroutine, which we forgot to `await`:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致`printer`协程出现错误，我们忘记使用`await`：
- en: '[PRE34]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note that this will only occur when the event loop has been closed. The event
    loop can’t know if you intended to execute the coroutine at a later moment, so
    this can still be difficult to debug.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这只会发生在事件循环被关闭时。事件循环无法知道你是否打算在稍后执行协程，因此这仍然可能很难调试。
- en: This is also one of the cases where using the `PYTHONASYNCIODEBUG` environment
    variable instead of `loop.set_debug(True)` can make a difference. Think about
    a scenario where you have multiple event loops and forget to enable debug mode
    for all of them, or where a forgotten coroutine is created before debug mode is
    enabled, which means it will not be tracked.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是使用`PYTHONASYNCIODEBUG`环境变量而不是`loop.set_debug(True)`可能有所不同的案例之一。考虑一个场景，你可能有多个事件循环，并且忘记为它们全部启用调试模式，或者在一个忘记启用调试模式之前创建了协程，这意味着它不会被跟踪。
- en: Slow blocking functions
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 慢速阻塞函数
- en: 'Not considering that a function might be slow and blocking your loop is easy
    to do. If it is somewhat slow but not slow enough that you’ll notice, you will
    probably never find out about it unless you enable the debug mode. Let’s look
    at how the debug mode helps us here:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 不考虑一个函数可能很慢并且会阻塞循环是很容易做到的。如果它有点慢但不足以让你注意到，除非你启用调试模式，否则你很可能永远不会发现它。让我们看看调试模式是如何帮助我们在这里的：
- en: '[PRE35]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In this case, we “accidentally” used `time.sleep()` instead of `asyncio.sleep()`.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们“意外”地使用了`time.sleep()`而不是`asyncio.sleep()`。
- en: 'For these issues, `debug=True` works great, but it never hurts to use `PYTHONASYNCIODEBUG=1`
    when developing:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些问题，`debug=True`效果很好，但在开发时使用`PYTHONASYNCIODEBUG=1`永远不会有害：
- en: '[PRE36]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As we expected, we get a warning with this slow function.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所预期，我们得到了这个慢速函数的警告。
- en: The default warning threshold is set to 100 ms and we are sleeping for 200 ms,
    so it is reported. The threshold can be changed through `loop.slow_callback_duration=<seconds>`
    if needed. This could be useful if you are working on a slower system such as
    a Raspberry Pi, or if you want to look for slow code.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 默认警告阈值设置为100毫秒，而我们睡眠了200毫秒，因此被报告了。如果需要，可以通过`loop.slow_callback_duration=<seconds>`来更改阈值。如果你正在使用较慢的系统，如树莓派，或者想要查找慢速代码，这可能很有用。
- en: Forgetting to check the results or exiting early
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 忘记检查结果或提前退出
- en: A common way to write code with `asyncio` is to use fire-and-forget with `asyncio.create_task()`
    without storing the resulting future. While this is not inherently wrong, if an
    exception unexpectedly occurs in your code, it can be very difficult to find the
    culprit without the debug mode enabled.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`asyncio`编写代码的常见方式是使用`asyncio.create_task()`的fire-and-forget，而不存储结果future。虽然这本身并不是错误的，但如果你的代码中意外发生异常，如果没有启用调试模式，可能很难找到原因。
- en: 'To illustrate, we are going to use the following uncaught exception and execute
    it both with and without debug mode:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明，我们将使用以下未捕获的异常，并在启用和未启用调试模式的情况下执行它：
- en: '[PRE37]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'If we execute this without debug mode, we get the following output:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不启用调试模式执行此操作，我们会得到以下输出：
- en: '[PRE38]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: While this does nicely show us where the exception occurred and what exception
    occurred, it does not show us who or what created the coroutine.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这很好地显示了异常发生的位置和发生的异常，但它并没有显示是谁或什么创建了协程。
- en: 'Now if we repeat the same with debug mode enabled, we get this:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果我们启用调试模式重复同样的操作，我们得到以下结果：
- en: '[PRE39]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This might still be a bit hard to read, but now we see that the exception originated
    from `asyncio.create_task(throw_exception())` and we can even see the `asyncio.run(main())`
    call.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能仍然有点难以阅读，但现在我们可以看到异常起源于`asyncio.create_task(throw_exception())`，我们甚至可以看到`asyncio.run(main())`的调用。
- en: For a slightly larger code base, this can be essential in tracing the source
    of your exceptions.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个稍微大一点的代码库，这在追踪你的异常来源时可能是至关重要的。
- en: Exiting before all tasks are done
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在所有任务完成之前退出
- en: Pay attention here, because this issue is extremely subtle but can have huge
    consequences if you don’t notice it.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这里，因为这个问题是极其微妙的，但如果你没有注意到，它可能会产生巨大的后果。
- en: Similar to forgetting to fetch the results, when you create a task while the
    loop is already tearing down, the task will *not* always run. In some cases, it
    does not have the chance to run and you most likely won’t notice it.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 与忘记获取结果类似，当你在一个循环正在拆解时创建一个任务，该任务*不一定*会运行。在某些情况下，它没有运行的机会，你很可能不会注意到这一点。
- en: 'Take a look at this example where we have a task spawning another task:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下这个例子，我们有一个任务在生成另一个任务：
- en: '[PRE40]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In this case, even the debug mode cannot help you. To illustrate, let’s look
    at what happens when we call this with debug mode enabled:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，即使是调试模式也无法帮助你。为了说明这一点，让我们看看当我们启用调试模式调用这个函数时会发生什么：
- en: '[PRE41]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The call to `sub_printer()` seems to have disappeared. It really hasn’t, but
    we did not explicitly wait for it to finish so it never got a chance to run.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 对`sub_printer()`的调用似乎消失了。实际上并没有消失，但我们没有明确等待它完成，所以它从未有机会运行。
- en: The **best** solution by far is to keep track of all futures created by `asyncio.create_task()`
    and do an `await asyncio.gather(*futures)` at the end of your `main()` function.
    But this is not always an option – you might not have access to the futures created
    by other libraries, or the futures might be created in a scope you cannot easily
    access. So what can you do?
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，**最好的**解决方案是跟踪由`asyncio.create_task()`创建的所有future，并在你的`main()`函数的末尾执行`await
    asyncio.gather(*futures)`。但这并不总是可行的选项——你可能无法访问由其他库创建的future，或者future可能是在你无法轻松访问的作用域中创建的。那么你能做什么呢？
- en: 'As a very simple workaround, you can simply wait at the end of your `main()`
    function:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个非常简单的解决方案，你可以在`main()`函数的末尾简单地等待：
- en: '[PRE42]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'For this case, adding that little bit of sleep time works fine:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种情况，添加一点睡眠时间可以解决问题：
- en: '[PRE43]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: But this only does the trick if your task is fast enough or if you increase
    the sleep time. If we had a database teardown method that takes several seconds,
    we could still end up with an issue. As a very crude workaround, it can be useful
    to add this to your code since it will be more obvious when you’re missing a task.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 但这只有在你的任务足够快或者你增加了睡眠时间的情况下才有效。如果我们有一个需要几秒钟的数据库拆解方法，我们仍然可能会遇到问题。作为一个非常粗略的解决方案，将此添加到你的代码中可能是有用的，因为当你缺少一个任务时，这会更为明显。
- en: A slightly better solution is to ask `asyncio` what tasks are still running
    and wait until they have finished. The drawback of this method is that if you
    have a task that runs forever (in other words, `while True`), you will wait forever
    for the script to exit.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 一个稍微好一点的解决方案是询问`asyncio`哪些任务仍在运行，并等待它们完成。这种方法的一个缺点是，如果你有一个永远运行的任务（换句话说，`while
    True`），你将永远等待脚本退出。
- en: 'So let’s look at how we could implement a feature like this, with a fixed timeout
    so we won’t wait forever:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们看看我们如何实现这样一个具有固定超时时间的功能，这样我们就不会永远等待：
- en: '[PRE44]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This time, we have added a `shutdown()` method that fetches all tasks from `asyncio`
    using `asyncio.all_tasks()`. After collecting the tasks, we need to make sure
    that we don’t get our current task because that would result in a chicken-and-egg
    problem. The `shutdown()` task will never exit while waiting for the `shutdown()`
    task to finish.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们添加了一个`shutdown()`方法，它使用`asyncio.all_tasks()`从`asyncio`获取所有任务。在收集任务后，我们需要确保我们不会得到我们的当前任务，因为这会导致鸡生蛋的问题。`shutdown()`任务将在等待`shutdown()`任务完成时永远不会退出。
- en: When all tasks are gathered, we use `asyncio.as_completed()` to wait for them
    to finish and return after. If the waiting takes more than `timeout` seconds,
    `asyncio.as_completed()` will raise an `asyncio.TimeoutError` for us.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有任务都收集完毕后，我们使用`asyncio.as_completed()`等待它们完成并返回。如果等待时间超过`timeout`秒，`asyncio.as_completed()`将为我们抛出一个`asyncio.TimeoutError`。
- en: You can easily modify this to try and cancel all tasks so all non-shielded tasks
    will be canceled right away. And you can also change the exception to a warning
    instead if the pending tasks are not critical in your use case.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以轻松地修改它以尝试取消所有任务，这样所有非受保护的任务将立即被取消。如果待处理任务在您的用例中不是关键的，您也可以将异常更改为警告。
- en: '`task = asyncio.shield(...)` protects against `task.cancel()` and functions
    like an onion. A single `asyncio.shield()` protects against a single `task.cancel()`;
    to protect against multiple cancelations, you will need to shield in a loop, or
    at least multiple times.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`task = asyncio.shield(...)`可以防止`task.cancel()`和类似操作，就像洋葱一样。单个`asyncio.shield()`可以防止单个`task.cancel()`；要防止多次取消，您需要在循环中屏蔽，或者至少多次屏蔽。'
- en: Lastly, it should be noted that this solution is not without its flaws either.
    It could happen that one of the tasks spawns new tasks while running; this is
    not something that is handled by this implementation, and handling it improperly
    might lead to waiting forever.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，应该注意的是，这个解决方案也不是没有缺陷。在运行过程中，任务可能会产生新的任务；这不是这个实现所处理的，而且处理不当可能会导致永远等待。
- en: Now that we know how to debug the most common `asyncio` issues, it’s time to
    end with a few exercises.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何调试最常见的`asyncio`问题，是时候通过一些练习来结束了。
- en: Exercises
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Working with `asyncio` will require active thought throughout most of your development
    process. Besides `asyncio.run()` and similar methods, there is no way to run an
    `async def` from synchronous code. This means that every intermediate function
    between your main `async def` and the code that needs `asyncio` will have to be
    `async` as well.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个开发过程中，使用`asyncio`将需要积极的思考。除了`asyncio.run()`和类似的方法外，没有其他方法可以从同步代码中运行`async
    def`。这意味着您主`async def`和需要`asyncio`的代码之间的每个中间函数都必须是`async`的。
- en: You could make a synchronous function return a coroutine so one of the parent
    functions can run it within an event loop. But that usually results in a very
    confusing execution order of the code, so I would not recommend going down that
    route.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将同步函数返回一个协程，这样父函数中的一个就可以在事件循环中运行它。但通常这会导致代码执行顺序非常混乱，所以我不会推荐走这条路。
- en: 'In short, this means that any `asyncio` project you try with the `asyncio`
    debug setting enabled is good practice. We can create a few challenges, however:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，这意味着您尝试的任何启用`asyncio`调试设置的`asyncio`项目都是良好的实践。然而，我们可以提出一些挑战：
- en: Try to create a `asyncio` base class that automatically registers all instances
    for easy closing/destructuring when you are done
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试创建一个`asyncio`基类，当您完成时可以自动注册所有实例，以便于轻松关闭/解构
- en: Create an `asyncio` wrapper class for a synchronous process such as file or
    network operations using executors
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用executors为文件或网络操作等同步过程创建`asyncio`包装类
- en: Convert any of your scripts or projects to `asyncio`
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将您的脚本或项目转换为`asyncio`
- en: 'Example answers for these exercises can be found on GitHub: [https://github.com/mastering-python/exercises](Chapter_13.xhtml).
    You are encouraged to submit your own solutions and learn about alternative solutions
    from others.'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这些练习的示例答案可以在GitHub上找到：[https://github.com/mastering-python/exercises](Chapter_13.xhtml)。我们鼓励您提交自己的解决方案，并从他人的替代方案中学习。
- en: Summary
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: 'In this chapter, we have seen:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了：
- en: The basic concepts of `asyncio` and how they interact
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`asyncio`的基本概念及其交互方式'
- en: How to run external processes using `asyncio`
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用`asyncio`运行外部进程
- en: How to create a server and client using `asyncio`
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用`asyncio`创建服务器和客户端
- en: How to create context managers with `asyncio`
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用`asyncio`创建上下文管理器
- en: How to create generators with `asyncio`
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用`asyncio`创建生成器
- en: How to debug common issues when using `asyncio`
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何调试使用`asyncio`时常见的错误
- en: How to avoid the unfinished task pitfall
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何避免未完成任务的陷阱
- en: By now you should know how to keep your main loop responsive while waiting for
    results without having to resort to polling. In *Chapter 14*,*Multiprocessing
    – When a Single CPU Core Is Not Enough*, we will learn about `threading` and `multiprocessing`
    as an `asyncio` alternative to running multiple functions in parallel.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，您应该知道如何在等待结果的同时保持主循环的响应性，而无需求助于轮询。在 *第14章*，“当单个CPU核心不够用时——多进程”，我们将学习 `threading`
    和 `multiprocessing` 作为在并行运行多个函数时的 `asyncio` 替代方案。
- en: For new projects, I would strongly consider using `asyncio` from the ground
    up because it is usually the fastest solution for handling external resources.
    For existing scripts, however, this can be a very invasive process. So knowing
    about `threading` and `multiprocessing` is certainly important, also because `asyncio`
    can leverage them and you should be aware of thread and process safety.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 对于新项目，我强烈建议从头开始使用 `asyncio`，因为它通常是处理外部资源的最快解决方案。然而，对于现有脚本，这可能是一个非常侵入性的过程。因此，了解
    `threading` 和 `multiprocessing` 确实很重要，也因为 `asyncio` 可以利用它们，您应该了解线程和进程的安全性。
- en: When building utilities based on the `asyncio` library, make sure to search
    for pre-made libraries to solve your problems as `asyncio` is gaining more adoption
    every year. In many cases, someone has already created a library for you.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 当基于 `asyncio` 库构建工具时，请确保搜索现成的库来解决您的问题，因为 `asyncio` 正在每年获得更多的采用。在许多情况下，有人已经为您创建了一个库。
- en: Next up is parallel execution using `threading` and `multiprocessing`.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是使用 `threading` 和 `multiprocessing` 的并行执行。
- en: Join our community on Discord
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区
- en: 'Join our community’s Discord space for discussions with the author and other
    readers: [https://discord.gg/QMzJenHuJf](https://discord.gg/QMzJenHuJf)'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的 Discord 空间，与作者和其他读者进行讨论：[https://discord.gg/QMzJenHuJf](https://discord.gg/QMzJenHuJf)
- en: '![](img/QR_Code156081100001293319171.png)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![二维码](img/QR_Code156081100001293319171.png)'
