<html><head></head><body>
  <div><div><div><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Data and Classes</h1></div></div></div><p>In this chapter, we will use data and OOP classes using Python 3:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">How to use StringVar()</li><li class="listitem" style="list-style-type: disc">How to get data from a widget</li><li class="listitem" style="list-style-type: disc">Using module-level global variables</li><li class="listitem" style="list-style-type: disc">How coding in classes can improve the GUI</li><li class="listitem" style="list-style-type: disc">Writing callback functions</li><li class="listitem" style="list-style-type: disc">Creating reusable GUI components</li></ul></div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec37"/>Introduction</h1></div></div></div><p>In this chapter, we will save our GUI data into tkinter variables.</p><p>We will <a id="id110" class="indexterm"/>also start using <strong>object-oriented programming</strong> (<strong>OOP</strong>) to extend the existing tkinter classes in order to extend tkinter's built-in functionality. This will lead us into creating reusable OOP components.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec38"/>How to use StringVar()</h1></div></div></div><p>There <a id="id111" class="indexterm"/>are built-in programming types in tkinter that differ slightly from the Python types we are used to programming with. StringVar() is one of those tkinter types.</p><p>This recipe will show you how to use the StringVar() type.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec95"/>Getting ready</h2></div></div></div><p>We are learning how to save data from the tkinter GUI into variables so we can use that data. We can set and get their values, very similar to the Java getter/setter methods.</p><p>Here are <a id="id112" class="indexterm"/>some of the available types of coding in tkinter:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">strVar = StringVar()</code>
</p>
</td><td style="text-align: left" valign="top">
<p># Holds a string; the default value is an empty string ""</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">intVar = IntVar()</code>
</p>
</td><td style="text-align: left" valign="top">
<p># Holds an integer; the default value is 0</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">dbVar = DoubleVar()</code>
</p>
</td><td style="text-align: left" valign="top">
<p># Holds<a id="id113" class="indexterm"/> a float; the default value is 0.0</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">blVar  = BooleanVar()</code>
</p>
</td><td style="text-align: left" valign="top">
<p># Holds a Boolean, it returns 0 for false and 1 for true</p>
</td></tr></tbody></table></div><div><div><h3 class="title"><a id="note28"/>Note</h3><p>Different languages call numbers with decimal points, floats, or doubles. Tkinter calls a DoubleVar for what in Python is called a float datatype. Depending on the level of precision, floats and double data can be different. Here, we are translating the tkinter DoubleVar into what Python turns into a Python float type.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec96"/>How to do it...</h2></div></div></div><p>We<a id="id114" class="indexterm"/> are creating a new Python module and the following screenshot shows both the code and the resulting output:</p><div><img src="img/B04829_04_01.jpg" alt="How to do it..."/></div><p>First, we import the tkinter module and alias it to the name <code class="literal">tk</code>.</p><p>Next, we use this alias to create an instance of the <code class="literal">Tk</code> class by appending parentheses to <code class="literal">Tk</code>, which calls the constructor of the class. This is the same mechanism as calling a function, only here we are creating an instance of a class.</p><p>Usually we use this instance assigned to the variable <code class="literal">win</code> to start the main event loop later in the code. But here, we are not displaying a GUI but demonstrating how to use the tkinter StringVar type.</p><div><div><h3 class="title"><a id="note29"/>Note</h3><p>We still have to create an instance of <code class="literal">Tk()</code>. If we comment out this line, we will get an error from tkinter, so this call is necessary.</p></div></div><p>Then we <a id="id115" class="indexterm"/>create an instance of the tkinter StringVar type and assign it to our Python <code class="literal">strData</code> variable.</p><p>After that, we use our variable to call the <code class="literal">set()</code> method on StringVar and, after having it set to a value, we then get the value and save it in a new variable named <code class="literal">varData</code> and then print out its value.</p><p>In the Eclipse PyDev console, towards the bottom of the screenshot, we can see the output printed to the console, which is <strong>Hello StringVar</strong>.</p><p>Next, we will print the default values of tkinter's IntVar, DoubleVar, and BooleanVar types.</p><div><img src="img/B04829_04_02.jpg" alt="How to do it..."/></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec97"/>How it works...</h2></div></div></div><p>As can be seen in the preceding screenshot, the default values do not get printed as we would have expected.</p><p>The online literature mentions default values, but we won't see those values until we call the <code class="literal">get</code> method on them. Otherwise, we just get a variable name that automatically increments (for example PY_VAR3, as can be seen in the preceding screenshot).</p><p>Assigning <a id="id116" class="indexterm"/>the tkinter type to a Python variable does not change the outcome. We still do not get the default value.</p><p>Here, we are focusing on the simplest code (which creates PY_VAR0):</p><div><img src="img/B04829_04_03.jpg" alt="How it works..."/></div><p>The value is PY_VAR0, not the expected 0, until we call the <code class="literal">get</code> method. Now we can see the default value. We did not call <code class="literal">set</code>, so we see the default value automatically assigned to each tkinter type once we call the <code class="literal">get</code> method on each type.</p><div><img src="img/B04829_04_04.jpg" alt="How it works..."/></div><p>Notice<a id="id117" class="indexterm"/> how the default value of 0 gets printed to the console for the <code class="literal">IntVar</code> instance we saved in the <code class="literal">intData</code> variable. We can also see the values in the Eclipse PyDev debugger window at the top of the screenshot.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec39"/>How to get data from a widget</h1></div></div></div><p>When the <a id="id118" class="indexterm"/>user enters data, we want to do something with<a id="id119" class="indexterm"/> it in our code. This recipe shows how to capture data in a variable. In the previous recipe, we created several tkinter class variables. They were standalone. Now we are connecting them to our GUI, using the data we get from the GUI and storing it in Python variables.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec98"/>Getting ready</h2></div></div></div><p>We are continuing to use the Python GUI we were building in the previous chapter.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec99"/>How to do it...</h2></div></div></div><p>We are assigning a value from our GUI to a Python variable.</p><p>Add the following code towards the bottom of our module, just above the main event loop:</p><div><pre class="programlisting">strData = spin.get()
print("Spinbox value: " + strData)

# Place cursor into name Entry
nameEntered.focus()      
#======================
# Start GUI
#======================
win.mainloop()</pre></div><p>Running<a id="id120" class="indexterm"/> the code gives us the following result:</p><div><img src="img/B04829_04_05.jpg" alt="How to do it..."/></div><p>We are <a id="id121" class="indexterm"/>retrieving the current value of the <code class="literal">Spinbox</code> control.</p><div><div><h3 class="title"><a id="note30"/>Note</h3><p>We placed our code above the GUI main event loop and so the printing happens before the GUI becomes visible. We would have to place the code in a callback function if we wanted to print out the current value after displaying the GUI and changing the value of the <code class="literal">Spinbox</code> control.</p></div></div><p>We created our Spinbox widget using the following code, hard-coding the available values into it:</p><div><pre class="programlisting"># Adding a Spinbox widget using a set of values
spin = Spinbox(monty, values=(1, 2, 4, 42, 100), width=5, bd=8, command=_spin) 
spin.grid(column=0, row=2)</pre></div><p>We can also move the hard-coding of the data out of the creation of the <code class="literal">Spinbox</code> class instance and set it later.</p><div><pre class="programlisting"># Adding a Spinbox widget assigning values after creation
spin = Spinbox(monty, width=5, bd=8, command=_spin) 
spin['values'] = (1, 2, 4, 42, 100)
spin.grid(column=0, row=2)</pre></div><p>It does not matter how we create our widget and insert data into it because we can access this data by using the <code class="literal">get()</code> method on the instance of the widget.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec100"/>How it works...</h2></div></div></div><p>In order to get values out of our GUI written using tkinter, we use the tkinter <code class="literal">get()</code> method on an instance of the widget we wish to get the value from.</p><p>In the <a id="id122" class="indexterm"/>above example we used the Spinbox control, but the <a id="id123" class="indexterm"/>principle is the same for all widgets that have a <code class="literal">get()</code> method.</p><p>Once we have gotten the data, we are in a pure Python world and tkinter did serve us to build our GUI. Now that we know how to get the data out of our GUI, we can use this data.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec40"/>Using module-level global variables</h1></div></div></div><p>Encapsulation is<a id="id124" class="indexterm"/> a major strength in any programming language that enables us to program using OOP. Python is both OOP and procedural. We can create global variables that are localized to the module they reside in. They are global only to this module, which is one form of encapsulation. Why do we want this? Because, as we add more and more functionality to our GUI, we want to avoid naming conflicts, which could result in bugs in our code.</p><div><div><h3 class="title"><a id="note31"/>Note</h3><p>We do not want naming clashes creating bugs in our code! Namespaces are one way to avoid these bugs, and in Python, we can do this by using Python modules (which are unofficial namespaces).</p></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec101"/>Getting ready</h2></div></div></div><p>We can declare module-level globals in any module just above and outside of functions.</p><p>We then have to use the <code class="literal">global</code> Python keyword to refer to them. If we forget to use <code class="literal">global</code> in functions, we will accidentally create new local variables. This would be a bug and something we really do not want to do.</p><div><div><h3 class="title"><a id="note32"/>Note</h3><p>Python is a dynamic, strongly typed language. We will only notice bugs like this (forgetting to scope variables with the global keyword) at runtime.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec102"/>How to do it...</h2></div></div></div><p>Add the code shown on line 15 to the GUI we used in the previous recipe and the last chapter, which creates a module-level global variable. We use the C-style all uppercase convention, which is not truly "Pythonic" but I think this does emphasize the principle we are addressing in this recipe.</p><div><img src="img/B04829_04_06.jpg" alt="How to do it..."/></div><p>Running the<a id="id125" class="indexterm"/> code results in a printout of the global. Notice <strong>42</strong> being printed to the Eclipse console.</p><div><img src="img/B04829_04_07.jpg" alt="How to do it..."/></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec103"/>How it works...</h2></div></div></div><p>We define a global variable at the top of our module and, later, towards the bottom of our module, we print out its value.</p><p>That works.</p><p>Add this function towards the bottom of our module:</p><div><img src="img/B04829_04_08.jpg" alt="How it works..."/></div><p>Above, we<a id="id126" class="indexterm"/> are using the module-level global. It is easy to make a mistake by shadowing the <code class="literal">global</code>, as demonstrated in the following screenshot:</p><div><img src="img/B04829_04_09.jpg" alt="How it works..."/></div><p>Note how <code class="literal">42</code> became <code class="literal">777</code>, even though we are using the same variable name.</p><div><div><h3 class="title"><a id="note33"/>Note</h3><p>There is no compiler in Python that warns us if we overwrite global variables in a local function. This can lead to difficulties in debugging at runtime.</p></div></div><p>Using the global qualifier (line 234) prints out the value we originally assigned it (42) towards the top of our module, as can be seen in the following screenshot:</p><div><img src="img/B04829_04_10.jpg" alt="How it works..."/></div><p>But, be<a id="id127" class="indexterm"/> careful. When we uncomment the local global, we print out the value of the local, not the global:</p><div><img src="img/B04829_04_11.jpg" alt="How it works..."/></div><p>Even though we are using the <code class="literal">global</code> qualifier, the local variable seems to override it. We are getting a warning from the Eclipse PyDev plug-in that our <code class="literal">GLOBAL_CONST = 777</code> is not being used, yet running the code still prints 777 instead of the expected 42.</p><p>This might not be the behavior we expect. Using the <code class="literal">global</code> qualifier we might expect that we are pointing to the global variable created earlier.</p><p>Instead, it seems that Python creates a new global variable in a local function and overwrites the one we created earlier.</p><p>Global variables can be very useful when programming small applications. They can help to make data available across methods and functions within the same Python module and sometimes the overhead of OOP is not justified.</p><p>As our<a id="id128" class="indexterm"/> programs grow in complexity, the benefit we gained from using globals can quickly diminish.</p><div><div><h3 class="title"><a id="note34"/>Note</h3><p>It is best to avoid globals and accidentally shadowing variables by using the same name in different scopes. We can use OOP instead of using globals.</p></div></div><p>We played around with global variables within procedural code and learned how that can lead to hard-to-debug bugs. In the next chapter, we will move on to OOP, which can eliminate these kinds of bugs.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec41"/>How coding in classes can improve the GUI</h1></div></div></div><p>So far, <a id="id129" class="indexterm"/>we have been coding in a procedural style. This is a quick scripting method from Python. Once our code gets larger and larger, we need to advance to coding in OOP.</p><p>Why?</p><p>Because, among many other benefits, OOP allows us to move code around by using methods. Once we use classes, we no longer have to physically place code above the code that calls it. This gives us great flexibility in organizing our code.</p><p>We can write related code next to other code and no longer have to worry that the code will not run because the code does not sit above the code that calls it.</p><p>We can take that to some rather fancy extremes by coding up modules that refer to methods that are not being created within that module. They rely on the runtime state having created those methods during the time the code runs.</p><div><div><h3 class="title"><a id="note35"/>Note</h3><p>If the methods we call have not been created by that time, we get a runtime error.</p></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec104"/>Getting ready</h2></div></div></div><p>We will turn our entire procedural code into OOP very simply. We just turn it into a class, indent all the existing code, and prepend <code class="literal">self</code> to all variables.</p><p>It is very easy.</p><p>While at first it might feel a little bit annoying having to prepend everything with the <code class="literal">self</code> keyword, making our code more verbose (hey, we are wasting so much paper…); in the end, it will be worth it.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec105"/>How to do it...</h2></div></div></div><p>In the <a id="id130" class="indexterm"/>beginning, all hell breaks loose, but we will very soon fix this apparent mess.</p><p>Note that, in Eclipse, the PyDev editor hints at coding problems by highlighting them in red on the right-side portion of the code editor.</p><p>Maybe we should not code in OOP after all, but this is what we do, and for very good reasons.</p><div><img src="img/B04829_04_12.jpg" alt="How to do it..."/></div><p>We just have to prepend all variables with the <code class="literal">self</code> keyword and also bind the functions to the class by using <code class="literal">self</code>, which officially and technically turns the functions into methods.</p><div><div><h3 class="title"><a id="note36"/>Note</h3><p>There is a difference between functions and methods. Python makes this very clear. Methods are bound to a class while functions are not. We can even mix the two within the same Python module.</p></div></div><p>Let's prefix<a id="id131" class="indexterm"/> everything with <code class="literal">self</code> to get rid of the red, so we can run our code again.</p><div><img src="img/B04829_04_13.jpg" alt="How to do it..."/></div><p>Once we do this for all of the errors highlighted in red, we can run our Python code again.</p><p>The <code class="literal">clickMe</code> function is now bound to the class and has officially become a method.</p><p>Unfortunately, starting in a procedural way and then translating it into OOP is not as simple as I stated above. The code became a huge mess. This is a very good reason to start programming in Python using the OOP paradigm.</p><div><div><h3 class="title"><a id="note37"/>Note</h3><p>Python is good at doing things the easy way. The easy code often becomes more complex (because it was easy to begin with). Once we get too complex, refactoring our procedural code into what truly could be OOP code becomes harder with every single line of code.</p></div></div><p>We are translating our procedural code into object-oriented code. Looking at all the troubles we got ourselves into, translating only 200+ lines of Python code into OOP could suggest that we might as well start coding in OOP from the beginning.</p><p>We actually did break some of our previously working functionality. Using Tab 2 and clicking the radio buttons no longer works. We have to refactor more.</p><p>The procedural code was easy in the sense that it was simply top to bottom coding. Now that we have placed our code into a class, we have to move all callback functions into methods. This works, but does take some work to translate our original code.</p><p>Our procedural code looked like this:</p><div><pre class="programlisting"># Button Click Function
def clickMe():
    action.configure(text='Hello ' + name.get())

# Changing our Label
ttk.Label(monty, text="Enter a name:").grid(column=0, row=0, sticky='W')

# Adding a Textbox Entry widget
name = tk.StringVar()
nameEntered = ttk.Entry(monty, width=12, textvariable=name)
nameEntered.grid(column=0, row=1, sticky='W')

# Adding a Button
action = ttk.Button(monty, text="Click Me!", command=clickMe)
action.grid(column=2, row=1)

The new OOP code looks like this:
class OOP():
    def __init__(self): 
        # Create instance
        self.win = tk.Tk()   
        
        # Add a title       
        self.win.title("Python GUI")      
        self.createWidgets()
    
    # Button callback
    def clickMe(self):
        self.action.configure(text='Hello ' + self.name.get())

    # … more callback methods 

    def createWidgets(self):    
        # Tab Control introduced here -----------------------
        tabControl = ttk.Notebook(self.win)     # Create Tab Control
        
        tab1 = ttk.Frame(tabControl)            # Create a tab 
        tabControl.add(tab1, text='Tab 1')      # Add the tab
        
        tab2 = ttk.Frame(tabControl)            # Create second tab
        tabControl.add(tab2, text='Tab 2')      # Add second tab 
        
        tabControl.pack(expand=1, fill="both")  # Pack make visible
#======================
# Start GUI
#======================
oop = OOP()
oop.win.mainloop()</pre></div><p>We moved the callback methods to the top of the module, inside the new OOP class. We moved all the widget creation code into one rather long method, which we call in the initializer of the class.</p><p>Technically, deep<a id="id132" class="indexterm"/> underneath the hood of low-level code, Python does have a constructor, yet Python frees us from any worries about this. It is taken care of for us.</p><p>Instead, in addition to a "real" constructor, Python provides us with an initializer.</p><p>We are strongly encouraged to use this initializer. We can use it to pass in parameters to our class, initializing variables we wish to use inside of our class instance.</p><div><div><h3 class="title"><a id="note38"/>Note</h3><p>In Python, several classes can exist within the same Python module.</p></div></div><p>Unlike Java, which has a very rigid naming convention (without which it does not work), Python is much more flexible.</p><div><div><h3 class="title"><a id="note39"/>Note</h3><p>We can create multiple classes within the same Python module. Unlike Java, we do not depend on a file name that has to match each class name.</p><p>Python truly rocks!</p></div></div><p>Once our Python GUI gets large, we will break some classes out into their own modules but, unlike Java, we do not have to. In this book and project, we will keep some classes in the same module, while at the same time, we will break out some other classes into their own modules, importing them into what can be considered as a main() function (this is not C, but we can think C-like because Python is very flexible).</p><p>What we have achieved so far is to add the <code class="literal">ToolTip</code> class to our Python module and refactor our procedural Python code into OOP Python code.</p><p>Here, in this recipe, we can see that more than one class can live in the same Python module.</p><p>Cool stuff, indeed!</p><div><img src="img/B04829_04_14.jpg" alt="How to do it..."/></div><p>Both<a id="id133" class="indexterm"/> the <code class="literal">ToolTip</code> class and the <code class="literal">OOP</code> class reside within the same Python module.</p><div><img src="img/B04829_04_15.jpg" alt="How to do it..."/></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec106"/>How it works...</h2></div></div></div><p>In this recipe, we advanced our procedural code into object-oriented-programming (OOP) code.</p><p>Python enables us to write code in both a practical, procedural style like the C-programming language.</p><p>At the same time, we have the option to code in an OOP style, like Java, C#, and C++.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec42"/>Writing callback functions</h1></div></div></div><p>At first, callback <a id="id134" class="indexterm"/>functions can seem to be a little bit intimidating. You call the function, passing it some arguments, and now the function tells you that it is really very busy and it will call you back!</p><p>You wonder: "Will this function <em>ever</em> call me back?" "And how long do I have to <em>wait</em>?"</p><p>In Python, even callback functions are easy and, yes, they usually do call you back.</p><p>They just have to complete their assigned task first (hey, it was you who coded them in the first place…).</p><p>Let us understand a little bit more about what happens when we code callbacks into our GUI.</p><p>Our GUI is event-driven. After it has been created and displayed onscreen, it typically sits there waiting for an event to happen. It is basically waiting for an event to be sent to it. We can send an event to our GUI by clicking one of its action buttons.</p><p>This creates an event and, in a sense, we "called" our GUI by sending it a message.</p><p>Now, what is supposed to happen after we send a message to our GUI?</p><p>What happens after clicking the button depends on whether we created an event handler and associated it with this button. If we did not create an event handler, clicking the button will have no effect.</p><p>The event handler is a callback function (or method, if we use classes).</p><p>The callback method is also sitting there passively, like our GUI, waiting to be invoked.</p><p>Once our GUI gets its button clicked, it will invoke the callback.</p><p>The callback often does some processing and, when done, it returns the result to our GUI.</p><div><div><h3 class="title"><a id="note40"/>Note</h3><p>In a sense, we can see that our callback function is calling back to our GUI.</p></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec107"/>Getting ready</h2></div></div></div><p>The Python interpreter runs through all the code in a project once, finding any syntax errors and pointing them out. You cannot run your Python code if you do not have the syntax right. This includes indentation (if not resulting in a syntax error, wrong indentation usually results in a bug).</p><p>On the next parsing round, the interpreter interprets our code and runs it.</p><p>At runtime, many GUI events can be generated and it is usually callback functions that add functionality to GUI widgets.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec108"/>How to do it...</h2></div></div></div><p>Here is the <a id="id135" class="indexterm"/>callback for the Spinbox widget:</p><div><img src="img/B04829_04_16.jpg" alt="How to do it..."/></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec109"/>How it works...</h2></div></div></div><p>We created a callback method in the <code class="literal">OOP</code> class, which gets called when we select a value from the Spinbox widget because we bound the method to the widget via the <code class="literal">command</code> argument (<code class="literal">command=self._spin</code>). We use a leading underscore to hint at the fact that this method should be respected like a private Java method.</p><p>Python intentionally avoids language restrictions such as private, public, friend, and so on.</p><p>In Python, we use naming conventions instead. Leading and trailing double underscores surrounding a keyword are expected to be restricted to the Python language, and we should not use them in our own Python code.</p><p>However, we can use a leading underscore prefix to a variable name or function to provide a hint that this name should be respected as a private helper.</p><p>At the same time, we can postfix a single underscore if we wish to use what otherwise would be Python built-in names. For example, if we wished to abbreviate the length of a list, we could do the following:</p><div><pre class="programlisting">len_ = len(aList)</pre></div><p>Often, the underscore is hard to read and easy to oversee, so this might not be the best idea in practice.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec43"/>Creating reusable GUI components</h1></div></div></div><p>We are <a id="id136" class="indexterm"/>creating reusable GUI components using Python.</p><p>In this recipe, we will keep it simple by moving our <code class="literal">ToolTip</code> class into its own module. Next, we will import and use it for displaying tooltips over several widgets of our GUI.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec110"/>Getting ready</h2></div></div></div><p>We are building on our previous code.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec111"/>How to do it...</h2></div></div></div><p>We will<a id="id137" class="indexterm"/> start by breaking out our <code class="literal">ToolTip</code> class into a separate Python module. We will slightly enhance it to pass in the control widget and the tooltip text we wish to display when we hover the mouse over the control.</p><p>We create a new Python module and place the <code class="literal">ToolTip</code> class code into it and then import this module into our primary module.</p><p>We then reuse the imported <code class="literal">ToolTip</code> class by creating several tooltips, which can be seen when hovering the mouse over several of our GUI widgets.</p><p>Refactoring our common <code class="literal">ToolTip</code> class code out into its own module helps us to reuse this code from other modules. Instead of copy/paste/modify we use the DRY principle and our common code is located in only one place, so when we modify the code, all modules that import it will automatically get the latest version of our module.</p><div><div><h3 class="title"><a id="note41"/>Note</h3><p>DRY stands for Don't Repeat Yourself and we will look at it again in a later chapter.</p><p>We can do similar things by turning our Tab3 image into a reusable component.</p><p>To keep this recipe's code simple, we removed Tab 3, but you can experiment with the code from the previous chapter.</p></div></div><div><img src="img/B04829_04_17.jpg" alt="How to do it..."/></div><div><pre class="programlisting">        
# Add a Tooltip to the Spinbox
tt.createToolTip(self.spin, 'This is a Spin control.')
        
# Add Tooltips to more widgets
tt.createToolTip(nameEntered, 'This is an Entry control.')
tt.createToolTip(self.action, 'This is a Button control.')
tt.createToolTip(self.scr, 'This is a ScrolledText control.')</pre></div><p>This also <a id="id138" class="indexterm"/>works on the second tab.</p><div><img src="img/B04829_04_18.jpg" alt="How to do it..."/></div><p>The new code structure looks like this now:</p><div><img src="img/B04829_04_19.jpg" alt="How to do it..."/></div><p>The import statement looks like this:</p><div><img src="img/B04829_04_20.jpg" alt="How to do it..."/></div><p>And the <a id="id139" class="indexterm"/>broken out (aka refactored) code in a separate module looks like this:</p><div><img src="img/B04829_04_21.jpg" alt="How to do it..."/></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec112"/>How it works...</h2></div></div></div><p>In the preceding screenshots, we can see several tooltip messages being displayed. The one for the main window might appear a little bit annoying, so it is better not to display a tooltip for the main window because we really wish to highlight the functionality of the individual widgets. The main window form has a title that explains its purpose; no need for a tooltip.</p></div></div></div>
</body></html>