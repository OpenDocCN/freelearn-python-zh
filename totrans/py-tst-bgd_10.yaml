- en: Chapter 10. Other Testing Tools and Techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*We''ve covered the core elements of testing in Python, but there are a number
    of peripheral methods and tools that will make your life easier. In this chapter,
    we''ll go over several of them in brief.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we shall:'
  prefs: []
  type: TYPE_NORMAL
- en: Discuss code coverage, and learn about `coverage.py`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discuss continuous integration, and learn about buildbot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how to integrate automated testing into popular version control systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So let's get on with it!
  prefs: []
  type: TYPE_NORMAL
- en: Code coverage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tests tell you when the code you're testing doesn't work the way you thought
    it would, but they don't tell you a thing about the code that you're not testing.
    They don't even tell you that the code you're not testing isn't being tested.
  prefs: []
  type: TYPE_NORMAL
- en: Code coverage is a technique, which can be used to address that shortcoming.
    A code coverage tool watches while your tests are running, and keeps track of
    which lines of code are (and aren't) executed. After the tests have run, the tool
    will give you a report describing how well your tests cover the whole body of
    code.
  prefs: []
  type: TYPE_NORMAL
- en: It's desirable to have the coverage approach 100%, as you probably figured out
    already. Be careful not to focus on the coverage number too intensely though,
    it can be a bit misleading. Even if your tests execute every line of code in the
    program, they can easily not test everything that needs to be tested. That means
    you can't take 100% coverage as certain proof that your tests are complete. On
    the other hand, there are times when some code really, truly doesn't need to be
    covered by the tests—some debugging support code, for example—and so less than
    100% coverage can be completely acceptable.
  prefs: []
  type: TYPE_NORMAL
- en: Code coverage is a tool to give you insight into what your tests are doing,
    and what they may be overlooking. It's not the definition of a good test suite.
  prefs: []
  type: TYPE_NORMAL
- en: coverage.py
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We're going to be working with a module called `coverage.py`, which is—unsurprisingly—a
    code coverage tool for Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since `coverage.py` isn''t built in to Python, we''ll need to download and
    install it. You can download the latest version from the Python Package Index
    at [http://pypi.python.org/pypi/coverage](http://pypi.python.org/pypi/coverage).
    As before, users of Python 2.6 or later can install the package by unpacking the
    archive, changing to the directory, and typing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Users of older versions of Python need write permission to the system-wide
    `site-packages` directory, which is part of the Python installation. Anybody who
    has such permission can install coverage by typing:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$ python setup.py install`'
  prefs: []
  type: TYPE_NORMAL
- en: At the time of this writing, Windows users also had the option of downloading
    a Windows installer file from the Python Package Index and running it to install
    `coverage.py`.
  prefs: []
  type: TYPE_NORMAL
- en: We'll walk through the steps of using `coverage.py` here, but if you want more
    information you can find it on the `coverage.py` home page at [http://nedbatchelder.com/code/coverage/](http://nedbatchelder.com/code/coverage/).
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – using coverage.py
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll create a little `toy` code module with tests, and then apply `coverage.py`
    to find out how much of the code the tests actually use.
  prefs: []
  type: TYPE_NORMAL
- en: Place the following test code into `test_toy.py`. There are several problems
    with these tests, which we'll discuss later, but they ought to run.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Put the following code into `toy.py`. Notice the `if __name__ == '__main__'`
    clause at the bottom. We haven't dealt with one of those in a while, so I'll remind
    you that the code inside that block runs doctest if we were to run the module
    with `python toy.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Go ahead and run Nose. It should find them, run them, and report that all is
    well. The problem is, some of the code isn't ever tested.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's run it again, only this time we'll tell Nose to use `coverage.py` to measure
    coverage while it's running the tests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Time for action – using coverage.py](img/8846_10_01.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In step 1, we have a couple of `TestCase` classes with some very basic tests
    in them. These tests wouldn't be much use in a real world situation, but all we
    need them for is to illustrate how the code coverage tool works.
  prefs: []
  type: TYPE_NORMAL
- en: In step 2, we have the code that satisfies the tests from step 1\. Like the
    tests themselves, this code wouldn't be much use, but it serves as an illustration.
  prefs: []
  type: TYPE_NORMAL
- en: 'In step 4, we passed `--with-coverage` and `--cover-erase` as command line
    parameters when we ran Nose. What did they do? Well, `--with-coverage` is pretty
    straightforward: it told Nose to look for `coverage.py` and to use it while the
    tests execute. That''s just what we wanted. The second parameter, `--cover-erase`,
    tells Nose to forget about any coverage information that was acquired during previous
    runs. By default, coverage information is aggregated across all of the uses of
    `coverage.py`. This allows you to run a set of tests using different testing frameworks
    or mechanisms, and then check the cumulative coverage. You still want to erase
    the data from previous test runs at the beginning of that process, though, and
    the `--cover-erase` command line is how you tell Nose to tell `coverage.py` that
    you''re starting anew.'
  prefs: []
  type: TYPE_NORMAL
- en: What the coverage report tells us is that 9/12 (in other words, 75%) of the
    executable statements in the toy module were executed during our tests, and that
    the missing lines were line 16 and a lines 19 through 20\. Looking back at our
    code, we see that line 16 is the `__repr__` method. We really should have tested
    that, so the coverage check has revealed a hole in our tests that we should fix.
    Lines 19 and 20 are just code to run doctest, though. They're not something that
    we ought to be using under normal circumstances, so we can just ignore that coverage
    hole.
  prefs: []
  type: TYPE_NORMAL
- en: Code coverage can't detect problems with the tests themselves, in most cases.
    In the above test code, the test for the `timestwo` method violates the isolation
    of units and invokes two different methods of `example_class`. Since one of the
    methods is the constructor, this may be acceptable, but the coverage checker isn't
    in a position to even see that there might be a problem. All it saw was more lines
    of code being covered. That's not a problem— it's how a coverage checker ought
    to work— but it's something to keep in mind. Coverage is useful, but high coverage
    doesn't equal good tests.
  prefs: []
  type: TYPE_NORMAL
- en: Pop quiz – code coverage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What does a high coverage percentage mean?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If your boss asks you for a quantifiable measure of test quality, will you use
    the coverage percentage?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the most useful information on the coverage report?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Have a go hero – checking coverage in earlier chapters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Go back through the code from earlier chapters and use code coverage to check
    for things that should have been tested, but weren't. Try it on some of your own
    tested code too.
  prefs: []
  type: TYPE_NORMAL
- en: Version control hooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most version control systems have the ability to run a program that you've written
    in response to various events, as a way of customizing the version control system's
    behavior. These programs are commonly called hooks.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Version control systems are programs for keeping track of changes to a source
    code tree, even when those changes are made by different people. In a sense, they
    provide an universal undo history and change log for the whole project, going
    all the way back to the moment you started using the version control system. They
    also make it much easier to combine work done by different people into a single,
    unified entity, and to keep track of different editions of the same project.
  prefs: []
  type: TYPE_NORMAL
- en: You can do all kinds of things by installing the right hook programs, but we'll
    only focus on one use. We can make the version control program automatically run
    our tests, when we commit a new version of the code to the version control repository.
  prefs: []
  type: TYPE_NORMAL
- en: This is a fairly nifty trick, because it makes it difficult for test-breaking
    bugs to get into the repository unnoticed. Somewhat like code coverage, though
    there's potential for trouble if it becomes a matter of policy rather than simply
    being a tool to make your life easier.
  prefs: []
  type: TYPE_NORMAL
- en: In most systems, you can write the hooks such that it's impossible to commit
    code that breaks tests. That may sound like a good idea at first, but it's really
    not. One reason for this is that one of the major purposes of a version control
    system is communication between developers, and interfering with that tends to
    be unproductive in the long run. Another reason is that it prevents anybody from
    committing partial solutions to problems, which means that things tend to get
    dumped into the repository in big chunks. Big commits are a problem because they
    make it hard to keep track of what changed, which adds to the confusion. There
    are better ways to make sure you always have a working codebase socked away somewhere,
    such as version control branches.
  prefs: []
  type: TYPE_NORMAL
- en: Bazaar
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: B azaar is a distributed version control system, which means that it is capable
    of operating without a central server or master copy of the source code. One consequence
    of the distributed nature of Bazaar is that each user has their own set of hooks,
    which can be added, modified, or removed without involving anyone else. Bazaar
    is available on the Internet at [http://bazaar-vcs.org/](http://bazaar-vcs.org/).
  prefs: []
  type: TYPE_NORMAL
- en: If you don't have Bazaar already installed, and don't plan on using it, you
    can skip this section.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – installing Nose as a Bazaar post-commit hook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bazaar hooks go in your `plugins` directory. On Unix-like systems, that's `~/.bazaar/plugins/`,
    while on Windows it's `C:\Documents and Settings\<username>\Application Data\Bazaar\<version>\plugins\`.
    In either case, you may have to create the `plugins` subdirectory, if it doesn't
    already exist.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Place the following code into a file called `run_nose.py` in the `plugins`
    directory. Bazaar hooks are written in Python:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Make a new directory in your working files, and put the following code into
    it in a file called `test_simple.py`. These simple (and silly) tests are just
    to give Nose something to do, so that we can see that the hook is working.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Still in the same directory as `test_simple.py`, run the following commands
    to create a new repository and commit the tests to it. The output you see might
    differ in details, but it should be quite similar overall.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Time for action – installing Nose as a Bazaar post-commit hook](img/8846_10_02.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Notice that there's a Nose test report after the commit notification. From now
    on, any time you commit to a Bazaar repository, Nose will search for and run whatever
    tests it can find within that repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Bazaar hooks are written in Python, so we've written our hook as a function
    called `run_nose`. Our `run_nose` function checks to make sure that the repository
    which we're working on is local, and then it changes directories into the repository
    and runs nose. We registered `run_nose` as a hook by calling `branch.Branch.hooks.install_named_hook`.
  prefs: []
  type: TYPE_NORMAL
- en: Mercurial
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like Bazaar, Mercurial is a distributed version control system, with hooks that
    are managed by each user individually. Mercurial's hooks themselves, though, take
    a rather different form. You can find Mercurial on the web at [http://www.selenic.com/mercurial/](http://www.selenic.com/mercurial/).
  prefs: []
  type: TYPE_NORMAL
- en: If you don't have Mercurial installed and don't plan to use it, you can skip
    this section.
  prefs: []
  type: TYPE_NORMAL
- en: Mercurial hooks can go in several different places. The two most useful are
    in your personal configuration file and in your repository configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: Your personal configuration file is `~/.hgrc` on Unix-like systems, and `%USERPROFILE%\Mercurial.ini`
    (which usually means `c:\Documents and Settings\<username>\Mercurial.ini`) on
    Windows-based systems.
  prefs: []
  type: TYPE_NORMAL
- en: Your repository configuration file is stored in a subdirectory of the repository,
    specifically `.hg/hgrc`, on all systems.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – installing Nose as a Mercurial post-commit hook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll use the repository configuration file to store the hook, which means
    that the first thing we have to do is have a repository to work with. Make a new
    directory at a convenient place and execute the following command in it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'One side-effect of that command is that a `.hg` subdirectory got created. Change
    to that directory, and then create a text file called `hgrc` containing the following
    text:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Back in the repository directory (i.e. the parent of the `.hg` directory),
    we need some tests for Nose to run. Create a file called `test_simple.py` containing
    the following (admittedly silly) tests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the following commands to add the test file and commit it to the repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Time for action – installing Nose as a Mercurial post-commit hook](img/8846_10_03.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Notice that the commit triggered a run-through of the tests. Since we put the
    hook in the repository configuration file, it will only take effect on commits
    to this repository. If we'd instead put it into your personal configuration file,
    it would be called when you committed to *any* repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Mercurial's hooks are commands, just like you would enter into your operating
    systems command shell (also known as a DOS prompt on Windows). We just had to
    edit Mercurial's configuration file and tell it which command to run. Since we
    wanted it to run our Nose test suite when we commit, we set the commit hook to
    `nosetests`.
  prefs: []
  type: TYPE_NORMAL
- en: Git
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Git is a distributed version control system. Similar to Bazaar and Mercurial,
    it allows every user to control their own hooks, without involving other developers
    or server administrators.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Git hooks are stored in the `.git/hooks/` subdirectory of the repository, each
    in its own file.
  prefs: []
  type: TYPE_NORMAL
- en: If you don't have Git installed, and don't plan to use it, you can skip this
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – installing Nose as a Git post-commit hook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The hooks are stored in a subdirectory of a Git repository, so the first thing
    that we need to do is initialize a repository. Make a new directory for the Git
    repository and execute the following command inside of it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Git hooks are executable programs, so they can be written in any language. To
    run Nose, it makes sense to use a shell script (on Unix-like systems) or batch
    file (on Windows) for the hook. If you're using a Unix-like system, place the
    following two lines into a file called post-commit in the `.git/hooks/` subdirectory,
    and then use the `chmod +x post-commit` command to make it executable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you're using a Windows system, place the following lines inside a file called
    `post-commit.bat` in the `.git\hooks\` subdirectory.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need to put some test code in the repository directory (that is, the parent
    of the `.git` directory), so that Nose has something to do. Place the following
    (useless) code into a file called `test_simple.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the following commands to add the test file and commit it to the repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Time for action – installing Nose as a Git post-commit hook](img/8846_10_04.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Notice that the commit triggered an execution of Nose and printed out the test
    results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because each repository has its own hooks, only the repositories that were specifically
    configured to run Nose will do so.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Git finds its hooks by looking for programs with specific names, so we could
    have used any programming language to write our hook, as long as we could give
    the program the right name. However, all that we want is to run the `nosetests`
    command, so that we can use a simple shell script or batch file. All this simple
    program does is invoke the `nosetests` program, and then terminate.
  prefs: []
  type: TYPE_NORMAL
- en: Darcs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Darcs is a distributed version control system. Each user has control over their
    own set of hooks.
  prefs: []
  type: TYPE_NORMAL
- en: If you don't have Darcs installed, and you don't plan to use it, you can skip
    this section.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – installing Nose as a Darcs post-record hook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Each local repository has its own set of hooks, so the first thing we need
    to do is create a repository. Make a directory to work in, and execute the following
    command in it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We need to put some test code in the repository directory so that Nose has something
    to do. Place the following (useless) code into a file called `test_simple.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the following command to add the test file to the repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Darcs hooks are identified using command line options. In this case, we want
    to run `nosetests` after we tell Darcs to record changes, so we use the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Time for action – installing Nose as a Darcs post-record hook](img/8846_10_05.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Notice that Darcs ran our test suite once it was done recording the changes,
    and reported the results to us.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'That''s well and good, but Darcs doesn''t remember that we want `nosetests`
    to be a post-record hook. As far as it''s concerned, that was a one-time deal.
    Fortunately, we can tell it otherwise. Create a file called `defaults` in the
    `_darcs/prefs/` subdirectory, and place the following text into it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now if we change the code and record again, `nosetests` should run without
    us specifically asking for it. Make the following change to `test_simple.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the following command to record the change and run the tests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Time for action – installing Nose as a Darcs post-record hook](img/8846_10_06.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: If you want to skip the tests for a commit, you can pass the `--no-posthook`
    command line option when you record your changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Darcs hooks are specified as command line options, so when we issue the `record`
    command we need to specify a program to run as a hook. Since we don't want to
    do that manually every time we record changes, we make use of Darcs' ability to
    accept additional command line options in its configuration file. This allows
    us to make running `nosetests` as a hook into the default behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Subversion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unlike the other version control systems that we've discussed, Subversion is
    a centralized one. There is a single server tasked with keeping track of everybody's
    changes, which also handles running hooks. This means that there is a single set
    of hooks that applies to everybody, probably under control of a system administrator.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Subversion hooks are stored in files in the `hooks/` subdirectory of the server's
    repository.
  prefs: []
  type: TYPE_NORMAL
- en: If you don't have Subversion and don't plan on using it, you can skip this section.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – installing Nose as a Subversion post-commit hook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Because Subversion operates on an centralized, client-server architecture, we'll
    need both the client and server set up for this example. They can both be on the
    same computer, but they'll need to be in different directories.
  prefs: []
  type: TYPE_NORMAL
- en: 'First we need a server. You can create one by making a new directory called
    `svnrepo` and executing the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we need to configure the server to accept commits from us. To do this,
    we open up the file called `conf/passwd` and add the following line at the bottom:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then we need to edit `conf/svnserve.conf`, and change the line reading `# password-db
    = passwd` to `password-db = passwd`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The Subversion server needs to be running, before we can interact with it.
    This is done by making sure that we''re in the `svnrepo` directory and then running
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next we need to import some test code into the Subversion repository. Make
    a directory and place the following (simple and silly) code into it in a file
    called `test_simple.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can perform the import by executing:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That command is likely to print out a gigantic, scary message about remembering
    passwords. In spite of the warnings, just say `yes`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that we''ve got the code imported, we need to check out a copy of it to
    work on. We can do this with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: From here on in this example, we'll assume that the Subversion server is running
    in a Unix-like environment (the clients might be running on Windows, we don't
    care). The reason for this, is that the details of the post-commit hook are significantly
    different on systems that don't have a Unix style shell scripting language, although
    the concepts remain the same.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The following code goes into a file called `hooks/post-commit` inside the subversion
    server's repository. (The `svn update` and `svn checkout` lines have been wrapped
    around to fit on the page. In actual use, this wrapping should not be present.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Use the `chmod +x post-commit` command to make the hook executable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change to the `svn` directory created by the checkout in step 5, and edit `test_simple.py`
    to make one of the tests fail. We do this because if the tests all pass, Subversion
    won't show us anything to indicate that they were run at all. We only get feedback
    if they fail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now commit the changes using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Time for action – installing Nose as a Subversion post-commit hook](img/8846_10_07.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Notice that the commit triggered the execution of Nose, and that if any of the
    tests fail, Subversion shows us the errors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because Subversion has one central set of hooks, they apply automatically to
    anybody who uses the repository.
  prefs: []
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Subversion hooks are run on the server. Subversion locates its hooks by looking
    for programs with specific names, so we needed to create a program called `post-commit`
    to be the post-commit hook. We could have used any programming language to write
    the hook, as long as the program had the right name, but we chose to use shell
    scripting language, for simplicity's sake.
  prefs: []
  type: TYPE_NORMAL
- en: Pop quiz – version control hooks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In what ways can hooking your automated tests into your version control system
    help you?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are a couple of the things you could do with version control hooks, but
    shouldn't?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the biggest difference between hooks in distributed version control
    systems, and hooks in centralized version control systems?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Automated continuous integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Automated continuous integration tools are a step beyond using a version control
    hook to run your tests when you commit code to the repository. Instead of running
    your test suite once, an automated continuous integration system compiles your
    code (if need be) and runs your tests many times, in many different environments.
  prefs: []
  type: TYPE_NORMAL
- en: An automated continuous integration system might, for example, run your tests
    under Python versions 2.4, 2.5, and 2.6 on each of Windows, Linux, and Mac OS
    X. This not only lets you know about errors in your code, but also about unexpected
    problems caused by the external environment. It's nice to know when that last
    patch broke the program on Windows, even though it worked like a charm on your
    Linux box.
  prefs: []
  type: TYPE_NORMAL
- en: Buildbot
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Buildbot is a popular automated continuous integration tool. Using Buildbot,
    you can create a network of 'build slaves' that will check your code each time
    you commit to you commit it to your repository. This network can be quite large,
    and it can be distributed around the Internet, so Buildbot works even for projects
    with lots of developers spread around the world.
  prefs: []
  type: TYPE_NORMAL
- en: Buildbot's home page is at [http://buildbot.net/](http://buildbot.net/). Following
    links from that site, you can find the manual and download the latest version
    of the tool. Glossing over details that we've discussed several times before,
    installation requires you to unpack the archive, and then run the commands `python
    setup.py build`, and `python setup.py install --user`.
  prefs: []
  type: TYPE_NORMAL
- en: Buildbot operates in one of two modes, termed `buildmaster` and `buildslave`.
    A buildmaster manages a network of buildslaves, while the buildslaves run the
    tests in their assorted environments.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – using Buildbot with Bazaar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To set up a buildmaster, create a directory for it to operate in and then run
    the command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: where `<directory>` is the directory you just created for buildbot to work in.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Similarly, to set up a buildslave, create a directory for it to operate in
    and then run the command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: where `<directory>` is the directory you just created for the buildbot to work
    in, `<host:port>` are the internet host and port where the buildmaster can be
    found, and `<name>` and `<password>` are the login information that identifies
    this buildslave to the buildmaster. All of this information (except the directory)
    is determined by the operator of the buildmaster.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You should edit `<directory>/info/admin` and `<directory>/info/host` to contain
    the email address you want associated with this buildslave and a description of
    the buildslave's operating environment, respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On both the buildmaster and the buildslave, you''ll need to start up the buildbot
    background process. To do this, use the command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Configuring a buildmaster is a significant topic in itself (and one that we''
    won''t be addressing in detail). It''s fully described in Buildbot''s own documentation.
    We will provide a simple configuration file, though, for reference and quick setup.
    This particular configuration file assumes that you''re using Bazaar, but it is
    not significantly different for other version control systems. The following goes
    in the master `<directory>/master.cfg` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make effective use of that Buildbot config, you also need to install a version
    control hook that notifies Buildbot of changes. Generically, this can be done
    by calling the `buildbot sendchange` command from the hook, but there''s a nicer
    way to tie in with Bazaar: copy the `contrib/bzr_buildbot.py` file from the buildbot
    distribution archive into your Bazaar plugins directory, and then edit the `locations.conf`
    file, which you should find right next to the `plugins` directory. Add the following
    entry to `locations.conf`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You'll need to add similar entries for each repository that you want to be connected
    to buildbot.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once you have the buildmaster and buildslaves configured, and have hooked buildbot
    into your version control system, and have started the buildmaster and buildslaves,
    you're in business.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We just set up Buildbot to run our tests, whenever it notices that our source
    code has been unchanged for two hours.
  prefs: []
  type: TYPE_NORMAL
- en: 'We told it to run the tests by adding a build step that runs nosetests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We told it to wait for the source code to be unchanged for two hours by adding
    a build scheduler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll be able to see a report of the Buildbot status in your web browser,
    by navigating to the `buildbotURL` that you configured in the `master.cfg` file.
    One of the most useful reports is the so-called ''waterfall'' view. If the most
    recent commit passes the tests, you should see something similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What just happened?](img/8846_10_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'On the other hand, when the commit fails to pass the tests, you''ll see something
    more like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What just happened?](img/8846_10_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Either way, you'll also see a history of earlier versions, and whether or not
    they passed the tests, as well as who made the changes, when, and what the output
    of the test command looked like.
  prefs: []
  type: TYPE_NORMAL
- en: Pop quiz – Buildbot
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What kind of projects benefit most from Buildbot and other such tools?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When is it better to use Buildbot, as opposed to just running Nose from a version
    control hook?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When is it worse?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Aside from running tests, what sort of tasks would Buildbot be useful for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Have a go hero
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is an open-ended assignment: take what you''ve learned and put it to use.
    Try a small project first (but make it test-driven), with tests integrated into
    your version control system. Once you have an implementation, use code coverage
    to help you have a comprehensive test suite. If it makes sense for your project,
    use Buildbot.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We learned a lot in this chapter about code coverage and plugging our tests
    into the other automation systems that we use while writing software.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, we covered:'
  prefs: []
  type: TYPE_NORMAL
- en: What code coverage is, and what it can tell us about our tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to run Nose automatically when our version control software detects changes
    in the source code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to set up the Buildbot automated continuous integration system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we've learned about code coverage, version control hooks, and automated
    continuous integration, you're ready to tackle more or less anything. Congratulations!
  prefs: []
  type: TYPE_NORMAL
