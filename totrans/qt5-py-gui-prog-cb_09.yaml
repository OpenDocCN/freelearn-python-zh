- en: Chapter 9. Extending Our GUI with the wxPython Library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will enhance our Python GUI by using the wxPython library.
  prefs: []
  type: TYPE_NORMAL
- en: How to install the wxPython library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create our GUI in wxPython
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quickly adding controls using wxPython
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trying to embed a main wxPython app in a main tkinter app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trying to embed our tkinter GUI code into wxPython
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use Python to control two different GUI frameworks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to communicate between the two connected GUIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will introduce another Python GUI toolkit that currently
    does not ship with Python. It is called wxPython.
  prefs: []
  type: TYPE_NORMAL
- en: There are two versions of this library. The original is called Classic while
    the newest is called by its development project code name, Phoenix.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we are solely programming using Python 3, and because the new
    Phoenix project is aimed at supporting Python 3, this is the version of wxPython
    we are using in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: First, we will create a simple wxPython GUI, and then we will try to connect
    both the tkinter-based GUIs we developed in this book with the new wxPython library.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: wxPython is a Python binding to wxWidgets.
  prefs: []
  type: TYPE_NORMAL
- en: The w in wxPython stands for the Windows OS and the x stands for Unix-based
    operating systems such as Linux and OS X.
  prefs: []
  type: TYPE_NORMAL
- en: If things don't work out using these two GUI toolkits in unison, we will attempt
    to use Python to solve any problems and then we will use **Inter Process Communication**
    (**IPC**) within Python to make sure that our Python code works as we want it
    to work.
  prefs: []
  type: TYPE_NORMAL
- en: How to install the wxPython library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The wxPython library does not ship with Python, so, in order to use it, we first
    have to install it.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will show us where and how to find the right version to install
    to match both the installed version of Python and the operating system we are
    running.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The wxPython third-party library has been around for more than 17 years, which
    indicates that it is a robust library.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to use wxPython with Python 3, we have to install the wxPython Phoenix
    version.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When searching online for wxPython, we will probably find the official website
    at [www.wxpython.org](http://www.wxpython.org).
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/B04829_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If we click on the download link for MS Windows, we can see several Windows
    installers, all of which are for Python 2.x only.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/B04829_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To use wxPython with Python 3, we have to install the wxPython/Phoenix library.
    We can find the installer at the snapshot-builds link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://wxpython.org/Phoenix/snapshot-builds/](http://wxpython.org/Phoenix/snapshot-builds/)'
  prefs: []
  type: TYPE_NORMAL
- en: From here, we can select the wxPython/Phoenix version that matches both our
    versions of Python and our OS. I am using Python 3.4 running on a 64-bit Windows
    7 OS.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/B04829_09_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Python wheel (`.whl`) installer package has a numbering scheme.
  prefs: []
  type: TYPE_NORMAL
- en: For us, the most important part of this scheme is that we are installing the
    wxPython/Phoenix build that is for Python 3.4 (the cp34 in the installer name)
    and for the Windows 64-bit OS (the win_amd64 part of the installer name).
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/B04829_09_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After successfully downloading the wxPython/Phoenix package, we can now navigate
    to the directory where it resides and install this package using pip.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/B04829_09_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We have a new folder called `wx` in our Python `site-packages` folder.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/B04829_09_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`wx` is the folder name the wxPython/Phoenix library installed into. We will
    import this module into our Python code.'
  prefs: []
  type: TYPE_NORMAL
- en: We can verify that our installation worked by executing this simple demo script
    from the official wxPython/Phoenix website. The link to the official website is
    [http://wxpython.org/Phoenix/docs/html/](http://wxpython.org/Phoenix/docs/html/).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Running the preceding Python 3 script creates the following GUI using wxPython/Phoenix.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/B04829_09_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we successfully installed the correct version of the wxPython
    toolkit, which we can use with Python 3\. We found the Phoenix project for this
    GUI toolkit, which is the current and active development line. Phoenix will replace
    the Classic wxPython toolkit in time and is especially aimed at working well with
    Python 3.
  prefs: []
  type: TYPE_NORMAL
- en: After successfully installing the wxPython/Phoenix toolkit, we then created
    a GUI using this toolkit in only five lines of code.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We previously achieved the same results by using tkinter.
  prefs: []
  type: TYPE_NORMAL
- en: How to create our GUI in wxPython
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will start to create our Python GUIs using the wxPython GUI
    toolkit.
  prefs: []
  type: TYPE_NORMAL
- en: We will first recreate several of the widgets we previously created using tkinter,
    which ships with Python.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we will explore some of the widgets the wxPython GUI toolkit offers, which
    are harder to create using tkinter.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The previous recipe showed you how to install the correct version of wxPython
    that matches both your version of Python and the OS you are running.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A good place to start exploring the wxPython GUI toolkit is by going to the
    following URL: [http://wxpython.org/Phoenix/docs/html/gallery.html](http://wxpython.org/Phoenix/docs/html/gallery.html)'
  prefs: []
  type: TYPE_NORMAL
- en: This webpage displays many wxPython widgets. By clicking on any of them, we
    are taken to their documentation, which is a very nice and helpful feature to
    quickly learn about a wxPython control.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/B04829_09_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The following screenshot shows the documentation for a wxPython button widget.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/B04829_09_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can very quickly create a working window that comes with a title, a menu
    bar, and also a status bar. This status bar displays the text of a menu item when
    hovering the mouse over it. This can be achieved by writing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This creates the following GUI, which is written in Python using the wxPython
    library.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/B04829_09_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the previous code, we inherited from `wx.Frame`. In the following code, we
    inherit from `wx.Panel` and we pass in `wx.Frame` to the `__init__()` method of
    our class.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In wxPython, the top-level GUI window is called a frame. There cannot be a wxPython
    GUI without a frame and the frame has to be created as part of a wxPython application.
  prefs: []
  type: TYPE_NORMAL
- en: We create both the application and the frame at the bottom of our code.
  prefs: []
  type: TYPE_NORMAL
- en: In order to add widgets to our GUI, we have to attach them to a panel. The parent
    of the panel is the frame (our top-level window) and the parent of the widgets
    we place into the panel is the panel.
  prefs: []
  type: TYPE_NORMAL
- en: The following code adds a multiline textbox widget to a panel whose parent is
    a frame. We also add a button widget to the panel widget, which, when clicked,
    prints out some text to the textbox.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the complete code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the preceding code and clicking our wxPython button widget results
    in the following GUI output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/B04829_09_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have created our own GUI in this recipe using the mature wxPython GUI toolkit.
    In only a few lines of Python code, we were able to create a fully functional
    GUI that comes with `Minimize`, `Maximize`, and `Exit` buttons. We added a menu
    bar, a multi-line text-control, and a button. We also created a status bar that
    displays text when we select a menu item. We placed all these widgets into a Panel
    container widget.
  prefs: []
  type: TYPE_NORMAL
- en: We hooked up the button to print to the text control.
  prefs: []
  type: TYPE_NORMAL
- en: When hovering over a menu item, some text gets displayed in the status bar.
  prefs: []
  type: TYPE_NORMAL
- en: Quickly adding controls using wxPython
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will recreate the GUI we originally created earlier in this
    book with tkinter , but this time, we will be using the wxPython library. We will
    see how easy and quick it is to use the wxPython GUI toolkit to create our own
    Python GUIs.
  prefs: []
  type: TYPE_NORMAL
- en: We will not recreate the entire functionality we created in previous chapters.
    For example, we will not internationalize our wxPython GUI nor connect it to a
    MySQL database. We will recreate the visual aspects of the GUI and add some functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Comparing different libraries gives us the choice of which toolkits to use for
    our own Python GUI development and we can combine several of those toolkits in
    our own Python code.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ensure you have the wxPython module installed to follow this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, we create our Python `OOP` class as we did before using tkinter, but
    this time we inherit from and extend the `wx.Frame` class. For clarity reasons,
    we no longer call our class `OOP` but instead rename it as `MainFrame`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In wxPython, the main GUI window is called a Frame.
  prefs: []
  type: TYPE_NORMAL
- en: We also create a callback method that closes the GUI when we click the `Exit`
    Menu Item and declare a light-gray `tuple` as the background color for our GUI.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Next, we add a tabbed control to our GUI by creating an instance of the wxPython
    `Notebook` class and assign it as the parent to our own custom class named `Widgets`.
  prefs: []
  type: TYPE_NORMAL
- en: The `notebook` class instance variable has `wx.Panel` as its parent.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In wxPython, the tabbed widget is named `Notebook`, just as in tkinter.
  prefs: []
  type: TYPE_NORMAL
- en: Every `Notebook` widget needs to have a parent and, in order to lay out widgets
    in the `Notebook` in wxPython, we use different kinds of sizers.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: wxPython sizers are layout managers similar to tkinter's grid layout manager.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add controls to our Notebook page. We do this by creating a separate
    class that inherits from `wx.Panel`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We modularize our GUI code by breaking it into small methods, following Python
    OOP programming best practices, which keeps our code manageable and understandable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When using wxPython StaticBox widgets, in order to successfully lay them out,
    we use a combination of a `StaticBoxSizer` and a regular `BoxSizer`. The wxPython
    StaticBox is very similar to the tkinter LabelFrame widget.
  prefs: []
  type: TYPE_NORMAL
- en: 'Embedding a `StaticBox` within another `StaticBox` is straightforward in tkinter,
    but using wxPython is a little non-intuitive. One way to make it work is shown
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: First, we create a horizontal `BoxSizer`. Next, we create a vertical `StaticBoxSizer`
    because we want to arrange two labels in a vertical layout in this frame.
  prefs: []
  type: TYPE_NORMAL
- en: In order to arrange another widget to the right of the embedded `StaticBox`,
    we have to assign both the embedded `StaticBox` with its children controls and
    the next widget to the horizontal `BoxSizer` and then assign this `BoxSizer`,
    which now contains both our embedded `StaticBox` and our other widgets, to the
    main `StaticBox`.
  prefs: []
  type: TYPE_NORMAL
- en: Does this sound confusing?
  prefs: []
  type: TYPE_NORMAL
- en: You have to just experiment with these sizers to get a feel for how to use them.
    Start with the code for this recipe and comment out some code, or modify some
    x and y coordinates to see the effects.
  prefs: []
  type: TYPE_NORMAL
- en: It is also good to read the official wxPython documentation to learn more.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The important thing is knowing where in the code to add to the different sizers
    in order to achieve the layout we wish.
  prefs: []
  type: TYPE_NORMAL
- en: In order to create the second `StaticBox` below the first, we create separate
    `StaticBoxSizers` and assign them to the same panel.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The following code instantiates the main event loop which runs our wxPython
    GUI program.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The final result of our wxPython GUI looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/B04829_09_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We design and lay out our wxPython GUI in several classes.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have done this in the bottom section of our Python module, we create
    an instance of the wxPython application. Next, we instantiate our wxPython GUI
    code.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we call the main GUI event loop that executes all of our Python
    code running within this application process. This displays our wxPython GUI.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Whatever code we place between the creation of the app and calling its main
    event loop becomes our wxPython GUI.
  prefs: []
  type: TYPE_NORMAL
- en: 'It might take some time to really get used to the wxPython library and its
    API, but once we understand how to use it, this library is really fun and a powerful
    tool to build our own Python GUIs. There also is a visual designer tool that can
    be used with wxPython: [http://www.cae.tntech.edu/help/programming/wxdesigner-getting-started/view](http://www.cae.tntech.edu/help/programming/wxdesigner-getting-started/view)'
  prefs: []
  type: TYPE_NORMAL
- en: This recipe used OOP to learn how to use the wxPython GUI toolkit.
  prefs: []
  type: TYPE_NORMAL
- en: Trying to embed a main wxPython app in a main tkinter app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have created the same GUI using both the Python's built-in tkinter
    library as well as the wxPython wrapper of the wxWidgets library, we really do
    need to combine the GUIs we created using these technologies.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Both the wxPython and the tkinter libraries have their own advantages. In online
    forums such as [http://stackoverflow.com/](http://stackoverflow.com/), we often
    see questions such as, which one is better? Which GUI toolkit should I use? This
    suggests that we have to make an "either-or" decision. We do not have to make
    such a decision.
  prefs: []
  type: TYPE_NORMAL
- en: One of the main challenges in doing so is that each GUI toolkit has to have
    its own event loop.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will try to embed a simple wxPython GUI by calling it from
    our tkinter GUI.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will reuse the tkinter GUI we built in a previous recipe in [Chapter 1](ch01.html
    "Chapter 1. Creating the GUI Form and Adding Widgets"), *Creating the GUI Form
    and Adding Widgets*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are starting from a simple tkinter GUI that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/B04829_09_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, we will try to invoke a simple wxPython GUI, which we created in a previous
    recipe in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the entire code to do this in a simple, non-OOP way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Running the preceding code starts a wxPython GUI from our tkinter GUI after
    clicking the tkinter `Button` control.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/B04829_09_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The important part is that we placed the entire wxPython code into its own function,
    which we named `def wxPythonApp()`.
  prefs: []
  type: TYPE_NORMAL
- en: In the callback function for the button click-event, we simply call this code.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One thing to note is that we have to close the wxPython GUI before we can continue
    using the tkinter GUI.
  prefs: []
  type: TYPE_NORMAL
- en: Trying to embed our tkinter GUI code into wxPython
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will go in the opposite direction to the previous recipe
    and try to call our tkinter GUI code from within a wxPython GUI.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will reuse some of the wxPython GUI code we created in a previous recipe
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will start from a simple wxPython GUI, which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/B04829_09_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, we will try to invoke a simple tkinter GUI.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the entire code to do this in a simple, non-OOP way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Running the preceding code starts a tkinter GUI from our wxPython GUI after
    clicking the wxPython `Button` widget. We can then enter text into the tkinter
    textbox. By clicking its button, the button text gets updated with the name.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/B04829_09_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After starting the tkinter event loop, the wxPython GUI is still responsive
    because we can type into the `TextCtrl` widget while the tkinter GUI is up and
    running.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous recipe, we could not use our tkinter GUI until we had closed
    the wxPython GUI. Being aware of this difference can help our design decisions
    if we want to combine the two Python GUI technologies.
  prefs: []
  type: TYPE_NORMAL
- en: We can also create several tkinter GUI instances by clicking the wxPython GUI
    button several times. We cannot, however, close the wxPython GUI while any tkinter
    GUIs are still running. We have to close them first.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/B04829_09_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe we went in the opposite direction to the previous recipe by first
    creating a GUI using wxPython and then, from wit-hin it, creating several GUI
    instances built using tkinter.
  prefs: []
  type: TYPE_NORMAL
- en: The wxPython GUI remained responsive while one or more tkinter GUIs were running.
    However, clicking the tkinter button only updated its button text in the first
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: How to use Python to control two different GUI frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will explore ways to control the tkinter and wxPython GUI
    frameworks from Python. We have already used the Python threading module to keep
    our GUI responsive in the previous chapter, so here we will attempt to use the
    same approach.
  prefs: []
  type: TYPE_NORMAL
- en: We will see that things don't always work in a way that would be intuitive.
  prefs: []
  type: TYPE_NORMAL
- en: However, we will improve our tkinter GUI from being unresponsive while we invoke
    an instance of the wxPython GUI from within it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe will extend a previous recipe from this chapter in which we tried
    to embed a main wxPython GUI into our tkinter GUI.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we created an instance of a wxPython GUI from our tkinter GUI, we could
    no longer use the tkinter GUI controls until we closed the one instance of the
    wxPython GUI. Let's improve on this now.
  prefs: []
  type: TYPE_NORMAL
- en: Our first attempt might be to use threading from the tkinter button callback
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, our code might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: At first, this seems to be working, which would be intuitive as the tkinter
    controls are no longer disabled and we can create several instances of the wxPython
    GUI by clicking the button. We can also type into and select the other tkinter
    widgets.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/B04829_09_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: However, once we try to close the GUIs, we get an error from wxWidgets, and
    our Python executable crashes.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/B04829_09_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In order to avoid this, instead of trying to run the entire wxPython application
    in a thread, we can change the code to make only the wxPython `app.MainLoop` run
    in a thread.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We first tried to run the entire wxPython GUI application in a thread, but this
    did not work as the wxPython main event loop expects to be the main thread of
    the application.
  prefs: []
  type: TYPE_NORMAL
- en: We found a workaround for this by only running the wxPython `app.MainLoop` in
    a thread, which tricks it into believing it is the main thread.
  prefs: []
  type: TYPE_NORMAL
- en: One side-effect of this approach is that we can no longer individually close
    all of the wxPython GUI instances. At least one of them only closes when we close
    the wxPython GUI which created the threads as daemons.
  prefs: []
  type: TYPE_NORMAL
- en: I am not quite sure why this is. Intuitively, one might expect to be able to
    close all daemon threads without having to wait for the main thread that created
    them to close first.
  prefs: []
  type: TYPE_NORMAL
- en: It possibly has to do with a reference counter not having been set to zero while
    our main thread is still running.
  prefs: []
  type: TYPE_NORMAL
- en: On a pragmatic level, this is how it currently works.
  prefs: []
  type: TYPE_NORMAL
- en: How to communicate between the two connected GUIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipes, we found ways to connect a wxPython GUI with a tkinter
    GUI, invoking one from the other and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: While both GUIs were successfully running at the same time, they did not really
    communicate with each other as they were only launching one another.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will explore ways to make the two GUIs talk to each other.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Reading one of the previous recipes might be a good preparation for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will use a slightly modified GUI code compared to the previous
    recipe, but most of the basic GUI-building code is the same.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous recipes, one of our main challenges was how to combine two GUI
    technologies that were designed to be the one-and-only GUI toolkit for an application.
    We found various simple ways to combine them.
  prefs: []
  type: TYPE_NORMAL
- en: We will again launch the wxPython GUI from a tkinter GUI main event loop and
    start the wxPython GUI in its own thread that runs within the tkinter process.
  prefs: []
  type: TYPE_NORMAL
- en: In order to do this, we will use a shared global multiprocessing Python queue.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While it is often best to avoid global data in this recipe, they are a practical
    solution and Python globals are really only global in the module they have been
    declared in.
  prefs: []
  type: TYPE_NORMAL
- en: Here is the Python code that makes the two GUIs communicate with each other
    to a certain degree. In order to save space, this is not pure OOP code.
  prefs: []
  type: TYPE_NORMAL
- en: We are also not showing the creation code for all of the widgets. That code
    is the same as in previous recipes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Running the preceding code first creates the tkinter part of the program and,
    when we click the button in this GUI, it runs the wxPython GUI. Both are running
    at the same time as before, but this time, there is an extra level of communication
    between the two GUIs.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/B04829_09_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The tkinter GUI is shown on the left-hand side of the preceding screenshot and,
    by clicking the **Call wxPython GUI** button, we invoke an instance of the wxPython
    GUI. We can create several instances by clicking the button several times.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All of the created GUIs remain responsive. They do not crash nor freeze.
  prefs: []
  type: TYPE_NORMAL
- en: Clicking the **Print** button on any of the wxPython GUI instances writes one
    sentence to its own `TextCtrl` widget and then writes another line to itself as
    well as to the tkinter GUI. You will have to scroll up to see the first sentence
    in the wxPython GUI.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The way this works is by using a module-level queue and a tkinter `Text` widget
  prefs: []
  type: TYPE_NORMAL
- en: One important element to note is that we create a thread to run the wxPython
    `app.MainLoop`, as we did in the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We create a class that inherits from `wx.Panel` and name it `GUI`. We then instantiate
    an instance of this class in the preceding code.
  prefs: []
  type: TYPE_NORMAL
- en: We create a button click-event callback method in this class, which then calls
    the procedural code that was written above it. Because of this, the class has
    access to the functions and can write to the shared queue.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We first check if the data has been placed in the shared queue in the preceding
    method and, if that is the case, we then print the common data to both GUIs.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `putDataIntoQueue()` line places data into the queue and `readDataFromQueue()`
    reads it back out saving it in the `data` variable.
  prefs: []
  type: TYPE_NORMAL
- en: '`text.insert(''0.0'', data)` is the line that writes this data into the tkinter
    GUI from the **Print** button''s wxPython callback method.'
  prefs: []
  type: TYPE_NORMAL
- en: Following are the procedural functions (not methods, for they are not bound)
    that are being called in the code and that make it work.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We are using a simple Boolean flag named `dataInQueue` to communicate when the
    data is available in the queue.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we have successfully combined the two GUIs we created in a similar
    fashion, but previously standalone and not talking to each other. However, in
    this recipe, we connected them further by making one GUI launch another and, via
    a simple multiprocessing Python queue mechanism, we were able to make them communicate
    with each other, writing data from a shared queue into both GUIs.
  prefs: []
  type: TYPE_NORMAL
- en: There are many very advanced and complicated technologies available to connect
    different processes, threads, pools, locks, pipes, TCP/IP connections, and so
    on.
  prefs: []
  type: TYPE_NORMAL
- en: In the Pythonic spirit, we found a simple solution that works for us. Once our
    code becomes more complicated, we might have to refactor it, but this is a good
    beginning.
  prefs: []
  type: TYPE_NORMAL
