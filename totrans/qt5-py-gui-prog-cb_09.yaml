- en: Chapter 9. Extending Our GUI with the wxPython Library
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章 使用wxPython库扩展我们的GUI
- en: In this chapter, we will enhance our Python GUI by using the wxPython library.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过使用wxPython库来增强我们的Python GUI。
- en: How to install the wxPython library
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何安装 wxPython 库
- en: How to create our GUI in wxPython
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在 wxPython 中创建我们的 GUI
- en: Quickly adding controls using wxPython
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 wxPython 快速添加控件
- en: Trying to embed a main wxPython app in a main tkinter app
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试将主 wxPython 应用嵌入到主 tkinter 应用中
- en: Trying to embed our tkinter GUI code into wxPython
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试将我们的tkinter GUI代码嵌入到wxPython中
- en: How to use Python to control two different GUI frameworks
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用Python控制两个不同的GUI框架
- en: How to communicate between the two connected GUIs
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在两个连接的GUI之间进行通信
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In this chapter, we will introduce another Python GUI toolkit that currently
    does not ship with Python. It is called wxPython.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍另一个目前不随Python一起提供的Python GUI工具包。它被称为wxPython。
- en: There are two versions of this library. The original is called Classic while
    the newest is called by its development project code name, Phoenix.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这个库有两个版本。原始版本被称为Classic，而最新版本则被称为其开发项目的代号，Phoenix。
- en: In this book, we are solely programming using Python 3, and because the new
    Phoenix project is aimed at supporting Python 3, this is the version of wxPython
    we are using in this chapter.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们仅使用 Python 3 进行编程，并且由于新的凤凰项目旨在支持 Python 3，因此这是我们本章使用的 wxPython 版本。
- en: First, we will create a simple wxPython GUI, and then we will try to connect
    both the tkinter-based GUIs we developed in this book with the new wxPython library.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个简单的 wxPython 图形用户界面，然后我们将尝试将本书中开发的基于 tkinter 的 GUI 与新的 wxPython 库连接起来。
- en: Note
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: wxPython is a Python binding to wxWidgets.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: wxPython 是 wxWidgets 的 Python 绑定。
- en: The w in wxPython stands for the Windows OS and the x stands for Unix-based
    operating systems such as Linux and OS X.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: wxPython 中的 w 代表 Windows 操作系统，而 x 代表基于 Unix 的操作系统，例如 Linux 和 OS X。
- en: If things don't work out using these two GUI toolkits in unison, we will attempt
    to use Python to solve any problems and then we will use **Inter Process Communication**
    (**IPC**) within Python to make sure that our Python code works as we want it
    to work.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用这两个GUI工具包同时操作不成功，我们将尝试使用Python来解决任何问题，然后我们将在Python中使用**进程间通信**（**IPC**）来确保我们的Python代码按预期工作。
- en: How to install the wxPython library
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何安装 wxPython 库
- en: The wxPython library does not ship with Python, so, in order to use it, we first
    have to install it.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: wxPython 库并非随 Python 一起安装，因此，为了使用它，我们首先必须安装它。
- en: This recipe will show us where and how to find the right version to install
    to match both the installed version of Python and the operating system we are
    running.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱将向我们展示在哪里以及如何找到正确的版本进行安装，以确保与所安装的Python版本和正在运行的操作系统相匹配。
- en: Note
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: The wxPython third-party library has been around for more than 17 years, which
    indicates that it is a robust library.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: wxPython第三方库已经存在超过17年，这表明它是一个健壮的库。
- en: Getting ready
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: In order to use wxPython with Python 3, we have to install the wxPython Phoenix
    version.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用 wxPython 与 Python 3 兼容，我们必须安装 wxPython Phoenix 版本。
- en: How to do it...
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: When searching online for wxPython, we will probably find the official website
    at [www.wxpython.org](http://www.wxpython.org).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在网上搜索 wxPython 时，我们可能会找到官方网站 [www.wxpython.org](http://www.wxpython.org)。
- en: '![How to do it...](img/B04829_09_01.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_09_01.jpg)'
- en: If we click on the download link for MS Windows, we can see several Windows
    installers, all of which are for Python 2.x only.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们点击 MS Windows 的下载链接，我们可以看到几个 Windows 安装程序，所有这些安装程序都仅适用于 Python 2.x。
- en: '![How to do it...](img/B04829_09_02.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_09_02.jpg)'
- en: 'To use wxPython with Python 3, we have to install the wxPython/Phoenix library.
    We can find the installer at the snapshot-builds link:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Python 3中使用wxPython，我们必须安装wxPython/Phoenix库。我们可以在快照构建链接中找到安装程序：
- en: '[http://wxpython.org/Phoenix/snapshot-builds/](http://wxpython.org/Phoenix/snapshot-builds/)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://wxpython.org/Phoenix/snapshot-builds/](http://wxpython.org/Phoenix/snapshot-builds/)'
- en: From here, we can select the wxPython/Phoenix version that matches both our
    versions of Python and our OS. I am using Python 3.4 running on a 64-bit Windows
    7 OS.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，我们可以选择与我们的Python版本和操作系统版本相匹配的wxPython/Phoenix版本。我正在使用运行在64位Windows 7操作系统上的Python
    3.4。
- en: '![How to do it...](img/B04829_09_03.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_09_03.jpg)'
- en: The Python wheel (`.whl`) installer package has a numbering scheme.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Python 轮子（`.whl`）安装包有一个编号方案。
- en: For us, the most important part of this scheme is that we are installing the
    wxPython/Phoenix build that is for Python 3.4 (the cp34 in the installer name)
    and for the Windows 64-bit OS (the win_amd64 part of the installer name).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们来说，这个方案最重要的部分是我们正在安装适用于 Python 3.4（安装程序名称中的 cp34）和 Windows 64 位操作系统（安装程序名称中的
    win_amd64 部分）的 wxPython/Phoenix 构建。
- en: '![How to do it...](img/B04829_09_04.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_09_04.jpg)'
- en: After successfully downloading the wxPython/Phoenix package, we can now navigate
    to the directory where it resides and install this package using pip.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功下载 wxPython/Phoenix 软件包后，我们现在可以导航到它所在的目录，并使用 pip 安装此软件包。
- en: '![How to do it...](img/B04829_09_05.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_09_05.jpg)'
- en: We have a new folder called `wx` in our Python `site-packages` folder.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在Python的`site-packages`文件夹中有一个名为`wx`的新文件夹。
- en: '![How to do it...](img/B04829_09_06.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_09_06.jpg)'
- en: Note
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`wx` is the folder name the wxPython/Phoenix library installed into. We will
    import this module into our Python code.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`wx` 是 wxPython/Phoenix 库安装到的文件夹名称。我们将把这个模块导入到我们的 Python 代码中。'
- en: We can verify that our installation worked by executing this simple demo script
    from the official wxPython/Phoenix website. The link to the official website is
    [http://wxpython.org/Phoenix/docs/html/](http://wxpython.org/Phoenix/docs/html/).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过执行来自官方 wxPython/Phoenix 网站的简单演示脚本来验证我们的安装是否成功。官方网站的链接是 [http://wxpython.org/Phoenix/docs/html/](http://wxpython.org/Phoenix/docs/html/)。
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Running the preceding Python 3 script creates the following GUI using wxPython/Phoenix.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的 Python 3 脚本将使用 wxPython/Phoenix 创建以下 GUI。
- en: '![How to do it...](img/B04829_09_07.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_09_07.jpg)'
- en: How it works...
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we successfully installed the correct version of the wxPython
    toolkit, which we can use with Python 3\. We found the Phoenix project for this
    GUI toolkit, which is the current and active development line. Phoenix will replace
    the Classic wxPython toolkit in time and is especially aimed at working well with
    Python 3.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们成功安装了适用于 Python 3 的正确版本的 wxPython 工具包，我们可以用它来使用 Python 3。我们找到了这个 GUI
    工具包的 Phoenix 项目，它是当前活跃的开发线。Phoenix 将在适当的时候取代 Classic wxPython 工具包，并且特别针对与 Python
    3 的良好兼容性。
- en: After successfully installing the wxPython/Phoenix toolkit, we then created
    a GUI using this toolkit in only five lines of code.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功安装了 wxPython/Phoenix 工具包之后，我们只用五行代码就创建了图形用户界面。
- en: Note
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: We previously achieved the same results by using tkinter.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前通过使用tkinter实现了相同的结果。
- en: How to create our GUI in wxPython
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何在 wxPython 中创建我们的 GUI
- en: In this recipe, we will start to create our Python GUIs using the wxPython GUI
    toolkit.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将开始使用 wxPython GUI 工具包创建我们的 Python GUI。
- en: We will first recreate several of the widgets we previously created using tkinter,
    which ships with Python.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先重新创建我们之前使用tkinter创建的几个小部件，tkinter是Python自带的一个库。
- en: Then, we will explore some of the widgets the wxPython GUI toolkit offers, which
    are harder to create using tkinter.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将探讨wxPython GUI工具包提供的一些小部件，这些小部件使用tkinter创建起来较为困难。
- en: Getting ready
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: The previous recipe showed you how to install the correct version of wxPython
    that matches both your version of Python and the OS you are running.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的配方向您展示了如何安装与您所使用的 Python 版本和操作系统相匹配的正确版本的 wxPython。
- en: How to do it...
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'A good place to start exploring the wxPython GUI toolkit is by going to the
    following URL: [http://wxpython.org/Phoenix/docs/html/gallery.html](http://wxpython.org/Phoenix/docs/html/gallery.html)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 开始探索 wxPython GUI 工具包的好地方是访问以下网址：[http://wxpython.org/Phoenix/docs/html/gallery.html](http://wxpython.org/Phoenix/docs/html/gallery.html)
- en: This webpage displays many wxPython widgets. By clicking on any of them, we
    are taken to their documentation, which is a very nice and helpful feature to
    quickly learn about a wxPython control.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这个网页展示了多个wxPython小部件。点击任何一个，我们就会被带到它们的文档页面，这是一个非常不错且实用的功能，可以快速了解wxPython控件。
- en: '![How to do it...](img/B04829_09_08.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_09_08.jpg)'
- en: The following screenshot shows the documentation for a wxPython button widget.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了 wxPython 按钮小部件的文档。
- en: '![How to do it...](img/B04829_09_09.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_09_09.jpg)'
- en: 'We can very quickly create a working window that comes with a title, a menu
    bar, and also a status bar. This status bar displays the text of a menu item when
    hovering the mouse over it. This can be achieved by writing the following code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以非常快速地创建一个带有标题、菜单栏和状态栏的工作窗口。当鼠标悬停在菜单项上时，状态栏会显示该菜单项的文本。这可以通过编写以下代码实现：
- en: '[PRE1]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This creates the following GUI, which is written in Python using the wxPython
    library.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了一个以下GUI，它使用wxPython库用Python编写。
- en: '![How to do it...](img/B04829_09_10.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_09_10.jpg)'
- en: In the previous code, we inherited from `wx.Frame`. In the following code, we
    inherit from `wx.Panel` and we pass in `wx.Frame` to the `__init__()` method of
    our class.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，我们继承了`wx.Frame`。在下面的代码中，我们继承了`wx.Panel`并将`wx.Frame`传递给我们的类`__init__()`方法。
- en: Note
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: In wxPython, the top-level GUI window is called a frame. There cannot be a wxPython
    GUI without a frame and the frame has to be created as part of a wxPython application.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在wxPython中，顶级GUI窗口被称为框架。没有框架就无法创建wxPython GUI，并且框架必须作为wxPython应用程序的一部分来创建。
- en: We create both the application and the frame at the bottom of our code.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在我们的代码底部创建了应用和框架。
- en: In order to add widgets to our GUI, we have to attach them to a panel. The parent
    of the panel is the frame (our top-level window) and the parent of the widgets
    we place into the panel is the panel.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将小部件添加到我们的图形用户界面(GUI)中，我们必须将它们附加到一个面板上。面板的父级是框架（我们的顶级窗口），而我们放置到面板中的小部件的父级是面板。
- en: The following code adds a multiline textbox widget to a panel whose parent is
    a frame. We also add a button widget to the panel widget, which, when clicked,
    prints out some text to the textbox.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码向一个父级为框架的面板添加了一个多行文本框小部件。我们还向面板小部件添加了一个按钮小部件，当点击该按钮时，会在文本框中打印出一些文本。
- en: 'Here is the complete code:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是完整的代码：
- en: '[PRE2]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Running the preceding code and clicking our wxPython button widget results
    in the following GUI output:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码并点击我们的 wxPython 按钮小部件，将产生以下 GUI 输出：
- en: '![How to do it...](img/B04829_09_11.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_09_11.jpg)'
- en: How it works...
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We have created our own GUI in this recipe using the mature wxPython GUI toolkit.
    In only a few lines of Python code, we were able to create a fully functional
    GUI that comes with `Minimize`, `Maximize`, and `Exit` buttons. We added a menu
    bar, a multi-line text-control, and a button. We also created a status bar that
    displays text when we select a menu item. We placed all these widgets into a Panel
    container widget.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们使用成熟的 wxPython GUI 工具包创建了我们自己的 GUI。仅用几行 Python 代码，我们就能够创建一个带有 `最小化`、`最大化`
    和 `退出` 按钮的完整功能 GUI。我们添加了一个菜单栏、一个多行文本控件和一个按钮。我们还创建了一个状态栏，当选择菜单项时它会显示文本。我们将所有这些小部件放置在一个面板容器小部件中。
- en: We hooked up the button to print to the text control.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将打印按钮连接到了文本控件。
- en: When hovering over a menu item, some text gets displayed in the status bar.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当鼠标悬停在菜单项上时，一些文本会在状态栏中显示。
- en: Quickly adding controls using wxPython
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 wxPython 快速添加控件
- en: In this recipe, we will recreate the GUI we originally created earlier in this
    book with tkinter , but this time, we will be using the wxPython library. We will
    see how easy and quick it is to use the wxPython GUI toolkit to create our own
    Python GUIs.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将重新创建本书早期使用 tkinter 创建的 GUI，但这次我们将使用 wxPython 库。我们将看到使用 wxPython GUI
    工具包创建自己的 Python GUI 是多么简单快捷。
- en: We will not recreate the entire functionality we created in previous chapters.
    For example, we will not internationalize our wxPython GUI nor connect it to a
    MySQL database. We will recreate the visual aspects of the GUI and add some functionality.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会重新创建在前面章节中创建的全部功能。例如，我们不会国际化我们的wxPython GUI，也不会将其连接到MySQL数据库。我们将重新创建GUI的视觉方面，并添加一些功能。
- en: Note
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: Comparing different libraries gives us the choice of which toolkits to use for
    our own Python GUI development and we can combine several of those toolkits in
    our own Python code.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 比较不同的库为我们提供了选择用于我们自己的Python GUI开发的工具包，我们可以在自己的Python代码中结合使用这些工具包中的几个。
- en: Getting ready
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Ensure you have the wxPython module installed to follow this recipe.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您已安装 wxPython 模块以遵循此配方。
- en: How to do it...
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: First, we create our Python `OOP` class as we did before using tkinter, but
    this time we inherit from and extend the `wx.Frame` class. For clarity reasons,
    we no longer call our class `OOP` but instead rename it as `MainFrame`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们像之前使用tkinter一样创建我们的Python `OOP` 类，但这次我们继承并扩展了 `wx.Frame` 类。为了清晰起见，我们不再将我们的类命名为
    `OOP`，而是将其重命名为 `MainFrame`。
- en: Note
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In wxPython, the main GUI window is called a Frame.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在wxPython中，主要的GUI窗口被称为Frame。
- en: We also create a callback method that closes the GUI when we click the `Exit`
    Menu Item and declare a light-gray `tuple` as the background color for our GUI.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还创建了一个回调方法，当点击`退出`菜单项时关闭GUI，并声明浅灰色`元组`作为我们GUI的背景颜色。
- en: '[PRE3]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Next, we add a tabbed control to our GUI by creating an instance of the wxPython
    `Notebook` class and assign it as the parent to our own custom class named `Widgets`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过创建一个 wxPython `Notebook` 类的实例并将其分配为我们自定义的名为 `Widgets` 的类的父类，向我们的 GUI
    添加一个标签控制。
- en: The `notebook` class instance variable has `wx.Panel` as its parent.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`notebook` 类实例变量以 `wx.Panel` 作为其父类。'
- en: '[PRE4]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: In wxPython, the tabbed widget is named `Notebook`, just as in tkinter.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在wxPython中，标签控件被命名为`Notebook`，就像在tkinter中一样。
- en: Every `Notebook` widget needs to have a parent and, in order to lay out widgets
    in the `Notebook` in wxPython, we use different kinds of sizers.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`Notebook`小部件都需要有一个父级，并且为了在wxPython中的`Notebook`中布局小部件，我们使用不同类型的布局管理器。
- en: Note
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: wxPython sizers are layout managers similar to tkinter's grid layout manager.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: wxPython的sizer是类似于tkinter的网格布局管理器的布局管理器。
- en: Next, we add controls to our Notebook page. We do this by creating a separate
    class that inherits from `wx.Panel`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在笔记本页面中添加控件。我们通过创建一个继承自`wx.Panel`的单独类来实现这一点。
- en: '[PRE5]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We modularize our GUI code by breaking it into small methods, following Python
    OOP programming best practices, which keeps our code manageable and understandable.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将GUI代码拆分成小方法来模块化它，遵循Python面向对象编程的最佳实践，这使得我们的代码易于管理和理解。
- en: '[PRE6]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: When using wxPython StaticBox widgets, in order to successfully lay them out,
    we use a combination of a `StaticBoxSizer` and a regular `BoxSizer`. The wxPython
    StaticBox is very similar to the tkinter LabelFrame widget.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 wxPython StaticBox 小部件时，为了成功布局它们，我们使用 `StaticBoxSizer` 和常规的 `BoxSizer` 的组合。wxPython
    的 StaticBox 小部件与 tkinter 的 LabelFrame 小部件非常相似。
- en: 'Embedding a `StaticBox` within another `StaticBox` is straightforward in tkinter,
    but using wxPython is a little non-intuitive. One way to make it work is shown
    as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在tkinter中，将一个`StaticBox`嵌入另一个`StaticBox`是直接的，但使用wxPython则稍微不那么直观。使其工作的一种方法如下所示：
- en: '[PRE7]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: First, we create a horizontal `BoxSizer`. Next, we create a vertical `StaticBoxSizer`
    because we want to arrange two labels in a vertical layout in this frame.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个水平 `BoxSizer`。接下来，我们创建一个垂直 `StaticBoxSizer`，因为我们想在这个框架中将两个标签以垂直布局排列。
- en: In order to arrange another widget to the right of the embedded `StaticBox`,
    we have to assign both the embedded `StaticBox` with its children controls and
    the next widget to the horizontal `BoxSizer` and then assign this `BoxSizer`,
    which now contains both our embedded `StaticBox` and our other widgets, to the
    main `StaticBox`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将另一个小部件安排在嵌入的`StaticBox`右侧，我们必须将嵌入的`StaticBox`及其子控件以及下一个小部件都分配给水平`BoxSizer`，然后将这个`BoxSizer`（现在包含我们的嵌入`StaticBox`和我们的其他小部件）分配给主`StaticBox`。
- en: Does this sound confusing?
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来是不是很困惑？
- en: You have to just experiment with these sizers to get a feel for how to use them.
    Start with the code for this recipe and comment out some code, or modify some
    x and y coordinates to see the effects.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须亲自尝试这些尺寸调整器，以了解如何使用它们。从本菜谱的代码开始，注释掉一些代码，或者修改一些 x 和 y 坐标，以观察效果。
- en: It is also good to read the official wxPython documentation to learn more.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以阅读官方的 wxPython 文档来获取更多信息。
- en: Note
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: The important thing is knowing where in the code to add to the different sizers
    in order to achieve the layout we wish.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要知道在代码中添加到不同尺寸调整器的位置，以便实现我们想要的布局。
- en: In order to create the second `StaticBox` below the first, we create separate
    `StaticBoxSizers` and assign them to the same panel.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在第一个`StaticBox`下方创建第二个，我们创建单独的`StaticBoxSizers`并将它们分配到同一个面板。
- en: '[PRE8]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The following code instantiates the main event loop which runs our wxPython
    GUI program.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码实例化了主事件循环，该循环运行我们的 wxPython 图形用户界面程序。
- en: '[PRE9]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The final result of our wxPython GUI looks like this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 wxPython 构建的 GUI 最终效果如下：
- en: '![How to do it...](img/B04829_09_12.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_09_12.jpg)'
- en: How it works...
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We design and lay out our wxPython GUI in several classes.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在几个类中设计和布局我们的 wxPython GUI。
- en: Once we have done this in the bottom section of our Python module, we create
    an instance of the wxPython application. Next, we instantiate our wxPython GUI
    code.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们在 Python 模块的底部部分完成这个操作，我们就创建一个 wxPython 应用程序的实例。接下来，我们实例化我们的 wxPython GUI
    代码。
- en: After that, we call the main GUI event loop that executes all of our Python
    code running within this application process. This displays our wxPython GUI.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们调用主GUI事件循环，该循环执行此应用程序进程内运行的所有Python代码。这显示了我们的wxPython GUI。
- en: Note
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: Whatever code we place between the creation of the app and calling its main
    event loop becomes our wxPython GUI.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们在创建应用程序和调用其主事件循环之间放置什么代码，它都将成为我们的wxPython GUI。
- en: 'It might take some time to really get used to the wxPython library and its
    API, but once we understand how to use it, this library is really fun and a powerful
    tool to build our own Python GUIs. There also is a visual designer tool that can
    be used with wxPython: [http://www.cae.tntech.edu/help/programming/wxdesigner-getting-started/view](http://www.cae.tntech.edu/help/programming/wxdesigner-getting-started/view)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 真正熟悉 wxPython 库及其 API 可能需要一些时间，但一旦我们了解了如何使用它，这个库就变得非常有趣，并且是构建我们自己的 Python 图形用户界面（GUIs）的强大工具。wxPython
    还有一个可以与之配合使用的可视化设计工具：[http://www.cae.tntech.edu/help/programming/wxdesigner-getting-started/view](http://www.cae.tntech.edu/help/programming/wxdesigner-getting-started/view)
- en: This recipe used OOP to learn how to use the wxPython GUI toolkit.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱使用面向对象编程（OOP）来学习如何使用 wxPython 图形用户界面（GUI）工具包。
- en: Trying to embed a main wxPython app in a main tkinter app
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试将主 wxPython 应用嵌入到主 tkinter 应用中
- en: Now that we have created the same GUI using both the Python's built-in tkinter
    library as well as the wxPython wrapper of the wxWidgets library, we really do
    need to combine the GUIs we created using these technologies.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经使用Python内置的tkinter库以及wxWidgets库的wxPython包装器创建了相同的GUI，我们确实需要将这些技术创建的GUI结合起来。
- en: Note
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: Both the wxPython and the tkinter libraries have their own advantages. In online
    forums such as [http://stackoverflow.com/](http://stackoverflow.com/), we often
    see questions such as, which one is better? Which GUI toolkit should I use? This
    suggests that we have to make an "either-or" decision. We do not have to make
    such a decision.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: wxPython 和 tkinter 库各自都有其优势。在诸如 [http://stackoverflow.com/](http://stackoverflow.com/)
    这样的在线论坛中，我们经常看到类似的问题，比如：哪一个更好？我应该使用哪个 GUI 工具包？这表明我们必须做出一个“非此即彼”的选择。我们不必做出这样的决定。
- en: One of the main challenges in doing so is that each GUI toolkit has to have
    its own event loop.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这样做的主要挑战之一是，每个GUI工具包都必须有自己的事件循环。
- en: In this recipe, we will try to embed a simple wxPython GUI by calling it from
    our tkinter GUI.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将尝试通过从我们的tkinter GUI中调用它来嵌入一个简单的wxPython GUI。
- en: Getting ready
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: We will reuse the tkinter GUI we built in a previous recipe in [Chapter 1](ch01.html
    "Chapter 1. Creating the GUI Form and Adding Widgets"), *Creating the GUI Form
    and Adding Widgets*.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重用我们在[第1章](ch01.html "第1章。创建GUI表单和添加小部件")中构建的tkinter GUI，即*创建GUI表单和添加小部件*。
- en: How to do it...
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We are starting from a simple tkinter GUI that looks like this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个看起来是这样的简单tkinter GUI开始：
- en: '![How to do it...](img/B04829_09_13.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_09_13.jpg)'
- en: Next, we will try to invoke a simple wxPython GUI, which we created in a previous
    recipe in this chapter.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将尝试调用一个简单的 wxPython 图形用户界面（GUI），这是我们在这个章节之前的一个菜谱中创建的。
- en: 'This is the entire code to do this in a simple, non-OOP way:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这是用简单、非面向对象的方式完成此操作的完整代码：
- en: '[PRE10]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Running the preceding code starts a wxPython GUI from our tkinter GUI after
    clicking the tkinter `Button` control.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码，在点击tkinter的`Button`控件后，将从一个tkinter GUI启动一个wxPython GUI。
- en: '![How to do it...](img/B04829_09_14.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_09_14.jpg)'
- en: How it works...
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The important part is that we placed the entire wxPython code into its own function,
    which we named `def wxPythonApp()`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，我们将整个 wxPython 代码放入了一个名为 `def wxPythonApp()` 的独立函数中。
- en: In the callback function for the button click-event, we simply call this code.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在按钮点击事件的回调函数中，我们只需调用此代码。
- en: Note
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: One thing to note is that we have to close the wxPython GUI before we can continue
    using the tkinter GUI.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一点是，在继续使用 tkinter GUI 之前，我们必须关闭 wxPython GUI。
- en: Trying to embed our tkinter GUI code into wxPython
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试将我们的tkinter GUI代码嵌入到wxPython中
- en: In this recipe, we will go in the opposite direction to the previous recipe
    and try to call our tkinter GUI code from within a wxPython GUI.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将与之前的菜谱相反的方向，尝试从wxPython GUI内部调用我们的tkinter GUI代码。
- en: Getting ready
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: We will reuse some of the wxPython GUI code we created in a previous recipe
    in this chapter.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重用本章之前的一个菜谱中创建的一些 wxPython GUI 代码。
- en: How to do it...
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We will start from a simple wxPython GUI, which looks like this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从简单的 wxPython 图形用户界面（GUI）开始，它看起来像这样：
- en: '![How to do it...](img/B04829_09_15.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_09_15.jpg)'
- en: Next, we will try to invoke a simple tkinter GUI.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将尝试调用一个简单的tkinter GUI。
- en: 'This is the entire code to do this in a simple, non-OOP way:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这是用简单、非面向对象的方式完成此操作的完整代码：
- en: '[PRE11]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Running the preceding code starts a tkinter GUI from our wxPython GUI after
    clicking the wxPython `Button` widget. We can then enter text into the tkinter
    textbox. By clicking its button, the button text gets updated with the name.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码，在点击 wxPython 的 `Button` 控件后，将启动一个 tkinter GUI。然后我们可以将文本输入到 tkinter 的文本框中。通过点击其按钮，按钮文本会更新为相应的名字。
- en: '![How to do it...](img/B04829_09_16.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_09_16.jpg)'
- en: After starting the tkinter event loop, the wxPython GUI is still responsive
    because we can type into the `TextCtrl` widget while the tkinter GUI is up and
    running.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动 tkinter 事件循环后，wxPython GUI 仍然可以响应，因为我们可以在 tkinter GUI 运行时输入到 `TextCtrl`
    小部件中。
- en: Note
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: In the previous recipe, we could not use our tkinter GUI until we had closed
    the wxPython GUI. Being aware of this difference can help our design decisions
    if we want to combine the two Python GUI technologies.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的配方中，我们无法使用我们的tkinter GUI，直到我们关闭了wxPython GUI。意识到这种差异可以帮助我们做出设计决策，如果我们想要结合这两种Python
    GUI技术的话。
- en: We can also create several tkinter GUI instances by clicking the wxPython GUI
    button several times. We cannot, however, close the wxPython GUI while any tkinter
    GUIs are still running. We have to close them first.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过多次点击 wxPython GUI 按钮来创建几个 tkinter GUI 实例。然而，当任何 tkinter GUI 还在运行时，我们无法关闭
    wxPython GUI。我们必须先关闭它们。
- en: '![How to do it...](img/B04829_09_17.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_09_17.jpg)'
- en: How it works...
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe we went in the opposite direction to the previous recipe by first
    creating a GUI using wxPython and then, from wit-hin it, creating several GUI
    instances built using tkinter.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们与之前的菜谱相反，首先使用wxPython创建了一个GUI，然后，在它内部，创建了几个使用tkinter构建的GUI实例。
- en: The wxPython GUI remained responsive while one or more tkinter GUIs were running.
    However, clicking the tkinter button only updated its button text in the first
    instance.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个或多个tkinter GUI运行时，wxPython GUI仍然保持响应。然而，点击tkinter按钮只在其第一次点击时更新其按钮文本。
- en: How to use Python to control two different GUI frameworks
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何使用Python控制两个不同的GUI框架
- en: In this recipe, we will explore ways to control the tkinter and wxPython GUI
    frameworks from Python. We have already used the Python threading module to keep
    our GUI responsive in the previous chapter, so here we will attempt to use the
    same approach.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将探讨从 Python 控制 tkinter 和 wxPython GUI 框架的方法。在前一章中，我们已经使用了 Python 线程模块来保持我们的
    GUI 响应，因此在这里我们将尝试使用相同的方法。
- en: We will see that things don't always work in a way that would be intuitive.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到事情并不总是以直观的方式运作。
- en: However, we will improve our tkinter GUI from being unresponsive while we invoke
    an instance of the wxPython GUI from within it.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们从其中调用wxPython GUI的实例时，我们将改进我们的tkinter GUI，使其不再无响应。
- en: Getting ready
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: This recipe will extend a previous recipe from this chapter in which we tried
    to embed a main wxPython GUI into our tkinter GUI.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱将扩展本章中之前的一个菜谱，其中我们尝试将一个主要的 wxPython GUI 嵌入我们的 tkinter GUI。
- en: How to do it...
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: When we created an instance of a wxPython GUI from our tkinter GUI, we could
    no longer use the tkinter GUI controls until we closed the one instance of the
    wxPython GUI. Let's improve on this now.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从 tkinter GUI 创建了一个 wxPython GUI 实例后，我们就不能再使用 tkinter GUI 控件，直到关闭 wxPython
    GUI 的那个实例。现在让我们来改进这一点。
- en: Our first attempt might be to use threading from the tkinter button callback
    function.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们第一次尝试可能是使用来自 tkinter 按钮回调函数的线程。
- en: 'For example, our code might look like this:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们的代码可能看起来像这样：
- en: '[PRE12]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: At first, this seems to be working, which would be intuitive as the tkinter
    controls are no longer disabled and we can create several instances of the wxPython
    GUI by clicking the button. We can also type into and select the other tkinter
    widgets.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这似乎是有效的，这很直观，因为tkinter控件不再被禁用，我们可以通过点击按钮创建几个wxPython GUI的实例。我们还可以在其他的tkinter小部件中输入和选择内容。
- en: '![How to do it...](img/B04829_09_18.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_09_18.jpg)'
- en: However, once we try to close the GUIs, we get an error from wxWidgets, and
    our Python executable crashes.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一旦我们尝试关闭GUIs，我们就会从wxWidgets那里收到一个错误，并且我们的Python可执行文件会崩溃。
- en: '![How to do it...](img/B04829_09_19.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_09_19.jpg)'
- en: In order to avoid this, instead of trying to run the entire wxPython application
    in a thread, we can change the code to make only the wxPython `app.MainLoop` run
    in a thread.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种情况，我们不必尝试在单独的线程中运行整个 wxPython 应用程序，而是可以将代码修改为仅让 wxPython 的 `app.MainLoop`
    在线程中运行。
- en: '[PRE13]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: How it works...
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We first tried to run the entire wxPython GUI application in a thread, but this
    did not work as the wxPython main event loop expects to be the main thread of
    the application.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最初尝试在一个线程中运行整个 wxPython GUI 应用程序，但这样做并没有成功，因为 wxPython 的主事件循环期望成为应用程序的主线程。
- en: We found a workaround for this by only running the wxPython `app.MainLoop` in
    a thread, which tricks it into believing it is the main thread.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过仅在一个线程中运行 wxPython 的 `app.MainLoop` 来解决这个问题，这让它误以为自己是主线程。
- en: One side-effect of this approach is that we can no longer individually close
    all of the wxPython GUI instances. At least one of them only closes when we close
    the wxPython GUI which created the threads as daemons.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的一个副作用是，我们不能再单独关闭所有的 wxPython GUI 实例。至少有一个实例只有在关闭创建线程作为守护进程的 wxPython GUI
    时才会关闭。
- en: I am not quite sure why this is. Intuitively, one might expect to be able to
    close all daemon threads without having to wait for the main thread that created
    them to close first.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我并不完全清楚这是为什么。直观上，人们可能会期望能够关闭所有守护线程，而无需等待创建它们的父线程先关闭。
- en: It possibly has to do with a reference counter not having been set to zero while
    our main thread is still running.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是因为在我们主线程仍在运行时，引用计数器没有被设置为零。
- en: On a pragmatic level, this is how it currently works.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在实用层面上，这是它目前的工作方式。
- en: How to communicate between the two connected GUIs
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何在两个连接的GUI之间进行通信
- en: In the previous recipes, we found ways to connect a wxPython GUI with a tkinter
    GUI, invoking one from the other and vice versa.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的菜谱中，我们找到了连接 wxPython GUI 和 tkinter GUI 的方法，可以从一个调用另一个，反之亦然。
- en: While both GUIs were successfully running at the same time, they did not really
    communicate with each other as they were only launching one another.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这两个图形用户界面（GUIs）同时成功运行，但它们实际上并没有相互通信，因为它们只是互相启动。
- en: In this recipe, we will explore ways to make the two GUIs talk to each other.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将探讨如何让这两个图形用户界面相互通信。
- en: Getting ready
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Reading one of the previous recipes might be a good preparation for this recipe.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读之前的某个食谱可能是为这个食谱做准备的一个好方法。
- en: In this recipe, we will use a slightly modified GUI code compared to the previous
    recipe, but most of the basic GUI-building code is the same.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用与上一个菜谱略有修改的GUI代码，但大部分基本的GUI构建代码是相同的。
- en: How to do it...
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: In the previous recipes, one of our main challenges was how to combine two GUI
    technologies that were designed to be the one-and-only GUI toolkit for an application.
    We found various simple ways to combine them.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的菜谱中，我们面临的主要挑战之一是如何结合两种旨在成为应用程序唯一GUI工具包的GUI技术。我们发现了很多简单的方法来实现它们的结合。
- en: We will again launch the wxPython GUI from a tkinter GUI main event loop and
    start the wxPython GUI in its own thread that runs within the tkinter process.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次从 tkinter GUI 主事件循环中启动 wxPython GUI，并在 tkinter 进程内部启动其自己的线程来运行 wxPython
    GUI。
- en: In order to do this, we will use a shared global multiprocessing Python queue.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们将使用一个共享的全局多进程 Python 队列。
- en: Note
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: While it is often best to avoid global data in this recipe, they are a practical
    solution and Python globals are really only global in the module they have been
    declared in.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在这个菜谱中通常最好避免使用全局数据，但它们是一个实用的解决方案，并且Python的全局变量实际上仅在它们被声明的模块中是全局的。
- en: Here is the Python code that makes the two GUIs communicate with each other
    to a certain degree. In order to save space, this is not pure OOP code.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使两个GUI在某种程度上相互通信的Python代码。为了节省空间，这并非纯面向对象编程（OOP）代码。
- en: We are also not showing the creation code for all of the widgets. That code
    is the same as in previous recipes.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也没有展示所有小部件的创建代码。该代码与之前的食谱相同。
- en: '[PRE14]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Running the preceding code first creates the tkinter part of the program and,
    when we click the button in this GUI, it runs the wxPython GUI. Both are running
    at the same time as before, but this time, there is an extra level of communication
    between the two GUIs.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 首先运行前面的代码会创建程序中的tkinter部分，当我们点击这个GUI中的按钮时，它将运行wxPython GUI。这两个GUI仍然像之前一样同时运行，但这次，两个GUI之间增加了一个额外的通信层级。
- en: '![How to do it...](img/B04829_09_20.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_09_20.jpg)'
- en: The tkinter GUI is shown on the left-hand side of the preceding screenshot and,
    by clicking the **Call wxPython GUI** button, we invoke an instance of the wxPython
    GUI. We can create several instances by clicking the button several times.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个截图的左侧显示了 tkinter 图形用户界面，通过点击**调用 wxPython GUI**按钮，我们可以调用 wxPython GUI 的一个实例。我们可以通过多次点击按钮来创建多个实例。
- en: Note
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: All of the created GUIs remain responsive. They do not crash nor freeze.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 所有创建的GUI都保持响应。它们不会崩溃也不会冻结。
- en: Clicking the **Print** button on any of the wxPython GUI instances writes one
    sentence to its own `TextCtrl` widget and then writes another line to itself as
    well as to the tkinter GUI. You will have to scroll up to see the first sentence
    in the wxPython GUI.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 点击任何 wxPython GUI 实例上的 **打印** 按钮，会在其自身的 `TextCtrl` 小部件中写入一句话，然后还会写入另一行到自身以及
    tkinter GUI 中。您需要向上滚动才能在 wxPython GUI 中看到第一句话。
- en: Note
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: The way this works is by using a module-level queue and a tkinter `Text` widget
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这种工作方式是通过使用模块级队列和 tkinter 的 `Text` 小部件
- en: One important element to note is that we create a thread to run the wxPython
    `app.MainLoop`, as we did in the previous recipe.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一个重要元素是，我们创建了一个线程来运行 wxPython 的 `app.MainLoop`，就像我们在之前的菜谱中做的那样。
- en: '[PRE15]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We create a class that inherits from `wx.Panel` and name it `GUI`. We then instantiate
    an instance of this class in the preceding code.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个从 `wx.Panel` 继承的类，并将其命名为 `GUI`。然后，我们在前面的代码中实例化了这个类的实例。
- en: We create a button click-event callback method in this class, which then calls
    the procedural code that was written above it. Because of this, the class has
    access to the functions and can write to the shared queue.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类中，我们创建了一个按钮点击事件回调方法，然后调用上面编写的程序代码。正因为如此，这个类可以访问这些函数并且可以向共享队列写入。
- en: '[PRE16]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We first check if the data has been placed in the shared queue in the preceding
    method and, if that is the case, we then print the common data to both GUIs.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先检查数据是否已经在先前方法中放置到共享队列中，如果是这样，我们随后将公共数据打印到两个GUI上。
- en: Note
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: The `putDataIntoQueue()` line places data into the queue and `readDataFromQueue()`
    reads it back out saving it in the `data` variable.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`putDataIntoQueue()` 这一行将数据放入队列，而 `readDataFromQueue()` 则从队列中读取数据，并将其保存在 `data`
    变量中。'
- en: '`text.insert(''0.0'', data)` is the line that writes this data into the tkinter
    GUI from the **Print** button''s wxPython callback method.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`text.insert(''0.0'', data)` 是将此数据写入 tkinter GUI 的 **打印** 按钮的 wxPython 回调方法的代码行。'
- en: Following are the procedural functions (not methods, for they are not bound)
    that are being called in the code and that make it work.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在代码中被调用并使代码工作的过程函数（不是方法，因为它们没有绑定）。
- en: '[PRE17]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We are using a simple Boolean flag named `dataInQueue` to communicate when the
    data is available in the queue.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一个简单的布尔标志`dataInQueue`来通信，当数据在队列中可用时。
- en: How it works...
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we have successfully combined the two GUIs we created in a similar
    fashion, but previously standalone and not talking to each other. However, in
    this recipe, we connected them further by making one GUI launch another and, via
    a simple multiprocessing Python queue mechanism, we were able to make them communicate
    with each other, writing data from a shared queue into both GUIs.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们成功地将我们以前以类似方式创建的两个GUI结合起来，但之前是独立的，彼此之间没有交流。然而，在这个菜谱中，我们通过让一个GUI启动另一个GUI，并通过简单的Python多进程队列机制，使它们能够相互通信，将数据从共享队列写入两个GUI中。
- en: There are many very advanced and complicated technologies available to connect
    different processes, threads, pools, locks, pipes, TCP/IP connections, and so
    on.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多非常先进和复杂的技术可用于连接不同的进程、线程、线程池、锁、管道、TCP/IP连接等等。
- en: In the Pythonic spirit, we found a simple solution that works for us. Once our
    code becomes more complicated, we might have to refactor it, but this is a good
    beginning.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python的精神中，我们找到了一个对我们来说简单有效的解决方案。一旦我们的代码变得复杂，我们可能需要重构它，但这是一个良好的开端。
