<html><head></head><body>
		<div><h1 id="_idParaDest-104"><em class="italic"><a id="_idTextAnchor116"/>Chapter 4</em>: URLs, Views, and Templates</h1>
			<p>In this chapter, we will build the <strong class="bold">URL</strong> patterns that route to different <strong class="bold">views</strong>, processing a request sent to the server. One of the jobs of a view is to send processed information in the form of <strong class="bold">context</strong> to a <strong class="bold">template</strong> that will be used to render static or dynamically changing content. By the end of this chapter, we will have created several URL patterns for the user to visit and view data. Some examples will trigger errors or not-found exceptions on purpose to help demonstrate the concepts provided in this chapter.</p>
			<p>Django is based on what is called the <strong class="bold">Model-Template-View</strong> (<strong class="bold">MTV</strong>) architectural design pattern, which is similar to the well-known <strong class="bold">Model-View-Controller</strong> (<strong class="bold">MVC</strong>) design pattern used for a variety of popular web-based software systems today. The view in both of these architectural design patterns is what sometimes confuses people who are starting to learn Django and come from an MVC background. In both patterns, the model is the same, and both correspond to the tables within a database. In Django, the view is best compared to the controller used in the MVC design pattern, while the template in Django's MTV pattern is best compared to the view in an MVC design pattern. </p>
			<p>We will begin this chapter by discussing URL patterns that let us tell Django what paths we want available on a website, within our project. A <code>.com</code>, <code>.org</code>, or <code>.edu</code> part of a URL. The path in <code>www.example.com/my-url-pattern/</code> would be <code>/my-url-pattern/</code>. We can tell Django to map different URL patterns to different views and we can point different URL patterns to the same view. Views are what process a request and return a response. Usually, a response is returned in the form of an HTML template, but a response can also be in the form of JSON, XML, or any other data type. Templates take context provided by a view and/or a context processor and then use that context data to render dynamic HTML in a client's browser. <strong class="bold">Context</strong> is actually a <a id="_idIndexMarker522"/>dictionary of dynamic variables that change as conditions and states change within your app. Data that lives in the database is also provided to the template through that same context. Views perform queries and/or communicate with caching systems and APIs to fetch data from a data storage device, used when rendering templates. </p>
			<p>In this chapter, we will cover the following:</p>
			<ul>
				<li>Configuring URL patterns</li>
				<li>Mapping URL patterns</li>
				<li>Resolving URLs</li>
				<li>Resolving absolute URLs</li>
				<li>Working with complex views</li>
				<li>Working with templates</li>
			</ul>
			<h1 id="_idParaDest-105"><a id="_idTextAnchor117"/>Technical requirements</h1>
			<p>To work with the code in this chapter, the following tools will need to be installed on your local machine:</p>
			<ul>
				<li>Python version 3.9 – used as the underlying programming language for the project</li>
				<li>Django version 4.0 – used as the backend framework of the project</li>
				<li>pip package manager – used to manage third-party Python/Django packages</li>
			</ul>
			<p>We will continue to work with the solution created in <a href="B17243_02_ePub.xhtml#_idTextAnchor037"><em class="italic">Chapter 2</em></a>, <em class="italic">Project Configuration</em>. However, it is not necessary to use the Visual Studio IDE. The main project itself can be run using another IDE or run independently using a terminal or command-line window from within the project root folder. This is where the <code>manage.py</code> file resides. Whatever editor or IDE you are using, a virtual environment will also be needed to work with the Django project. Instructions for how to create a project and virtual environment can be found in <a href="B17243_02_ePub.xhtml#_idTextAnchor037"><em class="italic">Chapter 2</em></a>, <em class="italic">Project Configuration</em>. You will need a database to store the data contained in your project. PostgreSQL was chosen for the examples in the previous chapter; however, any database type that you choose for your project can be used to work with the examples in this chapter.</p>
			<p>We will also be using data that is in the form of a Django fixture, provided previously in <a href="B17243_03_ePub.xhtml#_idTextAnchor077"><em class="italic">Chapter 3</em></a>, <em class="italic">Models, Relations, and Inheritance</em>, in the subsection titled <em class="italic">Loading the Chapter_3 data fixture</em>. Make sure the <code>chapter_3</code> fixture is loaded into your database. If this has already been done, then you may skip the next command. If you have already created the tables found in <a href="B17243_03_ePub.xhtml#_idTextAnchor077"><em class="italic">Chapter 3</em></a>, <em class="italic">Models, Relations, and Inheritance</em>, and have not loaded that fixture yet, then run the following command, after activating your virtual environment:</p>
			<pre>(virtual_env) PS &gt; python manage.py loaddata chapter_3</pre>
			<p>All of the code created in this chapter can be found in the GitHub repository for this book: <a href="https://github.com/PacktPublishing/Becoming-an-Enterprise-Django-Developer">https://github.com/PacktPublishing/Becoming-an-Enterprise-Django-Developer</a>. The bulk of the code used in this chapter can be found in the <code>/becoming_a_django_entdev/becoming_a_django_entdev/chapter_4/</code> directory.</p>
			<p>Check out the following video to see the <em class="italic">Code in Action</em>: <a href="https://bit.ly/3A6AxNU">https://bit.ly/3A6AxNU</a>.</p>
			<h1 id="_idParaDest-106"><a id="_idTextAnchor118"/>Preparing for this chapter</h1>
			<p>Start by creating a new app in your project called <code>chapter_4</code> by following the steps discussed in <a href="B17243_02_ePub.xhtml#_idTextAnchor037"><em class="italic">Chapter 2</em></a>, <em class="italic">Project Configuration</em>, in the subsection titled <em class="italic">Creating a Django app</em>. As discussed in that section, don't forget to change the value of your <code>name =</code> variable for your app class found in the <code>/becoming_a_django_entdev/becoming_a_django_entdev/chapter_4/apps.py</code> file to now point to the path where you installed your app. Be sure to also include this app in your <code>INSTALLED_APPS</code> variable found in the <code>settings.py</code> file as well.</p>
			<h1 id="_idParaDest-107"><a id="_idTextAnchor119"/>Configuring URL patterns</h1>
			<p>Django controls and processes URL <a id="_idIndexMarker523"/>patterns in what it calls a <code>urls.py</code> file, which is <a id="_idIndexMarker525"/>specified as the <code>ROOT_URLCONF</code> variable, found in the <code>settings.py</code> file. Visual Studio automatically created the <code>ROOT_URLCONF</code> variable for us when we created a project and it should have also done so when executing the Django <code>startproject</code> command. </p>
			<p>If your project did not create this variable, add the following setting to your <code>settings.py</code> file:</p>
			<pre class="source-code"><strong class="bold"># /becoming_a_django_entdev/settings.py</strong></pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">ROOT_URLCONF = '<strong class="bold">becoming_a_django_entdev.urls</strong>'</pre>
			<p>The <code>urls.py</code> file defined in the <code>ROOT_URLCONF</code> variable is what Django considers the <code>url.py</code> files can be linked together<a id="_idIndexMarker526"/> by importing them <a id="_idIndexMarker527"/>using an <code>import()</code> function. Django looks for only one thing in these <code>urls.py</code> files, a single variable named <code>urlpatterns</code>, which contains a set of URL patterns that have been defined for a project or reusable app. This file can contain<a id="_idIndexMarker528"/> many methods, classes, and other utilities that help you formulate those patterns.</p>
			<h2 id="_idParaDest-108"><a id="_idTextAnchor120"/>Basic path functions</h2>
			<p>Django provides us with a<a id="_idIndexMarker529"/> variety of path functions to build URL patterns. These functions create and return elements that will be included within any <code>urlpatterns</code> variable. The <code>path()</code> and <code>re_path()</code> functions can accept up to four positional arguments in the following order: <code>route</code>, <code>view</code>, <code>kwargs</code>, and <code>name</code>. The first two of these arguments are required and must be defined. The first argument, <code>route</code>, expects a string; this <a id="_idIndexMarker530"/>can be a simple string or a fairly complex string when combining path converters and using regular expressions. If you are using a method to perform logic of some kind for this argument, it just needs to return a string. The <code>route</code> argument is the path that Django is listening for and then mapping to the second argument, <code>view</code>. The <code>view</code> argument is used to tell Django how to process the <code>GET</code> request of a URL pattern. <code>view</code> can perform any kind of logic. The third <a id="_idIndexMarker531"/>argument is the <code>view</code>. The last argument, <code>name</code>, is a way to map URL patterns when using other functions, such as a reverse lookup.</p>
			<p>Let's go over some examples of using basic functions before we dive into more complicated URL patterns, using path converters.</p>
			<h3>Function – static()</h3>
			<p>The <code>static()</code> function is <a id="_idIndexMarker533"/>provided by Django to help serve up static files when running a project locally and with debug mode turned on. These are files such<a id="_idIndexMarker534"/> as images, CSS, and JavaScript files that are placed in the <code>static</code> folder of a Django app. This function will enable access to those static folders, allowing you to run your project and add, delete, and edit those files all without having to run the <code>python manage.py collectstatic</code> command to reflect those changes in your browser. Of course, in the browser, you still have to hit refresh unless you have other tools/plugins installed in <a id="_idIndexMarker535"/>your browser <a id="_idIndexMarker536"/>to update a page when it detects changes to files that it is using. </p>
			<h4>Static files</h4>
			<p>To activate static files in your local <a id="_idIndexMarker537"/>environment, in your main <code>urls.py</code> file, <a id="_idTextAnchor121"/>add the following <code>import</code> statements and append the following<a id="_idIndexMarker538"/> function to the <code>urlpatterns</code> variable:</p>
			<pre class="source-code"><strong class="bold"># /becoming_a_django_entdev/urls.py</strong></pre>
			<pre class="source-code">from django.conf import <strong class="bold">settings</strong></pre>
			<pre class="source-code">from django.conf.urls.static import <strong class="bold">static</strong></pre>
			<pre class="source-code">urlpatterns = [...] + <strong class="bold">static</strong>(</pre>
			<pre class="source-code">    <strong class="bold">settings.STATIC_URL</strong>, </pre>
			<pre class="source-code">    document_root = <strong class="bold">settings.STATIC_ROOT</strong></pre>
			<pre class="source-code">)</pre>
			<p>In the preceding example, we imported the <code>settings.py</code> file to gain access to the values of the <code>STATIC_URL</code> and <code>STATIC_ROOT</code> variables. Since we installed the <code>pip</code> <code>whiteNoise</code> package, to work with Heroku as our host, we actually do not need to write the <code>static()</code> function depicted previously. This means we can skip writing the preceding code if we want to, but adding it will not hurt either and will allow your project to work on other hosts. </p>
			<p>This can also be written using a conditional that checks whether <code>DEBUG</code> is enabled. </p>
			<p>The alternative would be written as follows:</p>
			<pre class="source-code"><strong class="bold"># /becoming_a_django_entdev/urls.py</strong></pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">urlpatterns = [...]</pre>
			<pre class="source-code"><strong class="bold">if settings.DEBUG:</strong></pre>
			<pre class="source-code">    urlpatterns += static(</pre>
			<pre class="source-code">        settings.STATIC_URL, </pre>
			<pre class="source-code">        document_root = settings.STATIC_ROOT</pre>
			<pre class="source-code">    )</pre>
			<p>Please use only one<a id="_idIndexMarker539"/> of the examples depicted in this subsection and not both of them at the same time. You can <a id="_idIndexMarker540"/>comment out the unused one.</p>
			<p>Let's configure media files next.</p>
			<h4>Media files</h4>
			<p>Even with the <code>whitenoise</code> package, we<a id="_idIndexMarker541"/> still need to use the <code>static()</code> function to <a id="_idIndexMarker542"/>serve up media files. <code>FileField</code>, <code>ImageField</code>, or several other methods of uploading files to a media storage device. These files are also known as <strong class="bold">User-Generated Content</strong> (<strong class="bold">UGC</strong>) and they can range from<a id="_idIndexMarker543"/> anything such as an image to a PDF document, Excel document, Word document, audio file, or even movie file. The file that gets uploaded is placed in the media folder that we created and configured in <a href="B17243_02_ePub.xhtml#_idTextAnchor037"><em class="italic">Chapter 2</em></a><em class="italic">,</em> <em class="italic">Project Configuration</em>. </p>
			<p>To access these images when running a project locally, follow these steps:</p>
			<ol>
				<li>In your main <code>urls.py</code> file, insert the following highlighted code:<pre><strong class="bold"># /becoming_a_django_entdev/urls.py</strong>
...
from django.conf import <strong class="bold">settings</strong>
from django.conf.urls.static import <strong class="bold">static</strong>
urlpatterns = [...] + static(
    settings.STATIC_URL,
    document_root = settings.STATIC_ROOT
) <strong class="bold">+ static(</strong>
    <strong class="bold">settings.MEDIA_URL</strong>,<strong class="bold"> </strong>
    <strong class="bold">document_root = settings.MEDIA_ROOT</strong>
<strong class="bold">)</strong></pre></li>
				<li>This can also be added to the debug conditional statement shown in the previous subsection, titled <em class="italic">Static files</em>. </li>
				<li>If you downloaded the code that came along with this book, a sample image has been included in the directory called <code>/media</code> and is used to test whether accessing media files is<a id="_idIndexMarker544"/> actually working. If the <code>/media</code> folder is <a id="_idIndexMarker545"/>not created at this time in your project, go ahead and create that in your IDE or file browser or by running the following command:<pre><strong class="bold">(virtual_env) PS &gt; mkdir media</strong></pre></li>
				<li>Copy the <code>/becoming_a_django_entdev/media/media.jpg</code> file into your project in the same directory.</li>
				<li>Run your project and attempt to navigate to the URL <code>http://localhost:8000/media/media.jpg</code> without the preceding code and you should get a 404 response. Then try it with the preceding code and you should see the media image shown here:</li>
			</ol>
			<div><div><img src="img/Figure_4.01_B17243.jpg" alt="Figure 4.1 – Media sample image&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.1 – Media sample image</p>
			<p>Let's take these functions a step further and build our first path next.</p>
			<h3>Function – path()</h3>
			<p>A <code>path()</code> function takes in the <code>route</code>, <code>view</code>, <code>kwargs</code>, and <code>name</code> attributes and returns a single element to<a id="_idIndexMarker546"/> be included in the <code>urlpatterns</code> list. A <code>path()</code> function can be thought of as handling static paths as well as dynamic paths using<a id="_idIndexMarker547"/> path converters. If you want to use regular expressions to register a dynamic path converter, you will want to use the <code>re_path()</code> function instead. </p>
			<p>Follow these steps to work with the <code>path()</code> function in your project:</p>
			<ol>
				<li value="1">First, run your project and navigate<a id="_idIndexMarker548"/> to the base URL of the project at <code>http://localhost:8000/</code>. You might be wondering why we are seeing a <code>Page not found (404)</code> message, as shown here: </li>
			</ol>
			<div><div><img src="img/Figure_4.02_B17243.jpg" alt="Figure 4.2 – 404 with debug turned on&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.2 – 404 with debug turned on</p>
			<p>When we activated the <code>static</code> and <code>media</code> URL patterns, we caused this error message to happen. This is the reason we are not seeing the famous Django success rocket ship that we are used to seeing. It's nothing to be alarmed about; it just means that we haven't created a URL pattern to handle the home page yet. This error message can be thought of as a reminder to create that home page, which we will do next.</p>
			<p>Using the <code>path()</code> function, we will define a single static URL pattern that will listen for the home page URL. Before we do that, let's create the HTML file that it will serve up. When we used <a id="_idIndexMarker549"/>Visual Studio to create the <code>chapter_4</code> app, a file named <code>index.html</code> was automatically created for us in the <code>/becoming_a_django_entdev/chapter_4/templates/chapter_4/</code> directory. </p>
			<ol>
				<li value="2">If you do not have the <code>/chapter_4/templates/chapter_4/index.html</code> file in that directory, go ahead and create this file now, or copy the one provided with this book. Sometimes this file is not automatically created for us. </li>
			</ol>
			<p>The <code>index.html</code> file will be used as a custom home page and we will focus on just the URL pattern at this time; we will have dived into templates in more depth by the end of this chapter.</p>
			<p>Writing a URL pattern to listen for the home page is pretty easy compared to how complex other URL <a id="_idIndexMarker550"/>patterns can be to write. Django will try to match a URL to a pattern by starting from first to last in the order that they are placed within the <code>urlpatterns</code> list. It's usually best to include static URL patterns at the top and then place your dynamic patterns below them. If a static pattern is similar to a dynamic pattern, the static URL pattern will be matched first, which is likely what you want to happen.</p>
			<ol>
				<li value="3">In your main <code>/becoming_a_django_entdev/urls.py</code> file, add the following code:<pre><strong class="bold"># /becoming_a_django_entdev/urls.py</strong>
...
from django.urls 
import <strong class="bold">path</strong>
from django.views.generic 
import <strong class="bold">TemplateView</strong>
urlpatterns = [
   <strong class="bold">path(</strong>
     <strong class="bold">'', </strong>
     <strong class="bold">TemplateView.as_view(</strong>
       <strong class="bold">template_name = 'chapter_4/index.html'</strong>
     <strong class="bold">)</strong>
   <strong class="bold">),</strong>
]</pre></li>
			</ol>
			<p>The preceding <code>path()</code> function is used to listen for a route/path defined as nothing (<code>''</code>), and then we are using the built-in <code>TemplateView</code> class, provided by the <code>django.views.generic</code> library, to serve up the home page in template form. Since this is a static page and a static URL, meaning no content on the page will change and the URL itself will not change either, we do not need to write a view class to handle how the context of the page will change. Instead, we can <a id="_idIndexMarker551"/>skip creating the view in this example by using the <code>TemplateView</code> class. With a <code>TemplateView</code> class, we <a id="_idIndexMarker552"/>could still pass in keyword arguments and define the <code>name</code> argument if we wanted to. If we did want to pass in <code>kwargs</code>, that would be done using the following step.</p>
			<ol>
				<li value="4">Add <code>kwargs</code> to your home page:<pre><strong class="bold"># /becoming_a_django_entdev/urls.py</strong>
...
urlpatterns = [   
    <strong class="bold">path(</strong>
<strong class="bold">        '', </strong>
<strong class="bold">        TemplateView.as_view(</strong>
<strong class="bold">            template_name = 'chapter_4/index.html'</strong>
<strong class="bold">        ),</strong> 
        <strong class="bold">kwargs = {</strong>
            <strong class="bold">'sub_title': 'I am the sub title.'</strong>
        <strong class="bold">}</strong>
    ), 
]</pre></li>
				<li>In the <code>/chapter_4/index.html</code> file that is provided with this book, a conditional will check whether <code>sub_title</code> has a value and then displays that value in your template. Copy that<a id="_idIndexMarker553"/> conditional into your file, as highlighted here:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_4/templates/chapter_4/index.html</strong>
<strong class="bold">{% load static %}</strong>
&lt;html&gt;
    &lt;head&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;
    &lt;body style="text-align:center"&gt;
        &lt;p&gt;<a id="_idTextAnchor122"/>Home Page&lt;/p&gt;
        &lt;img src="img/<strong class="bold">{% static 'chapter_4/home_page.jpg' %}</strong>" role="img" alt="Home Page Image" width="400" style="margin: 0 auto" /&gt;
        <strong class="bold">{% if sub_title %}</strong>
        <strong class="bold">&lt;p&gt;{{ sub_title }}&lt;/p&gt;</strong>
        <strong class="bold">{% endif %}</strong>
    &lt;/body&gt;
&lt;/html&gt;</pre></li>
			</ol>
			<p>We will explain more about building<a id="_idIndexMarker554"/> templates before the end of this chapter, in the <em class="italic">Working with templates</em> section.</p>
			<p>One of the reasons we configured our project to handle static files in <a href="B17243_02_ePub.xhtml#_idTextAnchor037"><em class="italic">Chapter 2</em></a>, <em class="italic">Project Configuration</em>, and in this chapter, under the subsection titled <em class="italic">Static files</em>, was to access those files within a template, as is done in the example shown previously. The <code>{% load static %}</code> tag statement allows us to begin using the <code>static</code> template tag, such as <code>{% static 'chapter_4/home_page.jpg' %}</code>. The <code>{% static %}</code> tag returns a working URL, pointing to the image file at <code>http://localhost:8000/chapter_4/home_page.jpg</code>. </p>
			<ol>
				<li value="6">Create the <code>/static/chapter_4/</code> folder in your project using the IDE, file browser, or the following command:<pre><strong class="bold">(virtual_env) PS &gt; mkdir becoming_a_django_entdev/chapter_4/static/chapter_4</strong></pre></li>
				<li>Copy the <code>/chapter_4/home_page.jpg</code> file provided with the code of this book into your project. </li>
			</ol>
			<p>Django automatically <a id="_idIndexMarker555"/>searches the <code>static</code> folder found in each app of a project. It is common practice<a id="_idIndexMarker556"/> to override static files, such as images, CSS, and JavaScript files, of packages that are installed in your virtual environment by including the same path and filename in the static folder of any app in your project. The same principle also applies when working with template files. </p>
			<p>In <em class="italic">step 5</em>, the highlighted <code>{{ sub_title }}</code> variable tag is the keyword argument that was passed into that URL pattern in <em class="italic">step 4</em>. A custom function/callable can also be used instead of hardcoding a value here. Any context variable can be recalled in a template using the bracket syntax, <code>{{ }}</code>. Objects such as a dictionary, list, set, and query set can all be accessed using a period for each key and subkey, as in <code>{{ context_variable.key.subkey }}</code>.</p>
			<ol>
				<li value="8">Now, run your project and you should no longer see a 404 debug message. Instead, you should see the following screenshot:</li>
			</ol>
			<p class="figure-caption"> </p>
			<div><div><img src="img/Figure_4.03_B17243.jpg" alt="Figure 4.3 – Project home page&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.3 – Project home page</p>
			<p>Next, let's work with the <code>include()</code> function to<a id="_idIndexMarker557"/> import URL patterns from <a id="_idIndexMarker558"/>other apps/packages.</p>
			<h3>Function – include()</h3>
			<p>The <code>include()</code> function is used to import additional <code>urls.py</code> files that contain their own <code>urlpatterns</code> variable. This is <a id="_idIndexMarker559"/>how we can write URL patterns for reusable apps, and then<a id="_idIndexMarker560"/> include them for use in a project within <code>ROOT_URLCONF</code> of a site. </p>
			<p>Let's use this to better organize our chapter-specific URL patterns by following these steps:</p>
			<ol>
				<li value="1">If this file was not already created for you, go ahead and create a <code>urls.py</code> file inside of your <code>/becoming_a_django_entdev/chapter_4/</code> folder, and then add the following URL pattern to that file:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_4/urls.py</strong>
from django.urls 
import <strong class="bold">path</strong>
from django.views.generic 
import <strong class="bold">TemplateView</strong>
urlpatterns = [
    <strong class="bold">path(</strong>
       <strong class="bold">'chapter-4/', </strong>
       <strong class="bold">TemplateView.as_view(</strong>
            <strong class="bold">template_name='chapter_4/chapter_4.html'</strong>
       <strong class="bold">)</strong>
    <strong class="bold">),</strong>
]</pre></li>
				<li>In the main <code>/becoming_a_django_entdev/urls.py</code> file that we have been using, comment out the previous patterns that we created in this chapter and add the<a id="_idIndexMarker561"/> following <code>path</code> statement:<pre><strong class="bold"># /becoming_a_django_entdev/urls.py</strong>
...
from django.urls 
import <strong class="bold">include</strong>, <strong class="bold">path</strong>
urlpatterns = [
    <strong class="bold">path(</strong>
        <strong class="bold">'', </strong>
        <strong class="bold">include(</strong>
           <strong class="bold">'becoming_a_django_entdev.chapter_4.urls'</strong>
        <strong class="bold">)</strong>
    <strong class="bold">),</strong>
]</pre></li>
				<li>Copy the <code>chapter_4.html</code> template file that is provided with the code of this book into your project, found<a id="_idIndexMarker562"/> in the <code>/becoming_a_django_entdev/chapter_4/templates/chapter_4/</code> directory. </li>
				<li>Navigate to the URL <code>http://localhost:8000/chapter-4/</code>, and you should see a white page that only says <strong class="bold">This is Chapter 4</strong>, as shown in the following screenshot:</li>
			</ol>
			<div><div><img src="img/Figure_4.04_B17243.jpg" alt="Figure 4.4 – URL pattern – include()&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.4 – URL pattern – include()</p>
			<p>Now that we have the <code>include()</code> example working, we will put all new URL patterns in the <code>/chapter_4/urls.py</code> file and organize <a id="_idIndexMarker563"/>all future chapters in a similar manner.</p>
			<p>Now, let's practice redirecting URLs.</p>
			<h2 id="_idParaDest-109"><a id="_idTextAnchor123"/>Redirecting patterns</h2>
			<p>Instead of using the <code>TemplateView</code> class as we have been, we can write URL patterns to handle redirects from within the project, without having to configure them directly in a web server. This is<a id="_idIndexMarker564"/> convenient because in traditional web development, redirects are handled by the web server and it is much easier to manage in a project than it is in a web server. Redirects can be handled using the <code>RedirectView</code> class provided by Django. </p>
			<p>We are going to specify a redirect rule on the <code>http://localhost:8000/my_path/my_unwanted_url/</code> path to take us to <code>http://localhost:8000/my_wanted_url/</code> instead. Follow these steps to configure your redirect: </p>
			<ol>
				<li value="1">Add the following pattern to your existing <code>/chapter_4/urls.py</code> file:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_4/urls.py</strong>
...
from django.urls 
import include, path
from django.views.generic 
import (
    TemplateView,
    <strong class="bold">RedirectView</strong>
)
urlpatterns = [
    ...,
    path(
        '<strong class="bold">my_path/my_unwanted_url/</strong>', 
        <strong class="bold">RedirectView</strong>.as_view(
            url = '<strong class="bold">http://localhost:8000/my_wanted_url/</strong>'
        )
    ),
]</pre></li>
				<li>Run your project and navigate to the URL <code>http://localhost:8000/my_path/my_unwanted_url/</code>. You should now be redirected to, and also see in the address bar of the browser, <code>http://localhost:8000/my_wanted_url/</code>. In the body of the page, you should see a 404 response because we have not yet defined a URL pattern for the <code>my_wanted_url</code> path. This is to be expected when performing this step.</li>
				<li>Additional arguments can be<a id="_idIndexMarker565"/> included, such as stating that we want this to be a permanent or temporary redirect, by writing the path using the following example:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_4/urls.py</strong>
...
urlpatterns = [
    ...,
    path(
        'my_path/my_unwanted_url/', 
        RedirectView.as_view(
            url = 'http://localhost:8000/my_wanted_url/', 
            <strong class="bold">permanent = True</strong>
        )
    ),
]</pre></li>
			</ol>
			<p>Django also allows us to define <code>pattern_name</code> and <code>query_string</code> as additional arguments of the <code>RedirectView</code> class. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">The preceding path has a hardcoded value of <code>http://localhost:8000/</code>, which can become a problem in a remote environment that is not your local machine. To overcome this, you will need to adopt the concept of global context variables discussed later in this chapter in the subsection titled <em class="italic">Creating a context processor</em>.</p>
			<p>Next, let's discuss using path<a id="_idIndexMarker566"/> converters to listen for dynamic path routes.  </p>
			<h2 id="_idParaDest-110"><a id="_idTextAnchor124"/>Using path converters</h2>
			<p>A <code>str</code>, <code>int</code>, <code>slug</code>, <code>uuid</code>, and <code>path</code>. These are preformatted converters that allow a variety of choices and permit strings and integers within a pattern. For example, the path converter called <code>path</code> is used in the following code to search for any variety of characters, numbers, and certain symbols that a URL can possess.</p>
			<p>To practice using path converters, follow these steps:</p>
			<ol>
				<li value="1">Add the following URL pattern to your <code>/chapter_4/urls.py</code> file:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_4/urls.py </strong>
...
from django.urls 
import include, path
from django.views.generic 
import ..., <strong class="bold">TemplateView</strong>
urlpatterns = [
    ...,
    path(
        'my_path/<strong class="bold">&lt;path:my_pattern&gt;</strong>/', 
        <strong class="bold">TemplateView</strong>.as_view(
            template_name = 'chapter_4/index.html'
        )
    ),
]</pre></li>
				<li>Now, navigate to the URL <code>http://localhost:8000/my_path/testing/</code>, and you should see the same home page<a id="_idIndexMarker569"/> that we saw before. We are seeing the same page because we are pointing to the same <code>index.html</code> file, just to see that it is working. Additionally, if we navigate to the URL <code>http://localhost:8000/my_path/2022/</code>, we will also see the same home page. This is to be expected. The one thing we won't see is the value of the <code>sub_title</code> keyword <a id="_idIndexMarker570"/>argument on this page because we did not pass that into this URL pattern. The conditional <code>{% if sub_title %}</code> statement found in that template is used to prevent breakage if no <code>sub_title</code> is provided.</li>
				<li>Change the existing <code>my_path</code> path converter shown in <em class="italic">step 1</em> from path to int and change <code>my_path</code> to <code>my_year_path</code>, as shown in the<a id="_idIndexMarker571"/> following code, allowing for the URL <code>http://localhost:8000/my_year_path/2022/</code> to work:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_4/urls.py </strong>
...
from django.urls 
import include, path
from django.views.generic 
import ..., <strong class="bold">TemplateView</strong>
urlpatterns = [
    ...,
    path(
        'my_year_path/<strong class="bold">&lt;int:my_year&gt;</strong>/', 
        <strong class="bold">TemplateView</strong>.as_view(
            template_name = 'chapter_4/index.html'
        )
    )
]</pre></li>
				<li>Next, run your project again. With the <code>int</code> path converter, the URL <code>http://localhost:8000/my_year_path/testing/</code> should no longer work when we try to navigate to it. Instead, we should see the same 404 debug message that we saw <a id="_idIndexMarker572"/>earlier. It will only allow a numeric value of any length now. This means we should see the home page image when we visit the URL <code>http://localhost:8000/my_year_path/2/</code>, or any numeric value.</li>
			</ol>
			<p>When we wrote <code>int:my_year</code>, the <code>my_year</code> in this argument can be named anything we want. The same applies to the <code>my_pattern</code> in the <code>path:my_pattern</code> argument and in any other <a id="_idIndexMarker573"/>converter type. The second parameter is what is used to access that key word argument in a view class or method.</p>
			<p>Let's write a custom path converter next.</p>
			<h3>Custom path converters</h3>
			<p>A custom path converter is a way for us to write a class that uses a regular expression to define the path that Django listens for. The <a id="_idIndexMarker574"/>converter class is structured in a way to return the data type that is<a id="_idIndexMarker575"/> intended to be used in the view, such as an <code>int</code> data type used in the example of the previous subsection. This class also returns another string representation of the data type sent to the view that is intended to be used in the URL. For example, if we do<a id="_idIndexMarker576"/> not want <code>http://localhost:8000/my_year_path/2/</code> to be a valid URL and we only want to allow four-digit numbers, a custom path converter can be used to accomplish this.</p>
			<p>Follow these steps to create <a id="_idIndexMarker577"/>your custom path converter:</p>
			<ol>
				<li value="1">In your <code>/chapter_4/</code> app directory, create a new file called <code>converters.py</code>. </li>
				<li>Inside the file, add the following class, with the two methods provided:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_4/converters.py</strong>
class <strong class="bold">YearConverter</strong>:
    regex = '[0-9]{4}'
    def <strong class="bold">to_python</strong>(self, value):
        return int(value)
    def <strong class="bold">to_url</strong>(self, value):
        return '%04d' % value</pre></li>
				<li>In your <code>/chapter_4/urls.py</code> file, add the following code, which registers the newly created converter class for use <a id="_idIndexMarker578"/>where it is highlighted in <code>&lt;year:year&gt;</code> in the<a id="_idIndexMarker579"/> following code block:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_4/urls.py</strong>
...
from django.urls 
import path, <strong class="bold">register_converter</strong>
from .converters 
import <strong class="bold">YearConverter</strong>
<strong class="bold">register_converter(YearConverter, 'year')</strong>
urlpatterns = [
    ...,
    path(
        'my_year_path/&lt;<strong class="bold">year</strong>:year&gt;/', 
        TemplateView.as_view(
            template_name = 'chapter_4/index.html'
        )
    ),
]</pre></li>
				<li>Now, run your project and navigate to the URL <code>http://localhost:8000/my_year_path/2/</code>; you should see a 404 debug message. This occurs because the preceding pattern will only accept a four-digit integer now, including <code>0001</code> and <code>1111</code>, which is to be expected. </li>
			</ol>
			<p>We can get even more in-depth <a id="_idIndexMarker580"/>by writing a method-based or class-based view and in that view compare whether a year is greater than, say, the year 1900, and if it is<a id="_idIndexMarker581"/> not, return a 404 response. We will discuss doing that soon in the section titled <em class="italic">Working with conditional responses</em> of this <a id="_idIndexMarker582"/>chapter.</p>
			<p>Next, let's practice working with regular expression paths.</p>
			<h3>Function – re_path()</h3>
			<p>A <code>re_path()</code> function, better known as a regular expression path function, is similar to a <code>path()</code> function but allows us <a id="_idIndexMarker583"/>to pass in a formatted regular expression string as<a id="_idIndexMarker584"/> the route parameter without the need to create a custom path converter.</p>
			<p>For example, we could write the same year example as previously without the converter class. In your <code>/chapter_4/urls.py</code> file, add the path shown as follows, and comment out the previous <code>my_year_path</code>:</p>
			<pre class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_4/urls.py</strong></pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">from django.urls </pre>
			<pre class="source-code">import path, <strong class="bold">re_path</strong></pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">urlpatterns = [</pre>
			<pre class="source-code">    ...,</pre>
			<pre class="source-code">    <strong class="bold">re_path</strong>(</pre>
			<pre class="source-code">        'my_year_path/<strong class="bold">(?P&lt;year&gt;[0-9]{4})/$</strong>', </pre>
			<pre class="source-code">        TemplateView.as_view(</pre>
			<pre class="source-code">            template_name = 'chapter_4/index.html'</pre>
			<pre class="source-code">        )</pre>
			<pre class="source-code">    ),</pre>
			<pre class="source-code">]</pre>
			<p>There is actually a difference between using a <code>re_path()</code> function and writing your own converter class. The difference is in the data type of the value of the pattern recognized when we use that value within a view class or method. With the <code>re_path()</code> function, the <a id="_idIndexMarker585"/>data type of this value when used in a view will always be a string, whereas the data type of the value when using a converter class will always<a id="_idIndexMarker586"/> be the data type defined by the <code>def to_python()</code> method of that class, meaning you can transform the data type to anything you want, if you need to. </p>
			<p>Before we illustrate the difference in data types between using a converter class and using the<a id="_idTextAnchor125"/> <code>re_path()</code> function, let's map a URL pattern to a simple view.</p>
			<h1 id="_idParaDest-111"><a id="_idTextAnchor126"/>Mapping URL patterns</h1>
			<p>Writing custom views is a <a id="_idIndexMarker587"/>way for us to perform all of the tasks and services needed to render a page that includes all of the content that we want. Within a view, we can validate against business logic rules to determine how to handle a request. </p>
			<p>In this exercise, we will use the year pattern that we wrote earlier in this chapter, to only allow a year greater than 1900. Anything less than that, we will tell Django to serve up a 404 response.</p>
			<h2 id="_idParaDest-112"><a id="_idTextAnchor127"/>Using simple views</h2>
			<p>A <strong class="bold">simple view</strong> is also known as a <a id="_idIndexMarker588"/>method-based view, which<a id="_idIndexMarker589"/> is a callable function in Python. </p>
			<p>Follow these steps to map to a simple view in your project:</p>
			<ol>
				<li value="1">In your <code>/chapter_4/urls.py</code> file, revert to using the same converter class that we wrote in the <em class="italic">Using path converters</em> subsection of this chapter. Reference a view that we will <a id="_idIndexMarker590"/>write next in a different file called <code>practice_view()</code>, as highlighted <a id="_idIndexMarker591"/>here:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_4/urls.py </strong>
...
from django.urls 
import ..., <strong class="bold">register_converter</strong>
from .converters 
import <strong class="bold">YearConverter</strong>
from .views 
import <strong class="bold">practice_view</strong>
<strong class="bold">register_converter(YearConverter, 'year')</strong>
urlpatterns = [
    ...,
    <strong class="bold">path(</strong>
        <strong class="bold">'my_year_path/&lt;year:year&gt;/',</strong>
        <strong class="bold">practice_view</strong>
    <strong class="bold">),</strong>
]</pre></li>
			</ol>
			<p>The thing we did differently from before is that we replaced the <code>TemplateView</code> class with a custom simple view class, called <code>practice_view</code>. </p>
			<ol>
				<li value="2">Create the view method called <code>practice_view()</code> in a <code>views.py</code> file in your <code>/becoming_a_django_entdev/chapter_4/</code> directory. Then, add the code shown <a id="_idIndexMarker592"/>here:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_4/views.py</strong>
from django.template.response 
import (
    TemplateResponse
)
def <strong class="bold">practice_view</strong>(request, year):
    return TemplateResponse(
        request,
        'chapter_4/my_practice_page.html',
        {
           'year': year
        }
    )</pre></li>
				<li>Copy the template file<a id="_idIndexMarker593"/> provided with the code of this book into your project, located at <code>/becoming_a_django_entdev/chapter_4/templates/chapter_4/my_practice_page.html</code>. </li>
				<li>Navigate to the URL <code>http://localhost:8000/my_year_path/1066/</code> and you should see the practice page shown in the following screenshot:</li>
			</ol>
			<div><div><img src="img/Figure_4.05_B17243.jpg" alt="Figure 4.5 – Out-of-bounds year returns valid response&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.5 – Out-of-bounds year returns valid response</p>
			<p>We are almost there. The success message we see here is to be expected. What we actually want is to return a 404 response instead of a valid path, in order to comply with the business logic discussed earlier, to <a id="_idIndexMarker594"/>only allow a year greater than or equal to 1900. Therefore, we need to use <a id="_idIndexMarker595"/>keyword arguments and conditional statements to perform custom validation when a request is processed, which we will do next.</p>
			<h2 id="_idParaDest-113"><a id="_idTextAnchor128"/>Using kwargs in views</h2>
			<p>To access keyword arguments inside of<a id="_idIndexMarker596"/> a view method, we need to pass it in as<a id="_idIndexMarker597"/> a positional argument of that method. In the example, <code>def practice_view(request, year):</code>, <code>year</code> would be the positional keyword argument. Since we defined a path converter in the <code>urls.py</code> file with the name of <code>year</code>, we are required to include <code>year</code> as a positional argument when accessing a view with that same name. Without <a id="_idIndexMarker598"/>this argument, Django would give us an error during runtime.</p>
			<p>Follow these steps to configure your <code>view</code> method:</p>
			<ol>
				<li value="1">In your <code>/chapter_4/urls.py</code> file, use the following URL pattern along with the same path converter class that we created earlier. Comment out the other <code>my_year_path</code> patterns:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_4/urls.py </strong>
...
from django.urls 
import ..., register_converter
from .converters 
import YearConverter
from .views 
import ..., <strong class="bold">practice_year_view</strong>
register_converter(YearConverter, 'year')
urlpatterns = [
    ...,
    path(
        '<strong class="bold">my_year_path/&lt;year:year&gt;/</strong>', 
        <strong class="bold">practice_year_view</strong>
    ),
]</pre></li>
				<li>In your <code>/chapter_4/views.py</code> file, write the<a id="_idIndexMarker599"/> new method <a id="_idIndexMarker600"/>provided <a id="_idIndexMarker601"/>here:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_4/views.py</strong>
from django.template.response 
import (
    TemplateResponse
)
...
def <strong class="bold">practice_year_view</strong>(request, <strong class="bold">year</strong>):
    print(type(year))
    print(year)
    return TemplateResponse(
        request, 
        'chapter_4/my_year.html', 
        {<strong class="bold">'year'</strong>: <strong class="bold">year</strong>}
    )</pre></li>
				<li>Copy the template file provided with the code of this book, found in <code>/becoming_a_django_entdev/chapter_4/templates/chapter_4/my_year.html</code>. </li>
				<li>Now, navigate to the URL <code>http://localhost:8000/my_year_path/2022/</code> and you should see a successful response. When we<a id="_idIndexMarker602"/> look at the terminal or<a id="_idIndexMarker603"/> command window, we will see that it is telling us <a id="_idIndexMarker604"/>the value of <code>year</code> is <code>2022</code> and that it is of an integer, <code>&lt;class</code> <code>'int'&gt;</code>, data type, as depicted in the following screenshot:</li>
			</ol>
			<div><div><img src="img/Figure_4.06_B17243.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.6 – Converter class – integer data type</p>
			<ol>
				<li value="5">Change the URL pattern in your <code>/chapter_4/urls.py</code> file back to using the <code>re_path()</code> function instead of the custom <code>YearConverter</code> example, as shown:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_4/urls.py </strong>
...
from .views 
import ..., <strong class="bold">practice_year_view</strong>
<strong class="bold">#</strong>register_converter(YearConverter, 'year')
urlpatterns = [
    ...,
    <strong class="bold">re_path</strong>(
        'my_year_path/(?P&lt;year&gt;[0-9]{4})/$', 
        <strong class="bold">practice_year_view</strong>
    ),
]</pre></li>
			</ol>
			<p>You can comment <a id="_idIndexMarker605"/>out the <code>register_converter</code> that we previously used.</p>
			<ol>
				<li value="6">Visit the URL <code>http://localhost:8000/my_year_path/2022/</code> one more time. You should see how the output will change from <code>&lt;class</code> <code>'int'&gt;</code> to <code>&lt;class 'str'&gt;</code> in your<a id="_idIndexMarker606"/> terminal or command-line window, as<a id="_idIndexMarker607"/> depicted here: </li>
			</ol>
			<div><div><img src="img/Figure_4.07_B17243.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.7 – Converter class – string data type</p>
			<p>Now, we can actually see the differences between writing a pattern using <code>re_path()</code> and the alternative, going through the steps to create a custom converter class. With the <code>re_path()</code> function, we now have to take additional steps in a view to convert a keyword argument into an integer before<a id="_idIndexMarker608"/> we can even check <a id="_idIndexMarker609"/>whether the <code>year</code> value is greater than a certain year. If we do not do that conversion, we would wind up with an error telling us <strong class="bold">'&gt;=' not supported between instances of 'str' and 'int'</strong>. If the same regular expression pattern is used over and over again, it would mean converting a string into an integer many times, one time for each view that is being used by that pattern. This is what is known as the <strong class="bold">Write Everything Twice</strong> (<strong class="bold">WET</strong>) design principle and is usually frowned upon. Writing a<a id="_idIndexMarker610"/> converter class will solve that problem and allow you to write it just<a id="_idIndexMarker611"/> once according to the <strong class="bold">Don't Repeat Yourself</strong> (<strong class="bold">DRY</strong>) design principle.</p>
			<p>Let's work with conditional <a id="_idIndexMarker612"/>responses next.</p>
			<h2 id="_idParaDest-114"><a id="_idTextAnchor129"/>Working with conditional responses</h2>
			<p>Instead of returning a valid <code>TemplateResponse()</code> like we have been doing in previous exercises, we will finally<a id="_idIndexMarker613"/> check if the value of the <code>year</code> <code>kwarg</code> is greater than or equal to <code>1900</code>. If the <code>year</code> value is less than <code>1900</code>, we are going to raise a <code>Http404()</code> response. Using the URL pattern that uses<a id="_idIndexMarker614"/> the custom path converter <code>YearConverter</code> class that we wrote earlier, we will serve up an integer instead of a string as the data type of the keyword argument <code>year</code>, allowing us to perform mathematical operations using that value.</p>
			<p>Follow these steps to configure your conditional statements:</p>
			<ol>
				<li value="1">In your <code>/chapter_4/urls.py</code> file, add the following code, making sure to comment out or delete the other <code>my_year_path</code> patterns:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_4/urls.py </strong>
...
from django.urls 
import ..., register_converter
from .converters 
import YearConverter
from .views 
import ..., <strong class="bold">practice_year_view</strong> 
register_converter(YearConverter, 'year')
urlpatterns = [
    ...,
    path(
        'my_year_path/&lt;year:year&gt;/',
        <strong class="bold">practice_year_view</strong>
    ),
]</pre></li>
				<li>In your <code>/chapter_4/views.py</code> file, modify <code>practice_year_view()</code> to look like the following<a id="_idIndexMarker615"/> highlighted<a id="_idIndexMarker616"/> code:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_4/views.py</strong>
from django.http 
import <strong class="bold">Http404</strong>
from django.template.response 
import (
    TemplateResponse
)
def practice_year_view(request, <strong class="bold">year</strong>):
    <strong class="bold">if year &gt;= 1900:</strong>
        return TemplateResponse(
            request, 
            'chapter_4/my_year.html', 
            {'year': year}
        )
    <strong class="bold">else:</strong>
        <strong class="bold">raise Http404(f'Year Not Found: {year}')</strong></pre></li>
				<li>Now, visit the URL <code>http://localhost:8000/my_year_path/1066/</code>, and you should see the<a id="_idIndexMarker617"/> following 404 message, which is intentional:</li>
			</ol>
			<div><div><img src="img/Figure_4.08_B17243.jpg" alt="Figure 4.8 – Out-of-bounds year returns invalid response&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.8 – Out-of-bounds year returns invalid response</p>
			<ol>
				<li value="4">Next, visit a path with a year greater than <code>1900</code>, such as <code>http://localhost:8000/my_year_path/2022/</code>, and you should see a successful response, as<a id="_idIndexMarker618"/> on the year page depicted here:</li>
			</ol>
			<div><div><img src="img/Figure_4.09_B17243.jpg" alt="Figure 4.9 – In-bounds year returns valid response&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.9 –<a id="_idTextAnchor130"/> In-bounds year returns valid response</p>
			<p>Let's link models to our views and templates next.</p>
			<h2 id="_idParaDest-115"><a id="_idTextAnchor131"/>Linking models to views and templates</h2>
			<p>Using the same models that we created in <a href="B17243_03_ePub.xhtml#_idTextAnchor077"><em class="italic">Chapter 3</em></a>, <em class="italic">Models, Relations, and Inheritance</em>, we can<a id="_idIndexMarker619"/> provide information about <a id="_idIndexMarker620"/>those objects within a template. We will write a URL pattern that will point to a new simple view method and display<a id="_idIndexMarker621"/> information about a vehicle.</p>
			<p>Follow these steps to display model information in your templates:</p>
			<ol>
				<li value="1">In your <code>/chapter_4/urls.py</code> file, include the following URL pattern:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_4/urls.py </strong>
...
from .views 
import ..., <strong class="bold">vehicle_view</strong> 
urlpatterns = [
    ...,
    <strong class="bold">path(</strong>
        <strong class="bold">'vehicle/&lt;int:id&gt;/',</strong>
        <strong class="bold">vehicle_view,</strong>
        <strong class="bold">name = 'vehicle-detail'</strong>
    <strong class="bold">),</strong>
]</pre></li>
			</ol>
			<p>Our new view will listen for the primary key, also known as the ID, that is passed in to us as a keyword argument of that path converter. The ID is used to look up that object in the<a id="_idIndexMarker622"/> database, and if not found, it will serve up a 404 response instead. Instead of writing <code>&lt;int:id&gt;</code>, we could target the path converter to listen for a string, such as the VIN using <code>&lt;str:vin&gt;</code>. Then, in the view where we perform the database query, search for a record matching the VIN instead of the ID of a vehicle. You are welcome<a id="_idIndexMarker623"/> to practice both options. </p>
			<ol>
				<li value="2">In your <code>/chapter_4/views.py</code> file, add<a id="_idIndexMarker624"/> the following <code>import</code> statement and <code>view</code> method:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_4/views.py</strong>
...
from django.http 
import Http404
<strong class="bold">from ..chapter_3.models </strong>
<strong class="bold">import Vehicle</strong>
def <strong class="bold">vehicle_view</strong>(request, id):
    try:
        <strong class="bold">vehicle = Vehicle.objects.get(id=id)</strong>
    except Vehicle.DoesNotExist:
        raise Http404(f'Vehicle ID Not Found: {id}')
    return TemplateResponse(
        request,
        'chapter_4/my_vehicle.html',
        {<strong class="bold">'vehicle': vehicle</strong>}
    )</pre></li>
			</ol>
			<p>The preceding <code>import</code> statement uses two periods (<code>..</code>), which is Python path syntax, to navigate up one directory level and enter the sibling <code>chapter_3</code> folder, to access the <a id="_idIndexMarker625"/>models that are written in the <code>chapter_3</code> app. When you are working with many different apps in your project, this is common practice. The <code>try</code>/<code>except</code> block shown previously<a id="_idIndexMarker626"/> checks to see whether the requested object exists and if it does exist, a 404 response is raised. </p>
			<ol>
				<li value="3">Copy the template file<a id="_idIndexMarker627"/> that has been provided along with the code of this book, located at <code>/becoming_a_django_entdev/chapter_4/templates/chapter_4/my_vehicle.html</code>. </li>
			</ol>
			<p>We can access any field in a model object from within the template by using the name of the context variable that we passed into <code>TemplateResponse</code>. For example, when used in a template file, the <code>vehicle</code> context variable would be written as <code>{{ vehicle.vin }}</code>. This is already done in the template file you just copied into your<a id="_idIndexMarker628"/> project. </p>
			<ol>
				<li value="4">Run your project and navigate to <code>http://localhost:8000/vehicle/4/</code>. You should see vehicle detail information on this page, as shown in the following screenshot: </li>
			</ol>
			<div><div><img src="img/Figure_4.10_B17243.jpg" alt="Figure 4.10 – Vehicle ID = 4&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.10 – Vehicle ID = 4</p>
			<p>If you change the ID in your URL, the vehicle will change. If you activated the VIN as the path converter, then you would navigate to <code>http://localhost:8000/vehicle/aa456789012345678/</code> in order to see the same<a id="_idIndexMarker629"/> results, using the data provided in the <code>chapter_3</code> data fixture.</p>
			<p>Now that we have views to <a id="_idIndexMarker630"/>work with, we can practice getting the reverse URL when providing only the <code>kwarg</code> of a path converter and the <code>name</code> attribute value.</p>
			<h1 id="_idParaDest-116"><a id="_idTextAnchor132"/>Resolving URLs</h1>
			<p>Resolving a URL is the process of taking a relative path or object and obtaining the URL that relates to a unique field such as a primary key. Django's reverse<a id="_idIndexMarker631"/> resolution of URL patterns is a method of generating a URL structure using argument values that we provide instead of hardcoding URL paths in places, which can break over time. We can use template tags and statements throughout the project to use the <code>name</code> argument of a URL pattern. This is encouraged as best practice and follows a DRY design principle, which is less prone to breakage as your project evolves. </p>
			<p>Let's discuss how to use the <code>name</code> attribute to get a reverse resolution pattern.</p>
			<h2 id="_idParaDest-117"><a id="_idTextAnchor133"/>Naming URL patterns</h2>
			<p>Using the<a id="_idIndexMarker632"/> same custom <code>YearConverter</code> class and the same <code>my_year_path</code> URL pattern that we created earlier in this chapter, do the following to configure your URL pattern.</p>
			<p>In your <code>/chapter_4/urls.py</code> file, you should have the path shown in the following code block, using the highlighted <code>name</code> attribute:</p>
			<pre class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_4/urls.py </strong></pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">from django.urls </pre>
			<pre class="source-code">import ..., register_converter</pre>
			<pre class="source-code">from .converters </pre>
			<pre class="source-code">import YearConverter</pre>
			<pre class="source-code">from .views </pre>
			<pre class="source-code">import ..., practice_year_view </pre>
			<pre class="source-code">register_converter(YearConverter, 'year')</pre>
			<pre class="source-code">urlpatterns = [</pre>
			<pre class="source-code">    ...,</pre>
			<pre class="source-code">    path(</pre>
			<pre class="source-code">        'my_year_path/&lt;year:year&gt;/', </pre>
			<pre class="source-code">        practice_year_view,</pre>
			<pre class="source-code">        <strong class="bold">name = 'year_url'</strong></pre>
			<pre class="source-code">    ),</pre>
			<pre class="source-code">]</pre>
			<p>Now we can use a <code>reverse()</code> function, which<a id="_idIndexMarker633"/> we will do next.</p>
			<h2 id="_idParaDest-118"><a id="_idTextAnchor134"/>Using the reverse() function</h2>
			<p>The <code>reverse()</code> function <a id="_idIndexMarker634"/>provides us with the relative URL of an object, providing the <code>name</code> attribute value. In our view, we will write several <code>print</code> statements to tell us<a id="_idIndexMarker635"/> the relative path of objects when provided with different input arguments. </p>
			<p>Follow these steps to configure your <code>view</code> method:</p>
			<ol>
				<li value="1">In your <code>/chapter_4/views.py</code> file, add the following <code>import</code> statement, below the existing <code>import</code> statements:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_4/views.py</strong>
...
<strong class="bold">from django.urls import reverse</strong></pre></li>
				<li>In your <code>/chapter_4/views.py</code> file, and in the same <code>practice_year_view()</code> method, go ahead and include the following <code>print</code> statements. Make sure these are placed before your conditional statement that executes the <code>return</code>/<code>raise</code> calls:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_4/views.py</strong>
...
def <strong class="bold">practice_year_view</strong>(request, year):
    ...
    <strong class="bold">print(reverse('year_url', args=(2023,)))</strong>
    <strong class="bold">print(reverse('year_url', args=(2024,)))</strong>
    ...( Repeat as desired )...</pre></li>
				<li>Run your project and navigate to any URL using this pattern, such as <code>http://localhost:8000/my_year_path/2022/</code>. What will be printed in your terminal or command-line window is the formatted relative path for each of the URLs, as shown<a id="_idIndexMarker636"/> in the following screenshot:</li>
			</ol>
			<div><div><img src="img/Figure_4.11_B17243.jpg" alt="Figure 4.11 – Naming URL – view usage&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.11 – Naming URL – view usage</p>
			<p>The <code>reverse()</code> method is how we can look up a URL, using the arguments that are passed into that function. The <code>reverse()</code> method can be imported and used anywhere within a project, not just within a view class or method. This method takes in two positional arguments, the first being the name of a URL pattern, such as <code>year_url</code> highlighted in the preceding example, and is required. The second positional argument is the keyword arguments that get passed into the <code>reverse()</code> method, which is sometimes required. If there is more than one path converter defined for a URL pattern, they would be<a id="_idIndexMarker637"/> included in the <code>reverse()</code> method in the order in which they were created for that pattern and separated by a comma. Remember that the position of the keyword arguments pertaining<a id="_idIndexMarker638"/> to each path converter is important and follows the order in which keyword arguments were created for that URL pattern.</p>
			<h2 id="_idParaDest-119"><a id="_idTextAnchor135"/>Using the {% url %} template tag</h2>
			<p>The <code>{% url arg1 arg2 %}</code> template<a id="_idIndexMarker639"/> tag works just like the <code>reverse()</code> method, except <a id="_idIndexMarker640"/>used directly in a template. This tag also takes in two positional arguments, just like the <code>reverse()</code> method does. The first argument listens for the name of the URL pattern and the second is the arguments list. These arguments are separated with a space when using this template tag. Additional arguments are provided in the order the path converters were created for that URL pattern. When using the <code>{% url %}</code> tag, it is acceptable to include arguments written with and without keyword syntax. For example, both of the following<a id="_idIndexMarker641"/> tags and how they are used are valid:</p>
			<pre class="source-code"><strong class="bold"># Dummy Code</strong></pre>
			<pre class="source-code">{% url 'year_url' <strong class="bold">2023 5 25</strong> %}</pre>
			<pre class="source-code">{% url 'year_url' <strong class="bold">year=2023 month=5 day=25</strong> %}</pre>
			<p>The second example in the preceding code block would be used if we had actually created three path converters for the URL pattern, being <code>year</code>, <code>month</code>, and <code>day</code>.</p>
			<p>They can also be replaced by using context variables, if we created the three context variables called <code>year</code>, <code>month</code>, and <code>day</code> to be used in a template, as shown in the following code block:</p>
			<pre class="source-code"><strong class="bold"># Dummy Code</strong></pre>
			<pre class="source-code">{% url 'year_url' <strong class="bold">year month day</strong> %}</pre>
			<p>The code shown previously was for illustrative purposes only and will break if you try to use it without building the related URL patterns and views. </p>
			<p>Follow these steps to configure your project for this exercise:</p>
			<ol>
				<li value="1">In your existing <code>/chapter_4/my_year.html</code> file, uncomment the following hyperlinks that have been provided with the code of the book when you copied this file into your project or add them manually as shown. They are formatted using the Django <code>{% url %}</code> template<a id="_idIndexMarker642"/> tag:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_4/templates/chapter_4/my_year.html</strong>
...
&lt;html&gt;
    ...
    &lt;body style="text-align:center"&gt;
        ...
        &lt;br /&gt; &lt;br /&gt;
        <strong class="bold">&lt;a href="{% url 'year_url' 2023 %}"&gt;2023&lt;/a&gt;</strong>
        <strong class="bold">&lt;a href="{% url 'year_url' 2024 %}"&gt;<a id="_idTextAnchor136"/>2024&lt;/a&gt;</strong>
        ...( Repeat as desired )...
    &lt;/body&gt;
&lt;/html&gt;</pre></li>
				<li>Run your project and navigate to the same URL, <code>http://localhost:8000/my_year_path/2022/</code>, and you should now see what is depicted in<a id="_idIndexMarker643"/> the following screenshot, with the hyperlinks rendered to the page:</li>
			</ol>
			<div><div><img src="img/Figure_4.12_B17243.jpg" alt="Figure 4.12 – Naming URL – template usage&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.12 – Naming URL – template usage</p>
			<p>Each hyperlink that is rendered points to the correlating relative path at <code>href="/my_year_path/####/"</code>. We can continue modifying these two examples to format absolute URLs instead of relative URLs. This means we will include the <code>www.example.com</code> part of the URL. We<a id="_idIndexMarker644"/> will discuss that in the section titled <em class="italic">Resolving absolute URLs</em> later in this chapter. Let's process trailing slashes next.</p>
			<h2 id="_idParaDest-120"><a id="_idTextAnchor137"/>Processing trailing slashes</h2>
			<p>In Django, we can use the <code>re_path()</code> function in combination with the custom <code>YearConverter</code> class to write one <a id="_idIndexMarker645"/>URL pattern accepting a path with <a id="_idIndexMarker646"/>and without a trailing slash, <code>/</code>. What this means is that we can write a URL to listen for <code>www.example.com/my_path/</code> and will also allow <code>www.example.com/my_path</code> to render a success, essentially combining two paths into one statement.</p>
			<p>To process your trailing slashes, in your <code>/chapter_4/urls.py</code> file, add the following path and comment out all other <code>my_year_path</code> examples:</p>
			<pre class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_4/urls.py</strong></pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">from django.urls import (</pre>
			<pre class="source-code">    ..., </pre>
			<pre class="source-code">    <strong class="bold">re_path</strong>, </pre>
			<pre class="source-code">    <strong class="bold">register_converter</strong></pre>
			<pre class="source-code"><strong class="bold">)</strong></pre>
			<pre class="source-code">from .converters </pre>
			<pre class="source-code">import YearConverter</pre>
			<pre class="source-code">from .views </pre>
			<pre class="source-code">import ..., practice_view</pre>
			<pre class="source-code">register_converter(YearConverter, 'year')</pre>
			<pre class="source-code">urlpatterns = [</pre>
			<pre class="source-code">    ...,</pre>
			<pre class="source-code">    re_path(</pre>
			<pre class="source-code">        <strong class="bold">r'^my_year_path/(?P&lt;year&gt;[0-9]+)/?$'</strong>, </pre>
			<pre class="source-code">        practice_view</pre>
			<pre class="source-code">    ),</pre>
			<pre class="source-code">]</pre>
			<p><code>route</code> is defined in the <code>re_path()</code> function as <code>r'^my_year_path/(?P&lt;year&gt;[0-9]+)/?$'</code>, which constructs the path in a way that will listen for an optional forward slash. <code>year</code> is also written using just the tag name. If we were to write the <a id="_idIndexMarker647"/>statement using <code>&lt;year:year&gt;</code> as we did in previous exercises, then we would receive the following error message in the terminal or <a id="_idIndexMarker648"/>command-line window:</p>
			<pre>django.core.exceptions.ImproperlyConfigured: "^my_year_path/(?P&lt;year:year&gt;[0-9]+)/?$" is not a valid regular expression: bad character in group name 'year:year' at position 18</pre>
			<p>Since we are listening for a trailing slash via the use of regular expression operations, there is no need to modify values in the <code>settings.py</code> file, such as <code>APPEND_SLASH</code>. In order to actually use the <code>APPEND_SLASH</code> variable, Django requires the <code>common</code> middleware to be installed. You can learn more about using this approach instead of the regular expression approach here: https://docs.djangoproject.com/en/4.0/ref/settings/#append-slash. Using the regular expression basic structure shown previously, we don't need to worry about middleware. </p>
			<p>Now that we have resolved relative URLs, let's resolve absolute URLs next.</p>
			<h1 id="_idParaDest-121"><a id="_idTextAnchor138"/>Resolving absolute URLs</h1>
			<p>An absolute URL<a id="_idIndexMarker649"/> includes the scheme, host, and port of a URL, as in the following format, <code>scheme://host:port/path?query</code>. This is an example of an absolute URL: <a href="https://www.example.com:8000/my_path?query=my_query_value">https://www.example.com:8000/my_path?query=my_query_value</a>. </p>
			<p>Next, we will resolve an absolute URL while introducing the practice of using custom context processors.</p>
			<h2 id="_idParaDest-122"><a id="_idTextAnchor139"/>Creating a context processor</h2>
			<p>Context processors are useful in many ways: they provide context that is shared globally among all templates <a id="_idIndexMarker650"/>and views within a project. Alternatively, the context being created in a view can only be used by the template that the view is using <a id="_idIndexMarker651"/>and no other templates. In the next example, we will create and then activate a custom global context processor where we will add the base URL of the site. We will call the context variable <code>base_url</code>, referring to <code>scheme://host:port</code> of the URL found throughout this project's site. </p>
			<p>Follow these steps to create your context processor:</p>
			<ol>
				<li value="1">In the same folder as your <code>settings.py</code> file, create a new file called <code>context_processors.py</code>. </li>
				<li>Inside this file, place the code provided as follows, which will construct the <code>http://localhost:8000</code> portion of the site based on the environment we are running the project on:<pre><strong class="bold"># /becoming_a_django_entdev/context_processors.py</strong>
def <strong class="bold">global_context</strong>(request):
    return {
        '<strong class="bold">base_url</strong>': <strong class="bold">request.build_absolute_uri</strong>(
            <strong class="bold">'/'</strong>
        )[:-1].strip('/'),
    }</pre></li>
			</ol>
			<p>Context is returned as a dictionary of key-value pairs, where we can pack as many keys as we would like to. </p>
			<ol>
				<li value="3">To register this context processor for inclusion during runtime, we need to add it to the <code>settings.py</code> file, under the <code>TEMPLATES</code> variable. Include the path to your <code>global_context()</code> method, as shown:<pre><strong class="bold"># /becoming_a_django_entdev/settings.py</strong>
TEMPLATES = [
{
        ...
        'OPTIONS': 
        {
            '<strong class="bold">context_processors</strong>': [
                ...,
<strong class="bold">'becoming_a_django_entdev.context_processors.global_context'</strong>,
            ],
        },
},]</pre></li>
			</ol>
			<p>Place your custom context processor below any existing <code>context_processors</code> in the preceding list.</p>
			<p>Context processors can be broken<a id="_idIndexMarker652"/> down into individual apps within a project as well. Include each additional context processor that you create<a id="_idIndexMarker653"/> inside the preceding list and in the order desired. Additional global context processor variables have been included with the code of this book for extra practice as well.</p>
			<p>Let's use our newly created <code>base_url</code> context in a template next.</p>
			<h3>Using context processor data in a template</h3>
			<p>Using a <code>{% url %}</code> template <a id="_idIndexMarker654"/>tag, we can modify hyperlinks to use the context that we just made available in the previous example as a context processor called <code>global_context()</code>.</p>
			<p>Follow these steps to configure your template: </p>
			<ol>
				<li value="1">In your <code>/chapter_4/urls.py</code> file, add the following path and comment out all other <code>my_year_path</code> examples:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_4/urls.py</strong>
...
<strong class="bold">from django.urls </strong>
<strong class="bold">import ..., register_converter</strong>
<strong class="bold">from .converters </strong>
<strong class="bold">import YearConverter</strong>
<strong class="bold">from .views </strong>
<strong class="bold">import ..., practice_year_view </strong>
<strong class="bold">register_converter(YearConverter, 'year')</strong>
<strong class="bold">urlpatterns = [</strong>
<strong class="bold">    ...,</strong>
<strong class="bold">    path(</strong>
<strong class="bold">        'my_year_path/&lt;year:year&gt;/', </strong>
<strong class="bold">        practice_year_view,</strong>
<strong class="bold">        name = 'year_url'</strong>
    ),
]</pre></li>
				<li>In your <code>my_year.html</code> file, write/uncomment <a id="_idIndexMarker655"/>the following hyperlink examples:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_4/templates/chapter_4/my_year.html</strong>
...
&lt;html&gt;
    ...
    &lt;body style="text-align:center"&gt;
        ...
        &lt;br /&gt; &lt;br /&gt;
        &lt;a href="<strong class="bold">{{ base_url }}</strong>{% url 'year_url' 2023 %}"&gt;2023&lt;/a&gt;
        &lt;a href="<strong class="bold">{{ base_url }}</strong>{% url 'year_url' 2024 %}"&gt;2024&lt;/a&gt;          
        ...( Repeat as desired )...
    &lt;/body&gt;
&lt;/html&gt;</pre></li>
				<li>Navigate to <code>http://localhost:8000/my_year_path/2022/</code> one more time. Your <code>href</code> attribute on each hyperlink will now look like <code>href="http://localhost:8000/my_year_path/####/"</code> instead of what it was rendering before, as <code>href="/my_year_path/####/"</code>. </li>
			</ol>
			<p>When we added the <code>{{ base_url }}</code> template variable, we referenced the dictionary key of the context<a id="_idIndexMarker656"/> that was provided.</p>
			<h2 id="_idParaDest-123"><a id="_idTextAnchor140"/>From the request object</h2>
			<p>In this exercise, we will resolve the <a id="_idIndexMarker657"/>absolute URL using a <code>request</code> object. Follow these<a id="_idIndexMarker658"/> steps to do that in your project:</p>
			<ol>
				<li value="1">In your <code>/chapter_4/views.py</code> file, in your existing <code>practice_year_view()</code> method, include the following <code>print</code> statements. These statements will use the <code>build_absolute_uri()</code> method provided in your <code>request</code> object, as part of the Django framework. This will return to us the absolute URL of the reverse lookup:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_4/views.py</strong>
...
from django.urls 
import <strong class="bold">reverse</strong>
def <strong class="bold">practice_year_view</strong>(request, year):
    ...
    print(
        <strong class="bold">request.build_absolute_uri</strong>(
            <strong class="bold">reverse</strong>('year_url', args=(<strong class="bold">2023</strong>,))
        )
    )
    print(
        <strong class="bold">request.build_absolute_uri</strong>(
            <strong class="bold">reverse</strong>('year_url', args=(<strong class="bold">2024</strong>,))
        )
    )
    ...( Repeat as desired )...</pre></li>
			</ol>
			<p>The preceding <code>print</code> statements also utilize the <code>reverse()</code> method found in the <code>django.urls</code> library.</p>
			<ol>
				<li value="2">Run your<a id="_idIndexMarker659"/> project and<a id="_idIndexMarker660"/> navigate to <code>http://localhost:8000/my_year_path/2022/</code>. You should see the following paths printed in your terminal or command-line window:</li>
			</ol>
			<div><div><img src="img/Figure_4.13_B17243.jpg" alt="Figure 4.13 – Naming URL – view usage – absolute URL&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.13 – Naming URL – view usage – absolute URL</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The relative path of the current page can be retrieved from the <code>request</code> object using <code>print(request.path)</code>. On this page, it would return <code>/my_year_path/2022/</code>. Using <code>print(request.build_absolute_uri())</code> without the <code>reverse()</code> lookup function will return the absolute path of that particular request.</p>
			<p>Let's practice looking <a id="_idIndexMarker661"/>up absolute URLs from within a model class <a id="_idIndexMarker662"/>next.</p>
			<h2 id="_idParaDest-124"><a id="_idTextAnchor141"/>From within a model class</h2>
			<p>We will be expanding<a id="_idIndexMarker663"/> on the same <code>vehicle_view()</code> method for this <a id="_idIndexMarker664"/>next example, to get a formatted URL from an existing object. We are going to work in the same <code>/chapter_3/models.py</code> file that we worked on in <a href="B17243_03_ePub.xhtml#_idTextAnchor077"><em class="italic">Chapter 3</em></a>, <em class="italic">Models, Relations, and Inheritance</em>. </p>
			<p>Follow these steps to configure your model class:</p>
			<ol>
				<li value="1">In your <code>/chapter_3/models.py</code> file, add the following two methods (<code>get_url()</code> and <code>get_absolute_url()</code>) to <a id="_idIndexMarker665"/>your existing <code>Vehicle</code> model <a id="_idIndexMarker666"/>class: <pre><strong class="bold"># /becoming_a_django_entdev/chapter_3/models.py</strong> 
class <strong class="bold">Vehicle</strong>(models.Model):
    ...
    <strong class="bold">def get_url(self):</strong>
        from django.urls import <strong class="bold">reverse</strong>
        return <strong class="bold">reverse</strong>(
            'vehicle-detail', 
            kwargs = {'id': self.pk}
        )
    <strong class="bold">def get_absolute_url(self, request):</strong>
        from django.urls import <strong class="bold">reverse</strong>
        base_url = request.build_absolute_uri(
            '/'
        )[:-1].strip('/')
        return base_url + <strong class="bold">reverse</strong>(
            'vehicle-detail', 
            kwargs = {'id': self.pk}
        )</pre></li>
			</ol>
			<p>These methods import the <code>reverse()</code> function that was introduced earlier in this section to get the URL of the object in reference. The <code>import</code> statements are added to the methods<a id="_idIndexMarker667"/> themselves instead of at the<a id="_idIndexMarker668"/> top of this document to allow for better performance handling when using these model class methods. The first method, <code>get_url()</code>, is used to return a relative URL path to that object, while the other method, <code>get_absolute_url()</code>, is intended to return the absolute path to that object. </p>
			<ol>
				<li value="2">In your <code>/chapter_4/views.py</code> file, in the existing <code>vehicle_view()</code> method, add the following <code>print</code> statements as part of the <code>else</code> catch, just after the <code>except</code> catch:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_4/views.py</strong>
...
from django.http 
import <strong class="bold">Http404</strong>
from ..chapter_3.models 
import <strong class="bold">Vehicle</strong>
...
def <strong class="bold">vehicle_view</strong>(request, id):
    try:
        vehicle = <strong class="bold">Vehicle</strong>.objects.get(id=id)
    except <strong class="bold">Vehicle</strong>.DoesNotExist:
        raise <strong class="bold">Http404</strong>(f'Vehicle ID Not Found: {id}')
    <strong class="bold">else:</strong>
        <strong class="bold">print(vehicle.get_url())</strong>
        <strong class="bold">print(vehicle.get_absolute_url(request))</strong>
<strong class="bold">    ...</strong></pre></li>
			</ol>
			<p>The <code>else</code> catch means the <code>Vehicle</code> object that it was searching for was found without errors. Remember to leave the same <code>return</code> statement that we previously wrote at<a id="_idIndexMarker669"/> the end of this <code>vehicle_view()</code> method.</p>
			<ol>
				<li value="3">Run your project and navigate to <code>http://localhost:8000/vehicle/4/</code>. In your terminal or command-line window, you should see the two different relative and absolute paths to the object that we looked<a id="_idIndexMarker670"/> up in the <code>vehicle_view()</code> method, as shown:</li>
			</ol>
			<div><div><img src="img/Figure_4.14_B17243.jpg" alt="Figure 4.14 – Model URLs&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.14 – Model URLs</p>
			<p>We have been practicing with simple views, otherwise known as method-based views. Many projects need views to provide a bit more power and usability, which can be achieved with class-based views, which we will create next.</p>
			<h1 id="_idParaDest-125"><a id="_idTextAnchor142"/>Working with complex views</h1>
			<p>A view method will suffice for<a id="_idIndexMarker671"/> a lot of different situations. For more robust and large-scale projects, we can apply a few tricks to make these views more adaptable in complicated use cases. Class-based views are used when writing adaptable and reusable applications.</p>
			<h2 id="_idParaDest-126"><a id="_idTextAnchor143"/>Class-based views</h2>
			<p>With class-based views, we can write code that can be reused and extended easily. Just like when we extended models in <a href="B17243_03_ePub.xhtml#_idTextAnchor077"><em class="italic">Chapter 3</em></a>, <em class="italic">Models, Relations, and Inheritance</em>, we can extend view classes in<a id="_idIndexMarker672"/> the exact same way, whereas function-based view methods cannot provide this ability. Two templates have been provided with the source<a id="_idIndexMarker673"/> code of this book to be used in the next exercise. These two files are the exact same file as the <code>my_vehicle.html</code> file, except that the title of the <code>&lt;h1&gt;</code> tag in each has been changed to <strong class="bold">VehicleView Class 1</strong> and <strong class="bold">VehicleView Class 2</strong> so that when we run the following examples, we can see the differences between them.</p>
			<p>Follow these steps to configure your class-based views:</p>
			<ol>
				<li value="1">Copy the files called <code>my_vehicle_class_1.html</code> and <code>my_vehicle_class_2.html</code> in the <code>/becoming_a_django_entdev/chapter_4/templates/chapter_4/</code> directory of the code provided with this book into your project at the same directory.</li>
				<li>In your <code>/chapter_4/urls.py</code> file, add the following <code>import</code> statement and URL pattern:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_4/urls.py</strong>
...
from .views 
import ..., <strong class="bold">VehicleView</strong>
urlpatterns = [
    ...,
    path(
        'vehicle/&lt;int:id&gt;/', 
        <strong class="bold">VehicleView.as_view()</strong>,
        name = 'vehicle-detail'
    ),
]</pre></li>
			</ol>
			<p>Don't forget to comment out the old <code>/vehicle/</code> URL patterns that were written before<a id="_idIndexMarker674"/> experimenting with this one. </p>
			<ol>
				<li value="3">In your <code>/chapter_4/views.py</code> file, create the class-based view called <code>VehicleView</code> and add<a id="_idIndexMarker675"/> the <code>import</code> statements, as shown:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_4/views.py</strong>
...
from django.http 
import <strong class="bold">Http404</strong>
from django.template.response 
import (
    <strong class="bold">TemplateResponse</strong>
<strong class="bold">)</strong>
from django.views.generic 
import <strong class="bold">View</strong>
from ..chapter_3.models 
import <strong class="bold">Vehicle</strong>
...
<strong class="bold">class VehicleView(View):</strong>
    <strong class="bold">template_name</strong> = 'chapter_4/my_vehicle_class_1.html'</pre></li>
				<li>Add the following <code>get()</code> method to your <code>VehicleView</code> class:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_4/views.py</strong>
...
<strong class="bold">class VehicleView(View):</strong>
    ...
    <strong class="bold">def get</strong>(self, request, <strong class="bold">id</strong>, *args, **kwargs):
        try:
            vehicle = <strong class="bold">Vehicle</strong>.objects.get(id=id)
        except <strong class="bold">Vehicle</strong>.DoesNotExist:
            raise <strong class="bold">Http404</strong>(
                f'Vehicle ID Not Found: {id}'
            )
        return <strong class="bold">TemplateResponse</strong>(
            request,
            self.template_name,
            {'vehicle': vehicle}
        )</pre></li>
				<li>Add the following <code>post()</code> method <a id="_idIndexMarker676"/>and import to <a id="_idIndexMarker677"/>your <code>VehicleView</code> class:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_4/views.py</strong>
...
from django.http 
import ..., <strong class="bold">HttpResponseRedirect</strong>
...
<strong class="bold">class VehicleView(View):</strong>
<strong class="bold">    ...</strong>
    <strong class="bold">def post</strong>(self, request, *args, **kwargs):
        return <strong class="bold">HttpResponseRedirect</strong>(
            '/success/'
        )</pre></li>
				<li>Run your project and navigate to <code>http://localhost:8000/vehicle/4/</code>. You should see the main title is displayed as <strong class="bold">VehicleView Class 1</strong> now. </li>
				<li>Next, modify the URL pattern<a id="_idIndexMarker678"/> to overload <code>template_name</code>, using the<a id="_idIndexMarker679"/> following example:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_4/urls.py</strong>
...
from .views 
import ..., VehicleView
urlpatterns = [
    ...,
    path(
        'vehicle/&lt;int:id&gt;/', 
        VehicleView.as_view(
            <strong class="bold">template_name = 'chapter_4/my_vehicle_class_2.html'</strong>
        ),
        name = 'vehicle-detail'
    ),
]</pre></li>
				<li>Now, rerun your project and navigate to the URL at <code>http://localhost:8000/vehicle/4/</code>. You should see the title on the page displayed as <strong class="bold">VehicleView Class 2</strong> this time.</li>
			</ol>
			<p>The <code>def get()</code> submethod depicted in <em class="italic">step 4</em> is where all of the code in the method-based view is moved to. It's also the only required method. Other optional methods, such as <code>def post()</code>, are used when working with form objects, when a postback response is executed. It can also be used to redirect the user to a success page, which is illustrated in the code of <em class="italic">step 5</em>, but <a id="_idIndexMarker680"/>you will never get Django to trigger this redirect <a id="_idIndexMarker681"/>with how we are using this class now, which is to be expected. We will discuss this in more depth later in <a href="B17243_05_ePub.xhtml#_idTextAnchor152"><em class="italic">Chapter 5</em></a>, <em class="italic">Django Forms</em>. When we are working with positional keyword arguments of a URL, they are passed into the view class, where the <code>id</code> attribute is written in the preceding <code>get()</code> method. If you have more than one keyword argument, they would be added after <code>id</code> in the order that they exist in that URL pattern. </p>
			<p>We performed <em class="italic">step 7</em> and <em class="italic">step 8</em> just to check that this is working and to see how we can still override default settings just like we did earlier in this chapter. Let's extend our class-based views next, also known as inheritance.</p>
			<h2 id="_idParaDest-127"><a id="_idTextAnchor144"/>Extending class-based views</h2>
			<p>Extending class-based views, also known as inheritance, is done in<a id="_idIndexMarker682"/> the exact same way as when<a id="_idIndexMarker683"/> we extended model classes in <a href="B17243_03_ePub.xhtml#_idTextAnchor077"><em class="italic">Chapter 3</em></a>, <em class="italic">Models, Relations, and Inheritance</em>. We can display the same title on the page by extending the first class into a second class, eliminating the need to define <code>template_name</code> in the URL pattern itself, among many other benefits. </p>
			<p>Follow these steps to extend your class:</p>
			<ol>
				<li value="1">In your <code>/chapter_4/urls.py</code> file, comment out the previous URL patterns and write a new one using the code provided, where we are using <code>VehicleView2</code> as the view class now:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_4/urls.py</strong>
...
from .views 
import ..., <strong class="bold">VehicleView2</strong>
urlpatterns = [
    ...,
    path(
        'vehicle/&lt;int:id&gt;/', 
        <strong class="bold">VehicleView2.as_view()</strong>, 
        name = 'vehicle-detail'
    ),
]</pre></li>
				<li>Next, in your <code>/chapter_4/views.py</code> file, add the following <code>VehicleView2</code> class constructed <a id="_idIndexMarker684"/>from the <code>VehicleView</code> class:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_4/views.py</strong>
...
class <strong class="bold">VehicleView2</strong>(<strong class="bold">VehicleView</strong>):
    template_name = 'chapter_4/my_vehicle_class_2.html'</pre></li>
				<li>Run your project and navigate to the URL <code>http://localhost:8000/vehicle/4/</code>. You should see the same title, <strong class="bold">VehicleView Class 2</strong>, displayed on the page.</li>
			</ol>
			<p>The preceding example is just a very <a id="_idIndexMarker685"/>simple extension of the existing <code>VehicleView</code> class that demonstrates how to extend a view class. The only thing we are changing/overriding in this exercise is the <code>template_name</code> variable in order to demonstrate this concept.</p>
			<p>Next, let's learn what asynchronous views are used for.</p>
			<h2 id="_idParaDest-128"><a id="_idTextAnchor145"/>Asynchronous views</h2>
			<p>Django also offers support of asynchronous views, a feature first introduced in Django 3.1. Asynchronous views are views<a id="_idIndexMarker686"/> that can be processed in individual processing threads and run together at the same time. These are used to build better multithreaded apps. Traditional <a id="_idIndexMarker687"/>Django projects use the <strong class="bold">Web Server Gateway Interface</strong> (<strong class="bold">WSGI</strong>) by default. To actually use asynchronous function- and class-based views, we need to configure a project and the server to use the <strong class="bold">Asynchronous Server Gateway Interface</strong> (<strong class="bold">ASGI</strong>) instead of WSGI. Since<a id="_idIndexMarker688"/> this requires quite a bit more work to configure the server and potentially the hosting provider, we will skip providing any examples for this section, but if this is something you want or need in your project, you can get started here: <a href="https://docs.djangoproject.com/en/4.0/topics/async/">https://docs.djangoproject.com/en/4.0/topics/async/</a>.  </p>
			<p>Up to now, we have been using templates that have been pre-built and provided with the code of this book in order to demonstrate core programming concepts. Next, let's explore what it takes to actually build those templates on our own.</p>
			<h1 id="_idParaDest-129"><a id="_idTextAnchor146"/>Working with templates</h1>
			<p>The Django template language<a id="_idIndexMarker689"/> provides us with a set of template tags and template filters that are used to perform simple actions directly within a template. It makes it easy to perform simple logic operations, such as Python operations. Tags and filters are actually two different things that closely resemble each other. The Django template language can be closely compared to Shopify's Liquid syntax and is similar to the Razor syntax used in ASP.NET frameworks, but the Django template language is a bit easier to use and read. Django also allows us to create custom tags and filters for use within a project. Custom filters are most commonly used to transform a single context variable. Custom tags provide for more robust and complex use cases. For a complete breakdown of all of the template tags and template filters that exist, read the official Django documentation about them here: <a href="https://docs.djangoproject.com/en/4.0/ref/templates/builtins/">https://docs.djangoproject.com/en/4.0/ref/templates/builtins/</a>. </p>
			<p>Next, we will touch briefly on the features and capabilities of the most commonly used template tags and filters that are available.</p>
			<h2 id="_idParaDest-130"><a id="_idTextAnchor147"/>Template tags</h2>
			<p>We can structure a template to feel more like an app by breaking it down into smaller components. Those components <a id="_idIndexMarker690"/>can then be used interchangeably within other templates. For example, we can write a base template that contains the <code>&lt;head&gt;</code> and <code>&lt;body&gt;</code> elements of a page and then break apart subtemplates that structure the body content of each of those templates. Areas can be created in the <code>&lt;head&gt;</code> and <code>&lt;body&gt;</code> of a document where we can pass dynamic text and HTML into them, such as the <code>&lt;title&gt;</code> tag. </p>
			<p>For the next example, let's use the <code>{% block %}</code>, <code>{% extend %}</code>, and <code>{% include %}</code> template tags to create two template files, demonstrating how to break templates down into manageable pieces. </p>
			<p>Follow these steps to configure your template tags:</p>
			<ol>
				<li value="1">In your <code>/chapter_4/urls.py</code> file, comment out the other paths and include the following path:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_4/urls.py</strong>
...
from .views 
import ..., <strong class="bold">TestPageView</strong>
urlpatterns = [
    ...,
    path(
        'test_page_1/', 
        <strong class="bold">TestPageView</strong>.as_view(), 
        name = 'test-page'
    ),
]</pre></li>
				<li>In your <code>/chapter_4/views.py</code> file, create the following class-based view called <code>TestPageView</code>, using the code provided here:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_4/views.py</strong>
...
from django.template.response 
import (
    <strong class="bold">TemplateResponse</strong>
)
from django.views.generic 
import <strong class="bold">View</strong>
...
class <strong class="bold">TestPageView</strong>(<strong class="bold">View</strong>):
    template_name = 'chapter_4/pages/test_page_1.html'
    def get(self, request, *args, **kwargs):
        return <strong class="bold">TemplateResponse</strong>(
            request, 
            self.template_name, 
            {
                'title': 'My Test Page 1',
                'page_id': 'test-id-1',
                'page_class': 'test-page-1',
                'h1_tag': 'This is Test Page 1'
            }
        )</pre></li>
			</ol>
			<p>In the <code>TestPageView</code> class, we are <a id="_idIndexMarker691"/>defining a default <code>template_name</code> as <code>'chapter_4/pages/test_page_1.html'</code>. In the <code>get()</code> method, we pass in hardcoded context variables to be used in this demonstration. In a real-world scenario, this information would be generated after performing logic that is <a id="_idIndexMarker692"/>written to generate those values. </p>
			<ol>
				<li value="3">Create the <code>/becoming_a_django_entdev/chapter_4/templates/chapter_4/pages/test_page_1.html</code> file and add the following code:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_4/templates/chapter_4/pages/test_page_1.html</strong>
{% extends 'chapter_4/base/base_template_1.html' %}
{% load static %}
<strong class="bold">{% block page_title %}{{ title }}{% endblock %}</strong>
{% block head_stylesheets %}{% endblock %}
{% block js_scripts %}{% endblock %}
{% block page_id %}{{ page_id }}{% endblock %}
{% block page_class %}<strong class="bold">{{ block.super }}</strong> {{ page_class }}{% endblock %}
{% block <strong class="bold">body_content</strong> %}
    {% <strong class="bold">if</strong> h1_tag %}
        &lt;h1&gt;{{ h1_tag }}&lt;/h1&gt;
    {% <strong class="bold">else</strong> %}
        &lt;h1&gt;Title Not Found&lt;/h1&gt;
    {% <strong class="bold">endif</strong> %}
{% endblock %}</pre></li>
			</ol>
			<p>This template starts with the <code>{% extends %}</code> template tag, which states that we want to actually start with the <code>/chapter_4/base/base_template_1.html</code> file, even though we specified the <code>test_page_1.html</code> file in our view class. Then, everywhere there is a <code>{% block %}</code> tag found in this file, we override or append to that same <code>{% block %}</code> found in the <code>base_template_1.html</code> file that we are extending. We are passing the value of <code>{{ title }}</code>, which was defined in the view, into the <code>{% block page_title %}</code> tag of the <code>/chapter_4/pages/test_page_1.html</code> file. The <code>{{ block.super }}</code> tag can be used to keep what is <a id="_idIndexMarker693"/>found in that same block of the <code>base_template_1.html</code> file. Without this tag, all code inside the parent block will be overwritten. HTML can be written inside of any block; the <code>{% block body_content %}</code> block, shown in <em class="italic">step 5</em> that follows, is where the bulk of the page content will be found.</p>
			<ol>
				<li value="4">Create the <code>/chapter_4/base/base_template_1.html</code> file and add the code shown here:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_4/templates/chapter_4/base/base_template_1.html</strong>
{% load static %}
&lt;!DOCTYPE html&gt;
&lt;html lang="en" xmlns="http://www.w3.org/1999/xhtml"&gt;
    &lt;head&gt;
        &lt;meta charset="utf-8" /&gt;
        &lt;title&gt;{% block page_title %}My Page Title{% endblock %}&lt;/title&gt;
        &lt;link rel="stylesheet" href="{{ base_url }}{% static 'chapter_8/css/site.css' %}"&gt;
        {% block head_stylesheets %}{% endblock %}
        &lt;script defer type="text/javascript" src="img/site-js.js' %}"&gt;&lt;/script&gt;
    &lt;/head&gt;
&lt;/html&gt;</pre></li>
				<li>In the same <code>/chapter_4/base/base_template_1.html</code> file that you just created, insert the body<a id="_idIndexMarker694"/> code provided next, just below your existing closing <code>&lt;/head&gt;</code> tag:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_4/templates/chapter_4/base/base_template_1.html</strong>
...
    &lt;/head&gt;
    &lt;body id="{% block page_id %}{% endblock %}" class="{% block page_class %}base-template-class{% endblock %}" style="text-align: center;"&gt;
        {% block header %}
            {% <strong class="bold">include 'chapter_4/headers/header_1.html'</strong> %}
        {% endblock %}
        {% block site_container %}
            &lt;div class="site-container"&gt;
                &lt;div class="body-content"&gt;
                    <strong class="bold">{% block body_content %}</strong>
                    <strong class="bold">{% endblock %}</strong>
                &lt;/div&gt;
                {% block footer %}
                    {% <strong class="bold">include 'chapter_4/footers/footer_1.html'</strong> <strong class="bold">with message='Footer of Document'</strong> %}
                {% endblock %}
            &lt;/div&gt;
        {% endblock %}
        {% block js_scripts %}{% endblock %}
    &lt;/body&gt;
&lt;/html&gt;</pre></li>
				<li>Copy the <code>/chapter_4/headers/header_1.html</code> and <code>/chapter_4/footers/footer_1.html</code> files provided with the code of this book into your project in the same directory.</li>
				<li>Copy the <code>/chapter_4/static/chapter_4/css/site.css</code> and <code>/chapter_4/static/chapter_4/js/site-js.js</code> files provided with the code of this book into your <a id="_idIndexMarker695"/>project at the same directory.</li>
				<li>Run your project and navigate to <code>http://localhost:8000/test_page_1/</code>. You should see the following information in your browser window:</li>
			</ol>
			<div><div><img src="img/Figure_4.15_B17243.jpg" alt="Figure 4.15 – Extending templates&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.15 – Extending templates</p>
			<p>In the preceding steps, the main HTML of the page is broken down into a header, body content, and footer format. The <code>{% include %}</code> tags used previously demonstrate different ways of working with those files. Adding a <code>with</code> attribute to any <code>{% include %}</code> tag is how we can pass context into that file from the parent template. That is what is done to the preceding footer file. This means making context available without the need for a context processor or by writing code twice. The preceding HTML is structured in a way that allows us to <a id="_idIndexMarker696"/>get fancy by modifying everything within the <code>{% block site_container %}</code> tag, if we wanted or needed to. In order to do that, we would write the <code>{% block site_container %}</code> block again in the file that extends this template file and write the modified code there. That is essentially what <em class="italic">step 3</em> did for us, with the <code>{% block body_content %}</code> tag. </p>
			<p>Let's work with template filters next.</p>
			<h2 id="_idParaDest-131"><a id="_idTextAnchor148"/>Template filters</h2>
			<p>Template filters are a way to<a id="_idIndexMarker697"/> transform the value of a context variable. They can do things such as make a string upper or lowercase using the <code>{{ context_variable|upper }}</code> or <code>{{ context_variable|lower }}</code> filters. They can be used to find the number of items in a list using the <code>{{ my_list|length }}</code> filter or even format time with a <code>{{ my_time|time:"</code> <code>n/j/Y" }}</code> filter. When using a <code>time</code> filter, it is not necessary to specify the <code>:" n/j/Y"</code> argument of that filter. Even without these specifications, Django will default to the setting specified in your <code>settings.py</code> file as the <code>TIME_FORMAT</code> variable. To learn about all of the filters that are available, visit the official Django documentation found here: https://docs.djangoproject.com/en/4.0/ref/templates/builtins/#built-in-filter-reference. </p>
			<p>Let's check out custom tags and filters next. </p>
			<h2 id="_idParaDest-132"><a id="_idTextAnchor149"/>Custom tags and filters</h2>
			<p>Earlier, in <em class="italic">Figure 4.10</em>, we saw that the value of the<a id="_idIndexMarker698"/> make of the vehicle was displayed as the number <strong class="bold">3</strong>. This is a perfect example of how we can write a custom <a id="_idIndexMarker699"/>filter that takes in a numeric value and returns the string representation of that value.</p>
			<p>Follow these steps to create your custom filter:</p>
			<ol>
				<li value="1">Create a new folder in the <code>/becoming_a_django_entdev/chapter_4/</code> directory called <code>templatetags</code>. </li>
				<li>Create a new file in this folder called <code>chapter_4.py</code> and inside this file, place the following code:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_4/templatetags/chapter_4.py</strong>
from django.template 
import <strong class="bold">Library</strong>
register = <strong class="bold">Library()</strong>
<strong class="bold">@register.filter(name = 'vehicle_make')</strong>
def <strong class="bold">vehicle_make</strong>(value):
    <strong class="bold">from ...chapter_3.models import MAKE_CHOICES</strong>
    for i, choice in enumerate(<strong class="bold">MAKE_CHOICES</strong>):
        if i == value:
            try:
                return choice[1]
            except ValueError:
                pass
    return ''</pre></li>
			</ol>
			<p>Here, we are writing a very simple method called <code>vehicle_make()</code> that takes in the numeric value of <code>3</code> and returns to us the string representation of <code>Chevrolet</code>, when <a id="_idIndexMarker700"/>used in a template. In this method, we are using Python path syntax to import the <code>MAKE_CHOICES</code> variable, which we created in <a href="B17243_03_ePub.xhtml#_idTextAnchor077"><em class="italic">Chapter 3</em></a>, <em class="italic">Models, Relations, and Inheritance</em>, in the subsection titled <em class="italic">Mutable versus immutable objects</em>. </p>
			<ol>
				<li value="3">Make sure you have uncommented previous URL patterns and use the one shown in the following code block: <pre># /becoming_a_django_entdev/chapter_4/urls.py 
... 
from .views import ..., vehicle_view 
urlpatterns = [ 
    ..., 
    path( 
        'vehicle/&lt;int:id&gt;/', 
        vehicle_view, 
        name = 'vehicle-detail' 
    ), 
]</pre></li>
				<li>In your existing <code>/chapter_4/my_vehicle.html</code> file, change <code>{{ vehicle.make }}</code> to the statement we can see highlighted in the following code block, and add the <code>chapter_4</code> template tag library to your <code>{% load %}</code> tag:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_4/templates/chapter_4/my_vehicle.html</strong>
{% load static <strong class="bold">chapter_4</strong> %}
...
        {% if vehicle %}
            ...
            &lt;p&gt;{{ vehicle.make }}&lt;/p&gt;
            &lt;p&gt;<strong class="bold">{{ vehicle.make|vehicle_make }}</strong>&lt;/p&gt;
            ...
        {% endif %}
...</pre></li>
			</ol>
			<p>In order to use the template filter that we registered, we import it into the HTML file using the <code>{% load chapter_4 %}</code> tag, where the name of the template tag set that we are loading is the name of the Python file that we created in any <code>templatetags</code> folder of an app.</p>
			<ol>
				<li value="5">Now, making sure your project is running, you can navigate to the URL at <code>http://localhost:8000/vehicle/4/</code> to see that our vehicle now says <strong class="bold">Chevrolet</strong>.</li>
			</ol>
			<p>Creating custom template tags instead of custom filters can be done by changing <code>@register.filter(name = 'my_filter')</code> to <code>@register.tag(name = 'my_tag')</code>. In this scenario, the tag can be used in a template similar to <code>{% my_tag %}</code>. To learn more about the <a id="_idIndexMarker701"/>complexities of writing your own template tags and how they can be useful in your project, visit the official documentation on that subject found here: https://docs.djangoproject.com/en/4.0/howto/custom-template-tags/#writing-custom-template-tags. </p>
			<p>Next, let's add some custom error pages.</p>
			<h2 id="_idParaDest-133"><a id="_idTextAnchor150"/>Error page templates</h2>
			<p>Django provides a very easy way to<a id="_idIndexMarker702"/> create your own custom error page templates for errors such as 400, 403, 404, and 500. Other errors, such as a <code>templates</code> directories, <code>400.html</code>, <code>403.html</code>, <code>404.html</code>, and <code>500.html</code>, as long as they are not placed in a subfolder. These four<a id="_idIndexMarker703"/> template files have been provided with the code of this book and follow the same design pattern as depicted in the subsection titled <em class="italic">Template tags</em> of this chapter. In order to see a custom debug template, we must turn off <code>DEBUG</code> in the <code>settings.py</code> file. </p>
			<p>Follow these steps to configure your error pages:</p>
			<ol>
				<li value="1">Copy the four error page template files found in the <code>/becoming_a_django_entdev/chapter_4/templates/</code> directory provided with the code of this book into the same directory of your project. Those four files are <code>400.html</code>, <code>403.html</code>, <code>404.html</code>, and <code>500.html</code>, and also copy the <code>base_error.html</code> file found in the same directory.</li>
				<li>In your <code>settings.py</code> file, change the following value to <code>False</code>:<pre><strong class="bold"># /becoming_a_django_entdev/settings.py</strong>
...
DEBUG = <strong class="bold">False</strong></pre></li>
				<li>Make sure your virtual environment is activated and run the <code>collectstatic</code> command shown here, in order to have access to the static files that have been created up to this point in time: <pre><strong class="bold">(virtual_env) PS &gt; python manage.py collectstatic</strong></pre></li>
				<li>With <code>DEBUG</code> turned off, we have to run the <code>collectstatic</code> command in order to see changes reflect in the browser every time a static file is changed.</li>
				<li>Now, run your project and <a id="_idIndexMarker704"/>navigate to any non-existent<a id="_idIndexMarker705"/> URL on the site, a URL that we have not created a URL pattern for yet, such as <code>http://localhost:8000/asdfasdf</code>. You should see the following message in your browser window instead of the debug error message we are used to seeing, such as in <em class="italic">Figure 4.2</em>:</li>
			</ol>
			<div><div><img src="img/Figure_4.16_B17243.jpg" alt="Figure 4.16 – Custom error page&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.16 – Custom error page</p>
			<h1 id="_idParaDest-134"><a id="_idTextAnchor151"/>Summary</h1>
			<p>By now, we have constructed what might feel like an entire project, but in reality, an application will consist of so much more than what was covered in this chapter. What we do have is a way to route URL paths to views and render different contexts in each template used. We learned how we can query the database in a view to get the data that we want to render in a template. We even covered the different ways we can handle and process an error page or simply redirect a URL to another path. We even used class-based views to write reusable class structures, making a project more adaptable to change in the long run. </p>
			<p>In the next chapter, we will discuss how we can use form objects in combination with the function-based and class-based views and templates we learned how to create in this chapter.</p>
		</div>
	</body></html>