<html><head></head><body>
		<div id="_idContainer066">
			<h1 id="_idParaDest-104"><em class="italic"><a id="_idTextAnchor116"/>Chapter 4</em>: URLs, Views, and Templates</h1>
			<p>In this chapter, we will build the <strong class="bold">URL</strong> patterns that route to different <strong class="bold">views</strong>, processing a request sent to the server. One of the jobs of a view is to send processed information in the form of <strong class="bold">context</strong> to a <strong class="bold">template</strong> that will be used to render static or dynamically changing content. By the end of this chapter, we will have created several URL patterns for the user to visit and view data. Some examples will trigger errors or not-found exceptions on purpose to help demonstrate the concepts provided in this chapter.</p>
			<p>Django is based on what is called the <strong class="bold">Model-Template-View</strong> (<strong class="bold">MTV</strong>) architectural design pattern, which is similar to the well-known <strong class="bold">Model-View-Controller</strong> (<strong class="bold">MVC</strong>) design pattern used for a variety of popular web-based software systems today. The view in both of these architectural design patterns is what sometimes confuses people who are starting to learn Django and come from an MVC background. In both patterns, the model is the same, and both correspond to the tables within a database. In Django, the view is best compared to the controller used in the MVC design pattern, while the template in Django's MTV pattern is best compared to the view in an MVC design pattern. </p>
			<p>We will begin this chapter by discussing URL patterns that let us tell Django what paths we want available on a website, within our project. A <strong class="bold">path</strong> is considered<a id="_idIndexMarker520"/> anything found after the suffix of a web address, where<a id="_idIndexMarker521"/> a <strong class="bold">suffix</strong> is the <strong class="source-inline">.com</strong>, <strong class="source-inline">.org</strong>, or <strong class="source-inline">.edu</strong> part of a URL. The path in <strong class="source-inline">www.example.com/my-url-pattern/</strong> would be <strong class="source-inline">/my-url-pattern/</strong>. We can tell Django to map different URL patterns to different views and we can point different URL patterns to the same view. Views are what process a request and return a response. Usually, a response is returned in the form of an HTML template, but a response can also be in the form of JSON, XML, or any other data type. Templates take context provided by a view and/or a context processor and then use that context data to render dynamic HTML in a client's browser. <strong class="bold">Context</strong> is actually a <a id="_idIndexMarker522"/>dictionary of dynamic variables that change as conditions and states change within your app. Data that lives in the database is also provided to the template through that same context. Views perform queries and/or communicate with caching systems and APIs to fetch data from a data storage device, used when rendering templates. </p>
			<p>In this chapter, we will cover the following:</p>
			<ul>
				<li>Configuring URL patterns</li>
				<li>Mapping URL patterns</li>
				<li>Resolving URLs</li>
				<li>Resolving absolute URLs</li>
				<li>Working with complex views</li>
				<li>Working with templates</li>
			</ul>
			<h1 id="_idParaDest-105"><a id="_idTextAnchor117"/>Technical requirements</h1>
			<p>To work with the code in this chapter, the following tools will need to be installed on your local machine:</p>
			<ul>
				<li>Python version 3.9 – used as the underlying programming language for the project</li>
				<li>Django version 4.0 – used as the backend framework of the project</li>
				<li>pip package manager – used to manage third-party Python/Django packages</li>
			</ul>
			<p>We will continue to work with the solution created in <a href="B17243_02_ePub.xhtml#_idTextAnchor037"><em class="italic">Chapter 2</em></a>, <em class="italic">Project Configuration</em>. However, it is not necessary to use the Visual Studio IDE. The main project itself can be run using another IDE or run independently using a terminal or command-line window from within the project root folder. This is where the <strong class="source-inline">manage.py</strong> file resides. Whatever editor or IDE you are using, a virtual environment will also be needed to work with the Django project. Instructions for how to create a project and virtual environment can be found in <a href="B17243_02_ePub.xhtml#_idTextAnchor037"><em class="italic">Chapter 2</em></a>, <em class="italic">Project Configuration</em>. You will need a database to store the data contained in your project. PostgreSQL was chosen for the examples in the previous chapter; however, any database type that you choose for your project can be used to work with the examples in this chapter.</p>
			<p>We will also be using data that is in the form of a Django fixture, provided previously in <a href="B17243_03_ePub.xhtml#_idTextAnchor077"><em class="italic">Chapter 3</em></a>, <em class="italic">Models, Relations, and Inheritance</em>, in the subsection titled <em class="italic">Loading the Chapter_3 data fixture</em>. Make sure the <strong class="source-inline">chapter_3</strong> fixture is loaded into your database. If this has already been done, then you may skip the next command. If you have already created the tables found in <a href="B17243_03_ePub.xhtml#_idTextAnchor077"><em class="italic">Chapter 3</em></a>, <em class="italic">Models, Relations, and Inheritance</em>, and have not loaded that fixture yet, then run the following command, after activating your virtual environment:</p>
			<p class="source-code">(virtual_env) PS &gt; python manage.py loaddata chapter_3</p>
			<p>All of the code created in this chapter can be found in the GitHub repository for this book: <a href="https://github.com/PacktPublishing/Becoming-an-Enterprise-Django-Developer">https://github.com/PacktPublishing/Becoming-an-Enterprise-Django-Developer</a>. The bulk of the code used in this chapter can be found in the <strong class="source-inline">/becoming_a_django_entdev/becoming_a_django_entdev/chapter_4/</strong> directory.</p>
			<p>Check out the following video to see the <em class="italic">Code in Action</em>: <a href="https://bit.ly/3A6AxNU">https://bit.ly/3A6AxNU</a>.</p>
			<h1 id="_idParaDest-106"><a id="_idTextAnchor118"/>Preparing for this chapter</h1>
			<p>Start by creating a new app in your project called <strong class="source-inline">chapter_4</strong> by following the steps discussed in <a href="B17243_02_ePub.xhtml#_idTextAnchor037"><em class="italic">Chapter 2</em></a>, <em class="italic">Project Configuration</em>, in the subsection titled <em class="italic">Creating a Django app</em>. As discussed in that section, don't forget to change the value of your <strong class="source-inline">name =</strong> variable for your app class found in the <strong class="source-inline">/becoming_a_django_entdev/becoming_a_django_entdev/chapter_4/apps.py</strong> file to now point to the path where you installed your app. Be sure to also include this app in your <strong class="source-inline">INSTALLED_APPS</strong> variable found in the <strong class="source-inline">settings.py</strong> file as well.</p>
			<h1 id="_idParaDest-107"><a id="_idTextAnchor119"/>Configuring URL patterns</h1>
			<p>Django controls and processes URL <a id="_idIndexMarker523"/>patterns in what it calls a <strong class="bold">URL dispatcher</strong>. Django <a id="_idIndexMarker524"/>starts with the <strong class="source-inline">urls.py</strong> file, which is <a id="_idIndexMarker525"/>specified as the <strong class="source-inline">ROOT_URLCONF</strong> variable, found in the <strong class="source-inline">settings.py</strong> file. Visual Studio automatically created the <strong class="source-inline">ROOT_URLCONF</strong> variable for us when we created a project and it should have also done so when executing the Django <strong class="source-inline">startproject</strong> command. </p>
			<p>If your project did not create this variable, add the following setting to your <strong class="source-inline">settings.py</strong> file:</p>
			<pre class="source-code"><strong class="bold"># /becoming_a_django_entdev/settings.py</strong></pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">ROOT_URLCONF = '<strong class="bold">becoming_a_django_entdev.urls</strong>'</pre>
			<p>The <strong class="source-inline">urls.py</strong> file defined in the <strong class="source-inline">ROOT_URLCONF</strong> variable is what Django considers the <strong class="bold">root URLconf</strong> of any project, short for <strong class="bold">URL configuration</strong>. Other <strong class="source-inline">url.py</strong> files can be linked together<a id="_idIndexMarker526"/> by importing them <a id="_idIndexMarker527"/>using an <strong class="source-inline">import()</strong> function. Django looks for only one thing in these <strong class="source-inline">urls.py</strong> files, a single variable named <strong class="source-inline">urlpatterns</strong>, which contains a set of URL patterns that have been defined for a project or reusable app. This file can contain<a id="_idIndexMarker528"/> many methods, classes, and other utilities that help you formulate those patterns.</p>
			<h2 id="_idParaDest-108"><a id="_idTextAnchor120"/>Basic path functions</h2>
			<p>Django provides us with a<a id="_idIndexMarker529"/> variety of path functions to build URL patterns. These functions create and return elements that will be included within any <strong class="source-inline">urlpatterns</strong> variable. The <strong class="source-inline">path()</strong> and <strong class="source-inline">re_path()</strong> functions can accept up to four positional arguments in the following order: <strong class="source-inline">route</strong>, <strong class="source-inline">view</strong>, <strong class="source-inline">kwargs</strong>, and <strong class="source-inline">name</strong>. The first two of these arguments are required and must be defined. The first argument, <strong class="source-inline">route</strong>, expects a string; this <a id="_idIndexMarker530"/>can be a simple string or a fairly complex string when combining path converters and using regular expressions. If you are using a method to perform logic of some kind for this argument, it just needs to return a string. The <strong class="source-inline">route</strong> argument is the path that Django is listening for and then mapping to the second argument, <strong class="source-inline">view</strong>. The <strong class="source-inline">view</strong> argument is used to tell Django how to process the <strong class="source-inline">GET</strong> request of a URL pattern. <strong class="source-inline">view</strong> can perform any kind of logic. The third <a id="_idIndexMarker531"/>argument is the <strong class="bold">Keyword Arguments</strong> (<strong class="bold">kwargs</strong>), and this is a dictionary of <a id="_idIndexMarker532"/>additional keywords to pass into <strong class="source-inline">view</strong>. The last argument, <strong class="source-inline">name</strong>, is a way to map URL patterns when using other functions, such as a reverse lookup.</p>
			<p>Let's go over some examples of using basic functions before we dive into more complicated URL patterns, using path converters.</p>
			<h3>Function – static()</h3>
			<p>The <strong class="source-inline">static()</strong> function is <a id="_idIndexMarker533"/>provided by Django to help serve up static files when running a project locally and with debug mode turned on. These are files such<a id="_idIndexMarker534"/> as images, CSS, and JavaScript files that are placed in the <strong class="source-inline">static</strong> folder of a Django app. This function will enable access to those static folders, allowing you to run your project and add, delete, and edit those files all without having to run the <strong class="source-inline">python manage.py collectstatic</strong> command to reflect those changes in your browser. Of course, in the browser, you still have to hit refresh unless you have other tools/plugins installed in <a id="_idIndexMarker535"/>your browser <a id="_idIndexMarker536"/>to update a page when it detects changes to files that it is using. </p>
			<h4>Static files</h4>
			<p>To activate static files in your local <a id="_idIndexMarker537"/>environment, in your main <strong class="source-inline">urls.py</strong> file, <a id="_idTextAnchor121"/>add the following <strong class="source-inline">import</strong> statements and append the following<a id="_idIndexMarker538"/> function to the <strong class="source-inline">urlpatterns</strong> variable:</p>
			<pre class="source-code"><strong class="bold"># /becoming_a_django_entdev/urls.py</strong></pre>
			<pre class="source-code">from django.conf import <strong class="bold">settings</strong></pre>
			<pre class="source-code">from django.conf.urls.static import <strong class="bold">static</strong></pre>
			<pre class="source-code">urlpatterns = [...] + <strong class="bold">static</strong>(</pre>
			<pre class="source-code">    <strong class="bold">settings.STATIC_URL</strong>, </pre>
			<pre class="source-code">    document_root = <strong class="bold">settings.STATIC_ROOT</strong></pre>
			<pre class="source-code">)</pre>
			<p>In the preceding example, we imported the <strong class="source-inline">settings.py</strong> file to gain access to the values of the <strong class="source-inline">STATIC_URL</strong> and <strong class="source-inline">STATIC_ROOT</strong> variables. Since we installed the <strong class="source-inline">pip</strong> <strong class="source-inline">whiteNoise</strong> package, to work with Heroku as our host, we actually do not need to write the <strong class="source-inline">static()</strong> function depicted previously. This means we can skip writing the preceding code if we want to, but adding it will not hurt either and will allow your project to work on other hosts. </p>
			<p>This can also be written using a conditional that checks whether <strong class="source-inline">DEBUG</strong> is enabled. </p>
			<p>The alternative would be written as follows:</p>
			<pre class="source-code"><strong class="bold"># /becoming_a_django_entdev/urls.py</strong></pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">urlpatterns = [...]</pre>
			<pre class="source-code"><strong class="bold">if settings.DEBUG:</strong></pre>
			<pre class="source-code">    urlpatterns += static(</pre>
			<pre class="source-code">        settings.STATIC_URL, </pre>
			<pre class="source-code">        document_root = settings.STATIC_ROOT</pre>
			<pre class="source-code">    )</pre>
			<p>Please use only one<a id="_idIndexMarker539"/> of the examples depicted in this subsection and not both of them at the same time. You can <a id="_idIndexMarker540"/>comment out the unused one.</p>
			<p>Let's configure media files next.</p>
			<h4>Media files</h4>
			<p>Even with the <strong class="source-inline">whitenoise</strong> package, we<a id="_idIndexMarker541"/> still need to use the <strong class="source-inline">static()</strong> function to <a id="_idIndexMarker542"/>serve up media files. <strong class="bold">Media files</strong> are just like static files except they are considered what a user would upload through <strong class="source-inline">FileField</strong>, <strong class="source-inline">ImageField</strong>, or several other methods of uploading files to a media storage device. These files are also known as <strong class="bold">User-Generated Content</strong> (<strong class="bold">UGC</strong>) and they can range from<a id="_idIndexMarker543"/> anything such as an image to a PDF document, Excel document, Word document, audio file, or even movie file. The file that gets uploaded is placed in the media folder that we created and configured in <a href="B17243_02_ePub.xhtml#_idTextAnchor037"><em class="italic">Chapter 2</em></a><em class="italic">,</em> <em class="italic">Project Configuration</em>. </p>
			<p>To access these images when running a project locally, follow these steps:</p>
			<ol>
				<li>In your main <strong class="source-inline">urls.py</strong> file, insert the following highlighted code:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/urls.py</strong></p><p class="source-code">...</p><p class="source-code">from django.conf import <strong class="bold">settings</strong></p><p class="source-code">from django.conf.urls.static import <strong class="bold">static</strong></p><p class="source-code">urlpatterns = [...] + static(</p><p class="source-code">    settings.STATIC_URL,</p><p class="source-code">    document_root = settings.STATIC_ROOT</p><p class="source-code">) <strong class="bold">+ static(</strong></p><p class="source-code">    <strong class="bold">settings.MEDIA_URL</strong>,<strong class="bold"> </strong></p><p class="source-code">    <strong class="bold">document_root = settings.MEDIA_ROOT</strong></p><p class="source-code"><strong class="bold">)</strong></p></li>
				<li>This can also be added to the debug conditional statement shown in the previous subsection, titled <em class="italic">Static files</em>. </li>
				<li>If you downloaded the code that came along with this book, a sample image has been included in the directory called <strong class="source-inline">/media</strong> and is used to test whether accessing media files is<a id="_idIndexMarker544"/> actually working. If the <strong class="source-inline">/media</strong> folder is <a id="_idIndexMarker545"/>not created at this time in your project, go ahead and create that in your IDE or file browser or by running the following command:<p class="source-code"><strong class="bold">(virtual_env) PS &gt; mkdir media</strong></p></li>
				<li>Copy the <strong class="source-inline">/becoming_a_django_entdev/media/media.jpg</strong> file into your project in the same directory.</li>
				<li>Run your project and attempt to navigate to the URL <strong class="source-inline">http://localhost:8000/media/media.jpg</strong> without the preceding code and you should get a 404 response. Then try it with the preceding code and you should see the media image shown here:</li>
			</ol>
			<div>
				<div id="_idContainer050" class="IMG---Figure">
					<img src="image/Figure_4.01_B17243.jpg" alt="Figure 4.1 – Media sample image&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.1 – Media sample image</p>
			<p>Let's take these functions a step further and build our first path next.</p>
			<h3>Function – path()</h3>
			<p>A <strong class="source-inline">path()</strong> function takes in the <strong class="source-inline">route</strong>, <strong class="source-inline">view</strong>, <strong class="source-inline">kwargs</strong>, and <strong class="source-inline">name</strong> attributes and returns a single element to<a id="_idIndexMarker546"/> be included in the <strong class="source-inline">urlpatterns</strong> list. A <strong class="source-inline">path()</strong> function can be thought of as handling static paths as well as dynamic paths using<a id="_idIndexMarker547"/> path converters. If you want to use regular expressions to register a dynamic path converter, you will want to use the <strong class="source-inline">re_path()</strong> function instead. </p>
			<p>Follow these steps to work with the <strong class="source-inline">path()</strong> function in your project:</p>
			<ol>
				<li value="1">First, run your project and navigate<a id="_idIndexMarker548"/> to the base URL of the project at <strong class="source-inline">http://localhost:8000/</strong>. You might be wondering why we are seeing a <strong class="source-inline">Page not found (404)</strong> message, as shown here: </li>
			</ol>
			<div>
				<div id="_idContainer051" class="IMG---Figure">
					<img src="image/Figure_4.02_B17243.jpg" alt="Figure 4.2 – 404 with debug turned on&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.2 – 404 with debug turned on</p>
			<p>When we activated the <strong class="source-inline">static</strong> and <strong class="source-inline">media</strong> URL patterns, we caused this error message to happen. This is the reason we are not seeing the famous Django success rocket ship that we are used to seeing. It's nothing to be alarmed about; it just means that we haven't created a URL pattern to handle the home page yet. This error message can be thought of as a reminder to create that home page, which we will do next.</p>
			<p>Using the <strong class="source-inline">path()</strong> function, we will define a single static URL pattern that will listen for the home page URL. Before we do that, let's create the HTML file that it will serve up. When we used <a id="_idIndexMarker549"/>Visual Studio to create the <strong class="source-inline">chapter_4</strong> app, a file named <strong class="source-inline">index.html</strong> was automatically created for us in the <strong class="source-inline">/becoming_a_django_entdev/chapter_4/templates/chapter_4/</strong> directory. </p>
			<ol>
				<li value="2">If you do not have the <strong class="source-inline">/chapter_4/templates/chapter_4/index.html</strong> file in that directory, go ahead and create this file now, or copy the one provided with this book. Sometimes this file is not automatically created for us. </li>
			</ol>
			<p>The <strong class="source-inline">index.html</strong> file will be used as a custom home page and we will focus on just the URL pattern at this time; we will have dived into templates in more depth by the end of this chapter.</p>
			<p>Writing a URL pattern to listen for the home page is pretty easy compared to how complex other URL <a id="_idIndexMarker550"/>patterns can be to write. Django will try to match a URL to a pattern by starting from first to last in the order that they are placed within the <strong class="source-inline">urlpatterns</strong> list. It's usually best to include static URL patterns at the top and then place your dynamic patterns below them. If a static pattern is similar to a dynamic pattern, the static URL pattern will be matched first, which is likely what you want to happen.</p>
			<ol>
				<li value="3">In your main <strong class="source-inline">/becoming_a_django_entdev/urls.py</strong> file, add the following code:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/urls.py</strong></p><p class="source-code">...</p><p class="source-code">from django.urls </p><p class="source-code">import <strong class="bold">path</strong></p><p class="source-code">from django.views.generic </p><p class="source-code">import <strong class="bold">TemplateView</strong></p><p class="source-code">urlpatterns = [</p><p class="source-code">   <strong class="bold">path(</strong></p><p class="source-code">     <strong class="bold">'', </strong></p><p class="source-code">     <strong class="bold">TemplateView.as_view(</strong></p><p class="source-code">       <strong class="bold">template_name = 'chapter_4/index.html'</strong></p><p class="source-code">     <strong class="bold">)</strong></p><p class="source-code">   <strong class="bold">),</strong></p><p class="source-code">]</p></li>
			</ol>
			<p>The preceding <strong class="source-inline">path()</strong> function is used to listen for a route/path defined as nothing (<strong class="source-inline">''</strong>), and then we are using the built-in <strong class="source-inline">TemplateView</strong> class, provided by the <strong class="source-inline">django.views.generic</strong> library, to serve up the home page in template form. Since this is a static page and a static URL, meaning no content on the page will change and the URL itself will not change either, we do not need to write a view class to handle how the context of the page will change. Instead, we can <a id="_idIndexMarker551"/>skip creating the view in this example by using the <strong class="source-inline">TemplateView</strong> class. With a <strong class="source-inline">TemplateView</strong> class, we <a id="_idIndexMarker552"/>could still pass in keyword arguments and define the <strong class="source-inline">name</strong> argument if we wanted to. If we did want to pass in <strong class="source-inline">kwargs</strong>, that would be done using the following step.</p>
			<ol>
				<li value="4">Add <strong class="source-inline">kwargs</strong> to your home page:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/urls.py</strong></p><p class="source-code">...</p><p class="source-code">urlpatterns = [   </p><p class="source-code">    <strong class="bold">path(</strong></p><p class="source-code"><strong class="bold">        '', </strong></p><p class="source-code"><strong class="bold">        TemplateView.as_view(</strong></p><p class="source-code"><strong class="bold">            template_name = 'chapter_4/index.html'</strong></p><p class="source-code"><strong class="bold">        ),</strong> </p><p class="source-code">        <strong class="bold">kwargs = {</strong></p><p class="source-code">            <strong class="bold">'sub_title': 'I am the sub title.'</strong></p><p class="source-code">        <strong class="bold">}</strong></p><p class="source-code">    ), </p><p class="source-code">]</p></li>
				<li>In the <strong class="source-inline">/chapter_4/index.html</strong> file that is provided with this book, a conditional will check whether <strong class="source-inline">sub_title</strong> has a value and then displays that value in your template. Copy that<a id="_idIndexMarker553"/> conditional into your file, as highlighted here:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_4/templates/chapter_4/index.html</strong></p><p class="source-code"><strong class="bold">{% load static %}</strong></p><p class="source-code">&lt;html&gt;</p><p class="source-code">    &lt;head&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;</p><p class="source-code">    &lt;body style="text-align:center"&gt;</p><p class="source-code">        &lt;p&gt;<a id="_idTextAnchor122"/>Home Page&lt;/p&gt;</p><p class="source-code">        &lt;img src="<strong class="bold">{% static 'chapter_4/home_page.jpg' %}</strong>" role="img" alt="Home Page Image" width="400" style="margin: 0 auto" /&gt;</p><p class="source-code">        <strong class="bold">{% if sub_title %}</strong></p><p class="source-code">        <strong class="bold">&lt;p&gt;{{ sub_title }}&lt;/p&gt;</strong></p><p class="source-code">        <strong class="bold">{% endif %}</strong></p><p class="source-code">    &lt;/body&gt;</p><p class="source-code">&lt;/html&gt;</p></li>
			</ol>
			<p>We will explain more about building<a id="_idIndexMarker554"/> templates before the end of this chapter, in the <em class="italic">Working with templates</em> section.</p>
			<p>One of the reasons we configured our project to handle static files in <a href="B17243_02_ePub.xhtml#_idTextAnchor037"><em class="italic">Chapter 2</em></a>, <em class="italic">Project Configuration</em>, and in this chapter, under the subsection titled <em class="italic">Static files</em>, was to access those files within a template, as is done in the example shown previously. The <strong class="source-inline">{% load static %}</strong> tag statement allows us to begin using the <strong class="source-inline">static</strong> template tag, such as <strong class="source-inline">{% static 'chapter_4/home_page.jpg' %}</strong>. The <strong class="source-inline">{% static %}</strong> tag returns a working URL, pointing to the image file at <strong class="source-inline">http://localhost:8000/chapter_4/home_page.jpg</strong>. </p>
			<ol>
				<li value="6">Create the <strong class="source-inline">/static/chapter_4/</strong> folder in your project using the IDE, file browser, or the following command:<p class="source-code"><strong class="bold">(virtual_env) PS &gt; mkdir becoming_a_django_entdev/chapter_4/static/chapter_4</strong></p></li>
				<li>Copy the <strong class="source-inline">/chapter_4/home_page.jpg</strong> file provided with the code of this book into your project. </li>
			</ol>
			<p>Django automatically <a id="_idIndexMarker555"/>searches the <strong class="source-inline">static</strong> folder found in each app of a project. It is common practice<a id="_idIndexMarker556"/> to override static files, such as images, CSS, and JavaScript files, of packages that are installed in your virtual environment by including the same path and filename in the static folder of any app in your project. The same principle also applies when working with template files. </p>
			<p>In <em class="italic">step 5</em>, the highlighted <strong class="source-inline">{{ sub_title }}</strong> variable tag is the keyword argument that was passed into that URL pattern in <em class="italic">step 4</em>. A custom function/callable can also be used instead of hardcoding a value here. Any context variable can be recalled in a template using the bracket syntax, <strong class="source-inline">{{ }}</strong>. Objects such as a dictionary, list, set, and query set can all be accessed using a period for each key and subkey, as in <strong class="source-inline">{{ context_variable.key.subkey }}</strong>.</p>
			<ol>
				<li value="8">Now, run your project and you should no longer see a 404 debug message. Instead, you should see the following screenshot:</li>
			</ol>
			<p class="figure-caption"> </p>
			<div>
				<div id="_idContainer052" class="IMG---Figure">
					<img src="image/Figure_4.03_B17243.jpg" alt="Figure 4.3 – Project home page&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.3 – Project home page</p>
			<p>Next, let's work with the <strong class="source-inline">include()</strong> function to<a id="_idIndexMarker557"/> import URL patterns from <a id="_idIndexMarker558"/>other apps/packages.</p>
			<h3>Function – include()</h3>
			<p>The <strong class="source-inline">include()</strong> function is used to import additional <strong class="source-inline">urls.py</strong> files that contain their own <strong class="source-inline">urlpatterns</strong> variable. This is <a id="_idIndexMarker559"/>how we can write URL patterns for reusable apps, and then<a id="_idIndexMarker560"/> include them for use in a project within <strong class="source-inline">ROOT_URLCONF</strong> of a site. </p>
			<p>Let's use this to better organize our chapter-specific URL patterns by following these steps:</p>
			<ol>
				<li value="1">If this file was not already created for you, go ahead and create a <strong class="source-inline">urls.py</strong> file inside of your <strong class="source-inline">/becoming_a_django_entdev/chapter_4/</strong> folder, and then add the following URL pattern to that file:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_4/urls.py</strong></p><p class="source-code">from django.urls </p><p class="source-code">import <strong class="bold">path</strong></p><p class="source-code">from django.views.generic </p><p class="source-code">import <strong class="bold">TemplateView</strong></p><p class="source-code">urlpatterns = [</p><p class="source-code">    <strong class="bold">path(</strong></p><p class="source-code">       <strong class="bold">'chapter-4/', </strong></p><p class="source-code">       <strong class="bold">TemplateView.as_view(</strong></p><p class="source-code">            <strong class="bold">template_name='chapter_4/chapter_4.html'</strong></p><p class="source-code">       <strong class="bold">)</strong></p><p class="source-code">    <strong class="bold">),</strong></p><p class="source-code">]</p></li>
				<li>In the main <strong class="source-inline">/becoming_a_django_entdev/urls.py</strong> file that we have been using, comment out the previous patterns that we created in this chapter and add the<a id="_idIndexMarker561"/> following <strong class="source-inline">path</strong> statement:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/urls.py</strong></p><p class="source-code">...</p><p class="source-code">from django.urls </p><p class="source-code">import <strong class="bold">include</strong>, <strong class="bold">path</strong></p><p class="source-code">urlpatterns = [</p><p class="source-code">    <strong class="bold">path(</strong></p><p class="source-code">        <strong class="bold">'', </strong></p><p class="source-code">        <strong class="bold">include(</strong></p><p class="source-code">           <strong class="bold">'becoming_a_django_entdev.chapter_4.urls'</strong></p><p class="source-code">        <strong class="bold">)</strong></p><p class="source-code">    <strong class="bold">),</strong></p><p class="source-code">]</p></li>
				<li>Copy the <strong class="source-inline">chapter_4.html</strong> template file that is provided with the code of this book into your project, found<a id="_idIndexMarker562"/> in the <strong class="source-inline">/becoming_a_django_entdev/chapter_4/templates/chapter_4/</strong> directory. </li>
				<li>Navigate to the URL <strong class="source-inline">http://localhost:8000/chapter-4/</strong>, and you should see a white page that only says <strong class="bold">This is Chapter 4</strong>, as shown in the following screenshot:</li>
			</ol>
			<div>
				<div id="_idContainer053" class="IMG---Figure">
					<img src="image/Figure_4.04_B17243.jpg" alt="Figure 4.4 – URL pattern – include()&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.4 – URL pattern – include()</p>
			<p>Now that we have the <strong class="source-inline">include()</strong> example working, we will put all new URL patterns in the <strong class="source-inline">/chapter_4/urls.py</strong> file and organize <a id="_idIndexMarker563"/>all future chapters in a similar manner.</p>
			<p>Now, let's practice redirecting URLs.</p>
			<h2 id="_idParaDest-109"><a id="_idTextAnchor123"/>Redirecting patterns</h2>
			<p>Instead of using the <strong class="source-inline">TemplateView</strong> class as we have been, we can write URL patterns to handle redirects from within the project, without having to configure them directly in a web server. This is<a id="_idIndexMarker564"/> convenient because in traditional web development, redirects are handled by the web server and it is much easier to manage in a project than it is in a web server. Redirects can be handled using the <strong class="source-inline">RedirectView</strong> class provided by Django. </p>
			<p>We are going to specify a redirect rule on the <strong class="source-inline">http://localhost:8000/my_path/my_unwanted_url/</strong> path to take us to <strong class="source-inline">http://localhost:8000/my_wanted_url/</strong> instead. Follow these steps to configure your redirect: </p>
			<ol>
				<li value="1">Add the following pattern to your existing <strong class="source-inline">/chapter_4/urls.py</strong> file:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_4/urls.py</strong></p><p class="source-code">...</p><p class="source-code">from django.urls </p><p class="source-code">import include, path</p><p class="source-code">from django.views.generic </p><p class="source-code">import (</p><p class="source-code">    TemplateView,</p><p class="source-code">    <strong class="bold">RedirectView</strong></p><p class="source-code">)</p><p class="source-code">urlpatterns = [</p><p class="source-code">    ...,</p><p class="source-code">    path(</p><p class="source-code">        '<strong class="bold">my_path/my_unwanted_url/</strong>', </p><p class="source-code">        <strong class="bold">RedirectView</strong>.as_view(</p><p class="source-code">            url = '<strong class="bold">http://localhost:8000/my_wanted_url/</strong>'</p><p class="source-code">        )</p><p class="source-code">    ),</p><p class="source-code">]</p></li>
				<li>Run your project and navigate to the URL <strong class="source-inline">http://localhost:8000/my_path/my_unwanted_url/</strong>. You should now be redirected to, and also see in the address bar of the browser, <strong class="source-inline">http://localhost:8000/my_wanted_url/</strong>. In the body of the page, you should see a 404 response because we have not yet defined a URL pattern for the <strong class="source-inline">my_wanted_url</strong> path. This is to be expected when performing this step.</li>
				<li>Additional arguments can be<a id="_idIndexMarker565"/> included, such as stating that we want this to be a permanent or temporary redirect, by writing the path using the following example:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_4/urls.py</strong></p><p class="source-code">...</p><p class="source-code">urlpatterns = [</p><p class="source-code">    ...,</p><p class="source-code">    path(</p><p class="source-code">        'my_path/my_unwanted_url/', </p><p class="source-code">        RedirectView.as_view(</p><p class="source-code">            url = 'http://localhost:8000/my_wanted_url/', </p><p class="source-code">            <strong class="bold">permanent = True</strong></p><p class="source-code">        )</p><p class="source-code">    ),</p><p class="source-code">]</p></li>
			</ol>
			<p>Django also allows us to define <strong class="source-inline">pattern_name</strong> and <strong class="source-inline">query_string</strong> as additional arguments of the <strong class="source-inline">RedirectView</strong> class. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">The preceding path has a hardcoded value of <strong class="source-inline">http://localhost:8000/</strong>, which can become a problem in a remote environment that is not your local machine. To overcome this, you will need to adopt the concept of global context variables discussed later in this chapter in the subsection titled <em class="italic">Creating a context processor</em>.</p>
			<p>Next, let's discuss using path<a id="_idIndexMarker566"/> converters to listen for dynamic path routes.  </p>
			<h2 id="_idParaDest-110"><a id="_idTextAnchor124"/>Using path converters</h2>
			<p>A <strong class="bold">path converter</strong> in Django is a URL pattern <a id="_idIndexMarker567"/>that is designed to listen to a dynamic <a id="_idIndexMarker568"/>path, where that path can change. There are five standard path converters built into Django and available to use: <strong class="source-inline">str</strong>, <strong class="source-inline">int</strong>, <strong class="source-inline">slug</strong>, <strong class="source-inline">uuid</strong>, and <strong class="source-inline">path</strong>. These are preformatted converters that allow a variety of choices and permit strings and integers within a pattern. For example, the path converter called <strong class="source-inline">path</strong> is used in the following code to search for any variety of characters, numbers, and certain symbols that a URL can possess.</p>
			<p>To practice using path converters, follow these steps:</p>
			<ol>
				<li value="1">Add the following URL pattern to your <strong class="source-inline">/chapter_4/urls.py</strong> file:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_4/urls.py </strong></p><p class="source-code">...</p><p class="source-code">from django.urls </p><p class="source-code">import include, path</p><p class="source-code">from django.views.generic </p><p class="source-code">import ..., <strong class="bold">TemplateView</strong></p><p class="source-code">urlpatterns = [</p><p class="source-code">    ...,</p><p class="source-code">    path(</p><p class="source-code">        'my_path/<strong class="bold">&lt;path:my_pattern&gt;</strong>/', </p><p class="source-code">        <strong class="bold">TemplateView</strong>.as_view(</p><p class="source-code">            template_name = 'chapter_4/index.html'</p><p class="source-code">        )</p><p class="source-code">    ),</p><p class="source-code">]</p></li>
				<li>Now, navigate to the URL <strong class="source-inline">http://localhost:8000/my_path/testing/</strong>, and you should see the same home page<a id="_idIndexMarker569"/> that we saw before. We are seeing the same page because we are pointing to the same <strong class="source-inline">index.html</strong> file, just to see that it is working. Additionally, if we navigate to the URL <strong class="source-inline">http://localhost:8000/my_path/2022/</strong>, we will also see the same home page. This is to be expected. The one thing we won't see is the value of the <strong class="source-inline">sub_title</strong> keyword <a id="_idIndexMarker570"/>argument on this page because we did not pass that into this URL pattern. The conditional <strong class="source-inline">{% if sub_title %}</strong> statement found in that template is used to prevent breakage if no <strong class="source-inline">sub_title</strong> is provided.</li>
				<li>Change the existing <strong class="source-inline">my_path</strong> path converter shown in <em class="italic">step 1</em> from path to int and change <strong class="source-inline">my_path</strong> to <strong class="source-inline">my_year_path</strong>, as shown in the<a id="_idIndexMarker571"/> following code, allowing for the URL <strong class="source-inline">http://localhost:8000/my_year_path/2022/</strong> to work:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_4/urls.py </strong></p><p class="source-code">...</p><p class="source-code">from django.urls </p><p class="source-code">import include, path</p><p class="source-code">from django.views.generic </p><p class="source-code">import ..., <strong class="bold">TemplateView</strong></p><p class="source-code">urlpatterns = [</p><p class="source-code">    ...,</p><p class="source-code">    path(</p><p class="source-code">        'my_year_path/<strong class="bold">&lt;int:my_year&gt;</strong>/', </p><p class="source-code">        <strong class="bold">TemplateView</strong>.as_view(</p><p class="source-code">            template_name = 'chapter_4/index.html'</p><p class="source-code">        )</p><p class="source-code">    )</p><p class="source-code">]</p></li>
				<li>Next, run your project again. With the <strong class="source-inline">int</strong> path converter, the URL <strong class="source-inline">http://localhost:8000/my_year_path/testing/</strong> should no longer work when we try to navigate to it. Instead, we should see the same 404 debug message that we saw <a id="_idIndexMarker572"/>earlier. It will only allow a numeric value of any length now. This means we should see the home page image when we visit the URL <strong class="source-inline">http://localhost:8000/my_year_path/2/</strong>, or any numeric value.</li>
			</ol>
			<p>When we wrote <strong class="source-inline">int:my_year</strong>, the <strong class="source-inline">my_year</strong> in this argument can be named anything we want. The same applies to the <strong class="source-inline">my_pattern</strong> in the <strong class="source-inline">path:my_pattern</strong> argument and in any other <a id="_idIndexMarker573"/>converter type. The second parameter is what is used to access that key word argument in a view class or method.</p>
			<p>Let's write a custom path converter next.</p>
			<h3>Custom path converters</h3>
			<p>A custom path converter is a way for us to write a class that uses a regular expression to define the path that Django listens for. The <a id="_idIndexMarker574"/>converter class is structured in a way to return the data type that is<a id="_idIndexMarker575"/> intended to be used in the view, such as an <strong class="source-inline">int</strong> data type used in the example of the previous subsection. This class also returns another string representation of the data type sent to the view that is intended to be used in the URL. For example, if we do<a id="_idIndexMarker576"/> not want <strong class="source-inline">http://localhost:8000/my_year_path/2/</strong> to be a valid URL and we only want to allow four-digit numbers, a custom path converter can be used to accomplish this.</p>
			<p>Follow these steps to create <a id="_idIndexMarker577"/>your custom path converter:</p>
			<ol>
				<li value="1">In your <strong class="source-inline">/chapter_4/</strong> app directory, create a new file called <strong class="source-inline">converters.py</strong>. </li>
				<li>Inside the file, add the following class, with the two methods provided:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_4/converters.py</strong></p><p class="source-code">class <strong class="bold">YearConverter</strong>:</p><p class="source-code">    regex = '[0-9]{4}'</p><p class="source-code">    def <strong class="bold">to_python</strong>(self, value):</p><p class="source-code">        return int(value)</p><p class="source-code">    def <strong class="bold">to_url</strong>(self, value):</p><p class="source-code">        return '%04d' % value</p></li>
				<li>In your <strong class="source-inline">/chapter_4/urls.py</strong> file, add the following code, which registers the newly created converter class for use <a id="_idIndexMarker578"/>where it is highlighted in <strong class="source-inline">&lt;year:year&gt;</strong> in the<a id="_idIndexMarker579"/> following code block:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_4/urls.py</strong></p><p class="source-code">...</p><p class="source-code">from django.urls </p><p class="source-code">import path, <strong class="bold">register_converter</strong></p><p class="source-code">from .converters </p><p class="source-code">import <strong class="bold">YearConverter</strong></p><p class="source-code"><strong class="bold">register_converter(YearConverter, 'year')</strong></p><p class="source-code">urlpatterns = [</p><p class="source-code">    ...,</p><p class="source-code">    path(</p><p class="source-code">        'my_year_path/&lt;<strong class="bold">year</strong>:year&gt;/', </p><p class="source-code">        TemplateView.as_view(</p><p class="source-code">            template_name = 'chapter_4/index.html'</p><p class="source-code">        )</p><p class="source-code">    ),</p><p class="source-code">]</p></li>
				<li>Now, run your project and navigate to the URL <strong class="source-inline">http://localhost:8000/my_year_path/2/</strong>; you should see a 404 debug message. This occurs because the preceding pattern will only accept a four-digit integer now, including <strong class="source-inline">0001</strong> and <strong class="source-inline">1111</strong>, which is to be expected. </li>
			</ol>
			<p>We can get even more in-depth <a id="_idIndexMarker580"/>by writing a method-based or class-based view and in that view compare whether a year is greater than, say, the year 1900, and if it is<a id="_idIndexMarker581"/> not, return a 404 response. We will discuss doing that soon in the section titled <em class="italic">Working with conditional responses</em> of this <a id="_idIndexMarker582"/>chapter.</p>
			<p>Next, let's practice working with regular expression paths.</p>
			<h3>Function – re_path()</h3>
			<p>A <strong class="source-inline">re_path()</strong> function, better known as a regular expression path function, is similar to a <strong class="source-inline">path()</strong> function but allows us <a id="_idIndexMarker583"/>to pass in a formatted regular expression string as<a id="_idIndexMarker584"/> the route parameter without the need to create a custom path converter.</p>
			<p>For example, we could write the same year example as previously without the converter class. In your <strong class="source-inline">/chapter_4/urls.py</strong> file, add the path shown as follows, and comment out the previous <strong class="source-inline">my_year_path</strong>:</p>
			<pre class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_4/urls.py</strong></pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">from django.urls </pre>
			<pre class="source-code">import path, <strong class="bold">re_path</strong></pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">urlpatterns = [</pre>
			<pre class="source-code">    ...,</pre>
			<pre class="source-code">    <strong class="bold">re_path</strong>(</pre>
			<pre class="source-code">        'my_year_path/<strong class="bold">(?P&lt;year&gt;[0-9]{4})/$</strong>', </pre>
			<pre class="source-code">        TemplateView.as_view(</pre>
			<pre class="source-code">            template_name = 'chapter_4/index.html'</pre>
			<pre class="source-code">        )</pre>
			<pre class="source-code">    ),</pre>
			<pre class="source-code">]</pre>
			<p>There is actually a difference between using a <strong class="source-inline">re_path()</strong> function and writing your own converter class. The difference is in the data type of the value of the pattern recognized when we use that value within a view class or method. With the <strong class="source-inline">re_path()</strong> function, the <a id="_idIndexMarker585"/>data type of this value when used in a view will always be a string, whereas the data type of the value when using a converter class will always<a id="_idIndexMarker586"/> be the data type defined by the <strong class="source-inline">def to_python()</strong> method of that class, meaning you can transform the data type to anything you want, if you need to. </p>
			<p>Before we illustrate the difference in data types between using a converter class and using the<a id="_idTextAnchor125"/> <strong class="source-inline">re_path()</strong> function, let's map a URL pattern to a simple view.</p>
			<h1 id="_idParaDest-111"><a id="_idTextAnchor126"/>Mapping URL patterns</h1>
			<p>Writing custom views is a <a id="_idIndexMarker587"/>way for us to perform all of the tasks and services needed to render a page that includes all of the content that we want. Within a view, we can validate against business logic rules to determine how to handle a request. </p>
			<p>In this exercise, we will use the year pattern that we wrote earlier in this chapter, to only allow a year greater than 1900. Anything less than that, we will tell Django to serve up a 404 response.</p>
			<h2 id="_idParaDest-112"><a id="_idTextAnchor127"/>Using simple views</h2>
			<p>A <strong class="bold">simple view</strong> is also known as a <a id="_idIndexMarker588"/>method-based view, which<a id="_idIndexMarker589"/> is a callable function in Python. </p>
			<p>Follow these steps to map to a simple view in your project:</p>
			<ol>
				<li value="1">In your <strong class="source-inline">/chapter_4/urls.py</strong> file, revert to using the same converter class that we wrote in the <em class="italic">Using path converters</em> subsection of this chapter. Reference a view that we will <a id="_idIndexMarker590"/>write next in a different file called <strong class="source-inline">practice_view()</strong>, as highlighted <a id="_idIndexMarker591"/>here:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_4/urls.py </strong></p><p class="source-code">...</p><p class="source-code">from django.urls </p><p class="source-code">import ..., <strong class="bold">register_converter</strong></p><p class="source-code">from .converters </p><p class="source-code">import <strong class="bold">YearConverter</strong></p><p class="source-code">from .views </p><p class="source-code">import <strong class="bold">practice_view</strong></p><p class="source-code"><strong class="bold">register_converter(YearConverter, 'year')</strong></p><p class="source-code">urlpatterns = [</p><p class="source-code">    ...,</p><p class="source-code">    <strong class="bold">path(</strong></p><p class="source-code">        <strong class="bold">'my_year_path/&lt;year:year&gt;/',</strong></p><p class="source-code">        <strong class="bold">practice_view</strong></p><p class="source-code">    <strong class="bold">),</strong></p><p class="source-code">]</p></li>
			</ol>
			<p>The thing we did differently from before is that we replaced the <strong class="source-inline">TemplateView</strong> class with a custom simple view class, called <strong class="source-inline">practice_view</strong>. </p>
			<ol>
				<li value="2">Create the view method called <strong class="source-inline">practice_view()</strong> in a <strong class="source-inline">views.py</strong> file in your <strong class="source-inline">/becoming_a_django_entdev/chapter_4/</strong> directory. Then, add the code shown <a id="_idIndexMarker592"/>here:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_4/views.py</strong></p><p class="source-code">from django.template.response </p><p class="source-code">import (</p><p class="source-code">    TemplateResponse</p><p class="source-code">)</p><p class="source-code">def <strong class="bold">practice_view</strong>(request, year):</p><p class="source-code">    return TemplateResponse(</p><p class="source-code">        request,</p><p class="source-code">        'chapter_4/my_practice_page.html',</p><p class="source-code">        {</p><p class="source-code">           'year': year</p><p class="source-code">        }</p><p class="source-code">    )</p></li>
				<li>Copy the template file<a id="_idIndexMarker593"/> provided with the code of this book into your project, located at <strong class="source-inline">/becoming_a_django_entdev/chapter_4/templates/chapter_4/my_practice_page.html</strong>. </li>
				<li>Navigate to the URL <strong class="source-inline">http://localhost:8000/my_year_path/1066/</strong> and you should see the practice page shown in the following screenshot:</li>
			</ol>
			<div>
				<div id="_idContainer054" class="IMG---Figure">
					<img src="image/Figure_4.05_B17243.jpg" alt="Figure 4.5 – Out-of-bounds year returns valid response&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.5 – Out-of-bounds year returns valid response</p>
			<p>We are almost there. The success message we see here is to be expected. What we actually want is to return a 404 response instead of a valid path, in order to comply with the business logic discussed earlier, to <a id="_idIndexMarker594"/>only allow a year greater than or equal to 1900. Therefore, we need to use <a id="_idIndexMarker595"/>keyword arguments and conditional statements to perform custom validation when a request is processed, which we will do next.</p>
			<h2 id="_idParaDest-113"><a id="_idTextAnchor128"/>Using kwargs in views</h2>
			<p>To access keyword arguments inside of<a id="_idIndexMarker596"/> a view method, we need to pass it in as<a id="_idIndexMarker597"/> a positional argument of that method. In the example, <strong class="source-inline">def practice_view(request, year):</strong>, <strong class="source-inline">year</strong> would be the positional keyword argument. Since we defined a path converter in the <strong class="source-inline">urls.py</strong> file with the name of <strong class="source-inline">year</strong>, we are required to include <strong class="source-inline">year</strong> as a positional argument when accessing a view with that same name. Without <a id="_idIndexMarker598"/>this argument, Django would give us an error during runtime.</p>
			<p>Follow these steps to configure your <strong class="source-inline">view</strong> method:</p>
			<ol>
				<li value="1">In your <strong class="source-inline">/chapter_4/urls.py</strong> file, use the following URL pattern along with the same path converter class that we created earlier. Comment out the other <strong class="source-inline">my_year_path</strong> patterns:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_4/urls.py </strong></p><p class="source-code">...</p><p class="source-code">from django.urls </p><p class="source-code">import ..., register_converter</p><p class="source-code">from .converters </p><p class="source-code">import YearConverter</p><p class="source-code">from .views </p><p class="source-code">import ..., <strong class="bold">practice_year_view</strong></p><p class="source-code">register_converter(YearConverter, 'year')</p><p class="source-code">urlpatterns = [</p><p class="source-code">    ...,</p><p class="source-code">    path(</p><p class="source-code">        '<strong class="bold">my_year_path/&lt;year:year&gt;/</strong>', </p><p class="source-code">        <strong class="bold">practice_year_view</strong></p><p class="source-code">    ),</p><p class="source-code">]</p></li>
				<li>In your <strong class="source-inline">/chapter_4/views.py</strong> file, write the<a id="_idIndexMarker599"/> new method <a id="_idIndexMarker600"/>provided <a id="_idIndexMarker601"/>here:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_4/views.py</strong></p><p class="source-code">from django.template.response </p><p class="source-code">import (</p><p class="source-code">    TemplateResponse</p><p class="source-code">)</p><p class="source-code">...</p><p class="source-code">def <strong class="bold">practice_year_view</strong>(request, <strong class="bold">year</strong>):</p><p class="source-code">    print(type(year))</p><p class="source-code">    print(year)</p><p class="source-code">    return TemplateResponse(</p><p class="source-code">        request, </p><p class="source-code">        'chapter_4/my_year.html', </p><p class="source-code">        {<strong class="bold">'year'</strong>: <strong class="bold">year</strong>}</p><p class="source-code">    )</p></li>
				<li>Copy the template file provided with the code of this book, found in <strong class="source-inline">/becoming_a_django_entdev/chapter_4/templates/chapter_4/my_year.html</strong>. </li>
				<li>Now, navigate to the URL <strong class="source-inline">http://localhost:8000/my_year_path/2022/</strong> and you should see a successful response. When we<a id="_idIndexMarker602"/> look at the terminal or<a id="_idIndexMarker603"/> command window, we will see that it is telling us <a id="_idIndexMarker604"/>the value of <strong class="source-inline">year</strong> is <strong class="source-inline">2022</strong> and that it is of an integer, <strong class="source-inline">&lt;class</strong> <strong class="source-inline">'int'&gt;</strong>, data type, as depicted in the following screenshot:</li>
			</ol>
			<div>
				<div id="_idContainer055" class="IMG---Figure">
					<img src="image/Figure_4.06_B17243.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.6 – Converter class – integer data type</p>
			<ol>
				<li value="5">Change the URL pattern in your <strong class="source-inline">/chapter_4/urls.py</strong> file back to using the <strong class="source-inline">re_path()</strong> function instead of the custom <strong class="source-inline">YearConverter</strong> example, as shown:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_4/urls.py </strong></p><p class="source-code">...</p><p class="source-code">from .views </p><p class="source-code">import ..., <strong class="bold">practice_year_view</strong></p><p class="source-code"><strong class="bold">#</strong>register_converter(YearConverter, 'year')</p><p class="source-code">urlpatterns = [</p><p class="source-code">    ...,</p><p class="source-code">    <strong class="bold">re_path</strong>(</p><p class="source-code">        'my_year_path/(?P&lt;year&gt;[0-9]{4})/$', </p><p class="source-code">        <strong class="bold">practice_year_view</strong></p><p class="source-code">    ),</p><p class="source-code">]</p></li>
			</ol>
			<p>You can comment <a id="_idIndexMarker605"/>out the <strong class="source-inline">register_converter</strong> that we previously used.</p>
			<ol>
				<li value="6">Visit the URL <strong class="source-inline">http://localhost:8000/my_year_path/2022/</strong> one more time. You should see how the output will change from <strong class="source-inline">&lt;class</strong> <strong class="source-inline">'int'&gt;</strong> to <strong class="source-inline">&lt;class 'str'&gt;</strong> in your<a id="_idIndexMarker606"/> terminal or command-line window, as<a id="_idIndexMarker607"/> depicted here: </li>
			</ol>
			<div>
				<div id="_idContainer056" class="IMG---Figure">
					<img src="image/Figure_4.07_B17243.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.7 – Converter class – string data type</p>
			<p>Now, we can actually see the differences between writing a pattern using <strong class="source-inline">re_path()</strong> and the alternative, going through the steps to create a custom converter class. With the <strong class="source-inline">re_path()</strong> function, we now have to take additional steps in a view to convert a keyword argument into an integer before<a id="_idIndexMarker608"/> we can even check <a id="_idIndexMarker609"/>whether the <strong class="source-inline">year</strong> value is greater than a certain year. If we do not do that conversion, we would wind up with an error telling us <strong class="bold">'&gt;=' not supported between instances of 'str' and 'int'</strong>. If the same regular expression pattern is used over and over again, it would mean converting a string into an integer many times, one time for each view that is being used by that pattern. This is what is known as the <strong class="bold">Write Everything Twice</strong> (<strong class="bold">WET</strong>) design principle and is usually frowned upon. Writing a<a id="_idIndexMarker610"/> converter class will solve that problem and allow you to write it just<a id="_idIndexMarker611"/> once according to the <strong class="bold">Don't Repeat Yourself</strong> (<strong class="bold">DRY</strong>) design principle.</p>
			<p>Let's work with conditional <a id="_idIndexMarker612"/>responses next.</p>
			<h2 id="_idParaDest-114"><a id="_idTextAnchor129"/>Working with conditional responses</h2>
			<p>Instead of returning a valid <strong class="source-inline">TemplateResponse()</strong> like we have been doing in previous exercises, we will finally<a id="_idIndexMarker613"/> check if the value of the <strong class="source-inline">year</strong> <strong class="source-inline">kwarg</strong> is greater than or equal to <strong class="source-inline">1900</strong>. If the <strong class="source-inline">year</strong> value is less than <strong class="source-inline">1900</strong>, we are going to raise a <strong class="source-inline">Http404()</strong> response. Using the URL pattern that uses<a id="_idIndexMarker614"/> the custom path converter <strong class="source-inline">YearConverter</strong> class that we wrote earlier, we will serve up an integer instead of a string as the data type of the keyword argument <strong class="source-inline">year</strong>, allowing us to perform mathematical operations using that value.</p>
			<p>Follow these steps to configure your conditional statements:</p>
			<ol>
				<li value="1">In your <strong class="source-inline">/chapter_4/urls.py</strong> file, add the following code, making sure to comment out or delete the other <strong class="source-inline">my_year_path</strong> patterns:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_4/urls.py </strong></p><p class="source-code">...</p><p class="source-code">from django.urls </p><p class="source-code">import ..., register_converter</p><p class="source-code">from .converters </p><p class="source-code">import YearConverter</p><p class="source-code">from .views </p><p class="source-code">import ..., <strong class="bold">practice_year_view</strong> </p><p class="source-code">register_converter(YearConverter, 'year')</p><p class="source-code">urlpatterns = [</p><p class="source-code">    ...,</p><p class="source-code">    path(</p><p class="source-code">        'my_year_path/&lt;year:year&gt;/',</p><p class="source-code">        <strong class="bold">practice_year_view</strong></p><p class="source-code">    ),</p><p class="source-code">]</p></li>
				<li>In your <strong class="source-inline">/chapter_4/views.py</strong> file, modify <strong class="source-inline">practice_year_view()</strong> to look like the following<a id="_idIndexMarker615"/> highlighted<a id="_idIndexMarker616"/> code:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_4/views.py</strong></p><p class="source-code">from django.http </p><p class="source-code">import <strong class="bold">Http404</strong></p><p class="source-code">from django.template.response </p><p class="source-code">import (</p><p class="source-code">    TemplateResponse</p><p class="source-code">)</p><p class="source-code">def practice_year_view(request, <strong class="bold">year</strong>):</p><p class="source-code">    <strong class="bold">if year &gt;= 1900:</strong></p><p class="source-code">        return TemplateResponse(</p><p class="source-code">            request, </p><p class="source-code">            'chapter_4/my_year.html', </p><p class="source-code">            {'year': year}</p><p class="source-code">        )</p><p class="source-code">    <strong class="bold">else:</strong></p><p class="source-code">        <strong class="bold">raise Http404(f'Year Not Found: {year}')</strong></p></li>
				<li>Now, visit the URL <strong class="source-inline">http://localhost:8000/my_year_path/1066/</strong>, and you should see the<a id="_idIndexMarker617"/> following 404 message, which is intentional:</li>
			</ol>
			<div>
				<div id="_idContainer057" class="IMG---Figure">
					<img src="image/Figure_4.08_B17243.jpg" alt="Figure 4.8 – Out-of-bounds year returns invalid response&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.8 – Out-of-bounds year returns invalid response</p>
			<ol>
				<li value="4">Next, visit a path with a year greater than <strong class="source-inline">1900</strong>, such as <strong class="source-inline">http://localhost:8000/my_year_path/2022/</strong>, and you should see a successful response, as<a id="_idIndexMarker618"/> on the year page depicted here:</li>
			</ol>
			<div>
				<div id="_idContainer058" class="IMG---Figure">
					<img src="image/Figure_4.09_B17243.jpg" alt="Figure 4.9 – In-bounds year returns valid response&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.9 –<a id="_idTextAnchor130"/> In-bounds year returns valid response</p>
			<p>Let's link models to our views and templates next.</p>
			<h2 id="_idParaDest-115"><a id="_idTextAnchor131"/>Linking models to views and templates</h2>
			<p>Using the same models that we created in <a href="B17243_03_ePub.xhtml#_idTextAnchor077"><em class="italic">Chapter 3</em></a>, <em class="italic">Models, Relations, and Inheritance</em>, we can<a id="_idIndexMarker619"/> provide information about <a id="_idIndexMarker620"/>those objects within a template. We will write a URL pattern that will point to a new simple view method and display<a id="_idIndexMarker621"/> information about a vehicle.</p>
			<p>Follow these steps to display model information in your templates:</p>
			<ol>
				<li value="1">In your <strong class="source-inline">/chapter_4/urls.py</strong> file, include the following URL pattern:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_4/urls.py </strong></p><p class="source-code">...</p><p class="source-code">from .views </p><p class="source-code">import ..., <strong class="bold">vehicle_view</strong> </p><p class="source-code">urlpatterns = [</p><p class="source-code">    ...,</p><p class="source-code">    <strong class="bold">path(</strong></p><p class="source-code">        <strong class="bold">'vehicle/&lt;int:id&gt;/',</strong></p><p class="source-code">        <strong class="bold">vehicle_view,</strong></p><p class="source-code">        <strong class="bold">name = 'vehicle-detail'</strong></p><p class="source-code">    <strong class="bold">),</strong></p><p class="source-code">]</p></li>
			</ol>
			<p>Our new view will listen for the primary key, also known as the ID, that is passed in to us as a keyword argument of that path converter. The ID is used to look up that object in the<a id="_idIndexMarker622"/> database, and if not found, it will serve up a 404 response instead. Instead of writing <strong class="source-inline">&lt;int:id&gt;</strong>, we could target the path converter to listen for a string, such as the VIN using <strong class="source-inline">&lt;str:vin&gt;</strong>. Then, in the view where we perform the database query, search for a record matching the VIN instead of the ID of a vehicle. You are welcome<a id="_idIndexMarker623"/> to practice both options. </p>
			<ol>
				<li value="2">In your <strong class="source-inline">/chapter_4/views.py</strong> file, add<a id="_idIndexMarker624"/> the following <strong class="source-inline">import</strong> statement and <strong class="source-inline">view</strong> method:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_4/views.py</strong></p><p class="source-code">...</p><p class="source-code">from django.http </p><p class="source-code">import Http404</p><p class="source-code"><strong class="bold">from ..chapter_3.models </strong></p><p class="source-code"><strong class="bold">import Vehicle</strong></p><p class="source-code">def <strong class="bold">vehicle_view</strong>(request, id):</p><p class="source-code">    try:</p><p class="source-code">        <strong class="bold">vehicle = Vehicle.objects.get(id=id)</strong></p><p class="source-code">    except Vehicle.DoesNotExist:</p><p class="source-code">        raise Http404(f'Vehicle ID Not Found: {id}')</p><p class="source-code">    return TemplateResponse(</p><p class="source-code">        request,</p><p class="source-code">        'chapter_4/my_vehicle.html',</p><p class="source-code">        {<strong class="bold">'vehicle': vehicle</strong>}</p><p class="source-code">    )</p></li>
			</ol>
			<p>The preceding <strong class="source-inline">import</strong> statement uses two periods (<strong class="source-inline">..</strong>), which is Python path syntax, to navigate up one directory level and enter the sibling <strong class="source-inline">chapter_3</strong> folder, to access the <a id="_idIndexMarker625"/>models that are written in the <strong class="source-inline">chapter_3</strong> app. When you are working with many different apps in your project, this is common practice. The <strong class="source-inline">try</strong>/<strong class="source-inline">except</strong> block shown previously<a id="_idIndexMarker626"/> checks to see whether the requested object exists and if it does exist, a 404 response is raised. </p>
			<ol>
				<li value="3">Copy the template file<a id="_idIndexMarker627"/> that has been provided along with the code of this book, located at <strong class="source-inline">/becoming_a_django_entdev/chapter_4/templates/chapter_4/my_vehicle.html</strong>. </li>
			</ol>
			<p>We can access any field in a model object from within the template by using the name of the context variable that we passed into <strong class="source-inline">TemplateResponse</strong>. For example, when used in a template file, the <strong class="source-inline">vehicle</strong> context variable would be written as <strong class="source-inline">{{ vehicle.vin }}</strong>. This is already done in the template file you just copied into your<a id="_idIndexMarker628"/> project. </p>
			<ol>
				<li value="4">Run your project and navigate to <strong class="source-inline">http://localhost:8000/vehicle/4/</strong>. You should see vehicle detail information on this page, as shown in the following screenshot: </li>
			</ol>
			<div>
				<div id="_idContainer059" class="IMG---Figure">
					<img src="image/Figure_4.10_B17243.jpg" alt="Figure 4.10 – Vehicle ID = 4&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.10 – Vehicle ID = 4</p>
			<p>If you change the ID in your URL, the vehicle will change. If you activated the VIN as the path converter, then you would navigate to <strong class="source-inline">http://localhost:8000/vehicle/aa456789012345678/</strong> in order to see the same<a id="_idIndexMarker629"/> results, using the data provided in the <strong class="source-inline">chapter_3</strong> data fixture.</p>
			<p>Now that we have views to <a id="_idIndexMarker630"/>work with, we can practice getting the reverse URL when providing only the <strong class="source-inline">kwarg</strong> of a path converter and the <strong class="source-inline">name</strong> attribute value.</p>
			<h1 id="_idParaDest-116"><a id="_idTextAnchor132"/>Resolving URLs</h1>
			<p>Resolving a URL is the process of taking a relative path or object and obtaining the URL that relates to a unique field such as a primary key. Django's reverse<a id="_idIndexMarker631"/> resolution of URL patterns is a method of generating a URL structure using argument values that we provide instead of hardcoding URL paths in places, which can break over time. We can use template tags and statements throughout the project to use the <strong class="source-inline">name</strong> argument of a URL pattern. This is encouraged as best practice and follows a DRY design principle, which is less prone to breakage as your project evolves. </p>
			<p>Let's discuss how to use the <strong class="source-inline">name</strong> attribute to get a reverse resolution pattern.</p>
			<h2 id="_idParaDest-117"><a id="_idTextAnchor133"/>Naming URL patterns</h2>
			<p>Using the<a id="_idIndexMarker632"/> same custom <strong class="source-inline">YearConverter</strong> class and the same <strong class="source-inline">my_year_path</strong> URL pattern that we created earlier in this chapter, do the following to configure your URL pattern.</p>
			<p>In your <strong class="source-inline">/chapter_4/urls.py</strong> file, you should have the path shown in the following code block, using the highlighted <strong class="source-inline">name</strong> attribute:</p>
			<pre class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_4/urls.py </strong></pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">from django.urls </pre>
			<pre class="source-code">import ..., register_converter</pre>
			<pre class="source-code">from .converters </pre>
			<pre class="source-code">import YearConverter</pre>
			<pre class="source-code">from .views </pre>
			<pre class="source-code">import ..., practice_year_view </pre>
			<pre class="source-code">register_converter(YearConverter, 'year')</pre>
			<pre class="source-code">urlpatterns = [</pre>
			<pre class="source-code">    ...,</pre>
			<pre class="source-code">    path(</pre>
			<pre class="source-code">        'my_year_path/&lt;year:year&gt;/', </pre>
			<pre class="source-code">        practice_year_view,</pre>
			<pre class="source-code">        <strong class="bold">name = 'year_url'</strong></pre>
			<pre class="source-code">    ),</pre>
			<pre class="source-code">]</pre>
			<p>Now we can use a <strong class="source-inline">reverse()</strong> function, which<a id="_idIndexMarker633"/> we will do next.</p>
			<h2 id="_idParaDest-118"><a id="_idTextAnchor134"/>Using the reverse() function</h2>
			<p>The <strong class="source-inline">reverse()</strong> function <a id="_idIndexMarker634"/>provides us with the relative URL of an object, providing the <strong class="source-inline">name</strong> attribute value. In our view, we will write several <strong class="source-inline">print</strong> statements to tell us<a id="_idIndexMarker635"/> the relative path of objects when provided with different input arguments. </p>
			<p>Follow these steps to configure your <strong class="source-inline">view</strong> method:</p>
			<ol>
				<li value="1">In your <strong class="source-inline">/chapter_4/views.py</strong> file, add the following <strong class="source-inline">import</strong> statement, below the existing <strong class="source-inline">import</strong> statements:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_4/views.py</strong></p><p class="source-code">...</p><p class="source-code"><strong class="bold">from django.urls import reverse</strong></p></li>
				<li>In your <strong class="source-inline">/chapter_4/views.py</strong> file, and in the same <strong class="source-inline">practice_year_view()</strong> method, go ahead and include the following <strong class="source-inline">print</strong> statements. Make sure these are placed before your conditional statement that executes the <strong class="source-inline">return</strong>/<strong class="source-inline">raise</strong> calls:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_4/views.py</strong></p><p class="source-code">...</p><p class="source-code">def <strong class="bold">practice_year_view</strong>(request, year):</p><p class="source-code">    ...</p><p class="source-code">    <strong class="bold">print(reverse('year_url', args=(2023,)))</strong></p><p class="source-code">    <strong class="bold">print(reverse('year_url', args=(2024,)))</strong></p><p class="source-code">    ...( Repeat as desired )...</p></li>
				<li>Run your project and navigate to any URL using this pattern, such as <strong class="source-inline">http://localhost:8000/my_year_path/2022/</strong>. What will be printed in your terminal or command-line window is the formatted relative path for each of the URLs, as shown<a id="_idIndexMarker636"/> in the following screenshot:</li>
			</ol>
			<div>
				<div id="_idContainer060" class="IMG---Figure">
					<img src="image/Figure_4.11_B17243.jpg" alt="Figure 4.11 – Naming URL – view usage&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.11 – Naming URL – view usage</p>
			<p>The <strong class="source-inline">reverse()</strong> method is how we can look up a URL, using the arguments that are passed into that function. The <strong class="source-inline">reverse()</strong> method can be imported and used anywhere within a project, not just within a view class or method. This method takes in two positional arguments, the first being the name of a URL pattern, such as <strong class="source-inline">year_url</strong> highlighted in the preceding example, and is required. The second positional argument is the keyword arguments that get passed into the <strong class="source-inline">reverse()</strong> method, which is sometimes required. If there is more than one path converter defined for a URL pattern, they would be<a id="_idIndexMarker637"/> included in the <strong class="source-inline">reverse()</strong> method in the order in which they were created for that pattern and separated by a comma. Remember that the position of the keyword arguments pertaining<a id="_idIndexMarker638"/> to each path converter is important and follows the order in which keyword arguments were created for that URL pattern.</p>
			<h2 id="_idParaDest-119"><a id="_idTextAnchor135"/>Using the {% url %} template tag</h2>
			<p>The <strong class="source-inline">{% url arg1 arg2 %}</strong> template<a id="_idIndexMarker639"/> tag works just like the <strong class="source-inline">reverse()</strong> method, except <a id="_idIndexMarker640"/>used directly in a template. This tag also takes in two positional arguments, just like the <strong class="source-inline">reverse()</strong> method does. The first argument listens for the name of the URL pattern and the second is the arguments list. These arguments are separated with a space when using this template tag. Additional arguments are provided in the order the path converters were created for that URL pattern. When using the <strong class="source-inline">{% url %}</strong> tag, it is acceptable to include arguments written with and without keyword syntax. For example, both of the following<a id="_idIndexMarker641"/> tags and how they are used are valid:</p>
			<pre class="source-code"><strong class="bold"># Dummy Code</strong></pre>
			<pre class="source-code">{% url 'year_url' <strong class="bold">2023 5 25</strong> %}</pre>
			<pre class="source-code">{% url 'year_url' <strong class="bold">year=2023 month=5 day=25</strong> %}</pre>
			<p>The second example in the preceding code block would be used if we had actually created three path converters for the URL pattern, being <strong class="source-inline">year</strong>, <strong class="source-inline">month</strong>, and <strong class="source-inline">day</strong>.</p>
			<p>They can also be replaced by using context variables, if we created the three context variables called <strong class="source-inline">year</strong>, <strong class="source-inline">month</strong>, and <strong class="source-inline">day</strong> to be used in a template, as shown in the following code block:</p>
			<pre class="source-code"><strong class="bold"># Dummy Code</strong></pre>
			<pre class="source-code">{% url 'year_url' <strong class="bold">year month day</strong> %}</pre>
			<p>The code shown previously was for illustrative purposes only and will break if you try to use it without building the related URL patterns and views. </p>
			<p>Follow these steps to configure your project for this exercise:</p>
			<ol>
				<li value="1">In your existing <strong class="source-inline">/chapter_4/my_year.html</strong> file, uncomment the following hyperlinks that have been provided with the code of the book when you copied this file into your project or add them manually as shown. They are formatted using the Django <strong class="source-inline">{% url %}</strong> template<a id="_idIndexMarker642"/> tag:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_4/templates/chapter_4/my_year.html</strong></p><p class="source-code">...</p><p class="source-code">&lt;html&gt;</p><p class="source-code">    ...</p><p class="source-code">    &lt;body style="text-align:center"&gt;</p><p class="source-code">        ...</p><p class="source-code">        &lt;br /&gt; &lt;br /&gt;</p><p class="source-code">        <strong class="bold">&lt;a href="{% url 'year_url' 2023 %}"&gt;2023&lt;/a&gt;</strong></p><p class="source-code">        <strong class="bold">&lt;a href="{% url 'year_url' 2024 %}"&gt;<a id="_idTextAnchor136"/>2024&lt;/a&gt;</strong></p><p class="source-code">        ...( Repeat as desired )...</p><p class="source-code">    &lt;/body&gt;</p><p class="source-code">&lt;/html&gt;</p></li>
				<li>Run your project and navigate to the same URL, <strong class="source-inline">http://localhost:8000/my_year_path/2022/</strong>, and you should now see what is depicted in<a id="_idIndexMarker643"/> the following screenshot, with the hyperlinks rendered to the page:</li>
			</ol>
			<div>
				<div id="_idContainer061" class="IMG---Figure">
					<img src="image/Figure_4.12_B17243.jpg" alt="Figure 4.12 – Naming URL – template usage&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.12 – Naming URL – template usage</p>
			<p>Each hyperlink that is rendered points to the correlating relative path at <strong class="source-inline">href="/my_year_path/####/"</strong>. We can continue modifying these two examples to format absolute URLs instead of relative URLs. This means we will include the <strong class="source-inline">www.example.com</strong> part of the URL. We<a id="_idIndexMarker644"/> will discuss that in the section titled <em class="italic">Resolving absolute URLs</em> later in this chapter. Let's process trailing slashes next.</p>
			<h2 id="_idParaDest-120"><a id="_idTextAnchor137"/>Processing trailing slashes</h2>
			<p>In Django, we can use the <strong class="source-inline">re_path()</strong> function in combination with the custom <strong class="source-inline">YearConverter</strong> class to write one <a id="_idIndexMarker645"/>URL pattern accepting a path with <a id="_idIndexMarker646"/>and without a trailing slash, <strong class="source-inline">/</strong>. What this means is that we can write a URL to listen for <strong class="source-inline">www.example.com/my_path/</strong> and will also allow <strong class="source-inline">www.example.com/my_path</strong> to render a success, essentially combining two paths into one statement.</p>
			<p>To process your trailing slashes, in your <strong class="source-inline">/chapter_4/urls.py</strong> file, add the following path and comment out all other <strong class="source-inline">my_year_path</strong> examples:</p>
			<pre class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_4/urls.py</strong></pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">from django.urls import (</pre>
			<pre class="source-code">    ..., </pre>
			<pre class="source-code">    <strong class="bold">re_path</strong>, </pre>
			<pre class="source-code">    <strong class="bold">register_converter</strong></pre>
			<pre class="source-code"><strong class="bold">)</strong></pre>
			<pre class="source-code">from .converters </pre>
			<pre class="source-code">import YearConverter</pre>
			<pre class="source-code">from .views </pre>
			<pre class="source-code">import ..., practice_view</pre>
			<pre class="source-code">register_converter(YearConverter, 'year')</pre>
			<pre class="source-code">urlpatterns = [</pre>
			<pre class="source-code">    ...,</pre>
			<pre class="source-code">    re_path(</pre>
			<pre class="source-code">        <strong class="bold">r'^my_year_path/(?P&lt;year&gt;[0-9]+)/?$'</strong>, </pre>
			<pre class="source-code">        practice_view</pre>
			<pre class="source-code">    ),</pre>
			<pre class="source-code">]</pre>
			<p><strong class="source-inline">route</strong> is defined in the <strong class="source-inline">re_path()</strong> function as <strong class="source-inline">r'^my_year_path/(?P&lt;year&gt;[0-9]+)/?$'</strong>, which constructs the path in a way that will listen for an optional forward slash. <strong class="source-inline">year</strong> is also written using just the tag name. If we were to write the <a id="_idIndexMarker647"/>statement using <strong class="source-inline">&lt;year:year&gt;</strong> as we did in previous exercises, then we would receive the following error message in the terminal or <a id="_idIndexMarker648"/>command-line window:</p>
			<p class="source-code">django.core.exceptions.ImproperlyConfigured: "^my_year_path/(?P&lt;year:year&gt;[0-9]+)/?$" is not a valid regular expression: bad character in group name 'year:year' at position 18</p>
			<p>Since we are listening for a trailing slash via the use of regular expression operations, there is no need to modify values in the <strong class="source-inline">settings.py</strong> file, such as <strong class="source-inline">APPEND_SLASH</strong>. In order to actually use the <strong class="source-inline">APPEND_SLASH</strong> variable, Django requires the <strong class="source-inline">common</strong> middleware to be installed. You can learn more about using this approach instead of the regular expression approach here: https://docs.djangoproject.com/en/4.0/ref/settings/#append-slash. Using the regular expression basic structure shown previously, we don't need to worry about middleware. </p>
			<p>Now that we have resolved relative URLs, let's resolve absolute URLs next.</p>
			<h1 id="_idParaDest-121"><a id="_idTextAnchor138"/>Resolving absolute URLs</h1>
			<p>An absolute URL<a id="_idIndexMarker649"/> includes the scheme, host, and port of a URL, as in the following format, <strong class="source-inline">scheme://host:port/path?query</strong>. This is an example of an absolute URL: <a href="https://www.example.com:8000/my_path?query=my_query_value">https://www.example.com:8000/my_path?query=my_query_value</a>. </p>
			<p>Next, we will resolve an absolute URL while introducing the practice of using custom context processors.</p>
			<h2 id="_idParaDest-122"><a id="_idTextAnchor139"/>Creating a context processor</h2>
			<p>Context processors are useful in many ways: they provide context that is shared globally among all templates <a id="_idIndexMarker650"/>and views within a project. Alternatively, the context being created in a view can only be used by the template that the view is using <a id="_idIndexMarker651"/>and no other templates. In the next example, we will create and then activate a custom global context processor where we will add the base URL of the site. We will call the context variable <strong class="source-inline">base_url</strong>, referring to <strong class="source-inline">scheme://host:port</strong> of the URL found throughout this project's site. </p>
			<p>Follow these steps to create your context processor:</p>
			<ol>
				<li value="1">In the same folder as your <strong class="source-inline">settings.py</strong> file, create a new file called <strong class="source-inline">context_processors.py</strong>. </li>
				<li>Inside this file, place the code provided as follows, which will construct the <strong class="source-inline">http://localhost:8000</strong> portion of the site based on the environment we are running the project on:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/context_processors.py</strong></p><p class="source-code">def <strong class="bold">global_context</strong>(request):</p><p class="source-code">    return {</p><p class="source-code">        '<strong class="bold">base_url</strong>': <strong class="bold">request.build_absolute_uri</strong>(</p><p class="source-code">            <strong class="bold">'/'</strong></p><p class="source-code">        )[:-1].strip('/'),</p><p class="source-code">    }</p></li>
			</ol>
			<p>Context is returned as a dictionary of key-value pairs, where we can pack as many keys as we would like to. </p>
			<ol>
				<li value="3">To register this context processor for inclusion during runtime, we need to add it to the <strong class="source-inline">settings.py</strong> file, under the <strong class="source-inline">TEMPLATES</strong> variable. Include the path to your <strong class="source-inline">global_context()</strong> method, as shown:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/settings.py</strong></p><p class="source-code">TEMPLATES = [</p><p class="source-code">{</p><p class="source-code">        ...</p><p class="source-code">        'OPTIONS': </p><p class="source-code">        {</p><p class="source-code">            '<strong class="bold">context_processors</strong>': [</p><p class="source-code">                ...,</p><p class="source-code"><strong class="bold">'becoming_a_django_entdev.context_processors.global_context'</strong>,</p><p class="source-code">            ],</p><p class="source-code">        },</p><p class="source-code">},]</p></li>
			</ol>
			<p>Place your custom context processor below any existing <strong class="source-inline">context_processors</strong> in the preceding list.</p>
			<p>Context processors can be broken<a id="_idIndexMarker652"/> down into individual apps within a project as well. Include each additional context processor that you create<a id="_idIndexMarker653"/> inside the preceding list and in the order desired. Additional global context processor variables have been included with the code of this book for extra practice as well.</p>
			<p>Let's use our newly created <strong class="source-inline">base_url</strong> context in a template next.</p>
			<h3>Using context processor data in a template</h3>
			<p>Using a <strong class="source-inline">{% url %}</strong> template <a id="_idIndexMarker654"/>tag, we can modify hyperlinks to use the context that we just made available in the previous example as a context processor called <strong class="source-inline">global_context()</strong>.</p>
			<p>Follow these steps to configure your template: </p>
			<ol>
				<li value="1">In your <strong class="source-inline">/chapter_4/urls.py</strong> file, add the following path and comment out all other <strong class="source-inline">my_year_path</strong> examples:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_4/urls.py</strong></p><p class="source-code">...</p><p class="source-code"><strong class="bold">from django.urls </strong></p><p class="source-code"><strong class="bold">import ..., register_converter</strong></p><p class="source-code"><strong class="bold">from .converters </strong></p><p class="source-code"><strong class="bold">import YearConverter</strong></p><p class="source-code"><strong class="bold">from .views </strong></p><p class="source-code"><strong class="bold">import ..., practice_year_view </strong></p><p class="source-code"><strong class="bold">register_converter(YearConverter, 'year')</strong></p><p class="source-code"><strong class="bold">urlpatterns = [</strong></p><p class="source-code"><strong class="bold">    ...,</strong></p><p class="source-code"><strong class="bold">    path(</strong></p><p class="source-code"><strong class="bold">        'my_year_path/&lt;year:year&gt;/', </strong></p><p class="source-code"><strong class="bold">        practice_year_view,</strong></p><p class="source-code"><strong class="bold">        name = 'year_url'</strong></p><p class="source-code">    ),</p><p class="source-code">]</p></li>
				<li>In your <strong class="source-inline">my_year.html</strong> file, write/uncomment <a id="_idIndexMarker655"/>the following hyperlink examples:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_4/templates/chapter_4/my_year.html</strong></p><p class="source-code">...</p><p class="source-code">&lt;html&gt;</p><p class="source-code">    ...</p><p class="source-code">    &lt;body style="text-align:center"&gt;</p><p class="source-code">        ...</p><p class="source-code">        &lt;br /&gt; &lt;br /&gt;</p><p class="source-code">        &lt;a href="<strong class="bold">{{ base_url }}</strong>{% url 'year_url' 2023 %}"&gt;2023&lt;/a&gt;</p><p class="source-code">        &lt;a href="<strong class="bold">{{ base_url }}</strong>{% url 'year_url' 2024 %}"&gt;2024&lt;/a&gt;          </p><p class="source-code">        ...( Repeat as desired )...</p><p class="source-code">    &lt;/body&gt;</p><p class="source-code">&lt;/html&gt;</p></li>
				<li>Navigate to <strong class="source-inline">http://localhost:8000/my_year_path/2022/</strong> one more time. Your <strong class="source-inline">href</strong> attribute on each hyperlink will now look like <strong class="source-inline">href="http://localhost:8000/my_year_path/####/"</strong> instead of what it was rendering before, as <strong class="source-inline">href="/my_year_path/####/"</strong>. </li>
			</ol>
			<p>When we added the <strong class="source-inline">{{ base_url }}</strong> template variable, we referenced the dictionary key of the context<a id="_idIndexMarker656"/> that was provided.</p>
			<h2 id="_idParaDest-123"><a id="_idTextAnchor140"/>From the request object</h2>
			<p>In this exercise, we will resolve the <a id="_idIndexMarker657"/>absolute URL using a <strong class="source-inline">request</strong> object. Follow these<a id="_idIndexMarker658"/> steps to do that in your project:</p>
			<ol>
				<li value="1">In your <strong class="source-inline">/chapter_4/views.py</strong> file, in your existing <strong class="source-inline">practice_year_view()</strong> method, include the following <strong class="source-inline">print</strong> statements. These statements will use the <strong class="source-inline">build_absolute_uri()</strong> method provided in your <strong class="source-inline">request</strong> object, as part of the Django framework. This will return to us the absolute URL of the reverse lookup:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_4/views.py</strong></p><p class="source-code">...</p><p class="source-code">from django.urls </p><p class="source-code">import <strong class="bold">reverse</strong></p><p class="source-code">def <strong class="bold">practice_year_view</strong>(request, year):</p><p class="source-code">    ...</p><p class="source-code">    print(</p><p class="source-code">        <strong class="bold">request.build_absolute_uri</strong>(</p><p class="source-code">            <strong class="bold">reverse</strong>('year_url', args=(<strong class="bold">2023</strong>,))</p><p class="source-code">        )</p><p class="source-code">    )</p><p class="source-code">    print(</p><p class="source-code">        <strong class="bold">request.build_absolute_uri</strong>(</p><p class="source-code">            <strong class="bold">reverse</strong>('year_url', args=(<strong class="bold">2024</strong>,))</p><p class="source-code">        )</p><p class="source-code">    )</p><p class="source-code">    ...( Repeat as desired )...</p></li>
			</ol>
			<p>The preceding <strong class="source-inline">print</strong> statements also utilize the <strong class="source-inline">reverse()</strong> method found in the <strong class="source-inline">django.urls</strong> library.</p>
			<ol>
				<li value="2">Run your<a id="_idIndexMarker659"/> project and<a id="_idIndexMarker660"/> navigate to <strong class="source-inline">http://localhost:8000/my_year_path/2022/</strong>. You should see the following paths printed in your terminal or command-line window:</li>
			</ol>
			<div>
				<div id="_idContainer062" class="IMG---Figure">
					<img src="image/Figure_4.13_B17243.jpg" alt="Figure 4.13 – Naming URL – view usage – absolute URL&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.13 – Naming URL – view usage – absolute URL</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The relative path of the current page can be retrieved from the <strong class="source-inline">request</strong> object using <strong class="source-inline">print(request.path)</strong>. On this page, it would return <strong class="source-inline">/my_year_path/2022/</strong>. Using <strong class="source-inline">print(request.build_absolute_uri())</strong> without the <strong class="source-inline">reverse()</strong> lookup function will return the absolute path of that particular request.</p>
			<p>Let's practice looking <a id="_idIndexMarker661"/>up absolute URLs from within a model class <a id="_idIndexMarker662"/>next.</p>
			<h2 id="_idParaDest-124"><a id="_idTextAnchor141"/>From within a model class</h2>
			<p>We will be expanding<a id="_idIndexMarker663"/> on the same <strong class="source-inline">vehicle_view()</strong> method for this <a id="_idIndexMarker664"/>next example, to get a formatted URL from an existing object. We are going to work in the same <strong class="source-inline">/chapter_3/models.py</strong> file that we worked on in <a href="B17243_03_ePub.xhtml#_idTextAnchor077"><em class="italic">Chapter 3</em></a>, <em class="italic">Models, Relations, and Inheritance</em>. </p>
			<p>Follow these steps to configure your model class:</p>
			<ol>
				<li value="1">In your <strong class="source-inline">/chapter_3/models.py</strong> file, add the following two methods (<strong class="source-inline">get_url()</strong> and <strong class="source-inline">get_absolute_url()</strong>) to <a id="_idIndexMarker665"/>your existing <strong class="source-inline">Vehicle</strong> model <a id="_idIndexMarker666"/>class: <p class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_3/models.py</strong> </p><p class="source-code">class <strong class="bold">Vehicle</strong>(models.Model):</p><p class="source-code">    ...</p><p class="source-code">    <strong class="bold">def get_url(self):</strong></p><p class="source-code">        from django.urls import <strong class="bold">reverse</strong></p><p class="source-code">        return <strong class="bold">reverse</strong>(</p><p class="source-code">            'vehicle-detail', </p><p class="source-code">            kwargs = {'id': self.pk}</p><p class="source-code">        )</p><p class="source-code">    <strong class="bold">def get_absolute_url(self, request):</strong></p><p class="source-code">        from django.urls import <strong class="bold">reverse</strong></p><p class="source-code">        base_url = request.build_absolute_uri(</p><p class="source-code">            '/'</p><p class="source-code">        )[:-1].strip('/')</p><p class="source-code">        return base_url + <strong class="bold">reverse</strong>(</p><p class="source-code">            'vehicle-detail', </p><p class="source-code">            kwargs = {'id': self.pk}</p><p class="source-code">        )</p></li>
			</ol>
			<p>These methods import the <strong class="source-inline">reverse()</strong> function that was introduced earlier in this section to get the URL of the object in reference. The <strong class="source-inline">import</strong> statements are added to the methods<a id="_idIndexMarker667"/> themselves instead of at the<a id="_idIndexMarker668"/> top of this document to allow for better performance handling when using these model class methods. The first method, <strong class="source-inline">get_url()</strong>, is used to return a relative URL path to that object, while the other method, <strong class="source-inline">get_absolute_url()</strong>, is intended to return the absolute path to that object. </p>
			<ol>
				<li value="2">In your <strong class="source-inline">/chapter_4/views.py</strong> file, in the existing <strong class="source-inline">vehicle_view()</strong> method, add the following <strong class="source-inline">print</strong> statements as part of the <strong class="source-inline">else</strong> catch, just after the <strong class="source-inline">except</strong> catch:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_4/views.py</strong></p><p class="source-code">...</p><p class="source-code">from django.http </p><p class="source-code">import <strong class="bold">Http404</strong></p><p class="source-code">from ..chapter_3.models </p><p class="source-code">import <strong class="bold">Vehicle</strong></p><p class="source-code">...</p><p class="source-code">def <strong class="bold">vehicle_view</strong>(request, id):</p><p class="source-code">    try:</p><p class="source-code">        vehicle = <strong class="bold">Vehicle</strong>.objects.get(id=id)</p><p class="source-code">    except <strong class="bold">Vehicle</strong>.DoesNotExist:</p><p class="source-code">        raise <strong class="bold">Http404</strong>(f'Vehicle ID Not Found: {id}')</p><p class="source-code">    <strong class="bold">else:</strong></p><p class="source-code">        <strong class="bold">print(vehicle.get_url())</strong></p><p class="source-code">        <strong class="bold">print(vehicle.get_absolute_url(request))</strong></p><p class="source-code"><strong class="bold">    ...</strong></p></li>
			</ol>
			<p>The <strong class="source-inline">else</strong> catch means the <strong class="source-inline">Vehicle</strong> object that it was searching for was found without errors. Remember to leave the same <strong class="source-inline">return</strong> statement that we previously wrote at<a id="_idIndexMarker669"/> the end of this <strong class="source-inline">vehicle_view()</strong> method.</p>
			<ol>
				<li value="3">Run your project and navigate to <strong class="source-inline">http://localhost:8000/vehicle/4/</strong>. In your terminal or command-line window, you should see the two different relative and absolute paths to the object that we looked<a id="_idIndexMarker670"/> up in the <strong class="source-inline">vehicle_view()</strong> method, as shown:</li>
			</ol>
			<div>
				<div id="_idContainer063" class="IMG---Figure">
					<img src="image/Figure_4.14_B17243.jpg" alt="Figure 4.14 – Model URLs&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.14 – Model URLs</p>
			<p>We have been practicing with simple views, otherwise known as method-based views. Many projects need views to provide a bit more power and usability, which can be achieved with class-based views, which we will create next.</p>
			<h1 id="_idParaDest-125"><a id="_idTextAnchor142"/>Working with complex views</h1>
			<p>A view method will suffice for<a id="_idIndexMarker671"/> a lot of different situations. For more robust and large-scale projects, we can apply a few tricks to make these views more adaptable in complicated use cases. Class-based views are used when writing adaptable and reusable applications.</p>
			<h2 id="_idParaDest-126"><a id="_idTextAnchor143"/>Class-based views</h2>
			<p>With class-based views, we can write code that can be reused and extended easily. Just like when we extended models in <a href="B17243_03_ePub.xhtml#_idTextAnchor077"><em class="italic">Chapter 3</em></a>, <em class="italic">Models, Relations, and Inheritance</em>, we can extend view classes in<a id="_idIndexMarker672"/> the exact same way, whereas function-based view methods cannot provide this ability. Two templates have been provided with the source<a id="_idIndexMarker673"/> code of this book to be used in the next exercise. These two files are the exact same file as the <strong class="source-inline">my_vehicle.html</strong> file, except that the title of the <strong class="source-inline">&lt;h1&gt;</strong> tag in each has been changed to <strong class="bold">VehicleView Class 1</strong> and <strong class="bold">VehicleView Class 2</strong> so that when we run the following examples, we can see the differences between them.</p>
			<p>Follow these steps to configure your class-based views:</p>
			<ol>
				<li value="1">Copy the files called <strong class="source-inline">my_vehicle_class_1.html</strong> and <strong class="source-inline">my_vehicle_class_2.html</strong> in the <strong class="source-inline">/becoming_a_django_entdev/chapter_4/templates/chapter_4/</strong> directory of the code provided with this book into your project at the same directory.</li>
				<li>In your <strong class="source-inline">/chapter_4/urls.py</strong> file, add the following <strong class="source-inline">import</strong> statement and URL pattern:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_4/urls.py</strong></p><p class="source-code">...</p><p class="source-code">from .views </p><p class="source-code">import ..., <strong class="bold">VehicleView</strong></p><p class="source-code">urlpatterns = [</p><p class="source-code">    ...,</p><p class="source-code">    path(</p><p class="source-code">        'vehicle/&lt;int:id&gt;/', </p><p class="source-code">        <strong class="bold">VehicleView.as_view()</strong>,</p><p class="source-code">        name = 'vehicle-detail'</p><p class="source-code">    ),</p><p class="source-code">]</p></li>
			</ol>
			<p>Don't forget to comment out the old <strong class="source-inline">/vehicle/</strong> URL patterns that were written before<a id="_idIndexMarker674"/> experimenting with this one. </p>
			<ol>
				<li value="3">In your <strong class="source-inline">/chapter_4/views.py</strong> file, create the class-based view called <strong class="source-inline">VehicleView</strong> and add<a id="_idIndexMarker675"/> the <strong class="source-inline">import</strong> statements, as shown:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_4/views.py</strong></p><p class="source-code">...</p><p class="source-code">from django.http </p><p class="source-code">import <strong class="bold">Http404</strong></p><p class="source-code">from django.template.response </p><p class="source-code">import (</p><p class="source-code">    <strong class="bold">TemplateResponse</strong></p><p class="source-code"><strong class="bold">)</strong></p><p class="source-code">from django.views.generic </p><p class="source-code">import <strong class="bold">View</strong></p><p class="source-code">from ..chapter_3.models </p><p class="source-code">import <strong class="bold">Vehicle</strong></p><p class="source-code">...</p><p class="source-code"><strong class="bold">class VehicleView(View):</strong></p><p class="source-code">    <strong class="bold">template_name</strong> = 'chapter_4/my_vehicle_class_1.html'</p></li>
				<li>Add the following <strong class="source-inline">get()</strong> method to your <strong class="source-inline">VehicleView</strong> class:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_4/views.py</strong></p><p class="source-code">...</p><p class="source-code"><strong class="bold">class VehicleView(View):</strong></p><p class="source-code">    ...</p><p class="source-code">    <strong class="bold">def get</strong>(self, request, <strong class="bold">id</strong>, *args, **kwargs):</p><p class="source-code">        try:</p><p class="source-code">            vehicle = <strong class="bold">Vehicle</strong>.objects.get(id=id)</p><p class="source-code">        except <strong class="bold">Vehicle</strong>.DoesNotExist:</p><p class="source-code">            raise <strong class="bold">Http404</strong>(</p><p class="source-code">                f'Vehicle ID Not Found: {id}'</p><p class="source-code">            )</p><p class="source-code">        return <strong class="bold">TemplateResponse</strong>(</p><p class="source-code">            request,</p><p class="source-code">            self.template_name,</p><p class="source-code">            {'vehicle': vehicle}</p><p class="source-code">        )</p></li>
				<li>Add the following <strong class="source-inline">post()</strong> method <a id="_idIndexMarker676"/>and import to <a id="_idIndexMarker677"/>your <strong class="source-inline">VehicleView</strong> class:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_4/views.py</strong></p><p class="source-code">...</p><p class="source-code">from django.http </p><p class="source-code">import ..., <strong class="bold">HttpResponseRedirect</strong></p><p class="source-code">...</p><p class="source-code"><strong class="bold">class VehicleView(View):</strong></p><p class="source-code"><strong class="bold">    ...</strong></p><p class="source-code">    <strong class="bold">def post</strong>(self, request, *args, **kwargs):</p><p class="source-code">        return <strong class="bold">HttpResponseRedirect</strong>(</p><p class="source-code">            '/success/'</p><p class="source-code">        )</p></li>
				<li>Run your project and navigate to <strong class="source-inline">http://localhost:8000/vehicle/4/</strong>. You should see the main title is displayed as <strong class="bold">VehicleView Class 1</strong> now. </li>
				<li>Next, modify the URL pattern<a id="_idIndexMarker678"/> to overload <strong class="source-inline">template_name</strong>, using the<a id="_idIndexMarker679"/> following example:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_4/urls.py</strong></p><p class="source-code">...</p><p class="source-code">from .views </p><p class="source-code">import ..., VehicleView</p><p class="source-code">urlpatterns = [</p><p class="source-code">    ...,</p><p class="source-code">    path(</p><p class="source-code">        'vehicle/&lt;int:id&gt;/', </p><p class="source-code">        VehicleView.as_view(</p><p class="source-code">            <strong class="bold">template_name = 'chapter_4/my_vehicle_class_2.html'</strong></p><p class="source-code">        ),</p><p class="source-code">        name = 'vehicle-detail'</p><p class="source-code">    ),</p><p class="source-code">]</p></li>
				<li>Now, rerun your project and navigate to the URL at <strong class="source-inline">http://localhost:8000/vehicle/4/</strong>. You should see the title on the page displayed as <strong class="bold">VehicleView Class 2</strong> this time.</li>
			</ol>
			<p>The <strong class="source-inline">def get()</strong> submethod depicted in <em class="italic">step 4</em> is where all of the code in the method-based view is moved to. It's also the only required method. Other optional methods, such as <strong class="source-inline">def post()</strong>, are used when working with form objects, when a postback response is executed. It can also be used to redirect the user to a success page, which is illustrated in the code of <em class="italic">step 5</em>, but <a id="_idIndexMarker680"/>you will never get Django to trigger this redirect <a id="_idIndexMarker681"/>with how we are using this class now, which is to be expected. We will discuss this in more depth later in <a href="B17243_05_ePub.xhtml#_idTextAnchor152"><em class="italic">Chapter 5</em></a>, <em class="italic">Django Forms</em>. When we are working with positional keyword arguments of a URL, they are passed into the view class, where the <strong class="source-inline">id</strong> attribute is written in the preceding <strong class="source-inline">get()</strong> method. If you have more than one keyword argument, they would be added after <strong class="source-inline">id</strong> in the order that they exist in that URL pattern. </p>
			<p>We performed <em class="italic">step 7</em> and <em class="italic">step 8</em> just to check that this is working and to see how we can still override default settings just like we did earlier in this chapter. Let's extend our class-based views next, also known as inheritance.</p>
			<h2 id="_idParaDest-127"><a id="_idTextAnchor144"/>Extending class-based views</h2>
			<p>Extending class-based views, also known as inheritance, is done in<a id="_idIndexMarker682"/> the exact same way as when<a id="_idIndexMarker683"/> we extended model classes in <a href="B17243_03_ePub.xhtml#_idTextAnchor077"><em class="italic">Chapter 3</em></a>, <em class="italic">Models, Relations, and Inheritance</em>. We can display the same title on the page by extending the first class into a second class, eliminating the need to define <strong class="source-inline">template_name</strong> in the URL pattern itself, among many other benefits. </p>
			<p>Follow these steps to extend your class:</p>
			<ol>
				<li value="1">In your <strong class="source-inline">/chapter_4/urls.py</strong> file, comment out the previous URL patterns and write a new one using the code provided, where we are using <strong class="source-inline">VehicleView2</strong> as the view class now:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_4/urls.py</strong></p><p class="source-code">...</p><p class="source-code">from .views </p><p class="source-code">import ..., <strong class="bold">VehicleView2</strong></p><p class="source-code">urlpatterns = [</p><p class="source-code">    ...,</p><p class="source-code">    path(</p><p class="source-code">        'vehicle/&lt;int:id&gt;/', </p><p class="source-code">        <strong class="bold">VehicleView2.as_view()</strong>, </p><p class="source-code">        name = 'vehicle-detail'</p><p class="source-code">    ),</p><p class="source-code">]</p></li>
				<li>Next, in your <strong class="source-inline">/chapter_4/views.py</strong> file, add the following <strong class="source-inline">VehicleView2</strong> class constructed <a id="_idIndexMarker684"/>from the <strong class="source-inline">VehicleView</strong> class:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_4/views.py</strong></p><p class="source-code">...</p><p class="source-code">class <strong class="bold">VehicleView2</strong>(<strong class="bold">VehicleView</strong>):</p><p class="source-code">    template_name = 'chapter_4/my_vehicle_class_2.html'</p></li>
				<li>Run your project and navigate to the URL <strong class="source-inline">http://localhost:8000/vehicle/4/</strong>. You should see the same title, <strong class="bold">VehicleView Class 2</strong>, displayed on the page.</li>
			</ol>
			<p>The preceding example is just a very <a id="_idIndexMarker685"/>simple extension of the existing <strong class="source-inline">VehicleView</strong> class that demonstrates how to extend a view class. The only thing we are changing/overriding in this exercise is the <strong class="source-inline">template_name</strong> variable in order to demonstrate this concept.</p>
			<p>Next, let's learn what asynchronous views are used for.</p>
			<h2 id="_idParaDest-128"><a id="_idTextAnchor145"/>Asynchronous views</h2>
			<p>Django also offers support of asynchronous views, a feature first introduced in Django 3.1. Asynchronous views are views<a id="_idIndexMarker686"/> that can be processed in individual processing threads and run together at the same time. These are used to build better multithreaded apps. Traditional <a id="_idIndexMarker687"/>Django projects use the <strong class="bold">Web Server Gateway Interface</strong> (<strong class="bold">WSGI</strong>) by default. To actually use asynchronous function- and class-based views, we need to configure a project and the server to use the <strong class="bold">Asynchronous Server Gateway Interface</strong> (<strong class="bold">ASGI</strong>) instead of WSGI. Since<a id="_idIndexMarker688"/> this requires quite a bit more work to configure the server and potentially the hosting provider, we will skip providing any examples for this section, but if this is something you want or need in your project, you can get started here: <a href="https://docs.djangoproject.com/en/4.0/topics/async/">https://docs.djangoproject.com/en/4.0/topics/async/</a>.  </p>
			<p>Up to now, we have been using templates that have been pre-built and provided with the code of this book in order to demonstrate core programming concepts. Next, let's explore what it takes to actually build those templates on our own.</p>
			<h1 id="_idParaDest-129"><a id="_idTextAnchor146"/>Working with templates</h1>
			<p>The Django template language<a id="_idIndexMarker689"/> provides us with a set of template tags and template filters that are used to perform simple actions directly within a template. It makes it easy to perform simple logic operations, such as Python operations. Tags and filters are actually two different things that closely resemble each other. The Django template language can be closely compared to Shopify's Liquid syntax and is similar to the Razor syntax used in ASP.NET frameworks, but the Django template language is a bit easier to use and read. Django also allows us to create custom tags and filters for use within a project. Custom filters are most commonly used to transform a single context variable. Custom tags provide for more robust and complex use cases. For a complete breakdown of all of the template tags and template filters that exist, read the official Django documentation about them here: <a href="https://docs.djangoproject.com/en/4.0/ref/templates/builtins/">https://docs.djangoproject.com/en/4.0/ref/templates/builtins/</a>. </p>
			<p>Next, we will touch briefly on the features and capabilities of the most commonly used template tags and filters that are available.</p>
			<h2 id="_idParaDest-130"><a id="_idTextAnchor147"/>Template tags</h2>
			<p>We can structure a template to feel more like an app by breaking it down into smaller components. Those components <a id="_idIndexMarker690"/>can then be used interchangeably within other templates. For example, we can write a base template that contains the <strong class="source-inline">&lt;head&gt;</strong> and <strong class="source-inline">&lt;body&gt;</strong> elements of a page and then break apart subtemplates that structure the body content of each of those templates. Areas can be created in the <strong class="source-inline">&lt;head&gt;</strong> and <strong class="source-inline">&lt;body&gt;</strong> of a document where we can pass dynamic text and HTML into them, such as the <strong class="source-inline">&lt;title&gt;</strong> tag. </p>
			<p>For the next example, let's use the <strong class="source-inline">{% block %}</strong>, <strong class="source-inline">{% extend %}</strong>, and <strong class="source-inline">{% include %}</strong> template tags to create two template files, demonstrating how to break templates down into manageable pieces. </p>
			<p>Follow these steps to configure your template tags:</p>
			<ol>
				<li value="1">In your <strong class="source-inline">/chapter_4/urls.py</strong> file, comment out the other paths and include the following path:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_4/urls.py</strong></p><p class="source-code">...</p><p class="source-code">from .views </p><p class="source-code">import ..., <strong class="bold">TestPageView</strong></p><p class="source-code">urlpatterns = [</p><p class="source-code">    ...,</p><p class="source-code">    path(</p><p class="source-code">        'test_page_1/', </p><p class="source-code">        <strong class="bold">TestPageView</strong>.as_view(), </p><p class="source-code">        name = 'test-page'</p><p class="source-code">    ),</p><p class="source-code">]</p></li>
				<li>In your <strong class="source-inline">/chapter_4/views.py</strong> file, create the following class-based view called <strong class="source-inline">TestPageView</strong>, using the code provided here:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_4/views.py</strong></p><p class="source-code">...</p><p class="source-code">from django.template.response </p><p class="source-code">import (</p><p class="source-code">    <strong class="bold">TemplateResponse</strong></p><p class="source-code">)</p><p class="source-code">from django.views.generic </p><p class="source-code">import <strong class="bold">View</strong></p><p class="source-code">...</p><p class="source-code">class <strong class="bold">TestPageView</strong>(<strong class="bold">View</strong>):</p><p class="source-code">    template_name = 'chapter_4/pages/test_page_1.html'</p><p class="source-code">    def get(self, request, *args, **kwargs):</p><p class="source-code">        return <strong class="bold">TemplateResponse</strong>(</p><p class="source-code">            request, </p><p class="source-code">            self.template_name, </p><p class="source-code">            {</p><p class="source-code">                'title': 'My Test Page 1',</p><p class="source-code">                'page_id': 'test-id-1',</p><p class="source-code">                'page_class': 'test-page-1',</p><p class="source-code">                'h1_tag': 'This is Test Page 1'</p><p class="source-code">            }</p><p class="source-code">        )</p></li>
			</ol>
			<p>In the <strong class="source-inline">TestPageView</strong> class, we are <a id="_idIndexMarker691"/>defining a default <strong class="source-inline">template_name</strong> as <strong class="source-inline">'chapter_4/pages/test_page_1.html'</strong>. In the <strong class="source-inline">get()</strong> method, we pass in hardcoded context variables to be used in this demonstration. In a real-world scenario, this information would be generated after performing logic that is <a id="_idIndexMarker692"/>written to generate those values. </p>
			<ol>
				<li value="3">Create the <strong class="source-inline">/becoming_a_django_entdev/chapter_4/templates/chapter_4/pages/test_page_1.html</strong> file and add the following code:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_4/templates/chapter_4/pages/test_page_1.html</strong></p><p class="source-code">{% extends 'chapter_4/base/base_template_1.html' %}</p><p class="source-code">{% load static %}</p><p class="source-code"><strong class="bold">{% block page_title %}{{ title }}{% endblock %}</strong></p><p class="source-code">{% block head_stylesheets %}{% endblock %}</p><p class="source-code">{% block js_scripts %}{% endblock %}</p><p class="source-code">{% block page_id %}{{ page_id }}{% endblock %}</p><p class="source-code">{% block page_class %}<strong class="bold">{{ block.super }}</strong> {{ page_class }}{% endblock %}</p><p class="source-code">{% block <strong class="bold">body_content</strong> %}</p><p class="source-code">    {% <strong class="bold">if</strong> h1_tag %}</p><p class="source-code">        &lt;h1&gt;{{ h1_tag }}&lt;/h1&gt;</p><p class="source-code">    {% <strong class="bold">else</strong> %}</p><p class="source-code">        &lt;h1&gt;Title Not Found&lt;/h1&gt;</p><p class="source-code">    {% <strong class="bold">endif</strong> %}</p><p class="source-code">{% endblock %}</p></li>
			</ol>
			<p>This template starts with the <strong class="source-inline">{% extends %}</strong> template tag, which states that we want to actually start with the <strong class="source-inline">/chapter_4/base/base_template_1.html</strong> file, even though we specified the <strong class="source-inline">test_page_1.html</strong> file in our view class. Then, everywhere there is a <strong class="source-inline">{% block %}</strong> tag found in this file, we override or append to that same <strong class="source-inline">{% block %}</strong> found in the <strong class="source-inline">base_template_1.html</strong> file that we are extending. We are passing the value of <strong class="source-inline">{{ title }}</strong>, which was defined in the view, into the <strong class="source-inline">{% block page_title %}</strong> tag of the <strong class="source-inline">/chapter_4/pages/test_page_1.html</strong> file. The <strong class="source-inline">{{ block.super }}</strong> tag can be used to keep what is <a id="_idIndexMarker693"/>found in that same block of the <strong class="source-inline">base_template_1.html</strong> file. Without this tag, all code inside the parent block will be overwritten. HTML can be written inside of any block; the <strong class="source-inline">{% block body_content %}</strong> block, shown in <em class="italic">step 5</em> that follows, is where the bulk of the page content will be found.</p>
			<ol>
				<li value="4">Create the <strong class="source-inline">/chapter_4/base/base_template_1.html</strong> file and add the code shown here:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_4/templates/chapter_4/base/base_template_1.html</strong></p><p class="source-code">{% load static %}</p><p class="source-code">&lt;!DOCTYPE html&gt;</p><p class="source-code">&lt;html lang="en" xmlns="http://www.w3.org/1999/xhtml"&gt;</p><p class="source-code">    &lt;head&gt;</p><p class="source-code">        &lt;meta charset="utf-8" /&gt;</p><p class="source-code">        &lt;title&gt;{% block page_title %}My Page Title{% endblock %}&lt;/title&gt;</p><p class="source-code">        &lt;link rel="stylesheet" href="{{ base_url }}{% static 'chapter_8/css/site.css' %}"&gt;</p><p class="source-code">        {% block head_stylesheets %}{% endblock %}</p><p class="source-code">        &lt;script defer type="text/javascript" src="{{ base_url }}{% static 'chapter_8/js/site-js.js' %}"&gt;&lt;/script&gt;</p><p class="source-code">    &lt;/head&gt;</p><p class="source-code">&lt;/html&gt;</p></li>
				<li>In the same <strong class="source-inline">/chapter_4/base/base_template_1.html</strong> file that you just created, insert the body<a id="_idIndexMarker694"/> code provided next, just below your existing closing <strong class="source-inline">&lt;/head&gt;</strong> tag:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_4/templates/chapter_4/base/base_template_1.html</strong></p><p class="source-code">...</p><p class="source-code">    &lt;/head&gt;</p><p class="source-code">    &lt;body id="{% block page_id %}{% endblock %}" class="{% block page_class %}base-template-class{% endblock %}" style="text-align: center;"&gt;</p><p class="source-code">        {% block header %}</p><p class="source-code">            {% <strong class="bold">include 'chapter_4/headers/header_1.html'</strong> %}</p><p class="source-code">        {% endblock %}</p><p class="source-code">        {% block site_container %}</p><p class="source-code">            &lt;div class="site-container"&gt;</p><p class="source-code">                &lt;div class="body-content"&gt;</p><p class="source-code">                    <strong class="bold">{% block body_content %}</strong></p><p class="source-code">                    <strong class="bold">{% endblock %}</strong></p><p class="source-code">                &lt;/div&gt;</p><p class="source-code">                {% block footer %}</p><p class="source-code">                    {% <strong class="bold">include 'chapter_4/footers/footer_1.html'</strong> <strong class="bold">with message='Footer of Document'</strong> %}</p><p class="source-code">                {% endblock %}</p><p class="source-code">            &lt;/div&gt;</p><p class="source-code">        {% endblock %}</p><p class="source-code">        {% block js_scripts %}{% endblock %}</p><p class="source-code">    &lt;/body&gt;</p><p class="source-code">&lt;/html&gt;</p></li>
				<li>Copy the <strong class="source-inline">/chapter_4/headers/header_1.html</strong> and <strong class="source-inline">/chapter_4/footers/footer_1.html</strong> files provided with the code of this book into your project in the same directory.</li>
				<li>Copy the <strong class="source-inline">/chapter_4/static/chapter_4/css/site.css</strong> and <strong class="source-inline">/chapter_4/static/chapter_4/js/site-js.js</strong> files provided with the code of this book into your <a id="_idIndexMarker695"/>project at the same directory.</li>
				<li>Run your project and navigate to <strong class="source-inline">http://localhost:8000/test_page_1/</strong>. You should see the following information in your browser window:</li>
			</ol>
			<div>
				<div id="_idContainer064" class="IMG---Figure">
					<img src="image/Figure_4.15_B17243.jpg" alt="Figure 4.15 – Extending templates&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.15 – Extending templates</p>
			<p>In the preceding steps, the main HTML of the page is broken down into a header, body content, and footer format. The <strong class="source-inline">{% include %}</strong> tags used previously demonstrate different ways of working with those files. Adding a <strong class="source-inline">with</strong> attribute to any <strong class="source-inline">{% include %}</strong> tag is how we can pass context into that file from the parent template. That is what is done to the preceding footer file. This means making context available without the need for a context processor or by writing code twice. The preceding HTML is structured in a way that allows us to <a id="_idIndexMarker696"/>get fancy by modifying everything within the <strong class="source-inline">{% block site_container %}</strong> tag, if we wanted or needed to. In order to do that, we would write the <strong class="source-inline">{% block site_container %}</strong> block again in the file that extends this template file and write the modified code there. That is essentially what <em class="italic">step 3</em> did for us, with the <strong class="source-inline">{% block body_content %}</strong> tag. </p>
			<p>Let's work with template filters next.</p>
			<h2 id="_idParaDest-131"><a id="_idTextAnchor148"/>Template filters</h2>
			<p>Template filters are a way to<a id="_idIndexMarker697"/> transform the value of a context variable. They can do things such as make a string upper or lowercase using the <strong class="source-inline">{{ context_variable|upper }}</strong> or <strong class="source-inline">{{ context_variable|lower }}</strong> filters. They can be used to find the number of items in a list using the <strong class="source-inline">{{ my_list|length }}</strong> filter or even format time with a <strong class="source-inline">{{ my_time|time:"</strong> <strong class="source-inline">n/j/Y" }}</strong> filter. When using a <strong class="source-inline">time</strong> filter, it is not necessary to specify the <strong class="source-inline">:" n/j/Y"</strong> argument of that filter. Even without these specifications, Django will default to the setting specified in your <strong class="source-inline">settings.py</strong> file as the <strong class="source-inline">TIME_FORMAT</strong> variable. To learn about all of the filters that are available, visit the official Django documentation found here: https://docs.djangoproject.com/en/4.0/ref/templates/builtins/#built-in-filter-reference. </p>
			<p>Let's check out custom tags and filters next. </p>
			<h2 id="_idParaDest-132"><a id="_idTextAnchor149"/>Custom tags and filters</h2>
			<p>Earlier, in <em class="italic">Figure 4.10</em>, we saw that the value of the<a id="_idIndexMarker698"/> make of the vehicle was displayed as the number <strong class="bold">3</strong>. This is a perfect example of how we can write a custom <a id="_idIndexMarker699"/>filter that takes in a numeric value and returns the string representation of that value.</p>
			<p>Follow these steps to create your custom filter:</p>
			<ol>
				<li value="1">Create a new folder in the <strong class="source-inline">/becoming_a_django_entdev/chapter_4/</strong> directory called <strong class="source-inline">templatetags</strong>. </li>
				<li>Create a new file in this folder called <strong class="source-inline">chapter_4.py</strong> and inside this file, place the following code:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_4/templatetags/chapter_4.py</strong></p><p class="source-code">from django.template </p><p class="source-code">import <strong class="bold">Library</strong></p><p class="source-code">register = <strong class="bold">Library()</strong></p><p class="source-code"><strong class="bold">@register.filter(name = 'vehicle_make')</strong></p><p class="source-code">def <strong class="bold">vehicle_make</strong>(value):</p><p class="source-code">    <strong class="bold">from ...chapter_3.models import MAKE_CHOICES</strong></p><p class="source-code">    for i, choice in enumerate(<strong class="bold">MAKE_CHOICES</strong>):</p><p class="source-code">        if i == value:</p><p class="source-code">            try:</p><p class="source-code">                return choice[1]</p><p class="source-code">            except ValueError:</p><p class="source-code">                pass</p><p class="source-code">    return ''</p></li>
			</ol>
			<p>Here, we are writing a very simple method called <strong class="source-inline">vehicle_make()</strong> that takes in the numeric value of <strong class="source-inline">3</strong> and returns to us the string representation of <strong class="source-inline">Chevrolet</strong>, when <a id="_idIndexMarker700"/>used in a template. In this method, we are using Python path syntax to import the <strong class="source-inline">MAKE_CHOICES</strong> variable, which we created in <a href="B17243_03_ePub.xhtml#_idTextAnchor077"><em class="italic">Chapter 3</em></a>, <em class="italic">Models, Relations, and Inheritance</em>, in the subsection titled <em class="italic">Mutable versus immutable objects</em>. </p>
			<ol>
				<li value="3">Make sure you have uncommented previous URL patterns and use the one shown in the following code block: <p class="source-code"># /becoming_a_django_entdev/chapter_4/urls.py </p><p class="source-code">... </p><p class="source-code">from .views import ..., vehicle_view </p><p class="source-code">urlpatterns = [ </p><p class="source-code">    ..., </p><p class="source-code">    path( </p><p class="source-code">        'vehicle/&lt;int:id&gt;/', </p><p class="source-code">        vehicle_view, </p><p class="source-code">        name = 'vehicle-detail' </p><p class="source-code">    ), </p><p class="source-code">]</p></li>
				<li>In your existing <strong class="source-inline">/chapter_4/my_vehicle.html</strong> file, change <strong class="source-inline">{{ vehicle.make }}</strong> to the statement we can see highlighted in the following code block, and add the <strong class="source-inline">chapter_4</strong> template tag library to your <strong class="source-inline">{% load %}</strong> tag:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_4/templates/chapter_4/my_vehicle.html</strong></p><p class="source-code">{% load static <strong class="bold">chapter_4</strong> %}</p><p class="source-code">...</p><p class="source-code">        {% if vehicle %}</p><p class="source-code">            ...</p><p class="source-code">            &lt;p&gt;{{ vehicle.make }}&lt;/p&gt;</p><p class="source-code">            &lt;p&gt;<strong class="bold">{{ vehicle.make|vehicle_make }}</strong>&lt;/p&gt;</p><p class="source-code">            ...</p><p class="source-code">        {% endif %}</p><p class="source-code">...</p></li>
			</ol>
			<p>In order to use the template filter that we registered, we import it into the HTML file using the <strong class="source-inline">{% load chapter_4 %}</strong> tag, where the name of the template tag set that we are loading is the name of the Python file that we created in any <strong class="source-inline">templatetags</strong> folder of an app.</p>
			<ol>
				<li value="5">Now, making sure your project is running, you can navigate to the URL at <strong class="source-inline">http://localhost:8000/vehicle/4/</strong> to see that our vehicle now says <strong class="bold">Chevrolet</strong>.</li>
			</ol>
			<p>Creating custom template tags instead of custom filters can be done by changing <strong class="source-inline">@register.filter(name = 'my_filter')</strong> to <strong class="source-inline">@register.tag(name = 'my_tag')</strong>. In this scenario, the tag can be used in a template similar to <strong class="source-inline">{% my_tag %}</strong>. To learn more about the <a id="_idIndexMarker701"/>complexities of writing your own template tags and how they can be useful in your project, visit the official documentation on that subject found here: https://docs.djangoproject.com/en/4.0/howto/custom-template-tags/#writing-custom-template-tags. </p>
			<p>Next, let's add some custom error pages.</p>
			<h2 id="_idParaDest-133"><a id="_idTextAnchor150"/>Error page templates</h2>
			<p>Django provides a very easy way to<a id="_idIndexMarker702"/> create your own custom error page templates for errors such as 400, 403, 404, and 500. Other errors, such as a <strong class="bold">502 Bad Gateway</strong> error, will not work since the error implies there is a problem with your web server and not with Django itself. For the four error types that we can manipulate, we can create four files in any of the <strong class="source-inline">templates</strong> directories, <strong class="source-inline">400.html</strong>, <strong class="source-inline">403.html</strong>, <strong class="source-inline">404.html</strong>, and <strong class="source-inline">500.html</strong>, as long as they are not placed in a subfolder. These four<a id="_idIndexMarker703"/> template files have been provided with the code of this book and follow the same design pattern as depicted in the subsection titled <em class="italic">Template tags</em> of this chapter. In order to see a custom debug template, we must turn off <strong class="source-inline">DEBUG</strong> in the <strong class="source-inline">settings.py</strong> file. </p>
			<p>Follow these steps to configure your error pages:</p>
			<ol>
				<li value="1">Copy the four error page template files found in the <strong class="source-inline">/becoming_a_django_entdev/chapter_4/templates/</strong> directory provided with the code of this book into the same directory of your project. Those four files are <strong class="source-inline">400.html</strong>, <strong class="source-inline">403.html</strong>, <strong class="source-inline">404.html</strong>, and <strong class="source-inline">500.html</strong>, and also copy the <strong class="source-inline">base_error.html</strong> file found in the same directory.</li>
				<li>In your <strong class="source-inline">settings.py</strong> file, change the following value to <strong class="source-inline">False</strong>:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/settings.py</strong></p><p class="source-code">...</p><p class="source-code">DEBUG = <strong class="bold">False</strong></p></li>
				<li>Make sure your virtual environment is activated and run the <strong class="source-inline">collectstatic</strong> command shown here, in order to have access to the static files that have been created up to this point in time: <p class="source-code"><strong class="bold">(virtual_env) PS &gt; python manage.py collectstatic</strong></p></li>
				<li>With <strong class="source-inline">DEBUG</strong> turned off, we have to run the <strong class="source-inline">collectstatic</strong> command in order to see changes reflect in the browser every time a static file is changed.</li>
				<li>Now, run your project and <a id="_idIndexMarker704"/>navigate to any non-existent<a id="_idIndexMarker705"/> URL on the site, a URL that we have not created a URL pattern for yet, such as <strong class="source-inline">http://localhost:8000/asdfasdf</strong>. You should see the following message in your browser window instead of the debug error message we are used to seeing, such as in <em class="italic">Figure 4.2</em>:</li>
			</ol>
			<div>
				<div id="_idContainer065" class="IMG---Figure">
					<img src="image/Figure_4.16_B17243.jpg" alt="Figure 4.16 – Custom error page&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.16 – Custom error page</p>
			<h1 id="_idParaDest-134"><a id="_idTextAnchor151"/>Summary</h1>
			<p>By now, we have constructed what might feel like an entire project, but in reality, an application will consist of so much more than what was covered in this chapter. What we do have is a way to route URL paths to views and render different contexts in each template used. We learned how we can query the database in a view to get the data that we want to render in a template. We even covered the different ways we can handle and process an error page or simply redirect a URL to another path. We even used class-based views to write reusable class structures, making a project more adaptable to change in the long run. </p>
			<p>In the next chapter, we will discuss how we can use form objects in combination with the function-based and class-based views and templates we learned how to create in this chapter.</p>
		</div>
	</body></html>