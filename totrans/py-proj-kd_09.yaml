- en: Chapter 9. Tiny Tennis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you learned about the basic modules, classes, and functions
    in pygame. You learned about these functions so that you can build a new game
    called **Tiny Tennis**. Tiny Tennis will be a two-player game that uses the keys
    on a keyboard to control two paddles, which hit a ball back and forth. While this
    game seems simple when you watch it, there are many different parts needed to
    make the game playable.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to game programming principles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many principles of game programming that apply to our project in this
    chapter. First, remember that the movement of objects in space is an illusion
    that we create. Unlike reality, objects that we create will appear to move because
    we will regularly draw and then redraw the objects in different places.
  prefs: []
  type: TYPE_NORMAL
- en: Another principle that we have discussed is a game loop. The game loop is important
    as it controls all of the things that need to happen in the game, including the
    moving and redrawing of objects. The timing of the game loop is important as this
    will tell the computer how many times to run the game loop. Each time a game loop
    runs is also known as a **frame**, and the speed at which the game loop runs is
    known as the **frame rate**.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, considering how the player interacts with the game is an important
    part of the game design. This means that we will consider how the player uses
    keys and has their score stored in the program's memory and displayed somewhere
    on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The game plan
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start to write any lines of code, we need to have our Python shell,
    terminal, and text editor open. We will be switching back and forth between these
    tools as we write and test lines of code throughout the chapter. Set up your monitor
    so that you are comfortable switching between each window.
  prefs: []
  type: TYPE_NORMAL
- en: Once you set up your workspace, go to the text editor window. We are going to
    outline our game in the text editor window using comments so that we can better
    organize our work.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an outline of game parts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to work on this game in four sections. The sections of the game
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Section 1: imports, globals, and drawings'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Section 2: moving the paddles'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Section 3: moving the ball'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Section 4: draw screen and track the score'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create a file called `tiny.py` in your text editor. Then, type the following
    lines into your `tiny.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you are done typing the preceding lines, save your file. This file now
    provides a general outline of the work that needs to be done to create your game.
    Here is how your file will look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating an outline of game parts](img/B04681_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We are following one particular approach to making this game of Tiny Tennis.
    It is important to note that there are *MANY* possible ways to write this game
    code. The way we are doing it here allows us to review all of the concepts that
    we learned along the way in this book. At the end of this chapter as well as in
    the next chapter, we will discuss some more advanced (and more streamlined) coding
    techniques that you can use to make this game do more things and do them more
    efficiently. Right now, though, let's start this game!
  prefs: []
  type: TYPE_NORMAL
- en: Section 1 – imports, globals, and drawings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this first section, we will write all of the code to set up the different
    parts of our game. This includes importing libraries, defining all of our global
    variables, and telling the computer how to draw the screen, ball, and paddles.
  prefs: []
  type: TYPE_NORMAL
- en: Importing libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first lines of code we write will be used to import the necessary libraries
    into the game, including pygame. We will be using three libraries in the game:
    pygame, math, and random. pygame, as we discussed in the previous chapter, allows
    us to have visual elements in our game. The random library, included with Python,
    gives us the ability to select and use random numbers in our game. The math library,
    also included with Python, allows for mathematics with floating point numbers.
    To use these modules and libraries in your code, type the following lines into
    your `tiny.py` file underneath the #imports, globals, and drawing comment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Make sure to save your `tiny.py` file now that you have added some new lines.
    Be in the habit of saving your code as *OFTEN* as you can.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make comments in your code if it helps you to organize your thoughts.
    Now, we will also initialize pygame so that we are able to use all of the capabilities,
    including starting our screen, drawing graphics, and running our game loop. To
    initialize pygame, we use the `init()` function. To initialize it, type these
    two lines of code below your imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `pygame.init()` starts the pygame process, and the pygame process will
    keep running until the program stops running when the player quits pygame. This
    allows us to access everything inside of pygame throughout the game. You will
    see how important this is as we continue to write our game. Right now, save your
    `tiny.py` file again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Importing libraries](img/B04681_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Introducing globals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have imported the libraries that we need, we will be making globals
    for some parts of the game. As a reminder, globals, or global variables, are variables
    that we can use throughout the entire file. We will set global variables for all
    of the colors that we wish to use. We also set global variables for the screen,
    paddles, and ball.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a color
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, we will make globals for each color. Colors, as we learned in [Chapter
    8](ch08.html "Chapter 8. pygame"), *pygame*, are represented by three different
    numbers listed in parentheses, also called a tuple. Instead of having to write
    these numbers repeatedly, we will make a global variable for each color so that
    we can use the names of all of the colors throughout the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending on what colors you like, you might want to make global variables
    for all the colors or only for a few. It is really up to you to decide what colors
    to add to your code. Here is a list of common colors that you may wish to use
    in your game. You should add the code for each color exactly as it appears here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding list shows the basic colors that you can include in your game
    code. If you want to include more advanced colors, you can search for `rgb color
    codes chart` in an Internet search engine, such as Google, and you will find that
    there are different variations for each color that you can change to your liking,
    such as light blue or dark blue. Once you have changed all the colors to your
    liking, make sure that you save your work:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Defining a color](img/B04681_09_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Adjusting the screen size
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will also use globals to define the parts of our screen display. This lets
    us show the size, color, and text for the main screen. Here are the color globals;
    we will add these lines of code for the width and height of the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have made the `screen_width` and `screen_height` variables, we can
    use these variables throughout our code, which makes our code easier to read.
    Also, if we do decide to change the screen width or screen height, we can change
    it one at a time in this global variable, and all of our code will still run properly.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing the screen
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So, the `screen_width` and `screen_height` variables are the basic information
    that pygame needs so that it can set up the actual game screen. pygame has a function
    called `pygame.display.set_mode()` that takes the variables of `screen_width`
    and `screen_height` to make the screen display. Now, writing `pygame.display.set_mode
    ((screen_width, screen_height))` is really long, especially if we keep doing it.
    Instead, we are going to set this to a global variable called `game_screen`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Creating screen labels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next set of functions that we use will set the text for the top of the
    screen and the font for the game screen. The first line of code defines what string
    of text we want to see, and in the following line, we define the font and size.
    If the font and the size are not available, the font will, by default, use whatever
    is originally set on your system. This is true for Windows, Mac, and Linux systems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we have now set all of the basic variables needed to create a game screen.
    Save your work and, when you are ready, move on to making the global variables
    that we will need for the ball, paddles, and scoring. Your screen code should
    look like this code sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating screen labels](img/B04681_09_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Ball – the starting location
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Tiny Tennis, the ball is one of the most important parts of the game. We
    have a lot to do to make it work. First, we need to give the ball some global
    characteristics so that it can be drawn and redrawn to create the illusion of
    movement.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to set the *x*, *y* coordinates of the ball. By making a global
    variable for this, we can tell the computer where to redraw the ball without having
    to write special code for each movement of the ball. We will set the default value
    of `x` and `y` so that the ball starts in the center of the screen. Write the
    next lines into your `tiny.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Ball – setting the speed and direction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have told the ball to start in the center of the screen as default,
    we need to tell the ball how far to move by giving it `x` and `y` coordinates
    for movement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `ball_xv = 3` means that the ball will move `3` pixels along the *x* axis
    each time it is redrawn. The `ball_yv = 3` means that the ball will move `3` pixels
    along the *y* axis each time the screen redraws. This is great as it will help
    us keep the ball going in the speed and direction that we like. Here*, v = velocity*
    which is the magnitude (speed) and direction (*x,y*) of the ball. So, when we
    say `ball_xv = 3`, we are really saying that *the ball moves along the x axis
    at a speed of 3 pixels each time the screen is redrawn*.
  prefs: []
  type: TYPE_NORMAL
- en: Ball – setting the size
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The final thing that we will define about the ball is its radius. The radius
    is half of the total width of the ball, as represented in pixels. By setting the
    radius, we set the size. Write the following line of code into your `tiny.py`
    file to represent the ball radius:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have defined the characteristics of the ball, make sure to save
    the file. Nobody wants to rewrite lines of working code! Take a look at an example
    of this section of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Ball – setting the size](img/B04681_09_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Paddles – starting location and size
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our game, we will have two paddles. Recall that in the beginning of this
    chapter, it was said that there is more than one way to do some of the things
    that we are doing. There are more advanced ways to make the paddles, but it is
    important that you understand each part of the paddle, so we are going to break
    our code down very simply. Later, once you have completed this game, you can do
    some research on creating objects and try creating paddles as objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will give our paddle four qualities: a starting location on the *x* axis,
    a starting location on the *y* axis, a width, and a height. Each of these numbers
    is a representation in pixels. Below the ball globals, on line 34, add the next
    five lines to your `tiny.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You probably noticed that the code we wrote is for `paddle1`. There are two
    paddles required for Tiny Tennis. We want to give each player a fair start, so
    we will create `paddle2` so that it is equal in size, but it''s located opposite
    `paddle1`. To make the second paddle, start on line 40 and write the next five
    lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You will notice that the `x` coordinate for paddle 2 combines `the screen_width`
    variable, which is the maximum `x` coordinate number (`600`) and then subtracts
    the width of the paddle (`25`) + the `x` coordinate value of paddle 1 (`10`) as
    well. This math allows us to make sure that the paddle is the same distance from
    the right-hand side of the screen as it is from the left-hand side of the screen.
    If you are confused, copy the code into your file and save it. You can play with
    the numbers and see how your paddles change based on each value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Paddles – starting location and size](img/B04681_09_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Initializing the score
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to have a score, we are going to create a variable for each player
    that begins at the default score, zero. As this is a global variable, like the
    other integers, it will change as the game loop runs. For now, we just need to
    have placeholders for each player. So, starting on line 46, add these lines of
    code to your game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We have now created all of the global variables that we need to write code
    that is easier to understand. Remember, these are called global variables because
    they can be used throughout the entire code file. Save your file. Then, compare
    your code with the completed code in this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Initializing the score](img/B04681_09_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Testing section 1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have imported libraries, initialized pygame, and created globals
    for colors, the screen, ball, and the paddles, we can run our first tests to check
    how things are going. To test the game, you will need to locate the directory
    where you saved your `tiny.py` file in your terminal/command prompt. In earlier
    games, we made this directory on the desktop. Once you navigate to the directory
    where `tiny.py` is saved, you can run the following commands from the terminal/command
    prompt to see your game so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: When you run this command, you should see a window pop up and then close. The
    window will not stay open because we have not written any of the code that runs
    the game; however, if the code runs and there are *NO ERRORS* in your terminal/command
    prompt, then you can keep moving forward with confidence.
  prefs: []
  type: TYPE_NORMAL
- en: If there are errors in your code, now is a good time to fix them. Some common
    errors that can take place include syntax errors (using the wrong symbols), typos
    (spelling something incorrectly, such as a Python keyword), or trying to run your
    file from the wrong directory. If you have errors, check for these common errors,
    and fix the mistakes in your code.
  prefs: []
  type: TYPE_NORMAL
- en: If you get an error that is not one of the aforementioned common errors, you
    can always perform an Internet search to ask a question about the problem you
    are having. It is very common for even experienced developers to use Internet
    searches to find help to fix errors, and there are many websites and blogs that
    people maintain in order to help others learn.
  prefs: []
  type: TYPE_NORMAL
- en: Section 2 – moving the paddles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we finally get to write the code that will make our paddles appear on the
    screen and allow us to control the paddle.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is where we get the chance to use the logic and loops that we learned
    about in earlier chapters. In a game such as Tiny Tennis, many decisions are made
    very quickly. Computers are great at making fast decisions based on our instructions.
    Here are the parts of the code that will be in the next section:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the `while` loop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Key events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will code these next pieces step by step, and then test the code by running
    it to check whether there are any errors. It is suggested that you read through
    this whole section before you start coding so that you know what to expect. Once
    you have read through everything, the fun starts!
  prefs: []
  type: TYPE_NORMAL
- en: Pre-loop actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we actually create the `while` loop, there are two actions that we will
    code. The first is to ensure that the cursor disappears when it goes over the
    game screen, so it is not an interruption. There is a special function for this
    behavior in pygame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: By setting the visibility to `0`, we make the mouse/cursor invisible to the
    game. Since we do not need the mouse in the game, it is okay for us to do this.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second action is to set the global variable for our `while` loop. We are
    going to call our main game loop variable `do_main`. We will set `do_main = True`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that syntax and case (uppercase or lowercase) are important. Notice
    the *CAPITAL* letter *T*, and make sure to copy it exactly as it is. Remember,
    *True* is a Boolean that needs to be written with a capital *T*. Now, we are ready
    to write our `while` loop.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the while loop
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our game loop will be a `while` loop. We will use `do_main` as our `True` statement.
    So, you will have another line of code that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Make sure you place a colon (`:`) at the end of the line. Also, all of the
    other lines of code in the game loop will be indented at least once because they
    all need to be *INSIDE* of the loop to run. Here is a screenshot of the `while`
    loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the while loop](img/B04681_09_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Moving the paddles – keyboard events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first set of events in the `while` loop are keyboard events. These events
    take place when a key or set of keys get pressed. The events use the `if`/`elif`
    logic. All of them are indented on at least one tab, and some are indented on
    two tabs or more. Remember that indents are an organizational tool in Python and
    help us keep track of when certain code should be run.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice the code on line 54 of the screenshot. In line 54, we will create the
    pressed variable, which we will set equal to the `pygame.key.get_pressed()` function.
    This will give us a shorter reference to the function. Type this code in line
    54:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In line 55, we use the `pygame.key.set_repeat()` function. This tells the computer
    that once a key is pressed, the action that the key performs should continue until
    the user lets the key go. Type the next line of code into line 55 of your `tiny.py`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have set the variable and characteristics for the keyboard events,
    we will create our first loop, a `for` loop that looks for the player to quit.
    Using a `for` loop, we will loop over each event that is found using the `pygame.event.get()`
    function. If the event is a *QUIT* event, then the `while` loop will automatically
    end. You will notice that we also use our `if` logic here so that we can tell
    the computer to make a decision if it finds the quit event. To make this `for`
    loop, you will write the following lines of code, starting on line 56 of your
    code file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have told the computer how and when to end the `while` loop, we
    can tell the computer what to do when certain keys are pressed. For our Tiny Tennis
    game, we need to assign keys to exit the game as well as ones to control paddle
    1 and paddle 2.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Want to choose different keys than the ones we use in this book? You can find
    an entire list of how to use every keyboard key on the pygame website at [http://www.pygame.org/docs/ref/key.html](http://www.pygame.org/docs/ref/key.html).
  prefs: []
  type: TYPE_NORMAL
- en: Exiting the game – escape key
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To exit the game, we will use the *Esc* key. You will notice that we use our
    pressed variable followed by the key code for the *Esc* key. Starting from line
    60, type these two lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The lines of code tell the computer that if the *Esc* key is pressed, then the
    `do_main` global variable should be set to `False`. When `do_main` is set to Boolean
    `False`, then the `while` loop stops. We will write the code that ends the game
    a bit later.
  prefs: []
  type: TYPE_NORMAL
- en: Paddle control – player 1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For player 1''s paddle to go up, we will use the *W* key. For player 1''s paddle
    to go down, we will use the *S* key. These are very typical keys to use for computer
    game controls. Notice which letters are uppercase and which are lowercase, and
    be sure to copy them exactly, starting from line 63:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Paddle control – player 2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Player 2 also needs to have keyboard controls that work to move his/her paddle
    up and down at the same time as player 1\. This means that we must assign different
    keys for the second paddle. For this game, we are using the up arrow key to move
    paddle 2 up and the down arrow key to move paddle 2 down. Type the following lines
    of code into your `tiny.py` file, starting from line 68:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Save your work!
  prefs: []
  type: TYPE_NORMAL
- en: The increase and decrease value (-= and +=)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will notice the **-=** and **+=** symbols in this code. These symbols are
    used as shortcuts to increase or decrease the value of something. In the code
    for moving the paddles, we use these symbols to add or subtract values when the
    paddle keys are pressed. Both the -= and += symbols are very important for setting
    the proper paddle position each time the paddles are moved by the user.
  prefs: []
  type: TYPE_NORMAL
- en: Testing section 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Time to test our code again. In your terminal/command prompt, locate the directory
    where you saved your `tiny.py` file. In earlier games, we made this directory
    on the desktop. Once you navigate to the directory where `tiny.py` is saved, you
    can run the following command from the terminal/command prompt to see your game
    so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'During this test, you will see a window open that says **Tiny Tennis** at the
    top and is totally blank otherwise. See this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing section 2](img/B04681_09_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you are getting errors, remember to check your code for typos, syntax errors,
    and case errors.
  prefs: []
  type: TYPE_NORMAL
- en: Section 3 – moving the ball
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have written and tested the code for the paddles, we need to write
    code to move the ball. We will be changing the location of the ball with some
    of our code, and we will create something called collision detection.
  prefs: []
  type: TYPE_NORMAL
- en: Moving the ball – updating the location
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we need to be constantly calculating the `x` and `y` coordinates of
    the ball based on the velocity of the ball that we set in the global variables.
    This allows us to make constant updates as long as we are playing the game. To
    make sure that the `x` and `y` coordinates of the ball update as the ball moves,
    you will type the following lines of code, starting from line 74:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Collision detection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our next job is to code something called **collision detection**. This means
    that we can program the computer to know when two objects are hitting one another.
    We can also tell the computer what we want it to do when the objects collide.
    In Tiny Tennis, we have three kinds of collisions that we want to detect:'
  prefs: []
  type: TYPE_NORMAL
- en: Collision of the ball with the top and bottom of the screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collision of the paddle with the top and bottom of the screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collision of the ball with the paddle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collision of the ball with the top and the bottom of the screen
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, we will use our `if` statement to define what happens if the ball hits
    the top or the bottom of the screen. Basically, we want the ball to bounce back
    if it hits the top or bottom of the screen. Type the following code starting from
    line 77 of your `tiny.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The first line, beginning with `if`, basically says *If the radius is subtracted
    from the y coordinate and that is less than or equal to zero OR if the radius
    is added to the y coordinate and it is greater than the number of the screen height
    (400), then do something about it*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second line of the code that comes after the colon tells us what to do:
    *the velocity of the y coordinate of the ball should be in the reverse direction*.
    The second line of code, `ball_yv *= -1`, means that the velocity of the `y` coordinate
    gets reversed because it is multiplied by `-1`. Any number multiplied by `-1`
    becomes opposite to its original sign, and, in this case, reversing the sign means
    reversing the direction of the ball.'
  prefs: []
  type: TYPE_NORMAL
- en: So, why does this code work? Let's think about it. The top `y` coordinate is
    zero. If the ball tries to move past the top, its `y` value will be less than
    zero, which means that it will be out of the screen. To make the ball stay on
    the screen, we change its direction when the `y` coordinate value is less than
    zero.
  prefs: []
  type: TYPE_NORMAL
- en: The bottom `y` coordinate is `400`. So, if the ball's `y` value is greater than
    `400`, then we change the direction of the ball to go back up. We make these directional
    changes by multiplying the velocity of the ball by `-1`, resulting in a directional
    change.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before moving on, compare your code to this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Collision of the ball with the top and the bottom of the screen](img/B04681_09_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Collision of the paddle with the top and the bottom of screen
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We want the paddle to stop when it reaches the top or bottom of the screen.
    To make this happen, we need to create a code that will recognize the `y` value
    of the paddle and then stop the paddle from moving beyond the two `y` values that
    create the screen borders. These two values are `0` for the top of the screen,
    and `400` for the bottom. Copy the following lines of code into your program,
    starting from line 81\. Check to make sure that your indent level is correct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This code works differently from the ball code because we do not want the paddles
    to bounce around! Instead, we want the paddles to stop when they hit the top or
    bottom of the screen. So, you will notice that whenever paddle 1 or paddle 2 goes
    beyond the barriers of the screen (`0` and `400`), the value of the paddle is
    reset to *EQUAL* the boundary values of `0` or `400`, depending on *WHERE* the
    paddle is located (is it at the top of the screen or the bottom?). Save your work
    once you are done with adding this code.
  prefs: []
  type: TYPE_NORMAL
- en: Collision of the ball with the paddles
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The collision of the ball with the paddles will determine what happens when
    the ball hits the paddle. There are two paddles, and it will be helpful if you
    add some comment code using a hashtag to keep track of the code for the left-hand
    side paddle (paddle 1) and the right-hand side paddle (paddle 2).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have done some collision detection, let''s think about the ball
    and paddle. When the ball hits the paddle, we want the ball to appear as though
    it has bounced off of the paddle. Therefore, we need to make sure that the result
    of the collision between the ball and the paddle is that the ball reverses itself
    and goes in the opposite direction. This is actually the same behavior that we
    used to make the ball bounce off the edges of the screen, except now we need to
    outline all the pieces of paddle 1 and paddle 2\. Copy these lines of code into
    your file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Take a look at this screenshot, and compare your code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Collision of the ball with the paddles](img/B04681_09_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Testing – section 3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You are almost done writing the game! Now it''s time to test our code again.
    In your terminal/command prompt, locate the directory where you saved your `tiny.py`
    file. You can run the following command from the terminal/command prompt to check
    the progress of your game so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: During this test, if everything is working correctly, your results will be the
    same as the test from Section 2\. A blank screen will open and will be called
    Tiny Tennis. Congratulations!
  prefs: []
  type: TYPE_NORMAL
- en: If your program has some errors while running, look at the error messages to
    check whether you can figure out what is going wrong. Look for syntax mistakes,
    spelling mistakes, indentation mistakes, or any other errors in your code. Make
    sure that you are using spaces for your indentations, not tabs, or else you might
    have problems as well.
  prefs: []
  type: TYPE_NORMAL
- en: Section 4 – draw screen and track the score
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, we know that the ball bounces off the top and bottom of the screen as well
    as off the paddles. However, if the user misses the ball with the paddle, what
    happens to the ball? What happens to the player and their score?
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section of the game, we use the location of the `x` coordinates to
    determine whether the ball is on the screen or it has gone past the paddles and
    is outside the screen. We use our `if` statement to tell the computer what to
    do. The *x* axis `0` coordinate is the left-most side of the screen. If the ball''s
    `x` value is less than `0`, then the player on the other side (player 2) has scored
    a point because player 1 failed to block the ball. If you read the lines of code,
    you will notice that we reset the `ball_x` and `ball_y` coordinates to the center
    of the screen so that a new game can start. Copy the next four lines of code to
    place this logic into the game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'You will notice that the next four lines of code are almost identical, with
    only two changes. The ball''s `x` value is now being compared to the maximum screen
    width, which is `600`. If the ball''s `x` value becomes greater than `600`, it
    means that the player has missed the ball and the ball is now outside of the screen.
    Now, player 1 has scored because player 2 did not block the ball. To make sure
    that this logic is also in the game, copy the next four lines of code into your
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '![Section 4 – draw screen and track the score](img/B04681_09_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ensure that you save your work!
  prefs: []
  type: TYPE_NORMAL
- en: The render screen – show what's happened
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The final code that we need to write is the code that redraws the screen and
    all of the objects so that the movements appear to happen. The next lines of code
    draw the five objects that are a part of our game. There is no need to use variable
    names to draw the paddles, net, or the balls, except that it does make them easier
    to find if you want to fix or change that part of the code. Again, these lines
    of code are indented so that they are inside of the `while` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The `game_screen.fill(black)` code uses our `game_screen` variable and tells
    the `fill()` function to make our screen black by putting the color `black` in
    parentheses. Did you notice that we used two global variables, `game_screen` and
    `black`, in this line of code? Imagine how much longer the code would be without
    these variables. Imagine that it might be more difficult to read and to change.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will notice that the `pygame.draw.rect()` function is used to draw the
    paddles, since they are just rectangles. The paddles have the following characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: Game screen (tells you where they should go)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Color
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `x` coordinate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `y` coordinate (to provide a starting location)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A width
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A height
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you look at the `line()` and `circle()` objects, you will notice that they
    are not too different from the rectangle. Both have a `game_screen` and color
    property. The line object accepts arguments that define a length, width, and *x*
    value for the line. The circle object accepts arguments that define `game_screen`,
    color, and ball characteristics. Since we defined the ball characteristics early
    in the chapter with global variables, we can use them in the `circle()` code.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying player scores
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our next few lines of code will draw the player scores on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The top line of our game score code provides the definition for the `score_text`
    variable, which is used in the second line of this code that we just added. The
    `game_screen.blit()` function copies our score text each time our screen is redrawn,
    since the score text may not change for a long time if neither player misses the
    ball.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the `pygame.display.update()` function updates the image with the
    new information stored by our program. Because a computer can move at speeds infinitely
    faster than a human, we have added a `sleep` option, allowing for the update to
    occur at an interval that we can now control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Ending the program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The final line of code will be to end the initialization of pygame, which we
    performed at the start of the code. To end this, we will type `pygame.quit()`
    at the outermost level of indentation in our code. This goes outside of the `while`
    loop so that it only happens when the `while` loop stops running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have typed this, your final game code lines should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Ending the program](img/B04681_09_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Once you have double-checked your code against the screenshots in the chapter,
    make sure that you save your `tiny.py` file. Now you are ready to truly give your
    game a test!
  prefs: []
  type: TYPE_NORMAL
- en: Play Tiny Tennis!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The best part about Tiny Tennis is that you can play it against yourself, making
    it easy to test the game and experiment with different parts of the game. Now,
    when you run the file from your terminal, a window that looks like this should
    pop up:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Play Tiny Tennis!](img/B04681_09_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The ball should start moving immediately toward one side or the other of the
    screen. You can test the game by making sure that the paddles on each side of
    the screen are able to hit the ball and that they do not go outside of the screen
    space. You can test the scoring mechanism to make sure that the appropriate player
    is getting the points for each shot that they make past the other player. Then,
    you can invite others to play the game with you.
  prefs: []
  type: TYPE_NORMAL
- en: If you are not happy with parts of the game, you can change them. For example,
    you might choose a different color for the ball, paddles, and the screen. Maybe
    you want the paddles to be longer or shorter or, perhaps, thinner. Maybe you want
    to make the ball bigger or smaller by changing the radius.
  prefs: []
  type: TYPE_NORMAL
- en: You might decide that you want the ball and paddles to move faster so that the
    game is more challenging, or maybe you want the ball and paddles to move slower
    if you are designing the game to be played by younger children. Design choices
    are made for many reasons, and now that you have a playable game, you might decide
    to make some different design decisions.
  prefs: []
  type: TYPE_NORMAL
- en: You can test your decisions by making a copy of your game code and then testing
    any modifications in your copy. It is a good idea to keep a backup of your working
    code so that if you write broken code, you have a place to return to and start
    again.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Congratulations on building your first game! There are so many things that you
    learned to do. The greatest thing about code, though, is that there are many ways
    to do everything. Some ways are easier to understand but not as efficient as other
    ways. Some code is very efficient but might not be easily understood by another
    programmer. The best code is both easy to understand and written in the most efficient
    way possible.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout the previous chapter, we used a combination of code that was easy
    to understand, but may not have been as efficient as possible. This is because
    we were learning many new principles in pygame, and things, such as collision
    detection, can be challenging to code. You may decide to do things differently
    after you have a few games under your belt!
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will review all that we have learned in this book, and
    we will also take a look at some other ways that Python is used out in the world,
    as Python is a very useful language to know. See you in the last chapter!
  prefs: []
  type: TYPE_NORMAL
