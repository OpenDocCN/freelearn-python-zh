- en: Chapter 9. Tiny Tennis
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。迷你网球
- en: In the previous chapter, you learned about the basic modules, classes, and functions
    in pygame. You learned about these functions so that you can build a new game
    called **Tiny Tennis**. Tiny Tennis will be a two-player game that uses the keys
    on a keyboard to control two paddles, which hit a ball back and forth. While this
    game seems simple when you watch it, there are many different parts needed to
    make the game playable.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你学习了pygame中的基本模块、类和函数。你学习这些函数是为了能够构建一个名为**迷你网球**的新游戏。迷你网球将是一款双人游戏，使用键盘上的按键来控制两个挡板，挡板来回击球。虽然当你观看这个游戏时，它看起来很简单，但制作一个可玩的游戏需要很多不同的部分。
- en: Introduction to game programming principles
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏编程原则简介
- en: There are many principles of game programming that apply to our project in this
    chapter. First, remember that the movement of objects in space is an illusion
    that we create. Unlike reality, objects that we create will appear to move because
    we will regularly draw and then redraw the objects in different places.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中有很多游戏编程原则适用于我们的项目。首先，记住空间中对象的运动是我们创造的幻觉。与现实不同，我们创建的对象看起来会移动，因为我们会在不同的地方定期绘制和重绘对象。
- en: Another principle that we have discussed is a game loop. The game loop is important
    as it controls all of the things that need to happen in the game, including the
    moving and redrawing of objects. The timing of the game loop is important as this
    will tell the computer how many times to run the game loop. Each time a game loop
    runs is also known as a **frame**, and the speed at which the game loop runs is
    known as the **frame rate**.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论的另一个原则是游戏循环。游戏循环非常重要，因为它控制着游戏中需要发生的所有事情，包括对象的移动和重绘。游戏循环的时间安排很重要，因为这会告诉计算机游戏循环需要运行多少次。每次游戏循环的运行也被称为**帧**，游戏循环运行的速率被称为**帧率**。
- en: Finally, considering how the player interacts with the game is an important
    part of the game design. This means that we will consider how the player uses
    keys and has their score stored in the program's memory and displayed somewhere
    on the screen.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，考虑到玩家如何与游戏互动是游戏设计的一个重要部分。这意味着我们将考虑玩家如何使用键盘，以及他们的分数如何存储在程序的内存中并在屏幕的某个位置显示。
- en: The game plan
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏计划
- en: Before we start to write any lines of code, we need to have our Python shell,
    terminal, and text editor open. We will be switching back and forth between these
    tools as we write and test lines of code throughout the chapter. Set up your monitor
    so that you are comfortable switching between each window.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写任何代码行之前，我们需要打开我们的Python壳、终端和文本编辑器。在我们编写和测试本章中的代码行时，我们将在这三个工具之间来回切换。调整你的显示器，以便你可以在每个窗口之间舒适地切换。
- en: Once you set up your workspace, go to the text editor window. We are going to
    outline our game in the text editor window using comments so that we can better
    organize our work.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好你的工作区后，转到文本编辑器窗口。我们将使用注释在文本编辑器窗口中概述我们的游戏，这样我们可以更好地组织我们的工作。
- en: Creating an outline of game parts
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建游戏部分的概述
- en: 'We are going to work on this game in four sections. The sections of the game
    are as follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将分四个部分来制作这个游戏。游戏的部分如下：
- en: 'Section 1: imports, globals, and drawings'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第1节：导入、全局变量和绘图
- en: 'Section 2: moving the paddles'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第2节：移动挡板
- en: 'Section 3: moving the ball'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第3节：移动球
- en: 'Section 4: draw screen and track the score'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第4节：绘制屏幕和跟踪分数
- en: 'Create a file called `tiny.py` in your text editor. Then, type the following
    lines into your `tiny.py` file:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的文本编辑器中创建一个名为`tiny.py`的文件。然后，将以下行输入到你的`tiny.py`文件中：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once you are done typing the preceding lines, save your file. This file now
    provides a general outline of the work that needs to be done to create your game.
    Here is how your file will look:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在输入前面的行之后，保存你的文件。现在这个文件提供了一个创建游戏所需工作的概述。你的文件看起来会是这样：
- en: '![Creating an outline of game parts](img/B04681_09_01.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![创建游戏部分的概述](img/B04681_09_01.jpg)'
- en: We are following one particular approach to making this game of Tiny Tennis.
    It is important to note that there are *MANY* possible ways to write this game
    code. The way we are doing it here allows us to review all of the concepts that
    we learned along the way in this book. At the end of this chapter as well as in
    the next chapter, we will discuss some more advanced (and more streamlined) coding
    techniques that you can use to make this game do more things and do them more
    efficiently. Right now, though, let's start this game!
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在遵循一种特定的方法来制作这款迷你网球游戏。需要注意的是，编写这款游戏代码有*许多*可能的方式。我们在这里所采用的方法使我们能够回顾在这本书中学到的所有概念。在本章的结尾以及下一章中，我们将讨论一些更高级（且更简洁）的编码技术，这些技术可以帮助你使这款游戏执行更多操作，并且更有效率。不过，现在，让我们开始这款游戏吧！
- en: Section 1 – imports, globals, and drawings
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1节 – 导入、全局变量和绘图
- en: In this first section, we will write all of the code to set up the different
    parts of our game. This includes importing libraries, defining all of our global
    variables, and telling the computer how to draw the screen, ball, and paddles.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将编写所有代码来设置游戏的不同部分。这包括导入库、定义所有全局变量，以及告诉计算机如何绘制屏幕、球和挡板。
- en: Importing libraries
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入库
- en: 'The first lines of code we write will be used to import the necessary libraries
    into the game, including pygame. We will be using three libraries in the game:
    pygame, math, and random. pygame, as we discussed in the previous chapter, allows
    us to have visual elements in our game. The random library, included with Python,
    gives us the ability to select and use random numbers in our game. The math library,
    also included with Python, allows for mathematics with floating point numbers.
    To use these modules and libraries in your code, type the following lines into
    your `tiny.py` file underneath the #imports, globals, and drawing comment:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写的第一行代码将用于将必要的库导入到游戏中，包括pygame。在游戏中，我们将使用三个库：pygame、math和random。正如我们在上一章所讨论的，pygame使我们能够在游戏中添加视觉元素。Python附带的标准库random，使我们能够在游戏中选择和使用随机数。Python附带的math库允许进行浮点数运算。要在你的代码中使用这些模块和库，请在`tiny.py`文件中#导入、全局变量和绘图注释下面输入以下几行代码：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Tip
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Make sure to save your `tiny.py` file now that you have added some new lines.
    Be in the habit of saving your code as *OFTEN* as you can.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 确保现在你已经添加了一些新行，保存你的`tiny.py`文件。养成尽可能频繁保存代码的习惯。
- en: 'You can make comments in your code if it helps you to organize your thoughts.
    Now, we will also initialize pygame so that we are able to use all of the capabilities,
    including starting our screen, drawing graphics, and running our game loop. To
    initialize pygame, we use the `init()` function. To initialize it, type these
    two lines of code below your imports:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代码中的注释有助于你组织思路，你可以添加注释。现在，我们还将初始化pygame，以便我们能够使用所有功能，包括启动屏幕、绘制图形和运行游戏循环。要初始化pygame，我们使用`init()`函数。要初始化它，在你的导入下面输入以下两行代码：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Using `pygame.init()` starts the pygame process, and the pygame process will
    keep running until the program stops running when the player quits pygame. This
    allows us to access everything inside of pygame throughout the game. You will
    see how important this is as we continue to write our game. Right now, save your
    `tiny.py` file again:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`pygame.init()`启动pygame进程，pygame进程将持续运行，直到玩家退出pygame时程序停止运行。这使我们能够在整个游戏中访问pygame内部的所有内容。随着我们继续编写游戏，你会看到这一点有多么重要。现在，再次保存你的`tiny.py`文件：
- en: '![Importing libraries](img/B04681_09_02.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![导入库](img/B04681_09_02.jpg)'
- en: Introducing globals
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引入全局变量
- en: Now that we have imported the libraries that we need, we will be making globals
    for some parts of the game. As a reminder, globals, or global variables, are variables
    that we can use throughout the entire file. We will set global variables for all
    of the colors that we wish to use. We also set global variables for the screen,
    paddles, and ball.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经导入了所需的库，我们将为游戏的一些部分创建全局变量。提醒一下，全局变量，或称全局变量，是我们可以在整个文件中使用的变量。我们将为所有希望使用的颜色设置全局变量。我们还为屏幕、挡板和球设置了全局变量。
- en: Defining a color
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义颜色
- en: First, we will make globals for each color. Colors, as we learned in [Chapter
    8](ch08.html "Chapter 8. pygame"), *pygame*, are represented by three different
    numbers listed in parentheses, also called a tuple. Instead of having to write
    these numbers repeatedly, we will make a global variable for each color so that
    we can use the names of all of the colors throughout the game.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将为每种颜色创建全局变量。正如我们在[第8章](ch08.html "第8章。pygame")中学习的，颜色，在*pygame*中，由括号内列出的三个不同的数字表示，也称为元组。为了避免重复编写这些数字，我们将为每种颜色创建一个全局变量，这样我们就可以在整个游戏中使用所有颜色的名称。
- en: 'Depending on what colors you like, you might want to make global variables
    for all the colors or only for a few. It is really up to you to decide what colors
    to add to your code. Here is a list of common colors that you may wish to use
    in your game. You should add the code for each color exactly as it appears here:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您喜欢的颜色，您可能希望为所有颜色或仅为一小部分创建全局变量。实际上，决定添加哪些颜色到您的代码中完全取决于您。以下是一份您可能在游戏中希望使用的常见颜色列表。您应该将每种颜色的代码添加得与这里显示的完全一致：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The preceding list shows the basic colors that you can include in your game
    code. If you want to include more advanced colors, you can search for `rgb color
    codes chart` in an Internet search engine, such as Google, and you will find that
    there are different variations for each color that you can change to your liking,
    such as light blue or dark blue. Once you have changed all the colors to your
    liking, make sure that you save your work:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 上述列表显示了您可以在游戏代码中包含的基本颜色。如果您想包含更高级的颜色，您可以在搜索引擎中搜索`rgb颜色代码表`，例如Google，您会发现每种颜色都有不同的变化，您可以根据自己的喜好进行更改，例如浅蓝色或深蓝色。一旦您将所有颜色更改到您喜欢的样子，请确保保存您的作品：
- en: '![Defining a color](img/B04681_09_03.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![定义颜色](img/B04681_09_03.jpg)'
- en: Adjusting the screen size
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调整屏幕大小
- en: 'We will also use globals to define the parts of our screen display. This lets
    us show the size, color, and text for the main screen. Here are the color globals;
    we will add these lines of code for the width and height of the screen:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用全局变量来定义屏幕显示的部分。这使我们能够显示主屏幕的大小、颜色和文本。以下是颜色全局变量；我们将添加以下代码行以定义屏幕的宽度和高度：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now that we have made the `screen_width` and `screen_height` variables, we can
    use these variables throughout our code, which makes our code easier to read.
    Also, if we do decide to change the screen width or screen height, we can change
    it one at a time in this global variable, and all of our code will still run properly.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了`screen_width`和`screen_height`变量，我们可以在整个代码中使用这些变量，这使得我们的代码更容易阅读。此外，如果我们决定更改屏幕宽度或高度，我们可以在这个全局变量中逐个更改，而我们的所有代码仍然可以正常运行。
- en: Drawing the screen
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制屏幕
- en: 'So, the `screen_width` and `screen_height` variables are the basic information
    that pygame needs so that it can set up the actual game screen. pygame has a function
    called `pygame.display.set_mode()` that takes the variables of `screen_width`
    and `screen_height` to make the screen display. Now, writing `pygame.display.set_mode
    ((screen_width, screen_height))` is really long, especially if we keep doing it.
    Instead, we are going to set this to a global variable called `game_screen`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`screen_width`和`screen_height`变量是pygame设置实际游戏屏幕所需的基本信息。pygame有一个名为`pygame.display.set_mode()`的函数，它接受`screen_width`和`screen_height`变量来设置屏幕显示。现在，编写`pygame.display.set_mode
    ((screen_width, screen_height))`确实很长，尤其是如果我们一直这样做的话。相反，我们将将其设置为名为`game_screen`的全局变量：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Creating screen labels
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建屏幕标签
- en: 'The next set of functions that we use will set the text for the top of the
    screen and the font for the game screen. The first line of code defines what string
    of text we want to see, and in the following line, we define the font and size.
    If the font and the size are not available, the font will, by default, use whatever
    is originally set on your system. This is true for Windows, Mac, and Linux systems:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来使用的函数集将设置屏幕顶部的文本和游戏屏幕的字体。第一行代码定义了我们想要看到的文本字符串，在下一行中，我们定义了字体和大小。如果字体和大小不可用，字体将默认使用系统上最初设置的字体。这对于Windows、Mac和Linux系统都是正确的：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'So, we have now set all of the basic variables needed to create a game screen.
    Save your work and, when you are ready, move on to making the global variables
    that we will need for the ball, paddles, and scoring. Your screen code should
    look like this code sample:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在已经设置了创建游戏屏幕所需的所有基本变量。保存您的作品，当您准备好时，继续创建我们需要的球、挡板和计分的全局变量。您的屏幕代码应该看起来像以下代码示例：
- en: '![Creating screen labels](img/B04681_09_04.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![创建屏幕标签](img/B04681_09_04.jpg)'
- en: Ball – the starting location
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 球 - 起始位置
- en: In Tiny Tennis, the ball is one of the most important parts of the game. We
    have a lot to do to make it work. First, we need to give the ball some global
    characteristics so that it can be drawn and redrawn to create the illusion of
    movement.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在“迷你网球”游戏中，球是游戏最重要的部分之一。我们需要做很多事情来让它工作。首先，我们需要给球一些全局特性，以便它可以被绘制和重绘，从而产生运动的错觉。
- en: 'First, we need to set the *x*, *y* coordinates of the ball. By making a global
    variable for this, we can tell the computer where to redraw the ball without having
    to write special code for each movement of the ball. We will set the default value
    of `x` and `y` so that the ball starts in the center of the screen. Write the
    next lines into your `tiny.py` file:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要设置球的 *x*，*y* 坐标。通过为这个坐标创建一个全局变量，我们可以告诉计算机在哪里重绘球，而无需为球的每次移动编写特殊的代码。我们将设置
    `x` 和 `y` 的默认值，使球从屏幕中心开始。将以下几行代码写入你的 `tiny.py` 文件：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Ball – setting the speed and direction
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 球 - 设置速度和方向
- en: 'Now that we have told the ball to start in the center of the screen as default,
    we need to tell the ball how far to move by giving it `x` and `y` coordinates
    for movement:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经告诉球默认从屏幕中心开始，我们需要通过给出移动的 `x` 和 `y` 坐标来告诉球移动多远：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `ball_xv = 3` means that the ball will move `3` pixels along the *x* axis
    each time it is redrawn. The `ball_yv = 3` means that the ball will move `3` pixels
    along the *y* axis each time the screen redraws. This is great as it will help
    us keep the ball going in the speed and direction that we like. Here*, v = velocity*
    which is the magnitude (speed) and direction (*x,y*) of the ball. So, when we
    say `ball_xv = 3`, we are really saying that *the ball moves along the x axis
    at a speed of 3 pixels each time the screen is redrawn*.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`ball_xv = 3` 表示球每次重绘时将在 *x* 轴上移动 `3` 像素。`ball_yv = 3` 表示球每次屏幕重绘时将在 *y* 轴上移动
    `3` 像素。这很好，因为它将帮助我们保持球以我们喜欢的速度和方向移动。在这里，*v = 速度*，这是速度（大小）和方向（*x,y*）的量。所以当我们说 `ball_xv
    = 3` 时，我们实际上是在说 *球每次屏幕重绘时沿 x 轴以 3 像素的速度移动*。'
- en: Ball – setting the size
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 球 - 设置大小
- en: 'The final thing that we will define about the ball is its radius. The radius
    is half of the total width of the ball, as represented in pixels. By setting the
    radius, we set the size. Write the following line of code into your `tiny.py`
    file to represent the ball radius:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要定义的关于球最后的东西是它的半径。半径是球总宽度的二分之一，如像素所示。通过设置半径，我们设置了大小。将以下代码行写入你的 `tiny.py`
    文件以表示球半径：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now that we have defined the characteristics of the ball, make sure to save
    the file. Nobody wants to rewrite lines of working code! Take a look at an example
    of this section of code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了球的特点，请确保保存文件。没有人愿意重写正在工作的代码行！看看这个代码段的例子：
- en: '![Ball – setting the size](img/B04681_09_05.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![球 - 设置大小](img/B04681_09_05.jpg)'
- en: Paddles – starting location and size
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 球拍 - 起始位置和大小
- en: In our game, we will have two paddles. Recall that in the beginning of this
    chapter, it was said that there is more than one way to do some of the things
    that we are doing. There are more advanced ways to make the paddles, but it is
    important that you understand each part of the paddle, so we are going to break
    our code down very simply. Later, once you have completed this game, you can do
    some research on creating objects and try creating paddles as objects.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的游戏中，我们将有两个球拍。回想一下，在本章的开头，提到我们做某些事情的方式不止一种。有更高级的方法来制作球拍，但了解球拍的每个部分非常重要，因此我们将非常简单地分解我们的代码。一旦你完成了这个游戏，你可以做一些关于创建对象的研究，并尝试将球拍作为对象创建。
- en: 'We will give our paddle four qualities: a starting location on the *x* axis,
    a starting location on the *y* axis, a width, and a height. Each of these numbers
    is a representation in pixels. Below the ball globals, on line 34, add the next
    five lines to your `tiny.py` file:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将给我们的球拍四个特性：*x* 轴上的起始位置，*y* 轴上的起始位置，宽度和高度。这些数字都是像素表示。在球的全局变量下方，在第 34 行，将以下五行代码添加到你的
    `tiny.py` 文件中：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You probably noticed that the code we wrote is for `paddle1`. There are two
    paddles required for Tiny Tennis. We want to give each player a fair start, so
    we will create `paddle2` so that it is equal in size, but it''s located opposite
    `paddle1`. To make the second paddle, start on line 40 and write the next five
    lines of code:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You will notice that the `x` coordinate for paddle 2 combines `the screen_width`
    variable, which is the maximum `x` coordinate number (`600`) and then subtracts
    the width of the paddle (`25`) + the `x` coordinate value of paddle 1 (`10`) as
    well. This math allows us to make sure that the paddle is the same distance from
    the right-hand side of the screen as it is from the left-hand side of the screen.
    If you are confused, copy the code into your file and save it. You can play with
    the numbers and see how your paddles change based on each value:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '![Paddles – starting location and size](img/B04681_09_06.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
- en: Initializing the score
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to have a score, we are going to create a variable for each player
    that begins at the default score, zero. As this is a global variable, like the
    other integers, it will change as the game loop runs. For now, we just need to
    have placeholders for each player. So, starting on line 46, add these lines of
    code to your game:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We have now created all of the global variables that we need to write code
    that is easier to understand. Remember, these are called global variables because
    they can be used throughout the entire code file. Save your file. Then, compare
    your code with the completed code in this screenshot:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '![Initializing the score](img/B04681_09_07.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
- en: Testing section 1
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have imported libraries, initialized pygame, and created globals
    for colors, the screen, ball, and the paddles, we can run our first tests to check
    how things are going. To test the game, you will need to locate the directory
    where you saved your `tiny.py` file in your terminal/command prompt. In earlier
    games, we made this directory on the desktop. Once you navigate to the directory
    where `tiny.py` is saved, you can run the following commands from the terminal/command
    prompt to see your game so far:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When you run this command, you should see a window pop up and then close. The
    window will not stay open because we have not written any of the code that runs
    the game; however, if the code runs and there are *NO ERRORS* in your terminal/command
    prompt, then you can keep moving forward with confidence.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: If there are errors in your code, now is a good time to fix them. Some common
    errors that can take place include syntax errors (using the wrong symbols), typos
    (spelling something incorrectly, such as a Python keyword), or trying to run your
    file from the wrong directory. If you have errors, check for these common errors,
    and fix the mistakes in your code.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: If you get an error that is not one of the aforementioned common errors, you
    can always perform an Internet search to ask a question about the problem you
    are having. It is very common for even experienced developers to use Internet
    searches to find help to fix errors, and there are many websites and blogs that
    people maintain in order to help others learn.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Section 2 – moving the paddles
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we finally get to write the code that will make our paddles appear on the
    screen and allow us to control the paddle.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: 'This is where we get the chance to use the logic and loops that we learned
    about in earlier chapters. In a game such as Tiny Tennis, many decisions are made
    very quickly. Computers are great at making fast decisions based on our instructions.
    Here are the parts of the code that will be in the next section:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Creating the `while` loop
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Key events
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will code these next pieces step by step, and then test the code by running
    it to check whether there are any errors. It is suggested that you read through
    this whole section before you start coding so that you know what to expect. Once
    you have read through everything, the fun starts!
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Pre-loop actions
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we actually create the `while` loop, there are two actions that we will
    code. The first is to ensure that the cursor disappears when it goes over the
    game screen, so it is not an interruption. There is a special function for this
    behavior in pygame:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: By setting the visibility to `0`, we make the mouse/cursor invisible to the
    game. Since we do not need the mouse in the game, it is okay for us to do this.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: 'The second action is to set the global variable for our `while` loop. We are
    going to call our main game loop variable `do_main`. We will set `do_main = True`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Tip
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that syntax and case (uppercase or lowercase) are important. Notice
    the *CAPITAL* letter *T*, and make sure to copy it exactly as it is. Remember,
    *True* is a Boolean that needs to be written with a capital *T*. Now, we are ready
    to write our `while` loop.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Creating the while loop
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our game loop will be a `while` loop. We will use `do_main` as our `True` statement.
    So, you will have another line of code that looks like this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Make sure you place a colon (`:`) at the end of the line. Also, all of the
    other lines of code in the game loop will be indented at least once because they
    all need to be *INSIDE* of the loop to run. Here is a screenshot of the `while`
    loop:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the while loop](img/B04681_09_08.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
- en: Moving the paddles – keyboard events
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first set of events in the `while` loop are keyboard events. These events
    take place when a key or set of keys get pressed. The events use the `if`/`elif`
    logic. All of them are indented on at least one tab, and some are indented on
    two tabs or more. Remember that indents are an organizational tool in Python and
    help us keep track of when certain code should be run.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice the code on line 54 of the screenshot. In line 54, we will create the
    pressed variable, which we will set equal to the `pygame.key.get_pressed()` function.
    This will give us a shorter reference to the function. Type this code in line
    54:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In line 55, we use the `pygame.key.set_repeat()` function. This tells the computer
    that once a key is pressed, the action that the key performs should continue until
    the user lets the key go. Type the next line of code into line 55 of your `tiny.py`
    file:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now that we have set the variable and characteristics for the keyboard events,
    we will create our first loop, a `for` loop that looks for the player to quit.
    Using a `for` loop, we will loop over each event that is found using the `pygame.event.get()`
    function. If the event is a *QUIT* event, then the `while` loop will automatically
    end. You will notice that we also use our `if` logic here so that we can tell
    the computer to make a decision if it finds the quit event. To make this `for`
    loop, you will write the following lines of code, starting on line 56 of your
    code file:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now that we have told the computer how and when to end the `while` loop, we
    can tell the computer what to do when certain keys are pressed. For our Tiny Tennis
    game, we need to assign keys to exit the game as well as ones to control paddle
    1 and paddle 2.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Want to choose different keys than the ones we use in this book? You can find
    an entire list of how to use every keyboard key on the pygame website at [http://www.pygame.org/docs/ref/key.html](http://www.pygame.org/docs/ref/key.html).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Exiting the game – escape key
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To exit the game, we will use the *Esc* key. You will notice that we use our
    pressed variable followed by the key code for the *Esc* key. Starting from line
    60, type these two lines of code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The lines of code tell the computer that if the *Esc* key is pressed, then the
    `do_main` global variable should be set to `False`. When `do_main` is set to Boolean
    `False`, then the `while` loop stops. We will write the code that ends the game
    a bit later.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Paddle control – player 1
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For player 1''s paddle to go up, we will use the *W* key. For player 1''s paddle
    to go down, we will use the *S* key. These are very typical keys to use for computer
    game controls. Notice which letters are uppercase and which are lowercase, and
    be sure to copy them exactly, starting from line 63:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Paddle control – player 2
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Player 2 also needs to have keyboard controls that work to move his/her paddle
    up and down at the same time as player 1\. This means that we must assign different
    keys for the second paddle. For this game, we are using the up arrow key to move
    paddle 2 up and the down arrow key to move paddle 2 down. Type the following lines
    of code into your `tiny.py` file, starting from line 68:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Tip
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Save your work!
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: The increase and decrease value (-= and +=)
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will notice the **-=** and **+=** symbols in this code. These symbols are
    used as shortcuts to increase or decrease the value of something. In the code
    for moving the paddles, we use these symbols to add or subtract values when the
    paddle keys are pressed. Both the -= and += symbols are very important for setting
    the proper paddle position each time the paddles are moved by the user.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Testing section 2
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Time to test our code again. In your terminal/command prompt, locate the directory
    where you saved your `tiny.py` file. In earlier games, we made this directory
    on the desktop. Once you navigate to the directory where `tiny.py` is saved, you
    can run the following command from the terminal/command prompt to see your game
    so far:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'During this test, you will see a window open that says **Tiny Tennis** at the
    top and is totally blank otherwise. See this screenshot:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing section 2](img/B04681_09_09.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
- en: If you are getting errors, remember to check your code for typos, syntax errors,
    and case errors.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Section 3 – moving the ball
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have written and tested the code for the paddles, we need to write
    code to move the ball. We will be changing the location of the ball with some
    of our code, and we will create something called collision detection.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Moving the ball – updating the location
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we need to be constantly calculating the `x` and `y` coordinates of
    the ball based on the velocity of the ball that we set in the global variables.
    This allows us to make constant updates as long as we are playing the game. To
    make sure that the `x` and `y` coordinates of the ball update as the ball moves,
    you will type the following lines of code, starting from line 74:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Collision detection
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our next job is to code something called **collision detection**. This means
    that we can program the computer to know when two objects are hitting one another.
    We can also tell the computer what we want it to do when the objects collide.
    In Tiny Tennis, we have three kinds of collisions that we want to detect:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Collision of the ball with the top and bottom of the screen
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collision of the paddle with the top and bottom of the screen
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collision of the ball with the paddle
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collision of the ball with the top and the bottom of the screen
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, we will use our `if` statement to define what happens if the ball hits
    the top or the bottom of the screen. Basically, we want the ball to bounce back
    if it hits the top or bottom of the screen. Type the following code starting from
    line 77 of your `tiny.py` file:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The first line, beginning with `if`, basically says *If the radius is subtracted
    from the y coordinate and that is less than or equal to zero OR if the radius
    is added to the y coordinate and it is greater than the number of the screen height
    (400), then do something about it*.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: 'The second line of the code that comes after the colon tells us what to do:
    *the velocity of the y coordinate of the ball should be in the reverse direction*.
    The second line of code, `ball_yv *= -1`, means that the velocity of the `y` coordinate
    gets reversed because it is multiplied by `-1`. Any number multiplied by `-1`
    becomes opposite to its original sign, and, in this case, reversing the sign means
    reversing the direction of the ball.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: So, why does this code work? Let's think about it. The top `y` coordinate is
    zero. If the ball tries to move past the top, its `y` value will be less than
    zero, which means that it will be out of the screen. To make the ball stay on
    the screen, we change its direction when the `y` coordinate value is less than
    zero.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: The bottom `y` coordinate is `400`. So, if the ball's `y` value is greater than
    `400`, then we change the direction of the ball to go back up. We make these directional
    changes by multiplying the velocity of the ball by `-1`, resulting in a directional
    change.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: 'Before moving on, compare your code to this code:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '![Collision of the ball with the top and the bottom of the screen](img/B04681_09_10.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
- en: Collision of the paddle with the top and the bottom of screen
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We want the paddle to stop when it reaches the top or bottom of the screen.
    To make this happen, we need to create a code that will recognize the `y` value
    of the paddle and then stop the paddle from moving beyond the two `y` values that
    create the screen borders. These two values are `0` for the top of the screen,
    and `400` for the bottom. Copy the following lines of code into your program,
    starting from line 81\. Check to make sure that your indent level is correct:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This code works differently from the ball code because we do not want the paddles
    to bounce around! Instead, we want the paddles to stop when they hit the top or
    bottom of the screen. So, you will notice that whenever paddle 1 or paddle 2 goes
    beyond the barriers of the screen (`0` and `400`), the value of the paddle is
    reset to *EQUAL* the boundary values of `0` or `400`, depending on *WHERE* the
    paddle is located (is it at the top of the screen or the bottom?). Save your work
    once you are done with adding this code.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Collision of the ball with the paddles
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The collision of the ball with the paddles will determine what happens when
    the ball hits the paddle. There are two paddles, and it will be helpful if you
    add some comment code using a hashtag to keep track of the code for the left-hand
    side paddle (paddle 1) and the right-hand side paddle (paddle 2).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have done some collision detection, let''s think about the ball
    and paddle. When the ball hits the paddle, we want the ball to appear as though
    it has bounced off of the paddle. Therefore, we need to make sure that the result
    of the collision between the ball and the paddle is that the ball reverses itself
    and goes in the opposite direction. This is actually the same behavior that we
    used to make the ball bounce off the edges of the screen, except now we need to
    outline all the pieces of paddle 1 and paddle 2\. Copy these lines of code into
    your file:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Take a look at this screenshot, and compare your code:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '![Collision of the ball with the paddles](img/B04681_09_11.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
- en: Testing – section 3
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You are almost done writing the game! Now it''s time to test our code again.
    In your terminal/command prompt, locate the directory where you saved your `tiny.py`
    file. You can run the following command from the terminal/command prompt to check
    the progress of your game so far:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: During this test, if everything is working correctly, your results will be the
    same as the test from Section 2\. A blank screen will open and will be called
    Tiny Tennis. Congratulations!
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: If your program has some errors while running, look at the error messages to
    check whether you can figure out what is going wrong. Look for syntax mistakes,
    spelling mistakes, indentation mistakes, or any other errors in your code. Make
    sure that you are using spaces for your indentations, not tabs, or else you might
    have problems as well.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Section 4 – draw screen and track the score
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, we know that the ball bounces off the top and bottom of the screen as well
    as off the paddles. However, if the user misses the ball with the paddle, what
    happens to the ball? What happens to the player and their score?
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section of the game, we use the location of the `x` coordinates to
    determine whether the ball is on the screen or it has gone past the paddles and
    is outside the screen. We use our `if` statement to tell the computer what to
    do. The *x* axis `0` coordinate is the left-most side of the screen. If the ball''s
    `x` value is less than `0`, then the player on the other side (player 2) has scored
    a point because player 1 failed to block the ball. If you read the lines of code,
    you will notice that we reset the `ball_x` and `ball_y` coordinates to the center
    of the screen so that a new game can start. Copy the next four lines of code to
    place this logic into the game:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You will notice that the next four lines of code are almost identical, with
    only two changes. The ball''s `x` value is now being compared to the maximum screen
    width, which is `600`. If the ball''s `x` value becomes greater than `600`, it
    means that the player has missed the ball and the ball is now outside of the screen.
    Now, player 1 has scored because player 2 did not block the ball. To make sure
    that this logic is also in the game, copy the next four lines of code into your
    file:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '![Section 4 – draw screen and track the score](img/B04681_09_12.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
- en: Tip
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ensure that you save your work!
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: The render screen – show what's happened
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The final code that we need to write is the code that redraws the screen and
    all of the objects so that the movements appear to happen. The next lines of code
    draw the five objects that are a part of our game. There is no need to use variable
    names to draw the paddles, net, or the balls, except that it does make them easier
    to find if you want to fix or change that part of the code. Again, these lines
    of code are indented so that they are inside of the `while` loop:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `game_screen.fill(black)` code uses our `game_screen` variable and tells
    the `fill()` function to make our screen black by putting the color `black` in
    parentheses. Did you notice that we used two global variables, `game_screen` and
    `black`, in this line of code? Imagine how much longer the code would be without
    these variables. Imagine that it might be more difficult to read and to change.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 'You will notice that the `pygame.draw.rect()` function is used to draw the
    paddles, since they are just rectangles. The paddles have the following characteristics:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Game screen (tells you where they should go)
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Color
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `x` coordinate
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `y` coordinate (to provide a starting location)
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A width
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A height
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you look at the `line()` and `circle()` objects, you will notice that they
    are not too different from the rectangle. Both have a `game_screen` and color
    property. The line object accepts arguments that define a length, width, and *x*
    value for the line. The circle object accepts arguments that define `game_screen`,
    color, and ball characteristics. Since we defined the ball characteristics early
    in the chapter with global variables, we can use them in the `circle()` code.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Displaying player scores
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our next few lines of code will draw the player scores on the screen:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The top line of our game score code provides the definition for the `score_text`
    variable, which is used in the second line of this code that we just added. The
    `game_screen.blit()` function copies our score text each time our screen is redrawn,
    since the score text may not change for a long time if neither player misses the
    ball.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the `pygame.display.update()` function updates the image with the
    new information stored by our program. Because a computer can move at speeds infinitely
    faster than a human, we have added a `sleep` option, allowing for the update to
    occur at an interval that we can now control:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Ending the program
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The final line of code will be to end the initialization of pygame, which we
    performed at the start of the code. To end this, we will type `pygame.quit()`
    at the outermost level of indentation in our code. This goes outside of the `while`
    loop so that it only happens when the `while` loop stops running:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Once you have typed this, your final game code lines should look like this:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '![Ending the program](img/B04681_09_13.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
- en: Once you have double-checked your code against the screenshots in the chapter,
    make sure that you save your `tiny.py` file. Now you are ready to truly give your
    game a test!
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: Play Tiny Tennis!
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The best part about Tiny Tennis is that you can play it against yourself, making
    it easy to test the game and experiment with different parts of the game. Now,
    when you run the file from your terminal, a window that looks like this should
    pop up:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '![Play Tiny Tennis!](img/B04681_09_14.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
- en: The ball should start moving immediately toward one side or the other of the
    screen. You can test the game by making sure that the paddles on each side of
    the screen are able to hit the ball and that they do not go outside of the screen
    space. You can test the scoring mechanism to make sure that the appropriate player
    is getting the points for each shot that they make past the other player. Then,
    you can invite others to play the game with you.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: If you are not happy with parts of the game, you can change them. For example,
    you might choose a different color for the ball, paddles, and the screen. Maybe
    you want the paddles to be longer or shorter or, perhaps, thinner. Maybe you want
    to make the ball bigger or smaller by changing the radius.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: You might decide that you want the ball and paddles to move faster so that the
    game is more challenging, or maybe you want the ball and paddles to move slower
    if you are designing the game to be played by younger children. Design choices
    are made for many reasons, and now that you have a playable game, you might decide
    to make some different design decisions.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: You can test your decisions by making a copy of your game code and then testing
    any modifications in your copy. It is a good idea to keep a backup of your working
    code so that if you write broken code, you have a place to return to and start
    again.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Congratulations on building your first game! There are so many things that you
    learned to do. The greatest thing about code, though, is that there are many ways
    to do everything. Some ways are easier to understand but not as efficient as other
    ways. Some code is very efficient but might not be easily understood by another
    programmer. The best code is both easy to understand and written in the most efficient
    way possible.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Throughout the previous chapter, we used a combination of code that was easy
    to understand, but may not have been as efficient as possible. This is because
    we were learning many new principles in pygame, and things, such as collision
    detection, can be challenging to code. You may decide to do things differently
    after you have a few games under your belt!
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will review all that we have learned in this book, and
    we will also take a look at some other ways that Python is used out in the world,
    as Python is a very useful language to know. See you in the last chapter!
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
