["```py\n>>> from itertools import count \n>>> enumerate = lambda x, start=0: zip(count(start), x)\n```", "```py\n>>> list(zip(count(), iter(’word’))) \n[(0, ’w’), (1, ’o’), (2, ’r’), (3, ’d’)] \n>>> list(enumerate(iter(’word’))) \n[(0, ’w’), (1, ’o’), (2, ’r’), (3, ’d’)]\n```", "```py\n>>> list(zip(count(1, 3), iter(’word’))) \n[(1, ’w’), (4, ’o’), (7, ’r’), (10, ’d’)]\n```", "```py\n>>> source = iter(’word’) \n>>> gen3 = ((1+3*e, x) for e, x in enumerate(source)) \n>>> list(gen3) \n[(1, ’w’), (4, ’o’), (7, ’r’), (10, ’d’)]\n```", "```py\nfrom collections.abc import Callable, Iterator \nfrom typing import TypeVar \nT = TypeVar(\"T\") \n\ndef find_first( \n    terminate: Callable[[T], bool], \n    iterator: Iterator[T] \n) -> T: \n    i = next(iterator) \n    if terminate(i): \n        return i \n    return find_first(terminate, iterator)\n```", "```py\n\n>>> def term_iter(): \n...     d = 1 \n...     sgn = 1 \n...     while True: \n...         yield Fraction(sgn, d) \n...         d += 2 \n...         sgn = -1 if sgn == 1 else 1\n```", "```py\n\n>>> find_first(lambda v: abs(v) < 1E-2, term_iter()) \nFraction(1, 101)\n```", "```py\nfrom itertools import count \nfrom collections.abc import Iterator \nfrom typing import NamedTuple, TypeAlias \n\nPair = NamedTuple(’Pair’, [(’flt_count’, float), (’int_count’, float)]) \nPair_Gen: TypeAlias = Iterator[Pair] \n\nsource: Pair_Gen = ( \n  Pair(fc, ic) for fc, ic in \n  zip(count(0, 0.1), (.1*c for c in count())) \n) \n\ndef not_equal(pair: Pair) -> bool: \n  return abs(pair.flt_count - pair.int_count) > 1.0E-12\n```", "```py\n>>> find_first(not_equal, source)\nPair(flt_count=92.799999999999, int_count=92.80000000000001)\n\n```", "```py\n>>> source: Pair_Gen = map(Pair, count(0, 0.1), (.1*c for c in count())) \n\n>>> find_first(lambda pair: pair.flt_count != pair.int_count, source) \nPair(flt_count=0.6, int_count=0.6000000000000001)\n```", "```py\n>>> from itertools import cycle \n\n>>> m3 = (i == 0 for i in cycle(range(3))) \n>>> m5 = (i == 0 for i in cycle(range(5)))\n```", "```py\n>>> multipliers = zip(range(10), m3, m5)\n```", "```py\n>>> list(multipliers)\n[(0, True, True), (1, False, False), (2, False, False), ..., (9, True,\nFalse)]\n\n```", "```py\n>>> multipliers = zip(range(10), m3, m5) \n>>> total = sum(i \n...     for i, *multipliers in multipliers \n...     if any(multipliers) \n... )\n```", "```py\nfrom collections.abc import Iterable, Iterator \nfrom itertools import cycle \nfrom typing import TypeVar \nDT = TypeVar(\"DT\") \n\ndef subset_iter( \n         source: Iterable[DT], cycle_size: int \n) -> Iterator[DT]: \n    chooser = (x == 0 for x in cycle(range(cycle_size))) \n    yield from ( \n        row \n        for keep, row in zip(chooser, source) \n        if keep \n    )\n```", "```py\nimport csv \nfrom pathlib import Path \n\ndef csv_subset( \n        source: Path, target: Path, cycle_size: int = 3 \n) -> None: \n    with ( \n            source.open() as source_file, \n            target.open(’w’, newline=’’) as target_file \n    ): \n        rdr = csv.reader(source_file, delimiter=’\\t’) \n        wtr = csv.writer(target_file) \n        wtr.writerows(subset_iter(rdr, cycle_size))\n```", "```py\nfrom itertools import cycle, repeat \n\ndef subset_rule_iter( \n        source: Iterable[DT], rule: Iterator[bool] \n) -> Iterator[DT]: \n    return ( \n        v \n        for v, keep in zip(source, rule) \n        if keep \n    ) \n\nall_rows = lambda: repeat(True) \nsubset = lambda n: (i == 0 for i in cycle(range(n)))\n```", "```py\nimport random \n\ndef randomized(limit: int) -> Iterator[bool]: \n    while True: \n        yield random.randrange(limit) == 0\n```", "```py\n>>> import random \n>>> random.seed(42) \n>>> data = [random.randint(1, 12) for _ in range(12)] \n>>> data \n[11, 2, 1, 12, 5, 4, 4, 3, 12, 2, 11, 12] \n\n>>> list(subset_rule_iter(data, all_rows())) \n[11, 2, 1, 12, 5, 4, 4, 3, 12, 2, 11, 12] \n>>> list(subset_rule_iter(data, subset(3))) \n[11, 12, 4, 2] \n\n>>> random.seed(42) \n>>> list(subset_rule_iter(data, randomized(3))) \n[2, 1, 4, 4, 3, 2]\n```", "```py\n>>> raw_values = [1.2, .8, 1.2, 2.3, 11, 18] \n\n>>> tuple(enumerate(sorted(raw_values))) \n((0, 0.8), (1, 1.2), (2, 1.2), (3, 2.3), (4, 11), (5, 18))\n```", "```py\n>>> from textwrap import wrap \n>>> from pprint import pprint \n\n>>> trip[0] \nLegNT(start=PointNT(latitude=37.54901619777347, longitude=-76.33029518659048), ... \n\n>>> pprint(wrap(str(trip[0]))) \n[’LegNT(start=PointNT(latitude=37.54901619777347,’, \n ’longitude=-76.33029518659048), end=PointNT(latitude=37.840832,’, \n ’longitude=-76.273834), distance=17.7246)’] \n>>> pprint(wrap(str(trip[-1]))) \n[’LegNT(start=PointNT(latitude=38.330166, longitude=-76.458504),’, \n ’end=PointNT(latitude=38.976334, longitude=-76.473503),’, \n ’distance=38.8019)’]\n```", "```py\nfrom typing import NamedTuple \n\nclass Point(NamedTuple): \n    latitude: float \n    longitude: float \n\nclass Leg(NamedTuple): \n    order: int \n    start: Point \n    end: Point \n    distance: float\n```", "```py\nfrom typing import Iterator \nfrom Chapter04.ch04_ex1 import haversine \n\ndef numbered_leg_iter( \n    pair_iter: Iterator[tuple[Point, Point]] \n) -> Iterator[Leg]: \n    for order, pair in enumerate(pair_iter): \n        start, end = pair \n        yield Leg( \n            order, \n            start, \n            end, \n            round(haversine(start, end), 4) \n        )\n```", "```py\n>>> from Chapter06.ch06_ex3 import row_iter_kml \n>>> from Chapter04.ch04_ex1 import legs, haversine \n>>> import urllib.request \n\n>>> source_url = \"file:./Winter%202012-2013.kml\" \n>>> with urllib.request.urlopen(source_url) as source: \n...     path_iter = float_lat_lon(row_iter_kml(source)) \n...     pair_iter = legs(path_iter) \n...     trip_iter = numbered_leg_iter(pair_iter) \n...     trip = list(trip_iter)\n```", "```py\n>>> from itertools import accumulate \n>>> import math \n\n>>> distances = (leg.distance for leg in trip) \n>>> distance_accum = list(accumulate(distances)) \n>>> scale = math.ceil(distance_accum[-1] / 4) \n\n>>> quartiles = list(int(scale*d) for d in distance_accum)\n```", "```py\n[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \n2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, \n3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3]\n```", "```py\nimport csv \nfrom collections.abc import Iterator \nfrom contextlib import ExitStack \nfrom pathlib import Path \nfrom typing import TextIO \n\ndef row_iter_csv_tab(*filepaths: Path) -> Iterator[list[str]]: \n    with ExitStack() as stack: \n        files: list[TextIO] = [ \n            stack.enter_context(path.open()) \n            for path in filepaths \n        ] \n        readers = map( \n            lambda f: csv.reader(f, delimiter=’\\t’), \n            files) \n        yield from chain(*readers)\n```", "```py\n>>> from itertools import groupby \n>>> from Chapter07.ch07_ex1 import get_trip \n\n>>> source_url = \"file:./Winter%202012-2013.kml\" \n>>> trip = get_trip(source_url) \n>>> quartile = quartiles(trip) \n>>> group_iter = groupby(zip(quartile, trip), key=lambda q_raw: q_raw[0]) \n>>> for group_key, group_iter in group_iter: \n...    print(f\"Group {group_key+1}: {len(list(group_iter))} legs\") \nGroup 1: 23 legs \nGroup 2: 14 legs \nGroup 3: 19 legs \nGroup 4: 17 legs\n```", "```py\nfrom collections import defaultdict \nfrom collections.abc import Iterable, Callable, Hashable \n\nDT = TypeVar(\"DT\") \nKT = TypeVar(\"KT\", bound=Hashable) \n\ndef groupby_2( \n    iterable: Iterable[DT], \n    key: Callable[[DT], KT] \n) -> Iterator[tuple[KT, Iterator[DT]]]: \n    groups: dict[KT, list[DT]] = defaultdict(list) \n    for item in iterable: \n        groups[key(item)].append(item) \n    for g in groups: \n        yield g, iter(groups[g])\n```", "```py\n>>> from itertools import pairwise \n\n>>> text = \"hello world\" \n>>> list(pairwise(text)) \n[(’h’, ’e’), (’e’, ’l’), (’l’, ’l’), ...]\n```", "```py\nfrom typing import TypeVar \n\nDataT = TypeVar(\"DataT\") \n\ndef subset_gen( \n        data: Iterable[DataT], rule: Iterable[bool] \n) -> Iterator[DataT]: \n    return ( \n        v \n        for v, keep in zip(data, rule) \n        if keep \n    )\n```", "```py\n>>> import random \n>>> random.seed(1) \n>>> data = [random.randint(1, 12) for _ in range(12)] \n\n>>> from itertools import compress \n\n>>> copy = compress(data, all_rows()) \n>>> list(copy) \n[3, 10, 2, 5, 2, 8, 8, 8, 11, 7, 4, 2] \n\n>>> cycle_subset = compress(data, subset(3)) \n>>> list(cycle_subset) \n[3, 5, 8, 7] \n\n>>> random.seed(1) \n>>> random_subset = compress(data, randomized(3)) \n>>> list(random_subset) \n[3, 2, 2, 4, 2]\n```", "```py\nfrom itertools import compress, tee \nfrom collections.abc import Iterable, Iterator, Callable \nfrom typing import TypeVar \n\nSrcT = TypeVar(\"SrcT\") \n\ndef filter_concept( \n        function: Callable[[SrcT], bool], \n        source: Iterable[SrcT] \n) -> Iterator[SrcT]: \n    i1, i2 = tee(source, 2) \n    return compress(i1, map(function, i2))\n```", "```py\n>>> from Chapter04.ch04_ex5 import parse_g \n\n>>> with open(\"1000.txt\") as source: \n...    flat = list(parse_g(source)) \n\n>>> flat[:10] \n[2, 3, 5, 7, 11, 13, 17, 19, 23, 29] \n\n>>> flat[-10:] \n[7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919]\n```", "```py\n>>> list(zip(flat[0::2], flat[1::2])) \n[(2, 3), (5, 7), (11, 13), ...]\n```", "```py\n>>> flat_iter_1 = iter(flat)\n>>> flat_iter_2 = iter(flat)\n>>> pairs = list(zip(\n... islice(flat_iter_1, 0, None, 2),\n... islice(flat_iter_2, 1, None, 2)\n... ))\n>>> len(pairs)\n500\n>>> pairs[:3]\n[(2, 3), (5, 7), (11, 13)]\n>>> pairs[-3:]\n[(7877, 7879), (7883, 7901), (7907, 7919)]\n\n```", "```py\n[(2, 3), (5, 7), (11, 13), (17, 19), (23, 29), \n... \n(7883, 7901), (7907, 7919)]\n```", "```py\nGIMP Palette \nName: Crayola \nColumns: 16 \n#\n```", "```py\n255 73 108 Radical Red\n```", "```py\n255 73 108\\tRadical Red\n```", "```py\n>>> import csv \n>>> from pathlib import Path \n\n>>> source_path = Path(\"crayola.gpl\") \n>>> with source_path.open() as source: \n...     rdr = csv.reader(source, delimiter=’\\\\t’) \n...     row_iter = dropwhile( \n...         lambda row: row[0] != ’#’, rdr \n...     ) \n...     color_rows = islice(row_iter, 1, None) \n...     colors = list( \n...         (color.split(), name) for color, name in color_rows \n...     )\n```", "```py\nfilterfalse_concept = ( \n    lambda pred, iterable: \n    filter(lambda x: not pred(x), iterable) \n)\n```", "```py\n>>> from itertools import filterfalse \n\n>>> source = [0, False, 1, 2] \n>>> list(filter(None, source)) \n[1, 2] \n\n>>> filterfalse(None, source) \n<itertools.filterfalse object at ...> \n>>> list(_) \n[0, False]\n```", "```py\n>>> iter_1, iter_2 = tee(iter(raw_samples), 2) \n\n>>> rule_subset_iter = filter(rule, iter_1) \n>>> not_rule_subset_iter = filterfalse(rule, iter_2)\n```", "```py\nmap_concept = ( \n    lambda function, arg_iter: \n    (function(a) for a in arg_iter) \n)\n```", "```py\nstarmap_concept = ( \n    lambda function, arg_iter: \n    (function(*a) for a in arg_iter) \n             #^-- Adds this * to decompose tuples \n)\n```", "```py\nfrom Chapter04.ch04_ex1 import legs, haversine \nfrom Chapter06.ch06_ex3 import row_iter_kml \nfrom Chapter07.ch07_ex1 import float_lat_lon, LegNT, PointNT \nimport urllib.request \nfrom collections.abc import Callable \n\ndef get_trip_starmap(url: str) -> List[LegNT]: \n    make_leg: Callable[[PointNT, PointNT], LegNT] = ( \n        lambda start, end: \n        LegNT(start, end, haversine(start, end)) \n    ) \n    with urllib.request.urlopen(url) as source: \n        path_iter = float_lat_lon( \n            row_iter_kml(source) \n        ) \n        pair_iter = legs(path_iter) \n        trip = list(starmap(make_leg, pair_iter)) \n                   #-------- Used here \n    return trip\n```", "```py\n>>> from pprint import pprint \n>>> source_url = \"file:./Winter%202012-2013.kml\" \n>>> trip = get_trip_starmap(source_url) \n>>> len(trip) \n73 \n>>> pprint(trip[0]) \nLegNT(start=PointNT(latitude=37.54901619777347, longitude=-76.33029518659048), end=PointNT(latitude=37.840832, longitude=-76.273834), distance=17.724564798884984) \n\n>>> pprint(trip[-1]) \nLegNT(start=PointNT(latitude=38.330166, longitude=-76.458504), end=PointNT(latitude=38.976334, longitude=-76.473503), distance=38.801864781785845)\n```", "```py\nfrom collections.abc import Iterable \n\ndef mean_t(source: Iterable[float]) -> float: \n    it_0, it_1 = tee(iter(source), 2) \n    N = sum(1 for x in it_0) \n    sum_x = sum(x for x in it_1) \n    return sum_x/N\n```"]