<html><head></head><body>
  <div id="sbo-rt-content"><div class="chapter" title="Chapter 3. IPv6, Unix Domain Sockets, and Network Interfaces"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. IPv6, Unix Domain Sockets, and Network Interfaces</h1></div></div></div><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Forwarding a local port to a remote host</li><li class="listitem" style="list-style-type: disc">Pinging hosts on the network with ICMP</li><li class="listitem" style="list-style-type: disc">Waiting for a remote network service</li><li class="listitem" style="list-style-type: disc">Enumerating interfaces on your machine</li><li class="listitem" style="list-style-type: disc">Finding the IP address for a specific interface on your machine</li><li class="listitem" style="list-style-type: disc">Finding whether an interface is up on your machine</li><li class="listitem" style="list-style-type: disc">Detecting inactive machines on your network</li><li class="listitem" style="list-style-type: disc">Performing a basic IPC using connected sockets (socketpair)</li><li class="listitem" style="list-style-type: disc">Performing IPC using Unix domain sockets</li><li class="listitem" style="list-style-type: disc">Finding out if your Python supports IPv6 sockets</li><li class="listitem" style="list-style-type: disc">Extracting an IPv6 prefix from an IPv6 address</li><li class="listitem" style="list-style-type: disc">Writing an IPv6 echo client/server</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec28"/>Introduction</h1></div></div></div><p>This chapter extends the use of Python's socket library with a few third-party libraries. It also discusses some advanced techniques, for example, the asynchronous <code class="literal">ayncore</code> module from the Python standard library. This chapter also touches upon various protocols, ranging from an ICMP ping to an IPv6 client/server.</p><p>In this chapter, a few useful Python third-party modules have been introduced by some example recipes. For example, the network packet capture library, <span class="strong"><strong>Scapy</strong></span><a id="id137" class="indexterm"/>, is well known among Python network programmers.</p><p>A few recipes have been dedicated to explore the IPv6 utilities in Python including an IPv6 client/server. Some other recipes cover Unix domain sockets.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Forwarding a local port to a remote host"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec29"/>Forwarding a local port to a remote host</h1></div></div></div><p>Sometimes, you may need to create a local port forwarder that will redirect all traffic from a local port to a <a id="id138" class="indexterm"/>particular remote host. This might be useful to<a id="id139" class="indexterm"/> enable proxy users to browse a certain site while preventing them from browsing some others.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec48"/>How to do it... </h2></div></div></div><p>Let us create a local port forwarding script that will redirect all traffic received at port 8800 to the Google home page (<a class="ulink" href="http://www.google.com">http://www.google.com</a>). We can pass the local and remote host as well as port number to this script. For the sake of simplicity, let's only specify the local port number as we are aware that the web server runs on port 80.</p><p>Listing 3.1 shows a port forwarding example, as follows:</p><div class="informalexample"><pre class="programlisting">#!/usr/bin/env python
# Python Network Programming Cookbook -- Chapter – 3
# This program is optimized for Python 2.7.
# It may run on any other version with/without modifications.

import argparse
LOCAL_SERVER_HOST = 'localhost'
REMOTE_SERVER_HOST = 'www.google.com'
BUFSIZE = 4096
import asyncore
import socket</pre></div><p>First, we define the <code class="literal">PortForwarder</code> class:</p><div class="informalexample"><pre class="programlisting">class PortForwarder(asyncore.dispatcher):
    def __init__(self, ip, port, remoteip,remoteport,backlog=5):
        asyncore.dispatcher.__init__(self)
        self.remoteip=remoteip
        self.remoteport=remoteport
        self.create_socket(socket.AF_INET,socket.SOCK_STREAM)
        self.set_reuse_addr()
        self.bind((ip,port))
        self.listen(backlog)
    def handle_accept(self):
        conn, addr = self.accept()
        print "Connected to:",addr
        Sender(Receiver(conn),self.remoteip,self.remoteport)</pre></div><p>Now, we need <a id="id140" class="indexterm"/>to specify the <code class="literal">Receiver</code> and <code class="literal">Sender</code> classes, as<a id="id141" class="indexterm"/> follows:</p><div class="informalexample"><pre class="programlisting">class Receiver(asyncore.dispatcher):
    def __init__(self,conn):
        asyncore.dispatcher.__init__(self,conn)
        self.from_remote_buffer=''
        self.to_remote_buffer=''
        self.sender=None
    def handle_connect(self):
        pass
    def handle_read(self):
        read = self.recv(BUFSIZE)
        self.from_remote_buffer += read
    def writable(self):
        return (len(self.to_remote_buffer) &gt; 0)
    def handle_write(self):
        sent = self.send(self.to_remote_buffer)
        self.to_remote_buffer = self.to_remote_buffer[sent:]
    def handle_close(self):
        self.close()
        if self.sender:
            self.sender.close()
class Sender(asyncore.dispatcher):
    def __init__(self, receiver, remoteaddr,remoteport):
        asyncore.dispatcher.__init__(self)
        self.receiver=receiver
        receiver.sender=self
        self.create_socket(socket.AF_INET, socket.SOCK_STREAM)
        self.connect((remoteaddr, remoteport))
    def handle_connect(self):
        pass
    def handle_read(self):
        read = self.recv(BUFSIZE)
        self.receiver.to_remote_buffer += read
    def writable(self):
        return (len(self.receiver.from_remote_buffer) &gt; 0)
    def handle_write(self):
        sent = self.send(self.receiver.from_remote_buffer)
        self.receiver.from_remote_buffer = self.receiver.from_remote_buffer[sent:]
    def handle_close(self):
        self.close()
        self.receiver.close()

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Port forwarding example')
    parser.add_argument('--local-host', action="store", dest="local_host", default=LOCAL_SERVER_HOST)
    parser.add_argument('--local-port', action="store", dest="local_port", type=int, required=True)
    parser.add_argument('--remote-host', action="store", dest="remote_host",  default=REMOTE_SERVER_HOST)
    parser.add_argument('--remote-port', action="store", dest="remote_port", type=int, default=80)
    given_args = parser.parse_args() 
    local_host, remote_host = given_args.local_host, given_args.remote_host
    local_port, remote_port = given_args.local_port, given_args.remote_port
    print "Starting port forwarding local %s:%s =&gt; remote %s:%s" % (local_host, local_port, remote_host, remote_port)
    PortForwarder(local_host, local_port, remote_host, remote_port)
    asyncore.loop()</pre></div><p>If you run this script,<a id="id142" class="indexterm"/> it will show the following<a id="id143" class="indexterm"/> output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python 3_1_port_forwarding.py --local-port=8800 </strong></span>
<span class="strong"><strong>Starting port forwarding local localhost:8800 =&gt; remote www.google.com:80 </strong></span>
</pre></div><p>Now, open your browser and visit <code class="literal">http://localhost:8800</code>. This will take you to the Google home page and the script will print something similar to the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Connected to: ('127.0.0.1', 38557)</strong></span>
</pre></div><p>The following screenshot shows the forwarding a local port to a remote host:</p><div class="mediaobject"><img src="images/3463OS_03_01.jpg" alt="How to do it..."/></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec49"/>How it works...</h2></div></div></div><p>We created<a id="id144" class="indexterm"/> a port forwarding class, <code class="literal">PortForwarder subclassed</code>, from <code class="literal">asyncore.dispatcher</code>, which wraps around the socket object. It provides a few additional helpful functions when certain events occur, for example, when the connection is successful or a client is<a id="id145" class="indexterm"/> connected to a server socket. You have the <a id="id146" class="indexterm"/>choice of overriding the set of methods defined in this class. In our case, we only override the <a id="id147" class="indexterm"/>
<code class="literal">handle_accept()</code> method.</p><p>Two other classes have been derived from <code class="literal">asyncore.dispatcher</code>. The <a id="id148" class="indexterm"/>
<code class="literal">Receiver</code> class handles the incoming client requests and the <code class="literal">Sender</code> class takes this <code class="literal">Receiver</code> instance and processes the sent data to the clients. As you can see, these two classes override the<a id="id149" class="indexterm"/> <code class="literal">handle_read()</code>, <code class="literal">handle_write()</code>,<a id="id150" class="indexterm"/> and <code class="literal">writeable()</code> methods<a id="id151" class="indexterm"/> to facilitate the bi-directional communication between the remote host and local client.</p><p>In summary, the <code class="literal">PortForwarder</code> class takes the incoming client request in a local socket and passes this to the <code class="literal">Sender</code> class instance, which in turn uses the <code class="literal">Receiver</code> class instance to initiate a bi-directional communication<a id="id152" class="indexterm"/> with a remote server<a id="id153" class="indexterm"/> in the specified port.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Pinging hosts on the network with ICMP"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec30"/>Pinging hosts on the network with ICMP</h1></div></div></div><p>An ICMP ping is the most common type of network scanning you have ever encountered. It is very easy to open a<a id="id154" class="indexterm"/> command-line prompt or terminal <a id="id155" class="indexterm"/>and type <code class="literal">ping www.google.com</code>. How difficult is that from inside a Python program? This recipe shows you an example of a Python ping.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec50"/>Getting ready</h2></div></div></div><p>You need the superuser or administrator privilege to run this recipe on your machine.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec51"/>How to do it... </h2></div></div></div><p>You can lazily write a Python script that calls the system ping command-line tool, as follows:</p><div class="informalexample"><pre class="programlisting">import subprocess
import shlex

command_line = "ping -c 1 www.google.com"
args = shlex.split(command_line)
try:
      subprocess.check_call(args,stdout=subprocess.PIPE,\
stderr=subprocess.PIPE)
    print "Google web server is up!"
except subprocess.CalledProcessError:
    print "Failed to get ping."</pre></div><p>However, in many circumstances, the system's ping executable may not be available or may be inaccessible. In this case, we need a pure Python script to do that ping. Note that this script needs to be run as a superuser or administrator.</p><p>Listing 3.2 shows the ICMP ping, as follows:</p><div class="informalexample"><pre class="programlisting">#!/usr/bin/env python
# Python Network Programming Cookbook -- Chapter – 3
# This program is optimized for Python 2.7.
# It may run on any other version with/without modifications.

import os
import argparse
import socket
import struct
import select
import time

ICMP_ECHO_REQUEST = 8 # Platform specific
DEFAULT_TIMEOUT = 2
DEFAULT_COUNT = 4 

class Pinger(object):
    """ Pings to a host -- the Pythonic way"""
    def __init__(self, target_host, count=DEFAULT_COUNT, timeout=DEFAULT_TIMEOUT):
        self.target_host = target_host
        self.count = count
        self.timeout = timeout
    def do_checksum(self, source_string):
        """  Verify the packet integritity """
        sum = 0
        max_count = (len(source_string)/2)*2
        count = 0
        while count &lt; max_count:
            val = ord(source_string[count + 1])*256 + ord(source_string[count])
            sum = sum + val
            sum = sum &amp; 0xffffffff 
            count = count + 2
        if max_count&lt;len(source_string):
            sum = sum + ord(source_string[len(source_string) - 1])
            sum = sum &amp; 0xffffffff 
        sum = (sum &gt;&gt; 16)  +  (sum &amp; 0xffff)
        sum = sum + (sum &gt;&gt; 16)
        answer = ~sum
        answer = answer &amp; 0xffff
        answer = answer &gt;&gt; 8 | (answer &lt;&lt; 8 &amp; 0xff00)
        return answer
 
    def receive_pong(self, sock, ID, timeout):
        """
        Receive ping from the socket.
        """
        time_remaining = timeout
        while True:
            start_time = time.time()
            readable = select.select([sock], [], [], time_remaining)
            time_spent = (time.time() - start_time)
            if readable[0] == []: # Timeout
                return
     
            time_received = time.time()
            recv_packet, addr = sock.recvfrom(1024)
            icmp_header = recv_packet[20:28]
            type, code, checksum, packet_ID, sequence = struct.unpack(
                "bbHHh", icmp_header
            )
            if packet_ID == ID:
                bytes_In_double = struct.calcsize("d")
                time_sent = struct.unpack("d", recv_packet[28:28 + bytes_In_double])[0]
                return time_received - time_sent
     
            time_remaining = time_remaining - time_spent
            if time_remaining &lt;= 0:
                return</pre></div><p>We need a <code class="literal">send_ping()</code> method<a id="id156" class="indexterm"/> that <a id="id157" class="indexterm"/>will send the data of a ping request<a id="id158" class="indexterm"/> to the target host. Also, this will call the <code class="literal">do_checksum()</code> method<a id="id159" class="indexterm"/> for checking the integrity of the ping data, as follows:</p><div class="informalexample"><pre class="programlisting">    def send_ping(self, sock,  ID):
        """
        Send ping to the target host
        """
        target_addr  =  socket.gethostbyname(self.target_host)
        my_checksum = 0
        # Create a dummy header with a 0 checksum.
        header = struct.pack("bbHHh", ICMP_ECHO_REQUEST, 0, my_checksum, ID, 1)
        bytes_In_double = struct.calcsize("d")
        data = (192 - bytes_In_double) * "Q"
        data = struct.pack("d", time.time()) + data
        # Get the checksum on the data and the dummy header.
        my_checksum = self.do_checksum(header + data)
        header = struct.pack(
            "bbHHh", ICMP_ECHO_REQUEST, 0, socket.htons(my_checksum), ID, 1
        )
        packet = header + data
        sock.sendto(packet, (target_addr, 1))</pre></div><p>Let us define another method called <code class="literal">ping_once()</code> <a id="id160" class="indexterm"/>that makes a single ping call to the target host. It creates a raw ICMP socket by passing the ICMP protocol to <code class="literal">socket()</code>. The exception handling code takes<a id="id161" class="indexterm"/> care if the script is not run by a superuser or if any other socket error occurs. Let's take a look at the following code:</p><div class="informalexample"><pre class="programlisting">    def ping_once(self):
        """
        Returns the delay (in seconds) or none on timeout.
        """
        icmp = socket.getprotobyname("icmp")
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, icmp)
        except socket.error, (errno, msg):
            if errno == 1:
                # Not superuser, so operation not permitted
                msg +=  "ICMP messages can only be sent from root user processes"
                raise socket.error(msg)
        except Exception, e:
            print "Exception: %s" %(e)
        my_ID = os.getpid() &amp; 0xFFFF
        self.send_ping(sock, my_ID)
        delay = self.receive_pong(sock, my_ID, self.timeout)
        sock.close()
        return delay</pre></div><p>The main executive method of this class is <code class="literal">ping()</code>. It runs a <code class="literal">for</code> loop inside which the <code class="literal">ping_once()</code> method is<a id="id162" class="indexterm"/> called count times and receives a delay in the ping response in seconds. If no delay is returned, that means the ping has failed. Let's take a look at the following code:</p><div class="informalexample"><pre class="programlisting">    def ping(self):
        """
        Run the ping process
        """
        for i in xrange(self.count):
            print "Ping to %s..." % self.target_host,
            try:
                delay  =  self.ping_once()
            except socket.gaierror, e:
                print "Ping failed. (socket error: '%s')" % e[1]
                break
            if delay  ==  None:
               print "Ping failed. (timeout within %ssec.)" % \  \
                      self.timeout
            else:
                delay  =  delay * 1000
                print "Get pong in %0.4fms" % delay

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Python ping')
    parser.add_argument('--target-host', action="store", dest="target_host", required=True)
    given_args = parser.parse_args()  
    target_host = given_args.target_host
    pinger = Pinger(target_host=target_host)
    pinger.ping()</pre></div><p>This script shows the following output. This has been run with the superuser privilege:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo python 3_2_ping_remote_host.py --target-host=www.google.com </strong></span>
<span class="strong"><strong>Ping to www.google.com... Get pong in 7.6921ms </strong></span>
<span class="strong"><strong>Ping to www.google.com... Get pong in 7.1061ms </strong></span>
<span class="strong"><strong>Ping to www.google.com... Get pong in 8.9211ms </strong></span>
<span class="strong"><strong>Ping to www.google.com... Get pong in 7.9899ms </strong></span>
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec52"/>How it works...</h2></div></div></div><p>A <code class="literal">Pinger</code> clas<a id="id163" class="indexterm"/>s has been<a id="id164" class="indexterm"/> constructed to define a few useful methods. <a id="id165" class="indexterm"/>The class initializes with a few user-defined or default inputs, which are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">target_host</code>: This is the target host to ping</li><li class="listitem" style="list-style-type: disc"><code class="literal">count</code>: This is how many times to do the ping</li><li class="listitem" style="list-style-type: disc"><code class="literal">timeout</code>: This is the value that determines when to end an unfinished ping operation</li></ul></div><p>The <code class="literal">send_ping()</code> method gets the DNS hostname of the target host and creates an <code class="literal">ICMP_ECHO_REQUEST</code> packet using the <code class="literal">struct</code> module. It's necessary to check the data integrity of the method using the <code class="literal">do_checksum()</code> method<a id="id166" class="indexterm"/>. It takes the source string and manipulates it to produce a proper checksum. On the receiving end, the <code class="literal">receive_pong()</code> method<a id="id167" class="indexterm"/> waits for a response until the timeout occurs or receives the response. It captures the ICMP response header and then compares the packet ID and calculates the delay in the request and response cycle.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Waiting for a remote network service"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec31"/>Waiting for a remote network service</h1></div></div></div><p>Sometimes, during the <a id="id168" class="indexterm"/>recovery of a network service, it might be useful to run a script to check when the server is online again.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec53"/>How to do it... </h2></div></div></div><p>We can write a client that will wait for a particular network service forever or for a timeout. In this example, by default, we would like to check when a web server is up in localhost. If you specified some other remote host or port, that information will be used instead.</p><p>Listing 3.3 shows waiting for a remote network service, as follows:</p><div class="informalexample"><pre class="programlisting">#!/usr/bin/env python
# Python Network Programming Cookbook -- Chapter – 3
# This program is optimized for Python 2.7.
# It may run on any other version with/without modifications.

import argparse
import socket
import errno
from time import time as now

DEFAULT_TIMEOUT = 120
DEFAULT_SERVER_HOST = 'localhost'
DEFAULT_SERVER_PORT = 80

class NetServiceChecker(object):
    """ Wait for a network service to come online"""
    def __init__(self, host, port, timeout=DEFAULT_TIMEOUT):
        self.host = host
        self.port = port
        self.timeout = timeout
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    
    def end_wait(self):
        self.sock.close()

    def check(self):
        """ Check the service """
        if self.timeout:
            end_time = now() + self.timeout
    
        while True:
            try:
                if self.timeout:
                    next_timeout = end_time - now()
                    if next_timeout &lt; 0:
                        return False
                    else:
                        print "setting socket next timeout %ss"\
                       %round(next_timeout)
                        self.sock.settimeout(next_timeout)
                self.sock.connect((self.host, self.port))
            # handle exceptions
            except socket.timeout, err:
                if self.timeout:
                    return False
            except socket.error, err:
                print "Exception: %s" %err
            else: # if all goes well
                self.end_wait()
                return True

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Wait for Network Service')
    parser.add_argument('--host', action="store", dest="host",  default=DEFAULT_SERVER_HOST)
    parser.add_argument('--port', action="store", dest="port", type=int, default=DEFAULT_SERVER_PORT)
    parser.add_argument('--timeout', action="store", dest="timeout", type=int, default=DEFAULT_TIMEOUT)
    given_args = parser.parse_args() 
    host, port, timeout = given_args.host, given_args.port, given_args.timeout
    service_checker = NetServiceChecker(host, port, timeout=timeout)
    print "Checking for network service %s:%s ..." %(host, port)
    if service_checker.check():
        print "Service is available again!"</pre></div><p>If a web server, such<a id="id169" class="indexterm"/> as Apache, is running on your machine, this script will show the following output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python 3_3_wait_for_remote_service.py </strong></span>
<span class="strong"><strong>Waiting for network service localhost:80 ... </strong></span>
<span class="strong"><strong>setting socket next timeout 120.0s </strong></span>
<span class="strong"><strong>Service is available again!</strong></span>
</pre></div><p>Now, stop the Apache process, run this script, and restart Apache again. The output pattern will be different. On my machine, the following output pattern was found:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Exception: [Errno 103] Software caused connection abort </strong></span>
<span class="strong"><strong>setting socket next timeout 104.189137936 </strong></span>
<span class="strong"><strong>Exception: [Errno 111] Connection refused </strong></span>
<span class="strong"><strong>setting socket next timeout 104.186291933 </strong></span>
<span class="strong"><strong>Exception: [Errno 103] Software caused connection abort </strong></span>
<span class="strong"><strong>setting socket next timeout 104.186164856 </strong></span>
<span class="strong"><strong>Service is available again!</strong></span>
</pre></div><p>The following screenshot shows the waiting for an active Apache web server process:</p><div class="mediaobject"><img src="images/3463OS_03_02.jpg" alt="How to do it..."/></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec54"/>How it works...</h2></div></div></div><p>The preceding script uses the <code class="literal">argparse</code> module to take the user input and process the hostname, port, and timeout, that is how long our script will wait for the desired network service. It launches an<a id="id170" class="indexterm"/> instance of the <code class="literal">NetServiceChecker</code> class<a id="id171" class="indexterm"/> and calls the <code class="literal">check()</code> method<a id="id172" class="indexterm"/>. This method calculates the final end time of waiting and uses the socket's <code class="literal">settimeout()</code> method<a id="id173" class="indexterm"/> to control each round's end time, that is <code class="literal">next_timeout</code>. It then uses the socket's <code class="literal">connect()</code> method to test if the desired network service is available until the socket timeout occurs. This method also catches the socket timeout error and checks the socket timeout against the timeout values given by the user.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Enumerating interfaces on your machine"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec32"/>Enumerating interfaces on your machine</h1></div></div></div><p>If you need to list the network interfaces<a id="id174" class="indexterm"/> present on your machine, it is not very complicated in Python. There are a couple of third-party libraries out there that can do this job in a few lines. However, let's see how this is done using a pure socket call.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec55"/>Getting ready</h2></div></div></div><p>You need to run this recipe on a Linux box. To get the list of available interfaces, you can execute the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ /sbin/ifconfig</strong></span>
</pre></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec56"/>How to do it... </h2></div></div></div><p>Listing 3.4 shows how to list the networking interfaces, as follows:</p><div class="informalexample"><pre class="programlisting">#!/usr/bin/env python
# Python Network Programming Cookbook -- Chapter – 3
# This program is optimized for Python 2.7.
# It may run on any other version with/without modifications.
import sys
import socket
import fcntl
import struct
import array

SIOCGIFCONF = 0x8912 #from C library sockios.h
STUCT_SIZE_32 = 32
STUCT_SIZE_64 = 40
PLATFORM_32_MAX_NUMBER =  2**32
DEFAULT_INTERFACES = 8


def list_interfaces():
    interfaces = []
    max_interfaces = DEFAULT_INTERFACES
    is_64bits = sys.maxsize &gt; PLATFORM_32_MAX_NUMBER
    struct_size = STUCT_SIZE_64 if is_64bits else STUCT_SIZE_32
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) 
    while True:
        bytes = max_interfaces * struct_size
        interface_names = array.array('B', '\0' * bytes)
        sock_info = fcntl.ioctl( 
            sock.fileno(),
            SIOCGIFCONF,
            struct.pack('iL', bytes,interface_names.buffer_info()[0])
        )
        outbytes = struct.unpack('iL', sock_info)[0]
        if outbytes == bytes:
            max_interfaces *= 2  
        else: 
            break
    namestr = interface_names.tostring()
    for i in range(0, outbytes, struct_size):
        interfaces.append((namestr[i:i+16].split('\0', 1)[0]))
    return interfaces

if __name__ == '__main__':
    interfaces = list_interfaces()
    print "This machine has %s network interfaces: %s." %(len(interfaces), interface)</pre></div><p>The preceding script will list the network interfaces, as shown in the following output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python 3_4_list_network_interfaces.py </strong></span>
<span class="strong"><strong>This machine has 2 network interfaces: ['lo', 'eth0'].</strong></span>
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec57"/>How it works...</h2></div></div></div><p>This recipe code uses a low-level socket feature<a id="id175" class="indexterm"/> to find out the interfaces present on the system. The single <code class="literal">list_interfaces()</code>method<a id="id176" class="indexterm"/> creates a socket object and finds the network interface information from manipulating this object. It does so by making a call to the <code class="literal">fnctl</code> module's <code class="literal">ioctl()</code> method<a id="id177" class="indexterm"/>. The <code class="literal">fnctl</code> module interfaces with some Unix routines, for example, <code class="literal">fnctl()</code>. This interface performs an I/O control operation on the underlying file descriptor socket, which is obtained by calling the <code class="literal">fileno()</code> method<a id="id178" class="indexterm"/> of the socket object.</p><p>The additional parameter of the <code class="literal">ioctl()</code> method includes the <code class="literal">SIOCGIFADDR</code> constant defined in the C socket library and a data structure produced by the <code class="literal">struct</code> module's <code class="literal">pack()</code> function<a id="id179" class="indexterm"/>. The memory address specified by a data structure is modified as a result of the <code class="literal">ioctl()</code> call. In this case, the <code class="literal">interface_names</code> variable<a id="id180" class="indexterm"/> holds this information. After unpacking the <code class="literal">sock_info</code> return value of the <code class="literal">ioctl()</code> call, the number of network interfaces is increased twice if the size of the data suggests it. This is done in a <code class="literal">while</code> loop to discover all interfaces if our initial interface count assumption is not correct.</p><p>The names of interfaces are extracted from the string format of the <code class="literal">interface_names</code> variable. It reads specific<a id="id181" class="indexterm"/> fields of that variable and appends the values in the interfaces' list. At the end of the <code class="literal">list_interfaces()</code> function<a id="id182" class="indexterm"/>, this is returned.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Finding the IP address for a specific interface on your machine"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec33"/>Finding the IP address for a specific interface on your machine</h1></div></div></div><p>Finding the IP address of a particular<a id="id183" class="indexterm"/> network interface may be needed<a id="id184" class="indexterm"/> from your Python network application.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec58"/>Getting ready</h2></div></div></div><p>This recipe is prepared exclusively for a Linux box. There are some Python modules specially designed to bring similar functionalities on Windows and Mac platforms. For example, see <a class="ulink" href="http://sourceforge.net/projects/pywin32/">http://sourceforge.net/projects/pywin32/</a> for Windows-specific implementation.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec59"/>How to do it...</h2></div></div></div><p>You can use the <code class="literal">fnctl</code> module to query the IP address on your machine.</p><p>Listing 3.5 shows us how to find the IP address for a specific interface on your machine, as follows:</p><div class="informalexample"><pre class="programlisting">#!/usr/bin/env python
# Python Network Programming Cookbook -- Chapter – 3
# This program is optimized for Python 2.7.
# It may run on any other version with/without modifications.

import argparse
import sys
import socket
import fcntl
import struct
import array

def get_ip_address(ifname):
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    return socket.inet_ntoa(fcntl.ioctl(
        s.fileno(),
        0x8915,  # SIOCGIFADDR
        struct.pack('256s', ifname[:15])
    )[20:24])

if __name__ == '__main__':
    #interfaces =  list_interfaces()
    parser = argparse.ArgumentParser(description='Python networking utils')
    parser.add_argument('--ifname', action="store", dest="ifname", required=True)
    given_args = parser.parse_args() 
    ifname = given_args.ifname    
    print "Interface [%s] --&gt; IP: %s" %(ifname, get_ip_address(ifname)) </pre></div><p>The output of this script is shown in one line, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python 3_5_get_interface_ip_address.py --ifname=eth0 </strong></span>
<span class="strong"><strong>Interface [eth0] --&gt; IP: 10.0.2.15 </strong></span>
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec60"/>How it works...</h2></div></div></div><p>This recipe is similar to the previous one. The preceding script takes a command-line argument: the name of the network interface whose IP address is to be known. The <a id="id185" class="indexterm"/>
<code class="literal">get_ip_address()</code> function<a id="id186" class="indexterm"/> creates a socket object and calls the <code class="literal">fnctl.ioctl()</code> function<a id="id187" class="indexterm"/> to query on that object about IP information. Note<a id="id188" class="indexterm"/> that the <code class="literal">socket.inet_ntoa()</code> function<a id="id189" class="indexterm"/> converts the binary data to a human-readable string in a dotted format as we are familiar with it.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Finding whether an interface is up on your machine"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec34"/>Finding whether an interface is up on your machine</h1></div></div></div><p>If you have multiple network interfaces<a id="id190" class="indexterm"/> on your machine, before doing any work on a particular interface, you would like to know the status of that network interface, for example, if the interface is actually up. This makes sure that you route your command to active interfaces.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec61"/>Getting ready</h2></div></div></div><p>This recipe is written for a Linux machine. So, this script will not run on a Windows or Mac host. In this recipe, we use <code class="literal">nmap</code>, a famous network scanning tool. You can find more about <code class="literal">nmap</code> from its website <a class="ulink" href="http://nmap.org/">http://nmap.org/</a>.</p><p>You also need the <code class="literal">python-nmap</code> module to run this recipe. This can be installed by <code class="literal">pip</code>, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ pip install python-nmap</strong></span>
</pre></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec62"/>How to do it...</h2></div></div></div><p>We can create a socket object and get the IP address of that interface. Then, we can use any of the scanning techniques to probe the interface status.</p><p>Listing 3.6 shows the<a id="id191" class="indexterm"/> detect network interface status, as follows:</p><div class="informalexample"><pre class="programlisting">#!/usr/bin/env python
# Python Network Programming Cookbook -- Chapter – 3
# This program is optimized for Python 2.7.
# It may run on any other version with/without modifications.

import argparse
import socket
import struct
import fcntl
import nmap
SAMPLE_PORTS = '21-23'

def get_interface_status(ifname):
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    ip_address = socket.inet_ntoa(fcntl.ioctl(
        sock.fileno(),
        0x8915, #SIOCGIFADDR, C socket library sockios.h
        struct.pack('256s', ifname[:15])
    )[20:24])

    nm = nmap.PortScanner()         
    nm.scan(ip_address, SAMPLE_PORTS)      
    return nm[ip_address].state()          

if  __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Python networking utils')
    parser.add_argument('--ifname', action="store", dest="ifname", required=True)
    given_args = parser.parse_args() 
    ifname = given_args.ifname    
    print "Interface [%s] is: %s" %(ifname, get_interface_status(ifname))      </pre></div><p>If you run this script to inquire the status of the <code class="literal">eth0</code> status, it will show something similar to the following output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python 3_6_find_network_interface_status.py --ifname=eth0 </strong></span>
<span class="strong"><strong>Interface [eth0] is: up</strong></span>
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec63"/>How it works...</h2></div></div></div><p>The recipe takes the interface's name from the command line and passes it to the <code class="literal">get_interface_status()</code> function<a id="id192" class="indexterm"/>. This function finds the IP address of that interface by manipulating a UDP socket object.</p><p>This recipe needs the <code class="literal">nmap</code> third-party module. We can install that PyPI using the <code class="literal">pip</code> install command. <a id="id193" class="indexterm"/>The <code class="literal">nmap</code> scanning instance, <code class="literal">nm</code>, has been created by calling <code class="literal">PortScanner()</code>. An initial scan to a local IP address gives us the status of the associated network interface.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Detecting inactive machines on your network"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec35"/>Detecting inactive machines on your network</h1></div></div></div><p>If you have been given a list of IP addresses of a few machines on your network and you are asked to write a script to find out<a id="id194" class="indexterm"/> which hosts are inactive periodically, you would want to create a network scanner type program without installing anything on the target host computers.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec64"/>Getting ready</h2></div></div></div><p>This recipe requires installing the Scapy library (&gt; 2.2), which can be obtained at <a class="ulink" href="http://www.secdev.org/projects/scapy/files/scapy-latest.zip">http://www.secdev.org/projects/scapy/files/scapy-latest.zip</a>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec65"/>How to do it...</h2></div></div></div><p>We can use Scapy, a mature network-analyzing, third-party library, to launch an ICMP scan. Since we would like to do it periodically, we need Python's <code class="literal">sched</code> module to schedule the scanning tasks.</p><p>Listing 3.7 shows us how to detect inactive machines, as follows:</p><div class="informalexample"><pre class="programlisting">#!/usr/bin/env python
# Python Network Programming Cookbook -- Chapter – 3
# This program is optimized for Python 2.7.
# It may run on any other version with/without modifications.
# This recipe requires scapy-2.2.0 or higher 

import argparse
import time
import sched
from scapy.all import sr, srp, IP, UDP, ICMP, TCP, ARP, Ether
RUN_FREQUENCY = 10
scheduler = sched.scheduler(time.time, time.sleep)

def detect_inactive_hosts(scan_hosts):
    """ 
    Scans the network to find scan_hosts are live or dead
    scan_hosts can be like 10.0.2.2-4 to cover range. 
    See Scapy docs for specifying targets.   
    """
    global scheduler
    scheduler.enter(RUN_FREQUENCY, 1, detect_inactive_hosts, (scan_hosts, ))
    inactive_hosts = []
    try:
        ans, unans = sr(IP(dst=scan_hosts)/ICMP(),retry=0, timeout=1)
        ans.summary(lambda(s,r) : r.sprintf("%IP.src% is alive"))
        for inactive in unans:
            print "%s is inactive" %inactive.dst
            inactive_hosts.append(inactive.dst)
        print "Total %d hosts are inactive" %(len(inactive_hosts))
    except KeyboardInterrupt:
        exit(0)
if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Python networking utils')
    parser.add_argument('--scan-hosts', action="store", dest="scan_hosts", required=True)
    given_args = parser.parse_args() 
    scan_hosts = given_args.scan_hosts    
    scheduler.enter(1, 1, detect_inactive_hosts, (scan_hosts, ))
    scheduler.run()</pre></div><p>The output of this<a id="id195" class="indexterm"/> script will be something like the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo python 3_7_detect_inactive_machines.py --scan-hosts=10.0.2.2-4</strong></span>
<span class="strong"><strong>Begin emission:</strong></span>
<span class="strong"><strong>.*...Finished to send 3 packets.</strong></span>
<span class="strong"><strong>.</strong></span>
<span class="strong"><strong>Received 6 packets, got 1 answers, remaining 2 packets</strong></span>
<span class="strong"><strong>10.0.2.2 is alive</strong></span>
<span class="strong"><strong>10.0.2.4 is inactive</strong></span>
<span class="strong"><strong>10.0.2.3 is inactive</strong></span>
<span class="strong"><strong>Total 2 hosts are inactive</strong></span>
<span class="strong"><strong>Begin emission:</strong></span>
<span class="strong"><strong>*.Finished to send 3 packets.</strong></span>
<span class="strong"><strong>Received 3 packets, got 1 answers, remaining 2 packets</strong></span>
<span class="strong"><strong>10.0.2.2 is alive</strong></span>
<span class="strong"><strong>10.0.2.4 is inactive</strong></span>
<span class="strong"><strong>10.0.2.3 is inactive</strong></span>
<span class="strong"><strong>Total 2 hosts are inactive</strong></span>
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec66"/>How it works...</h2></div></div></div><p>The preceding script first takes a list of network hosts, <code class="literal">scan_hosts</code>, from the command line. It then creates a schedule to launch the <code class="literal">detect_inactive_hosts()</code> function<a id="id196" class="indexterm"/> after a one-second delay. The target function takes the <code class="literal">scan_hosts</code> argument and calls Scapy's <code class="literal">sr()</code> function.</p><p>This function schedules itself<a id="id197" class="indexterm"/> to rerun after every 10 seconds by calling the <code class="literal">schedule.enter()</code> function<a id="id198" class="indexterm"/> once again. This way, we run this scanning task periodically.</p><p>Scapy's <code class="literal">sr()</code> scanning function takes an IP, protocol and some scan-control information. In this case, the <code class="literal">IP()</code> method passes <code class="literal">scan_hosts</code> as the destination hosts to scan, and the protocol is specified as ICMP. This can also be TCP or UDP. We do not specify a retry and one-second timeout to run this script faster. However, you can experiment with the options that suit you.</p><p>The scanning <code class="literal">sr()</code>function<a id="id199" class="indexterm"/> returns the hosts that answer and those that don't as a tuple. We check the hosts that don't answer, build a list, and print that information.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Performing a basic IPC using connected sockets (socketpair)"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec36"/>Performing a basic IPC using connected sockets (socketpair)</h1></div></div></div><p>Sometimes, two scripts need to <a id="id200" class="indexterm"/>communicate some<a id="id201" class="indexterm"/> information between themselves via two processes. In Unix/Linux, there's a concept of connected socket, of <code class="literal">socketpair</code>. We can experiment with this here.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec67"/>Getting ready</h2></div></div></div><p>This recipe is designed for a Unix/Linux host. Windows/Mac is not suitable for running this one.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec68"/>How to do it...</h2></div></div></div><p>We use a <code class="literal">test_socketpair()</code> function<a id="id202" class="indexterm"/> to wrap a few lines that test the socket's <code class="literal">socketpair()</code> function.</p><p>List 3.8 shows an <a id="id203" class="indexterm"/>example of <code class="literal">socketpair</code>, as<a id="id204" class="indexterm"/> follows:</p><div class="informalexample"><pre class="programlisting">#!/usr/bin/env python
# Python Network Programming Cookbook -- Chapter – 3
# This program is optimized for Python 2.7.
# It may run on any other version with/without modifications.

import socket
import os

BUFSIZE = 1024

def test_socketpair():
    """ Test Unix socketpair"""
    parent, child = socket.socketpair()
    
    pid = os.fork()
    try:
        if pid:
            print "@Parent, sending message..."
            child.close()
            parent.sendall("Hello from parent!")
            response = parent.recv(BUFSIZE)
            print "Response from child:", response
            parent.close()
        
        else:
            print "@Child, waiting for message from parent"
            parent.close()
            message = child.recv(BUFSIZE)
            print "Message from parent:", message
            child.sendall("Hello from child!!")
            child.close()
    except Exception, err:
        print "Error: %s" %err

if __name__ == '__main__':
    test_socketpair()</pre></div><p>The output from the preceding script is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python 3_8_ipc_using_socketpairs.py</strong></span>
<span class="strong"><strong>@Parent, sending message... </strong></span>
<span class="strong"><strong>@Child, waiting for message from parent </strong></span>
<span class="strong"><strong>Message from parent: Hello from parent! </strong></span>
<span class="strong"><strong>Response from child: Hello from child!! </strong></span>
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec69"/>How it works...</h2></div></div></div><p>The <code class="literal">socket.socketpair()</code> function<a id="id205" class="indexterm"/> simply returns two connected socket objects. In our case, we can say that one is a parent and another is a child. We fork another process via a <code class="literal">os.fork()</code> call. This returns the process ID of the parent. In each process, the other process' socket is closed first<a id="id206" class="indexterm"/> and then a message is <a id="id207" class="indexterm"/>exchanged via a <code class="literal">sendall()</code> method<a id="id208" class="indexterm"/> call on the process's socket. The try-except block prints any error in case of any kind of exception.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Performing IPC using Unix domain sockets"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec37"/>Performing IPC using Unix domain sockets</h1></div></div></div><p><span class="strong"><strong>Unix domain sockets</strong></span> (<span class="strong"><strong>UDS</strong></span>) are sometimes<a id="id209" class="indexterm"/> used as a convenient way to communicate between two processes. As in Unix, everything<a id="id210" class="indexterm"/> is conceptually a file. If you need an example of such an IPC action, this can be useful.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec70"/>How to do it...</h2></div></div></div><p>We launch a UDS server that binds to a filesystem path, and a UDS client uses the same path to communicate with the server.</p><p>Listing 3.9a shows a Unix domain socket server, as follows:</p><div class="informalexample"><pre class="programlisting">#!/usr/bin/env python
# Python Network Programming Cookbook -- Chapter – 3
# This program is optimized for Python 2.7.
# It may run on any other version with/without modifications.

import socket
import os
import time

SERVER_PATH = "/tmp/python_unix_socket_server"
 
def run_unix_domain_socket_server():
    if os.path.exists(SERVER_PATH):
        os.remove( SERVER_PATH )
     
    print "starting unix domain socket server."
    server = socket.socket( socket.AF_UNIX, socket.SOCK_DGRAM )
    server.bind(SERVER_PATH)
     
    print "Listening on path: %s" %SERVER_PATH
    while True:
        datagram = server.recv( 1024 )
        if not datagram:
            break
        else:
            print "-" * 20
            print datagram
        if "DONE" == datagram:
            break
    print "-" * 20
    print "Server is shutting down now..."
    server.close()
    os.remove(SERVER_PATH)
    print "Server shutdown and path removed."

if __name__ == '__main__':
    run_unix_domain_socket_server()</pre></div><p>Listing 3.9b shows a<a id="id211" class="indexterm"/> UDS client,<a id="id212" class="indexterm"/> as follows:</p><div class="informalexample"><pre class="programlisting">#!/usr/bin/env python
# Python Network Programming Cookbook -- Chapter - 3
# This program is optimized for Python 2.7.
# It may run on any other version with/without modifications.

import socket
import sys

SERVER_PATH = "/tmp/python_unix_socket_server"

def run_unix_domain_socket_client():
    """ Run "a Unix domain socket client """
    sock = socket.socket(socket.AF_UNIX, socket.SOCK_DGRAM)
    
    # Connect the socket to the path where the server is listening
    server_address = SERVER_PATH 
    print "connecting to %s" % server_address
    try:
        sock.connect(server_address)
    except socket.error, msg:
        print &gt;&gt;sys.stderr, msg
        sys.exit(1)
    
    try:
        message = "This is the message.  This will be echoed back!"
        print  "Sending [%s]" %message
        sock.sendall(message)
        amount_received = 0
        amount_expected = len(message)
        
        while amount_received &lt; amount_expected:
            data = sock.recv(16)
            amount_received += len(data)
            print &gt;&gt;sys.stderr, "Received [%s]" % data
    
    finally:
        print "Closing client"
        sock.close()

if __name__ == '__main__':
    run_unix_domain_socket_client()</pre></div><p>The server output is as<a id="id213" class="indexterm"/> follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python 3_9a_unix_domain_socket_server.py </strong></span>
<span class="strong"><strong>starting unix domain socket server. </strong></span>
<span class="strong"><strong>Listening on path: /tmp/python_unix_socket_server</strong></span>
<span class="strong"><strong>-------------------- </strong></span>
<span class="strong"><strong>This is the message.  This will be echoed back!</strong></span>
</pre></div><p>The client <a id="id214" class="indexterm"/>output is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python 3_9b_unix_domain_socket_client.py </strong></span>
<span class="strong"><strong>connecting to /tmp/python_unix_socket_server </strong></span>
<span class="strong"><strong>Sending [This is the message.  This will be echoed back!]</strong></span>
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec71"/>How it works...</h2></div></div></div><p>A common path is defined for a UDS client/server to interact. Both the client and server use the same path to connect and listen to.</p><p>In a server code, we remove the path if it exists from the previous run of this script. It then creates a Unix datagram socket and binds it to the specified path. It then listens for incoming connections. In the data<a id="id215" class="indexterm"/> processing loop, it uses the <code class="literal">recv()</code> method<a id="id216" class="indexterm"/> to get data from the client and prints that information on screen.</p><p>The client-side code simply opens a Unix datagram socket and connects to the shared server address. It sends a message to the server using <code class="literal">sendall()</code>. It then waits for the message to be echoed <a id="id217" class="indexterm"/>back to itself and prints that message.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Finding out if your Python supports IPv6 sockets"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec38"/>Finding out if your Python supports IPv6 sockets</h1></div></div></div><p>IP version 6 or IPv6 is increasingly adopted by the industry to build newer applications. In case you would like to <a id="id218" class="indexterm"/>write an IPv6 application, the first thing you'd like to know is if your machine supports IPv6. This can be done from the Linux/Unix command line, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cat /proc/net/if_inet6 </strong></span>
<span class="strong"><strong>00000000000000000000000000000001 01 80 10 80       lo </strong></span>
<span class="strong"><strong>fe800000000000000a0027fffe950d1a 02 40 20 80     eth0 </strong></span>
</pre></div><p>From your Python script, you can also check if the IPv6 support is present on your machine, and Python is installed with that support.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec72"/>Getting ready</h2></div></div></div><p>For this recipe, use <code class="literal">pip</code> to install a Python third-party library, <code class="literal">netifaces</code>, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ pip install   netifaces</strong></span>
</pre></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec73"/>How to do it...</h2></div></div></div><p>We can use a third-party library, <code class="literal">netifaces</code>, to find out if there is IPv6 support on your machine. We can call the <code class="literal">interfaces()</code> function from this library to list all interfaces present in the system.</p><p>Listing 3.10 shows the Python IPv6 support checker, as follows:</p><div class="informalexample"><pre class="programlisting">#!/usr/bin/env python
# Python Network Programming Cookbook -- Chapter – 3
# This program is optimized for Python 2.7.
# It may run on any other version with/without modifications.
# This program depends on Python module netifaces =&gt; 0.8
import socket
import argparse
import netifaces as ni

def inspect_ipv6_support():
    """ Find the ipv6 address"""
    print "IPV6 support built into Python: %s" %socket.has_ipv6
    ipv6_addr = {}
    for interface in ni.interfaces():
        all_addresses = ni.ifaddresses(interface)
        print "Interface %s:" %interface
        for family,addrs in all_addresses.iteritems():
            fam_name = ni.address_families[family]
            print '  Address family: %s' % fam_name
            for addr in addrs:
                if fam_name == 'AF_INET6':
                    ipv6_addr[interface] = addr['addr']
                print     '    Address  : %s' % addr['addr']
                nmask = addr.get('netmask', None)
                if nmask:
                    print '    Netmask  : %s' % nmask
                bcast = addr.get('broadcast', None)
                if bcast:
                    print '    Broadcast: %s' % bcast
    if ipv6_addr:
        print "Found IPv6 address: %s" %ipv6_addr
    else:
        print "No IPv6 interface found!"  

if __name__ == '__main__':
    inspect_ipv6_support()</pre></div><p>The output <a id="id219" class="indexterm"/>from this script will be as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python 3_10_check_ipv6_support.py </strong></span>
<span class="strong"><strong>IPV6 support built into Python: True </strong></span>
<span class="strong"><strong>Interface lo: </strong></span>
<span class="strong"><strong>  Address family: AF_PACKET </strong></span>
<span class="strong"><strong>    Address  : 00:00:00:00:00:00 </strong></span>
<span class="strong"><strong>  Address family: AF_INET </strong></span>
<span class="strong"><strong>    Address  : 127.0.0.1 </strong></span>
<span class="strong"><strong>    Netmask  : 255.0.0.0 </strong></span>
<span class="strong"><strong>  Address family: AF_INET6 </strong></span>
<span class="strong"><strong>    Address  : ::1 </strong></span>
<span class="strong"><strong>    Netmask  : ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff </strong></span>
<span class="strong"><strong>Interface eth0: </strong></span>
<span class="strong"><strong>  Address family: AF_PACKET </strong></span>
<span class="strong"><strong>    Address  : 08:00:27:95:0d:1a </strong></span>
<span class="strong"><strong>    Broadcast: ff:ff:ff:ff:ff:ff </strong></span>
<span class="strong"><strong>  Address family: AF_INET </strong></span>
<span class="strong"><strong>    Address  : 10.0.2.15 </strong></span>
<span class="strong"><strong>    Netmask  : 255.255.255.0 </strong></span>
<span class="strong"><strong>    Broadcast: 10.0.2.255 </strong></span>
<span class="strong"><strong>  Address family: AF_INET6 </strong></span>
<span class="strong"><strong>    Address  : fe80::a00:27ff:fe95:d1a</strong></span>
<span class="strong"><strong>    Netmask  : ffff:ffff:ffff:ffff:: </strong></span>
<span class="strong"><strong>Found IPv6 address: {'lo': '::1', 'eth0': 'fe80::a00:27ff:fe95:d1a'}</strong></span>
</pre></div><p>The following screenshot shows the interaction between the IPv6 client and server:</p><div class="mediaobject"><img src="images/3463OS_03_03.jpg" alt="How to do it..."/></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec74"/>How it works...</h2></div></div></div><p>The IPv6<a id="id220" class="indexterm"/> support checker function, <code class="literal">inspect_ipv6_support()</code>,<a id="id221" class="indexterm"/> first checks if <a id="id222" class="indexterm"/>Python is built with IPv6 using <code class="literal">socket.has_ipv6</code>. Next, we call the <code class="literal">interfaces()</code> function from the <code class="literal">netifaces</code> module. This gives us the list of all interfaces. If we call the <code class="literal">ifaddresses()</code> method<a id="id223" class="indexterm"/> by passing a network interface to it, we can get all the IP addresses of this interface. We then extract various IP-related information, such as protocol family, address, netmask, and broadcast address. Then, the address of a network interface has been added to the <code class="literal">IPv6_address</code> dictionary if its protocol family matches <code class="literal">AF_INET6</code>.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Extracting an IPv6 prefix from an IPv6 address"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec39"/>Extracting an IPv6 prefix from an IPv6 address</h1></div></div></div><p>In your IPv6 application, you<a id="id224" class="indexterm"/> need to dig out the IPv6 address for getting the prefix information.<a id="id225" class="indexterm"/> Note that the upper 64-bits of an IPv6 address are represented from a global routing prefix plus a subnet ID, as defined in RFC 3513. A general prefix (for example, /48) holds a short prefix based on which a number of longer, more specific prefixes (for example, /64) can be defined. A Python script can be very helpful in generating the prefix information.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec75"/>How to do it...</h2></div></div></div><p>We can use the <code class="literal">netifaces</code> and <code class="literal">netaddr</code> third-party libraries to find out the IPv6 prefix information for a given IPv6 address, as follows:</p><div class="informalexample"><pre class="programlisting">#!/usr/bin/env python
# Python Network Programming Cookbook -- Chapter – 3
# This program is optimized for Python 2.7.
# It may run on any other version with/without modifications.

import socket
import netifaces as ni
import netaddr as na

def extract_ipv6_info():
    """ Extracts IPv6 information"""
    print "IPV6 support built into Python: %s" %socket.has_ipv6
    for interface in ni.interfaces():
        all_addresses = ni.ifaddresses(interface)
        print "Interface %s:" %interface
        for family,addrs in all_addresses.iteritems():
            fam_name = ni.address_families[family]
            #print '  Address family: %s' % fam_name
            for addr in addrs:
                if fam_name == 'AF_INET6':
                    addr = addr['addr']
                    has_eth_string = addr.split("%eth")
                    if has_eth_string:
       addr = addr.split("%eth")[0]
       print "    IP Address: %s" %na.IPNetwork(addr)
       print "    IP Version: %s" %na.IPNetwork(addr).version
       print "    IP Prefix length: %s" %na.IPNetwork(addr).prefixlen
       print "    Network: %s" %na.IPNetwork(addr).network
       print "    Broadcast: %s" %na.IPNetwork(addr).broadcast
if __name__ == '__main__':
    extract_ipv6_info()</pre></div><p>The output from this script is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python 3_11_extract_ipv6_prefix.py </strong></span>
<span class="strong"><strong>IPV6 support built into Python: True </strong></span>
<span class="strong"><strong>Interface lo: </strong></span>
<span class="strong"><strong>    IP Address: ::1/128 </strong></span>
<span class="strong"><strong>    IP Version: 6 </strong></span>
<span class="strong"><strong>    IP Prefix length: 128 </strong></span>
<span class="strong"><strong>    Network: ::1 </strong></span>
<span class="strong"><strong>    Broadcast: ::1 </strong></span>
<span class="strong"><strong>Interface eth0: </strong></span>
<span class="strong"><strong>    IP Address: fe80::a00:27ff:fe95:d1a/128 </strong></span>
<span class="strong"><strong>    IP Version: 6 </strong></span>
<span class="strong"><strong>    IP Prefix length: 128 </strong></span>
<span class="strong"><strong>    Network: fe80::a00:27ff:fe95:d1a </strong></span>
<span class="strong"><strong>    Broadcast: fe80::a00:27ff:fe95:d1a </strong></span>
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec76"/>How it works...</h2></div></div></div><p>Python's <code class="literal">netifaces</code> module gives<a id="id226" class="indexterm"/> us the network interface IPv6 address.<a id="id227" class="indexterm"/> It uses the <code class="literal">interfaces()</code> and <code class="literal">ifaddresses()</code> functions for doing this. The <code class="literal">netaddr</code> module is particularly helpful to manipulate a network address. It has a <code class="literal">IPNetwork()</code> class<a id="id228" class="indexterm"/> that provides us with an address, IPv4 or IPv6, and computes the prefix, network, and broadcast addresses. Here, we find this information class instance's version, prefixlen, and network and broadcast attributes.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Writing an IPv6 echo client/server"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec40"/>Writing an IPv6 echo client/server</h1></div></div></div><p>You need to write an<a id="id229" class="indexterm"/> IPv6 compliant server or client and wonder what could be the differences between an IPv6 compliant server or client and its IPv4 counterpart.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec77"/>How to do it...</h2></div></div></div><p>We use the same approach as writing an echo client/server using IPv6. The only major difference is how the socket is<a id="id230" class="indexterm"/> created using IPv6 information.</p><p>Listing 12a shows an IPv6 echo server, as follows:</p><div class="informalexample"><pre class="programlisting">#!/usr/bin/env python
# Python Network Programming Cookbook -- Chapter - 3
# This program is optimized for Python 2.7.
# It may run on any other version with/without modifications.

import argparse 
import socket
import sys

HOST = 'localhost'

def echo_server(port, host=HOST):
    """Echo server using IPv6 """
    for res in socket.getaddrinfo(host, port, socket.AF_UNSPEC, 				socket.SOCK_STREAM, 0, socket.AI_PASSIVE):
        af, socktype, proto, canonname, sa = res
        try:
            sock = socket.socket(af, socktype, proto)
        except socket.error, err:
            print "Error: %s" %err
        
        try:
            sock.bind(sa)
            sock.listen(1)
            print "Server listening on %s:%s" %(host, port)
        except socket.error, msg:
            sock.close()
            continue
        break
        sys.exit(1)
    conn, addr = sock.accept()
    print 'Connected to', addr
    while True:
        data = conn.recv(1024)
        print "Received data from the client: [%s]" %data
        if not data: break
        conn.send(data)
        print "Sent data echoed back to the client: [%s]" %data
    conn.close()

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='IPv6 Socket Server Example')
    parser.add_argument('--port', action="store", dest="port", type=int, required=True)
    given_args = parser.parse_args() 
    port = given_args.port
    echo_server(port)</pre></div><p>Listing 12b shows<a id="id231" class="indexterm"/> an IPv6 echo client, as follows:</p><div class="informalexample"><pre class="programlisting">#!/usr/bin/env python
# Python Network Programming Cookbook -- Chapter - 3
# This program is optimized for Python 2.7.

# It may run on any other version with/without modifications.

import argparse
import socket
import sys

HOST = 'localhost'
BUFSIZE = 1024

def ipv6_echo_client(port, host=HOST):
    for res in socket.getaddrinfo(host, port, socket.AF_UNSPEC, socket.SOCK_STREAM):
        af, socktype, proto, canonname, sa = res
        try:
            sock = socket.socket(af, socktype, proto)
        except socket.error, err:
            print "Error:%s" %err
        try:
            sock.connect(sa)
        except socket.error, msg:
            sock.close()
            continue
    if sock is None:
        print 'Failed to open socket!'
        sys.exit(1)
    msg = "Hello from ipv6 client"
    print "Send data to server: %s" %msg
    sock.send(msg)
    while True:
        data = sock.recv(BUFSIZE)
        print 'Received from server', repr(data)
        if not data: 
            break
    sock.close()
if __name__ == '__main__': 
    parser = argparse.ArgumentParser(description='IPv6 socket client example')
    parser.add_argument('--port', action="store", dest="port", type=int, required=True)
    given_args = parser.parse_args() 
    port = given_args.port
    ipv6_echo_client(port)</pre></div><p>The server <a id="id232" class="indexterm"/>output is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python 3_12a_ipv6_echo_server.py --port=8800 </strong></span>
<span class="strong"><strong>Server lisenting on localhost:8800 </strong></span>
<span class="strong"><strong>Connected to ('127.0.0.1', 35034) </strong></span>
<span class="strong"><strong>Received data from the client: [Hello from ipv6 client] </strong></span>
<span class="strong"><strong>Sent data echoed back to the client: [Hello from ipv6 client] </strong></span>
</pre></div><p>The client output is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python 3_12b_ipv6_echo_client.py --port=8800 </strong></span>
<span class="strong"><strong>Send data to server: Hello from ipv6 client </strong></span>
<span class="strong"><strong>Received from server 'Hello from ipv6 client' </strong></span>
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec78"/>How it works...</h2></div></div></div><p>The IPv6 echo server first determines its IPv6 information by calling <code class="literal">socket.getaddrinfo()</code>. Notice that we passed the <code class="literal">AF_UNSPEC</code> protocol for creating a TCP socket. The resulting information is a tuple of five values. We use three of them, address family, socket type, and protocol, to create a server socket. Then, this socket is bound with the socket address from the previous tuple. It then listens to the incoming connections and accepts them. After a connection is made, it receives data from the client and echoes it back.</p><p>On the client-side code, we create an IPv6-compliant client socket instance and send the data using the <code class="literal">send()</code> method of that instance. When the data is echoed back, the <code class="literal">recv()</code> method is used to get it back.</p></div></div></div>
</body></html>