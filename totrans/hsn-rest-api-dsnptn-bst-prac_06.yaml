- en: RESTful Services API Testing and Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any software that claims to be enterprise-ready must have gone through rigorous
    testing cycles, be quality assurance certified, and have met several quality measures
    so that it gets used on production servers. The security of a software application
    is another critical aspect that determines whether or not it will be used on production
    servers.
  prefs: []
  type: TYPE_NORMAL
- en: To equip readers with an understanding of different aspects of production and
    enterprise-ready RESTful APIs, this chapter will discuss various aspects of those
    quality and security measures.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter''s intention is to take readers on an API testing journey. These
    are the milestones or topics we will cover as we go along:'
  prefs: []
  type: TYPE_NORMAL
- en: Types of API tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Challenges in API testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security in API testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition, we will give you a glimpse of various API testing tools, API security
    tools, and frameworks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Midway through the API testing journey, readers will be taken on a detour to
    be introduced to some security issues and API vulnerabilities and learn how to
    expose them as part of API testing.
  prefs: []
  type: TYPE_NORMAL
- en: An overview of software testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any product, be it simple safety pins or majestic airplanes, needs to go through
    a process to ensure that it solves the purpose of its creation, and so does software,
    too. Software testing is a process to confirm the accuracy and quality of software
    through the verification and validation of its purpose, end-to-end.
  prefs: []
  type: TYPE_NORMAL
- en: So, the primary focus of any software product or application is verification
    (checks for consistency and alignment according to the documented requirements)
    and validation (checks the accuracy of the system and validates the end user's
    needs versus the actual outcome).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s list a few essential outcomes of software testing and move on to focus
    more on API testing in the upcoming sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Assert and ensure that there are no differences between the realities and the
    expectations of the requirements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assert and ensure software product continuity and availability, regardless of
    the amount of end users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Foresee and uncover concealed problems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assert and ensure that offerings function seamlessly with anticipated end user
    platforms, browsers, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RESTful APIs and testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As this book deals with RESTful APIs, this chapter is intended to take readers
    through a few essential best practices and API testing principles, along with
    a couple of testing frameworks. With integration tests (both manual and automated),
    we can accomplish most critical API testing strategies for distributed applications
    and help those applications to be production-ready, deployable, and part of CI/CD,
    as well as to assert their scalability and stability for every release.
  prefs: []
  type: TYPE_NORMAL
- en: The following section introduces the basics of API testing, API testing approaches,
    their types, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Basics of API testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A software application product, that we discussed in an earlier section, has
    various software layers such, as the **user interface** (**UI**), the business
    logic layer, middleware, and a database. **API testing** and certification primarily
    focuses on data integration tests on the **Business layer**. **API testing** is
    software testing that involves direct **API testing**, unlike other generic tests,
    which primarily involve the UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4aee86d4-d52a-4cde-bbf1-4aa5cb2e33dd.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding diagram depicts the typical layers of software, with **API testing**
    on the **Business layer** and the functional or UI testing on the **Presentation
    layer**.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding API testing approaches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Agreeing on an approach for API testing when beginning API development is an
    essential API strategy. Let''s look at a few principles of API testing:'
  prefs: []
  type: TYPE_NORMAL
- en: Clear definition of the scope and a good understanding of the functionality
    of the API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common testing methodologies such as boundary analysis and equivalence classes
    are part of API test cases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plan, define, and be ready with input parameters, zero, and sample data for
    the API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Determine and compare expected and actual results, and ensure that there are
    no differences
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API testing types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will review the various categories of API testing and move
    on to best practices as well.
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Tests that involves the validation of individual operations are unit tests.
    In our investor services API examples in [Chapter 4](c44b2a11-65db-459f-a799-1692dd3930e8.xhtml),
    *Advanced RESTful API Patterns*, we covered numerous unit test cases, and the
    following is one of the sample code snippets of a specific unit test case that
    validates getting all the investors from the API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: API validation tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All software needs quick evaluation and to assert its purpose of creation. The
    validation tests need to be run for every function that is developed, at the end
    of the development process. Unlike unit tests, which focus on particular pieces
    or functions of the API, validation tests are a higher-level consideration, answering
    a set of questions so that the development can move on to the next phase.
  prefs: []
  type: TYPE_NORMAL
- en: 'A set of questions for validation tests could be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A product-specific question, such as, is it the necessary function that is asked
    for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A behavioral question, such as, is the developed function doing what is intended?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An efficiency-related question, such as, is the intended function using the
    necessary code, in an independent and optimized manner?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All of these questions, in essence, serve to validate the API in line with the
    agreed acceptance criteria and also to ensure its adherence to standards regarding
    the delivery of expected end goals and meeting user needs and requirements flawlessly.
  prefs: []
  type: TYPE_NORMAL
- en: Functional tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Tests that involve specific functions of the APIs and their code base are functional
    tests. Validating the count of active users through the API, regression tests
    and test case execution come under functional tests. We saw many examples of functional
    tests executed with the Postman tool earlier, in [Chapter 3](bdb7c23e-8c80-4a89-af31-e40d1b4c1d36.xhtml),
    *Essential RESTful API Patterns*, and [Chapter 4](c44b2a11-65db-459f-a799-1692dd3930e8.xhtml),
    *Advanced RESTful API Patterns*. The following screenshot may refresh your memory
    of one such functional testing example of investor service validation for user
    authentication:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a465ead7-212a-4aea-91bb-0de24776e251.png)'
  prefs: []
  type: TYPE_IMG
- en: UI or end-to-end tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tests that involve and assert end-to-end scenarios, including GUI functions
    and API functions, which in most of the cases, validate every transaction of an
    application, are grouped under end-to-end tests.
  prefs: []
  type: TYPE_NORMAL
- en: Load testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we know, an increase in the number of end users should not affect the performance
    of the functions of an application. Load testing will uncover such issues and
    also validate the performance of an API in normal conditions too.
  prefs: []
  type: TYPE_NORMAL
- en: Runtime error detection tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tests that help to monitor the application and detect problems such as race
    conditions, exceptions, and resource leaks belong in the runtime error tests category.
    The following points capture a brief about those factors.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tests for various implementation errors, handler failures, and other inherent
    concerns inside the API code base and ensures it does not have any holes that
    would lead to application insecurity.
  prefs: []
  type: TYPE_NORMAL
- en: Execution errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Valid requests to the API return responses and asserting them for expected
    valid responses is common, however, asserting invalid requests for expected failures
    is also essential as part of an API testing strategy, and those tests come under
    execution errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bbccd840-8914-46c3-84a3-dd1ff4296c6a.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot depicts the [Chapter 3](bdb7c23e-8c80-4a89-af31-e40d1b4c1d36.xhtml), *Essential
    RESTful API Patterns*, example of expecting an error when the user gives an ID
    that is not present on the system.
  prefs: []
  type: TYPE_NORMAL
- en: Resource leaks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Negative tests to validate the underlying API resource malfunctions by submitting
    invalid requests to the API. The resources, in this case, are memory, data, insecurities,
    timeout operations, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Error detection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Detect network communication failures. Authentication failures from giving
    the wrong credentials is an example error detection scenario. These are tests
    ensure the errors are captured and then resolved as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/43e9cab8-a9ad-409f-ab6a-49702c77fd31.png)'
  prefs: []
  type: TYPE_IMG
- en: We saw an authentication error in our [Chapter 4](c44b2a11-65db-459f-a799-1692dd3930e8.xhtml),
    *Advanced RESTful API Patterns*, investor-service example, and the previous screenshot
    depicts this, as the code returns `401` (as it should); this is an example of
    an error detection test.
  prefs: []
  type: TYPE_NORMAL
- en: REST API security vulnerabilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: APIs are popular and widely used because they are simple, schematic, fast to
    develop, and quick to deploy. This naturally brings challenges in terms of ensuring
    that implementations are secured from various threats, such as **man-in-the-middle-attacks**
    (**MITM**), a lack of XML encryptions, insecure endpoints, and API URL parameters.
  prefs: []
  type: TYPE_NORMAL
- en: REST APIs have similar vulnerabilities as web applications; we will present
    the most common API attacks and vulnerabilities in the following sections, then
    move on to security tests.
  prefs: []
  type: TYPE_NORMAL
- en: Exposing sensitive data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first and foremost essential security aspect of testing a REST API (or any
    application) is to evaluate and determine the categories of data and the need
    for data protection when they are in transit or in a persisted state. For instance,
    personal information, credit card information, health records, financial information,
    business information, and many other such categories of information need protection.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, data is fundamentally protected through encryption, as exposing sensitive
    data with no encryption could lead to an attacker stealing sensitive data, which
    would not just be limited to personal data, credit card numbers, identity theft,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many preventative measures and means of protection sensitive data
    you can apply according to the classification (of data) and data protection needs.
    Some of these protection measures are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: Classify data and apply controls according to data classification.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not store sensitive information unless necessary and discard it as soon as
    possible. Use tokenization and truncation methods to prevent the exposure of sensitive
    data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encryption is a necessary and crucial protection measure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not implement a cache for sensitive data (or disable caches for sensitive
    data transactions).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use salts and adaptive (with a configurable number of iterations) hashing methodologies
    for passwords.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding authentication and authentication attacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Authentication is a process to determine the identity of an entity (a process,
    a machine, or a human user) to either disallow or allow that entity to access
    underlying application functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: Logon authentication, network authentication, IP authentication, remote authentication,
    basic authentication, and client certificates are a few authentication types.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication attacks are processes with which hackers attempt to exploit an
    authentication process and gain unauthorized access. Successfully penetrating
    an authentication system and gaining unauthorized access will allow a hacker to
    steal sensitive information and alter, corrupt, or delete valuable data. Imagine
    a hacker assumes someone's identity; this is identity theft and can lead to personal
    damage and monetary theft. Worse, if the hacked identity is of a network or server
    administrator, then the damage may be beyond our imagination.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication-type attacks include bypass attacks, brute-force attacks (for
    passwords), verify impersonation, and reflection attacks.
  prefs: []
  type: TYPE_NORMAL
- en: While we are discussing authentication attacks, it may be good to recollect
    an example implementation of basic authentication [Chapter 4](c44b2a11-65db-459f-a799-1692dd3930e8.xhtml),
    *Advanced RESTful API Patterns*. The investor service has some necessary security
    measure such as basic authentication, authorization with a default key, and also
    authorization with credentials to restrict API access only to genuine users. We
    also touched upon how to test and validate those security measures with Postman.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot depicts one such scenario (Authorization with a default
    key) and how we validate access using a default security key:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d96067ed-c4e1-46a8-862e-be25b2e07cf1.png)'
  prefs: []
  type: TYPE_IMG
- en: Understanding authorization and OAuth2 schemes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we now understand, proving a correct identity is authentication, and allowing
    a specific action by authenticated users is authorization. In this section, we
    will present a brief about OAuth—an industry-standard protocol for authorization
    – along with a few authorization schemes. When we mention the OAuth IETF OAuth
    Working Group ([https://tools.ietf.org/wg/oauth/](https://tools.ietf.org/wg/oauth/))
    in this section, it's OAuth 2.0, which focuses on client-developer simplicity
    (a RESTful principle) while providing specific authorization flows for various
    application use cases such as desktop applications, web applications, mobile phones,
    and even IoT-enabled living room devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we move on to OAuth 2.0 schemes, let''s understand why you would choose
    OAuth-based authorization over traditional cookie-based authorization with the
    following list:'
  prefs: []
  type: TYPE_NORMAL
- en: Cookie-based authorization is mostly stateful, that is, the server has to keep
    a record of active user sessions. To manage active sessions, the server would
    need multiple database calls to maintain the state. Also, a few other server-side
    overheads make it difficult to decouple the authorization process from the application
    server (to be stateless).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cookie-based authentication and authorization involve domains, as applications
    may interact with multiple domains, and so the underlying server needs a few additional
    configurations, resulting in maintenance and security overheads.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration of third-party clients such as Google+ and Facebook. Authorization
    for the application with cookie-based authorization is not a feasible solution
    in many cases.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cookie-based authorization is considered a maintenance nightmare (in some cases,
    such as native mobile apps) and so is not a preferred choice for many applications,
    especially when relying on mobile-based authentication.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'OAuth addresses these concerns by allowing arbitrary clients (for example,
    a first-party iOS application or a third-party web application) to access user''s
    (resource owner''s) resources on resource servers via authorization servers with
    secure, reliable, and effective methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ec89ac69-cd08-49ff-9b65-4e2c78a149ea.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding diagram depicts OAuth authorization stakeholders and their roles.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at a few OAuth 2.0-based authorization schemes and the situations
    or business cases you would choose those specific schemes for, with the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Schemes / Flow** | **Client type** | **Brief description** |'
  prefs: []
  type: TYPE_TB
- en: '| Implicit | **Single-page application** (**SPA**) such as Google Fonts. |
    Application requests access tokens from the gateway and the user grants permission
    |'
  prefs: []
  type: TYPE_TB
- en: '| Client-credentials | Machine-to-machine non-interactive programs such as
    services, daemons, and so on | The application passes the client credentials and
    gets the access token from the gateway server |'
  prefs: []
  type: TYPE_TB
- en: '| Authorization code | Less trusted apps (third-party apps requesting access
    to your application) | The application sends a temporary authorization code it
    receives from the gateway and gets it validated (by the same gateway) |'
  prefs: []
  type: TYPE_TB
- en: '| Resource owner password credentials | Highly trusted apps (first-party apps)
    | The client will ask the user for their authorization credentials (usually a
    username and password), then the client sends a few parameters (`grant_type`,
    `client_id`, `client_secret`) to the authorization server |'
  prefs: []
  type: TYPE_TB
- en: As part of this chapter, we have provided OAuth 2.0 example code that implements
    the **Resource Owner** password credentials flow and is available on GitHub for
    anyone to download and execute.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram depicts the typical sequence of a resource owner password
    credential OAuth scheme, before we move to the section that explains how to run
    that example code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/af08c287-fef1-4dfd-850a-f9aeeb3d5aa4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following steps and a few screenshots of the Postman tool will be useful
    if you want to run and test that example code on your system:'
  prefs: []
  type: TYPE_NORMAL
- en: Download the code from GitHub (you may want to refer to the *Technical requirement*
    section [Chapter 3](bdb7c23e-8c80-4a89-af31-e40d1b4c1d36.xhtml), *Essential RESTful
    API Patterns*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the Terminal and `cd` to `downloaded_loc/Hands-On-RESTful-API-Design-Patterns-and-Best-Practices\Chapter06\oauth2-sample`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `mvn clean install` and wait for the `BUILD SUCCESS` message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the application by running the `java -jar target\ oauth2-sample-0.0.1-SNAPSHOT.jar` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the local Postman tool and test the URLs (in the `Chapter06` folder of
    Postman collections).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: you will see the following screenshots when you run the different scenarios.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try error conditions and other scenarios as well (by providing incorrect credentials,
    user credentials instead of admin credential, and so on).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the sample with the `java -jar` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6e0f85e6-0756-4eb2-ba5e-273f31769792.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Wait for the local server to start and be ready to accept requests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6eacd0e4-1cfd-49eb-8b0b-555ed7190353.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Open the Postman tool, run the collections in the `Chapter06` folder, and observe
    the client credentials (required for the Authorization server):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f6c06887-3630-436f-929a-16db396bf8b2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now enter user credentials for the Authorization server to provide the necessary
    token:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/873d65ba-5ad2-401b-933d-13b96175b8f4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Get the access-token from the Authorization server so that we can use it to
    access the necessary resources in the next step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/145b19ac-494c-4183-84d8-b1921d3173fb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Use the access token that we got in the last step and access the admin (resource)
    API. Notice the response body:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/927e0519-6a19-438a-813d-b78748f0fb87.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Repeat the same steps for user resources with the necessary user credentials
    (notice the user name in the input):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/70aa2a4c-6608-450b-bc80-17c61193a6dc.png)'
  prefs: []
  type: TYPE_IMG
- en: So, you can execute different scenarios (not provided as part of this chapter)
    such as error messages and different HTTP error codes (`403`, `302`, and so on)
    with the sample code.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-site scripting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **Cross-site scripting** (**XSS**) attack is the process of injecting malicious
    code as part of the input to web services, usually through a browser. Once injected,
    the malicious script can access any cookies, session tokens, and sensitive information
    retained by the browser, and can even masquerade as the content of the rendered
    pages. XSS can be categorized into server-side XSS and client-side XSS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Traditionally, XSS is one of three types:'
  prefs: []
  type: TYPE_NORMAL
- en: Reflected XSS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stored XSS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DOM XSS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An exciting read about stored XSS on the word-press REST API defect can be
    found here: [https://threatpost.com/wordpress-rest-api-bug-could-be-used-in-stored-xss-attacks/124294/](https://threatpost.com/wordpress-rest-api-bug-could-be-used-in-stored-xss-attacks/124294/) and
    here: [https://threatpost.com/wordpress-silently-fixed-privilege-escalation-vulnerability-in-4-72-update/123533/](https://threatpost.com/wordpress-silently-fixed-privilege-escalation-vulnerability-in-4-72-update/123533/).'
  prefs: []
  type: TYPE_NORMAL
- en: Reflected XSS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Successful reflected cross-site scripting happens when an application allows
    an attacker to inject browser-executable code (such as JavaScript, Applets, Action
    Scripts, Flash) within a single HTTP response. You may be aware the injected code
    is non-persistent and impacts the users only when they open the maliciously crafted
    link or URL or third-party web page that renders the affected response.
  prefs: []
  type: TYPE_NORMAL
- en: Stored XSS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Stored XSS, also known as persistent XSS, often considered harmful and high
    risk, occurs when a malicious script is injected into a vulnerable application
    as input and is viewed by another user or an administrator at a later time.
  prefs: []
  type: TYPE_NORMAL
- en: DOM XSS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The third type (developed by Amit Klein and available since 2005), DOM XSS,
    occurs when client-side code uses insecure references to DOM objects that are
    not entirely controlled by server-provided pages. Generally, but not limited to,
    APIs that dynamically inject attacker-controllable data to a page and JavaScript
    frameworks. Single-page applications are vulnerable to DOM XSS.
  prefs: []
  type: TYPE_NORMAL
- en: XSS protection needs to filter malicious content from user input and also needs
    encoding (escape).
  prefs: []
  type: TYPE_NORMAL
- en: Cross-site request forgery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Cross-site request forgery** (**CSRF**), Sea Surf, or XSRF, as it''s known,
    is a one-click attack vulnerability that web applications exposes the possibility
    of the end user being forced (by forged links, emails, and HTML pages) to execute
    unwanted actions on a currently authenticated session.'
  prefs: []
  type: TYPE_NORMAL
- en: The synchronize token pattern, cookie-to-header token, double submit cookie,
    and client-side safeguards are common CSRF prevention methodologies.
  prefs: []
  type: TYPE_NORMAL
- en: Denial-of-service attack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **denial-of-service** (**DoS**) attack is intended to make the targeted machine
    reach its maximum load (capacity to serve requests) quickly by sending numerous
    false requests so the target system denies further genuine requests.
  prefs: []
  type: TYPE_NORMAL
- en: Flood attacks and buffer overflow attacks are two categories of DoS. With flood
    attacks, the attacker saturates the target server by generating enormous traffic
    to the server, causing the target server to end up in DoS.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, a buffer overflow attack is intended to target a machine
    and make that machine consume all available memory or hard disk space, or cause
    high usage of the CPU. This result in various consequences, such as the system
    becoming slow to respond or sluggish in its behavior, and there may even be a
    situation in which the targeted system will crash, creating potentially catastrophic
    results.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that, generally, DoS attacks happen on networks where the malicious
    user (attacker) has more available bandwidth than the target server. Smurf attacks,
    ping floods, and ping of death attacks are some actual DoS attacks.
  prefs: []
  type: TYPE_NORMAL
- en: Distributed denial of service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DoS attacks on distribution systems are known as **distributed denial of service**
    (**DDoS**) attacks. DDoS attacks achieve success by employing multiple compromised
    computer systems, including network resources such as IoT devices, as sources
    of attack traffic.
  prefs: []
  type: TYPE_NORMAL
- en: Injection attacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most harmful and dangerous attacks is an injection attack. The attacker
    supplies untrusted input to the application, which gets executed/processed as
    a part of a command or query, thus resulting in the partial or complete discourse
    of the application behavior and leading to consequences such as data theft, data
    loss, loss of data integrity, and DoS. It can even lead to full-system compromise.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table captures a few common injection attack types, brief descriptions
    for each, and their potential impact:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type of Injection** | **A brief description** | **Potential impacts** |'
  prefs: []
  type: TYPE_TB
- en: '| Code injection/OS command injection | Execute operating system commands with
    application code | Gains higher privileges with higher privilege escalation vulnerabilities
    and lead to full-system compromise |'
  prefs: []
  type: TYPE_TB
- en: '| CRLF injection | Injects an EOL/carriage return character in an input sequence
    | Results in splitting the HTTP header to facilitate arbitrary content injection
    in the response body, including XSS |'
  prefs: []
  type: TYPE_TB
- en: '| Email (Mail command/SMTP) injection | Injects IMAP/SMTP statements to a mail
    server | Personal information disclosure and relay of SPAM emails |'
  prefs: []
  type: TYPE_TB
- en: '| Host header injection | Abuses the trust of the HTTP Host Header by dynamically
    generating headers based on user input | Cache poisoning—manipulates the caching
    system and serves malicious pagesPassword reset poisoning—exploits with password
    reset email and delivers malicious content directly to the target |'
  prefs: []
  type: TYPE_TB
- en: '| LDAP injection | Injects **Lightweight Directory Access Protocol** (**LDAP**)
    statements and executes them | Modifies contents of LDAP tree and grants illegitimate
    permissions, privilege escalations, and bypass authentication |'
  prefs: []
  type: TYPE_TB
- en: '| SQL injection | Injects fabricated SQL commands to exercise database read
    or modify data | Leads to data loss, data theft, data integrity loss, DoS, and
    can even result in full system compromise due to advanced variations of SQL injections
    |'
  prefs: []
  type: TYPE_TB
- en: '| XPath injection | Executes fabricated XPath queries by injecting false data
    into an application | Results in information disclosure and bypass authentication
    |'
  prefs: []
  type: TYPE_TB
- en: Insecure direct object references
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Insecure direct object references** (**IDOR**) are equally as harmful as
    the other top API vulnerabilities; they occur when an application exposes direct
    access to internal objects based on user inputs such as ID and filename.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at a quick example of IDOR with the following diagram. In it, Bob
    is getting his file having ID 1001 from the app does make sense, but what about
    he is getting Alice's document with ID **1003**?
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b802c14b-e9af-4981-8b73-edda25649ccf.png)'
  prefs: []
  type: TYPE_IMG
- en: A direct object reference is happening, as the developer exposed a reference
    to an internal implementation object – here, in the preceding example, it is a
    file (an object reference may be a directory, an image file, a database key, and
    so on) – with the application.
  prefs: []
  type: TYPE_NORMAL
- en: So, not having a validation mechanism, allowing Bob (the attacker) to manipulate
    these references to access unauthorized data is called an IDOR vulnerability.
  prefs: []
  type: TYPE_NORMAL
- en: One can test for IDOR vulnerabilities by mapping out all of the endpoints where
    the user input is a direct reference (as depicted in the example diagram) and
    used as a reference object. Its always recommended two ore more users to cover
    direct objects and functions.
  prefs: []
  type: TYPE_NORMAL
- en: Missing function-level access control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another aspect of IDOR is missing functional level access rights. The application
    might have missed implementing function-level access rights, and so anyone with
    network access will be able to send a request and get a response rather than just
    the specific user who has privileges. For instance, an admin URL should not be
    available to a user who does not have admin-level access rights.
  prefs: []
  type: TYPE_NORMAL
- en: APIs with insufficient protection for sensitive request handlers within an application
    fall into the category of missing functional-level access rights vulnerability,
    and so allow hackers to penetrate the application without the necessary authorization.
  prefs: []
  type: TYPE_NORMAL
- en: Testing aspects of this vulnerability should focus on two essential scenarios—whether
    the user can directly browse a resource, and whether the UI accessing the API
    resources expose an unauthorized resource to that UI.
  prefs: []
  type: TYPE_NORMAL
- en: Man-in-the-middle attacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An MITM attack is an attack by a perpetrator who has placed themself in the
    middle of a network or communication between a genuine user and an application
    server. They intend to steal, eavesdrop on, impersonate and secretly relay, intercept,
    or alter communications, including API messages, between two communicating parties,
    all while it appears as though a normal exchange of information is underway:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6fa3b6d9-a6d1-42c4-95c0-6c8c79383708.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding diagram depicts a typical MITM attack, where the eavesdropper
    impersonates and relays communications/responses to the caller as they come from
    the server, and they will appear genuine.
  prefs: []
  type: TYPE_NORMAL
- en: An example of an MITM attack could be communication between an API that issues
    a session token as part of an HTTP header and a perpetrator acting as a man in
    the middle between the user's browser and the HTTP header (session token). So,
    it's easy to intercept that session token as it opens up access to the user's
    account, then the damage can be done depending on that account's privileges.
  prefs: []
  type: TYPE_NORMAL
- en: Common types of MITM attacks and protection measures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are a few common MITM attacks, as found in the following list, that you
    need to be aware of, and also a few protection measures against those attacks:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sniffing**: Sniffing, also known as packet sniffing, in which attackers use
    widely/freely available packet capture tools by using specific wireless devices
    to inspect and monitor packets communicated over a network.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Packet injection**: Injecting malicious packets into data communication streams
    in such a way that they blend in with valid data streams and appear as part of
    the original/intended communication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SSL stripping**: Altering HTTPS network communication to HTTP on the fly
    and making the communication insecure is another form of MITM attack (the user
    may not even realize that they are redirected to unsecured endpoints) and, leaking
    sensitive information as plain text, which attackers get onto it quickly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Email hijacking**: A very common type of MITM attack, in which attackers
    mimic a trusted site (for example, a bank''s website) send an email with instructions
    to the targeted account and convinces the account holder to follow the instructions
    in the email, resulting in the catastrophic effect of losing their money/personal
    information and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Wi-Fi eavesdropping**: This involves setting up exclusive Wi-Fi access points
    to lure users to get connected and make them use the network. Once the user is
    connected to those Wi-Fi access points, attackers will intercept and gain their
    credentials, credit card information, and much more sensitive information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Session hijacking**: Once the user logs in to an application with their credentials,
    the application will generate a temporary token so that user does not need to
    provide credentials again to access subsequent pages. However, an attacker can
    sniff and pick up that session token and use it to gain access to the user''s
    account.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Protection measures**: Protection against MITM attacks are as follow:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Secure/Multipurpose Internet Mail Extensions** (**S/MIME**)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Public key infrastructure** (**PKI**) based authentication certificates'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: SSL/TLS certificates
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: System and server configurations
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HTTP Strict Transport Security** (**HSTS**)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Replay attacks and spoofing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Replay attacks, also known as playback attacks, are network attacks in which
    valid data transmissions (supposed to be once only) are repeated many times (maliciously)
    by the attacker who spoofed the valid transaction. While a server is expecting
    a valid transaction, it will not have any doubts as to whether requests are valid
    transactions. However, these are a masqueraded request and lead to catastrophic
    effects for clients:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9b1355a7-fbcf-4228-970c-0af52e8f450c.png)'
  prefs: []
  type: TYPE_IMG
- en: The previous diagram depicts a replay attack example where the legitimate user
    sends a valid request, but the attacker spoofs it and resends/replays it to the
    APIs.
  prefs: []
  type: TYPE_NORMAL
- en: As RESTful APIs are stateless, the chances of getting those APIs into replay
    attacks are high (they're an easy target). So, it is evident that API designers/developers
    need to have countermeasures in their APIs for all replay attacks. Protection
    measures include a one-time password with session identifiers, **time-to-live**
    (**TTL**) measures, MAC implementation on the client side, and including timestamps
    in requests, along with secure protocol such as Kerberos protocol prevention,
    secure routing, and the **challenge-handshake authentication protocol** (**CHAP**).
  prefs: []
  type: TYPE_NORMAL
- en: Causes of vulnerabilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have looked at a few of the vulnerabilities in the previous section, let's
    also familiarize ourselves with a few common concerns and issues that cause APIs
    to be vulnerable to various attacks in the following paragraphs.
  prefs: []
  type: TYPE_NORMAL
- en: API design and development flaws
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Missing or not adhering to API security principles and best practices may lead
    to defects that expose business-critical data. Another aspect of design and development
    is to keep APIs as simple as possible, as complexity may lead to less coverage
    and vulnerability. Poor user input validation, SQL injection loopholes, and buffer
    overflows are a few other causes.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 2](edae86df-d90e-4b4c-9ada-4de80edaef71.xhtml)*, Design Strategy,
    Guidelines, and Best Practices*, discussed various aspects of design strategies
    and RESTful API design practices. Understanding and implementing those design
    principles and practices in APIs helps reduce design and development flaws.'
  prefs: []
  type: TYPE_NORMAL
- en: Poor system configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even the best design and development is not necessarily enough to safeguard
    a system if the system configurations (where the APIs are) do not adhere to security
    compliance. This will also lead to loopholes and attackers stealing information.
  prefs: []
  type: TYPE_NORMAL
- en: Human error
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Non-adherence to organization security compliance and inadequate knowledge of
    security measures such as document-shredding policies, secure coding practices,
    strong passwords, maintaining the confidentiality of passwords, periodical resetting
    passwords, and preventing access to unknown/unsecured sites creates loopholes
    in the API that can lead to security breaches.
  prefs: []
  type: TYPE_NORMAL
- en: Internal and external connectivity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As APIs are part of unsecured internal and external networks, the connectivity
    of APIs in an unsecured network is another major cause of vulnerability. Also,
    APIs' exposure to large and unique channels, such as mobile networks, poor risk
    management, and lenient authorization practices within a network are a few examples
    from this category of vulnerability.
  prefs: []
  type: TYPE_NORMAL
- en: Security tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Security tests ensure APIs are secure from external threats and protected from
    the vulnerabilities that we have discussed in earlier sections. The primary focus
    of API security tests and security testers is to find the vulnerabilities of the
    API they intend to test by running penetration tests, fuzz tests, validations,
    sensitive data exposure determination, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Security functional testing and security vulnerability testing are two categories
    of security tests. A functional test executes manual tests and manually checks
    for the presence of security mechanisms within API's implementation. Security
    vulnerability tests execute automated test cases that may expose vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: The ultimate goal of the tester should be to understand the system behavior
    by studying error messages and expose any security vulnerability such as gaining
    unauthorized access, IDOR, MITM, and replay attacks.
  prefs: []
  type: TYPE_NORMAL
- en: You can fulfil security test goals by running penetration tests and fuzz tests
    along with various manual tests.
  prefs: []
  type: TYPE_NORMAL
- en: This section discusses penetration tests and fuzz tests in detail and also discusses
    the tools/frameworks that provide out-of-the-box support for security tests so
    that API testers can make use of tools to get security assurance for underlying
    APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Penetration tests or pen tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the imperatives in API testing is penetration tests, also known as pen
    tests. Pen tests are the process of simulating cyber attack against a the system
    or API to expose/determine exploitable vulnerabilities such as intra-network loopholes,
    XSS attacks, SQL injections, and code-injection attacks.
  prefs: []
  type: TYPE_NORMAL
- en: Pen tests asses the threat vector from an external standpoint, such as supported
    functions, available resources, and the API's internal components as well.
  prefs: []
  type: TYPE_NORMAL
- en: Let's discuss more details about pen testing—its stages, testing methods, frameworks
    that support pen testing, and a few criteria for selecting the best penetration
    tool in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Importance of penetration tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we delve into the details, the following rationalizations will help
    us understand why pen tests are so crucial in API testing:'
  prefs: []
  type: TYPE_NORMAL
- en: No compromise to data privacy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Guaranteed and secured financial transactions and financial data over the network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discover security vulnerabilities and loopholes in APIs and in underlying systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simulate, forecast, understand, and assess the impacts of attacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make APIs fully information security compliant
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pen testing lifecycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have a good understanding of vulnerability causes from the earlier
    section, let''s look at the five stages of pen tests in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/184aeeb9-4c31-43a2-b458-63f044b39990.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding diagram depicts the life cycle of pen tests, involving five phases
    of activities such as Preparation, **Scanning**, **Gaining Access** and **Maintaining
    Access**, and reporting.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at each phase in more detail in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Preparation, planning, and reconnaissance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first phase of the life cycle involves the following two parts:'
  prefs: []
  type: TYPE_NORMAL
- en: Scope, scope definitions, defining the goals of the tests to be carried out,
    and defining the testing methods and systems to be addressed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gathering intelligence such as the domain and endpoints, and understanding how
    the target API works, along with its exposure to vulnerabilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scanning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understanding the target application's response to various intrusion attempts
    with static and dynamic analysis is the focus of the **Scanning** phase.
  prefs: []
  type: TYPE_NORMAL
- en: Gaining access
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This involves attempting to uncover API vulnerabilities with application attacks
    such as XSS, SQL injections, code injections, and backdoors. Once those vulnerabilities
    are uncovered, exploiting them with privilege escalations, data stealing methods,
    and traffic interceptions are part of the **Gaining Access** scope, as well as
    assessing the damage that API vulnerability could cause.
  prefs: []
  type: TYPE_NORMAL
- en: Maintaining access
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An illicit, long-term intruder presence in a network may cause irreversible
    damage to the system, as they may be present in the system for a long time, which
    facilitates highly sensitive data mining (especially on government, military,
    and financial networks) in steady, well-researched, and meticulously planned attacks.
  prefs: []
  type: TYPE_NORMAL
- en: Assessing the long-term presence abilities, and the chances of them gaining
    in-depth access to systems/APIs is the primary intention of this **Maintaining
    Access** phase.
  prefs: []
  type: TYPE_NORMAL
- en: Analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The final phase of the life cycle focuses on compiling and presenting the results
    of penetration tests as a report. These reports generally contain a specific vulnerability
    that was exploited as part of pen tests, details of compromised/accessed sensitive
    data as part of the pen test exercise, and, most importantly, the duration of
    the time that you were able to remain in the system undetected. These results
    and reports will act as a feed/input security configurations across the organization
    to prevent any future attacks.
  prefs: []
  type: TYPE_NORMAL
- en: Pen testing types for API testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We discussed the importance of penetration tests in security testing, and APIs
    are no exception; they all need to go through these penetration tests and ensure
    that underlying APIs are not exposing any vulnerabilities. Please note that there
    are three categories of pen tests in practice and they are—black-box pen tests,
    grey-box pen tests, and white-box pen tests.
  prefs: []
  type: TYPE_NORMAL
- en: Black-box and grey-box testing assumes testers have only limited knowledge about
    the underlying API. We shall briefly cover white-box testing in this section,
    as it's essential for API security testing, and why it is preferred for API penetration
    tests in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: White-box penetration testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: White-box testing is also known as **structure-testing**, open-box, clear-box,
    and glass-box testing. The white-box pen test is a comprehensive testing methodology,
    as you get a whole range of information about the schema, source code, models,
    and so on, before starting the testing. White-box tests are intended to scrutinize
    the code and catch any design and development errors. They are simulations of
    internal security attacks.
  prefs: []
  type: TYPE_NORMAL
- en: 'API pen tests rely on white-box testing for the following reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: The tests run on all of the independent paths of a module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The tests confirm and verify all logical decisions (`true`/`false`) inside the
    code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The tests execute syntax checking, and so find typographical errors that are
    critical to finding code injections and SQL injection attacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The tests find design errors caused by a mismatch of the logical flow of the
    program and the actual execution (design for intent)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are plenty of open source tools available and commercial versions that
    can scan code, check for malicious code, find security loopholes using data encryption
    techniques, and even find hardcoded username and passwords. A few of the tools
    are listed in the following table (both commercial and open source versions):'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Tool** | **Type** | **Providers** |'
  prefs: []
  type: TYPE_TB
- en: '| Nmap | OpenSSL | Pure Hacking |'
  prefs: []
  type: TYPE_TB
- en: '| Nessus | Cain and Abel | Torrid Networks |'
  prefs: []
  type: TYPE_TB
- en: '| Metasploit | THC Hydra | SecPoint |'
  prefs: []
  type: TYPE_TB
- en: '| Wireshark | w3af | Veracode |'
  prefs: []
  type: TYPE_TB
- en: Let's summarize this section by stating that pen tests for APIs should expose
    API vulnerabilities before real attackers find them, and move on to fuzz tests.
  prefs: []
  type: TYPE_NORMAL
- en: Fuzz tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fuzz testing, also known as fuzzing, is one of the most widely used testing
    practices in the quality assurance phase. It involves massive amounts of random
    data (noise or fuzz) as input to the target system with the intention of targeting
    APIs to exhibit buffer overflow or any other unwanted behaviors, or even to provoke
    the system to crash.
  prefs: []
  type: TYPE_NORMAL
- en: Barton Miller at the University of Wisconsin introduced fuzz testing (in 1988,
    as part of his *Operating System Utility Program Reliability – The Fuzz Generator
    project*) to reveal any security loopholes and coding errors in APIs, software,
    networks, and operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'The primary purpose of API fuzzing is not to test the correct functionality
    of the API as such, but to explore and test the undefined region with the help
    of fuzzed data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/16a6fa71-6dde-4f41-85d0-db716b7b93b5.png)'
  prefs: []
  type: TYPE_IMG
- en: As shown in the preceding diagram, the scope of fuzzing is to expose any unexpected
    behaviors of the underlying API.
  prefs: []
  type: TYPE_NORMAL
- en: The life cycle of fuzz tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The various stages in a typical life cycle of an API fuzz test start with identifying
    the target APIs and defining the inputs for the test, and end with the generation
    of logs showing vulnerabilities detected in the API. The following diagram depicts
    each phase of the fuzz testing lifecycle:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7f7e8b8b-044b-4bc0-9410-c5c4156463dc.png)'
  prefs: []
  type: TYPE_IMG
- en: Fuzz testing strategy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fuzz testing strategy varies depending on the attack vectors, fuzzing targets,
    fuzzing methods, and so forth. For an API, let's focus on fuzzing targets. Fuzz
    testing has two primary classifications—mutation based and generation based. We
    will look at the details of both classifications in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Mutation-based fuzz tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Mutation or dumb fuzz tests are a simple approach, wherein we create new test
    data by altering existing data samples. Sample data generation starts with valid
    samples of protocols and altering the supplied inputs, to the extent of altering
    every bit of the inputs. The following diagrams illustrate two ways of going about
    mutation:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Bit flipping, where inputs are flipped in a sequence or in a random manner:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6a659ec3-f090-401b-8bdd-2afa8a1b3902.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Append a random string, where the end of the input has random strings appended:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f0da69fb-586b-44bd-a833-0aa84fa420e4.png)'
  prefs: []
  type: TYPE_IMG
- en: Generation-based fuzz tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generation-based fuzz tests, also known as intelligent fuzzing, are tests based
    on an understanding of known formats, known protocols, and the generation of inputs
    from scratch according to the system/API specifications (RFC) and formats (for
    instance, the format from the API documentation).
  prefs: []
  type: TYPE_NORMAL
- en: Generation fuzz tests are capable of building test data based on the data model.
    Sometimes, these tests are as simple as injecting random bytes, and sometimes
    they can be much smarter, knowing good data values and combining them in multiple
    interesting ways (such as having regular expressions as part of the request body,
    having hostnames in the header, and changing intended response types to different
    types).
  prefs: []
  type: TYPE_NORMAL
- en: Before we conclude this section on fuzz-testing strategies, let's get to know
    another very successful fuzz testing method, known as protocol-based fuzz testing
    (also known as syntax testing, grammar testing, and robust testing). In protocol-based
    fuzz testing, the testers have detailed knowledge of the protocol format, and
    their understanding depends on the given specifications. Here, the specifications
    are intended as an array of stored specifications within a model-based testing
    tool, and it is also capable of generating test data. Then, the tool needs to
    go through all of the specifications and add irregularity to the sequence, data
    contents, and so on to expose vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that, as the mutation approach does not require you to understand
    the protocol, you may feel more comfortable using it compared to the generation-based
    approach at first glance. However, the generation-based approach is a thorough,
    better, and recommended process even though it takes more time because it involves
    several valid input combinations. It does, however, lead to better code coverage
    and code paths.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages and disadvantages of fuzz tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following points intend to justify why fuzz tests are popular among the
    software professional community:'
  prefs: []
  type: TYPE_NORMAL
- en: They are extremely simple, easy, cost-effective, and quick to set up as they
    are free of preconceptions about system behavior
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Their one-time setup is easy to repeat for regression (automation)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As it is a protocol-aware test, test results lead to finding precise, descriptive,
    and easy-to-debug errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They enables you to find bugs that are impossible to find with the human eye
    in defined testing or approach-based testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They yields the best results when used in conjunction with black-box testing,
    beta testing, and other debugging methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'While fuzz tests bring many advantages to the table, we also need to be aware
    of and understand a few disadvantages, which are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: Mutation-based fuzz tests can run indefinitely (generate numerous test cases
    and run indefinitely) and so determining the optimal number of tests, or determining
    whether time they run for is long enough, is a difficult in some cases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tests results may report no defects, even after running numerous test cases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test results may report the same defects for various test cases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is challenging to find which test case caused the fault
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is difficult to find the vulnerability in the event of a system crash
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To conclude this section, let's list a few tools that you can take advantage
    of when running fuzz tests for APIs without much pain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open source:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Mutational fuzzing** | **Fuzzing Frameworks** | **Domain Specific fuzzing**
    |'
  prefs: []
  type: TYPE_TB
- en: '| American fuzzy lop | Sulley | Microsoft SDL MiniFuzz File Fuzzer |'
  prefs: []
  type: TYPE_TB
- en: '| Radamsa—a flock of fuzzers | Boofuzz | Microsoft SDL Regex Fuzzer |'
  prefs: []
  type: TYPE_TB
- en: '| OWASP WebScarab | BFuzz | ABNF Fuzzer |'
  prefs: []
  type: TYPE_TB
- en: '| OWASP WSFuzzer | - | - |'
  prefs: []
  type: TYPE_TB
- en: 'The preceding table details open source fuzzing tools. The following list provides
    a few commercial tools you may want to make use of for fuzz tests:'
  prefs: []
  type: TYPE_NORMAL
- en: Codenomicon's product suite
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Peach Fuzer Platform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spirent Avalanche NEXT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Beyond Security's beSTORM product
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And also, here are a few of the latest tools that readers might find exciting
    to run through their APIs:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Tool** | **Reference/Link** |'
  prefs: []
  type: TYPE_TB
- en: '| REST-ler | [https://www.microsoft.com/en-us/research/uploads/prod/2018/04/restler.pdf](https://www.microsoft.com/en-us/research/uploads/prod/2018/04/restler.pdf)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Burp | [https://portswigger.net/burp](https://portswigger.net/burp) |'
  prefs: []
  type: TYPE_TB
- en: '| Fuzzapi | [https://github.com/Fuzzapi/fuzzapi](https://github.com/Fuzzapi/fuzzapi)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Fuzz-rest-api | [https://github.com/dubzzz/fuzz-rest-api](https://github.com/dubzzz/fuzz-rest-api)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Big-list-of-naughty-strings | [https://github.com/minimaxir/big-list-of-naughty-strings/](https://github.com/minimaxir/big-list-of-naughty-strings/)
    |'
  prefs: []
  type: TYPE_TB
- en: Back to API testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have taken a detour from API tests and looked at many aspects of security
    tests in the previous sections. Now, let's get our focus back and redirect our
    journey to a few more API testing aspects in the rest of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: API test cases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To begin with, let's say that test cases for APIs need to have a few parameters
    or placeholders, such as input parameters, expected results, the time taken to
    receive a response (from the API), parsing input, error handling, and response
    formats so that test results of an API are ascertained and certified.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we move on to a few aspects of test case preparation, let''s get a glimpse
    of the possible types of bug that API tests help us to detect:'
  prefs: []
  type: TYPE_NORMAL
- en: Mishandled errors or disgraceful error conditions by the API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any unused flags
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Missing or duplicate functionality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multi-threading issues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Incorrect handling of valid argument values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validation issues such as schema validations or structure issues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reliability issues and performance issues (such as timeout and connecting and
    getting a response time) of the API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API vulnerabilities and any security issues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Essential aspects of API test cases and test case preparation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following list covers a few essential aspects of test case preparation
    for API testing, as the test cases on API testing depend on their outputs:'
  prefs: []
  type: TYPE_NORMAL
- en: Assert a return value based on different input conditions and a combination
    of inputs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assert the behavior of the API when there is no return value. Check for return
    codes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assert the events and triggers of an API if the underlying/target API creates
    subsequent events.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assert not only the API results in case of update data structure but validate
    the effect on the system that it has updated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assert by accessing impacted resources when the API is involved in modifying
    specific resources.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API testing challenges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are ready with the necessary test cases, is it sufficient to start testing
    the intended API? No, it is not—there are some more challenges one should be aware
    of, and we will look at a few common challenges you may face and also how to address
    those challenges when you want to start API testing in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Initial setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The testing infrastructure and its stability/availability, and uptime. Starting
    and practising API testing in the design phase and checking the APIs for 100%
    uptime is key.
  prefs: []
  type: TYPE_NORMAL
- en: API schema updates for testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Request and response schema or formats are the lifelines of the API. However,
    frequent changes to schemas are inevitable (especially during the development
    phase) and so test cases for schema configuration too. Managing tests in alpha
    and beta environments may reduce the number of issues (due to schema updates)
    by up to 90%.
  prefs: []
  type: TYPE_NORMAL
- en: Testing parameter combinations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Adding additional parameters to the API increases the number of combinations
    exponentially, while it is necessary to test every possible combination of parameter
    requests to find issues specific to configurations. API releases and ensuring
    potential API release candidates are available for testing helps address these
    challenges effectively.
  prefs: []
  type: TYPE_NORMAL
- en: API call sequence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Calling APIs in a specific sequence to attain the desired result is inevitable
    in many cases, and for those scenarios, test cases also need to have the proper
    sequence implemented. However, this is challenging in major APIs, and becomes
    even more challenging when cases of multi threaded applications are involved.
    Along with enforcing release candidates, a visual representation of a sequence
    of API calls or a flow chart for the sequence of API calls will help not only
    the testing phase but also the development team as well (as part of development
    phase).
  prefs: []
  type: TYPE_NORMAL
- en: Validating parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Checking numbers and the number of digits in a phone number, length restrictions,
    data type validations, data-ranges modifications, and such validation criteria
    or tests are daunting tasks for the testing team especially with larger APIs that
    have a vast number of parameters to validate. Implementing synthetic and **application
    performance monitoring** (**APM**) tools will help to ensure catching any problems
    that arise due to parameter validations. Validating parameter is one of the crucial
    aspects of security testing as well.
  prefs: []
  type: TYPE_NORMAL
- en: Tracking system integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A data tracking system helps to find the correct responses to the calls. However,
    it is a challenging task for the team to ensure that the API testing system is
    working correctly with the data tracking system and calls that the API is making
    are getting the right response. you can address this challenge by implementing
    and including load tests with **continuous delivery **(**CD**).
  prefs: []
  type: TYPE_NORMAL
- en: API testing best practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following section lists a few API testing best practices you should know
    about. To start with, the following are test case best practices:'
  prefs: []
  type: TYPE_NORMAL
- en: Group API test cases by test category (unit tests, functional tests, security
    tests, and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure test cases indicate the declarations of involved (called) APIs on top
    of each test case
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure parameter selections are mentioned explicitly in the test case itself
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executes test cases independently, that is, each test case is a self-contained
    and an independent entity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: prioritize API calls, which helps to simplify API testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep test cases free from *test chaining* (reusing test data objects created
    by other tests)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test cases deal with one-time call functions such as delete, close window, asynchronous
    calls, and so need special attention to avoid undesirable executions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure API call sequences are well planned and also have clear execution plans
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create test cases for every possible known input combination of the API, as
    this leads to better test coverage of the underlying APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API testing tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It may be a good idea to complete our API testing journey with some information
    about a few common API testing tools. The following screenshot of API testing
    tools gives brief details on each tool, their ease of use, and supporting platforms
    and may come in handy:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/facc50dc-0ff7-49f2-83d6-c1c9918f030d.png)'
  prefs: []
  type: TYPE_IMG
- en: CQRS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Command Query Responsibility Segregation** (**CQRS**) is an architectural
    pattern, proposed by Greg Young. CQRS suggests the segregation of the reading
    operations (queries) and writing operations (commands) of a system to separate
    subsystems, as reads are eventually consistent and retrieved from de-normalized
    views and commands are usually asynchronous and stored in transactional storage,
    and reads are eventually consistent and retrieved from deformalized views.'
  prefs: []
  type: TYPE_NORMAL
- en: So, segregating read and write operations with separate interfaces or subsystems
    doesn't only help to maximize the performance of APIs, it also helps in security
    and scalability aspects, as well as managing merge conflicts at the domain level,
    due to update commands, leading to more flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we delve further into CQRS, let''s look at traditional patterns for
    **Data Access** in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/81fca498-5e41-44d2-8df9-550481f1e125.png)'
  prefs: []
  type: TYPE_IMG
- en: Traditional Data Source and DTO models (CRUD)
  prefs: []
  type: TYPE_NORMAL
- en: As depicted, the read and write operations of data (source) are from one data
    source or data storage, with updates or writes and Queries (read).
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few disadvantages with the CRUD approach, as listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: The data that is being read and the data being updated may have different representations
    and managing that updated data in sync to serve both reads and writes is an overhead
    to the underlying system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance is affected by the high load on the data store and data access layers
    and depends on queries and the complexities involved in retrieving information.
    High volume transactions also increase the chances of data contention when records
    are locked in a data store and accessed by multiple domains.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing security and roles for data access might be challenging as well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The CQRS pattern addresses those disadvantages, as its implementation segregates
    queries (reads) from the update (**Commands**) operations with separate interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/31719e3c-885f-4207-82c7-19808c1a6c5c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It also check the following instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7121565c-7b6f-47f6-b195-bfbb8558df8d.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding two diagrams depict two variations of CQRS implementation. The
    first one represents a simplified design and implementation of CQRS with read
    and write models within a single data source. Note that it is not a single data
    model (like CRUD), but read and write as a separate models. The downside of this
    version of CQRS implementation is that, unlike CRUD, the automatic code generation
    with scaffolding mechanism is not possible for CQRS based systems.
  prefs: []
  type: TYPE_NORMAL
- en: The diagram with a separate data source depicts another CQRS design, where we
    have two different physical data stores one for write or update operations (commands)
    and then another one exclusively for queries. Separate data store implementation
    maximizes performance, scalability, and security.
  prefs: []
  type: TYPE_NORMAL
- en: 'While CQRS brings higher performance, scalability, and security, it also brings
    increased complexity and maintenance overheads to manage consistency due to multiple
    data stores and also one would need to understand from the following list when
    to choose CQRS for your implementations:'
  prefs: []
  type: TYPE_NORMAL
- en: CQRS is suitable for systems in which number of writing (updates) and reading
    (queries) differ significantly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's ideal for systems in which reads and writes need individual scaling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's suitable for systems where the consistency of data is not critical (addressed
    eventual consistency) but the availability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It 's ideal for systems that prefer fire-and-forget events (asynchronous events)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's suitable for the systems that have a data store access layer based on event
    sources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's ideal for systems that implement domain-driven designs and isolate the
    business or domain complexity, and having CRUD would make more complex
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are at the end of our API testing journey and, reflecting on of this journey,
    we have learned a few basics of API testing types and API testing approaches,
    starting from unit test cases, through to API validation tests, functional tests,
    load tests, and end-to-end tests, along with API monitoring. We have also touched
    on a few important API errors aspects such as execution errors, resource leaks,
    and error detection methodologies.
  prefs: []
  type: TYPE_NORMAL
- en: While we were looking at on API testing, we got to know a few critical security
    vulnerabilities in the REST API world, including sensitive data exposure, authentication
    attacks, XSS attacks, see-surf (CSRF), DoS attacks, and injection attacks. We
    did not just focus on attacks, as this chapter introduced the causes of those
    attacks (vulnerabilities), as well as methods and tools for detecting those API
    vulnerabilities by means of penetration and fuzz tests.
  prefs: []
  type: TYPE_NORMAL
- en: We continued on our API testing journey after understanding API security measures—we
    got to know a few of the basics of API test case creation, API testing challenges,
    and API testing best practices, and concluded our journey with a snapshot of API
    testing tools.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Mastering Modern Web Penetration Testing* ([https://www.packtpub.com/networking-and-servers/mastering-modern-web-penetration-testing](https://www.packtpub.com/networking-and-servers/mastering-modern-web-penetration-testing)),
    Prakhar Prasad, Packt Publishing.'
  prefs: []
  type: TYPE_NORMAL
