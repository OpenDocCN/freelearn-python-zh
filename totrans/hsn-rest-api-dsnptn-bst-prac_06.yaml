- en: RESTful Services API Testing and Security
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RESTful服务API测试和安全
- en: Any software that claims to be enterprise-ready must have gone through rigorous
    testing cycles, be quality assurance certified, and have met several quality measures
    so that it gets used on production servers. The security of a software application
    is another critical aspect that determines whether or not it will be used on production
    servers.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 声称企业就绪的任何软件都必须经过严格的测试周期，获得质量保证认证，并满足多个质量标准，以便在生产服务器上使用。软件应用程序的安全性是另一个决定其是否会在生产服务器上使用的关键方面。
- en: To equip readers with an understanding of different aspects of production and
    enterprise-ready RESTful APIs, this chapter will discuss various aspects of those
    quality and security measures.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让读者了解生产和企业级RESTful API的不同方面，本章将讨论这些质量和安全措施的各种方面。
- en: 'This chapter''s intention is to take readers on an API testing journey. These
    are the milestones or topics we will cover as we go along:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目的是带读者进行API测试之旅。以下是我们将涵盖的里程碑或主题：
- en: Types of API tests
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API测试的类型
- en: Challenges in API testing
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API测试的挑战
- en: Security in API testing
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API测试中的安全性
- en: In addition, we will give you a glimpse of various API testing tools, API security
    tools, and frameworks
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，我们还将向您展示各种API测试工具、API安全工具和框架的概览
- en: Midway through the API testing journey, readers will be taken on a detour to
    be introduced to some security issues and API vulnerabilities and learn how to
    expose them as part of API testing.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在API测试之旅的中途，读者将进行一次小插曲，介绍一些安全问题和API漏洞，并学习如何在API测试中揭露它们。
- en: An overview of software testing
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件测试概述
- en: Any product, be it simple safety pins or majestic airplanes, needs to go through
    a process to ensure that it solves the purpose of its creation, and so does software,
    too. Software testing is a process to confirm the accuracy and quality of software
    through the verification and validation of its purpose, end-to-end.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 任何产品，无论是简单的安全别针还是宏伟的飞机，都需要经过一个过程来确保它解决了其创造的目的，软件也是如此。软件测试是通过验证和验证其目的，从端到端来确认软件的准确性和质量的过程。
- en: So, the primary focus of any software product or application is verification
    (checks for consistency and alignment according to the documented requirements)
    and validation (checks the accuracy of the system and validates the end user's
    needs versus the actual outcome).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，任何软件产品或应用的主要重点是验证（根据文档要求检查一致性和对齐）和验证（检查系统的准确性，并验证最终用户的需求与实际结果之间的差异）。
- en: 'Let''s list a few essential outcomes of software testing and move on to focus
    more on API testing in the upcoming sections:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们列出一些软件测试的基本成果，然后转向下一部分，重点关注API测试：
- en: Assert and ensure that there are no differences between the realities and the
    expectations of the requirements
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 断言并确保实际与需求期望之间没有差异
- en: Assert and ensure software product continuity and availability, regardless of
    the amount of end users
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 断言并确保软件产品无论用户数量多少都能持续可用
- en: Foresee and uncover concealed problems
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预测和揭示隐藏的问题
- en: Assert and ensure that offerings function seamlessly with anticipated end user
    platforms, browsers, and so on
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 断言并确保产品与预期的最终用户平台、浏览器等无缝运行
- en: RESTful APIs and testing
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RESTful API和测试
- en: As this book deals with RESTful APIs, this chapter is intended to take readers
    through a few essential best practices and API testing principles, along with
    a couple of testing frameworks. With integration tests (both manual and automated),
    we can accomplish most critical API testing strategies for distributed applications
    and help those applications to be production-ready, deployable, and part of CI/CD,
    as well as to assert their scalability and stability for every release.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本书涉及RESTful API，本章旨在引导读者了解一些基本最佳实践和API测试原则，以及一些测试框架。通过集成测试（包括手动和自动的），我们可以完成分布式应用的大部分关键API测试策略，并帮助这些应用达到生产就绪、可部署，并成为CI/CD的一部分，同时确保每个版本的可扩展性和稳定性。
- en: The following section introduces the basics of API testing, API testing approaches,
    their types, and so on.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分介绍了API测试的基础、API测试方法、它们的类型等。
- en: Basics of API testing
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API测试的基础
- en: 'A software application product, that we discussed in an earlier section, has
    various software layers such, as the **user interface** (**UI**), the business
    logic layer, middleware, and a database. **API testing** and certification primarily
    focuses on data integration tests on the **Business layer**. **API testing** is
    software testing that involves direct **API testing**, unlike other generic tests,
    which primarily involve the UI:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面章节讨论的软件应用程序产品，具有各种软件层，例如用户界面（**UI**）、业务逻辑层、中间件和数据库。**API 测试**和认证主要关注**业务层**上的数据集成测试。**API
    测试**是一种软件测试，涉及直接的**API 测试**，与其它通用测试不同，后者主要涉及用户界面：
- en: '![](img/4aee86d4-d52a-4cde-bbf1-4aa5cb2e33dd.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4aee86d4-d52a-4cde-bbf1-4aa5cb2e33dd.png)'
- en: The preceding diagram depicts the typical layers of software, with **API testing**
    on the **Business layer** and the functional or UI testing on the **Presentation
    layer**.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图示展示了软件的典型层，其中**API 测试**位于**业务层**，而功能或 UI 测试位于**表示层**。
- en: Understanding API testing approaches
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 API 测试方法
- en: 'Agreeing on an approach for API testing when beginning API development is an
    essential API strategy. Let''s look at a few principles of API testing:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始 API 开发时商定 API 测试的方法是一个关键的 API 策略。让我们看看 API 测试的一些原则：
- en: Clear definition of the scope and a good understanding of the functionality
    of the API
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 明确定义范围并充分理解 API 的功能
- en: Common testing methodologies such as boundary analysis and equivalence classes
    are part of API test cases
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见的测试方法，如边界分析和等价类，是 API 测试用例的一部分
- en: Plan, define, and be ready with input parameters, zero, and sample data for
    the API
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 制定计划，定义输入参数，准备零和样本数据以供 API 使用
- en: Determine and compare expected and actual results, and ensure that there are
    no differences
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定并比较预期和实际结果，并确保没有差异
- en: API testing types
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API 测试类型
- en: In this section, we will review the various categories of API testing and move
    on to best practices as well.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将回顾 API 测试的各种类别，并继续探讨最佳实践。
- en: Unit tests
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: 'Tests that involves the validation of individual operations are unit tests.
    In our investor services API examples in [Chapter 4](c44b2a11-65db-459f-a799-1692dd3930e8.xhtml),
    *Advanced RESTful API Patterns*, we covered numerous unit test cases, and the
    following is one of the sample code snippets of a specific unit test case that
    validates getting all the investors from the API:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 涉及验证单个操作的测试是单元测试。在我们的投资者服务 API 示例中，[第 4 章](c44b2a11-65db-459f-a799-1692dd3930e8.xhtml)，“高级
    RESTful API 模式”，我们涵盖了大量的单元测试用例，以下是一个特定单元测试用例的样本代码片段，用于验证从 API 获取所有投资者：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: API validation tests
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API 验证测试
- en: All software needs quick evaluation and to assert its purpose of creation. The
    validation tests need to be run for every function that is developed, at the end
    of the development process. Unlike unit tests, which focus on particular pieces
    or functions of the API, validation tests are a higher-level consideration, answering
    a set of questions so that the development can move on to the next phase.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 所有软件都需要快速评估，并确认其创建的目的。验证测试需要在开发过程的最后对每个开发的功能进行运行。与关注 API 的特定部分或功能的单元测试不同，验证测试是一个更高层次的考虑，通过回答一系列问题，以便开发可以进入下一阶段。
- en: 'A set of questions for validation tests could be the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 验证测试的一组问题可能如下：
- en: A product-specific question, such as, is it the necessary function that is asked
    for?
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个产品特定的问题，例如，是否是请求的必要功能？
- en: A behavioral question, such as, is the developed function doing what is intended?
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个行为问题，例如，开发的功能是否做了预期的事情？
- en: An efficiency-related question, such as, is the intended function using the
    necessary code, in an independent and optimized manner?
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个与效率相关的问题，例如，预期的功能是否以独立和优化的方式使用必要的代码？
- en: All of these questions, in essence, serve to validate the API in line with the
    agreed acceptance criteria and also to ensure its adherence to standards regarding
    the delivery of expected end goals and meeting user needs and requirements flawlessly.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些问题，本质上都是为了验证 API 符合约定的验收标准，并确保其完美地遵循关于实现预期最终目标和满足用户需求和要求的规范。
- en: Functional tests
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能测试
- en: 'Tests that involve specific functions of the APIs and their code base are functional
    tests. Validating the count of active users through the API, regression tests
    and test case execution come under functional tests. We saw many examples of functional
    tests executed with the Postman tool earlier, in [Chapter 3](bdb7c23e-8c80-4a89-af31-e40d1b4c1d36.xhtml),
    *Essential RESTful API Patterns*, and [Chapter 4](c44b2a11-65db-459f-a799-1692dd3930e8.xhtml),
    *Advanced RESTful API Patterns*. The following screenshot may refresh your memory
    of one such functional testing example of investor service validation for user
    authentication:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 涉及API特定功能和它们的代码库的测试是功能测试。通过API验证活跃用户数量、回归测试和测试用例执行都属于功能测试。我们之前在[第3章](bdb7c23e-8c80-4a89-af31-e40d1b4c1d36.xhtml)，*基本RESTful
    API模式*和[第4章](c44b2a11-65db-459f-a799-1692dd3930e8.xhtml)，*高级RESTful API模式*中看到了许多使用Postman工具执行的功能测试的例子。以下截图可能会刷新你对投资者服务用户认证验证此类功能测试例子的记忆：
- en: '![](img/a465ead7-212a-4aea-91bb-0de24776e251.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a465ead7-212a-4aea-91bb-0de24776e251.png)'
- en: UI or end-to-end tests
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UI或端到端测试
- en: Tests that involve and assert end-to-end scenarios, including GUI functions
    and API functions, which in most of the cases, validate every transaction of an
    application, are grouped under end-to-end tests.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 包括GUI功能和API功能在内的涉及和断言端到端场景的测试，在大多数情况下，验证应用程序的每个事务，被归类为端到端测试。
- en: Load testing
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 压力测试
- en: As we know, an increase in the number of end users should not affect the performance
    of the functions of an application. Load testing will uncover such issues and
    also validate the performance of an API in normal conditions too.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，用户数量的增加不应影响应用程序功能的表现。压力测试将揭示这些问题，并验证API在正常条件下的性能。
- en: Runtime error detection tests
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行时错误检测测试
- en: Tests that help to monitor the application and detect problems such as race
    conditions, exceptions, and resource leaks belong in the runtime error tests category.
    The following points capture a brief about those factors.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 帮助监控应用程序并检测诸如竞争条件、异常和资源泄露等问题属于运行时错误测试类别。以下要点简要介绍了这些因素。
- en: Monitoring APIs
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监控API
- en: Tests for various implementation errors, handler failures, and other inherent
    concerns inside the API code base and ensures it does not have any holes that
    would lead to application insecurity.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 测试各种实现错误、处理程序失败和其他API代码库内部的固有关注点，确保它没有可能导致应用程序不安全的漏洞。
- en: Execution errors
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行错误
- en: 'Valid requests to the API return responses and asserting them for expected
    valid responses is common, however, asserting invalid requests for expected failures
    is also essential as part of an API testing strategy, and those tests come under
    execution errors:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 对API的有效请求返回响应，并断言它们为预期的有效响应是常见的，然而，断言无效请求以期望失败也是API测试策略的一部分，这些测试属于执行错误：
- en: '![](img/bbccd840-8914-46c3-84a3-dd1ff4296c6a.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bbccd840-8914-46c3-84a3-dd1ff4296c6a.png)'
- en: The preceding screenshot depicts the [Chapter 3](bdb7c23e-8c80-4a89-af31-e40d1b4c1d36.xhtml), *Essential
    RESTful API Patterns*, example of expecting an error when the user gives an ID
    that is not present on the system.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个截图展示了[第3章](bdb7c23e-8c80-4a89-af31-e40d1b4c1d36.xhtml)，*基本RESTful API模式*的例子，当用户提供的ID在系统中不存在时，预期会出现错误。
- en: Resource leaks
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源泄露
- en: Negative tests to validate the underlying API resource malfunctions by submitting
    invalid requests to the API. The resources, in this case, are memory, data, insecurities,
    timeout operations, and so on.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 通过向API提交无效请求来验证底层API资源故障的负面测试。在这种情况下，资源包括内存、数据、不安全性、超时操作等。
- en: Error detection
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误检测
- en: 'Detect network communication failures. Authentication failures from giving
    the wrong credentials is an example error detection scenario. These are tests
    ensure the errors are captured and then resolved as well:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 检测网络通信故障。由于提供错误的凭据而导致的认证失败是一个错误检测场景的例子。这些测试确保错误被捕获并得到解决：
- en: '![](img/43e9cab8-a9ad-409f-ab6a-49702c77fd31.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/43e9cab8-a9ad-409f-ab6a-49702c77fd31.png)'
- en: We saw an authentication error in our [Chapter 4](c44b2a11-65db-459f-a799-1692dd3930e8.xhtml),
    *Advanced RESTful API Patterns*, investor-service example, and the previous screenshot
    depicts this, as the code returns `401` (as it should); this is an example of
    an error detection test.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第4章](c44b2a11-65db-459f-a799-1692dd3930e8.xhtml)，*高级RESTful API模式*，投资者服务示例中遇到了认证错误，如图所示的前一个截图描绘了这一点，因为代码返回了`401`（正如预期的那样）；这是一个错误检测测试的例子。
- en: REST API security vulnerabilities
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST API安全漏洞
- en: APIs are popular and widely used because they are simple, schematic, fast to
    develop, and quick to deploy. This naturally brings challenges in terms of ensuring
    that implementations are secured from various threats, such as **man-in-the-middle-attacks**
    (**MITM**), a lack of XML encryptions, insecure endpoints, and API URL parameters.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: API因其简单、结构化、开发速度快和部署迅速而受到欢迎和广泛使用。这自然带来了确保实现免受各种威胁的挑战，例如**中间人攻击**（**MITM**）、缺乏XML加密、不安全的端点和API
    URL参数。
- en: REST APIs have similar vulnerabilities as web applications; we will present
    the most common API attacks and vulnerabilities in the following sections, then
    move on to security tests.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: REST API与Web应用程序具有类似的安全漏洞；我们将在以下章节中介绍最常见的API攻击和漏洞，然后转向安全测试。
- en: Exposing sensitive data
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 暴露敏感数据
- en: The first and foremost essential security aspect of testing a REST API (or any
    application) is to evaluate and determine the categories of data and the need
    for data protection when they are in transit or in a persisted state. For instance,
    personal information, credit card information, health records, financial information,
    business information, and many other such categories of information need protection.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 测试REST API（或任何应用程序）的首要和最重要的安全方面是评估和确定数据在传输或持久化状态下的数据类别和数据保护需求。例如，个人信息、信用卡信息、健康记录、财务信息、商业信息以及许多其他此类信息类别都需要保护。
- en: Moreover, data is fundamentally protected through encryption, as exposing sensitive
    data with no encryption could lead to an attacker stealing sensitive data, which
    would not just be limited to personal data, credit card numbers, identity theft,
    and so on.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，数据通过加密得到根本性的保护，因为没有加密的敏感数据泄露可能导致攻击者窃取敏感数据，这不仅仅限于个人数据、信用卡号码、身份盗窃等等。
- en: 'There are many preventative measures and means of protection sensitive data
    you can apply according to the classification (of data) and data protection needs.
    Some of these protection measures are listed here:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 根据数据的分类（和数据保护需求），你可以应用许多预防措施和保护手段来保护敏感数据。以下是一些保护措施的列表：
- en: Classify data and apply controls according to data classification.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据数据分类进行数据分类并应用控制措施。
- en: Do not store sensitive information unless necessary and discard it as soon as
    possible. Use tokenization and truncation methods to prevent the exposure of sensitive
    data.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除非必要，否则不要存储敏感信息，并尽快丢弃。使用令牌化和截断方法来防止敏感数据泄露。
- en: Encryption is a necessary and crucial protection measure.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加密是一种必要且至关重要的保护措施。
- en: Do not implement a cache for sensitive data (or disable caches for sensitive
    data transactions).
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要为敏感数据实现缓存（或禁用敏感数据交易的缓存）。
- en: Use salts and adaptive (with a configurable number of iterations) hashing methodologies
    for passwords.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为密码使用盐和自适应（具有可配置的迭代次数）散列方法。
- en: Understanding authentication and authentication attacks
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解认证和认证攻击
- en: Authentication is a process to determine the identity of an entity (a process,
    a machine, or a human user) to either disallow or allow that entity to access
    underlying application functionalities.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 认证是一个确定实体（一个过程、一台机器或一个人类用户）身份的过程，以允许或拒绝该实体访问底层应用程序功能。
- en: Logon authentication, network authentication, IP authentication, remote authentication,
    basic authentication, and client certificates are a few authentication types.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 登录认证、网络认证、IP认证、远程认证、基本认证和客户端证书是一些认证类型。
- en: Authentication attacks are processes with which hackers attempt to exploit an
    authentication process and gain unauthorized access. Successfully penetrating
    an authentication system and gaining unauthorized access will allow a hacker to
    steal sensitive information and alter, corrupt, or delete valuable data. Imagine
    a hacker assumes someone's identity; this is identity theft and can lead to personal
    damage and monetary theft. Worse, if the hacked identity is of a network or server
    administrator, then the damage may be beyond our imagination.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 认证攻击是黑客尝试利用认证过程并获取未授权访问的过程。成功渗透认证系统并获得未授权访问将允许黑客窃取敏感信息并更改、破坏或删除有价值的数据。想象一下黑客假扮成某人的身份；这是身份盗窃，可能导致个人损害和金钱盗窃。更糟糕的是，如果被黑客攻击的身份是网络或服务器管理员，那么损害可能超乎我们的想象。
- en: Authentication-type attacks include bypass attacks, brute-force attacks (for
    passwords), verify impersonation, and reflection attacks.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 认证类型攻击包括绕过攻击、暴力攻击（针对密码）、验证冒充和反射攻击。
- en: While we are discussing authentication attacks, it may be good to recollect
    an example implementation of basic authentication [Chapter 4](c44b2a11-65db-459f-a799-1692dd3930e8.xhtml),
    *Advanced RESTful API Patterns*. The investor service has some necessary security
    measure such as basic authentication, authorization with a default key, and also
    authorization with credentials to restrict API access only to genuine users. We
    also touched upon how to test and validate those security measures with Postman.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在讨论认证攻击时，回顾一个基本认证的示例实现[第4章](c44b2a11-65db-459f-a799-1692dd3930e8.xhtml)，*高级RESTful
    API模式*可能是个好主意。投资者服务有一些必要的安全措施，如基本认证、使用默认密钥的授权以及使用凭证进行授权，以限制API访问仅限于真正的用户。我们还讨论了如何使用Postman测试和验证这些安全措施。
- en: 'The following screenshot depicts one such scenario (Authorization with a default
    key) and how we validate access using a default security key:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图描述了一个这样的场景（使用默认密钥的授权）以及我们如何使用默认安全密钥验证访问：
- en: '![](img/d96067ed-c4e1-46a8-862e-be25b2e07cf1.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d96067ed-c4e1-46a8-862e-be25b2e07cf1.png)'
- en: Understanding authorization and OAuth2 schemes
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解授权和OAuth2方案
- en: As we now understand, proving a correct identity is authentication, and allowing
    a specific action by authenticated users is authorization. In this section, we
    will present a brief about OAuth—an industry-standard protocol for authorization
    – along with a few authorization schemes. When we mention the OAuth IETF OAuth
    Working Group ([https://tools.ietf.org/wg/oauth/](https://tools.ietf.org/wg/oauth/))
    in this section, it's OAuth 2.0, which focuses on client-developer simplicity
    (a RESTful principle) while providing specific authorization flows for various
    application use cases such as desktop applications, web applications, mobile phones,
    and even IoT-enabled living room devices.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，证明一个正确的身份是认证，允许经过认证的用户执行特定操作是授权。在本节中，我们将简要介绍OAuth——一个行业标准的授权协议——以及一些授权方案。当我们在本节中提到OAuth
    IETF OAuth工作组([https://tools.ietf.org/wg/oauth/](https://tools.ietf.org/wg/oauth/))时，指的是OAuth
    2.0，它侧重于客户端开发者的简便性（一个RESTful原则），同时为各种应用用例提供特定的授权流程，例如桌面应用程序、Web应用程序、移动电话，甚至物联网（IoT）支持的客厅设备。
- en: 'Before we move on to OAuth 2.0 schemes, let''s understand why you would choose
    OAuth-based authorization over traditional cookie-based authorization with the
    following list:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续介绍OAuth 2.0方案之前，让我们通过以下列表了解为什么你会选择基于OAuth的授权而不是传统的基于Cookie的授权：
- en: Cookie-based authorization is mostly stateful, that is, the server has to keep
    a record of active user sessions. To manage active sessions, the server would
    need multiple database calls to maintain the state. Also, a few other server-side
    overheads make it difficult to decouple the authorization process from the application
    server (to be stateless).
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于Cookie的授权主要是状态性的，也就是说，服务器必须记录活跃用户会话。为了管理活跃会话，服务器需要多次数据库调用以维护状态。此外，一些其他服务器端开销使得将授权过程从应用程序服务器（以无状态的方式）解耦变得困难。
- en: Cookie-based authentication and authorization involve domains, as applications
    may interact with multiple domains, and so the underlying server needs a few additional
    configurations, resulting in maintenance and security overheads.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于Cookie的认证和授权涉及域名，因为应用程序可能与多个域名交互，因此底层服务器需要一些额外的配置，从而导致维护和安全开销。
- en: Integration of third-party clients such as Google+ and Facebook. Authorization
    for the application with cookie-based authorization is not a feasible solution
    in many cases.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成第三方客户端，如Google+和Facebook。在许多情况下，使用基于Cookie的授权对应用程序进行授权不是一个可行的解决方案。
- en: Cookie-based authorization is considered a maintenance nightmare (in some cases,
    such as native mobile apps) and so is not a preferred choice for many applications,
    especially when relying on mobile-based authentication.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于Cookie的授权被认为是一个维护噩梦（在某些情况下，如原生移动应用），因此不是许多应用程序的首选选择，尤其是在依赖基于移动的认证时。
- en: 'OAuth addresses these concerns by allowing arbitrary clients (for example,
    a first-party iOS application or a third-party web application) to access user''s
    (resource owner''s) resources on resource servers via authorization servers with
    secure, reliable, and effective methods:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth通过允许任意客户端（例如，第一方iOS应用程序或第三方Web应用程序）通过授权服务器以安全、可靠和有效的方法访问资源服务器上的用户（资源所有者）的资源来解决这些担忧：
- en: '![](img/ec89ac69-cd08-49ff-9b65-4e2c78a149ea.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ec89ac69-cd08-49ff-9b65-4e2c78a149ea.png)'
- en: The preceding diagram depicts OAuth authorization stakeholders and their roles.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图表描述了OAuth授权的利益相关者和他们的角色。
- en: 'Now, let''s look at a few OAuth 2.0-based authorization schemes and the situations
    or business cases you would choose those specific schemes for, with the following
    table:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看一些基于OAuth 2.0的授权方案以及你可能会选择这些特定方案的情况或业务案例，以下表格展示了这些内容：
- en: '| **Schemes / Flow** | **Client type** | **Brief description** |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| **方案/流程** | **客户端类型** | **简要描述** |'
- en: '| Implicit | **Single-page application** (**SPA**) such as Google Fonts. |
    Application requests access tokens from the gateway and the user grants permission
    |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| 隐式 | **单页应用**（如Google Fonts） | 应用请求网关的访问令牌，用户授予权限 |'
- en: '| Client-credentials | Machine-to-machine non-interactive programs such as
    services, daemons, and so on | The application passes the client credentials and
    gets the access token from the gateway server |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| 客户端凭据 | 机器到机器的非交互式程序，如服务、守护进程等 | 应用将客户端凭据传递给网关服务器并获取访问令牌 |'
- en: '| Authorization code | Less trusted apps (third-party apps requesting access
    to your application) | The application sends a temporary authorization code it
    receives from the gateway and gets it validated (by the same gateway) |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| 授权码 | 不太可信的应用（第三方应用请求访问你的应用） | 应用发送从网关接收到的临时授权码，并由同一网关进行验证 |'
- en: '| Resource owner password credentials | Highly trusted apps (first-party apps)
    | The client will ask the user for their authorization credentials (usually a
    username and password), then the client sends a few parameters (`grant_type`,
    `client_id`, `client_secret`) to the authorization server |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| 资源所有者密码凭证 | 高度可信的应用（第一方应用） | 客户端将请求用户授权凭据（通常是用户名和密码），然后客户端发送一些参数（`grant_type`、`client_id`、`client_secret`）到授权服务器
    |'
- en: As part of this chapter, we have provided OAuth 2.0 example code that implements
    the **Resource Owner** password credentials flow and is available on GitHub for
    anyone to download and execute.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 作为本章的一部分，我们提供了实现**资源所有者**密码凭证流的OAuth 2.0示例代码，该代码可在GitHub上供任何人下载和执行。
- en: 'The following diagram depicts the typical sequence of a resource owner password
    credential OAuth scheme, before we move to the section that explains how to run
    that example code:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表描述了资源所有者密码凭证OAuth方案的标准流程，在我们进入解释如何运行该示例代码的部分之前：
- en: '![](img/af08c287-fef1-4dfd-850a-f9aeeb3d5aa4.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/af08c287-fef1-4dfd-850a-f9aeeb3d5aa4.png)'
- en: 'The following steps and a few screenshots of the Postman tool will be useful
    if you want to run and test that example code on your system:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在你的系统上运行和测试那个示例代码，以下步骤和一些Postman工具的截图将会很有用：
- en: Download the code from GitHub (you may want to refer to the *Technical requirement*
    section [Chapter 3](bdb7c23e-8c80-4a89-af31-e40d1b4c1d36.xhtml), *Essential RESTful
    API Patterns*).
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从GitHub下载代码（你可能需要参考第3章的*技术要求*部分[Chapter 3](bdb7c23e-8c80-4a89-af31-e40d1b4c1d36.xhtml)，*Essential
    RESTful API Patterns*)。
- en: Open the Terminal and `cd` to `downloaded_loc/Hands-On-RESTful-API-Design-Patterns-and-Best-Practices\Chapter06\oauth2-sample`.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并使用`cd`命令进入`downloaded_loc/Hands-On-RESTful-API-Design-Patterns-and-Best-Practices\Chapter06\oauth2-sample`。
- en: Run `mvn clean install` and wait for the `BUILD SUCCESS` message.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`mvn clean install`并等待`BUILD SUCCESS`消息。
- en: Run the application by running the `java -jar target\ oauth2-sample-0.0.1-SNAPSHOT.jar` command.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`java -jar target\ oauth2-sample-0.0.1-SNAPSHOT.jar`命令运行应用程序。
- en: Open the local Postman tool and test the URLs (in the `Chapter06` folder of
    Postman collections).
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开本地Postman工具并测试URL（在Postman集合的`Chapter06`文件夹中）。
- en: you will see the following screenshots when you run the different scenarios.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你运行不同的场景时，你会看到以下截图。
- en: Try error conditions and other scenarios as well (by providing incorrect credentials,
    user credentials instead of admin credential, and so on).
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试错误条件和其它场景（例如提供错误的凭据，使用用户凭据而不是管理员凭据等）。
- en: 'Run the sample with the `java -jar` command:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`java -jar`命令运行示例：
- en: '![](img/6e0f85e6-0756-4eb2-ba5e-273f31769792.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6e0f85e6-0756-4eb2-ba5e-273f31769792.png)'
- en: 'Wait for the local server to start and be ready to accept requests:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待本地服务器启动并准备好接受请求：
- en: '![](img/6eacd0e4-1cfd-49eb-8b0b-555ed7190353.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6eacd0e4-1cfd-49eb-8b0b-555ed7190353.png)'
- en: 'Open the Postman tool, run the collections in the `Chapter06` folder, and observe
    the client credentials (required for the Authorization server):'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Postman工具，运行`Chapter06`文件夹中的集合，并观察客户端凭据（对于授权服务器是必需的）：
- en: '![](img/f6c06887-3630-436f-929a-16db396bf8b2.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f6c06887-3630-436f-929a-16db396bf8b2.png)'
- en: 'Now enter user credentials for the Authorization server to provide the necessary
    token:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在输入授权服务器的用户凭据以提供必要的令牌：
- en: '![](img/873d65ba-5ad2-401b-933d-13b96175b8f4.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](img/873d65ba-5ad2-401b-933d-13b96175b8f4.png)'
- en: 'Get the access-token from the Authorization server so that we can use it to
    access the necessary resources in the next step:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从授权服务器获取访问令牌，以便我们可以在下一步中使用它来访问必要的资源：
- en: '![](img/145b19ac-494c-4183-84d8-b1921d3173fb.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](img/145b19ac-494c-4183-84d8-b1921d3173fb.png)'
- en: 'Use the access token that we got in the last step and access the admin (resource)
    API. Notice the response body:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用我们在上一步中获得的访问令牌访问管理员（资源）API。注意响应体：
- en: '![](img/927e0519-6a19-438a-813d-b78748f0fb87.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/927e0519-6a19-438a-813d-b78748f0fb87.png)'
- en: 'Repeat the same steps for user resources with the necessary user credentials
    (notice the user name in the input):'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用必要的用户凭据对用户资源重复相同的步骤（注意输入中的用户名）：
- en: '![](img/70aa2a4c-6608-450b-bc80-17c61193a6dc.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](img/70aa2a4c-6608-450b-bc80-17c61193a6dc.png)'
- en: So, you can execute different scenarios (not provided as part of this chapter)
    such as error messages and different HTTP error codes (`403`, `302`, and so on)
    with the sample code.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可以使用示例代码执行不同的场景（本章节未提供），例如错误消息和不同的HTTP错误代码（`403`、`302`等）。
- en: Cross-site scripting
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跨站脚本
- en: A **Cross-site scripting** (**XSS**) attack is the process of injecting malicious
    code as part of the input to web services, usually through a browser. Once injected,
    the malicious script can access any cookies, session tokens, and sensitive information
    retained by the browser, and can even masquerade as the content of the rendered
    pages. XSS can be categorized into server-side XSS and client-side XSS.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**跨站脚本**（**XSS**）攻击是将恶意代码作为输入注入到网络服务的过程，通常通过浏览器进行。一旦注入，恶意脚本可以访问浏览器保留的任何cookies、会话令牌和敏感信息，甚至可以伪装为渲染页面的内容。XSS可以分为服务器端XSS和客户端XSS。'
- en: 'Traditionally, XSS is one of three types:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，XSS是三种类型之一：
- en: Reflected XSS
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反射型XSS
- en: Stored XSS
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储型XSS
- en: DOM XSS
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DOM XSS
- en: 'An exciting read about stored XSS on the word-press REST API defect can be
    found here: [https://threatpost.com/wordpress-rest-api-bug-could-be-used-in-stored-xss-attacks/124294/](https://threatpost.com/wordpress-rest-api-bug-could-be-used-in-stored-xss-attacks/124294/) and
    here: [https://threatpost.com/wordpress-silently-fixed-privilege-escalation-vulnerability-in-4-72-update/123533/](https://threatpost.com/wordpress-silently-fixed-privilege-escalation-vulnerability-in-4-72-update/123533/).'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 关于WordPress REST API缺陷中存储型XSS攻击的精彩阅读，请在此处找到：[https://threatpost.com/wordpress-rest-api-bug-could-be-used-in-stored-xss-attacks/124294/](https://threatpost.com/wordpress-rest-api-bug-could-be-used-in-stored-xss-attacks/124294/) 以及在此处：[https://threatpost.com/wordpress-silently-fixed-privilege-escalation-vulnerability-in-4-72-update/123533/](https://threatpost.com/wordpress-silently-fixed-privilege-escalation-vulnerability-in-4-72-update/123533/)。
- en: Reflected XSS
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反射型XSS
- en: Successful reflected cross-site scripting happens when an application allows
    an attacker to inject browser-executable code (such as JavaScript, Applets, Action
    Scripts, Flash) within a single HTTP response. You may be aware the injected code
    is non-persistent and impacts the users only when they open the maliciously crafted
    link or URL or third-party web page that renders the affected response.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 成功的反射型跨站脚本攻击发生在应用程序允许攻击者在一个HTTP响应中注入浏览器可执行代码（如JavaScript、Applets、Action Scripts、Flash）时。你可能知道，注入的代码是非持久的，并且只有在用户打开恶意构建的链接或URL或渲染受影响响应的第三方网页时才会影响用户。
- en: Stored XSS
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储型XSS
- en: Stored XSS, also known as persistent XSS, often considered harmful and high
    risk, occurs when a malicious script is injected into a vulnerable application
    as input and is viewed by another user or an administrator at a later time.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 存储型XSS，也称为持久型XSS，通常被认为是有害且风险高，发生在恶意脚本作为输入注入到易受攻击的应用程序中，并在稍后由其他用户或管理员查看。
- en: DOM XSS
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DOM XSS
- en: The third type (developed by Amit Klein and available since 2005), DOM XSS,
    occurs when client-side code uses insecure references to DOM objects that are
    not entirely controlled by server-provided pages. Generally, but not limited to,
    APIs that dynamically inject attacker-controllable data to a page and JavaScript
    frameworks. Single-page applications are vulnerable to DOM XSS.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种类型（由Amit Klein开发，自2005年以来可用），DOM XSS，发生在客户端代码使用不安全的引用到不由服务器提供的页面完全控制的DOM对象时。通常，但不限于，动态向页面注入攻击者可控制数据的API和JavaScript框架。单页应用程序容易受到DOM
    XSS攻击。
- en: XSS protection needs to filter malicious content from user input and also needs
    encoding (escape).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: XSS防护需要从用户输入中过滤恶意内容，并且还需要进行编码（转义）。
- en: Cross-site request forgery
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跨站请求伪造
- en: '**Cross-site request forgery** (**CSRF**), Sea Surf, or XSRF, as it''s known,
    is a one-click attack vulnerability that web applications exposes the possibility
    of the end user being forced (by forged links, emails, and HTML pages) to execute
    unwanted actions on a currently authenticated session.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**跨站请求伪造**（**CSRF**），也称为Sea Surf或XSRF，是一种一键攻击漏洞，Web应用程序暴露了最终用户可能被强制（通过伪造链接、电子邮件和HTML页面）在当前已认证会话中执行不受欢迎的操作的可能性。'
- en: The synchronize token pattern, cookie-to-header token, double submit cookie,
    and client-side safeguards are common CSRF prevention methodologies.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 同步令牌模式、Cookie到Header令牌、双重提交Cookie和客户端保护是常见的CSRF预防方法。
- en: Denial-of-service attack
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拒绝服务攻击
- en: A **denial-of-service** (**DoS**) attack is intended to make the targeted machine
    reach its maximum load (capacity to serve requests) quickly by sending numerous
    false requests so the target system denies further genuine requests.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**拒绝服务**（**DoS**）攻击的目的是通过发送大量虚假请求，使目标机器快速达到其最大负载（处理请求的能力），从而使目标系统拒绝进一步的真实请求。'
- en: Flood attacks and buffer overflow attacks are two categories of DoS. With flood
    attacks, the attacker saturates the target server by generating enormous traffic
    to the server, causing the target server to end up in DoS.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 洪水攻击和缓冲区溢出攻击是两种拒绝服务（DoS）攻击类型。在洪水攻击中，攻击者通过向服务器生成大量流量来饱和目标服务器，导致目标服务器最终陷入DoS状态。
- en: On the other hand, a buffer overflow attack is intended to target a machine
    and make that machine consume all available memory or hard disk space, or cause
    high usage of the CPU. This result in various consequences, such as the system
    becoming slow to respond or sluggish in its behavior, and there may even be a
    situation in which the targeted system will crash, creating potentially catastrophic
    results.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，缓冲区溢出攻击的目的是针对一台机器，并使该机器消耗所有可用内存或硬盘空间，或者导致CPU使用率过高。这会导致各种后果，如系统响应缓慢或行为迟钝，甚至可能导致目标系统崩溃，造成潜在的灾难性后果。
- en: Please note that, generally, DoS attacks happen on networks where the malicious
    user (attacker) has more available bandwidth than the target server. Smurf attacks,
    ping floods, and ping of death attacks are some actual DoS attacks.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，通常，DoS攻击发生在恶意用户（攻击者）具有比目标服务器更多可用带宽的网络中。Smurf攻击、ping洪水和ping of death攻击是一些实际的DoS攻击。
- en: Distributed denial of service
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分布式拒绝服务
- en: DoS attacks on distribution systems are known as **distributed denial of service**
    (**DDoS**) attacks. DDoS attacks achieve success by employing multiple compromised
    computer systems, including network resources such as IoT devices, as sources
    of attack traffic.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式系统上的DoS攻击被称为**分布式拒绝服务**（**DDoS**）攻击。DDoS攻击通过使用多个被入侵的计算机系统作为攻击流量源，包括网络资源如物联网设备，来实现成功。
- en: Injection attacks
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注入攻击
- en: One of the most harmful and dangerous attacks is an injection attack. The attacker
    supplies untrusted input to the application, which gets executed/processed as
    a part of a command or query, thus resulting in the partial or complete discourse
    of the application behavior and leading to consequences such as data theft, data
    loss, loss of data integrity, and DoS. It can even lead to full-system compromise.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 最有害和最危险的攻击之一是注入攻击。攻击者向应用程序提供不受信任的输入，该输入作为命令或查询的一部分被执行/处理，从而导致应用程序行为的部分或完全失控，并导致诸如数据盗窃、数据丢失、数据完整性丢失和DoS等后果。它甚至可能导致整个系统被完全控制。
- en: 'The following table captures a few common injection attack types, brief descriptions
    for each, and their potential impact:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 下表总结了几个常见的注入攻击类型、每种类型的简要描述及其潜在影响：
- en: '| **Type of Injection** | **A brief description** | **Potential impacts** |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| **注入类型** | **简要描述** | **潜在影响** |'
- en: '| Code injection/OS command injection | Execute operating system commands with
    application code | Gains higher privileges with higher privilege escalation vulnerabilities
    and lead to full-system compromise |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| 代码注入/操作系统命令注入 | 使用应用程序代码执行操作系统命令 | 利用更高权限的漏洞获得更高权限，并可能导致整个系统被完全控制 |'
- en: '| CRLF injection | Injects an EOL/carriage return character in an input sequence
    | Results in splitting the HTTP header to facilitate arbitrary content injection
    in the response body, including XSS |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| CRLF注入 | 在输入序列中注入EOL/回车字符 | 导致HTTP头部分割，便于在响应体中注入任意内容，包括XSS |'
- en: '| Email (Mail command/SMTP) injection | Injects IMAP/SMTP statements to a mail
    server | Personal information disclosure and relay of SPAM emails |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| 电子邮件（邮件命令/SMTP）注入 | 向邮件服务器注入IMAP/SMTP语句 | 个人信息泄露和垃圾邮件中继 |'
- en: '| Host header injection | Abuses the trust of the HTTP Host Header by dynamically
    generating headers based on user input | Cache poisoning—manipulates the caching
    system and serves malicious pagesPassword reset poisoning—exploits with password
    reset email and delivers malicious content directly to the target |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| 主机头注入 | 通过根据用户输入动态生成头信息滥用HTTP Host头信任 | 缓存投毒——操纵缓存系统并服务恶意页面密码重置投毒——利用密码重置电子邮件并直接向目标发送恶意内容
    |'
- en: '| LDAP injection | Injects **Lightweight Directory Access Protocol** (**LDAP**)
    statements and executes them | Modifies contents of LDAP tree and grants illegitimate
    permissions, privilege escalations, and bypass authentication |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| LDAP注入 | 注入并执行**轻量级目录访问协议**（**LDAP**）语句 | 修改LDAP树的内容并授予非法权限、权限提升和绕过身份验证 |'
- en: '| SQL injection | Injects fabricated SQL commands to exercise database read
    or modify data | Leads to data loss, data theft, data integrity loss, DoS, and
    can even result in full system compromise due to advanced variations of SQL injections
    |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| SQL注入 | 注入伪造的SQL命令以执行数据库读取或修改数据 | 导致数据丢失、数据盗窃、数据完整性丢失、DoS，甚至由于SQL注入的高级变体而导致完全系统妥协
    |'
- en: '| XPath injection | Executes fabricated XPath queries by injecting false data
    into an application | Results in information disclosure and bypass authentication
    |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| XPath注入 | 通过向应用程序注入虚假数据执行伪造的XPath查询 | 导致信息泄露和绕过身份验证 |'
- en: Insecure direct object references
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不安全的直接对象引用
- en: '**Insecure direct object references** (**IDOR**) are equally as harmful as
    the other top API vulnerabilities; they occur when an application exposes direct
    access to internal objects based on user inputs such as ID and filename.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '**不安全的直接对象引用**（**IDOR**）与其他顶级API漏洞一样有害；它们发生在应用程序根据用户输入（如ID和文件名）暴露对内部对象的直接访问时。'
- en: Let's look at a quick example of IDOR with the following diagram. In it, Bob
    is getting his file having ID 1001 from the app does make sense, but what about
    he is getting Alice's document with ID **1003**?
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下图例快速了解IDOR。在图中，鲍勃从应用程序中获取ID为1001的文件是有意义的，但他是如何获取ID为**1003**的爱丽丝的文档的呢？
- en: '![](img/b802c14b-e9af-4981-8b73-edda25649ccf.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b802c14b-e9af-4981-8b73-edda25649ccf.png)'
- en: A direct object reference is happening, as the developer exposed a reference
    to an internal implementation object – here, in the preceding example, it is a
    file (an object reference may be a directory, an image file, a database key, and
    so on) – with the application.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 正在发生直接对象引用，因为开发者暴露了对内部实现对象的引用——在这里，在先前的示例中，它是一个文件（对象引用可能是一个目录、图像文件、数据库键等）——与应用程序。
- en: So, not having a validation mechanism, allowing Bob (the attacker) to manipulate
    these references to access unauthorized data is called an IDOR vulnerability.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，没有验证机制，允许鲍勃（攻击者）操纵这些引用以访问未经授权的数据被称为IDOR漏洞。
- en: One can test for IDOR vulnerabilities by mapping out all of the endpoints where
    the user input is a direct reference (as depicted in the example diagram) and
    used as a reference object. Its always recommended two ore more users to cover
    direct objects and functions.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过绘制所有用户输入作为直接引用（如图例所示）并用作引用对象的端点来测试IDOR漏洞。始终建议有两个或更多用户来覆盖直接对象和函数。
- en: Missing function-level access control
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缺少函数级访问控制
- en: Another aspect of IDOR is missing functional level access rights. The application
    might have missed implementing function-level access rights, and so anyone with
    network access will be able to send a request and get a response rather than just
    the specific user who has privileges. For instance, an admin URL should not be
    available to a user who does not have admin-level access rights.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: IDOR的另一个方面是缺少功能级访问权限。应用程序可能遗漏了实现功能级访问权限，因此任何具有网络访问权限的人都可以发送请求并获得响应，而不仅仅是具有特权的特定用户。例如，没有管理员级别访问权限的用户不应能够访问管理员URL。
- en: APIs with insufficient protection for sensitive request handlers within an application
    fall into the category of missing functional-level access rights vulnerability,
    and so allow hackers to penetrate the application without the necessary authorization.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序中敏感请求处理程序缺乏保护的API属于缺少功能级访问权限漏洞的范畴，因此允许黑客在没有必要授权的情况下渗透应用程序。
- en: Testing aspects of this vulnerability should focus on two essential scenarios—whether
    the user can directly browse a resource, and whether the UI accessing the API
    resources expose an unauthorized resource to that UI.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 测试这种漏洞的各个方面应侧重于两个基本场景——用户是否可以直接浏览资源，以及访问API资源的UI是否向该UI暴露了未经授权的资源。
- en: Man-in-the-middle attacks
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中间人攻击
- en: 'An MITM attack is an attack by a perpetrator who has placed themself in the
    middle of a network or communication between a genuine user and an application
    server. They intend to steal, eavesdrop on, impersonate and secretly relay, intercept,
    or alter communications, including API messages, between two communicating parties,
    all while it appears as though a normal exchange of information is underway:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 中间人攻击（MITM attack）是指攻击者将自己置于网络或用户与应用服务器之间的通信中间。他们的意图是窃取、监听、伪装、秘密中继、拦截或篡改两个通信方之间的通信，包括API消息，而这一切都表现得像正常的信息交换正在进行中：
- en: '![](img/6fa3b6d9-a6d1-42c4-95c0-6c8c79383708.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6fa3b6d9-a6d1-42c4-95c0-6c8c79383708.png)'
- en: The preceding diagram depicts a typical MITM attack, where the eavesdropper
    impersonates and relays communications/responses to the caller as they come from
    the server, and they will appear genuine.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图示了一个典型的中间人攻击，其中窃听者模仿并转发通信/响应给呼叫者，就像它们来自服务器一样，它们将看起来是真实的。
- en: An example of an MITM attack could be communication between an API that issues
    a session token as part of an HTTP header and a perpetrator acting as a man in
    the middle between the user's browser and the HTTP header (session token). So,
    it's easy to intercept that session token as it opens up access to the user's
    account, then the damage can be done depending on that account's privileges.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 中间人攻击的一个例子可能是发出会话令牌的API与充当用户浏览器和HTTP头（会话令牌）之间中间人的攻击者之间的通信。因此，拦截那个会话令牌很容易，因为它打开了访问用户账户的通道，然后根据该账户的权限进行破坏。
- en: Common types of MITM attacks and protection measures
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见的中间人攻击类型和防护措施
- en: 'There are a few common MITM attacks, as found in the following list, that you
    need to be aware of, and also a few protection measures against those attacks:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下列表中，有一些常见的中间人攻击类型，你需要意识到，还有一些针对这些攻击的防护措施：
- en: '**Sniffing**: Sniffing, also known as packet sniffing, in which attackers use
    widely/freely available packet capture tools by using specific wireless devices
    to inspect and monitor packets communicated over a network.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**嗅探**：嗅探，也称为数据包嗅探，其中攻击者使用广泛/免费的数据包捕获工具，通过特定的无线设备检查和监控通过网络通信的数据包。'
- en: '**Packet injection**: Injecting malicious packets into data communication streams
    in such a way that they blend in with valid data streams and appear as part of
    the original/intended communication.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据包注入**：以这种方式将恶意数据包注入数据通信流中，使其与有效数据流混合，并看起来像是原始/预期通信的一部分。'
- en: '**SSL stripping**: Altering HTTPS network communication to HTTP on the fly
    and making the communication insecure is another form of MITM attack (the user
    may not even realize that they are redirected to unsecured endpoints) and, leaking
    sensitive information as plain text, which attackers get onto it quickly.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SSL剥离**：在运行中将HTTPS网络通信更改为HTTP，使通信不安全，这是另一种中间人攻击形式（用户甚至可能没有意识到他们被重定向到不安全的端点），并且以明文形式泄露敏感信息，攻击者可以迅速获取这些信息。'
- en: '**Email hijacking**: A very common type of MITM attack, in which attackers
    mimic a trusted site (for example, a bank''s website) send an email with instructions
    to the targeted account and convinces the account holder to follow the instructions
    in the email, resulting in the catastrophic effect of losing their money/personal
    information and so on.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**电子邮件劫持**：这是一种非常常见的中间人攻击类型，攻击者模仿一个受信任的网站（例如，银行的网站）向目标账户发送带有指示的电子邮件，并说服账户持有人遵循电子邮件中的指示，从而导致灾难性的后果，如失去金钱/个人信息等。'
- en: '**Wi-Fi eavesdropping**: This involves setting up exclusive Wi-Fi access points
    to lure users to get connected and make them use the network. Once the user is
    connected to those Wi-Fi access points, attackers will intercept and gain their
    credentials, credit card information, and much more sensitive information.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Wi-Fi 间谍活动**：这涉及到设置专用的 Wi-Fi 访问点来诱使用户连接并让他们使用该网络。一旦用户连接到这些 Wi-Fi 访问点，攻击者将拦截并获取他们的凭据、信用卡信息以及更多敏感信息。'
- en: '**Session hijacking**: Once the user logs in to an application with their credentials,
    the application will generate a temporary token so that user does not need to
    provide credentials again to access subsequent pages. However, an attacker can
    sniff and pick up that session token and use it to gain access to the user''s
    account.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**会话劫持**：一旦用户使用他们的凭据登录到应用程序，应用程序将生成一个临时令牌，这样用户就不需要再次提供凭据来访问后续页面。然而，攻击者可以嗅探并捕获那个会话令牌，并使用它来获取对用户账户的访问权限。'
- en: '**Protection measures**: Protection against MITM attacks are as follow:'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**防护措施**：防止中间人攻击的防护措施如下：'
- en: '**Secure/Multipurpose Internet Mail Extensions** (**S/MIME**)'
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全/多用途互联网邮件扩展**（**S/MIME**）'
- en: '**Public key infrastructure** (**PKI**) based authentication certificates'
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于公钥基础设施**（**PKI**）的认证证书'
- en: SSL/TLS certificates
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: SSL/TLS 证书
- en: System and server configurations
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统和服务器配置
- en: '**HTTP Strict Transport Security** (**HSTS**)'
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HTTP 严格传输安全**（**HSTS**）'
- en: Replay attacks and spoofing
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重放攻击和欺骗
- en: 'Replay attacks, also known as playback attacks, are network attacks in which
    valid data transmissions (supposed to be once only) are repeated many times (maliciously)
    by the attacker who spoofed the valid transaction. While a server is expecting
    a valid transaction, it will not have any doubts as to whether requests are valid
    transactions. However, these are a masqueraded request and lead to catastrophic
    effects for clients:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 重放攻击，也称为回放攻击，是一种网络攻击，其中攻击者（欺骗了有效交易）恶意多次重复（多次）有效的数据传输（本应只发生一次）。当服务器期望一个有效的交易时，它不会对请求是否为有效交易有任何怀疑。然而，这些是伪装的请求，对客户端产生灾难性的影响：
- en: '![](img/9b1355a7-fbcf-4228-970c-0af52e8f450c.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9b1355a7-fbcf-4228-970c-0af52e8f450c.png)'
- en: The previous diagram depicts a replay attack example where the legitimate user
    sends a valid request, but the attacker spoofs it and resends/replays it to the
    APIs.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张图展示了重放攻击的示例，其中合法用户发送了一个有效的请求，但攻击者欺骗了它并重新发送/重放给 API。
- en: As RESTful APIs are stateless, the chances of getting those APIs into replay
    attacks are high (they're an easy target). So, it is evident that API designers/developers
    need to have countermeasures in their APIs for all replay attacks. Protection
    measures include a one-time password with session identifiers, **time-to-live**
    (**TTL**) measures, MAC implementation on the client side, and including timestamps
    in requests, along with secure protocol such as Kerberos protocol prevention,
    secure routing, and the **challenge-handshake authentication protocol** (**CHAP**).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 RESTful API 无状态，这些 API 被重放攻击的风险很高（它们是易受攻击的目标）。因此，很明显，API 设计师/开发者需要在他们的 API
    中为所有重放攻击采取对策。防护措施包括带有会话标识符的一次性密码、**生存时间**（**TTL**）措施、客户端上的 MAC 实现，以及在请求中包含时间戳，以及像
    Kerberos 协议预防、安全路由和**挑战-握手认证协议**（**CHAP**）这样的安全协议。
- en: Causes of vulnerabilities
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 漏洞原因
- en: As we have looked at a few of the vulnerabilities in the previous section, let's
    also familiarize ourselves with a few common concerns and issues that cause APIs
    to be vulnerable to various attacks in the following paragraphs.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一小节所述，我们已经查看了一些漏洞，现在让我们也熟悉一下以下段落中导致 API 易受各种攻击的一些常见担忧和问题。
- en: API design and development flaws
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API 设计和开发缺陷
- en: Missing or not adhering to API security principles and best practices may lead
    to defects that expose business-critical data. Another aspect of design and development
    is to keep APIs as simple as possible, as complexity may lead to less coverage
    and vulnerability. Poor user input validation, SQL injection loopholes, and buffer
    overflows are a few other causes.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 缺少或不遵守 API 安全原则和最佳实践可能导致暴露业务关键数据的缺陷。设计和开发的一个方面是尽可能简化 API，因为复杂性可能导致覆盖范围减少和漏洞。较差的用户输入验证、SQL
    注入漏洞和缓冲区溢出是其他一些原因。
- en: '[Chapter 2](edae86df-d90e-4b4c-9ada-4de80edaef71.xhtml)*, Design Strategy,
    Guidelines, and Best Practices*, discussed various aspects of design strategies
    and RESTful API design practices. Understanding and implementing those design
    principles and practices in APIs helps reduce design and development flaws.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '[第二章](edae86df-d90e-4b4c-9ada-4de80edaef71.xhtml)*，设计策略、指南和最佳实践*，讨论了设计策略和RESTful
    API设计实践的各个方面。理解和实施这些设计原则和实践有助于减少设计和开发缺陷。'
- en: Poor system configuration
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 系统配置不良
- en: Even the best design and development is not necessarily enough to safeguard
    a system if the system configurations (where the APIs are) do not adhere to security
    compliance. This will also lead to loopholes and attackers stealing information.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 即使设计和发展得再好，如果系统配置（API所在位置）不遵守安全合规性，那么系统也可能无法得到充分保护。这也会导致漏洞，攻击者会窃取信息。
- en: Human error
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 人类错误
- en: Non-adherence to organization security compliance and inadequate knowledge of
    security measures such as document-shredding policies, secure coding practices,
    strong passwords, maintaining the confidentiality of passwords, periodical resetting
    passwords, and preventing access to unknown/unsecured sites creates loopholes
    in the API that can lead to security breaches.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 不遵守组织安全合规性以及缺乏对安全措施的了解，例如文件销毁政策、安全编码实践、强密码、维护密码的机密性、定期重置密码以及防止访问未知/不安全的网站，这些都会在API中造成漏洞，可能导致安全漏洞。
- en: Internal and external connectivity
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内部和外部连接性
- en: As APIs are part of unsecured internal and external networks, the connectivity
    of APIs in an unsecured network is another major cause of vulnerability. Also,
    APIs' exposure to large and unique channels, such as mobile networks, poor risk
    management, and lenient authorization practices within a network are a few examples
    from this category of vulnerability.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 由于API是未受保护的内网和外网的一部分，因此未受保护网络中API的连接性是造成漏洞的另一个主要原因。此外，API暴露于大型和独特的渠道，如移动网络、风险管理不善以及网络内的宽松授权实践等，都是这一类别漏洞的例子。
- en: Security tests
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全测试
- en: Security tests ensure APIs are secure from external threats and protected from
    the vulnerabilities that we have discussed in earlier sections. The primary focus
    of API security tests and security testers is to find the vulnerabilities of the
    API they intend to test by running penetration tests, fuzz tests, validations,
    sensitive data exposure determination, and so on.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 安全测试确保API免受外部威胁，并保护我们之前章节中讨论的漏洞。API安全测试和安全测试人员的主要重点是通过对API进行渗透测试、模糊测试、验证、敏感数据泄露确定等操作，找出他们打算测试的API的漏洞。
- en: Security functional testing and security vulnerability testing are two categories
    of security tests. A functional test executes manual tests and manually checks
    for the presence of security mechanisms within API's implementation. Security
    vulnerability tests execute automated test cases that may expose vulnerabilities.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 安全功能测试和安全漏洞测试是安全测试的两个类别。功能测试执行手动测试，并手动检查API实现中是否存在安全机制。安全漏洞测试执行可能暴露漏洞的自动化测试用例。
- en: The ultimate goal of the tester should be to understand the system behavior
    by studying error messages and expose any security vulnerability such as gaining
    unauthorized access, IDOR, MITM, and replay attacks.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 测试人员的最终目标应该是通过研究错误信息来理解系统行为，并暴露任何安全漏洞，例如未经授权的访问、IDOR、中间人攻击和重放攻击。
- en: You can fulfil security test goals by running penetration tests and fuzz tests
    along with various manual tests.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过运行渗透测试和模糊测试以及各种手动测试来实现安全测试目标。
- en: This section discusses penetration tests and fuzz tests in detail and also discusses
    the tools/frameworks that provide out-of-the-box support for security tests so
    that API testers can make use of tools to get security assurance for underlying
    APIs.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 本节详细讨论渗透测试和模糊测试，并讨论提供现成安全测试支持的工具/框架，以便API测试人员可以利用工具为底层API获得安全保障。
- en: Penetration tests or pen tests
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渗透测试或pen tests
- en: One of the imperatives in API testing is penetration tests, also known as pen
    tests. Pen tests are the process of simulating cyber attack against a the system
    or API to expose/determine exploitable vulnerabilities such as intra-network loopholes,
    XSS attacks, SQL injections, and code-injection attacks.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: API测试中的一个强制性要求是渗透测试，也称为pen tests。pen tests是通过模拟对系统或API的网络安全攻击来暴露/确定可利用的漏洞的过程，例如内部网络漏洞、XSS攻击、SQL注入和代码注入攻击。
- en: Pen tests asses the threat vector from an external standpoint, such as supported
    functions, available resources, and the API's internal components as well.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 突破测试从外部角度评估威胁向量，例如支持的功能、可用的资源以及API的内部组件。
- en: Let's discuss more details about pen testing—its stages, testing methods, frameworks
    that support pen testing, and a few criteria for selecting the best penetration
    tool in the following sections.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地讨论突破测试的各个阶段、测试方法、支持突破测试的框架，以及选择最佳渗透工具的一些标准。
- en: Importance of penetration tests
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 突破测试的重要性
- en: 'Before we delve into the details, the following rationalizations will help
    us understand why pen tests are so crucial in API testing:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入细节之前，以下理由将帮助我们理解为什么突破测试在API测试中如此关键：
- en: No compromise to data privacy
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不损害数据隐私
- en: Guaranteed and secured financial transactions and financial data over the network
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保网络上的金融交易和金融数据的安全
- en: Discover security vulnerabilities and loopholes in APIs and in underlying systems
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发现API和底层系统中的安全漏洞和漏洞
- en: Simulate, forecast, understand, and assess the impacts of attacks
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟、预测、理解和评估攻击的影响
- en: Make APIs fully information security compliant
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使API完全符合信息安全规范
- en: Pen testing lifecycle
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 突破测试生命周期
- en: 'Now that we have a good understanding of vulnerability causes from the earlier
    section, let''s look at the five stages of pen tests in this section:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经从前面的部分很好地理解了漏洞的原因，让我们在本节中看看突破测试的五个阶段：
- en: '![](img/184aeeb9-4c31-43a2-b458-63f044b39990.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/184aeeb9-4c31-43a2-b458-63f044b39990.png)'
- en: The preceding diagram depicts the life cycle of pen tests, involving five phases
    of activities such as Preparation, **Scanning**, **Gaining Access** and **Maintaining
    Access**, and reporting.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图表描述了突破测试的生命周期，包括准备、**扫描**、**获取访问权限**、**维护访问权限**和报告等五个活动阶段。
- en: Let's look at each phase in more detail in the following sections.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地探讨以下各阶段。
- en: Preparation, planning, and reconnaissance
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备、计划和侦察
- en: 'The first phase of the life cycle involves the following two parts:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 生命周期第一阶段包括以下两个部分：
- en: Scope, scope definitions, defining the goals of the tests to be carried out,
    and defining the testing methods and systems to be addressed
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 范围、范围定义、确定要进行的测试目标，以及确定要处理的测试方法和系统
- en: Gathering intelligence such as the domain and endpoints, and understanding how
    the target API works, along with its exposure to vulnerabilities
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 收集有关域和端点等情报，了解目标API的工作方式，以及其暴露于漏洞的程度
- en: Scanning
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扫描
- en: Understanding the target application's response to various intrusion attempts
    with static and dynamic analysis is the focus of the **Scanning** phase.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 通过静态和动态分析了解目标应用程序对各种入侵尝试的反应是**扫描**阶段的重点。
- en: Gaining access
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取访问权限
- en: This involves attempting to uncover API vulnerabilities with application attacks
    such as XSS, SQL injections, code injections, and backdoors. Once those vulnerabilities
    are uncovered, exploiting them with privilege escalations, data stealing methods,
    and traffic interceptions are part of the **Gaining Access** scope, as well as
    assessing the damage that API vulnerability could cause.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这涉及尝试通过诸如XSS、SQL注入、代码注入和后门等应用程序攻击来揭露API漏洞。一旦发现这些漏洞，利用它们进行权限提升、数据窃取方法和流量拦截是**获取访问权限**范围的一部分，以及评估API漏洞可能造成的损害。
- en: Maintaining access
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 维护访问权限
- en: An illicit, long-term intruder presence in a network may cause irreversible
    damage to the system, as they may be present in the system for a long time, which
    facilitates highly sensitive data mining (especially on government, military,
    and financial networks) in steady, well-researched, and meticulously planned attacks.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 网络中非法、长期的入侵者存在可能会对系统造成不可逆转的损害，因为他们可能在系统中存在很长时间，这有助于在持续、经过充分研究和精心策划的攻击中进行高度敏感的数据挖掘（尤其是在政府、军事和金融网络上）。
- en: Assessing the long-term presence abilities, and the chances of them gaining
    in-depth access to systems/APIs is the primary intention of this **Maintaining
    Access** phase.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 评估长期存在的能力，以及他们获得对系统/API的深入访问的机会是**维护访问权限**阶段的主要目标。
- en: Analysis
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析
- en: The final phase of the life cycle focuses on compiling and presenting the results
    of penetration tests as a report. These reports generally contain a specific vulnerability
    that was exploited as part of pen tests, details of compromised/accessed sensitive
    data as part of the pen test exercise, and, most importantly, the duration of
    the time that you were able to remain in the system undetected. These results
    and reports will act as a feed/input security configurations across the organization
    to prevent any future attacks.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 生命周期的最后阶段专注于编译和呈现渗透测试结果作为报告。这些报告通常包含作为渗透测试一部分被利用的特定漏洞，作为渗透测试练习的一部分被损害/访问的敏感数据细节，以及，最重要的是，你在系统中未被检测到的持续时间。这些结果和报告将作为组织内部安全配置的输入/输出，以防止任何未来的攻击。
- en: Pen testing types for API testing
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API测试的渗透测试类型
- en: We discussed the importance of penetration tests in security testing, and APIs
    are no exception; they all need to go through these penetration tests and ensure
    that underlying APIs are not exposing any vulnerabilities. Please note that there
    are three categories of pen tests in practice and they are—black-box pen tests,
    grey-box pen tests, and white-box pen tests.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了渗透测试在安全测试中的重要性，API也不例外；它们都需要经过这些渗透测试，确保底层API没有暴露任何漏洞。请注意，在实际操作中有三种渗透测试类别，它们是——黑盒渗透测试、灰盒渗透测试和白盒渗透测试。
- en: Black-box and grey-box testing assumes testers have only limited knowledge about
    the underlying API. We shall briefly cover white-box testing in this section,
    as it's essential for API security testing, and why it is preferred for API penetration
    tests in the following section.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 黑盒测试和灰盒测试假设测试人员对底层API的了解仅限于有限的范围。在本节中，我们将简要介绍白盒测试，因为它对于API安全测试至关重要，以及为什么在下一节中它被优先用于API渗透测试。
- en: White-box penetration testing
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 白盒渗透测试
- en: White-box testing is also known as **structure-testing**, open-box, clear-box,
    and glass-box testing. The white-box pen test is a comprehensive testing methodology,
    as you get a whole range of information about the schema, source code, models,
    and so on, before starting the testing. White-box tests are intended to scrutinize
    the code and catch any design and development errors. They are simulations of
    internal security attacks.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 白盒测试也称为**结构测试**、**开箱测试**、**透明盒测试**和**玻璃盒测试**。白盒渗透测试是一种全面的测试方法，因为你在开始测试之前就能获得有关模式、源代码、模型等方面的全部信息。白盒测试旨在审查代码并捕捉任何设计和开发错误。它们是内部安全攻击的模拟。
- en: 'API pen tests rely on white-box testing for the following reasons:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: API渗透测试依赖于以下原因进行白盒测试：
- en: The tests run on all of the independent paths of a module
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试将在模块的所有独立路径上运行
- en: The tests confirm and verify all logical decisions (`true`/`false`) inside the
    code
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试确认和验证代码内部的所有逻辑决策（`true`/`false`）
- en: The tests execute syntax checking, and so find typographical errors that are
    critical to finding code injections and SQL injection attacks
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试执行语法检查，因此发现对查找代码注入和SQL注入攻击至关重要的打印错误
- en: The tests find design errors caused by a mismatch of the logical flow of the
    program and the actual execution (design for intent)
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试发现由程序逻辑流程与实际执行不匹配（针对意图的设计）引起的设计错误
- en: 'There are plenty of open source tools available and commercial versions that
    can scan code, check for malicious code, find security loopholes using data encryption
    techniques, and even find hardcoded username and passwords. A few of the tools
    are listed in the following table (both commercial and open source versions):'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多开源工具和商业版本可供扫描代码、检查恶意代码、使用数据加密技术查找安全漏洞，甚至找到硬编码的用户名和密码。以下表格中列出了一些工具（包括商业和开源版本）：
- en: '| **Tool** | **Type** | **Providers** |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| **工具** | **类型** | **提供商** |'
- en: '| Nmap | OpenSSL | Pure Hacking |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| Nmap | OpenSSL | Pure Hacking |'
- en: '| Nessus | Cain and Abel | Torrid Networks |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| Nessus | Cain and Abel | Torrid Networks |'
- en: '| Metasploit | THC Hydra | SecPoint |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| Metasploit | THC Hydra | SecPoint |'
- en: '| Wireshark | w3af | Veracode |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| Wireshark | w3af | Veracode |'
- en: Let's summarize this section by stating that pen tests for APIs should expose
    API vulnerabilities before real attackers find them, and move on to fuzz tests.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过指出API的渗透测试应该在真实攻击者发现之前暴露API漏洞，并继续进行模糊测试来总结本节。
- en: Fuzz tests
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模糊测试
- en: Fuzz testing, also known as fuzzing, is one of the most widely used testing
    practices in the quality assurance phase. It involves massive amounts of random
    data (noise or fuzz) as input to the target system with the intention of targeting
    APIs to exhibit buffer overflow or any other unwanted behaviors, or even to provoke
    the system to crash.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 模糊测试，也称为模糊化，是质量保证阶段最广泛使用的测试实践之一。它涉及向目标系统输入大量随机数据（噪声或模糊），目的是针对API以展示缓冲区溢出或其他不受欢迎的行为，甚至引发系统崩溃。
- en: Barton Miller at the University of Wisconsin introduced fuzz testing (in 1988,
    as part of his *Operating System Utility Program Reliability – The Fuzz Generator
    project*) to reveal any security loopholes and coding errors in APIs, software,
    networks, and operating systems.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 威斯康星大学的Barton Miller在1988年（作为他*操作系统实用程序可靠性——模糊生成器项目*的一部分）引入了模糊测试，以揭示API、软件、网络和操作系统中的任何安全漏洞和编码错误。
- en: 'The primary purpose of API fuzzing is not to test the correct functionality
    of the API as such, but to explore and test the undefined region with the help
    of fuzzed data:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: API模糊测试的主要目的并不是测试API的正确功能，而是通过模糊数据来探索和测试未定义的区域：
- en: '![](img/16a6fa71-6dde-4f41-85d0-db716b7b93b5.png)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/16a6fa71-6dde-4f41-85d0-db716b7b93b5.png)'
- en: As shown in the preceding diagram, the scope of fuzzing is to expose any unexpected
    behaviors of the underlying API.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，模糊测试的范围是暴露底层API的任何意外行为。
- en: The life cycle of fuzz tests
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模糊测试的生命周期
- en: 'The various stages in a typical life cycle of an API fuzz test start with identifying
    the target APIs and defining the inputs for the test, and end with the generation
    of logs showing vulnerabilities detected in the API. The following diagram depicts
    each phase of the fuzz testing lifecycle:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: API模糊测试的典型生命周期中的各个阶段从确定目标API和定义测试输入开始，以生成显示API中检测到的漏洞的日志结束。以下图示描绘了模糊测试生命周期的每个阶段：
- en: '![](img/7f7e8b8b-044b-4bc0-9410-c5c4156463dc.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7f7e8b8b-044b-4bc0-9410-c5c4156463dc.png)'
- en: Fuzz testing strategy
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模糊测试策略
- en: Fuzz testing strategy varies depending on the attack vectors, fuzzing targets,
    fuzzing methods, and so forth. For an API, let's focus on fuzzing targets. Fuzz
    testing has two primary classifications—mutation based and generation based. We
    will look at the details of both classifications in the following section.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 模糊测试策略根据攻击向量、模糊测试目标、模糊测试方法等因素而有所不同。对于一个API，让我们专注于模糊测试目标。模糊测试主要有两种分类——基于变异的和基于生成的。我们将在下一节中查看这两种分类的详细信息。
- en: Mutation-based fuzz tests
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于变异的模糊测试
- en: 'Mutation or dumb fuzz tests are a simple approach, wherein we create new test
    data by altering existing data samples. Sample data generation starts with valid
    samples of protocols and altering the supplied inputs, to the extent of altering
    every bit of the inputs. The following diagrams illustrate two ways of going about
    mutation:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 变异或愚昧的模糊测试是一种简单的方法，其中我们通过改变现有数据样本来创建新的测试数据。样本数据生成从协议的有效样本开始，并改变提供的输入，直到改变输入的每一个位。以下图示说明了两种变异的方法：
- en: 'Bit flipping, where inputs are flipped in a sequence or in a random manner:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 位翻转，其中输入以序列或随机方式翻转：
- en: '![](img/6a659ec3-f090-401b-8bdd-2afa8a1b3902.png)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6a659ec3-f090-401b-8bdd-2afa8a1b3902.png)'
- en: 'Append a random string, where the end of the input has random strings appended:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在输入的末尾附加一个随机字符串：
- en: '![](img/f0da69fb-586b-44bd-a833-0aa84fa420e4.png)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f0da69fb-586b-44bd-a833-0aa84fa420e4.png)'
- en: Generation-based fuzz tests
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于生成的模糊测试
- en: Generation-based fuzz tests, also known as intelligent fuzzing, are tests based
    on an understanding of known formats, known protocols, and the generation of inputs
    from scratch according to the system/API specifications (RFC) and formats (for
    instance, the format from the API documentation).
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 基于生成的模糊测试，也称为智能模糊测试，是基于对已知格式、已知协议的理解，并按照系统/API规范（RFC）和格式（例如，API文档中的格式）从头生成输入的测试。
- en: Generation fuzz tests are capable of building test data based on the data model.
    Sometimes, these tests are as simple as injecting random bytes, and sometimes
    they can be much smarter, knowing good data values and combining them in multiple
    interesting ways (such as having regular expressions as part of the request body,
    having hostnames in the header, and changing intended response types to different
    types).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 生成模糊测试能够根据数据模型构建测试数据。有时，这些测试只是注入随机字节，有时它们可以更加智能，知道良好的数据值并将它们以多种有趣的方式组合在一起（例如，将正则表达式作为请求体的一部分，在标题中使用主机名，以及将预期的响应类型更改为不同类型）。
- en: Before we conclude this section on fuzz-testing strategies, let's get to know
    another very successful fuzz testing method, known as protocol-based fuzz testing
    (also known as syntax testing, grammar testing, and robust testing). In protocol-based
    fuzz testing, the testers have detailed knowledge of the protocol format, and
    their understanding depends on the given specifications. Here, the specifications
    are intended as an array of stored specifications within a model-based testing
    tool, and it is also capable of generating test data. Then, the tool needs to
    go through all of the specifications and add irregularity to the sequence, data
    contents, and so on to expose vulnerabilities.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们总结关于模糊测试策略的这一节之前，让我们了解另一种非常成功的模糊测试方法，即基于协议的模糊测试（也称为语法测试、语法测试和鲁棒测试）。在基于协议的模糊测试中，测试人员对协议格式有详细的了解，他们的理解取决于给定的规范。在这里，规范被视为一个存储在基于模型的测试工具中的规范数组，并且它还能够生成测试数据。然后，工具需要遍历所有规范，并在序列、数据内容等方面添加不规则性，以暴露漏洞。
- en: Please note that, as the mutation approach does not require you to understand
    the protocol, you may feel more comfortable using it compared to the generation-based
    approach at first glance. However, the generation-based approach is a thorough,
    better, and recommended process even though it takes more time because it involves
    several valid input combinations. It does, however, lead to better code coverage
    and code paths.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于变异方法不需要您了解协议，因此您可能会觉得与基于生成的方法相比，一开始使用起来更舒适。然而，基于生成的方法是一个彻底、更好且推荐的过程，尽管它需要更多时间，因为它涉及几个有效的输入组合。然而，它确实导致了更好的代码覆盖率和代码路径。
- en: Advantages and disadvantages of fuzz tests
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模糊测试的优点和缺点
- en: 'The following points intend to justify why fuzz tests are popular among the
    software professional community:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 以下要点旨在说明为什么模糊测试在软件专业人士社区中很受欢迎：
- en: They are extremely simple, easy, cost-effective, and quick to set up as they
    are free of preconceptions about system behavior
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于它们没有关于系统行为的先入之见，因此它们极其简单、易于使用、成本效益高，并且快速设置
- en: Their one-time setup is easy to repeat for regression (automation)
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们的单次设置易于重复用于回归（自动化）
- en: As it is a protocol-aware test, test results lead to finding precise, descriptive,
    and easy-to-debug errors
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为一种协议感知测试，测试结果有助于找到精确、描述性且易于调试的错误
- en: They enables you to find bugs that are impossible to find with the human eye
    in defined testing or approach-based testing
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使您能够找到在定义测试或基于方法的测试中用肉眼无法找到的漏洞
- en: They yields the best results when used in conjunction with black-box testing,
    beta testing, and other debugging methods
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当与黑盒测试、beta测试和其他调试方法结合使用时，它们能产生最佳结果
- en: 'While fuzz tests bring many advantages to the table, we also need to be aware
    of and understand a few disadvantages, which are listed here:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然模糊测试带来了许多优势，但我们还需要了解和了解一些缺点，这些缺点在此列出：
- en: Mutation-based fuzz tests can run indefinitely (generate numerous test cases
    and run indefinitely) and so determining the optimal number of tests, or determining
    whether time they run for is long enough, is a difficult in some cases
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于变异的模糊测试可以无限期运行（生成大量测试用例并无限期运行），因此在某些情况下确定最佳测试数量或确定它们运行的时间是否足够长是困难的
- en: Tests results may report no defects, even after running numerous test cases
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试结果可能会报告没有缺陷，即使运行了大量的测试用例
- en: Test results may report the same defects for various test cases
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试结果可能会报告各种测试用例中的相同缺陷
- en: It is challenging to find which test case caused the fault
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找出哪个测试用例导致了故障是具有挑战性的
- en: It is difficult to find the vulnerability in the event of a system crash
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在系统崩溃的情况下，很难找到漏洞
- en: To conclude this section, let's list a few tools that you can take advantage
    of when running fuzz tests for APIs without much pain.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 为了总结本节，让我们列出一些在运行API模糊测试时可以轻松利用的工具。
- en: 'Open source:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 开源：
- en: '| **Mutational fuzzing** | **Fuzzing Frameworks** | **Domain Specific fuzzing**
    |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
  zh: '| **突变模糊测试** | **模糊测试框架** | **领域特定模糊测试** |'
- en: '| American fuzzy lop | Sulley | Microsoft SDL MiniFuzz File Fuzzer |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '| American fuzzy lop | Sulley | Microsoft SDL MiniFuzz File Fuzzer |'
- en: '| Radamsa—a flock of fuzzers | Boofuzz | Microsoft SDL Regex Fuzzer |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
  zh: '| Radamsa——一群模糊测试工具 | Boofuzz | Microsoft SDL Regex Fuzzer |'
- en: '| OWASP WebScarab | BFuzz | ABNF Fuzzer |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
  zh: '| OWASP WebScarab | BFuzz | ABNF Fuzzer |'
- en: '| OWASP WSFuzzer | - | - |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '| OWASP WSFuzzer | - | - |'
- en: 'The preceding table details open source fuzzing tools. The following list provides
    a few commercial tools you may want to make use of for fuzz tests:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 上述表格详细介绍了开源模糊测试工具。以下列表提供了一些您可能希望用于模糊测试的商业工具：
- en: Codenomicon's product suite
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Codenomicon的产品套件
- en: The Peach Fuzer Platform
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Peach Fuzer平台
- en: Spirent Avalanche NEXT
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spirent Avalanche NEXT
- en: Beyond Security's beSTORM product
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Beyond Security的beSTORM产品
- en: 'And also, here are a few of the latest tools that readers might find exciting
    to run through their APIs:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，以下是一些读者可能会觉得有趣的最新工具，可以运行它们的API：
- en: '| **Tool** | **Reference/Link** |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| **工具** | **参考/链接** |'
- en: '| REST-ler | [https://www.microsoft.com/en-us/research/uploads/prod/2018/04/restler.pdf](https://www.microsoft.com/en-us/research/uploads/prod/2018/04/restler.pdf)
    |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| REST-ler | [https://www.microsoft.com/en-us/research/uploads/prod/2018/04/restler.pdf](https://www.microsoft.com/en-us/research/uploads/prod/2018/04/restler.pdf)
    |'
- en: '| Burp | [https://portswigger.net/burp](https://portswigger.net/burp) |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| Burp | [https://portswigger.net/burp](https://portswigger.net/burp) |'
- en: '| Fuzzapi | [https://github.com/Fuzzapi/fuzzapi](https://github.com/Fuzzapi/fuzzapi)
    |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| Fuzzapi | [https://github.com/Fuzzapi/fuzzapi](https://github.com/Fuzzapi/fuzzapi)
    |'
- en: '| Fuzz-rest-api | [https://github.com/dubzzz/fuzz-rest-api](https://github.com/dubzzz/fuzz-rest-api)
    |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| Fuzz-rest-api | [https://github.com/dubzzz/fuzz-rest-api](https://github.com/dubzzz/fuzz-rest-api)
    |'
- en: '| Big-list-of-naughty-strings | [https://github.com/minimaxir/big-list-of-naughty-strings/](https://github.com/minimaxir/big-list-of-naughty-strings/)
    |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| Big-list-of-naughty-strings | [https://github.com/minimaxir/big-list-of-naughty-strings/](https://github.com/minimaxir/big-list-of-naughty-strings/)
    |'
- en: Back to API testing
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回到API测试
- en: We have taken a detour from API tests and looked at many aspects of security
    tests in the previous sections. Now, let's get our focus back and redirect our
    journey to a few more API testing aspects in the rest of the chapter.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几节中，我们偏离了API测试，探讨了安全测试的许多方面。现在，让我们将注意力重新集中，将旅程转向本章剩余部分的一些更多API测试方面。
- en: API test cases
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API测试用例
- en: To begin with, let's say that test cases for APIs need to have a few parameters
    or placeholders, such as input parameters, expected results, the time taken to
    receive a response (from the API), parsing input, error handling, and response
    formats so that test results of an API are ascertained and certified.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们假设API的测试用例需要一些参数或占位符，例如输入参数、预期结果、接收响应所需的时间（来自API）、解析输入、错误处理和响应格式，以便确定和认证API的测试结果。
- en: 'Before we move on to a few aspects of test case preparation, let''s get a glimpse
    of the possible types of bug that API tests help us to detect:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续探讨测试用例准备的一些方面之前，让我们先了解一下API测试帮助我们检测的可能类型的错误：
- en: Mishandled errors or disgraceful error conditions by the API
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API处理错误或不体面的错误条件
- en: Any unused flags
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何未使用的标志
- en: Missing or duplicate functionality
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺少或重复的功能
- en: Multi-threading issues
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多线程问题
- en: Incorrect handling of valid argument values
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误处理有效参数值
- en: Validation issues such as schema validations or structure issues
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证问题，如模式验证或结构问题
- en: Reliability issues and performance issues (such as timeout and connecting and
    getting a response time) of the API
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API的可靠性问题和性能问题（如超时、连接和获取响应时间）
- en: API vulnerabilities and any security issues
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API漏洞和任何安全问题
- en: Essential aspects of API test cases and test case preparation
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API测试用例和测试用例准备的基本要素
- en: 'The following list covers a few essential aspects of test case preparation
    for API testing, as the test cases on API testing depend on their outputs:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表涵盖了API测试测试用例准备的一些基本方面，因为API测试的测试用例取决于它们的输出：
- en: Assert a return value based on different input conditions and a combination
    of inputs.
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据不同的输入条件和输入组合断言返回值。
- en: Assert the behavior of the API when there is no return value. Check for return
    codes.
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当API没有返回值时，断言API的行为。检查返回代码。
- en: Assert the events and triggers of an API if the underlying/target API creates
    subsequent events.
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果底层/目标API创建后续事件，断言API的事件和触发器。
- en: Assert not only the API results in case of update data structure but validate
    the effect on the system that it has updated.
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不仅断言更新数据结构时的API结果，还要验证它对系统更新后产生的影响。
- en: Assert by accessing impacted resources when the API is involved in modifying
    specific resources.
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当API涉及修改特定资源时，通过访问受影响的资源进行断言。
- en: API testing challenges
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API测试挑战
- en: If you are ready with the necessary test cases, is it sufficient to start testing
    the intended API? No, it is not—there are some more challenges one should be aware
    of, and we will look at a few common challenges you may face and also how to address
    those challenges when you want to start API testing in the following sections.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你准备好了必要的测试用例，开始测试目标API是否足够？不，还不够——还有一些挑战你应该知道，在接下来的几节中，我们将探讨你可能会遇到的一些常见挑战以及如何解决这些挑战，当你想要开始API测试时。
- en: Initial setup
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始设置
- en: The testing infrastructure and its stability/availability, and uptime. Starting
    and practising API testing in the design phase and checking the APIs for 100%
    uptime is key.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 测试基础设施及其稳定性/可用性，以及正常运行时间。在设计阶段开始并实践API测试，并确保API达到100%的运行时间是关键。
- en: API schema updates for testing
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API架构更新用于测试
- en: Request and response schema or formats are the lifelines of the API. However,
    frequent changes to schemas are inevitable (especially during the development
    phase) and so test cases for schema configuration too. Managing tests in alpha
    and beta environments may reduce the number of issues (due to schema updates)
    by up to 90%.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 请求和响应架构或格式是API的生命线。然而，架构的频繁更改是不可避免的（尤其是在开发阶段），因此也需要为架构配置编写测试用例。在alpha和beta环境中管理测试可以减少多达90%的问题（由于架构更新）。
- en: Testing parameter combinations
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试参数组合
- en: Adding additional parameters to the API increases the number of combinations
    exponentially, while it is necessary to test every possible combination of parameter
    requests to find issues specific to configurations. API releases and ensuring
    potential API release candidates are available for testing helps address these
    challenges effectively.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 向API添加额外的参数会指数级地增加组合数量，而测试每个可能的参数请求组合以找到特定于配置的问题是必要的。API发布和确保潜在的API候选发布版本可用于测试有助于有效地解决这些挑战。
- en: API call sequence
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API调用序列
- en: Calling APIs in a specific sequence to attain the desired result is inevitable
    in many cases, and for those scenarios, test cases also need to have the proper
    sequence implemented. However, this is challenging in major APIs, and becomes
    even more challenging when cases of multi threaded applications are involved.
    Along with enforcing release candidates, a visual representation of a sequence
    of API calls or a flow chart for the sequence of API calls will help not only
    the testing phase but also the development team as well (as part of development
    phase).
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，按照特定顺序调用API以获得期望的结果是不可避免的，对于这些场景，测试用例也需要实现适当的顺序。然而，在主要API中，这很具挑战性，当涉及多线程应用程序的情况时，挑战性更大。除了强制执行候选发布版本外，API调用序列的可视表示或API调用序列的流程图将不仅有助于测试阶段，而且对开发团队也有帮助（作为开发阶段的一部分）。
- en: Validating parameters
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证参数
- en: Checking numbers and the number of digits in a phone number, length restrictions,
    data type validations, data-ranges modifications, and such validation criteria
    or tests are daunting tasks for the testing team especially with larger APIs that
    have a vast number of parameters to validate. Implementing synthetic and **application
    performance monitoring** (**APM**) tools will help to ensure catching any problems
    that arise due to parameter validations. Validating parameter is one of the crucial
    aspects of security testing as well.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 检查电话号码中的数字和数字数量、长度限制、数据类型验证、数据范围修改等验证标准或测试对于测试团队来说是一项艰巨的任务，尤其是对于具有大量参数需要验证的大型API。实施合成和**应用性能监控**（**APM**）工具将有助于确保捕捉到由于参数验证而产生的问题。验证参数也是安全测试的关键方面之一。
- en: Tracking system integration
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跟踪系统集成
- en: A data tracking system helps to find the correct responses to the calls. However,
    it is a challenging task for the team to ensure that the API testing system is
    working correctly with the data tracking system and calls that the API is making
    are getting the right response. you can address this challenge by implementing
    and including load tests with **continuous delivery **(**CD**).
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 数据跟踪系统有助于找到对调用的正确响应。然而，对于团队来说，确保API测试系统与数据跟踪系统正确工作，并且API发出的调用得到正确响应是一个具有挑战性的任务。您可以通过实施和包括**持续交付**（**CD**）中的负载测试来解决这个挑战。
- en: API testing best practices
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API测试最佳实践
- en: 'The following section lists a few API testing best practices you should know
    about. To start with, the following are test case best practices:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分列出了您应该了解的一些API测试最佳实践。首先，以下是一些测试用例最佳实践：
- en: Group API test cases by test category (unit tests, functional tests, security
    tests, and so on)
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按测试类别（单元测试、功能测试、安全测试等）分组API测试用例
- en: Ensure test cases indicate the declarations of involved (called) APIs on top
    of each test case
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保测试用例在每项测试用例的顶部指明涉及的（调用的）API声明
- en: Ensure parameter selections are mentioned explicitly in the test case itself
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保在测试用例中明确提及参数选择
- en: Executes test cases independently, that is, each test case is a self-contained
    and an independent entity
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 独立执行测试用例，也就是说，每个测试用例都是一个自包含且独立的实体
- en: prioritize API calls, which helps to simplify API testing
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优先考虑API调用，这有助于简化API测试
- en: Keep test cases free from *test chaining* (reusing test data objects created
    by other tests)
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持测试用例不受*测试链*（重用其他测试创建的测试数据对象）的影响
- en: Test cases deal with one-time call functions such as delete, close window, asynchronous
    calls, and so need special attention to avoid undesirable executions
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试用例处理一次性调用函数，如删除、关闭窗口、异步调用等，因此需要特别注意以避免不希望的执行
- en: Ensure API call sequences are well planned and also have clear execution plans
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保API调用序列规划良好，并且有明确的执行计划
- en: Create test cases for every possible known input combination of the API, as
    this leads to better test coverage of the underlying APIs
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为API的每个可能的已知输入组合创建测试用例，因为这有助于提高底层API的测试覆盖率
- en: API testing tools
  id: totrans-357
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API测试工具
- en: 'It may be a good idea to complete our API testing journey with some information
    about a few common API testing tools. The following screenshot of API testing
    tools gives brief details on each tool, their ease of use, and supporting platforms
    and may come in handy:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 完成我们的API测试之旅，了解一些常见的API测试工具可能是个好主意。以下API测试工具的截图提供了每个工具的简要细节，包括其易用性、支持的平台，可能很有用：
- en: '![](img/facc50dc-0ff7-49f2-83d6-c1c9918f030d.png)'
  id: totrans-359
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/facc50dc-0ff7-49f2-83d6-c1c9918f030d.png)'
- en: CQRS
  id: totrans-360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CQRS
- en: '**Command Query Responsibility Segregation** (**CQRS**) is an architectural
    pattern, proposed by Greg Young. CQRS suggests the segregation of the reading
    operations (queries) and writing operations (commands) of a system to separate
    subsystems, as reads are eventually consistent and retrieved from de-normalized
    views and commands are usually asynchronous and stored in transactional storage,
    and reads are eventually consistent and retrieved from deformalized views.'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '**命令查询责任分离**（**CQRS**）是一种由格雷格·杨提出的架构模式。CQRS建议将系统的读取操作（查询）和写入操作（命令）分离到不同的子系统，因为读取操作最终是一致的，并且从反规范化视图中检索，而命令通常是异步的，并存储在事务性存储中，读取操作最终是一致的，并且从非规范化视图中检索。'
- en: So, segregating read and write operations with separate interfaces or subsystems
    doesn't only help to maximize the performance of APIs, it also helps in security
    and scalability aspects, as well as managing merge conflicts at the domain level,
    due to update commands, leading to more flexibility.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过使用单独的接口或子系统来分离读取和写入操作，不仅有助于最大化API的性能，还有助于安全性和可扩展性方面，以及由于更新命令导致的领域级别合并冲突的管理，从而提供更多灵活性。
- en: 'Before we delve further into CQRS, let''s look at traditional patterns for
    **Data Access** in the following diagram:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进一步探讨CQRS之前，让我们看看以下图中传统的**数据访问**模式：
- en: '![](img/81fca498-5e41-44d2-8df9-550481f1e125.png)'
  id: totrans-364
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/81fca498-5e41-44d2-8df9-550481f1e125.png)'
- en: Traditional Data Source and DTO models (CRUD)
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的数据源和DTO模型（CRUD）
- en: As depicted, the read and write operations of data (source) are from one data
    source or data storage, with updates or writes and Queries (read).
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 如上图所示，数据的读取和写入操作（源）来自一个数据源或数据存储，包括更新或写入和查询（读取）。
- en: 'There are a few disadvantages with the CRUD approach, as listed here:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: CRUD方法有一些缺点，如下所示：
- en: The data that is being read and the data being updated may have different representations
    and managing that updated data in sync to serve both reads and writes is an overhead
    to the underlying system.
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被读取的数据和被更新的数据可能有不同的表示形式，并且为了同步管理这些更新数据以服务于读取和写入，这给底层系统带来了开销。
- en: Performance is affected by the high load on the data store and data access layers
    and depends on queries and the complexities involved in retrieving information.
    High volume transactions also increase the chances of data contention when records
    are locked in a data store and accessed by multiple domains.
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能受数据存储和数据访问层的高负载影响，并取决于查询以及获取信息所涉及到的复杂性。高量交易还会增加在数据存储中锁定记录并由多个领域访问时的数据争用机会。
- en: Managing security and roles for data access might be challenging as well.
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理数据访问的安全性和角色可能也是一个挑战。
- en: 'The CQRS pattern addresses those disadvantages, as its implementation segregates
    queries (reads) from the update (**Commands**) operations with separate interfaces:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: CQRS模式解决了这些缺点，因为它的实现将查询（读取）与更新（**命令**）操作通过单独的接口分离：
- en: '![](img/31719e3c-885f-4207-82c7-19808c1a6c5c.png)'
  id: totrans-372
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/31719e3c-885f-4207-82c7-19808c1a6c5c.png)'
- en: 'It also check the following instances:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 它还检查以下实例：
- en: '![](img/7121565c-7b6f-47f6-b195-bfbb8558df8d.png)'
  id: totrans-374
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7121565c-7b6f-47f6-b195-bfbb8558df8d.png)'
- en: The preceding two diagrams depict two variations of CQRS implementation. The
    first one represents a simplified design and implementation of CQRS with read
    and write models within a single data source. Note that it is not a single data
    model (like CRUD), but read and write as a separate models. The downside of this
    version of CQRS implementation is that, unlike CRUD, the automatic code generation
    with scaffolding mechanism is not possible for CQRS based systems.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的两个图展示了CQRS实现的两种变体。第一个图表示了CQRS在单一数据源内具有读取和写入模型的简化设计和实现。请注意，它不是一个单一的数据模型（如CRUD），而是读取和写入作为独立的模型。这种CQRS实现版本的缺点是，与CRUD不同，基于CQRS的系统无法实现带有脚手架机制的自动代码生成。
- en: The diagram with a separate data source depicts another CQRS design, where we
    have two different physical data stores one for write or update operations (commands)
    and then another one exclusively for queries. Separate data store implementation
    maximizes performance, scalability, and security.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 具有单独数据源的图描述了另一种CQRS设计，其中我们有两个不同的物理数据存储，一个用于写入或更新操作（命令），然后另一个专门用于查询。单独的数据存储实现最大化性能、可扩展性和安全性。
- en: 'While CQRS brings higher performance, scalability, and security, it also brings
    increased complexity and maintenance overheads to manage consistency due to multiple
    data stores and also one would need to understand from the following list when
    to choose CQRS for your implementations:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 CQRS 带来了更高的性能、可扩展性和安全性，但它也带来了增加的复杂性和维护开销，以管理由于多个数据存储而导致的致性，同时还需要了解以下列表，以确定何时为您的实现选择CQRS：
- en: CQRS is suitable for systems in which number of writing (updates) and reading
    (queries) differ significantly
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CQRS适用于读写（更新）和读取（查询）数量差异显著的系统
- en: It's ideal for systems in which reads and writes need individual scaling
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它适用于读取和写入需要单独扩展的系统
- en: It's suitable for systems where the consistency of data is not critical (addressed
    eventual consistency) but the availability
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它适用于数据一致性不是关键（解决最终一致性）但可用性是关键的系统
- en: It 's ideal for systems that prefer fire-and-forget events (asynchronous events)
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于偏好“发射后不管”事件（异步事件）的系统来说，这是理想的。
- en: It's suitable for the systems that have a data store access layer based on event
    sources
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它适用于基于事件源的数据存储访问层的系统
- en: It's ideal for systems that implement domain-driven designs and isolate the
    business or domain complexity, and having CRUD would make more complex
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它适用于实现领域驱动设计并隔离业务或领域复杂性的系统，并且拥有CRUD会使系统更复杂
- en: Summary
  id: totrans-384
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We are at the end of our API testing journey and, reflecting on of this journey,
    we have learned a few basics of API testing types and API testing approaches,
    starting from unit test cases, through to API validation tests, functional tests,
    load tests, and end-to-end tests, along with API monitoring. We have also touched
    on a few important API errors aspects such as execution errors, resource leaks,
    and error detection methodologies.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了我们的API测试之旅，回顾这段旅程，我们学习了API测试类型和API测试方法的一些基本知识，从单元测试用例开始，到API验证测试、功能测试、负载测试和端到端测试，以及API监控。我们还触及了一些重要的API错误方面，如执行错误、资源泄漏和错误检测方法。
- en: While we were looking at on API testing, we got to know a few critical security
    vulnerabilities in the REST API world, including sensitive data exposure, authentication
    attacks, XSS attacks, see-surf (CSRF), DoS attacks, and injection attacks. We
    did not just focus on attacks, as this chapter introduced the causes of those
    attacks (vulnerabilities), as well as methods and tools for detecting those API
    vulnerabilities by means of penetration and fuzz tests.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在查看API测试时，我们了解到了REST API世界中的几个关键安全漏洞，包括敏感数据泄露、身份验证攻击、XSS攻击、会话固定（CSRF）、DoS攻击和注入攻击。我们不仅关注攻击，因为本章介绍了这些攻击（漏洞）的原因，以及通过渗透和模糊测试检测这些API漏洞的方法和工具。
- en: We continued on our API testing journey after understanding API security measures—we
    got to know a few of the basics of API test case creation, API testing challenges,
    and API testing best practices, and concluded our journey with a snapshot of API
    testing tools.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解API安全措施之后，我们继续我们的API测试之旅——我们了解了一些API测试用例创建、API测试挑战和API测试最佳实践的 basics，并以API测试工具的快照结束了我们的旅程。
- en: Further reading
  id: totrans-388
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Mastering Modern Web Penetration Testing* ([https://www.packtpub.com/networking-and-servers/mastering-modern-web-penetration-testing](https://www.packtpub.com/networking-and-servers/mastering-modern-web-penetration-testing)),
    Prakhar Prasad, Packt Publishing.'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '*《精通现代网络渗透测试》* ([https://www.packtpub.com/networking-and-servers/mastering-modern-web-penetration-testing](https://www.packtpub.com/networking-and-servers/mastering-modern-web-penetration-testing))，Prakhar
    Prasad，Packt Publishing。'
