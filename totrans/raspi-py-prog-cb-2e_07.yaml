- en: Chapter 7. Sense and Display Real-World Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 7 章. 感知和显示现实世界数据
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Using devices with the I²C bus
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用带有 I²C 总线的设备
- en: Reading analog data using an analog-to-digital converter
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模数转换器读取模拟数据
- en: Logging and plotting data
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录和绘制数据
- en: Extending the Raspberry Pi GPIO with an I/O expander
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 I/O 扩展器扩展 Raspberry Pi GPIO
- en: Capturing data in an SQLite database
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 SQLite 数据库中捕获数据
- en: Viewing data from your own webserver
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从您的自有网络服务器查看数据
- en: Sensing and sending data to online services
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 感知并将数据发送到在线服务
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In the previous chapter, we made use of the Raspberry Pi GPIO to directly control
    and respond to the attached hardware by controlling or reading the GPIO pins.
    In this chapter, we will learn how to collect analog data from the real world
    and process it so we can display, log, graph, and share the data and make use
    of it in our programs.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们使用了 Raspberry Pi GPIO 直接通过控制或读取 GPIO 引脚来控制并响应连接的硬件。在本章中，我们将学习如何从现实世界收集模拟数据并对其进行处理，以便我们可以显示、记录、绘图并共享数据，并在我们的程序中使用它。
- en: We will extend the capabilities of the Raspberry Pi by interfacing with **Analog-to-Digital
    Converters** (**ADCs**), LCD alphanumeric displays, and digital port expanders
    using Raspberry Pi's GPIO connections.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过使用 Raspberry Pi 的 GPIO 连接与**模数转换器**（**ADC**）、LCD 数码显示屏和数字端口扩展器来扩展 Raspberry
    Pi 的功能。
- en: Tip
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Be sure to check out [Appendix](apa.html "Appendix A. Hardware and Software
    List"), *Hardware and Software List*, which lists all the items used in this chapter
    and the places you can obtain them from.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 请务必查看[附录](apa.html "附录 A. 硬件和软件列表")，*硬件和软件列表*，其中列出了本章中使用的所有项目及其获取地点。
- en: Using devices with the I²C bus
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用带有 I²C 总线的设备
- en: The Raspberry Pi can support several higher-level protocols that a wider range
    of devices can easily be connected to. In this chapter, we shall focus on the
    most common bus, called **I²C** (**I-squared-C**). It provides a medium-speed
    bus for communicating with devices over two wires. In this section, we shall use
    I²C to interface with an 8-bit ADC. This device will measure an analog signal,
    convert it to a relative value between 0 and 255, and send the value as a digital
    signal (represented by 8 bits) over the I²C bus to the Raspberry Pi.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Raspberry Pi 可以支持多种高级协议，这使得更广泛的设备可以轻松连接。在本章中，我们将重点关注最常用的总线，称为**I²C**（**I-squared-C**）。它提供了一个中速总线，用于通过两根线与设备通信。在本节中，我们将使用
    I²C 与 8 位 ADC 进行接口。该设备将测量模拟信号，将其转换为介于 0 和 255 之间的相对值，并将该值作为数字信号（由 8 位表示）通过 I²C
    总线发送到 Raspberry Pi。
- en: Getting ready
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The I²C bus is not enabled in all Raspberry Pi images; therefore, we need to
    enable the module and install some supporting tools. Newer versions of Raspbian
    use **Device Trees** to handle hardware peripherals and drivers.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: I²C 总线并非在所有 Raspberry Pi 图像中都已启用；因此，我们需要启用模块并安装一些支持工具。Raspbian 的新版本使用**设备树**来处理硬件外围设备和驱动程序。
- en: In order to make use of the I²C bus, we need to enable the ARM I²C in the `\boot\config.txt`
    file.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用 I²C 总线，我们需要在 `\boot\config.txt` 文件中启用 ARM I²C。
- en: 'You can do this automatically using the following command:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令自动完成此操作：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As shown in the following screenshot, select **Advanced Options** from the menu
    and then **I2C**. When asked, select **Yes** to enable the interface and **Yes**
    to load the module by default.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下截图所示，从菜单中选择**高级选项**，然后选择**I²C**。当被询问时，选择**是**以启用接口，并默认加载模块。
- en: '![Getting ready](img/6623OT_07_001.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/6623OT_07_001.jpg)'
- en: From the menu select **I²C** and select **Yes** to enable the interface and
    to load the module by default.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 从菜单中选择**I²C**，并选择**是**以启用接口并默认加载模块。
- en: Tip
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The `raspi-config` program enables the `I2C_ARM` interface by altering `/boot/config.txt`
    to include `dtparam=i2c_arm=on`. The other bus (I2C_VC) is typically reserved
    for interfacing with Raspberry Pi HAT add-on boards (to read the configuration
    information from the on-board memory devices); however, you can enable this using
    `dtparam=i2c_vc=on`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`raspi-config` 程序通过修改 `/boot/config.txt` 以包含 `dtparam=i2c_arm=on` 来启用 `I2C_ARM`
    接口。另一个总线（I2C_VC）通常保留用于与 Raspberry Pi HAT 扩展板进行接口（从板载存储设备读取配置信息）；然而，您可以使用 `dtparam=i2c_vc=on`
    来启用它。'
- en: You can also enable the SPI using `raspi-config` list if you wish, which is
    another type of bus that can be seen in [Chapter 10](ch10.html "Chapter 10. Interfacing
    with Technology"), *Interfacing with Technology*.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您愿意，也可以通过 `raspi-config` 列表启用 SPI，这是另一种可以在[第 10 章](ch10.html "第 10 章。与技术接口")，*与技术接口*中看到的总线类型。
- en: 'Next, we should include the I²C module to be loaded on power up, as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们应该包含在开机时加载的 I²C 模块，如下所示：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Add the following on separate lines and save (*Ctrl + X, Y, Enter*):'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在单独的行上添加以下内容并保存（*Ctrl + X, Y, Enter*）：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Similarly, we can also enable the SPI module by adding `spi-bcm2708`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们也可以通过添加 `spi-bcm2708` 来启用 SPI 模块。
- en: 'Next, we will install some tools to use I²C devices directly from the command
    line, as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将安装一些工具，以便可以直接从命令行使用 I²C 设备，如下所示：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Finally, shut down the Raspberry Pi before attaching the hardware in order
    to allow the changes to be applied, as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在连接硬件之前关闭 Raspberry Pi，以便应用更改，如下所示：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You will need a PCF8591 module (retailers of these are listed in [Appendix,](apa.html
    "Appendix A. Hardware and Software List") *Hardware and Software List*) or you
    can obtain the PCF8591 chip separately and build your own circuit (see the *There's
    more…* section for details of the circuit).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要一个 PCF8591 模块（这些模块的零售商列在[附录，](apa.html "附录 A. 硬件和软件列表") *硬件和软件列表*中），或者您可以单独获取
    PCF8591 芯片并构建自己的电路（有关电路的详细信息，请参阅 *还有更多…* 部分）。
- en: '![Getting ready](img/6623OT_07_002.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](img/6623OT_07_002.jpg)'
- en: The PCF8591 ADC and sensor module from dx.com
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 来自 dx.com 的 PCF8591 ADC 和传感器模块
- en: 'Connect the **GND**, **VCC**, **SDA**, and **SCL** pins to the Raspberry Pi
    GPIO header as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 将 **GND**、**VCC**、**SDA** 和 **SCL** 引脚连接到 Raspberry Pi GPIO 引脚，如下所示：
- en: '![Getting ready](img/6623OT_07_003.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](img/6623OT_07_003.jpg)'
- en: I²C connections on the Raspberry Pi GPIO header
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Raspberry Pi GPIO 引脚上的 I²C 连接
- en: Note
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can use the same I²C tools/code with other I²C devices by studying the datasheet
    of the device to find out what messages to send/read and which registers are used
    to control your device.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过研究设备的规格书来使用相同的 I²C 工具/代码与其他 I²C 设备进行交互，以找出要发送/读取的消息以及用于控制您的设备的哪些寄存器。
- en: How to do it...
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Detect the I²C device by using `i2cdetect` (the `--y` option skips any warnings
    about possible interference with other hardware that could be connected to the
    I²C bus) using the following commands to scan both buses:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令通过 `i2cdetect`（使用 `--y` 选项跳过关于可能与其他硬件（可能连接到 I²C 总线）发生干扰的任何警告）检测 I²C 设备：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Depending on your Raspberry Pi board revision, the address of the device should
    be listed on bus 0 (for Model B Rev1 boards) or bus 1 (for Raspberry Pi 2 & 3,
    Raspberry Pi 1 Model A and Model B Rev 2). By default, the PCF8591 address is
    `0x48`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的 Raspberry Pi 板修订版，设备的地址应列在总线 0 上（对于 B 型 Rev1 板）或总线 1 上（对于 Raspberry Pi
    2 & 3，Raspberry Pi 1 Model A 和 Model B Rev2）。默认情况下，PCF8591 地址为 `0x48`。
- en: '| I²C bus number to use | Bus 00 | Bus 11 |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 要使用的 I²C 总线编号 | 总线 00 | 总线 11 |'
- en: '| --- | --- | --- |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Raspberry Pi 2 & 3 | HAT ID (I2C_VC) | GPIO (I2C_ARM) |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| Raspberry Pi 2 & 3 | HAT ID (I2C_VC) | GPIO (I2C_ARM) |'
- en: '| Model A and Model B Revision 2 | P5 | GPIO |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| A 型和 B 型修订 2 | P5 | GPIO |'
- en: '| Model B Revision 1 | GPIOGPIO | n/a |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| B 型修订 1 | GPIOGPIO | n/a |'
- en: 'The following screenshot shows the output of `i2cdetect`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了 `i2cdetect` 的输出：
- en: '![How to do it...](img/6623OT_07_004.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/6623OT_07_004.jpg)'
- en: The PCF8591 address (48) is displayed here on bus 1
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: PCF8591 地址（48）在此显示在总线 1 上
- en: If nothing is listed, shut down and double-check your connections (the ADC module
    from [www.dx.com](http://www.dx.com) will have a red LED showing when powered).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有列出任何内容，请关闭并检查您的连接（来自 [www.dx.com](http://www.dx.com) 的 ADC 模块在供电时会显示红色 LED）。
- en: Note
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you receive an error that the `/dev/i2c1` bus doesn't exist, you can perform
    the following checks.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您收到 `/dev/i2c1` 总线不存在的错误，您可以执行以下检查。
- en: 'Ensure that the `/etc/modprobe.d/raspi-blacklist.conf` file is empty (that
    is, the modules haven''t been blacklisted), using the following command to view
    the file:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 确保文件 `/etc/modprobe.d/raspi-blacklist.conf` 为空（即，模块没有被列入黑名单），使用以下命令查看文件：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If there is anything in the file (such as `blacklist i2c-bcm2708`), remove it
    and save.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件中存在任何内容（例如 `blacklist i2c-bcm2708`），请将其删除并保存。
- en: Check `/boot/config` and ensure there isn't a line that has `device_tree_param=`
    (this will disable support for the new device tree configurations and disable
    support for some Raspberry Pi HAT add-on boards).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 检查 `/boot/config` 并确保没有一行包含 `device_tree_param=`（这将禁用对新设备树配置的支持，并禁用对某些 Raspberry
    Pi HAT 扩展板的兼容性支持）。
- en: Check whether the modules have been loaded by using `lsmod` and look for `i2c-bcm2708`
    and `i2c_dev`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`lsmod`检查模块是否已加载，并查找`i2c-bcm2708`和`i2c_dev`。
- en: 'Using the detected bus number (`0` or `1`) and the device address (`0x48`)
    use `i2cget` to read from the device (after a power up or channel change you will
    need to read the device twice to see the latest value), as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 使用检测到的总线号（`0`或`1`）和设备地址（`0x48`），使用`i2cget`从设备读取（在上电或通道更改后，你需要读取设备两次以查看最新值），如下所示：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To read from channel `1` (this is the temperature sensor on the module), we
    can use `i2cset` to write `0x01` to the PCF8591 control register. Again, use two
    reads to get a new sample from channel `1`, as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要从通道`1`（这是模块上的温度传感器）读取，我们可以使用`i2cset`将`0x01`写入PCF8591控制寄存器。同样，使用两次读取从通道`1`获取一个新的样本，如下所示：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To cycle through each of the input channels, use `i2cset` to set the control
    register to `0x04`, as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要循环遍历每个输入通道，请使用`i2cset`将控制寄存器设置为`0x04`，如下所示：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can also control the AOUT pin using the following command to set it fully
    on (lighting up the LED D1):'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用以下命令来控制AOUT引脚，将其完全打开（点亮LED D1）：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Finally, we can use the following command to set it fully off (switching off
    the LED D1):'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以使用以下命令将其完全关闭（关闭LED D1）：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How it works...
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The first read from the device after power on will return `0x80` and will also
    trigger the new sample from channel 0\. If you read a second time, it will return
    the sample previously read and generate a fresh sample. Each reading will be an
    8-bit value (ranging from `0` to `255`), representing the voltage 0 to VCC (in
    this case, 0V to 3.3V). On the [www.dx.com](http://www.dx.com) module, channel
    0 is connected to a light sensor, so if you cover up the module with your hand
    and resend the command, you will observe a change in the values (darker means
    a higher value and lighter means a lower one). You will find the readings are
    always one behind; this is because as it returns the previous sample, it captures
    the next sample.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在上电后从设备读取第一次将返回`0x80`，并也会触发从通道0的新样本。如果你再次读取，它将返回之前读取的样本并生成一个新的样本。每次读取都将是一个8位值（范围从`0`到`255`），表示电压从0到VCC（在这种情况下，0V到3.3V）。在[www.dx.com](http://www.dx.com)模块上，通道0连接到一个光传感器，所以如果你用手遮住模块并重新发送命令，你会观察到值的变化（变暗意味着值更高，变亮意味着值更低）。你会发现读取值总是落后一步；这是因为当它返回前一个样本时，它会捕获下一个样本。
- en: 'We use the following command to specify a particular channel to read:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用以下命令来指定要读取的特定通道：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This changes the channel that is read to channel 1 (this is marked as **AIN1**
    on the module). Remember, you will need to perform two reads before you will see
    data from the newly selected channel. The following table shows the channels and
    pin names as well as which jumper connectors enable/disable each of the sensors:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这将读取的通道更改为通道1（在模块上标记为**AIN1**）。记住，你需要在看到新选择通道的数据之前执行两次读取。以下表格显示了通道和引脚名称以及哪些跳线连接器启用/禁用每个传感器：
- en: '| Channel | 0 | 1 | 2 | 3 |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| 通道 | 0 | 1 | 2 | 3 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| Pin Name | AIN0 | AIN1 | AIN2 | AIN3 |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| 引脚名称 | AIN0 | AIN1 | AIN2 | AIN3 |'
- en: '| Sensor | Light Dependent Resistor | Thermistor | External Pin | Potentiometer
    |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| 传感器 | 光敏电阻 | 热敏电阻 | 外部引脚 | 滑动变阻器 |'
- en: '| Jumper | P5 | P4 |   | P6 |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| 跳线 | P5 | P4 |   | P6 |'
- en: 'Next, we control the AOUT pin by setting the analog output enable flag (bit
    6) of the control register and use the next value to set the analog voltage (0V-3.3V
    0x00-0xFF), as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过设置控制寄存器的模拟输出使能标志（位6）来控制AOUT引脚，并使用下一个值来设置模拟电压（0V-3.3V 0x00-0xFF），如下所示：
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Finally, you can set bit 2 (`0x04`) to auto-increment and cycle through the
    input channels as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以将位2（`0x04`）设置为自动递增，并按如下方式循环遍历输入通道：
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Each time you run `i2cget -y 1 0x48`, the next channel will be selected, starting
    with channel AIN0, then AIN1 through to AIN3, and back to AIN0 again.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 每次运行`i2cget -y 1 0x48`，下一个通道将被选择，从通道AIN0开始，然后是AIN1到AIN3，再回到AIN0。
- en: Note
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To understand how to set a particular bit in a value, it helps to look at the
    binary representation of a number. The 8-bit value `0x04` can be written as `b0000
    0100` in binary (`0x` indicates the value is written in hexadecimal or hex, and
    b indicates a binary number).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何设置一个值中的特定位，查看数字的二进制表示很有帮助。8位值`0x04`可以写成二进制`b0000 0100`（`0x`表示值是以十六进制或十六进制形式编写的，而b表示一个二进制数）。
- en: Bits within binary numbers are counted from right to left, starting with 0,
    that is, MSB 7 6 5 4 3 2 1 0 LSB.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制数中的位从右到左计数，从 0 开始，即 MSB 7 6 5 4 3 2 1 0 LSB。
- en: Bit 7 is known as the **Most Significant Bit** (**MSB**) and bit 0 as the **Least
    Significant Bit** (**LSB**). Therefore, by setting bit 2, we end up with `b0000
    0100` (which is `0x04`).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 位 7 被称为 **最高有效位**（**MSB**），位 0 被称为 **最低有效位**（**LSB**）。因此，通过设置位 2，我们最终得到 `b0000
    0100`（这是 `0x04`）。
- en: There's more...
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The I²C bus allows us to easily connect multiple devices using only a few wires.
    The PCF8591 chip can be used to connect your own sensors to the module or just
    the chip.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: I²C 总线使我们能够通过仅使用几根线轻松地连接多个设备。PCF8591 芯片可以用来将您的传感器连接到模块或只是芯片。
- en: Using multiple I²C devices
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用多个 I²C 设备
- en: All commands on the I²C bus are addressed to a specific I²C device (many have
    the option to set some pins high or low to select additional addresses and allow
    multiple devices to exist on the same bus). Each device must have a unique address
    so that only one device will respond at any one time. The PCF8591 starting address
    is `0x48`, with additional addresses selectable by the three address pins to `0x4F`.
    This allows up to eight PCF8591 devices to be used on the same bus.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: I²C 总线上的所有命令都是针对特定的 I²C 设备的（许多设备可以选择将一些引脚设置为高电平或低电平以选择额外的地址，并允许多个设备存在于同一总线上）。每个设备都必须有一个唯一的地址，这样在任何时候只有一个设备会响应。PCF8591
    的起始地址是 `0x48`，通过三个地址引脚可选择到 `0x4F`。这允许在同一总线上使用多达八个 PCF8591 设备。
- en: Note
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you decide to use the I2C_VC bus that is located on GPIO pins 27 and 2828
    (or on the P5 header on Model A and Rev2 Model B devices), you may need to add
    a 1k8 ohm pull-up resistor between the I²C lines and 3.3V. These resistors are
    already present on the I²C bus on the GPIO connector. However, some I²C modules,
    including the PCF8591 module, have their own resistors fitted, so it will work
    without the extra resistors.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您决定使用位于 GPIO 引脚 27 和 28（或 Model A 和 Rev2 Model B 设备上的 P5 头部）的 I2C_VC 总线，您可能需要在
    I²C 线和 3.3V 之间添加一个 1k8 欧姆的上拉电阻。这些电阻已经存在于 GPIO 连接器上的 I²C 总线上。然而，一些 I²C 模块，包括 PCF8591
    模块，已经安装了自己的电阻，因此无需额外的电阻即可工作。
- en: I²C bus and level shifting
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: I²C 总线和电平转换
- en: The I²C bus consists of two wires, one data (SDA) and one clock (SCL). Both
    are passively pulled to VCC (on the Raspberry Pi, this is 3.3V) with pull-up resistors.
    The Raspberry Pi will control the clock by pulling it low every cycle and the
    data line can be pulled low by Raspberry Pi to send commands or by the connected
    device to respond with data.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: I²C 总线由两根线组成，一根是数据（SDA），另一根是时钟（SCL）。两者都通过上拉电阻被动地拉到 VCC（在 Raspberry Pi 上，这是 3.3V）。Raspberry
    Pi 将通过在每个周期中将时钟拉低来控制时钟，数据线可以通过 Raspberry Pi 拉低来发送命令，或者由连接的设备拉低以响应数据。
- en: '![I2C bus and level shifting](img/6623OT_07_005.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![I2C 总线和电平转换](img/6623OT_07_005.jpg)'
- en: The Raspberry Pi I²C pins include pull-up resistors on SDA and SCL
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Raspberry Pi 的 I²C 引脚包括 SDA 和 SCL 上的上拉电阻
- en: Since the slave devices can only pull the data line to **GND**, the device may
    be powered by **3.3V** or even **5V** without the risk of driving the GPIO pins
    too high (remember that the Raspberry Pi GPIO is not able to handle voltages over
    3.3V). This should work as long as the I²C bus of the device will recognize logic
    high at 3.3V instead of 5V. The I²C device must not have its own pull-up resistors
    fitted, as this will cause the GPIO pins to be pulled to the supply voltage of
    the I²C device.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 由于从设备只能将数据线拉到 **GND**，因此设备可以由 **3.3V** 或甚至 **5V** 供电，而不会存在驱动 GPIO 引脚过高的风险（记住
    Raspberry Pi 的 GPIO 不能处理超过 3.3V 的电压）。只要设备的 I²C 总线能识别 3.3V 而不是 5V 的逻辑高电平，这应该就可以工作。I²C
    设备不得配备自己的上拉电阻，因为这会导致 GPIO 引脚被拉到 I²C 设备的供电电压。
- en: 'Note the PCF8591 module used in this chapter has resistors fitted; therefore,
    we must only use VCC=3V3\. A bidirectional logic level converter can be used to
    overcome any issues with logic levels. One such device is the **Adafruit** I²C
    bidirectional logic level translator, shown in the following image:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，本章中使用的 PCF8591 模块已安装了电阻；因此，我们只能使用 VCC=3V3。可以使用双向逻辑电平转换器来解决任何逻辑电平问题。这样的设备之一是
    **Adafruit** I²C 双向逻辑电平转换器，如图所示：
- en: '![I2C bus and level shifting](img/6623OT_07_006.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![I2C 总线和电平转换](img/6623OT_07_006.jpg)'
- en: Adafruit I²C Bi-directional logic level translator module
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Adafruit I²C 双向逻辑电平转换模块
- en: In addition to ensuring that any logic voltages are at suitable levels for the
    device you are using, it will allow the bus to be extended over longer wires (the
    level shifter will also act as a bus repeater).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 除了确保任何逻辑电压适合您所使用的设备外，它还将允许总线通过更长的电线扩展（电平转换器还将充当总线中继器）。
- en: Using just the PCF8591 chip or adding alternative sensors
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 仅使用PCF8591芯片或添加替代传感器
- en: 'A circuit diagram of the PCF8591 module without the sensors attached is shown
    in the following diagram:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示显示了未连接传感器的PCF8591模块的电路图：
- en: '![Using just the PCF8591 chip or adding alternative sensors](img/6623OT_07_007.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![仅使用PCF8591芯片或添加替代传感器](img/6623OT_07_007.jpg)'
- en: The PCF8591 ADC circuit – VCC, GND, SCL, and SDA are connected to the Raspberry
    Pi as before
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: PCF8591 ADC电路 – VCC、GND、SCL和SDA如前所述连接到Raspberry Pi
- en: As you can see, excluding the sensors, there are only five additional components.
    We have a power-filtering capacitor (C1) and the power-indicating LED (D2) with
    a current-limiting resistor (R5), all of which are optional.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，除了传感器外，只有五个额外的组件。我们有一个电源滤波电容（C1）和电源指示LED（D2）以及限流电阻（R5），所有这些都是可选的。
- en: It should be noted that the module includes two 10k pull-up resistors (R8 and
    R9) for SCL and SDA signals. However, since the GPIO I²C connections on the Raspberry
    Pi also include pull-up resistors, these are not needed on the module (and could
    be removed). It also means we should only connect this module to VCC=3.3V (if
    we use 5V, then voltages on SCL and SDA will be around 3.56V, which is too high
    for the Raspberry Pi GPIO pins).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 应注意，该模块包含两个10k上拉电阻（R8和R9）用于SCL和SDA信号。然而，由于Raspberry Pi上的GPIO I²C连接也包含上拉电阻，因此在该模块上不需要这些电阻（并且可以移除）。这也意味着我们应仅将此模块连接到VCC=3.3V（如果我们使用5V，则SCL和SDA上的电压将约为3.56V，这对Raspberry
    Pi的GPIO引脚来说太高）。
- en: The sensors on the PCF891 module are all resistive, so the voltage level that
    is present on analog input will change between GND and VCC as the resistance of
    the sensor changes.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: PCF891模块上的传感器都是电阻性的，因此当传感器的电阻变化时，模拟输入上的电压将在GND和VCC之间变化。
- en: '![Using just the PCF8591 chip or adding alternative sensors](img/6623OT_07_008.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![仅使用PCF8591芯片或添加替代传感器](img/6623OT_07_008.jpg)'
- en: A potential divider circuit is used to provide a voltage proportional to the
    sensor's resistance
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 电位分压器电路用于提供与传感器电阻成比例的电压
- en: The module uses a circuit known as a potential divider. The resistor at the
    top balances the resistance provided by the sensor at the bottom to provide a
    voltage that is somewhere between VCC and GND.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块使用一种称为电位分压器的电路。顶部的电阻平衡底部传感器的电阻，以提供介于VCC和GND之间的电压。
- en: 'The output voltage (*Vout*) of the potential divider can be calculated as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 电位分压器输出电压（*Vout*）的计算如下：
- en: '![Using just the PCF8591 chip or adding alternative sensors](img/6623OT_07_009.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![仅使用PCF8591芯片或添加替代传感器](img/6623OT_07_009.jpg)'
- en: The Rt and Rb are the resistance values at the top and bottom respectively,
    and VCC is the supply voltage.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Rt和Rb分别是顶部和底部的电阻值，VCC是供电电压。
- en: The potentiometer in the module has the 10k ohm resistance split between top
    and bottom depending on the position of the adjuster. So, halfway, we have 5k
    ohm on each side and an output voltage of 1.65V; a quarter of the way (clockwise),
    we have 2.5k ohm and 7.5k ohm, producing 0.825V.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 模块中的电位计电阻在顶部和底部之间根据调节器的位置分为10k欧姆。因此，在中点，每侧有5k欧姆，输出电压为1.65V；四分之一处（顺时针方向），我们有2.5k欧姆和7.5k欧姆，产生0.825V。
- en: Note
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: I've not shown the AOUT circuit, which is a resistor and LED. However, as you
    will find, an LED isn't suited to indicate an analog output (except to show the
    on/off states).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我没有展示AOUT电路，它是一个电阻和LED。然而，正如您将发现的，LED不适合指示模拟输出（除了显示开/关状态）。
- en: For more sensitive circuits, you can use more complex circuits such as a **Wheatstone
    bridge** (which allows the detection of very small changes in resistance), or
    you can use dedicated sensors that output an analog voltage based on their readings
    (such as a **TMP36** temperature sensor). The PCF891 also supports the differential
    input mode, where one channel can be compared to the input of another (the resultant
    reading will be the difference between the two).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更敏感的电路，您可以使用更复杂的电路，如**惠斯通电桥**（允许检测非常小的电阻变化），或者您可以使用基于其读数的专用传感器输出模拟电压（如**TMP36**温度传感器）。PCF891还支持差分输入模式，其中一个通道可以与另一个通道的输入进行比较（结果读数将是两个之间的差值）。
- en: For more information on the PCF8591 chip, refer to the datasheet at [http://www.nxp.com/documents/data_sheet/PCF8591.pdf](http://www.nxp.com/documents/data_sheet/PCF8591.pdf).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 关于PCF8591芯片的更多信息，请参阅[http://www.nxp.com/documents/data_sheet/PCF8591.pdf](http://www.nxp.com/documents/data_sheet/PCF8591.pdf)的数据表。
- en: Reading analog data using an analog-to-digital converter
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模数转换器读取模拟数据
- en: The I2CTools (used in the previous section) are very useful for debugging I²C
    devices on the command line, but they are not practical for use within Python,
    as they would be slow and require significant overhead to use. Fortunately, there
    are several Python libraries that provide I²C support, allowing efficient use
    of I²C to communicate with connected devices and provide easy operation.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: I2CTools（在上一节中使用）在命令行中调试I²C设备非常有用，但它们在Python中使用并不实用，因为它们会变慢，并且使用时需要大量的开销。幸运的是，有几个Python库提供了I²C支持，允许高效地使用I²C与连接的设备通信并提供易于操作。
- en: We will use such a library to create our own Python module that will allow us
    to quickly and easily obtain data from the ADC device and use it in our programs.
    The module is designed in such a way that other hardware or data sources may be
    put in its place without impacting the remaining examples.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这样的库来创建自己的Python模块，使我们能够快速轻松地从ADC设备获取数据，并在我们的程序中使用它。该模块设计得如此之好，以至于其他硬件或数据源可以替换它，而不会影响剩余的示例。
- en: Getting ready
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: To use the I²C bus using Python 3, we will use Gordon Henderson's `wiringPi2`
    (see [http://wiringpi.com/](http://wiringpi.com/) for more details).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Python 3的I²C总线，我们将使用Gordon Henderson的`wiringPi2`（更多详情请见[http://wiringpi.com/](http://wiringpi.com/)）。
- en: The easiest way to install `wiringPi2` is by using PIP for Python 3\. PIP is
    a package manager for Python that works in a similar way to `apt-get`. Any packages
    you wish to install will be automatically downloaded and installed from an online
    repository.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 安装`wiringPi2`最简单的方法是使用Python 3的PIP。PIP是Python的一个包管理器，其工作方式与`apt-get`类似。您希望安装的任何包都将自动从在线仓库下载并安装。
- en: 'To install PIP, use the following command:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装PIP，请使用以下命令：
- en: '[PRE15]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then install `wiringPi2` with the following command:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用以下命令安装`wiringPi2`：
- en: '[PRE16]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Once the install has completed, you should see the following, indicating success:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，您应该会看到以下内容，表示成功：
- en: '![Getting ready](img/6623OT_07_010.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](img/6623OT_07_010.jpg)'
- en: Successfully installed wiringPi2
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 成功安装wiringPi2
- en: You will need the PCF8591 module wired as before to the I²C connections of the
    Raspberry Pi.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要将PCF8591模块按照之前的方式连接到Raspberry Pi的I²C连接。
- en: '![Getting ready](img/6623OT_07_011.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](img/6623OT_07_011.jpg)'
- en: The PCF8591 module and pin connections to the Raspberry Pi GPIO connector (as
    used in the previous section)
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: PCF8591模块和引脚连接到Raspberry Pi的GPIO连接器（如前所述）
- en: How to do it...
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: In the next section, we shall write a script to allow us to gather data that
    we will then use later on in this chapter.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将编写一个脚本，使我们能够收集数据，然后在本章的后续部分使用这些数据。
- en: 'Create the following script, `data_adc.py`, as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 创建以下脚本，`data_adc.py`，如下所示：
- en: 'First, import the modules and create the variables we will use, as follows:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，导入模块并创建我们将使用的变量，如下所示：
- en: '[PRE17]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Create the class called `device` with a constructor to initialize it, as follows:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`device`的类，并使用构造函数来初始化它，如下所示：
- en: '[PRE18]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Within the class, define a function to provide a list of channel names as follows:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类中，定义一个函数以提供如下通道名称列表：
- en: '[PRE19]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Define another function (still as part of the class) to return a new set of
    samples from the ADC channels as follows:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义另一个函数（仍然作为类的一部分），以如下方式返回来自ADC通道的新样本集：
- en: '[PRE20]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Finally, after the device class, create a test function to exercise our new
    `device` class as follows. This is only to be run when the script is executed
    directly:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在设备类之后，创建一个测试函数来测试我们的新`device`类，如下所示。这仅在脚本直接执行时运行：
- en: '[PRE21]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You can run the test function of this module using the following command:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令运行此模块的测试函数：
- en: '[PRE22]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How it works...
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We start by importing `wiringpi2` so we can communicate with our I²C device
    later on. We will create a class to contain the required functionality to control
    the ADC. When we create the class, we can initialize `wiringPi2` in such a way
    that it is ready to use the I²C bus (using `wiringpi2.I2C()`), and we set up a
    generic I²C device with the chip's bus address (using `self.i2c.setup(0x48)`).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入 `wiringpi2`，以便我们稍后可以与我们的 I²C 设备通信。我们将创建一个类来包含控制 ADC 所需的功能。当我们创建类时，我们可以初始化
    `wiringPi2` 以便它可以使用 I²C 总线（使用 `wiringpi2.I2C()`），并且我们使用芯片的总线地址设置一个通用的 I²C 设备（使用
    `self.i2c.setup(0x48)`）。
- en: Note
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`wiringPi2` also has a dedicated class to use with the PCF8591 chip; however,
    in this case, it is more useful to use the standard I²C functionality to illustrate
    how any I²C device can be controlled using `wiringPi2`. By referring to the device
    datasheet, you can use similar commands to communicate to any connected I²C device
    (whether it is directly supported or not).'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`wiringPi2` 还有一个用于与 PCF8591 芯片一起使用的专用类；然而，在这种情况下，使用标准的 I²C 功能来展示如何使用 `wiringPi2`
    控制任何 I²C 设备更有用。通过参考设备数据表，你可以使用类似的命令与任何连接的 I²C 设备通信（无论它是否直接受支持）。'
- en: As before, we perform a device read and configure the ADC to cycle through the
    channels, but instead of `i2cget` and `i2cset`, we use the `wiringPi2` read and
    write functions of the I²C object. Once initialized, the device will be ready
    to read the analog signals on each of the channels.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们执行设备读取并配置 ADC 在通道之间循环，但不是使用 `i2cget` 和 `i2cset`，而是使用 I²C 对象的 `wiringPi2`
    读写函数。一旦初始化，设备将准备好读取每个通道上的模拟信号。
- en: The class will also have two member functions. The first function, `getName()`,
    returns a list of channel names (which we can use to correlate our data to its
    source) and the second function, `getNew()`, returns a new set of data from all
    the channels. The data is read from ADC using the `i2c.read()` function and, since
    we have already put it into cycle mode, each read will be from the next channel.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 该类还将有两个成员函数。第一个函数 `getName()` 返回一个通道名称列表（我们可以用它来关联我们的数据与其来源），第二个函数 `getNew()`
    返回所有通道的新数据集。数据通过 `i2c.read()` 函数从 ADC 读取，并且由于我们已经将其置于循环模式，每次读取都将来自下一个通道。
- en: As we plan to reuse this class later on, we will use the `if __name__` test
    to allow us to define some code to run when we execute the file directly. Within
    our `main()` function, we create ADC, which is an instance of our new device class.
    We can choose to select a non-default address if we need to; otherwise, the default
    address for the chip will be used. We use the `getName()` function to print out
    the names of the channels and then we can collect data from the `ADC` (using `getNew()`)
    and display them.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们计划稍后重用此类，我们将使用 `if __name__` 测试来允许我们在直接执行文件时运行一些代码。在我们的 `main()` 函数中，我们创建了一个
    ADC 实例，它是我们新设备类的一个实例。如果我们需要，可以选择非默认地址；否则，将使用芯片的默认地址。我们使用 `getName()` 函数打印出通道名称，然后我们可以从
    `ADC`（使用 `getNew()`）收集数据并显示它们。
- en: There's more...
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The following allows us to define an alternative version of the device class
    in `data_adc.py` so it can be used in place of the ADC module. This will allow
    the remaining sections of the chapter to be tried without needing any specific
    hardware.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 以下内容允许我们在 `data_adc.py` 中定义设备类的替代版本，以便它可以替代 ADC 模块使用。这将使得本章剩余部分可以在不需要任何特定硬件的情况下进行尝试。
- en: Gathering analog data without hardware
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无硬件收集模拟数据
- en: If you don't have an ADC module available, there is a wealth of data available
    from within Raspberry Pi that you can use instead.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有 ADC 模块可用，Raspberry Pi 内部有大量数据可供使用。
- en: 'Create the following script, `data_local.py`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 创建以下脚本，`data_local.py`：
- en: '[PRE23]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The preceding script allows us to gather system information from the Raspberry
    Pi using the following commands (the `subprocess` module allows us to capture
    the results and process them):'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 以下脚本允许我们使用以下命令从 Raspberry Pi 收集系统信息（`subprocess` 模块允许我们捕获结果并处理它们）：
- en: 'CPU speed:'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CPU 速度：
- en: '[PRE24]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'CPU load:'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CPU 负载：
- en: '[PRE25]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Core temperature (scaled by 1,000):'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 核心温度（按 1,000 缩放）：
- en: '[PRE26]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Drive info:'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 驱动信息：
- en: '[PRE27]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'RAM info:'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RAM 信息：
- en: '[PRE28]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Each data item is sampled using one of the functions. In the case of the drive
    and RAM information, we split the response into a list (separated by spaces) and
    select the items that we want to monitor (such as available memory and used drive
    space).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 每个数据项使用其中一个函数进行采样。在驱动和 RAM 信息的情况下，我们将响应拆分为一个列表（由空格分隔）并选择我们想要监控的项目（如可用内存和已用驱动器空间）。
- en: This is all packaged up to function in the same way as the `data_adc.py` file
    and the `device` class (so you can choose to use either in the following examples
    just by swapping the `data_adc` include with `data_local`).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都被打包起来，以便以与 `data_adc.py` 文件和 `device` 类相同的方式工作（因此你可以在以下示例中选择使用其中一个，只需将 `data_adc`
    包含文件替换为 `data_local`）。
- en: Logging and plotting data
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志记录和绘图数据
- en: Now that we are able to sample and collect a lot of data, it is important that
    we can capture and analyze it. We will make use of a Python library called `matplotlib`,
    which includes lots of useful tools for manipulating, graphing, and analyzing
    data. We will use `pyplot` (which is a part of `matplotlib`) to produce graphs
    of our captured data. For more information on `pyplot`, go to [http://matplotlib.org/users/pyplot_tutorial.html](http://matplotlib.org/users/pyplot_tutorial.html).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够采样和收集大量数据，因此我们能够捕获和分析它变得非常重要。我们将使用一个名为 `matplotlib` 的 Python 库，它包括许多用于操作、绘图和分析数据的实用工具。我们将使用
    `pyplot`（它是 `matplotlib` 的一部分）来生成我们捕获数据的图表。有关 `pyplot` 的更多信息，请访问 [http://matplotlib.org/users/pyplot_tutorial.html](http://matplotlib.org/users/pyplot_tutorial.html)。
- en: Getting ready
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To use `pyplot`, we will need to install `matplotlib`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `pyplot`，我们需要安装 `matplotlib`。
- en: Note
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Due to a problem with the `matplotlib` installer, performing the installation
    using pip-3.2 doesn't always work correctly. The method that follows will overcome
    this problem by performing all the steps PIP does manually; however, this can
    take over 30 minutes to complete.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `matplotlib` 安装程序的问题，使用 pip-3.2 进行安装并不总是正确。以下方法将通过手动执行 PIP 所做的所有步骤来克服这个问题；然而，这可能需要超过
    30 分钟才能完成。
- en: To save time, you can try the PIP installation, which is much quicker. If it
    doesn't work, you can install it using this manual method.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 为了节省时间，你可以尝试使用 PIP 安装，这会快得多。如果不起作用，你可以使用这种方法手动安装。
- en: 'Try installing `matplotlib` using PIP with the following commands:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用以下命令使用 PIP 安装 `matplotlib`：
- en: '[PRE29]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You can confirm `matplotlib` has installed by running `python3` and trying
    to import it from the Python terminal, as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过运行 `python3` 并尝试从 Python 终端导入它来确认 `matplotlib` 是否已安装，如下所示：
- en: '[PRE30]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'If the installation failed, it will respond with the following:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果安装失败，它将响应如下：
- en: '[PRE31]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Otherwise, there will be no errors.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，将没有错误。
- en: 'Use the following steps to install `matplotlib` manually:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下步骤手动安装 `matplotlib`：
- en: 'Install the support packages as follows:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式安装支持包：
- en: '[PRE32]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Download the source files from the Git repository (the command should be a
    single line) as follows:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 Git 仓库下载源文件（命令应该是一行）如下：
- en: '[PRE33]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Unzip and open the `matplotlib-master` folder created, as follows:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解压并打开创建的 `matplotlib-master` 文件夹，如下所示：
- en: '[PRE34]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Run the setup file to build (this will take a while) and install it as follows:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行设置文件进行构建（这将需要一段时间）并按如下方式安装：
- en: '[PRE35]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Test the installation in the same way as the automated install.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以与自动安装相同的方式进行安装测试。
- en: We will either need the PCF8591 ADC module (and `wiringPi2` installed as before),
    or we can use the `data_local.py` module from the previous section (just replace
    `data_adc` with `data_local` in the import section of the script). We also need
    to have `data_adc.py` and `data_local.py` in the same directory as the new script,
    depending on which you use.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能需要 PCF8591 ADC 模块（并且之前已安装 `wiringPi2`），或者我们可以使用上一节中的 `data_local.py` 模块（只需在脚本的导入部分将
    `data_adc` 替换为 `data_local`）。我们还需要将 `data_adc.py` 和 `data_local.py` 放在新脚本相同的目录中，具体取决于你使用哪个。
- en: How to do it...
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Create the following script, `log_adc.py`:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建以下脚本，`log_adc.py`：
- en: '[PRE36]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Create a second script, `log_graph.py`, as follows:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建第二个脚本，`log_graph.py`，如下所示：
- en: '[PRE37]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: How it works...
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The first script, `log_adc.py`, allows us to collect data and write it to a
    logfile.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个脚本 `log_adc.py` 允许我们收集数据并将其写入日志文件。
- en: 'We can use the ADC device by importing `data_adc` as `dataDevice` or we can
    import `data_local` to use the system data. The numbers given to `VAL0` through
    `VAL3` allow us to change the order of the channels (and if using the `data_local`
    device, select the other channels). We also define the format string for the header
    and each line in the logfile (to create a file with data separated by tabs) using
    `%s`, `%d`, and `%f` to allow us to substitute strings, integers, and float values,
    as shown in the following table:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将 `data_adc` 导入为 `dataDevice` 来使用 ADC 设备，或者我们可以导入 `data_local` 来使用系统数据。给
    `VAL0` 到 `VAL3` 分配的数字允许我们更改通道的顺序（如果使用 `data_local` 设备，则选择其他通道）。我们还定义了日志文件中标题和每行的格式字符串（以创建一个用制表符分隔数据的文件），使用
    `%s`，`%d` 和 `%f` 来允许我们替换字符串、整数和浮点值，如下表所示：
- en: '![How it works...](img/6623OT_07_012.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/6623OT_07_012.jpg)'
- en: The table of data captured from the ADC sensor module
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 从 ADC 传感器模块捕获的数据表
- en: If logging in to the file (when `FILE=True`), we open `data.log` in write mode
    using the `'w'` option (this will overwrite any existing files; to append to a
    file, use `'a'`).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将日志记录到文件（当 `FILE=True` 时），我们使用 `'w'` 选项以写入模式打开 `data.log`（这将覆盖任何现有文件；要追加到文件，请使用
    `'a'`）。
- en: As part of our data log, we generate `timestamp` using `time` and `datetime`
    to get the current **Epoch time** (this is the number of milliseconds since Jan
    1, 1970) using the `time.time()` command. We convert the value into a more friendly
    `year-month-day hour:min:sec` format using `strftime()`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 作为我们数据日志的一部分，我们使用 `time` 和 `datetime` 生成 `timestamp`，以获取当前的 **纪元时间**（这是自 1970
    年 1 月 1 日以来的毫秒数），使用 `time.time()` 命令。我们使用 `strftime()` 将值转换为更友好的 `年-月-日 时:分:秒`
    格式。
- en: The `main()` function starts by creating an instance of our `device` class (we
    made this in the previous example), which will supply the data. We fetch the channel
    names from the `data` device and construct the `header` string. If `DEBUG` is
    set to `True`, the data is printed to screen; if `FILE` is set to `True`, it will
    be written to file.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()` 函数首先创建我们 `device` 类的一个实例（我们在前面的示例中创建了它），这将提供数据。我们从 `data` 设备获取通道名称并构建
    `header` 字符串。如果 `DEBUG` 设置为 `True`，数据将被打印到屏幕上；如果 `FILE` 设置为 `True`，它将被写入文件。'
- en: 'In the main loop, we use the `getNew()` function of the device to collect data
    and format it to display on screen or log to the file. The `main()` function is
    called using the `try: finally:` command, which will ensure that when the script
    is aborted the file will be correctly closed.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '在主循环中，我们使用设备的 `getNew()` 函数收集数据并将其格式化以在屏幕上显示或记录到文件。使用 `try: finally:` 命令调用
    `main()` 函数，这将确保当脚本被终止时，文件将被正确关闭。'
- en: 'The second script, `log_graph.py`, allows us to read the logfile and produce
    a graph of the recorded data, as shown in the following figure:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个脚本 `log_graph.py` 允许我们读取日志文件并生成记录数据的图表，如下所示：
- en: '![How it works...](img/6623OT_07_013.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/6623OT_07_013.jpg)'
- en: Graphs produced by log_graph.py from the light and temperature sensors
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 由 light 和温度传感器生成的 log_graph.py 产生的图表
- en: We start by opening up the logfile and reading the first line; this contains
    the header information (which we can then use to identify the data later on).
    Next, we use `numpy`, a specialist Python library that extends how we can manipulate
    data and numbers. In this case, we use it to read in the data from the file, split
    it up based on the tab delimiter, and provide identifiers for each of the data
    channels.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先打开日志文件并读取第一行；这包含标题信息（然后我们可以使用它来识别后续的数据）。接下来，我们使用 `numpy`，这是一个专业的 Python
    库，它扩展了我们可以操作数据和数字的方式。在这种情况下，我们使用它来读取文件中的数据，根据制表符分隔符拆分它，并为每个数据通道提供标识符。
- en: We define a figure to hold our graphs, adding two subplots (located in a 2 x
    1 grid and positions 1 and 2 in the grid – set by the values `211` and `212`).
    Next, we define the values we want to plot, providing the `x` values (`data['sample']`),
    the `y` values (`data['DATA0']`), the `color` value (`'r'` which is `Red` or `'b'`
    for `Blue`), and `label` (set to the heading text we read previously from the
    top of the file).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义一个图形来保存我们的图表，添加两个子图（位于 2 x 1 网格中，网格位置为 1 和 2 - 由值 `211` 和 `212` 设置）。接下来，我们定义我们想要绘制的值，提供
    `x` 值（`data['sample']`），`y` 值（`data['DATA0']`），`color` 值（`'r'` 代表红色或 `'b'` 代表蓝色），以及
    `label`（设置为从文件顶部读取的标题文本）。
- en: Finally, we set a title, `x` and `y` labels for each subplot, enable legends
    (to show the labels), and display the plot (using `plt.show()`).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们为每个子图设置一个标题，`x` 和 `y` 标签，启用图例（以显示标签），并显示图表（使用 `plt.show()`）。
- en: There's more...
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Now that we have the ability to see the data we have been capturing, we can
    take things even further by displaying it as we sample it. This will allow us
    to instantly see how the data reacts to changes in the environment or stimuli.
    We can also calibrate our data so that we can assign the appropriate scaling to
    produce measurements in real units.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了查看我们一直在捕获的数据的能力，我们可以通过在采样时显示数据来更进一步。这将使我们能够立即看到数据如何对环境或刺激的变化做出反应。我们还可以校准数据，以便我们可以分配适当的缩放比例以产生实际单位中的测量值。
- en: Plotting live data
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实时数据绘图
- en: Besides plotting data from files, we can use `matplotlib` to plot sensor data
    as it is sampled. To achieve this, we can use the `plot-animation` feature, which
    automatically calls a function to collect new data and update our plot.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 除了从文件中绘制数据外，我们还可以使用`matplotlib`绘制采样时的传感器数据。为了实现这一点，我们可以使用`plot-animation`功能，该功能会自动调用一个函数来收集新数据并更新我们的图表。
- en: 'Create the following script, `live_graph.py`:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 创建以下脚本，`live_graph.py`：
- en: '[PRE38]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We start by defining our `dataDevice` object and creating an empty array, `dispdata[]`,
    which will hold all the data collected. Next, we define our subplot and the line
    we are going to plot.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义我们的`dataDevice`对象并创建一个空数组`dispdata[]`，它将保存所有收集到的数据。接下来，我们定义我们的子图和将要绘制的线条。
- en: The `FuncAnimation()` function allows us to update a figure (`fig`) by defining
    an update function and a generator function. The generator function (`data_gen()`)
    will be called every interval (1,000 ms) and will produce a data value.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`FuncAnimation()`函数允许我们通过定义一个更新函数和一个生成函数来更新一个图形（`fig`）。生成函数（`data_gen()`）将每隔（1,000毫秒）被调用一次，并产生一个数据值。'
- en: This example uses the core temperature reading that, when divided by 1,000,
    gives the actual temperature in `degC`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例使用核心温度读数，当除以1,000时，给出实际的温度`degC`。
- en: Tip
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'To use the ADC data instead, change the import for `dataDevice` to `data_adc`
    and adjust the following line to use a channel other than `[1]` and apply a scaling
    that is different from 1,000:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用ADC数据，请将`dataDevice`的导入更改为`data_adc`，并调整以下行以使用除`[1]`以外的通道，并应用不同于1,000的缩放比例：
- en: '[PRE39]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '![Plotting live data](img/6623OT_07_014.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![实时数据绘图](img/6623OT_07_014.jpg)'
- en: The Raspberry Pi plotting in real time (core temperature in degC versus time
    in seconds)
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 树莓派实时绘图（核心温度（以摄氏度为单位）与时间（以秒为单位））
- en: The data value is passed to the `update()` function, which allows us to add
    it to our `dispdata[]` array that will contain all the data values to be displayed
    in the plot. We adjust the *x* axis range to be near the `min` and `max` values
    of the data, as well as adjust the *y* axis to grow as we continue to sample more
    data.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 数据值传递给`update()`函数，这使得我们可以将其添加到我们的`dispdata[]`数组中，该数组将包含所有要在图中显示的数据值。我们调整*x*轴的范围，使其接近数据的`min`和`max`值，同时调整*y*轴，以便在继续采样更多数据时增长。
- en: Note
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `FuncAnimation()` function requires the `data_gen()` object to be a special
    type of function called `generator`. A `generator` function produces a continuous
    series of values each time it is called, and can even use its previous state to
    calculate the next value if required. This is used to perform continuous calculations
    for plotting; this is why it is used here. In our case, we just want to run the
    same sampling function (`new_data()`) continuously, so each time it is called,
    it will yield a new sample.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`FuncAnimation()`函数需要`data_gen()`对象是一个特殊类型的函数，称为`generator`。`generator`函数在每次被调用时都会产生一系列连续的值，如果需要，甚至可以使用其先前状态来计算下一个值。这用于执行绘图时的连续计算；这就是为什么在这里使用它的原因。在我们的情况下，我们只想连续运行相同的采样函数（`new_data()`），因此每次调用它时，它将产生一个新的样本。'
- en: Finally, we update the *x* and *y* axes data with our `dispdata[]` array (using
    the `set_data()` function), which will plot our samples against the number of
    seconds we are sampling. To use other data, or to plot data from the ADC, adjust
    the import for `dataDevice` and select the required channel (and scaling) in the
    `data_gen()` function.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用`dispdata[]`数组（使用`set_data()`函数）更新*x*和*y*轴的数据，这将绘制我们的样本与采样秒数的对应关系。要使用其他数据或绘制来自ADC的数据，请调整`dataDevice`的导入，并在`data_gen()`函数中选择所需的通道（和缩放比例）。
- en: Scaling and calibrating data
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据缩放和校准
- en: You may have noticed that it can sometimes be difficult to interpret data read
    from an ADC, since the value is just a number. A number isn't much help except
    to tell you it is slightly hotter or slightly darker than the previous sample.
    However, if you can use another device to provide comparable values (such as the
    current room temperature), you can then calibrate your sensor data to provide
    more useful real-world information.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，有时从模数转换器（ADC）读取的数据可能很难解释，因为它的值只是一个数字。除了告诉你它比前一个样本稍微热一点或暗一点之外，数字并没有太大的帮助。然而，如果你可以使用另一个设备提供可比较的值（例如当前房间温度），那么你可以校准你的传感器数据以提供更有用的现实世界信息。
- en: 'To obtain a rough calibration, we shall use two samples to create a linear
    fit model that can then be used to estimate real-world values for other ADC readings
    (this assumes the sensor itself is mostly linear in its response). The following
    figure shows a linear fit using two readings at 25 and 30 degrees Celsius, providing
    estimated ADC values for other temperatures:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得粗略的校准，我们将使用两个样本来创建一个线性拟合模型，然后可以使用该模型来估计其他ADC读取的真实世界值（这假设传感器本身的响应主要是线性的）。以下图显示了在25度和30摄氏度下的两个读取值，为其他温度提供了估计的ADC值：
- en: '![Scaling and calibrating data](img/6623OT_07_015.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![数据缩放和校准](img/6623OT_07_015.jpg)'
- en: Samples are used to linearly calibrate temperature sensor readings
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 样本用于线性校准温度传感器读取
- en: 'We can calculate our model using the following function:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下函数来计算我们的模型：
- en: '[PRE40]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This will return `cal`, which will contain the model slope (`A`) and offset
    (`C`).
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回`cal`，它将包含模型斜率（`A`）和偏移量（`C`）。
- en: 'We can then use the following function to calculate the value of any reading
    by using the calculated `cal` values for that channel:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下函数通过使用该通道计算出的`cal`值来计算任何读取的值：
- en: '[PRE41]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: For more accuracy, you can take several samples and use linear interpolation
    between the values (or fit the data to other more complex mathematical models),
    if required.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高精度，你可以取几个样本，并在值之间使用线性插值（或者根据需要将数据拟合到其他更复杂的数学模型）。
- en: Extending the Raspberry Pi GPIO with an I/O expander
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用I/O扩展器扩展Raspberry Pi GPIO
- en: As we have seen, making use of the higher-level bus protocols allows us to connect
    to more complex hardware quickly and easily. The I²C can be put to great use by
    using it to expand the available I/O on the Raspberry Pi as well as providing
    additional circuit protection (and, in some cases, additional power to drive more
    hardware).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，利用高级总线协议使我们能够快速轻松地连接到更复杂的硬件。通过使用I²C来扩展Raspberry Pi上的可用I/O以及提供额外的电路保护（在某些情况下，还可以提供额外的电源来驱动更多硬件），I²C可以得到很好的利用。
- en: There are lots of devices available that provide I/O expansion over the I²C
    bus (and also SPI), but the most commonly used is a 28-pin device, MCP23017, which
    provides 16 additional digital input/output pins. Being an I²C device, it only
    requires the two signals (SCL and SDA connections plus ground and power) and will
    happily function with other I²C devices on the same bus.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多设备可以提供I²C总线的I/O扩展（以及SPI），但最常用的是28引脚设备，MCP23017，它提供了16个额外的数字输入/输出引脚。作为一个I²C设备，它只需要两个信号（SCL和SDA连接加上地线和电源）并且可以与其他I²C设备在同一总线上愉快地工作。
- en: We shall see how the Adafruit I²C 16x2 RGB LCD Pi Plate makes use of one of
    these chips to control an LCD alphanumeric display and keypad over the I²C bus
    (without the I/O expander, this would normally require up to 15 GPIO pins).
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到Adafruit I²C 16x2 RGB LCD Pi Plate如何使用这些芯片之一来通过I²C总线控制LCD字符显示和键盘（如果没有I/O扩展器，这通常需要多达15个GPIO引脚）。
- en: Getting ready
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'You will need the Adafruit I²C 16x2 RGB LCD Pi Plate (which also includes five
    keypad buttons), and is shown in the following image:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 你将需要Adafruit I²C 16x2 RGB LCD Pi Plate（它还包括五个按键），如下图所示：
- en: '![Getting ready](img/6623OT_07_016.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/6623OT_07_016.jpg)'
- en: Adafruit I²C 16x2 RGB LCD Pi Plate with keypad buttons
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 带有按键的Adafruit I²C 16x2 RGB LCD Pi Plate
- en: The Adafruit I²C 16x2 RGB LCD Pi Plate directly connects to the GPIO connector
    of Raspberry Pi.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: Adafruit I²C 16x2 RGB LCD Pi Plate直接连接到Raspberry Pi的GPIO连接器。
- en: As before, we can use the PCF8591 ADC module or use the `data_local.py` module
    from the previous section (use `data_adc` or `data_local` in the import section
    of the script). The files `data_adc.py` and `data_local.py` should be in the same
    directory as the new script.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们可以使用PCF8591 ADC模块或使用上一节中的`data_local.py`模块（在脚本的导入部分使用`data_adc`或`data_local`）。`data_adc.py`和`data_local.py`文件应与新的脚本在同一目录中。
- en: Tip
  id: totrans-268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The LCD Pi Plate only requires five pins (SDA, SCL, GND, and 5V); it connects
    over the whole GPIO header. If we want to use it with other devices, such as the
    PCF8591 ADC module, then something similar to a TriBorg from PiBorg (which splits
    the GPIO port into three) can be used.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: LCD Pi板只需要五个引脚（SDA，SCL，GND和5V）；它连接到整个GPIO引脚头。如果我们想与其他设备一起使用它，例如PCF8591 ADC模块，则可以使用类似PiBorg的TriBorg（它将GPIO端口分成三个部分）。
- en: How to do it...
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Create the following script, `lcd_i2c.py`:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建以下脚本，`lcd_i2c.py`：
- en: '[PRE42]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'With the LCD module connected, run the script as follows:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接LCD模块后，按如下方式运行脚本：
- en: '[PRE43]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Select the data channel you want to display using the left and right buttons
    and press the **SELECT** button to exit.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 使用左右按钮选择要显示的数据通道，然后按**SELECT**按钮退出。
- en: How it works...
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `wiringPi2` library has excellent support for I/O expander chips, like
    the one used for the AdaFruit LCD Character module. To use the Adafruit module,
    we need to set up the pin mapping for all the pins of MCP23017 PortA, as shown
    in the following table (then we set up the I/O expander pins with an offset of
    `100`):'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`wiringPi2`库对I/O扩展器芯片（如用于AdaFruit LCD字符模块的芯片）有很好的支持。要使用Adafruit模块，我们需要为MCP23017端口A的所有引脚设置引脚映射，如下表所示（然后我们使用偏移量`100`设置I/O扩展器引脚）：'
- en: '| Name | SELECT | RIGHT | DOWN | UP | LEFT | GREEN | BLUE | RED |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| Name | SELECT | RIGHT | DOWN | UP | LEFT | GREEN | BLUE | RED |'
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- | --- | --- |'
- en: '| MCP23017 PortA | A0 | A1 | A2 | A3 | A4 | A6 | A7 | A8 |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| MCP23017 PortA | A0 | A1 | A2 | A3 | A4 | A6 | A7 | A8 |'
- en: '| WiringPiPin | 100 | 101 | 102 | 103 | 104 | 106 | 107 | 108 |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| WiringPiPin | 100 | 101 | 102 | 103 | 104 | 106 | 107 | 108 |'
- en: 'The pin mapping for all the pins of MCP23017 PortB are as follows:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: MCP23017端口B的所有引脚的引脚映射如下：
- en: '| Name | DB7 | DB6 | DB5 | DB4 | E | RW | RS |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| Name | DB7 | DB6 | DB5 | DB4 | E | RW | RS |'
- en: '| --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- | --- |'
- en: '| MCP23017 PortB | B1 | B2 | B3 | B4 | B5 | B6 | B7 |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| MCP23017 PortB | B1 | B2 | B3 | B4 | B5 | B6 | B7 |'
- en: '| WiringPiPin | 109 | 110 | 111 | 112 | 113 | 114 | 115 |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| WiringPiPin | 109 | 110 | 111 | 112 | 113 | 114 | 115 |'
- en: To set up the LCD screen, we initialize `wiringPiSetup()` and the I/O expander,
    `mcp23017Setup()`. We then specify the pin offset and bus address of the I/O expander.
    Next, we set all the hardware buttons as inputs (using `pinMode(pin number,0)`),
    and the RW pin of the LCD to an output. The `wiringPi2` LCD library expects the
    RW pin to be set to `LOW` (forcing it into read-only mode), so we set the pin
    to `LOW` (using `digitalWrite(AF_RW,0)`).
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置LCD屏幕，我们初始化`wiringPiSetup()`和I/O扩展器，`mcp23017Setup()`。然后我们指定I/O扩展器的引脚偏移和总线地址。接下来，我们将所有硬件按钮设置为输入（使用`pinMode(pin
    number,0)`），并将LCD的RW引脚设置为输出。`wiringPi2` LCD库期望RW引脚被设置为`LOW`（强制进入只读模式），因此我们将引脚设置为`LOW`（使用`digitalWrite(AF_RW,0)`）。
- en: We create an `lcd` object by defining the number of rows and columns of the
    screen, and whether we are using 4- or 8-bit data mode (we are using 4 of the
    8 data lines, so it is the 4-bit mode). We also provide the pin mapping of the
    pins we are using (the last four are set to `0` since we are only using four data
    lines).
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过定义屏幕的行数和列数，以及我们是否使用4位或8位数据模式（我们使用8条数据线中的4条，因此是4位模式）来创建一个`lcd`对象。我们还提供了我们使用的引脚映射（最后四条设置为`0`，因为我们只使用四条数据线）。
- en: Now we create a function called `PrintLCD()`, which will allow us to send strings
    to show on each line of the display. We use `lcdPosition()` to set the cursor
    position on the `lcd` object for each line and then print the text for each line.
    We also add some blank spaces at the end of each line to ensure the full line
    is overwritten.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们创建一个名为`PrintLCD()`的函数，它将允许我们向显示的每一行发送字符串。我们使用`lcdPosition()`在`lcd`对象上设置每行的光标位置，然后打印每行的文本。我们还在每行末尾添加一些空白空间，以确保整行被覆盖。
- en: The next function, `checkBtn()` briefly checks the left/right and select buttons
    to see if they have been pressed (using the `digitalRead()` function). If the
    left/right button has been pressed, then the index is set to the previous or next
    item in the array. If the **SELECT** button is pressed, then the `run` flag is
    set to `False` (this will exit the main loop, allowing the script to finish).
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个函数`checkBtn()`简要检查左右和选择按钮是否被按下（使用`digitalRead()`函数）。如果左右按钮被按下，则索引设置为数组中的前一个或下一个项目。如果**SELECT**按钮被按下，则`run`标志设置为`False`（这将退出主循环，允许脚本完成）。
- en: The `main()` function calls `gpiosetup()` to create our `lcd` object; then we
    create our `dataDevice` object and fetch the data names. Within the main loop,
    we get new data; then we use our `printLCD()` function to display the data name
    on the top line and the data value on the second line. Finally, we check to see
    whether the buttons have been pressed and set the index to our data as required.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示展示了如何将电压稳压器连接到I/O扩展器（或其他设备）以提供更多电流来驱动额外的硬件：
- en: There's more…
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Using an expander chip such as the MCP23017 provides an excellent way to increase
    the amount of hardware connectivity to the Raspberry Pi while also providing an
    additional layer of protection (it is cheaper to replace the expander chip Raspberry
    Pi).
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 使用如MCP23017的扩展器芯片提供了一种极好的方法来增加与树莓派的硬件连接数量，同时也提供了一层额外的保护（更换扩展器芯片比更换树莓派便宜）。
- en: I/O expander voltages and limits
  id: totrans-294
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: I/O扩展器电压和限制
- en: The port expander only uses a small amount of power when in use, but if you
    are powering it using the 3.3V supply, then you will still only be able to draw
    a maximum of 50 mA in total from all the pins. If you draw too much power, then
    you may experience system freezes or corrupted read/writes on the SD card.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 端口扩展器在使用时仅消耗少量电力，但如果您使用3.3V电源供电，那么您从所有引脚中总共只能抽取最大50 mA的电流。如果您抽取过多电力，那么您可能会遇到系统冻结或SD卡上的读/写损坏。
- en: If you power the expander using the 5V supply, then you can draw up to the maximum
    the expander can support (around 25 mA maximum per pin and 125 mA total) as long
    as your USB power supply is powerful enough.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用5V电源为扩展器供电，那么只要您的USB电源足够强大，您就可以抽取扩展器所能支持的最大电流（每个引脚最大约25 mA，总电流125 mA）。
- en: We must remember that if the expander is powered with 5V, the inputs/outputs
    and interrupt lines will also be 5V and should never be connected back to the
    Raspberry Pi (without using level shifters to translate the voltage down to 3.3V).
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须记住，如果扩展器使用5V供电，输入/输出和中断线也将是5V，并且绝不应该连接回树莓派（除非使用电平转换器将电压降至3.3V）。
- en: 'By changing the wiring of the address pins (A0, A1, and A2) on the expander
    chip, up to eight modules can be used on the same I²C bus simultaneously. To ensure
    there is enough current available for each, we would need to use a separate 3.3V
    supply. A linear regulator such as LM1117-3.3 would be suitable (this would provide
    up to 800 mA at 3.3V, 100 mA for each), and only needs the following simple circuit:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 通过改变扩展器芯片上的地址引脚（A0、A1和A2）的布线，可以同时使用多达八个模块在同一I²C总线上。为了确保每个模块都有足够的电流，我们需要使用单独的3.3V电源。一个如LM1117-3.3的线性稳压器就非常合适（这将在3.3V下提供高达800
    mA的电流，每个模块100 mA），并且只需要以下简单的电路：
- en: '![I/O expander voltages and limits](img/6623OT_07_017.jpg)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![I/O扩展器电压和限制](img/6623OT_07_017.jpg)'
- en: The LM1117 linear voltage regulator circuit
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: LM1117线性电压稳压器电路
- en: 'The following diagram shows how a voltage regulator can be connected to the
    I/O expander (or other device) to provide more current for driving extra hardware:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 使用您自己的I/O扩展器模块
- en: '![I/O expander voltages and limits](img/6623OT_07_018.jpg)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![I/O扩展器电压和限制](img/6623OT_07_018.jpg)'
- en: Using a voltage regulator with the Raspberry Pi
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 使用电压稳压器与树莓派一起使用
- en: The input voltage (Vin) is provided by the Raspberry Pi (for example, from the
    GPIO pin header, such as 5V pin 2). However, Vin could be provided by any other
    power supply (or battery pack) as long as it is between 4.5V and 15V and able
    to provide enough current. The important part is ensuring that the ground connections
    (GND) of the Raspberry Pi, the power supply (if a separate one is used), the regulator,
    and the I/O expander are all connected together (as a common ground).
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 输入电压（Vin）由树莓派提供（例如，来自GPIO引脚头，如5V引脚2）。然而，Vin可以由任何其他电源（或电池组）提供，只要它在4.5V到15V之间，并且能够提供足够的电流。重要的是确保树莓派、电源（如果使用单独的电源）、稳压器和I/O扩展器的地连接（GND）都连接在一起（作为公共地）。
- en: Using your own I/O expander module
  id: totrans-305
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![使用您自己的I/O扩展器模块](img/6623OT_07_019.jpg)'
- en: 'You can use one of the I/O expander modules that are available (or just the
    MCP23017 chip in the following circuit) to control most HD44780-compatible LCD
    displays:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用可用的I/O扩展器模块（或以下电路中的MCP23017芯片）来控制大多数与HD44780兼容的LCD显示器：
- en: '![Using your own I/O expander module](img/6623OT_07_019.jpg)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
  zh: '`main()`函数调用`gpiosetup()`来创建我们的`lcd`对象；然后我们创建我们的`dataDevice`对象并获取数据名称。在主循环中，我们获取新的数据；然后我们使用我们的`printLCD()`函数在顶部行显示数据名称，在第二行显示数据值。最后，我们检查按钮是否被按下，并根据需要设置索引到我们的数据。'
- en: The I/O expander and a HD44780-compatible display
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: I/O 扩展器和 HD44780 兼容显示屏
- en: The D-Pad circuit, which is explained in the recipe *The GPIO keypad input*
    in [Chapter 6](ch06.html "Chapter 6. Using Python to Drive Hardware"), *Using
    Python to Drive Hardware*, can also be connected to the remaining Port A pins
    of the expander (`PA0` to Button 1, `PA1` to Right, `PA2` to Down, `PA3` to Up,
    `PA4` to Left, and `PA5` to Button 2). As in the previous example, the buttons
    will be `PA0` to `PA4` (WiringPiPin number 100 to 104); apart from these, we have
    the second button added to `PA5` (WiringPiPin number 105).
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 6 章](ch06.html "第 6 章。使用 Python 驱动硬件") 的食谱 *The GPIO keypad input* 中解释的
    D-Pad 电路，也可以连接到扩展器的剩余 Port A 引脚（`PA0` 到按钮 1，`PA1` 到右，`PA2` 到下，`PA3` 到上，`PA4` 到左，`PA5`
    到按钮 2）。与前面的示例一样，按钮将是 `PA0` 到 `PA4`（WiringPiPin 编号 100 到 104）；除此之外，我们还在 `PA5`（WiringPiPin
    编号 105）上添加了第二个按钮。
- en: Directly controlling an LCD alphanumeric display
  id: totrans-310
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 直接控制 LCD 数码显示屏
- en: 'Alternatively, you can also drive the screen directly from the Raspberry Pi
    with the following connections:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您也可以使用以下连接直接从 Raspberry Pi 驱动屏幕：
- en: '| **LCD** | VSS | VDD | V0 | RS | RW | E | DB4 | DB5 | DB6 | DB7 |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| **LCD** | VSS | VDD | V0 | RS | RW | E | DB4 | DB5 | DB6 | DB7 |'
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |'
- en: '| **LCD Pin** | 1 | 2 | 3 | 4 | 5 | 6 | 11 | 12 | 13 | 14 |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| **LCD 引脚** | 1 | 2 | 3 | 4 | 5 | 6 | 11 | 12 | 13 | 14 |'
- en: '| **Raspberry Pi GPIO** | 6 (GND) | 2 (5V) | Contrast | 11 | 13 (GND) | 15
    | 12 | 16 | 18 | 22 |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| **Raspberry Pi GPIO** | 6 (GND) | 2 (5V) | 对比度 | 11 | 13 (GND) | 15 | 12
    | 16 | 18 | 22 |'
- en: The preceding table lists the connections required between the Raspberry Pi
    and the HD44780-compatible alphanumeric display module.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格列出了 Raspberry Pi 和 HD44780 兼容数码显示屏模块之间所需的连接。
- en: The contrast pin (V0) can be connected to a variable resistor as before (with
    one side on 5V and the other on GND); although, depending on the screen, you may
    find you can connect directly to GND/5V to obtain the maximum contrast.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 对比度引脚（V0）可以像以前一样连接到一个可变电阻（一边接 5V，另一边接 GND）；尽管如此，根据屏幕的不同，您可能发现可以直接连接到 GND/5V
    以获得最大对比度。
- en: The wiringPi2 LCD library assumes that the RW pin is connected to GND (read
    only); this avoids the risk that the LCD will send data back if connected directly
    to the Raspberry Pi (this would be a problem since the screen is powered by 5V
    and would send data using 5V logic).
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: wiringPi2 LCD 库假定 RW 引脚连接到 GND（只读）；这避免了 LCD 在直接连接到 Raspberry Pi 时发送数据的风险（这将是一个问题，因为屏幕由
    5V 供电，会使用 5V 逻辑发送数据）。
- en: Ensure you update the code with the new `AF_XX` references and refer to the
    physical pin number by changing the setup within the `gpiosetup()` function. We
    can also skip the setup of the MCP23017 device.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您使用新的 `AF_XX` 引用更新代码，并在 `gpiosetup()` 函数中更改设置以通过物理引脚编号进行引用。我们还可以跳过 MCP23017
    设备的设置。
- en: 'Have a look at the following commands:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下命令：
- en: '[PRE44]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Replace the preceding commands with the following command:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 将前面的命令替换为以下命令：
- en: '[PRE45]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: You can see that we only need to change the pin references to switch between
    using the I/O expander and not using it, which shows how convenient the wiringPi2
    implementation is.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，我们只需更改引脚引用即可在使用 I/O 扩展器和不使用它之间切换，这显示了 wiringPi2 实现的便利性。
- en: Capturing data in an SQLite database
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 SQLite 数据库中捕获数据
- en: Databases are a perfect way to store lots of structured data while maintaining
    the ability to access and search for specific data. **Structured Query Language**
    (**SQL**) is a standardized set of commands to update and query databases. For
    this example, we will use SQLite (a lightweight self-contained implementation
    of an SQL database system).
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库是存储大量结构化数据的同时保持访问和搜索特定数据能力的完美方式。**结构化查询语言**（**SQL**）是一组标准的命令，用于更新和查询数据库。在此示例中，我们将使用
    SQLite（一个轻量级的自包含 SQL 数据库系统实现）。
- en: In this chapter, we will gather raw data from our ADC (or local data source)
    and build our own database. We can then use a Python library called `sqlite3`
    to add data to a database and then query it.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从我们的 ADC（或本地数据源）收集原始数据，并构建我们自己的数据库。然后我们可以使用名为 `sqlite3` 的 Python 库将数据添加到数据库中，然后查询它。
- en: '[PRE46]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Getting ready
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To capture data in our database, we will install SQLite ready to use with Python''s
    `sqlite3` built-in module. Use the following command to install SQLite:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 要在数据库中捕获数据，我们将安装 SQLite 以与 Python 的 `sqlite3` 内置模块一起使用。使用以下命令安装 SQLite：
- en: '[PRE47]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Next, we will perform some basic operations with SQLite to see how to use SQL
    queries.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用 SQLite 执行一些基本操作，以了解如何使用 SQL 查询。
- en: 'Run SQLite directly, creating a new `test.db` database file with the following
    command:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 直接运行SQLite，使用以下命令创建一个新的`test.db`数据库文件：
- en: '[PRE48]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This will open a SQLite console within which we enter SQL commands directly.
    For example, the following commands will create a new table, add some data, display
    the content, and then remove the table:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在其中直接输入SQL命令的SQLite控制台内打开。例如，以下命令将创建一个新表，添加一些数据，显示内容，然后删除表：
- en: '[PRE49]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: You will need the same hardware setup as the previous recipe, as detailed in
    the *Getting ready* section of the *Using devices with the I²C bus* recipe.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要与之前配方中详细说明的*准备就绪*部分相同的硬件设置。
- en: How to do it...
  id: totrans-338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create the following script, `mysqlite_adc.py`:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '创建以下脚本，`mysqlite_adc.py`:'
- en: '[PRE50]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Note
  id: totrans-341
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you do not have the ADC module hardware, you can capture local data by setting
    the `dataDevice` module as `data_local`. Ensure you have `data_local.py` (from
    the *There''s more…* section in the *Reading analog data using an analog-to-digital
    converter* recipe) in the same directory as this script:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有ADC模块硬件，你可以通过将`dataDevice`模块设置为`data_local`来捕获本地数据。确保你有一个`data_local.py`（来自*还有更多…*部分中的*使用模拟数字转换器读取模拟数据*配方），它与该脚本位于同一目录下：
- en: '[PRE51]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This will capture the local data (RAM, CPU activity, temperature, and so on)
    to the SQLite database instead of ADC samples.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 这将捕获本地数据（RAM、CPU活动、温度等）到SQLite数据库，而不是ADC样本。
- en: How it works...
  id: totrans-345
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'When the script is first run, it will create a new SQLite database file called
    `mydatabase.db`, which will add a table named `recordeddata`. The table is generated
    by `createTable()`, which runs the following SQLite command:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 当脚本首次运行时，它将创建一个新的SQLite数据库文件，名为`mydatabase.db`，并添加一个名为`recordeddata`的表。该表由`createTable()`生成，它运行以下SQLite命令：
- en: '[PRE52]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The new table will contain the following data items:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 新表将包含以下数据项：
- en: '| Name | Description |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '| Name | Description |'
- en: '| --- | --- |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `itm_date` | Used to store the date of the data sample. When the data record
    is created the current date (using `date(''now'',''localtime'')`) is applied as
    the DEFAULT value. |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
  zh: '| `itm_date` | 用于存储数据样本的日期。当创建数据记录时，当前日期（使用`date(''now'',''localtime'')`）作为默认值应用。
    |'
- en: '| `itm_time` | Used to store the time of the data sample. When the data record
    is created the current time (using `time(''now'',''localtime'')`) is applied as
    the DEFAULT value. |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '| `itm_time` | 用于存储数据样本的时间。当创建数据记录时，当前时间（使用`time(''now'',''localtime'')`）作为默认值应用。
    |'
- en: '| `itm_name` | Used to record the name of the sample. |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
  zh: '| `itm_name` | 用于记录样本的名称。 |'
- en: '| `itm_value` | Used to keep the sampled value. |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
  zh: '| `itm_value` | 用于保存采样值。 |'
- en: 'We then use the same the method to capture ten data samples from the ADC as
    we did in the *Logging and plotting* *data* recipe previously (as shown in the
    function `captureSamples()`). However, this time we will then add the captured
    data into our new SQLite database table, using the following SQL command (applied
    using `cursor.execute(sqlquery)`):'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后使用与之前在*记录和绘图*数据配方中相同的方法从ADC捕获十个数据样本（如函数`captureSamples()`所示）。然而，这次我们将添加捕获的数据到我们新的SQLite数据库表中，使用以下SQL命令（通过`cursor.execute(sqlquery)`应用）：
- en: '[PRE53]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The current date and time will be added by default to each record as it is created.
    We end up with a set of 40 records (four records for every cycle of ADC samples
    captured), which are now stored in the SQLite database.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 每条记录在创建时都会默认添加当前日期和时间。最终我们得到一组40条记录（每个ADC采样周期有4条记录），这些记录现在存储在SQLite数据库中。
- en: '![How it works...](img/6623OT_07_020.jpg)'
  id: totrans-358
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/6623OT_07_020.jpg)'
- en: Eight ADC samples have been captured and stored in the SQLite database
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 已捕获并存储在SQLite数据库中的ADC样本有8个
- en: After the records have been created we must remember to call `cursor.commit()`,
    which will save all the new records to the database.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建记录后，我们必须记得调用`cursor.commit()`，这将保存所有新记录到数据库中。
- en: 'The last part of the script calls `displayAll()`, which will use the following
    SQL command:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本的最后部分调用`displayAll()`，它将使用以下SQL命令：
- en: '[PRE54]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This will select all of the data records in the `recordeddata` table, and we
    use `cursor.fetch()` to provide the selected data as a list we can iterate through:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 这将选择`recordeddata`表中的所有数据记录，我们使用`cursor.fetch()`提供选定的数据作为我们可以迭代的列表：
- en: '[PRE55]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This allows us to print out the full contents of the database, displaying the
    captured data.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们打印出数据库的全部内容，显示捕获的数据。
- en: Note
  id: totrans-366
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Notice that here we use the `try`, `except`, and `finally` constructs in this
    script to attempt to handle the mostly likely scenario users will face when running
    the script.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这里我们使用 `try`、`except` 和 `finally` 构造来尝试处理用户在运行脚本时可能遇到的大部分情况。
- en: First we ensure that if the database directory doesn't exist, we create it.
    Next we try opening the database file; this process will automatically create
    a new database file if one doesn't already exist. If either of these initial steps
    fail (due to not having read/write permissions, for example) we cannot continue
    so we report that we cannot open the database and simply exit the script.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们确保如果数据库目录不存在，我们创建它。接下来，我们尝试打开数据库文件；如果不存在数据库文件，此过程将自动创建一个新的数据库文件。如果这些初始步骤中的任何一个失败（例如，由于没有读写权限），我们无法继续，因此我们报告无法打开数据库并简单地退出脚本。
- en: Next, we try to open the required table within the database and display it;
    if the database file is brand new this operation will always fail as it will be
    empty. However, if this occurs we just catch the exception and create the table
    before continuing with the script to add our sampled data to the table and display
    it.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们尝试在数据库中打开所需的表并显示它；如果数据库文件是全新的，此操作将始终失败，因为它将是空的。然而，如果发生这种情况，我们只是捕获异常，在继续脚本以将样本数据添加到表并显示之前创建表。
- en: This allows the script to gracefully handle potential problems, take corrective
    action and then continue smoothly. The next time the script is run, the database
    and table will already exist, so we won't need to create them a second time and
    we can append the sample data to the table within the same database file.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许脚本优雅地处理潜在的问题，采取纠正措施，然后继续顺利运行。下次运行脚本时，数据库和表已经存在，因此我们不需要再次创建它们，我们可以将样本数据追加到同一数据库文件中的表内。
- en: There's more…
  id: totrans-371
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'There are many variants of SQL servers available (such as MySQL, Microsoft
    SQL Server, or PostgreSQL); however, they should at least have the following primary
    commands (or equivalent):'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的 SQL 服务器版本有很多（例如 MySQL、Microsoft SQL Server 或 PostgreSQL）；然而，它们至少应该具备以下主要命令（或等效命令）：
- en: '[PRE56]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: You should find that even if you choose to use a different SQL server to the
    SQLite one used here, the SQL commands will be relatively similar.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会发现，即使你选择使用与这里使用的 SQLite 不同的 SQL 服务器，SQL 命令也将相对相似。
- en: CREATE
  id: totrans-375
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CREATE
- en: 'The `CREATE TABLE` command is used to define a new table by specifying the
    column names (and also to set DEFAULT values if desired):'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '`CREATE TABLE` 命令用于通过指定列名（如果需要，还可以设置默认值）来定义新表：'
- en: '[PRE57]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The previous SQL command will create a new table called `table_name`, containing
    three data items. One column would contain text, another integers (for example,
    1, 3, -9) and finally one column for real numbers (for example, 5.6, 3.1749, 1.0).
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的 SQL 命令将创建一个名为 `table_name` 的新表，包含三个数据项。一列将包含文本，另一列包含整数（例如，1、3、-9），最后是一列用于实数（例如，5.6、3.1749、1.0）。
- en: INSERT
  id: totrans-379
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: INSERT
- en: 'The `INSERT` command will add a particular entry to a table in the database:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '`INSERT` 命令将向数据库中的表添加特定的条目：'
- en: '[PRE58]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This will enter the values provided into the corresponding columns in the table.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把提供的值输入到表中的相应列中。
- en: SELECT
  id: totrans-383
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SELECT
- en: 'The `SELECT` command allows us to specify a particular column or columns from
    the database table, returning a list of records with the data:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '`SELECT` 命令允许我们指定数据库表中的特定列或列，返回包含数据的记录列表：'
- en: '[PRE59]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Or to select all items, use this command:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 或者要选择所有项目，使用此命令：
- en: '[PRE60]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: WHERE
  id: totrans-388
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: WHERE
- en: 'The `WHERE` command is used to specify specific entries to be selected, updated,
    or deleted:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '`WHERE` 命令用于指定要选择、更新或删除的具体条目：'
- en: '[PRE61]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This will `SELECT` any records where the `column_name1` matches `'Terry Pratchett'`.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 这将 `SELECT` 任何 `column_name1` 与 `'Terry Pratchett'` 匹配的记录。
- en: UPDATE
  id: totrans-392
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: UPDATE
- en: 'The UPDATE command will allow us to change (`SET`) the values of data in each
    of the specified columns. We can also combine this with the `WHERE` command to
    limit the records the change is applied to:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '`UPDATE` 命令将允许我们更改（`SET`）指定列中的数据值。我们还可以将此与 `WHERE` 命令结合使用，以限制更改应用到的记录：'
- en: '[PRE62]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: DELETE
  id: totrans-395
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DELETE
- en: 'The `DELETE` command allows any records selected using `WHERE` to be removed
    from the specified table. However, if the whole table is selected, using `DELETE
    * FROM table_name` will delete the entire contents of the table:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '`DELETE` 命令允许使用 `WHERE` 选择的任何记录从指定的表中删除。但是，如果选择整个表，使用 `DELETE * FROM table_name`
    将删除表中的全部内容：'
- en: '[PRE63]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: DROP
  id: totrans-398
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DROP
- en: 'The `DROP` command allows a table to be removed completely from the database:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '`DROP` 命令允许将表完全从数据库中删除：'
- en: '[PRE64]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Be warned that this will permanently remove all the data that was stored in
    the specified table and the structure.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：这将永久删除指定表中存储的所有数据及其结构。
- en: Viewing data from your own webserver
  id: totrans-402
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看您自己的网络服务器上的数据
- en: Gathering and collecting information into databases is very helpful, but if
    it is locked inside a database or a file it isn't much use. However, if we allow
    the stored data to be viewed via a web page it will be far more accessible; not
    only can we view the data from other devices, we can also share it with others
    on the same network.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 收集和整理信息到数据库非常有用，但如果它们被锁在数据库或文件中，就没什么用了。然而，如果我们允许通过网页查看存储的数据，它将更容易访问；我们不仅可以从其他设备查看数据，还可以与同一网络上的其他人共享它。
- en: 'We shall create a local web server to query and display the captured SQLite
    data and allow it to be viewed through a PHP web interface. This will allow the
    data to be viewed, not only via the web browser on the Raspberry, Pi but also
    on other devices, such as cell phones or tablets, on the local network:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个本地网络服务器来查询和显示捕获的SQLite数据，并通过PHP网络界面允许查看。这将允许数据不仅可以通过Raspberry Pi的网络浏览器查看，还可以在本地网络上的其他设备，如手机或平板电脑上查看：
- en: '![Viewing data from your own webserver](img/6623OT_07_021.jpg)'
  id: totrans-405
  prefs: []
  type: TYPE_IMG
  zh: '![查看您自己的网络服务器上的数据](img/6623OT_07_021.jpg)'
- en: Data captured in the SQLite database displayed via a web-page
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 通过网页显示的SQLite数据库中捕获的数据
- en: Using a web server to enter and display information is a powerful way to allow
    a wide range of users to interact with your projects. The following example demonstrates
    a web server setup that can be customized for a variety of uses.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 使用网络服务器来输入和显示信息是允许广泛用户与您的项目互动的一种强大方式。以下示例演示了一个可以针对各种用途定制的网络服务器设置。
- en: Getting ready
  id: totrans-408
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Ensure you have completed the previous recipe so that the sensor data has been
    collected and stored in the SQLite database. We need to install a web server (**Apache2**)
    and enable PHP support to allow SQLite access.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您已完成了前面的食谱，以便传感器数据已被收集并存储在SQLite数据库中。我们需要安装一个网络服务器（**Apache2**）并启用PHP支持以允许SQLite访问。
- en: 'Use these commands to install a web server and PHP:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令安装一个网络服务器和PHP：
- en: '[PRE65]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The `/var/www/` directory is used by the web server; by default it will load
    `index.html` (or `index.php`), otherwise it will just display a list of the links
    to the files within the directory.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '`/var/www/` 目录由网络服务器使用；默认情况下，它将加载 `index.html`（或 `index.php`），否则它将仅显示目录内文件的链接列表。'
- en: 'To test the web server is running, create a default `index.html` page. To do
    this you will need to create the file using `sudo` permissions (the `/var/www/`
    directory is protected from changes made by normal users). Use the following command:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试网络服务器是否正在运行，创建一个默认的 `index.html` 页面。为此，您需要使用 `sudo` 权限创建文件（`/var/www/` 目录受普通用户更改的保护）。使用以下命令：
- en: '[PRE66]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Create `index.html` with the following content:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 创建包含以下内容的 `index.html`：
- en: '[PRE67]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Close and save the file (using *Ctrl + X*, *Y* and *Enter*).
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭并保存文件（使用 *Ctrl + X*，*Y* 和 *Enter*）。
- en: 'If you are using the Raspberry Pi with a screen, you can check it is working
    by loading the desktop:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用带有屏幕的Raspberry Pi，可以通过加载桌面来检查它是否工作：
- en: '[PRE68]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Then, open the web browser (**epiphany-browser**) and enter `http://localhost`
    as the address. You should see the following test page, indicating the web server
    is active:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，打开网络浏览器（**epiphany-browser**）并将 `http://localhost` 作为地址输入。您应该看到以下测试页面，表明网络服务器正在运行：
- en: '![Getting ready](img/6623OT_07_022.jpg)'
  id: totrans-421
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/6623OT_07_022.jpg)'
- en: Raspberry Pi browser displaying the test page, located at http://localhost
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: Raspberry Pi浏览器显示的测试页面，位于http://localhost
- en: If you are using the Raspberry Pi remotely or it is connected to your network,
    you should also be able to view the page on another computer on your network.
    First, identify the IP address of the Raspberry Pi (using `sudo hostname -I`)
    and then use this as the address in your web browser. You may even find you can
    use the actual hostname of the Raspberry Pi (by default this is [http://raspberrypi/](http://raspberrypi/)).
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您远程使用Raspberry Pi或它连接到您的网络，您也应该能够在您的网络上另一台计算机上查看该页面。首先，确定Raspberry Pi的IP地址（使用
    `sudo hostname -I`），然后在您的网络浏览器中使用此地址。您甚至可能发现您可以使用Raspberry Pi的实际主机名（默认情况下这是 [http://raspberrypi/](http://raspberrypi/)）。
- en: Note
  id: totrans-424
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you are unable to see the web page from another computer, ensure that you
    do not have a firewall enabled (on the computer itself or on your router) that
    could be blocking it.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您无法从另一台计算机上看到网页，请确保您没有启用防火墙（在计算机本身或您的路由器上），这可能正在阻止它。
- en: 'Next, we can test that PHP is operating correctly. We can create the following
    web page, `test.php`, and ensure it is located in the `/var/www/ directory`:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '![Getting ready](img/6623OT_07_023.jpg)'
  id: totrans-428
  prefs: []
  type: TYPE_IMG
- en: 'View the test.php page at the following location: http://localhost/test.php'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: We are ready to write our own PHP web page to view the data in the SQLite database.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-431
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create the following PHP files and save them in the webserver directory, `/var/www/./`.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following command to create the PHP file:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The `show_data_lite.php` file should contain:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Use the following command to create the PHP file:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Note
  id: totrans-439
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note: In order for the PHP code to delete the table within the database, it
    needs to be writable by the web server. Use the following command to allow it
    to be writable:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '`show_data_lite.php` will appear as a web page if you open it in a web browser
    by using the following address:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Alternatively, you can open the web page (including on another computer within
    your network) by referencing the IP address of the Raspberry Pi (use `hostname
    -I` to confirm the IP address):'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: You may be able to use the hostname instead (by default, this would make the
    address [http://raspberrypi/show_data_lite.php](http://raspberrypi/show_data_lite.php)).
    However, this may depend upon your network setup.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: If there is no data present, ensure you run the `mysqlite_adc.py` script to
    capture additional data.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the `show_data_lite.php` page display automatically when you visit
    the web address of your Raspberry Pi (instead of the "`It works!`" page), we can
    change the `index.html` to the following:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: This will automatically redirect the browser to load our `show_data_lite.php`
    page.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-451
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `show_data_lite.php` file shall display the temperature data that has been
    stored within the SQLite database (either from the ADC samples or local data sources).
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: 'The `show_data_lite.php` file consists of standard HTML code as well as a special
    PHP code section. The HTML code sets `ACD Data` as the title on the head section
    of the page and uses the following command to make the page automatically reload
    every 10 seconds:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Next, we define a `Delete` button, which will load the `del_data_lite.php`
    page when clicked:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Finally, we use the PHP code section to load the SQLite database and display
    the Channel 0 data.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the following PHP command to open the SQLite database we have previously
    stored data in (located at `/var/databases/testsites/mydatabase.db`):'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Next, we use the following SQLite query to select all the entries where the
    zone includes `0:` in the text (for example, `0:Light`):'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Note
  id: totrans-462
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice that even though we are now using PHP, the queries we use with the SQLite
    database are the same as we would use when using the SQLite3 Python module.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: 'We now collect the query result in the `$response` variable:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The `del_data_lite.php` file is fairly similar; it starts by reopening the
    `mydatabase.db` file as before. It then executes the following SQLite query:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: As described in the *There's more… DROP* section, this will remove the table
    `recordeddata` from the database. If the `response` isn't equal to 1, the action
    was not completed. The most likely reason for this is that the directory that
    contains the `mydatabase.db` file isn't writable by the web server (see the note
    in the *How to do it* section about changing the file owner to `www-data`).
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we provide another button that will take the user back to the `show_data_lite.php`
    page (which will show that the recorded data has now been cleared).
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/6623OT_07_024.jpg)'
  id: totrans-470
  prefs: []
  type: TYPE_IMG
- en: The del_data_lite.php page includes a button to return to the data display page
    (show_data_lite.php)
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  id: totrans-472
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You may have noticed that this recipe has focused more on HTML and PHP than
    Python (yes, check the cover, this is still a book for Python programmers!). However,
    it is important to remember that a key part of engineering is integrating and
    combining different technologies to produce desired results.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: By design, Python lends itself well to this kind of task since it allows easy
    customization and integration with a huge range of other languages and modules.
    We could just do it all in Python… but why not make use of the existing solutions
    instead? After all, they are usually well documented, have undergone extensive
    testing, and are often industry standards.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: Security
  id: totrans-475
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SQL databases are used in many places to store a wide range of information from
    product information to customer details. In such circumstances, users may be required
    to enter information which is then formed into SQL queries. In a poorly implemented
    system, a malicious user may be able to include additional SQL syntax in their
    response, allowing them to compromise the SQL database (such as access sensitive
    information, alter it, or simply delete it).
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, when asking for a username within a web page, the user could enter
    the following text:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'If this was used directly to construct the SQL query, we would end up with
    the following:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The result is we have just allowed the attacker to delete everything in the
    `CurrentOrders` table!
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: Using user input to form part of SQL queries means we have to be careful what
    commands we allow to be executed. In this example, the user may be able to wipe
    out potentially important information, which could be very costly for a company
    and its reputation.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: 'This technique is called SQL injection and is easily protected against by using
    the parameters option of the SQLite `execute()` function. We can replace our Python
    SQLite query with a safer version, as follows:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Instead of blindly building the SQL query, the SQLite module will first check
    that the provided parameters are valid values to enter into the database, then
    it will ensure that no additional SQL actions will result from inserting them
    into the command. Finally, the value of the `dataName` and `data[i]` parameters
    will be used to replace the `?` characters to generate the final safe SQLite query.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: Using MySQL instead
  id: totrans-486
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用MySQL代替
- en: SQLite, used in this recipe, is just one of many SQL databases available. It
    is helpful for small projects that only require relatively small databases and
    minimal resources. However, for larger projects that require additional features
    (such user accounts to control access and additional security), you can use alternatives
    such as MySQL.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中使用的SQLite只是许多SQL数据库中的一种。它适用于只需要相对较小的数据库和最少资源的较小项目。然而，对于需要额外功能（如用户账户以控制访问和额外的安全性）的较大项目，您可以使用MySQL等替代品。
- en: To use a different SQL database, you will need to adjust the Python code we
    used to capture the entries using a suitable Python module.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用不同的SQL数据库，您需要调整我们用来捕获条目的Python代码，以使用合适的Python模块。
- en: For MySQL (`mysql-server`) we can use a Python 3 compatible library called **PyMySQL**
    to interface with it. See the PyMySQL website ([https://github.com/PyMySQL/PyMySQL](https://github.com/PyMySQL/PyMySQL))
    for additional information about how to use this library.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 对于MySQL（`mysql-server`），我们可以使用一个与Python 3兼容的库，称为**PyMySQL**，来与之接口。有关如何使用此库的更多信息，请参阅PyMySQL网站（[https://github.com/PyMySQL/PyMySQL](https://github.com/PyMySQL/PyMySQL)）。
- en: To use PHP with MySQL, you will also need PHP MySQL (`php5-mysql`); for more
    information, see the excellent resource on W3 Schools ([http://www.w3schools.com/php/php_mysql_connect.asp](http://www.w3schools.com/php/php_mysql_connect.asp)).
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用PHP与MySQL，你还需要PHP MySQL（`php5-mysql`）；更多信息，请参阅W3 Schools上的优秀资源（[http://www.w3schools.com/php/php_mysql_connect.asp](http://www.w3schools.com/php/php_mysql_connect.asp)）。
- en: You will notice that although there are small differences between SQL implementations,
    the general concepts and commands should now be familiar to you whichever one
    you select.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到，尽管SQL实现之间有细微差别，但无论您选择哪个，一般概念和命令现在都应该熟悉。
- en: Sensing and sending data to online services
  id: totrans-492
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 感应并发送数据到在线服务
- en: In this section, we shall make use of an online service called Xively; the service
    allows us to connect, transmit, and view data online. Xively makes use of a common
    protocol that is used for transferring information over HTTP called REpresentational
    State Transfer (REST). REST is used by many services, such as Facebook and Twitter,
    using various keys and access tokens to ensure data is transferred securely between
    authorized applications and verified sites.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用一个名为Xively的在线服务；该服务允许我们在线连接、传输和查看数据。Xively使用一个常见的协议，即用于通过HTTP传输信息的REST协议。许多服务，如Facebook和Twitter，都使用各种密钥和访问令牌来确保数据在授权应用程序和验证网站之间安全传输。
- en: You can perform most REST operations (methods such as `POST`, `GET`, `SET`,
    and so on) manually using a Python library called `requests` ([http://docs.python-requests.org](http://docs.python-requests.org)).
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用一个名为`requests`的Python库手动执行大多数REST操作（如`POST`、`GET`、`SET`等），[http://docs.python-requests.org](http://docs.python-requests.org)。
- en: However, it is often easier to make use of specific libraries available for
    the service you intend to use. They will handle the authorization process; provide
    access functions; and, if the service changes, the library can be updated rather
    than your code.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，通常更容易使用为打算使用的服务提供的特定库。它们将处理授权过程；提供访问函数；如果服务发生变化，则可以更新库而不是您的代码。
- en: We will use the `xively-python` library, which provides Python functions to
    allow us to easily interact with the site.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`xively-python`库，它提供了Python函数，使我们能够轻松地与该网站交互。
- en: For details about the `xively-python` library, refer to [http://xively.github.io/xively-python/](http://xively.github.io/xively-python/).
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`xively-python`库的详细信息，请参阅[http://xively.github.io/xively-python/](http://xively.github.io/xively-python/)。
- en: 'The data collected by Xively is shown in the following screenshot:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: Xively收集的数据如下截图所示：
- en: '![Sensing and sending data to online services](img/6623OT_07_025.jpg)'
  id: totrans-499
  prefs: []
  type: TYPE_IMG
  zh: '![感应并发送数据到在线服务](img/6623OT_07_025.jpg)'
- en: Xively collects and graphs data transferred using REST
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: Xively收集并绘制使用REST传输的数据
- en: Getting ready
  id: totrans-501
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: You will need to create an account on [www.xively.com](http://www.xively.com),
    which we will use to receive our data. Go to the site and sign up for a free developer
    account (via the *Developer* section, [https://personal.xively.com/signup](https://personal.xively.com/signup)).
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在[www.xively.com](http://www.xively.com)上创建一个账户，我们将使用它来接收我们的数据。访问网站并注册一个免费的开发者账户（通过*开发者*部分，[https://personal.xively.com/signup](https://personal.xively.com/signup)）。
- en: '![Getting ready](img/6623OT_07_026.jpg)'
  id: totrans-503
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](img/6623OT_07_026.jpg)'
- en: Sign up and create a Xively account
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 注册并创建Xively账户
- en: Once you have registered and verified your account, you can follow the instructions
    that will take you through a test drive example. This will demonstrate linking
    to data from your smartphone (gyroscopic data, location, and so on), which will
    give you a taste of what we can do with the Raspberry Pi.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: 'When you log in, you will be taken to the **Development Devices** dashboard
    (located in the **WebTools** drop-down menu):'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/6623OT_07_027.jpg)'
  id: totrans-507
  prefs: []
  type: TYPE_IMG
- en: Adding a new device
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: Select **+Add Device** and fill in the details, giving your device a name and
    setting **Device** as **Private**.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: You will now see the control page for your remote device, which contains all
    the information you need to connect and also where your data will be displayed.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/6623OT_07_028.jpg)'
  id: totrans-511
  prefs: []
  type: TYPE_IMG
- en: Example API Key and feed number (this will be unique for your device)
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: 'Although there is a lot of information on this page, you only need two parts
    of it:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: 'The API Key (which is the long code in the `API Keys` section), as follows:'
  id: totrans-514
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-515
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'The feed number (referred to in the `API Keys` section and also listed at the
    top of the page), as follows:'
  id: totrans-516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-517
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Now that we have the details we need to connect with Xively, we can focus on
    the Raspberry Pi side of things.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use pip-3.2 to install Xively, as follows:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Ensure that the install reports the following:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: You are now ready to send some data from your Raspberry Pi.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-524
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create the following script, `xivelyLog.py`. Ensure you set `FEED_ID` and `API_KEY`
    within the code to match the device you created:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: How it works...
  id: totrans-527
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, we initialize the Xively API client, to which we supply `API_KEY` (this
    authorizes us to send data to the `Xively` device we created previously). Next,
    we use `FEED_ID` to link us to the specific feed we want to send the data to.
    Finally, we request the datastream to connect to (if it doesn't already exist
    in the feed, the `get_datastream()` function will create one for us).
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: For each datastream in the feed, we supply a `name` function and `tags` (these
    are keywords that help us identify the data; we can use our data names for this).
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
- en: Once we have defined our datastreams, we enter the `main` loop; here, we gather
    our data values from `dataDevice`. We then set the `current_value` function and
    also the timestamp of the data for each data item and apply it to our datastream
    objects.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
- en: Finally, when all the data is ready, we update each of the datastreams and the
    data is sent to Xively, appearing within a few moments on the dashboard for the
    device.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
- en: We can log in to our Xively account and view data as it comes in, using a standard
    web browser. This provides the means to send data and remotely monitor it anywhere
    in the world (perhaps from several Raspberry Pis at once if required). The service
    even supports the creation of triggers that can send additional messages back
    if certain items go out of expected ranges, reach specific values, or match set
    criteria. The triggers can in turn be used to control other devices or raise alerts,
    and so on.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用标准网络浏览器登录到我们的 Xively 账户，并查看传入的数据。这提供了在任何地方发送数据和远程监控数据的方法（如果需要，可能一次从多个
    Raspberry Pi 上进行）。该服务甚至支持创建触发器，如果某些项目超出预期范围、达到特定值或匹配设置的标准，则可以发送额外的消息。这些触发器反过来可以用来控制其他设备或触发警报等。
- en: See also
  id: totrans-533
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The AirPi Air Quality and Weather project ([http://airpi.es](http://airpi.es))
    shows you how to add your own sensors or use their AirPi kit to create your own
    air quality and weather station (with data logging to your own Xively account).
    The site also allows you to share your Xively data feeds with others from around
    the world.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: AirPi 空气质量和天气项目 ([http://airpi.es](http://airpi.es)) 展示了如何添加您自己的传感器或使用他们的 AirPi
    套件来创建您自己的空气质量和水文站（并将数据记录到您的 Xively 账户）。该网站还允许您与世界各地的其他人共享您的 Xively 数据流。
