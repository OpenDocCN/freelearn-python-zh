- en: Chapter 3. Further Test Customization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter covers syntax and styles necessary to create reusable test components
    for automated tests. Apart from the Robot Framework centric tests, it also covers
    an introduction to behavior-driven development and covers the following major
    topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Need for test re-use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Internal and external re-use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Feeding data into test scripts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Higher order test re-use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different styles of writing tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automation and agile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The agile manifesto places tremendous importance on usable code over conventional
    documents. It encourages practices such as extreme programming, which is a type
    of agile software development practice that improves software quality and makes
    the software development more responsive to the ever changing customer requirements.
    Amongst other important tenets of this practice is the automated acceptance testing.
    An acceptance test is simply some code that can be run and captures at its heart
    some aspect of the functionality of the system. The idea is that both the developer
    and the stakeholder collaborate on writing this test together, to capture the
    requirements in the code, which when passed, forms some kind of seal of approval.
    These are distinct from unit and integration tests as they are largely written
    by the developer, and for the developer. They help them emerge, validate design,
    and protect against errors. Acceptance tests are written by the stakeholder and
    the developer, for the stakeholder and the developer. Agile methodology places
    importance over tests as tests themselves become specifications rather than business
    reports or documentation.
  prefs: []
  type: TYPE_NORMAL
- en: A commonly used expression is that the difference between unit tests and acceptance
    tests is that unit tests helps you build the thing right, whereas acceptance tests
    helps you build the right thing.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned before, the Robot Framework as an automated acceptance test-driven
    development tool provides various capabilities out of the box and allows the user
    with enough flexibility to go about with automation to ensure that the software
    in question can always have its basic functionality in place.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before proceeding with writing down the tests, it is necessary to know how
    to implement a design that will help scale and maintain the tests for future requirements.
    Similar to the creation of any other software, the tests written in modular fashion
    enable re-use through selection of different test modules as required. This can
    better be explained by the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Automation and agile](img/3033OS_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here, it is evident that separation of test **1** into a unique module has enabled
    us to use the same set of tests in part of three other tests, thereby reducing
    the amount of repetition involved in writing if the tests were to be created manually.
  prefs: []
  type: TYPE_NORMAL
- en: However, generally, during acceptance tests, there are some portions that are
    unique to the situation under which the test is executing. Consider the following
    example that needs to perform acceptance testing for a large website consisting
    of hundreds of pages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Test website module functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the specific page URL.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that it is not an empty page/invalid URL.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check whether the site headers and footers exist and are displayed properly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ascertain if the actual page content (excluding the header and footer) is not
    empty.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Search and verify whether a specific element exists in the page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Close the browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Even in this brief test, there are innumerable possibilities and a single test
    cannot address all of them. For this reason, testers make copies of tests such
    as this and after making changes, put them elsewhere to meet another requirement.
    However, copying leads to presence of duplicate tests that are hard to change
    as change in the environment requires changes across the different tests. On the
    other hand, if there is test re-use, then changes in the re-used test at one place
    can reflect across different tests. To address the concern of uniqueness in different
    scenarios, one can parameterize the same test. In the preceding example, a possible
    parameterization can be as follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Test website module functionality(browser, URL, and content):'
  prefs: []
  type: TYPE_NORMAL
- en: Open the **browser** (select the specified browser).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the specific page **URL** (as specified in the parameters).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that it is not an empty page/invalid **URL**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check whether the site headers and footers exist and are displayed properly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ascertain if the actual page **content** (excluding the header and footer as
    specified in the parameter) is not empty.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Search and verify whether the parameterized **content** exists in the page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Close the browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now the same test can be used in a wide variety of scenarios (read pages) and
    different portions of the entire website can be tested for page contents using
    the same test.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned here, the same parameterized approach to create reusable tests
    can be applied to the Robot Framework through the use of variables. The variables
    can be used as an input mechanism from a given source of information which is
    not related with the test and the execution of tests occurs depending upon the
    obtained data. As repetition of test actions forms the cornerstone of test re-use,
    there is a possibility to repeat test actions even within the tests. While doing
    so, a single test or use case can repeat the same instructions again internally,
    often with some variable data that is unique to a specific repetition. These are
    detailed in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Internal re-use
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned earlier, repetition within the single test constitutes test re-use
    internally. Note that the data, if any, involved in different instances of the
    iterations might come from outside, but the repetition only occurs within the
    test action.
  prefs: []
  type: TYPE_NORMAL
- en: Loops and flow control
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Having gained a good background of the syntax of writing a test, it is time
    to move on to the most common and convenient way of iteration, that is, a loop.
    Robot Framework solves this problem through the use of Python styled `for` loops,
    but that's easily understandable for the uninitiated as well.
  prefs: []
  type: TYPE_NORMAL
- en: It follows a straightforward syntax, the loop is started with `FOR` which is
    a special keyword. This is followed with a variable that is present within the
    loop. This variable is followed by a mandatory `IN` statement. This is followed
    by the variable or a collection over which the `for` loop is to run. Like Python
    loops, the subsequent statements are indented by a single space. As soon as the
    indentation stops, it is assumed that the body of the loop is finished.
  prefs: []
  type: TYPE_NORMAL
- en: 'All this seems like an iterative construct of any programming language, but
    in the Robot Framework there are a couple of exceptions, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: The `for` loop can iterate with multiple variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The loop cannot have directly nested loops within itself, but can make use of
    custom keywords within the loops that can contain loops within themselves
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **scalar variable** collection over which the loop iterates can be specified
    as different arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that the `for` loop requires explicit whitespace definition to clearly
    demarcate different columns as a simple text file with space/tab delimiters wouldn't
    do. If tried to run, it will print out the error message "FOR loop contains no
    keywords". This is because the body of the loop requires (an extra) indentation,
    which is not possible in simple whitespace as two or more than two spaces are
    only constructed as a single separation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `for` loop has a variant that allows for iteration over a range of values.
    This is idiomatic Python, but is quite convenient at times. Its syntax is: `FOR`
    keyword followed by a single variable. Next comes the `In Range` keyword that
    provides various range limits through arguments. This can be demonstrated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Flow control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At times during the loop iteration, there may be cases where the execution needs
    to be changed, which can be done either to skip the present and continue with
    the next iteration or to terminate the loop entirely.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, the loop contents need to be processed in such a manner, which is
    not iterative in nature. In this case, we need to issue special commands that
    allow us to manipulate the contents of the flow of contents within the loop irrespective
    of the iteration status. In most conventional programming languages, this is specified
    by the `continue` and `break` constructs. Robot Framework offers a similar approach
    by providing some special keywords for this purpose in its default library.
  prefs: []
  type: TYPE_NORMAL
- en: Breaking off without finishing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By using the `Exit For Loop` or the `Exit For Loop If` built-in keywords, it
    is possible to terminate the loop and continue with the further statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, `Run Keyword if` is used, which is present in the
    built-in library. As soon as its condition is evaluated to true, it is executed
    and the `Exit for Loop` keyword causes the loop to terminate. If the test case
    contains any other statements after the loop, then they will get executed normally.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be simplified through the use of `Exit For Loop If` keyword as it
    acts as a handler for the break operation without requiring a separate `if` condition
    and hence the preceding command can be rewritten as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Continuing with the next iteration, similar to breaking the loop, sometimes
    there are exceptional cases where there is a need to continue with the next iteration
    of the loop before the present iteration has completed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note the use of the `If` suffix on various commands. The `If` statement is not
    a specific keyword, but many statements, such as the `Exit For Loop` and `continue`
    keywords, have alternate definitions that act conditionally in the presence of
    certain conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Feeding external data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tests can be fed data from any external data store such as a database, an Excel,
    or a CSV file or some external application that returns values dynamically and
    then can execute over the same data. To demonstrate this concept of test re-use
    further, we will undertake another exercise that focuses on performing the same
    task repeatedly. For the sake of the reader, we have abstracted the concepts now
    as these can then be implemented in whichever manner possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Basically, if we are having a set of repeatable tasks specified in a collection
    of values, then we can perform them in two different manners:'
  prefs: []
  type: TYPE_NORMAL
- en: Perform the set of tasks repeatedly inside a test for each value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Perform the entire test repeatedly for the values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing a set of tasks repeatedly within a test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this scenario, we create a test that takes in the argument or uses a variable
    containing a list of elements and iterate over it. As a precursor to this, first
    let us create the file containing the dynamic variable. Here, the system under
    test is a Python script that selects values out of current time in an array whose
    value we cannot predetermine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The preceding script first imports the `time` module as it will be used in the
    program later on. Next, the `var` array is created. This is followed by a `while`
    loop that checks the last decimal value of the currently elapsed time and checks
    if it is less than `8`. If it is, then it adds this last value as an integer into
    the array and sleeps for a second to get another value. Although, the `var` array
    is not randomized, its size and contents are unknown beforehand, which makes the
    `var` array dynamic at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'This lets us have the variable `var` with an unspecified amount of value. Now
    we can use it to better utilize collection of values within tests. Within the
    test, first this Python variable file is loaded and then the contents are iterated
    upon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This will load the contents from the script, and iterate over the collection
    of values and perform a sample task over the value.
  prefs: []
  type: TYPE_NORMAL
- en: Application in test automation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The outlined concept of looping can be applied in test automation through the
    use of customized user keywords and loading of test data via an external program
    that can leverage any available data medium to load the data for the system under
    test. As explained earlier, this is useful in achieving test re-use and ensuring
    that as testers, we follow the principals of **Don't Repeat Yourself** (**DRY**).
  prefs: []
  type: TYPE_NORMAL
- en: Higher order re-use
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The tests can be repeated within the test suite through the creation and use
    of constructs of higher order that contain various test commands and at times
    even entire tests. This enables the tester to combine similar or equivalent user
    stories or use cases into a single test and provide different inputs depending
    upon the circumstances. Another significant advantage that test re-use offers
    is the overall clarity of the project. Tests if re-used have to be called from
    various places, thereby giving the benefits of DRY.
  prefs: []
  type: TYPE_NORMAL
- en: User keywords
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned earlier, user keywords can be used to embed a part of test into
    a single custom keyword. These can be re-used and they can also specify arguments
    in their definition, which can be used to pass on test data parameters by the
    callers of these tests.
  prefs: []
  type: TYPE_NORMAL
- en: Test templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Test templates are used to create components within a test that can accept
    different parameters at runtime. This is different from user keywords as the user
    keywords have to be called with their name and arguments by the caller, but templates
    are provided with only the data to be processed. A better picture can be obtained
    from a sample template that just logs the provided data to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This example provides the arguments to the template one at a time in order
    to get itself processed. Here the test repeats the operation specified by the
    templates to its arguments and the test effectively becomes the shorter version
    of the following actual test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note that this is a simple example of template that is only visible inside the
    test cases table. There are other possibilities in creation of a template that
    can be re-used across different tests. Through the use of templates, the test
    becomes more oriented towards data and the official Robot Framework documentation
    states that, through templates, the keyword driven tests can be converted into
    data driven tests.
  prefs: []
  type: TYPE_NORMAL
- en: User libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: User libraries provide wrappers for implementing functionality into the Robot
    Framework. By using user libraries, we are able to extend the framework to provide
    for a certain task, or more importantly, extend the capability of this tool to
    work on some other tool. Conversely, to use a custom library, the Robot Framework
    test must follow the keywords made available by such a library and provide data
    to the necessary arguments, thereby fulfilling the keyword format contract that
    leads to correct execution of the tests. This technique of creating customized
    library and consuming it in various tests will be dealt in detail in the next
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Approaches towards writing tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are various approaches involved in testing and it is often the different
    nature of various test writing styles that separates the tests from other forms
    of software development. Writing acceptance tests can either be done by using
    the standard and external library keywords directly as mentioned before, or by
    using some mechanism to simplify the text of tests and make them more readable
    from the perspective of a non-technical person. This is crucial in agile software
    development as the stakeholders are involved in the design of software early on
    that might not be technically inclined or requiring to understand the syntax of
    tests like a programmer. However, they can provide a vision of how an application
    is supposed to work or behave; their input and feedback are important.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Robot Framework supports mainly three styles of writing tests. While the
    execution and output of the tests are not different, it is the nature of the test''s
    syntax itself that separates it from a similar test written in a different style.
    These are explained in detail in the following section:'
  prefs: []
  type: TYPE_NORMAL
- en: Keyboard-driven tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Keyboard-driven test is the most commonly used technique where the test is broken
    down into different portions known as keywords, which determine the contents of
    the tests. These keywords may further contain other keywords or tests, which are
    able to be re-used and extracted wherever needed. Through the use of keywords,
    test constructs can be made abstract and multiple and/or complex statements can
    be added under a single keyword that can make the tests a lot easier to understand
    and its function can be easily understood.
  prefs: []
  type: TYPE_NORMAL
- en: 'To better understand this approach, consider the following test code, which
    uses the process library to open the Firefox browser with [google.com](http://google.com)
    as the opened page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now consider the keyword approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This does exactly the same as the previous code, but offers much clearer view
    in the test. Its implementation details can be hidden in the `Keyword` table as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Data-driven tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The data-driven tests are useful while doing parameterization as the same test
    can be re-used with data comprising of different values. This makes tests like
    these versatile and without performing the same set of actions, one can easily
    have various test cases where the task to be carried out largely remains the same
    with only the inputs and outputs to be changed. This differs from the keyword-driven
    tests as these tests are coarser, granular, and depend on the test templates to
    provide the necessary tests in place as explained in the test template section
    earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Behavior-driven tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the popular styles that has recently seen an increased growth is the
    behavior-driven development. Creating tests that cover software behavior and writing
    actual software based on these tests is known as **Behavior-Driven Development**
    (**BDD**). However, so far this book was dealing with keyword-driven acceptance
    test, which is quite rigid in its structure. To deal with automation, external
    data streams can be used and the tests can be fed this information based on the
    data. However, the tests can also be structured to suit the business user requirements
    oriented towards behavior. However, first we need to understand BDD before applying
    the same in our tests.
  prefs: []
  type: TYPE_NORMAL
- en: Behavior-driven development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Despite the obvious benefits of automated acceptance tests, in practice, even
    amongst experienced XP and TDD teams, it''s rarely done, or done well. One of
    the reasons is that finding a stakeholder with the technical ability, interest,
    and patience to sit in front of a computer writing pure code for even a DSL like
    gerkin or RSpec is hard. Consider the following `rspec` test present in WEBrick
    (an HTTP server in Ruby commonly used in development):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This example observes the behavior that is based on the response from the server,
    from this it can be concluded that the server is a WEBrick server or not.
  prefs: []
  type: TYPE_NORMAL
- en: However, at time this may be deeply integrated into the code of test and requires
    that the internals of the system under test are exposed to it. This is because
    the developer is required to provide the actual method calls/interfaces or code
    mocks or stubs of the software right into the `rspec` tests, which might be fine
    in projects involving developers, but is not feasible where black box testing,
    as in acceptance testing is required.
  prefs: []
  type: TYPE_NORMAL
- en: BDD using the Robot Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Robot Framework not only provides a DSL or a platform to easily write the code
    in a human-readable format, but also separates itself from understanding the internals
    of the concerned software as it only performs the acceptance testing for a given
    behavior. These tests only differ in the manner in which the user keywords take
    in arguments, which is done within the keywords themselves. Here these keywords
    comprise of multiple letters and describe a specific thing to do.
  prefs: []
  type: TYPE_NORMAL
- en: Standard libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Robot Framework provides various keywords, which have been discussed so
    far. These are contained in the `builtIn` library and are available to any test
    by default. In addition to these, there are certain extra keywords that are part
    of the framework which are bundled as separate libraries and to use them, an explicit
    reference needs to be provided without any installation. These libraries are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Collections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dialogs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operating System
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Screenshot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: String
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Telnet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This library uses the supplied lists and dictionaries from an external Python
    file and performs various operations, such as comparison and modification over
    it. Some keywords from the `builtin` library that operate over lists and dictionaries
    can also be used in conjunction with this library. For example, consider the following
    example where the Python file defines the following variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'These variables can be manipulated in the test as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, other keywords belonging to the collections library can be used together
    with other libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Dialogs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Dialogs provide a way to let the user input data during the test execution.
    Although this goes against the principles of automated testing, but is desired
    at times.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that currently, this library does not work on IronPython runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, the following command lets the user pass or fail a given step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This provides the following dialog box which waits for the user input to continue:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Dialogs](img/36033OS_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: On specifying the **Fail** option, the user is further requested for the failure
    message before failing the test.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, the other keywords specified in this library can be used.
  prefs: []
  type: TYPE_NORMAL
- en: Operating System
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This library provides the Robot Framework interaction with the OS environment,
    such as files and folders, environment variables, and the ability to call various
    processes. Most of the methods declared in this library are self-explanatory.
    However, keywords that manage processes are deprecated and are now also present
    in process library.
  prefs: []
  type: TYPE_NORMAL
- en: Process
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This library allows the test to run external programs. It uses the sub process
    module in Python where the external process is spawned, the input/error/output
    message pipes are connected, and the return codes are obtained. It can either
    run process and wait for their termination or run the processes in the background.
    For better management, it can also terminate one or all the processes started
    by the test.
  prefs: []
  type: TYPE_NORMAL
- en: Screenshot
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This library enables capture of screens during the Robot Framework test execution,
    which allows detailed reporting of the project if there are screens present in
    the test environment. If using with Python runtime, this will require additional
    libraries like `wxPython` or `pygtk`. Other runtimes provide an out of the box
    support for screen capture. The `take` screenshot takes the screenshot of the
    screen and saves it where the log file or the XML output is generated if no setting
    or file location is specified. If no name is given, then `Screenshot_number.jpg`
    is saved where the number gets incremented after every execution to create a unique
    saved image. Similarly, the width argument specifies how much area gets allocated
    to the image in the log file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following specifies the file name and size of screen capture image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This saves the following image and embeds it into the log file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot](img/3033OS_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: String
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This provides the normal String operation, such as substring, replace, and splitting
    strings, as well as specialized functions that generate random string. This also
    contains utility methods that operate over strings present across multiple lines.
  prefs: []
  type: TYPE_NORMAL
- en: Telnet
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This library enables the Robot Framework test to connect to a Telnet server
    and pass commands to run over the server. An easiest way to test this is to set
    up a test server on your machine itself. Considering you set the Telnet server
    correctly on your machine with user and password both set to `test`, then the
    following code will perform as desired:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that setting up prompt in the `Open Connection` command is not mandatory,
    but is needed for certain commands like the `execute` command. This library is
    sufficient for opening, closing, as well as changing between multiple Telnet connections
    and covers most of the Telnet features.
  prefs: []
  type: TYPE_NORMAL
- en: XML
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is the XML parser supplied by the framework and can be used to search and
    validate supplied XML file or text. It uses the ElementTree library internally
    and offers capabilities to parse and find different elements, attributes, values,
    and supports Xpath-styled lookup.
  prefs: []
  type: TYPE_NORMAL
- en: Remote test execution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Robot Framework also supports the use of remote libraries, where a part
    of the test can be hosted as a server and can be used by other tests remotely.
    This is useful in centralizing a part of test at a single place and all the client
    tests can derive information based on that test itself.
  prefs: []
  type: TYPE_NORMAL
- en: It uses the XML-RPC protocol for the remote interaction and offers various capabilities
    for distributed testing, such as making different keywords available remotely
    that can be used to perform some operation over the remote server by different
    tests. Hence, a method in the remote library can be used to perform some task
    that can be called as a library keyword in the tests which provides re-usability
    of code across different tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start off with the remote test, within the test, only the setting table
    needs to specify the location of the remote test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'On the server side, the following can be specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Here, this file can be run from the Python command to set up a Robot Remote
    Server and the methods defined here can be used as keywords, such as `strings
    should be equal`. If you are wondering if the code needs anything more, then you
    need to download the provided `RobotRemoteServer` script file separately and place
    it besides this script. Currently, the servers for Python and Ruby are present,
    but other servers can also be created. Thus, writing distributed tests in the
    Robot Framework is trivial and can easily be used through HTTP.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter dealt with the philosophy and style of writing the tests. As the
    tests should be written with automation in mind, both the internal and external
    re-use through iteration and parameterization of test cases as well as getting
    data into the tests was covered as these are amongst the important things to consider
    while going forward with the automation. Next, all three different writing styles
    consisting of keyword, data, and behavior driven tests was covered followed with
    brief discussion of importance of behavior-driven development and comparison with
    other development tools currently in popular use. This chapter provides all the
    remaining portions of the Robot Framework library and you can now confidently
    begin writing tests that can be automated and provide testing for small to large
    enterprise software systems by using the wide variety of tools and support provided
    within the framework itself. In order to extend the capabilities of the framework
    and make it usable with a wide variety of software, extensive focus will be made
    on user library in the following chapter.
  prefs: []
  type: TYPE_NORMAL
