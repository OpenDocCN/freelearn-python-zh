<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;10.&#xA0;Monitoring with Beacons"><div class="book" id="1Q5IA2-d9976ffc65994572ad672a3ef48f1135"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch10" class="calibre1"/>Chapter 10. Monitoring with Beacons</h1></div></div></div><p class="calibre8">
<span class="strong"><strong class="calibre2">Beacons</strong></span> are a<a id="id312" class="calibre1"/> newer type of module in Salt which are designed to watch resources on a Minion, and report to the Master when those resources fall out of alignment with what you expect them to look like. In this chapter, we will discuss:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Monitoring external systems with Salt</li><li class="listitem">Troubleshooting beacons</li></ul></div></div>

<div class="book" title="Chapter&#xA0;10.&#xA0;Monitoring with Beacons">
<div class="book" title="Watching for data"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch10lvl1sec54" class="calibre1"/>Watching for data</h1></div></div></div><p class="calibre8">There are<a id="id313" class="calibre1"/> two basic types of monitoring services: those that record data, and those that trigger alerts based on that data. On the surface, beacons may look like the second type. They run on a regular interval (as frequently as every second, by default) and when they find data that is important, they send it up to the Master.</p><p class="calibre8">However, because beacons have access to execution modules on the Minion that they are running on, they can interact with any program on the Minion that an execution module can.</p></div></div>

<div class="book" title="Chapter&#xA0;10.&#xA0;Monitoring with Beacons">
<div class="book" title="Watching for data">
<div class="book" title="Keeping an eye on things"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch10lvl2sec88" class="calibre1"/>Keeping an eye on things</h2></div></div></div><p class="calibre8">Let's go<a id="id314" class="calibre1"/> ahead and put together a beacon that monitors <code class="email">nspawn</code> containers. It doesn't need to be very complex; indeed, beacons should be as simple as possible, since they are expected to run so often. All that our beacon needs to do is keep an eye on containers that should be running, and those that should be absent.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note07" class="calibre1"/>Note</h3><p class="calibre8">Containers have become very popular in the modern data center, thanks in large part to Docker and LXC. systemd has its own containering system called <code class="email">nspawn</code>, which is a very powerful system in its own right. A number of Linux distributions now ship with systemd, which means that you may already have <code class="email">nspawn</code> installed. You <a id="id315" class="calibre1"/>can find a more complete discussion of <code class="email">nspawn</code> itself on Lennart Pottering's blog at:</p><p class="calibre8">
<a class="calibre1" href="http://0pointer.net/blog/systemd-for-administrators-part-xxi.html">http://0pointer.net/blog/systemd-for-administrators-part-xxi.html</a>
</p></div><p class="calibre8">First, we <a id="id316" class="calibre1"/>need to set up our <code class="email">__virtual__()</code> function. Since <code class="email">nspawn</code> is part of <code class="email">systemd</code>, and not every Minion will have <code class="email">systemd</code> on it, we need to perform a check for it. However, since we're going to use the <code class="email">nspawn</code> execution module that ships with Salt, and it already contains a <code class="email">__virtual__()</code> function, all that we really need to do is make sure it is present:</p><div class="informalexample"><pre class="programlisting">'''
Send events covering nspawn containers

This beacon accepts a list of containers and whether they should be
running or absent:

beacons:
  nspawn:
    vsftpd: absent
    httpd: running

This file should be saved as salt/beacons/nspawn.py
'''
__virtualname__ = 'nspawn'


def __virtual__():
    '''
    Ensure that systemd-nspawn is available
    '''
    if 'nspawn.list_running' in __salt__:
        return __virtualname__
    return False</pre></div><p class="calibre8">It makes sense to check specifically for <code class="email">nspawn.list_running</code>, since that is the only function that we'll be using here.</p></div></div></div>

<div class="book" title="Chapter&#xA0;10.&#xA0;Monitoring with Beacons">
<div class="book" title="Watching for data">
<div class="book" title="Validating configuration"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch10lvl2sec89" class="calibre1"/>Validating configuration</h2></div></div></div><p class="calibre8">Beacons <a id="id317" class="calibre1"/>will not run unless they know which data to watch for. You probably saw the configuration example in the preceding docstring. The <code class="email">validate()</code> function checks the configuration that was passed to this beacon, to make sure that it has been formatted in the correct way.</p><p class="calibre8">If we <a id="id318" class="calibre1"/>were going to be minimalistic about this, then we would just check to make sure that the correct type of data has been passed in. In our case, we're expecting a dictionary, so we could get away with just checking for that:</p><div class="informalexample"><pre class="programlisting">def validate(config):
    '''
    Validate the beacon configuration
    '''
    if not isinstance(config, dict):
        return False
    return True</pre></div><p class="calibre8">But we'll go ahead and add just a little more, to make sure that, at the very least, the containers listed are set to one of the required values: <code class="email">running</code> or <code class="email">absent</code>:</p><div class="informalexample"><pre class="programlisting">def validate(config):
    '''
    Validate the beacon configuration
    '''
    if not isinstance(config, dict):
        return False
    for key in config:
        if config[key] not in ('running', 'absent'):
            return False
    return True</pre></div><p class="calibre8">You can skip this function if you need to; if it's not there, then Salt will skip over it. However, it is a good idea to have it there, to help keep bad configuration from causing the beacon to crash with a stacktrace.</p></div></div></div>

<div class="book" title="Chapter&#xA0;10.&#xA0;Monitoring with Beacons">
<div class="book" title="Watching for data">
<div class="book" title="The beacon() function"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch10lvl2sec90" class="calibre1"/>The beacon() function</h2></div></div></div><p class="calibre8">As with <a id="id319" class="calibre1"/>some of the other types of modules, beacons have a function that is required, since Salt will look for it when trying to use the module. Not surprisingly, this function is called <code class="email">beacon()</code>. It is passed the same <code class="email">config</code> data as the <code class="email">validate()</code> function.</p><p class="calibre8">Our beacon's only job is to use <code class="email">machinectl</code> to report which containers are currently running on the Minion. Its output looks something like the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2"># machinectl list</strong></span>
<span class="strong"><strong class="calibre2">MACHINE       CLASS     SERVICE       </strong></span>
<span class="strong"><strong class="calibre2">vsftpd         container systemd-nspawn</strong></span>

<span class="strong"><strong class="calibre2">1 machines listed.</strong></span>
</pre></div><p class="calibre8">We could call this manually and parse the output ourselves, but as I said before, there is already an <code class="email">nspawn</code> execution module that ships with Salt, and it has a <code class="email">list_running()</code> function that does all of that for us.</p><p class="calibre8">All that <a id="id320" class="calibre1"/>we have to do then is get a list of the nodes that are reported as running, and then match it against the list of nodes in the <code class="email">config</code> dictionary:</p><div class="informalexample"><pre class="programlisting">def beacon(config):
    '''
    Scan for nspawn containers and fire events
    '''
    nodes = __salt__['nspawn.list_running']()
    ret = []
    for name in config:
        if config[name] == 'running':
            if name not in nodes:
                ret.append({name: 'Absent'})
        elif config[name] == 'absent':
            if name in nodes:
                ret.append({name: 'Running'})
        else:
            if name not in nodes:
                ret.append({name: False})

    return ret</pre></div><p class="calibre8">Rather than stepping through the list of running nodes, we iterate through the list of nodes that were configured. If a node that should be absent shows up in the running list, then we mark it as running. If it should be running but doesn't show up, then we mark it as absent.</p><p class="calibre8">That last <code class="email">else</code> statement will notify us if something that wasn't marked as running or absent showed up in the list. Since we already did that check in the <code class="email">validate()</code> function, this shouldn't be needed. But it's not a bad idea to keep this kind of check in there, just in case your <code class="email">validate()</code> function missed something. If you start seeing events from this module that have nodes set to <code class="email">False</code>, then you know you need to go back and check the <code class="email">validate()</code> function.</p><p class="calibre8">If you've been following along and have already started testing this module, then you may notice something, well, obnoxious. By default, beacons are executed once a second. You can change that interval on a per-module basis:</p><div class="informalexample"><pre class="programlisting">beacons:
  nspawn:
    vsftpd: present
    httpd: absent
    interval: 30</pre></div><p class="calibre8">With that configuration, the <code class="email">nspawn</code> beacon will only be executed once every five seconds, instead of every second. That will cut down on the chatter, but also means that your beacon won't necessarily be watching as often as you'd like.</p><p class="calibre8">Let's go<a id="id321" class="calibre1"/> ahead and add some code, which will allow the beacon to run as often as you'd like, but send updates on a less regular basis. Let's say that you have your beacon tied into a monitoring service (through the event reactor), and you want up-to-the-second monitoring, but you don't need to be told more than once every five minutes that, "oh, by the way, the container is still down":</p><div class="informalexample"><pre class="programlisting">import time
def beacon(config):
    '''
    Scan for nspawn containers and fire events
    '''
    interval = __salt__['config.get']('nspawn_alert_interval', 360)
    now = int(time.time())

    nodes = __salt__['nspawn.list_running']()
    ret = []
    for name in config:
        lasttime = __grains__.get('nspawn_last_notify', {}).get(name, 0)
        if config[name] == 'running':
            if name not in nodes:
                if now - lasttime &gt;= interval:
                    ret.append({name: 'Absent'})
                    __salt__['grains.setval']('nspawn_last_notify', {name: now})
        elif config[name] == 'absent':
            if name in nodes:
                if now - lasttime &gt;= interval:
                    ret.append({name: 'Running'})
                    __salt__['grains.setval']('nspawn_last_notify', {name: now})
        else:
            if name not in nodes:
                if now - lasttime &gt;= interval:
                    ret.append({name: False})
                        __salt__['grains.setval']('nspawn_last_notify', {name: now})

    return ret</pre></div><p class="calibre8">First, we set up an alert interval called <code class="email">nspawn_alert_interval</code>, and default it to <code class="email">360</code> seconds (or, every five minutes). Because we used <code class="email">config.get</code> to look for it, we can configure it in either the <code class="email">master</code> or <code class="email">minion</code> configuration files, or in a grain or a pillar for the Minion.</p><p class="calibre8">Then we make a note of the current time using Python's own <code class="email">time.time()</code> function. This function reports the number of seconds since the epoch, which is perfect for our purposes, since our alert interval is also configured in seconds.</p><p class="calibre8">As we<a id="id322" class="calibre1"/> iterate through the list of configured nodes, we check to see when the last notification was sent out. This is stored in a grain called <code class="email">nspawn_last_notify</code>. This isn't a grain that your users will be updating; this is one that the beacon will keep track of.</p><p class="calibre8">In fact, you will see that happen for each of the branches in the <code class="email">if</code> statement. Whenever the beacon detects that an alert should be sent, it first checks to see if an alert has already been sent during the specified interval. If not, then it sets up an event to be returned.</p></div></div></div>

<div class="book" title="Chapter&#xA0;10.&#xA0;Monitoring with Beacons">
<div class="book" title="Watching for data">
<div class="book" title="Watching for beacons"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch10lvl2sec91" class="calibre1"/>Watching for beacons</h2></div></div></div><p class="calibre8">Beacons<a id="id323" class="calibre1"/> use Salt's event bus to send notifications to the Master. You can use the <code class="email">event</code> function in the <code class="email">state</code> runner to watch the beacons come in on the event bus. The return from this particular beacon module will look like the following:</p><div class="informalexample"><pre class="programlisting">salt/beacon/alton/nspawn/	{
    "_stamp": "2016-01-17T17:48:48.986662",
    "data": {
        "vsftpd": "Present",
        "id": "alton"
    },
    "tag": "salt/beacon/alton/nspawn/"
}</pre></div><p class="calibre8">Take note of the tag, which contains <code class="email">salt/beacon/</code>, followed by the ID of the Minion (<code class="email">alton</code>) that fired the beacon, and then the name of the beacon itself (<code class="email">nspawn</code>).</p></div></div></div>
<div class="book" title="The final beacon module" id="1R42S1-d9976ffc65994572ad672a3ef48f1135"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec55" class="calibre1"/>The final beacon module</h1></div></div></div><p class="calibre8">When all is<a id="id324" class="calibre1"/> said and done, our final beacon module will look like this:</p><div class="informalexample"><pre class="programlisting">'''
Send events covering nspawn containers

This beacon accepts a list of containers and whether they should be
running or absent:

    .. code-block:: yaml

        beacons:
          nspawn:
            vsftpd: running
            httpd: absent


This file should be saved as salt/beacons/nspawn.py
'''
import time

__virtualname__ = 'nspawn'


def __virtual__():
    '''
    Ensure that systemd-nspawn is available
    '''
    if 'nspawn.list_running' in __salt__:
        return __virtualname__
    return False


def validate(config):
    '''
    Validate the beacon configuration
    '''
    if not isinstance(config, dict):
        return False
    for key in config:
        if config[key] not in ('running', 'absent'):
            return False
    return True


def beacon(config):
    '''
    Scan for nspawn containers and fire events
    '''
    interval = __salt__['config.get']('nspawn_alert_interval', 360)
    now = int(time.time())

    nodes = __salt__['nspawn.list_running']()
    ret = []
    for name in config:
        lasttime = __grains__.get('nspawn_last_notify', {}).get(name, 0)
        if config[name] == 'running':
            if name not in nodes:
                if now - lasttime &gt;= interval:
                    ret.append({name: 'Absent'})
                    __salt__['grains.setval']('nspawn_last_notify', {name: now})
        elif config[name] == 'absent':
            if name in nodes:
                if now - lasttime &gt;= interval:
                    ret.append({name: 'Running'})
                    __salt__['grains.setval']('nspawn_last_notify', {name: now})
        else:
            if name not in nodes:
                if now - lasttime &gt;= interval:
                    ret.append({name: False})
                    __salt__['grains.setval']('nspawn_last_notify', {name: now})

    return ret</pre></div></div>
<div class="book" title="Troubleshooting beacons" id="1S2JE1-d9976ffc65994572ad672a3ef48f1135"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec56" class="calibre1"/>Troubleshooting beacons</h1></div></div></div><p class="calibre8">Beacons <a id="id325" class="calibre1"/>are a type of module that require both a running Master and a running Minion. Running the <code class="email">salt-master</code> service in the foreground won't give you much insight, since the code will be running on the Minion, but running the <code class="email">salt-minion</code> service in the foreground will be very helpful:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2"># salt-minion -l debug</strong></span>
</pre></div><p class="calibre8">Set aside a Minion that only has your beacon configured and no others. By default, these beacons will run every second, and that can generate very noisy logs indeed:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">[INFO    ] Executing command 'machinectl --no-legend --no-pager list' in directory '/root'</strong></span>
<span class="strong"><strong class="calibre2">[DEBUG   ] stdout: vsftpd container systemd-nspawn</strong></span>
<span class="strong"><strong class="calibre2">[INFO    ] Executing command 'machinectl --no-legend --no-pager list' in directory '/root'</strong></span>
<span class="strong"><strong class="calibre2">[DEBUG   ] stdout: vsftpd container systemd-nspawn</strong></span>
<span class="strong"><strong class="calibre2">[INFO    ] Executing command 'machinectl --no-legend --no-pager list' in directory '/root'</strong></span>
<span class="strong"><strong class="calibre2">[DEBUG   ] stdout: vsftpd container systemd-nspawn</strong></span>
</pre></div><p class="calibre8">Imagine several beacons running at once, each logging its own data for what it's currently doing. That will get old fast.</p><p class="calibre8">You will also want to keep an event listener open on the Master:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2"># salt-r</strong></span>
<span class="strong"><strong class="calibre2">un state.event pretty=True</strong></span>
</pre></div><div class="informalexample"><pre class="programlisting">salt/beacon/alton/nspawn/	{
    "_stamp": "2016-01-17T17:48:48.986662",
    "data": {
        "ftp-container": "Present",
        "id": "alton"
    },
    "tag": "salt/beacon/alton/nspawn/"
}</pre></div><p class="calibre8">Fortunately, beacons<a id="id326" class="calibre1"/> are not the sort of thing that you really need to wait around for; just make the machine exhibit the kind of behavior that you're looking for, and then start up the <code class="email">salt-minion</code> process. Just make sure to test for any variation of the behavior that you expect to find, whether or not it is expected to return an event.</p></div>
<div class="book" title="Summary" id="1T1401-d9976ffc65994572ad672a3ef48f1135"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec57" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">Beacons give Minions the ability to raise events based on monitored conditions. A <code class="email">validate()</code> function is helpful for ensuring that the configuration is correct, but it is not required. A <code class="email">beacon()</code> function is required, as it is the function that performs the actual monitoring. Use execution modules when possible to perform the heavy lifting. Beacons can run at very short intervals, but by having them store data in grains, you can set notifications at longer intervals.</p><p class="calibre8">Now that we have all of the Minion-side modules in the book out of the way, let's go back and finish up with some Master-side modules. Next up: extending the Master.</p></div></body></html>