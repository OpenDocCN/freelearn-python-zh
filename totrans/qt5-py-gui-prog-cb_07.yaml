- en: Chapter 7. Storing Data in Our MySQL Database via Our GUI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we will enhance our Python GUI by connecting to a MySQL database.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to a MySQL database from Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring the MySQL connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing the Python GUI database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the SQL INSERT command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the SQL UPDATE command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the SQL DELETE command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing and retrieving data from our MySQL database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we can connect to a MySQL server, we have to have access to a MySQL server.
    The first recipe in this chapter will show you how to install the free MySQL Server
    Community Edition.
  prefs: []
  type: TYPE_NORMAL
- en: After successfully connecting to a running instance of our MySQL server, we
    will design and create a database that will accept a book title, which could be
    our own journal or a quote we found somewhere on the Internet. We will require
    a page number for the book, which could be blank, and then we will `insert` the
    quote we like from a book, journal, website or friend into our MySQL database
    using our GUI built in Python 3.
  prefs: []
  type: TYPE_NORMAL
- en: We will insert, modify, delete and display our favorite quotes using our Python
    GUI to issue these SQL commands and to display the data.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**CRUD** is a database term you might come across that abbreviates the four
    basic SQL commands and stands for **Create**, **Read**, **Update**, and **Delete**.'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to a MySQL database from Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we can connect to a MySQL database, we have to connect to the MySQL server.
  prefs: []
  type: TYPE_NORMAL
- en: In order to do this, we need to know the IP address of the MySQL server as well
    as the port it is listening on.
  prefs: []
  type: TYPE_NORMAL
- en: We also have to be a registered user with a password in order to get authenticated
    by the MySQL server.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will need to have access to a running MySQL server instance and you also
    need to have administrator privileges in order to create databases and tables.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a free MySQL Community Edition available from the official MySQL website.
    You can download and install it on your local PC from: [http://dev.mysql.com/downloads/](http://dev.mysql.com/downloads/)'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this chapter, we are using MySQL Community Server (GPL) Release: 5.6.26.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to connect to MySQL, we first need to install a special Python connector
    driver. This driver will enable us to talk to the MySQL server from Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'The driver is freely available on the MySQL website and comes with a very nice
    online tutorial. You can install it from:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://dev.mysql.com/doc/connector-python/en/index.html](http://dev.mysql.com/doc/connector-python/en/index.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Make sure you choose the installer that matches the version of Python you have
    installed. In this chapter, we are using the installer for Python 3.4.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/B04829_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There is currently a little bit of a surprise at the end of the installation
    process. When we start the `.msi` installer we briefly see a MessageBox showing
    the progress of the installation, but then it disappears. We get no confirmation
    that the installation actually succeeded.
  prefs: []
  type: TYPE_NORMAL
- en: One way to verify that we installed the correct driver, that lets Python talk
    to MySQL, is by looking into the Python site-packages directory.
  prefs: []
  type: TYPE_NORMAL
- en: If your site-packages directory looks similar to the following screenshot and
    you see some new files that have `mysql_connector_python` in their name, well,
    then we did indeed install something…
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/B04829_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The official MySQL website mentioned above comes with a tutorial, at the following
    URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://dev.mysql.com/doc/connector-python/en/connector-python-tutorials.html](http://dev.mysql.com/doc/connector-python/en/connector-python-tutorials.html)'
  prefs: []
  type: TYPE_NORMAL
- en: The online tutorial example on how to verify that installing the Connector/Python
    driver worked is a little bit misleading as it tries to connect to an employees'
    database that did not get created automatically, at least in my Community Edition.
  prefs: []
  type: TYPE_NORMAL
- en: The way to verify that our Connector/Python driver really did get installed
    is by just connecting to the MySQL server without specifying a particular database
    and then printing out the connection object.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Replace the placeholder bracketed names `<adminUser>` and `<adminPwd>` with
    the real credentials you are using in your MySQL installation.
  prefs: []
  type: TYPE_NORMAL
- en: If you installed the MySQL Community Edition, you are the administrator and
    will have chosen both a username and password during the MySQL installation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If running the preceding code results in the following output printed to the
    console, then we are good.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/B04829_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you are not able to connect to the MySQL server, then something probably
    went wrong during the installation. If this is the case, try uninstalling MySQL,
    reboot your PC, and then run the MySQL installation again. Double-check that you
    downloaded the MySQL installer to match your version of Python. If you have more
    than one version of Python installed, that sometimes leads to confusion as the
    one you installed last gets prepended to the Windows path environmental variable
    and some installers just use the first Python version they can find in this location.
  prefs: []
  type: TYPE_NORMAL
- en: That happened to me when I installed a Python 32-bit version in addition to
    my 64-bit version and I was puzzled why some of my downloaded modules did not
    work.
  prefs: []
  type: TYPE_NORMAL
- en: The installers downloaded the 32-bit modules, which are incompatible with a
    64-bit version of Python.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to connect our GUI to a MySQL server, we need to be able to connect
    to the server with administrative privileges if we want to create our own database.
  prefs: []
  type: TYPE_NORMAL
- en: If the database already exists, then we just need the authorization rights to
    connect, insert, update, and delete data.
  prefs: []
  type: TYPE_NORMAL
- en: We will create a new database on a MySQL server in the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the MySQL connection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we used the shortest way to connect to a MySQL server
    by hard-coding the credentials required for authentication into the `connection`
    method. While this is a fast approach for early development, we definitely do
    not want to expose our MySQL server credentials to anybody unless we *grant* permission
    to databases, tables, views, and related database commands to specific users.
  prefs: []
  type: TYPE_NORMAL
- en: A much safer way to get authenticated by a MySQL server is by storing the credentials
    in a configuration file, which is what we will do in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: We will use our configuration file to connect to the MySQL server and then create
    our own database on the MySQL server.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will use this database in all of the following recipes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Access to a running MySQL server with administrator privileges is required to
    run the code shown in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The previous recipe shows how to install the free Community Edition of MySQL
    Server. The administrator privileges will enable you to implement this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, we create a dictionary in the same module of the `MySQL.py` code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Next, in the connection method, we unpack the dictionary values. Instead of
    writing,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: we use `(**dbConfig)`, which does the same as above but is much shorter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This results in the same successful connection to the MySQL server, but the
    difference is that the connection method no longer exposes any mission-critical
    information.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A database server is critical to your mission. You realize this once you have
    lost your valuable data…and can't find any recent backup!
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/B04829_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, placing the same username, password, database, and so on into a dictionary
    in the same Python module does not eliminate the risk of having the credentials
    seen by anyone perusing the code.
  prefs: []
  type: TYPE_NORMAL
- en: In order to increase database security, we first move the dictionary into its
    own Python module. Let's call the new Python module `GuiDBConfig.py`.
  prefs: []
  type: TYPE_NORMAL
- en: We then import this module and unpack the credentials, as we did before.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once we place this module into a secure place, separated from the rest of the
    code, we have achieved a better level of security for our MySQL data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we know how to connect to MySQL and have administrator privileges,
    we can create our own database by issuing the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In order to execute commands to MySQL, we create a cursor object from the connection
    object.
  prefs: []
  type: TYPE_NORMAL
- en: A cursor is usually a place in a specific row in a database table, which we
    move up or down the table, but here we use it to create the database itself.
  prefs: []
  type: TYPE_NORMAL
- en: We wrap the Python code into a `try…except` block and use the built-in error
    codes of MySQL to tell us if anything went wrong.
  prefs: []
  type: TYPE_NORMAL
- en: We can verify that this block works by executing the database-creating code
    twice. The first time, it will create a new database in MySQL, and the second
    time it will print out an error message stating that this database already exists.
  prefs: []
  type: TYPE_NORMAL
- en: We can verify which databases exist by executing the following MySQL command
    using the very same cursor object syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of issuing the `CREATE DATABASE` command, we create a cursor and use
    it to execute the `SHOW DATABASES` command, the result of which we fetch and print
    to the console output.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We retrieve the results by calling the `fetchall` method on the cursor object.
  prefs: []
  type: TYPE_NORMAL
- en: Running this code shows us which databases currently exist in our MySQL server
    instance. As we can see from the output, MySQL ships with several built-in databases,
    such as `information_schema`, and so on. We have successfully created our own
    `guidb` database, which is shown in the output. All other databases illustrated
    come shipped with MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/B04829_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note how, even though we specified the database when we created it in mixed-case
    letters as GuiDB, the `SHOW DATABASES` command shows all existing databases in
    MySQL in lower-case and displays our database as `guidb`.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to connect our Python GUI to a MySQL database, we first have to know
    how to connect to the MySQL server. This requires establishing a connection and
    this connection will only be accepted by MySQL if we are able to provide the required
    credentials.
  prefs: []
  type: TYPE_NORMAL
- en: While it is easy to place strings into one line of Python code, when we deal
    with databases we have to be really thoughtful, because today's personal sandbox
    development environment, by tomorrow, could easily end up being accessible on
    the World Wide Web.
  prefs: []
  type: TYPE_NORMAL
- en: You do not want to compromise database security and the first part of this recipe
    showed ways to be more secure by placing the connection credentials to the MySQL
    server into a separate file, and by placing this file into a location where it
    is not accessible from the outside world, our database system will become more
    secure.
  prefs: []
  type: TYPE_NORMAL
- en: In a real-world production environment, both the MySQL server installation,
    connection credentials and this dbConfig file would be handled by IT system administrators
    who would enable you to import the dbConfig file to connect to the MySQL server
    without you knowing what the actual credentials are. Unpacking dbConfig would
    not expose the credentials as it does in our code.
  prefs: []
  type: TYPE_NORMAL
- en: The second part created our own database in a MySQL server instance and we will
    extend and use this database in the very next recipes, combining it with our Python
    GUI.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the Python GUI database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start creating tables and inserting data into them we have to design
    the database. Unlike changing local Python variable names, changing a database
    schema once it has been created and loaded with data is not that easy.
  prefs: []
  type: TYPE_NORMAL
- en: We would have to `DROP` the table, which means we would lose all the data that
    was in the table. So, before dropping a table, we would have to extract the data,
    then `DROP` the table, and recreate it under a different name and finally reimport
    the original data.
  prefs: []
  type: TYPE_NORMAL
- en: You get the picture…
  prefs: []
  type: TYPE_NORMAL
- en: Designing our GUI MySQL database means first thinking about what we want our
    Python application to do with it and then choose names for our tables that match
    the intended purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are working with the MySQL database we created in the previous recipe. A
    running instance of MySQL is necessary and the two previous recipes show how to
    install MySQL and all necessary additional drivers, as well as how to create the
    database we are using in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, we move widgets from our Python GUI around between the two tabs we created
    in the previous recipes, in order to organize our Python GUI better to connect
    to a MySQL database.
  prefs: []
  type: TYPE_NORMAL
- en: We rename several widgets and separate the code that accesses the MySQL data
    to what used to be named Tab 1, and we will move unrelated widgets to what we
    called in earlier recipes Tab 2.
  prefs: []
  type: TYPE_NORMAL
- en: We also adjust some internal Python variable names in order to understand our
    code better.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Code readability is a coding virtue and not a waste of time.
  prefs: []
  type: TYPE_NORMAL
- en: Our refactored Python GUI now looks like the following screenshot. We have renamed
    the first tab as MySQL and created two tkinter LabelFrame widgets. We labeled
    the one on the top, Python Database, and it contains two labels and six tkinter
    entry widgets plus three buttons, which we aligned in four rows and three columns
    using the tkinter grid layout manager.
  prefs: []
  type: TYPE_NORMAL
- en: We will enter book titles and pages into the entry widgets and clicking the
    buttons will result in either inserting, retrieving, or modifying book quotations.
  prefs: []
  type: TYPE_NORMAL
- en: The LabelFrame at the bottom has a label of **Book Quotation** and the ScrolledText
    widget that is part of this frame will display our books and quotations.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/B04829_07_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We will create two SQL tables to hold our data. The first will hold the data
    for the book title and the book page. We will then join with the second table,
    which will hold the book quotation.
  prefs: []
  type: TYPE_NORMAL
- en: We will link the two tables together via primary to foreign key relations.
  prefs: []
  type: TYPE_NORMAL
- en: So, let's create the first database table now.
  prefs: []
  type: TYPE_NORMAL
- en: Before we do that, let's verify first that our database indeed has no tables.
    According to the online MySQL documentation, the command to view the tables that
    exist in a database is as follows.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '13.7.5.38 `SHOW` `TABLES` syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: It is important to note that, in the preceding syntax, arguments in square brackets
    such as `FULL` are optional while arguments in curly braces such as `FROM` are
    required in the description for the `SHOW TABLES` command. The pipe symbol between
    `FROM` and `IN` means that the MySQL syntax requires one or the other.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: When we execute the SQL command in Python we get the expected result, which
    is an empty list, showing us that our database currently has no tables.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/B04829_07_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can also first select the database by executing the `USE <DB>` command. Now,
    we don't have to pass it into the `SHOW TABLES` command because we already selected
    the database we want to talk to.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code creates the same true result as did the previous one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now that we know how to verify that our database has no tables, let's create
    some. After we have created two tables, we will verify that they have truly made
    it into our database by using the same commands as before.
  prefs: []
  type: TYPE_NORMAL
- en: We create the first table, named `Books`, by executing the following code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We can verify that the table was created in our database by executing the following
    commands.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/B04829_07_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now the result is no longer an empty list but a list that contains a tuple,
    showing the `books` table we just created.
  prefs: []
  type: TYPE_NORMAL
- en: We can use the MySQL command line client to see the columns in our table. In
    order to do this, we have to log in as the root user. We also have to append a
    semicolon to the end of the command.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On Windows, you simply double-click the MySQL command line client shortcut,
    which is automatically installed during the MySQL installation.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don''t have a shortcut on your desktop, you can find the executable
    at the following path for a typical default installation:'
  prefs: []
  type: TYPE_NORMAL
- en: '`C:\Program Files\MySQL\MySQL Server 5.6\bin\mysql.exe`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Without a shortcut to run the MySQL client, you have to pass it some parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`C:\Program Files\MySQL\MySQL Server 5.6\bin\mysql.exe`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--defaults-file=C:\ProgramData\MySQL\MySQL Server 5.6\my.ini`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-uroot`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-p`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Either double-clicking the shortcut, or using the command line with the full
    path to the executable and passing in the required parameters, will bring up the
    MySQL command line client which prompts you to enter the password for the root
    user.
  prefs: []
  type: TYPE_NORMAL
- en: If you remember the password you assigned to the root user during the installation,
    you can then run the `SHOW COLUMNS FROM books;` command, as shown below. This
    will display the columns of our `books` table from our guidb.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When executing commands in the MySQL client, the syntax is not Pythonic.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/B04829_07_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we will create the second table that will store the book and journal
    quotations. We will create it by executing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Executing the `SHOW TABLES` command now shows that our database has two tables.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/B04829_07_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can see the columns by executing the SQL command using Python.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/B04829_07_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using the MySQL client might present the data in a better format. We could also
    use Python's pretty print (`pprint`) feature.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/B04829_07_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The MySQL client still shows our columns in a clearer format which can be seen
    when you run this client.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We designed our Python GUI database and refactored our GUI in preparation to
    use our new database. We then created a MySQL database and created two tables
    within it.
  prefs: []
  type: TYPE_NORMAL
- en: We verified that the tables made it into our database by using both Python and
    the MySQL client that ships with the MySQL server.
  prefs: []
  type: TYPE_NORMAL
- en: In the next recipe, we will insert data into our tables.
  prefs: []
  type: TYPE_NORMAL
- en: Using the SQL INSERT command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe presents the entire Python code that shows you how to create and
    drop MySQL databases and tables, as well as how to display the existing databases,
    tables, columns, and data of our MySQL instance.
  prefs: []
  type: TYPE_NORMAL
- en: After creating the database and tables, we will insert data into the two tables
    we are creating in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We are using a primary to foreign key relationship to connect the data of the
    two tables.
  prefs: []
  type: TYPE_NORMAL
- en: We will go into the details of how this works in the following two recipes,
    where we modify and delete the data in our MySQL database.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe builds on the MySQL database we created in the previous recipe and
    also shows you how to drop and recreate the GuiDB.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Dropping the database of course deletes all data the database had in its tables,
    so we will also show you how to re-insert that data.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The entire code of our `MySQL.py` module is present in the code folder of this
    chapter, which is available for download from Packt Publishing's website. It creates
    the database, adds tables to it, and then inserts data into the two tables we
    created.
  prefs: []
  type: TYPE_NORMAL
- en: Here we will outline the code without showing all implementation details in
    order to preserve space, because it would take too many pages to show the entire
    code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Running the preceding code creates the following tables and data in the database
    we created.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/B04829_07_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have created a MySQL database, established a connection to it, and then created
    two tables that hold the data for a favorite book or journal quotation.
  prefs: []
  type: TYPE_NORMAL
- en: We have distributed the data between two tables because the quotations tend
    to be rather large while the book titles and book page numbers are very short.
    By doing this, we can increase the efficiency of our database.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In SQL database language, separating data into separate tables is called normalization.
  prefs: []
  type: TYPE_NORMAL
- en: Using the SQL UPDATE command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will use the code from the previous recipe, explain it in more detail,
    and then extend the code to update our data.
  prefs: []
  type: TYPE_NORMAL
- en: In order to update data we have previously inserted into our MySQL database
    tables, we use the SQL `UPDATE` command.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe builds on the previous recipe, so read and study the previous recipe
    in order to follow the coding in this recipe where we modify existing data.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we will display the data to be modified by running the following Python
    to MySQL command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the code creates the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/B04829_07_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We might not agree with the "Gang of Four", so let's change their famous programming
    quote.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Gang of Four are the four authors who created the world famous book called
    *Design Patterns,* which strongly influenced our entire software industry to recognize,
    think, and code using software design patterns.
  prefs: []
  type: TYPE_NORMAL
- en: We will do this by updating our database of favorite quotes.
  prefs: []
  type: TYPE_NORMAL
- en: First, we retrieve the primary key value by searching for the book title and
    then we pass that value into our search for the quote.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives us the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/B04829_07_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now that we know the primary key of the quote, we can update the quote by executing
    the following commands.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: By running the preceding code we make this programming classic more Pythonic.
  prefs: []
  type: TYPE_NORMAL
- en: As can be seen in the following screenshot, before we ran the preceding code,
    our title with `Book_ID 1` was related via a primary to foreign key relationship
    to the quotation in the `Books_Book_ID` column of the quotation table.
  prefs: []
  type: TYPE_NORMAL
- en: This is the original quotation from the *Design Patterns* book.
  prefs: []
  type: TYPE_NORMAL
- en: We then updated the quotation related to this ID via the SQL `UPDATE` command.
  prefs: []
  type: TYPE_NORMAL
- en: None of the IDs have changed, but the quotation that is now associated with
    `Book_ID 1` has changed, as can be seen in the second MySQL client window, as
    follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/B04829_07_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we retrieved existing data from our database and database tables
    we created in earlier recipes. We inserted data into the tables and updated our
    data using the SQL `UPDATE` command.
  prefs: []
  type: TYPE_NORMAL
- en: Using the SQL DELETE command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will use the SQL `DELETE` command to delete the data we created
    in the previous recipes.
  prefs: []
  type: TYPE_NORMAL
- en: While deleting data might at first sight sound trivial, once we get a rather
    large database design in production, things might not be that easy any more.
  prefs: []
  type: TYPE_NORMAL
- en: Because we have designed our GUI database by relating two tables via a primary
    to foreign key relation, when we delete certain data we do not end up with orphan
    records because this database design takes care of cascading deletes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe uses the MySQL database, tables, as well as the data inserted into
    those tables from the previous recipes in this chapter. In order to show how to
    create orphan records, we will have to change the design of one of our database
    tables.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We kept our database design simple by using only two database tables.
  prefs: []
  type: TYPE_NORMAL
- en: While this works when we delete data, there is always a chance of ending up
    with orphan records. What this means is that we delete data in one table but somehow
    do not delete the related data in another SQL table.
  prefs: []
  type: TYPE_NORMAL
- en: If we create our `quotations` table without a foreign key relationship to the
    `books` table, we can end up with orphan records.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: After inserting data into the `books` and `quotations` tables, if we execute
    the same `delete` statement as before we are only deleting the book with `Book_ID
    1`, while the related quotation with the `Books_Book_ID 1` is left behind.
  prefs: []
  type: TYPE_NORMAL
- en: This in an orphaned record. There no longer exists a book record that has a
    `Book_ID` of `1`.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/B04829_07_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This situation can create a mess, which we can avoid by using cascading deletes.
  prefs: []
  type: TYPE_NORMAL
- en: We do this in the creation of the tables by adding certain database constraints.
    When we created the table that holds the quotations in a previous recipe, we created
    our `quotations` table with a foreign key constraint that explicitly references
    the primary key of the books table, linking the two.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `FOREIGN KEY` relation includes the `ON DELETE CASCADE` attribute, which
    basically tells our MySQL server to delete related records in this table when
    the records this foreign key relates to are deleted.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Without specifying the `ON DELETE CASCADE` attribute in the creation of our
    table we can neither delete nor update our data because an `UPDATE` is a `DELETE`
    followed by an `INSERT`.
  prefs: []
  type: TYPE_NORMAL
- en: Because of this design, no orphan records will be left behind, which is what
    we want.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In MySQL, we have to specify `ENGINE=InnoDB` in order to use foreign keys.
  prefs: []
  type: TYPE_NORMAL
- en: Let's display the data in our database.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This shows us the following data in our database tables:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/B04829_07_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This shows us that we have two records that are related via primary to foreign
    key relationships.
  prefs: []
  type: TYPE_NORMAL
- en: When we now delete a record in the `books` table, we expect the related record
    in the `quotations` table to also be deleted by a cascading delete.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try this by executing the following SQL commands in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'After executing the preceding commands to delete records, we get the following
    new results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/B04829_07_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The famous `Design Patterns` are gone from our database of favorite quotations…
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We triggered cascading deletes in this recipe by designing our database in a
    solid fashion via primary to foreign key relationships with cascading deletes.
  prefs: []
  type: TYPE_NORMAL
- en: This keeps our data sane and integral.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this recipe and the sample code we have referred to the same table names
    sometimes starting capitalized and at other times in all lower-case.
  prefs: []
  type: TYPE_NORMAL
- en: This works for a Windows default installation of MySQL but might not work on
    Linux unless we change a setting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a link to the official MySQL documentation: [http://dev.mysql.com/doc/refman/5.0/en/identifier-case-sensitivity.html](http://dev.mysql.com/doc/refman/5.0/en/identifier-case-sensitivity.html)'
  prefs: []
  type: TYPE_NORMAL
- en: In the next recipe, we will use the code of our `MySQL.py` module from our Python
    GUI.
  prefs: []
  type: TYPE_NORMAL
- en: Storing and retrieving data from our MySQL database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will use our Python GUI to insert data into our MySQL database tables. We
    have already refactored the GUI we built in previous recipes in preparation for
    connecting and using a database.
  prefs: []
  type: TYPE_NORMAL
- en: We will use two textbox entry widgets into which we can type the book or journal
    title and the page number. We will also use a ScrolledText widget to type our
    favorite book quotations into, which we will then store in our MySQL database.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe will build on the MySQL database and tables we created in previous
    recipes.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will insert, retrieve, and modify our favorite quotations using our Python
    GUI. We have refactored the MySQL tab of our GUI in preparation for this.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/B04829_07_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In order to make the buttons do something, we will connect them to callback
    functions, as we did in previous recipes.
  prefs: []
  type: TYPE_NORMAL
- en: We will display the data in the ScrolledText widget below the buttons.
  prefs: []
  type: TYPE_NORMAL
- en: In order to do this, we will import the `MySQL.py` module, as we did before.
    All of the code that talks to our MySQL server instance and database resides in
    this module, which is a form of encapsulating code in the spirit of object-oriented
    programming.
  prefs: []
  type: TYPE_NORMAL
- en: We connect the **Insert Quote** button to the following callback function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: When we now run our code, we can insert data from our Python GUI into our MySQL
    database.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/B04829_07_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After entering a book title and book page plus a quotation from the book or
    movie, we insert the data into our database by clicking the **Insert Quote** button.
  prefs: []
  type: TYPE_NORMAL
- en: Our current design allows for titles, pages, and a quotation. We can also insert
    our favorite quotations from movies. While a movie does not have pages, we can
    use the page column to insert the approximate time when the quotation occurred
    within the movie.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we can verify that all of this data made it into our database tables by
    issuing the same commands we used previously.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/B04829_07_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After inserting the data, we can verify that it made it into our two MySQL tables
    by clicking the **Get Quotes** button which then displays the data we inserted
    into our two MySQL database tables, as shown above.
  prefs: []
  type: TYPE_NORMAL
- en: Clicking the **Get Quotes** button invokes the callback method we associated
    with the button click event. This gives us the data that we display in our ScrolledText
    widget.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We use the `self.mySQL` class instance variable to invoke the `showBooks()`
    method, which is part of the MySQL class we imported.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we imported the Python module that contains all of the coding
    logic to connect to our MySQL database and know how to insert, update, delete,
    and display the data.
  prefs: []
  type: TYPE_NORMAL
- en: We have now connected our Python GUI to this SQL logic.
  prefs: []
  type: TYPE_NORMAL
