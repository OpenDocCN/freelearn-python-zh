["```py\n>>> import bpy\n>>> bpy.context.scene.render.fps\n24\n```", "```py\n>>> import bpy\n>>> bpy.context.scene.frame_start\n1\n>>> bpy.context.scene.frame_end\n250\n```", "```py\n>>> import bpy\n>>> bpy.context.scene.frame_step\n1\n```", "```py\n>>> import bpy\n>>> bpy.context.scene.frame_current\n1\n```", "```py\n>>> import bpy\n>>> bpy.context.scene.frame_preview_start\n1\n>>> bpy.context.scene.frame_preview_end\n250\n```", "```py\nbl_info = {\n    \"name\": \"Action to Range\",\n    \"author\": \"John Packt\",\n    \"version\": (1, 0),\n    \"blender\": (3, 00, 0),\n    \"location\": \"Timeline > View > Action to Scene Range\"\n    \"description\": \" Action Duration to Scene Range\",\n    \"category\": \"Learning\",\n}\n```", "```py\nimport bpy\nclass ActionToSceneRange(bpy.types.Operator):\n    \"\"\"Set Playback range to current action Start/End\"\"\"\n    bl_idname = \"anim.action_to_range\"\n    bl_label = \"Action Range to Scene\"\n    bl_description = \"Transfer action range to scene range\"\n    bl_options = {'REGISTER', 'UNDO'}\n```", "```py\n    use_preview: bpy.props.BoolProperty(default=False)\n```", "```py\n    @classmethod\n    def poll(cls, context):\n        obj = context.object\n        if not obj:\n            return False\n        if not obj.animation_data:\n            return False\n        if not obj.animation_data.action:\n            return False\n        return True\n```", "```py\n    def execute(self, context):\n        anim_data = context.object.animation_data\n        first, last = anim_data.action.frame_range\n```", "```py\n        scn = context.scene\n        if self.use_preview:\n            scn.frame_preview_start = int(first)\n            scn.frame_preview_end = int(last)\n```", "```py\n        else:\n            scn.frame_start = int(first)\n            scn.frame_end = int(last)\n```", "```py\n        bpy.ops.action.view_all()\n        return {'FINISHED'}\n```", "```py\nbl_options = {'REGISTER', 'UNDO'}\n```", "```py\ndef view_menu_items(self, context):\n    props = self.layout.operator(\n                         ActionToSceneRange.bl_idname,\n                         text=ActionToSceneRange.bl_label +\n                              \" (preview)\")\n    props.use_preview = True\n```", "```py\n    props = self.layout.operator(\n                         ActionToSceneRange.bl_idname\n                         )\n    props.use_preview = False\n```", "```py\n        sub.menu(\"TIME_MT_view\")\n```", "```py\ndef register():\n    bpy.utils.register_class(ActionToSceneRange)\n    bpy.types.TIME_MT_view.append(view_menu_items)\n```", "```py\ndef unregister():\n    bpy.types.TIME_MT_view.remove(view_menu_items)\n    bpy.utils.unregister_class(ActionToSceneRange)\n```", "```py\nRuntimeError: Operator bpy.ops.action.view_all.poll() failed, context is incorrect\n```", "```py\ntry:\n    bpy.ops.action.view_all()\nexcept RuntimeError:\n    pass\n```", "```py\n    for window in context.window_manager.windows:\n        screen = window.screen\n```", "```py\n        for area in screen.areas:\n            if area.type != 'DOPESHEET_EDITOR':\n                continue\n```", "```py\n            for region in area.regions:\n                if region.type == 'WINDOW':\n```", "```py\n                    with context.temp_override(\n                                            window=window,\n                                            area=area,\n                                            region=region):\n                        bpy.ops.action.view_all()\n                    break\n                break\n    return {'FINISHED'}\n```", "```py\nkeyframe_insert(data_path,\n                index=- 1,\n                frame=bpy.context.scene.frame_current,\n[…]\nReturns\n        Success of keyframe insertion.\n```", "```py\n>>> import bpy\n>>> bpy.context.object.location = 10.0, 10.0, 10.0\n>>> bpy.context.object.keyframe_insert('location', frame=1)\nTrue\n```", "```py\n>>> bpy.context.object.location = -10.0, -10.0, -10.0\n>>> bpy.context.object.keyframe_insert('location',frame=24)\nTrue\n```", "```py\n>>> bpy.context.object.animation_data\nbpy.data.objects['Cube']...AnimData\n```", "```py\n>>> anim_data = bpy.context.object.animation_data\n>>> anim_data.action\nbpy.data.actions['CubeAction']\n```", "```py\n>>> action = anim_data.action\n>>> anim_data.action.fcurves\nbpy.data.actions['CubeAction'].fcurves\n```", "```py\n>>> fcurves = anim_data.action.fcurves\n>>> for fc in fcurves:\n...     print(fc.data_path, fc.array_index)\n...\nlocation 0\nlocation 1\nlocation 2\n```", "```py\n>>> for fc in fcurves:\n...     print(fc.data_path, fc.array_index)\n...     for kf in fc.keyframe_points:\n...        frame, value = kf.co\n...        print(\"\\t frame\", frame, \"value\", value)\nlocation 0\n    frame 1.0 value 0.0\n    frame 24.0 value 0.2\nlocation 1\n    frame 1.0 value 0.0\n    frame 24.0 value 4.0\nlocation 2\n    frame 1.0 value 0.0\n    frame 24.0 value 3.0\n```", "```py\n>>> kf.interpolation\n'BEZIER'\n```", "```py\n>>> kf.handle_left\nVector((16.0, 10.0))\n>>> kf.handle_right\nVector((31.0, 10.0))\n```", "```py\nbl_info = {\n    \"name\": \"Vert Runner\",\n    \"author\": \"John Packt\",\n    \"version\": (1, 0),\n    \"blender\": (3, 00, 0),\n    \"location\": \"Object > Animation > Vert Runner\"\n    \"description\": \"Run on vertices of the active object\",\n    \"category\": \"Learning\",\n}\n```", "```py\nimport bpy\nclass VertRunner(bpy.types.Operator):\n    \"\"\"Run over vertices of the active object\"\"\"\n    bl_idname = \"object.vert_runner\"\n    bl_label = \"Vertex Runner\"\n    bl_description = \"Animate along verts of active object\"\n    bl_options = {'REGISTER', 'UNDO'}\n```", "```py\n    step: bpy.props.IntProperty(default=12)\n```", "```py\n    @classmethod\n    def poll(cls, context):\n        obj = context.object\n        if not obj:\n            return False\n        if not obj.type == 'MESH':\n            return False\n        if not len(context.selected_objects) > 1:\n            return False\n        return True\n```", "```py\n    def execute(self, context):\n        verts = list(context.object.data.vertices)\n```", "```py\n        for ob in context.selected_objects:\n            if ob == context.active_object:\n                continue\n```", "```py\n            frame = context.scene.frame_current\n            for vert in verts:\n                ob.location = vert.co\n                ob.keyframe_insert('location', frame=frame)\n                frame += self.step\n        return {'FINISHED'}\n```", "```py\ndef anim_menu_func(self, context):\n    self.layout.separator()\n    self.layout.operator(VertRunner.bl_idname,\n                         text=VertRunner.bl_label)\n```", "```py\ndef register():\n    bpy.utils.register_class(VertRunner)\n    bpy.types.VIEW3D_MT_object_animation.append(\n                                            anim_menu_func)\ndef unregister():\n    bpy.types.VIEW3D_MT_object_animation.remove(\n                                            anim_menu_func)\n    bpy.utils.unregister_class(VertRunner)\n```", "```py\nclass VertRunner(bpy.types.Operator):\n    \"\"\"Run over the vertices of the active object\"\"\"\n    bl_idname = \"object.vert_runner\"\n    bl_label = \"Vert Runner\"\n    bl_description = \"Animate along verts of active object\"\n    bl_options = {'REGISTER', 'UNDO'}\n    step: bpy.props.IntProperty(default=12)\n    loop: bpy.props.BoolProperty(default=True)\n```", "```py\n        if self.loop:\n            verts.append(verts[0])\n```", "```py\nrotation = arcsin(sine)\n```", "```py\nimport bpy\nfrom math import asin\nfrom math import pi\n```", "```py\n    def aim_to_point(self, ob, point_co):\n        \"\"\"Orient object to look at coordinates\"\"\"\n        direction = point_co – ob.location\n```", "```py\n        direction.normalize()\n```", "```py\n        arc = asin(direction.y)\n        if direction.x < 0:\n            arc = pi – arc\n```", "```py\n        arc += pi / 2\n```", "```py\n    arcs = (arc, arc + 2*pi, arc - 2*pi)\n```", "```py\n    diffs = [abs(ob.rotation_euler.z - a) for a in arcs]\n    shortest = min(diffs)\n```", "```py\n    res = next(a for i, a in enumerate(arcs)\n               if diffs[i] == shortest)\n    ob.rotation_euler.z = res\n```", "```py\n  def execute(self, context):\n      verts = list(context.object.data.vertices)\n      if self.loop:\n          verts.append(verts[0])\n      for ob in context.selected_objects:\n          if ob == context.active_object:\n            continue\n```", "```py\n      ob.location = context.object.data.vertices[-1].co\n```", "```py\n      frame = context.scene.frame_current\n      for vert in verts:\n          self.aim_to_point(ob, vert.co)\n          ob.keyframe_insert('rotation_euler',\n                             frame=frame, index=2)\n          ob.location = vert.co\n          ob.keyframe_insert('location', frame=frame)\n          frame += self.step\n  return {'FINISHED'}\n```"]