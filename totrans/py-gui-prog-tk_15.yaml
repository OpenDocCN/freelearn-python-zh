- en: '15'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Visualizing Data Using the Canvas Widget
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With months of experimental data logged in the database, it's time to begin
    the process of visualizing and interpreting it. Rather than exporting data into
    a spreadsheet to create charts and graphs, your fellow analysts have asked whether
    the program itself can create graphical data visualizations. Indeed it can! To
    implement this feature, you're going to need to learn about Tkinter's `Canvas`
    widget.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you''ll implement data visualizations as you learn the following
    topics:'
  prefs: []
  type: TYPE_NORMAL
- en: In *Drawing and animation with Tkinter's Canvas*, you'll learn to use the `Canvas`
    widget for drawing and animation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In *Creating simple graphs using Canvas*, we'll build a simple line graph using
    the Tkinter `Canvas`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In *Advanced graphs using Matplotlib*, we'll learn to integrate the Matplotlib
    library for more powerful charting and graphic capabilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing and animation with Tkinter's Canvas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Canvas` widget is undoubtedly one of the most powerful widgets available
    in Tkinter. It can be used to build anything from custom widgets and views to
    complete user interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: As the name implies, a `Canvas` widget is a blank area on which figures and
    images can be drawn. To understand its basic usage, let's create a small demo
    script.
  prefs: []
  type: TYPE_NORMAL
- en: 'Begin the script by creating a root window and a `Canvas` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Creating a `Canvas` object is just like creating any other Tkinter widget. In
    addition to the parent widget and `background` argument, we can also specify `width`
    and `height` arguments to set the size of the `Canvas`. Setting the size of a
    `Canvas` widget is important, because it defines not only the size of the widget
    but also the **viewport**; that is, the area in which our drawn objects will be
    visible. We can actually draw anywhere on the `Canvas`'s virtually infinite surface,
    but only the area inside the viewport will be visible.
  prefs: []
  type: TYPE_NORMAL
- en: We'll learn how to see the area outside the viewport below in the *Scrolling
    the Canvas* section.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing on the Canvas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once we have a `Canvas` object, we can start drawing items on it using its many
    `create_()` methods. These methods allow us to draw shapes, lines, images, and
    text. Let's explore these methods in more detail as we develop the `simple_canvas_demo.py`
    script.
  prefs: []
  type: TYPE_NORMAL
- en: Rectangles and squares
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Rectangles or squares can be drawn on the `Canvas` using the `create_rectangle()`
    method, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The first four arguments of `create_rectangle()` are the coordinates of the
    upper-left and lower-right corners, counted in pixels from the upper-left corner
    of the `Canvas`. Each `create_()` method begins with positional arguments that
    define the position and size of the shape. Following those, we can specify a variety
    of keyword arguments to describe other aspects of the shape; for example, the
    `fill` option used here specifies the color of the inside of the object.
  prefs: []
  type: TYPE_NORMAL
- en: It's vital to understand that vertical coordinates on the `Canvas`, unlike coordinates
    on a typical chart, extend *down* from the top. For example, the coordinate (200,
    100) is 100 pixels *above* (200, 200). The same is true for coordinates on all
    Tkinter widgets, and in many other GUI programming environments as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Coordinates can also be specified as tuple pairs, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Although this requires more characters, it improves readability considerably.
    The `create_rectangle()` method supports several other keyword arguments to configure
    the rectangle''s fill and outline, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Argument | Values | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `dash` | Tuple of integers | Defines a dash pattern (see below) for the outline
    |'
  prefs: []
  type: TYPE_TB
- en: '| `outline` | Color string | Specifies a color for the border |'
  prefs: []
  type: TYPE_TB
- en: '| `width` | Integer | Specifies a width for the border |'
  prefs: []
  type: TYPE_TB
- en: '| `stipple` | Bitmap name | Name of a bitmap pattern to use for the fill |'
  prefs: []
  type: TYPE_TB
- en: Dashed or dotted lines can be defined on `Canvas` objects using a **dash pattern**.
    This is a tuple of integers that describes the number of pixels before switching
    between line and blank. For example, a `dash` value of `(5, 1, 2, 1)` would produce
    a repeating pattern of five pixels of line, one blank pixel, two pixels of line,
    and one blank.
  prefs: []
  type: TYPE_NORMAL
- en: The `stipple` value allows you to specify a bitmap to be used for filling the
    shape instead of a solid fill. Tkinter comes with some built-in bitmap files,
    such as `gray75`, `gray50`, `gray25`, and `gray12` (each of which is filled with
    evenly spaced pixels at the specified percentage), or you can load in a `.xbm`
    file of your own using the format `@filename.xbm`.
  prefs: []
  type: TYPE_NORMAL
- en: Ovals, circles, and arcs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In addition to rectangles, we can also create ovals and circles using the `create_oval()`
    method. Add an oval to the demo as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As with creating a rectangle, we begin by specifying the coordinates to describe
    the shape; however, this time the coordinates determine the upper-left and lower-right
    corners of its **bounding box**. A bounding box is the smallest rectangle that
    will contain an item. For example, in the case of this oval, the bounding box
    has corners at `(350, 200)` and `(450, 250)`. To make a circle, of course, we
    simply define an oval with a square bounding box.
  prefs: []
  type: TYPE_NORMAL
- en: '`create_oval()` allows the same keyword arguments as `create_rectangle()` to
    configure the fill and outline of the shape.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to draw only a sector of the oval, we can use the `create_arc()`
    method. This method works identically to `create_oval()`, but also takes `extent`
    and `start` keyword arguments. The `start` argument specifies the number of degrees
    from the origin at the left middle of the circle to the point where the drawing
    starts, and the `extent` argument specifies how many degrees counter-clockwise
    the arc will extend. For example, an `extent` of `90` and `start` of `180` will
    draw a quarter of the oval starting at the right side and going to the bottom,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image77828.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.1: Drawing an arc'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add an arc to our demo:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Lines
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can also draw lines on the `Canvas` using the `create_line()` method. As
    with rectangles, ovals, and arcs, we begin by specifying coordinates to define
    the line. Unlike with the shapes, the coordinates do not define a bounding box,
    but rather a set of points that define the line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add a line to our demo script, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this example, a straight line will be drawn from the first point at `(0,
    180)` to the second at `(1024, 180)`. The `fill` argument in this case defines
    the color of the line, and `width` determines how wide it is.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `create_line()` method is not limited to a single line between two points.
    We can specify any number of coordinate pairs as positional arguments, and Tkinter
    will connect them all from first to last. For example, add this to the demo:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This time we've created a more complex line with six points.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the additional arguments for `create_line()` are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Argument | Values | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `arrow` | `FIRST`, `LAST`, or `BOTH` | If specified, will draw arrows at
    the end of the line. Default is no value, indicating no arrows. |'
  prefs: []
  type: TYPE_TB
- en: '| `capstyle` | `BUTT`, `PROJECTING`, or `ROUND` | Specifies the style for the
    end of the line. Default is `BUTT`. |'
  prefs: []
  type: TYPE_TB
- en: '| `dash` | Tuple of integers | Defines the dash style for the line. |'
  prefs: []
  type: TYPE_TB
- en: '| `joinstyle` | `ROUND`, `BEVEL`, or `MITER` | Specifies the style of corner
    joins. Default is `ROUND`. |'
  prefs: []
  type: TYPE_TB
- en: '| `smooth` | Boolean | Whether to draw the line with spline curves or straight
    lines. Default is `False` (straight lines). |'
  prefs: []
  type: TYPE_TB
- en: '| `tags` | Tuple of strings | Any number of tags to assign to the line. |'
  prefs: []
  type: TYPE_TB
- en: Polygons
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Canvas` also allows us to draw arbitrary polygons; it works in a similar
    fashion to lines, in which each coordinate defines a point that will be connected
    to draw the outline of the polygon. The difference is that the last point and
    the first point will also be connected to form a closed shape.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a polygon to our demo script like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note that, unlike with `create_line()`, the `fill` argument defines the color
    of the polygon's interior, not the color of the outline. The appearance of the
    polygon's outline can be configured using the same arguments that `create_rectangle()`
    and `create_oval()` use.
  prefs: []
  type: TYPE_NORMAL
- en: Text
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In addition to simple shapes, we can also place text directly on the `Canvas`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s add some text to our demo:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The single coordinate argument determines the point where the text will be anchored
    to the `Canvas`. By default, the text is attached at its own center point to the
    anchor point. In this case, that means that the middle of our string (somewhere
    around the "a") will be at `x=500`, `y=100`. However, the `anchor` argument can
    be used to specify which part of the text item is attached to the anchor point;
    it can be any of the cardinal direction constants (`N`, `NW`, `W`, and so on)
    or `CENTER`, which is the default.
  prefs: []
  type: TYPE_NORMAL
- en: The `fill` argument in this case determines the color of the text, and we can
    use `font` to determine the font properties of the text. Tkinter 8.6 and later
    also offers an `angle` argument that can rotate the text by the given number of
    degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Images
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Of course, we aren''t limited to just drawing lines and simple shapes on the
    `Canvas`; we can also place raster images using the `create_image()` method. This
    method allows us to place a `PhotoImage` or `BitmapImage` object on the `Canvas`,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As with text, the image is attached to the anchor coordinate at its center by
    default, but the `anchor` argument can be used to change that to any side or corner
    of the image's bounding box.
  prefs: []
  type: TYPE_NORMAL
- en: Tkinter widgets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The last thing we can place on the `Canvas` is another Tkinter widget. Of course,
    since the `Canvas` is a widget, we can just do this using a geometry manager like
    `pack()` or `grid()`, but we gain a lot more control if we add it as a `Canvas`
    item using `create_window()`.
  prefs: []
  type: TYPE_NORMAL
- en: To add a widget using `create_window()`, the widget need only be a child of
    a widget on the same parent window as the `Canvas` widget. We can then pass a
    reference to the widget to the method's `window` argument. We can also specify
    a `width` and `height` argument to determine the size of the window area to which
    the widget will be added; the widget will expand into that area by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s add a quit button to the demo:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Just as with text and images, the widget is anchored to the given coordinate
    at its center by default, and the `anchor` argument can be used to attach it at
    a side or corner instead.
  prefs: []
  type: TYPE_NORMAL
- en: Canvas items and state
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note the use of the `activeforeground` and `activebackground` arguments in
    the code example above. Just like widgets, `Canvas` items can have various states
    set that can be used to dynamically change the appearance. The table below shows
    the available states for items, and what result they have:'
  prefs: []
  type: TYPE_NORMAL
- en: '| State | Trigger | Result |'
  prefs: []
  type: TYPE_TB
- en: '| `normal` | Default | Normal appearance |'
  prefs: []
  type: TYPE_TB
- en: '| `disabled` | Manual setting | Disabled appearance |'
  prefs: []
  type: TYPE_TB
- en: '| `active` | Mouse hovers over | Active appearance |'
  prefs: []
  type: TYPE_TB
- en: '| `hidden` | Manual setting | Not shown |'
  prefs: []
  type: TYPE_TB
- en: All drawn items (that is, not images) have state-based versions of their `fill`,
    `outline`, `dash`, `width`, `stipple`, and `outlinestipple` arguments, which are
    simply the argument with `active` or `disabled` prefixed to it. For example, `activefill`
    sets the `fill` value when the item is hovered over by the mouse, while `disabledoutline`
    sets the outline color when the item is set to a `disabled` state. Image items
    have `disabledimage` and `activeimage` arguments that can be set to display a
    different image when the item is disabled or active.
  prefs: []
  type: TYPE_NORMAL
- en: The `active` state is automatically set when an item is hovered over by the
    mouse; the `disabled` and `hidden` states can be set using the `Canvas.itemconfigure()`
    method, which is discussed below in the *Canvas object methods* section.
  prefs: []
  type: TYPE_NORMAL
- en: Canvas object methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Canvas` items are not represented by a Python object; instead, the return
    value of any `create_()` method is an integer that uniquely identifies the item
    in the context of the `Canvas` object. To manipulate `Canvas` items after they''ve
    been created, we need to save that identification value and pass it to various
    `Canvas` methods.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we could save the ID of the image we added, then bind the image
    to a callback using the `Canvas.tag_bind()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Here, we've used the `tag_bind()` method to bind a left-mouse click on our image
    object to the `Canvas`'s `delete()` method, which (when given an item identifier)
    deletes the item.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Canvas` object has many methods that can operate on a `Canvas` item; some
    of the more useful ones are listed in this table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Arguments | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `bbox()` | Item ID | Returns a tuple describing the bounding box of the item.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `coords()` | Item ID, coordinates | If only the ID is provided, returns the
    coordinates of the item. Otherwise, moves the item to the given coordinates. |'
  prefs: []
  type: TYPE_TB
- en: '| `delete()` | Item ID | Deletes the item from the `Canvas`. |'
  prefs: []
  type: TYPE_TB
- en: '| `find_overlapping()` | Box coordinates | Returns a list of item IDs that
    overlap the box described by the coordinates. |'
  prefs: []
  type: TYPE_TB
- en: '| `itemcget()` | Item ID, option | Returns the value of `option` for the given
    item. |'
  prefs: []
  type: TYPE_TB
- en: '| `itemconfigure()` | Item ID, option | Sets one or more configuration options
    on the specified item. |'
  prefs: []
  type: TYPE_TB
- en: '| `move()` | Item ID, X, Y | Moves the item on the `Canvas` relative to its
    current position by the given `X` and `Y` amounts. |'
  prefs: []
  type: TYPE_TB
- en: '| `type()` | Item ID | Returns a string describing the type of object (rectangle,
    oval, arc, and so on). |'
  prefs: []
  type: TYPE_TB
- en: Note that any of these methods that take an item ID can also take a **tag**.
    Recall from *Chapter 9*, *Improving the Look with Styles and Themes*, that a tag
    is just a string that can be assigned to an item when created, allowing us to
    refer to multiple items at once. The `Canvas` has two tags built in by default,
    `all` and `current`. As you might expect, `all` refers to all items on the `Canvas`,
    and `current` refers to the item that currently has focus.
  prefs: []
  type: TYPE_NORMAL
- en: All `create_()` methods allow the option of specifying a tuple of tag strings
    to attach to the object.
  prefs: []
  type: TYPE_NORMAL
- en: By the way, if you haven't yet, add `root.mainloop()` to the demo script and
    execute it to see what we've drawn!
  prefs: []
  type: TYPE_NORMAL
- en: Scrolling the Canvas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned earlier, the width and height of a `Canvas` widget determines the
    size of the viewport, but the actual drawable area on the widget stretches endlessly
    out in all directions. To actually see objects outside the viewport area, we need
    to enable scrolling.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how this works, let''s create a scrollable starfield; open a new file
    called `canvas_scroll.py` and let''s begin like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here, we've imported `tkinter` and some functions from `random`, then created
    a root window and a `Canvas` object with a viewport size of 1024x768\. Finally,
    we've placed the `Canvas` on the root window using `grid()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s draw some "stars":'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We begin by defining a list of color values, then start a `for` loop that will
    iterate 1000 times. Inside the loop, we'll generate random `X` and `Y` coordinates,
    a random size (`Z`), and choose one of the colors at random. We'll then have the
    `Canvas` draw a circle centered on the random point filled with the random color.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the ranges supplied for `X` and `Y` are double the size of the `Canvas`
    object. Because of this, the loop will be creating circles out to the right and
    down from our viewport area.
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable scrolling of the `Canvas`, we first have to define a `scrollregion`
    value for it, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `scrollregion` value is a tuple of four integers that describe the bounding
    box of the area we want to be able to scroll. Essentially, the first two integers
    are the `X` and `Y` coordinates of the upper-left corner of the box, and the second
    two are the coordinates of the lower right.
  prefs: []
  type: TYPE_NORMAL
- en: To actually scroll the `Canvas`, we'll need some `Scrollbar` widgets. We've
    already encountered these in *Chapter 8*, *Navigating Records with Treeview and
    Notebook*, remember that to use them we need to create the widgets, add them to
    the layout, and connect the appropriate callbacks so that the scrollbars can communicate
    with the widget being scrolled.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here, we've created two `Scrollbar` widgets, one for horizontal scrolling and
    one for vertical. We've added them to the layout just below and to the right of
    the `Canvas`, respectively. Then, we connect each scrollbar's `command` argument
    to the `Canvas`'s `xview` or `yview` method, and configure the `Canvas`'s `yscrollcommand`
    and `xscrollcommand` arguments to call the respective scrollbar's `set()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finish off this script with a call to `root.mainloop()` and execute it; you
    should see something like the picture here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.1: Scrolling through the stars!](img/B17578_15_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.2: Scrolling through the stars!'
  prefs: []
  type: TYPE_NORMAL
- en: A handy trick to properly configure the scroll region after drawing runtime-defined
    points on the `Canvas` (for example, drawing based on user input) is to set `scrollregion`
    to the output of `canvas.bbox('all')` after creating the items. When passed a
    tag of `all`, the `bbox()` method returns a bounding box that contains the entirety
    of all items on the `Canvas`. You can set this value directly to `scrollregion`
    to make sure all your items can be viewed.
  prefs: []
  type: TYPE_NORMAL
- en: Animating Canvas objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Tkinter's `Canvas` widget doesn't have a built-in animation framework, but we
    can still create simple animations by combining its `move()` method with our understanding
    of the event queue.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate this, we'll create a bug race simulator, in which two bugs (represented
    by colored circles) will race haphazardly toward a finish line on the other side
    of the screen. Like real bugs, they won't have any notion that they're in a race
    and will move relatively randomly, the winner being whichever bug incidentally
    hits the finish line first.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, open a new Python file and start with a basic object-oriented pattern,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This is just a simple OOP Tkinter boilerplate application with a `Canvas` object
    added to the root window. This will be the basic platform on which we'll build
    our game code.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the playing field
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we have the basic framework, let''s set up the playing field. We want
    to be able to reset the playing field after each round, so rather than doing this
    in the initializer, we''ll create a separate method called `setup()`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `setup()` method begins by calculating some relative locations on the `Canvas`
    object and saving them as instance properties, which will simplify the placement
    of objects on the `Canvas` object. Calculating these at runtime means we can resize
    the window between rounds for a longer or shorter racecourse.
  prefs: []
  type: TYPE_NORMAL
- en: The finish line is implemented as a rectangle across the right edge of the window.
    Note the use of the `stipple` argument to specify a bitmap that will overlay the
    solid color to give it some texture; in this case, `gray50` is a built-in bitmap
    that alternates filled and transparent pixels. This gives us something a little
    more interesting than a flat color.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a call to `setup()` at the end of `App.__init__()` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Because `setup()` relies on the width and height values of the `Canvas` object,
    we need to make sure it isn't called until the operating system's window manager
    has drawn and sized the window. The simplest way of doing this is to call `wait_visibility()`
    on the `Canvas` object, which will block execution until the object has been drawn.
  prefs: []
  type: TYPE_NORMAL
- en: Setting our players
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we have the playing field, we need to create our players. We''ll create
    a `Racer` class to represent a player; start it like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `Racer` class will be created with a reference to the `Canvas` object and
    a color string, from which its color and name will be derived. We'll draw the
    racer initially at the middle left of the screen and make it 50 pixels in size.
    Finally, we save a reference to its item ID string in `self.id`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, back in `App.setup()`, we''ll create two racers by adding the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: At this point, all the objects in our game are set up. Run the program and you
    should see a yellow-stippled finish line on the right and a green circle on the
    left (the red circle will be hidden under the green, since they're at the same
    coordinates).
  prefs: []
  type: TYPE_NORMAL
- en: Animating the racers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To animate our racers, we're going to use the `Canvas.move()` method. As we
    learned earlier, `move()` takes an item ID, a number of `X` pixels, and a number
    of `Y` pixels, and moves the item by that amount. By combining this with the `random.randint()`
    function and some simple logic, we can generate a series of moves that will send
    each racer on a meandering path toward the finish line.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple implementation may look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This method generates a random forward `X` movement, a random up-or-down `Y`
    movement, and a random time interval. We then use the `after()` method to schedule
    a call to `move()` for the generated `X` and `Y` movements after the random time
    interval. The `if` statement determines whether the racer's bounding box is currently
    at or beyond the right side of the screen; if this test evaluates to `False`,
    we schedule another call to `move_racer()`.
  prefs: []
  type: TYPE_NORMAL
- en: This method gets the racers to the finish line, but it isn't quite what we want.
    The problem is that `move()` acts instantaneously, causing the bug to jump across
    the screen in jerky movements rather than moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the bugs move smoothly, we''re going to need to take a more complex
    approach:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we'll calculate a series of linear moves, each with a random delta `x`,
    delta `y`, and interval, that will reach the finish line
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we'll break each individual move into a number of steps determined by
    dividing the movement interval into a regular animation frame interval
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we'll add each step of each movement to a queue
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we'll call a method once each animation frame interval that will pull
    the next step from the queue and pass it to `move()`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s start by defining our frame interval; in the `Racer` class, create a
    class attribute for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '`FRAME_RES` (short for frame resolution) defines the number of milliseconds
    between each `Canvas.move()` call. 50 milliseconds gives us 20 frames per second
    and should be sufficient for smooth movements.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to import the `Queue` class and create an instance inside the
    `Racer` object''s initializer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will create the method that will plot the course to the finish line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This method plots a course from the left center of the `Canvas` to a random
    point on the right side by generating random `x` and `y` movements until the total
    change in `x` is greater than the width of the `Canvas` object. The change in
    `x` will always be positive, keeping our bugs moving toward the finish line, but
    the change in `y` can be positive or negative, to allow both upward and downward
    movement. To keep our bugs on the screen, we constrain the total `y` movements
    by negating any change in `y` that would put the player outside the top or bottom
    bounds of the `Canvas`.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the random `dx` and `dy` values, we generate a random time interval
    for the move to take, between half a second and two seconds. Finally, the generated
    `dx`, `dy`, and `time` values are passed to a `queue_move()` method.
  prefs: []
  type: TYPE_NORMAL
- en: The `queue_move()` method will need to break the large move into individual
    frames of movement that describe how the racer should move in one `FRAME_RES`
    interval. To make this calculation, we will need a **partition function**, a mathematical
    function that will break an integer `N` into `K` approximately equal integers.
    For example, if we wanted to break `-10` into four parts, our function should
    return a list like `[-2, -2, -3, -3]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create `partition()` as a static method on `Racer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We start the method with the easy case: when `n` is `0`, return a list of `k`
    zeros.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we''ll deal with the more complicated cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: For a non-zero `n`, we first calculate the `base_step` by dividing `n` by `k`
    using floor division, which rounds our result down to the nearest integer. Then,
    we create a list of length `k` that is made up of `base_step` values. Next, we
    need to distribute the remainder of `n / k` among this list as evenly as we can.
    To accomplish this, we will add 1 to the first `n % k` items in the parts list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow the math here using our example of `n = -10` and `k = 4`:'
  prefs: []
  type: TYPE_NORMAL
- en: The base step is calculated as `-10 / 4 = -3` (remember, floor division always
    rounds down, so `-2.5` gets rounded to `-3`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We then create a list of four base step values: `[-3, -3, -3, -3]`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-10 % 4 = 2`, so we add `1` to the first two items in the list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We arrive at an answer of `[-2, -2, -3, -3]`. Perfect!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operations like this partition function are part of **discrete mathematics**,
    a branch of mathematics that deals with operations on whole numbers. Discrete
    mathematics is often used for solving spatial problems such as those encountered
    in drawing and animation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the partition method, we can write the `queue_move()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We first determine the necessary number of steps in this move by dividing the
    time interval by `FRAME_RES` using floor division. We then create a list of `X`
    moves and a list of `Y` moves by passing `dx` and `dy` each to our `partition()`
    method. Those two lists are combined with `zip()` to form a single list of `(dx,
    dy)` pairs, which we iterate to add each pair to the animation queue.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the animation actually happen, we''ll need a method to check the queue
    and make each move; we''ll call it `next_move()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `next_move()` method first checks the queue for a movement step. If there
    is one, `canvas.move()` is called with the racer's ID and the `X` and `Y` values
    for the step. When the game starts, this method will be called repeatedly from
    the `App` object until one of the racers has won.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we need to add a call to `plot_course()` to the `Racer` class''s initializer,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Thus, as soon as a `Racer` object is created, it will plot the course to the
    finish line, and wait for the `App` class to tell it to move.
  prefs: []
  type: TYPE_NORMAL
- en: Running the game loop and detecting a win condition
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To actually run the game, we need to start a game loop. Of course, we know from
    *Chapter 14*, *Asynchronous Programming with Thread and Queue*, that we can't
    simply use a Python `for` or `while` loop, since this would block Tkinter drawing
    operations and simply make the game freeze up until it was over. Instead, we need
    to create a method that executes a single "frame" of the game animation, then
    schedules itself on the Tkinter event loop to run again.
  prefs: []
  type: TYPE_NORMAL
- en: 'That method begins like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: It begins by iterating through the racer objects and executing their `next_move()`
    methods. After moving each racer, our next step is to determine if one of them
    has crossed the finish line and won.
  prefs: []
  type: TYPE_NORMAL
- en: To detect this condition, we need to check whether a racer is overlapping with
    the finish line item.
  prefs: []
  type: TYPE_NORMAL
- en: Collision detection between items is slightly awkward with the Tkinter `Canvas`
    widget. We have to pass a set of bounding box coordinates to `find_overlapping()`,
    which returns a tuple of item identifiers that overlap with the bounding box.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create an `overlapping()` method for our `Racer` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This method retrieves the bounding box of the `Racer` item using the `Canvas`'s
    `bbox()` method. It then fetches a tuple of items overlapping this bounding box
    using `find_overlapping()`. Since this would include the ID of the `Racer` item
    itself, we'll filter that out of the tuple using a list comprehension. The result
    is a list of items overlapping with this `Racer` object's `Canvas` item. Since
    this method doesn't require any arguments and only returns a value, we've made
    it a property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in our `execute_frame()` method, we''ll check each racer to see if it
    has crossed the finish line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: If the `finish_line` ID is in the list returned by the racer's `overlapping()`
    method, the racer has hit the finish line and will be declared the winner by calling
    a `declare_winner()` method and returning from the method.
  prefs: []
  type: TYPE_NORMAL
- en: If no player was declared the winner, the `execute_frame()` method is scheduled
    to run again after `Racer.FRAME_RES` milliseconds. This effectively implements
    a game loop using the Tkinter event loop, which will run until one racer wins.
  prefs: []
  type: TYPE_NORMAL
- en: 'We handle a win condition in the `declare_winner()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In this method, we've just created a text item declaring `racer.name` as the
    winner in the center of the `Canvas`. The `activefill` argument causes the color
    to appear violet when the mouse is hovered over it, indicating to the user that
    this text is clickable.
  prefs: []
  type: TYPE_NORMAL
- en: 'When that text is clicked, it calls the `reset()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The `reset()` method needs to clear off the `Canvas`, so it calls the `delete()`
    method with an argument of `all`. Remember that `all` is a built-in tag that applies
    to all items on the `Canvas`, so this line effectively deletes all `Canvas` items.
    Once the `Canvas` is clear, we call `setup()` to reset and restart the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing we need to do is make sure the game starts whenever `setup()`
    is called. To do that, add a call to `execute_frame()` to the end of `setup()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The game is now complete; run the script and you should see something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17578_15_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.3: The bug race game. Red wins!'
  prefs: []
  type: TYPE_NORMAL
- en: While not exactly simple, animation in Tkinter can provide smooth and satisfactory
    results with some careful planning and a bit of math. Enough games, though; let's
    get back to the lab and figure out how to use the Tkinter `Canvas` widget to visualize
    data.
  prefs: []
  type: TYPE_NORMAL
- en: Creating simple graphs using Canvas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first graph we want to produce is a simple line graph that shows the growth
    of our plants over time. Each lab has varying climate conditions, and we want
    to see how those conditions are affecting the growth of all plants, so the chart
    will have one line per lab showing the average of the median height measurements
    for all plots in the lab over the days of the experiment.
  prefs: []
  type: TYPE_NORMAL
- en: We'll start by creating a model method to return the raw data, then create a
    `Canvas`-based line-chart view, and finally create an application callback to
    pull the data and send it to the chart view.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the model method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Working with another data analyst at ABQ, you develop a SQL query that determines
    the day number of a plot check by subtracting its date from the oldest date in
    the `plot_checks` table, then pulls `lab_id` and the average of `median_height`
    for all plants in the given lab on the given day. The query looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The query returns a table of data that looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Day | lab_id | Average Height (cm) |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | A | 1.4198750000000000 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | B | 1.3320000000000000 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | C | 1.5377500000000000 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | A | 1.7266250000000000 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | B | 1.8503750000000000 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | C | 1.4633750000000000 |'
  prefs: []
  type: TYPE_TB
- en: 'Using this query, let''s create a new `SQLModel` method called `get_growth_by_lab()`
    to return the needed data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a fairly straightforward method; it just runs the query and returns
    the results. Recall that the `SQLModel.query()` method returns results as a list
    of dictionaries; in this case, each of the dictionaries contains three fields:
    `Day`, `lab_id`, and `Avg Height (cm)`. Now we just need to develop a chart view
    that can visualize this data for the user.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the chart view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The chart view we''re going to create will need to take the data structure
    from our model method and use it to plot a line chart. Head over to `views.py`,
    where we''ll create the `LineChartView` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '`LineChartView` is a subclass of `Canvas`, so we''ll be able to draw items
    directly on it. This view will not only contain the data plots, but the axes,
    labels, and legend as well. It will be constructed for re-usability, so we''re
    going to design it without any specific reference to the data we''re charting
    in this instance. Ideally, we''d like to be able to send arbitrary datasets to
    it to generate line graphs. The two class attributes defined here provide a default
    value for the `margin` around the chart (in pixels) and a list of `colors` to
    use for each subsequent line plot. The growth chart we''re making only has three
    plots (one for each lab), but the additional colors allow us to specify up to
    seven. You could provide additional colors in this list if you wanted to use it
    for charts with more than seven plots.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we''ll begin the initializer method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Apart from the usual parent widget argument, we''ve specified these additional
    positional arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`data` will be our list of dictionaries containing the data from the query.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`plot_size` will be a tuple of integers specifying the width and height of
    the plot area in pixels.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x_field` and `y_field` will be the field names to use for the `X` and `Y`
    values of the plot. For the growth chart this will be `Day` and `Avg Height (cm)`,
    respectively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`plot_by_field` will be the field whose value will be used to categorize the
    rows into individual plots. For the growth chart, this will be `lab_id`, since
    we want one line plot for each lab.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All these values are stored to instance variables so we can access them from
    our methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re going to implement the plot area of this widget as a second `Canvas`
    placed on the `LineChartView`. The size of the `LineChartView` then will need
    to be the size of the chart plus the margins around the outside where the axes
    and labels will be drawn. We''ll calculate that size, then pass it to the `LineChartView`
    superclass initializer, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Note that we've saved the plot area's width and height as instance variables,
    as we'll need them in some of our methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve initialized the superclass, we can begin drawing on the main
    `Canvas`; to begin, let''s draw the axes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Our chart's origin will be `self.margin` pixels from the bottom-left corner,
    and we'll draw the `X` and `Y` axes as simple black lines moving right and up
    from the origin to the edge of the chart. Remember that the `Canvas` `Y` coordinates
    count down from the top, not up from the bottom, so the `Y` coordinate for the
    origin is the height of the view area minus the margin.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll label the axes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Here, we're creating the text items set to the labels for the `X` and `Y` axes,
    using the field names passed into the object for the text labels. Note the use
    of `anchor` to set which side of the text's bounding box is attached to the coordinates
    provided. In the case of the `X` axis, for instance, we've specified `n` (north),
    so the top of our text will be under the `X`-axis line. For the `Y`-axis label,
    we want the text to be sideways, so we've specified `angle=90` to rotate it. Also,
    note that we've used south (`s`) as the `anchor` position for the rotated text;
    even though it's rotated, the cardinal directions here are relative to the object
    *before* rotation. Thus, "south" will always be the bottom of the text as normally
    written, even if the object is rotated.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the axes labeled, we need to create a second `Canvas` that will contain
    the plot area:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This `Canvas` object is where the actual plots will be drawn. While we could
    draw our plots on the `LineChartView` directly, embedding a second `Canvas` makes
    it easier to calculate the coordinate points for the plot, since we won't have
    to factor in the margin. It also allows us to use a different background color
    for a nicer look.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we can draw data on the chart, we need to create a method that can do
    so. Let''s create a private instance method called `_plot_line()` to draw a single
    line plot on the chart, which begins like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This method will receive a `data` argument containing the `X` and `Y` points
    for the line as a list of tuples. Since our chart is a fixed number of pixels,
    and our data values may have any arbitrary range, the first thing we need to do
    is scale the data to fit just inside the size of our chart. To do this, we first
    find the maximum values of the `X` and `Y` fields, then create a scaling ratio
    for each axis by dividing the set height of the chart by the maximum value (note
    that this assumes the minimum value is 0\. This particular chart class isn't designed
    to handle negative values).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have the scale values, we can then transform our data points to coordinates
    by using a list comprehension that multiplies each data point by the scale value,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Note that we are rounding the values, since we can't plot to fractional pixel
    values. Also, once again, since data is usually graphed with the origin in the
    bottom left, but coordinates on the `Canvas` measure from the top left, we'll
    need to flip the `Y` coordinates; this is done in our list comprehension as well
    by subtracting the new `Y` value from the plot height.
  prefs: []
  type: TYPE_NORMAL
- en: 'These coordinates can now be passed to `create_line()` along with a reasonable
    width and the color argument passed in by the caller, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Note that we've also used the `smooth` argument to round out the curve a bit
    and make it appear more organic.
  prefs: []
  type: TYPE_NORMAL
- en: To use this method, we need to head back to the initializer and do some calculations.
    Since the `_plot_line()` method only handles one plot at a time, we'll need to
    filter out our data by the `plot_by_field` field and render the lines one at a
    time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this code at the end of `LineChartView.__init__()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: First, we get the individual plot names by retrieving the unique `plot_by_field`
    values from the data. These are sorted and cast to a `set` object so that we only
    have the unique values. Then, we create a color mapping using `zip()` to build
    a list of name-to-color tuples. Since `zip()` returns a generator and we're going
    to want to use this map more than once, it's cast to a `list` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s plot our lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: For each distinct plot name and color, we first format the data into a list
    of (`X`, `Y`) pairs using a list comprehension. Then we call `_plot_line()` with
    the data and the color. Our lines are now plotted!
  prefs: []
  type: TYPE_NORMAL
- en: 'One last thing we need is a legend, to tell the user what each color on the
    chart represents. Without that, this chart would be meaningless to the user. To
    create it, we''ll write a `_draw_legend()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Our method takes the color map list that we created in the initializer and iterates
    over it, using the `enumerate()` function to also generate an incrementing number
    for each iteration. For each mapping, we simply draw a text item containing the
    label text with the associated fill color. This is drawn starting at ten pixels
    from the top-left corner of the chart, with each item twenty pixels below the
    last.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s call this method from the initializer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The `LineChartView` is ready to go; now we just need to create the supporting
    code to invoke it.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Back in the `Application` class, create a new method for showing our chart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The first order of business is to fetch the data from our `get_growth_by_lab()`
    method. Then, we build a `TopLevel` widget to hold our `LineChartView` object.
    On this widget, we add the `LineChartView` object, configuring it to be `800`
    by `400` pixels and specifying the fields for `X` (`Day`), `Y` (`Avg Height (cm)`),
    and the `plot_by_field` value (`lab_id`). This chart gets packed into the `Toplevel`.
  prefs: []
  type: TYPE_NORMAL
- en: The `Toplevel` widget creates a new, blank window outside the root window. You
    should use it as a base for new windows that aren't simple dialogs or message
    boxes.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this method complete, add it to the `event_callbacks` dictionary in the
    `Application` initializer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to add a menu item to launch the chart. Add the following
    method to the `GenericMainMenu` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Then use this method in each menu class''s `_build_menu()` method to add this
    option to the **Tools** menu. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'When you call your function, you should see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The growth chart on Ubuntu Linux](img/B17578_15_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.4: The growth chart on Ubuntu Linux'
  prefs: []
  type: TYPE_NORMAL
- en: Your graph won't look like much without some sample data. Unless you just like
    doing data entry, there is a script for loading sample data in the `sql` directory.
    Run this script against your database before testing your chart.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced graphs using Matplotlib
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our line graph is pretty, but it still needs considerable work to be a truly
    professional-looking visualization: it lacks a scale, grid lines, zoom capabilities,
    and other features that would make it a completely useful chart.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We could spend a lot of time making it more complete, but there''s a faster
    way to get much more satisfactory graphs and charts in our Tkinter application:
    Matplotlib.'
  prefs: []
  type: TYPE_NORMAL
- en: Matplotlib is a third-party Python library for generating professional-quality,
    interactive graphs of all types. It's a vast library with many add-ons, and we
    won't cover much of its actual usage, but we will look at how to integrate Matplotlib
    charts into a Tkinter application. To demonstrate this, we'll create a bubble
    chart showing the yield of each plot as it relates to humidity and temperature.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should be able to install the `matplotlib` library using `pip` with this
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: For complete instructions on installation, please see [https://matplotlib.org/users/installing.html](https://matplotlib.org/users/installing.html).
  prefs: []
  type: TYPE_NORMAL
- en: Data model method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we can make a chart, we''ll need another `SQLModel` method to extract
    the data for the chart. Once again, you''ve been provided with a SQL query that
    returns the required data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The purpose of this chart is to find the sweet spot of temperature and humidity
    for each seed sample. Therefore, we need one row per plot that includes the maximum
    fruit measurement, average humidity and temperature at the plot column, and the
    seed sample. Since we don't want any bad data, we'll filter out rows that have
    an Equipment Fault.
  prefs: []
  type: TYPE_NORMAL
- en: 'The query returns data that looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '| seed_sample | yield | avg_humidity | avg_temperature |'
  prefs: []
  type: TYPE_TB
- en: '| AXM480 | 11 | 27.7582142857142857 | 23.7485714285714286 |'
  prefs: []
  type: TYPE_TB
- en: '| AXM480 | 20 | 27.2146428571428571 | 23.8032142857142857 |'
  prefs: []
  type: TYPE_TB
- en: '| AXM480 | 15 | 26.2896428571428571 | 23.6750000000000000 |'
  prefs: []
  type: TYPE_TB
- en: '| AXM478 | 31 | 27.2928571428571429 | 23.8317857142857143 |'
  prefs: []
  type: TYPE_TB
- en: '| AXM477 | 39 | 27.1003571428571429 | 23.7360714285714286 |'
  prefs: []
  type: TYPE_TB
- en: '| AXM478 | 39 | 26.8550000000000000 | 23.7632142857142857 |'
  prefs: []
  type: TYPE_TB
- en: 'To provide this data to the application, let''s put the query into another
    model method called `get_yield_by_plot()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: That's all the model needs, so let's move on to the views.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the bubble chart view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To integrate Matplotlib into a Tkinter application, there are several module
    imports we need to make into `views.py`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first is `matplotlib` itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: It may seem odd to execute methods in the import section of a script, and your
    code editor or IDE may even complain about it. According to Matplotlib's documentation,
    though, `use()` should be called before other modules are imported from `matplotlib`
    to tell it which rendering backend it should use. In this case, we want the `TkAgg`
    backend, which is made to integrate into Tkinter.
  prefs: []
  type: TYPE_NORMAL
- en: Matplotlib has backends for a variety of GUI toolkits such as PyQt, wxWidgets,
    and Gtk3, as well as backends for non-GUI situations (for example, rendering plots
    directly to a file) like SVG rendering or web usage. See the documentation at
    [https://matplotlib.org/stable/api/index_backend_api.html](https://matplotlib.org/stable/api/index_backend_api.html)
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve set the backend, we can import a few other items from `matplotlib`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The `Figure` class represents the basic drawing area on which `matplotlib` charts
    can be drawn. The `FigureCanvasTkAgg` class is an interface between the `Figure`
    and the Tkinter `Canvas`, and `NavigationToolbar2Tk` allows us to place a pre-made
    navigation toolbar for the `Figure` object on our GUI.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how these fit together, let''s start our `YieldChartView` class in `views.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: After calling the superclass initializer to create the `Frame` object, we create
    a `Figure` object to hold our chart. Instead of a size in pixels, the `Figure`
    object takes a size in inches and a dots-per-inch (`dpi`) setting. In this case,
    our arguments of 6 by 4 inches and 100 dots per inch result in a 600-by-400-pixel
    `Figure` object. Next, we create a `FigureCanvasTkAgg` object that will be used
    to connect our `Figure` object with a Tkinter `Canvas`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `FigureCanvasTkAgg` object is not itself a `Canvas` object or subclass,
    but it contains a `Canvas` object we can place in our application. A reference
    to this `Canvas` object can be retrieved using the `FigureCanvasTkAgg` object''s
    `get_tk_widget()` method. We''ll go ahead and get a reference to the `Canvas`
    and pack it into the `YieldChartView` widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll add the toolbar and attach it to our `FigureCanvasTkAgg` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Note that we don't need to use a geometry manager to add the toolbar; instead
    we just pass the `FigureCanvasTkAgg` object and the parent widget (`self`, which
    is our `YiedChartView` object in this case) to the toolbar's initializer, and
    this will attach it to our `Figure`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to set up the axes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: In `matplotlib`, an `Axes` object represents a single set of `X` and `Y` axes
    on which data can be plotted, and is created using the `Figure.add_subplot()`
    method. The three integers passed to `add_subplot()` establish that this is the
    first set of axes out of one row of one column of subplots. Our figure could conceivably
    contain multiple subplots arranged in a table-like format, but we only need one,
    thus we're passing all 1s here. After it's created, we set the labels on the `Axes`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: To create a bubble chart, we're going to use the **scatter plot** feature of
    Matplotlib, using the size of each dot to indicate the fruit yield. We'll also
    color code the dots to indicate which seed sample the data point represents.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s implement a method to draw our scatter plots:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The data passed in should contain three columns per record, and we're breaking
    those out into three separate lists containing the `x`, `y`, and `size` values.
    Next, we're going to amplify the differences between the `size` values to make
    them more apparent by squaring each value then dividing it by two. This isn't
    strictly necessary, but it helps make the chart more readable when differences
    are relatively small.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we draw the data onto the `axes` object by calling `scatter()`, also
    passing along the color and label values for the dots, and making them semi-transparent
    with the `alpha` argument.
  prefs: []
  type: TYPE_NORMAL
- en: '`zip(*data)` is a Python idiom for breaking a list of n-length tuples into
    n lists of values, essentially the reverse of `zip(x, y, s)`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To draw a legend for our `Axes` object, we need two things: a list of our scatter
    objects and a list of their labels. To get these, we''ll have to create a couple
    of blank lists in `__init__()` and append the appropriate values to them whenever
    `draw_scatter()` is called.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `__init__()`, add some empty lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, at the end of `draw_scatter()`, append the lists and update the `legend()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Note that we can call `legend()` repeatedly and it will simply destroy and redraw
    the legend each time.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the Application class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Back in `Application`, let's create the method to show our yield data chart.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating a method to display a `Toplevel` widget with our chart view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s set up the data for our scatters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve retrieved the yield data from the data model and created a dictionary
    that will hold the colors we want to use for each seed sample. Now we just need
    to iterate through the seed samples and draw the scatters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Once again, we're formatting and filtering down our data using a list comprehension,
    providing average humidity for `x`, average temperature for `y`, and yield for
    `s`.
  prefs: []
  type: TYPE_NORMAL
- en: Add the method to the callbacks dictionary and create a menu item for it just
    under the growth chart option.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your bubble chart should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17578_15_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.5: Our scatter plot showing how seed samples performed under different
    conditions'
  prefs: []
  type: TYPE_NORMAL
- en: Take a moment to play with this chart using the navigation toolbar. Notice how
    you can zoom and pan, adjust the size of the chart, and save the image. These
    powerful tools are provided by Matplotlib automatically, and make for very professional-looking
    charts.
  prefs: []
  type: TYPE_NORMAL
- en: This wraps up our charting needs for the time being, but as you've seen it's
    quite simple to integrate Matplotlib's powerful charts and graphs into our application.
    And, of course, with enough effort, the sky is the limit with generating visualizations
    using the `Canvas` widget.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about Tkinter's graphical capabilities. You learned
    about the `Canvas` widget, and how to draw shapes, lines, images, text, and widgets
    on it. You implemented animations on the `Canvas` by queuing item movements in
    the Tkinter event queue. You implemented a simple line chart class using a plain
    `Canvas` to provide basic data visualization for SQL query results. Finally, you
    learned how to integrate the powerful Matplotlib library with its wide variety
    of charts and graphs into your application.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll learn how to package up our application for distribution.
    We'll learn how to arrange the directory for distribution as Python code, and
    how to use third-party tools to create executables across Windows, macOS, and
    Linux.
  prefs: []
  type: TYPE_NORMAL
