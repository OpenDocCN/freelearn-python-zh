<html><head></head><body>
		<div><h1 id="_idParaDest-99"><a id="_idTextAnchor173"/>Chapter 8: Simplifying the Frontend</h1>
			<p>Throughout the chapters (e.g., doing the chat project or the blog), we wrote sloppy JavaScript code. We were forced to repeat tasks every time the backend sent new HTML, cleaning up orphaned events and reassigning new ones to the newly created DOM. Our ambitions with the frontend have been quite modest. We’ve limited ourselves to surviving by focusing all our energies on the Django code. If we had had a tool to handle events via HTML rendered by the server, the JavaScript code would have been less verbose and much easier to work with. It’s time to refactor the frontend, but we need help to do that.</p>
			<p>Stimulus is ideal for the job. We are talking about a framework whose objective is to constantly monitor changes in the page by connecting attributes and events with functions that we indicate. We can create controllers that we will assign through datasets to the inputs or any other element that we need to incorporate an event. And, in turn, we will associate each event to some logic in JavaScript. A fantastic definition that is in Stimulus’ own documentation: you should think of Stimulus as a CSS class that connects an HTML element with a set of styles.</p>
			<p>In this chapter, we will focus on creating a minimal example with Stimulus that will serve as a basis for understanding how it works and that can be implemented in any event on the website. In order, we will cover the following points:</p>
			<ul>
				<li>Installing and configuring Stimulus</li>
				<li>Defining a controller</li>
				<li>Managing events with actions</li>
				<li>Capturing references with targets</li>
				<li>Building an application that converts text into uppercase letters</li>
			</ul>
			<p>The final goal is to build a small application where we write in a text box and in real time, we visualize the same string but in capital letters. For this, we will use Stimulus to capture the event and the input value and communicate with the consumer. You will be surprised at how elegant the frontend will become when everything is in place.</p>
			<h1 id="_idParaDest-100"><a id="_idTextAnchor174"/>Technical requirements </h1>
			<p>The example is based on the template we used in <a href="B18321_04_ePub.xhtml#_idTextAnchor090"><em class="italic">Chapter 4</em></a><em class="italic">, Working with the Database</em>:</p>
			<p><a href="https://github.com/PacktPublishing/Building-SPAs-with-Django-and-HTML-Over-the-Wire/tree/main/chapter-4/initial-template">https://github.com/PacktPublishing/Building-SPAs-with-Django-and-HTML-Over-the-Wire/tree/main/chapter-4/initial-template</a></p>
			<p>The finished code can be found in the following repository: </p>
			<p><a href="https://github.com/PacktPublishing/Building-SPAs-with-Django-and-HTML-Over-the-Wire/tree/main/chapter-8">https://github.com/PacktPublishing/Building-SPAs-with-Django-and-HTML-Over-the-Wire/tree/main/chapter-8</a></p>
			<p>It is also recommended that you visit Stimulus’ own documentation to learn more about important concepts such as controllers, actions, and targets:</p>
			<p><a href="https://stimulus.hotwired.dev/handbook/">https://stimulus.hotwired.dev/handbook/</a></p>
			<p>And, optionally, it’s recommended that you have a modern version of Node.js along with the latest version of <code>npm</code>. We will use it to install the Stimulus package, but we can also use the CDN.</p>
			<p class="callout-heading">CDN or Content delivery network</p>
			<p class="callout">A CDN is a group of servers located around the world that work together to deliver content to users quickly and efficiently. It is used with static content such as images, CSS and JavaScript.</p>
			<p>With the resources clear, we can now start implementing a better version of the frontend. We will start by installing Stimulus and talking about its different configurations.</p>
			<h1 id="_idParaDest-101"><a id="_idTextAnchor175"/>Installing and configuring Stimulus</h1>
			<p>Before you can use <a id="_idIndexMarker414"/>Stimulus, you will need to download and install the<a id="_idIndexMarker415"/> framework. If you don’t want to complicate things, you can import it from its CDN. Just add the following script  in the HTML template:</p>
			<pre class="source-code">&lt;script type="module" src=</pre>
			<pre class="source-code">https://unpkg.com/@hotwired/stimulus@3.0.1/dist/stimulus.js</pre>
			<pre class="source-code">&gt; </pre>
			<p>If you opt for this solution, you can ignore the rest of this section.</p>
			<p>However, if you want to download Stimulus, which is very good practice, please note that it is available in the <code>npm</code> packages, so let’s install it with a command:</p>
			<pre>npm i @hotwired/stimulus</pre>
			<p>From<a id="_idIndexMarker416"/> here, you have three different configuration possibilities: using <a id="_idIndexMarker417"/>Webpack, using another build system, or using the native JavaScript module system. We are going to focus on the last option, using modules, to simplify your implementation and not add more complexity:</p>
			<ol>
				<li>Copy the Stimulus file to a folder inside <code>static</code>, for example, in the <code>static/js/vendors/</code> path:<pre><code>mkdir -p static/js/vendors/</code>
<code>cp node_modules/@hotwired/stimulus/dist/stimulus. Js static/js/vendors/  </code></pre></li>
				<li>We create a JavaScript file called <code>main.js</code> that will contain all future frontend logic and imports (including Stimulus):<pre>touch static/js/main.js</pre></li>
				<li>Inside the file we just created, <code>main.js</code>, we will import Stimulus and run it:<pre>import { Application } from "./vendors/stimulus.js";
window.Stimulus = Application.start();</pre></li>
				<li>Finally, we<a id="_idIndexMarker418"/> import the JavaScript module into a script that will be present<a id="_idIndexMarker419"/> in the main HTML template of the application so that the browser can load it:<pre>&lt;script defer type="module" 
  src="img/main.js' %}"&gt;&lt;/script&gt;</pre></li>
			</ol>
			<p>Stimulus is ready! It’s up and running and waiting for our events.</p>
			<p>The best way to understand all the elementary concepts is to create a simple application. As we said in the introduction, we are going to build an app that has a basic functionality: convert some text from lowercase to uppercase. We will have an input and a button; when pressed, the button will show the uppercase text at the bottom. </p>
			<p>To achieve the objective, we will learn about the three basic pillars of Stimulus: <strong class="bold">controllers</strong>, <strong class="bold">actions</strong> (not to be confused with those created in the backend), and <strong class="bold">targets</strong>. We will start by looking at controllers and their importance in organizing logic.</p>
			<h1 id="_idParaDest-102"><a id="_idTextAnchor176"/>Defining a controller </h1>
			<p>The purpose of the <a id="_idIndexMarker420"/>controller is to connect the DOM with JavaScript. It will bind the inputs to a variable and the events that we indicate to a function created inside the controller.</p>
			<p>The structure is as follows:</p>
			<pre class="source-code">import { Controller } from "../vendors/stimulus.js".</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">export default class extends Controller {</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">   // Variables linked to inputs.</pre>
			<pre class="source-code">   static targets = [ "input1" ]</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">   // Constructor or function to be executed when the</pre>
			<pre class="source-code">   // controller is loaded.</pre>
			<pre class="source-code">   connect() {</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   // Simple function</pre>
			<pre class="source-code">   myFunction(event) {</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">}</pre>
			<p>We have<a id="_idIndexMarker421"/> imported the <code>Controller</code> class that belongs to the framework itself with a combination of <code>import</code> and <code>from</code>. Then, we created a class that extends <code>Controller</code> and is also accessible from an import (<code>export default</code>). Inside, we have an example of a target called <code>input1</code> and two functions: <code>connect()</code> will be executed when Stimulus is ready and <code>myFunction()</code>is an example function that can be executed.</p>
			<p>For the application, we will create a file in <code>static/js/controllers/transformer_controller.js</code> with the following content:</p>
			<pre class="source-code">import { Controller } from "../vendors/stimulus.js"</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">export default class extends Controller {</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">  static targets = [ "myText" ]</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">    connect() {</pre>
			<pre class="source-code">      // Connect to the WebSocket server</pre>
			<pre class="source-code">        this.myWebSocket = new WebSocket(</pre>
			<pre class="source-code">          'ws://hello.localhost/ws/example/');</pre>
			<pre class="source-code">        // Listen for messages from the server</pre>
			<pre class="source-code">        this.myWebSocket.addEventListener("message",</pre>
			<pre class="source-code">                                          (event) =&gt; {</pre>
			<pre class="source-code">            // Parse the data received</pre>
			<pre class="source-code">            const data = JSON.parse(event.data);</pre>
			<pre class="source-code">            // Renders the HTML received from the Consumer</pre>
			<pre class="source-code">            const newFragment = document.createRange().</pre>
			<pre class="source-code">              createContextualFragment(data.html);</pre>
			<pre class="source-code">            document.querySelector(data.selector).</pre>
			<pre class="source-code">              replaceChildren(newFragment);</pre>
			<pre class="source-code">        });</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">    lowercaseToUppercase(event) {</pre>
			<pre class="source-code">      event.preventDefault()</pre>
			<pre class="source-code">      // Prepare the information we will send</pre>
			<pre class="source-code">      const data = {</pre>
			<pre class="source-code">          "action": "text in capital letters",</pre>
			<pre class="source-code">          "data": {</pre>
			<pre class="source-code">              "text": this.myTextTarget.value</pre>
			<pre class="source-code">          }</pre>
			<pre class="source-code">      };</pre>
			<pre class="source-code">      // Send the data to the server</pre>
			<pre class="source-code">      this.myWebSocket.send(JSON.stringify(data));</pre>
			<pre class="source-code">  }</pre>
			<pre class="source-code">}</pre>
			<p>As you can see, it is a <a id="_idIndexMarker422"/>reorganization of the code we used in the frontend during the previous chapters. Let’s take a closer look at each part:</p>
			<ul>
				<li>In <code>targets</code>, we define a variable called <code>myText</code> that will be linked later, in the <em class="italic">Capturing references with targets</em> section, where we get the value of the input. Inside the controller, we can use the input with <code>this.mytextTarget</code>. A target contains all the elements of an input, such as <code>value</code>.</li>
				<li><code>connect()</code> is a function that is executed when the driver is fully mounted. It is a good place to connect to the WebSockets server and set a listener event for messages.</li>
				<li><code>lowercaseToUppercase(event)</code> is a function that sends the backend the text to convert to uppercase. In the next section, <em class="italic">Managing events with actions</em>, we will link the button click event to the function. For now, we just declare its logic.</li>
			</ul>
			<p>After declaring the<a id="_idIndexMarker423"/> controller, we need to register it in Stimulus and give it a name. We edit <code>static/js/main.js</code> with the following code.</p>
			<pre class="source-code">import { Application } from "./vendors/stimulus.js";</pre>
			<pre class="source-code">import TransformerController from </pre>
			<pre class="source-code">  "./controllers/transformer_controller.js"; // New line</pre>
			<pre class="source-code">window.Stimulus = Application.start();</pre>
			<pre class="source-code">// New line</pre>
			<pre class="source-code">Stimulus.register("transformer", TransformerController);</pre>
			<p>Basically, we have imported the <code>TransformerController</code> class and registered it in Stimulus with the alias <code>transformer</code>.</p>
			<p>At the moment, Stimulus already has a controller registered, but it doesn’t know which area of the DOM it should be watching and where to apply it. Let’s take care of that.</p>
			<p>In a new template, for example with the name <code>index.html</code>, we are going to create a simple form and an element to render everything coming from the backend:</p>
			<pre class="source-code">&lt;main&gt;</pre>
			<pre class="source-code">&lt;form&gt;</pre>
			<pre class="source-code">&lt;input type="text" placeholder="Enter text"&gt;</pre>
			<pre class="source-code">&lt;input type="button" value="Transform"&gt;</pre>
			<pre class="source-code">&lt;/form&gt;</pre>
			<pre class="source-code">&lt;div id="results"&gt;&lt;/div&gt;</pre>
			<pre class="source-code">&lt;/main&gt;</pre>
			<p>The form has a field to write the text and a button that will execute the action. On the other hand, we have included a HTML <code>div</code> tag with the ID <code>results</code>, which will be the place to show the text already converted into uppercase processed by the backend</p>
			<p>We are going to tell Stimulus to make the controller work with the DOM of our choice. The way to do this is by means of a <code>data-controller</code> dataset:</p>
			<pre class="source-code">&lt;element data-controller="alias"&gt;&lt;/element&gt;</pre>
			<p>In our case, we update the opening of <code>&lt;main&gt;</code>:</p>
			<pre class="source-code">&lt;main data-controller="transformer"&gt;</pre>
			<p>Easy, isn’t it? Stimulus <a id="_idIndexMarker424"/>already has a registered controller and now knows where to apply it.</p>
			<p>The next step is to indicate which event is related to which function, and which input is related to which target.</p>
			<h1 id="_idParaDest-103"><a id="_idTextAnchor177"/>Managing events with actions </h1>
			<p>Actions are <a id="_idIndexMarker425"/>a structure used by Stimulus to link events to controller functions. They are declared in the DOM by means of a <code>data-action</code> dataset with the following structure:</p>
			<pre class="source-code">&lt;div data-controller="aliasController"&gt;</pre>
			<pre class="source-code">&lt;button</pre>
			<pre class="source-code">  data-action=</pre>
			<pre class="source-code">    "event-&gt;aliasController#functionOfTheController"</pre>
			<pre class="source-code">&gt;Click me!&lt;/button&gt;</pre>
			<pre class="source-code">&lt;/div&gt;</pre>
			<p>It will<a id="_idIndexMarker426"/> only work if it is inside a controller with the same alias; you cannot place<a id="_idIndexMarker427"/> an action in DOMs outside the tree.</p>
			<p>Following the example, we modify our button:</p>
			<pre class="source-code">&lt;input</pre>
			<pre class="source-code">  type="button"</pre>
			<pre class="source-code">  value="Transform"</pre>
			<pre class="source-code">  data-action="click-&gt;transformer#lowercaseToUppercase"</pre>
			<pre class="source-code">&gt;</pre>
			<p>Let’s analyze what we have done with <code>data-action</code>, since it contains its own format that we must follow:</p>
			<ol>
				<li value="1">The event is <code>click</code>. It could be any other event, such as a <code>submit</code> event if we were in a HTML <code>&lt;form&gt;</code> tag, a <code>scroll</code> event, and so on.</li>
				<li>After the arrow, <code>-&gt;</code>, which acts as a separator, we indicate the alias of the controller where it is enclosed.</li>
				<li>Finally, after <code>#</code>, which is another separator, we indicate the function to be executed (<code>lowercaseToUppercase</code>).</li>
			</ol>
			<p>We have<a id="_idIndexMarker428"/> simplified the definition of the events, but now they will also be<a id="_idIndexMarker429"/> self-managed as we include or remove elements in the DOM. Not only that, but the backend now has the superpower to add new events. Yes, you read that right, the backend can include JavaScript events! They have become datasets in the HTML that we can remove or add as needed.</p>
			<p>There is only one step left to finish with Stimulus: detailing the inputs that can be accessed with the targets. Otherwise, we will not be able to collect the information from the forms.</p>
			<h1 id="_idParaDest-104"><a id="_idTextAnchor178"/>Capturing references with targets </h1>
			<p>Stimulus <a id="_idIndexMarker430"/>connects to form inputs via targets, or a special <a id="_idIndexMarker431"/>dataset. Internally, Stimulus creates a variable that can be used anywhere in the controller. For example, we define in the DOM an alias called <code>name</code>:</p>
			<pre class="source-code">&lt;div data-controller="aliasController"&gt;</pre>
			<pre class="source-code">&lt;input type="text" data-aliasController-target="name"&gt;</pre>
			<pre class="source-code">&lt;/div&gt;</pre>
			<p>While in the controller, we define the following:</p>
			<pre class="source-code">static targets = [ "name" ]</pre>
			<p>From here, I can call the target within any function/method in the following way:</p>
			<pre class="source-code">this.nameTarget</pre>
			<p>As you can see, the alias is joined with the target text.</p>
			<p>In the application we are developing, we have defined the target with the name <code>myText</code>:</p>
			<pre class="source-code">static targets = [ "myText" ]</pre>
			<p>We update the DOM of the input as follows:</p>
			<pre class="source-code">&lt;input type="text" data-transformer-target="myText" </pre>
			<pre class="source-code">  placeholder="Enter text"&gt;</pre>
			<p>The whole frontend is ready. We have installed Stimulus, created a controller, and defined an action to trigger actions and a target to collect the input text. We only need to define the functionality in the consumer. We go to Django.</p>
			<h1 id="_idParaDest-105"><a id="_idTextAnchor179"/>An application that converts text into uppercase letters</h1>
			<p>We have<a id="_idIndexMarker432"/> already simplified the frontend with Stimulus, installing, configuring, and implementing the tools provided by this fantastic framework. However, we still have one last step left in the application that converts the text from lowercase to uppercase: implementing the backend in the consumer. </p>
			<p>Edit <code>app/app_template/consumers.py</code> with the<a id="_idIndexMarker433"/> following code:</p>
			<pre class="source-code">from channels.generic.websocket import JsonWebsocketConsumer</pre>
			<pre class="source-code">from django.template.loader import render_to_string </pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">class ExampleConsumer(JsonWebsocketConsumer): </pre>
			<pre class="source-code">    def connect(self):</pre>
			<pre class="source-code">        """Event when client connects"""</pre>
			<pre class="source-code">        # Accept the connection</pre>
			<pre class="source-code">        self.accept()</pre>
			<pre class="source-code">  </pre>
			<pre class="source-code">    def receive_json(self, data_received):</pre>
			<pre class="source-code">        # Get the data</pre>
			<pre class="source-code">        data = data_received['data']</pre>
			<pre class="source-code">        # Depending on the action we will do one task or</pre>
			<pre class="source-code">        # another.</pre>
			<pre class="source-code">        match data_received['action']:</pre>
			<pre class="source-code">            case 'text in capital letters':</pre>
			<pre class="source-code">                self.send_uppercase(data)</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">    def send_uppercase(self, data):</pre>
			<pre class="source-code">        """Event: Send html to client"""</pre>
			<pre class="source-code">        self.send_json( {</pre>
			<pre class="source-code">                'selector': '#results',</pre>
			<pre class="source-code">                'html': data["text"]. upper(),</pre>
			<pre class="source-code">            })</pre>
			<p>The code is so basic<a id="_idIndexMarker434"/> that it looks like it belongs in the first chapters. We have removed the <code>actions.py</code> file and some other elements, as we are just looking for the minimum necessary to make it work.</p>
			<p>Let’s review where the information enters the backend, where it is transformed, and where it is returned:</p>
			<ul>
				<li>The information from the frontend goes to <code>receive_json</code>, which in turn receives the <code>'text in capital letters'</code> action by executing the <code>self.send_uppercase(data)</code> function.</li>
				<li><code>self.send_uppercase(data)</code> converts the text to uppercase and sends the information to the frontend, specifically to the <code>#results</code> selector.</li>
			</ul>
			<p>It’s time to test that everything works. We pull up Docker and go to <code>http://hello.localhost</code>. Type in the input and click on the <strong class="bold">Transform</strong> button.</p>
			<div><div><img src="img/Figure_8.01_B18321.jpg" alt="Figure 8.1 – We tested that the application works by transforming lowercase letters into uppercase&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.1 – We tested that the application works by transforming lowercase letters into uppercase</p>
			<p>At the <a id="_idIndexMarker435"/>bottom, the text will be displayed in capitals – we’ve done it!</p>
			<p>We can even improve it. The local delay between pressing the button and displaying the final result is negligible, in my case, 0.002 seconds. We can incorporate the <code>input</code> event into the input to see the result as we type, giving a feeling that there is no apparent delay:</p>
			<pre class="source-code">&lt;input</pre>
			<pre class="source-code">  type="text"</pre>
			<pre class="source-code">  data-transformer-target="myText"</pre>
			<pre class="source-code">  placeholder="Enter text"</pre>
			<pre class="source-code">  data-action="input-&gt;transformer#lowercaseToUppercase"</pre>
			<pre class="source-code">&gt;</pre>
			<p>And with this <a id="_idIndexMarker436"/>small optimization, we can conclude the backend implementation of the application.</p>
			<p>You might be tempted to take Stimulus to the examples in the previous chapters – I can only tell you: go ahead. It will be neater, you will learn a lot more about Stimulus, and things will be easier to maintain.</p>
			<h1 id="_idParaDest-106"><a id="_idTextAnchor180"/>Summary</h1>
			<p>Our journey of learning HTML over the wire with Django comes to an end. We are now able to create SPAs in real time by gathering all the logic in the backend, avoiding duplicating tasks such as validations or HTML structures. We have relieved the frontend of a big responsibility; it now only needs to handle events or animations, thanks to Stimulus controllers and internal automation from datasets.</p>
			<p>I would love to tell you that you already know everything you need to know, but the journey continues. The book is just a first push. There is still a lot of work ahead of you: practice, adopt Stimulus in your workflow (or any other similar framework), solve small difficulties typical of any SPA (such as managing when the user clicks on the back button in the history), explore other related protocols such as Server-Side Events, train your colleagues, convince your boss, define your line between backend and frontend (the infinite struggle of any web developer), and even adopt some other framework. The limit is set by you.</p>
			<p>It has been a pleasure to join you in this real-time Python adventure. I have enjoyed writing every line and preparing every example. Thank you.</p>
			<p>I can only say to you: I expect big things from you.</p>
			<pre class="source-code">WebSocket.close()</pre>
		</div>
		<div><div></div>
		</div>
	</body></html>