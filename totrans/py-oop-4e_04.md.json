["```py\n>>> print \"hello world\"\n  File \"<input>\", line 1\n    print \"hello world\"\n          ^\nSyntaxError: Missing parentheses in call to 'print'. Did you mean print(\"hello world\")? \n```", "```py\n>>> x = 5 / 0\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nZeroDivisionError: division by zero\n>>> lst = [1,2,3]\n>>> print(lst[3])\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nIndexError: list index out of range\n>>> lst + 2\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: can only concatenate list (not \"int\") to list\n>>> lst.add\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nAttributeError: 'list' object has no attribute 'add'\n>>> d = {'a': 'hello'}\n>>> d['b']\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nKeyError: 'b'\n>>> print(this_is_not_a_var)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nNameError: name 'this_is_not_a_var' is not defined \n```", "```py\nfrom typing import List\nclass EvenOnly(List[int]):\n    def append(self, value: int) -> None:\n        if not isinstance(value, int):\n            raise TypeError(\"Only integers can be added\")\n        if value % 2 != 0:\n            raise ValueError(\"Only even numbers can be added\")\n        super().append(value) \n```", "```py\n>>> e = EvenOnly()\n>>> e.append(\"a string\")\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n  File \"even_integers.py\", line 7, in add\n    raise TypeError(\"Only integers can be added\")\nTypeError: Only integers can be added\n>>> e.append(3)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n  File \"even_integers.py\", line 9, in add\n    raise ValueError(\"Only even numbers can be added\")\nValueError: Only even numbers can be added\n>>> e.append(2) \n```", "```py\nfrom typing import NoReturn\ndef never_returns() -> NoReturn:\n    print(\"I am about to raise an exception\")\n    raise Exception(\"This is always raised\")\n    print(\"This line will never execute\")\n    return \"I won't be returned\" \n```", "```py\n>>> never_returns()\nI am about to raise an exception\nTraceback (most recent call last):\n  File \"<input>\", line 1, in <module>\n  File \"<input>\", line 6, in never_returns\nException: This is always raised \n```", "```py\ndef call_exceptor() -> None:\n    print(\"call_exceptor starts here...\")\n    never_returns()\n    print(\"an exception was raised...\")\n    print(\"...so these lines don't run\") \n```", "```py\n>>> call_exceptor()\ncall_exceptor starts here...\nI am about to raise an exception\nTraceback (most recent call last):\n  File \"<input>\", line 1, in <module>\n  File \"<input>\", line 3, in call_exceptor\n  File \"<input>\", line 6, in never_returns\nException: This is always raised \n```", "```py\ndef handler() -> None:\n    try:\n        never_returns()\n        print(\"Never executed\")\n    except Exception as ex:\n        print(f\"I caught an exception: {ex!r}\")\n    print(\"Executed after the exception\") \n```", "```py\nI am about to raise an exception\nI caught an exception: Exception('This is always raised')\nExecuted after the exception \n```", "```py\nfrom typing import Union\ndef funny_division(divisor: float) -> Union[str, float]:\n    try:\n        return 100 / divisor\n    except ZeroDivisionError:\n        return \"Zero is not a good idea!\" \n```", "```py\n>>> print(funny_division(0))\nZero is not a good idea!\n>>> print(funny_division(50.0))\n2.0\n>>> print(funny_division(\"hello\"))\nTraceback (most recent call last):\n...\nTypeError: unsupported operand type(s) for /: 'int' and 'str' \n```", "```py\ndef funnier_division(divisor: int) -> Union[str, float]:\n    try:\n        if divisor == 13:\n            raise ValueError(\"13 is an unlucky number\")\n        return 100 / divisor\n    except (ZeroDivisionError, TypeError):\n        return \"Enter a number other than zero\" \n```", "```py\n>>> for val in (0, \"hello\", 50.0, 13):\n...     print(f\"Testing {val!r}:\", end=\" \")\n...     print(funnier_division(val))\n...     \nTesting 0: Enter a number other than zero\nTesting 'hello': Enter a number other than zero\nTesting 50.0: 2.0\nTesting 13: Traceback (most recent call last):\n  File \"<input>\", line 3, in <module>\n  File \"<input>\", line 4, in funnier_division\nValueError: 13 is an unlucky number \n```", "```py\ndef funniest_division(divisor: int) -> Union[str, float]:\n    try:\n        if divider == 13:\n            raise ValueError(\"13 is an unlucky number\")\n        return 100 / divider\n    except ZeroDivisionError:\n        return \"Enter a number other than zero\"\n    except TypeError:\n        return \"Enter a numerical value\"\n    except ValueError:\n        print(\"No, No, not 13!\")\n        raise \n```", "```py\n>>> try: \n...     raise ValueError(\"This is an argument\") \n... except ValueError as e: \n...     print(f\"The exception arguments were {e.args}\") \n...\nThe exception arguments were ('This is an argument',) \nValueError upon initialization.\n```", "```py\nsome_exceptions = [ValueError, TypeError, IndexError, None]\nfor choice in some_exceptions:\n    try:\n        print(f\"\\nRaising {choice}\")\n        if choice:\n            raise choice(\"An error\")\n        else:\n            print(\"no exception raised\")\n    except ValueError:\n        print(\"Caught a ValueError\")\n    except TypeError:\n        print(\"Caught a TypeError\")\n    except Exception as e:\n        print(f\"Caught some other error: {e.__class__.__name__}\")\n    else:\n        print(\"This code called if there is no exception\")\n    finally:\n        print(\"This cleanup code is always called\") \n```", "```py\n(CaseStudy39) % python ch_04/src/all_exceptions.py\nRaising <class 'ValueError'>\nCaught a ValueError\nThis cleanup code is always called\nRaising <class 'TypeError'>\nCaught a TypeError\nThis cleanup code is always called\nRaising <class 'IndexError'>\nCaught some other error: IndexError\nThis cleanup code is always called\nRaising None\nno exception raised\nThis code called if there is no exception\nThis cleanup code is always called \n```", "```py\n>>> class InvalidWithdrawal(ValueError): \n...     pass \n\n>>> raise InvalidWithdrawal(\"You don't have $50 in your account\")\nTraceback (most recent call last):\n  File \"<input>\", line 1, in <module>\nInvalidWithdrawal: You don't have $50 in your account \n```", "```py\n>>> from decimal import Decimal\n>>> class InvalidWithdrawal(ValueError): \n...     def __init__(self, balance: Decimal, amount: Decimal) -> None: \n...         super().__init__(f\"account doesn't have ${amount}\") \n...         self.amount = amount \n...         self.balance = balance \n...     def overage(self) -> Decimal: \n...         return self.amount - self.balance \n```", "```py\n>>> raise InvalidWithdrawal(Decimal('25.00'), Decimal('50.00'))\nTraceback (most recent call last):\n...\nInvalidWithdrawal: account doesn't have $50.00 \n```", "```py\n>>> try: \n...     balance = Decimal('25.00')\n...     raise InvalidWithdrawal(balance, Decimal('50.00')) \n... except InvalidWithdrawal as ex: \n...     print(\"I'm sorry, but your withdrawal is \" \n...             \"more than your balance by \" \n...             f\"${ex.overage()}\") \n```", "```py\ndef divide_with_exception(dividend: int, divisor: int) -> None:\n    try:\n        print(f\"{dividend / divisor=}\")\n    except ZeroDivisionError:\n        print(\"You can't divide by zero\")\ndef divide_with_if(dividend: int, divisor: int) -> None:\n    if divisor == 0:\n        print(\"You can't divide by zero\")\n    else:\n        print(f\"{dividend / divisor=}\") \n```", "```py\nclass OutOfStock(Exception):\n    pass\nclass InvalidItemType(Exception):\n    pass\nclass Inventory:\n    def __init__(self, stock: list[ItemType]) -> None:\n        pass\n    def lock(self, item_type: ItemType) -> None:\n        \"\"\"Context Entry.\n        Lock the item type so nobody else can manipulate the\n        inventory while we're working.\"\"\"\n        pass\n    def unlock(self, item_type: ItemType) -> None:\n        \"\"\"Context Exit.\n        Unlock the item type.\"\"\"\n        pass\n    def purchase(self, item_type: ItemType) -> int:\n        \"\"\"If the item is not locked, raise a\n        ValueError because something went wrong.\n        If the item_type does not exist,\n          raise InvalidItemType.\n        If the item is currently out of stock,\n          raise OutOfStock.\n        If the item is available,\n          subtract one item; return the number of items left.\n        \"\"\"\n        # Mocked results.\n        if item_type.name == \"Widget\":\n            raise OutOfStock(item_type)\n        elif item_type.name == \"Gadget\":\n            return 42\n        else:\n            raise InvalidItemType(item_type) \n```", "```py\nclass ItemType:\n    def __init__(self, name: str) -> None:\n        self.name = name\n        self.on_hand = 0 \n```", "```py\n>>> widget = ItemType(\"Widget\")\n>>> gadget = ItemType(\"Gadget\")\n>>> inv = Inventory([widget, gadget])\n>>> item_to_buy = widget\n>>> inv.lock(item_to_buy)\n>>> try:\n...     num_left = inv.purchase(item_to_buy)\n... except InvalidItemType:\n...     print(f\"Sorry, we don't sell {item_to_buy.name}\")\n... except OutOfStock:\n...     print(\"Sorry, that item is out of stock.\")\n... else:\n...     print(f\"Purchase complete. There are {num_left} {item_to_buy.name}s left\")\n... finally:\n...     inv.unlock(item_to_buy)\n...\nSorry, that item is out of stock. \n```", "```py\nmsg = (\n    f\"there is {num_left} {item_to_buy.name} left\" \n    if num_left == 1 \n    else f\"there are {num_left} {item_to_buy.name}s left\")\nprint(msg) \n```", "```py\nclass InvalidSampleError(ValueError):\n    \"\"\"Source data file has invalid data representation\"\"\" \n```", "```py\n>>> row = {\"sepal_length\": \"5.1\", \"sepal_width\": \"3.5\", \n... \"petal_length\": \"1.4\", \"petal_width\": \"0.2\", \n... \"species\": \"Iris-setosa\"} \n```", "```py\n@classmethod\ndef from_dict(cls, row: dict[str, str]) -> \"KnownSample\":\n    if row[\"species\"] not in {\n            \"Iris-setosa\", \"Iris-versicolour\", \"Iris-virginica\"}:\n        raise InvalidSampleError(f\"invalid species in {row!r}\")\n    try:\n        return cls(\n            species=row[\"species\"],\n            sepal_length=float(row[\"sepal_length\"]),\n            sepal_width=float(row[\"sepal_width\"]),\n            petal_length=float(row[\"petal_length\"]),\n            petal_width=float(row[\"petal_width\"]),\n        )\n    except ValueError as ex:\n        raise InvalidSampleError(f\"invalid {row!r}\") \n```", "```py\nclass TrainingKnownSample(KnownSample): \n    pass \n```", "```py\nclass TrainingKnownSample(KnownSample):\n    @classmethod\n    def from_dict(cls, row: dict[str, str]) -> \"TrainingKnownSample\":\n        return cast(TrainingKnownSample, super().from_dict(row)) \n```", "```py\nclass KnownSample(Sample):\n    def __init__(\n        self,\n        species: str,\n        sepal_length: float,\n        sepal_width: float,\n        petal_length: float,\n        petal_width: float,\n    ) -> None:\n        super().__init__(\n            sepal_length=sepal_length,\n            sepal_width=sepal_width,\n            petal_length=petal_length,\n            petal_width=petal_width,\n        )\n        self.species = species\n    def __repr__(self) -> str:\n        return (\n            f\"{self.__class__.__name__}(\"\n            f\"sepal_length={self.sepal_length}, \"\n            f\"sepal_width={self.sepal_width}, \"\n            f\"petal_length={self.petal_length}, \"\n            f\"petal_width={self.petal_width}, \"\n            f\"species={self.species!r}, \"\n            f\")\"\n        ) \n```", "```py\n>>> from model import TrainingKnownSample\n>>> valid = {\"sepal_length\": \"5.1\", \"sepal_width\": \"3.5\",\n...  \"petal_length\": \"1.4\", \"petal_width\": \"0.2\",\n...  \"species\": \"Iris-setosa\"}\n>>> rks = TrainingKnownSample.from_dict(valid)\n>>> rks\nTrainingKnownSample(sepal_length=5.1, sepal_width=3.5, petal_length=1.4, petal_width=0.2, species='Iris-setosa', ) \n```", "```py\n>>> from model import TestingKnownSample, InvalidSampleError\n>>> invalid_species = {\"sepal_length\": \"5.1\", \"sepal_width\": \"3.5\",\n...  \"petal_length\": \"1.4\", \"petal_width\": \"0.2\",\n...  \"species\": \"nothing known by this app\"}\n>>> eks = TestingKnownSample.from_dict(invalid_species)\nTraceback (most recent call last):\n...\nmodel.InvalidSampleError: invalid species in {'sepal_length': '5.1', 'sepal_width': '3.5', 'petal_length': '1.4', 'petal_width': '0.2', 'species': 'nothing known by this app'} \n```", "```py\nclass OutlierError(ValueError):\n    \"\"\"Value lies outside the expected range.\"\"\" \n```", "```py\n>>> from enum import Enum\n>>> class Species(Enum):\n...    Setosa = \"Iris-setosa\"\n...    Versicolour = \"Iris-versicolour\"\n...    Viginica = \"Iris-virginica\"\n>>> Species(\"Iris-setosa\")\n<Species.Setosa: 'Iris-setosa'>\n>>> Species(\"Iris-pinniped\")\nTraceback (most recent call last):\n...\nValueError: 'Iris-pinniped' is not a valid Species \n```", "```py\n>>> from typing import Set\n>>> class Domain(Set[str]):\n...     def validate(self, value: str) -> str:\n...         if value in self:\n...             return value\n...         raise ValueError(f\"invalid {value!r}\")\n>>> species = Domain({\"Iris-setosa\", \"Iris-versicolour\", \"Iris-virginica\"})\n>>> species.validate(\"Iris-versicolour\")\n'Iris-versicolour'\n>>> species.validate(\"odobenidae\")\nTraceback (most recent call last):\n...\nValueError: invalid 'odobenidae' \n```", "```py\n@classmethod\ndef from_dict(cls, row: dict[str, str]) -> \"KnownSample\":\n    try:\n        return cls(\n            species=species.validate(row[\"species\"]),\n            sepal_length=float(row[\"sepal_length\"]),\n            sepal_width=float(row[\"sepal_width\"]),\n            petal_length=float(row[\"petal_length\"]),\n            petal_width=float(row[\"petal_width\"]),\n        )\n    except ValueError as ex:\n        raise InvalidSampleError(f\"invalid {row!r}\") \n```", "```py\nclass TrainingData:\n    def __init__(self, name: str) -> None:\n        self.name = name\n        self.uploaded: datetime.datetime\n        self.tested: datetime.datetime\n        self.training: list[TrainingKnownSample] = []\n        self.testing: list[TestingKnownSample] = []\n        self.tuning: list[Hyperparameter] = []\n    def load(self, raw_data_iter: Iterable[dict[str, str]]) -> None:\n        for n, row in enumerate(raw_data_iter):\n            try:\n                if n % 5 == 0:\n                    test = TestingKnownSample.from_dict(row)\n                    self.testing.append(test)\n                else:\n                    train = TrainingKnownSample.from_dict(row)\n                    self.training.append(train)\n            except InvalidSampleError as ex:\n                print(f\"Row {n+1}: {ex}\")\n                return\n        self.uploaded = datetime.datetime.now(tz=datetime.timezone.utc) \n```", "```py\ntext Row 2: invalid species in {'sepal_length': 7.9, 'sepal_width': 3.2, 'petal_length': 4.7, 'petal_width': 1.4, 'species': 'Buttercup'} \n```", "```py\ndef load(self, raw_data_iter: Iterable[dict[str, str]]) -> None:\n    bad_count = 0\n    for n, row in enumerate(raw_data_iter):\n        try:\n            if n % 5 == 0:\n                test = TestingKnownSample.from_dict(row)\n                self.testing.append(test)\n            else:\n                train = TrainingKnownSample.from_dict(row)\n                self.training.append(train)\n        except InvalidSampleError as ex:\n            print(f\"Row {n+1}: {ex}\")\n            bad_count += 1\n    if bad_count != 0:\n        print(f\"{bad_count} invalid rows\")\n        return\n    self.uploaded = datetime.datetime.now(tz=datetime.timezone.utc) \n```"]