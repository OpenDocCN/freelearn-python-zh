- en: Chapter 5. Adding Controls – Scripting for Rigging
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。添加控件 – 骨架脚本化
- en: 'This chapter will cover how to use Python to build rigs by:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍如何使用Python通过以下方式构建骨架：
- en: Creating skeletons with script
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用脚本创建骨骼
- en: Setting up set-driven key relationships with script
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用脚本设置驱动关键帧关系
- en: Adding custom attributes and locking and hiding attributes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加自定义属性以及锁定和隐藏属性
- en: Setting up inverse kinematics (IK) with script
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用脚本设置反向运动学（IK）
- en: Introduction
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Once you've created your model, laid out the UVs, and set up the shading networks,
    you'll still need to build controls into it if you want it to move. In this chapter,
    we'll be looking at how to do that with scripts.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了你的模型，布局了UV，并设置了着色网络，如果你想让它移动，你仍然需要将其中的控件构建进去。在本章中，我们将探讨如何使用脚本来实现这一点。
- en: We'll be looking at how to use Python to automate tasks related to rigging.
    Rigging is already one of the more technical aspects of 3D animation, and as such
    lends itself quite well to a script-based approach.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨如何使用Python来自动化与骨架相关的任务。骨架已经是3D动画中较为技术性的方面之一，因此非常适合基于脚本的解决方案。
- en: Creating skeletons with script
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用脚本创建骨骼
- en: In this example, we'll be looking at how to create skeletons with script. We'll
    create two examples, one simple chain of bones and one branching set, similar
    to what you might want for a creature's hand.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将探讨如何使用脚本创建骨骼。我们将创建两个示例，一个是简单的骨骼链，另一个是分支集合，类似于你可能想要用于生物的手。
- en: How to do it...
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Create a new file and add the following code:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新文件并添加以下代码：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Run this code, and you'll see two separate networks of bones, both centered
    at the origin—one that is a straight vertical chain of five bones and one that
    approximates a hand (five fingers with three joints each).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码，你将看到两个独立的骨骼网络，它们都位于原点中心——一个是五根骨骼的垂直链，另一个近似于手（五个手指，每个手指有三个关节）。
- en: The end result should look something like the following (shown after moving
    the two skeletons apart).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果应该看起来像以下这样（在将两个骨骼分开后显示）。
- en: '![How to do it...](img/4657_05_01.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![如何做到这一点...](img/4657_05_01.jpg)'
- en: How it works...
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We''ll start with the `createSimpleSkeleton` command. Note that we start the
    function with a triple-quoted comment:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从`createSimpleSkeleton`命令开始。注意，我们在函数开始处使用了一个三引号注释：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: By placing a comment as the very first thing in the function definition, Python
    will recognize it as a *docstring*.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在函数定义中作为第一件事放置注释，Python会将其识别为*文档字符串*。
- en: 'Docstrings are a great way to provide documentation to the end user about what
    your code does and how it should be used. If you''ve added docstrings to your
    functions, the user will be able to view them with the help command. For example,
    let''s say we have a file named `myFunctions.py` with a handful of functions,
    and we start the first one in the following manner:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 文档字符串是向最终用户提供有关代码做什么以及如何使用的文档的绝佳方式。如果你已经为你的函数添加了文档字符串，用户将能够使用help命令查看它们。例如，假设我们有一个名为`myFunctions.py`的文件，其中包含一些函数，我们以下述方式启动第一个函数：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The user could use the following command to view our description for functionOne:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以使用以下命令来查看`functionOne`函数的描述：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note the use of dot syntax to specify first the module (Python treats all files
    as modules) then the specific function within it. Also note that there aren't
    any parentheses after the name of the function; that's because we're not calling
    the function. Instead, we're passing the function into the help command, which
    will cause Python to output the docstring for that function, if one exists.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用点语法来指定首先模块（Python将所有文件视为模块），然后是其中的特定函数。还要注意函数名称后面没有括号；这是因为我们并没有调用函数。相反，我们正在将函数传递给help命令，这将导致Python输出该函数的文档字符串（如果存在）。
- en: Docstrings can also be used to provide documentation for classes and modules.
    In either case, make sure that the docstring is the first thing to appear in the
    class, function, or file, either directly after "def [functionName]", as we've
    done here, after "class [className]:" (for classes), or at the top of the file
    (for modules).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 文档字符串也可以用来为类和模块提供文档。在两种情况下，确保文档字符串是类、函数或文件中首先出现的内容，无论是直接在“def [functionName]”之后，就像我们在这里所做的那样，还是在“class
    [className]：”之后（对于类），或者是在文件顶部（对于模块）。
- en: When adding docstrings, it's generally a good practice to describe each of the
    inputs to the function and what they signify. In this case, our function has a
    single input, which will specify the number of bones to create.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加文档字符串时，通常一个好的做法是描述函数的每个输入以及它们的意义。在这种情况下，我们的函数有一个单一输入，它将指定要创建的骨骼数量。
- en: 'Now that we''ve properly documented our code, it''s time to actually make some
    bones. The bulk of the work is done using the joint tool to create a new bone
    using the position/p flag to specify where it should go, as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经正确地记录了我们的代码，是时候实际创建一些骨骼了。大部分工作是通过使用关节工具来创建一个新的骨骼来完成的，使用位置/p标志来指定它应该去哪里，如下所示：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In our first example, we make things slightly easier on ourselves by creating
    an array to hold the position of the bones and passing that in to each successive
    call to the joint command. This way, we can easily just modify the Y position
    of the joints that we create, while keeping the X and Z coordinates the same to
    produce a vertical chain of bones:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个例子中，我们通过创建一个数组来存储骨骼的位置，并将它传递给每个后续的关节命令调用，使事情变得稍微简单一些。这样，我们可以轻松地只修改我们创建的关节的Y位置，同时保持X和Z坐标不变，以产生一个垂直的骨骼链：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We also create an array to hold the output of the joint command after each
    bone is created in order to allow us to take further actions on the bones once
    they''ve been created:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还创建了一个数组来存储在创建每个骨骼之后联合命令的输出，以便我们可以在骨骼创建后对它们执行进一步的操作：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Once we have both of those, we simply run through a loop, changing the second
    element of our pos array to alter the Y-value and creating a new joint:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了这两者，我们只需通过一个循环，改变我们位置数组中的第二个元素来改变Y值，并创建一个新的关节：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The most notable thing about the this is what we're *not* doing. Note that this
    code merely creates bones; it does nothing to explicitly create any sort of hierarchy
    between them. Nevertheless, the preceding code will result in a proper chain of
    bones, with each one a child of the previous bone.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这中最值得注意的是我们*没有*做什么。请注意，这段代码仅仅创建了骨骼；它没有明确创建任何它们之间的层次结构。尽管如此，前面的代码将导致一个正确的骨骼链，每个都是前一个骨骼的子对象。
- en: 'This is due to the fact that, when creating bones, Maya will automatically
    make any newly created joint a child of the currently selected object, if that
    object happens to be a joint. That, combined with the fact that all of Maya''s
    commands that result in the creation of a new object leave that new object selected
    means that, as we build up the chain of joints, Maya automatically connects them
    into the proper hierarchy. This also explains why the first line of the function
    was:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为，在创建骨骼时，Maya会自动将任何新创建的关节作为当前选中对象的子对象，如果那个对象恰好是一个关节。结合Maya的所有命令在创建新对象时都会选中那个新对象的事实，这意味着，当我们构建关节链时，Maya会自动将它们连接到正确的层次结构中。这也解释了为什么函数的第一行是：
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This ensured that nothing was selected. When creating new joint networks, it
    is always good to make sure that your selection is clear before starting; otherwise,
    you may end up with connections that you don't want.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这确保了没有任何东西被选中。在创建新的关节网络时，在开始之前确保你的选择是清晰的总是好的；否则，你可能会得到你不想有的连接。
- en: 'Now that we''ve looked at making a simple chain of bones, we''ll move on to
    a slightly more complex example in the `createHand` function. Once again, we''ll
    add a docstring at the start of the function to properly document the inputs to
    the function and the effects of each:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经查看了一个简单的骨骼链的创建，我们将继续到`createHand`函数中一个稍微复杂一点的例子。我们再次在函数的开始处添加一个文档字符串，以正确记录函数的输入和每个效果：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We start by creating a single joint to be the root bone and saving it in the
    `baseJoint` variable, so we can easily refer to it again later.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个单一的关节作为根骨骼，并将其保存在`baseJoint`变量中，这样我们就可以稍后轻松地引用它。
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We'll also make sure to give our new bone a sensible name. In this case, we'll
    use "wrist" since it will be serving as the parent bone for all of our fingers.
    You might be wondering why we're setting the name *and* storing the result into
    a variable. That is necessary in order to avoid problems if there is already something
    named "wrist" in our scene. If there *is* something named "wrist", then Maya would
    append a number onto the name of the newly created bone, resulting in something
    like "wrist1". If we later tried to do something to "wrist", we would end up affecting
    a different object. So, we have to do two things; we'll store the output of the
    joint command into a variable so that we can refer to it later *and* we give it
    a name so that it's nicer to work with.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还会确保给我们的新骨骼一个合理的名称。在这种情况下，我们将使用“wrist”，因为它将作为所有手指的父骨骼。你可能想知道为什么我们既要设置名称又要将结果存储到变量中。这是必要的，以避免如果场景中已经存在名为“wrist”的东西时出现问题。如果确实存在名为“wrist”的东西，Maya会在新创建的骨骼名称上附加一个数字，结果可能像“wrist1”。如果我们后来试图对“wrist”做些什么，我们最终会影响到不同的对象。所以，我们必须做两件事；我们将关节命令的输出存储到变量中，以便以后可以引用，并且给它一个名称，这样更容易处理。
- en: Having all of the bones in your rig named "jointX" is a great way to make things
    unnecessarily confusing, so always be sure to give your bones proper names; just
    don't trust those names to always be unique.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的绑定中所有骨骼都命名为“jointX”是使事情变得不必要混乱的好方法，所以总是确保给你的骨骼合适的名称；只是不要相信那些名称总是唯一的。
- en: Now that we have our base bone, we create a few variables to control the layout
    of the "hand"—one for the length of the palm, one for the length of each finger
    joint, and one for the gap between each finger.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了基础骨骼，我们创建了一些变量来控制“手”的布局——一个用于手掌的长度，一个用于每个手指关节的长度，一个用于每个手指之间的间隙。
- en: '![How it works...](img/4657_05_02.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/4657_05_02.jpg)'
- en: Now we're ready to create each finger. We start each pass through the loop by
    first selecting the baseJoint bone. That's all we need to do in order to make
    sure that we have the proper hierarchy, with each finger having a separate chain
    and each chain being parented to the base joint.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备创建每个手指。我们每次通过循环的第一步是首先选择baseJoint骨骼。这就是我们确保拥有正确层次结构所需做的全部工作，每个手指都有一个独立的链，每个链都是base
    joint的父链。
- en: 'We start each finger with a joint that is palmLen units above the base joint.
    The horizontal spacing is a little more involved and requires some explanation.
    We have the following code:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们每个手指都从比基础关节高palmLen单位的关节开始。水平间距稍微复杂一些，需要一些解释。我们有以下代码：
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'There are two parts to the preceding code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码分为两部分：
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This will ensure that the fingers are spaced out horizontally by the proper
    amount, but if we left it at that, we would have all of the fingers to the right
    of the wrist. To fix this, we need to move all of our positions to the left by
    one half of the total width. The total width is equal to our fingerSpacing variable
    multiplied by the number of gaps between the fingers. Since the number of gaps
    is equal to the number of fingers, minus one, we have:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保手指以正确的数量水平分布，但如果我们就这样留下，所有手指都会在手腕的右侧。为了解决这个问题，我们需要将所有位置向左移动半个总宽度。总宽度等于我们的fingerSpacing变量乘以手指之间的间隙数。由于间隙的数量等于手指的数量减一，所以我们有：
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Subtracting the second part from the first will keep the finger-to-finger spacing
    the same, but will move everything such that the fingers are centered over the
    based joint.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 从第一部分减去第二部分将保持手指间的间距不变，但会将所有东西移动，使得手指都集中在基础关节上方。
- en: 'Now that we have the proper position for the base of our "finger", we create
    the first joint, as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经确定了“手指”基础的位置，我们按照以下方式创建第一个关节：
- en: '[PRE14]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note that we use the string format command to build up the name of the joint
    from some literals and the number of the finger we're on at the moment (adding
    one so that the first finger is a more readable "1" instead of "0"). This will
    give us joints named along the lines of "finger1base", "finger2base", and so on.
    We'll do something similar with the successive joints to name them with both the
    name of the finger and the name of the joint ("finger1joint1", for example).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用字符串格式命令从一些字面量和当前手指的编号（加一，以便第一个手指是更易读的“1”而不是“0”）构建关节的名称。这将给出类似“finger1base”、“finger2base”等名称的关节。我们会对后续的关节做类似处理，用手指的名称和关节的名称来命名它们（例如，“finger1joint1”）。
- en: 'Once we''ve started the finger, we run through another loop to create each
    of the finger joints:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦开始绘制手指，我们就会运行另一个循环来创建每个手指关节：
- en: '[PRE15]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note that there's one small difference with this, in that we're passing what
    appears to be the same position in to the joint command. That still works because
    we're also using the `relative` command, which will cause Maya to position the
    new bone relative to its immediate parent. In this case, this means that each
    new bone will be created `jointLen` units above the previous one.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这里有一个小的不同，因为我们把看起来相同的位置传递给关节命令。这仍然有效，因为我们还使用了`relative`命令，这会导致Maya将新骨骼相对于其直接父级定位。在这种情况下，这意味着每个新骨骼都将创建在之前的骨骼上方`jointLen`个单位。
- en: There's more...
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In order to create branching skeletons, it is necessary to change the currently
    selected bone before creating child bones. In the preceding example, we did that
    directly, by explicitly selecting our base joint again before starting each new
    branch.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建分支骨骼，在创建子骨骼之前必须更改当前选中的骨骼。在前面的例子中，我们直接这样做，通过在开始每个新分支之前再次显式选择我们的基础关节。
- en: That's not the only way though you can also use the `pickWalk` command. The
    `pickWalk` command operates on the current selection and allows you to move around
    its hierarchy. To use the command, you have to specify a direction—up, down, left,
    or right. The most useful options are up, which will change the selection to be
    the parent of the currently selected node, and down, which will change the selection
    to a child of the currently selected node (assuming it has children). So, another
    option to create a branching network of joints would be
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是唯一的方法，你还可以使用`pickWalk`命令。`pickWalk`命令作用于当前选择，并允许你在其层次结构中移动。要使用该命令，你必须指定一个方向——向上、向下、向左或向右。最有用的选项是向上，这将更改选择以成为当前选中节点的父节点，以及向下，这将更改选择为当前选中节点的子节点（假设它有子节点）。因此，创建关节分支网络的另一个选项是
- en: 'to import maya.cmds as cmds, as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 导入maya.cmds作为cmds，如下所示：
- en: '[PRE16]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The first two lines create a base bone and add a child bone one unit up and
    to the left. Then, the `pickWalk` command is used to move the selection back to
    the base joint before creating a third bone.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 前两行创建一个基础骨骼，并在上方和左侧各一个单位的位置添加一个子骨骼。然后，使用`pickWalk`命令将选择移动回基础关节，在创建第三个骨骼之前。
- en: The results of creating three bones in sequence. The left image indicates what
    happens if pickWalk is used to move back up the hierarchy after creating the second,
    and the right image indicates what happens if pickWalk is omitted.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 创建三个骨骼的连续结果。左图表示在创建第二个骨骼后使用pickWalk向上移动层次结构会发生什么，右图表示省略pickWalk会发生什么。
- en: '![There''s more...](img/4657_05_03.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多...](img/4657_05_03.jpg)'
- en: Setting up set-driven key relationships with script
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用脚本设置驱动键关系
- en: A great deal of rigging is nothing more than setting up connections between
    attributes. Sometimes, those connections can be very direct, such as making sure
    that two joints are always in exactly the same position in world space, but in
    other times, something other than a direct one-to-one mapping is called for.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 大量的绑定工作不过是设置属性之间的连接。有时，这些连接可能非常直接，例如确保两个关节在世界空间中始终处于完全相同的位置，但在其他时候，可能需要除了直接的一对一映射之外的其他映射。
- en: There are a few different ways to connect attributes in non-linear ways, including
    using Maya's set-driven key capability to map one arbitrary range of an attribute
    onto a different arbitrary range of another. In this example, we'll be looking
    at how to set that up with scripting.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种不同的方式可以将属性以非线性方式连接起来，包括使用Maya的驱动键功能将一个属性的任意范围映射到另一个属性的另一个任意范围。在本例中，我们将探讨如何通过脚本设置它。
- en: Our example will set up the "Hello World" equivalent for using a set-driven
    key, a finger that curls all of its joints smoothly at the same time, allowing
    the animator to keyframe a single attribute per finger instead of three (or possibly
    even more).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的例子将设置使用驱动键的“Hello World”等效，一个手指的所有关节同时平滑弯曲，允许动画师为每个手指键帧一个属性，而不是三个（或甚至更多）。
- en: Getting ready
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this example, you'll want to have a simple chain of at least three bones.
    The output of the script will cause all of the bones downstream from the selected
    bone to rotate when the parent bone (the knuckle) is rotated. Either create a
    simple chain of bones, or use the output from this chapter's example on bone creation.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，你希望有一个至少由三个骨骼组成的简单链。脚本的输出将导致当父骨骼（指关节）旋转时，所选骨骼下游的所有骨骼都会旋转。你可以创建一个简单的骨骼链，或者使用本章示例中创建骨骼的输出。
- en: How to do it...
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Create a new script and enter the following code:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的脚本并输入以下代码：
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Once you have the script ready, select the "knuckle" bone and run it. Then,
    try rotating the knuckle bone around the *z* axis. You should see all of the bones
    downstream from the knuckle rotate as well:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦脚本准备就绪，选择“指关节”骨骼并运行它。然后，尝试围绕 *z* 轴旋转指关节骨骼。你应该看到从指关节下游的所有骨骼也会旋转：
- en: '[fig setDrivenKey_1]'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '[fig setDrivenKey_1]'
- en: How it works...
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: There are two main aspects to the script—the actual set-driven key setup and
    some code to walk down the chain of bones.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本有两个主要方面——实际的驱动键设置和一些遍历骨骼链的代码。
- en: First off, we start by grabbing the currently selected object, as we've done
    in the past.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们开始获取当前选定的对象，就像我们过去做的那样。
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We store the selected object to a variable (baseJoint) so that we can easily
    refer to it later. We'll also want an easy way to refer to the driver attribute,
    in this case, the Z-rotation of the base bone, so we store that to a variable
    as well.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将选定的对象存储到一个变量（baseJoint）中，这样我们就可以轻松地稍后引用它。我们还将需要一个容易引用的驱动属性，在这种情况下，是基础骨骼的
    Z-旋转，因此我们也将它存储到一个变量中。
- en: '[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now we''re ready to start stepping through our chain of bones. To do this,
    we''ll need to first grab a list of all of the downstream bones from the selected
    joint. We can do that using the `listRelatives` command with the children flag.
    Normally, that would only use the direct children of the given node, but if we
    also set the `allDescendents` flag to True, we will be given the full list of
    children, grandchildren, and so on down the entire hierarchy:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备开始逐步遍历我们的骨骼链。为此，我们首先需要获取从所选关节的所有下游骨骼的列表。我们可以使用带有子节点标志的 `listRelatives`
    命令来完成此操作。通常，这只会使用给定节点的直接子节点，但如果我们也将 `allDescendents` 标志设置为 True，我们将得到完整的子节点、孙节点以及整个层次结构中的所有节点列表：
- en: '[PRE20]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now that we have a list of all of the nodes that are children of the selected
    node (in this case, our base joint), we're ready to step through the list and
    set up a set-driven key relationship on each. To do this, we'll use the `setDrivenKeyframe`
    command.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有一个所选节点（在这种情况下，我们的基础关节）的所有子节点的列表，我们准备遍历列表并在每个上设置一个驱动键关系。为此，我们将使用 `setDrivenKeyframe`
    命令。
- en: 'In each iteration through our loop, we''ll:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环的每次迭代中，我们将：
- en: Set our `driven` variable to the proper attribute (bone + ".rotateZ").
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们的 `driven` 变量设置为正确的属性（骨骼 + ".rotateZ")。
- en: Set the value of our driven attribute using setAttr to its minimum value.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `setAttr` 将驱动属性设置为最小值。
- en: Use the `setDrivenKeyframe` command to link the two attributes.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `setDrivenKeyframe` 命令来链接两个属性。
- en: Repeat steps 2 and 3 to set the maximum values.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复步骤 2 和 3 来设置最大值。
- en: 'The `setDrivenKeyframe` command is fairly straightforward, requiring that we
    pass in the driver attribute, the driven attribute, and the values for each. In
    both cases, the attributes in question need to be the full name (node name, ".",
    and attribute name). So, to set it up so that our driven attribute is at 0 when
    our driver attribute is at -10, we could use the following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`setDrivenKeyframe` 命令相当直接，需要我们传递驱动属性、驱动属性和每个属性的值。在两种情况下，所涉及的属性都需要是全名（节点名称、"."
    和属性名称）。因此，为了设置当驱动属性在 -10 时，驱动属性在 0 时，我们可以使用以下命令：'
- en: '[PRE21]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This should be enough to get the results we want, but the command can often
    fail unless the driver value is explicitly set beforehand. That's why, we use
    `setAttr` before calling `setDrivenKeyframe`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该足以得到我们想要的结果，但除非驱动值事先明确设置，否则该命令通常会失败。这就是为什么我们在调用 `setDrivenKeyframe` 之前使用
    `setAttr`。
- en: 'The `setAttr` command is a real workhorse, and it is the one that you''re likely
    to use in a great deal of different scenarios. Luckily, it''s also very easy to
    use; just call it and pass in first the attribute you''re setting, then the value
    to which you want to set it, as in:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`setAttr` 命令是一个真正的多面手，你很可能会在许多不同的场景中使用它。幸运的是，它也非常容易使用；只需调用它，然后传入你想要设置的属性，然后是你想要设置的值，就像这样：'
- en: '[PRE22]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Once we''ve set at least two keys on each bone, we''ll have a proper set-driven
    key relationship. Putting this all together gives us the following loop:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们在每个骨骼上设置了至少两个键，我们就会有一个合适的关键驱动键关系。将这些放在一起，我们得到以下循环：
- en: '[PRE23]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Finally, we'll finish off the script with a little bit of cleanup to ensure
    that we leave things as we found them. In this case, it means setting the driver
    value back to zero.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将通过一些清理工作来完成脚本，以确保我们留下的是我们找到的状态。在这种情况下，这意味着将驱动值设置回零。
- en: '[PRE24]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: There's more...
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'In the preceding example, we used only two keyframes, but you can certainly
    have more than two points on the graph relating the driven variable to the driver
    if you wanted to have a more non-linear relationship between the attributes. For
    example, if we wanted to have the driven variable change at a greater rate during
    the last third of the range, we could do something like the following:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们只使用了两个关键帧，但如果你想要在属性和驱动变量之间建立更非线性的关系，你当然可以在图表上有超过两个点。例如，如果我们想要在范围的最后三分之一内，驱动变量以更快的速度变化，我们可以做如下操作：
- en: '[PRE25]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this code, the first twenty units of change in the driver (0–20) would result
    in only 10 units of change in the driven (0–10), but the last 10 units of change
    in the driver (20–30) would drive a 20-unit change in the driven attribute.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，驱动器的第一个二十个单位的改变（0-20）将导致驱动变量只有十个单位的改变（0-10），但驱动器的最后十个单位的改变（20-30）将驱动驱动属性二十个单位的改变。
- en: Another thing you might want to consider is what kind of curve you want to create.
    Each of the keyframes added with `setDrivenKeyframe` can be given its own tangent
    types, for both the input and output. To do it, set either the `inTangentType`
    or `outTangentType` when calling the function. In either case, you'll want to
    give it a string representing the tangent type you want.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还想考虑你想创建什么类型的曲线。使用`setDrivenKeyframe`添加的每个关键帧都可以为其输入和输出分配自己的切线类型。要做到这一点，在调用函数时设置`inTangentType`或`outTangentType`。在任何情况下，你都会想要提供一个字符串，表示你想要的切线类型。
- en: 'So, if we wanted to have linear tangents for both the input and output of a
    new driven keyframe, we could do the following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们想要为新的驱动关键帧的输入和输出都使用线性切线，我们可以这样做：
- en: '[PRE26]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: For a full list of the allowed options, consult the documentation for the `setDrivenKe`
    `yframe` command.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取允许选项的完整列表，请参阅`setDrivenKeyframe`命令的文档。
- en: Adding custom attributes and locking and hiding attributes
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加自定义属性以及锁定和隐藏属性
- en: As you build up the rig for a model, it is often helpful to create custom attributes
    so that you can link things to `forefingerRight.curl` (for example), instead of
    `forefingerRight.rotateZ`. Not only will that make your rigs a great deal easier
    to understand, but it also allows you to tie actions of the rig to values that
    are completely independent of any built-in affects such as rotation or translation.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当你为模型建立绑定时，创建自定义属性通常很有帮助，这样你就可以将东西链接到`forefingerRight.curl`（例如），而不是`forefingerRight.rotateZ`。这不仅会使你的绑定更容易理解，而且还可以让你将绑定的动作与完全独立于任何内置效果（如旋转或平移）的值相关联。
- en: Just as there are sometimes attributes that you will want to add to a given
    node, there are often attributes on a node that you know you'll never want to
    animate. Locking such attributes and hiding them in the channel box is another
    way to make your rigs easier to work with.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 正如有时你可能想要给某个节点添加属性一样，节点上往往有一些你知道永远不会想要动画化的属性。锁定这些属性并在通道框中隐藏它们是使你的绑定更容易工作的另一种方法。
- en: In this example, we'll be looking at how to do both things—adding new, custom
    attributes to a node and hiding undesirable or unimportant attributes from view.
    More specifically, we'll be hiding the rotation and scale attributes and adding
    some attributes of the sort that you might want in order to animate a facial rig.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将探讨如何做这两件事——向节点添加新的自定义属性，并从视图中隐藏不希望或不重要的属性。更具体地说，我们将隐藏旋转和缩放属性，并添加一些你可能想要用于动画面部绑定的属性。
- en: 'Here''s a screenshot of the channel box both before and after the example script
    is run:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是示例脚本运行前后通道框的截图：
- en: '![Adding custom attributes and locking and hiding attributes](img/4657_05_04.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![添加自定义属性以及锁定和隐藏属性](img/4657_05_04.jpg)'
- en: Getting ready
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Before adding to or altering the attributes on a node, it's important to determine
    exactly what you need. In this case, we'll be setting things up in a way similar
    to what we might want for control of a facial rig. This means for the node itself,
    we'll likely want to be able to change its position, but not the rotation or scale.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在向节点添加或修改属性之前，确定确切需要什么非常重要。在这种情况下，我们将以类似于我们可能希望用于面部绑定控制的方式设置事物。这意味着对于节点本身，我们可能希望能够改变其位置，但不能改变其旋转或缩放。
- en: 'We''ll also want to add several different attributes to control the parts of
    our rig. These will naturally vary from rig to rig, but in all cases, it''s necessary
    to think about what kind of data we need for each. For the sake of the example,
    let''s say that we want the following controls:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望添加几个不同的属性来控制我们的绑定部分。这些属性自然会因绑定而异，但在所有情况下，考虑每个属性所需的数据类型都是必要的。为了举例，让我们假设我们想要以下控制：
- en: A "blink" attribute, which will cause both eyelids to close and open.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个"blink"属性，将导致上下眼睑同时闭合和睁开。
- en: An "IK/FK" switch control for each of the legs that can switch between IK and
    FK controls
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为每条腿添加一个"IK/FK"切换控制，可以在IK和FK控制之间切换
- en: For each of these, we'll need to think about what kind of data we need. For
    the blink attribute, we want a number that can vary smoothly from one value (representing
    fully open) to another (representing fully closed). For that, we'll need a decimal
    number.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些，我们需要考虑我们需要什么类型的数据。对于眨眼属性，我们想要一个可以从一个值（表示完全睁开）平滑变化到另一个值（表示完全闭合）的数字。为此，我们需要一个十进制数。
- en: For the IK/FK switch, we could approach it in two different ways. We could have
    a value that represents whether IK is on, with "off" meaning that FK is currently
    being used. For that, we would want to use a simple on/off value. Alternatively,
    we could implement our IK/FK switch as a dropdown of options. That would likely
    be a better and more user-friendly way to go. In this example, we'll be implementing
    both approaches for the sake of completeness.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 对于IK/FK切换，我们可以采取两种不同的方法。我们可以有一个表示IK是否开启的值，其中"关闭"表示当前正在使用FK。为此，我们希望使用一个简单的开/关值。或者，我们可以将我们的IK/FK切换实现为一个选项下拉菜单。这可能是更好、更用户友好的方法。在这个例子中，我们将实现这两种方法以确保完整性。
- en: How to do it...
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Create a new file and add the following code:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新文件并添加以下代码：
- en: '[PRE27]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Select an object and run the preceding script, making sure that you have the
    channel box visible when you do so. You should see the rotation and scale attributes
    disappear and the new attributes appear.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 选择一个对象并运行前面的脚本，确保在这样做时通道框是可见的。你应该会看到旋转和缩放属性消失，而新的属性出现。
- en: How it works...
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'First off, we grab the currently selected object, just as we''ve done in the
    past. Once we''ve done that, we start by adding the blink attribute with the following:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们获取当前选定的对象，就像我们过去做的那样。一旦我们这样做，我们就开始添加眨眼属性，如下所示：
- en: '[PRE28]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This is a fairly involved command, but the general idea is that we specify
    the following for each attribute we want to add:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当复杂的命令，但基本思想是，对于我们要添加的每个属性，我们指定以下内容：
- en: The name
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称
- en: The type of attribute
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性的类型
- en: Any additional information that the specific type of attribute requires
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特定类型的属性所需的所有附加信息
- en: The names of attributes come in two flavors—the short name and the long name.
    You have to specify at least one of those to have the command work, but it's generally
    a good idea to specify both. In this case, "blink" is sufficiently short to use
    it for both the short and long versions.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 属性名称有两种形式——短名称和长名称。您必须指定其中之一才能使命令生效，但通常最好同时指定两者。在这种情况下，"blink"足够短，可以用于短名称和长名称版本。
- en: If we don't directly specify the type of attribute we're creating, Maya will
    default to a numerical type, which happens to be exactly what we want for the
    blink attribute. Since a "blink" attribute has a natural upper and lower bound
    (since eyelids open by a finite amount), it also makes sense to give our attribute
    minimum and maximum values, with the default being in between. Here, we're using
    -1 and 1 for the minimum and maximum, which is fairly standard.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有直接指定创建的属性类型，Maya将默认为数值类型，这恰好是我们想要的眨眼属性类型。由于"眨眼"属性有一个自然的上限和下限（因为眼睑只能打开有限的程度），因此为我们的属性指定最小值和最大值也很有意义，默认值位于两者之间。在这里，我们使用-1和1作为最小值和最大值，这是相当标准的。
- en: Finally, in order to ensure that our new attribute shows up in the channel box,
    we need to make sure that we set the `keyable` flag to true.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了确保我们的新属性出现在通道框中，我们需要确保将 `keyable` 标志设置为 true。
- en: 'Next up is our simple on/off version of the IK/FK switch. For this, we''ll
    be using a Boolean type. For non-numeric types, we''ll need to use the `attributeType`
    flag with the appropriate value (in this case, "bool"). We still specify the short
    and long names, and use the `keyable` flag to make it appear in the channel box:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是简单的开/关版本的 IK/FK 开关。为此，我们将使用布尔类型。对于非数值类型，我们需要使用 `attributeType` 标志并指定适当的值（在这种情况下，"bool"）。我们仍然指定短名称和长名称，并使用
    `keyable` 标志使其出现在通道框中：
- en: '[PRE29]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The resulting attribute will accept values of either 0 or 1, but will display
    them as "off" or "on" (respectfully) in the channel box.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的属性将接受 0 或 1 的值，但在通道框中将以“关闭”或“开启”（分别）的形式显示。
- en: For our final attribute, we'll create one with two possible states, either "IK"
    or "FK", presented to the user as a drop-down list. For that, we'll create an
    attribute of type "enum" (short for "enumerated list"). We'll also need to specify
    the specific options that we want with the `enumName` flag. The `enumName` flag
    expects a string containing one or more options, all separated with colons.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的最后一个属性，我们将创建一个具有两种可能状态的属性，即“IK”或“FK”，以下拉列表的形式呈现给用户。为此，我们将创建一个类型为“enum”（即“枚举列表”）的属性。我们还需要使用
    `enumName` 标志指定我们想要的特定选项。`enumName` 标志期望一个包含一个或多个选项的字符串，所有选项都由冒号分隔。
- en: 'So, in order to have "IK" and "FK" options, we''ll want the value of our `enumName`
    flag to be "IK:FK". Putting this all together gives us:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了有“IK”和“FK”选项，我们希望 `enumName` 标志的值为“IK:FK”。将这些全部放在一起，我们得到：
- en: '[PRE30]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Note that, in order to actually hook our new attribute up to anything, it''s
    important to know what the actual values of each option are. By default, the first
    option will have a value of 0, with each successive option increasing by one.
    So, in this case, "IK" will correspond to 0 and "FK" will correspond to 1\. If
    you want to have specific numerical values for specific options, that''s also
    possible. For example, if we wanted "IK" to correspond to 5 and "FK" to 23, we
    could do that with the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，为了实际上将我们的新属性连接到任何东西，了解每个选项的实际值非常重要。默认情况下，第一个选项的值将为 0，每个后续选项的值将增加 1。因此，在这种情况下，“IK”将对应于
    0，“FK”将对应于 1。如果您想为特定选项指定特定的数值，这也是可能的。例如，如果我们想让“IK”对应于 5，“FK”对应于 23，我们可以使用以下方法：
- en: '[PRE31]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'At this point, we''re all done adding attributes and can move on to hiding
    the ones we don''t want—the rotation and scale attributes. We''ll want to do three
    separate things to properly hide each attribute, namely:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经完成了属性的添加，可以继续隐藏我们不需要的属性——旋转和缩放属性。为了正确地隐藏每个属性，我们需要做三件事，具体如下：
- en: Lock the attribute so that its value cannot be changed.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 锁定属性，使其值不能更改。
- en: Set the attribute to not be keyable.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将属性设置为不可键入。
- en: Set the attribute to not appear in the channel box.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将属性设置为不在通道框中显示。
- en: 'All of these can be accomplished with the `setAttr` command, used in the edit
    mode, as in:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都可以使用 `setAttr` 命令在编辑模式下完成，如下所示：
- en: '[PRE32]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note that the first thing we pass in to setAttr is the full name of the attribute
    (object name and attribute name, joined by a "."). That can be a little tedious
    to do each time though, so we create a function that accepts the object and attribute
    name, and locks and hides it.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们传递给 setAttr 的第一个参数是属性的完整名称（对象名称和属性名称，由一个点“.”连接）。虽然每次这样做可能有点繁琐，但我们可以创建一个函数，该函数接受对象和属性名称，并将其锁定并隐藏。
- en: '[PRE33]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We can then use a bit of Python''s built-in functionality to make it even easier
    to lock a list of attributes by iterating over a list of attribute names and passing
    them to our `lockAndHide` function, as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用 Python 内置的一些功能，通过遍历属性名称列表并将它们传递给我们的 `lockAndHide` 函数，使锁定一系列属性变得更加容易，如下所示：
- en: '[PRE34]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In this case, Python's approach to for loops (iterating over a list) makes things
    very straightforward, indeed.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，Python 对 for 循环（遍历列表）的方法确实使事情变得非常简单明了。
- en: There's more...
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: If you look at the documentation for the `addAttr` command, you'll see that
    there is an extensive list of attribute types. Don't let the length of that list
    scare you; the vast majority of attributes you're likely to want to add can be
    implemented as the default (double) type with the appropriate minimum and maximum
    values. "Double" in this context is short for "double precision" meaning a decimal
    value that uses twice the number of bytes as a typical float.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看`addAttr`命令的文档，你会看到一个广泛的属性类型列表。不要让列表的长度吓到你；你很可能想要添加的大多数属性都可以作为默认（双精度）类型实现，并具有适当的最低和最高值。“双精度”在这里是“双精度”的缩写，意味着一个十进制值使用的字节数是典型浮点数的两倍。
- en: While the several different flavors of integer and floating-point numeric values
    aren't likely to make much of a difference in your scripts, a few of the more
    esoteric types may come in handy.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然几种不同的整数和浮点数值类型在你的脚本中可能不会造成太大的差异，但一些更神秘的类型可能会派上用场。
- en: One thing you might find useful is the ability to add a color attribute to a
    node. Adding a color requires adding a compound attribute, which is a little bit
    more involved than what we've seen so far. First, you need to add an attribute
    to serve as the parent, then you'll need to add successive child attributes, of
    the same type and of the right number as the parent attribute's type.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会发现的一项有用功能是能够向节点添加颜色属性。添加颜色需要添加一个复合属性，这比我们之前看到的要复杂一些。首先，你需要添加一个属性作为父属性，然后你需要添加连续的子属性，类型与父属性类型相同，数量与父属性类型正确。
- en: For a color, we'll need to use an attribute type with three values for the parent,
    such as "float3". We'll also want to set the `usedAsColor` flag to true so that
    it is properly recognized as a color by Maya.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 对于颜色，我们需要使用具有三个值的父属性类型，例如“float3”。我们还想将`usedAsColor`标志设置为true，以便Maya能够正确识别它为颜色。
- en: '[PRE35]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Once we''ve done that, we can add attributes for each component of the parent
    attribute (in this case, values for the red, green, and blue components). Note
    the use of the parent flag to properly tie the new attributes to our "colorTest"
    group:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成了这个步骤，我们就可以为父属性（在这种情况下，红色、绿色和蓝色组件的值）的每个组件添加属性。注意使用父标志正确地将新属性绑定到我们的“colorTest”组：
- en: '[PRE36]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Note that some types of attributes won't display in the channel box. To see
    such attributes, select the node they've been added to, open the attribute editor,
    and expand the "extra attributes" tab.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，某些类型的属性不会在通道框中显示。要查看此类属性，请选择已添加属性的节点，打开属性编辑器，并展开“额外属性”选项卡。
- en: '![There''s more...](img/4657_05_05.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多...](img/4657_05_05.jpg)'
- en: Setting up inverse kinematics (IK) with script
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用脚本设置反向运动学（IK）
- en: While it is very likely that any given model will require at least some custom
    rigging work, it can often be helpful to automate the setup of common subcomponents
    that occur frequently in many different rigs. In this example, we'll be doing
    just that and setting up a simple inverse kinematics (IK) system with code.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然任何给定模型很可能都需要至少一些自定义骨架工作，但自动化设置在许多不同骨架中频繁出现的常见子组件通常很有帮助。在这个例子中，我们将这样做，并使用代码设置一个简单的反向运动学（IK）系统。
- en: 'Although our example will be simple, it will still demonstrate a common issue—the
    need to accurately position joints to match the specific proportions of a model.
    As such, the script will have the following two distinct parts:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们的示例将很简单，但它仍然将演示一个常见问题——需要准确定位关节以匹配模型的特定比例。因此，脚本将有两个明显的部分：
- en: A preliminary step, where we create locators representing where the various
    joints will be created.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个初步步骤，其中我们创建表示各种关节创建位置的定位器。
- en: A secondary step, where we build a skeleton and set up its attributes based
    on the position of the locators.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个次要步骤，其中我们构建骨架并根据定位器的位置设置其属性。
- en: By breaking the script into two parts, we allow the user to alter the positions
    of the locators after they've been created, but before the actual skeleton has
    been set up. This tends to be a much more effective way to match rigs to characters,
    and there can also be a great way to solicit input from the user for other kinds
    of tasks as well.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将脚本分成两部分，我们允许用户在创建定位器之后、实际骨架设置之前更改定位器的位置。这通常是一种更有效的方法来匹配骨架和角色，也可以是征求用户对其他类型任务意见的绝佳方式。
- en: Getting ready
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: While you running the example script doesn't require having a suitable model,
    you might enjoy it more if you have a bipedal model to fit the joints we'll be
    creating to.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行示例脚本时不需要有合适的模型，但如果你有一个双足模型来适应我们将要创建的关节，你可能会觉得更有趣。
- en: How to do it...
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Create a new script and add the following code:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的脚本并添加以下代码：
- en: '[PRE37]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: How it works...
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Since this script requires two separate parts, we''ll need to implement a simple
    UI in order to allow the user to run the first part, alter the positions of the
    locators, and invoke the second. The UI isn''t anything complicated, but just
    two buttons, and should look familiar if you''ve worked through any of the examples
    in [Chapter 2](ch02.html "Chapter 2. Creating User Interfaces"), *Creating User
    Interfaces*. We simply create a window, add a layout, and add one button for each
    of the steps of our script. We have the following code:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此脚本需要两个独立的部分，我们需要实现一个简单的用户界面，以便用户可以运行脚本的第一部分，改变定位器的位置，并调用第二部分。用户界面并不复杂，只有两个按钮，如果你已经完成了[第2章](ch02.html
    "第2章。创建用户界面")中的任何示例，应该会感到熟悉。我们简单地创建一个窗口，添加一个布局，并为脚本中的每个步骤添加一个按钮。我们有以下代码：
- en: '[PRE38]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The things start to get interesting in the `makeLocators` function, which will
    create four locator objects in a default layout. Before creating the locators,
    we''ll create four global variables so that we can store references to them for
    later use. The `global` keyword tells Python that these variables should be treated
    as global in scope, meaning that they will be available beyond the immediate,
    local scope (in this case, the `makeLocators` function). Later on, we''ll invoke
    the global variables again from within our second function (the `setupIK` function)
    in order to refer to the locators we''re about to create:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当进入`makeLocators`函数时，事情开始变得有趣，该函数将在默认布局中创建四个定位器对象。在创建定位器之前，我们将创建四个全局变量，以便我们可以存储它们的引用以供后续使用。`global`关键字告诉Python这些变量应该被视为具有全局作用域，这意味着它们将在立即的局部作用域之外（在这种情况下，`makeLocators`函数）可用。稍后，我们将从我们的第二个函数（`setupIK`函数）内部再次调用全局变量，以便引用我们即将创建的定位器：
- en: '[PRE39]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now we're ready to create the locators. Locators are especially useful for rigging
    because they provide a bare-bones transform node that is nonrenderable, but easily
    selectable in Maya's interface.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好创建定位器了。定位器在绑定中特别有用，因为它们提供了一个非渲染的裸骨变换节点，但在Maya的界面中很容易选择。
- en: To make a locator, we can use the `spaceLocator` command. We'll use the name
    flag to set the name of created locator, but this is mainly just to make things
    nice for the end user.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个定位器，我们可以使用`spaceLocator`命令。我们将使用名称标志来设置创建的定位器的名称，但这主要是为了使最终用户的使用更加方便。
- en: Tip
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Although it is sometimes nice to give created nodes names, you should never
    rely on those names for later reference, as there's no guarantee that the name
    you specify is the name that the object will end up with. If you name something
    `myObject`, but there's already a node in your scene by that name, Maya will force
    the newly created object to be named `myObject1`, and any code that you wrote
    referencing `myObject` would be pointed at the wrong thing. Never, ever, trust
    names in Maya; instead store the output of commands that create nodes to variables
    and use those variables to refer to the created objects.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有时给创建的节点命名是个不错的选择，但你绝不应该依赖这些名称作为后续的参考，因为没有保证你指定的名称就是对象最终拥有的名称。如果你将某个东西命名为`myObject`，但你的场景中已经存在同名节点，Maya会强制将新创建的对象命名为`myObject1`，而你编写的任何引用`myObject`的代码都会指向错误的对象。永远不要在Maya中信任名称；相反，将创建节点的命令输出存储到变量中，并使用这些变量来引用创建的对象。
- en: 'We''ll create four locators in total, one each for the hip, knee, ankle, and
    toe of a simple leg. The output of each of our calls to the `spaceLocator` command
    is saved to one of our global variables:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将总共创建四个定位器，每个定位器对应于简单腿部的一个部分：臀部、膝盖、脚踝和脚趾。我们调用`spaceLocator`命令的每个输出都保存到我们的一个全局变量中：
- en: '[PRE40]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: If you look at the documentation for the `spaceLocator` command, you'll see
    that there is a `position` flag that can be used to set the position of the created
    locator. However, note that we're not using that flag in the previous code. This's
    because while the locator will appear to be at the specified position, the pivot
    point for the locator will remain at the origin. Since we're creating the locators
    specifically to use them to grab positions in world space, which makes things
    difficult for us.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看`spaceLocator`命令的文档，你会看到有一个`position`标志可以用来设置创建的定位器的位置。然而，请注意，我们在之前的代码中没有使用该标志。这是因为虽然定位器看起来会出现在指定的位置，但定位器的旋转中心点将保持在原点。由于我们创建定位器是为了在全局空间中获取位置，这给我们带来了困难。
- en: 'There''s an easy workaround, though we''ll just leave the position unspecified,
    which will cause both the locator and its pivot to be at the origin, then use
    the `xform` (short for "transform") command to set the position of each locator
    to a reasonable starting position. This ends up looking like the following:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，有一个简单的解决方案，我们只需不指定位置，这将导致定位器和其旋转中心点都位于原点，然后使用`xform`（简称为“变换”）命令将每个定位器的位置设置到一个合理的起始位置。这最终看起来如下所示：
- en: '[PRE41]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `xform` command can be used in several different ways, all related to querying
    or altering the transform (position, rotation, and scale) values of nodes. In
    this case, we're using it to set the translation of the locators to set values.
    We also set the absolute flag to true to indicate that the values represent where
    the locator should be moved to in absolute coordinates (as opposed to a relative
    displacement from its current position).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`xform`命令可以以几种不同的方式使用，所有这些都与查询或更改节点的变换（位置、旋转和缩放）值有关。在这种情况下，我们使用它来设置定位器的平移值。我们还设置了绝对标志为true，以指示这些值代表定位器应在绝对坐标中移动到的位置（而不是从当前位置的相对位移）。'
- en: We move the hip joint up a bit, the knee joint up half as far, and the foot
    (toe) joint forward a bit on the *x* axis. The ankle joint is left at the origin.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将髋关节向上移动一点，膝关节向上移动一半的距离，并在*x*轴上将脚（脚趾）关节向前移动一点。踝关节保持在原点。
- en: '![How it works...](img/4657_05_06.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/4657_05_06.jpg)'
- en: Once we've set up the necessary locators, the user can then adjust their position
    to better match the specifics of the model to which the joints will be applied.
    Once that's been done, we can move on to creating joints and setting up the IK
    system, which we handle in the `setupIK` function.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置了必要的定位器，用户就可以调整它们的位置，以更好地匹配将要应用关节的模型的具体细节。完成这一步骤后，我们可以继续创建关节并设置IK系统，这我们在`setupIK`函数中处理。
- en: 'First off, we need to invoke our global variables so that we can grab the positions
    of the locators and create bones at the positions of each one. We also clear out
    our selection, just to be on the safe side. We''re about to create bones and we
    don''t want our newly created joints to be children of any joints that might be
    selected when the user runs this part of the script. Once again, we use the global
    keyword to specify that we mean the variables that are in global scope instead
    of local variables:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要调用全局变量，以便我们可以获取定位器的位置并在每个位置创建骨骼。我们也清除选择，以确保安全。我们即将创建骨骼，不希望新创建的关节成为用户运行此脚本部分时可能选择的任何关节的子级。再次使用全局关键字来指定我们指的是全局范围内的变量，而不是局部变量：
- en: '[PRE42]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Once we've done all this, we're ready to make the bones. For each bone, we'll
    need to first determine the world-space position of each of our locators, which
    we can do with the `xform` command. By calling xform in the query mode, we'll
    retrieve, rather than set, the position of our locators. We'll also make sure
    to set the `worldSpace` flag to true to get the true (world space) position of
    the locators, rather than their local position.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 完成所有这些后，我们就可以开始创建骨骼了。对于每根骨骼，我们首先需要确定每个定位器的世界空间位置，这可以通过`xform`命令来完成。通过以查询模式调用xform，我们将检索而不是设置定位器的位置。我们还将确保将`worldSpace`标志设置为true，以获取定位器的真实（世界空间）位置，而不是它们的位置。
- en: 'We''ll start with the hip locator and work our way down our list of locators,
    grabbing each one''s location and feeding it into the `joint` command to create
    the bone:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从髋关节定位器开始，逐个处理我们的定位器列表，获取每个定位器的位置并将其输入到`joint`命令中以创建骨骼：
- en: '[PRE43]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Once again, we rely on Maya's default behavior of automatically connecting joints
    to build the skeleton. Once all the joints have been created, we can finally create
    the IK system.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们依赖于Maya的默认行为，即自动连接关节来构建骨骼。一旦所有关节都创建完成，我们最终可以创建逆运动学系统。
- en: 'Setting up IK is actually really straightforward; all we have to do it to call
    the `ikHandle` command and specify the appropriate start and end joints with the
    `startJoint` and `endEffector` flags. In our case, we''ll want the IK system to
    run from the hip to the ankle. Translating that into code ends up looking like
    the following:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 设置逆运动学实际上非常简单；我们只需要调用`ikHandle`命令，并使用`startJoint`和`endEffector`标志指定适当的起始和结束关节。在我们的例子中，我们希望逆运动学系统从臀部运行到脚踝。将其转换为代码看起来如下：
- en: '[PRE44]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Once we've done this, we'll be left with a brand new IK system.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成这个步骤，我们将拥有一个全新的逆运动学（IK）系统。
- en: There's more...
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Although this example covers the basics of creating a joint chain from locators
    and adding an IK handle, there are a number of additional things needed to finish
    it off. To set up a real IK system, you'll likely want to constrain the behavior
    of each of the joints in the chain (knee joints, for example, should only rotate
    around a single axis).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个例子涵盖了从定位器创建关节链并添加逆运动学手柄的基本方法，但还需要做许多其他事情才能完成。为了设置一个真正的逆运动学系统，你可能会想要约束链中每个关节的行为（例如，膝盖关节应该只围绕一个轴旋转）。
- en: Properly constraining the joints in an IK system generally involves at least
    two things—locking attributes that shouldn't rotate at all and setting limits
    on the axes that *should* rotate so that a joint that should be a knee doesn't
    bend in the wrong direction.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 正确约束逆运动学系统中的关节通常至少涉及两件事——锁定那些根本不应该旋转的属性，以及设置应该旋转的轴的限制，以便一个应该是膝盖的关节不会向错误的方向弯曲。
- en: 'To prevent a joint from rotating at all around a given axis, we can set the
    relevant `jointType` attribute to 0 to completely disable rotation around that
    axis. For example, if we wanted to make sure that our knee joint is prevented
    from rotating around either the *x* or *y* axes, we could do the following:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 要防止关节在给定的轴上旋转，我们可以将相关的`jointType`属性设置为0，以完全禁用该轴的旋转。例如，如果我们想确保我们的膝盖关节不会绕*x*或*y*轴旋转，我们可以做以下操作：
- en: '[PRE45]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This will completely prevent any rotation around the *x* and *y* axes. For the
    remaining axis (*z*, in this case), we would likely want to limit the rotation
    to a specific range. For this, we could use the `transformLimits` command, which
    will allow us to set minimum and maximum values for rotation.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这将完全防止任何绕*x*和*y*轴的旋转。对于剩余的轴（在本例中为*z*轴），我们可能希望限制旋转到特定的范围。为此，我们可以使用`transformLimits`命令，它将允许我们设置旋转的最小值和最大值。
- en: To make use of the `transformLimits` command, we'll need to not only specify
    the specific minimum and maximums, but we'll also need to enable the limits. This
    is similar to what one sees when setting joint limits in the attribute editor,
    that is, the values for the minimums and maximums don't actually apply unless
    you've *also* clicked the checkboxes to enable limits.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`transformLimits`命令，我们不仅需要指定特定的最小值和最大值，还需要启用限制。这类似于在属性编辑器中设置关节限制时所见到的，也就是说，除非你*也*点击了复选框来启用限制，否则最小值和最大值实际上并不适用。
- en: 'Let''s say that we wanted the knee to only rotate from -90 to 0 degrees. We
    could set that up with the following line of code:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们希望膝盖只能从-90度旋转到0度。我们可以通过以下代码行来设置：
- en: '[PRE46]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The `rotationZ` flag in the preceding code is used to set the minimum and maximum
    values for the given node. The `enableRotationZ` is somewhat confusingly named,
    in that it really controls the setting of rotation *limits*. So, passing (1, 1)
    into `enableRotationZ` means that we''re enabling limits for both the minimum
    and maximum values. If we wanted to only have a minimum (but no maximum) value,
    we could do the following instead:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`rotationZ`标志用于设置给定节点的最小值和最大值。`enableRotationZ`的命名有些令人困惑，因为它实际上控制的是旋转*限制*的设置。因此，将（1，1）传递给`enableRotationZ`意味着我们正在启用最小值和最大值的限制。如果我们只想有一个最小值（但没有最大值），我们可以做以下操作：
- en: '[PRE47]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In the preceding code, the (1,0) passed to `enableRotationZ` would both enable
    a minimum limit and disable the maximum.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，传递给`enableRotationZ`的（1，0）将同时启用最小限制并禁用最大限制。
