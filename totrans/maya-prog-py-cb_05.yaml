- en: Chapter 5. Adding Controls – Scripting for Rigging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter will cover how to use Python to build rigs by:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating skeletons with script
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up set-driven key relationships with script
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding custom attributes and locking and hiding attributes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up inverse kinematics (IK) with script
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you've created your model, laid out the UVs, and set up the shading networks,
    you'll still need to build controls into it if you want it to move. In this chapter,
    we'll be looking at how to do that with scripts.
  prefs: []
  type: TYPE_NORMAL
- en: We'll be looking at how to use Python to automate tasks related to rigging.
    Rigging is already one of the more technical aspects of 3D animation, and as such
    lends itself quite well to a script-based approach.
  prefs: []
  type: TYPE_NORMAL
- en: Creating skeletons with script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we'll be looking at how to create skeletons with script. We'll
    create two examples, one simple chain of bones and one branching set, similar
    to what you might want for a creature's hand.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new file and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Run this code, and you'll see two separate networks of bones, both centered
    at the origin—one that is a straight vertical chain of five bones and one that
    approximates a hand (five fingers with three joints each).
  prefs: []
  type: TYPE_NORMAL
- en: The end result should look something like the following (shown after moving
    the two skeletons apart).
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/4657_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll start with the `createSimpleSkeleton` command. Note that we start the
    function with a triple-quoted comment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: By placing a comment as the very first thing in the function definition, Python
    will recognize it as a *docstring*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Docstrings are a great way to provide documentation to the end user about what
    your code does and how it should be used. If you''ve added docstrings to your
    functions, the user will be able to view them with the help command. For example,
    let''s say we have a file named `myFunctions.py` with a handful of functions,
    and we start the first one in the following manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The user could use the following command to view our description for functionOne:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note the use of dot syntax to specify first the module (Python treats all files
    as modules) then the specific function within it. Also note that there aren't
    any parentheses after the name of the function; that's because we're not calling
    the function. Instead, we're passing the function into the help command, which
    will cause Python to output the docstring for that function, if one exists.
  prefs: []
  type: TYPE_NORMAL
- en: Docstrings can also be used to provide documentation for classes and modules.
    In either case, make sure that the docstring is the first thing to appear in the
    class, function, or file, either directly after "def [functionName]", as we've
    done here, after "class [className]:" (for classes), or at the top of the file
    (for modules).
  prefs: []
  type: TYPE_NORMAL
- en: When adding docstrings, it's generally a good practice to describe each of the
    inputs to the function and what they signify. In this case, our function has a
    single input, which will specify the number of bones to create.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve properly documented our code, it''s time to actually make some
    bones. The bulk of the work is done using the joint tool to create a new bone
    using the position/p flag to specify where it should go, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In our first example, we make things slightly easier on ourselves by creating
    an array to hold the position of the bones and passing that in to each successive
    call to the joint command. This way, we can easily just modify the Y position
    of the joints that we create, while keeping the X and Z coordinates the same to
    produce a vertical chain of bones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We also create an array to hold the output of the joint command after each
    bone is created in order to allow us to take further actions on the bones once
    they''ve been created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have both of those, we simply run through a loop, changing the second
    element of our pos array to alter the Y-value and creating a new joint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The most notable thing about the this is what we're *not* doing. Note that this
    code merely creates bones; it does nothing to explicitly create any sort of hierarchy
    between them. Nevertheless, the preceding code will result in a proper chain of
    bones, with each one a child of the previous bone.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is due to the fact that, when creating bones, Maya will automatically
    make any newly created joint a child of the currently selected object, if that
    object happens to be a joint. That, combined with the fact that all of Maya''s
    commands that result in the creation of a new object leave that new object selected
    means that, as we build up the chain of joints, Maya automatically connects them
    into the proper hierarchy. This also explains why the first line of the function
    was:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This ensured that nothing was selected. When creating new joint networks, it
    is always good to make sure that your selection is clear before starting; otherwise,
    you may end up with connections that you don't want.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve looked at making a simple chain of bones, we''ll move on to
    a slightly more complex example in the `createHand` function. Once again, we''ll
    add a docstring at the start of the function to properly document the inputs to
    the function and the effects of each:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We start by creating a single joint to be the root bone and saving it in the
    `baseJoint` variable, so we can easily refer to it again later.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We'll also make sure to give our new bone a sensible name. In this case, we'll
    use "wrist" since it will be serving as the parent bone for all of our fingers.
    You might be wondering why we're setting the name *and* storing the result into
    a variable. That is necessary in order to avoid problems if there is already something
    named "wrist" in our scene. If there *is* something named "wrist", then Maya would
    append a number onto the name of the newly created bone, resulting in something
    like "wrist1". If we later tried to do something to "wrist", we would end up affecting
    a different object. So, we have to do two things; we'll store the output of the
    joint command into a variable so that we can refer to it later *and* we give it
    a name so that it's nicer to work with.
  prefs: []
  type: TYPE_NORMAL
- en: Having all of the bones in your rig named "jointX" is a great way to make things
    unnecessarily confusing, so always be sure to give your bones proper names; just
    don't trust those names to always be unique.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our base bone, we create a few variables to control the layout
    of the "hand"—one for the length of the palm, one for the length of each finger
    joint, and one for the gap between each finger.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/4657_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now we're ready to create each finger. We start each pass through the loop by
    first selecting the baseJoint bone. That's all we need to do in order to make
    sure that we have the proper hierarchy, with each finger having a separate chain
    and each chain being parented to the base joint.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start each finger with a joint that is palmLen units above the base joint.
    The horizontal spacing is a little more involved and requires some explanation.
    We have the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two parts to the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This will ensure that the fingers are spaced out horizontally by the proper
    amount, but if we left it at that, we would have all of the fingers to the right
    of the wrist. To fix this, we need to move all of our positions to the left by
    one half of the total width. The total width is equal to our fingerSpacing variable
    multiplied by the number of gaps between the fingers. Since the number of gaps
    is equal to the number of fingers, minus one, we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Subtracting the second part from the first will keep the finger-to-finger spacing
    the same, but will move everything such that the fingers are centered over the
    based joint.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the proper position for the base of our "finger", we create
    the first joint, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note that we use the string format command to build up the name of the joint
    from some literals and the number of the finger we're on at the moment (adding
    one so that the first finger is a more readable "1" instead of "0"). This will
    give us joints named along the lines of "finger1base", "finger2base", and so on.
    We'll do something similar with the successive joints to name them with both the
    name of the finger and the name of the joint ("finger1joint1", for example).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we''ve started the finger, we run through another loop to create each
    of the finger joints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note that there's one small difference with this, in that we're passing what
    appears to be the same position in to the joint command. That still works because
    we're also using the `relative` command, which will cause Maya to position the
    new bone relative to its immediate parent. In this case, this means that each
    new bone will be created `jointLen` units above the previous one.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to create branching skeletons, it is necessary to change the currently
    selected bone before creating child bones. In the preceding example, we did that
    directly, by explicitly selecting our base joint again before starting each new
    branch.
  prefs: []
  type: TYPE_NORMAL
- en: That's not the only way though you can also use the `pickWalk` command. The
    `pickWalk` command operates on the current selection and allows you to move around
    its hierarchy. To use the command, you have to specify a direction—up, down, left,
    or right. The most useful options are up, which will change the selection to be
    the parent of the currently selected node, and down, which will change the selection
    to a child of the currently selected node (assuming it has children). So, another
    option to create a branching network of joints would be
  prefs: []
  type: TYPE_NORMAL
- en: 'to import maya.cmds as cmds, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The first two lines create a base bone and add a child bone one unit up and
    to the left. Then, the `pickWalk` command is used to move the selection back to
    the base joint before creating a third bone.
  prefs: []
  type: TYPE_NORMAL
- en: The results of creating three bones in sequence. The left image indicates what
    happens if pickWalk is used to move back up the hierarchy after creating the second,
    and the right image indicates what happens if pickWalk is omitted.
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more...](img/4657_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Setting up set-driven key relationships with script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A great deal of rigging is nothing more than setting up connections between
    attributes. Sometimes, those connections can be very direct, such as making sure
    that two joints are always in exactly the same position in world space, but in
    other times, something other than a direct one-to-one mapping is called for.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few different ways to connect attributes in non-linear ways, including
    using Maya's set-driven key capability to map one arbitrary range of an attribute
    onto a different arbitrary range of another. In this example, we'll be looking
    at how to set that up with scripting.
  prefs: []
  type: TYPE_NORMAL
- en: Our example will set up the "Hello World" equivalent for using a set-driven
    key, a finger that curls all of its joints smoothly at the same time, allowing
    the animator to keyframe a single attribute per finger instead of three (or possibly
    even more).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this example, you'll want to have a simple chain of at least three bones.
    The output of the script will cause all of the bones downstream from the selected
    bone to rotate when the parent bone (the knuckle) is rotated. Either create a
    simple chain of bones, or use the output from this chapter's example on bone creation.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new script and enter the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have the script ready, select the "knuckle" bone and run it. Then,
    try rotating the knuckle bone around the *z* axis. You should see all of the bones
    downstream from the knuckle rotate as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[fig setDrivenKey_1]'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are two main aspects to the script—the actual set-driven key setup and
    some code to walk down the chain of bones.
  prefs: []
  type: TYPE_NORMAL
- en: First off, we start by grabbing the currently selected object, as we've done
    in the past.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We store the selected object to a variable (baseJoint) so that we can easily
    refer to it later. We'll also want an easy way to refer to the driver attribute,
    in this case, the Z-rotation of the base bone, so we store that to a variable
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we''re ready to start stepping through our chain of bones. To do this,
    we''ll need to first grab a list of all of the downstream bones from the selected
    joint. We can do that using the `listRelatives` command with the children flag.
    Normally, that would only use the direct children of the given node, but if we
    also set the `allDescendents` flag to True, we will be given the full list of
    children, grandchildren, and so on down the entire hierarchy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have a list of all of the nodes that are children of the selected
    node (in this case, our base joint), we're ready to step through the list and
    set up a set-driven key relationship on each. To do this, we'll use the `setDrivenKeyframe`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: 'In each iteration through our loop, we''ll:'
  prefs: []
  type: TYPE_NORMAL
- en: Set our `driven` variable to the proper attribute (bone + ".rotateZ").
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the value of our driven attribute using setAttr to its minimum value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `setDrivenKeyframe` command to link the two attributes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat steps 2 and 3 to set the maximum values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `setDrivenKeyframe` command is fairly straightforward, requiring that we
    pass in the driver attribute, the driven attribute, and the values for each. In
    both cases, the attributes in question need to be the full name (node name, ".",
    and attribute name). So, to set it up so that our driven attribute is at 0 when
    our driver attribute is at -10, we could use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This should be enough to get the results we want, but the command can often
    fail unless the driver value is explicitly set beforehand. That's why, we use
    `setAttr` before calling `setDrivenKeyframe`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `setAttr` command is a real workhorse, and it is the one that you''re likely
    to use in a great deal of different scenarios. Luckily, it''s also very easy to
    use; just call it and pass in first the attribute you''re setting, then the value
    to which you want to set it, as in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we''ve set at least two keys on each bone, we''ll have a proper set-driven
    key relationship. Putting this all together gives us the following loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we'll finish off the script with a little bit of cleanup to ensure
    that we leave things as we found them. In this case, it means setting the driver
    value back to zero.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the preceding example, we used only two keyframes, but you can certainly
    have more than two points on the graph relating the driven variable to the driver
    if you wanted to have a more non-linear relationship between the attributes. For
    example, if we wanted to have the driven variable change at a greater rate during
    the last third of the range, we could do something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In this code, the first twenty units of change in the driver (0–20) would result
    in only 10 units of change in the driven (0–10), but the last 10 units of change
    in the driver (20–30) would drive a 20-unit change in the driven attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing you might want to consider is what kind of curve you want to create.
    Each of the keyframes added with `setDrivenKeyframe` can be given its own tangent
    types, for both the input and output. To do it, set either the `inTangentType`
    or `outTangentType` when calling the function. In either case, you'll want to
    give it a string representing the tangent type you want.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, if we wanted to have linear tangents for both the input and output of a
    new driven keyframe, we could do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: For a full list of the allowed options, consult the documentation for the `setDrivenKe`
    `yframe` command.
  prefs: []
  type: TYPE_NORMAL
- en: Adding custom attributes and locking and hiding attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you build up the rig for a model, it is often helpful to create custom attributes
    so that you can link things to `forefingerRight.curl` (for example), instead of
    `forefingerRight.rotateZ`. Not only will that make your rigs a great deal easier
    to understand, but it also allows you to tie actions of the rig to values that
    are completely independent of any built-in affects such as rotation or translation.
  prefs: []
  type: TYPE_NORMAL
- en: Just as there are sometimes attributes that you will want to add to a given
    node, there are often attributes on a node that you know you'll never want to
    animate. Locking such attributes and hiding them in the channel box is another
    way to make your rigs easier to work with.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we'll be looking at how to do both things—adding new, custom
    attributes to a node and hiding undesirable or unimportant attributes from view.
    More specifically, we'll be hiding the rotation and scale attributes and adding
    some attributes of the sort that you might want in order to animate a facial rig.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a screenshot of the channel box both before and after the example script
    is run:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding custom attributes and locking and hiding attributes](img/4657_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before adding to or altering the attributes on a node, it's important to determine
    exactly what you need. In this case, we'll be setting things up in a way similar
    to what we might want for control of a facial rig. This means for the node itself,
    we'll likely want to be able to change its position, but not the rotation or scale.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll also want to add several different attributes to control the parts of
    our rig. These will naturally vary from rig to rig, but in all cases, it''s necessary
    to think about what kind of data we need for each. For the sake of the example,
    let''s say that we want the following controls:'
  prefs: []
  type: TYPE_NORMAL
- en: A "blink" attribute, which will cause both eyelids to close and open.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An "IK/FK" switch control for each of the legs that can switch between IK and
    FK controls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For each of these, we'll need to think about what kind of data we need. For
    the blink attribute, we want a number that can vary smoothly from one value (representing
    fully open) to another (representing fully closed). For that, we'll need a decimal
    number.
  prefs: []
  type: TYPE_NORMAL
- en: For the IK/FK switch, we could approach it in two different ways. We could have
    a value that represents whether IK is on, with "off" meaning that FK is currently
    being used. For that, we would want to use a simple on/off value. Alternatively,
    we could implement our IK/FK switch as a dropdown of options. That would likely
    be a better and more user-friendly way to go. In this example, we'll be implementing
    both approaches for the sake of completeness.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new file and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Select an object and run the preceding script, making sure that you have the
    channel box visible when you do so. You should see the rotation and scale attributes
    disappear and the new attributes appear.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First off, we grab the currently selected object, just as we''ve done in the
    past. Once we''ve done that, we start by adding the blink attribute with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a fairly involved command, but the general idea is that we specify
    the following for each attribute we want to add:'
  prefs: []
  type: TYPE_NORMAL
- en: The name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The type of attribute
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any additional information that the specific type of attribute requires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The names of attributes come in two flavors—the short name and the long name.
    You have to specify at least one of those to have the command work, but it's generally
    a good idea to specify both. In this case, "blink" is sufficiently short to use
    it for both the short and long versions.
  prefs: []
  type: TYPE_NORMAL
- en: If we don't directly specify the type of attribute we're creating, Maya will
    default to a numerical type, which happens to be exactly what we want for the
    blink attribute. Since a "blink" attribute has a natural upper and lower bound
    (since eyelids open by a finite amount), it also makes sense to give our attribute
    minimum and maximum values, with the default being in between. Here, we're using
    -1 and 1 for the minimum and maximum, which is fairly standard.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, in order to ensure that our new attribute shows up in the channel box,
    we need to make sure that we set the `keyable` flag to true.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up is our simple on/off version of the IK/FK switch. For this, we''ll
    be using a Boolean type. For non-numeric types, we''ll need to use the `attributeType`
    flag with the appropriate value (in this case, "bool"). We still specify the short
    and long names, and use the `keyable` flag to make it appear in the channel box:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The resulting attribute will accept values of either 0 or 1, but will display
    them as "off" or "on" (respectfully) in the channel box.
  prefs: []
  type: TYPE_NORMAL
- en: For our final attribute, we'll create one with two possible states, either "IK"
    or "FK", presented to the user as a drop-down list. For that, we'll create an
    attribute of type "enum" (short for "enumerated list"). We'll also need to specify
    the specific options that we want with the `enumName` flag. The `enumName` flag
    expects a string containing one or more options, all separated with colons.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in order to have "IK" and "FK" options, we''ll want the value of our `enumName`
    flag to be "IK:FK". Putting this all together gives us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that, in order to actually hook our new attribute up to anything, it''s
    important to know what the actual values of each option are. By default, the first
    option will have a value of 0, with each successive option increasing by one.
    So, in this case, "IK" will correspond to 0 and "FK" will correspond to 1\. If
    you want to have specific numerical values for specific options, that''s also
    possible. For example, if we wanted "IK" to correspond to 5 and "FK" to 23, we
    could do that with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we''re all done adding attributes and can move on to hiding
    the ones we don''t want—the rotation and scale attributes. We''ll want to do three
    separate things to properly hide each attribute, namely:'
  prefs: []
  type: TYPE_NORMAL
- en: Lock the attribute so that its value cannot be changed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the attribute to not be keyable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the attribute to not appear in the channel box.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'All of these can be accomplished with the `setAttr` command, used in the edit
    mode, as in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Note that the first thing we pass in to setAttr is the full name of the attribute
    (object name and attribute name, joined by a "."). That can be a little tedious
    to do each time though, so we create a function that accepts the object and attribute
    name, and locks and hides it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then use a bit of Python''s built-in functionality to make it even easier
    to lock a list of attributes by iterating over a list of attribute names and passing
    them to our `lockAndHide` function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In this case, Python's approach to for loops (iterating over a list) makes things
    very straightforward, indeed.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you look at the documentation for the `addAttr` command, you'll see that
    there is an extensive list of attribute types. Don't let the length of that list
    scare you; the vast majority of attributes you're likely to want to add can be
    implemented as the default (double) type with the appropriate minimum and maximum
    values. "Double" in this context is short for "double precision" meaning a decimal
    value that uses twice the number of bytes as a typical float.
  prefs: []
  type: TYPE_NORMAL
- en: While the several different flavors of integer and floating-point numeric values
    aren't likely to make much of a difference in your scripts, a few of the more
    esoteric types may come in handy.
  prefs: []
  type: TYPE_NORMAL
- en: One thing you might find useful is the ability to add a color attribute to a
    node. Adding a color requires adding a compound attribute, which is a little bit
    more involved than what we've seen so far. First, you need to add an attribute
    to serve as the parent, then you'll need to add successive child attributes, of
    the same type and of the right number as the parent attribute's type.
  prefs: []
  type: TYPE_NORMAL
- en: For a color, we'll need to use an attribute type with three values for the parent,
    such as "float3". We'll also want to set the `usedAsColor` flag to true so that
    it is properly recognized as a color by Maya.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we''ve done that, we can add attributes for each component of the parent
    attribute (in this case, values for the red, green, and blue components). Note
    the use of the parent flag to properly tie the new attributes to our "colorTest"
    group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Note that some types of attributes won't display in the channel box. To see
    such attributes, select the node they've been added to, open the attribute editor,
    and expand the "extra attributes" tab.
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more...](img/4657_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Setting up inverse kinematics (IK) with script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While it is very likely that any given model will require at least some custom
    rigging work, it can often be helpful to automate the setup of common subcomponents
    that occur frequently in many different rigs. In this example, we'll be doing
    just that and setting up a simple inverse kinematics (IK) system with code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although our example will be simple, it will still demonstrate a common issue—the
    need to accurately position joints to match the specific proportions of a model.
    As such, the script will have the following two distinct parts:'
  prefs: []
  type: TYPE_NORMAL
- en: A preliminary step, where we create locators representing where the various
    joints will be created.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A secondary step, where we build a skeleton and set up its attributes based
    on the position of the locators.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By breaking the script into two parts, we allow the user to alter the positions
    of the locators after they've been created, but before the actual skeleton has
    been set up. This tends to be a much more effective way to match rigs to characters,
    and there can also be a great way to solicit input from the user for other kinds
    of tasks as well.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While you running the example script doesn't require having a suitable model,
    you might enjoy it more if you have a bipedal model to fit the joints we'll be
    creating to.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new script and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since this script requires two separate parts, we''ll need to implement a simple
    UI in order to allow the user to run the first part, alter the positions of the
    locators, and invoke the second. The UI isn''t anything complicated, but just
    two buttons, and should look familiar if you''ve worked through any of the examples
    in [Chapter 2](ch02.html "Chapter 2. Creating User Interfaces"), *Creating User
    Interfaces*. We simply create a window, add a layout, and add one button for each
    of the steps of our script. We have the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The things start to get interesting in the `makeLocators` function, which will
    create four locator objects in a default layout. Before creating the locators,
    we''ll create four global variables so that we can store references to them for
    later use. The `global` keyword tells Python that these variables should be treated
    as global in scope, meaning that they will be available beyond the immediate,
    local scope (in this case, the `makeLocators` function). Later on, we''ll invoke
    the global variables again from within our second function (the `setupIK` function)
    in order to refer to the locators we''re about to create:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Now we're ready to create the locators. Locators are especially useful for rigging
    because they provide a bare-bones transform node that is nonrenderable, but easily
    selectable in Maya's interface.
  prefs: []
  type: TYPE_NORMAL
- en: To make a locator, we can use the `spaceLocator` command. We'll use the name
    flag to set the name of created locator, but this is mainly just to make things
    nice for the end user.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although it is sometimes nice to give created nodes names, you should never
    rely on those names for later reference, as there's no guarantee that the name
    you specify is the name that the object will end up with. If you name something
    `myObject`, but there's already a node in your scene by that name, Maya will force
    the newly created object to be named `myObject1`, and any code that you wrote
    referencing `myObject` would be pointed at the wrong thing. Never, ever, trust
    names in Maya; instead store the output of commands that create nodes to variables
    and use those variables to refer to the created objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll create four locators in total, one each for the hip, knee, ankle, and
    toe of a simple leg. The output of each of our calls to the `spaceLocator` command
    is saved to one of our global variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: If you look at the documentation for the `spaceLocator` command, you'll see
    that there is a `position` flag that can be used to set the position of the created
    locator. However, note that we're not using that flag in the previous code. This's
    because while the locator will appear to be at the specified position, the pivot
    point for the locator will remain at the origin. Since we're creating the locators
    specifically to use them to grab positions in world space, which makes things
    difficult for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s an easy workaround, though we''ll just leave the position unspecified,
    which will cause both the locator and its pivot to be at the origin, then use
    the `xform` (short for "transform") command to set the position of each locator
    to a reasonable starting position. This ends up looking like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The `xform` command can be used in several different ways, all related to querying
    or altering the transform (position, rotation, and scale) values of nodes. In
    this case, we're using it to set the translation of the locators to set values.
    We also set the absolute flag to true to indicate that the values represent where
    the locator should be moved to in absolute coordinates (as opposed to a relative
    displacement from its current position).
  prefs: []
  type: TYPE_NORMAL
- en: We move the hip joint up a bit, the knee joint up half as far, and the foot
    (toe) joint forward a bit on the *x* axis. The ankle joint is left at the origin.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/4657_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Once we've set up the necessary locators, the user can then adjust their position
    to better match the specifics of the model to which the joints will be applied.
    Once that's been done, we can move on to creating joints and setting up the IK
    system, which we handle in the `setupIK` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'First off, we need to invoke our global variables so that we can grab the positions
    of the locators and create bones at the positions of each one. We also clear out
    our selection, just to be on the safe side. We''re about to create bones and we
    don''t want our newly created joints to be children of any joints that might be
    selected when the user runs this part of the script. Once again, we use the global
    keyword to specify that we mean the variables that are in global scope instead
    of local variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Once we've done all this, we're ready to make the bones. For each bone, we'll
    need to first determine the world-space position of each of our locators, which
    we can do with the `xform` command. By calling xform in the query mode, we'll
    retrieve, rather than set, the position of our locators. We'll also make sure
    to set the `worldSpace` flag to true to get the true (world space) position of
    the locators, rather than their local position.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start with the hip locator and work our way down our list of locators,
    grabbing each one''s location and feeding it into the `joint` command to create
    the bone:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Once again, we rely on Maya's default behavior of automatically connecting joints
    to build the skeleton. Once all the joints have been created, we can finally create
    the IK system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting up IK is actually really straightforward; all we have to do it to call
    the `ikHandle` command and specify the appropriate start and end joints with the
    `startJoint` and `endEffector` flags. In our case, we''ll want the IK system to
    run from the hip to the ankle. Translating that into code ends up looking like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Once we've done this, we'll be left with a brand new IK system.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although this example covers the basics of creating a joint chain from locators
    and adding an IK handle, there are a number of additional things needed to finish
    it off. To set up a real IK system, you'll likely want to constrain the behavior
    of each of the joints in the chain (knee joints, for example, should only rotate
    around a single axis).
  prefs: []
  type: TYPE_NORMAL
- en: Properly constraining the joints in an IK system generally involves at least
    two things—locking attributes that shouldn't rotate at all and setting limits
    on the axes that *should* rotate so that a joint that should be a knee doesn't
    bend in the wrong direction.
  prefs: []
  type: TYPE_NORMAL
- en: 'To prevent a joint from rotating at all around a given axis, we can set the
    relevant `jointType` attribute to 0 to completely disable rotation around that
    axis. For example, if we wanted to make sure that our knee joint is prevented
    from rotating around either the *x* or *y* axes, we could do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This will completely prevent any rotation around the *x* and *y* axes. For the
    remaining axis (*z*, in this case), we would likely want to limit the rotation
    to a specific range. For this, we could use the `transformLimits` command, which
    will allow us to set minimum and maximum values for rotation.
  prefs: []
  type: TYPE_NORMAL
- en: To make use of the `transformLimits` command, we'll need to not only specify
    the specific minimum and maximums, but we'll also need to enable the limits. This
    is similar to what one sees when setting joint limits in the attribute editor,
    that is, the values for the minimums and maximums don't actually apply unless
    you've *also* clicked the checkboxes to enable limits.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say that we wanted the knee to only rotate from -90 to 0 degrees. We
    could set that up with the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The `rotationZ` flag in the preceding code is used to set the minimum and maximum
    values for the given node. The `enableRotationZ` is somewhat confusingly named,
    in that it really controls the setting of rotation *limits*. So, passing (1, 1)
    into `enableRotationZ` means that we''re enabling limits for both the minimum
    and maximum values. If we wanted to only have a minimum (but no maximum) value,
    we could do the following instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the (1,0) passed to `enableRotationZ` would both enable
    a minimum limit and disable the maximum.
  prefs: []
  type: TYPE_NORMAL
