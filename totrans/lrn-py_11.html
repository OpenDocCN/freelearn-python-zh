<html><head></head><body><div class="chapter" title="Chapter&#xA0;11.&#xA0;Debugging and Troubleshooting"><div class="titlepage"><div><div><h1 class="title"><a id="ch11"/>Chapter 11. Debugging and Troubleshooting</h1></div></div></div><div class="blockquote"><table border="0" width="100%" cellspacing="0" cellpadding="0" class="blockquote" summary="Block quote"><tr><td valign="top"> </td><td valign="top"><p><span class="emphasis"><em>"If debugging is the process of removing software bugs, then programming must be the process of putting them in."</em></span></p></td><td valign="top"> </td></tr><tr><td valign="top"> </td><td colspan="2" align="right" valign="top" style="text-align: center">--<span class="attribution"><span class="emphasis"><em>Edsger W. Dijkstra</em></span></span></td></tr></table></div><p>In the life of a professional coder, debugging and troubleshooting take up a significant amount of time. Even if you work on the most beautiful codebase ever written by man, there will still be bugs in it, that is guaranteed.</p><p>We spend an awful lot of time reading other people's code and, in my opinion, a good software developer is someone who keeps their attention high, even when they're reading code that is not reported to be wrong or buggy.</p><p>Being able to debug code efficiently and quickly is a skill that any coder needs to keep improving. Some think that because they have read the manual, they're fine, but the reality is, the number of variables in the game is so big that there is no manual. There are guidelines that one can follow, but there is no magic book that will teach you everything you need to know in order to become good at this.</p><p>I feel that on this particular subject, I have learned the most from my colleagues. It amazes me to observe someone very skilled attacking a problem. I enjoy seeing the steps they take, the things they verify to exclude possible causes, and the way they consider the suspects that eventually lead them to the solution to the problem.</p><p>Every colleague we work with can teach us something, or surprise us with a fantastic guess that turns out to be the right one. When that happens, don't just remain in wonderment (or worse, in envy), but seize the moment and ask them how they got to that guess and why. The answer will allow you to see if there is something you can study in deep later on so that, maybe next time, you'll be the one who will catch the bug.</p><p>Some bugs are very easy to spot. They come out of coarse mistakes and, once you see the effects of those mistakes, it's easy to find a solution that fixes the problem.</p><p>But there are other bugs which are much more subtle, much more slippery, and require true expertise, and a great deal of creativity and out-of-the-box thinking, to be dealt with.</p><p>The worst of all, at least for me, are the nondeterministic ones. These sometimes happen, and sometimes don't. Some happen only in environment A but not in environment B, even though A and B are supposed to be exactly the same. Those bugs are the true evil ones, and they can drive you crazy.</p><p>And of course, bugs don't just happen in the sandbox, right? With your boss telling you "<span class="emphasis"><em>don't worry! take your time to fix this, have lunch first!</em></span>". Nope. They happen on a Friday at half past five, when your brain is cooked and you just want to go home. It's in those moments, when everyone is getting upset in a split second, when your boss is breathing on your neck, that you have to be able to keep calm. And I do mean it. That's the most important skill to have if you want to be able to fight bugs effectively. If you allow your mind to get stressed, say goodbye to creative thinking, to logic deduction, and to everything you need at that moment. So take a deep breath, sit properly, and focus.</p><p>In this chapter, I will try to demonstrate some useful techniques that you can employ according to the severity of the bug, and a few suggestions that will hopefully boost your weapons against bugs and issues.</p><div class="section" title="Debugging techniques"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec82"/>Debugging techniques</h1></div></div></div><p>In <a id="id772" class="indexterm"/>this part, I'll present you with the most common techniques, the ones I use most often, however, please don't consider this list to be exhaustive.</p><div class="section" title="Debugging with print"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec126"/>Debugging with print</h2></div></div></div><p>This is <a id="id773" class="indexterm"/>probably the easiest technique of all. It's not very effective, it cannot be used everywhere and it requires access to both the source code and a terminal that will run it (and therefore show the results of the print function calls).</p><p>However, in many situations, this is still a quick and useful way to debug. For example, if you are developing a Django website and what happens in a page is not what would you expect, you can fill the view with prints and keep an eye on the console while you reload the page. I've probably done it a million times.</p><p>When you scatter calls to <code class="literal">print</code> in your code, you normally end up in a situation where you duplicate a lot of debugging code, either because you're printing a timestamp (like we did when we were measuring how fast list comprehensions and generators were), or because you have to somehow build a string of some sort that you want to display.</p><p>Another issue is that it's extremely easy to forget calls to <code class="literal">print</code> in your code.</p><p>So, for <a id="id774" class="indexterm"/>these reasons, rather than using a bare call to <code class="literal">print</code>, I sometimes prefer to code a custom function. Let's see how.</p></div><div class="section" title="Debugging with a custom function"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec127"/>Debugging with a custom function</h2></div></div></div><p>Having a custom function in a snippet that you can quickly grab and paste into the code, and then use to debug, can be very useful. If you're fast, you can always code one on the fly. The<a id="id775" class="indexterm"/> important thing is to code it in a way that it won't leave stuff around when you eventually remove the calls and its definition, therefore <span class="emphasis"><em>it's important to code it in a way that is completely self-contained</em></span>. Another good reason for this requirement is that it will avoid potential name clashes with the rest of the code.</p><p>Let's see an example of such a function.</p><p>
<code class="literal">custom.py</code>
</p><div class="informalexample"><pre class="programlisting">def debug(*msg, print_separator=True):
    print(*msg)
    if print_separator:
        print('-' * 40)

debug('Data is ...')
debug('Different', 'Strings', 'Are not a problem')
debug('After while loop', print_separator=False)</pre></div><p>In this case, I am using a keyword-only argument to be able to print a separator, which is a line of 40 dashes.</p><p>The function is very simple, I just redirect whatever is in <code class="literal">msg</code> to a call to <code class="literal">print</code> and, if <code class="literal">print_separator</code> is <code class="literal">True</code>, I print a line separator. Running the code will show:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python custom.py </strong></span>
<span class="strong"><strong>Data is ...</strong></span>
<span class="strong"><strong>----------------------------------------</strong></span>
<span class="strong"><strong>Different Strings Are not a problem</strong></span>
<span class="strong"><strong>----------------------------------------</strong></span>
<span class="strong"><strong>After while loop</strong></span>
</pre></div><p>As you can see, there is no separator after the last line.</p><p>This is just one easy way to somehow augment a simple call to the <code class="literal">print</code> function. Let's see how we can calculate a time difference between calls, using one of Python's tricky features to our advantage.</p><p>
<code class="literal">custom_timestamp.py</code>
</p><div class="informalexample"><pre class="programlisting">from time import sleep

def debug(*msg, timestamp=[None]):
    print(*msg)
    from time import time  # local import
    if timestamp[0] is None:
        <span class="strong"><strong>timestamp[0] = time()</strong></span>  #1
    else:
        now = time()
        print(' Time elapsed: {:.3f}s'.format(
            now - timestamp[0]))
        <span class="strong"><strong>timestamp[0] = now</strong></span>  #2

debug('Entering nasty piece of code...')
sleep(.3)
debug('First step done.')
sleep(.5)
debug('Second step done.')</pre></div><p>This<a id="id776" class="indexterm"/> is a bit trickier, but still quite simple. First notice we import the <code class="literal">time</code> function from the <code class="literal">time</code> module from the <code class="literal">debug</code> function. This allows us to avoid having to add that import outside of the function, and maybe forget it there.</p><p>Take a look at how I defined <code class="literal">timestamp</code>. It's a list, of course, but what's important here is that it is a <span class="emphasis"><em>mutable</em></span> object. This means that it will be set up when Python parses the function and it will retain its value throughout different calls. Therefore, if we put a timestamp in it after each call, we can keep track of time without having to use an external global variable. I borrowed this trick from my studies on <span class="strong"><strong>closures</strong></span>, a technique that I encourage you to read about because it's very interesting.</p><p>Right, so, after having printed whatever message we had to print and importing time, we then inspect the content of the only item in <code class="literal">timestamp</code>. If it is <code class="literal">None</code>, we have no previous reference, therefore we set the value to the current time (<code class="literal">#1</code>).</p><p>On the other hand, if we have a previous reference, we can calculate a difference (which we nicely format to three decimal digits) and then we finally put the current time again in <code class="literal">timestamp</code> (<code class="literal">#2</code>). It's a nice trick, isn't it?</p><p>Running this code shows this result:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python custom_timestamp.py </strong></span>
<span class="strong"><strong>Entering nasty piece of code...</strong></span>
<span class="strong"><strong>First step done.</strong></span>
<span class="strong"><strong> Time elapsed: 0.300s</strong></span>
<span class="strong"><strong>Second step done.</strong></span>
<span class="strong"><strong> Time elapsed: 0.501s</strong></span>
</pre></div><p>Whatever<a id="id777" class="indexterm"/> is your situation, having a self contained function like this can be very useful.</p></div><div class="section" title="Inspecting the traceback"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec128"/>Inspecting the traceback</h2></div></div></div><p>We <a id="id778" class="indexterm"/>briefly talked about the traceback in <a class="link" href="ch07.html" title="Chapter 7. Testing, Profiling, and Dealing with Exceptions">Chapter 7</a>, <span class="emphasis"><em>Testing, Profiling, and Dealing with Exceptions</em></span> when we saw several different kinds of exceptions. The traceback gives you information about what happened in your application that went wrong. You get a great help from reading it. Let's see a very small example:</p><p>
<code class="literal">traceback_simple.py</code>
</p><div class="informalexample"><pre class="programlisting">d = {'some': 'key'}
key = 'some-other'
print(d[key])</pre></div><p>We have a dict and we have tried to access a key which isn't in it. You should remember that this will raise a <code class="literal">KeyError</code> exception. Let's run the code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python traceback_simple.py </strong></span>
<span class="strong"><strong>Traceback (most recent call last):</strong></span>
<span class="strong"><strong>  File "traceback_simple.py", line 3, in &lt;module&gt;</strong></span>
<span class="strong"><strong>    print(d[key])</strong></span>
<span class="strong"><strong>KeyError: 'some-other'</strong></span>
</pre></div><p>You can see that we get all the information we need: the module name, the line that caused the error (both the number and the instruction), and the error itself. With this information, you can go back to the source code and try and understand what's going wrong.</p><p>Let's now create a more interesting example that builds on this, and exercises a feature that is only available in Python 3. Imagine that we're validating a dict, working on mandatory fields, therefore we expect them to be there. If not, we need to raise a custom <code class="literal">ValidationError</code>, that we will trap further upstream in the process that runs the validator (which is not shown here, it could be anything, really). It should be something like this:</p><p>
<code class="literal">traceback_validator.py</code>
</p><div class="informalexample"><pre class="programlisting">class ValidatorError(Exception):
    """Raised when accessing a dict results in KeyError. """

d = {'some': 'key'}
mandatory_key = 'some-other'
try:
    print(d[mandatory_key])
except KeyError:
    raise ValidatorError(
        '`{}` not found in d.'.format(mandatory_key))</pre></div><p>We define<a id="id779" class="indexterm"/> a custom exception that is raised when the mandatory key isn't there. Note that its body consists of its documentation string so we don't need to add any other statements.</p><p>Very simply, we define a dummy dict and try to access it using <code class="literal">mandatory_key</code>. We trap the <code class="literal">KeyError</code> and raise <code class="literal">ValidatorError</code> when that happens. The purpose of doing this is that we may also want to raise <code class="literal">ValidatorError</code> in other circumstances, not necessarily as a consequence of a mandatory key being missing. This technique allows us to run the validation in a simple <code class="literal">try</code>/<code class="literal">except</code> that only cares about <code class="literal">ValidatorError</code>.</p><p>The thing is, in Python 2, this code would just display the last exception (<code class="literal">ValidatorError</code>), which means we would lose the information about the <code class="literal">KeyError</code> that precedes it. In Python 3, this behavior has changed and exceptions are now chained so that you have a much better information report when something happens. The code produces this result:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python traceback_validator.py </strong></span>
<span class="strong"><strong>Traceback (most recent call last):</strong></span>
<span class="strong"><strong>  File "traceback_validator.py", line 7, in &lt;module&gt;</strong></span>
<span class="strong"><strong>    print(d[mandatory_key])</strong></span>
<span class="strong"><strong>KeyError: 'some-other'</strong></span>

<span class="strong"><strong>During handling of the above exception, another exception occurred:</strong></span>

<span class="strong"><strong>Traceback (most recent call last):</strong></span>
<span class="strong"><strong>  File "traceback_validator.py", line 10, in &lt;module&gt;</strong></span>
<span class="strong"><strong>    '`{}` not found in d.'.format(mandatory_key))</strong></span>
<span class="strong"><strong>__main__.ValidatorError: `some-other` not found in d.</strong></span>
</pre></div><p>This is brilliant, because we can see the traceback of the exception that led us to raise <code class="literal">ValidationError</code>, as well as the traceback for the <code class="literal">ValidationError</code> itself.</p><p>I had a nice discussion with one of my reviewers about the traceback you get from the <code class="literal">pip</code> installer. He was having trouble setting everything up in order to review the code for <a class="link" href="ch09.html" title="Chapter 9. Data Science">Chapter 9</a>, <span class="emphasis"><em>Data Science</em></span>. His fresh Ubuntu installation was missing a few libraries that were needed by the <code class="literal">pip</code> packages in order to run correctly.</p><p>The reason he was blocked was that he was trying to fix the errors displayed in the traceback starting from the top one. I suggested that he started from the bottom one instead, and fix that. The reason was that, if the installer had gotten to that last line, I guess that before that, whatever error may have occurred, it was still possible to recover from it. Only<a id="id780" class="indexterm"/> after the last line, <code class="literal">pip</code> decided it wasn't possible to continue any further, and therefore I started fixing that one. Once the libraries required to fix that error had been installed, everything else went smoothly.</p><p>Reading a traceback can be tricky, and my friend was lacking the necessary experience to address this problem correctly, therefore, if you end up in the same situation, don't be discouraged, and try to shake things up a bit, don't take anything for granted.</p><p>Python has a huge and wonderful community and it's very unlikely that, when you encounter a problem, you're the first one to see it, so open a browser and search. By doing so, your searching skills will also improve because you will have to trim the error down to the minimum but essential set of details that will make your search effective.</p><p>If you want to play and understand the traceback a bit better, in the standard library there is a module called, surprise surprise, <code class="literal">traceback</code> that you can use. It provides a standard interface to extract, format, and print stack traces of Python programs, mimicking exactly the behavior of the Python interpreter when it prints a stack trace.</p></div><div class="section" title="Using the Python debugger"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec129"/>Using the Python debugger</h2></div></div></div><p>Another <a id="id781" class="indexterm"/>very effective way of debugging Python is to use the Python debugger: <span class="strong"><strong>pdb</strong></span>. If you are addicted to the IPython console, like<a id="id782" class="indexterm"/> me, you should definitely check out the <span class="strong"><strong>ipdb</strong></span> library. <span class="emphasis"><em>ipdb</em></span> augments<a id="id783" class="indexterm"/> the standard <span class="emphasis"><em>pdb</em></span> interface like IPython does with the Python console.</p><p>There are several different ways of using this debugger (whichever version, it is not important), but the most common one consists of simply setting a breakpoint and running the code. When Python reaches the breakpoint, execution is suspended and you get console access to that point so that you can inspect all the names, and so on. You can also alter data on the fly to change the flow of the program.</p><p>As a toy example, let's pretend we have a parser that is raising a <code class="literal">KeyError</code> because a key is missing in a dict. The dict is from a JSON payload that we cannot control, and we just want, for the time being, to cheat and pass that control, since we're interested in what comes afterwards. Let's see how we could intercept this moment, inspect the data, fix it and get to the bottom, with <span class="emphasis"><em>ipdb</em></span>.</p><p>
<code class="literal">ipdebugger.py</code>
</p><div class="informalexample"><pre class="programlisting"># d comes from a JSON payload we don't control
d = {'first': 'v1', 'second': 'v2', 'fourth': 'v4'}
# keys also comes from a JSON payload we don't control
keys = ('first', 'second', 'third', 'fourth')

def do_something_with_value(value):
    print(value)

for key in keys:
    do_something_with_value(d[key])

print('Validation done.')</pre></div><p>As you<a id="id784" class="indexterm"/> can see, this code will break when <code class="literal">key</code> gets the value <code class="literal">'third'</code>, which is missing in the dict. Remember, we're pretending that both <code class="literal">d</code> and <code class="literal">keys</code> come dynamically from a JSON payload we don't control, so we need to inspect them in order to fix <code class="literal">d</code> and pass the <code class="literal">for</code> loop. If we run the code as it is, we get the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python ipdebugger.py </strong></span>
<span class="strong"><strong>v1</strong></span>
<span class="strong"><strong>v2</strong></span>
<span class="strong"><strong>Traceback (most recent call last):</strong></span>
<span class="strong"><strong>  File "ipdebugger.py", line 10, in &lt;module&gt;</strong></span>
<span class="strong"><strong>    do_something_with_value(d[key])</strong></span>
<span class="strong"><strong>KeyError: 'third'</strong></span>
</pre></div><p>So we see that that <code class="literal">key</code> is missing from the dict, but since every time we run this code we may get a different dict or <code class="literal">keys</code> tuple, this information doesn't really help us. Let's inject a call to <span class="emphasis"><em>ipdb</em></span>.</p><p>
<code class="literal">ipdebugger_ipdb.py</code>
</p><div class="informalexample"><pre class="programlisting"># d comes from a JSON payload we don't control
d = {'first': 'v1', 'second': 'v2', 'fourth': 'v4'}
# keys also comes from a JSON payload we don't control
keys = ('first', 'second', 'third', 'fourth')

def do_something_with_value(value):
    print(value)

<span class="strong"><strong>import ipdb</strong></span>
<span class="strong"><strong>ipdb.set_trace()  # we place a breakpoint here</strong></span>

for key in keys:
    do_something_with_value(d[key])

print('Validation done.')</pre></div><p>If we now run this code, things get interesting (note that your output may vary a little and that all the comments in this output were added by me):</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python ipdebugger_ipdb.py</strong></span>
<span class="strong"><strong>&gt; /home/fab/srv/l.p/ch11/ipdebugger_ipdb.py(12)&lt;module&gt;()</strong></span>
<span class="strong"><strong>     11 </strong></span>
<span class="strong"><strong>---&gt; 12 for key in keys:  # this is where the breakpoint comes</strong></span>
<span class="strong"><strong>     13     do_something_with_value(d[key])</strong></span>

<span class="strong"><strong>ipdb&gt; keys  # let's inspect the keys tuple</strong></span>
<span class="strong"><strong>('first', 'second', 'third', 'fourth')</strong></span>
<span class="strong"><strong>ipdb&gt; !d.keys()  # now the keys of d</strong></span>
<span class="strong"><strong>dict_keys(['first', 'fourth', 'second'])  # we miss 'third'</strong></span>
<span class="strong"><strong>ipdb&gt; !d['third'] = 'something dark side...'  # let's put it in</strong></span>
<span class="strong"><strong>ipdb&gt; c  # ... and continue</strong></span>
<span class="strong"><strong>v1</strong></span>
<span class="strong"><strong>v2</strong></span>
<span class="strong"><strong>something dark side...</strong></span>
<span class="strong"><strong>v4</strong></span>
<span class="strong"><strong>Validation done.</strong></span>
</pre></div><p>This is <a id="id785" class="indexterm"/>very interesting. First, note that, when you reach a breakpoint, you're served a console that tells you where you are (the Python module) and which line is the next one to be executed. You can, at this point, perform a bunch of exploratory actions, such as inspecting the code before and after the next line, printing a stacktrace, interacting with the objects, and so on. Please consult the official Python documentation on <span class="emphasis"><em>pdb</em></span> to learn more about this. In our case, we first inspect the <code class="literal">keys</code> tuple. After that, we inspect the keys of <code class="literal">d</code>.</p><p>Have you noticed that exclamation mark I prepended to <code class="literal">d</code>? It's needed because <code class="literal">d</code> is a command in the <span class="emphasis"><em>pdb</em></span> interface that moves the frame (<span class="emphasis"><em>d</em></span>)own.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note65"/>Note</h3><p>I indicate commands within the <span class="emphasis"><em>ipdb</em></span> shell with this notation: each command is activated by one letter, which typically is the first letter of the command name. So, <span class="emphasis"><em>d</em></span> for <span class="emphasis"><em>down</em></span>, <span class="emphasis"><em>n</em></span> for <span class="emphasis"><em>next</em></span>, and <span class="emphasis"><em>s</em></span> for <span class="emphasis"><em>step</em></span> become, more concisely, (<span class="emphasis"><em>d</em></span>)own, (<span class="emphasis"><em>n</em></span>)ext and (<span class="emphasis"><em>s</em></span>)tep. </p></div></div><p>I guess this is a good enough reason to have better names, right? Indeed, but I needed to show you this, so I chose to use <code class="literal">d</code>. In order to tell <span class="emphasis"><em>pdb</em></span> that we're not yielding a (<span class="emphasis"><em>d</em></span>)own command, we put "<code class="literal">!</code>" in front of <code class="literal">d</code> and we're fine.</p><p>After seeing the keys of <code class="literal">d</code>, we see that <code class="literal">'third'</code> is missing, so we put it in ourselves (could this be dangerous? think about it). Finally, now that all the keys are in, we type <code class="literal">c</code>, which means (<span class="emphasis"><em>c</em></span>)ontinue.</p><p>
<span class="emphasis"><em>pdb</em></span> also gives you the ability to proceed with your code one line at a time using (<span class="emphasis"><em>n</em></span>)ext, to (<span class="emphasis"><em>s</em></span>)tep into a function for deeper analysis, or handling breaks with (<span class="emphasis"><em>b</em></span>)reak. For a complete list of commands, please refer to the documentation or type (<span class="emphasis"><em>h</em></span>)elp in the console.</p><p>You can see from the output that we could finally get to the end of the validation.</p><p>
<span class="emphasis"><em>pdb</em></span> (or <span class="emphasis"><em>ipdb</em></span>) are invaluable tools that I use every day, I couldn't live without them. So, go and <a id="id786" class="indexterm"/>have fun, set a breakpoint somewhere and try and inspect, follow the official documentation and try the commands in your code to see their effect and learn them well.</p></div><div class="section" title="Inspecting log files"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec130"/>Inspecting log files</h2></div></div></div><p>Another <a id="id787" class="indexterm"/>way of debugging a misbehaving application is to inspect its log files. <span class="strong"><strong>Log files</strong></span> are special files in which an application <a id="id788" class="indexterm"/>writes down all sorts of things, normally related to what's going on inside of it. If an important procedure is started, I would typically expect a line for that in the logs. It is the same when it finishes, and possibly for what happens inside of it.</p><p>Errors need to be logged so that when a problem happens we can inspect what went wrong by taking a look at the information in the log files.</p><p>There are many different ways to set up a logger in Python. Logging is very malleable and you can configure it. In a nutshell, there are normally four players in the game: loggers, handlers, filters, and formatters:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Loggers</strong></span> expose<a id="id789" class="indexterm"/> the interface that the application code uses directly</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Handlers</strong></span> send<a id="id790" class="indexterm"/> the log records (created by loggers) to the appropriate destination</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Filters</strong></span> provide <a id="id791" class="indexterm"/>a finer grained facility for determining which log records to output</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Formatters</strong></span> specify<a id="id792" class="indexterm"/> the layout of the log records in the final output</li></ul></div><p>Logging is performed by calling methods on instances of the <code class="literal">Logger</code> class. Each line you log has a level. The levels normally used are: <code class="literal">DEBUG</code>, <code class="literal">INFO</code>, <code class="literal">WARNING</code>, <code class="literal">ERROR</code>, and <code class="literal">CRITICAL</code>. You can import them from the <code class="literal">logging</code> module. They are in order of severity and it's very important to use them properly because they will help you filter the contents of a log file based on what you're searching for. Log files usually become extremely big so it's very important to have the information in them written properly so that you can find it quickly when it matters.</p><p>You can log to a file but you can also log to a network location, to a queue, to a console, and so on. In general, if you have an architecture that is deployed on one machine, logging to a file is acceptable, but when your architecture spans over multiple machines (such as in the <a id="id793" class="indexterm"/>case of <span class="strong"><strong>service-oriented architectures</strong></span>), it's very useful to implement a centralized solution for logging so that all log messages coming from each service can be stored and investigated in a single place. It helps a lot, otherwise you can really go crazy trying to correlate giant files from several different sources to figure out what went wrong.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note66"/>Note</h3><p>A <span class="strong"><strong>service-oriented architecture</strong></span> (<span class="strong"><strong>SOA</strong></span>) is an architectural pattern in software design <a id="id794" class="indexterm"/>in which application components provide services to other components via a communications protocol, typically over a network. The beauty of this system is that, when coded properly, each service can be written in the most appropriate language to serve its purpose. The only thing that matters is the communication with the other services, which needs to happen via a common format so that data exchange can be done.</p></div></div><p>Here, I <a id="id795" class="indexterm"/>will present you with a very simple logging example. We will log a few messages to a file:</p><p>
<code class="literal">log.py</code>
</p><div class="informalexample"><pre class="programlisting">import logging

logging.basicConfig(
    filename='ch11.log',
    level=logging.DEBUG,  # minimum level capture in the file
    format='[%(asctime)s] %(levelname)s:%(message)s',
    datefmt='%m/%d/%Y %I:%M:%S %p')

mylist = [1, 2, 3]
<span class="strong"><strong>logging.info</strong></span>('Starting to process `mylist`...')

for position in range(4):
    try:
        <span class="strong"><strong>logging.debug</strong></span>('Value at position {} is {}'.format(
            position, mylist[position]))
    except IndexError:
        <span class="strong"><strong>logging.exception</strong></span>('Faulty position: {}'.format(position))

<span class="strong"><strong>logging.info</strong></span>('Done parsing `mylist`.')</pre></div><p>Let's go through it line by line. First, we import the <code class="literal">logging</code> module, then we set up a basic configuration. In general, a production logging configuration is much more complicated than this, but I wanted to keep things as easy as possible. We specify a filename, the minimum logging level we want to capture in the file, and the message format. We'll log the date and time information, the level, and the message.</p><p>I will start by logging an <code class="literal">info</code> message that tells me we're about to process our list. Then, I will log (this time using the <code class="literal">DEBUG</code> level, by using the <code class="literal">debug</code> function) which is the value at some position. I'm using <code class="literal">debug</code> here because I want to be able to filter out these logs in the future (by setting the minimum level to <code class="literal">logging.INFO</code> or more), because I might have to handle very big lists and I don't want to log all the values.</p><p>If we <a id="id796" class="indexterm"/>get an <code class="literal">IndexError</code> (and we do, since I'm looping over <code class="literal">range(4)</code>), we call <code class="literal">logging.exception()</code>, which is the same as <code class="literal">logging.error()</code>, but it also prints the traceback.</p><p>At the end of the code, I log another <code class="literal">info</code> message saying we're done. The result is this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[10/08/2015 04:17:06 PM] INFO:Starting to process `mylist`...</strong></span>
<span class="strong"><strong>[10/08/2015 04:17:06 PM] DEBUG:Value at position 0 is 1</strong></span>
<span class="strong"><strong>[10/08/2015 04:17:06 PM] DEBUG:Value at position 1 is 2</strong></span>
<span class="strong"><strong>[10/08/2015 04:17:06 PM] DEBUG:Value at position 2 is 3</strong></span>
<span class="strong"><strong>[10/08/2015 04:17:06 PM] ERROR:Faulty position: 3</strong></span>
<span class="strong"><strong>Traceback (most recent call last):</strong></span>
<span class="strong"><strong>  File "log.py", line 15, in &lt;module&gt;</strong></span>
<span class="strong"><strong>    position, mylist[position]))</strong></span>
<span class="strong"><strong>IndexError: list index out of range</strong></span>
<span class="strong"><strong>[10/08/2015 04:17:06 PM] INFO:Done parsing `mylist`.</strong></span>
</pre></div><p>This is exactly what we need to be able to debug an application that is running on a box, and not on our console. We can see what went on, the traceback of any exception raised, and so on.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note67"/>Note</h3><p>The example presented here only scratches the surface of logging. For a more in-depth explanation, you can find a very nice introduction in the how to (<a class="ulink" href="https://docs.python.org/3.4/howto/logging.html">https://docs.python.org/3.4/howto/logging.html</a>) section of the<a id="id797" class="indexterm"/> official Python documentation.</p></div></div><p>Logging is an art, you need to find a good balance between logging everything and logging nothing. Ideally, you should log anything that you need to make sure your application is working correctly, and possibly all errors or exceptions.</p></div><div class="section" title="Other techniques"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec131"/>Other techniques</h2></div></div></div><p>In this final section, I'd like to demonstrate briefly a couple of techniques that you may find useful.</p><div class="section" title="Profiling"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec40"/>Profiling</h3></div></div></div><p>We talked <a id="id798" class="indexterm"/>about profiling in <a class="link" href="ch07.html" title="Chapter 7. Testing, Profiling, and Dealing with Exceptions">Chapter 7</a>, <span class="emphasis"><em>Testing, Profiling, and Dealing with Exceptions</em></span>, and I'm only mentioning it here because profiling can sometimes explain weird errors that are due to a component being too slow. Especially when networking is involved, having an idea of the timings and latencies your application has to go through is very important in order to understand what may be going on when problems arise, therefore I suggest you get acquainted with profiling techniques also for a troubleshooting perspective.</p></div><div class="section" title="Assertions"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec41"/>Assertions</h3></div></div></div><p>Assertions<a id="id799" class="indexterm"/> are a nice way to make your code ensure your assumptions are verified. If they are, all proceeds regularly but, if they are not, you get a nice exception that you can work with. Sometimes, instead of inspecting, it's quicker to drop a couple of assertions in the code just to exclude possibilities. Let's see an example:</p><p>
<code class="literal">assertions.py</code>
</p><div class="informalexample"><pre class="programlisting">mylist = [1, 2, 3]  # this ideally comes from some place
assert 4 == len(mylist)  # this will break
for position in range(4):
    print(mylist[position])</pre></div><p>This code simulates a situation in which <code class="literal">mylist</code> isn't defined by us like that, of course, but we're assuming it has four elements. So we put an assertion there, and the result is this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python assertions.py </strong></span>
<span class="strong"><strong>Traceback (most recent call last):</strong></span>
<span class="strong"><strong>  File "assertions.py", line 3, in &lt;module&gt;</strong></span>
<span class="strong"><strong>    assert 4 == len(mylist)</strong></span>
<span class="strong"><strong>AssertionError</strong></span>
</pre></div><p>This tells us exactly where the problem is.</p></div></div><div class="section" title="Where to find information"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec132"/>Where to find information</h2></div></div></div><p>In the<a id="id800" class="indexterm"/> Python official documentation, there is a section dedicated to debugging and profiling, where you can read up about the <code class="literal">bdb</code> debugger framework, and about modules such as <code class="literal">faulthandler</code>, <code class="literal">timeit</code>, <code class="literal">trace</code>, <code class="literal">tracemallock</code>, and of course <span class="emphasis"><em>pdb</em></span>. Just head to the standard library section in the documentation and you'll find all this information very easily.</p></div></div></div>
<div class="section" title="Troubleshooting guidelines"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec83"/>Troubleshooting guidelines</h1></div></div></div><p>In this<a id="id801" class="indexterm"/> short section, I'll like to give you a few tips that come from my troubleshooting experience.</p><div class="section" title="Using console editors"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec133"/>Using console editors</h2></div></div></div><p>First, get comfortable using <span class="strong"><strong>vim</strong></span> or <span class="strong"><strong>nano</strong></span> as an editor, and learn the basics of the console. When<a id="id802" class="indexterm"/> things break bad you <a id="id803" class="indexterm"/>don't <a id="id804" class="indexterm"/>have the luxury of your editor with all the bells and whistles there. You have to connect to a box and work from there. So it's a very good idea to be comfortable browsing your production environment with console commands, and be able to edit files using console-based editors such as vi, vim, or nano. Don't let your usual development environment spoil you, because you'll have to pay a price if you do.</p></div><div class="section" title="Where to inspect"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec134"/>Where to inspect</h2></div></div></div><p>My second <a id="id805" class="indexterm"/>suggestion is on where to place your debugging breakpoints. It doesn't matter if you are using <code class="literal">print</code>, a custom function, or <span class="emphasis"><em>ipdb</em></span>, you still have to choose where to place the calls that provide you with the information, right?</p><p>Well, some places are better than others, and there are ways to handle the debugging progression that are better than others.</p><p>I normally avoid placing a breakpoint in an <code class="literal">if</code> clause because, if that clause is not exercised, I lose the chance of getting the information I wanted. Sometimes it's not easy or quick to get to the breakpoint, so think carefully before placing them.</p><p>Another important thing is where to start. Imagine that you have 100 lines of code that handle your data. Data comes in at line 1, and somehow it's wrong at line 100. You don't know where the bug is, so what do you do? You can place a breakpoint at line 1 and patiently go through all the lines, checking your data. In the worst case scenario, 99 lines later (and many coffee cups) you spot the bug. So, consider using a different approach.</p><p>You start at line 50, and inspect. If the data is good, it means the bug happens later, in which case you place your next breakpoint at line 75. If the data at line 50 is already bad, you go on by placing a breakpoint at line 25. Then, you repeat. Each time, you move either backwards or forwards, by half the jump you did last time.</p><p>In our worst case scenario, your debugging would go from 1, 2, 3, ..., 99 to 50, 75, 87, 93, 96, ..., 99 which is way faster. In fact, it's logarithmic. This searching technique is called <span class="strong"><strong>binary search</strong></span>, it's<a id="id806" class="indexterm"/> based on a divide and conquer approach and it's very effective, so try to master it.</p></div><div class="section" title="Using tests to debug"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec135"/>Using tests to debug</h2></div></div></div><p>Do you <a id="id807" class="indexterm"/>remember <a class="link" href="ch07.html" title="Chapter 7. Testing, Profiling, and Dealing with Exceptions">Chapter 7</a>, <span class="emphasis"><em>Testing, Profiling, and Dealing with Exceptions</em></span>, about tests? Well, if we have a bug and all tests are passing, it means something is wrong or missing in our test codebase. So, one approach is to modify the tests in such a way that they cater for the new edge case that has been spotted, and then work your way through the code. This approach can be very beneficial, because it makes sure that your bug will be covered by a test when it's fixed.</p></div><div class="section" title="Monitoring"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec136"/>Monitoring</h2></div></div></div><p>Monitoring <a id="id808" class="indexterm"/>is also very important. Software applications can go completely crazy and have non-deterministic hiccups when they encounter edge case situations such as the network being down, a queue being full, an external component being unresponsive, and so on. In these cases, it's important to have an idea of what was the big picture when the problem happened and be able to correlate it to something related to it in a subtle, perhaps mysterious way.</p><p>You can monitor API endpoints, processes, web pages availability and load time, and basically almost everything that you can code. In general, when starting an application from scratch, it can be very useful to design it keeping in mind how you want to monitor it.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec84"/>Summary</h1></div></div></div><p>In this short chapter, we saw different techniques and suggestions to debug and troubleshoot our code. Debugging is an activity that is always part of a software developer's work, so it's important to be good at it.</p><p>If approached with the correct attitude, it can be fun and rewarding.</p><p>We saw techniques to inspect our code base on functions, logging, debuggers, traceback information, profiling, and assertions. We saw simple examples of most of them and we also talked about a set of guidelines that will help when it comes to face the fire.</p><p>Just <span class="emphasis"><em>remember to always stay calm and focused</em></span>, and debugging will be easier already. This too, is a skill that needs to be learned and it's the most important. An agitated and stressed mind cannot work properly, logically and creatively, therefore, if you don't strengthen it, it will be hard for you to put all of your knowledge to good use.</p><p>In the next chapter, we will end the book with another small project whose goal is to leave you more thirsty than you were when you started this journey with me.</p><p>Ready?</p></div></body></html>