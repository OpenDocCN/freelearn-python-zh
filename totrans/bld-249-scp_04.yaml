- en: Chapter 4. Pydrivers and Constraints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When designing a complex object with movable parts we'd like to control how
    these parts move in relation to each other. Sometimes, we might want to try and
    simulate reality by using a physics engine such as bullet, but often this is either
    not accurate enough or does not provide an animator with enough control. Most
    of the time the clever use of multiple constraints will achieve our goals, but
    sometimes the restrictions and relations cannot be expressed in terms of simple
    constraints and key-framed motions. In those cases, we can extend Blender's capabilities
    by defining our own constraints or relations between animated properties by using
    Python.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will see how we can associate built-in constraints with
    Blender objects and how to define complex relationships between animated properties
    by using the so-called **pydrivers**. We will also define new complex constraints
    that may be used just like the built-in constraints. We will not yet look into
    defining key frames for animated properties as we will encounter those in later
    chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will see:'
  prefs: []
  type: TYPE_NORMAL
- en: How to drive one **IPO** from another by a Python expression
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to work around some limitations inherent in **pydrivers**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to restrict the motion of objects and bones by adding constraints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to write a constraint in Python that will snap an object to the closest
    vertex on another object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a lot to cover here so let's first start off with some definitions
    to get a clear idea about what we are dealing with.
  prefs: []
  type: TYPE_NORMAL
- en: Getting to grips with animated properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Blender's system is versatile, yet complex. Before we are able to manipulate
    animated properties from a Python script it is necessary we understand the concepts
    involved thoroughly.
  prefs: []
  type: TYPE_NORMAL
- en: IPO
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Blender, almost any property can be animated. Normally this is done by fixing
    the values of some property such as the position of an Object at certain key frames
    and interpolating between these values for intermediate frames. Blender groups
    related animated properties together in so-called IPOs. For instance, all spatial
    properties such as location, rotation, and scale are grouped as an Object type
    IPO and may be associated with almost any Blender Object for instance, a `Mesh`,
    a `Camera`, or a `Lamp`. The many properties of Blender Materials are grouped
    in the Material type IPO. A Material type IPO may be associated with any object
    that has associated materials. Likewise, a Lamp type IPO should be associated
    with a `Lamp` object. An overview of possible IPO types is given in the next table.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**IPO** sounds like an abbreviation and it probably is, but what it stands
    for exactly is a bit vague. The Blender wiki states that it stands for InterPOlation
    system, but InterPolation Object is sometimes encountered as well. Most of the
    time, IPO is used as a noun by itself however, so this discussion is a bit academical.'
  prefs: []
  type: TYPE_NORMAL
- en: Each IPO may be associated with more than one object. It is for example possible
    to animate the rotation of many objects in the same manner by associating a single
    appropriate Object type IPO with them. In the Blender Python API, IPOs are represented
    by IPO objects. An IPO object may be associated with another object by means of
    the `setIpo()` method. The following table gives an overview of IPO types, typical
    channels, and the type of objects they can be applied to. Refer to the API documentation
    for the Blender.IPO module for more details ([http://www.blender.org/documentation/249PythonDoc/index.html](http://www.blender.org/documentation/249PythonDoc/index.html)).
  prefs: []
  type: TYPE_NORMAL
- en: '| IPO type | IPO channels (some examples, refer to API documentation for a
    full list) | Relevant to these Blender objects |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Object | `LocX`, `LocY`, `LocZ` (location)`RotX`, `RotY`, `RotZ` (rotation)`ScaleX`,
    `ScaleY`, `ScaleZ` (scale) | All Blender objects that can be positioned, such
    as `Mesh`, `Lamp`, `Camera`, and so on |'
  prefs: []
  type: TYPE_TB
- en: '| Pose | `RotX`, `RotY`, `RotZ` (rotation) | Bone |'
  prefs: []
  type: TYPE_TB
- en: '| Material | `R`,`G`,`B` (diffuse color) | Any object that takes a material
    |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | `Contrast` | Any object with associated textures, such as `Mesh`,
    `Lamp`, `World`, and so on |'
  prefs: []
  type: TYPE_TB
- en: '| Curve | `Speed` | `Curve` |'
  prefs: []
  type: TYPE_TB
- en: '| Lamp | `Energ` (energy)`R`,`G`,`B` (color) | `Lamp` |'
  prefs: []
  type: TYPE_TB
- en: '| World | `HorR`,`HorG`,`HorB` (horizon color) | World |'
  prefs: []
  type: TYPE_TB
- en: '| Constraint | `Inf` (Influence) | Constraint |'
  prefs: []
  type: TYPE_TB
- en: '| Sequence | `Fac` (Factor, for example, the volume of an audio strip) | Sequence
    |'
  prefs: []
  type: TYPE_TB
- en: IPOchannels and IPOCurves
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: IPOs of a given type will contain a whole collection of related animated properties.
    Each of these properties is often referred to as a channel. Examples of channels
    in an Object type IPO are for example `LocX` (the x-component of a location) and
    `RotY` (the rotation around the y-axis). Each channel is represented by an `IPOCurve`
    object that implements the required functionality to return a value interpolated
    between key frames.
  prefs: []
  type: TYPE_NORMAL
- en: An example of a channel in a Material type IPO would be `SpecB`—the blue component
    of the specular color.
  prefs: []
  type: TYPE_NORMAL
- en: '`IPOCurve` objects of a given IPO are accessed as attributes, for example,
    `myipo.LocX` will refer to a `LocX` `IPOCurve` if `myipo` is an Object type IPO.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate these concepts imagine that we want to animate the movement of
    a simple cube along the x-axis. We want to start the motion at frame number 1
    and to end it at frame number 25\. Within Blender, this is accomplished by following
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a simple `Cube` by selecting **Add | Mesh | Cube** and make sure that you
    are in Object mode again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to frame number one (for example, by entering the frame number in the frame
    number widget below the 3D View window).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Insert a location key frame by selecting **Object | Insert keyframe | Loc**.
    In the `IPOCurve` editing window this location key frame will show up as an Object
    type IPO (highlighted in the following screenshot).![IPOchannels and IPOCurves](img/0400-04-01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The current frame is visible as a green vertical line. A location IPO holds
    three distinct channels (for the location along the x-axis, `LocX`, and along
    the y– and z-axes (`LocY` and `LocZ`). These channels are represented as different
    colored graphs (they might overlap). These graphs may be manipulated in the `IPOCurve`
    editor directly, but here we will just add a second key frame in the 3D View window.
  prefs: []
  type: TYPE_NORMAL
- en: In the 3D View window, go to frame number 25.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the Cube and move it along the x-axis to the right.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Insert a second location key frame by selecting **Object | Insert keyframe |
    Loc**. Now we see that each of the graphs representing the three location IPO
    channels have a second point defined on them. Because we changed the location
    of the cube only along the x-axis, the graphs of the other channels remain flat,
    but the `LocX` channel shows how the change of x-position progresses with each
    frame.![IPOchannels and IPOCurves](img/0400-04-02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By adding more key frames we can make any motion as complex as we want, but
    this becomes a lot of work if we want our object to follow a precise precalculated
    path for example. Later in this chapter we will see how we can manipulate the
    `IPOCurve` objects that represent these channels within an IPO programmatically.
  prefs: []
  type: TYPE_NORMAL
- en: Constraints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Constraints** in Blender are associated with top-level Blender Objects or
    Blender Bone objects and represented by `Constraint` objects. Blender Objects
    and Bones have a `constraints` attribute, which is an object implementing a sequence
    of constraints and methods to add, remove, and alter the order of constraints
    in this sequence (being able to change the order of constraints is necessary because
    in some situations the order in which constraints are applied matters).'
  prefs: []
  type: TYPE_NORMAL
- en: When a constraint is associated with an object the result will be a mix of the
    constrained parameters and the calculated parameters. How much this mix will consist
    of constrained or unconstrained parameters is determined by the `influence` attribute
    and this may even be animated.
  prefs: []
  type: TYPE_NORMAL
- en: Difference between drivers and constraints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Drivers and constraints are related in the sense that they influence the way
    parameters may change but they are also very different: constraints act on objects
    while drivers determine how IPO curves (animated parameters) change other IPO
    curves. And where constraints can only influence the spatial properties of an
    object such as its position, scale or rotation, any IPO curve may be driven by
    another IPO curve. This means that even material parameters, such as color or
    a `Lamp` parameter such as energy, may be driven by another IPO. There is a restriction
    though: the IPO curves that drive other IPO curves must currently be special properties
    of an object so you can drive the color of a material by the rotation of some
    object but you cannot drive that color by the energy of a lamp for instance. Also,
    the fact that constraints can affect only spatial properties means that there
    is for instance no way that you can limit the diffuse color of a material. The
    following table shows some constraints and their relevant attributes. Refer to
    the API documentation for the `Blender.Constraint` module for more details.'
  prefs: []
  type: TYPE_NORMAL
- en: '| Constraint type | Typical attributes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `TrackTo` | `Target` (target object)`Track` (axis to track) |'
  prefs: []
  type: TYPE_TB
- en: '| `Floor` | `Target` (target object) |'
  prefs: []
  type: TYPE_TB
- en: '| `StretchTo` | `Target` (target object) |'
  prefs: []
  type: TYPE_TB
- en: '| `CopyLocation` | `Copy` (which location component(s) to copy) |'
  prefs: []
  type: TYPE_TB
- en: Note that it is possible to animate the influence of a constraint as well, in
    which case an Object will have an associated constraint type IPO.
  prefs: []
  type: TYPE_NORMAL
- en: Programming with constraints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Blender has many constraints that you may apply to an object. Some of them are
    quite like drivers, in the sense that they do not restrict a motion of an object
    but copy some parameters such as rotation or location. From a developer's point
    of view, each Blender Object has a `constraints` attribute that is a sequence
    of constraint objects. This sequence can be appended and items from this sequence
    can be deleted. It is also possible to alter the order of the items.
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Action | Example |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `append(`*type*`)` | Appends a new constraint to an object and returns the
    constraint | `ob.constraints.append(Constraint.Type.TRACKTO)` |'
  prefs: []
  type: TYPE_TB
- en: '| `remove(`*constraint*`)` | Removes a constraint from an object | `ob.constraints.remove(ob.constraints[0])`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `moveUp(`*constraint*`)``moveDown(`*constraint*`)` | Change the position
    of a constraint in the list of constraints | `ob.constraints.moveDown(ob.constraints[0])`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `[]` | Accesses an attribute of a constraint | `Con = ob.constraints[0]``Con[Constraint.Settings.TARGET]
    = other` |'
  prefs: []
  type: TYPE_TB
- en: New `Constraint` objects are not instanced by way of a constructor, but by calling
    the `append()` method of the `constraints` attribute with the type of the constraint
    to add. `append()` will then return the new `Constraint` whose settings may then
    be altered.
  prefs: []
  type: TYPE_NORMAL
- en: Programming with IPOs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'IPO channels can be changed from a script just as constraints can but they
    are rather more diverse than constraints because there are many different types
    of IPO channels and some of them, notably texture channels and shape keys, need
    a special treatment. They have a separate chapter of their own ([Chapter 6](ch06.html
    "Chapter 6. Shape Keys, IPOs, and Poses"): *Shape keys, IPOs, and Poses*) but
    a different use of Python for IPO channels is shown in the next section.'
  prefs: []
  type: TYPE_NORMAL
- en: PyDrivers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many cases where we would like to change some property by referring
    to another property but where the relationship cannot be captured by driving an
    IPO channel by another one. Often, this is because the relation is not a simple
    linear dependency, for example, a piston driven by a circular motion. Another
    case would be if the relation is non continuous, for example, a light that is
    turned on when a switch is in a certain position.
  prefs: []
  type: TYPE_NORMAL
- en: In these cases the relationship may be defined by a Python expression or by
    the so-called *pydriver*. A pydriver takes the IPO channel of another object as
    input and produces output that will drive a channel on the current object. Because
    these Python expressions can access the complete Blender API, these relations
    can be made very complex indeed.
  prefs: []
  type: TYPE_NORMAL
- en: PyConstraints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Where pydrivers may be used to bypass limitations in the built-in possibilities
    to drive IPO channels, **PyConstraints** allow us to conquer difficulties in situations
    where the built-in constraints will not suffice. For example, it is not possible
    to restrict the position of an object to the surface of another object with holes
    in it. The built-in constraints offer ways to limit the position to a location
    not lower than another object (the `floor` constraint). But if we would like it
    to be possible for our object to drop below the surface at locations where there
    is a hole, we would have to program such a constraint ourselves. As we will see,
    PyConstraints allow us to do just that.
  prefs: []
  type: TYPE_NORMAL
- en: With all these introductory remarks behind us we can finally turn to programming
    again in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the time—one to rule them all
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What use is a clock if you cannot set the time in a convenient way? Instead
    of positioning each hand, we would like to turn a single knob to move both the
    big hand and the little hand where the little hand would have to move twelve times
    as slow as the big hand.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, we would have to define a `knob` object (that we probably would not
    render) and drive the rotation of the bones in the clock by the rotation of this
    knob.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set up the driven channels we follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the 3D View, select the `bighand` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the IPO window, make sure that you have the object IPO types selected. On
    the right-hand side, there will be a list of channels. Select the one labeled
    **RotZ** by left-clicking on it. It will be highlighted.![Setting the time—one
    to rule them all](img/0400-04-03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Curve | Transform Properties**. A pop-up window will appear. Click
    on the **Add Driver** button.![Setting the time—one to rule them all](img/0400-04-04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the **Transform Properties** pop up still present, select **Curve | Insert
    1:1** **mapping** and next click on the **Default one-to-one mapping** pop up
    (or press *Enter*). The resulting graph will show up as a straight, pale blue
    line in the IPO editor window.![Setting the time—one to rule them all](img/0400-04-05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the **Transform Properties** pop-up window, click on the pale green python
    icon. The python icon will turn dark green and it is now possible to enter a pydriver
    expression in the adjacent text field. Enter the following line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Et voila! If you now rotate the `knob` object about its z-axis the big hand
    follows suit. The pydriver expression does need some clarification though. The
    highlighted part is the driver—the object channel that supplies the input for
    our driven channel. The `ob('Knob')` part is the shorthand allowed in pydriver
    expressions for `Blender.Object.Get('Knob')` and the `RotZ` attribute supplies
    us with the rotation about the z-axis. This rotation, however, is given in radians,
    whereas the result of a pydriver expression for a rotation channel should be in
    degrees, so we multiply by 360 degrees and divide by 2 times pi. Finally, we divide
    our calculated number of degrees by ten because for some obscure reason, Blender
    does not really expect degrees but the number of degrees divided by 10! (Note
    that this "divide by ten" business is valid only for rotation channels and not
    for any of the other channels!)
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 1-on-1 mappings
  prefs: []
  type: TYPE_NORMAL
- en: You may wonder why we would have to insert a 1-on-1 curve first. Well, the relation
    between a driven channel and its driver contains one more layer and that is a
    curve translating the output of the pydriver to the final output. This curve can
    be tweaked of course, but normally we would do all the fine-tuning in our pydriver
    and just put in a 1-on-1 curve. This way of working is so common that Blender
    provides a menu entry especially for this situation since it is quite tedious
    to create the necessary curves again and again for each driven channel.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, we could have accomplished the same feat by driving the rotation
    channel directly by the rotation channel of the `knob` object or even by a copy
    rotation constraint. That would have saved us the strange conversion issues but
    the purpose of this section is to show the basics.
  prefs: []
  type: TYPE_NORMAL
- en: 'The little hand is an example where using a pydriver really is a valid solution.
    (Although by tweaking the IPO curve itself we could alter the pace of the driven
    channel but that would not be as clear as a simple expression and almost impossible
    for more complex relations) We repeat the list of actions shown earlier but now
    for the little hand object and enter the following pydriver expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Because the little hand runs twelve times as slow as the big hand, we use the
    same pydriver expression as for the big hand but divide that result by twelve.
    Now when we rotate the `knob` object about its z-axis, the big hand will follow
    as will the little hand at its set pace. Instead of manually rotating the knob
    it is also possible to animate the rotation of the knob to animate both clock
    hands. The complete result is available as `clock-pydriver.blend` and a rendered
    image of the clock, with the knob driving the motion of the hands visible on the
    top left, is shown in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting the time—one to rule them all](img/0400-04-06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Shortcuts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Within pydriver expressions some useful shortcuts can be used to save on typing.
    In the step-by-step example we already made use of the `ob('<name>')` shortcut
    that refers to Blender objects by name and likewise, it is possible to access
    `Mesh` objects and materials by `me('<name>')` and `ma('<name>')` respectively.
    Furthermore, the `Blender` module is available as `b`, the `Blender.Noise` module
    as `n`, and Python's `math` module as `m`. This allows for expressions using trigonometric
    functions such as sinus, for example. These facilities are sufficient to cover
    many issues but they still might not be enough, for instance if we would like
    to import external modules. There is a way around these difficulties though as
    we will see in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Overcoming limitations: pydrivers.py'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The input field for pydrivers is limited to 125 characters and even though
    the shortcuts provided to access Python''s `math` module and some of the Blender
    modules allow for shorter expressions, the space provided is often not enough.
    Also, as pydrivers must be Python expressions, it is quite difficult to debug
    them (because you cannot insert `print` statements for example) or to attain something
    like an `if/then` functionality. The latter can be overcome, to a certain extent,
    by clever tricks based on the fact that `True` and `False` in Python are converted
    to 1 and 0 respectively inside numerical expressions, so the statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'may be expressed as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this feels awkward and evaluates the condition twice. Fortunately,
    both the space problem and the limitation to a single expression can be solved
    by using a text block named `pydrivers.py`. If such a text block is present, its
    contents are accessible as a module called `p`. So, for example, if we define
    a function `clamp()` in `pydrivers.py` that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We may invoke this function in our pydriver expression as `p.clamp(a,14,109)`.
  prefs: []
  type: TYPE_NORMAL
- en: We will use `pydrivers.py` quite a bit in the following examples, not only because
    it allows for more complex expressions, but also because the width of the pydriver
    field is even smaller than the length of its allowed content making it very hard
    to read as you have to scroll about to access all parts of an expression.
  prefs: []
  type: TYPE_NORMAL
- en: Internal combustion—correlating complex changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine that we want to demonstrate how a four-stroke internal combustion engine
    works. Such an engine has a lot of moving parts and many of them are related in
    complex ways.
  prefs: []
  type: TYPE_NORMAL
- en: To see what these exact relations are, it might be useful to have a look at
    the following illustration. It lists the names that we will use when we refer
    to the various parts. (I am neither an automotive engineer nor a mechanic so these
    part names may not be accurate but at least we will be talking about the same
    things. For more information you may want to read [http://en.wikipedia.org/wiki/Four-stroke_cycle](http://en.wikipedia.org/wiki/Four-stroke_cycle).)
  prefs: []
  type: TYPE_NORMAL
- en: '![Internal combustion—correlating complex changes](img/0400-04-07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Before we start to configure the parts to have their rotation and position
    driven by another part, it is a good thing to think ahead: in real life, the pistons
    inside the cylinders are propelled by the expansion of the ignited fuel and the
    pistons drive the drive shaft (or crank-shaft) with the attached flywheel and
    a distribution belt (or in our case some gears, that are not shown here) transfers
    that motion back to the camshafts that drive the motion of the inlet and outlet
    valves. Obviously, we cannot follow this concept directly as there is no fuel
    object of some sort to drive other objects so it makes more sense to reverse the
    chain of relations. In our setup the flywheel will drive the drive shaft and the
    different gears and the drive shaft will drive most other objects, including the
    piston and its connecting rod. We will also drive the energy of the lamp positioned
    at the tip of the spark plug by the rotation of the drive shaft.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The drive shaft will simply follow the rotation of the flywheel as will the
    lower gear (this could be implemented with a `copy` `rotation` constraint just
    as well but here we choose to implement everything by pydrivers). The corresponding
    pydrivers for the `RotX` channel will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This may look awkward for something just copying a rotation but remember that
    rotations are stored as radians while pydriver expressions should return rotations
    as degrees divided by 10.
  prefs: []
  type: TYPE_NORMAL
- en: 'The top gear and both the camshafts will also follow the rotation of the flywheel
    but with the speed reduced to half and with the direction of the rotation reversed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: To illustrate how to access functions in Python's `math` module we did not do
    the conversion to degrees ourselves but used the `degrees()` function supplied
    by the `math` module.
  prefs: []
  type: TYPE_NORMAL
- en: 'We modeled the camshafts with the cam pointing exactly downward. If we want
    to drive the x-axis rotation of the inlet camshaft by the rotation of the drive
    shaft we have to take into account that it moves at half the speed. Also, its
    rotation lags behind a bit to match the ignition cycle of the cylinder as it opens
    the inlet valve on the first downstroke and closes the valve just before the ignition
    spark:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The expression for the outlet camshaft is almost identical except for the amount
    it lags behind (here `24`, but tuning this engine is left to real mechanics):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '![Internal combustion—correlating complex changes](img/0400-04-08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The movement of the piston is limited to just the vertical, but the exact motion
    is somewhat more involved to calculate. We are interested in the position of the
    quantity **Q**—see the preceding figure—and the distance between the center of
    the drive shaft and point where the connecting rod (**L** in the diagram) connects
    to the piston. Because the length of the connecting rod is fixed, **Q** will vary
    as a function of the rotation angle **α** of the drive shaft. The distance from
    the center of the drive shaft to point where the connecting rod is connected to
    the drive shaft is also fixed. We call this distance R. Now we have a triangle
    with sides **Q**, **L**, and **R** and a known angle **α**. As three of these
    quantities (L, R, and α) are known, we can calculate the fourth, **Q**, by using
    the cosine rule ([http://en.wikipedia.org/wiki/Law_of_cosines](http://en.wikipedia.org/wiki/Law_of_cosines)).
    Therefore, we define a function `q()` in `pydrivers.py` that will return the length
    **Q** when **L**,**R**, and **α** are given:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The expression for the `LocZ` channel of the piston will then simply call this
    function with the appropriate values for the arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The precise values for **L** and **R** were taken from the mesh by noting the
    position of appropriate vertices of the connecting rod and the drive shaft in
    the `Transform Properties` window. (*N* key in the 3D View)
  prefs: []
  type: TYPE_NORMAL
- en: The connecting rod itself may use the same expression for its `LocZ` channel
    as we carefully made the mesh origins of the piston and the connecting rod to
    coincide.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the motion of the connecting rod is not limited to the z-location
    as it will rotate around the x-axis centered on the point connecting it to the
    piston. The angle of this rotation (**γ** in the diagram) can be derived from
    the quantities **L**, **R**, and **α**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The pydriver expression for `RotX` will then look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The inlet and outlet valves are driven by the rotation of their respective
    camshafts. The outline of the actual cam is quite complex so here, we use not
    the actual form of that outline but approximate it by something that looks good
    enough (that is, open the valve in a fluent yet brisk motion at the correct moment).
    The following graph shows the valve travel as a function of rotation angle:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Internal combustion—correlating complex changes](img/0400-04-09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To this end, in `pydrivers.py` we define a function `spike()` that will take
    the rotation of the camshaft as its argument and returns a value between `0.0`
    and `1.0` that rises steeply around the zero angle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the motion of the valve is linear but the line it follows is tilted by
    10 degrees (forward for the inlet valve, backward for the outlet valve) so we
    have to drive two channels, `LocZ` and `LocY`, each multiplied by the correct
    amount to effect the slanted motion. We therefore define two functions in `pydrivers.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Both functions will return a distance given the rotation angle of the object
    driving it. The `tilt` is the amount that the valve is tilted (in degrees), `travel`
    is the maximum distance the valve will travel along the tilted line, and `offset`
    is a value that allows us to tweak the position of the valve. The corresponding
    pydriver expressions for the `LocZ` and `LocY` channels of the inlet valve will
    then become:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: and
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: (The expressions for the outlet valve look the same but with a positive tilt
    angle.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Until now, all channels have been object channels, that is, locations and rotations.
    But it is also possible to drive other channels, and that is precisely what we
    need to drive the energy of the lamp positioned at the tip of our spark plug.
    In `pydrivers.py` we first define a helper function `topi()` that, besides the
    rotation angle of the driving object, will take an angle `h` (in radians) and
    an intensity `i` as arguments. It will return that intensity if the angle of the
    driving object is between `0` and `h` and will return zero outside this range.
    Because the input angle may be larger than two times pi (when the driving object
    is rotated more than full circle), we correct this by the highlighted *modulo*
    operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The pydriver expression for the energy channel (called "Energ" in the IPO editor
    window) can then be expressed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As shown, this expression will 'fire' the spark plug for the first 17 degrees
    or so (`0.3` radians) of its cycle by setting the energy to `0.5`.
  prefs: []
  type: TYPE_NORMAL
- en: More power—combining multiple cylinders to an engine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once we have modeled a single cylinder and taken care of driving the motions
    of the individual parts, our next step is to duplicate the cylinders to create
    a set like the opening illustration of this chapter. In principle we can select
    all parts, duplicate them by pressing *Shift* + *D*, and adjust the timing of
    the individual driven channels.
  prefs: []
  type: TYPE_NORMAL
- en: There is a snag, however. When using *Shift* + *D* rather than *Alt* + *D* we
    make actual copies of the object meshes instead of merely referring to the same.
    We would expect the same for other items associated with an object, such as materials,
    textures, and IPOs. This is not the case however as Blender, by default, does
    not duplicate those last three categories when duplicating an object. This would
    be awkward, as a change in the IPO of the first piston for example would affect
    all duplicated pistons as well.
  prefs: []
  type: TYPE_NORMAL
- en: We could make those copies unique afterward (by clicking on the user count field
    of those IPOs for instance and confirm the **make** **single** **user?** popup)
    but this is tedious as it would have to be repeated for each copy.
  prefs: []
  type: TYPE_NORMAL
- en: '![More power—combining multiple cylinders to an engine](img/0400-04-10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A better way is to alter the **Duplicate** **with** **object** settings in the
    **Edit** **Methods** screen of the **User Preferences** window as shown in the
    preceding screenshot. In this way, IPOs associated with an object will be made
    into unique copies when duplicating an object. A screenshot of the **User Preferences**
    window with buttons to duplicate IPOs (highlighted) is shown above.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result of our labors, a four cylinder engine with gears to transfer the
    motion of the drive shaft to the camshafts is available as `engine001.blend`.
    A still image from the animation available at [http://vimeo.com/7170769](http://vimeo.com/7170769)
    is shown in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![More power—combining multiple cylinders to an engine](img/0400-04-11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Adding simple constraints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Constraints may be applied to objects as well as to bones. In both instances
    a new constraint is added by calling the `append()` method of the `constraints`
    attribute. Our next example will show how we may restrict the movement of the
    clock hands from the rigged clock (from [Chapter 3](ch03.html "Chapter 3. Vertex
    Groups and Materials"), *Vertex Groups and Materials*) to rotate around the z-axis.
    The code defining the function to accomplish this starts off with two `import`
    statements that will save us some typing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The function itself will take two arguments: `obbones`, a reference to a Blender
    object whose data is an armature (that is, not the armature object itself) and
    `bone`, the name of the bone whose motion we would like to restrict. It is important
    to understand that the constraint that we will associate with a bone is not a
    property of the armature but of the pose of the object containing the armature.
    Many objects may refer to the same armature and any poses are associated with
    the object so different objects referring to the same armature may strike different
    poses.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So the function starts off by getting the pose first and then a reference to
    the bone that we want to constrain. The highlighted line shows how to associate
    the constraint (this would be similar if we would associate a constraint with
    a Blender object instead of a bone):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The newly appended constraint is retained as the variable `c` and the subsequent
    lines show that the different attributes of a constraint may be accessed like
    a dictionary. First, we configure the `LIMIT` attribute (a bitmap) to limit the
    rotation of the x and y axes. Next, we set the minimum and maximum of the rotations
    around these axes to `0.0`, as we disallow any movement. In the rigging of a realistic
    animal skeleton, for example, these values could be set to limit the extent of
    the rotation to values comparable with a real joint. Finally, to make the changes
    to our `Pose` object visible, we call its `update()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Defining complex constraints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Where pydrivers enable us to drive the change of one `IPOCurve` by the change
    in another, PyConstraints provide us with ways to let object properties change
    only in a limited way.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, Blender has many simple constraints predefined as we saw in previous
    sections and often a combination of simple constraints may be exactly what you
    want. But say you want your objects to move about freely within a non-rectangular
    area, for example to simplify the allowed placement of traffic lights and phone
    booths on a street grid. How would we achieve that? Enter pyconstraints.
  prefs: []
  type: TYPE_NORMAL
- en: '**PyConstraints** are Python scripts that should be present as a text block
    in Blender''s text editor and start with a comment line identifying it as a constraint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: A Python constraint should contain three functions called `doConstraint()`,
    `doTarget()`, and `getSettings()`. The first two are invoked anytime we move either
    the target or the constrained object and the last one is called when the user
    clicks the **Options** button that is present once the user has selected a pyconstraint.
    The following screenshot shows the **Constraints** tab once a pyconstraint is
    selected.
  prefs: []
  type: TYPE_NORMAL
- en: '![Defining complex constraints](img/0400-04-12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The easiest way to understand what these functions do is by looking at the built-in
    constraint template that we can use as a basis to write our own constraints. It
    is accessible in the text editor from the menu **Text | Script Templates | Script
    Constraint**. If clicked, it will create a new text block that can be selected
    from the dropdown at the bottom of the text editor.
  prefs: []
  type: TYPE_NORMAL
- en: The Blender constraint template
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Blender constraint template contains a lot of helpful comments as well,
    but here we list mostly the bare functions. Also, the template creates a dummy
    properties window. We will encounter properties in the next section so our example
    of `getSettings()` here will be almost empty. As shown the functions will implement
    a functional constraint, however, nothing is actually constrained. Location, rotation,
    and scale of the constrained object are all kept the same.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `doConstraint()` function will be passed the transformation matrix of the
    constrained object and a list of transformation matrices for every target object.
    It will also receive a dictionary of properties of the constraint that may be
    accessed by name.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we do is to separate out the translation, rotation, and scale
    components of the constrained objects' transformation matrix. The translation
    part will be a vector with the x, y, z position and the scale part will be a vector
    with scaling factors along the x, y, and z-axis. The rotation part will be represented
    by a Euler vector with the rotation about the three principal axes. (Eulers greatly
    simplify working with rotations in 3D but are rather difficult to grasp at first.
    Wikipedia has a great page on Euler angles [http://en.wikipedia.org/wiki/Euler_angle](http://en.wikipedia.org/wiki/Euler_angle)
    but for now, it is easiest to think of Eulers as a rotation separated out as rotations
    around the local x, y, and z axes.) We could separate any of the target object's
    transformation matrices as well, if we wanted, and then modify the transformation
    components of the transformation matrix of the constrained object in any way we
    wish.
  prefs: []
  type: TYPE_NORMAL
- en: The function as shown here does nothing but converts the different transformation
    components back to matrices by using API methods (where available) and then recombines
    them by using matrix multiplication to a single matrix that is subsequently returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `doTarget()` function is called prior to calling `doConstraint()` and gives
    us the opportunity to manipulate the target matrix before it is passed to `doConstraint()`.
    Its arguments are the target object, the subtarget (either a `Bone` or a vertex
    group for a target armature or mesh respectively), the target matrix, and the
    properties of the constraint. In a later section, we exploit this opportunity
    to store a reference to the target object in the properties so that `doConstraint()`
    may access that information that it otherwise could not access. If we do not wish
    to alter anything then returning the target matrix as is will suffice, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Likewise, if there is no need to offer the user the possibility to specify
    additional properties, `getSettings()` may simply return. If we *do* want to show
    a pop up, `getSettings()` is the place where it should happen. We see an example
    of that in a later section as well. The following code is a valid "do nothing"
    implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Do you find me attractive too?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As the moon and earth revolve around each other they feel each other's gravitational
    attraction. On earth this will result in tides, but the solid body of the earth
    and moon will be distorted as well, although this effect is small. Now there is
    a lot more to tides than attraction alone ([http://en.wikipedia.org/wiki/Tides](http://en.wikipedia.org/wiki/Tides)),
    but we can show the gravitational distortion in an exaggerated way by applying
    constraints.
  prefs: []
  type: TYPE_NORMAL
- en: One way of doing this is to use a `TrackTo` constraint to orient an axis of
    our constrained object towards the attracting object and add a second constraint
    that scales the constrained object along the same axis. The size of the scale
    will depend on the inverse distance between the constrained object and the target
    object. The effect is illustrated in the next screenshot where the effect of a
    `TrackTo` constraint is combined with the script constraint `moon_constraint.py`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Do you find me attractive too?](img/0400-04-13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We will have to write this distance-dependent scaling ourselves. If we take
    the constraint template provided by Blender we can leave the `doTarget()` and
    `getSettings()` functions as is, but we do have to write a suitable `doConstraint()`
    function (full code available as `moon_constraint.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We left out any lines related to properties as we do not implement any user-configurable
    properties for this constraint. The highlighted lines show what we have to do
    to calculate the distance-dependent scaling.
  prefs: []
  type: TYPE_NORMAL
- en: The first line gets the location of our target. Next, we calculate the distance
    between the constrained object and the target and limit this to a minimum (slightly
    larger than zero) to prevent a division by zero in the next highlighted line.
    The formula used here is nowhere near an approximation of any gravitational influence
    but behaves nicely enough for our purpose; the scale factor will be `1.0` if `d`
    is very large and will smoothly increase as the distance `d` becomes smaller.
    The final highlighted line shows that we alter the scale only of the y-axis, that
    is, the axis we orient towards the target object with the `TrackTo` constraint.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Cyclic dependencies:**'
  prefs: []
  type: TYPE_NORMAL
- en: If both objects have a comparable mass, the gravitational distortion would be
    of comparable size on both objects. We might be tempted to add the `TrackTo` and
    `moon_constraint.py` constraints to both objects to see the effect they assert
    on each other, but unfortunately that will not work because it will create a cyclic
    dependency and Blender will protest.
  prefs: []
  type: TYPE_NORMAL
- en: Snapping to mesh vertices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is like the "snap to vertex" mode that is available in Blender from the
    menu **Object | Transform | Snap** (see **[http://wiki.blender.org/index.php/Doc:Manual/Modelling/Meshes/Snap_to_Mesh](http://wiki.blender.org/index.php/Doc:Manual/Modelling/Meshes/Snap_to_Mesh)
    for more about snapping) except that the effect is not permanent (the object reverts
    to its unconstrained position once the constraint is removed) and the strength
    of the constraint can be modulated (animated even) by changing the Influence slider.**
  prefs: []
  type: TYPE_NORMAL
- en: '**In the constraints that we designed so far, only the position of the target
    object was needed to calculate the effects on the constrained object. This position
    was readily available to the `doConstraint()` function as the matrices of the
    targets were passed as arguments. Now we are facing a different challenge though:
    if we want to snap to a vertex we must have access to the mesh data of the target
    object, but the target object is not passed to the `doConstraint()` function.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**The way around this obstacle is the `idprop` argument that is passed to `doConstraint()`.
    Before `doConstraint()` is called, Blender first calls `doTarget()` for each target
    object. This function is passed as a reference to the target object and to the
    properties of the constraint. This allows us to insert a reference to the target
    object in these properties and because these properties are passed to `doConstraint()`,
    this provides us with a means to pass the necessary information to `doConstraint()`
    to get at the `Mesh` data. There is a minor point to consider here though: Blender
    properties can only be numbers or strings so we cannot actually store a reference
    to an object but have to settle for its name. Because a name is unique and Blender''s
    `Object.Get()` provides a way to retrieve an object by name, this is not a problem.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**The code for `doConstraint()` and `doTarget()` will look like this (the full
    code is provided as `zoning_constraint.py`):**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '**The highlighted lines show how we pass the name of the target object to `doConstraint()`.
    In `doConstraint()` we first retrieve the target mesh. This may throw an exception,
    for example, if the target object is not a mesh, but this will be caught by Blender
    itself. The constraint will not be affected then and an error is shown on the
    console, but Blender will proceed happily.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Once we have the mesh data of the target object we retrieve the object location
    of the target object. We need this because all vertex coordinates are relative
    to this. Next we compare the location of the constrained object to all the vertex
    locations of the target mesh and remember the closest one to calculate the object
    location of the constrained object. Finally, we reconstruct the transformation
    matrix of the constrained object by combining various transformation components
    as before.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Aligning along a vertex normal**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Now that we can constrain an object to the closest vertex on a target mesh
    we can see that something is missing: the object is not oriented in a meaningful
    way. This might not always be a problem, for example, trees will normally point
    upward, but in many situations it would be nice if we could orient the constrained
    object perpendicular to the surface. This is the same for all practical purposes,
    as orienting the constrained object along the vertex normal of the vertex it has
    been snapped to.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Therefore, after finding the closest vertex we determine the angle between
    the vertex normal and the z-axis (that is, we arbitrarily define the z direction
    as ''up'') and then rotate the constrained object by the same amount around the
    axis perpendicular to both the vertex normal and the z-axis. This will orient
    the constrained object along that vertex normal. If the constrained object was
    rotated manually before adding the constraint these previous rotations would be
    lost. If that is not what we want, we can apply any rotations permanently before
    adding the constraint.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**To implement this alignment feature, our code will change (`zoning_constraint.py`
    contains these changes already): `doConstraint()` will have to calculate the rotation
    part of the transformation matrix. We have to calculate the rotation angle, the
    rotation axis, and then the new rotation matrix. The highlighted part of the following
    code shows that the essential tools for these calculations are already provided
    by the `Mathutils` module:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '**In the preceding code we can see that we have made an alignment dependent
    on the `NormalAlign` property. Only if it is set do we calculate the necessary
    transformation. Therefore, we need to adapt `getSettings()` as well because the
    user needs a way to select whether he wants alignment or not:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '**As shown, the `NormalAlign` property will be set to `True` by default. The
    option is then presented as a simple pop up with a toggle button. If the user
    clicks outside the pop up or presses the *Esc* key, the return value from `PupBlock()`
    will be `None` and we won''t change the `NormalAlign` property. Otherwise, it
    will be set to the value of the toggle button.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**The effects are shown in the illustrations. The first one shows a small pine
    tree constrained to a vertex of a simple subdivided ground plane. It is snapped
    to the exact vertex location but its z-axis points straight up along the global
    z-axis. The following screenshot shows a fir tree constrained to a vertex in a
    craggy landscape.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**![Aligning along a vertex normal](img/0400-04-14.jpg)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**If we turn on the `NormalAlign` property we see that the tree model is no
    longer pointing straight up, but that its z-axis is aligned along the direction
    of the vertex normal of the vertex it is snapped to. The following screenshot
    shows a fir tree constrained to a vertex and aligned along the vertex normal.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**![Aligning along a vertex normal](img/0400-04-15.jpg)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**It is possible to restrict the vertices the model can snap to even further,
    for example, to just the vertices belonging to a vertex group. In the following
    illustration, our model cannot move beyond the extent of the vertex group that
    is shown in white. How this might be accomplished is shown in the next section.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**![Aligning along a vertex normal](img/0400-04-16.jpg)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Snap to vertices in a vertex group**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**What if we want to restrict the vertices we can snap an object to? This can
    be achieved by defining a vertex group and then consider only vertices from this
    vertex group as candidates to snap to. The code needed for this would take just
    a couple of lines and the relevant part of `doConstraint()` would look like this
    (the highlighted code shows the additional lines dealing with the matching against
    a vertex group):**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '**The `try/except` construction ensures that if the `VertexGroup` property
    refers to a nonexistent vertex group, we will get the chance to check all vertices.
    Of course, we now need a way for the user to select the vertex group, so `getSettings()`
    will have to be adapted too. We settle for a simple string input field where the
    name of a vertex group can be typed. There is no checking if the vertex group
    exists and if we do not want to restrict the snapping to a vertex group, then
    we can either leave this input field blank or type in the name of a nonexistent
    group. Not very elegant but it works (added lines highlighted):**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '**The next screenshot shows how the input box for the vertex group may look:**'
  prefs: []
  type: TYPE_NORMAL
- en: '**![Snap to vertices in a vertex group](img/0400-04-17.jpg)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Note that the script constraint also presents the user with a VG string input
    field that may refer to a vertex group, but this is different from the vertex
    group input field that we show the user in the **Options** pop up. This VG field
    will alter the way the constraint looks at a target. If a valid vertex group is
    set here, the target matrix passed to `doConstraint()` will be that of the median
    position of the vertices in the vertex group.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**# Summary'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we saw how different animated properties can be linked together
    and how we could constrain the spatial properties of objects to complex limitations.
    We have learned how to:'
  prefs: []
  type: TYPE_NORMAL
- en: Drive one **IPO** from another by a Python expression
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Work around some limitations inherent in pydrivers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Restrict the motion of objects and bones by adding constraints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write a constraint in Python that will snap an object to the closest vertex
    on another object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next we take a look at how to perform some action every time we advance a frame
    in our animation.**
  prefs: []
  type: TYPE_NORMAL
