- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Introduction to PyCharm – the Most Popular IDE for Python
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PyCharm 简介 – 最受欢迎的 Python 集成开发环境
- en: Welcome to the second edition of *Hands-On Application Development with PyCharm*!
    Most programmers have the objective to build robust, high-quality software that
    can stand the test of time. The most important step to reach this goal is choosing
    the correct language. With so many languages out there, which is the best one
    to choose? A stellar programmer will take many things about the language into
    consideration. One of the most important aspects of the programming language to
    consider is the support tools that are necessary for the development stages. The
    **Python** programming language is rumored to enable great productivity compared
    to many other languages. Python’s famous *batteries included* philosophy embodies
    this idea by bundling a powerful standard library, a code editor, and a debugger.
    Everything is built into the language’s normal installer, which is available from
    [https://www.python.org](https://www.python.org). There’s just one small problem,
    at least for me – Microsoft.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到《PyCharm 实战应用开发》的第二版！大多数程序员的目标是构建健壮、高质量的软件，这些软件能够经受时间的考验。实现这一目标最重要的步骤是选择正确的语言。在这么多语言中，哪一种是最好的选择呢？一位杰出的程序员会考虑很多关于语言的因素。在编程语言中需要考虑的最重要方面之一是开发阶段所需的工具支持。据说
    **Python** 编程语言与其他许多语言相比，能够极大地提高生产力。Python 著名的 *batteries included* 哲学通过捆绑一个强大的标准库、一个代码编辑器和调试器来体现这一理念。所有这些都被整合到了语言的正常安装程序中，可以从
    [https://www.python.org](https://www.python.org) 获取。但至少对我来说，有一个小问题——微软。
- en: I know what you’re thinking. You’ve just mentally prepared yourself for a protracted
    rant from one of those **Unix**/**Linux** guys complaining about the big, bad
    evil that is Microsoft. I’m not going to do that because I’m not sure I’m a Linux
    guy. I mean, I do have an awful lot of cargo pants in my closet. I can’t help
    it. They’re just so roomy and you can carry all of your stuff without dragging
    a bag around with you. I’ll also admit to having a great many T-shirts with emblems,
    logos, or statements that maybe only 5% of the people I encounter will understand.
    These T-shirts are very funny, but the only grins I get are from my colleagues.
    The more I think about it, I’m not a Linux guy. To me, Linux is a tool. Sometimes,
    it’s the right one, but sometimes, it isn’t. Since I’m not a Linux fanboy, that
    can’t be the reason for my statement that Microsoft is the problem. The real reason
    is quite the opposite. About 30 or so years ago, Microsoft did something massively
    right. They created the first really good commercially available **integrated
    development** **environment** (**IDE**).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道你们在想什么。你们已经在心理上准备好听一位那些 **Unix**/**Linux** 的人抱怨微软这个大坏蛋了。但我不打算这么做，因为我并不确定自己是不是一个
    Linux 的人。我的意思是，我确实有很多条卡其裤在衣柜里。我无法控制自己。它们真是太宽松了，你可以携带所有东西而不需要拖着包走来走去。我还要承认，我有很多带有徽章、标志或可能只有我遇到的5%的人能理解的说法的T恤。这些T恤非常有趣，但我得到的唯一笑容都是来自我的同事。越想越觉得，我并不是一个
    Linux 的人。对我来说，Linux 只是一个工具。有时候，它是正确的选择，但有时候，它并不是。既然我不是一个 Linux 迷，那么这不能成为我声称微软是问题的原因。真正的理由正好相反。大约30年前，微软做了一件非常正确的事情。他们创造了第一个真正好的商业化的
    **集成开发** **环境** (**IDE**)。
- en: In truth, it may have been more than 30 years ago, and there may have been others
    before it. However, many “senior developers” in the software business today got
    their start with a Microsoft product called **Visual Basic** (**VB**). OK; this
    is the part where the language snobs sneer and hold their noses as though they
    were just presented with a plate of Brussels sprouts, or maybe a dirty diaper,
    but let’s reel it back in. 30 years ago, most people rocking home computers only
    had a handful of options. **Beginners All-Purpose Symbolic Instruction Code**
    (**BASIC**) shipped with just about every computer made from 1978 forward. It
    was an age when not even Apple had a **graphical user interface** (**GUI**) on
    their **operating system** (**OS**). That didn’t happen until 1983 when Apple
    released Lisa. We had mice, and we could create programs capable of working with
    pointing devices, but the OS didn’t have a windowing system. They didn’t need
    a windowing system because back then, computers could only run one program at
    a time.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Writing desktop software for computers that lacked OS-level support for Windows
    was hard. There were no **software development kits** (**SDKs**) or **application
    programming interfaces** (**APIs**) to handle any of the heavy lifting. Writing
    software was mostly an exercise in tedium. You had to write hundreds of lines
    of box-drawing boilerplate code in a tool that was barely better than Notepad.
    Then, one day in 1991, the year I graduated from the University of Oklahoma, it
    all changed.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft released a version of BASIC that included the ability to create **desktop
    GUIs** right there in the development environment. They called it *Visual Basic*.
    The first versions ran in **Microsoft’s Disk Operating System** (**MS-DOS**),
    but later, we got support for Windows, Windows 2, and then Windows 3.1\. Windows
    3.1 was significant because that’s when we got true multitasking if our PC was
    equipped with an 80386 processor. PCs were no longer limited to running one program
    at a time, and the Windows OS made mouse-driven interaction ubiquitous.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: 'Things got interesting with VB. Instead of coding an interface, you drew the
    interface. The IDE included a palette of components and a window. You could draw
    buttons, text boxes, and anything else you needed, directly onto the window. After
    you drew them, you would then “wire them together” with event handlers. What you
    drew was what showed up when you ran the program. The VB **user interface** (**UI**)
    was ultimately carried over into Microsoft’s Visual Studio. Even today, Visual
    Studio 2022 continues with the same features that were so groundbreaking in 1991\.
    *Figure 1**.1* shows the toolkit used to draw visual UIs for Windows:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.1: The Visual Studio IDE originated as a product called Visual Basic
    in 1991\. It defined the standards for what a good IDE should be](img/B19644_Figure_1.01.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.1: The Visual Studio IDE originated as a product called Visual Basic
    in 1991\. It defined the standards for what a good IDE should be'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1：Visual Studio IDE起源于1991年的Visual Basic产品。它定义了良好IDE应该具备的标准
- en: The VB3 IDE that began my career introduced even more ground-breaking features
    that my smug, cargo-pants-wearing Unix colleagues could only dream of. They were
    still fighting over vi’s superiority over Emacs, or vice versa, depending on whom
    you asked. Meanwhile, VB3 had colored syntax highlighting, support for editing
    multiple files, a graphical interface editor for drawing buttons and other screen
    widgets, and a visual programming tool that tied code, events, and GUI elements
    together. It had a debugging system you could use by simply clicking a line number.
    Doing so would create a red dot – a breakpoint in the code where the execution
    would stop during a test run, allowing the developer to inspect the state of the
    running program. It was pure coder nerd-vana! Love them or hate them, Microsoft’s
    VB IDEs defined what IDEs are supposed to be today. Nobody who has learned to
    code using a Microsoft IDE, whether it be a legacy language or a modern one, is
    willing to accept anything less than that experience.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 那个开启我职业生涯的VB3 IDE引入了更多革命性的特性，我的那些自负、穿着工装裤的Unix同事只能梦想拥有。他们还在争论vi和Emacs谁更优越，或者反过来，这取决于你问的是谁。与此同时，VB3拥有彩色语法高亮、支持编辑多个文件、用于绘制按钮和其他屏幕小部件的图形界面编辑器，以及将代码、事件和GUI元素结合在一起的视觉编程工具。它有一个调试系统，你可以通过简单地点击行号来使用。这样做会在代码中创建一个红色圆点——一个在测试运行期间执行会停止的断点，允许开发者检查正在运行的程序的状态。这是一个纯粹的程序员乌托邦！无论你喜欢还是讨厌，微软的VB
    IDE定义了今天IDE应该是什么样子。任何使用微软IDE学习编码的人，无论是传统语言还是现代语言，都不愿意接受低于那种体验的东西。
- en: With every language that I’ve learned since, the first thing I always do is
    find the very best IDE available that offers those features I can’t live without.
    When I started working with Python 3 about six years ago, I found PyCharm. I used
    it to perform a full re-write on a complex **software-as-a-service** (**SaaS**)
    product, which took me about 18 months to complete. It was trial by fire. In this
    book, I intend to share what I learned, complete with scorch marks.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 自从我开始学习每一种语言以来，我总是首先寻找提供我无法离开的特性的最佳IDE。大约六年前，当我开始使用Python 3时，我发现了PyCharm。我用它对一个复杂的**软件即服务**（SaaS）产品进行了全面的重写，这个过程花费了我大约18个月的时间。这是一次真正的火炼。在这本书中，我打算分享我所学到的知识，包括所有的经验教训。
- en: Throughout this book, we will be learning about the general interface of the
    PyCharm IDE, along with customizations and extensions to help you adapt your tools
    to the kind of work you’ll be doing with Python. This first chapter discusses
    the merits of IDEs in general. I’ll provide a comparison of the most common tools
    used for Python development. Some of them are very good while others, despite
    being widely used, are fairly primitive.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们将学习PyCharm IDE的一般界面，以及自定义和扩展，以帮助您将工具适应您将使用Python进行的类型的工作。第一章讨论了IDE的一般优点。我将提供最常用于Python开发的工具的比较。其中一些非常好，而其他一些，尽管被广泛使用，但相当原始。
- en: 'We’ll cover the following main topics in this chapter:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: The purpose of PyCharm as a Python IDE and some notable details on its developing
    company, JetBrains
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PyCharm作为Python IDE的目的以及其开发公司JetBrains的一些显著细节
- en: The usage of PyCharm within the community and a breakdown of which professions
    tend to utilize PyCharm the most
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PyCharm在社区中的使用情况以及哪些职业倾向于最频繁地使用PyCharm
- en: A comprehensive outline regarding the advantages and disadvantages of using
    PyCharm, in comparison to other Python editors/IDEs
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一份关于使用PyCharm相对于其他Python编辑器/IDE的优缺点全面概述
- en: The differences between the Professional and Community editions of PyCharm and
    the additional functionalities that the paid edition offers
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PyCharm专业版和社区版之间的区别以及付费版提供的额外功能
- en: On the other hand, if you have already decided that PyCharm is the Python IDE
    for you, feel free to jump to [*Chapter 2*](B19644_02.xhtml#_idTextAnchor028),
    *Installing and Configuring PyCharm*, to go through the installation and registration
    process. If you have already downloaded and successfully set up PyCharm on your
    system, you might want to begin at the second section of this book, starting from
    [*Chapter 3*](B19644_03.xhtml#_idTextAnchor052), *Customizing Interpreters and*
    *Virtual Environments*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果你已经决定PyCharm是你需要的Python IDE，那么请随意跳转到[*第2章*](B19644_02.xhtml#_idTextAnchor028)，*安装和配置PyCharm*，开始安装和注册过程。如果你已经下载并在你的系统上成功设置了PyCharm，你可能想从本书的第二部分开始，从[*第3章*](B19644_03.xhtml#_idTextAnchor052)，*自定义解释器和虚拟环境*开始。
- en: Technical requirements
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter is introductory, so we won’t be coding yet and the technical requirements
    are nil. It’s [*Chapter 1*](B19644_01.xhtml#_idTextAnchor014) and I know you’re
    all fired up and ready to go and nil is boring. So, let’s get moving!
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是入门性的，所以我们不会编写代码，技术要求为零。这是[*第1章*](B19644_01.xhtml#_idTextAnchor014)，我知道你们都热情洋溢，准备出发，零是无聊的。所以，让我们开始吧！
- en: 'First, here is what you will need to be successful with this book:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这是你成功使用本书所需的东西：
- en: A computer. I know! It’s obvious, but I pride myself on being complete and leaving
    nothing to chance!
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台电脑。我知道！这很明显，但我以我的全面性而自豪，不留任何余地！
- en: An OS. This works best if it is installed on your computer already since we
    won’t cover how to do that in this book. Windows, macOS, Linux – it’s all the
    same as far as this book is concerned because PyCharm works in all three, and
    the UI is nearly identical in each environment.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作系统。如果它已经安装在你的电脑上，这将是最有效的，因为我们不会在这本书中介绍如何安装它。Windows、macOS、Linux——就本书而言，它们都是一样的，因为PyCharm在这三个环境中都能运行，并且每个环境的UI几乎相同。
- en: An installation of Python. We’re going to be using Python 3 exclusively in this
    book. There are a few different “flavors” of Python 3 but for the most part, the
    plain old Python 3 from [https://www.python.org](https://www.python.org) will
    be fine. We’ll get into those “flavors” later when we start talking about virtual
    environments in [*Chapter 3*](B19644_03.xhtml#_idTextAnchor052), *Customizing
    Interpreters and Virtual Environments*. If revision numbers give you comfort,
    the latest release at the time I’m writing this book is 3.11.1\. The Python revision
    I’m using in that production SaaS app I mentioned earlier is 3.8\. If your Python
    3 installation is older than that, you should update it.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装Python。在这本书中，我们将仅使用Python 3。Python 3有几个不同的“风味”，但大部分情况下，从[https://www.python.org](https://www.python.org)下载的普通Python
    3就足够了。我们将在[*第3章*](B19644_03.xhtml#_idTextAnchor052)，*自定义解释器和虚拟环境*中讨论这些“风味”。如果修订号让你感到安心，我在写这本书时的最新版本是3.11.1。我之前提到的那个生产SaaS应用中使用的Python版本是3.8。如果你的Python
    3安装版本比这更旧，你应该更新它。
- en: At some point, a **GitHub** account might come in handy since I will be sharing
    the code from the book using a **Git** repository.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在某个时候，拥有一个**GitHub**账户可能会很有用，因为我会使用**Git**仓库分享书中的代码。
- en: The continued success of Python
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python的持续成功
- en: 'In the first edition of this book, the author titled this section *The recent
    rise of Python*. Time has passed and I’m picking up where he left off. I think
    it’s important to point out that the *recent* rise has more or less continued
    since the first edition of this book was published. Python has continued to be
    one of the most popular and widely adopted languages for some very good reasons.
    One of those reasons is that Python stresses readability and uses a simple syntax.
    This allows newcomers to the language, and indeed to the field of software development,
    a quick path to success. Contrast that with the previously normal experience of
    forcing college and university students to learn C or C++ as their first language.
    These languages are terse and complicated and generally have a poor track record
    when it comes to developer productivity. Sure, C and C++ are powerful languages
    and can produce the most performant software available. However, in my experience,
    a language that can take you from “Hello World” to being able to produce useful
    software in a short period trumps the performance gains in all but the most extreme
    cases. **Guido van Rossum**, the creator of Python, compares the quickness of
    Python to other languages in his paper *OMG-DARPA-MCC Workshop on Compositional
    Software Architecture*. In the paper, van Rossum states that development in Python
    is estimated to be 3-5 times faster than that in Java, and 5-10 times faster than
    that in C/C++. Keeping this difference in mind, we can easily understand why Python
    is being so widely adopted. After all, time is money. You can find Guido van Rossum’s
    complete essay here: [http://www.python.org/doc/essays/omg-darpa-mcc-position/](http://www.python.org/doc/essays/omg-darpa-mcc-position/).'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: The comparison between Python and Java or C/C++ is a weak one since these languages
    are designed and used for different applications. C and C++ are used when very
    high performance is required. Most OSs are written in C++, as are real-time systems
    such as those you’d find in a Tesla automobile or modern spacecraft. It isn’t
    necessarily fair to compare specific productivity between Python and C++ because
    they aren’t used to make the same types of applications.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: 'Java, on the other hand, is used to develop the same types of applications
    for which you might use Python: enterprise and web applications. Java, though,
    requires a lot of boilerplate. This means a developer has to create a lot of code
    and structures just to support the application’s existence before they can even
    think about writing code for the application itself. This boilerplate is largely
    absent from Python. Furthermore, Java relies on a very rigid, static object-oriented
    paradigm. Python, in contrast, is far more flexible, offering a dynamic programming
    model. Even though the two languages are used to make the same type of application,
    Python gives you some serious shortcuts, owing to its more flexible paradigm.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'These factors that comprise Python’s strengths, along with many others, have
    coalesced to form a very accessible development language supported by a community
    of raving fans. That community is still growing by introducing coding to a gamut
    of fields and professions distinct from those of us who historically focus solely
    on traditional application development. At the time of writing, the **TIOBE Index**,
    a ranking system for the popularity of programming languages, ranks Python as
    the number one language, as seen in *Figure 1**.2*:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.2: TIOBE rankings show Python to be the most popular language](img/B19644_Figure_1.02.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.2: TIOBE rankings show Python to be the most popular language'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Python has a huge standard library that provides anything you might need to
    build any kind of software you can imagine. If that statement proves false for
    your specific project, there is a vast third-party and largely open source ecosystem
    consisting of hundreds of thousands of libraries upon which you can build. You
    can find a catalog of these libraries at [https://pypi.org](https://pypi.org).
    Taking all this together, a new software developer can go from idea and zero Python
    experience to a production application very quickly. This process can be greatly
    accelerated by a good IDE.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: The philosophy of IDEs
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Back when I was your age, things were different. That is, of course, unless
    we are the same age, in which case everything was the same. We didn’t have the
    internet. When we wanted to learn new coding languages and techniques or understand
    the history of our craft, we were required to take a sacred pilgrimage. One year,
    I smuggled in a Polaroid. You can see the pictures I took in *Figure 1**.3*. You
    should understand that all of what I am about to tell you is both true and a closely
    guarded industry secret. Just so we’re clear, you didn’t hear this from me.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Hidden somewhere in a mystic range of mountains, seekers of great coding wisdom
    would ascend the 10,000 stairs by the light of the full moon in search of the
    Master. The journey was not easy, and the wisdom imparted had to be hard-earned.
    It was on one such crusade that I learned why good IDEs are so important. The
    Master said, “If you know the language, and you know the IDE, you need not fear
    the result of a hundred deployments.”
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 1.3: High in the sacred mountains, up the 10,000 stairs\uFEFF,\uFEFF\
    \ lies the monastery where I learned to code](img/B19644_Figure_1.03.jpg)"
  id: totrans-37
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.3: High in the sacred mountains, up the 10,000 stairs, lies the monastery
    where I learned to code'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: The Master often speaks in riddles, so let me explain. *Deployment* refers to
    a published iteration or an **increment** of your software. In most professional
    circumstances, the objective is to publish your software. If our objective is
    to publish, the next sticking point is that we must know a programming language.
    I assume you have at least a tacit understanding of programming in Python. That
    just leaves the Master’s reference to the IDE.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: There are several classes of tools a developer might use to develop Python code.
    The Python language can be considered an interpreted language. We could argue
    that when it runs, some of the code is optimized into C code and cached, but at
    this stage, we aren’t worried about that level of detail. The point is that a
    Python program exists as simple plain text files and can be executed in that form.
    Contrast this with statically compiled languages such as C, C++, C#, Java, or
    Go. Those and many other languages require the code in the text files to undergo
    a compilation phase where a new executable file is produced. In C#, you can’t
    simply execute a `.cs` file. You need to compile it into a binary, then execute
    the binary. Since Python executes its code directly via the Python interpreter,
    the level of tooling needed to work on Python can be very simple. Essentially,
    any text editor will do. There are three levels of editor capability to choose
    from.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: The first is a simple text editor. Simple text editors are generally limited
    to opening, editing, and saving text. They are generic tools designed to work
    with any kind of text file, from grocery lists to `systemd` configurations. In
    Windows, you might know it as *Notepad*. On a Mac, you might use *TextPad*, and
    if you are rocking a Linux desktop such as `systemd` configuration is, don’t sweat
    it; it’s a system administration file on Linux. I just needed something that sounded
    complicated to characterize the more complex end of the text file gamut.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'The second evolution of programming editors is called *enhanced editors*. These
    editors are purposefully designed to work with technical files. Some popular examples
    include the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio Code
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Atom
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notepad++
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UltraEdit
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sublime Text
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JetBrains Fleet
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bluefish Editor
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IDLE (the editor that ships with Python)
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These tools are designed to work with a wide range of programming languages
    and can generally be easily customized to add support for emerging languages.
    Enhanced editors offer some common features that make a developer’s life a little
    nicer, such as these:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Syntax highlighting, which color codes keywords and other semantic elements
    in your code.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Macros, which allow the developer to record and play back common keystrokes
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project and file organization to allow easy switching between multiple files
    that make up a project
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rudimentary code completion to reduce the amount of typing needed to write your
    code
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plugin support for other niceties such as linters, spell checkers, file previews
    for your code, and more
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Over time, some of these enhanced editors have become very robust because you
    can customize and expand their capabilities. When you consider these tools as
    they are right out of the box, they are more useful and specialized than general
    text editors, but they fall short of qualifying as IDEs.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of the code editor food chain is the **IDE**. If you were to look
    inside the cockpit of a fighter plane from the World War I era, you’d see a few
    simple controls and nothing more. If that’s a text editor, the IDE is the cockpit
    of a Boeing 747 aircraft. Every tool a developer could ever desire or need is
    crammed into a comparably complex UI. IDEs contain all the features of an enhanced
    text editor, but usually offer the following additional enhancements:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Some easy ways to run your code right from the editor.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tooling to help manage your source code repository, such as **Git** or **Subversion**.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An integrated, easy-to-use debugger, which allows you to pause the execution
    of a running program and inspect or alter its current state.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tools to help you write automated tests such as unit tests and run and visualize
    the results.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Complex code completion is based on the introspection or indexing of the code
    in your project. In modern IDEs, this is enhanced using **artificial** **intelligence**
    (**AI**).
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Profiling tools to help you find execution bottlenecks.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrated tooling to help with supplementary systems, such as databases.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tools for deploying your code to a server or cloud environment right from the
    IDE.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some popular examples of IDEs include the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio (this is different from Visual Studio Code)
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PyCharm
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IntelliJ IDEA
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NetBeans
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apple Xcode
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Xamarin Studio
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Eclipse
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, the IDE is the most powerful weapon in your coding arsenal.
    It is important to use the best one available to you. If you are new to software
    development, or maybe even not-so-new, you might wonder why the enhanced editors
    are so popular. At the time of writing, roughly 50% of developers use Visual Studio
    Code, which is not on my list of IDEs.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Many developers prefer a more “lightweight” development environment. This is
    especially true of frontend web developers who swear by Sublime Text and Visual
    Studio Code. In truth, they need all the features of the IDE, and they use them,
    but they are spread out across different tools they use throughout the day. A
    frontend developer relies on profilers and debuggers that run in web browsers
    and they don’t need those tools in an IDE. Instead, they can get a simpler editor
    that downloads quickly, installs simply, and runs instantly when they click the
    icon in their OS.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: I submit that if you are doing full stack web development or mobile development,
    or you need to work servers or containers, an IDE is a better choice.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: There exists a certain class of software developer who swears you should never
    use anything other than the simplest possible tools. They believe that reliance
    on a tool to do coding and related hard work diminishes the overall mastery and
    accomplishment needed to be considered proficient. I couldn’t disagree more. One
    year, while at the monastery, the Master told me a story of a great swordsman
    from Japan named Miyamoto Musashi. In his day, every samurai knew of Musashi as
    the greatest living swordsman and all the samurai wanted to take a shot at defeating
    him. Back then, duels were usually fought to the death. One day, a dueling challenger
    met Musashi as he was getting off a boat. Musashi was unarmed. The challenger
    waited until Musashi could fashion a wooden sword, called a *bokken*, from one
    of the boat’s oars, which he intended to use in the dual. Legend has it Musashi
    made a fool of that challenger and left him alive, much to the challenger’s disgrace.
    Musashi, the Master said, was the finest warrior who ever lived, and his skill
    with a sword has never since been matched. However, if the objective were simply
    to defeat him, I could have easily done so with a machine gun.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: In my opinion, limiting the tools you use owing to a sense of pride in your
    capability, or lack thereof, is foolish. The objective of a software developer
    is to ship software, usually on an unforgiving deadline. It isn’t to waste time
    trying to prove yourself to someone else’s standards, unless, of course, you’re
    a degree-seeking student. I’m sure there are a few of you reading this book. Play
    the game and do what your professors say. You should realize that once you graduate,
    everything changes. You will be expected to produce code quickly, accurately,
    and consistently. This is best achieved via the automation available in a good
    IDE. You should choose the best tool for the job at hand. I found PyCharm helped
    me to become productive while I was learning the Python language. When you start,
    and you’re not using an editor that corrects your line spacing and indents, you’re
    going to make a lot of silly mistakes. It’s frustrating. I’d think to myself,
    “If I were using C#, I’d be done by now.” I was even tempted to abandon Python
    and PyCharm for something more comfortable. However, that’s not what I wanted
    to do.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: PyCharm will underline all those silly mistakes for you and correct them with
    the touch of a button! I learned, after seeing those mistakes underlined over
    and over, what to do when I’m using an editor without code inspection. Today,
    when I am working in other languages, I still use Python rules. Having learned
    Python with the help of PyCharm, I was able to ship faster, learn faster, and
    improve my code in other languages and tools. Do me a favor and never let anybody
    tell you you’re not a *real developer* because you didn’t do something their way.
    If they persist, tell them nano is better than vi or Emacs, and just walk away.
    Such a statement will probably cause their head to explode.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: I’d like to make one more comment about Visual Studio Code. This editor has
    evolved through plugins to the point where it can compete with a fully featured
    IDE. However, this comes at a cost compared to a professionally developed IDE
    such as PyCharm. To get the identical features you’d find in PyCharm in Visual
    Studio Code, you’d need to install a large number of plugins. These plugins are
    all written by the community, which means they are all independent development
    efforts. These plugins will never work as cohesively as the base features you
    will find in an IDE such as PyCharm. This is also true when comparing Visual Studio
    with Visual Studio Code. Try creating a C# project in Visual Studio versus Visual
    Studio Code and you’ll find the process is dreamy and smooth in Visual Studio.
    Visual Studio Code, on the other hand, requires a lot of command-line work and
    lots of weird plugin installations. The experience just isn’t the same. The same
    observation holds with other editors such as vim, which can be heavily customized.
    You’ll spend a week messing with plugins and open source scripts to achieve, at
    best, partial parity with an IDE’s out-of-the-box functionality.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: PyCharm as a Python IDE
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It’s all well and good to talk about tool comparisons common to other languages.
    But we don’t care about that, do we? We want to know our options for Python! The
    best IDEs are typically specialized. PyCharm is specialized in working with Python.
    That’s it. When you create a new project in PyCharm, you’ll see options for Python
    projects and nothing else. Contrast this experience with Visual Studio. In my
    opinion, Visual Studio is the only close competitor to PyCharm when it comes to
    working with Python projects. When a project is created in Visual Studio, you
    will most likely spend a good five minutes trying to wade through the myriad of
    options. The IDE supports dozens of languages, and that is compounded by a dozen
    project types such as web, desktop, and others. Visual Studio is trying to be
    all things to all developers. PyCharm only wants to play with Python developers.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'PyCharm itself was created with a few design goals in mind:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Intelligent coding assistance
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Streamlined programming tools
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web development options
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scientific computing support
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual debugging and performance profiling
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We’ll take a look at each of these design goals in turn, but first, I need
    to point something out. At the time I’m writing this, PyCharm is about to go through
    a big change. JetBrains is working on a brand-new user experience. By the time
    this book is published, there is a strong chance that this new UI will be the
    default. If you’re new to PyCharm, you should understand that you’re going to
    see it in two different ways for a while. The classic UI will continue to be available
    in the product for a time, allowing us to ease into the new experience. I’ve decided
    I’m going to embrace the new UI given the time between the first edition and this
    one is a few years. That said, it bears mentioning that you’re going to see the
    classic UI alongside the new UI until probably late 2024 when the old UI is no
    longer maintained. It will become deprecated and one day will disappear into the
    sands of time like Shelley’s fabled statue of Ozymandias:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.4: The new UI (top) compared to the classic UI (bottom)](img/B19644_Figure_1.04.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.4: The new UI (top) compared to the classic UI (bottom)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 1**.4* shows the two UIs side by side. The design objective of the
    new UI is to reduce the clutter in the interface. They’re not wrong on that point.
    As the tool has grown over the years, more and more features have been crammed
    into the menus, making the UI a little bit daunting for new users. The biggest
    thing to realize is that most of the things you’d find in the menu are still there,
    but the menu system itself is hidden beneath the hamburger icon in the top-left
    corner of the screen. Don’t worry; I’ll cover this in detail later. As I write
    this, there is a setting we’ll review in [*Chapter 2*](B19644_02.xhtml#_idTextAnchor028),
    *Installing and Configuring PyCharm*, that allows you to toggle between the classic
    and new UIs.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: I wanted to point this out now because you’re about to see some screenshots,
    and if you’ve seen the old UI, you might think you’ve picked up the wrong book.
    You haven’t. Just the opposite. If I time this right, you’ll be the only one with
    the right book.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: Intelligent coding assistance
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I’m going to tell you something my wife says all the time. I’m very lazy. Wait.
    That came out wrong. She is saying that I’m lazy. I’m not saying that she is saying
    she is lazy. Sheesh. Writing is hard! I almost dug a hole there, didn’t I?
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: She’s not wrong. As a developer, I am essentially very lazy. I refuse to spend
    hours or even minutes doing something the long way. The Greeks had a legend about
    a guy named Sisyphus who was cursed to push a stone up a steep hill. As soon as
    he reached the top, the stone would roll back down the hill. Sisyphus was stuck
    in an infinite loop with no *Cmd*/*Ctrl* + *C* option on his keyboard.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s one thing I know: Sisyphus was not a software developer! Any software
    developer would have rolled that stone exactly twice, after which they would have
    spent eternity devising a system of pulleys and cranes controlled by an IoT device.
    Naturally, the microcontroller would be running a Python script. I digress.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: 'What *some* (I say in my head looking in my unsuspecting wife’s direction)
    might call lazy, I call *efficient*! As a developer, I want to create maximum
    effect with minimal effort in everything I do. Writing code is complicated. You
    are writing instructions for the most stubborn and unintelligent object ever devised.
    Coding is worse than trying to teach a 2-year-old to tie their shoes. Trust me,
    I’ve done both! Coders must be extremely specific and verbose in their explanation
    of any operations they want to perform. Furthermore, things are made worse by
    the language developers out there who tend to want to force users to write a bunch
    of boilerplate code. I’m talking about the excise code that has nothing to do
    with the code you want to write or the problem you want to solve. Python generally
    avoids this, so let me give an example of possibly the worst offender: Java.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Back in the day when I was a wee lad, Java was all the rage. There was this
    caste of corporate programmers involved with Java who thought up something called
    **Enterprise Java Beans** (**EJBs**). EJBs were supposed to be the epitome of
    module programming with reusable objects. It was an absolute beating to implement.
    Rather than simply making a class, which is all you need, you had to create a
    special file structure with various folders and manifest files to expose what
    was in the bean, and it was all compiled into a special format. It turned out
    that the special format was nothing more than a ZIP file. It took a lot of work
    just to make an EJB, which meant developers had to make a ton of files and write
    a lot of code just to get started on the functionality they needed to express
    to get their work done. That’s what we mean by *boilerplate*. Boilerplate is generally
    useless but necessary because, without it, the code doesn’t work.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: All IDEs have evolved because of this phenomenon. PyCharm evolved from JetBrains’
    Java IDE, IntelliJ. Python doesn’t usually have a lot of boilerplate required
    for your code to work, but it does come up. There are two kinds of boilerplate.
    The boilerplate needed to make old-school EJBs work is the bad kind. The boilerplate
    generated as a means to jumpstart your project is the good kind. As we’ll see,
    PyCharm, as with most IDEs, generates a folder structure, a set of files, and
    some basic code to get you started. That can be considered boilerplate. But in
    this case, that code isn’t retained. It is replaced by the real code for your
    project. The code generated by the IDE is just a mental prompt to get you going.
    It prevents you from having to create your project’s starting point by hand.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: 'All this is great, but boilerplate code generation isn’t what we usually think
    about when we hear “intelligent coding assistance.” We usually think of the feature
    pioneered by Microsoft called **IntelliSense**. If you’ll allow me to anthropomorphize
    the IDE for a moment, this feature watches as you type your code. All the while,
    the IDE is thinking about what you’re trying to do. When it sees a way it can
    help, such as by completing a word or line for you automatically, it presents
    that as an option. I have an intelligent person completing all my sentences for
    me: she’s my wife. When she completes my sentences for me, they are usually more
    organized and intelligent than they would have been if I were on my own. (This
    might be another reason she thinks I’m lazy.)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: I want to point out that not all tools with an IntelliSense-like feature are
    created equally. When you see this feature in an enhanced editor, it usually works
    differently than it would in an IDE. In enhanced editors, they use keyword lists
    to highlight and autocomplete the elements of a language. Really good enhanced
    editors might index your code and recognize variable and function names and use
    statistics to give you the most likely completion first. That option is generally
    followed by a long list of noise comprising every possibility that exists for
    a given completion. Code completion is becoming very advanced with the introduction
    of AI tools, and this makes the difference between IDEs and enhanced editors a
    little muddier, at least on this point. Tools such as GitHub’s Copilot can not
    only autocomplete variable names and keywords but also write entire sections of
    your code automatically.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: It is important to remember, at least as I write this, that those AI features
    are not part of the IDE or enhanced editor. They are implemented as plugins. Since
    this is true, I’ll continue espousing the merits of IDEs, and PyCharm in particular,
    based solely on the merits of the software by itself. We’ll discuss plugins in
    [*Chapter 16*](B19644_16.xhtml#_idTextAnchor401), *More Possibilities with* *PyCharm
    Plugins*.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: While enhanced editors might present you with a long list of possibilities for
    your code completion, PyCharm can analyze your code and perform more intelligent
    autocompletion. You also get code analysis, such as duplicate code warnings. A
    common antipattern in software development is copying and pasting code across
    or even within the same project. It’s a terrible but common thing to see. PyCharm
    will spot duplicate code and flag it for you so that you can be reminded to refactor
    the duplicated code into a function or module that can be reused and maintained
    in one location.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: PyCharm can also perform a static analysis of your code. This type of analysis
    is looking for antipatterns within the code itself; for example, PyCharm will
    detect dead code like that shown in *Figure 1**.5*. Concerning Python development,
    PyCharm will automatically format your indentations and give you critical feedback
    on how your code conforms to **PEP-8** conventions, which are stylistic requirements
    you must meet to be considered *pythonic* (that’s a good thing).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you were to type the following code into a new file in PyCharm,
    you’d see PyCharm’s warning that you have created unreachable code on line 13\.
    The text on that line is highlighted. Hovering your mouse over this highlighted
    line reveals what is wrong:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `print_hi` function starts innocuously enough by printing to the console
    whatever is passed into the function within the `name` argument. After that, we
    create a loop that will run 25 times. On each run of the loop, we print out `x`,
    which contains the current iteration. When the counter variable, `x`, reaches
    12, the loop exits via the `return` function, which, as luck has it, is on line
    12\. I assure you, this is purely a coincidence. Since the loop returns on line
    12, the code on line 13 will never be reached:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.5: PyCharm will highlight many common coding mistakes such as this
    one. The code on line 13 is unreachable, which is indicated when you hover your
    mouse over the highlighted code](img/B19644_Figure_1.05.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.5: PyCharm will highlight many common coding mistakes such as this
    one. The code on line 13 is unreachable, which is indicated when you hover your
    mouse over the highlighted code'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: PyCharm also allows you to navigate between files in a complex project by helping
    you find where functions, variables, and classes are defined, as well as where
    they are used. Over time, you’ll learn a set of keystrokes that will allow you
    to move anywhere in your project without your fingers leaving the keyboard.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: In essence, PyCharm’s intelligent coding assistance allows you to worry less
    about mistakes and more about your logic and requirements, which allows you to
    complete your code more quickly with fewer mistakes.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Streamlined programming tools
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Writing code is but one activity a developer performs each day in pursuit of
    a project deadline. Great developers also spend time debugging, testing, and profiling
    their products to produce the best possible result. We also need to deal with
    pushing code to testing servers, refactoring (other people’s) bad code, working
    with databases, and dealing with containers. There is tooling in PyCharm for each
    of these processes and more. When I write complicated web applications in PyCharm,
    the only tools I usually have open are PyCharm and a web browser: two tools each
    on their own monitor.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: The PyCharm debugger
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: My favorite feature and the one that got me excited the first time I used PyCharm
    is the debugger. PyCharm’s debugger is great. It is much better than the standard
    debugger you get with Python itself. Python ships with a debugger called **Python
    Debugger** (**pdb**). In my humble opinion, I’d rather eat bugs off the sidewalk
    than use this tool. I alluded to this earlier in this chapter. I grew up using
    Microsoft debuggers and simply nothing else will do. PyCharm’s debugger works
    exactly as I would expect. Click your mouse at the line where you want execution
    to stop to make a breakpoint and click the debug button in the IDE, and the program
    runs and stops at the indicated line. You will get a screen where you can inspect
    both the state of the stack as well as the terminal output. It’s very simple to
    use, and I’ll be showing you how to do so in [*Chapter 6*](B19644_06.xhtml#_idTextAnchor145),
    *Seamless Testing, Debugging,* *and Profiling.*
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Running tests with the graphical test runner
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Testing tools are integrated in the form of test runners. PyCharm supports all
    the major testing frameworks, including **pytest**, **nose**, and the regular
    unit test features from the standard library. Again, I’m coming from experiencing
    some very good IDEs, and in this case, I’m remembering Eclipse and Visual Studio,
    which both include graphical test runners. The adage *If the bar is green, the
    code is clean* is visually implemented in PyCharm. You can see an example in *Figure
    1**.6*. You can run your tests and see a list display showing what passed and
    what failed, though it is a list rather than a bar. You can then rerun your failing
    tests until they work.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ll give you a simple example. In `main.py` within this chapter’s source code,
    I have one file called `main.py` and another called `test_main.py`. The content
    of `main.py` is a simple function that adds two numbers together:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Within the `test_main.py` file, there is a simple unit test:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `Test` class contains two tests: one that will pass and one that will automatically
    fail. I usually make the automatically failing test first just to make sure I
    have my test class set up properly. Then, later, I remove the fail because of
    my dopamine addiction, which is only satisfied by green checkmarks in the test
    runner, as seen in *Figure 1**.6*. If I right-click on `test_main.py`, as seen
    in *Figure 1**.5*, I’ll get an option to run the tests within the file:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.6: Right-click the test_main.py file and click Run ‘Python tests
    in test…’ to run the unit tests contained within the file](img/B19644_Figure_1.06.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.6: Right-click the test_main.py file and click Run ‘Python tests in
    test…’ to run the unit tests contained within the file'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: 'Look to the lower-left corner in *Figure 1**.7*, which shows the test run’s
    completion, and you’ll see a list of tests that passed or failed with either a
    green check or a yellow X showing failure. Like all figures in this book, which
    are printed in black and white, you won’t see the colors. Color ink is expensive,
    and your father is right, money doesn’t grow on trees:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 1.7: PyCharm’s built-in test runner shows a traditional pass/fail\
    \ list (lowe\uFEFFr-left pane) to indicate passing and failing tests](img/B19644_Figure_1.07.jpg)"
  id: totrans-128
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.7: PyCharm’s built-in test runner shows a traditional pass/fail list
    (lower-left pane) to indicate passing and failing tests'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: PyCharm’s profiling tools
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Similarly, code profiling is built in and easy to use. You can click the **Profile**
    button to run the code. When the program exits, you will get a graph of each function
    call, along with the time and resources consumed by the call. This makes it easy
    to spot unrealized opportunities for improvement concerning the speed of execution
    and resource consumption.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the possibility that you have an algorithm in your program that might
    not be performing as you’d like. I know, I know, it would never happen to you,
    so supposed you just got hired, and the person they fired wrote this horribly
    performing algorithm. Maybe pretend it is 1956, and the guy who got fired from
    your new employer, New York Life Insurance Company, was one **Edward Harry Friend**.
    Friend wrote a paper titled *Sorting on Electronic Computer Systems*, which is
    likely the first published instance of an algorithm we know today as **bubble
    sort**. If Friend had written his algorithm in Python 3, it might look a little
    like this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Friend has just created a function that accepts a list as an argument, which
    in our case will be an array of integers. The objective is to sort these numbers.
    To do this, let’s create two loops, one inside the other:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Within these loops, each number is compared with the number before it. If it
    is determined those two numbers are out of order, they are swapped. In the next
    run of the loop, this happens again with the next two numbers, and this continues
    until it reaches the end of the list.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: If you’ve studied algorithms at all, you’ve probably heard of bubble sort, and
    you’ve been warned as to why it is not used. It is very slow. We have a `for`
    loop within another `for` loop, which is fine if the size of your unsorted list
    is small. But this algorithm slows down at a logarithmic rate as the list of numbers
    grows. Algorithm performance is measured using **big O notation**. I don’t want
    to turn this into an algorithm book, so I’ll just tell you that a loop inside
    another loop will scale poorly in terms of performance. In big O notation, we
    classify this algorithm as *O*(*n*2). That’s bad.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: In plain English, this means that if you double the count of numbers to sort
    (*n*), then your algorithm will take 22 or 4 times longer to process. If you multiply
    your count’s size by 5, then it becomes 52 or 25 times slower. The bigger the
    list, the slower it sorts.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'To show off the performance tool, we’re going to give this test run a list
    of 100,000 numbers to sort. Now is a good time to point out I’m running an Intel
    i9 processor. If you’re a student or some other budget-constrained consumer rocking
    an i3 processor (or worse), you might want to take the list of numbers down a
    few zeros if you want to try this out. It takes a good while on my i9:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let’s finish the test code by calling the function and printing the results:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We’ll cover the profiling tool extensively in [*Chapter 6*](B19644_06.xhtml#_idTextAnchor145),
    *Seamless Testing, Debugging, and Profiling*, but for now, let’s just run this
    code with the profiler and review the result. To run the profiler on the `performance.py`
    file, simply right-click the file and click **More Run/Debug**, then **Profile
    ‘performance’**, as shown in *Figure 1**.8*:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.8: Right-click the file you’d like to profile and click More Run/Debug
    | Profile ‘performance’ to see a performance profile](img/B19644_Figure_1.08.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.8: Right-click the file you’d like to profile and click More Run/Debug
    | Profile ‘performance’ to see a performance profile'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember, if you use the same code I did, this will take a long time to run,
    especially on a slower computer. Feel free to adjust the size of the list downward
    if it’s taking too long to run. The result is a `.pstat` file that displays as
    a table in PyCharm. Again, we’ll cover this more extensively in [*Chapter 6*](B19644_06.xhtml#_idTextAnchor145),
    *Seamless Testing, Debugging, and Profiling*. You can see the performance report
    in *Figure 1**.9*:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.9: PyCharm’s resource profiler shows the performance bottlenecks
    in a running program](img/B19644_Figure_1.09.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.9: PyCharm’s resource profiler shows the performance bottlenecks in
    a running program'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, 84.4% of the program’s time is spent in the `bubble_sort` function,
    which is the bottleneck. PyCharm has told you where to concentrate your refactoring
    efforts to improve the performance of your program.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Publishing from the IDE
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you need to publish your code to a testing server, and you aren’t using
    a continuous integration system for that, you can use PyCharm. To be clear, you
    should use a continuous integration system, but I often use the PyCharm features
    early in a project before the continuous integration system is operational to
    get code up for stakeholders to play with. You can deploy using **file transfer
    protocol** (**FTP**) or **secure file transfer protocol** (**SFTP**), or copy
    directly to a network share for a quick and easy way to share your progress with
    anyone who might want to review it.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring tools
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'PyCharm has robust refactoring tools you’d expect from a proper IDE. If you
    want to change a variable name, or even a method signature on a function, right-click
    and select the **Refactor** tool. Rest assured the changes you make will carry
    over to all related instances in your project, not just in the file you are editing.
    *Figure 1**.10* shows an example of this in action:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 1.10: PyCharm has a full \uFEFFselection of refactoring tools available](img/B19644_Figure_1.10.jpg)"
  id: totrans-154
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.10: PyCharm has a full selection of refactoring tools available'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: In addition to renaming a variable or function, there are other actions you
    can perform, such as changing the method signature and changing the structure
    of your object-oriented classes.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Working with databases in PyCharm
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you work with databases, the Professional edition of PyCharm includes a
    graphical table editor and SQL support for dozens of popular databases. Check
    it out in *Figure 1**.11*. I’ll talk more about the Professional edition of PyCharm
    a little later in this chapter; we’ll have a whole chapter on the database features
    in [*Chapter 11*](B19644_11.xhtml#_idTextAnchor266), *Understanding Database Management*
    *with PyCharm*:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.11: PyCharm has a robust and complete set of tools for working with
    relational databases such as Oracle, SQL Server, Postgres, and many more](img/B19644_Figure_1.11.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.11: PyCharm has a robust and complete set of tools for working with
    relational databases such as Oracle, SQL Server, Postgres, and many more'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, a great many relational and NoSQL databases are directly supported.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Remote development, containers, and virtual machines
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Finally, but not exhaustively, PyCharm has features for working with remote
    systems via **SSH**, local virtual machines using HashiCorp’s **Vagrant**, and
    extensive support for **Docker** containers.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: This isn’t an exhaustive list of what PyCharm can do for you, but by now, you
    get the point. Every tool you might need is integrated into the development environment.
    That’s probably why they called it an *integrated* *development environment*.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Web development options
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I’d wager that more than half the developers working in Python need, at some
    point, a web project. Whether you’re like me and you’re making a SaaS offering
    as a fully realized web application, or you are doing rocket science and you need
    a way to visualize and interactively share your latest fast-Fourier transform
    on deep space radio emissions data, web projects are usually inevitable. I’m not
    a scientist and I made that up. If the last sentence made sense to anyone, it
    was pure coincidence.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Working with web projects offers a new and separate layer of complexity. Most
    use three-tier designs commonly expressed with the **model-view-controller** (**MVC**)
    pattern. If you’re not sure what this means, stay tuned because there’s a whole
    section of this book dedicated to web development. For now, this means the application
    has a frontend where the user can interact, a middle tier containing connective
    logic, and a database tier for structured data storage and retrieval. Only the
    middle tier is done in Python. We’ll extensively cover web development in later
    chapters, but for now, I want to tell you about the level of tooling you get with
    PyCharm.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: The company that made PyCharm, JetBrains, makes a variety of IDEs targeted at
    different languages. One of their IDEs is specifically targeted toward web development.
    It is called **WebStorm**. I said earlier that good IDEs target one language.
    WebStorm targets JavaScript; specifically, we’re talking about full stack JavaScript.
    Modern JavaScript execution occurs in two places. Traditionally, JavaScript was
    always executed in the browser. About 10 years ago, **Node.js** was released and
    JavaScript was released from the confines of the browser window and allowed to
    run on the backend.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'Earlier, I alluded to a robust set of features in PyCharm for working with
    databases. JetBrains also has an IDE that targets SQL database developers called
    **DataGrip**. As it happens, the Professional edition of PyCharm includes the
    entire feature set available in WebStorm and DataGrip. When you buy the Professional
    edition, you’re getting three JetBrains products in one package: PyCharm, WebStorm,
    and DataGrip. When you use PyCharm to work on web projects, you need all three
    feature sets and they are there for you in the Professional edition.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Scientific computing support
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The growth of the data science field has played an important role in the growth
    of Python itself, and Python is now the most common programming tool used in scientific
    projects (even more common than **R**). Notable functionalities included in PyCharm
    that facilitate data science work are the integration of **IPython**, **Jupyter**
    notebooks, and an interactive console. The support for scientific computing in
    PyCharm is detailed in section four of this book, starting from [*Chapter 13*](B19644_13.xhtml#_idTextAnchor318),
    *Turning On Scientific Mode*. PyCharm also provides a customized view that optimally
    organizes workspaces in a scientific project called **SciView**, which is shown
    in *Figure 1**.12*:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.12: SciView in PyCharm grants access to scientific visualization
    tools via a slick interface](img/B19644_Figure_1.12.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.12: SciView in PyCharm grants access to scientific visualization tools
    via a slick interface'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Professional, Community, and Educational editions
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are three editions to PyCharm. I’ve alluded to two, because the third
    is a special version that is only useful to teachers, and the focus of this book
    is application development, not software development instruction. I’ll tell you
    about each, but I know what you want is a feature comparison chart. You’ll find
    it in *Figure 1**.13*:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **PyCharm Professional** | **PyCharm Community** |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
- en: '| Cost | Paid | Free |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
- en: '| Intelligent Python editor | ![Checkmark with solid fill](img/B19644_Figure_1.13.png)
    | ![Checkmark with solid fill](img/B19644_Figure_1.13.png) |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
- en: '| Graphical debugger and test runner | ![Checkmark with solid fill](img/B19644_Figure_1.13.png)
    | ![Checkmark with solid fill](img/B19644_Figure_1.13.png) |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
- en: '| Code navigation and refactor tools | ![Checkmark with solid fill](img/B19644_Figure_1.13.png)
    | ![Checkmark with solid fill](img/B19644_Figure_1.13.png) |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
- en: '| Code inspection | ![Checkmark with solid fill](img/B19644_Figure_1.13.png)
    | ![Checkmark with solid fill](img/B19644_Figure_1.13.png) |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
- en: '| Git, Subversion, and other source control tools | ![Checkmark with solid
    fill](img/B19644_Figure_1.13.png) | ![Checkmark with solid fill](img/B19644_Figure_1.13.png)
    |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
- en: '| Scientific tools | ![Checkmark with solid fill](img/B19644_Figure_1.13.png)
    |  |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
- en: '| Web development with HTML, JavaScript, CSS, and so on | ![Checkmark with
    solid fill](img/B19644_Figure_1.13.png) |  |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
- en: '| Python web framework support | ![Checkmark with solid fill](img/B19644_Figure_1.13.png)
    |  |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
- en: '| Performance profiling | ![Checkmark with solid fill](img/B19644_Figure_1.13.png)
    |  |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
- en: '| Remote development, containers, and so on | ![Checkmark with solid fill](img/B19644_Figure_1.13.png)
    |  |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
- en: '| Database and SQL support | ![Checkmark with solid fill](img/B19644_Figure_1.13.png)
    |  |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
- en: 'Figure 1.13: A feature comparison chart showing the features contained in the
    free Community edition versus the paid Professional version'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: The **Community edition** is free but only offers a limited set of features
    compared to the Professional edition. It is perfect for working on projects that
    only entail working with Python. The product I work on has a set of Python scripts
    that batch-process large amounts of data. Everything happens in Python and this
    is the perfect use case for the Community edition. If all you need is a terrific
    Python IDE, use the free version. The Community edition is also perfect if you
    are just working on automation scripts, such as graphics pipelines for 3D computer
    graphics, or general IT task automation.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: The **Professional edition** has all the features of the free version but adds
    web development, database, remote development, containerization, and scientific
    project types. This is aimed at professionals who produce publishable software
    projects. While it is not free, JetBrains is pretty good about keeping it affordable
    with several pricing options, depending on how you are using the tool. Solo developers
    may obtain licenses at a lower price point than corporate developers. There are
    also ways to get the Professional edition free of charge, such as proving that
    you are using PyCharm on a **fully open source software** (**FOSS**) project.
    Start-up companies might be eligible for a 50% discount, and if you’re teaching
    in a code boot camp or a university setting, you may also qualify for free professional
    licenses. Since these things can fluctuate over time, you should check the JetBrains
    website for full details at [https://www.jetbrains.com/pycharm/](https://www.jetbrains.com/pycharm/).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: I said earlier there are three editions of PyCharm, and we’ve only covered two.
    The **Educational edition** is aimed at teachers and university professors developing
    curricula to teach Python. This edition can create and play back interactive lessons
    right in the IDE. It is only valuable to teachers, instructors, and content creators.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: In this book, I will focus on the features present in the Community edition
    and the Professional edition.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we introduced the Python language itself, as well as the background
    behind Python IDEs in general and, specifically, PyCharm.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: We also discussed the usability of PyCharm for Python programmers. Specifically,
    to be able to take full advantage of all the features and functionalities that
    PyCharm offers without becoming too dependent on the IDE, a programmer should
    first master the fundamentals of the Python language and its core syntax. We also
    looked at comparisons between PyCharm itself and various other Python editors/IDEs
    and the reason why PyCharm is considered the best development environment of them
    all.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we compared the two editions of PyCharm that are available for download:
    the paid Professional edition and the free Community edition. If you are working
    with large, complex projects with many moving parts, including database management,
    web development languages, and viewability in scientific reports, then you will
    most likely benefit from using the Professional edition.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how to download PyCharm, set it up on your
    system, and configure its environment for your Python projects. This will serve
    as the first step in getting started with PyCharm, after which we will start discussing
    the specific features PyCharm offers that this book covers.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Answer the following questions to test your knowledge of this chapter:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Programmers typically develop their code with an editor or an IDE. What is the
    difference between the two, and which one is PyCharm?
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why might some think that an IDE for Python development might be inappropriate
    or unnecessary?
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are some key features of PyCharm? Of those features, which give PyCharm
    an edge over other editors/IDEs?
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What advantage does PyCharm have over editors such as Visual Studio Code or
    vim, which can be configured to perform many of the same features offered by PyCharm?
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the three editions of PyCharm? What are the key differences between
    them?
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Be sure to check out the companion website for this book at [http://pycharm-book.com](http://pycharm-book.com).
    To learn more about the topics that were covered in this chapter, take a look
    at the following resources:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: 'Friend, Edward H. *Sorting on Electronic Computer Systems*. *Journal of the
    ACM (JACM)* 3.3 (1956): 134-168.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Nguyen, Quan. *Hands-On Application Development with PyCharm: Accelerate your
    Python applications using practical coding techniques in PyCharm*. Packt Publishing
    Ltd, 2019.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shelley, Percy B. *Ozymandias*. [https://www.poetryfoundation.org/poems/46565/ozymandias](https://www.poetryfoundation.org/poems/46565/ozymandias).
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wikipedia contributors. (2022, December 19). *Bubble sort*. Wikipedia. [https://en.wikipedia.org/wiki/Bubble_sort](https://en.wikipedia.org/wiki/Bubble_sort).
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
