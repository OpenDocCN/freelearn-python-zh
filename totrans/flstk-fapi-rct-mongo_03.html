<html><head></head><body>
<div><div><div><h1 id="_idParaDest-46" class="contributor"><a id="_idTextAnchor051" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/><a id="_idTextAnchor052" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>3</h1>
			<h1 id="_idParaDest-47" class="contributor"><a id="_idTextAnchor053" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Python Type Hints and Pydantic</h1>
			<p class="calibre5">Before exploring FastAPI, it is useful to explore some Python concepts that will be heavily used throughout your journey with FastAPI.</p>
			<p class="calibre5">Python type hinting is a very important and relatively new feature of the language that facilitates the work of developers, bringing greater robustness and maintainability to the development workflow. Types make your code more readable and understandable, and most importantly, they promote good practices.</p>
			<p class="calibre5">FastAPI is heavily based on Python type hints. So, before diving into the framework, it is useful to review the basic concepts of type hinting, what they are, how they are implemented, and what their purpose is. This foundational knowledge will help you create robust, maintainable, and scalable APIs with FastAPI.</p>
			<p class="calibre5">By the end of this chapter, you will have a deep understanding of the role of type annotations in Python with FastAPI and Pydantic. Pydantic is a modern Python library that enforces type hints at runtime, provides customizable and user-friendly errors when data is invalid, and allows definition of data structures using Python type annotations.</p>
			<p class="calibre5">You will be able to model your data with precision, leveraging the advanced features of Pydantic to make you a better and more productive FastAPI developer.</p>
			<p class="calibre5">This chapter will cover the following topics:</p>
			<ul class="calibre14">
				<li class="calibre17">Python type hints and their usage</li>
				<li class="calibre17">A general overview of Pydantic and its main functions, including parsing and validating data</li>
				<li class="calibre17">Data deserialization and serialization, including advanced and special cases</li>
				<li class="calibre17">Validation and data transformation, aliases, and field and model-level validation</li>
				<li class="calibre17">Advanced Pydantic usage such as nested models, fields, and model settings</li>
			</ul>
			<h1 id="_idParaDest-48" class="contributor"><a id="_idTextAnchor054" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Technical requirements</h1>
			<p class="calibre5">To run the sample application in this chapter, you should have Python version 3.11.7<em class="italic"> </em>(https://www.python.org/downloads/) or higher installed on your local computer, a virtual environment, and a couple of packages. As the examples in this chapter will not make use of FastAPI, if you wish, you can create a pristine virtual environment and install Pydantic with the following:</p>
			<pre class="source-code">
pip install pydantic==2.7.1 pydantic_settings==2.2.1</pre>			<p class="calibre5">In this chapter, you will be working with Pydantic and some Pydantic-related packages, such as <code>pydantic_settings</code>.</p>
			<h1 id="_idParaDest-49" class="contributor"><a id="_idTextAnchor055" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Python types</h1>
			<p class="calibre5">The different types present in a programming language define the language itself—they define its boundaries and set some ground rules for what is possible and, more importantly, what the recommended way of achieving something is. Different types of variables have completely different sets of methods and properties available. For example, while capitalizing a string makes perfect sense, capitalizing a floating number or a list of integers doesn’t.</p>
			<p class="calibre5">If you have used Python for a while, even for the most mundane tasks, you already know that, like every programming language, it supports different types of data—strings and different numerical types such as integers and floats. It also features a rather rich data structure library: from dictionaries to lists, from sets to tuples, and so on.</p>
			<p class="calibre5">Python is a <strong class="bold">dynamically typed language</strong>. This means that the type of a variable is not determined at compile time, but at runtime. This feature gives the language itself a lot of flexibility and enables you to declare a variable as a string, use it, and then later on reassign it to a list. However, the ease of changing the variable type can make larger and more complex codebases more prone to errors. Dynamic typing implies that the type of a variable is embedded with the variable itself and is easily modifiable.</p>
			<p class="calibre5">On the other end of the spectrum lie the so-called statically typed languages: C, C++, Java, Rust, Go, and so on. In these languages, the type of the variable is known at compile time, and it cannot change over time. The type-checking is performed at compile time (so before runtime) and errors are caught before runtime, as the compiler will prevent the program from being compiled.</p>
			<p class="calibre5">Programming languages are divided into different categories along another, different axis: strongly typed languages and weakly typed languages. This characteristic tells us how much a language restricts its types to operations inherent to those specific types and how easy it is to coerce, or change, a variable from one to another type. Unlike JavaScript, for instance, Python is considered to be on the stronger side of the spectrum, and the interpreter sends strong messages when you try to perform an illegal operation, such as typing the following in a Python interpreter to add a <code>dict</code> type to a number:</p>
			<pre class="source-code">
&gt;&gt;&gt;{}+3
Traceback (most recent call last):
File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: unsupported operand type(s) for +: 'dict' and 'int'</pre>			<p class="calibre5">So, while Python does complain when you attempt to perform unsupported operations, it only does so at runtime, not before executing the code. In fact, there is no indication to you—the developer—that you are writing code that violates the Python type system.</p>
			<h1 id="_idParaDest-50" class="contributor"><a id="_idTextAnchor056" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Type hinting</h1>
			<p class="calibre5">As you have seen in the previous section, Python is a dynamically typed language, and types aren’t known until runtime. Since variable types are embedded in the value of the variable itself, as a developer, you cannot know the type of a variable that you encounter in a codebase just by looking at it or inspecting it with your IDE of choice. Fortunately, Python introduced a very sought-out feature starting from version 3.5—type annotations (https://peps.python.org/pep-0484/).</p>
			<p class="calibre5">Type annotations or hints in Python are an additional syntax that notifies you, the developer, of the expected type of a variable. They are not used by the Python language at runtime, and they do not modify or affect the behavior of your program in any way. You might be wondering what the use of these hints is if the Python interpreter cannot even see them.</p>
			<p class="calibre5">As it turns out, several important benefits will make almost any codebase much more robust, more maintainable, and future-proof:</p>
			<ul class="calibre14">
				<li class="calibre17"><strong class="bold">Faster code development</strong>: Any developer reading your code will know exactly the type of any annotated variable—whether it is an integer or a floating point, a list or a set, allowing for faster development.</li>
				<li class="calibre17"><strong class="bold">Knowledge of methods and properties</strong>: You will know exactly which methods or properties are available for any given variable. Inadvertently changing the type of a variable in a larger codebase will be picked up immediately.</li>
				<li class="calibre17"><strong class="bold">Simplified code development</strong>: Code editors and IDE (such as Visual Studio Code) will provide excellent support and auto-completion (IntelliSense), further simplifying development and reducing the cognitive load on the developer.</li>
				<li class="calibre17"><strong class="bold">Automatic code generation</strong>: FastAPI provides automatic and interactive (as in a fully functional REST API) documentation that is entirely based on Python type hints.</li>
				<li class="calibre17"><strong class="bold">Type checkers</strong>: This is the most important benefit. These are programs that run in the background and perform static analysis of your code, spotting potential problems and informing you immediately.</li>
				<li class="calibre17"><strong class="bold">Easier to read and smaller cognitive load</strong>: Annotated code is much easier to read and puts much less cognitive load on you as a developer when you have to work on a piece of code and are trying to figure out what it is supposed to do.</li>
				<li class="calibre17"><strong class="bold">Strongly typed and flexible</strong>: Preserves the language’s strongly typed nature and dynamic typing flexibility, while allowing for imposing the necessary safety requirements and constraints. While recommended for larger codebases, Python type hints are ingrained into FastAPI and Pydantic, so even the smallest projects will require you to at least know your way around types and how to work with them.</li>
			</ul>
			<p class="calibre5">Type hinting is at the very base of FastAPI. Coupled with MongoDB’s flexible document schema, it is the backbone of FARM stack development. Type hinting ensures that your application data flow maintains the right data types going in and out of the system at every moment. While this might seem trivial for simpler endpoints—quantities should be integers, names should be strings, and so on—when your data structure becomes more complex, debugging type errors can become very cumbersome.</p>
			<p class="calibre5">Type hints can also be defined as a formalism—a formal solution to statically (before runtime) indicate the type of a value to a type checker (<strong class="bold">Mypy</strong>, in your case), which will ensure that when the Python runtime encounters your program the types will not be problematic.</p>
			<p class="calibre5">The next section will detail the syntax of type hints, how to annotate functions, and how to check your code with Mypy.</p>
			<h2 id="_idParaDest-51" class="about-the-author"><a id="_idTextAnchor057" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Implementing type hints</h2>
			<p class="calibre5">Let’s see how you can implement type hinting. Create a directory named <code>Chapter3</code> and create a virtual environment inside it, as shown earlier. Inside, add a <code>requirements.txt</code> file with the following contents if you want to be able to recreate the examples in the chapter exactly:</p>
			<pre class="source-code">
mypy==1.10.0
pydantic==2.7.4</pre>			<p class="calibre5">Install the packages with <code>requirements.txt</code>:</p>
			<pre class="source-code">
pip install -r requirements.txt</pre>			<p class="calibre5">Now you are ready to explore the world of Python type hints.</p>
			<p class="calibre5">While there are many Python type checkers—basically tools that perform static analysis of the source code without running it—we will use <code>mypy</code> as it is easily installable. Later, you will have tools such as Black or Ruff at your disposal. These perform different actions on your source code, including type checking.</p>
			<p class="calibre5">In order to showcase the Python type annotation syntax, a simple function, such as the following will suffice:</p>
			<ol class="calibre14">
				<li class="calibre15">Create a file called <code>chapter3_01.py</code> and define a simple function:<pre class="source-code">
def print_name_x_times(name: str, times: int) -&gt; None:
    for _ in range(times):
        print(name)</pre><p class="list-inset">The previous function accepts two parameters, <code>name</code> (a string) and <code>times</code> (an integer), and returns <code>None</code>, while the function prints the given name for a given number of times in the console. If you try to call the function in your code and start typing the arguments, Visual Studio Code (or any IDE with Python type-checking support) will immediately suggest a string as the first positional argument and an integer as the second.</p></li>				<li class="calibre15">You can try to input the wrong argument types, for instance, an integer first and then a string afterward, save the file, and run <code>mypy</code> on the command line:<pre class="source-code">
mypy chapter3_01.py</pre></li>				<li class="calibre15">Mypy will inform you that there are two errors:<pre class="source-code">
types_testing.py:8: error: Argument 1 to "print_name_x_times" has incompatible type "int"; expected "str"  [arg-type]
types_testing.py:8: error: Argument 2 to "print_name_x_times" has incompatible type "str"; expected "int"  [arg-type]
Found 2 errors in 1 file (checked 1 source file)</pre></li>			</ol>
			<p class="calibre5">This example was simple enough, but take a look again at what <strong class="bold">Python Enhancement Proposal 8</strong> (<strong class="bold">PEP 8</strong>)<strong class="bold"> </strong>recommends when it comes to the type-hinting syntax with another example:</p>
			<ol class="calibre14">
				<li class="calibre15">Insert a simple variable that has a value:<pre class="source-code">
text: str = "John"</pre><p class="list-inset">The colon is attached to the variable (no spaces), there is one space after the colon, and, in cases where you do provide a value, there are spaces around the equal sign.</p></li>				<li class="calibre15">When annotating the output of a function, the "arrow," which is made up of a dash and greater than sign (<code>-&gt;</code>), should be surrounded by one space, like this:<pre class="source-code">
def count_users(users: list[str]) -&gt; int:
    return len(users)</pre><p class="list-inset">So far, you have seen simple annotations that constrain a variable to some Python primitive types including integers and strings. Typing annotations can be more flexible: you might want to allow a variable to accept several variable types, such as an integer and a string.</p></li>				<li class="calibre15">You can achieve this with the use of the <code>Union</code> package from the <code>typing</code> module:<pre class="source-code">
from typing import Union
x: Union(str, int)</pre></li>				<li class="calibre15">The previously defined <code>x</code> variable can take a string or an integer value. The more modern and concise way of achieving the same functionality is the following:<pre class="source-code">
x: str | int</pre></li>			</ol>
			<p class="calibre5">These annotations mean that the variable <code>x</code> can be an integer or it can take a value of <code>string</code>, which is a different type from an integer.</p>
			<p class="calibre5">The <code>typing</code> module contains several types of so-called generics, including the following:</p>
			<ul class="calibre14">
				<li class="calibre17"><code>List</code>: For variables that should be of the list type</li>
				<li class="calibre17"><code>Dict</code>: For dictionaries</li>
				<li class="calibre17"><code>Sequence</code>: For any type of sequence of values</li>
				<li class="calibre17"><code>Callable</code>: For callables, such as functions</li>
				<li class="calibre17"><code>Iterator</code>: Indicates that a function or variable accepts an iterator object (an object that implements the iterator protocol and can be used in a <code>for</code> loop)</li>
			</ul>
			<p class="callout-heading">Note</p>
			<p class="callout">You are encouraged to explore the <code>typing</code> module but bear in mind that the types from the module are gradually being imported into Python’s code functionality.</p>
			<p class="calibre5">For instance, the <code>List</code> type is very useful in working with FastAPI as it allows you to serialize a list of items or resources quickly and efficiently into a JSON output.</p>
			<p class="calibre5">An example of a <code>List</code> type is the following, in a new file called <code>chapter3_02.py</code>:</p>
			<pre class="source-code">
from typing import List
def square_numbers(numbers: List[int]) -&gt; List[int]:
    return [number ** 2 for number in numbers]
# Example usage
input_numbers = [1, 2, 3, 4, 5]
squared_numbers = square_numbers(input_numbers)
print(squared_numbers)  # Output: [1, 4, 9, 16, 25]</pre>			<p class="calibre5">Another useful type is <code>Literal</code> , which restricts the possible values of a variable to a few admissible states:</p>
			<pre class="source-code">
from typing import Literal
account_type: Literal["personal", "business"]
account_type = "name"</pre>			<p class="calibre5">The preceding lines showcase the power of type hints. There is nothing inherently wrong with assigning the <code>account_type</code> variable to a string, but that string is not part of the admissible state set and thus Mypy complains and returns an <code>Incompatible types in </code><code>assignment</code> error.</p>
			<p class="calibre5">Now, look at an example that includes a <code>datetime</code> argument. Create a new file called <code>chapter3_03.py</code>:</p>
			<pre class="source-code">
from datetime import datetime
def format_datetime(dt: datetime) -&gt; str:
     return dt.strftime("%Y-%m-%d %H:%M:%S")
now = datetime.now()
print(format_datetime(now))</pre>			<p class="calibre5">The previously defined function accepts one parameter—a datetime object—and outputs a string: a nicely formatted date and time, useful for displaying on websites. If you try to type <em class="italic">dt</em> and then a dot in your Visual Studio Code editor, you will be prompted by the autocompletion system, offering all the methods and properties related to the datetime object.</p>
			<p class="calibre5">To declare a structure as a list of dictionaries (something very familiar to anyone working with a JSON-based API), you could use something like this, in a file named <code>chapter3_04.py</code>:</p>
			<pre class="source-code">
def get_users(id: int) -&gt; list[dict]:
    return [
        {"id": 1, "name": "Alice"},
        {"id": 2, "name": "Bob"},
        {"id": 3, "name": "Charlie"},
    ]</pre>			<p class="calibre5">After having covered the basic annotation types in Python, the next few sections will look at some more advanced types that are very useful when working with FastAPI and Pydantic.</p>
			<h2 id="_idParaDest-52" class="about-the-author"><a id="_idTextAnchor058" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Advanced annotations</h2>
			<p class="calibre5">The annotations you have seen so far are very simple and convey basic information related only to the specific desired type of a variable, function, class argument, or output. Python’s typing system is capable of much more and it can be used to restrict the allowable variables' state further and prevent you, the developer, from creating impossible or illegal states in your code. </p>
			<p class="calibre5">The most frequently used types are the following:</p>
			<ul class="calibre14">
				<li class="calibre17">The <code>Optional</code> type is used for handling optional values and <code>None</code> values in an explicit and developer-friendly way.</li>
				<li class="calibre17">The <code>Union</code> type allows you to define a union of possible types, such as integers and strings. Modern Python uses the pipe operator (<code>|</code>), as shown in the previous example.</li>
				<li class="calibre17">The <code>self</code> type is used to indicate that the value will be an instance of a certain class, useful in Pydantic model validators as we will see later.</li>
				<li class="calibre17">The <code>New</code> type allows developers to define completely new types based on existing types.</li>
			</ul>
			<p class="calibre5">This section detailed Python type hints, their purpose, and how they are implemented. The next section will take a deeper look at Pydantic, the workhorse of FastAPI data validation.</p>
			<h1 id="_idParaDest-53" class="contributor"><a id="_idTextAnchor059" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Pydantic</h1>
			<p class="calibre5">Pydantic is a data validation library labeled on its website as the most widely used data validation library for Python. It allows you to model your data in a granular way and perform various types of validation while being firmly rooted in the Python type hinting system. The actual version, V2, has critical parts of the code rewritten in <strong class="bold">Rust</strong> for speed and allows for an excellent developer experience. The following list describes some of the benefits of using Pydantic:</p>
			<ul class="calibre14">
				<li class="calibre17"><strong class="bold">Based on type hints that are part of the standard library</strong>: Instead of needing to learn contrived new systems or terminologies, you just need to learn pure Python types.</li>
				<li class="calibre17"><strong class="bold">Excellent speed</strong>: Everything about FastAPI and MongoDB revolves around speed—fast and responsive applications delivered in record time—so having a fast validation and parsing library is mandatory. The core of Pydantic is written in Rust, which ensures high-speed operations on data.</li>
				<li class="calibre17"><strong class="bold">Huge community support and wide adoption</strong>: Learning your way around Pydantic will prove useful when working with popular packages such as Django Ninja, SQLModel, LangChain, and more.</li>
				<li class="calibre17"><strong class="bold">The possibility of emitting JSON schema</strong>: It facilitates integration with other systems.</li>
				<li class="calibre17"><strong class="bold">More flexibility</strong>: Pydantic supports different modes (strict and lax when it comes to coercion) and nearly unlimited customization options and flexibility.</li>
				<li class="calibre17"><strong class="bold">Popular among developers</strong>: It has been downloaded more than 70 million times and over 8,000 packages on PyPI depend on Pydantic (as of July 2024).</li>
			</ul>
			<p class="callout-heading">Note</p>
			<p class="callout">You can take a look at Pydantic in detail in its documentation:  <a href="https://docs.pydantic.dev/latest/" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2">https://docs.pydantic.dev/latest/</a>.</p>
			<p class="calibre5">Broadly speaking, Pydantic tackles many important problems in a modern web development workflow. It ensures that the data that is ingested into your application is properly formed and formatted, falls within the desired range, is of the appropriate type and dimensions, and reaches your document store safely and without errors.</p>
			<p class="calibre5">Pydantic also ensures that your application outputs the data exactly as intended and according to the specification, omitting fields that should not be exposed (such as user passwords) and even more complex tasks, including interfacing with other incompatible systems.</p>
			<p class="calibre5">FastAPI is standing on the shoulders of two powerful Python libraries—Starlette and Pydantic. While Starlette takes care of the web-related aspects of the framework, often through thin wrappers and utility functions and classes provided by FastAPI, Pydantic is responsible for FastAPI’s phenomenal developer experience. Pydantic is fundamental to FastAPI, and leveraging its powerful capabilities opens up the playing field for all FARM stack developers.</p>
			<p class="calibre5">While type checking is performed statically (without running the code), the role of Pydantic is apparent during runtime and performs the role of a guardian of inbound data. Your FastAPI application will receive data from users, from a flexible MongoDB database schema, and from other systems via APIs—and Pydantic will facilitate the parsing and data validation. Instead of crafting complex validation logic for every possible invalid case, you will simply create Pydantic models of desired complexity, matching your application’s needs as closely as possible.</p>
			<p class="calibre5">In the following sections, you will explore most of functionality of Pydantic through examples with increasing complexity and demands as we feel that it is the best and most effective way of familiarizing yourself with the library.</p>
			<h2 id="_idParaDest-54" class="about-the-author"><a id="_idTextAnchor060" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Pydantic basics</h2>
			<p class="calibre5">Unlike some other libraries that provide similar functionality (such as <code>dataclasses</code>), Pydantic provides a base model (aptly named <code>BaseModel</code>) that enables the parsing and validation functionality through inheritance. Since you will be building a user model in the coming sections, you can start by jotting down the most basic data that needs to be associated with your user. At the minimum, you will need the following:</p>
			<ul class="calibre14">
				<li class="calibre17">A username</li>
				<li class="calibre17">An email address</li>
				<li class="calibre17">An ID (keep it as an integer for now)</li>
				<li class="calibre17">A date of birth</li>
			</ul>
			<p class="calibre5">In Pydantic, a user model that would be associated with this specification could look like the following, in a file called <code>chapter3_05.py</code>:</p>
			<pre class="source-code">
from datetime import datetime
from pydantic import BaseModel
class User(BaseModel):
    id: int
    username: str
    email: str
    dob: datetime</pre>			<p class="calibre5">The <code>User</code> class already handled a lot of work for you—there is no need to perform validation checks as the instantiation of the class performs the validation and parsing immediately.</p>
			<p class="calibre5">The process of constructing the class is pretty straightforward: each field has a type declaration, and Pydantic is ready to inform you of any erroneous types it might encounter.</p>
			<p class="calibre5">If you try and create a user, you shouldn’t see any errors:</p>
			<pre class="source-code">
Pu = User(id=1, username="freethrow", email="email@gmail.com", dob=datetime(1975, 5, 13))</pre>			<p class="calibre5">Say however, you create a user with the wrong data, and conveniently import the Pydantic <code>ValidationError</code>:</p>
			<pre class="source-code">
from pydantic import BaseModel, ValidationError
try:
    u = User(
        id="one",
        username="freethrow",
        email="email@gmail.com",
        dob=datetime(1975, 5, 13),
    )
    print(u)
except ValidationError as e:
    print(e)</pre>			<p class="calibre5">Pydantic will inform you that the data cannot be validated when you run the program:</p>
			<pre class="source-code">
1 validation error for User
id
  Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='one', input_type=str]</pre>			<p class="calibre5">The error messages of Pydantic, derived from <code>ValidationError</code>, are deliberately informative and precise. The field with an error is called <code>id</code> and the type of error is described. The first useful aspect that comes to mind is that if there were several errors—for instance, you might provide an invalid <code>datetime</code>—Pydantic will not stop at the first error. It will continue parsing the entire instance and outputting the list of errors that can easily be output in JSON format. That is actually the desired behavior when working with APIs; you want to be able to list all the errors, for instance, to a user that has sent the wrong data to the backend. The exception contains a list of all the encountered errors.</p>
			<p class="calibre5">The model guarantees that the instance, once validation is passed, will have the required fields and that they are of the correct type.</p>
			<p class="calibre5">You can also provide defaults and nullable types, according to the type hinting conventions:</p>
			<pre class="source-code">
class User(BaseModel):
    id: int = 2
    username: str
    email: str
    dob: datetime
    fav_colors: list[str] | None = ["red", "blue"]</pre>			<p class="calibre5">The previous model has a default <code>id</code> value (which is not something that you would want to do in practice) and a list of favorite colors as strings, which can also be <code>None</code>.</p>
			<p class="calibre5">When you create and print a model (or more precisely, when you invoke its representation via the <code>print</code> function), you get a nice output:</p>
			<pre class="source-code">
id=2 username='marko' email='email@gmail.com' dob=datetime.datetime(1975, 5, 13, 0, 0) fav_colors=None</pre>			<p class="calibre5">Pydantic by default operates in a lax mode, which means that it will try to coerce the provided types to the ones that are declared in the model. For instance, if you pass the user ID as a string <code>"2"</code> to the model, there will not be any errors, as Pydantic automatically converts the ID to an integer.</p>
			<p class="calibre5">Although fields are available through the dot notation (<code>user.id</code>) and they can be easily modified, this is not recommended as the validation rules will not be applied. You could instantiate a user with an <code>id</code> value of <code>5</code>, access <code>user.id</code>, and set it to a string <code>"five"</code>, but that is probably not something you would want.</p>
			<p class="calibre5">Besides pure data validation, Pydantic provides other important functionalities to your application. Some of the most widely used operations with Pydantic models are the following:</p>
			<ul class="calibre14">
				<li class="calibre17"><strong class="bold">Data deserialization</strong>: Ingesting data into the model</li>
				<li class="calibre17"><strong class="bold">Data serialization</strong>: Outputting validated data from the model into Python data structures or JSON</li>
				<li class="calibre17"><strong class="bold">Data modification</strong>: Sanitizing or modifying data on the fly</li>
			</ul>
			<p class="calibre5">The next few sections will look at each of these operations in more detail.</p>
			<h2 id="_idParaDest-55" class="about-the-author"><a id="_idTextAnchor061" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Deserialization</h2>
			<p class="calibre5">Deserialization refers to the process of providing data to the model, which is the input phase, as opposed to the process of serialization, which means outputting model data in a desired form. Deserialization is tightly coupled with validation as the processes of validation and parsing are performed when instantiating the model, although this can be overridden.</p>
			<p class="calibre5">In Pydantic, the term <code>ValidationError</code> type of Pydantic that is raised when data cannot be successfully parsed into a model instance.</p>
			<p class="calibre5">While you have already performed a couple of validations through instantiating the Pydantic-based user models, the data to be validated is often passed in the form of a dictionary. The following is an example of passing data as a dictionary, in a file named <code>chapter3_06.py</code>:</p>
			<p class="calibre5">Create another version of your user model and pass it a dictionary of data:</p>
			<pre class="source-code">
class User(BaseModel):
    id: int
    username: str
    email: str
    password: str
user = User.model_validate(
    {
        "id": 1,
        "username": "freethrow",
        "email": "email@gmail.com",
        "password": "somesecret",
    }
)
print(user)</pre>			<p class="calibre5">The <code>.model_validate()</code> method is a helper that accepts a Python dictionary and performs the class instantiation and thus validation. This method creates your <code>user</code> instance and validates the data types in one step.</p>
			<p class="calibre5">Similarly, <code>model_validate_json()</code> accepts a JSON string (useful when working with APIs).</p>
			<p class="calibre5">There is also a method for constructing a model instance without validation with <code>model_construct()</code> but this has very specific user cases and is not recommended in most cases.</p>
			<p class="calibre5">You have learned how to pass data to your simple Pydantic model. The next section will take a closer look at the model fields and their properties.</p>
			<h2 id="_idParaDest-56" class="about-the-author"><a id="_idTextAnchor062" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Model fields</h2>
			<p class="calibre5">Pydantic fields are based on Python types and setting them to be required or nullable and providing default values is intuitive. For instance, to create a default value for a field, it is enough to provide it in the model as a value, while the nullable field follows the same conventions that you saw in the <em class="italic">Python types</em> sections—by using the older union syntax from the <code>typing</code> module, or the newer syntax with the pipe operator.</p>
			<p class="calibre5">The following is an example of another user model in a file named <code>chapter3_07.py</code>:</p>
			<ol class="calibre14">
				<li class="calibre15">Insert some default values:<pre class="source-code">
from pydantic import BaseModel
from typing import Literal
class UserModel(BaseModel):
    id: int
    username: str
    email: str
    account: Literal["personal", "business"] | None = None
    nickname: str | None = None</pre><p class="list-inset">The previously defined <code>UserModel</code> class defines a couple of standard string-type fields: an account that can have exactly two values or be equal to <code>None</code> and a nickname that can be a string or <code>None</code>.</p></li>				<li class="calibre15">You may use the <code>model_fields</code> property to inspect the model as follows:<pre class="source-code">
print(UserModel.model_fields)</pre><p class="list-inset">You will get a handy list of all the fields belonging to the model with information about them including their types and whether they are required:</p><pre class="source-code">{'id': FieldInfo(annotation=int, required=True), 'username': FieldInfo(annotation=str, required=True), 'email': FieldInfo(annotation=str, required=True), 'account': FieldInfo(annotation=Union[Literal['personal', 'business'], NoneType], required=False, default=None), 'nickname': FieldInfo(annotation=Union[str, NoneType], required=False, default=None)}</pre></li>			</ol>
			<p class="calibre5">The next section will detail Pydantic-specific types that make working with the library easier and faster.</p>
			<h2 id="_idParaDest-57" class="about-the-author"><a id="_idTextAnchor063" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Pydantic types</h2>
			<p class="calibre5">While Pydantic is based on standard Python types such as strings, integers, dictionaries, and sets, which makes it very intuitive and straightforward for starting, the library also provides a plethora of customizations and solutions for common cases. In this section, you will get to know the most useful ones.</p>
			<p class="calibre5">Strict types such as <code>StrictBool</code>, <code>StrictInt</code>, <code>StrictStr</code>, and other Pydantic-specific types are types that will pass validation only if the validated value belongs to these types, without any coercion: a <code>StrictInt</code> must be of type <code>Integer</code> and not <code>"1"</code> or <code>1.0</code>, for example.</p>
			<p class="calibre5">Constrained types provide additional constraints for existing types. For instance, <code>condate()</code> is a date type with greater than, greater than or equal, less than, and less than or equal constraints. <code>conlist()</code> wraps the list type and adds length validation or can impose a rule that the items contained must be unique.</p>
			<p class="calibre5">Pydantic is not limited to the validation of primitive types such as strings and integers. Many additional validators cover the vast majority of uses that you might run into while modeling your business logic. For instance, the <code>email</code> validator validates email addresses and, since it is not part of the core Pydantic package, it needs to be installed separately by using the following command:</p>
			<pre class="source-code">
pip install pydantic[email]</pre>			<p class="calibre5">The Pydantic website (https://docs.pydantic.dev/latest/api/types/) provides a comprehensive list of additional validation types that extend the functionalities—lists can have a minimum and maximum length, uniqueness can be required, integers can be positive or negative, and many more, including CSS color codes, for instance.</p>
			<h2 id="_idParaDest-58" class="about-the-author"><a id="_idTextAnchor064" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Pydantic fields</h2>
			<p class="calibre5">While the simple Python type annotations might suffice in many cases, the real power of Pydantic starts to show when you begin to use the <code>Field</code> class for the fields. The <code>Field</code> class is used to customize models and add metadata to the model fields.</p>
			<p class="calibre5">Let’s see how you can use the <code>Field</code> class for the <code>UserModel</code> explored in the previous section. Create a file and name it <code>chapter3_08.py</code>.</p>
			<p class="calibre5">First, rewrite your previous <code>UserModel</code> with the help of the <code>Field</code> class:</p>
			<pre class="source-code">
from typing import Literal
from pydantic import BaseModel, Field
class UserModelFields(BaseModel):
    id: int = Field(…)
    username: str = Field(…)
    email: str = Field(…)
    account: Literal["personal", "business"] | None = Field(default=None)
    nickname: str | None = Field(default=None)</pre>			<p class="calibre5">This model is equivalent to the one previously defined without fields. The first syntactic difference can be seen in the way default values are provided—the <code>Field</code> class accepts a default value that is defined explicitly.</p>
			<p class="calibre5">Fields also provide additional model flexibility, through the use of aliases, as you will see in the next section.</p>
			<h3 class="calibre8">Field aliases</h3>
			<p class="calibre5">Fields allow you to create and use aliases, which is very useful when dealing with different systems that need to be compatible with your Pydantic-based data definition. Create a file named <code>chapter3_09.py</code>. Assume that your application uses the <code>UserModelFields</code> model for users, but also needs to be able to ingest data from another system, maybe through a JSON-based API, and this other system sends the data in the following JSON format:</p>
			<pre class="source-code">
external_api_data = {
    "user_id": 234,
    "name": "Marko",
    "email": "email@gmail.com",
    "account_type": "personal",
    "nick": "freethrow",
}</pre>			<p class="calibre5">This format clearly doesn’t conform to your <code>UserModelFields</code> model and aliases provide an elegant way of dealing with this incompatibility:</p>
			<pre class="source-code">
class UserModelFields(BaseModel):
    id: int = Field(<strong class="bold">alias="user_id"</strong>)
    username: str = Field(<strong class="bold">alias="name"</strong>)
    email: str = Field()
    account: Literal["personal", "business"] | None = Field(
        default=None, <strong class="bold">alias="account_type"</strong>
    )
    nickname: str | None = Field(default=None, <strong class="bold">alias="nick"</strong>)</pre>			<p class="calibre5">This updated model provides aliases for all the fields that have different names, so it is possible to validate your external data:</p>
			<pre class="source-code">
user = UserModelFields.model_validate(external_api_data)</pre>			<p class="calibre5">In this case, you have used the simple <code>alias</code> parameter, but there are other options for aliases for serialization or for validation only.</p>
			<p class="calibre5">Additionally, the <code>Field</code> class enables numeric values to be constrained in different ways, which is a feature heavily used in FastAPI. Create a file called <code>chapter3_10.py</code> and start populating it.</p>
			<p class="calibre5">Suppose you need to model a chess event that has the following fields:</p>
			<pre class="source-code">
from datetime import datetime
from uuid import uuid4
from pydantic import BaseModel, Field
class ChessTournament(BaseModel):
    id: int = Field(strict=True)
    dt: datetime = Field(default_factory=datetime.now)
    name: str = Field(min_length=10, max_length=30)
    num_players: int = Field(ge=4, le=16, multiple_of=2)
    code: str = Field(default_factory=uuid4)</pre>			<p class="calibre5">In this relatively simple class, Pydantic fields introduce some complex validation rules that would otherwise be very verbose and cumbersome to write:</p>
			<ul class="calibre14">
				<li class="calibre17"><code>dt</code>: The <code>datetime</code> object of the tournament uses a <code>default_factory</code> parameter, a function invoked at instantiation time that provides the default value. In this case, the value is equal to <code>datetime.now</code>.</li>
				<li class="calibre17"><code>name</code>: This field has some length constraints, such as the minimum and maximum length.</li>
				<li class="calibre17"><strong class="bold">The number of enlisted players is constrained</strong>: It must be greater than or equal to 4, less than or equal to 16, and additionally, it must be an even number—a multiple of 2—to allow for all players to play in each round.</li>
				<li class="calibre17"><code>uuid</code> library.</li>
				<li class="calibre17"><code>id</code>: This field is an integer, but this time you apply the <code>strict</code> flag, which means you override the default behavior of Pydantic and do not allow strings like <code>"3"</code> to pass validation, even though they could be cast to integers.</li>
			</ul>
			<p class="callout-heading">Note</p>
			<p class="callout">A useful page in the Pydantic documentation is dedicated to Fields: https://docs.pydantic.dev/latest/concepts/fields/. There are numerous validation options available through the <code>Field</code> class, and you are encouraged to skim through them before you start your modeling process.</p>
			<p class="calibre5">The next section will detail how to get the data out of the model through the process of deserialization.</p>
			<h2 id="_idParaDest-59" class="about-the-author"><a id="_idTextAnchor065" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Serialization</h2>
			<p class="calibre5">The most important task of any parsing and validation library is data serialization (or data dumping). It is the process of converting and outputting a model instance to a Python dictionary or a JSON-encoded string. The method for generating a Python dictionary is <code>model_dump()</code>, as demonstrated by the following user model example, in a new file called <code>chapter3_11.py</code>.</p>
			<p class="calibre5">To be able to use email validation in Pydantic, add the following line to the <code>requirements.txt</code> file:</p>
			<pre class="source-code">
email_validator==2.1.1</pre>			<p class="calibre5">And then, re-run the user model:</p>
			<pre class="source-code">
pip install -r requirements.txt
class UserModel(BaseModel):
    id: int = Field()
    username: str = Field(min_length=5, max_length=20)
    email: EmailStr = Field()
    password: str = Field(min_length=5, max_length=20, pattern="^[a-zA-Z0-9]+$")</pre>			<p class="calibre5">The user model that you are using is a fairly standard one, and, with your knowledge of Pydantic fields, you can already understand it. There are a couple of new validations, but they are intuitive: the <code>EmailStr</code> object imported from Pydantic is a string that validates email addresses, while the <code>password</code> field contains an additional regular expression to ensure that the field contains only alphanumeric characters and no spaces. Here’s another example:</p>
			<ol class="calibre14">
				<li class="calibre15">Create an instance of the model and serialize it to a Python dictionary:<pre class="source-code">
u = UserModel(
    id=1,
    username="freethrow",
    email="email@gmail.com",
    password="password123",
)
print(u.model_dump())</pre><p class="list-inset">The result is a simple Python dictionary:</p><pre class="source-code">{'id': 1, 'username': 'freethrow', 'email': 'email@gmail.com', 'password': 'password123'}</pre></li>				<li class="calibre15">Try to dump the model to a JSON representation and omit the password for security reasons:<pre class="source-code">
print(u.model_dump_json(exclude=set("password"))</pre><p class="list-inset">The result is a JSON string with the password omitted:</p><pre class="source-code">{"id":1,"username":"freethrow","email":"email@gmail.com"}</pre></li>			</ol>
			<p class="calibre5">Serialization uses the field names and not the aliases by default, but that is another setting that can be easily overridden by setting the <code>by_alias</code> flag to <code>True</code>.</p>
			<p class="calibre5">An example of an alias used when working with FastAPI and MongoDB is MongoDB’s <code>ObjectId</code> field, which is mostly serialized as a string. Another useful method is <code>model_json_schema()</code>, which generates the JSON schema for a model.</p>
			<p class="calibre5">Models can be additionally configured through the <code>ConfigDict</code> object, and the special field called <code>model_config</code>—the name is reserved and mandatory. In the following file, called <code>chapter3_12.py</code>, you are using the <code>model_config</code> field to allow populating the model by name and prevent passing additional data to the model:</p>
			<pre class="source-code">
from pydantic import BaseModel, Field, ConfigDict, EmailStr
class UserModel(BaseModel):
    id: int = Field()
    username: str = Field(min_length=5, max_length=20, alias="name")
    email: EmailStr = Field()
    password: str = Field(min_length=5, max_length=20, pattern="^[a-zA-Z0-9]+$")
    model_config = ConfigDict(extra="forbid", populate_by_name=True)</pre>			<p class="calibre5">The <code>model_config</code> field allows for additional configuration of the model. For instance, the <code>extra</code> keyword refers to additional data fields that are passed to the deserialization process: the default behavior is just to ignore this data.</p>
			<p class="calibre5">In this example, we set <code>extra</code> to <code>forbid</code>, so any additional data passed and not declared in the model will throw a validation error. <code>populate_by_name</code> is another useful setting as it allows us to populate a model by using field names and not only aliases, practically mixing and matching. You will see that this feature is handy when crafting APIs that have to talk to different systems.</p>
			<h3 class="calibre8">Custom serializers</h3>
			<p class="calibre5">Pydantic can provide you with virtually unlimited capabilities when it comes to serialization and also provides different serialization methods for Python and JSON outputs with the use of the <code>@</code><code>field_serializer</code> decorator.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Python decorators are a powerful and elegant feature that allow you to modify or extend the behavior of functions or methods without changing their actual code.</p>
			<p class="callout">Decorators are higher-order functions that take a function as input, add some functionality, and return a new, decorated function. This approach promotes the reusability, modularity, and separation of concerns in your Python programs.</p>
			<p class="calibre5">In the following example, you are going to create a very simple bank account model and use different serializers depending on the type of serialization. Your requirement is to round the balance to exactly two decimals and, only when serializing to JSON, to format the <code>updated</code> field according to the ISO format:</p>
			<ol class="calibre14">
				<li class="calibre15">Create a new file named <code>chapter3_13.py</code> and add a simple model for a bank account that contains only two fields, the balance and the time of the last account update:<pre class="source-code">
from datetime import datetime
from pydantic import BaseModel, field_serializer
class Account(BaseModel):
    balance: float
    updated: datetime
    @field_serializer("balance", when_used="always")
    def serialize_balance(self, value: float) -&gt; float:
        return round(value, 2)
    @field_serializer("updated", when_used="json")
    def serialize_updated(self, value: datetime) -&gt; str:
       return value.isoformat()</pre><p class="list-inset">You have added two custom serializers. The first is the balance serializer (as denoted by the string <code>"balance"</code>), which will always be used. This serializer simply rounds the balance to two decimals. The second serializer is used only for JSON serialization and returns the date as an ISO-formatted datetime string.</p></li>				<li class="calibre15">If you try to populate the model and inspect the serializations, you will see how the serializers modified the initial default output:<pre class="source-code">
account_data = {
    "balance": 123.45545,
    "updated": datetime.now(),
}
account = Account.model_validate(account_data)
print("Python dictionary:", account.model_dump())
print("JSON:", account.model_dump_json())</pre><p class="list-inset">You will get a similar output:</p><pre class="source-code">Python dictionary: {'balance': 123.46, 'updated': datetime.datetime(2024, 5, 2, 21, 34, 11, 917378)}
JSON: {"balance":123.46,"updated":"2024-05-02T21:34:11.917378"}</pre></li>			</ol>
			<p class="calibre5">Earlier in this chapter, you saw basic validation provided by Pydantic through the mere instantiation of the model class. The next section will discuss the various custom validation methods of Pydantic with the help of Pydantic decorators and how they can be leveraged to move beyond serialization and provide powerful custom validation functionality.</p>
			<h2 id="_idParaDest-60" class="about-the-author"><a id="_idTextAnchor066" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Custom data validation</h2>
			<p class="calibre5">Similar to custom field serializers, custom field validators are implemented as decorators, with the <code>@</code><code>field_validator</code> decorator.</p>
			<p class="calibre5">Field validators are class methods, so they must receive the entire class as the first argument, not the instance, while the second value is the name of the field to be validated (or a list of fields, or the <code>*</code> symbol for all fields).</p>
			<p class="calibre5">Field validators should return either the parsed value or a <code>ValueError</code> response (or <code>AssertionError</code>) in case the data passed to the validator doesn’t conform to the validation rules. As with other Pydantic features, it is much easier to start with an example. Create a new file called <code>chapter3_14.py</code> and insert the following code:</p>
			<pre class="source-code">
from pydantic import BaseModel,  field_validator
class Article(BaseModel):
    id: int
    title: str
    content: str
    published: bool
    @field_validator("title")
    @classmethod
    def check_title(cls, v: str) -&gt; str:
        if "FARM stack" not in v:
            raise ValueError('Title must contain "FARM stack"')
        return v.title()</pre>			<p class="calibre5">The validator is run before the class instantiation and accepts the class and the name of the validated field as arguments. The <code>check_title</code> validator checks that the title contains the string <code>"FARM stack"</code> and if it doesn’t, it throws <code>ValueError</code>. Additionally, the validator returns the string in title case, so we can perform data transformation as well, at the field level.</p>
			<p class="calibre5">While field validators provide great flexibility, they do not consider field interactions and the combinations of field values. That is where model validators come into play, as the next section will outline.</p>
			<h2 id="_idParaDest-61" class="about-the-author"><a id="_idTextAnchor067" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Model validators</h2>
			<p class="calibre5">Another useful feature when performing validation of web-related data is model validation—the possibility to write validation functions at the model level, allowing for complex interactions between various fields.</p>
			<p class="calibre5">The model validators can run before or after instantiating the model class. Again, we will take a look at a rather simple example:</p>
			<ol class="calibre14">
				<li class="calibre15">First, create a new file and name it <code>chapter3_15.py</code>.</li>
				<li class="calibre15">Suppose you have a user model with the following structure:<pre class="source-code">
from pydantic import BaseModel, EmailStr, ValidationError, model_validator
from typing import Any, Self
class UserModelV(BaseModel):
    id: int
    username: str
    email: EmailStr
    password1: str
    password2: str</pre><p class="list-inset">The model is simple like the previous ones, and it contains two password fields that are required to match to enable the registration of a new user. Additionally, you want to impose another validation—the data that comes into the model via deserialization must not contain private data (such as a social security number or card number). Model validators allow you to perform flexible validations such as this.</p></li>				<li class="calibre15">Continuing the previous model, you can write the following model validators under the class definition:<pre class="source-code">
@model_validator(mode='after')
def check_passwords_match(self) -&gt; Self:
    pw1 = self.password1
    pw2 = self.password2
    if pw1 is not None and pw2 is not None and pw1 != pw2:
        raise ValueError('passwords do not match')
    return self
@model_validator(mode='before')
@classmethod
def check_private_data(cls, data: Any) -&gt; Any:
    if isinstance(data, dict):
        assert (
            'private_data' not in data
        ), 'Private data should not be included'
    return data</pre></li>				<li class="calibre15">Now, try to validate of the following data:<pre class="source-code">
usr_data = {
    "id": 1,
    "username": "freethrow",
    "email": "email@gmail.com",
    "password1": "password123",
    "password2": "password456",
    "private_data": "some private data",
}
try:
    user = UserModelV.model_validate(usr_data)
    print(user)
except ValidationError as e:
    print(e)</pre><p class="list-inset">You will be informed of just one error—the one related to the <code>before</code> mode, stating that private data should not be included.</p></li>				<li class="calibre15">If you comment out or delete the line that sets the <code>private_data</code> field and re-run the example, the error becomes the following:<pre class="source-code">
Value error, passwords do not match [type=value_error, input_value={'id': 1, 'username': 'fr...ssword2': 'password456'}, input_type=dict]</pre></li>			</ol>
			<p class="calibre5">There are a couple of new concepts involved in the previous example; you are using the <code>Self</code> Python type, introduced for denoting instances of the wrapping class, so you practically expect the output to be an instance of the <code>UserModelV</code> class.</p>
			<p class="calibre5">Another new concept is present in the <code>check_private_data</code> function as it checks whether the data passed to the class is an instance of a dictionary, and then proceeds to verify whether the undesired <code>private_data</code> field is present in the dictionary—this is just Pydantic’s way of checking for the data passed as it is stored inside a dictionary.</p>
			<p class="calibre5">The next section will detail how to compose nested models with Pydantic to validate models of increasing complexity.</p>
			<h2 id="_idParaDest-62" class="about-the-author"><a id="_idTextAnchor068" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Nested models</h2>
			<p class="calibre5">The treatment of nested models in Pydantic through composition is very straightforward and intuitive if you are coming from a basic MongoDB background. To understand how to implement nested models, the easiest way is to start from an existing data structure that needs to be validated and run through Pydantic:</p>
			<ol class="calibre14">
				<li class="calibre15">Begin with the structure of a JSON document that returns car brands and makes (or models). Create a new file named <code>chapter3_16.py</code> and add the following lines of code:<pre class="source-code">
car_data = {
    "brand": "Ford",
    "models": [
        {"model": "Mustang", "year": 1964},
        {"model": "Focus", "year": 1975},
        {"model": "Explorer", "year": 1999},
    ],
    "country": "USA",
}</pre><p class="list-inset">You can start from the inside of the data structure and begin identifying the smallest units or the most deeply nested structures—in this case, the smallest unit is the car model (a Ford Mustang from 1964).</p></li>				<li class="calibre15">This can be the first Pydantic model:<pre class="source-code">
class CarModel(BaseModel):
    model: str
    year: int</pre></li>				<li class="calibre15">Once this first abstraction is made, it is easy to create a model for the brand:<pre class="source-code">
class CarBrand(BaseModel):
    brand: str
    models: List[CarModel]
    country: str</pre></li>			</ol>
			<p class="calibre5">The car brand model has distinct names and countries of origin and contains a list of models.</p>
			<p class="calibre5">Model fields can be other models (or lists or sets or other sequences thereof) and this feature makes mapping Pydantic data structures to data, and especially MongoDB documents, a very pleasant and intuitive process.</p>
			<p class="calibre5">While MongoDB can support up to 100 levels of nesting, you will probably not hit that limit in your data modeling process. However, it’s worth noting that Pydantic will support you as you delve deeper and deeper into your data structures. Embedding data also becomes much more manageable from the Python side, as you can rest assured that data coming into your collections is stored as intended.</p>
			<p class="calibre5">The next and final section will detail another useful tool that Pydantic offers—a little help with managing environment variables and settings, a problem that you face in every web-related project.</p>
			<h2 id="_idParaDest-63" class="about-the-author"><a id="_idTextAnchor069" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Pydantic Settings</h2>
			<p class="calibre5">Pydantic Settings is an external package that needs to be installed separately. It provides Pydantic features for loading a settings or config class from environment variables or secret files.</p>
			<p class="calibre5">That is basically the definition from the Pydantic website (<a href="https://docs.pydantic.dev/latest/concepts/pydantic_settings/" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2">https://docs.pydantic.dev/latest/concepts/pydantic_settings/</a>), and the whole concept revolves around the <code>BaseSettings</code> class.</p>
			<p class="calibre5">A model that inherits from this class attempts to read the values of any fields passed as keyword arguments by scanning the environment.</p>
			<p class="calibre5">This simple functionality allows you to define clear and straightforward configuration classes from environment variables. Pydantic settings can also automatically pick up environment modifications and, when needed, manually override settings for testing, development, or production.</p>
			<p class="calibre5">In the following exercise, you will create a simple <code>pydantic_settings</code> setup that will allow you to read environment variables and easily override them in case the necessity arises:</p>
			<ol class="calibre14">
				<li class="calibre15">Install Pydantic settings with <code>pip</code>:<pre class="source-code">
pip install pydantic-settings</pre></li>				<li class="calibre15">Create a <code>.env</code> file at the same level as your project files:<pre class="source-code">
API_URL=https://api.com/v2
SECRET_KEY=s3cretstr1n6</pre></li>				<li class="calibre15">Now you can set up a simple <code>Settings</code> configuration (the <code>chapter3_17.py</code> file):<pre class="source-code">
from pydantic import Field
from pydantic_settings import BaseSettings
class Settings(BaseSettings):
    api_url: str = Field(default="")
    secret_key: str = Field(default="")
    class Config:
        env_file = ".env"
print(Settings().model_dump())</pre></li>				<li class="calibre15">If you run this code, both the Python and the <code>.env</code> file are on the same path, so you will see that Pydantic was able to read the environment variables from the <code>.</code><code>env</code> file:<pre class="source-code">
{'api_url': 'https://api.com/v2', 'secret_key': 's3cretstr1n6'}</pre><p class="list-inset">However, if you set an environment variable, it will take precedence over the <code>.</code><code>env</code> file.</p></li>				<li class="calibre15">You can test it by adding this line before the <code>Settings()</code> call and observing the output of the program:<pre class="source-code">
os.environ["API_URL"] = 'http://localhost:8000'</pre></li>			</ol>
			<p class="calibre5">Pydantic Settings makes managing configurations such as your Atlas and MongoDB URLs, secrets for hashing passwords, and other configurations much more structured and organized.</p>
			<h1 id="_idParaDest-64" class="contributor"><a id="_idTextAnchor070" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Summary</h1>
			<p class="calibre5">This chapter detailed aspects of Python that are either new and still evolving, or often simply overlooked, such as type hinting, and the implications that their use can have on your projects.</p>
			<p class="calibre5">FastAPI is based on Pydantic and type hinting. Working with these solid principles and conventions will make your code more robust, maintainable, and future-proof even when working with other frameworks. You have a solid Python types foundation and have learned the basic functionalities provided by Pydantic—validation, serialization, and deserialization.</p>
			<p class="calibre5">You have learned how to deserialize, serialize, and validate data through Pydantic, and even add some transformations during the process, creating structures of increased complexity.</p>
			<p class="calibre5">This chapter has equipped you to learn more web-specific aspects of FastAPI and to blend data seamlessly between MongoDB, Python data structures, and JSON.</p>
			<p class="calibre5">The next chapter will explore FastAPI and its Pythonic foundations.</p>
		</div>
	</div>
</div>
</body></html>