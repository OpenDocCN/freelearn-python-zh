<html><head></head><body>
<div id="book-content" class="calibre2">
<div id="sbo-rt-content" class="calibre3"><div id="_idContainer025" class="calibre4">
			<h1 id="_idParaDest-46" class="contributor"><a id="_idTextAnchor051" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/><a id="_idTextAnchor052" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>3</h1>
			<h1 id="_idParaDest-47" class="contributor"><a id="_idTextAnchor053" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Python Type Hints and Pydantic</h1>
			<p class="calibre5">Before exploring FastAPI, it is useful to explore some Python concepts that will be heavily used throughout your journey <span>with FastAPI.</span></p>
			<p class="calibre5">Python type hinting is a very important and relatively new feature of the language that facilitates the work of developers, bringing greater robustness and maintainability to the development workflow. Types make your code more readable and understandable, and most importantly, they promote <span>good practices.</span></p>
			<p class="calibre5">FastAPI is heavily based on Python type hints. So, before diving into the framework, it is useful to review the basic concepts of type hinting, what they are, how they are implemented, and what their purpose is. This foundational knowledge will help you create robust, maintainable, and scalable APIs <span>with FastAPI.</span></p>
			<p class="calibre5">By the end of this chapter, you will have a deep understanding of the role of type annotations in Python with FastAPI and Pydantic. Pydantic is a modern Python library that enforces type hints at runtime, provides customizable and user-friendly errors when data is invalid, and allows definition of data structures using Python <span>type annotations.</span></p>
			<p class="calibre5">You will be able to model your data with precision, leveraging the advanced features of Pydantic to make you a better and more productive <span>FastAPI developer.</span></p>
			<p class="calibre5">This chapter will cover the <span>following topics:</span></p>
			<ul class="calibre14">
				<li class="calibre17">Python type hints and <span>their usage</span></li>
				<li class="calibre17">A general overview of Pydantic and its main functions, including parsing and <span>validating data</span></li>
				<li class="calibre17">Data deserialization and serialization, including advanced and <span>special cases</span></li>
				<li class="calibre17">Validation and data transformation, aliases, and field and <span>model-level validation</span></li>
				<li class="calibre17">Advanced Pydantic usage such as nested models, fields, and <span>model settings</span></li>
			</ul>
			<h1 id="_idParaDest-48" class="contributor"><a id="_idTextAnchor054" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Technical requirements</h1>
			<p class="calibre5">To run the sample application in this chapter, you should have Python version 3.11.7<em class="italic"> </em>(<span>https://www.python.org/downloads/</span>) or higher installed on your local computer, a virtual environment, and a couple of packages. As the examples in this chapter will not make use of FastAPI, if you wish, you can create a pristine virtual environment and install Pydantic with <span>the following:</span></p>
			<pre class="source-code">
pip install pydantic==2.7.1 pydantic_settings==2.2.1</pre>			<p class="calibre5">In this chapter, you will be working with Pydantic and some Pydantic-related packages, such <span>as </span><span><strong class="source-inline">pydantic_settings</strong></span><span>.</span></p>
			<h1 id="_idParaDest-49" class="contributor"><a id="_idTextAnchor055" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Python types</h1>
			<p class="calibre5">The different types present in a programming language define the language itself—they define its boundaries and set some ground rules for what is possible and, more importantly, what the recommended way of achieving something is. Different types of variables have completely different sets of methods and properties available. For example, while capitalizing a string makes perfect sense, capitalizing a floating number or a list of <span>integers doesn’t.</span></p>
			<p class="calibre5">If you have used Python for a while, even for the most mundane tasks, you already know that, like every programming language, it supports different types of data—strings and different numerical types such as integers and floats. It also features a rather rich data structure library: from dictionaries to lists, from sets to tuples, and <span>so on.</span></p>
			<p class="calibre5">Python is a <strong class="bold">dynamically typed language</strong>. This means that the type of a variable is not determined at compile time, but at runtime. This feature gives the language itself a lot of flexibility and enables you to declare a variable as a string, use it, and then later on reassign it to a list. However, the ease of changing the variable type can make larger and more complex codebases more prone to errors. Dynamic typing implies that the type of a variable is embedded with the variable itself and is <span>easily modifiable.</span></p>
			<p class="calibre5">On the other end of the spectrum lie the so-called statically typed languages: C, C++, Java, Rust, Go, and so on. In these languages, the type of the variable is known at compile time, and it cannot change over time. The type-checking is performed at compile time (so before runtime) and errors are caught before runtime, as the compiler will prevent the program from <span>being compiled.</span></p>
			<p class="calibre5">Programming languages are divided into different categories along another, different axis: strongly typed languages and weakly typed languages. This characteristic tells us how much a language restricts its types to operations inherent to those specific types and how easy it is to coerce, or change, a variable from one to another type. Unlike JavaScript, for instance, Python is considered to be on the stronger side of the spectrum, and the interpreter sends strong messages when you try to perform an illegal operation, such as typing the following in a Python interpreter to add a <strong class="source-inline">dict</strong> type to <span>a number:</span></p>
			<pre class="source-code">
&gt;&gt;&gt;{}+3
Traceback (most recent call last):
File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: unsupported operand type(s) for +: 'dict' and 'int'</pre>			<p class="calibre5">So, while Python does complain when you attempt to perform unsupported operations, it only does so at runtime, not before executing the code. In fact, there is no indication to you—the developer—that you are writing code that violates the Python <span>type system.</span></p>
			<h1 id="_idParaDest-50" class="contributor"><a id="_idTextAnchor056" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Type hinting</h1>
			<p class="calibre5">As you have seen in the previous section, Python is a dynamically typed language, and types aren’t known until runtime. Since variable types are embedded in the value of the variable itself, as a developer, you cannot know the type of a variable that you encounter in a codebase just by looking at it or inspecting it with your IDE of choice. Fortunately, Python introduced a very sought-out feature starting from version 3.5—type <span>annotations (</span><span><span>https://peps.python.org/pep-0484/</span></span><span>).</span></p>
			<p class="calibre5">Type annotations or hints in Python are an additional syntax that notifies you, the developer, of the expected type of a variable. They are not used by the Python language at runtime, and they do not modify or affect the behavior of your program in any way. You might be wondering what the use of these hints is if the Python interpreter cannot even <span>see them.</span></p>
			<p class="calibre5">As it turns out, several important benefits will make almost any codebase much more robust, more maintainable, <span>and future-proof:</span></p>
			<ul class="calibre14">
				<li class="calibre17"><strong class="bold">Faster code development</strong>: Any developer reading your code will know exactly the type of any annotated variable—whether it is an integer or a floating point, a list or a set, allowing for <span>faster development.</span></li>
				<li class="calibre17"><strong class="bold">Knowledge of methods and properties</strong>: You will know exactly which methods or properties are available for any given variable. Inadvertently changing the type of a variable in a larger codebase will be picked <span>up immediately.</span></li>
				<li class="calibre17"><strong class="bold">Simplified code development</strong>: Code editors and IDE (such as Visual Studio Code) will provide excellent support and auto-completion (IntelliSense), further simplifying development and reducing the cognitive load on <span>the developer.</span></li>
				<li class="calibre17"><strong class="bold">Automatic code generation</strong>: FastAPI provides automatic and interactive (as in a fully functional REST API) documentation that is entirely based on Python <span>type hints.</span></li>
				<li class="calibre17"><strong class="bold">Type checkers</strong>: This is the most important benefit. These are programs that run in the background and perform static analysis of your code, spotting potential problems and informing <span>you immediately.</span></li>
				<li class="calibre17"><strong class="bold">Easier to read and smaller cognitive load</strong>: Annotated code is much easier to read and puts much less cognitive load on you as a developer when you have to work on a piece of code and are trying to figure out what it is supposed <span>to do.</span></li>
				<li class="calibre17"><strong class="bold">Strongly typed and flexible</strong>: Preserves the language’s strongly typed nature and dynamic typing flexibility, while allowing for imposing the necessary safety requirements and constraints. While recommended for larger codebases, Python type hints are ingrained into FastAPI and Pydantic, so even the smallest projects will require you to at least know your way around types and how to work <span>with them.</span></li>
			</ul>
			<p class="calibre5">Type hinting is at the very base of FastAPI. Coupled with MongoDB’s flexible document schema, it is the backbone of FARM stack development. Type hinting ensures that your application data flow maintains the right data types going in and out of the system at every moment. While this might seem trivial for simpler endpoints—quantities should be integers, names should be strings, and so on—when your data structure becomes more complex, debugging type errors can become <span>very cumbersome.</span></p>
			<p class="calibre5">Type hints can also be defined as a formalism—a formal solution to statically (before runtime) indicate the type of a value to a type checker (<strong class="bold">Mypy</strong>, in your case), which will ensure that when the Python runtime encounters your program the types will not <span>be problematic.</span></p>
			<p class="calibre5">The next section will detail the syntax of type hints, how to annotate functions, and how to check your code <span>with Mypy.</span></p>
			<h2 id="_idParaDest-51" class="about-the-author"><a id="_idTextAnchor057" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Implementing type hints</h2>
			<p class="calibre5">Let’s see how you can implement type hinting. Create a directory named <strong class="source-inline">Chapter3</strong> and create a virtual environment inside it, as shown earlier. Inside, add a <strong class="source-inline">requirements.txt</strong> file with the following contents if you want to be able to recreate the examples in the <span>chapter exactly:</span></p>
			<pre class="source-code">
mypy==1.10.0
pydantic==2.7.4</pre>			<p class="calibre5">Install the packages <span>with </span><span><strong class="source-inline">requirements.txt</strong></span><span>:</span></p>
			<pre class="source-code">
pip install -r requirements.txt</pre>			<p class="calibre5">Now you are ready to explore the world of Python <span>type hints.</span></p>
			<p class="calibre5">While there are many Python type checkers—basically tools that perform static analysis of the source code without running it—we will use <strong class="source-inline">mypy</strong> as it is easily installable. Later, you will have tools such as Black or Ruff at your disposal. These perform different actions on your source code, including <span>type checking.</span></p>
			<p class="calibre5">In order to showcase the Python type annotation syntax, a simple function, such as the following <span>will suffice:</span></p>
			<ol class="calibre14">
				<li class="calibre15">Create a file called <strong class="source-inline">chapter3_01.py</strong> and define a <span>simple function:</span><pre class="source-code">
def print_name_x_times(name: str, times: int) -&gt; None:
    for _ in range(times):
        print(name)</pre><p class="list-inset">The previous function accepts two parameters, <strong class="source-inline">name</strong> (a string) and <strong class="source-inline">times</strong> (an integer), and returns <strong class="source-inline">None</strong>, while the function prints the given name for a given number of times in the console. If you try to call the function in your code and start typing the arguments, Visual Studio Code (or any IDE with Python type-checking support) will immediately suggest a string as the first positional argument and an integer as <span>the second.</span></p></li>				<li class="calibre15">You can try to input the wrong argument types, for instance, an integer first and then a string afterward, save the file, and run <strong class="source-inline">mypy</strong> on the <span>command line:</span><pre class="source-code">
mypy chapter3_01.py</pre></li>				<li class="calibre15">Mypy will inform you that there are <span>two errors:</span><pre class="source-code">
types_testing.py:8: error: Argument 1 to "print_name_x_times" has incompatible type "int"; expected "str"  [arg-type]
types_testing.py:8: error: Argument 2 to "print_name_x_times" has incompatible type "str"; expected "int"  [arg-type]
Found 2 errors in 1 file (checked 1 source file)</pre></li>			</ol>
			<p class="calibre5">This example was simple enough, but take a look again at what <strong class="bold">Python Enhancement Proposal 8</strong> (<strong class="bold">PEP 8</strong>)<strong class="bold"> </strong>recommends when it comes to the type-hinting syntax with <span>another example:</span></p>
			<ol class="calibre14">
				<li class="calibre15">Insert a simple variable that has <span>a value:</span><pre class="source-code">
text: str = "John"</pre><p class="list-inset">The colon is attached to the variable (no spaces), there is one space after the colon, and, in cases where you do provide a value, there are spaces around the <span>equal sign.</span></p></li>				<li class="calibre15">When annotating the output of a function, the "arrow," which is made up of a dash and greater than sign (<strong class="source-inline">-&gt;</strong>), should be surrounded by one space, <span>like this:</span><pre class="source-code">
def count_users(users: list[str]) -&gt; int:
    return len(users)</pre><p class="list-inset">So far, you have seen simple annotations that constrain a variable to some Python primitive types including integers and strings. Typing annotations can be more flexible: you might want to allow a variable to accept several variable types, such as an integer and <span>a string.</span></p></li>				<li class="calibre15">You can achieve this with the use of the <strong class="source-inline">Union</strong> package from the <span><strong class="source-inline">typing</strong></span><span> module:</span><pre class="source-code">
from typing import Union
x: Union(str, int)</pre></li>				<li class="calibre15">The previously defined <strong class="source-inline">x</strong> variable can take a string or an integer value. The more modern and concise way of achieving the same functionality is <span>the following:</span><pre class="source-code">
x: str | int</pre></li>			</ol>
			<p class="calibre5">These annotations mean that the variable <strong class="source-inline">x</strong> can be an integer or it can take a value of <strong class="source-inline">string</strong>, which is a different type from <span>an integer.</span></p>
			<p class="calibre5">The <strong class="source-inline">typing</strong> module contains several types of so-called generics, including <span>the following:</span></p>
			<ul class="calibre14">
				<li class="calibre17"><strong class="source-inline">List</strong>: For variables that should be of the <span>list type</span></li>
				<li class="calibre17"><strong class="source-inline">Dict</strong>: <span>For dictionaries</span></li>
				<li class="calibre17"><strong class="source-inline">Sequence</strong>: For any type of sequence <span>of values</span></li>
				<li class="calibre17"><strong class="source-inline">Callable</strong>: For callables, such <span>as functions</span></li>
				<li class="calibre17"><strong class="source-inline">Iterator</strong>: Indicates that a function or variable accepts an iterator object (an object that implements the iterator protocol and can be used in a <span><strong class="source-inline">for</strong></span><span> loop)</span></li>
			</ul>
			<p class="callout-heading">Note</p>
			<p class="callout">You are encouraged to explore the <strong class="source-inline">typing</strong> module but bear in mind that the types from the module are gradually being imported into Python’s <span>code functionality.</span></p>
			<p class="calibre5">For instance, the <strong class="source-inline">List</strong> type is very useful in working with FastAPI as it allows you to serialize a list of items or resources quickly and efficiently into a <span>JSON output.</span></p>
			<p class="calibre5">An example of a <strong class="source-inline">List</strong> type is the following, in a new file <span>called </span><span><strong class="source-inline">chapter3_02.py</strong></span><span>:</span></p>
			<pre class="source-code">
from typing import List
def square_numbers(numbers: List[int]) -&gt; List[int]:
    return [number ** 2 for number in numbers]
# Example usage
input_numbers = [1, 2, 3, 4, 5]
squared_numbers = square_numbers(input_numbers)
print(squared_numbers)  # Output: [1, 4, 9, 16, 25]</pre>			<p class="calibre5">Another useful type is <strong class="source-inline">Literal</strong> , which restricts the possible values of a variable to a few <span>admissible states:</span></p>
			<pre class="source-code">
from typing import Literal
account_type: Literal["personal", "business"]
account_type = "name"</pre>			<p class="calibre5">The preceding lines showcase the power of type hints. There is nothing inherently wrong with assigning the <strong class="source-inline">account_type</strong> variable to a string, but that string is not part of the admissible state set and thus Mypy complains and returns an <strong class="source-inline">Incompatible types in </strong><span><strong class="source-inline">assignment</strong></span><span> error.</span></p>
			<p class="calibre5">Now, look at an example that includes a <strong class="source-inline">datetime</strong> argument. Create a new file <span>called </span><span><strong class="source-inline">chapter3_03.py</strong></span><span>:</span></p>
			<pre class="source-code">
from datetime import datetime
def format_datetime(dt: datetime) -&gt; str:
     return dt.strftime("%Y-%m-%d %H:%M:%S")
now = datetime.now()
print(format_datetime(now))</pre>			<p class="calibre5">The previously defined function accepts one parameter—a datetime object—and outputs a string: a nicely formatted date and time, useful for displaying on websites. If you try to type <em class="italic">dt</em> and then a dot in your Visual Studio Code editor, you will be prompted by the autocompletion system, offering all the methods and properties related to the <span>datetime object.</span></p>
			<p class="calibre5">To declare a structure as a list of dictionaries (something very familiar to anyone working with a JSON-based API), you could use something like this, in a file <span>named </span><span><strong class="source-inline">chapter3_04.py</strong></span><span>:</span></p>
			<pre class="source-code">
def get_users(id: int) -&gt; list[dict]:
    return [
        {"id": 1, "name": "Alice"},
        {"id": 2, "name": "Bob"},
        {"id": 3, "name": "Charlie"},
    ]</pre>			<p class="calibre5">After having covered the basic annotation types in Python, the next few sections will look at some more advanced types that are very useful when working with FastAPI <span>and Pydantic.</span></p>
			<h2 id="_idParaDest-52" class="about-the-author"><a id="_idTextAnchor058" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Advanced annotations</h2>
			<p class="calibre5">The annotations you have seen so far are very simple and convey basic information related only to the specific desired type of a variable, function, class argument, or output. Python’s typing system is capable of much more and it can be used to restrict the allowable variables' state further and prevent you, the developer, from creating impossible or illegal states in your code. </p>
			<p class="calibre5">The most frequently used types are <span>the following:</span></p>
			<ul class="calibre14">
				<li class="calibre17">The <strong class="source-inline">Optional</strong> type is used for handling optional values and <strong class="source-inline">None</strong> values in an explicit and <span>developer-friendly way.</span></li>
				<li class="calibre17">The <strong class="source-inline">Union</strong> type allows you to define a union of possible types, such as integers and strings. Modern Python uses the pipe operator (<strong class="source-inline">|</strong>), as shown in the <span>previous example.</span></li>
				<li class="calibre17">The <strong class="source-inline">self</strong> type is used to indicate that the value will be an instance of a certain class, useful in Pydantic model validators as we will <span>see later.</span></li>
				<li class="calibre17">The <strong class="source-inline">New</strong> type allows developers to define completely new types based on <span>existing types.</span></li>
			</ul>
			<p class="calibre5">This section detailed Python type hints, their purpose, and how they are implemented. The next section will take a deeper look at Pydantic, the workhorse of FastAPI <span>data validation.</span></p>
			<h1 id="_idParaDest-53" class="contributor"><a id="_idTextAnchor059" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Pydantic</h1>
			<p class="calibre5">Pydantic is a data validation library labeled on its website as the most widely used data validation library for Python. It allows you to model your data in a granular way and perform various types of validation while being firmly rooted in the Python type hinting system. The actual version, V2, has critical parts of the code rewritten in <strong class="bold">Rust</strong> for speed and allows for an excellent developer experience. The following list describes some of the benefits of <span>using Pydantic:</span></p>
			<ul class="calibre14">
				<li class="calibre17"><strong class="bold">Based on type hints that are part of the standard library</strong>: Instead of needing to learn contrived new systems or terminologies, you just need to learn pure <span>Python types.</span></li>
				<li class="calibre17"><strong class="bold">Excellent speed</strong>: Everything about FastAPI and MongoDB revolves around speed—fast and responsive applications delivered in record time—so having a fast validation and parsing library is mandatory. The core of Pydantic is written in Rust, which ensures high-speed operations <span>on data.</span></li>
				<li class="calibre17"><strong class="bold">Huge community support and wide adoption</strong>: Learning your way around Pydantic will prove useful when working with popular packages such as Django Ninja, SQLModel, LangChain, <span>and more.</span></li>
				<li class="calibre17"><strong class="bold">The possibility of emitting JSON schema</strong>: It facilitates integration with <span>other systems.</span></li>
				<li class="calibre17"><strong class="bold">More flexibility</strong>: Pydantic supports different modes (strict and lax when it comes to coercion) and nearly unlimited customization options <span>and flexibility.</span></li>
				<li class="calibre17"><strong class="bold">Popular among developers</strong>: It has been downloaded more than 70 million times and over 8,000 packages on PyPI depend on Pydantic (as of <span>July 2024).</span></li>
			</ul>
			<p class="callout-heading">Note</p>
			<p class="callout">You can take a look at Pydantic in detail in its documentation:  <a href="https://docs.pydantic.dev/latest/" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"><span><span>https://docs.pydantic.dev/latest/</span></span></a><span>.</span></p>
			<p class="calibre5">Broadly speaking, Pydantic tackles many important problems in a modern web development workflow. It ensures that the data that is ingested into your application is properly formed and formatted, falls within the desired range, is of the appropriate type and dimensions, and reaches your document store safely and <span>without errors.</span></p>
			<p class="calibre5">Pydantic also ensures that your application outputs the data exactly as intended and according to the specification, omitting fields that should not be exposed (such as user passwords) and even more complex tasks, including interfacing with other <span>incompatible systems.</span></p>
			<p class="calibre5">FastAPI is standing on the shoulders of two powerful Python libraries—Starlette and Pydantic. While Starlette takes care of the web-related aspects of the framework, often through thin wrappers and utility functions and classes provided by FastAPI, Pydantic is responsible for FastAPI’s phenomenal developer experience. Pydantic is fundamental to FastAPI, and leveraging its powerful capabilities opens up the playing field for all FARM <span>stack developers.</span></p>
			<p class="calibre5">While type checking is performed statically (without running the code), the role of Pydantic is apparent during runtime and performs the role of a guardian of inbound data. Your FastAPI application will receive data from users, from a flexible MongoDB database schema, and from other systems via APIs—and Pydantic will facilitate the parsing and data validation. Instead of crafting complex validation logic for every possible invalid case, you will simply create Pydantic models of desired complexity, matching your application’s needs as closely <span>as possible.</span></p>
			<p class="calibre5">In the following sections, you will explore most of functionality of Pydantic through examples with increasing complexity and demands as we feel that it is the best and most effective way of familiarizing yourself with <span>the library.</span></p>
			<h2 id="_idParaDest-54" class="about-the-author"><a id="_idTextAnchor060" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Pydantic basics</h2>
			<p class="calibre5">Unlike some other libraries that provide similar functionality (such as <strong class="source-inline">dataclasses</strong>), Pydantic provides a base model (aptly named <strong class="source-inline">BaseModel</strong>) that enables the parsing and validation functionality through inheritance. Since you will be building a user model in the coming sections, you can start by jotting down the most basic data that needs to be associated with your user. At the minimum, you will need <span>the following:</span></p>
			<ul class="calibre14">
				<li class="calibre17"><span>A username</span></li>
				<li class="calibre17">An <span>email address</span></li>
				<li class="calibre17">An ID (keep it as an integer <span>for now)</span></li>
				<li class="calibre17">A date <span>of birth</span></li>
			</ul>
			<p class="calibre5">In Pydantic, a user model that would be associated with this specification could look like the following, in a file <span>called </span><span><strong class="source-inline">chapter3_05.py</strong></span><span>:</span></p>
			<pre class="source-code">
from datetime import datetime
from pydantic import BaseModel
class User(BaseModel):
    id: int
    username: str
    email: str
    dob: datetime</pre>			<p class="calibre5">The <strong class="source-inline">User</strong> class already handled a lot of work for you—there is no need to perform validation checks as the instantiation of the class performs the validation and <span>parsing immediately.</span></p>
			<p class="calibre5">The process of constructing the class is pretty straightforward: each field has a type declaration, and Pydantic is ready to inform you of any erroneous types it <span>might encounter.</span></p>
			<p class="calibre5">If you try and create a user, you shouldn’t see <span>any errors:</span></p>
			<pre class="source-code">
Pu = User(id=1, username="freethrow", email="email@gmail.com", dob=datetime(1975, 5, 13))</pre>			<p class="calibre5">Say however, you create a user with the wrong data, and conveniently import the Pydantic <span><strong class="source-inline">ValidationError</strong></span><span>:</span></p>
			<pre class="source-code">
from pydantic import BaseModel, ValidationError
try:
    u = User(
        id="one",
        username="freethrow",
        email="email@gmail.com",
        dob=datetime(1975, 5, 13),
    )
    print(u)
except ValidationError as e:
    print(e)</pre>			<p class="calibre5">Pydantic will inform you that the data cannot be validated when you run <span>the program:</span></p>
			<pre class="source-code">
1 validation error for User
id
  Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='one', input_type=str]</pre>			<p class="calibre5">The error messages of Pydantic, derived from <strong class="source-inline">ValidationError</strong>, are deliberately informative and precise. The field with an error is called <strong class="source-inline">id</strong> and the type of error is described. The first useful aspect that comes to mind is that if there were several errors—for instance, you might provide an invalid <strong class="source-inline">datetime</strong>—Pydantic will not stop at the first error. It will continue parsing the entire instance and outputting the list of errors that can easily be output in JSON format. That is actually the desired behavior when working with APIs; you want to be able to list all the errors, for instance, to a user that has sent the wrong data to the backend. The exception contains a list of all the <span>encountered errors.</span></p>
			<p class="calibre5">The model guarantees that the instance, once validation is passed, will have the required fields and that they are of the <span>correct type.</span></p>
			<p class="calibre5">You can also provide defaults and nullable types, according to the type <span>hinting conventions:</span></p>
			<pre class="source-code">
class User(BaseModel):
    id: int = 2
    username: str
    email: str
    dob: datetime
    fav_colors: list[str] | None = ["red", "blue"]</pre>			<p class="calibre5">The previous model has a default <strong class="source-inline">id</strong> value (which is not something that you would want to do in practice) and a list of favorite colors as strings, which can also <span>be </span><span><strong class="source-inline">None</strong></span><span>.</span></p>
			<p class="calibre5">When you create and print a model (or more precisely, when you invoke its representation via the <strong class="source-inline">print</strong> function), you get a <span>nice output:</span></p>
			<pre class="source-code">
id=2 username='marko' email='email@gmail.com' dob=datetime.datetime(1975, 5, 13, 0, 0) fav_colors=None</pre>			<p class="calibre5">Pydantic by default operates in a lax mode, which means that it will try to coerce the provided types to the ones that are declared in the model. For instance, if you pass the user ID as a string <strong class="source-inline">"2"</strong> to the model, there will not be any errors, as Pydantic automatically converts the ID to <span>an integer.</span></p>
			<p class="calibre5">Although fields are available through the dot notation (<strong class="source-inline">user.id</strong>) and they can be easily modified, this is not recommended as the validation rules will not be applied. You could instantiate a user with an <strong class="source-inline">id</strong> value of <strong class="source-inline">5</strong>, access <strong class="source-inline">user.id</strong>, and set it to a string <strong class="source-inline">"five"</strong>, but that is probably not something you <span>would want.</span></p>
			<p class="calibre5">Besides pure data validation, Pydantic provides other important functionalities to your application. Some of the most widely used operations with Pydantic models are <span>the following:</span></p>
			<ul class="calibre14">
				<li class="calibre17"><strong class="bold">Data deserialization</strong>: Ingesting data into <span>the model</span></li>
				<li class="calibre17"><strong class="bold">Data serialization</strong>: Outputting validated data from the model into Python data structures <span>or JSON</span></li>
				<li class="calibre17"><strong class="bold">Data modification</strong>: Sanitizing or modifying data on <span>the fly</span></li>
			</ul>
			<p class="calibre5">The next few sections will look at each of these operations in <span>more detail.</span></p>
			<h2 id="_idParaDest-55" class="about-the-author"><a id="_idTextAnchor061" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Deserialization</h2>
			<p class="calibre5">Deserialization refers to the process of providing data to the model, which is the input phase, as opposed to the process of serialization, which means outputting model data in a desired form. Deserialization is tightly coupled with validation as the processes of validation and parsing are performed when instantiating the model, although this can <span>be overridden.</span></p>
			<p class="calibre5">In Pydantic, the term <strong class="bold">validation</strong> refers to the process of instantiating a model (or other type) that adheres to specified types and constraints. Pydantic guarantees the types and constraints of the output, not the input data. This distinction becomes apparent when you consider the <strong class="source-inline">ValidationError</strong> type of Pydantic that is raised when data cannot be successfully parsed into a <span>model instance.</span></p>
			<p class="calibre5">While you have already performed a couple of validations through instantiating the Pydantic-based user models, the data to be validated is often passed in the form of a dictionary. The following is an example of passing data as a dictionary, in a file <span>named </span><span><strong class="source-inline">chapter3_06.py</strong></span><span>:</span></p>
			<p class="calibre5">Create another version of your user model and pass it a dictionary <span>of data:</span></p>
			<pre class="source-code">
class User(BaseModel):
    id: int
    username: str
    email: str
    password: str
user = User.model_validate(
    {
        "id": 1,
        "username": "freethrow",
        "email": "email@gmail.com",
        "password": "somesecret",
    }
)
print(user)</pre>			<p class="calibre5">The <strong class="source-inline">.model_validate()</strong> method is a helper that accepts a Python dictionary and performs the class instantiation and thus validation. This method creates your <strong class="source-inline">user</strong> instance and validates the data types in <span>one step.</span></p>
			<p class="calibre5">Similarly, <strong class="source-inline">model_validate_json()</strong> accepts a JSON string (useful when working <span>with APIs).</span></p>
			<p class="calibre5">There is also a method for constructing a model instance without validation with <strong class="source-inline">model_construct()</strong> but this has very specific user cases and is not recommended in <span>most cases.</span></p>
			<p class="calibre5">You have learned how to pass data to your simple Pydantic model. The next section will take a closer look at the model fields and <span>their properties.</span></p>
			<h2 id="_idParaDest-56" class="about-the-author"><a id="_idTextAnchor062" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Model fields</h2>
			<p class="calibre5">Pydantic fields are based on Python types and setting them to be required or nullable and providing default values is intuitive. For instance, to create a default value for a field, it is enough to provide it in the model as a value, while the nullable field follows the same conventions that you saw in the <em class="italic">Python types</em> sections—by using the older union syntax from the <strong class="source-inline">typing</strong> module, or the newer syntax with the <span>pipe operator.</span></p>
			<p class="calibre5">The following is an example of another user model in a file <span>named </span><span><strong class="source-inline">chapter3_07.py</strong></span><span>:</span></p>
			<ol class="calibre14">
				<li class="calibre15">Insert some <span>default values:</span><pre class="source-code">
from pydantic import BaseModel
from typing import Literal
class UserModel(BaseModel):
    id: int
    username: str
    email: str
    account: Literal["personal", "business"] | None = None
    nickname: str | None = None</pre><p class="list-inset">The previously defined <strong class="source-inline">UserModel</strong> class defines a couple of standard string-type fields: an account that can have exactly two values or be equal to <strong class="source-inline">None</strong> and a nickname that can be a string <span>or </span><span><strong class="source-inline">None</strong></span><span>.</span></p></li>				<li class="calibre15">You may use the <strong class="source-inline">model_fields</strong> property to inspect the model <span>as follows:</span><pre class="source-code">
print(UserModel.model_fields)</pre><p class="list-inset">You will get a handy list of all the fields belonging to the model with information about them including their types and whether they <span>are required:</span></p><pre class="source-code">{'id': FieldInfo(annotation=int, required=True), 'username': FieldInfo(annotation=str, required=True), 'email': FieldInfo(annotation=str, required=True), 'account': FieldInfo(annotation=Union[Literal['personal', 'business'], NoneType], required=False, default=None), 'nickname': FieldInfo(annotation=Union[str, NoneType], required=False, default=None)}</pre></li>			</ol>
			<p class="calibre5">The next section will detail Pydantic-specific types that make working with the library easier <span>and faster.</span></p>
			<h2 id="_idParaDest-57" class="about-the-author"><a id="_idTextAnchor063" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Pydantic types</h2>
			<p class="calibre5">While Pydantic is based on standard Python types such as strings, integers, dictionaries, and sets, which makes it very intuitive and straightforward for starting, the library also provides a plethora of customizations and solutions for common cases. In this section, you will get to know the most <span>useful ones.</span></p>
			<p class="calibre5">Strict types such as <strong class="source-inline">StrictBool</strong>, <strong class="source-inline">StrictInt</strong>, <strong class="source-inline">StrictStr</strong>, and other Pydantic-specific types are types that will pass validation only if the validated value belongs to these types, without any coercion: a <strong class="source-inline">StrictInt</strong> must be of type <strong class="source-inline">Integer</strong> and not <strong class="source-inline">"1"</strong> or <strong class="source-inline">1.0</strong>, <span>for example.</span></p>
			<p class="calibre5">Constrained types provide additional constraints for existing types. For instance, <strong class="source-inline">condate()</strong> is a date type with greater than, greater than or equal, less than, and less than or equal constraints. <strong class="source-inline">conlist()</strong> wraps the list type and adds length validation or can impose a rule that the items contained must <span>be unique.</span></p>
			<p class="calibre5">Pydantic is not limited to the validation of primitive types such as strings and integers. Many additional validators cover the vast majority of uses that you might run into while modeling your business logic. For instance, the <strong class="source-inline">email</strong> validator validates email addresses and, since it is not part of the core Pydantic package, it needs to be installed separately by using the <span>following command:</span></p>
			<pre class="source-code">
pip install pydantic[email]</pre>			<p class="calibre5">The Pydantic website (<span>https://docs.pydantic.dev/latest/api/types/</span>) provides a comprehensive list of additional validation types that extend the functionalities—lists can have a minimum and maximum length, uniqueness can be required, integers can be positive or negative, and many more, including CSS color codes, <span>for instance.</span></p>
			<h2 id="_idParaDest-58" class="about-the-author"><a id="_idTextAnchor064" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Pydantic fields</h2>
			<p class="calibre5">While the simple Python type annotations might suffice in many cases, the real power of Pydantic starts to show when you begin to use the <strong class="source-inline">Field</strong> class for the fields. The <strong class="source-inline">Field</strong> class is used to customize models and add metadata to the <span>model fields.</span></p>
			<p class="calibre5">Let’s see how you can use the <strong class="source-inline">Field</strong> class for the <strong class="source-inline">UserModel</strong> explored in the previous section. Create a file and name <span>it </span><span><strong class="source-inline">chapter3_08.py</strong></span><span>.</span></p>
			<p class="calibre5">First, rewrite your previous <strong class="source-inline">UserModel</strong> with the help of the <span><strong class="source-inline">Field</strong></span><span> class:</span></p>
			<pre class="source-code">
from typing import Literal
from pydantic import BaseModel, Field
class UserModelFields(BaseModel):
    id: int = Field(…)
    username: str = Field(…)
    email: str = Field(…)
    account: Literal["personal", "business"] | None = Field(default=None)
    nickname: str | None = Field(default=None)</pre>			<p class="calibre5">This model is equivalent to the one previously defined without fields. The first syntactic difference can be seen in the way default values are provided—the <strong class="source-inline">Field</strong> class accepts a default value that is <span>defined explicitly.</span></p>
			<p class="calibre5">Fields also provide additional model flexibility, through the use of aliases, as you will see in the <span>next section.</span></p>
			<h3 class="calibre8">Field aliases</h3>
			<p class="calibre5">Fields allow you to create and use aliases, which is very useful when dealing with different systems that need to be compatible with your Pydantic-based data definition. Create a file named <strong class="source-inline">chapter3_09.py</strong>. Assume that your application uses the <strong class="source-inline">UserModelFields</strong> model for users, but also needs to be able to ingest data from another system, maybe through a JSON-based API, and this other system sends the data in the following <span>JSON format:</span></p>
			<pre class="source-code">
external_api_data = {
    "user_id": 234,
    "name": "Marko",
    "email": "email@gmail.com",
    "account_type": "personal",
    "nick": "freethrow",
}</pre>			<p class="calibre5">This format clearly doesn’t conform to your <strong class="source-inline">UserModelFields</strong> model and aliases provide an elegant way of dealing with <span>this incompatibility:</span></p>
			<pre class="source-code">
class UserModelFields(BaseModel):
    id: int = Field(<strong class="bold">alias="user_id"</strong>)
    username: str = Field(<strong class="bold">alias="name"</strong>)
    email: str = Field()
    account: Literal["personal", "business"] | None = Field(
        default=None, <strong class="bold">alias="account_type"</strong>
    )
    nickname: str | None = Field(default=None, <strong class="bold">alias="nick"</strong>)</pre>			<p class="calibre5">This updated model provides aliases for all the fields that have different names, so it is possible to validate your <span>external data:</span></p>
			<pre class="source-code">
user = UserModelFields.model_validate(external_api_data)</pre>			<p class="calibre5">In this case, you have used the simple <strong class="source-inline">alias</strong> parameter, but there are other options for aliases for serialization or for <span>validation only.</span></p>
			<p class="calibre5">Additionally, the <strong class="source-inline">Field</strong> class enables numeric values to be constrained in different ways, which is a feature heavily used in FastAPI. Create a file called <strong class="source-inline">chapter3_10.py</strong> and start <span>populating it.</span></p>
			<p class="calibre5">Suppose you need to model a chess event that has the <span>following fields:</span></p>
			<pre class="source-code">
from datetime import datetime
from uuid import uuid4
from pydantic import BaseModel, Field
class ChessTournament(BaseModel):
    id: int = Field(strict=True)
    dt: datetime = Field(default_factory=datetime.now)
    name: str = Field(min_length=10, max_length=30)
    num_players: int = Field(ge=4, le=16, multiple_of=2)
    code: str = Field(default_factory=uuid4)</pre>			<p class="calibre5">In this relatively simple class, Pydantic fields introduce some complex validation rules that would otherwise be very verbose and cumbersome <span>to write:</span></p>
			<ul class="calibre14">
				<li class="calibre17"><strong class="source-inline">dt</strong>: The <strong class="source-inline">datetime</strong> object of the tournament uses a <strong class="source-inline">default_factory</strong> parameter, a function invoked at instantiation time that provides the default value. In this case, the value is equal <span>to </span><span><strong class="source-inline">datetime.now</strong></span><span>.</span></li>
				<li class="calibre17"><strong class="source-inline">name</strong>: This field has some length constraints, such as the minimum and <span>maximum length.</span></li>
				<li class="calibre17"><strong class="bold">The number of enlisted players is constrained</strong>: It must be greater than or equal to 4, less than or equal to 16, and additionally, it must be an even number—a multiple of 2—to allow for all players to play in <span>each round.</span></li>
				<li class="calibre17"><strong class="bold">The code of the tournament</strong>: This is another string generated by a default factory, in this case the <span><strong class="source-inline">uuid</strong></span><span> library.</span></li>
				<li class="calibre17"><strong class="source-inline">id</strong>: This field is an integer, but this time you apply the <strong class="source-inline">strict</strong> flag, which means you override the default behavior of Pydantic and do not allow strings like <strong class="source-inline">"3"</strong> to pass validation, even though they could be cast <span>to integers.</span></li>
			</ul>
			<p class="callout-heading">Note</p>
			<p class="callout">A useful page in the Pydantic documentation is dedicated to Fields: <span>https://docs.pydantic.dev/latest/concepts/fields/</span>. There are numerous validation options available through the <strong class="source-inline">Field</strong> class, and you are encouraged to skim through them before you start your <span>modeling process.</span></p>
			<p class="calibre5">The next section will detail how to get the data out of the model through the process <span>of deserialization.</span></p>
			<h2 id="_idParaDest-59" class="about-the-author"><a id="_idTextAnchor065" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Serialization</h2>
			<p class="calibre5">The most important task of any parsing and validation library is data serialization (or data dumping). It is the process of converting and outputting a model instance to a Python dictionary or a JSON-encoded string. The method for generating a Python dictionary is <strong class="source-inline">model_dump()</strong>, as demonstrated by the following user model example, in a new file <span>called </span><span><strong class="source-inline">chapter3_11.py</strong></span><span>.</span></p>
			<p class="calibre5">To be able to use email validation in Pydantic, add the following line to the <span><strong class="source-inline">requirements.txt</strong></span><span> file:</span></p>
			<pre class="source-code">
email_validator==2.1.1</pre>			<p class="calibre5">And then, re-run the <span>user model:</span></p>
			<pre class="source-code">
pip install -r requirements.txt
class UserModel(BaseModel):
    id: int = Field()
    username: str = Field(min_length=5, max_length=20)
    email: EmailStr = Field()
    password: str = Field(min_length=5, max_length=20, pattern="^[a-zA-Z0-9]+$")</pre>			<p class="calibre5">The user model that you are using is a fairly standard one, and, with your knowledge of Pydantic fields, you can already understand it. There are a couple of new validations, but they are intuitive: the <strong class="source-inline">EmailStr</strong> object imported from Pydantic is a string that validates email addresses, while the <strong class="source-inline">password</strong> field contains an additional regular expression to ensure that the field contains only alphanumeric characters and no spaces. Here’s <span>another example:</span></p>
			<ol class="calibre14">
				<li class="calibre15">Create an instance of the model and serialize it to a <span>Python dictionary:</span><pre class="source-code">
u = UserModel(
    id=1,
    username="freethrow",
    email="email@gmail.com",
    password="password123",
)
print(u.model_dump())</pre><p class="list-inset">The result is a simple <span>Python dictionary:</span></p><pre class="source-code">{'id': 1, 'username': 'freethrow', 'email': 'email@gmail.com', 'password': 'password123'}</pre></li>				<li class="calibre15">Try to dump the model to a JSON representation and omit the password for <span>security reasons:</span><pre class="source-code">
print(u.model_dump_json(exclude=set("password"))</pre><p class="list-inset">The result is a JSON string with the <span>password omitted:</span></p><pre class="source-code">{"id":1,"username":"freethrow","email":"email@gmail.com"}</pre></li>			</ol>
			<p class="calibre5">Serialization uses the field names and not the aliases by default, but that is another setting that can be easily overridden by setting the <strong class="source-inline">by_alias</strong> flag <span>to </span><span><strong class="source-inline">True</strong></span><span>.</span></p>
			<p class="calibre5">An example of an alias used when working with FastAPI and MongoDB is MongoDB’s <strong class="source-inline">ObjectId</strong> field, which is mostly serialized as a string. Another useful method is <strong class="source-inline">model_json_schema()</strong>, which generates the JSON schema for <span>a model.</span></p>
			<p class="calibre5">Models can be additionally configured through the <strong class="source-inline">ConfigDict</strong> object, and the special field called <strong class="source-inline">model_config</strong>—the name is reserved and mandatory. In the following file, called <strong class="source-inline">chapter3_12.py</strong>, you are using the <strong class="source-inline">model_config</strong> field to allow populating the model by name and prevent passing additional data to <span>the model:</span></p>
			<pre class="source-code">
from pydantic import BaseModel, Field, ConfigDict, EmailStr
class UserModel(BaseModel):
    id: int = Field()
    username: str = Field(min_length=5, max_length=20, alias="name")
    email: EmailStr = Field()
    password: str = Field(min_length=5, max_length=20, pattern="^[a-zA-Z0-9]+$")
    model_config = ConfigDict(extra="forbid", populate_by_name=True)</pre>			<p class="calibre5">The <strong class="source-inline">model_config</strong> field allows for additional configuration of the model. For instance, the <strong class="source-inline">extra</strong> keyword refers to additional data fields that are passed to the deserialization process: the default behavior is just to ignore <span>this data.</span></p>
			<p class="calibre5">In this example, we set <strong class="source-inline">extra</strong> to <strong class="source-inline">forbid</strong>, so any additional data passed and not declared in the model will throw a validation error. <strong class="source-inline">populate_by_name</strong> is another useful setting as it allows us to populate a model by using field names and not only aliases, practically mixing and matching. You will see that this feature is handy when crafting APIs that have to talk to <span>different systems.</span></p>
			<h3 class="calibre8">Custom serializers</h3>
			<p class="calibre5">Pydantic can provide you with virtually unlimited capabilities when it comes to serialization and also provides different serialization methods for Python and JSON outputs with the use of the <strong class="source-inline">@</strong><span><strong class="source-inline">field_serializer</strong></span><span> decorator.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">Python decorators are a powerful and elegant feature that allow you to modify or extend the behavior of functions or methods without changing their <span>actual code.</span></p>
			<p class="callout">Decorators are higher-order functions that take a function as input, add some functionality, and return a new, decorated function. This approach promotes the reusability, modularity, and separation of concerns in your <span>Python programs.</span></p>
			<p class="calibre5">In the following example, you are going to create a very simple bank account model and use different serializers depending on the type of serialization. Your requirement is to round the balance to exactly two decimals and, only when serializing to JSON, to format the <strong class="source-inline">updated</strong> field according to the <span>ISO format:</span></p>
			<ol class="calibre14">
				<li class="calibre15">Create a new file named <strong class="source-inline">chapter3_13.py</strong> and add a simple model for a bank account that contains only two fields, the balance and the time of the last <span>account update:</span><pre class="source-code">
from datetime import datetime
from pydantic import BaseModel, field_serializer
class Account(BaseModel):
    balance: float
    updated: datetime
    @field_serializer("balance", when_used="always")
    def serialize_balance(self, value: float) -&gt; float:
        return round(value, 2)
    @field_serializer("updated", when_used="json")
    def serialize_updated(self, value: datetime) -&gt; str:
       return value.isoformat()</pre><p class="list-inset">You have added two custom serializers. The first is the balance serializer (as denoted by the string <strong class="source-inline">"balance"</strong>), which will always be used. This serializer simply rounds the balance to two decimals. The second serializer is used only for JSON serialization and returns the date as an ISO-formatted <span>datetime string.</span></p></li>				<li class="calibre15">If you try to populate the model and inspect the serializations, you will see how the serializers modified the initial <span>default output:</span><pre class="source-code">
account_data = {
    "balance": 123.45545,
    "updated": datetime.now(),
}
account = Account.model_validate(account_data)
print("Python dictionary:", account.model_dump())
print("JSON:", account.model_dump_json())</pre><p class="list-inset">You will get a <span>similar output:</span></p><pre class="source-code">Python dictionary: {'balance': 123.46, 'updated': datetime.datetime(2024, 5, 2, 21, 34, 11, 917378)}
JSON: {"balance":123.46,"updated":"2024-05-02T21:34:11.917378"}</pre></li>			</ol>
			<p class="calibre5">Earlier in this chapter, you saw basic validation provided by Pydantic through the mere instantiation of the model class. The next section will discuss the various custom validation methods of Pydantic with the help of Pydantic decorators and how they can be leveraged to move beyond serialization and provide powerful custom <span>validation functionality.</span></p>
			<h2 id="_idParaDest-60" class="about-the-author"><a id="_idTextAnchor066" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Custom data validation</h2>
			<p class="calibre5">Similar to custom field serializers, custom field validators are implemented as decorators, with the <strong class="source-inline">@</strong><span><strong class="source-inline">field_validator</strong></span><span> decorator.</span></p>
			<p class="calibre5">Field validators are class methods, so they must receive the entire class as the first argument, not the instance, while the second value is the name of the field to be validated (or a list of fields, or the <strong class="source-inline">*</strong> symbol for <span>all fields).</span></p>
			<p class="calibre5">Field validators should return either the parsed value or a <strong class="source-inline">ValueError</strong> response (or <strong class="source-inline">AssertionError</strong>) in case the data passed to the validator doesn’t conform to the validation rules. As with other Pydantic features, it is much easier to start with an example. Create a new file called <strong class="source-inline">chapter3_14.py</strong> and insert the <span>following code:</span></p>
			<pre class="source-code">
from pydantic import BaseModel,  field_validator
class Article(BaseModel):
    id: int
    title: str
    content: str
    published: bool
    @field_validator("title")
    @classmethod
    def check_title(cls, v: str) -&gt; str:
        if "FARM stack" not in v:
            raise ValueError('Title must contain "FARM stack"')
        return v.title()</pre>			<p class="calibre5">The validator is run before the class instantiation and accepts the class and the name of the validated field as arguments. The <strong class="source-inline">check_title</strong> validator checks that the title contains the string <strong class="source-inline">"FARM stack"</strong> and if it doesn’t, it throws <strong class="source-inline">ValueError</strong>. Additionally, the validator returns the string in title case, so we can perform data transformation as well, at the <span>field level.</span></p>
			<p class="calibre5">While field validators provide great flexibility, they do not consider field interactions and the combinations of field values. That is where model validators come into play, as the next section <span>will outline.</span></p>
			<h2 id="_idParaDest-61" class="about-the-author"><a id="_idTextAnchor067" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Model validators</h2>
			<p class="calibre5">Another useful feature when performing validation of web-related data is model validation—the possibility to write validation functions at the model level, allowing for complex interactions between <span>various fields.</span></p>
			<p class="calibre5">The model validators can run before or after instantiating the model class. Again, we will take a look at a rather <span>simple example:</span></p>
			<ol class="calibre14">
				<li class="calibre15">First, create a new file and name <span>it </span><span><strong class="source-inline">chapter3_15.py</strong></span><span>.</span></li>
				<li class="calibre15">Suppose you have a user model with the <span>following structure:</span><pre class="source-code">
from pydantic import BaseModel, EmailStr, ValidationError, model_validator
from typing import Any, Self
class UserModelV(BaseModel):
    id: int
    username: str
    email: EmailStr
    password1: str
    password2: str</pre><p class="list-inset">The model is simple like the previous ones, and it contains two password fields that are required to match to enable the registration of a new user. Additionally, you want to impose another validation—the data that comes into the model via deserialization must not contain private data (such as a social security number or card number). Model validators allow you to perform flexible validations such <span>as this.</span></p></li>				<li class="calibre15">Continuing the previous model, you can write the following model validators under the <span>class definition:</span><pre class="source-code">
@model_validator(mode='after')
def check_passwords_match(self) -&gt; Self:
    pw1 = self.password1
    pw2 = self.password2
    if pw1 is not None and pw2 is not None and pw1 != pw2:
        raise ValueError('passwords do not match')
    return self
@model_validator(mode='before')
@classmethod
def check_private_data(cls, data: Any) -&gt; Any:
    if isinstance(data, dict):
        assert (
            'private_data' not in data
        ), 'Private data should not be included'
    return data</pre></li>				<li class="calibre15">Now, try to validate of the <span>following data:</span><pre class="source-code">
usr_data = {
    "id": 1,
    "username": "freethrow",
    "email": "email@gmail.com",
    "password1": "password123",
    "password2": "password456",
    "private_data": "some private data",
}
try:
    user = UserModelV.model_validate(usr_data)
    print(user)
except ValidationError as e:
    print(e)</pre><p class="list-inset">You will be informed of just one error—the one related to the <strong class="source-inline">before</strong> mode, stating that private data should not <span>be included.</span></p></li>				<li class="calibre15">If you comment out or delete the line that sets the <strong class="source-inline">private_data</strong> field and re-run the example, the error becomes <span>the following:</span><pre class="source-code">
Value error, passwords do not match [type=value_error, input_value={'id': 1, 'username': 'fr...ssword2': 'password456'}, input_type=dict]</pre></li>			</ol>
			<p class="calibre5">There are a couple of new concepts involved in the previous example; you are using the <strong class="source-inline">Self</strong> Python type, introduced for denoting instances of the wrapping class, so you practically expect the output to be an instance of the <span><strong class="source-inline">UserModelV</strong></span><span> class.</span></p>
			<p class="calibre5">Another new concept is present in the <strong class="source-inline">check_private_data</strong> function as it checks whether the data passed to the class is an instance of a dictionary, and then proceeds to verify whether the undesired <strong class="source-inline">private_data</strong> field is present in the dictionary—this is just Pydantic’s way of checking for the data passed as it is stored inside <span>a dictionary.</span></p>
			<p class="calibre5">The next section will detail how to compose nested models with Pydantic to validate models of <span>increasing complexity.</span></p>
			<h2 id="_idParaDest-62" class="about-the-author"><a id="_idTextAnchor068" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Nested models</h2>
			<p class="calibre5">The treatment of nested models in Pydantic through composition is very straightforward and intuitive if you are coming from a basic MongoDB background. To understand how to implement nested models, the easiest way is to start from an existing data structure that needs to be validated and run <span>through Pydantic:</span></p>
			<ol class="calibre14">
				<li class="calibre15">Begin with the structure of a JSON document that returns car brands and makes (or models). Create a new file named <strong class="source-inline">chapter3_16.py</strong> and add the following lines <span>of code:</span><pre class="source-code">
car_data = {
    "brand": "Ford",
    "models": [
        {"model": "Mustang", "year": 1964},
        {"model": "Focus", "year": 1975},
        {"model": "Explorer", "year": 1999},
    ],
    "country": "USA",
}</pre><p class="list-inset">You can start from the inside of the data structure and begin identifying the smallest units or the most deeply nested structures—in this case, the smallest unit is the car model (a Ford Mustang <span>from 1964).</span></p></li>				<li class="calibre15">This can be the first <span>Pydantic model:</span><pre class="source-code">
class CarModel(BaseModel):
    model: str
    year: int</pre></li>				<li class="calibre15">Once this first abstraction is made, it is easy to create a model for <span>the brand:</span><pre class="source-code">
class CarBrand(BaseModel):
    brand: str
    models: List[CarModel]
    country: str</pre></li>			</ol>
			<p class="calibre5">The car brand model has distinct names and countries of origin and contains a list <span>of models.</span></p>
			<p class="calibre5">Model fields can be other models (or lists or sets or other sequences thereof) and this feature makes mapping Pydantic data structures to data, and especially MongoDB documents, a very pleasant and <span>intuitive process.</span></p>
			<p class="calibre5">While MongoDB can support up to 100 levels of nesting, you will probably not hit that limit in your data modeling process. However, it’s worth noting that Pydantic will support you as you delve deeper and deeper into your data structures. Embedding data also becomes much more manageable from the Python side, as you can rest assured that data coming into your collections is stored <span>as intended.</span></p>
			<p class="calibre5">The next and final section will detail another useful tool that Pydantic offers—a little help with managing environment variables and settings, a problem that you face in every <span>web-related project.</span></p>
			<h2 id="_idParaDest-63" class="about-the-author"><a id="_idTextAnchor069" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Pydantic Settings</h2>
			<p class="calibre5">Pydantic Settings is an external package that needs to be installed separately. It provides Pydantic features for loading a settings or config class from environment variables or <span>secret files.</span></p>
			<p class="calibre5">That is basically the definition from the Pydantic website (<a href="https://docs.pydantic.dev/latest/concepts/pydantic_settings/" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"><span>https://docs.pydantic.dev/latest/concepts/pydantic_settings/</span></a>), and the whole concept revolves around the <span><strong class="source-inline">BaseSettings</strong></span><span> class.</span></p>
			<p class="calibre5">A model that inherits from this class attempts to read the values of any fields passed as keyword arguments by scanning <span>the environment.</span></p>
			<p class="calibre5">This simple functionality allows you to define clear and straightforward configuration classes from environment variables. Pydantic settings can also automatically pick up environment modifications and, when needed, manually override settings for testing, development, <span>or production.</span></p>
			<p class="calibre5">In the following exercise, you will create a simple <strong class="source-inline">pydantic_settings</strong> setup that will allow you to read environment variables and easily override them in case the <span>necessity arises:</span></p>
			<ol class="calibre14">
				<li class="calibre15">Install Pydantic settings <span>with </span><span><strong class="source-inline">pip</strong></span><span>:</span><pre class="source-code">
pip install pydantic-settings</pre></li>				<li class="calibre15">Create a <strong class="source-inline">.env</strong> file at the same level as your <span>project files:</span><pre class="source-code">
API_URL=https://api.com/v2
SECRET_KEY=s3cretstr1n6</pre></li>				<li class="calibre15">Now you can set up a simple <strong class="source-inline">Settings</strong> configuration (the <span><strong class="source-inline">chapter3_17.py</strong></span><span> file):</span><pre class="source-code">
from pydantic import Field
from pydantic_settings import BaseSettings
class Settings(BaseSettings):
    api_url: str = Field(default="")
    secret_key: str = Field(default="")
    class Config:
        env_file = ".env"
print(Settings().model_dump())</pre></li>				<li class="calibre15">If you run this code, both the Python and the <strong class="source-inline">.env</strong> file are on the same path, so you will see that Pydantic was able to read the environment variables from the <strong class="source-inline">.</strong><span><strong class="source-inline">env</strong></span><span> file:</span><pre class="source-code">
{'api_url': 'https://api.com/v2', 'secret_key': 's3cretstr1n6'}</pre><p class="list-inset">However, if you set an environment variable, it will take precedence over the <strong class="source-inline">.</strong><span><strong class="source-inline">env</strong></span><span> file.</span></p></li>				<li class="calibre15">You can test it by adding this line before the <strong class="source-inline">Settings()</strong> call and observing the output of <span>the program:</span><pre class="source-code">
os.environ["API_URL"] = 'http://localhost:8000'</pre></li>			</ol>
			<p class="calibre5">Pydantic Settings makes managing configurations such as your Atlas and MongoDB URLs, secrets for hashing passwords, and other configurations much more structured <span>and organized.</span></p>
			<h1 id="_idParaDest-64" class="contributor"><a id="_idTextAnchor070" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Summary</h1>
			<p class="calibre5">This chapter detailed aspects of Python that are either new and still evolving, or often simply overlooked, such as type hinting, and the implications that their use can have on <span>your projects.</span></p>
			<p class="calibre5">FastAPI is based on Pydantic and type hinting. Working with these solid principles and conventions will make your code more robust, maintainable, and future-proof even when working with other frameworks. You have a solid Python types foundation and have learned the basic functionalities provided by Pydantic—validation, serialization, <span>and deserialization.</span></p>
			<p class="calibre5">You have learned how to deserialize, serialize, and validate data through Pydantic, and even add some transformations during the process, creating structures of <span>increased complexity.</span></p>
			<p class="calibre5">This chapter has equipped you to learn more web-specific aspects of FastAPI and to blend data seamlessly between MongoDB, Python data structures, <span>and JSON.</span></p>
			<p class="calibre5">The next chapter will explore FastAPI and its <span>Pythonic foundations.</span></p>
		</div>
	</div>
</div>
</body></html>