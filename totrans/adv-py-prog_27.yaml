- en: '*Chapter 24*: The Chain of Responsibility Pattern'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now cover the **Chain of Responsibility design pattern**, which should be
    used, as we will see, when we do not know the number and type of requests/events
    we would need to support. While this may seem vague, this pattern is useful among
    a wide range of use cases, such as event-based systems, purchase systems, and
    shipping systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn what the Chain of Responsibility pattern is,
    its benefits, and—as always—how to implement it in a practical Python example.
    We will discuss the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Chain of Responsibility pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Real-world examples
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use cases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code files for this chapter can be accessed through this link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter24](https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter24)'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Chain of Responsibility pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When developing an application, most of the time, we know which method should
    satisfy a particular request in advance. However, this is not always the case.
    For example, think of any broadcast computer network, such as the original Ethernet
    implementation. In broadcast computer networks, all requests are sent to all nodes
    (broadcast domains are excluded for simplicity), but only the nodes that are interested
    in a sent request process it.
  prefs: []
  type: TYPE_NORMAL
- en: 'All computers that participate in a broadcast network are connected to each
    other using a common medium such as the cable that connects all nodes. If a node
    is not interested or does not know how to handle a request, it can perform the
    following actions:'
  prefs: []
  type: TYPE_NORMAL
- en: Ignore the request and do nothing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Forward the request to the next node
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The way in which the node reacts to a request is an implementation detail. However,
    we can use the analogy of a broadcast computer network to understand what the
    Chain of Responsibility pattern is all about. The Chain of Responsibility pattern
    is used when we want to give multiple objects the chance to satisfy a single request
    or when we don't know in advance which object (from a chain of objects) should
    process a specific request.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate the principle, imagine a chain (linked list, tree, or any other
    convenient data structure) of objects and the following flow:'
  prefs: []
  type: TYPE_NORMAL
- en: We start by sending a request to the first object in the chain.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The object decides whether it should satisfy the request or not.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The object forwards the request to the next object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This procedure is repeated until we reach the end of the chain.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the application level, instead of talking about cables and network nodes,
    we can focus on objects and the flow of a request. The following diagram shows
    how the client code sends a request to all processing elements of an application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 24.1 – Client code sending a request ](img/Figure_24.1_B17499.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 24.1 – Client code sending a request
  prefs: []
  type: TYPE_NORMAL
- en: Note that the client code only knows about the first processing element, instead
    of having references to all of them, and each processing element only knows about
    its immediate next neighbor (called the **successor**), not about every other
    processing element. This is usually a one-way relationship, which in programming
    terms means a **singly linked list** in contrast to a **doubly linked list**.
    A singly linked list does not allow navigation in both ways, while a doubly linked
    list allows that. This chain organization is used for a good reason. It achieves
    decoupling between the sender (client) and the receivers (processing elements).
  prefs: []
  type: TYPE_NORMAL
- en: We will see some real-world examples of this pattern in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Real-world examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Automated teller machines** (**ATMs**) and, in general, any kind of machine
    that accepts/returns banknotes or coins (for example, a snack-vending machine)
    use the Chain of Responsibility pattern.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is always a single slot for all banknotes, as shown in the following
    diagram, courtesy of *SourceMaking* ([www.sourcemaking.com](http://www.sourcemaking.com)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 24.2 – An ATM has a single slot for all banknotes ](img/Figure_24.2_B17499.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 24.2 – An ATM has a single slot for all banknotes
  prefs: []
  type: TYPE_NORMAL
- en: When a banknote is dropped, it is routed to the appropriate receptacle. When
    it is returned, it is taken from the appropriate receptacle. We can think of the
    single slot as a shared communication medium and the different receptacles as
    processing elements. The result contains cash from one or more receptacles. For
    example, in the preceding diagram, we see what happens when we request **United
    States dollars** (**USD**) $175 from the ATM.
  prefs: []
  type: TYPE_NORMAL
- en: In software, the servlet filters of Java are pieces of code that are executed
    before a **HyperText Transfer Protocol** (**HTTP**) request arrives at a target.
    When using servlet filters, there is a chain of filters. Each filter performs
    a different action (user authentication, logging, data compression, and so forth)
    and either forwards the request to the next filter until the chain is exhausted
    or breaks the flow if there is an error—for example, the authentication failed
    three consecutive times ([j.mp/soservl](http://j.mp/soservl)).
  prefs: []
  type: TYPE_NORMAL
- en: As another software example, Apple's Cocoa and Cocoa Touch frameworks use the
    Chain of Responsibility to handle events. When a *view* receives an event that
    it doesn't know how to handle, it forwards the event to its *superview*. This
    goes on until a *view* is capable of handling the event or the *chain of views*
    is exhausted ([j.mp/chaincocoa](http://j.mp/chaincocoa)).
  prefs: []
  type: TYPE_NORMAL
- en: When is this design pattern useful? Let's discuss that in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Use cases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By using the Chain of Responsibility pattern, we provide a chance to a number
    of different objects to satisfy a specific request. This is useful when we don't
    know which object should satisfy a request in advance. An example is a purchase
    system. In purchase systems, there are many approval authorities. One approval
    authority might be able to approve orders up to a certain value—let's say $100\.
    If the order is for more than $100, the order is sent to the next approval authority
    in the chain that can approve orders up to $200, and so forth.
  prefs: []
  type: TYPE_NORMAL
- en: Another case where the Chain of Responsibility is useful is when we know that
    more than one object might need to process a single request. This is what happens
    in event-based programming. A single event, such as a left-mouse click, can be
    caught by more than one listener.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that the Chain of Responsibility pattern is not very
    useful if all the requests can be taken care of by a single processing element
    unless we really don't know which element that is. The value of this pattern is
    the decoupling that it offers. Instead of having a many-to-many relationship between
    a client and all processing elements (and the same is true regarding the relationship
    between a processing element and all other processing elements), a client only
    needs to know how to communicate with the start (head) of the chain.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram illustrates the difference between **tight** and **loose
    coupling**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 24.3 – Loose versus tight coupling ](img/Figure_24.3_B17499.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 24.3 – Loose versus tight coupling
  prefs: []
  type: TYPE_NORMAL
- en: The idea behind loosely coupled systems is to simplify maintenance and make
    it easier for us to understand how they function ([j.mp/loosecoup](http://j.mp/loosecoup)).
  prefs: []
  type: TYPE_NORMAL
- en: We will see that this is the case in the next section, where we implement an
    event-based system.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many ways to implement a Chain of Responsibility in Python, but my
    favorite implementation is the one by Vespe Savikko ([https://legacy.python.org/workshops/1997-10/proceedings/savikko.html](https://legacy.python.org/workshops/1997-10/proceedings/savikko.html)).
    Vespe's implementation uses dynamic dispatching in a Pythonic style to handle
    requests ([http://j.mp/ddispatch](http://j.mp/ddispatch)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s implement a simple event-based system using Vespe''s implementation
    as a guide. Here is a **Unified Modeling Language** (**UML**) class diagram of
    an event-based system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 24.4 – UML class diagram of an event-based system ](img/Figure_24.4_B17499.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 24.4 – UML class diagram of an event-based system
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Event` class describes an event. We''ll keep it simple, so in our case,
    an event has only `name`, as illustrated in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Widget` class is the core class of the application. The `parent` object,
    which, by convention, we assume is a `Widget` instance. Note, however, that according
    to the rules of inheritance, an instance of any of the subclasses of `Widget`
    (for example, an instance of `MsgText`) is also an instance of `Widget`. The default
    value of `parent` is `None`, as illustrated in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `handle()` method uses dynamic dispatching through `hasattr()` and `getattr()`
    to decide who is the handler of a specific request (event). If the widget that
    is asked to handle an event does not support it, there are two fallback mechanisms.
    If the widget has a parent, then the `handle()` method of the parent is executed.
    If the widget has no parent but a `handle_default()` method, `handle_default()`
    is executed, as illustrated in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: At this point, you might have realized why the `Widget` and `Event` classes
    are only associated (no aggregation or composition relationships) in the UML class
    diagram. The association is used to show that the `Widget` class knows about the
    `Event` class but does not have any strict references to it, since an event needs
    to be passed only as a parameter to `handle()`.
  prefs: []
  type: TYPE_NORMAL
- en: '`MainWindow`, `MsgText`, and `SendDialog` are all widgets with different behaviors.
    Not all these three widgets are expected to be able to handle the same events,
    and even if they can handle the same event, they might behave differently. `MainWindow`
    can only handle `close` and `default` events, as illustrated in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`SendDialog` can only handle `paint` events, as illustrated in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, `MsgText` can only handle `down` events, as illustrated in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `main()` function shows how we can create a few widgets and events and
    how the widgets react to those events. All events are sent to all the widgets.
    Note the parent relationship of each widget. The `sd` object (an instance of `SendDialog`)
    has as its parent the `mw` object (an instance of `MainWindow`). However, not
    all objects need to have a parent that is an instance of `MainWindow`. For example,
    the `msg` object (an instance of `MsgText`) has the `sd` object as a parent, as
    illustrated in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing the `python chain.py` command gives us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: There are some interesting things that we can see in the output. For instance,
    sending a `down` event to `MainWindow` ends up being handled by the default `MainWindow`
    handler. Another nice case is that although a `close` event cannot be handled
    directly by `SendDialog` and `MsgText`, all `close` events end up being handled
    properly by `MainWindow`. That's the beauty of using the *parent relationship*
    as a fallback mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to spend some more creative time on the event example, you can replace
    the dumb `print` statements and add some actual behavior to the listed events.
    Of course, you are not limited to the listed events. Just add your favorite event
    and make it do something useful!
  prefs: []
  type: TYPE_NORMAL
- en: Another exercise is to add a `MsgText` instance during runtime that has `MainWindow`
    as the parent and do the same for an event (add a new event to an existing widget).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the Chain of Responsibility design pattern. This
    pattern is useful to model requests and/or handle events when the number and type
    of handlers aren't known in advance.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, we have learned how to use this design pattern to facilitate loose
    coupling between the sender and the receiver(s). Some examples that we have seen
    where this is particularly beneficial include Java's servlet and Apple's Cocoa
    frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: That's it for the Chain of Responsibility pattern. In the next chapter, we will
    cover the Command pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The answers for the following questions can be found in the *Assessments* section
    at the end of the book.
  prefs: []
  type: TYPE_NORMAL
- en: What are the high-level benefits of the Chain of Responsibility pattern?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How is the Chain of Responsibility pattern implemented in the Python example
    of the event-based system we considered?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is an example of a situation in which the Chain of Responsibility pattern
    is not useful?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
