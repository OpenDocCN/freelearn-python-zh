- en: '*Chapter 24*: The Chain of Responsibility Pattern'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第24章*：责任链模式'
- en: We now cover the **Chain of Responsibility design pattern**, which should be
    used, as we will see, when we do not know the number and type of requests/events
    we would need to support. While this may seem vague, this pattern is useful among
    a wide range of use cases, such as event-based systems, purchase systems, and
    shipping systems.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来介绍**责任链设计模式**，当我们需要支持未知数量和类型的请求/事件时，应该使用这个模式。虽然这听起来可能有些模糊，但这种模式在广泛的应用场景中都是很有用的，例如基于事件的系统、购买系统和运输系统。
- en: 'In this chapter, we will learn what the Chain of Responsibility pattern is,
    its benefits, and—as always—how to implement it in a practical Python example.
    We will discuss the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习责任链模式（Chain of Responsibility pattern）是什么，它的好处，以及——一如既往地——如何在实际的Python示例中实现它。我们将讨论以下主题：
- en: Understanding the Chain of Responsibility pattern
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解责任链模式
- en: Real-world examples
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现实世界的例子
- en: Use cases
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用例
- en: Implementation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code files for this chapter can be accessed through this link:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以通过以下链接访问：
- en: '[https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter24](https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter24)'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter24](https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter24)'
- en: Understanding the Chain of Responsibility pattern
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解责任链模式
- en: When developing an application, most of the time, we know which method should
    satisfy a particular request in advance. However, this is not always the case.
    For example, think of any broadcast computer network, such as the original Ethernet
    implementation. In broadcast computer networks, all requests are sent to all nodes
    (broadcast domains are excluded for simplicity), but only the nodes that are interested
    in a sent request process it.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发应用程序时，大多数时候，我们事先就知道哪个方法应该满足特定的请求。然而，情况并不总是如此。例如，想想任何广播计算机网络，如原始的以太网实现。在广播计算机网络中，所有请求都发送到所有节点（为了简单起见，排除广播域），但只有对发送请求感兴趣的节点才会处理它。
- en: 'All computers that participate in a broadcast network are connected to each
    other using a common medium such as the cable that connects all nodes. If a node
    is not interested or does not know how to handle a request, it can perform the
    following actions:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 参与广播网络的计算机都通过一个共同的中介连接在一起，例如连接所有节点的电缆。如果一个节点不感兴趣或不知道如何处理请求，它可以执行以下操作：
- en: Ignore the request and do nothing
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 忽略请求并什么都不做
- en: Forward the request to the next node
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将请求转发到下一个节点
- en: The way in which the node reacts to a request is an implementation detail. However,
    we can use the analogy of a broadcast computer network to understand what the
    Chain of Responsibility pattern is all about. The Chain of Responsibility pattern
    is used when we want to give multiple objects the chance to satisfy a single request
    or when we don't know in advance which object (from a chain of objects) should
    process a specific request.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 节点对请求的反应方式是实现细节。然而，我们可以使用广播计算机网络的类比来理解责任链模式的核心。当我们要给多个对象机会满足单个请求，或者我们事先不知道哪个对象（从对象链中）应该处理特定请求时，就会使用责任链模式。
- en: 'To illustrate the principle, imagine a chain (linked list, tree, or any other
    convenient data structure) of objects and the following flow:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这个原则，想象一个对象链（链表、树或其他方便的数据结构）和以下流程：
- en: We start by sending a request to the first object in the chain.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先向链中的第一个对象发送请求。
- en: The object decides whether it should satisfy the request or not.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对象决定是否应该满足请求。
- en: The object forwards the request to the next object.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对象将请求转发到下一个对象。
- en: This procedure is repeated until we reach the end of the chain.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个过程会一直重复，直到我们到达链的末尾。
- en: 'At the application level, instead of talking about cables and network nodes,
    we can focus on objects and the flow of a request. The following diagram shows
    how the client code sends a request to all processing elements of an application:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用层面，我们不再谈论电缆和网络节点，而是可以关注对象和请求的流动。以下图表显示了客户端代码如何向应用程序的所有处理元素发送请求：
- en: '![Figure 24.1 – Client code sending a request ](img/Figure_24.1_B17499.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图24.1 – 客户端代码发送请求](img/Figure_24.1_B17499.jpg)'
- en: Figure 24.1 – Client code sending a request
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图24.1 – 客户端代码发送请求
- en: Note that the client code only knows about the first processing element, instead
    of having references to all of them, and each processing element only knows about
    its immediate next neighbor (called the **successor**), not about every other
    processing element. This is usually a one-way relationship, which in programming
    terms means a **singly linked list** in contrast to a **doubly linked list**.
    A singly linked list does not allow navigation in both ways, while a doubly linked
    list allows that. This chain organization is used for a good reason. It achieves
    decoupling between the sender (client) and the receivers (processing elements).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，客户端代码只知道第一个处理元素，而不是所有处理元素的引用，每个处理元素只知道其直接的下一位邻居（称为**后继者**），而不是其他所有处理元素。这通常是一种单向关系，在编程术语中意味着**单链表**，与**双链表**相对。单链表不允许双向导航，而双链表允许。这种链式组织有很好的理由。它实现了发送者（客户端）和接收者（处理元素）之间的解耦。
- en: We will see some real-world examples of this pattern in the next section.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中看到这个模式的一些实际例子。
- en: Real-world examples
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实际例子
- en: '**Automated teller machines** (**ATMs**) and, in general, any kind of machine
    that accepts/returns banknotes or coins (for example, a snack-vending machine)
    use the Chain of Responsibility pattern.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**自动柜员机**（**ATMs**）以及一般而言，任何接受/退还纸币或硬币的机器（例如，零食自动售货机）都使用了责任链模式。'
- en: 'There is always a single slot for all banknotes, as shown in the following
    diagram, courtesy of *SourceMaking* ([www.sourcemaking.com](http://www.sourcemaking.com)):'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如下图中所示，所有纸币都有一个单独的插槽，这是由*SourceMaking*提供的（[www.sourcemaking.com](http://www.sourcemaking.com)）：
- en: '![Figure 24.2 – An ATM has a single slot for all banknotes ](img/Figure_24.2_B17499.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图24.2 – 自动柜员机有一个用于所有纸币的单个插槽](img/Figure_24.2_B17499.jpg)'
- en: Figure 24.2 – An ATM has a single slot for all banknotes
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图24.2 – 自动柜员机有一个用于所有纸币的单个插槽
- en: When a banknote is dropped, it is routed to the appropriate receptacle. When
    it is returned, it is taken from the appropriate receptacle. We can think of the
    single slot as a shared communication medium and the different receptacles as
    processing elements. The result contains cash from one or more receptacles. For
    example, in the preceding diagram, we see what happens when we request **United
    States dollars** (**USD**) $175 from the ATM.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当纸币被投入时，它会路由到相应的容器。当它被退回时，它会从相应的容器中取出。我们可以将单个插槽视为共享通信介质，而不同的容器视为处理元素。结果包含来自一个或多个容器的现金。例如，在上面的图中，我们看到当我们从自动柜员机请求**美元**（**USD**）$175时会发生什么。
- en: In software, the servlet filters of Java are pieces of code that are executed
    before a **HyperText Transfer Protocol** (**HTTP**) request arrives at a target.
    When using servlet filters, there is a chain of filters. Each filter performs
    a different action (user authentication, logging, data compression, and so forth)
    and either forwards the request to the next filter until the chain is exhausted
    or breaks the flow if there is an error—for example, the authentication failed
    three consecutive times ([j.mp/soservl](http://j.mp/soservl)).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件中，Java的servlet过滤器是在**超文本传输协议**（**HTTP**）请求到达目标之前执行的代码片段。当使用servlet过滤器时，存在一个过滤器链。每个过滤器执行不同的操作（用户认证、日志记录、数据压缩等），要么将请求转发到下一个过滤器，直到链耗尽，要么在出现错误时（例如，认证连续三次失败）中断流程——[j.mp/soservl](http://j.mp/soservl)。
- en: As another software example, Apple's Cocoa and Cocoa Touch frameworks use the
    Chain of Responsibility to handle events. When a *view* receives an event that
    it doesn't know how to handle, it forwards the event to its *superview*. This
    goes on until a *view* is capable of handling the event or the *chain of views*
    is exhausted ([j.mp/chaincocoa](http://j.mp/chaincocoa)).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 作为另一个软件示例，苹果的Cocoa和Cocoa Touch框架使用责任链来处理事件。当一个**视图**收到它不知道如何处理的事件时，它会将事件转发给其**父视图**。这个过程会一直进行，直到有一个**视图**能够处理该事件或**视图链**耗尽（[j.mp/chaincocoa](http://j.mp/chaincocoa)）。
- en: When is this design pattern useful? Let's discuss that in the next section.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这个设计模式在何时有用？我们将在下一节中讨论这个问题。
- en: Use cases
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用例
- en: By using the Chain of Responsibility pattern, we provide a chance to a number
    of different objects to satisfy a specific request. This is useful when we don't
    know which object should satisfy a request in advance. An example is a purchase
    system. In purchase systems, there are many approval authorities. One approval
    authority might be able to approve orders up to a certain value—let's say $100\.
    If the order is for more than $100, the order is sent to the next approval authority
    in the chain that can approve orders up to $200, and so forth.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用责任链模式，我们为多个不同的对象提供了满足特定请求的机会。当我们事先不知道哪个对象应该满足请求时，这很有用。一个例子是采购系统。在采购系统中，有许多审批权限。一个审批权限可能能够批准价值达到一定数额的订单——比如说100美元。如果订单价值超过100美元，订单就会被发送到链中的下一个审批权限，该权限可以批准价值达到200美元的订单，以此类推。
- en: Another case where the Chain of Responsibility is useful is when we know that
    more than one object might need to process a single request. This is what happens
    in event-based programming. A single event, such as a left-mouse click, can be
    caught by more than one listener.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 责任链模式在另一种情况下也很有用，即当我们知道可能需要多个对象来处理单个请求时。这就是基于事件编程中发生的情况。一个单一的事件，比如左键点击，可以被多个监听器捕获。
- en: It is important to note that the Chain of Responsibility pattern is not very
    useful if all the requests can be taken care of by a single processing element
    unless we really don't know which element that is. The value of this pattern is
    the decoupling that it offers. Instead of having a many-to-many relationship between
    a client and all processing elements (and the same is true regarding the relationship
    between a processing element and all other processing elements), a client only
    needs to know how to communicate with the start (head) of the chain.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，如果所有请求都可以由单个处理元素处理，除非我们真的不知道是哪个元素，否则责任链模式并不是非常有用。这种模式的价值在于它提供的解耦。而不是在客户端和所有处理元素之间（以及处理元素和其他所有处理元素之间的关系）存在多对多的关系，客户端只需要知道如何与链的起始（头部）元素通信。
- en: 'The following diagram illustrates the difference between **tight** and **loose
    coupling**:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表说明了**紧密**耦合和**松散**耦合之间的区别：
- en: '![Figure 24.3 – Loose versus tight coupling ](img/Figure_24.3_B17499.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图24.3 – 松散耦合与紧密耦合](img/Figure_24.3_B17499.jpg)'
- en: Figure 24.3 – Loose versus tight coupling
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图24.3 – 松散耦合与紧密耦合
- en: The idea behind loosely coupled systems is to simplify maintenance and make
    it easier for us to understand how they function ([j.mp/loosecoup](http://j.mp/loosecoup)).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 松散耦合系统的理念是简化维护，并使我们更容易理解它们的运作方式（[j.mp/loosecoup](http://j.mp/loosecoup)）。
- en: We will see that this is the case in the next section, where we implement an
    event-based system.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中看到这一点，我们将实现一个基于事件的系统。
- en: Implementation
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现
- en: There are many ways to implement a Chain of Responsibility in Python, but my
    favorite implementation is the one by Vespe Savikko ([https://legacy.python.org/workshops/1997-10/proceedings/savikko.html](https://legacy.python.org/workshops/1997-10/proceedings/savikko.html)).
    Vespe's implementation uses dynamic dispatching in a Pythonic style to handle
    requests ([http://j.mp/ddispatch](http://j.mp/ddispatch)).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中实现责任链模式有许多方法，但我最喜欢的实现是Vespe Savikko的（[https://legacy.python.org/workshops/1997-10/proceedings/savikko.html](https://legacy.python.org/workshops/1997-10/proceedings/savikko.html)）。Vespe的实现使用Python风格的动态分派来处理请求（[http://j.mp/ddispatch](http://j.mp/ddispatch)）。
- en: 'Let''s implement a simple event-based system using Vespe''s implementation
    as a guide. Here is a **Unified Modeling Language** (**UML**) class diagram of
    an event-based system:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以Vespe的实现为指导，实现一个简单的基于事件的系统。以下是基于事件的系统的**统一建模语言**（**UML**）类图：
- en: '![Figure 24.4 – UML class diagram of an event-based system ](img/Figure_24.4_B17499.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图24.4 – 基于事件的系统的UML类图](img/Figure_24.4_B17499.jpg)'
- en: Figure 24.4 – UML class diagram of an event-based system
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图24.4 – 基于事件的系统的UML类图
- en: 'The `Event` class describes an event. We''ll keep it simple, so in our case,
    an event has only `name`, as illustrated in the following code snippet:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`Event`类描述了一个事件。我们将保持简单，所以在这种情况下，一个事件只有一个`name`，如下面的代码片段所示：'
- en: '[PRE0]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `Widget` class is the core class of the application. The `parent` object,
    which, by convention, we assume is a `Widget` instance. Note, however, that according
    to the rules of inheritance, an instance of any of the subclasses of `Widget`
    (for example, an instance of `MsgText`) is also an instance of `Widget`. The default
    value of `parent` is `None`, as illustrated in the following code snippet:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`Widget` 类是应用程序的核心类。`parent` 对象，按照惯例，我们假设它是一个 `Widget` 实例。请注意，然而，根据继承规则，`Widget`
    的任何子类的实例（例如，`MsgText` 的实例）也是 `Widget` 的实例。`parent` 的默认值是 `None`，如下面的代码片段所示：'
- en: '[PRE1]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `handle()` method uses dynamic dispatching through `hasattr()` and `getattr()`
    to decide who is the handler of a specific request (event). If the widget that
    is asked to handle an event does not support it, there are two fallback mechanisms.
    If the widget has a parent, then the `handle()` method of the parent is executed.
    If the widget has no parent but a `handle_default()` method, `handle_default()`
    is executed, as illustrated in the following code snippet:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`handle()` 方法通过 `hasattr()` 和 `getattr()` 使用动态分派来决定谁是一个特定请求（事件）的处理者。如果请求处理事件的控件不支持它，有两种后备机制。如果控件有父控件，那么执行父控件的
    `handle()` 方法。如果控件没有父控件但有 `handle_default()` 方法，则执行 `handle_default()`，如下面的代码片段所示：'
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: At this point, you might have realized why the `Widget` and `Event` classes
    are only associated (no aggregation or composition relationships) in the UML class
    diagram. The association is used to show that the `Widget` class knows about the
    `Event` class but does not have any strict references to it, since an event needs
    to be passed only as a parameter to `handle()`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 到这个时候，你可能已经意识到为什么在 UML 类图中 `Widget` 和 `Event` 类只是关联（没有聚合或组合关系）。这种关联用于表示 `Widget`
    类知道 `Event` 类，但没有对其有严格的引用，因为事件只需要作为参数传递给 `handle()`。
- en: '`MainWindow`, `MsgText`, and `SendDialog` are all widgets with different behaviors.
    Not all these three widgets are expected to be able to handle the same events,
    and even if they can handle the same event, they might behave differently. `MainWindow`
    can only handle `close` and `default` events, as illustrated in the following
    code snippet:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainWindow`、`MsgText` 和 `SendDialog` 都是具有不同行为的控件。并不是所有这三个控件都期望能够处理相同的事件，即使它们可以处理相同的事件，它们的行为也可能不同。`MainWindow`
    只能处理 `close` 和 `default` 事件，如下面的代码片段所示：'
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`SendDialog` can only handle `paint` events, as illustrated in the following
    code snippet:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`SendDialog` 只能处理 `paint` 事件，如下面的代码片段所示：'
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Finally, `MsgText` can only handle `down` events, as illustrated in the following
    code snippet:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`MsgText` 只能处理 `down` 事件，如下面的代码片段所示：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `main()` function shows how we can create a few widgets and events and
    how the widgets react to those events. All events are sent to all the widgets.
    Note the parent relationship of each widget. The `sd` object (an instance of `SendDialog`)
    has as its parent the `mw` object (an instance of `MainWindow`). However, not
    all objects need to have a parent that is an instance of `MainWindow`. For example,
    the `msg` object (an instance of `MsgText`) has the `sd` object as a parent, as
    illustrated in the following code snippet:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()` 函数展示了我们如何创建一些控件和事件以及控件如何对这些事件做出反应。所有事件都发送到所有控件。注意每个控件的父母关系。`sd` 对象（`SendDialog`
    的实例）的父母是 `mw` 对象（`MainWindow` 的实例）。然而，并不是所有对象都需要有一个 `MainWindow` 实例作为其父控件。例如，`msg`
    对象（`MsgText` 的实例）的父母是 `sd` 对象，如下面的代码片段所示：'
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Executing the `python chain.py` command gives us the following output:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 `python chain.py` 命令会给出以下输出：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: There are some interesting things that we can see in the output. For instance,
    sending a `down` event to `MainWindow` ends up being handled by the default `MainWindow`
    handler. Another nice case is that although a `close` event cannot be handled
    directly by `SendDialog` and `MsgText`, all `close` events end up being handled
    properly by `MainWindow`. That's the beauty of using the *parent relationship*
    as a fallback mechanism.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在输出中看到一些有趣的事情。例如，向 `MainWindow` 发送 `down` 事件最终会被默认的 `MainWindow` 处理器处理。另一个很好的例子是，尽管
    `SendDialog` 和 `MsgText` 无法直接处理 `close` 事件，但所有 `close` 事件最终都会被 `MainWindow` 正确处理。这就是使用
    *父关系* 作为后备机制的美妙之处。
- en: If you want to spend some more creative time on the event example, you can replace
    the dumb `print` statements and add some actual behavior to the listed events.
    Of course, you are not limited to the listed events. Just add your favorite event
    and make it do something useful!
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在事件示例上花费更多富有创意的时间，你可以替换掉愚蠢的`print`语句，并为列出的事件添加一些实际的行为。当然，你不仅限于列出的事件。只需添加你喜欢的任何事件，并让它做一些有用的事情！
- en: Another exercise is to add a `MsgText` instance during runtime that has `MainWindow`
    as the parent and do the same for an event (add a new event to an existing widget).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个练习是在运行时添加一个具有`MainWindow`作为父级的`MsgText`实例，并为事件做同样的事情（向现有小部件添加一个新事件）。
- en: Summary
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered the Chain of Responsibility design pattern. This
    pattern is useful to model requests and/or handle events when the number and type
    of handlers aren't known in advance.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了链式责任设计模式。当处理者和/或事件的数量和类型事先未知时，此模式有助于对请求进行建模和处理事件。
- en: Overall, we have learned how to use this design pattern to facilitate loose
    coupling between the sender and the receiver(s). Some examples that we have seen
    where this is particularly beneficial include Java's servlet and Apple's Cocoa
    frameworks.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，我们已经学会了如何使用这种设计模式来促进发送者和接收者之间的松耦合。我们看到的某些特别有益的例子包括Java的servlet和Apple的Cocoa框架。
- en: That's it for the Chain of Responsibility pattern. In the next chapter, we will
    cover the Command pattern.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 链式责任模式的内容到此结束。在下一章中，我们将介绍命令模式。
- en: Questions
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: The answers for the following questions can be found in the *Assessments* section
    at the end of the book.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 以下问题的答案可以在本书末尾的*评估*部分找到。
- en: What are the high-level benefits of the Chain of Responsibility pattern?
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 链式责任模式的最高级好处是什么？
- en: How is the Chain of Responsibility pattern implemented in the Python example
    of the event-based system we considered?
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们考虑的事件驱动系统的Python示例中，链式责任模式是如何实现的？
- en: What is an example of a situation in which the Chain of Responsibility pattern
    is not useful?
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在什么情况下，链式责任模式不是很有用？
