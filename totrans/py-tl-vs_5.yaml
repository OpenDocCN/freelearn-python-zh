- en: Chapter 5. Advanced Django in PTVS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we look at how a Django development environment in Visual Studio with PTVS
    is set up, we can start analyzing some powerful libraries for Django and how to
    use them in Visual Studio. Over the years, lots of developers have created powerful
    libraries and tools for Django that speed up various aspects of the development
    cycle. We are going to take a closer look at some of them here to see how they
    integrate in Visual Studio and PTVS.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will analyze two libraries that are useful for a Django
    developer in two different aspects: automatizing tasks using the Fabric library,
    and managing model migrations on Django with South.'
  prefs: []
  type: TYPE_NORMAL
- en: Library management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already learned how to install new packages in PTVS using the GUI tools
    that it provides. Now, we will learn more about the criteria for choosing one
    package index over another; in other words, when to choose `easy_install` over
    `pip`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Generally speaking, using `pip` is much better than using `easy_install`, and
    there are major reasons for this. As Ian Bicking, the creator of `pip`, wrote
    in his own introduction to `pip`, the advantages are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: All packages are downloaded before installation. As a result, partially completed
    installation doesn't occur.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Care is taken when presenting useful output on the console.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The reasons for actions are being tracked. For instance, if a package is being
    installed, `pip` keeps track of why that package was required.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Error messages should be useful.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code is relatively concise and cohesive, making it easier to use programmatically.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packages don't have to be installed as egg archives; they can be installed flat
    (while keeping the egg metadata).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Native support is available for other version control systems (`Git`, `Mercurial`,
    and `Bazaar`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uninstallation of packages is easy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is simple to define, has fixed sets of requirements, and reliably reproduces
    a set of packages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It may seem that there are no reasons to choose `easy_install` over `pip`. However,
    this is where careful consideration is needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a caveat that makes the choice really hard for Windows environments:
    some libraries or dependencies are written in Python C, which is a way for Python
    to call libraries written in C/C++. To compile these libraries on your Windows
    machine, you have to install the exact same version of the original compiler that
    has been used to compile to the original interpreter. For example, you will need
    the C++ compiler of Visual Studio 2008 if you use Python 2.7 or Visual Studio
    2010 for Python 3.'
  prefs: []
  type: TYPE_NORMAL
- en: This is due to a long tradition where Python extension modules must be built
    with the same compiler version (more specifically, a CRT version) as Python itself,
    which is mentioned at [https://mail.python.org/pipermail/python-list/2010-April/573606.html](https://mail.python.org/pipermail/python-list/2010-April/573606.html).
  prefs: []
  type: TYPE_NORMAL
- en: Using the `easy_install` package installer, the precompiled packages are downloaded
    and installed into the system's `site-packages` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A rule of thumb: if the library you are trying to install on your Windows machine
    has Python C extensions in it, it''s far better to choose `easy_install`. For
    all other cases, `pip` is way better.'
  prefs: []
  type: TYPE_NORMAL
- en: If you don't know what kind of library you are importing, you should go with
    `pip`. If it encounters a problem during the compilation process of the installation,
    you can uninstall the library and reinstall it using `easy_install`.
  prefs: []
  type: TYPE_NORMAL
- en: Generally, most libraries that have low-level capabilities (for example, cryptography,
    graphics, and mathematical functions) and interaction with other software (for
    example, drivers) use Python C extensions.
  prefs: []
  type: TYPE_NORMAL
- en: The Fabric library – the deployment and development task manager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fabric is a Python library and a command-line tool that allows execution in
    application deployment and administration tasks. Essentially, Fabric is a tool
    that allows the developer to execute arbitrary Python functions via the command
    line and also a set of functions in order to execute shell commands on remote
    servers via SSH. Combining these two things together offers developers a powerful
    way to administrate the application workflow without having to remember the series
    of commands that need to be executed on the command line.
  prefs: []
  type: TYPE_NORMAL
- en: The library documentation can be found at [http://fabric.readthedocs.org/](http://fabric.readthedocs.org/).
  prefs: []
  type: TYPE_NORMAL
- en: Installing the library in PTVS is straightforward. Like all other libraries,
    to insert this library into a Django project, right-click on the **Python 2.7**
    node in **Python Environments** of the **Solution Explorer** window. Then, select
    the **Install Python Package** entry.
  prefs: []
  type: TYPE_NORMAL
- en: '![The Fabric library – the deployment and development task manager](img/8687OS_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Python environment contextual menu
  prefs: []
  type: TYPE_NORMAL
- en: 'Clicking on it brings up the **Install Python Package** modal window as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Fabric library – the deployment and development task manager](img/8687OS_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It's important to use `easy_install` to download from the Python package index.
    This will bring the precompiled versions of the library into the system instead
    of the plain Python C libraries that have to be compiled on the system.
  prefs: []
  type: TYPE_NORMAL
- en: Once the package is installed in the system, you can start creating tasks that
    can be executed outside your application from the command line. First, create
    a configuration file, `fabfile.py`, for Fabric. This file contains the tasks that
    Fabric will execute.
  prefs: []
  type: TYPE_NORMAL
- en: '![The Fabric library – the deployment and development task manager](img/8687OS_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The previous screenshot shows a really simple task: it prints out the string
    `hello world` once it''s executed. You can execute it from the command prompt
    by using the Fabric command `fab`, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Fabric library – the deployment and development task manager](img/8687OS_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now that you know that the system is working fine, you can move on to the juicy
    part where you can make some tasks that interact with a remote server through
    `ssh`. Create a task that connects to a remote machine and find out the type of
    OS that runs on it.
  prefs: []
  type: TYPE_NORMAL
- en: '![The Fabric library – the deployment and development task manager](img/8687OS_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The env object provides a way to add credentials to Fabric in a programmatic
    way
  prefs: []
  type: TYPE_NORMAL
- en: We have defined a Python function, `host_type`, that runs a POSIX command, `uname
    –s`, on the remote. We also set up a couple of variables to tell Fabric which
    is the remote machine we are connecting to, i.e. `env.hosts`, and the password
    that has to be used to access that machine, i.e. `env.password`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's never a good idea to put plain passwords into the source code, as is shown
    in the preceding screenshot example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can execute the `host_type` task in the command line as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Fabric library – the deployment and development task manager](img/8687OS_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Fabric library connects to the remote machine with the information provided
    and executes the command on the server. Then, it brings back the result of the
    command itself in the output part of the response.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also create tasks that accept parameters from the command line. Create
    a task that echoes a message on the remote machine, starting with a parameter
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Fabric library – the deployment and development task manager](img/8687OS_05_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following are two examples of how the task can be executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Fabric library – the deployment and development task manager](img/8687OS_05_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can also create a helper function that executes an arbitrary command on
    the remote machine as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We are also able to upload a file into the remote server by using `put`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Fabric library – the deployment and development task manager](img/8687OS_05_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The first argument of `put` is the local file you want to upload and the second
    one is the destination folder''s filename. Let''s see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Fabric library – the deployment and development task manager](img/8687OS_05_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Deploying process with Fabric
  prefs: []
  type: TYPE_NORMAL
- en: The possibilities of using Fabric are really endless, since the tasks can be
    written in plain Python language. This provides the opportunity to automate many
    operations and focus more on the development instead of focusing on how to deploy
    your code to servers to maintain them.
  prefs: []
  type: TYPE_NORMAL
- en: South – the database deployment library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Developed by the Python community, South is a Django library that brings schema
    migration to Django applications. The South library's main objective is to provide
    a simple, stable, and database-independent migration layer to prevent all the
    hassles of schema changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The key features of South are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Automatic migration creation**: South can detect what''s changed in your
    application model by analyzing your `model.py` files and automatically creating
    the migration code—basically the SQL commands for the database you are using—that
    matches the changes in the models.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Database independence**: South is database agnostic, supporting different
    database backends. Currently, South supports PostgreSQL, MySQL, SQLite, Microsoft
    SQL Server, Oracle, and Firebird (beta support).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**App-savvy**: South knows and works with the concept of Django applications,
    allowing developers to use migrations on only some of the applications and not
    on the whole project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**VCS-proof**: South will notice when someone else commits migrations to the
    same application and can check if there are conflicts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why use South with Django
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the most interesting parts of Django is its **Object-relational mapping**
    (**ORM**), which creates a consistent abstraction of the database structure. This
    is a very powerful tool that allows programmers to focus on the Python code. Django
    takes good care of the database structure management only for new models (for
    example, when creating them). It doesn't have an out-of-the-box solution to manage
    updates in the models that can be applied to existing database schemas.
  prefs: []
  type: TYPE_NORMAL
- en: It's usually a painful operation to change the model during the application
    lifecycle. Technically, when changing the schema of the model or when migrating
    the schema, whether you are modifying a field or adding another one, the database
    structure needs to be recreated. This means that all the data of that model is
    lost, or a manual migration needs to be done to move the data from the old version
    of the tables to the new one on the database. This is especially time consuming
    if you have to align that database from a development server environment to a
    production server environment.
  prefs: []
  type: TYPE_NORMAL
- en: Installing South
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s see how to bring South into PTVS. Like other Python libraries, we can
    install it from the **Solution Explorer** window by right-clicking on the environment
    of your choice (Python 2.7) and selecting **Install Python Package** to bring
    up the following installation dialog box:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Installing South](img/8687OS_05_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As stated in the South documentation, you have to use the `easy_install` **Python
    Package Index**; be sure to select it.
  prefs: []
  type: TYPE_NORMAL
- en: Once the package is installed, it's important to make sure that it's activated
    in the settings file. To do so, add `south` at the end of the code for `Installed_Apps`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Installing South](img/8687OS_05_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Be sure that the "south" library is the last in the "Installed_Apps" section
    in Settings.py
  prefs: []
  type: TYPE_NORMAL
- en: South needs to be the last package of the list due to the fact that when Django
    executes the library, all the models of the Django project are already created
    and are discoverable by South.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test if everything is working, navigate to the Django shell and try to import
    the library. Ordinary Python developers will go to the command line and run the
    `manage.py` shell, but in PTVS, there''s a panel for this. To open it, quickly
    right-click on the **Django** project entry in the **Solution Explorer** window
    and select the **Open Django** **Shell** option in **Django**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Installing South](img/8687OS_05_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This opens a new **Django Management Console** panel, which is basically a
    REPL but with Django integration. From here, it''s possible to see if the South
    library is working correctly by trying to import the library:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Installing South](img/8687OS_05_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: IntelliSense is active in the Django shell, so if you see **south** appear,
    then everything is working fine.
  prefs: []
  type: TYPE_NORMAL
- en: 'To finish the initialization process, run `sync_db` for South to create the
    migration-tracking tables. This can also be done from the Django contextual menu
    as seen earlier: just select the **Django Sync DB** command in the **Django**
    menu.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Installing South](img/8687OS_05_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As shown in the preceding screenshot, this starts the synchronization process
    of the current models in your application on South.
  prefs: []
  type: TYPE_NORMAL
- en: Schema migration with South
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have `south` installed and working in our solution, let''s try
    to create something to test the migration. Create a new application in your project
    and call it `south2ptvs` by using the **Django app** command in the **Add** menu,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Schema migration with South](img/8687OS_05_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Don''t forget to register the new application in the `settings.py` file, and
    make sure that `south` remains as the last entry of the `Installed_Apps` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Schema migration with South](img/8687OS_05_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, open the `models.py` file of the newly created application in which we
    are going to define our testing model:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Schema migration with South](img/8687OS_05_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Instead of using the standard Django `sync_db` command to create the schema
    of the model in the database, let's set up a migration for the model `Knight`.
    This operation will be the entry point for the entire migration history of the
    model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the command line and execute the initialization migration by executing
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This will execute South''s `schemamigration` command on the `south2pvts` application
    for the initialization process. Here is what is going to happen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Schema migration with South](img/8687OS_05_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We have successfully created the migration file but haven't applied it to `db`.
    Since **South** works on one application at a time, the migration file in which
    the information of the migration is stored is created inside the `south2ptvs`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: '![Schema migration with South](img/8687OS_05_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The content of the migrations folder in the Django app
  prefs: []
  type: TYPE_NORMAL
- en: The migration files are plain files written in Python. They can be edited, but
    you should do it with caution and only do so when necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only thing left to do is to apply the migration to the database by calling
    the South library''s `migrate` command on the app with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '![Schema migration with South](img/8687OS_05_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Execution of South's migration command
  prefs: []
  type: TYPE_NORMAL
- en: This will finalize the migration; now our model is ready to be modified. Future
    updates to the model can be easily applied to the database by South using migrations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the model by adding a new field as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Schema migration with South](img/8687OS_05_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So, now we have to create a new migration file and then apply it to the database.
    To create the migration file, use the `schemamigration` command again as shown
    in the following command. However, instead of the `–-initial` parameter, use `–-auto`,
    since a migration is already defined in the model.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '![Schema migration with South](img/8687OS_05_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To obtain the result of the migration file creation state to apply the migration
    to `db`, just run the following `migrate` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![Schema migration with South](img/8687OS_05_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If we register the model in the admin interface, we can go to the admin section
    of our website and see if the new field appears in the model:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Schema migration with South](img/8687OS_05_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Since the migrations are stored on the files, you can apply the changes on the
    remote server by just copying the migration files to the server and then applying
    the migration on the remote system (maybe with Fabric).
  prefs: []
  type: TYPE_NORMAL
- en: For more details and insights into this powerful tool, visit the official documentation
    website for South at [http://south.readthedocs.org/](http://south.readthedocs.org/).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we took a more in-depth look into how to deal with third-party
    Python libraries in PTVS, the main differences between the `pip` and `easy_install`
    package indexes, and how they deal with precompiled libraries written with Python
    C extensions.
  prefs: []
  type: TYPE_NORMAL
- en: We also looked into two popular and powerful Django open source libraries, Fabric
    and South, which add remote task management and schema migrations to your Django
    projects.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will introduce IPython and its graphic power in Visual
    Studio in order to cover the topic of IronPython and its integration with the
    .NET framework.
  prefs: []
  type: TYPE_NORMAL
