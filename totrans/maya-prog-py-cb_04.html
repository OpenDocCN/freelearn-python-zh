<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Giving Things a Coat of Paint – UVs and Materials</h1></div></div></div><p>In this chapter, we will be looking at topics related to the UV layout and shader creation:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Querying UV data</li><li class="listitem" style="list-style-type: disc">Laying out UVs with Python</li><li class="listitem" style="list-style-type: disc">Creating shading networks with code</li><li class="listitem" style="list-style-type: disc">Applying shaders to objects</li><li class="listitem" style="list-style-type: disc">Using shading nodes for non-rendering tasks</li></ul></div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec34"/>Introduction</h1></div></div></div><p>In the previous chapter, we looked at how to manipulate geometry with script. However, for most projects, creating the models is only the first step. Unless you want everything to look like boring gray plastic, you'll need to layout UVs, then create and apply shading networks.</p><p>In this chapter, we will be looking at how to do just that.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec35"/>Querying UV data</h1></div></div></div><p>In this example, we<a id="id159" class="indexterm"/> will be looking at how to get information about UVs on a polygonal object. We will look at examining how many UV sets the object contains, getting the UVs for a given part of the object, and grabbing the position of a given UV point.</p><p>We will also look at how to convert one kind of selection to another and use that to determine if a given edge can be split or not.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec86"/>Getting ready</h2></div></div></div><p>Make sure <a id="id160" class="indexterm"/>that you have a scene that contains at least one polygonal object that has UVs—either an object that you have unwrapped or any of the built-in primitive shapes, which have UVs by default.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec87"/>How to do it...</h2></div></div></div><p>Create a new file, name it <code class="literal">uvInfo.py</code> (or similar), and add the following code:</p><div><pre class="programlisting">import maya.cmds as cmds

def uvInfo():

    sel = cmds.ls(selection=True)
    obj = sel[0]

    uvs = cmds.polyEvaluate(obj, uvComponent=True)
    uvPos = cmds.polyEditUV(obj + '.map[0]', query=True)
        isFirstEdgeSplit = isSplitEdge(obj, 0)
    
    print('Num UVs: ' + str(uvs))
    print("Position of first UV: ", uvPos)
     print("First edge is split: ", isFirstEdgeSplit))

    cmds.select(obj, replace=True)

def isSplitEdge(obj, index):

    result = cmds.polyListComponentConversion(obj + '.e[' + str(index) + ']', fromEdge=True, toUV=True)
    cmds.select(result, replace=True)
    vertNum = cmds.polyEvaluate(vertexComponent=True)

    result = cmds.polyListComponentConversion(obj + '.e[' + str(index) + ']', fromEdge=True, toVertex=True)
    cmds.select(result, replace=True)
    uvNum = cmds.polyEvaluate(uvComponent=True)

    if (uvNum == vertNum):
        return False

    return True

uvInfo()</pre></div><p>If you run the preceding script with a polygonal object selected, you will get some information about the object's UVs, specifically:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">How many UVs the object has.</li><li class="listitem" style="list-style-type: disc">The location (in UV space) of the first UV point</li><li class="listitem" style="list-style-type: disc">Whether or not the first edge lies on the border between two separate UV shells.</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec88"/>How it works...</h2></div></div></div><p>We start <a id="id161" class="indexterm"/>by grabbing the currently selected object and storing it into our <code class="literal">obj</code> variable. Once we have done this, we use the <code class="literal">polyEvaluate</code> command to determine the total number of UVs the object has. This is similar to what we did in the previous chapter to find the number of geometric components, but this time around, we use the <code class="literal">uvComponent</code>/<code class="literal">uvc</code> flag.</p><div><pre class="programlisting">uvs = cmds.polyEvaluate(obj, uvComponent=True)</pre></div><p>Next up, we will find the specific position of the first UV point. UVs can be accessed in much the same way other polygonal components, but using the "map" list instead of the "f" (faces), "e" (edges), or "vtx" (vertices). Therefore, if we want to refer to the first UV of an object named <code class="literal">myObject</code>, we would use the following:</p><div><pre class="programlisting">myObject.map[0]</pre></div><p>Here, 0 indicates the first entry in the list and therefore the first UV of the object.</p><p>To actually find the specific U and V coordinates of a given UV, we can use the <code class="literal">polyEditUV</code> command in a query mode, as in the following:</p><div><pre class="programlisting">uvPos = cmds.polyEditUV(obj + '.map[0]', query=True)</pre></div><p>Next up is determining whether a given edge is internal to a UV shell or if it is on the border between two different shells. To do this, we create a function that accepts the name of an object and the index of an edge to check:</p><div><pre class="programlisting">isFirstEdgeSplit = isSplitEdge(obj, 0)</pre></div><p>The key thing that we are doing is to see how many vertices and how many UVs correspond to the given edge. If the number of vertices is not equal to the number of UVs, then that edge must be straddling the border of two different UV shells.</p><p>To determine how many vertices/UVs correspond to a given edge, we'll convert the edge to the desired component type using the <code class="literal">polyListComponentConversion</code> command. For that to work properly, we will need to specify both what we are converting from (in this case, edges), and what we're converting to (either vertices or UVs). The way that we do that is a bit odd; instead of specifying the types of each, we have to set two Boolean flags to true, one for the source type and one for the destination.</p><p>For example, if we were to convert the first edge of an object named <code class="literal">myObject</code> to vertices, we would need to do the following:</p><div><pre class="programlisting">cmds.polyListComponentConversion('myObject.e[0]', fromEdge=True, toVertex=True)</pre></div><p>Adding in the <a id="id162" class="indexterm"/>proper variables to set the name of the object and the index of the edge gives us:</p><div><pre class="programlisting">result = cmds.polyListComponentConversion(obj + '.e[' + str(index) + ']', fromEdge=True, toVertex=True)</pre></div><p>Note that we store the output of the command to a variable named "result". This is important because getting an accurate count of the number of points requires that we first select the components we want to count. This is easily done in the following way:</p><div><pre class="programlisting">cmds.select(result, replace=True)</pre></div><p>Once we've done this, we can use the <code class="literal">polyEvaluate</code> command with the proper flag to give us the number of <em>currently selected</em> components. For vertices and UVs, we will want to use <code class="literal">vertexComponent</code> and <code class="literal">uvComponent</code>, respectively. In both cases, we store the result to another variable, as follows:</p><div><pre class="programlisting">vertNum = cmds.polyEvaluate(vertexComponent=True)</pre></div><p>At this point, we have the number of vertices that correspond to the given edge. We then do the same operation (but with slightly different flags) to determine the number of UVs:</p><div><pre class="programlisting">result = cmds.polyListComponentConversion(obj + '.e[' + str(index) + ']', fromEdge=True, toUV=True)
cmds.select(result, replace=True)
uvNum = cmds.polyEvaluate(uvComponent=True)</pre></div><p>Finally, we compare the number of UVs to the number of vertices. If they are not the same, then the edge in question must exist on more than one UV shell and, as such, represents a border:</p><div><pre class="programlisting">if (uvNum == vertNum):
        return False

    return True</pre></div><p>Back in our main function, we output the results of our various queries with a few print statements:</p><div><pre class="programlisting">    print('Num UVs: ' + str(uvs))
    print("Position of first UV: ", uvPos)
    print("First edge is split: ", isFirstEdgeSplit)</pre></div><p>Finally, we will be sure to select the original object once again because we selected subcomponents during the <code class="literal">isSplitEdge</code> function:</p><div><pre class="programlisting">cmds.select(obj, replace=True)</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec36"/>Laying out UVs with Python</h1></div></div></div><p>In this example, we <a id="id163" class="indexterm"/>will look at how to actually lay out UVs using Python. We will be applying planar, cylindrical, and spherical projections, each to a different subset of the faces of the selected object.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec89"/>Getting ready</h2></div></div></div><p>Make sure that you have a scene containing a polygonal object. We will be applying three different mappings to different parts of the object (selected by dividing the total number of faces by three), so it is best to have an object with at least a few dozen faces. If you do not have a model handy, make a polygonal sphere of at least 10 or so divisions along both height and axis.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec90"/>How to do it...</h2></div></div></div><p>Create a new script and add the following code:</p><div><pre class="programlisting">import maya.cmds as cmds

def layoutUVs():

    selected = cmds.ls(selection=True)
    obj = selected[0]

    totalFaces = cmds.polyEvaluate(obj, face=True)

    oneThird = totalFaces/3

    startFace = 0
    endFace = oneThird - 1
    cmds.polyProjection(obj + '.f[' + str(startFace) + ':' + str(endFace) + ']', type="planar")

    startFace = oneThird
    endFace = (oneThird * 2) - 1
    cmds.polyProjection(obj + '.f[' + str(startFace) + ':' + str(endFace) + ']', type="cylindrical")

    startFace = (oneThird * 2)
    endFace = totalFaces - 1
    cmds.polyProjection(obj + '.f[' + str(startFace) + ':' + str(endFace) + ']', type="spherical")

layoutUVs()</pre></div><p>Run this script with a polygonal object selected and then switch to the UV Texture Editor panel to see the results.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec91"/>How it works...</h2></div></div></div><p>The main thing <a id="id164" class="indexterm"/>that we are doing here is to apply a new UV layout to a subset of the object's faces. This is a somewhat artificial example because we are selecting faces by just splitting the total number into thirds.</p><p>First off, we grab the currently selected object and determine the total number of faces it has using <code class="literal">polyEvaluate</code>:</p><div><pre class="programlisting">selected = cmds.ls(selection=True)
obj = selected[0]
totalFaces = cmds.polyEvaluate(obj, face=True)</pre></div><p>Then, we determine what one-third of that number is. Note that Python will default to integer division because both <code class="literal">totalFaces</code> and 3 are whole integer values. That happens to be exactly what we need for this application, but can easily lead to errors if you are not expecting it:</p><div><pre class="programlisting">oneThird = totalFaces/3</pre></div><p>If you ever want to ensure that you get a proper decimal value as a result, just be sure to divide by a floating-point value, as in:</p><div><pre class="programlisting">oneThirdAsDecimal = totalFaces/3.0</pre></div><p>We also create a couple of helper variables to hold the start and end indices for each of the three sets of faces:</p><div><pre class="programlisting">startFace = 0
endFace = oneThird - 1</pre></div><p>There is nothing particularly hard about what we are doing here though some care is needed to ensure that we include the entire range of faces. The values that we use are as follows:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom"> </th><th style="text-align: left" valign="bottom">
<p>Start index</p>
</th><th style="text-align: left" valign="bottom">
<p>End index</p>
</th><th style="text-align: left" valign="bottom">
<p>Example indices (based on a 100-face object)</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>1st (planar) mapping</p>
</td><td style="text-align: left" valign="top">
<p>0</p>
</td><td style="text-align: left" valign="top">
<p>oneThird - 1</p>
</td><td style="text-align: left" valign="top">
<p>0-32</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>2nd (cylindrical) mapping</p>
</td><td style="text-align: left" valign="top">
<p>oneThird</p>
</td><td style="text-align: left" valign="top">
<p>(oneThird * 2) - 1</p>
</td><td style="text-align: left" valign="top">
<p>33-65</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>3rd (spherical) mapping</p>
</td><td style="text-align: left" valign="top">
<p>oneThird * 2</p>
</td><td style="text-align: left" valign="top">
<p>totalFaces - 1</p>
</td><td style="text-align: left" valign="top">
<p>66-99</p>
</td></tr></tbody></table></div><p>Now we are ready for the meat of the script—actually, applying mappings. All three mapping types (planar, cylindrical, and spherical) are applied using the same command, <code class="literal">polyProjection</code>.</p><div><div><h3 class="title"><a id="tip02"/>Tip</h3><p>A brief aside on UV mapping—it might seem strange that the three types of mapping are planar, cylindrical, and spherical; why those particular shapes and no others? The reason for this is that if you think of the surface of the model as a two-dimensional skin, then any given part of the model can be classified as belonging to one of only three groups:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The region doesn't have any significant curvature.</li><li class="listitem" style="list-style-type: disc">The region has significant curvature in a single direction (horizontal or vertical).</li><li class="listitem" style="list-style-type: disc">The region has significant curvature in both directions.</li></ul></div><p>That maps neatly onto the three options of planar (no curve), cylindrical (single-direction curve), and spherical (curvature in both directions). While the part you are trying to map may be very different from a perfect plane, cylinder, or sphere, start by asking yourself how many directions it curves in and select your mapping accordingly.</p></div></div><p>There are <a id="id165" class="indexterm"/>two things we need to supply to the <code class="literal">polyProjection</code> command for it to work—the specific faces that should receive the mapping and the type of mapping to apply. To specify the range of faces, we will want to index into the faces or "f" array of the object. We can specify more than one face at a time using two indices with a colon in between. For example, if our object was named <code class="literal">mySphere</code>, and we wanted to refer to the first six faces, we could do that with:</p><div><pre class="programlisting">mySphere.f[0:5]</pre></div><p>In this case, we'll want to use the name of the selected object, and the <code class="literal">startFace</code> and <code class="literal">endFace</code> variables for the indices. Doing this gives us the following:</p><div><pre class="programlisting">obj + '.f[' + str(startFace) + ':' + str(endFace) + ']'</pre></div><p>Now that we have a way to specify the range of faces, we can apply the mappings, using the <code class="literal">type</code> flag to specify which kind of mapping to apply:</p><div><pre class="programlisting">cmds.polyProjection(obj + '.f[' + str(startFace) + ':' + str(endFace) + ']', type="planar")</pre></div><p>From here, we just repeat the process with different values for <code class="literal">startFace</code> and <code class="literal">endFace</code>, and different options for the type flag.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec92"/>There's more...</h2></div></div></div><p>If you want to apply a mapping to the entire object, you might think that you just have the name of the object and leave out the face indices. This doesn't work, but there is an easy way to tell Maya that you want to refer to all of the faces. To do this, just leave out both indices, but keep the colon, as in:</p><div><pre class="programlisting">myObject.f[:]</pre></div><p>If the starter index is missing, Maya will substitute 0, and if the ending index is missing, Maya will substitute the maximum index. Leaving <em>both</em> out will result in the mapping being applied to the entire object.</p><p>So far, we've <a id="id166" class="indexterm"/>only looked at selecting contiguous sequences of faces, but there are lots of situations where you might want to select faces that aren't consecutive indices. You can do that by having multiple selections separated by commas as first argument(s) to a function.</p><p>For example, let us say that we wanted to select the first 5 faces <em>and</em> faces 32 through 76 of <code class="literal">myObject</code>. We could use the following:</p><div><pre class="programlisting">cmds.select('myObject.f[0:4]', 'myObject.f[32:76]', replace=True)</pre></div><p>Applying this to UV mapping would give us something like the following:</p><div><pre class="programlisting">cmds.polyProjection('myObject.f[0:4]', 'myObject.f[32:76]', type="planar")</pre></div><p>When working with ranges of faces, it's very common that you'll determine the specific indices at runtime, either through some kind of calculation or based on a user input. It's easy enough to do, but can lead to overly complex sequences of stick together string literals and variables, such as the following:</p><div><pre class="programlisting">obj + '.f[' + str(startFace) + ':' + str(endFace) + ']'</pre></div><p>It's also very easy to forget to convert numerical values to strings with the <code class="literal">str()</code> command, which can lead to errors. Luckily enough, Python provides an alternative way to deal with building formatted strings from variables in the form of the <code class="literal">format</code> command.</p><p>To use the format command, you create a string with sections you want to replace with variables. Each replaceable section is represented with curly brackets containing a number such as <code class="literal">{0}</code>. You can then call the format command on that string and pass in variables that will replace the <code class="literal">{}</code> clauses. The numbers are used to specify which variables should go where ("{0}" means "replace with the first variable", for example).</p><p>So, as a really simple example, we could wish someone happy birthday with the following:</p><div><pre class="programlisting">personAge = 21
personName = "Alice"
"Congratulations on turning {0}, {1}!".format(personAge, personName)
# results in "Congratulations on turning 21, Alice!"</pre></div><p>Turning back to Maya, let's say that we wanted to have a generic way to select a range of faces. We would want to pass in the name of the object, the start index, and the ending index as variables. We could do this with:</p><div><pre class="programlisting">cmds.select(myObject + '.f[' + str(startFace) + ':' + str(endFace) + ']', replace=True)</pre></div><p>This would work just fine, but is a bit hard to read and is an easy way to introduce errors. If we were to rewrite that using the format command, we would have something like this:</p><div><pre class="programlisting">cmds.select("{0}.f[{1}:{2}]".format(myObj, startFace, endFace), replace=True)</pre></div><p>This tends <a id="id167" class="indexterm"/>to be a lot easier to think through because it allows you to separate the structure (the string) from the variables that should be slotted into it. You certainly don't have to use format, but as Maya scripting very often requires building up strings from variables in this way, using it will likely save you a lot of headaches. It also makes your code a lot more readable.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec93"/>See also</h2></div></div></div><p>The official Python documentation for the format command is a bit hard to wade through and presents the information in an overly opaque way. Instead, I highly recommend having a look at <a class="ulink" href="https://pyformat.info/">https://pyformat.info/</a>, for a detailed, yet highly readable explanation of the intricacies of the format command.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec37"/>Creating shading networks with code</h1></div></div></div><p>In this<a id="id168" class="indexterm"/> example, we'll be looking at how to create shading networks with code. We'll be creating a simple toon shader, with a solid color in the interior and a different color at the edges of the object. There are a few different ways to do this, including by creating a rampShader, but we'll be doing it in the somewhat old-fashioned way using a samplerInfo node, as it provides a great example of a relatively simple yet somewhat novel shading network.</p><p>First off, let's have a look at what our shader will do and how it will do it. The key characteristic of a toon shader is that the object has an outline around its edges that changes as the object moves. So, the first thing we'll need is some way of knowing what the angle is between a given part of the model and the camera. Luckily, Maya provides a utility node that does just that in the form of samplerInfo. SamplerInfo nodes provide us with a <code class="literal">facingRatio</code> attribute that ranges from 0 (when a surface is perpendicular to the camera) to 1 (when a surface is facing directly at the camera).</p><p>Once we have the facing ratio, we'll need to tie it to a color change somehow. The easiest and most flexible way to do this is to use a ramp texture with linear interpolation to provide a sharp cutoff between the border and interior colors.</p><p>Putting all that together gives us a relatively simple, three-node shading network similar to the following:</p><div><img src="img/4657_04_01.jpg" alt="Creating shading networks with code"/></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec94"/>How to do it...</h2></div></div></div><p>Create a <a id="id169" class="indexterm"/>new script and add the following code:</p><div><pre class="programlisting">import maya.cmds as cmds

def createNodes():

    shaderNode = cmds.shadingNode('blinn', asShader=True)
    rampTexture = cmds.shadingNode('ramp', asTexture=True)
    samplerNode = cmds.shadingNode('samplerInfo', asUtility=True)

    cmds.setAttr(rampTexture + '.interpolation', 0)
    cmds.setAttr(rampTexture + '.colorEntryList[0].position', 0)
    cmds.setAttr(rampTexture + '.colorEntryList[1].position', 0.45)
cmds.setAttr(rampTexture + '.colorEntryList[0].color', 0, 0, 0, type="float3")
    cmds.setAttr(rampTexture + '.colorEntryList[1].color', 1, 0, 0, type="float3")

    cmds.connectAttr(samplerNode + '.facingRatio', rampTexture + '.vCoord')
    cmds.connectAttr(rampTexture + '.outColor', shaderNode + '.color')

createNodes()</pre></div><p>If you run the script, you should see a new shader appear in the hypershade, consisting of a red interior and a black exterior edge.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec95"/>How it works...</h2></div></div></div><p>There are three <a id="id170" class="indexterm"/>parts of the script—creating the nodes, setting their attributes, and connecting them to each other.</p><p>First off, we create the three nodes we need with the <code class="literal">shadingNode</code> command:</p><div><pre class="programlisting">shaderNode = cmds.shadingNode('blinn', asShader=True)
rampTexture = cmds.shadingNode('ramp', asTexture=True)
samplerNode = cmds.shadingNode('samplerInfo', asUtility=True)</pre></div><p>The first thing to note is that the shadingNode command is used for all three nodes we create even though they're three different types (one shader, one texture, and one utility). In all cases, you get the results you want by specifying the specific kind of node that you want to create (<code class="literal">'blinn'</code>, for example) and also including one of the following flags set to True: <code class="literal">asShader</code>, <code class="literal">asTexture</code>, <code class="literal">asUtility</code>, <code class="literal">asPosProcess</code>, <code class="literal">asRendering</code>, <code class="literal">asLight</code>.</p><p>Leaving out those flags will result in an error. If you include the wrong flag (asTexture=True when creating a Blinn shader, for example), the command will still work, but I don't recommend it.</p><p>Creating the nodes is pretty straightforward—just make sure that you also save the output to a variable (as we've done here) so that you can later set their attributes and connect them.</p><p>Once we have all of our nodes created, we need to set their attributes. In this case, we need to do the following few different things that are applied to the ramp texture:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Ensure that the color interpolation is set to linear to give us nice sharp transitions between colors, rather than smooth gradients.</li><li class="listitem" style="list-style-type: disc">Make sure that the color swatches are positioned correctly along the length of the ramp.</li><li class="listitem" style="list-style-type: disc">Set both the colors to have the edge color and the interior color that we want.</li></ul></div><p>For all of the above, we'll use the <code class="literal">setAttr</code> command. The <code class="literal">setAttr</code> command expects the name of the attribute to set as the first argument, followed by the value to which it should be set. For single value, numeric values, that's pretty straightforward. For example, the following sets the ramp's interpolation to none:</p><div><pre class="programlisting">cmds.setAttr(rampTexture + '.interpolation', 0)</pre></div><p>Although the type of interpolation isn't actually a numerical value, it's a common practice in Maya (and other places) to use integers to represent various options. When setting attribute values that are represented in the interface by a drop-down menu, you'll generally want to use an integer, with the specific value corresponding to the position of the option in the list (with 0 being the first one).</p><p>Next, we'll <a id="id171" class="indexterm"/>want to set the colors of the ramp texture to have the correct positions and colors. The first thing to understand is that ramp textures maintain an array of nodes, contained in their <code class="literal">colorEntryList</code> attribute. Each entry in that list represents a stop in the ramp texture and has both a position and a color.</p><p>We'll want to make sure that the first entry is at the very beginning of the ramp, and the second entry is slightly less than halfway along it, as it gives us a good default edge thickness for the shader. We do this using setAttr to set the position of the first two entries in the <code class="literal">colorEntryList</code> array, as follows:</p><div><pre class="programlisting">cmds.setAttr(rampTexture + '.colorEntryList[0].position', 0)
cmds.setAttr(rampTexture + '.colorEntryList[1].position', 0.45)</pre></div><p>Next, we'll want to set the colors. That's a bit different, in that we need to feed three separate values into the <code class="literal">setAttr</code> command (one each for red, green, and blue). To do this, we'll need to provide all three numbers, and we'll also need to tell Maya to expect multiple inputs to the <code class="literal">setAttr</code> command by using the <code class="literal">type</code> flag.</p><p>The <code class="literal">setAttr</code> command is one of the most powerful and most flexible commands that Maya offers. It can be used to alter any value of any node. All that power requires the command be able to accept various kinds of inputs, all specified with the type flag. In this case, we need a format that supports decimal values (since colors are represented as number from 0 to 1), and that supports three separate values. Either <code class="literal">float3</code> or <code class="literal">double3</code> will work. Putting that all together gives us the following:</p><div><pre class="programlisting">cmds.setAttr(rampTexture + '.colorEntryList[0].color', 0, 0, 0, type="float3")
cmds.setAttr(rampTexture + '.colorEntryList[1].color', 1, 0, 0, type="float3")</pre></div><p>At this point, we've set all of the attribute values that we need for the shader. All that's left is to connect the nodes to each other. We do it with the <code class="literal">connectAttr</code> command. That's fairly straightforward and just requires that we specify first the source attribute, then the destination.</p><p>In this case, we want to make two connections:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">facingRatio</code> attribute of the samplerInfo to the V coordinate of the ramp</li><li class="listitem" style="list-style-type: disc">The <code class="literal">outColor</code> of the ramp texture to the color of the shader</li></ul></div><p>Doing this ends up looking like:</p><div><pre class="programlisting">cmds.connectAttr(samplerNode + '.facingRatio', rampTexture + '.vCoord')
cmds.connectAttr(rampTexture + '.outColor', shaderNode + '.color')</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec96"/>There's more...</h2></div></div></div><p>Creating <a id="id172" class="indexterm"/>nodes and connecting their attributes is a great way to approach a wide range of tasks in Maya, but it can sometimes be tedious. For example, if we wanted to create a <code class="literal">place2dTexture</code> utility node and connect it to a texture node, we would have to make over a dozen connections, which is tedious, to say the least. Luckily, Maya provides an easy shortcut to create nodes with the default behavior in the form of the <code class="literal">defaultNavigation</code> command.</p><p>Here's what that would look like:</p><div><pre class="programlisting">fileTex = cmds.shadingNode('file', asTexture=True)
placeTex = cmds.shadingNode('place2dTexture', asUtility=True)
cmds.defaultNavigation(connectToExisting=True, source=placeTex, destination=fileTex)</pre></div><p>Note the inclusion of the <code class="literal">connectToExisting=True</code> to indicate that the nodes being connected are already present in the scene. Much nicer than 18 separate calls to <code class="literal">connectAttr</code>, indeed.</p><p>You can also break connections between nodes with Python with the <code class="literal">disconnectAttr</code> command. For example, if we wanted the previously mentioned two-node network of a place2dTexture and a file texture to share everything <code class="literal">except</code> the offset attribute, we could do the following:</p><div><pre class="programlisting">cmds.disconnectAttr(placeTex + '.offset', fileTex + '.offset')</pre></div><p>Sometimes, it might be faster to connect two nodes with the default connections (with defaultNavigation) and break a few specific connections you don't want, instead of manually creating all the connections you do want.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec97"/>See also</h2></div></div></div><p>Be sure to refer to the built-in documentation for the <code class="literal">setAttr</code> command for a complete list of the types of inputs it can accept. The documentation is a bit dense, but it's definitely worth a look.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec38"/>Applying shaders to objects</h1></div></div></div><p>Once you <a id="id173" class="indexterm"/>have a shading network created, you'll generally<a id="id174" class="indexterm"/> want to apply it to one or more objects. In this example, we'll be looking at how to do it. Along the way, we'll create a script that can be used to apply a shader to all of the objects in the scene that are without one.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec98"/>Getting ready</h2></div></div></div><p>Make sure <a id="id175" class="indexterm"/>that you have a scene with a few different objects in it. Select a few objects and apply a shader to them in the normal way, using the hypershade's interface. Delete the shader, leaving at least one object without any shader of any kind.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec99"/>How to do it...</h2></div></div></div><p>Create a new<a id="id176" class="indexterm"/> script and add the following code:</p><div><pre class="programlisting">import maya.cmds as cmds

def shadersFromObject(obj):
    cmds.select(obj, replace=True)
    cmds.hyperShade(obj, shaderNetworksSelectMaterialNodes=True)
    shaders = cmds.ls(selection=True)
    return shaders

def isGeometry(obj):
    shapes = cmds.listRelatives(obj, shapes=True)

    shapeType = cmds.nodeType(shapes[0])
    geometryTypes = ['mesh', 'nurbsSurface', 'subdiv']

    if shapeType in geometryTypes:
        return True

    return False

def findUnattachedObjects():

    objects = cmds.ls(type="transform")

    unShaded = []

    for i in range(0, len(objects)):
        if (isGeometry(objects[i])):
            shaders = shadersFromObject(objects[i])
            if (len(shaders) &lt; 1):
                unShaded.append(objects[i])

    newShader = cmds.shadingNode('blinn', asShader=True)
    cmds.setAttr(newShader + '.color', 0, 1, 1, type="double3")

    cmds.select(unShaded, replace=True)
    cmds.hyperShade(assign=newShader)

findUnattachedObjects()</pre></div><p>Run the <a id="id177" class="indexterm"/>script, and <a id="id178" class="indexterm"/>you should see any and all of the objects that were previously without a shader sporting a brand new, cyan-colored blinn shader.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec100"/>How it works...</h2></div></div></div><p>The script works by:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Getting a list of all the objects in the scene.</li><li class="listitem" style="list-style-type: disc">Running through the list and checking whether a given node is geometry.</li><li class="listitem" style="list-style-type: disc">For any geometric node, find the shaders applied to it.</li><li class="listitem" style="list-style-type: disc">If a given object has no shaders, add it to a list of non-shaded objects.</li><li class="listitem" style="list-style-type: disc">Create a new shader to apply.</li><li class="listitem" style="list-style-type: disc">Apply the shader to the shader-less objects.</li></ul></div><p>This script makes use of the <code class="literal">hyperShade</code> command in a couple of different ways—to find the shaders attached to an object, the objects attached to a shader, and to apply a shader.</p><p>First, let's look at how to grab the shaders for a given object. To make things easier on ourselves later, we'll create a function to do it. We have the following code:</p><div><pre class="programlisting">def shadersFromObject(obj):
    cmds.select(obj, replace=True)
    cmds.hyperShade(shaderNetworksSelectMaterialNodes=True)
    shaders = cmds.ls(selection=True)
    return shaders</pre></div><p>The main thing that we're doing is to use the hyperShade command with the <code class="literal">shaderNetworksSelectMaterialNodes</code> (or just <code class="literal">smn</code>) flag set to true. That will select the shader (or shaders) of the currently selected objects. Because the command works on selections, we have to make sure that the object (or objects) we want to know about are selected before we run it. Once we've run it, we'll need to examine the currently selected nodes to get the list of shaders.</p><p>Next, we create a function to easily tell if a given transform node corresponds to actual geometry. We need it because we're going to iterate over all the transforms in the scene, and there are many things (lights, cameras, and so on) that have transforms but that aren't geometry. We accept the name of the node as an input and find the corresponding shape node:</p><div><pre class="programlisting">def isGeometry(obj):
    shapes = cmds.listRelatives(obj, shapes=True)</pre></div><p>Then, we<a id="id179" class="indexterm"/> examine the shape node to find what kind of object it is:</p><div><pre class="programlisting">    shapeType = cmds.nodeType(shapes[0])</pre></div><p>Note that <a id="id180" class="indexterm"/>the <code class="literal">listRelatives</code> command returns an array, so we need to index into that and grab the first element. It's unlikely that an object would have multiple shape nodes, but <code class="literal">listRelatives</code> can also be used to find an object's children, which will often be multiple nodes. Since it can sometimes result in multiples, the command therefore always returns an array even if there's only a single item.</p><p>Each of the three types of geometry in Maya (polygon, NURBS, and subdivision surfaces) has its own corresponding shape node. For the sake of convenience and code readability, we'll create an array of those types and check the current shape node's type against it:</p><div><pre class="programlisting">geometryTypes = ['mesh', 'nurbsSurface', 'subdiv']

if shapeType in geometryTypes:
    return True</pre></div><p>At this point, we're ready to jump into the real meat of the script. We start by grabbing a list of all of the transforms in the scene using the <code class="literal">ls</code> command. So far, we've mainly used that to find what's currently selected, but it can also be used to grab all the nodes of a specific type (selected or not):</p><div><pre class="programlisting">objects = cmds.ls(type="transform")</pre></div><p>Then, we create an empty list to which we'll add any object that we find to be lacking a shader and start running through the list of transforms. First, we check to make sure that the node in question is geometry of some kind. If that's the case, we use our <code class="literal">shadersFromObject</code> function to find the shader(s) applied to the object. Once we've done this, we check the length of the returned list- if it's zero, then the object had no shaders, and we add it to our list:</p><div><pre class="programlisting">unShaded = []

for i in range(0, len(objects)):
    if (isGeometry(objects[i])):
        shaders = shadersFromObject(objects[i])
        if (len(shaders) &lt; 1):
            unShaded.append(objects[i])</pre></div><p>At this point, the <code class="literal">unShaded</code> list contains all of the objects in the scene that lack shaders. We create a new shader, a simple blinn, and set its color to cyan:</p><div><pre class="programlisting">newShader = cmds.shadingNode('blinn', asShader=True)
cmds.setAttr(newShader + '.color', 0, 1, 1, type="double3")</pre></div><p>Finally, we <a id="id181" class="indexterm"/>select the contents of the <code class="literal">unShaded</code> list and apply<a id="id182" class="indexterm"/> the shader we just made. For that, we'll use the <code class="literal">hyperShade</code> command again, but this time with the assign flag to apply the specified shader to the currently selected objects. We have the following code:</p><div><pre class="programlisting">cmds.select(unShaded, replace=True)
cmds.hyperShade(assign=newShader)</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec101"/>There's more...</h2></div></div></div><p>The <code class="literal">hyperShade</code> command can be used to do most of the tasks one would normally accomplish in the hypershade panel interface. In the previous example, we grabbed shaders from objects, but the command can also be used to find the objects associated with a given shader with the <code class="literal">objects</code> flag. Wrapping that up in a nice function to return the objects for a given shader would look something like the following:</p><div><pre class="programlisting">def objectsFromShader(shader):
    cmds.hyperShade(objects=shader)
    objects = cmds.ls(selection=True)
    return objects</pre></div><p>Once again, the <code class="literal">hyperShade</code> changes the current selection, and we use the <code class="literal">ls</code> command to retrieve the selection as an array.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec39"/>Using shading nodes for non-shading tasks</h1></div></div></div><p>One of <a id="id183" class="indexterm"/>the really great things about the various nodes that Maya provides is that there are very few limits on how you use them. To Maya, all nodes are just collections of functionality with certain inputs and outputs, and as long as the type of data lines up, it doesn't really care how you connect them.</p><p>This means that it's completely possible (and often very useful) to use hypershade nodes for tasks that aren't related to creating shading networks. In this example, we'll be doing just that using a plus/minus/average utility node to set the position of a given object to the average position of a number of others. This could be used, for example, to ensure that the pelvis of a character always stays centered in between the IK handles controlling its feet.</p><p>Using utility nodes can be used for tasks where you might otherwise write an expression, but with the added benefit that they update constantly, not just while the playback head is moving.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec102"/>Getting ready</h2></div></div></div><p>Be sure that<a id="id184" class="indexterm"/> you have a scene with at least three objects in it.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec103"/>How to do it...</h2></div></div></div><p>Create a new script and add the following code:</p><div><pre class="programlisting">import maya.cmds as cmds

def keepCentered():

    objects = cmds.ls(selection=True)

    if (len(objects) &lt; 3):
        cmds.error('Please select at least three objects')

    avgNode = cmds.shadingNode('plusMinusAverage', asUtility=True)
    cmds.setAttr(avgNode + '.operation', 3)

    for i in range(0, len(objects) - 1):
        cmds.connectAttr(objects[i] + '.translateX', avgNode + '.input3D[{0}].input3Dx'.format(i))
        cmds.connectAttr(objects[i] + '.translateZ', avgNode + '.input3D[{0}].input3Dz'.format(i))

    controlledObjIndex = len(objects) - 1

    cmds.connectAttr(avgNode + '.output3D.output3Dx', objects[controlledObjIndex] + '.translateX')
    cmds.connectAttr(avgNode + '.output3D.output3Dz', objects[controlledObjIndex] + '.translateZ')

keepCentered()</pre></div><p>Select at least three objects, making sure that the object you want to be controlled is the last one selected, and run the script. Once you've done that, try moving the objects around, and you'll see that the X and Z position of the controlled object is always an average of the X and Z positions of all the other objects.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec104"/>How it works...</h2></div></div></div><p>First off, we check to make sure that there are at least three objects selected and error out if there isn't:</p><div><pre class="programlisting">objects = cmds.ls(selection=True)

    if (len(objects) &lt; 3):
        cmds.error('Please select at least three objects')</pre></div><p>If we <a id="id185" class="indexterm"/>have at least three objects, we proceed to create a brand new utility node, in this case a plus/minus/average node. Since the plus/minus/average node can perform three completely separate actions, we also need to set its "operation" attribute to average (which happens to be the fourth option in the corresponding dropdown, so has a value of 3), as follows:</p><div><pre class="programlisting">    avgNode = cmds.shadingNode('plusMinusAverage', asUtility=True)
    cmds.setAttr(avgNode + '.operation', 3)</pre></div><p>Once we've done this, we run through the list of selected objects and connect all but the last one to the utility node as inputs. PlusMinusAverage nodes can have one-dimensional, two-dimensional, or three-dimensional inputs. In this case, we'll use 3D inputs.</p><div><div><h3 class="title"><a id="tip04"/>Tip</h3><p>We're only using two inputs (X and Z), so we certainly could get by with 2D inputs instead. However, since we're dealing with position data, I think it's better to use full 3D inputs and just leave the Y inputs empty. This way, it's easier to later modify the script to allow the user to select any combination of X, Y, and Z that they want.</p><p>Of course, the "X", "Y", and "Z" of the plusMinusAverage node don't have any intrinsic meaning; they're just three separate pathways for the calculation, and we could certainly use them for things that have nothing to do with position.</p></div></div><p>The plusMinusAverage node holds an array for each type of input (one-dimensional, two-dimensional, and three-dimensional). So to do anything with it, we'll need to first access the proper array. If we had a plusMinusAverage node named <code class="literal">avgNode</code> and wanted to do something with the second one-dimensional input, we would use the following:</p><div><pre class="programlisting">avgNode.input1D[1]</pre></div><p>For two- and three-dimensional inputs, we need to specify not only the proper array but also the proper entry. For two-dimensional inputs, the array is specified as:</p><div><pre class="programlisting">avgNode.input2D[0].input2Dy</pre></div><p>For three-dimensional inputs, the array is specified as:</p><div><pre class="programlisting">avgNode.input3D[0].input3Dx</pre></div><p>We don't need to explicitly add inputs to the utility node; we can just use connectAttr to connect inputs to successive indices of the node's input 3D array.</p><p>In this case, we want to run through all of the selected objects except for the last one and connect their X and Z positions, which is easy enough:</p><div><pre class="programlisting">for i in range(0, len(objects) - 1):
    cmds.connectAttr(objects[i] + '.translateX', avgNode + '.input3D[{0}].input3Dx'.format(i))
    cmds.connectAttr(objects[i] + '.translateZ', avgNode + '.input3D[{0}].input3Dz'.format(i))</pre></div><p>At that <a id="id186" class="indexterm"/>point, we're mainly done. All that's left is to connect the outputs of the plusMinusAverage node to the controlled object. Storing the index of the controlled object as a variable isn't necessary, but does make the code a bit more readable:</p><div><pre class="programlisting">controlledObjIndex = len(objects) - 1

cmds.connectAttr(avgNode + '.output3D.output3Dx', objects[controlledObjIndex] + '.translateX')
cmds.connectAttr(avgNode + '.output3D.output3Dz', objects[controlledObjIndex] + '.translateZ')</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec105"/>There's more...</h2></div></div></div><p>In the discussed example, we created a very simple network, but it's certainly possible to create more complex networks. One important thing to bear in mind is that, while all the nodes have certain uses that they were created for, in no way this limits the kind of use to which they can be put. To Maya, numbers are just numbers, and there's nothing to stop you from using color channels to control position or rotation to control transparency.</p></div></div></body></html>