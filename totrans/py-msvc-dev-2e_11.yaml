- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: What's Next?
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接下来是什么？
- en: In this book, we have discussed the design and development of microservices
    written in Python using the Quart framework. We have built a monolithic application
    from which to work, and covered strategies to migrate from that architecture to
    one that makes the best use of microservices, along with the potential errors
    that could arise and how to avoid them. We have also learned about deploying our
    application to cloud providers using container-based services.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们讨论了使用Quart框架编写的Python微服务的设计和开发。我们构建了一个单体应用程序作为工作基础，并介绍了从该架构迁移到最佳利用微服务的架构的策略，以及可能出现的潜在错误以及如何避免它们。我们还学习了如何使用基于容器的服务将我们的应用程序部署到云服务提供商。
- en: However, this is not the end of the story, and there are other topics that are
    beneficial to learn more about. There is always going to be more room for improvement
    in our automation and tooling to help services keep up to date, more questions
    to answer about performance and capacity management that our monitoring and logging
    can help with, and considerations about how to scale and change our deployment
    architecture to improve the service's reliability and availability. Finally, we
    need to remember that – unless writing code for a hobby – the software itself
    is not the end goal, and we must keep our promises to the people who need the
    software.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不是故事的结束，还有其他一些话题值得进一步了解。我们的自动化和工具总是有改进的空间，以帮助服务保持更新，还有更多关于性能和容量管理的问题需要回答，我们的监控和日志可以帮助解决这些问题，以及如何扩展和改变我们的部署架构以提高服务的可靠性和可用性的考虑。最后，我们需要记住——除非是为了爱好编写代码——软件本身并不是最终目标，我们必须履行对需要软件的人的承诺。
- en: Automation
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化
- en: We briefly discussed **Terraform** as a way to automate the creation of cloud-based
    resources, and there is a lot more to learn about this tool as well as others
    that can automate some of the work involved in running a service.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简要讨论了**Terraform**作为自动化创建基于云资源的方法，还有更多关于这个工具以及其他可以自动化运行服务的一些工作的工具需要学习。
- en: To configure inside an instance, configuration management tools such as **Ansible**,
    **Chef**, and **Puppet** allow you to copy files, change file contents, install
    packages, and set up a computer how you like it in a repeatable, predictable manner.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 要在实例内部进行配置，配置管理工具如**Ansible**、**Chef**和**Puppet**允许你复制文件、更改文件内容、安装软件包，并以可重复、可预测的方式设置计算机，使其符合你的喜好。
- en: Building operating system images for your own environment can be done with HashiCorp's
    **Packer**, which lets you use the configuration management tools above to create
    operating system images for use in AWS, GCP, VMware, or Docker, among many others.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 使用HashiCorp的**Packer**为你的环境构建操作系统镜像，它允许你使用上述配置管理工具创建操作系统镜像，用于AWS、GCP、VMware或Docker等许多其他环境。
- en: Even if your infrastructure is small, using automation to create and maintain
    it is still valuable. In the event of a disaster, you are a few short commands
    away from recreating your entire suite of applications, instead of weeks of painstaking
    work.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你的基础设施很小，使用自动化来创建和维护它仍然很有价值。在发生灾难的情况下，你只需几条简短的命令就可以重新创建你整个应用程序套件，而不是几周痛苦的劳动。
- en: 'When creating infrastructure as code, it''s very easy to accidentally create
    a new monolith, responsible for creating and maintaining every component. If that
    is a deliberate, considered choice then it will work well, but it''s also worth
    remembering the other principles of privilege separation and ease of maintenance
    that come with separating out the features into smaller projects. Here are some
    relevant links:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建基础设施代码时，很容易不小心创建一个新的单体，负责创建和维护每个组件。如果这是一个深思熟虑的选择，那么它将工作得很好，但同时也值得记住将功能分离成更小的项目所带来的其他原则，比如权限分离和易于维护。以下是一些相关的链接：
- en: 'Terraform: [https://www.terraform.io/](https://www.terraform.io/)'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Terraform: [https://www.terraform.io/](https://www.terraform.io/)'
- en: 'Ansible: [https://www.ansible.com/](https://www.ansible.com/)'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Ansible: [https://www.ansible.com/](https://www.ansible.com/)'
- en: 'Chef: [https://www.chef.io/](https://www.chef.io/)'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Chef: [https://www.chef.io/](https://www.chef.io/)'
- en: 'Puppet: [https://puppet.com/](https://puppet.com/)'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Puppet: [https://puppet.com/](https://puppet.com/)'
- en: Scaling
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展
- en: When an application needs to do more work, the historical approach has been
    to run the application on a bigger computer. Give it more memory, more CPU cores,
    and even more disk space. This does not increase the application's reliability,
    as it still relies on a single computer, and it comes with added complications
    once your application is large enough that there simply aren't any computers large
    enough to run it on.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序需要做更多工作时，传统的方法是在更大的计算机上运行应用程序。给它更多的内存、更多的CPU核心，甚至更多的磁盘空间。这并不会增加应用程序的可靠性，因为它仍然依赖于单一计算机，而且一旦应用程序足够大，就没有足够的计算机可以运行它时，这会带来额外的复杂性。
- en: Giving a program a larger computer to run on is called scaling vertically. By
    contrast, scaling horizontally is the approach of using many smaller computers.
    We came across this idea when discussing deploying on container-based services
    and increasing the number of instances that our Docker swarm used. An application
    must have a replicated, scalable idea of its current state to operate in this
    way, for client sessions, shopping basket contents, and anything else that a visitor
    would expect to be persistent between different pages of a website.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 将程序运行在更大型的计算机上被称为垂直扩展。相比之下，水平扩展则是使用许多小型计算机的方法。我们在讨论基于容器的服务部署以及增加我们使用的Docker集群实例数量时遇到了这个想法。为了以这种方式运行，应用程序必须有一个复制的、可扩展的当前状态的概念，以便客户端会话、购物车内容以及访客期望在网站的不同页面之间持久存在的任何其他内容。
- en: Microservices allow you to scale an application much more easily, although it
    is important to remember that every component communicates with other microservices
    and that an increased load in one area will have consequences in others.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务允许您更容易地扩展应用程序，尽管重要的是要记住，每个组件都会与其他微服务通信，并且一个区域的负载增加将对其他区域产生后果。
- en: Careful monitoring will allow you to discover the bottlenecks in the overall
    system, and so prioritize which area needs the most urgent work in order to give
    the system more capacity.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细监控将使您能够发现整个系统中的瓶颈，从而确定哪个区域最需要紧急工作，以便为系统提供更多容量。
- en: Content Delivery Networks
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内容分发网络
- en: Some of the content our applications deliver does not change very often, such
    as HTML pages, JavaScript, images, and video streams. **Content Delivery Networks**
    (**CDNs**) aim to provide static content that is distributed around the world.
    Acting either as a layer in front of your application or alongside it, they can
    provide cacheable content to clients much more quickly than a customized service.
    Some CDNs will also allow you to dynamically scale images and video based on the
    client and its network quality, or provide protection against distributed denial
    of service attacks, making them a valuable tool for any web-based service.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序提供的一些内容并不经常改变，例如HTML页面、JavaScript、图像和视频流。**内容分发网络**（**CDNs**）旨在提供全球范围内分布的静态内容。它们可以作为您应用程序前端的层或与其并行工作，能够比定制化服务更快地向客户端提供可缓存的
    内容。一些CDNs还允许您根据客户端及其网络质量动态调整图像和视频，或者提供针对分布式拒绝服务攻击的保护，使它们成为任何基于Web的服务的重要工具。
- en: Multi-cloud deployments
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多云部署
- en: When assessing the risks involved in running a service, it's easy to come to
    the realization that your organization is completely dependent on one cloud provider.
    A common desire to improve redundancy is to deploy services to multiple providers
    and spread the workload across Azure, GCP, Amazon, and others. This might seem
    like a great idea, but it also introduces a lot of complexity as different providers
    have different feature sets available, will need unique security arrangements,
    and be unable to share storage and secrets management.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在评估运行服务的风险时，很容易意识到您的组织完全依赖于一个云服务提供商。为了提高冗余性，一个常见的愿望是将服务部署到多个提供商，并将工作负载分散到Azure、GCP、Amazon和其他服务上。这听起来可能是个好主意，但它也引入了许多复杂性，因为不同的提供商有不同的功能集可用，需要独特的安全安排，并且无法共享存储和秘密管理。
- en: While `Terraform` can help with this situation, it is often more achievable
    to aim for multiple regions within the same provider, and if several cloud providers
    are really required, to separate what's running in them based on how things interact.
    It's far easier to put a completely independent service somewhere else. There
    are parallels with the strategic approach and splitting a monolith into microservices,
    as a successful migration requires a clean interface between different components
    and well-structured isolation of concerns and requirements.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`Terraform`可以帮助处理这种情况，但通常更可行的是在同一提供者内追求多个区域，如果确实需要多个云提供者，可以根据它们之间的交互方式来区分它们运行的内容。将完全独立的服务放在其他地方要容易得多。这与战略方法和将单体拆分为微服务的做法有相似之处，因为成功的迁移需要不同组件之间的清晰接口和良好结构化的关注点和需求隔离。
- en: Lambda Functions
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lambda函数
- en: Lambda, or Cloud Functions, is a type of serverless deployment intended for
    small, short-lived tasks that can scale up and down very rapidly. While asynchronous
    frameworks have limited support in this area in 2021, they are widely used with
    synchronous code as the way they are run means that the responsiveness is controlled
    by the sheer number of them that can run simultaneously.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda，或云函数，是一种无服务器部署类型，旨在用于小型、短暂的任务，可以非常快速地扩展和缩减。尽管在2021年，异步框架在这个领域支持有限，但它们与同步代码广泛结合使用，因为它们的运行方式意味着响应性由可以同时运行的实例数量控制。
- en: Expanding monitoring
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展监控
- en: In *Chapter 5*, *Splitting the Monolith*, we discussed monitoring and collecting
    metrics to record what an application is doing. Measurements can tell some of
    the story and give a picture involving a count, a size, or time passing. To get
    even more information, we can use logging services to record messages our application
    produces.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第5章*，*拆分单体*中，我们讨论了监控和收集指标以记录应用程序正在做什么。测量可以讲述一些故事，并给出涉及计数、大小或时间流逝的画面。为了获取更多信息，我们可以使用日志服务来记录应用程序产生的消息。
- en: If you have set up a Linux server, you may be familiar with the logs that pass
    through `rsyslog` and end up in a file that exists in `/var/log`. In a cloud service,
    and especially in a container, logging locally is far less useful, as we would
    have to then investigate all the running containers and cloud instances to discover
    what was happening. Instead, we can use a centralized logging service.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经设置了一个Linux服务器，你可能熟悉通过`rsyslog`传递并通过位于`/var/log`中的文件结束的日志。在云服务中，尤其是在容器中，本地日志记录几乎没有什么用处，因为我们不得不调查所有运行的容器和云实例以发现发生了什么。相反，我们可以使用集中式日志服务。
- en: This could be done using tools such as AWS CloudWatch or Google's Cloud Logging,
    but it's also possible to run services such as `Splunk` or `Logstash`. The latter
    is part of a popular open source trio of tools called the `ELK` stack, as it contains
    Elasticsearch, Logstash, and Kibana, to collect, search, and visualize logged
    data. Using these tools, all the logs from the systems and applications can end
    up in a single place and be easily examined.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用AWS CloudWatch或Google的Cloud Logging等工具来完成这项工作，但也可以运行`Splunk`或`Logstash`等服务。后者是被称为`ELK`堆栈的流行开源工具组合的一部分，因为它包含了Elasticsearch、Logstash和Kibana，用于收集、搜索和可视化日志数据。使用这些工具，系统和应用程序的所有日志最终都可以集中在一个地方，并便于检查。
- en: Using structured logging techniques, it is also straightforward to annotate
    all the log entries to easily determine which microservice produced them, and
    so to better correlate events. A centralized logging service will allow you to
    connect the dots between errors in one component and reports from a separate area.
    At the same time, each microservice being more isolated means that any impact
    they have on other components should be through the designed interfaces, instead
    of being side effects due to resource constraints on the same server, or in the
    same process tree.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 使用结构化日志技术，注释所有日志条目以轻松确定哪个微服务产生了它们，从而更好地关联事件也是一件简单的事情。集中式日志服务将允许你连接一个组件中的错误和来自不同区域的报告之间的联系。同时，每个微服务更加隔离，这意味着它们对其他组件的影响应该通过设计的接口，而不是由于同一服务器上的资源限制或同一进程树中的副作用。
- en: The ELK stack is a great starting point for collecting large numbers of logs
    and metrics, and you can discover more about it at [https://www.elastic.co/what-is/elk-stack](https://www.elastic.co/what-is/elk-stack).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: ELK堆栈是收集大量日志和指标的一个很好的起点，你可以在[https://www.elastic.co/what-is/elk-stack](https://www.elastic.co/what-is/elk-stack)了解更多关于它的信息。
- en: Making promises
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 承诺
- en: When writing software, we are often not doing so in isolation, but instead to
    help our company or open source project achieve a goal. Relying on our intuition
    to tell us whether we're doing a good job is often misleading, as our instinct
    is affected by all the different biases humans have. Instead, we must measure
    – collect numbers, watch for patterns, and analyze data.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写软件时，我们通常不是孤立地工作，而是为了帮助我们的公司或开源项目实现目标。仅仅依靠我们的直觉来判断我们是否做得好往往具有误导性，因为我们的本能会受到人类所有不同偏见的影响。相反，我们必须进行测量——收集数据，观察模式，并分析数据。
- en: 'To demonstrate how well our software is doing, both to ourselves and to others,
    there are three levels we can think about. The first is the list of possible things
    we can measure, and these are known as **Service-Level Indicators** (**SLIs**).
    As developers, it is easy to come up with a list of technology-related SLIs, such
    as:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示我们的软件表现如何，无论是对我们自己还是对他人，我们可以考虑三个级别。第一个是我们可以测量的可能事物的列表，这些被称为**服务级别指标**（**SLIs**）。作为开发者，我们很容易列出与技术相关的
    SLIs，例如：
- en: The API response time in milliseconds
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API 响应时间（以毫秒为单位）
- en: A count of the different HTTP status codes
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同 HTTP 状态码的计数
- en: The number of bytes transferred in each request
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个请求中传输的字节数
- en: 'However, it is vitally important to include organization-level indicators as
    well, such as:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，包含组织级别的指标同样至关重要，例如：
- en: How long an online shop's check-out process takes
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在线商店的结账过程需要多长时间
- en: How many potential customers abandon a purchase during check-out
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有多少潜在客户在结账过程中放弃购买
- en: The financial cost of running a service, especially one that automatically scales
    up and down
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行服务的财务成本，尤其是自动扩展和缩减的服务
- en: 'Both types of indicators, when used together, can make for very useful reports
    and dashboards for an organization, but you also don''t want to be constantly
    checking on things – there is other work to be done! A **Service-Level Objective**
    (**SLO**) sets a threshold or alert value on top of an SLI, such as:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当这两种类型的指标结合使用时，可以为组织提供非常有用的报告和仪表板，但你也不希望不断地检查事情——还有其他工作要做！**服务级别目标**（**SLO**）在**服务级别指标**（**SLI**）的基础上设置一个阈值或警报值，例如：
- en: Fewer than 1% of HTTP status codes must indicate a server error
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不到 1% 的 HTTP 状态码必须表示服务器错误
- en: The rate of completed check-out operations must exceed 75%
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完成的结账操作率必须超过 75%
- en: Users can successfully complete at least 99.9% of their requests without an
    error
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户可以成功完成至少 99.9% 的请求而不会出现错误
- en: What should we do if an SLO is not met? That's where **Service-Level Agreements**
    (**SLAs**) come in. SLAs are a contract – official or otherwise – between the
    providers of a service and the people using it and describe what should happen
    when an SLO is not met.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未达到 SLO，我们应该怎么做？这就是**服务级别协议**（**SLA**）发挥作用的地方。SLA 是服务提供者和使用者之间的一种合同——无论是正式的还是非正式的——当
    SLO 未达到时，它描述了应该发生什么。
- en: 'Here is an example covering all the levels:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个涵盖所有级别的示例：
- en: 'Service-level indicator: The number of HTTP 500 errors recorded'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务级别指标：记录的 HTTP 500 错误数量
- en: 'Service-level objective: The HTTP 500 errors should not be more than 1% of
    the total requests'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务级别目标：HTTP 500 错误不应超过总请求的 1%
- en: 'Service-level agreement: A site reliability engineer is alerted and affected
    customers are informed'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务级别协议：当有站点可靠性工程师被通知，受影响的客户被通知时
- en: Creating SLOs helps developers and product team members understand what's important
    about an application and lets us demonstrate to everyone involved that the application
    is doing what it is meant to do.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 SLO 帮助开发人员和产品团队成员了解应用程序的重要之处，并让我们向所有相关人员展示应用程序正在做它应该做的事情。
- en: Summary
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: As software developers we never stop improving our skills and knowledge, trying
    out new technologies and architectures, and building on the work of many others.
    Our profession's core skill is approaching a situation in a rational and methodical
    manner, breaking down each part of the problem into manageable chunks, and making
    sure that we – and others who have a stake in our work – can make sense of it
    all.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 作为软件开发者，我们永远不会停止提高我们的技能和知识，尝试新技术和架构，并建立在许多人的工作之上。我们职业的核心技能是以理性、有条理的方式处理情况，将问题的每一部分分解成可管理的块，并确保我们——以及对我们工作有利益相关的人——能够理解这一切。
- en: The microservices approach uses the same techniques in systems design, making
    each component easier to reason about and investigate. Like many approaches, it
    works very well when it is done with careful consideration, rather than a desire
    to follow a fashion.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务方法在系统设计中使用了相同的技巧，使得每个组件更容易进行推理和调查。像许多方法一样，当它经过仔细考虑而不是仅仅为了追随潮流时，它工作得非常好。
- en: Designing applications well takes a combination of knowledge, skill, and experience,
    and we hope that this book has contributed to the expertise that you bring to
    your work, whether it's paid, volunteering, or a hobby.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 设计良好的应用程序需要知识、技能和经验的结合，我们希望这本书已经为你在工作中带来的专业知识做出了贡献，无论是付费工作、志愿服务还是爱好。
