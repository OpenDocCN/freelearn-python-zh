- en: Creating Controllers with Blueprints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The final piece of the **Model View Controller** (**MVC**) equation is controllers.
    We have already seen the basic usage of the view functions in our `main.py` file.
    Now, the more complex and powerful versions will be introduced, and we will turn
    our disparate view functions into cohesive wholes. We will also discuss the internals
    of how Flask handles the lifetime of an HTTP request and advanced ways to define
    Flask views.
  prefs: []
  type: TYPE_NORMAL
- en: Sessions and globals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Sessions** are the way Flask will store information across requests; to do
    this, Flask will use signed cookies using the previously set `SECRET_KEY` config
    to apply the HMAC-SHA1 default cryptographic method. So, a user can read their
    session cookie but can''t modify it. Flask also sets a default session lifetime
    that defaults to 31 days to prevent relay attacks; this can be changed by using
    the configuration key''s `PERMANENT_SESSION_LIFETIME` config key.'
  prefs: []
  type: TYPE_NORMAL
- en: Security is paramount in today's modern web applications; read Flask's documentation carefully, where
    various attacks methods are covered: [http://flask.pocoo.org/docs/security/](http://flask.pocoo.org/docs/security/).
  prefs: []
  type: TYPE_NORMAL
- en: 'A Flask session object is a special kind of Python dictionary, but you can
    use it much like a plain Python dictionary, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '**Global** is a thread-safe namespace store to keep data during a request''s
    context. At the beginning of each request, a new global object is created, and
    at the end of the request the object is destroyed. It''s the right place to keep
    a User object or any data that needs to be shared across views, templates, or
    Python functions that are called within the request context. This is done without
    the need to pass around any data.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The use of `g` (global)is very simple, to set a key on a request context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Request setup and teardown
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When your **WSGI** (**Web Server Gateway Interface**) handles a request, Flask
    creates a request context object that contains all the information about the request
    itself. This object is pushed into a stack that contains other important information,
    such as the Flask `app` , `g`, `session`, and flash messages.
  prefs: []
  type: TYPE_NORMAL
- en: The request object is available to any function, view, or template that is currently
    processing the request; this happens without the need to pass around the request
    object itself. `request` contains information such as HTTP headers, URI arguments,
    URL path, WSGI environment, and whatnot.
  prefs: []
  type: TYPE_NORMAL
- en: For more detailed information on the Flask request object, see: [http://flask.pocoo.org/docs/api/#incoming-request-data](http://flask.pocoo.org/docs/api/#incoming-request-data).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can easily add more information to the request context by implementing our
    own hooks on request creation. To achieve this, we can use Flask''s decorator
    function, `@app.before_request`, and the `g` object. The `@app.before_request` function is
    executed every time, before a new request is made. For example, the following
    code keeps a global counter for the number of page loads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Multiple functions can be decorated with `@app.before_request`, and they all
    will be executed before the requested view function is executed. There also exists
    a decorator, `@app.teardown_request`, which is called after the end of every request.
  prefs: []
  type: TYPE_NORMAL
- en: Initialize the example code provided for this chapter and watch how the data
    for `g`, `session`, and `request` changes. Also, note the `csrf_token` set by
    WTForm to secure our forms.
  prefs: []
  type: TYPE_NORMAL
- en: Error pages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Displaying a browser''s default error pages to the end user is jarring as the
    user loses all context of your app, and they must hit the back button to return
    to your site. To display your own templates when an error is returned with the
    Flask `abort()` function, use the `errorhandler` decorator function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`errorhandler` is also useful to translate internal server errors and HTTP
    500 codes into user-friendly error pages. The `app.errorhandler()` function may
    take either one or many HTTP status codes to define which code it will act on.
    The returning of a tuple instead of just an HTML string allows you to define the
    HTTP status code of the `Response` object. By default, this is set to `200`. The
    `recommend` method is covered in [Chapter 6](433b4f3b-4e05-4a63-ae8b-ec2e392877b4.xhtml),
    *Securing Your App*.'
  prefs: []
  type: TYPE_NORMAL
- en: Class-based views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In most Flask apps, views are handled by functions. However, when many views
    share common functionality or there are pieces of your code that could be broken
    out into separate functions, it would be useful to implement our views as classes
    to take advantage of inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we have views that render a template, we could create a generic
    view class that keeps our code *DRY*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The first thing to note about this code is the `dispatch_request()` function
    in our view class. This is the function in our view that acts as the normal view
    function and returns an HTML string. The `app.add_url_rule()` function mimics
    the `app.route()` function as it ties a route to a function call. The first argument
    defines the route of the function, and the `view_func` parameter defines the function
    that handles the route. The `View.as_view()` method is passed to the `view_func`
    parameter because it transforms the `View` class into a view function. The first
    argument defines the name of the view function, so functions such as `url_for()`
    can route to it. The remaining parameters are passed to the `__init__` function
    of the `View` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like the normal view functions, HTTP methods other than `GET` must be explicitly
    allowed for the `View` class. To allow other methods, a class variable containing
    the list of named methods must be added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This can be a very powerful approach. Take for example web pages that render
    tabular lists from database tables; they are almost identical, so are nice candidates
    for generic approaches. Although not a trivial task to carry out, the time you
    take to implement it can save you time in the future. An initial skeleton using
    class-based views could be this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: There are some interesting things to notice. First, in the class constructor
    we initialize the `columns` class property with the SQLAlchemy model columns;
    we are leveraging the model introspection ability of SQLAlchemy to be able to
    implement our generic template. So, column names are going to be passed to our
    generic template so that we can properly render a well formatted tabular list
    for any model we throw at it.
  prefs: []
  type: TYPE_NORMAL
- en: This is a simple example of how, with a single class view, we handle all list
    views from all our models.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how the template looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You can access these views by running the example code provided for this chapter,
    then directly accessing the declared URLs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://localhost:5000/generic_users`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http://localhost:5000/generic_posts`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http://localhost:5000/generic_comments`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may have noticed that our tabular view is missing the table column headers.
    As an exercise, I challenge you to implement it; you can simply render the provided `columns` class
    property, or even better, use a label/column mapping to display more user-friendly
    column names.
  prefs: []
  type: TYPE_NORMAL
- en: Method class views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Often, when functions handle multiple HTTP methods, the code can become difficult
    to read due to large sections of code nested within `if` statements, as demonstrated
    in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This can be solved with the `MethodView` class. `MethodView` allows each method
    to be handled by a different class method to separate concerns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Blueprints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Flask, a **blueprint** is a method of extending an existing Flask app. They
    provide a way of combining groups of views with common functionality and allow
    developers to break their app down into different components. In our architecture,
    the blueprints will act as our *controllers*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Views are registered to a blueprint; a separate template and static folder
    can be defined for it, and when it has all the desired content in it, it can be
    registered on the main Flask app to add the blueprint''s content. A blueprint
    acts much like a Flask app object, but is not actually a self-contained app. This
    is how Flask extensions provide view functions. To get an idea of what blueprints
    are, here is a very simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The blueprint takes two required parameters, the name of the blueprint and the
    name of the package, which are used internally in Flask, and passing `__name__`
    to it will suffice.
  prefs: []
  type: TYPE_NORMAL
- en: The other parameters are optional and define where the blueprint will look for
    files. Because `templates_folder` was specified, the blueprint will not look in
    the default template folder, and the route will render `templates/example/home.html`
    and not `templates/home.html`. The `url_prefix` option automatically adds the
    provided URI to the start of every route in the blueprint. So, the URL for the
    home view is actually `/example/`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `url_for()` function will now have to be told which blueprint the requested
    route is in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, the `url_for()` function will now have to be told whether the view is
    being rendered from within the same blueprint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `url_for()` function will also look for static files in the specified `static`
    folder as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use this to add the blueprint to our app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s transform our current app to one that uses blueprints. We will first
    need to define our blueprint before all of our routes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now, because the `templates` folder was defined, we need to move all of our
    templates into a subfolder of the `templates` folder named `blog`. Next, all of
    our routes need to have `@app.route` changed to `@blog_blueprint.route`, and any
    class view assignments now need to be registered to `blog_blueprint`. Remember
    that the `url_for()` function calls in the templates will also have to be changed
    to have a period prepended to then to indicate that the route is in the same blueprint.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of the file, right before the `if__name__ == ''__main__'':` statement,
    add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, all of our content is back in the app, which is registered under the blueprint.
    Because our base app no longer has any views, let''s add a redirect on the base
    URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Why blog and not `blog_blueprint`? Because blog is the name of the blueprint
    and the name is what Flask uses internally for routing. `blog_blueprint` is the
    name of the variable in the Python file.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have introduced you to some powerful features of Flask;
    we have seen how to use sessions to store user data across requests and globals
    for keeping data during the request context. We have introduced you to the concept
    of request context and started showing you some new features that will enable
    us to scale our applications easily to any size, using Blueprints and Method Class
    views.
  prefs: []
  type: TYPE_NORMAL
- en: We now have our app working inside a blueprint, but what does this give us?
    Let's say that we wanted to add a photo sharing function to our site, we would
    be able to group all the view functions into one blueprint with its own templates,
    static folder, and URL prefix without any fear of disrupting the functionality
    of the rest of the site.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, blueprints will be made even more powerful by separating
    them into different files after upgrading our file and code structure.
  prefs: []
  type: TYPE_NORMAL
