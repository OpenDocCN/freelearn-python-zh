<html><head></head><body>
  <div id="sbo-rt-content"><div class="chapter" title="Chapter 11. Key Concepts Behind Grok"><div class="titlepage"><div><div><h1 class="title"><a id="ch11"/>Chapter 11. Key Concepts Behind Grok</h1></div></div></div><p>In the first chapter of this book, we discussed the features of Grok, placing a strong emphasis on the importance of the <span class="strong"><strong> Zope Toolkit</strong></span> (<span class="strong"><strong>ZTK</strong></span>) and the <span class="strong"><strong> Zope Component Architecture</strong></span> (<span class="strong"><strong>ZCA</strong></span>). We also mentioned that Grok offers an agile way of using these.<a id="id356" class="indexterm"/>
</p><p>Throughout the preceding chapters, we used several ZTK packages and employed many ZCA patterns, introducing and explaining them, whenever needed. We also saw how agile Grok can be, as we grew our application bit by bit, while having a fully functional application from the very beginning.</p><p>With the material that we have covered so far, it's possible to create fairly complex applications, but to really get the most out of Grok, the concepts behind the ZCA and the tools that provide Grok's agility have to be explained at a more detailed level.</p><p>Although a full explanation of the ZCA and its patterns is beyond the scope of this book, this chapter will at least discuss its more important concepts and show their utility through small additions and extensions to our to-do list application. The author believes that it's easier to understand these concepts once we have seen practical examples of their use at work, which we can refer to when explaining them.</p><p>In this chapter, we will look at these concepts in detail. In particular, we'll discuss:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">What the ZCA is</li><li class="listitem" style="list-style-type: disc">Interfaces</li><li class="listitem" style="list-style-type: disc">Adapters, utilities, and events</li><li class="listitem" style="list-style-type: disc">Application extension through events</li><li class="listitem" style="list-style-type: disc">Application extension through adaptation</li></ul></div><div class="section" title="The Zope Component Architecture"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec01"/>The Zope Component Architecture</h1></div></div></div><p>Many agile web application frameworks were designed specifically to allow a quick turnaround from idea to working application. This is a good thing, but sometimes the emphasis on fast development cycles results in a little less attention being paid to things such as extensibility and code reuse. In contrast, Grok is based on a set of patterns whose primary concern is the maintainability and extensibility of applications. In fact, Grok applications can be extended even from the outside, without the need to touch their code. The set of patterns that allows this is known as the<span class="strong"><strong> Zope Component Architecture</strong></span>.<a id="id357" class="indexterm"/>
</p><p>Even though the word "Zope" is in its name, the ZCA is a set of general Python packages that can be used to create component-based applications, independent of the Zope web application server or the ZTK. In fact, we could use the ZCA to create any kind of Python application, and it's especially suited to the development of large systems.</p><p>The ZCA works by encapsulating the functionality of a Python object into an entity called a<span class="strong"><strong> component</strong></span>, which has a well-defined behavior that can be described by using a separate object, known as an<span class="strong"><strong> interface</strong></span>. The interface helps the developer to find out how to use a given component, or even replace it wholesale by implementing all of the functionality expressed therein.<a id="id358" class="indexterm"/>
</p><p>Because the concept of breaking up the functionality of a system into multiple components requires the developer to keep track of a potentially large number of components, the ZCA offers a registry that can register and retrieve components based on their interfaces. This is truly the key part of the Zope Component Architecture, as working with it mainly consists of interacting with the registry in various ways.</p><div class="section" title="Interfaces"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec01"/>Interfaces</h2></div></div></div><p>We introduced 'interfaces' in Chapter 5, when we used them for automatically generating forms. In that chapter, we explained that an interface is used to document the external behavior of objects.<a id="id359" class="indexterm"/>
</p><p>An object that has its functionality defined in an interface is said to<span class="emphasis"><em> provide</em></span> this interface. The interface defines what an object can do, but how the object internally complies with this contract is entirely decided by the implementor.</p><p>Interfaces in the ZCA are used to register and find components in the registry. This allows us to find components on the basis of what they do, and easily replace, extend, or override a specific functionality in an application.</p><p>When a class includes the functionality described in an interface, it is said to<span class="emphasis"><em> implement</em></span> that interface. The interface is independent of the class, though. One specific interface may be implemented by any number of classes. In addition, a class can implement any number of interfaces.</p><p>Let's take a look at the interface that we defined in Chapter 6, to make the projects, lists, and items searchable:<a id="id360" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">class ISearchable(interface.Interface):
title = interface.Attribute('title')
kind = interface.Attribute('kind')
description = interface.Attribute('description')
creator = interface.Attribute('creator')
creation_date = interface.Attribute('creation date')
modification_date = interface.Attribute('modification date')
checked = interface.Attribute('checked')
content_type = interface.Attribute('content type')
project_name = interface.Attribute('project name')
def searchableText():
"""return concatenated string with all text fields to search"""
</pre></div><p>An interface is a class that subclasses the<code class="literal"> Interface</code> class defined in the<code class="literal"> zope.interface</code> package. The<code class="literal"> ISearchable</code> interface describes the attributes and methods that a searchable object must provide. Similar to our to-do list application, we may have several different content types, but as long as all of their class definitions promise to implement<code class="literal"> ISearchable</code>, we can use the same search code on them without problems.<a id="id361" class="indexterm"/>
</p><p>Notice how the<code class="literal"> searchableText</code> method definition does not contain the<code class="literal"> self</code> parameter that is used in Python classes. That's because although the interface documents the methods, it will never be instantiated itself, and so<code class="literal"> self</code> is not required here.<a id="id362" class="indexterm"/>
</p><p>Once we have defined an interface, we can create the classes that implement it. In our application, the<code class="literal"> ISearchable</code> interface is implemented by several classes. For example, here's how the<code class="literal"> Project</code> content type declares its intention of abiding by the<code class="literal"> ISearchable</code> contract:</p><div class="informalexample"><pre class="programlisting">class Project(grok.Container):
grok.implements(IProject, IMetadata, ISearchable)
</pre></div><p>In Grok, we use the<code class="literal"> implements</code> class annotation to declare that a class implements one or more interfaces. We can see that, in addition to<code class="literal"> ISearchable</code>, the<code class="literal"> Project</code> class also implements<code class="literal"> IProject</code> and<code class="literal"> IMetadata</code>.</p><p>Once we create an actual<code class="literal"> Project</code> object, it is said to<span class="emphasis"><em> provide</em></span>
<code class="literal"> ISearchable</code>, which means that classes implement interfaces, and instances of those classes provide them.<a id="id363" class="indexterm"/>
</p><p>An interface can also be used to define schemata for form generation. We have used this a lot throughout our application's code. Here's an example:</p><div class="informalexample"><pre class="programlisting">class ITodoList(interface.Interface):
title = schema.TextLine(title=u'Title', required=True, constraint=check_title)
description = schema.Text(title=u'Description', required=False)
next_id = schema.Int(title=u'Next id' ,default=0)
</pre></div><p>We already saw that by using the<code class="literal"> grok.AutoFields</code> directive, we can turn this schema definition into HTML controls on a form.<a id="id364" class="indexterm"/>
</p><p>Because interfaces are used as keys in the component registry, it's possible to find all of the objects that implement an interface. This comes in handy for finding objects belonging to some type, but can also be used for more interesting things, such as creating methods that work only with objects that provide an interface, or components that extend the functionality of any class that implements it.</p><p>This is generally useful when no special functionality needs to be defined for some interface, so sometimes we can come across empty interface definitions, known as<span class="strong"><strong> marker interfaces</strong></span>. They basically mark an object as belonging to a certain type, which allows the registry to find them and register other components to work with them. We have not needed them so far in our application, but they can be a very useful addition to our arsenal.<a id="id365" class="indexterm"/>
</p></div><div class="section" title="Adapters"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec02"/>Adapters</h2></div></div></div><p>One of the principles of the ZCA is to use components instead of inheritance for extending application behavior, so that we can interconnect different components with each other to get the desired result.<a id="id366" class="indexterm"/>
</p><p>This approach requires three things:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Well-defined components, which is why we use interfaces. They mark a component as providing a specific behavior and also offer a sort of blueprint or contract for that functionality.</li><li class="listitem" style="list-style-type: disc">An easy way to keep track of multiple components. We already mentioned that the ZCA has a registry, and that interfaces are used as keys to retrieve the components according to their defined functionality. This also makes possible the complete replacement of a component for an entirely different one as long as it implements the same interface.</li><li class="listitem" style="list-style-type: disc">A way to make disparate components work together even if they have completely different interfaces. That's where adapters come in.</li></ul></div><p>An<span class="strong"><strong> adapter</strong></span> is simply a piece of code that takes an object with a certain interface and makes it provide an additional interface. In other words, it adapts the component, so that it offers new behavior, without requiring any change in its code.<a id="id367" class="indexterm"/>
</p><div class="section" title="Real-world adapters"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec01"/>Real-world adapters</h3></div></div></div><p>It may be helpful to think of this in terms of real-world objects. Nowadays, cellphones are ubiquitous, and many people depend on them for their communication needs. However, they have a pretty short battery life and need constant recharging. When we buy a new cellphone, we usually get an AC adapter, which allows us to plug the phone into any wall outlet and charge it. In some cases, we may not have access to a wall outlet, for example, during a long car trip. In such a situation, we can of course get a car adapter to charge the phone by using the vehicle's power outlet.<a id="id368" class="indexterm"/>
</p><p>Adapters for the ZCA are very similar to these phone adapters. They adapt a power source, be it the car or the wall outlet, and make it present in a different interface that can be used by the phone to get charged. Neither the power source nor the phone are changed in the least, or even need to know anything about the specific adapter used, as long as they conform to the established power and phone connection interfaces (now you see where the terminology came from).</p></div><div class="section" title="Defining and using an adapter"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec02"/>Defining and using an adapter</h3></div></div></div><p>Up to now, we have not explicitly defined or used an adapter, so let's take a quick look at how we would do this in Grok. Suppose that we want to show the number of days elapsed since the last modification to any content in our to-do list application. If we add the methods to each content type, we'll have a lot of repeated code, and any change to one method's logic would require making a change to all of the content types. By using an adapter, we get all of the code in one place, as shown below:<a id="id369" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">import datetime
class IDayCalculations(Interface):
def daysOld():
"number of days since the content was created"
def daysFromLastModification():
"number of days since the last modification"
class DaysOld(grok.Adapter):
grok.implements(IDayCalculations)
grok.adapts(ISearchable)
def daysOld(self):
return (datetime.datetime.now() - self.context.creation_date).days
def daysFromLastModification(self):
return (datetime.datetime.now() - self.context.modification_date).days
</pre></div><p>First, we define the interface for our 'day' calculation methods. We'll keep it simple, for demonstration purposes. The<code class="literal"> grok.Adapter</code> component is used to define an adapter. We create one, and use the<code class="literal"> grok.implements</code> directive to signal that it will implement the methods that we just defined in our interface.<a id="id370" class="indexterm"/>
</p><p>All of the content in our application already implements the<code class="literal"> ISearchable</code> interface, so to make every to-do application object provide this interface, we use the<code class="literal"> grok.adapts</code> directive. Thus,<code class="literal"> DaysOld</code> is an adapter that takes any object that provides<code class="literal"> ISearchable</code>, and provides<code class="literal"> IDayCalculations</code> for it.<a id="id371" class="indexterm"/>
</p><p>The adapter instance will have both the<code class="literal"> context</code> and the<code class="literal"> request</code> attributes. This is because an adapter always receives, as parameters, the things that it adapts, in order to be able to get at their properties and use them in the implementation. In this example,<code class="literal"> self.context</code> refers to the adapted<code class="literal"> context</code> object, which can be a<code class="literal"> TodoList</code>, a<code class="literal"> Project</code>, a<code class="literal"> TodoListItem</code>, and so on. As all of these objects implement<code class="literal"> ISearchable</code>, we know that<code class="literal"> modification_date</code> and<code class="literal"> creation_date</code> will be available for the calculations.</p><p>We could use this adapter inside any view for one of our content types, in the following way:<a id="id372" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">class ProjectView(grok.View):
grok.context(Project)
def update(self):
self.days_old = IDayCalculations(self.context).daysOld()
self.days_modified = IDayCalculations( self.context).daysFromLastModification()
</pre></div><p>In this example, we use the<code class="literal"> update</code> method to insert the<code class="literal"> days_modified</code> and<code class="literal"> days_old</code> properties into the view, so that they will be available to the view template, when it's rendered. To get the adapter from the registry, we call the<code class="literal"> IDayCalculations</code> interface itself, with the<code class="literal"> context</code> object as parameter, which in this case is a<code class="literal"> Project</code>. Once we have the adapter, we can simply call its methods, and it will behave as if these methods are a part of the<code class="literal"> Project</code> component.<a id="id373" class="indexterm"/>
</p><p>When first getting to know them, adapters might seem to be sort of a roundabout way of getting to the component that we need, but bear in mind that this whole system is designed for easy expansion and evolution. By using adapters, we could override components from within other packages and still have the system work fine without needing to modify the original code in any way.</p></div><div class="section" title="Adapters that we have used in our application"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec03"/>Adapters that we have used in our application</h3></div></div></div><p>For adapters to be used in Grok, they first need to be registered with the ZCA. Grok itself performs a number of registrations when the application is started. In fact, we have used these already in our code. In Chapter 7, we added authentication to our application and we decided to add specific roles to every new user that was created, to simplify permission management.<a id="id374" class="indexterm"/>
</p><p>A Grok site knows nothing about role assignment, so to be able to define roles for a principal, it uses a role manager. This<span class="strong"><strong> role manager</strong></span> is an adapter that enables the site to provide the role manager interface. Take a look at the code that we used:</p><div class="informalexample"><pre class="programlisting">def addUser(self, username, password, real_name, role):
session = Session()
result = session.query(Account).filter_by(name = username).first()
if result is None:
user = Account(username, password, real_name, role)
session.add(user)
role_manager = IPrincipalRoleManager(grok.getSite())
if role==u'Project Manager':
role_manager.assignRoleToPrincipal('todo.ProjectManager', username)
elif role==u'Application Manager':
role_manager.assignRoleToPrincipal('todo.AppManager', username)
else:
role_manager.assignRoleToPrincipal('todo.ProjectMember', username )
transaction.commit()
</pre></div><p>Here, we are adding a new user, and immediately after that, we are assigning a role to the user. As we mentioned earlier, the site delegates this responsibility to a role manager. The role manager is an adapter that is registered as implementing the<code class="literal"> IPrincipalRoleManager</code> interface for Grok sites, so we need to query the registry with this information to get the actual manager. The line that does this is:</p><div class="informalexample"><pre class="programlisting">role_manager = IPrincipalRoleManager(grok.getSite())
</pre></div><p>The interface itself performs the registry lookup, asking for a component that is registered for providing it to objects that implement the Grok site interface. Note that the Grok site itself is passed in as a parameter and not its interface, but the ZCA is smart enough to find the correct component, if it's registered.</p><p>In this case, the query gets us a role manager object that implements the<code class="literal"> IPrincipalRoleManager</code> interface, so that we know that the<code class="literal"> assignRoleToPrincipal</code> method will be available to assign the correct role to our new user.<a id="id375" class="indexterm"/>
</p><p>Adapters can be named, so that we could use its name to get a specific<code class="literal"> IPrincipalRoleManager</code> component. Also, it's possible for an adapter to adapt more than one component at the same time, in which case, it's called a<span class="strong"><strong> multiadapter</strong></span>. For example, all of the views in Grok are multiadapters for a request and a context:<a id="id376" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">class TodoListUpdateItems(grok.View):
grok.context(TodoList)
grok.name('updateitems')
grok.require('todo.changeitems')
</pre></div><p>The context is specified in the class body by using the<code class="literal"> grok.context</code> directive, and the request refers to the current browser request. In the preceding code,<code class="literal"> TodoListUpdateItems</code> is a multiadapter for a request and a<code class="literal"> TodoList</code>. It uses the name<code class="literal"> updateitems</code>. This multiadapter/view will be called by Grok only when the user requests the<code class="literal"> updateitems</code> view while browsing through a<code class="literal"> TodoList</code> object.<a id="id377" class="indexterm"/>
</p><p>We have also used multiadapters explicitly in our to-do list manager code:</p><div class="informalexample"><pre class="programlisting">class AddProjectViewlet(grok.Viewlet):
grok.viewletmanager(Main)
grok.context(Todo)
grok.view(AddProject)
def update(self):
self.form = getMultiAdapter((self.context, self.request), name='add')
self.form.update_form()
def render(self):
</pre></div><p>In Chapter 8, we showed how to get a form that is rendered inside a viewlet, and saw that we needed to get at the specific component that creates that specific form. Here, the registry lookup is performed by the<code class="literal"> getMultiAdapter</code> method, which is imported from<code class="literal"> zope.component</code>. We specifically want the 'add form' for a project, because we want to render the<code class="literal"> AddProjectViewlet</code>. We know that we have a request and that the context is a<code class="literal"> Todo</code> application, due to the<code class="literal"> grok.context</code> directive above, so if we call<code class="literal"> getMultiAdapter</code> and pass the request and the context along with the name of the required form, the ZCA machinery will find it for us.<a id="id378" class="indexterm"/>
</p></div></div><div class="section" title="Utilities"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec03"/>Utilities</h2></div></div></div><p>As we have seen, the component registry mainly consists of adapters that are registered to specific interfaces. In some cases, it's also useful to register components that do not adapt anything, but provide some sort of service that we need to be able to override or replace. A database connection, an authentication backend, and a user source are examples of this.<a id="id379" class="indexterm"/>
</p><p>The ZCA has the concept of a utility to cover this case. A<span class="strong"><strong> utility</strong></span> is simply a component with a declared interface, which may also have a name. Utilities in the ZCA can be either local or global.</p><div class="section" title="Global utilities"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec04"/>Global utilities</h3></div></div></div><p>A<span class="strong"><strong> global utility</strong></span> is the one that is created and registered when Grok is started, but which is not persistent (that is, its state is not saved in the ZODB). Examples of global utilities that we have used include database connections and session credentials.<a id="id380" class="indexterm"/>
</p><p>Let's take a look at the utility that we added in Chapter 7, when we integrated authentication services into our application:</p><div class="informalexample"><pre class="programlisting">class MySessionCredentialsPlugin(grok.GlobalUtility, SessionCredentialsPlugin):
grok.provides(ICredentialsPlugin)
grok.name('credentials')
loginpagename = 'login'
loginfield = 'login'
passwordfield = 'password'
</pre></div><p>To define a global utility, we inherit from the<code class="literal"> grok.GlobalUtility</code> component and declare the interface provided by the component, by using the<code class="literal"> grok.provides</code> directive. Named utilities also need to use the<code class="literal"> grok.name</code> directive to register their names.<a id="id381" class="indexterm"/>
</p><p>To get a global utility from the registry, we use the<code class="literal"> getUtility</code> function defined in<code class="literal"> zope.component</code>. In this case, the<code class="literal"> credentials</code> utility is not called directly by our code, but by the authentication mechanism itself. However, if we wanted to use this utility, we would get it as follows:<a id="id382" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">from zope.component import getUtility
credentials_plugin = getUtility(ICredentialsPlugin, 'credentials')
</pre></div></div><div class="section" title="Local utilities"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec05"/>Local utilities</h3></div></div></div><p>A<span class="strong"><strong> local utility</strong></span> is very similar to a global utility, but it gets saved in the database, so that its state and configuration are persistent. The Zope Toolkit catalog and the pluggable authentication mechanism used in our application are both examples of local utilities.<a id="id383" class="indexterm"/>
</p><p>We can take a look at the<code class="literal"> UserAuthenticatorPlugin</code> that we defined in Chapter 7, to see how to define a local utility:<a id="id384" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">class UserAuthenticatorPlugin(grok.LocalUtility):
grok.implements(IAuthenticatorPlugin)
grok.name('users')
</pre></div><p>We can see that this works exactly the same way as a global utility does, except that we inherit from<code class="literal"> grok.LocalUtility</code> instead. However, we can't actually use a local utility until we explicitly add it to a<code class="literal"> grok.Container</code> component. Take a look at the main application component for the<code class="literal"> Todo</code> application:<a id="id385" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">class Todo(grok.Application, grok.Container):
grok.implements(ITodo)
grok.local_utility(
UserAuthenticatorPlugin, provides=IAuthenticatorPlugin,
name='users',
)
grok.local_utility(
PluggableAuthentication, provides=IAuthentication,
setup=setup_authentication,
)
<a id="id386" class="indexterm"/>
</pre></div><p>Our application contains two local utilities. There is a<code class="literal"> UserAuthenticatorPlugin</code> utility, which is named, as we may want to work with several user sources. There is also a<code class="literal"> PluggableAuthentication</code> utility, which will handle all of the authentication needs for our site, and thus does not need to be differentiated from other similar utilities by name.<a id="id387" class="indexterm"/>
</p><p>In fact, our application also contains a third local utility, the "Catalog", which is added automatically by Grok upon application creation. The Catalog is not a named utility.</p><p>To work with any of these utilities, we use the same<code class="literal"> getUtility</code> function that we used for our global utility:<a id="id388" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">users = component.getUtility(IAuthenticatorPlugin, 'users')
auth = component.getUtility(IAuthentication)
</pre></div><p>One very important thing to keep in mind about local utilities is that, because they are added at an application's creation time and stored in the database, changing the initialization code of one will have no effect once the application is created. The easiest way to get a modified local utility to work, in this case, is to delete the application instance and create it again.<a id="id389" class="indexterm"/>
</p></div></div><div class="section" title="Events"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec04"/>Events</h2></div></div></div><p>The Zope Toolkit defines a series of life cycle events that are fired whenever certain operations are performed on an object, such as creation or modification. An<span class="strong"><strong> event</strong></span> can have one or more subscribers, which are called whenever the subscribed event takes place. These subscribers are known as<span class="strong"><strong> event handlers</strong></span>, and Grok offers an easy way of defining them.<a id="id390" class="indexterm"/>
</p><p>Here are some of the events that we can subscribe to by using Grok:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Event</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th><th style="text-align: left" valign="bottom">
<p>Event attributes</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">IObjectModifiedEvent</code>
</p>
</td><td style="text-align: left" valign="top">
<p>An object has been modified. This is a general event that encompasses any change to a persistent object, such as adding, moving, copying, or removing objects.</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">object</code>
</p>
<p>
<code class="literal">descriptions</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">IContainerModifiedEvent</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The container has been modified. Container modifications are specific to addition, removal, or reordering of subobjects. Inherits from<code class="literal"> grok.IObjectModifiedEvent.</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">object</code>
</p>
<p>
<code class="literal">descriptions</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">IObjectMovedEvent</code>
</p>
</td><td style="text-align: left" valign="top">
<p>An object has been moved.</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">object</code>
</p>
<p>
<code class="literal">oldParent</code>
</p>
<p>
<code class="literal">oldName</code>
</p>
<p>
<code class="literal">newParent</code>
</p>
<p>
<code class="literal">newName</code>
</p>
</td></tr><tr><td style="text-align: left" valign="bottom">
<p>Event</p>
</td><td style="text-align: left" valign="bottom">
<p>Description</p>
</td><td style="text-align: left" valign="bottom">
<p>Event attributes</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">IObjectAddedEvent</code>
</p>
</td><td style="text-align: left" valign="top">
<p>An object has been added to a container.</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">object</code>
</p>
<p>
<code class="literal">oldParent</code>
</p>
<p>
<code class="literal">oldName</code>
</p>
<p>
<code class="literal">newParent</code>
</p>
<p>
<code class="literal">newName</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">IObjectCopiedEvent</code>
</p>
</td><td style="text-align: left" valign="top">
<p>An object has been copied.</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">object</code>
</p>
<p>
<code class="literal">original</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">IObjectCreatedEvent</code>
</p>
</td><td style="text-align: left" valign="top">
<p>An object has been created. This event is intended to happen before an object has been made persistent, that is, its location attributes (__name__ and<code class="literal"> __parent__)</code> will usually be<code class="literal"> None.</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">object</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">IObjectRemovedEvent</code>
</p>
</td><td style="text-align: left" valign="top">
<p>An object has been removed from a container.</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">object</code>
</p>
<p>
<code class="literal">oldParent</code>
</p>
<p>
<code class="literal">oldName</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">IBeforeTraverseEvent</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The publisher is about to traverse an object.</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">object</code>
</p>
<p>
<code class="literal">request</code>
</p>
</td></tr></tbody></table></div><p>We can define an event handler in Grok by using the<code class="literal"> grok.subscriber</code> decorator:<a id="id391" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">@grok.subscribe(Project, grok.IObjectAddedEvent)
def handler(obj, event):
"New project added: %s." % obj.title
</pre></div><p>This code will be executed every time a new<code class="literal"> Project</code> is added to a container. The handler receives two parameters<code class="literal"> obj</code>, which contains the object involved, and<code class="literal"> event</code>, which contains the attributes that are listed in the preceding table.</p><p>As the subscription is really a kind of adapter, the first parameter to the<code class="literal"> grok.subscribe</code> decorator can be any interface, thus allowing us to make the subscription as general or specific as we like. In the earlier example, we passed<code class="literal"> Project</code> as a parameter, so the handler will be executed only when a<code class="literal"> Project</code> is added, but we could pass<code class="literal"> Interface</code> instead, in order to get all of the occurrences of the event, regardless of the object type. There can be additional subscribers to the same event, but the order in which they are called cannot be known in advance, so never depend on it.</p></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Extending a Grok application from the outside"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec02"/>Extending a Grok application from the outside</h1></div></div></div><p>Without a doubt, one of the nicest features of the Zope Component Architecture is that it makes it very easy to extend or override the functionality of an application without having to touch its code.<a id="id392" class="indexterm"/>
</p><p>Many Grok components, such as views and utilities, are ready to be overriden without the developer having to do anything special. Other objects, such as viewlets, may need small modifications to add new functionality.</p><p>In this section, we are going to show, how easy it is to extend a Grok application from the outside, simply by creating an independent package that adds new functionality to our to-do application. The knowledge that we just obtained about the ZCA will come in handy for this task, so that hopefully we understand it a little better when our add-on is ready.<a id="id393" class="indexterm"/>
</p><div class="section" title="Preparing the original application"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec05"/>Preparing the original application</h2></div></div></div><p>This demonstration will, of course, be more convincing if we keep modifications to the original application to a minimum. Fortunately, we need to make only one small addition to the<code class="literal"> app.py</code> module, and a simple modification to the<code class="literal"> navigation.pt</code> template.<a id="id394" class="indexterm"/>
</p><p>Add the following two lines at the top of<code class="literal"> app.py</code>, just below the<code class="literal"> import</code> statements:</p><div class="informalexample"><pre class="programlisting">master_template = grok.PageTemplateFile('app_templates/master.pt')
form_template = grok.PageTemplateFile('custom_edit_form.pt')
</pre></div><p>This will allow us to use the master page and the form templates in the new application, by using a simple<code class="literal"> import</code> statement.</p><p>The only other change that we will make is to add an extra viewlet manager to the navigation viewlet, so that other applications can easily insert navigation options there. To do this, we need to add the viewlet manager definition to<code class="literal"> app.py</code>, as shown below:</p><div class="informalexample"><pre class="programlisting">class ExtraNav(grok.ViewletManager):
grok.context(Interface)
grok.name('extranav')
</pre></div><p>We also need to modify the navigation template to take into account the new viewlet manager. Change<code class="literal"> app_templates/navigation.pt</code> to look like this:</p><div class="informalexample"><pre class="programlisting">&lt;div id="navigation"&gt;
&lt;a tal:attributes="href python:view.application_url('index')"&gt; Go back to main page&lt;/a&gt;
&lt;tal:extranav content="structure provider:extranav" /&gt;
&lt;/div&gt;
</pre></div><p>The only thing that we added here is the "provider" line, to insert new viewlets after the link, to go back to the main page.</p><p>This is all that we need to do in order to leave the to-do application ready for extension by third-party packages. Of course, we could have added this code there from the beginning, but it's instructive to show how little code you have to add, even if you didn't think in terms of extensibility from the start.</p></div><div class="section" title="The to-do plus package"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec06"/>The to-do plus package</h2></div></div></div><p>Imagine that we just found the to-do application somewhere on the net, and we think that it satisfies almost all of our requirements for a list manager, if only it had a couple of more features.<a id="id395" class="indexterm"/>
</p><p>The code is available, so we could just extend the application directly. However, as we don't control its development, we basically are forking the code, which means that any new features added to the application by their original developers would need to be merged into our code in order for us to take advantage of them. Also, the code style for the original application might be different to the one that we are comfortable with, and we don't want to have mixed styles.</p><p>What would be best for us is to create a completely independent package that extends the original application, and is under our complete control. If we really don't need to modify the original application heavily, this is the way to go. Let's create a "to-do plus" package that adds a few features to the existing "to-do" package, which we'll declare as a dependency.</p><div class="section" title="Creating the new package"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec06"/>Creating the new package</h3></div></div></div><p>In real life, the to-do package would be available as an "egg" that we could use in a new Grok project, but as we are still in the development stage here, we'll just add a new package to our project, instead of creating another one.<a id="id396" class="indexterm"/>
</p><p>The<code class="literal"> buildout</code> created by the grokproject script that we used to initialize our project has a<code class="literal"> src</code> directory to which we can add our new package. Go into that directory, and type the following command:</p><div class="informalexample"><pre class="programlisting">$ ../bin/paster create -t basic_package todo_plus
</pre></div><p>This script will ask a few questions, but for now, you can just press the<span class="emphasis"><em> Enter</em></span> key after every question, to accept the default values. A new directory, called<code class="literal"> todo_plus</code> will be created. This directory will contain our new package.</p><p>First, we need to make sure that this package gets grokked at startup time, so we include<code class="literal"> grok</code>, and grok the current package. As this package depends on the existence of the original<code class="literal"> todo</code> application, we have to make sure that its dependencies are grokked as well. Create a<code class="literal"> configure.zcml</code> file inside the<code class="literal"> todo_plus/todo_plus</code> directory, with the following contents:</p><div class="informalexample"><pre class="programlisting">&lt;configure   &gt;
&lt;include package="grok" /&gt;
&lt;includeDependencies package="." /&gt;
&lt;grok:grok package="." /&gt;
&lt;/configure&gt;
</pre></div><p>Notice that, unlike the<code class="literal"> todo</code> package created for our original project, the<code class="literal"> todo_plus</code> package has two subdirectory levels, so be careful to create this file inside the second level<code class="literal"> todo_plus</code> directory.</p><p>Next, create the<code class="literal"> app_templates</code> and the<code class="literal"> static</code> directories that are used by Grok applications:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ mkdir todo_plus/todo_plus/app_templates
$ mkdir todo_plus/todo_plus/static
</strong></span>
</pre></div><p>Also, you must add the<code class="literal"> todo</code> package to the<code class="literal"> requires</code> section in the<code class="literal"> todo_plus/setup.py</code> file, as follows:</p><div class="informalexample"><pre class="programlisting">install_requires=[
'todo',
]
</pre></div><p>Finally, the <code class="literal">buildout.cfg</code> file needs to be updated to include the new package. This is how the top of the file should look after the<code class="literal"> todo_plus</code> package has been added in the required parts (buildout will be discussed in more detail in Chapter 14):<a id="id397" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">[buildout]
develop = .
src/todo_plus
parts = eggbasket app i18n test data log
newest = false
extends = versions.cfg
# eggs will be installed in the default buildout location
# (see .buildout/default.cfg in your home directory)
# unless you specify an eggs-directory option here.
find-links = http://download.zope.org/distribution/
versions = versions
[app]
recipe = zc.recipe.egg
eggs = todo
todo_plus
z3c.evalexception&gt;=2.0
Paste
PasteScript
PasteDeploy
interpreter = python-console
site.zcml = &lt;include package="todo_plus" /&gt;
</pre></div><p>In the<code class="literal"> develop</code> line, we are telling<code class="literal"> buildout</code> that, in addition to the package in the current directory (that is, the<code class="literal"> todo</code> package itself), we'll be adding our new<code class="literal"> todo_plus</code> development package. This will create a development "egg" for<code class="literal"> todo_plus</code>, which should be added below the eggs line in the<code class="literal"> [app]</code> section, right under the original todo package.</p><p>Now we can rerun the<code class="literal"> buildout</code> and our package will be ready to work:</p><div class="informalexample"><pre class="programlisting">$ bin/buildout
<a id="id398" class="indexterm"/>
</pre></div></div></div><div class="section" title="Adding a skin chooser form to the application"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec07"/>Adding a skin chooser form to the application</h2></div></div></div><p>In Chapter 8, we added themes to our application, although the only way to look at a different theme than the default was to use the ugly<code class="literal"> ++skin++</code> traversal helper in the URL. As we had mentioned then, we don't want the user to do that, so a way to select the desired skin from a form would be neat.<a id="id399" class="indexterm"/>
</p><p>Let's make that the first feature our<code class="literal"> todo_plus</code> package will add to the to-do list application. The objective is to have a form where we get a list of available screens, pick one, and then save it. After that, Grok should automatically use the chosen skin when we navigate through the to-do application.</p><div class="section" title="Adding a new skin"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec07"/>Adding a new skin</h3></div></div></div><p>First, we'll have our package include its own skin layer to add to the three skins available in the original application. Of course, there are a few things we need to import from the to-do application, but it's all very straightforward. Create a file named<code class="literal"> app.py</code> inside the<code class="literal"> src/todo_plus/todo_plus</code> directory, and add the following lines of code to it:<a id="id400" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">import grok
from zope.interface import Interface
from zope.publisher.interfaces.browser import IBrowserSkinType, IDefaultBrowserLayer
from todo.app import ITodo, IProject, Todo, HeadSlot, ExtraNav, Main, master_template, form_template
class PlusLayer(IDefaultBrowserLayer):
grok.skin('plus')
class HeadPlus(grok.Viewlet):
grok.viewletmanager(HeadSlot)
grok.context(Interface)
grok.name('head')
grok.template('head_plus')
grok.layer(PlusLayer)
</pre></div><p>Because we need to add a viewlet to the<code class="literal"> HeadSlot</code> for this skin layer, we have to import it from<code class="literal"> todo.app</code>. Everything else that we need, we already did in Chapter 8. We add a new layer and turn it into a skin by using the<code class="literal"> grok.skin</code> directive. After that, we add a viewlet and register it with the name 'head' for this layer, overriding the original viewlet from the default skin. Of course, we need a template for the new viewlet. Add the following code to<code class="literal"> app_templates/head_plus</code>, at the top:</p><div class="informalexample"><pre class="programlisting">&lt;meta tal:attributes="http-equiv string:Content-Type; content string:text/html;; charset=utf-8" /&gt;
&lt;title tal:content="context/title"&gt;To-Do list manager&lt;/title&gt;
&lt;link rel="stylesheet" type="text/css" tal:attributes="href static/styles_plus.css" /&gt;
</pre></div><p>Finally, we can copy the<code class="literal"> styles.css</code> file from the original app and save it as<code class="literal"> styles_plus.css</code>. To keep it simple, as we did in Chapter 8, make some obvious modifications, such as changing the header background color, and leave it at that for now.</p><p>Restart the to-do application normally, by using paster and then navigate to <a class="ulink" href="http://localhost/++skin++plus/todo/index">http://localhost/++skin++plus/todo/index</a>, and you'll see the new skin. That's it. Not bad for a simple warm-up. Working from a completely separate package, we have added a new skin that transparently integrates with the to-do application.<a id="id401" class="indexterm"/>
</p></div><div class="section" title="The skin chooser form"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec08"/>The skin chooser form</h3></div></div></div><p>Now, we are ready to add the form. We need a drop-down list with the names of all of the available skins, which currently are Basic (the default), martian, forest, and plus. We can use a<code class="literal"> schema.Choice</code> field and pass these values to it, but then, if the original application adds a new skin or a third party comes up with another add-on package that has new skins, our skin list will be outdated. We need a dynamic way to specify the skin name values, so that we don't have to keep track of all of the skin names in the code.<a id="id402" class="indexterm"/>
</p><p>Fortunately, as we will frequently find out when we want to add new functionality to a Grok application, the Zope Toolkit already has a package called<code class="literal"> zc.sourcefactory</code> that can help us in this situation. We can use this package by adding it to the<code class="literal"> install_requires</code> section of the<code class="literal"> src/todo_plus/setup.py</code> file, as follows:</p><div class="informalexample"><pre class="programlisting">install_requires=[
'todo',
'zc.sourcefactory',
]
</pre></div><p>Rerun the<code class="literal"> buildout</code> and the package will be downloaded and installed, as usual. We can now use it to define a dynamic choice field:</p><div class="informalexample"><pre class="programlisting">from zope import schema
from zope.component import getAllUtilitiesRegisteredFor, getMultiAdapter, getUtility
from zc.sourcefactory.basic import BasicSourceFactory
class SkinNameSource(BasicSourceFactory):
def getValues(self):
values = ['Basic']
skin_tag = 'grokcore.view.directive.skin'
skin_names = [s.getTaggedValue(skin_tag)
for s in getAllUtilitiesRegisteredFor(IBrowserSkinType) if skin_tag in s.getTaggedValueTags()]
values.extend(skin_names)
return values
class ISkinChooser(Interface):
skin_name = schema.Choice(source=SkinNameSource(), title=u'Skin Name', description=u'Name of the new default skin')
</pre></div><p>A<span class="strong"><strong> source</strong></span> is simply a method that returns a list of values to be used inside a schema field, instead of static lists. The<code class="literal"> BasicSourceFactory</code> subclass is used to define a source.<a id="id403" class="indexterm"/>
</p><p>We have created a form schemata earlier, so the only new thing in the<code class="literal"> ISkinChooser</code> schema definition is the<code class="literal"> source=SkinNameSource()</code> parameter in the<code class="literal"> Choice</code> field. This tells Grok to use a source factory named<code class="literal"> SkinNameSource</code> to provide the skin name values.<a id="id404" class="indexterm"/>
</p><p>To create a source, we just subclass from<code class="literal"> BasicSourceFactory</code>, and add a<code class="literal"> getValues</code> method that will return a list of the skin names. To get the skin names themselves, we have to use the component registry. In Zope, a skin is registered as a named utility with the interface<code class="literal"> IBrowserSkinType</code> and the skin name.<a id="id405" class="indexterm"/>
</p><p>How do we get all of the utilities registered for this interface? The<code class="literal"> zope.component</code> package includes a function called<code class="literal"> getAllUtilitiesRegisteredFor</code> that does this. To distinguish them from the Zope skins, Grok adds a tag to its skin components that identify them as Grok layers. This tag is the<code class="literal"> grokcore.view.directive.skin</code> assigned to<code class="literal"> skin_tag</code> in the preceding code. To get the Grok skin names, we start with a list with the value 'Basic' in it, to account for the default skin, which is not tagged by Grok. We then go through every registered skin and check if it has<code class="literal"> skin_tag</code> on it. If it does, we add it to the list.</p><p>In this way, each time a new skin layer is added from a Grok package, it will automatically be listed in our 'skin chooser' form. The component registry takes care of the available skins for us.</p><p>Now we need to add the form, and also a<code class="literal"> SkinChooser</code> view and a viewlet that includes the form on it. We have done all of this in Chapter 8, so it should seem familiar:<a id="id406" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">from zope.app.session.interfaces import Isession
class SkinChooserForm(grok.Form):
grok.context(ITodo)
grok.name('skin_chooser_form')
form_fields = grok.AutoFields(ISkinChooser)
label = "Set the default skin for the To-Do list manager"
template = form_template
def setUpWidgets(self, ignore_request=False):
super(SkinChooserForm,self).setUpWidgets(ignore_request)
session = ISession(self.request)['todo_plus']
self.widgets['skin_name'].setRenderedValue(session.get( 'skin_name''Basic'))
@grok.action('Choose skin')
def choose(self, **data):
session = ISession(self.request)['todo_plus']
session['skin_name'] = data['skin_name']
return self.redirect(self.url('skin_chooser'))
class SkinChooser(grok.View):
grok.context(ITodo)
grok.name('skin_chooser')
grok.require('todo.changeitems')
def render(self):
return master_template.render(self)
class SkinChooserViewlet(grok.Viewlet):
grok.viewletmanager(Main)
grok.context(ITodo)
grok.view(SkinChooser)
def update(self):
self.form = getMultiAdapter((self.context, self.request), name='skin_chooser_form')
self.form.update_form()
def render(self):
return self.form.render()
</pre></div><p>The<code class="literal"> SkinChooserForm</code> inherits from<code class="literal"> grok.Form</code>, because we want a content-independent form. Its context is<code class="literal"> ITodo</code> to make it show up only at the root application level. We use the fields defined in the<code class="literal"> ISkinChooser</code> interface that we created earlier.</p><p>We need a way to store the skin selection so that it is available when the user navigates through the application. For this, we'll use the session mechanism that is defined in the<code class="literal"> zope.app.session</code> package (yeah, the Zope Toolkit to the rescue, again). The session is an adapter for the request, so we can get it by issuing an<code class="literal"> ISession(self.request)</code>. We use the<code class="literal"> todo_plus</code> package name as a session key to avoid namespace clashes with other session objects.</p><p>In the<code class="literal"> updateWidgets</code> method of the form, we try to get the value for<code class="literal"> skin_name</code> from the session ('Basic' is returned, if<code class="literal"> skin_name</code> has not been initialized). With this value, we can show the currently selected skin on the form by calling<code class="literal"> setRenderedValue</code> on the choice widget.<a id="id407" class="indexterm"/>
</p><p>Finally, in the form action, we set the<code class="literal"> skin_name</code> key of our session to the value returned in the form data submitted by the user, and redirect the user to the 'skin chooser' view.</p><div class="mediaobject"><img src="images/7481_11_01.jpg" alt="The skin chooser form"/></div><p>The view and viewlet definitions contain nothing new, but notice how we use the components imported from the original to-do application to perform our registrations. The view is assigned<code class="literal"> ITodo</code> as its context, and the viewlet is registered with the Main viewlet manager from that package.</p></div><div class="section" title="Using events to show the selected skin"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec09"/>Using events to show the selected skin</h3></div></div></div><p>So far, we have a<code class="literal"> skin_chooser</code> form that can save the chosen skin name in the current session, but we still need to use that name to set the skin automatically on every page view. To do this, we will take advantage of Grok's event functionality, which is discussed in<span class="emphasis"><em> The Zope Component Architecture</em></span> section of this chapter.<a id="id408" class="indexterm"/>
</p><p>The ZCA provides an event registered with the interface<code class="literal"> IBeforeTraverseEvent</code> that we can use to set the skin on every request. Grok has a very convenient<code class="literal"> grok.subscribe</code> decorator that allows us to easily add a handler for this event:</p><div class="informalexample"><pre class="programlisting">from zope.app.publication.interfaces import IbeforeTraverseEvent
from zope.publisher.browser import applySkin
@grok.subscribe(ITodo, IBeforeTraverseEvent)
def choose_skin(obj, event):
session = ISession(event.request)['todo_plus']
skin_name = session.get('skin_name','Basic')
skin = getUtility(IBrowserSkinType,skin_name)
applySkin(event.request, skin)
</pre></div><p>We register the<code class="literal"> ITodo</code> interface with the<code class="literal"> IBeforeTraverse</code> event, which means that just before Grok shows a view inside the to-do application instance, our<code class="literal"> choose_skin</code> handler will be called.<a id="id409" class="indexterm"/>
</p><p>Inside the handler, we get the session object and find the skin name that is currently selected for that browser session. We then use the<code class="literal"> getUtility</code> function to get the actual skin object by using this name, and then set the skin by using the<code class="literal"> applySkin</code> function, which is imported from<code class="literal"> zope.publisher.browser</code>. The result is that the chosen skin will be set just in time, before a page is displayed.</p></div></div><div class="section" title="Sending e-mail notifications on content creation"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec08"/>Sending e-mail notifications on content creation</h2></div></div></div><p>One feature that is usually requested in multiuser systems, where users can act on other users' content, is e-mail notification of changes. Our to-do plus package will surely earn its 'plus' moniker if we add such a feature to it.<a id="id410" class="indexterm"/>
</p><p>We'll need a form for setting the notification properties, such as the destination e-mail and message subject. Of course, to keep the site layout consistent, we must also do our usual form-inside-a-viewlet registration dance. These are things that we already know how to do. More interesting is how we'll set up our e-mail handler by using an event subscription, and how the actual e-mail will be sent. Let's get going.<a id="id411" class="indexterm"/>
</p><p>For now, this feature will send notification messages to a specified list of e-mails, whenever a project is created. For this, we first need an interface definition for the form schema:</p><div class="informalexample"><pre class="programlisting">class ISetNotifications(Interface):
enabled = schema.Bool(title=u'Enable notifications', description=u'Email will only be sent if this is enabled')
sender = schema.TextLine(title=u'Sender email', description=u'Email address of sender application')
emails = schema.TextLine(title=u'Notification emails', description=u'One or more emails separated by commas')
subject = schema.TextLine(title=u'Message subject')
message = schema.Text(title=u'Message introduction')
</pre></div><p>The<code class="literal"> enabled</code> field will allow the manager to turn notifications on or off. If they are turned on, an e-mail with the specified message and<code class="literal"> subject</code> field information will be sent to the list of e-mails specified in the<code class="literal"> emails</code> field.<a id="id412" class="indexterm"/>
</p><div class="section" title="Object annotations"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec10"/>Object annotations</h3></div></div></div><p>Before we proceed with the form definition, we need to decide how to store the notification properties. We can't use the session, as we did with the skin chooser, because the notification properties will be global for the application. In fact, they could be considered as a part of the<code class="literal"> Todo</code> instance itself, so the ideal thing would be to store them there. But that would require changing the original code to add these properties, right?<a id="id413" class="indexterm"/>
</p><p>Well, no. Grok offers a special component called<code class="literal"> annotation</code> that can be used to store information inside a specific context object, without needing to alter it directly. This is accomplished by using a persistent adapter registered for the context object. That is, behind the scenes, there is an<code class="literal"> IAnnotation</code> interface that provides this writing service to any objects in the registry that implement the<code class="literal"> IAnnotatable</code> interface.<a id="id414" class="indexterm"/>
</p><p>As usual, Grok simplifies the setup with a convenient component that we can subclass, called<code class="literal"> grok.Annotation</code>. As discussed earlier, let's register our<code class="literal"> annotation</code> component to the main application's<code class="literal"> ITodo</code> interface:<a id="id415" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">class SetNotificationsAnnotation(grok.Annotation):
grok.implements(ISetNotifications)
grok.context(ITodo)
sender = 'grokadmin@example.com'
emails = ''
subject = 'New project created'
message = ''
enabled = False
</pre></div><p>The<code class="literal"> grok.context</code> directive indicates that annotations will be added to a component with the<code class="literal"> ITodo</code> interface, which we know is the main application object. The<code class="literal"> grok.implements</code> directive tells Grok to register this annotation adapter with the<code class="literal"> ISetNotifications</code> interface, which is how we'll find it in the registry. Notice that this interface is the same as the one that we'll use in the 'notification properties' form. The variables defined after that represent the default values for the stored properties.<a id="id416" class="indexterm"/>
</p></div><div class="section" title="Creating the form"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec11"/>Creating the form</h3></div></div></div><p>As we now know where the properties will be stored, we can go ahead and create the form. The code for the form definition looks like this:<a id="id417" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">class SetNotificationsForm(grok.Form):
grok.context(ITodo)
grok.name('set_notifications_form')
form_fields = grok.AutoFields(ISetNotifications)
label = 'Set email notification options'
template = form_template
def setUpWidgets(self, ignore_request=False):
super(SetNotificationsForm,self).setUpWidgets(ignore_request)
todo_annotation = ISetNotifications(self.context)
self.widgets['sender'].displayWidth = 80
self.widgets['emails'].displayWidth = 80
self.widgets['subject'].displayWidth = 50
self.widgets['message'].height = 7
self.widgets['emails'].setRenderedValue( ','.join(todo_annotation.emails))
self.widgets['enabled'].setRenderedValue( todo_annotation.enabled)
self.widgets['sender'].setRenderedValue( todo_annotation.sender)
self.widgets['message'].setRenderedValue( todo_annotation.message)
self.widgets['subject'].setRenderedValue( todo_annotation.subject)
@grok.action('Set notification options')
def set_options(self, **data):
todo_annotation = ISetNotifications(self.context)
todo_annotation.emails = data['emails'].split(',')
todo_annotation.enabled = data['enabled']
todo_annotation.subject = data['subject']
todo_annotation.message = data['message']
return self.redirect(self.url('set_notifications'))
</pre></div><p>We use the<code class="literal"> grok.AutoFields</code> directive to construct a form automatically, by using the fields that we previously defined in the<code class="literal"> ISetNotifications</code> interface. As with the<code class="literal"> skin_chooser</code> form, we use the form template imported from the original application, in order to keep the look and feel of the site, the same.<a id="id418" class="indexterm"/>
</p><p>In the<code class="literal"> setUpWidgets</code> method, we get the<code class="literal"> annotation</code> object with the<code class="literal"> ISetNotifications(self.context)</code> call, which searches the registry for an adapter that implements<code class="literal"> ISetNotification</code> and that is registered for the current context, which is the<code class="literal"> todo</code> application. Once we have that, we use the<code class="literal"> setRenderedValue</code> method of each widget to make the form show the currently stored value when the form is displayed. We also alter the size of the various text fields (although, at the moment, this is not important).<a id="id419" class="indexterm"/>
</p><p>In the<code class="literal"> set_options</code> form submit handler, we fetch the annotation object again, but this time we store the submitted values inside their corresponding properties. After that, we just redirect the user to the same form.</p><p>All that's left is to insert the form into a viewlet, and then add that viewlet to the<code class="literal"> Main</code> viewlet manager in a view. The code for that is as follows:<a id="id420" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">class SetNotifications(grok.View):
grok.context(ITodo)
grok.name('set_notifications')
grok.require('todo.addprojects')
def render(self):
return master_template.render(self)
class SetNotificationsViewlet(grok.Viewlet):
grok.viewletmanager(Main)
grok.context(ITodo)
grok.view(SetNotifications)
def update(self):
self.form = getMultiAdapter((self.context, self.request), name='set_notifications_form')
self.form.update_form()
def render(self):
return self.form.render()
</pre></div><p>There is nothing new here. Just note that the permission to add projects will be required to edit the "e-mail notification" properties. The following screenshot shows the form in action:</p><div class="mediaobject"><img src="images/7481_11_02.jpg" alt="Creating the form"/></div></div><div class="section" title="Sending the e-mail"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec12"/>Sending the e-mail</h3></div></div></div><p>To send the e-mail, we need an e-mail delivery mechanism. Of course, the Zope Toolkit has a package called<code class="literal"> zope.sendmail</code> that does this, so we just need to add this to our<code class="literal"> setup.py</code>, file and then rerun the<code class="literal"> buildout</code>, in order to use it. Edit the<code class="literal"> setup.py</code> file, and add it to the<code class="literal"> install_requires</code> line:<a id="id421" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">install_requires=[
'todo',
'zc.sourcefactory',
'zope.sendmail',
]
</pre></div><p>Rerun the<code class="literal"> buildout</code>. Now, we have to configure the mail delivery service. Unlike the Grok packages that we have used so far, this Zope Toolkit package requires configuration by using ZCML the XML-based Zope configuration language. Open the<code class="literal"> configure.zcml</code> file in the<code class="literal"> todo_plus</code> package, and modify it to look like this:</p><div class="informalexample"><pre class="programlisting">&lt;configure  xmlns:mail=http://namespaces.zope.org/mail &gt;
&lt;include package="grok" /&gt;
&lt;includeDependencies package="." /&gt;
&lt;grok:grok package="." /&gt;
&lt;mail:smtpMailer
name="todoplus.smtp"
hostname="mail.example.com"
port="25"
username="cguardia"
password="password"
/&gt;
&lt;mail:queuedDelivery
name="mailer"
permission="zope.Public"
mailer="todoplus.smtp"
queuePath="mailqueue"
/&gt;
&lt;/configure&gt;
</pre></div><p>Note the addition of the<code class="literal"> mail</code> namespace at the top of the file. This allows us to use the mail directives that appear after the normal Grok configuration. The<code class="literal"> smtpMailer</code> directive represents a named SMTP server. Its parameters are<code class="literal"> host, port, username</code>, and<code class="literal"> password</code>. If your mail host does not require a password, simply omit the<code class="literal"> username</code> and<code class="literal"> password</code> parameters.</p><p>The<code class="literal"> queuedDelivery</code> directive sets up a queue to use to send the mail messages. This gets done in an independent thread to allow the application to keep working even when numerous e-mails are sent. The<code class="literal"> permission</code> argument refers to the permission needed for sending e-mails. Be sure to use the same name for the<code class="literal"> mailer</code> parameter that was used in the SMTP mailer definition, above.<a id="id422" class="indexterm"/>
</p><p>Now we are ready to register the event for sending the e-mail. We'll use the<code class="literal"> grok.subscribe</code> directive to register our handler with the<code class="literal"> IObjectAddedEvent</code> of<code class="literal"> Project</code> objects.<a id="id423" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">import email.MIMEText
import email.Header
from zope.sendmail.interfaces import IMailDelivery
@grok.subscribe(IProject, grok.IObjectAddedEvent)
def send_email(obj, event):
todo_annotation = ISetNotifications(obj.__parent__)
if not todo_annotation.enabled:
return
sender = todo_annotation.sender
recipient = todo_annotation.emails
subject = todo_annotation.subject
body = todo_annotation.message
body = body.replace('${title}',obj.title)
body = body.replace('${description}',obj.description)
body = body.replace('${creator}',obj.creator)
msg = email.MIMEText.MIMEText(body.encode('UTF-8'), 'plain', 'UTF-8')
msg["From"] = sender
msg["To"] = ','.join(recipient)
msg["Subject"] = email.Header.Header(subject, 'UTF-8')
mailer = getUtility(IMailDelivery, 'todoplus')
mailer.send(sender, recipient, msg.as_string())
</pre></div><p>The handler first finds the<code class="literal"> annotation</code> object and checks the value of the<code class="literal"> enabled</code> property. If it's<code class="literal"> False</code>, the method just returns without doing anything else; if it's<code class="literal"> True</code>, we get the property values and compose the message with the help of the Python e-mail module. One simple trick that we use here is to allow the message to insert the title, creator, and description of the newly created project by using simple string substitutions. Take a look at the screenshot under the<span class="emphasis"><em> Creating a form</em></span> section of this chapter, to see how this works.</p><p>The<code class="literal"> zope.sendmail</code> package registers the mailer utility by using an interface named<code class="literal"> IMailDelivery</code>, so we import this and use the<code class="literal"> getUtility</code> function from<code class="literal"> zope.component</code> to find it and finally send the e-mail.<a id="id424" class="indexterm"/>
</p></div></div><div class="section" title="Displaying additional navigation links"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec09"/>Displaying additional navigation links</h2></div></div></div><p>So far, the to-do application has 'user management' and 'skin chooser' forms, but they don't show up in the site navigation. We have a viewlet manager set up for that in our original application, so we just need to register a viewlet with that manager and add a template, and we are done. This will demonstrate how easy it is to insert arbitrary page fragments in Grok, when the original views plan for it carefully.<a id="id425" class="indexterm"/>
</p><p>Let's add two viewlets one for regular user options, and one for manager-only options:</p><div class="informalexample"><pre class="programlisting">class ManagerOptions(grok.Viewlet):
grok.viewletmanager(ExtraNav)
grok.context(Interface)
grok.require('zope.ManageApplication')
class UserOptions(grok.Viewlet):
grok.viewletmanager(ExtraNav)
grok.context(Interface)
grok.require('todo.changeitems')
</pre></div><p>Both of these viewlets are registered with the<code class="literal"> ExtraNav</code> viewlet manager from the to-do application, but one requires only the<code class="literal"> todo.changeitems</code> permission, while the other needs the<code class="literal"> zope.ManageApplication</code> permission, which is usually assigned to the site manager. The page templates just include a couple of links. First, inside<code class="literal"> manageroptions.pt</code>, we have:</p><div class="informalexample"><pre class="programlisting">| &lt;a tal:attributes="href python:view.application_url('userlist')"&gt;Manage users&lt;/a&gt;
</pre></div><p>That's right, just a link to the<code class="literal"> userlist</code> view, which will be inserted in the correct place by the viewlet manager.</p><p>The other template,<code class="literal"> useroptions.pt</code>, is almost as simple:</p><div class="informalexample"><pre class="programlisting">| &lt;a tal:attributes="href python:view.application_url('skin_chooser')"&gt;Choose skin&lt;/a&gt;
| &lt;a tal:attributes="href python:view.application_url('set_notifications')"&gt; Set notifications&lt;/a&gt;
</pre></div><p>That's all that is needed. You can see the result in the navigation section of the previous two screenshots of this chapter. The nice thing about this is that other third-party packages can add a navigation link as well, and this would be transparently integrated with the existing navigation options, without even having to know about the existence of these other packages.<a id="id426" class="indexterm"/>
</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec03"/>Summary</h1></div></div></div><p>This chapter discussed the main concepts behind the Zope Component Architecture, and showed how to use some of the ZCA's patterns to extend our application. Most importantly, we showed how to extend a package without touching its code. In the next chapter, we'll see how Grok uses a library called Martian to permit agile configuration, and learn how to benefit from it, for our own work.</p></div></div>
</body></html>