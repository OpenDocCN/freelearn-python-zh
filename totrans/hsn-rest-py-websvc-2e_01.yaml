- en: Developing RESTful APIs and Microservices with Flask 1.0.2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will start our journey toward RESTful Web APIs with Python
    3.7 and four different web frameworks. Python is one of the most popular and versatile
    programming languages. There are thousands of Python packages, and these allow
    you to extend Python capabilities to any kind of domain you can imagine, such
    as web development, **Internet of Things** (**IoT**), artificial intelligence,
    machine learning, and scientific computing. We can work with many different web
    frameworks and packages to easily build simple and complex RESTful Web APIs with
    Python, and we can combine these frameworks with other Python packages.
  prefs: []
  type: TYPE_NORMAL
- en: We can leverage our existing knowledge of Python and all of its ...
  prefs: []
  type: TYPE_NORMAL
- en: Designing a RESTful API to interact with a simple data source
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine that we have to configure the notification messages to be displayed
    in an **OLED** (short for **Organic Light Emitting Diode**) display wired to an
    IoT device. The IoT device is capable of running Python 3.7.1, Flask 1.0.2, and
    other Python packages. There is a team writing code that retrieves string messages
    that represent notifications from a dictionary and displays them in the OLED display
    wired to the IoT device. We have to start working on a mobile app and a website
    that has to interact with a RESTful API to perform CRUD operations with string
    messages that represent notifications.
  prefs: []
  type: TYPE_NORMAL
- en: We don't need an **ORM** (short for **Object-Relational Mapping**) because we
    won't persist the notifications on a database. We will just work with an in-memory
    dictionary as our data source. It is one of the requirements we have for this
    RESTful API. In this case, the RESTful Web Service will be running on the IoT
    device; that is, we will run the Flask development service on the IoT device.
  prefs: []
  type: TYPE_NORMAL
- en: We will definitely lose scalability for our RESTful API because we have the
    in-memory data source in the service, and therefore we cannot run the RESTful
    API in another IoT device. However, we will work with another example that is
    related to a more complex data source that will be able to scale in the RESTful
    way later. The first example is going to allow us to understand how Flask and
    Flask-RESTful work together with a very simple in-memory data source.
  prefs: []
  type: TYPE_NORMAL
- en: We have chosen Flask because it is an extremely lightweight framework, we don't
    need to configure an ORM, and we want to start running the RESTful API on the
    IoT device as soon as possible to allow all the teams to interact with it. We
    consider that there will be a website that will be coded with Flask too, and therefore,
    we want to use the same web micro-framework to power the website and the RESTful
    Web Service. In addition, Flask is an appropriate choice to create a microservice
    that can run our RESTful API on the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: There are many extensions available for Flask that make it easier to perform
    specific tasks with the Flask micro-framework. We will take advantage of Flask-RESTful,
    an extension that will allow us to encourage best practices while building our
    RESTful API. In this case, we will work with a Python dictionary as the data source.
    As previously explained, we will work with more complex data sources in forthcoming
    examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we must specify the requirements for our main resource—a notification.
    We need the following attributes or fields for a notification:'
  prefs: []
  type: TYPE_NORMAL
- en: An integer identifier.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A string message.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **TTL** (short for **Time to Live**), that is, a duration in seconds that
    will indicate the time the notification message has to be displayed on the OLED
    display.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A creation date and time. The timestamp will be added automatically when adding
    a new notification to the collection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A notification category description, such as *Warning* or *Information*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An integer counter that indicates the times when the notification message has
    been displayed on the OLED display.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Boolean value that indicates whether the notification message was displayed
    at least once on the OLED display.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following table shows the HTTP verbs, the scope, and the semantics for
    the methods that our first version of the API must support. Each method is composed
    of an HTTP verb and a scope, and all the methods have a well-defined meaning for
    all notifications and collections. In our API, each notification has its own unique
    URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '| HTTP verb | Scope | Semantics |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | Collection of notifications | Retrieve all the stored notifications
    in the collection. |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | Notification | Retrieve a single notification. |'
  prefs: []
  type: TYPE_TB
- en: '| `POST` | Collection of notifications | Create a new notification in the collection.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `PATCH` | Notification | Update one or more fields for an existing notification.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `DELETE` | Notification | Delete an existing notification. |'
  prefs: []
  type: TYPE_TB
- en: Understanding the tasks performed by each HTTP method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's consider that `http://localhost:5000/service/notifications/` is the URL
    for the collection of notifications. If we add a number to the previous URL, we
    identify a specific notification whose ID is equal to the specified numeric value.
    For example, `http://localhost:5000/service/notifications/5` identifies the notification
    whose ID is equal to `5`.
  prefs: []
  type: TYPE_NORMAL
- en: We want our API to differentiate collections from a single resource of the collection
    in the URLs. When we refer to a collection, we will use a slash (`/`) as the last
    character for the URL, as in `http://localhost:5000/service/notifications/`. When
    we refer to a single resource of the collection, we won't use a slash (`/`) as
    the last character for ...
  prefs: []
  type: TYPE_NORMAL
- en: Understanding microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last few years, many large and complex applications started shifting
    from a monolithic architecture to a microservices architecture. Instead of working
    with large and extremely complex web services, the microservices architecture
    proposes developing a collection of smaller, loosely-coupled services to implement
    all the features required by complex applications in a way that enables and simplifies
    continuous delivery.
  prefs: []
  type: TYPE_NORMAL
- en: RESTful APIs are essential pieces of the microservices architecture, and Python
    is extremely popular when shifting to this architecture. Each microservice can
    encapsulate a RESTful API that fulfills a specific and limited purpose. The microservice
    is self-contained, it is easy to maintain, and it helps to support continuous
    delivery.
  prefs: []
  type: TYPE_NORMAL
- en: As happens with any architecture, there are several ways to implement the microservices
    architecture. We will learn to encapsulate a RESTful API developed with Flask
    and Python into a microservice. This way, we will be able to leverage our skills
    by developing RESTful APIs and using them as the essential pieces to build self-contained
    and easy-to-maintain microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Working with lightweight virtual environments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this book, we will be working with different frameworks, packages,
    and libraries to create RESTful Web APIs and microservices, and therefore, it
    is convenient to work with Python virtual environments to isolate each development
    environment. Python 3.3 introduced lightweight virtual environments and they were
    improved in subsequent Python versions. We will work with these virtual environments
    and, therefore, you will need Python 3.7.1 or higher. You can read more about
    the PEP 405 Python virtual environment, which introduced the `venv` module, at
    [https://www.python.org/dev/peps/pep-0405](https://www.python.org/dev/peps/pep-0405).
    All the examples for this book were tested on Python 3.7.1 on Linux, macOS, and
    Windows.
  prefs: []
  type: TYPE_NORMAL
- en: In case you ...
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a virtual environment with Flask and Flask-RESTful
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have followed the necessary steps to create and activate a virtual environment.
    Now, we will create a `requirements.txt` file to specify the set of packages that
    our application requires to be installed in any supported platform. This way,
    it will be extremely easy to repeat the installation of the specified packages
    with their versions in any new virtual environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use your favorite editor to create a new text file, named `requirements.txt`,
    within the root folder of the recently created virtual environment. The following
    lines show the content of the file that declares the packages and the versions
    that our API requires. The code file for the sample is included in the `restful_python_2_01_01`
    folder, in the `Flask01/requirements.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Each line in the `requirements.txt` file indicates the package and the version
    that needs to be installed. In this case, we are working with exact versions by
    using the `==` operator because we want to make sure that the specified version
    is installed. The following table summarizes the packages and the version numbers
    that we specified as requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Package name | Version to be installed |'
  prefs: []
  type: TYPE_TB
- en: '| `Flask` | 1.0.2 |'
  prefs: []
  type: TYPE_TB
- en: '| `flask-restful` | 0.3.6 |'
  prefs: []
  type: TYPE_TB
- en: '| `httpie` | 1.0.0 |'
  prefs: []
  type: TYPE_TB
- en: 'Now, we must run the following command on macOS, Linux, or Windows to install
    the packages and the versions explained in the previous table with `pip` by using
    the recently created `requirements.txt` file. Notice that Flask is a dependency
    for Flask-RESTful. Make sure you are located in the folder that has the `requirements.txt`
    file before running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The last lines for the output will indicate all the packages that have been
    successfully installed, including `Flask`, `flask-restful`, and `httpie`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Declaring status codes for the responses with an enumerable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Neither Flask nor Flask-RESTful includes the declaration of variables for the
    different HTTP status codes. We don't want to return numbers as status codes.
    We want our code to be easy to read and understand, and therefore, we will use
    descriptive HTTP status codes. Specifically, we will take advantage of the support
    for enumerations added in Python 3.4 to declare a class that defines unique sets
    of names and values that represent the different HTTP status codes.
  prefs: []
  type: TYPE_NORMAL
- en: First, create a `service` folder within the root folder for the recently created
    virtual environment. Create a new `http_status.py` file within the `service` folder.
    The following lines show the code that declares the `HttpStatus ...`
  prefs: []
  type: TYPE_NORMAL
- en: Creating the model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we will create a simple `NotificationModel` class that we will use to
    represent notifications. Remember that we won''t be persisting the model in any
    database or file, and therefore, in this case, our class will just provide the
    required attributes and no mapping information. Create a new `models.py` file
    in the `service` folder. The following lines show the code that creates a `NotificationModel`
    class in the `service/models.py` file. The code file for the sample is included
    in the `restful_python_2_01_01` folder, in the `Flask01/service/models.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `NotificationModel` class just declares a constructor, that is, the `__init__`
    method. This method receives many arguments and uses them to initialize the attributes
    with the same names: `message`, `ttl`, `creation_date`, and `notification_category`.
    The `id` attribute is set to `0`, `displayed_times` is set to `0`, and `displayed_once`
    is set to `False`. We will automatically increment the identifier for each new
    notification generated with API calls.'
  prefs: []
  type: TYPE_NORMAL
- en: Using a dictionary as a repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we will create a `NotificationManager` class that we will use to persist
    the `NotificationModel` instances in an in-memory dictionary. Our API methods
    will call methods for the `NotificationManager` class to retrieve, insert, update,
    and delete `NotificationModel` instances. Create a new `service.py` file in the
    `service` folder. The following lines show the code that creates a `NotificationManager`
    class in the `service/service.py` file. In addition, the following lines declare
    all the `imports` we will need for all the code we will write in this file. The
    code file for the sample is included in the `restful_python_2_01_01` folder, in
    the `Flask01/service/service.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Configuring output fields
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we will create a `notification_fields` dictionary that we will use to
    control the data that we want Flask-RESTful to render in our responses when we
    return `NotificationModel` instances. Open the `service/service.py` file created
    previously and add the following lines to the existing code. The code file for
    the sample is included in the `restful_python_2_01_01` folder, in the `Flask01/service/service.py`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We declared the `notification_fields` dictionary (`dict`) with key-value pairs
    of strings and classes declared in the `flask_restful.fields` module. The keys
    are the names of the attributes we want to render from the `NotificationModel`
    class, and the values are the classes that format and return the value for the
    field. In the previous code, we worked with the following classes that format
    and return the value for the specified field in the key:'
  prefs: []
  type: TYPE_NORMAL
- en: '`fields.Integer`: Outputs an integer value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fields.Url`: Generates a string representation of a URL. By default, this
    class generates a relative URI for the resource that is being requested. The code
    specifies `''notification_endpoint''` for the `endpoint` argument. This way, the
    class will use the specified endpoint name. We will declare this endpoint later
    in the `service.py` file. We don''t want to include the hostname in the generated
    URI and, therefore, we use the default value for the `absolute` Boolean attribute,
    which is `False`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fields.DateTime`: Outputs a formatted date and time string in UTC, in the
    default RFC 822 format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fields.Boolean`: Generates a string representation of a Boolean value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `'uri'` field uses `fields.Url` and is related to the specified endpoint
    instead of being associated with an attribute of the `NotificationModel` class.
    It is the only case in which the specified field name doesn't have an attribute
    in the `NotificationModel` class. The other strings specified as keys indicate
    all the attributes we want to be rendered in the output when we use the `notification_fields`
    dictionary to make up the final serialized response output.
  prefs: []
  type: TYPE_NORMAL
- en: After we declare the `notification_fields` dictionary, the next line of code
    creates an instance of the `NotificationManager` class created previously, named
    `notification_manager`. We will use this instance to create, retrieve, and delete
    `NotificationModel` instances.
  prefs: []
  type: TYPE_NORMAL
- en: Working with resourceful routing on top of Flask pluggable views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Flask-RESTful uses resources built on top of Flask pluggable views as the main
    building block for a RESTful API. We just need to create a subclass of the `flask_restful.Resource`
    class and declare the methods for each supported HTTP verb.
  prefs: []
  type: TYPE_NORMAL
- en: A subclass of `flask_restful.Resource` represents a RESTful resource and, therefore,
    we will have to declare one class to represent the collection of notifications
    and another one to represent the notification resource.
  prefs: []
  type: TYPE_NORMAL
- en: First, we will create a `Notification` class that we will use to represent the
    notification resource. Open the `service/service.py` file created previously and
    add the following lines. The code file for the sample is included in the ...
  prefs: []
  type: TYPE_NORMAL
- en: Configuring resource routing and endpoints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We must make the necessary resource routing configurations to call the appropriate
    methods and pass them all the necessary arguments by defining URL rules. The following
    lines create the main entry point for the application, initialize it with a Flask
    application, and configure the resource routing for the service. Open the previously
    created `service/service.py` file and add the following lines. The code file for
    the sample is included in the `restful_python_2_01_01` folder, in the `Flask01/service/service.py`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The code creates an instance of the `flask_restful.Api` class and saves it in
    the `service` variable. Each call to the `service.add_resource` method routes
    a URL to a resource, specifically to one of the previously declared subclasses
    of the `flask_restful.Resource` superclass. When there is a request to the service
    and the URL matches one of the URLs specified in the `service.add_resource` method,
    Flask will call the method that matches the HTTP verb in the request for the specified
    class. The method follows standard Flask routing rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following line will make an HTTP `GET` request to `/service/notifications/`
    without any additional parameters to call the `NotificationList.get` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Flask will pass the URL variables to the called method as arguments. For example,
    the following line will make an HTTP `GET` request to `/service/notifications/26`
    to call the `Notification.get` method, with `26` passed as the value for the `id`
    argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In addition, we can specify a string value for the endpoint argument to make
    it easy to reference the specified route in the `fields.Url` fields. We pass the
    same endpoint name, `'notification_endpoint'`, as an argument in the `uri` field
    declared as `fields.Url` in the `notification_fields` dictionary that we use to
    render each `NotificationModel` instance. This way, `fields.Url` will generate
    a URI that considers this route.
  prefs: []
  type: TYPE_NORMAL
- en: 'We just required a few lines of code to configure resource routing and endpoints.
    The last line just calls the `app.run` method to start the Flask application,
    with the `debug` argument set to `True` to enable debugging. In this case, we
    start the application by calling the `run` method to immediately launch a local
    server. We could also achieve the same goal by using the `flask` command-line
    script. However, this option would require us to configure environment variables
    and the instructions are different for the platforms that we are covering in this
    book: macOS, Windows, and Linux.'
  prefs: []
  type: TYPE_NORMAL
- en: As with any other web framework, you should never enable debugging in a production
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: Making HTTP requests to the Flask API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we can run the `service/service.py` script that launches Flask''s development
    server to compose and send HTTP requests to our unsecured and simple web API (we
    will definitely add security later). Execute the following command. Make sure
    you have the virtual environment activated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines show the output after we execute the previous command.
    The development server is listening at port `5000`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Working with the curl and httpie command-line tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will start with command-line tools. One of the key advantages of command-line
    tools is that we can easily run again the HTTP requests after we build them for
    the first time, and we don't need to use the mouse or to tap the screen to run
    requests. We can also easily build a script with batch requests and run them.
    As happens with any command-line tool, it can take more time to perform the first
    requests compared with GUI tools, but it becomes easier once we've performed many
    requests and we can easily reuse the commands we have written in the past to compose
    new requests.
  prefs: []
  type: TYPE_NORMAL
- en: '**Curl**, also known as **cURL**, is a very popular open source command-line
    tool and library that allows us to easily transfer data. We can use the `curl`
    command-line tool to easily compose and send HTTP requests and check their responses.'
  prefs: []
  type: TYPE_NORMAL
- en: In macOS or Linux, you can open a Terminal and start using `curl` from the command
    line.
  prefs: []
  type: TYPE_NORMAL
- en: In Windows, you can work with `curl` in the Command Prompt or you can install
    `curl` as part of the Cygwin package installation option and execute it from the
    Cygwin terminal. In case you decide to use the `curl` command within the Command
    Prompt, download and unzip the latest version at [http://curl.haxx.se/download.html](http://curl.haxx.se/download.html).
    Then, make sure you include the folder in which the `curl.exe` file is included
    in your path to make it easy to run the command.
  prefs: []
  type: TYPE_NORMAL
- en: You can read more about the Cygwin terminal and its installation procedure at
    [http://cygwin.com/install.html](http://cygwin.com/install.html). In case you
    decide to use the Cygwin terminal, use it whenever you have to run the `curl`
    command instead of working with the Command Prompt.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that Windows PowerShell includes the `curl` alias that calls the `Inovoke-WebRequest`
    command. Thus, in case you decide to work with Windows PowerShell, you will have
    to remove the `curl` alias to use the `curl` utility we use in this book.
  prefs: []
  type: TYPE_NORMAL
- en: We used the `requirements.txt` file to install the packages for our virtual
    environment. In this file, we specified `httpie` as one of the required packages.
    This way, we installed **HTTPie**, a command-line HTTP client written in Python
    that makes it easy to send HTTP requests and uses a syntax that is easier than
    `curl`. One of the great advantages of HTTPie is that it displays colorized output
    and uses multiple lines to display the response details. Thus, HTTPie makes it
    easier to understand the responses than the `curl` utility. However, it is very
    important to mention that HTTPie is slower than `curl`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whenever we compose HTTP requests with the command line, we will use two versions
    of the same command: the first one with HTTPie, and the second one with `curl`.
    This way, you will be able to use the one that is most convenient for you.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure you leave the Flask development server running. Don''t close the
    Terminal or Command Prompt that is running this development server. Open a new
    Terminal in macOS or Linux, or a Command Prompt in Windows, and run the following
    command. It is very important that you enter the ending slash (`/`) when specified
    because `/service/notifications` won''t match any of the configured URL routes.
    Thus, we must enter `/service/notifications/`, including the ending slash (`/`).
    We will compose and send an HTTP request to create a new notification. The code
    file for the sample is included in the `restful_python_2_01_02` folder, in the
    `Flask01/cmd01.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent `curl` command. It is very important to use
    the `-H "Content-Type: application/json"` option to tell `curl` to send the data
    specified after the `-d` option as `application/json` instead of the default `application/x-www-form-urlencoded`
    option.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code file for the sample is included in the `restful_python_2_01_02` folder,
    in the `Flask01/cmd02.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous commands will compose and send the `POST http://localhost:5000/service/notifications/`
    HTTP request with the following JSON key-value pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The request specifies `/service/notifications/` and, therefore, it will match
    `''/service/notifications/''` and run the `NotificationList.post` method. The
    method doesn''t receive arguments because the URL route doesn''t include any parameters.
    As the HTTP verb for the request is `POST`, Flask calls the `post` method. If
    the new `NotificationModel` was successfully persisted in the dictionary, the
    function returns an HTTP `201 Created` status code and the recently persisted
    `NotificationModel` serialized to JSON in the response body. The following lines
    show an example response for the HTTP request, with the new `NotificationModel`
    object in the JSON response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We will compose and send an HTTP request to create another notification. Go
    back to the Command Prompt in Windows, or the Terminal in macOS or Linux, and
    run the following command. The code file for the sample is included in the `restful_python_2_01_02`
    folder, in the `Flask01/cmd03.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent `curl` command. The code file for the sample
    is included in the `restful_python_2_01_02` folder, in the `Flask01/cmd04.txt`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous commands will compose and send the `POST http://localhost:5000/service/notifications/`
    HTTP request with the following JSON key-value pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines show an example response for the HTTP request, with the
    new `NotificationModel` object in the JSON response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We will compose and send an HTTP request to retrieve all the notifications.
    Go back to the Command Prompt in Windows, or the Terminal in macOS or Linux, and
    run the following command. The code file for the sample is included in the `restful_python_2_01_02`
    folder, in the `Flask01/cmd05.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent `curl` command. The code file for the sample
    is included in the `restful_python_2_01_02` folder, in the `Flask01/cmd06.txt`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The previous commands will compose and send the `GET http://localhost:5000/service/notifications/`
    HTTP request. The request specifies `/service/notifications/` and, therefore,
    it will match `'/service/notifications/'` and run the `NotificationList.get` method.
    The method doesn't receive arguments because the URL route doesn't include any
    parameters. As the HTTP verb for the request is `GET`, Flask calls the `get` method.
    The method retrieves all the `NotificationModel` objects and generates a JSON
    response with all of these `NotificationModel` objects serialized.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following lines show an example response for the HTTP request. The first
    lines show the HTTP response headers, including the status (`200 OK)` and the
    content type (`application/json`). After the HTTP response headers, we can see
    the details for the two `NotificationModel` objects in the JSON response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'After we run the three requests, we will see the following lines in the window
    that is running the Flask development server. The output indicates that the service
    received three HTTP requests, specifically two `POST` requests and one `GET` request
    with `/service/notifications/` as the URI. The service processed the three HTTP
    requests, and returned the `201` status code for the first two requests and `200`
    for the last request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows two Terminal windows side by side on macOS.
    The Terminal window on the left-hand side is running the Flask development server
    and displays the received and processed HTTP requests. The Terminal window on
    the right-hand side is running `http` commands to generate the HTTP requests.
    It is a good idea to use a similar configuration to check the output while we
    compose and send the HTTP requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d02d1b9f-018b-4800-9f1b-1ba875372560.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we will compose and send an HTTP request to retrieve a notification that
    doesn''t exist. For example, in the previous list, there is no notification with
    an `id` value equal to `78`. Run the following command to try to retrieve this
    notification. Make sure you use an `id` value that doesn''t exist. We must make
    sure that the utilities display the headers as part of the response to see the
    returned status code. The code file for the sample is included in the `restful_python_2_01_02`
    folder, in the `Flask01/cmd07.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent `curl` command. The code file for the sample
    is included in the `restful_python_2_01_02` folder, in the `Flask01/cmd08.txt`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous commands will compose and send the `GET http://localhost:5000/service/notifications/78`
    HTTP request. The request is the same as the previous one we analyzed, with a
    different number for the `id` parameter. The service will run the `Notification.get`
    method, with `78` as the value for the `id` argument. The method will execute
    the code that retrieves the `NotificationModel` object whose ID matches the `id`
    value received as an argument. However, the first line in the `NotificationList.get`
    method calls the `abort_if_notification_not_found` method, which won''t find the
    ID in the dictionary keys, and it will call the `flask_restful.abort` function
    because there is no notification with the specified `id` value. Thus, the code
    will return an HTTP `404 Not Found` status code. The following lines show an example
    header response for the HTTP request and the message included in the body. In
    this case, we just leave the default message. Of course, we can customize it based
    on our specific needs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We provide an implementation for the `PATCH` method to make it possible for
    our API to update a single field for an existing resource. For example, we can
    use the `PATCH` method to update two fields for an existing notification and set
    the value for its `displayed_once` field to `true` and `displayed_times` to `1`.
    We don't want to use the `PUT` method because this method is meant to replace
    an entire notification.
  prefs: []
  type: TYPE_NORMAL
- en: The `PATCH` method is meant to apply a delta to an existing notification and,
    therefore, it is the appropriate method to just change the value of the `displayed_once`
    and `displayed_times` fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will compose and send an HTTP request to update an existing notification,
    specifically, to update the value of two fields. Make sure you replace `2` with
    the ID of an existing notification in your configuration. The code file for the
    sample is included in the `restful_python_2_01_02` folder, in the `Flask01/cmd09.txt`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent `curl` command. The code file for the sample
    is included in the `restful_python_2_01_02` folder, in the `Flask01/cmd10.txt`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous command will compose and send a `PATCH` HTTP request with the
    specified JSON key-value pairs. The request has a number after `/service/notifications/` and,
    therefore, it will match `''/service/notifications/<int:id>''` and run the `Notification.patch`
    method, that is, the `patch` method for the `Notification` class. If a `NotificationModel`
    instance with the specified ID exists and was successfully updated, the call to
    the method will return an HTTP `200 OK` status code and the recently updated `NotificationModel`
    instance serialized to JSON in the response body. The following lines show a sample
    response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The IoT device will execute the previously explained HTTP request when it displays
    the notification for the first time. Then, it will make additional `PATCH` requests
    to update the value for the `displayed_times` field.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will compose and send an HTTP request to delete an existing notification,
    specifically, the last one we added. As happened in our last HTTP requests, we
    have to check the value assigned to `id` in the previous response and replace
    `2` in the command with the returned value. The code file for the sample is included
    in the `restful_python_2_01_02` folder, in the `Flask01/cmd11.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent `curl` command. The code file for the sample
    is included in the `restful_python_2_01_02` folder, in the `Flask01/cmd12.txt`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous commands will compose and send the `DELETE http://localhost:5000/service/notifications/2`
    HTTP request. The request has a number after `/service/notifications/` and, therefore,
    it will match `''/service/notifications/<int:id>''` and run the `Notification.delete`
    method, that is, the `delete` method for the `Notification` class. If a `NotificationModel`
    instance with the specified ID exists and was successfully deleted, the call to
    the method will return an HTTP `204 No Content` status code. The following lines
    show a sample response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Working with GUI tools – Postman and others
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have been working with two terminal-based, or command-line, tools
    to compose and send HTTP requests to our Flask development server: cURL and HTTPie.
    Now, we will work with a **GUI** (short for **Graphical User Interface**) tool.'
  prefs: []
  type: TYPE_NORMAL
- en: Postman is a very popular API testing suite GUI tool that allows us to easily
    compose and send HTTP requests, among other features. Postman is available as
    a Chrome App and as a Macintosh App. We can execute it in Windows, Linux, and
    macOS as a native app. You can download the versions of the Postman app at [https://www.getpostman.com/apps](https://www.getpostman.com/apps).
  prefs: []
  type: TYPE_NORMAL
- en: You can download and install Postman for free to compose and send HTTP requests
    to our RESTful APIs. You just need to sign up to ...
  prefs: []
  type: TYPE_NORMAL
- en: Consuming the API with other programming languages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've built our first RESTful Web Service that is capable of running as a microservice
    with Flask and Python. We can consume the API with any modern programming language
    that can compose and send HTTP requests to the resources and verbs supported by
    the API and work easily with JSON content.
  prefs: []
  type: TYPE_NORMAL
- en: It is extremely important to make sure that we set the content type for the
    HTTP request as we did when working with the `curl` and `http` command-line utilities.
    We just need to check which is the most convenient way of doing so in the programming
    language that we have to use as a client.
  prefs: []
  type: TYPE_NORMAL
- en: The fact that we can easily run a Flask development server and check its console
    output whenever a new request is processed makes it easy to check which requests
    arrive at the server. In this case, we are working with a basic and unsecured
    API. However, we will work with secure and more advanced APIs in the forthcoming
    chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Test your knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see whether you can answer the following questions correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: 'HTTPie is a:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Command-line HTTP server written in Python that makes it easy to create a RESTful
    Web Server
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Command-line utility that allows us to run queries against a SQLite database
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Command-line HTTP client written in Python that makes it easy to compose and
    send HTTP requests
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Flask-RESTful uses which of the following as the main building block for a
    RESTful API:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Resources built on top of Flask pluggable views
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Statuses built on top of Flask resource views
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Resources built on top of Flask pluggable controllers
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: To process an HTTP `PATCH` request on a resource, which method should we declare
    in a subclass of `flask_restful.Resource`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`patch_restful ...`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we designed a RESTful API to interact with a simple dictionary
    that acted as a data repository and performed CRUD operations with notifications,
    to be used as a baseline for a microservice. We defined the requirements for our
    API and understood the tasks performed by each HTTP method. We set up a virtual
    environment with Flask and Flask-RESTful. We followed best practices to generate
    a reproducible virtual environment.
  prefs: []
  type: TYPE_NORMAL
- en: We created a model to represent and persist notifications. We learned how to
    configure the serialization of notifications into JSON representations with the
    features included in Flask-RESTful. We wrote classes that represent resources
    and process the different HTTP requests, and we configured the URL patterns to
    route URLs to classes.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we started the Flask development server and we used command-line tools
    to compose and send HTTP requests to our RESTful API and analyzed how each HTTP
    requests was processed in our code. We also worked with many useful GUI tools
    to compose and send HTTP requests.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand the basics of the combination of Flask and Flask-RESTful
    to create RESTful APIs that we can encapsulate in microservices, in the next chapter,
    we will expand the capabilities of the RESTful Web API by taking advantage of
    the advanced features included in Flask-RESTful and related ORMs.
  prefs: []
  type: TYPE_NORMAL
