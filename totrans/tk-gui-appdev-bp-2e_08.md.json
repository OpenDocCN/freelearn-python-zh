["```py\nclass RandomBall:\n\ndef __init__(self, canvas):\n self.canvas = canvas\n self.screen_width = canvas.winfo_screenwidth()\n self.screen_height = canvas.winfo_screenheight()\n self.create_ball()\n\ndef create_ball(self):\n self.generate_random_attributes()\n self.create_oval() \n\ndef generate_random_attributes(self):\n self.radius = r = randint(40, 70)\n self.x_coordinate = randint(r, self.screen_width - r)\n self.y_coordinate = randint(r, self.screen_height - r)\n self.x_velocity = randint(6, 12)\n self.y_velocity = randint(6, 12)\n self.color = self.generate_random_color()\n\ndef generate_random_color(self):\n r = lambda: randint(0, 0xffff)\n return '#{:04x}{:04x}{:04x}'.format(r(), r(), r())\n\ndef create_oval(self):\n x1 = self.x_coordinate - self.radius\n y1 = self.y_coordinate - self.radius\n x2 = self.x_coordinate + self.radius\n y2 = self.y_coordinate + self.radius\n self.ball = self.canvas.create_oval( x1, y1, x2, y2, fill=self.color, \n   outline=self.color)\n\ndef move_ball(self):\n self.check_screen_bounds()\n self.x_coordinate += self.x_velocity\n self.y_coordinate += self.y_velocity\n self.canvas.move(self.ball, self.x_velocity, self.y_velocity)\n\ndef check_screen_bounds(self):\n r = self.radius\n if not r < self.y_coordinate < self.screen_height - r:\n   self.y_velocity = -self.y_velocity\n if not r < self.x_coordinate < self.screen_width - r:\n   self.x_velocity = -self.x_velocity\n```", "```py\nclass ScreenSaver:\n\nballs = []\n\ndef __init__(self, number_of_balls):\n self.root = Tk()\n self.number_of_balls = number_of_balls\n self.root.attributes('-fullscreen', True)\n self.root.attributes('-alpha', 0.1)\n self.root.wm_attributes('-alpha',0.1)\n self.quit_on_interaction()\n self.create_screensaver()\n self.root.mainloop()\n\ndef create_screensaver(self):\n self.create_canvas()\n self.add_balls_to_canvas()\n self.animate_balls()\n\ndef create_canvas(self):\n self.canvas = Canvas(self.root)\n self.canvas.pack(expand=1, fill=BOTH)\n\ndef add_balls_to_canvas(self):\n for i in range(self.number_of_balls):\n    self.balls.append(RandomBall(self.canvas))\n\ndef quit_on_interaction(self):\n  for seq in ('<Any-KeyPress>', '<Any-Button>', '<Motion>'):\n    self.root.bind(seq, self.quit_screensaver)\n\ndef animate_balls(self):\n for ball in self.balls:\n    ball.move_ball()\n self.root.after(30, self.animate_balls)\n\ndef quit_screensaver(self, event):\n   self.root.destroy()\n```", "```py\nitem_id = canvas.create_arc(x1, y1, x2, y2, option, ...)\n```", "```py\ntotal_value_to_represent_by_pie_chart = 1000\ndef angle(n):\n   return 360.0 * n / total_value_to_represent_by_pie_chart\n```", "```py\ncanvas.create_arc((2,2,152,152), fill=\"#FAF402\", outline=\"#FAF402\", start=angle(0), extent = angle(200))\n```", "```py\nplot_data= [random.randint(75,200) for r in range(12)]\nfor x, y in enumerate(plot_data):\n  x1 = x + x * bar_width\n  y1 = canvas_height - y \n  x2 = x + x * bar_width + bar_width\n  y2 = canvas_height\n  canv.create_rectangle(x1, y1, x2, y2, fill=\"blue\")\n  canv.create_text(x1+3, y1, font=(\"\", 6),\n    text=str(y),anchor='sw' )\n```", "```py\npip3 install matplotlib pip3 install numpy\n```", "```py\nimport tkinter as tk\nfrom numpy import arange, sin, pi\nfrom matplotlib.backends.backend_tkagg import FigureCanvasTkAgg,NavigationToolbar2TkAgg\nfrom matplotlib.figure import Figure\n```", "```py\nf = Figure(figsize=(5,4), dpi=100)\na = f.add_subplot(111)\nt = arange(-1.0, 1.0, 0.001)\ns = t*sin(1/t)\na.plot(t, s)\n```", "```py\ncanvas = FigureCanvasTkAgg(f, master=root)\ncanvas.get_tk_widget().pack(side=tk.TOP, fill=tk.BOTH, expand=1)\n```", "```py\ntoolbar = NavigationToolbar2TkAgg(canvas, root )\ntoolbar.update()\n```", "```py\ndef polar_to_cartesian(r, theta, scaling_factor, x_center, y_center):\n x = r * math.cos(theta) * scaling_factor + x_center\n y = r * math.sin(theta) * scaling_factor + y_center\n return(x, y)\n```", "```py\n# draw radial lines at interval of 15 degrees\nfor theta in range(0,360,15): \n r = 180\n x, y = x_center + math.cos(math.radians(theta))*r, \\\n        y_center - math.sin(math.radians(theta)) *r\n c.create_line(x_center, y_center, x, y, fill='green', dash=(2, 4),\\\n               activedash=(6, 5, 2, 4) )\n c.create_text(x, y, anchor=W, font=\"Purisa 8\", text=str(theta) + 'Â°')\n\n# draw concentric_circles\nfor radius in range(1,4):\n x_max = x_center + radius * scaling_factor\n x_min = x_center - radius * scaling_factor\n y_max = y_center + radius * scaling_factor\n y_min = y_center - radius * scaling_factor\n c.create_oval(x_max, y_max, x_min, y_min, width=1, outline='grey', \\\n               dash=(2, 4), activedash=(6, 5, 2, 4))\n```", "```py\nfor theta in range(0, 3000):\n  r = 2*math.sin(2*theta)\n  x, y = polar_to_cartesian(r, theta, scaling_factor, x_center, y_center)\n  c.create_oval(x, y, x, y, width=1, outline='navy')\n```", "```py\nr = 0.0006 * theta   # an archimedean spiral\nr = 1 + 2*math.cos(theta) # cardoid pattern\nr = 3 * math.cos(theta) # circle\nr = 2*math.sin(5*theta) # 5 leaved rose\nr = 3 * math.cos(3*theta) # 3 leaved rose\nr = 2 * math.sin(theta)**2 # a  lemniscate\nr = (4 * math.cos(2*theta))**1/2 # another lemniscate\n```", "```py\nclass Planet:\n sun_mass = 1.989 * math.pow(10, 30)\n G = 6.67 * math.pow(10, -11)\n\n def __init__(self, name, mass, distance, radius, color, canvas):\n  self.name = name\n  self.mass = mass\n  self.distance = distance\n  self.radius = radius\n  self.canvas = canvas\n  self.color = color\n  self.angular_velocity = -math.sqrt(self.gravitational_force() /\n                          (self.mass * self.distance))\n  self.oval_id = self.draw_initial_planet()\n  self.scaled_radius = self.radius_scaler(self.radius)\n  self.scaled_distance = self.distance_scaler(self.distance)\n```", "```py\ndef distance_scaler(self, value):\n  #[57.91, 4497.1] scaled to [0, self.canvas.winfo_width()/2]\n  return (self.canvas.winfo_width() / 2 - 1) * (value - 1e10) /  \n    (2.27e11 - 1e10) + 1 \n\ndef radius_scaler(self, value):\n  #[2439, 6051.8] scaled to [0, self.canvas.winfo_width()/2]\n  return (16 * (value - 2439) / (6052 - 2439)) + 2\n```", "```py\ndef gravitational_force(self):\n force = self.G * (self.mass * self.sun_mass) / math.pow(self.distance, 2)\n return force\n\ndef angular_position(self, t):\n theta = self.angular_velocity * t\n return theta\n```", "```py\ndef update_location(self, t):\n theta = self.angular_position(t)\n x, y = self.coordinates(theta)\n scaled_radius = self.scaled_radius\n self.canvas.create_rectangle(x, y, x, y, outline=\"grey\")\n self.canvas.coords(self.oval_id, x - scaled_radius, y - scaled_radius,\n                   x + scaled_radius, y + scaled_radius)\n```", "```py\ndef coordinates(self, theta):\n screen_dim = self.canvas.winfo_width()\n y = self.scaled_distance * math.sin(theta) + screen_dim / 2\n x = self.scaled_distance * math.cos(theta) + screen_dim / 2\n return (x, y)\n```", "```py\n#name,mass,distance,radius, color, canvas\nmercury = Planet(\"Mercury\", 3.302e23, 5.7e10, 2439.7, 'red2', canvas)\nvenus = Planet(\"Venus\", 4.8685e24, 1.08e11, 6051.8, 'CadetBlue1', canvas)\nearth = Planet(\"Earth\", 5.973e24, 1.49e11, 6378, 'RoyalBlue1', canvas)\nmars = Planet(\"Mars\", 6.4185e23, 2.27e11, 3396, 'tomato2', canvas)\nplanets = [mercury, venus, earth, mars]\nmoon = Moon(\"Moon\", 7.347e22, 3.844e5, 173, 'white', canvas, earth)\n```", "```py\ntime = 0\ntime_step = 100000\n\ndef update_bodies_position():\n global time, time_step\n for planet in planets:\n   planet.update_location(time)\n moon.update_location(time)\n time = time + time_step\n root.after(100, update_bodies_position)\n```", "```py\nmax_number_of_iterations = 200\n```", "```py\nprint(mandelbrot_set_check(1, 0)) # returns 2\nprint(mandelbrot_set_check(-1, 0)) # returns 200\n```", "```py\ndef mandelbrot_set_check(real, imaginary):\n  iteration_count = 0\n  z_real = 0.0\n  z_imaginary = 0.0\n  while iteration_count < max_number_of_iterations and \\\n        z_real * z_real + z_imaginary * z_imaginary < 4.0:\n    temp = z_real * z_real - z_imaginary * z_imaginary + real\n    z_imaginary = 2.0 * z_real * z_imaginary + imaginary\n    z_real = temp\n    iteration_count += 1\n  return iteration_count\n```", "```py\nmin_real, max_real, min_imaginary, max_imaginary = -1.5, 0.7, -1.0, 1.0\n```", "```py\nimage_width = 512\nimage_height = 512\n```", "```py\ndef map_pixels_to_real(x):\n  real_range = max_real - min_real\n  return x * (real_range / image_width) + min_real\n\ndef map_pixels_to_imaginary(y):\n  imaginary_range = max_imaginary - min_imaginary\n  return y * (imaginary_range / image_height) + min_imaginary\n```", "```py\nfor y in range(image_height):\n for x in range(image_width):\n   real = map_pixels_to_real(x)\n   imaginary = map_pixels_to_imaginary(y)\n   num_iterations = mandelbrot_set_check(real, imaginary)\n   rgb = get_color(num_iterations)\n   canvas.create_rectangle([x, y, x, y], fill=rgb, width=0)\n```", "```py\nwidth = 800\nheight = 500\nnumber_of_attractor_points = 125\n```", "```py\ndef create_voronoi_diagram(canvas, w, h, number_of_attractor_points):\n  attractor_points = []\n  colors = []\n  for i in range(number_of_attractor_points):\n    attractor_points.append((random.randrange(w), random.randrange(h)))\n    colors.append('#%02x%02x%02x' % (random.randrange(256),\n                                     random.randrange(256),\n                                     random.randrange(256)))\n  for y in range(h):\n    for x in range(w):\n      minimum_distance = math.hypot(w , h )\n      index_of_nearest_attractor = -1\n      for i in range(number_of_attractor_points):\n        distance = math.hypot(attractor_points[i][0] - x, \n          attractor_points[i][1] - y)\n        if distance < minimum_distance:\n          minimum_distance = distance\n          index_of_nearest_attractor = i\n      canvas.create_rectangle([x, y, x, y], \n        fill=colors[index_of_neasrest_attractor], width=0)\n  for point in attractor_points:\n    x, y = point\n    dot = [x - 1, y - 1, x + 1, y + 1]\n    canvas.create_rectangle(dot, fill='blue', width=1)\n```", "```py\nUNSTRETCHED_SPRING_LENGTH = 30\nSPRING_CONSTANT = 0.1\nMASS = 0.3\nGRAVITY = 9.8\nNUMBER_OF_STEPS_IN_SIMULATION = 500\n```", "```py\nstate_vector = [ 1, 1, 0.3, 1 ]  \n# 4 values represent 'l', 'dl/dt', 'Î¸', 'dÎ¸/dt' respectively\n```", "```py\ndef differential_functions(state_vector, time):\n func1 = state_vector[1]\n func2 = (UNSTRETCHED_SPRING_LENGHT + state_vector[0]) * \n   state_vector[3]**2 -  \n   (SPRING_CONSTANT / MASS * state_vector[0]) + GRAVITY * \n     np.cos(state_vector[2])\n func3 = state_vector[3]\n func4 = -(GRAVITY * np.sin(state_vector[2]) + 2.0 * state_vector[1] * \n   state_vector[3]) / (UNSTRETCHED_SPRING_LENGHT + state_vector[0])\n return np.array([func1, func2, func3, func4])\n```", "```py\nscipy.integrate.odeint(func, y0, t, optional arguments)\n```", "```py\ntime = np.linspace(0, 37, NUMBER_OF_STEPS_IN_SIMULATION)\n```", "```py\node_solution = odeint(differential_functions, state_vector, time)\n```", "```py\nx_coordinates = (UNSTRETCHED_SPRING_LENGHT + ode_solution[:, 0]) \n                * np.sin(ode_solution[:, 2])\ny_coordinates = (UNSTRETCHED_SPRING_LENGHT + ode_solution[:, 0]) \n                * np.cos(ode_solution[:, 2])\n```", "```py\nplot_step = 0\n\ndef update_graph():\n global plot_step\n if plot_step == NUMBER_OF_STEPS_IN_SIMULATION: # simulation ended\n   plot_step = 0 # repeat the simulation\n x, y = int(x_coordinates[plot_step]) + w / 2, \n   int(y_coordinates[plot_step] + h / 2)\n canvas.delete('all')\n canvas.create_line(w / 2, 0, x, y, dash=(2, 1), width=1, fill=\"gold4\")\n canvas.create_oval(x - 10, y - 10, x + 10, y + 10, outline=\"gold4\", \n   fill=\"lavender\")\n plot_step = plot_step + 1\n root.after(15, update_graph)\n```", "```py\nv1 = (float(WIDTH/2), 0.0)\nv2 = (0.00, float(HEIGHT))\nv3 = (float(WIDTH), float(HEIGHT))\n```", "```py\ndef random_point_inside_triangle(v1, v2, v3):\n  a = random.random()\n  b = random.random()\n  if a + b > 1:\n    a = 1-a\n    b = 1-b\n  c = 1 - a -b\n  x = (a*v1[0])+(b*v2[0])+(c*v3[0]);\n  y = (a*v1[1])+(b*v2[1])+(c*v3[1]);\n  return (x,y)\n```", "```py\ndef midway_point(p1, p2):\n  x = p1[0] + (p2[0] - p1[0]) //2\n  y = p1[1] + (p2[1] - p1[1]) //2\n  return (x,y)\n```", "```py\ndef get_next_point():\n  global last_point\n  roll = random.choice(range(6))+1\n  mid_point = None\n  if roll == 1 or roll == 2:\n    mid_point = midway_point(last_point, v1)\n  elif roll == 3 or roll == 4:\n    mid_point = midway_point(last_point, v2)\n  elif roll == 5 or roll == 6:\n    mid_point = midway_point(last_point, v3)\n last_point = mid_point\n return mid_point\n```", "```py\ndef update():\n x,y = get_next_point()\n canvas.create_rectangle(x, y, x, y, outline=\"#FFFF33\")\n root.after(1, update)\n```", "```py\nwidth, height = 500, 500\nnumber_of_dots = 2000\nangle = 137.5\nscaling_factor = 4\ndot_size = 4\nn = np.arange(number_of_dots)\nr = np.zeros(number_of_dots)\nphi = np.zeros(number_of_dots)\nx= np.zeros(number_of_dots)\ny= np.zeros(number_of_dots)\ndots = []\ncolors = []\n```", "```py\nfor i in n:\n  r = (scaling_factor * np.sqrt(i) * 6 ) %256\n  color = '#%02x%02x%02x' % (int(r) , 0, 0)\n  colors.append(color)\n  dots.append(canvas.create_oval(x[i]-dot_size, y[i]-dot_size,\n                    x[i]+dot_size, y[i]+dot_size, fill=color ))\n```", "```py\ndef update():\n global angle\n angle +=0.000001\n phi = angle * n\n r = scaling_factor * np.sqrt(n)\n x = r * np.cos(phi) + width/2\n y = r * np.sin(phi) + height/2\n for i in n:\n canvas.coords(dots[i],x[i]-dot_size, y[i]-dot_size,x[i]+dot_size, \n   y[i]+dot_size )\n root.after(15, update )\n```", "```py\nVertex 1 : [-100,-100,-100],\nVertex 2 : [-100, 100,-100],\nVertex 3: [-100,-100,100],\nVertex 4: [-100,100,100],\nVertex 5: [100,-100,-100],\nVertex 6: [100,100,-100],\nVertex 7: [100,-100,100],\nVertex 8: [100,100,100]\n```", "```py\nclass MatrixHelpers():\n\n  def transpose_matrix(self,matrix):\n    return list(zip(*matrix))\n```", "```py\ndef translate_vector(self, x,y,dx,dy):\n  return x+dx, y+dy\n```", "```py\nclass Cube(MatrixHelpers):\n  def __init__(self, root):\n   self.root = root\n   self.init_data()\n   self.create_canvas()\n   self.draw_cube()\n```", "```py\ndef init_data(self):\n  self.cube = self.transpose_matrix([\n            [-100,-100,-100],\n            [-100, 100,-100],\n            [-100,-100,100],\n            [-100,100,100],\n            [100,-100,-100],\n            [100,100,-100],\n            [100,-100,100],\n            [100,100,100]\n         ])\n```", "```py\n def create_canvas(self):\n   self.canvas = Canvas(self.root, width=400, height=400, background=self.bg_color)\n   self.canvas.pack(fill=BOTH,expand=YES)\n```", "```py\ndef draw_cube(self):\n cube_points_to_draw_line = [[0, 1, 2, 4],\n           [3, 1, 2, 7],\n           [5, 1, 4, 7],\n           [6, 2, 4, 7]]\n w = self.canvas.winfo_width()/2\n h = self.canvas.winfo_height()/2\n self.canvas.delete(ALL)\n for i in cube_points_to_draw_line:\n  for j in i:\n    self.canvas.create_line(self.translate_vector(self.cube[0][i[0]], \n     self.cube[1][i[0]], w, h), \n    self.translate_vector(self.cube[0][j], self.cube[1][j], w, h), fill \n      = self.fg_color)\n```", "```py\ndef matrix_multiply(self, matrix_a, matrix_b):\n  zip_b = list(zip(*matrix_b))\n  return [[sum(ele_a*ele_b for ele_a, ele_b in zip(row_a, col_b)) \n          for col_b in zip_b] for row_a in matrix_a]\n```", "```py\ndef rotate_along_x(self, x, shape):\n   return self.matrix_multiply([[1, 0, 0],\n                                [0, cos(x), -sin(x)], \n                                [0, sin(x), cos(x)]], shape)\n\ndef rotate_along_y(self, y, shape):\n   return self.matrix_multiply([[cos(y), 0, sin(y)], \n                                [0, 1, 0], \n                                [-sin(y), 0, cos(y)]], shape)\n\ndef rotate_along_z(self, z, shape):\n   return self.matrix_multiply([[cos(z), sin(z), 0],\n                                [-sin(z), cos(z), 0], \n                                [0, 0, 1]], shape)\n```", "```py\ndef continually_rotate(self):\n self.cube = self.rotate_along_x(0.01, self.cube)\n self.cube = self.rotate_along_y(0.01, self.cube)\n self.cube = self.rotate_along_z(0.01, self.cube)\n self.draw_cube()\n self.root.after(15, self.continually_rotate)\n```", "```py\ndef bind_mouse_buttons(self):\n  self.canvas.bind(\"<Button-1>\", self.on_mouse_clicked)\n  self.canvas.bind(\"<B1-Motion>\", self.on_mouse_motion)\n```", "```py\ndef on_mouse_clicked(self, event):\n  self.last_x = event.x\n  self.last_y = event.y\n\ndef on_mouse_motion(self, event):\n  dx = self.last_y - event.y\n  self.cube = self.rotate_along_x(self.epsilon(-dx), self.cube)\n  dy = self.last_x - event.x\n  self.cube = self.rotate_along_y(self.epsilon(dy), self.cube)\n  self.draw_cube()\n  self.on_mouse_clicked(event)\n```", "```py\nself.epsilon = lambda d: d * 0.01\n```"]