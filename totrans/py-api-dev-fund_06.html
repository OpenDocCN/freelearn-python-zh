<html><head></head><body>
		<div>
			<div id="_idContainer107" class="Content">
			</div>
		</div>
		<div id="_idContainer108" class="Content">
			<h1 id="_idParaDest-120"><a id="_idTextAnchor268"/>6. Email Confirmation</h1>
		</div>
		<div id="_idContainer109" class="Content">
			<h2>Learning Objectives</h2>
			<p>By the end of this chapter, you will be able to:</p>
			<ul>
				<li class="bullets">Send out plaintext and HTML format emails using the Mailgun API</li>
				<li class="bullets">Create a token for account activation using the itsdangerous package</li>
				<li class="bullets">Utilize the entire workflow for user registration</li>
				<li class="bullets">Develop applications using the benefits of environment variables</li>
			</ul>
			<p>This chapter covers how to use an email package to develop an email activation feature on the food recipe sharing platform for user registration as well as email verification.</p>
		</div>
		<div id="_idContainer119" class="Content">
			<h2 id="_idParaDest-121"><a id="_idTextAnchor269"/>Introduction</h2>
			<p>In the previous chapter, we worked on validating APIs using marshmallow. In this chapter, we will add functionality to our application that allows us to send emails to users. </p>
			<p>Everyone has their own email address. Some people may even have multiple mailboxes for different needs. In order to ensure the correctness of the email addresses entered by users when creating an account in our application, we need to verify their email address during registration. It is important to get their email address correct, as we may need to send emails to users in the future. </p>
			<p>In this chapter, we will implement a function to verify a mailbox, learn how to send a message through the third-party Mailgun API, and create a unique token to ensure that it is verified by the user. This can be achieved with the <strong class="inline">itsdangerous</strong> package. At the end of the chapter, we will make our confidential information (for example, Mailgun API Secret Key) more secure by sorting it into environmental variables. So, when we upload our project to GitHub or other platforms down the road, this confidential information will not be shared in the project. The following is how the new user registration flow works:</p>
			<div>
				<div id="_idContainer110" class="IMG---Figure">
					<img src="image/C15309_06_01.jpg" alt="Figure 6.1: New user registration flow&#13;&#10;"/>
				</div>
			</div>
			<h6>Figure 6.1: New user registration flow</h6>
			<p>In our first section, we will introduce you to the <strong class="inline">Mailgun</strong> platform. Without further ado, let's get started.</p>
			<h2 id="_idParaDest-122">M<a id="_idTextAnchor270"/>ailgun</h2>
			<p>Mailgun is a third-party <strong class="keyword">SMTP</strong> (<strong class="keyword">Simple Mail Transfer Protocol</strong>) and API sending email provider. Through Mailgun, not only can a large number of emails be sent, but the log for every email can also be traced. You have 10,000 free quotas per month. That means, in the free plan, we can only send, at most, 10,000 emails. This will be enough for our learning purposes. </p>
			<p>Mailgun also provides an open RESTful API, which is easy to understand and use. In the following exercise, we will register a Mailgun account, and send an email through the API.</p>
			<h3 id="_idParaDest-123">E<a id="_idTextAnchor271"/>xercise 40: Get Started with Using Mailgun</h3>
			<p>T<a id="_idTextAnchor272"/>o start with, we need to register an account in Mailgun. As we explained before, Mailgun is a third-party platform. We will register a Mailgun account in this exercise. Then, we will obtain the necessary setup information to use their email sending service API:</p>
			<ol>
				<li><a id="_idTextAnchor273"/>Visit the Mailgun website at <a href="https://www.mailgun.com/">https://www.mailgun.com/</a>. Click <strong class="bold">Sign Up</strong> to register an account. The home page will look like the following screenshot:<div id="_idContainer111" class="IMG---Figure"><img src="image/C15309_06_02.jpg" alt="Figure 6.2: Mailgun home page&#13;&#10;"/></div><h6>Figure 6.2: Mailgun home page</h6><p>On<a id="_idTextAnchor274"/>ce registration is done, Mailgun will send out a verification email with an account activation link.</p></li>
				<li>Click on the link in the verification email to activate the account, which is shown in the following screenshot:<div id="_idContainer112" class="IMG---Figure"><img src="image/C15309_06_03.jpg" alt="Figure 6.3: Mailgun account activation email&#13;&#10;"/></div><h6>Figure 6.3: Mailgun account activation email</h6></li>
				<li>The<a id="_idTextAnchor275"/>n, we will follow the Mailgun verification process. Enter your phone number to get a verification code. Use the code to activate your account. The screen will look like this:<div id="_idContainer113" class="IMG---Figure"><img src="image/C15309_06_04.jpg" alt="Figure 6.4: Verifying the account&#13;&#10;"/></div><h6>Figure 6.4: Verifying the account</h6></li>
				<li>Afte<a id="_idTextAnchor276"/>r your account is activated, log in to your account, then go to the <strong class="bold">Overview</strong> screen under <strong class="bold">Sending</strong>. There, you can find the domain name, API key, and base URL. This information is required for our subsequent programming work. Mailgun also provides sample code for a quick start: <div id="_idContainer114" class="IMG---Figure"><img src="image/C15309_06_05.jpg" alt="Figure 6.5: Mailgun dashboard&#13;&#10;"/></div></li>
			</ol>
			<h6>Figu<a id="_idTextAnchor277"/>re 6.5: Mailgun dashboard</h6>
			<p>Now we have opened an account in Mailgun that will allow us to use their service to send emails to our users. The API URL and key are for our Smilecook application to connect to the Mailgun API. We will show you how to do that very soon. </p>
			<h4>Note</h4>
			<p class="callout"><a id="_idTextAnchor278"/>Currently, we are using the sandbox domain for testing. You can only send an email to your own email address (that is, the email address registered with Mailgun). If you want to send emails to other email addresses, you can add Authorized Recipients on the right-hand side, and it will send an email to that recipient. The recipient needs to accept you sending them email. </p>
			<p>We wi<a id="_idTextAnchor279"/>ll go through the process of how to send the first email in the next exercise.</p>
			<h3 id="_idParaDest-124"><a id="_idTextAnchor280"/>Exercise 41: Using the Mailgun API to Send Out Emails</h3>
			<p>So, we have already registered an account with Mailgun. With that Mailgun account, we will be able to use the Mailgun API to send out emails to our users. In this exercise, we'll use Mailgun to send out our first test email, programmatically, in our Smilecook project:</p>
			<ol>
				<li value="1">Impor<a id="_idTextAnchor281"/>t requests and create the <strong class="inline">MailgunApi</strong> class in <strong class="inline">mailgun.py</strong>, under the <strong class="inline">Smilecook</strong> project:<p class="snippet">import requests</p><p class="snippet">class MailgunApi:</p></li>
				<li>In the same <strong class="inline">MailgunApi</strong> class, set the <strong class="inline">API_URL</strong> to <strong class="inline">https://api.mailgun.net/v3/{}/messages</strong>; this is the <strong class="inline">API_URL</strong> provided by Mailgun:<p class="snippet">    API_URL = 'https://api.mailgun.net/v3/{}/messages'</p></li>
				<li>In the same <strong class="inline">MailgunApi</strong> class, define the <strong class="inline">__init__</strong> constructor method for instantiating the object: <p class="snippet">    def __init__(self, domain, api_key):</p><p class="snippet">        self.domain = domain</p><p class="snippet">        self.key = api_key</p><p class="snippet">        self.base_url = self.API_URL.format(self.domain)</p></li>
				<li>In the same <strong class="inline">MailgunApi</strong> class, define the <strong class="inline">send_email</strong> method for sending out emails using the Mailgun API. This method takes in <strong class="inline">to</strong>, <strong class="inline">subject</strong>, <strong class="inline">text</strong>, and <strong class="inline">html</strong> as the input parameters and composes the email: <p class="snippet">   def send_email(self, to, subject, text, html=None):</p><p class="snippet">        if not isinstance(to, (list, tuple)):</p><p class="snippet">            to = [to, ]</p><p class="snippet">        data = {</p><p class="snippet">            'from': 'SmileCook &lt;no-reply@{}&gt;'.format(self.domain),</p><p class="snippet">            'to': to,</p><p class="snippet">            'subject': subject,</p><p class="snippet">            'text': text,</p><p class="snippet">            'html': html</p><p class="snippet">        }</p><p class="snippet">        response = requests.post(url=self.base_url,</p><p class="snippet">                                                  auth=('api', self.key),</p><p class="snippet">                                                  data=data)</p><p class="snippet">        return response</p></li>
				<li>Use <strong class="inline">M<a id="_idTextAnchor282"/>ailgunApi</strong> to send the first email. Open the <strong class="bold">PyCharm</strong> Python console and first import <strong class="inline">MailgunApi</strong> from <strong class="inline">mailgun</strong>, then create a <strong class="inline">mailgun</strong> object by passing the domain name and API key provided by Mailgun in the previous exercise:<p class="snippet">&gt;&gt;&gt;from mailgun import MailgunApi</p><p class="snippet">&gt;&gt;&gt;mailgun = MailgunApi(domain='sandbox76165a034aa940feb3ef785819641871.mailgun.org',</p><p class="snippet">api_key='441acf048aae8d85be1c41774563e001-19f318b0-739d5c30')</p></li>
				<li>Then, use the <strong class="inline">send_mail()</strong> method in <strong class="inline">MailgunApi</strong> to send our first email. We can pass in the <strong class="inline">email</strong>, <strong class="inline">subject</strong>, and <strong class="inline">body</strong> as parameters. We will get an HTTP status code <strong class="bold">200</strong> if the mail is sent successfully:<p class="snippet">&gt;&gt;&gt;mailgun.send_email(to='smilecook.api@gmail.com',</p><p class="snippet">                               subject='Hello', </p><p class="snippet">                               text='Testing some Mailgun awesomeness!')</p><p class="snippet">&lt;Response [200]&gt;</p><h4>Note<a id="_idTextAnchor283"/></h4><p class="callout">Please note that we need to use the same email address registered in Mailgun when we opened the account. This is because we haven't added any other email addresses to the authorized recipient list yet. So, this email address, registered in Mailgun, is the only email address that we can send out an email to now. In this case, it is <strong class="inline">smilecook.api@gmail.com</strong>.</p></li>
				<li>Check<a id="_idTextAnchor284"/> the mailbox of the registered email address. You should receive an email. If you can't find it, it could be in your spam folder:<div id="_idContainer115" class="IMG---Figure"><img src="image/C15309_06_06.jpg" alt="Figure 6.6: Sending an email via Mailgun&#13;&#10;"/></div></li>
			</ol>
			<h6>Figure 6.6: Sending an email via Mailgun</h6>
			<p>So, we have just sent out our first email using the third-party <strong class="inline">Mailgun</strong> API. Now we know how to add email capability to our application without setting up our own mail server. Later on, we will incorporate this email capability into our Smilecook application. We are going to use it in our user account activation workflow.</p>
			<h2 id="_idParaDest-125"><a id="_idTextAnchor285"/>User Account Activation Workflow</h2>
			<p>We would like to add an account activation step to our recipe sharing platform so that when a user registers an account in our system, the account will not be activated by default. At this time, a user cannot log in to their account dashboard. It's only after they activate their account by clicking on the link in our activation email that they can then log in to their account dashboard:</p>
			<div>
				<div id="_idContainer116" class="IMG---Figure">
					<img src="image/C15309_06_07.jpg" alt="Figure 6.7: User account activation workflow&#13;&#10;"/>
				</div>
			</div>
			<h6>Figure 6.7: User account activation workflow</h6>
			<p>To build this workflow, we will use the <strong class="inline">is_active</strong> attribute in the user model to indicate whether the account is activated (whether the link of the activation email has been clicked), then create a method for sending the verification email when the user registers and the endpoint can be used to open the account. In order to create a unique link, we'll use the <strong class="inline">itsdangerous</strong> package, which will help us to create a unique token that will be used in the link for account activation. This package ensures that the email we generated is not modified by anyone so that we can verify the user's identity before we activate their account.</p>
			<h4>Note</h4>
			<p class="callout">If you are interested in understanding more about the <strong class="inline">itsdangerous</strong> package, please visit <a href="https://pythonhosted.org/itsdangerous/">https://pythonhosted.org/itsdangerous/</a>.</p>
			<p>In the next exercise, we will generate the account activation token.</p>
			<h3 id="_idParaDest-126">Exercis<a id="_idTextAnchor286"/>e 42: Generating the Account Activation Token</h3>
			<p>As explained previously, we would like to implement a user account activation flow in our Smilecook application. This is to make sure the email address provided during registration is valid and is owned by the user. In this exercise, we will create a function to generate the activation token, as well as another function to verify the token. They will then be used later in the account activation flow: </p>
			<ol>
				<li value="1">Add the<a id="_idTextAnchor287"/> following line of code to <strong class="inline">requirements.txt</strong>:<p class="snippet">itsdangerous==1.1.0</p></li>
				<li>Instal<a id="_idTextAnchor288"/>l<a id="_idTextAnchor289"/> the <strong class="inline">itsdangerous</strong> package using the following command:<p class="snippet">pip install -r requirements.txt</p><p>You should see the following result returned after the packages are successfully installed:</p><p class="snippet">Installing collected packages: itsdangerous</p><p class="snippet">Successfully installed itsdangerous-1.1.0</p></li>
				<li>Make su<a id="_idTextAnchor290"/>re the secret key is added in <strong class="inline">config.py</strong>; it will be useful when we use the <strong class="inline">itsdangerous</strong> package later:<p class="snippet">class Config:</p><p class="snippet">    SECRET_KEY = 'super-secret-key'</p></li>
				<li>In <strong class="inline">uti<a id="_idTextAnchor291"/>l<a id="_idTextAnchor292"/>s.py</strong>, import the <strong class="inline">URLSafeTimedSerializer</strong> module from <strong class="inline">itsdangerous</strong>:<p class="snippet">from itsdangerous import URLSafeTimedSerializer</p><p class="snippet">from flask import current_app</p></li>
				<li>In <strong class="inline">utils.py</strong> again, define the <strong class="inline">generate_token</strong> function:<p class="snippet">def generate_token(email, salt=None):</p><p class="snippet">    serializer = URLSafeTimedSerializer(current_app.config.get('SECRET_KEY'))</p><p class="snippet">    return serializer.dumps(email, salt=salt)</p><p>In the <strong class="inline">generate_token</strong> method, we used the <strong class="inline">URLSafeTimedSerializer</strong> class to create a token via email and the <strong class="inline">current_app.config.get('SECRET_KEY')</strong> secret key, which is the secret key we set in the <strong class="inline">config.py</strong> settings. This same secret key will be used to verify this token in the future. Also, note that the timestamp will be in this token, after which we can verify the time this message was created.</p></li>
				<li>In <strong class="inline">utils.py</strong> again, define the <strong class="inline">verify_token</strong> function:<p class="snippet">def verify_token(token, max_age=(30 * 60), salt=None):</p><p class="snippet">    serializer = URLSafeTimedSerializer(current_app.config.get('SECRET_KEY'))</p><p class="snippet">    try:</p><p class="snippet">        email = serializer.loads(token, max_age=max_age, salt=salt)</p><p class="snippet">    except:</p><p class="snippet">        return False</p><p class="snippet">    return email</p><p>The <strong class="inline">verify_token</strong> function will try to extract the email address from the token, which will confirm whether the valid period in the token is within 30 minutes (<em class="italics">30 * 60</em> seconds) through the <strong class="inline">max_age</strong> attribute.</p><h4>Note</h4><p class="callout">You can see in <em class="italics">steps 5</em> and <em class="italics">step 6</em>, that <strong class="inline">salt</strong> is used here to distinguish between different tokens. When tokens are created by email, for example, in the scenarios of opening an account, resetting the password, and upgrading the account, a verification email will be sent. You can use <strong class="inline">salt='activate-salt'</strong>, <strong class="inline">salt='reset-salt'</strong>, and <strong class="inline">salt='upgrade-salt'</strong> to distinguish between these scenarios. </p></li>
			</ol>
			<p>Now we have these two handy functions to generate and verify the activation token, in the next exercise, we will use them in the user account activation flow.</p>
			<h3 id="_idParaDest-127"><a id="_idTextAnchor293"/>Exercise 43: Sending Out the User Account Activation Email</h3>
			<p>Now, we have the activation token ready from our previous exercise, and we have also learned how to use the Mailgun API to send out an email. We are going to combine the two in this exercise, placing the activation token in the activation email to complete the whole account activation workflow:</p>
			<ol>
				<li value="1">Import<a id="_idTextAnchor294"/> <strong class="inline">url_for</strong>, the <strong class="inline">MailgunAPI</strong> class, and the <strong class="inline">generate_token</strong> and <strong class="inline">verify_token</strong> functions into <strong class="inline">resources/user.py</strong>:<p class="snippet">from flask import request, url_for</p><p class="snippet">from mailgun import MailgunApi</p><p class="snippet">from utils import generate_token, verify_token</p></li>
				<li>Create<a id="_idTextAnchor295"/> <a id="_idTextAnchor296"/>a <strong class="inline">MailgunApi</strong> object by passing in the <strong class="inline">Mailgun</strong> domain name and the API key that we got in the previous exercise:<p class="snippet">mailgun = MailgunApi(domain='sandbox76165a034aa940feb3ef785819641871.mailgun.org',</p><p class="snippet">           api_key='441acf048aae8d85be1c41774563e001-19f318b0-739d5c30')</p></li>
				<li>Add the<a id="_idTextAnchor297"/> following code in the <strong class="inline">UserListResource</strong> class, right after <strong class="inline">user.save()</strong>:<p class="snippet">        token = generate_token(user.email, salt='activate')</p><p class="snippet">        subject = 'Please confirm your registration.'</p><p>We first generate a token using <strong class="inline">generate_token(user.email, salt='activate')</strong>. Here, <strong class="inline">salt='activate'</strong> means that the token is mainly used to activate the account. The subject of the email is set to <strong class="inline">Please confirm your registration</strong>.</p></li>
				<li>Create an activation link and define the email text in the same <strong class="inline">UserListResource</strong> class:<p class="snippet">        link = url_for('useractivateresource',</p><p class="snippet">                             token=token,</p><p class="snippet">                             _external=True)</p><p class="snippet">        text = 'Hi, Thanks for using SmileCook! Please confirm your registration by clicking on the link: {}'.format(link)</p><p>We create the activation link using the <strong class="inline">url_for</strong> function. It will require <strong class="inline">UserActivateResource</strong> (we will create that in our next step). This endpoint will need a token as well. The <strong class="inline">_external=True</strong> parameter is used to convert the default relative URL, <strong class="inline">/users/activate/&lt;string:token&gt;</strong>, to an absolute URL, <strong class="inline">http://localhost:5000/users/activate/&lt;string:token&gt;</strong>:</p></li>
				<li>Finally, we use the <strong class="inline">mailgun.send_email</strong> method to send the email in the same <strong class="inline">UserListResource</strong> class:<p class="snippet">        mailgun.send_email(to=user.email,</p><p class="snippet">                                         subject=subject,</p><p class="snippet">                                         text=text)</p></li>
				<li>Create<a id="_idTextAnchor298"/> <a id="_idTextAnchor299"/>a new <strong class="inline">UserActivateResource</strong> class under <strong class="inline">resources/user.py</strong> and define the <strong class="inline">get</strong> method in it:<p class="snippet">class UserActivateResource(Resource):</p><p class="snippet">    def get(self, token):</p><p class="snippet">        email = verify_token(token, salt='activate')</p><p class="snippet">        if email is False:</p><p class="snippet">            return {'message': 'Invalid token or token expired'}, HTTPStatus.BAD_REQUEST</p><p>First, this method verifies the token using <strong class="inline">verify_token(token, salt='activate')</strong>. The token has a default expiration time of 30 minutes. If the token is valid and not expired, we will get the user email and can proceed with the account activation. Otherwise, the email will be set to <strong class="inline">False</strong> and we can return an error message, <strong class="inline">Invalid token or token expired</strong>, with an <strong class="bold">HTTP status code 400 Bad Request</strong>.</p></li>
				<li>Continue to work on the <strong class="inline">UserActivateResource.get</strong> method:<p class="snippet">        user = User.get_by_email(email=email)</p><p class="snippet">        if not user:</p><p class="snippet">            return {'message': 'User not found'}, HTTPStatus.NOT_FOUND</p><p class="snippet">        if user.is_active is True:</p><p class="snippet">            return {'message': 'The user account is already activated'}, HTTPStatus.BAD_REQUEST</p><p class="snippet">        user.is_active = True</p><p class="snippet">        user.save()</p><p>If we have the user's email, we can look up the <strong class="inline">user</strong> object and modify its <strong class="inline">is_active</strong> attribute. If the user account is already activated, we will simply return <strong class="inline">The user is already activated</strong>. Otherwise, we activate the account and save that. </p></li>
				<li>Finally, we will return HTTP status code<strong class="inline"> 204 No Content</strong> to indicate that the request was handled successfully:<p class="snippet">        return {}, HTTPStatus.NO_CONTENT</p><h4>Note</h4><p class="callout">Usually, in a real-world scenario, the activation link in the email will point to the frontend layer of the system. The frontend layer will, in turn, communicate with the backend through the API. Therefore, when the frontend receives the HTTP status code <strong class="bold">204 No Content</strong>, it means the account is activated. It can then forward the user to the account dashboard. </p></li>
				<li>Then, a<a id="_idTextAnchor300"/>dd the new <strong class="inline">UserActivateResource</strong> class to <strong class="inline">app.py</strong> by using the following code. First, import the <strong class="inline">UserActivateResource</strong> class from <strong class="inline">resources.user</strong>, then add the route:<p class="snippet">from resources.user import UserListResource, UserResource, MeResource, UserRecipeListResource, UserActivateResource</p><p class="snippet">    api.add_resource(UserActivateResource, '/users/activate/&lt;string:token&gt;')</p></li>
				<li>Finally, we would like to make sure the user cannot log in to the application before their account is activated. We will change the <strong class="inline">POST</strong> method in <strong class="inline">resources/token.py</strong>. Add the following lines of code right after checking the password to return the HTTP status code <strong class="bold">403 Forbidden</strong> if the user account is not activated:<p class="snippet">        if user.is_active is False:</p><p class="snippet">            return {'message': 'The user account is not activated yet'}, HTTPStatus.FORBIDDEN</p></li>
				<li>Right-click on it to run the application. And we are ready to test the entire user registration workflow.</li>
			</ol>
			<p>Congratulations! You have completed the development of the entire user registration workflow. Our Smilecook application will be able to send out an email with an activation link. Users can then click on the activation link to activate their user account.</p>
			<p>In the next activity, we would like you to go through the whole flow and test whether it works.</p>
			<h3 id="_idParaDest-128"><a id="_idTextAnchor301"/>Activity 9: Testing the Complete User Registration and Activation Workflow</h3>
			<p>In this activity, we will test the complete user registration and activation workflow:</p>
			<ol>
				<li value="1">Register a new user through Postman.</li>
				<li>Log in <a id="_idTextAnchor302"/>through the API.</li>
				<li>Use the<a id="_idTextAnchor303"/> link sent to the mailbox to activate the account.</li>
				<li>Log in <a id="_idTextAnchor304"/>again after the account is activated.<h4>Note</h4><p class="callout">The solution for this activity can be found on page 314.</p></li>
			</ol>
			<h3 id="_idParaDest-129"><a id="_idTextAnchor305"/>Setting Up Environment Variables</h3>
			<p>We are going to use environment variables to ensure that our sensitive information, such as the secret key, is safe. This ensures that we are not leaking this sensitive and confidential information when we share code with others. Environment variables are only saved in the local environment and they won't appear in code. That is a usual best practice to segregate code from confidential information.</p>
			<h3 id="_idParaDest-130"><a id="_idTextAnchor306"/>Exercise 44: Setting Up Environment Variables in PyCharm</h3>
			<p>The environment variable is a key-value pair stored in the local system, which can be accessed by our application. In this exercise, we will set the environment variables through <strong class="inline">PyCharm</strong>:</p>
			<ol>
				<li value="1">At the <a id="_idTextAnchor307"/>top of the <strong class="inline">PyCharm</strong> interface, select <strong class="bold">Run</strong> and then click <strong class="bold">Edit Configurations</strong>:<div id="_idContainer117" class="IMG---Figure"><img src="image/C15309_06_08.jpg" alt="Figure 6.8: Select Run and click Edit Configurations&#13;&#10;"/></div><h6>Figure 6.8: Select Run and click Edit Configurations</h6></li>
				<li>Click <strong class="bold">Browse</strong> next to <strong class="bold">Environment Variables</strong>. Then click <strong class="bold">+</strong> to add the <strong class="inline">MAILGUN_DOMAIN</strong> and <strong class="inline">MAILGUN_API_KEY</strong> environment variables.<strong class="inline"> </strong><p>Your screen will look as follows:</p><div id="_idContainer118" class="IMG---Figure"><img src="image/C15309_06_09.jpg" alt="Figure 6.9: Adding the MAILGUN_DOMAIN and MAILGUN_API_KEY environment variables&#13;&#10;"/></div><h6>Figure 6.9: Adding the MAILGUN_DOMAIN and MAILGUN_API_KEY environment variables</h6><h4>Note</h4><p class="callout">For the Python console, to read the environment variables, we can set it under <em class="italics">Pycharm &gt;&gt; Preferences &gt;&gt; Build, Execution, Deployment &gt;&gt; Console &gt;&gt; Python Console</em>.</p></li>
				<li>We will t<a id="_idTextAnchor308"/>hen import the <strong class="inline">os</strong> package in <strong class="inline">resources/user.py</strong> and get the value in the environment variables using <strong class="inline">os.environ['MAILGUN_DOMAIN']</strong> and <strong class="inline">os.environ['MAILGUN_API_KEY']</strong>:<p class="snippet">import os</p><p class="snippet">mailgun = MailgunApi(domain=os.environ.get('MAILGUN_DOMAIN'),</p><p class="snippet">                            api_key=os.environ.get('MAILGUN_API_KEY'))</p><p>So, this is how you can move the secret <strong class="inline">API_KEY</strong> and other related information out from the code. This secret data is now stored in the environment variable and is isolated from the code. </p><h4>Note</h4><p class="callout">If we get the environment variable using <strong class="inline">os.environ['KEY']</strong>. It will raise a <strong class="inline">'KeyError'</strong> if the environment variable is not defined. We can get the value using <strong class="inline">os.environ.get('KEY')</strong> or <strong class="inline">os.getenv('Key')</strong>. This will give us None if the variable is not defined. If we want to set a default value if the environment variable is not defined, we can use this syntax: <strong class="inline">os.getenv('KEY', default_value)</strong>.</p></li>
			</ol>
			<h2 id="_idParaDest-131"><a id="_idTextAnchor309"/>HTML Format Email</h2>
			<p>We can add a bit of color to our email by using an HTML format email instead of plaintext email. HTML format email is everywhere. I am sure you have seen images in emails, or emails with a fancy layout. Those are HTML format emails. Theoretically, to send out HTML format email using the <strong class="inline">Mailgun</strong> API, it could be as simple as passing in the HTML code as a parameter to the <strong class="inline">mailgun.send_email</strong> method. </p>
			<p>Please refer to the following sample code to send out an HTML format email using Mailgun. We can see that we are just adding the new <strong class="inline">html</strong> parameter here: </p>
			<p class="snippet">mailgun.send_email(to=user.email,</p>
			<p class="snippet">                         subject=subject,</p>
			<p class="snippet">                         text=text, </p>
			<p class="snippet">                         html='&lt;html&gt;&lt;body&gt;&lt;h1&gt;Test email&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;')</p>
			<p>However, this way of coupling the HTML code with the Python code is cumbersome. If we have a fancy layout, the HTML can be pretty long and that's too much to be included in the actual Python code. To address this, we can leverage the <strong class="inline">render_template()</strong> function in Flask. This is a function that makes use of the Jinja2 template engine. With it, we can just place the HTML code in a separate HTML file under a <strong class="inline">/templates</strong> folder in the application project. We can then pass in the HTML file, also called a template file, to this <strong class="inline">render_template</strong> function to generate the HTML text. </p>
			<p>From the following sample code, we can see that, with the <strong class="inline">render_template</strong> function, we can simplify the code a lot:</p>
			<p class="snippet"><strong class="inline">template/sample.html</strong></p>
			<p class="snippet">&lt;html&gt;&lt;body&gt;&lt;h1&gt;Test email&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</p>
			<p>We can then render the HTML with the subject set to <strong class="inline">Test email</strong> using the following code:</p>
			<p class="snippet">mailgun.send_email(to=user.email,</p>
			<p class="snippet">                         subject=subject,</p>
			<p class="snippet">                         text=text, </p>
			<p class="snippet">                         html=render_template('sample.html'))</p>
			<p>The sample code here will look for the <strong class="inline">templates/sample.html</strong> file under the application project folder and render the HTML code for us. </p>
			<p>The function is named <strong class="inline">render_template</strong> instead of <strong class="inline">render_html</strong> for a reason. The <strong class="inline">render_template</strong> function does more than just directly outputting the HTML code from the file. In fact, we can insert variable in the HTML template file and have the <strong class="inline">render_template</strong> function render it. </p>
			<p>For example, we can modify <strong class="inline">sample.html</strong> like this (the <strong class="inline">{{content}}</strong> here is a placeholder):</p>
			<p class="snippet"><strong class="inline">template/sample.html</strong></p>
			<p class="snippet">&lt;html&gt;&lt;body&gt;&lt;h1&gt;{{content}}&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</p>
			<p>We can then render the HTML with the subject set to <strong class="inline">test email</strong> using the following code:</p>
			<p class="snippet">mailgun.send_email(to=user.email,</p>
			<p class="snippet">                         subject=subject,</p>
			<p class="snippet">                         text=text, </p>
			<p class="snippet">                         html=render_template('sample.html', content='Test email'))</p>
			<p>In the next activity, we would like you to send out the activation email in HTML format. </p>
			<h3 id="_idParaDest-132">Activity <a id="_idTextAnchor310"/>10: Creating the HTML Format User Account Activation Email</h3>
			<p>We have previously sent out plaintext format emails. In this activity, we will create an HTML format email so that it looks more appealing to our users:</p>
			<ol>
				<li value="1">Put the user's email address into the <strong class="inline">Mailgun</strong> authorized recipient list.</li>
				<li>Copy an HTML template from the <strong class="inline">Mailgun</strong> website.</li>
				<li>Add in the activation token in the HTML template.</li>
				<li>Use the <strong class="inline">render_template</strong> function to render the HTML code and send out the activation email using the <strong class="inline">Mailgun</strong> API.</li>
				<li>Register a new account in Postman and get the account activation email in HTML format.<h4>Note</h4><p class="callout">The solution for this activity can be found on page 317.</p></li>
			</ol>
			<p>You have now learned how to send out an email in HTML format. You can design your own HTML templates from now on.</p>
			<h2 id="_idParaDest-133"><a id="_idTextAnchor311"/>Summary</h2>
			<p>In this chapter, we learned how to use the third-party <strong class="inline">Mailgun</strong> API to send a user account activation email. Later, we can send different emails, such as a notification email, using the <strong class="inline">MailgunAPI</strong> class. Mailgun not only provides the API for sending mail but also provides a backend dashboard for us to track the status of the emails we've sent out. It is a very handy service. User account activation is an important step to ensure we are onboarding a validated user. Though not every platform performs this kind of validation, it reduces the impact of spam and bots onboarding our platform. In this chapter, we used the <strong class="inline">itsdangerous</strong> package to create a unique token to confirm the ownership of the user's email address. This package contains timestamps so that we can<a id="_idTextAnchor312"/> verify whether the token has expired or not.</p>
			<p>In the next chapter, we will continue to add more features to our Smilecook application. We will work with images in our next chapter. I am sure you will learn a lot of practical skills there. Let's continue our journey.</p>
		</div>
	</body></html>