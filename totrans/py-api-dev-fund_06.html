<html><head></head><body>
		<div><div></div>
		</div>
		<div><h1 id="_idParaDest-120"><a id="_idTextAnchor268"/>6. Email Confirmation</h1>
		</div>
		<div><h2>Learning Objectives</h2>
			<p>By the end of this chapter, you will be able to:</p>
			<ul>
				<li class="bullets">Send out plaintext and HTML format emails using the Mailgun API</li>
				<li class="bullets">Create a token for account activation using the itsdangerous package</li>
				<li class="bullets">Utilize the entire workflow for user registration</li>
				<li class="bullets">Develop applications using the benefits of environment variables</li>
			</ul>
			<p>This chapter covers how to use an email package to develop an email activation feature on the food recipe sharing platform for user registration as well as email verification.</p>
		</div>
		<div><h2 id="_idParaDest-121"><a id="_idTextAnchor269"/>Introduction</h2>
			<p>In the previous chapter, we worked on validating APIs using marshmallow. In this chapter, we will add functionality to our application that allows us to send emails to users. </p>
			<p>Everyone has their own email address. Some people may even have multiple mailboxes for different needs. In order to ensure the correctness of the email addresses entered by users when creating an account in our application, we need to verify their email address during registration. It is important to get their email address correct, as we may need to send emails to users in the future. </p>
			<p>In this chapter, we will implement a function to verify a mailbox, learn how to send a message through the third-party Mailgun API, and create a unique token to ensure that it is verified by the user. This can be achieved with the <code>itsdangerous</code> package. At the end of the chapter, we will make our confidential information (for example, Mailgun API Secret Key) more secure by sorting it into environmental variables. So, when we upload our project to GitHub or other platforms down the road, this confidential information will not be shared in the project. The following is how the new user registration flow works:</p>
			<div><div><img src="img/C15309_06_01.jpg" alt="Figure 6.1: New user registration flow&#13;&#10;"/>
				</div>
			</div>
			<h6>Figure 6.1: New user registration flow</h6>
			<p>In our first section, we will introduce you to the <code>Mailgun</code> platform. Without further ado, let's get started.</p>
			<h2 id="_idParaDest-122">M<a id="_idTextAnchor270"/>ailgun</h2>
			<p>Mailgun is a third-party <strong class="keyword">SMTP</strong> (<strong class="keyword">Simple Mail Transfer Protocol</strong>) and API sending email provider. Through Mailgun, not only can a large number of emails be sent, but the log for every email can also be traced. You have 10,000 free quotas per month. That means, in the free plan, we can only send, at most, 10,000 emails. This will be enough for our learning purposes. </p>
			<p>Mailgun also provides an open RESTful API, which is easy to understand and use. In the following exercise, we will register a Mailgun account, and send an email through the API.</p>
			<h3 id="_idParaDest-123">E<a id="_idTextAnchor271"/>xercise 40: Get Started with Using Mailgun</h3>
			<p>T<a id="_idTextAnchor272"/>o start with, we need to register an account in Mailgun. As we explained before, Mailgun is a third-party platform. We will register a Mailgun account in this exercise. Then, we will obtain the necessary setup information to use their email sending service API:</p>
			<ol>
				<li><a id="_idTextAnchor273"/>Visit the Mailgun website at <a href="https://www.mailgun.com/">https://www.mailgun.com/</a>. Click <strong class="bold">Sign Up</strong> to register an account. The home page will look like the following screenshot:<div><img src="img/C15309_06_02.jpg" alt="Figure 6.2: Mailgun home page&#13;&#10;"/></div><h6>Figure 6.2: Mailgun home page</h6><p>On<a id="_idTextAnchor274"/>ce registration is done, Mailgun will send out a verification email with an account activation link.</p></li>
				<li>Click on the link in the verification email to activate the account, which is shown in the following screenshot:<div><img src="img/C15309_06_03.jpg" alt="Figure 6.3: Mailgun account activation email&#13;&#10;"/></div><h6>Figure 6.3: Mailgun account activation email</h6></li>
				<li>The<a id="_idTextAnchor275"/>n, we will follow the Mailgun verification process. Enter your phone number to get a verification code. Use the code to activate your account. The screen will look like this:<div><img src="img/C15309_06_04.jpg" alt="Figure 6.4: Verifying the account&#13;&#10;"/></div><h6>Figure 6.4: Verifying the account</h6></li>
				<li>Afte<a id="_idTextAnchor276"/>r your account is activated, log in to your account, then go to the <strong class="bold">Overview</strong> screen under <strong class="bold">Sending</strong>. There, you can find the domain name, API key, and base URL. This information is required for our subsequent programming work. Mailgun also provides sample code for a quick start: <div><img src="img/C15309_06_05.jpg" alt="Figure 6.5: Mailgun dashboard&#13;&#10;"/></div></li>
			</ol>
			<h6>Figu<a id="_idTextAnchor277"/>re 6.5: Mailgun dashboard</h6>
			<p>Now we have opened an account in Mailgun that will allow us to use their service to send emails to our users. The API URL and key are for our Smilecook application to connect to the Mailgun API. We will show you how to do that very soon. </p>
			<h4>Note</h4>
			<p class="callout"><a id="_idTextAnchor278"/>Currently, we are using the sandbox domain for testing. You can only send an email to your own email address (that is, the email address registered with Mailgun). If you want to send emails to other email addresses, you can add Authorized Recipients on the right-hand side, and it will send an email to that recipient. The recipient needs to accept you sending them email. </p>
			<p>We wi<a id="_idTextAnchor279"/>ll go through the process of how to send the first email in the next exercise.</p>
			<h3 id="_idParaDest-124"><a id="_idTextAnchor280"/>Exercise 41: Using the Mailgun API to Send Out Emails</h3>
			<p>So, we have already registered an account with Mailgun. With that Mailgun account, we will be able to use the Mailgun API to send out emails to our users. In this exercise, we'll use Mailgun to send out our first test email, programmatically, in our Smilecook project:</p>
			<ol>
				<li value="1">Impor<a id="_idTextAnchor281"/>t requests and create the <code>MailgunApi</code> class in <code>mailgun.py</code>, under the <code>Smilecook</code> project:<pre>import requests
class MailgunApi:</pre></li>
				<li>In the same <code>MailgunApi</code> class, set the <code>API_URL</code> to <code>https://api.mailgun.net/v3/{}/messages</code>; this is the <code>API_URL</code> provided by Mailgun:<pre>    API_URL = 'https://api.mailgun.net/v3/{}/messages'</pre></li>
				<li>In the same <code>MailgunApi</code> class, define the <code>__init__</code> constructor method for instantiating the object: <pre>    def __init__(self, domain, api_key):
        self.domain = domain
        self.key = api_key
        self.base_url = self.API_URL.format(self.domain)</pre></li>
				<li>In the same <code>MailgunApi</code> class, define the <code>send_email</code> method for sending out emails using the Mailgun API. This method takes in <code>to</code>, <code>subject</code>, <code>text</code>, and <code>html</code> as the input parameters and composes the email: <pre>   def send_email(self, to, subject, text, html=None):
        if not isinstance(to, (list, tuple)):
            to = [to, ]
        data = {
            'from': 'SmileCook &lt;no-reply@{}&gt;'.format(self.domain),
            'to': to,
            'subject': subject,
            'text': text,
            'html': html
        }
        response = requests.post(url=self.base_url,
                                                  auth=('api', self.key),
                                                  data=data)
        return response</pre></li>
				<li>Use <code>M<a id="_idTextAnchor282"/>ailgunApi</code> to send the first email. Open the <code>MailgunApi</code> from <code>mailgun</code>, then create a <code>mailgun</code> object by passing the domain name and API key provided by Mailgun in the previous exercise:<pre>&gt;&gt;&gt;from mailgun import MailgunApi
&gt;&gt;&gt;mailgun = MailgunApi(domain='sandbox76165a034aa940feb3ef785819641871.mailgun.org',
api_key='441acf048aae8d85be1c41774563e001-19f318b0-739d5c30')</pre></li>
				<li>Then, use the <code>send_mail()</code> method in <code>MailgunApi</code> to send our first email. We can pass in the <code>email</code>, <code>subject</code>, and <code>body</code> as parameters. We will get an HTTP status code <code>smilecook.api@gmail.com</code>.</p></li>
				<li>Check<a id="_idTextAnchor284"/> the mailbox of the registered email address. You should receive an email. If you can't find it, it could be in your spam folder:<div><img src="img/C15309_06_06.jpg" alt="Figure 6.6: Sending an email via Mailgun&#13;&#10;"/></div></li>
			</ol>
			<h6>Figure 6.6: Sending an email via Mailgun</h6>
			<p>So, we have just sent out our first email using the third-party <code>Mailgun</code> API. Now we know how to add email capability to our application without setting up our own mail server. Later on, we will incorporate this email capability into our Smilecook application. We are going to use it in our user account activation workflow.</p>
			<h2 id="_idParaDest-125"><a id="_idTextAnchor285"/>User Account Activation Workflow</h2>
			<p>We would like to add an account activation step to our recipe sharing platform so that when a user registers an account in our system, the account will not be activated by default. At this time, a user cannot log in to their account dashboard. It's only after they activate their account by clicking on the link in our activation email that they can then log in to their account dashboard:</p>
			<div><div><img src="img/C15309_06_07.jpg" alt="Figure 6.7: User account activation workflow&#13;&#10;"/>
				</div>
			</div>
			<h6>Figure 6.7: User account activation workflow</h6>
			<p>To build this workflow, we will use the <code>is_active</code> attribute in the user model to indicate whether the account is activated (whether the link of the activation email has been clicked), then create a method for sending the verification email when the user registers and the endpoint can be used to open the account. In order to create a unique link, we'll use the <code>itsdangerous</code> package, which will help us to create a unique token that will be used in the link for account activation. This package ensures that the email we generated is not modified by anyone so that we can verify the user's identity before we activate their account.</p>
			<h4>Note</h4>
			<p class="callout">If you are interested in understanding more about the <code>itsdangerous</code> package, please visit <a href="https://pythonhosted.org/itsdangerous/">https://pythonhosted.org/itsdangerous/</a>.</p>
			<p>In the next exercise, we will generate the account activation token.</p>
			<h3 id="_idParaDest-126">Exercis<a id="_idTextAnchor286"/>e 42: Generating the Account Activation Token</h3>
			<p>As explained previously, we would like to implement a user account activation flow in our Smilecook application. This is to make sure the email address provided during registration is valid and is owned by the user. In this exercise, we will create a function to generate the activation token, as well as another function to verify the token. They will then be used later in the account activation flow: </p>
			<ol>
				<li value="1">Add the<a id="_idTextAnchor287"/> following line of code to <code>requirements.txt</code>:<pre>itsdangerous==1.1.0</pre></li>
				<li>Instal<a id="_idTextAnchor288"/>l<a id="_idTextAnchor289"/> the <code>itsdangerous</code> package using the following command:<pre>pip install -r requirements.txt</pre><p>You should see the following result returned after the packages are successfully installed:</p><pre>Installing collected packages: itsdangerous
Successfully installed itsdangerous-1.1.0</pre></li>
				<li>Make su<a id="_idTextAnchor290"/>re the secret key is added in <code>config.py</code>; it will be useful when we use the <code>itsdangerous</code> package later:<pre>class Config:
    SECRET_KEY = 'super-secret-key'</pre></li>
				<li>In <code>uti<a id="_idTextAnchor291"/>l<a id="_idTextAnchor292"/>s.py</code>, import the <code>URLSafeTimedSerializer</code> module from <code>itsdangerous</code>:<pre>from itsdangerous import URLSafeTimedSerializer
from flask import current_app</pre></li>
				<li>In <code>utils.py</code> again, define the <code>generate_token</code> function:<pre>def generate_token(email, salt=None):
    serializer = URLSafeTimedSerializer(current_app.config.get('SECRET_KEY'))
    return serializer.dumps(email, salt=salt)</pre><p>In the <code>generate_token</code> method, we used the <code>URLSafeTimedSerializer</code> class to create a token via email and the <code>current_app.config.get('SECRET_KEY')</code> secret key, which is the secret key we set in the <code>config.py</code> settings. This same secret key will be used to verify this token in the future. Also, note that the timestamp will be in this token, after which we can verify the time this message was created.</p></li>
				<li>In <code>utils.py</code> again, define the <code>verify_token</code> function:<pre>def verify_token(token, max_age=(30 * 60), salt=None):
    serializer = URLSafeTimedSerializer(current_app.config.get('SECRET_KEY'))
    try:
        email = serializer.loads(token, max_age=max_age, salt=salt)
    except:
        return False
    return email</pre><p>The <code>verify_token</code> function will try to extract the email address from the token, which will confirm whether the valid period in the token is within 30 minutes (<em class="italics">30 * 60</em> seconds) through the <code>max_age</code> attribute.</p><h4>Note</h4><p class="callout">You can see in <em class="italics">steps 5</em> and <em class="italics">step 6</em>, that <code>salt</code> is used here to distinguish between different tokens. When tokens are created by email, for example, in the scenarios of opening an account, resetting the password, and upgrading the account, a verification email will be sent. You can use <code>salt='activate-salt'</code>, <code>salt='reset-salt'</code>, and <code>salt='upgrade-salt'</code> to distinguish between these scenarios. </p></li>
			</ol>
			<p>Now we have these two handy functions to generate and verify the activation token, in the next exercise, we will use them in the user account activation flow.</p>
			<h3 id="_idParaDest-127"><a id="_idTextAnchor293"/>Exercise 43: Sending Out the User Account Activation Email</h3>
			<p>Now, we have the activation token ready from our previous exercise, and we have also learned how to use the Mailgun API to send out an email. We are going to combine the two in this exercise, placing the activation token in the activation email to complete the whole account activation workflow:</p>
			<ol>
				<li value="1">Import<a id="_idTextAnchor294"/> <code>url_for</code>, the <code>MailgunAPI</code> class, and the <code>generate_token</code> and <code>verify_token</code> functions into <code>resources/user.py</code>:<pre>from flask import request, url_for
from mailgun import MailgunApi
from utils import generate_token, verify_token</pre></li>
				<li>Create<a id="_idTextAnchor295"/> <a id="_idTextAnchor296"/>a <code>MailgunApi</code> object by passing in the <code>Mailgun</code> domain name and the API key that we got in the previous exercise:<pre>mailgun = MailgunApi(domain='sandbox76165a034aa940feb3ef785819641871.mailgun.org',
           api_key='441acf048aae8d85be1c41774563e001-19f318b0-739d5c30')</pre></li>
				<li>Add the<a id="_idTextAnchor297"/> following code in the <code>UserListResource</code> class, right after <code>user.save()</code>:<pre>        token = generate_token(user.email, salt='activate')
        subject = 'Please confirm your registration.'</pre><p>We first generate a token using <code>generate_token(user.email, salt='activate')</code>. Here, <code>salt='activate'</code> means that the token is mainly used to activate the account. The subject of the email is set to <code>Please confirm your registration</code>.</p></li>
				<li>Create an activation link and define the email text in the same <code>UserListResource</code> class:<pre>        link = url_for('useractivateresource',
                             token=token,
                             _external=True)
        text = 'Hi, Thanks for using SmileCook! Please confirm your registration by clicking on the link: {}'.format(link)</pre><p>We create the activation link using the <code>url_for</code> function. It will require <code>UserActivateResource</code> (we will create that in our next step). This endpoint will need a token as well. The <code>_external=True</code> parameter is used to convert the default relative URL, <code>/users/activate/&lt;string:token&gt;</code>, to an absolute URL, <code>http://localhost:5000/users/activate/&lt;string:token&gt;</code>:</p></li>
				<li>Finally, we use the <code>mailgun.send_email</code> method to send the email in the same <code>UserListResource</code> class:<pre>        mailgun.send_email(to=user.email,
                                         subject=subject,
                                         text=text)</pre></li>
				<li>Create<a id="_idTextAnchor298"/> <a id="_idTextAnchor299"/>a new <code>UserActivateResource</code> class under <code>resources/user.py</code> and define the <code>get</code> method in it:<pre>class UserActivateResource(Resource):
    def get(self, token):
        email = verify_token(token, salt='activate')
        if email is False:
            return {'message': 'Invalid token or token expired'}, HTTPStatus.BAD_REQUEST</pre><p>First, this method verifies the token using <code>verify_token(token, salt='activate')</code>. The token has a default expiration time of 30 minutes. If the token is valid and not expired, we will get the user email and can proceed with the account activation. Otherwise, the email will be set to <code>False</code> and we can return an error message, <code>Invalid token or token expired</code>, with an <strong class="bold">HTTP status code 400 Bad Request</strong>.</p></li>
				<li>Continue to work on the <code>UserActivateResource.get</code> method:<pre>        user = User.get_by_email(email=email)
        if not user:
            return {'message': 'User not found'}, HTTPStatus.NOT_FOUND
        if user.is_active is True:
            return {'message': 'The user account is already activated'}, HTTPStatus.BAD_REQUEST
        user.is_active = True
        user.save()</pre><p>If we have the user's email, we can look up the <code>user</code> object and modify its <code>is_active</code> attribute. If the user account is already activated, we will simply return <code>The user is already activated</code>. Otherwise, we activate the account and save that. </p></li>
				<li>Finally, we will return HTTP status code<code> 204 No Content</code> to indicate that the request was handled successfully:<pre>        return {}, HTTPStatus.NO_CONTENT</pre><h4>Note</h4><p class="callout">Usually, in a real-world scenario, the activation link in the email will point to the frontend layer of the system. The frontend layer will, in turn, communicate with the backend through the API. Therefore, when the frontend receives the HTTP status code <strong class="bold">204 No Content</strong>, it means the account is activated. It can then forward the user to the account dashboard. </p></li>
				<li>Then, a<a id="_idTextAnchor300"/>dd the new <code>UserActivateResource</code> class to <code>app.py</code> by using the following code. First, import the <code>UserActivateResource</code> class from <code>resources.user</code>, then add the route:<pre>from resources.user import UserListResource, UserResource, MeResource, UserRecipeListResource, UserActivateResource
    api.add_resource(UserActivateResource, '/users/activate/&lt;string:token&gt;')</pre></li>
				<li>Finally, we would like to make sure the user cannot log in to the application before their account is activated. We will change the <code>POST</code> method in <code>resources/token.py</code>. Add the following lines of code right after checking the password to return the HTTP status code <strong class="bold">403 Forbidden</strong> if the user account is not activated:<pre>        if user.is_active is False:
            return {'message': 'The user account is not activated yet'}, HTTPStatus.FORBIDDEN</pre></li>
				<li>Right-click on it to run the application. And we are ready to test the entire user registration workflow.</li>
			</ol>
			<p>Congratulations! You have completed the development of the entire user registration workflow. Our Smilecook application will be able to send out an email with an activation link. Users can then click on the activation link to activate their user account.</p>
			<p>In the next activity, we would like you to go through the whole flow and test whether it works.</p>
			<h3 id="_idParaDest-128"><a id="_idTextAnchor301"/>Activity 9: Testing the Complete User Registration and Activation Workflow</h3>
			<p>In this activity, we will test the complete user registration and activation workflow:</p>
			<ol>
				<li value="1">Register a new user through Postman.</li>
				<li>Log in <a id="_idTextAnchor302"/>through the API.</li>
				<li>Use the<a id="_idTextAnchor303"/> link sent to the mailbox to activate the account.</li>
				<li>Log in <a id="_idTextAnchor304"/>again after the account is activated.<h4>Note</h4><p class="callout">The solution for this activity can be found on page 314.</p></li>
			</ol>
			<h3 id="_idParaDest-129"><a id="_idTextAnchor305"/>Setting Up Environment Variables</h3>
			<p>We are going to use environment variables to ensure that our sensitive information, such as the secret key, is safe. This ensures that we are not leaking this sensitive and confidential information when we share code with others. Environment variables are only saved in the local environment and they won't appear in code. That is a usual best practice to segregate code from confidential information.</p>
			<h3 id="_idParaDest-130"><a id="_idTextAnchor306"/>Exercise 44: Setting Up Environment Variables in PyCharm</h3>
			<p>The environment variable is a key-value pair stored in the local system, which can be accessed by our application. In this exercise, we will set the environment variables through <code>PyCharm</code>:</p>
			<ol>
				<li value="1">At the <a id="_idTextAnchor307"/>top of the <code>PyCharm</code> interface, select <strong class="bold">Run</strong> and then click <strong class="bold">Edit Configurations</strong>:<div><img src="img/C15309_06_08.jpg" alt="Figure 6.8: Select Run and click Edit Configurations&#13;&#10;"/></div><h6>Figure 6.8: Select Run and click Edit Configurations</h6></li>
				<li>Click <code>MAILGUN_DOMAIN</code> and <code>MAILGUN_API_KEY</code> environment variables.<code> </code><p>Your screen will look as follows:</p><div><img src="img/C15309_06_09.jpg" alt="Figure 6.9: Adding the MAILGUN_DOMAIN and MAILGUN_API_KEY environment variables&#13;&#10;"/></div><h6>Figure 6.9: Adding the MAILGUN_DOMAIN and MAILGUN_API_KEY environment variables</h6><h4>Note</h4><p class="callout">For the Python console, to read the environment variables, we can set it under <em class="italics">Pycharm &gt;&gt; Preferences &gt;&gt; Build, Execution, Deployment &gt;&gt; Console &gt;&gt; Python Console</em>.</p></li>
				<li>We will t<a id="_idTextAnchor308"/>hen import the <code>os</code> package in <code>resources/user.py</code> and get the value in the environment variables using <code>os.environ['MAILGUN_DOMAIN']</code> and <code>os.environ['MAILGUN_API_KEY']</code>:<pre>import os
mailgun = MailgunApi(domain=os.environ.get('MAILGUN_DOMAIN'),
                            api_key=os.environ.get('MAILGUN_API_KEY'))</pre><p>So, this is how you can move the secret <code>API_KEY</code> and other related information out from the code. This secret data is now stored in the environment variable and is isolated from the code. </p><h4>Note</h4><p class="callout">If we get the environment variable using <code>os.environ['KEY']</code>. It will raise a <code>'KeyError'</code> if the environment variable is not defined. We can get the value using <code>os.environ.get('KEY')</code> or <code>os.getenv('Key')</code>. This will give us None if the variable is not defined. If we want to set a default value if the environment variable is not defined, we can use this syntax: <code>os.getenv('KEY', default_value)</code>.</p></li>
			</ol>
			<h2 id="_idParaDest-131"><a id="_idTextAnchor309"/>HTML Format Email</h2>
			<p>We can add a bit of color to our email by using an HTML format email instead of plaintext email. HTML format email is everywhere. I am sure you have seen images in emails, or emails with a fancy layout. Those are HTML format emails. Theoretically, to send out HTML format email using the <code>Mailgun</code> API, it could be as simple as passing in the HTML code as a parameter to the <code>mailgun.send_email</code> method. </p>
			<p>Please refer to the following sample code to send out an HTML format email using Mailgun. We can see that we are just adding the new <code>html</code> parameter here: </p>
			<pre>mailgun.send_email(to=user.email,
                         subject=subject,
                         text=text, 
                         html='&lt;html&gt;&lt;body&gt;&lt;h1&gt;Test email&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;')</pre>
			<p>However, this way of coupling the HTML code with the Python code is cumbersome. If we have a fancy layout, the HTML can be pretty long and that's too much to be included in the actual Python code. To address this, we can leverage the <code>render_template()</code> function in Flask. This is a function that makes use of the Jinja2 template engine. With it, we can just place the HTML code in a separate HTML file under a <code>/templates</code> folder in the application project. We can then pass in the HTML file, also called a template file, to this <code>render_template</code> function to generate the HTML text. </p>
			<p>From the following sample code, we can see that, with the <code>render_template</code> function, we can simplify the code a lot:</p>
			<pre><code>template/sample.html</code>
&lt;html&gt;&lt;body&gt;&lt;h1&gt;Test email&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</pre>
			<p>We can then render the HTML with the subject set to <code>Test email</code> using the following code:</p>
			<pre>mailgun.send_email(to=user.email,
                         subject=subject,
                         text=text, 
                         html=render_template('sample.html'))</pre>
			<p>The sample code here will look for the <code>templates/sample.html</code> file under the application project folder and render the HTML code for us. </p>
			<p>The function is named <code>render_template</code> instead of <code>render_html</code> for a reason. The <code>render_template</code> function does more than just directly outputting the HTML code from the file. In fact, we can insert variable in the HTML template file and have the <code>render_template</code> function render it. </p>
			<p>For example, we can modify <code>sample.html</code> like this (the <code>{{content}}</code> here is a placeholder):</p>
			<pre><code>template/sample.html</code>
&lt;html&gt;&lt;body&gt;&lt;h1&gt;{{content}}&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</pre>
			<p>We can then render the HTML with the subject set to <code>test email</code> using the following code:</p>
			<pre>mailgun.send_email(to=user.email,
                         subject=subject,
                         text=text, 
                         html=render_template('sample.html', content='Test email'))</pre>
			<p>In the next activity, we would like you to send out the activation email in HTML format. </p>
			<h3 id="_idParaDest-132">Activity <a id="_idTextAnchor310"/>10: Creating the HTML Format User Account Activation Email</h3>
			<p>We have previously sent out plaintext format emails. In this activity, we will create an HTML format email so that it looks more appealing to our users:</p>
			<ol>
				<li value="1">Put the user's email address into the <code>Mailgun</code> authorized recipient list.</li>
				<li>Copy an HTML template from the <code>Mailgun</code> website.</li>
				<li>Add in the activation token in the HTML template.</li>
				<li>Use the <code>render_template</code> function to render the HTML code and send out the activation email using the <code>Mailgun</code> API.</li>
				<li>Register a new account in Postman and get the account activation email in HTML format.<h4>Note</h4><p class="callout">The solution for this activity can be found on page 317.</p></li>
			</ol>
			<p>You have now learned how to send out an email in HTML format. You can design your own HTML templates from now on.</p>
			<h2 id="_idParaDest-133"><a id="_idTextAnchor311"/>Summary</h2>
			<p>In this chapter, we learned how to use the third-party <code>Mailgun</code> API to send a user account activation email. Later, we can send different emails, such as a notification email, using the <code>MailgunAPI</code> class. Mailgun not only provides the API for sending mail but also provides a backend dashboard for us to track the status of the emails we've sent out. It is a very handy service. User account activation is an important step to ensure we are onboarding a validated user. Though not every platform performs this kind of validation, it reduces the impact of spam and bots onboarding our platform. In this chapter, we used the <code>itsdangerous</code> package to create a unique token to confirm the ownership of the user's email address. This package contains timestamps so that we can<a id="_idTextAnchor312"/> verify whether the token has expired or not.</p>
			<p>In the next chapter, we will continue to add more features to our Smilecook application. We will work with images in our next chapter. I am sure you will learn a lot of practical skills there. Let's continue our journey.</p>
		</div>
	</body></html>