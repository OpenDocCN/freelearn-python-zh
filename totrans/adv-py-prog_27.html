<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><div id="_idContainer196">
			<h1 id="_idParaDest-376"><em class="italic"><a id="_idTextAnchor357"/>Chapter 24</em>: The Chain of Responsibility Pattern</h1>
			<p>We now cover the <strong class="bold">Chain of Responsibility design pattern</strong>, which should be used, as we will see, when we do not know the number and type of requests/events we would need to support. While this may seem vague, this pattern is useful among a wide range of use cases, such as event-based systems, purchase systems, and shipping systems.</p>
			<p>In this chapter, we will learn what the Chain of Responsibility pattern is, its benefits, and—as always—how to implement it in a practical Python example. We will discuss the following topics:</p>
			<ul>
				<li>Understanding the Chain of Responsibility pattern</li>
				<li>Real-world examples</li>
				<li>Use cases</li>
				<li>Implementation</li>
			</ul>
			<h1 id="_idParaDest-377"><a id="_idTextAnchor358"/>Technical requirements</h1>
			<p>The code files for this chapter can be accessed through this link: </p>
			<p><a href="https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter24">https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter24</a></p>
			<h1 id="_idParaDest-378"><a id="_idTextAnchor359"/>Understanding the Chain of Responsibility pattern</h1>
			<p>When developing an application, most of the time, we know which method should satisfy a particular <a id="_idIndexMarker1382"/>request in advance. However, this is not always the case. For example, think of any broadcast computer network, such as the original Ethernet implementation. In broadcast computer networks, all requests are sent to all nodes (broadcast domains are excluded for simplicity), but only the nodes that are interested in a sent request process it.</p>
			<p>All computers that participate in a broadcast network are connected to each other using a common medium such as the cable that connects all nodes. If a node is not interested or does not know how to handle a request, it can perform the following actions:</p>
			<ul>
				<li>Ignore the request and do nothing</li>
				<li>Forward the request to the next node</li>
			</ul>
			<p>The way in which the node reacts to a request is an implementation detail. However, we can use the analogy of a broadcast computer network to understand what the Chain of Responsibility <a id="_idIndexMarker1383"/>pattern is all about. The Chain of Responsibility pattern is used when we want to give multiple objects the chance to satisfy a single request or when we don't know in advance which object (from a chain of objects) should process a specific request.</p>
			<p>To illustrate the principle, imagine a chain (linked list, tree, or any other convenient data structure) of objects and the following flow:</p>
			<ol>
				<li>We start by sending a request to the first object in the chain.</li>
				<li>The object decides whether it should satisfy the request or not.</li>
				<li>The object forwards the request to the next object.</li>
				<li>This procedure is repeated until we reach the end of the chain.</li>
			</ol>
			<p>At the application level, instead of talking about cables and network nodes, we can focus on objects and the flow of a request. The following diagram shows how the client code sends a request to all processing elements of an application:</p>
			<div>
				<div id="_idContainer192" class="IMG---Figure">
					<img src="image/Figure_24.1_B17499.jpg" alt="Figure 24.1 – Client code sending a request " width="1650" height="603"/>
				</div>
			</div>
			<p class="figure-caption">Figure 24.1 – Client code sending a request</p>
			<p>Note that the client code only knows about the first processing element, instead of having references <a id="_idIndexMarker1384"/>to all of them, and each processing element only knows about its immediate next neighbor (called the <strong class="bold">successor</strong>), not about <a id="_idIndexMarker1385"/>every other processing element. This is usually a one-way relationship, which in <a id="_idIndexMarker1386"/>programming terms means a <strong class="bold">singly linked list</strong> in <a id="_idIndexMarker1387"/>contrast to a <strong class="bold">doubly linked list</strong>. A singly linked list does not allow navigation in both ways, while a doubly linked list allows that. This chain organization is used for a good reason. It achieves decoupling between the sender (client) and the receivers (processing elements).</p>
			<p>We will see some real-world examples of this pattern in the next section.</p>
			<h1 id="_idParaDest-379"><a id="_idTextAnchor360"/>Real-world examples</h1>
			<p><strong class="bold">Automated teller machines</strong> (<strong class="bold">ATMs</strong>) and, in general, any kind of machine that accepts/returns <a id="_idIndexMarker1388"/>banknotes or coins (for example, a snack-vending machine) use <a id="_idIndexMarker1389"/>the Chain of Responsibility pattern.</p>
			<p>There is always a single slot for all banknotes, as shown in the following diagram, courtesy of <em class="italic">SourceMaking</em> (<a href="http://www.sourcemaking.com">www.sourcemaking.com</a>):</p>
			<div>
				<div id="_idContainer193" class="IMG---Figure">
					<img src="image/Figure_24.2_B17499.jpg" alt="Figure 24.2 – An ATM has a single slot for all banknotes " width="1475" height="905"/>
				</div>
			</div>
			<p class="figure-caption">Figure 24.2 – An ATM has a single slot for all banknotes</p>
			<p>When a banknote is dropped, it is routed to the appropriate receptacle. When it is returned, it is taken from the appropriate receptacle. We can think of the single slot as a shared <a id="_idIndexMarker1390"/>communication medium and the different receptacles as processing elements. The result contains cash from one or more receptacles. For example, in the preceding diagram, we see what happens when we request <strong class="bold">United States dollars</strong> (<strong class="bold">USD</strong>) $175 from the ATM.</p>
			<p>In software, the servlet filters of Java are pieces of code that are executed before a <strong class="bold">HyperText Transfer Protocol</strong> (<strong class="bold">HTTP</strong>) request arrives at a target. When using servlet filters, there is a <a id="_idIndexMarker1391"/>chain of filters. Each filter performs a different action (user authentication, logging, data compression, and so forth) and either forwards the request to the next filter until the chain is exhausted or breaks the flow if there is an error—for example, the authentication failed three consecutive times (<a href="http://j.mp/soservl">j.mp/soservl</a>).</p>
			<p>As another software example, Apple's Cocoa and Cocoa Touch frameworks use the Chain of Responsibility to handle events. When a <em class="italic">view</em> receives an event that it doesn't know how to handle, it forwards the event to its <em class="italic">superview</em>. This goes on until a <em class="italic">view</em> is capable <a id="_idIndexMarker1392"/>of handling the event or the <em class="italic">chain of views</em> is exhausted (<a href="http://j.mp/chaincocoa">j.mp/chaincocoa</a>).</p>
			<p>When is this design pattern useful? Let's discuss that in the next section.</p>
			<h1 id="_idParaDest-380"><a id="_idTextAnchor361"/>Use cases</h1>
			<p>By using the Chain of Responsibility pattern, we provide a chance to a number of different objects to <a id="_idIndexMarker1393"/>satisfy a specific request. This is useful when we don't know which object should satisfy a request in advance. An example is a purchase system. In purchase systems, there are many approval authorities. One approval authority might be able to approve orders up to a certain value—let's say $100. If the order is for more than $100, the order is sent to the next approval authority in the chain that can approve orders up to $200, and so forth.</p>
			<p>Another case where the Chain of Responsibility is useful is when we know that more than one object might need to process a single request. This is what happens in event-based programming. A single event, such as a left-mouse click, can be caught by more than one listener.</p>
			<p>It is important to note that the Chain of Responsibility pattern is not very useful if all the requests can be taken care of by a single processing element unless we really don't know which element that is. The value of this pattern is the decoupling that it offers. Instead of having a many-to-many relationship between a client and all processing elements (and the same is true regarding the relationship between a processing element and all other processing elements), a client only needs to know how to communicate with the start (head) of the chain.</p>
			<p>The following diagram illustrates the difference between <strong class="bold">tight</strong> and <strong class="bold">loose coupling</strong>:</p>
			<div>
				<div id="_idContainer194" class="IMG---Figure">
					<img src="image/Figure_24.3_B17499.jpg" alt="Figure 24.3 – Loose versus tight coupling " width="1474" height="657"/>
				</div>
			</div>
			<p class="figure-caption">Figure 24.3 – Loose versus tight coupling</p>
			<p>The idea behind <a id="_idIndexMarker1394"/>loosely coupled systems is to <a id="_idIndexMarker1395"/>simplify maintenance and make it easier for <a id="_idIndexMarker1396"/>us to understand how they function (<a href="http://j.mp/loosecoup">j.mp/loosecoup</a>).</p>
			<p>We will see that this is the case in the next section, where we implement an event-based system.</p>
			<h1 id="_idParaDest-381"><a id="_idTextAnchor362"/>Implementation</h1>
			<p>There are many <a id="_idIndexMarker1397"/>ways to implement a Chain of Responsibility in Python, but my favorite implementation is the one by Vespe Savikko (<a href="https://legacy.python.org/workshops/1997-10/proceedings/savikko.html">https://legacy.python.org/workshops/1997-10/proceedings/savikko.html</a>). Vespe's implementation uses dynamic dispatching in a Pythonic style to handle requests (<a href="http://j.mp/ddispatch">http://j.mp/ddispatch</a>).</p>
			<p>Let's implement a <a id="_idIndexMarker1398"/>simple event-based system using Vespe's implementation as a guide. Here is a <strong class="bold">Unified Modeling Language</strong> (<strong class="bold">UML</strong>) class diagram of an event-based system:</p>
			<div>
				<div id="_idContainer195" class="IMG---Figure">
					<img src="image/Figure_24.4_B17499.jpg" alt="Figure 24.4 – UML class diagram of an event-based system " width="812" height="275"/>
				</div>
			</div>
			<p class="figure-caption">Figure 24.4 – UML class diagram of an event-based system</p>
			<p>The <strong class="source-inline">Event</strong> class <a id="_idIndexMarker1399"/>describes an event. We'll keep it simple, so in our case, an event has only <strong class="source-inline">name</strong>, as illustrated in the following code snippet:</p>
			<p class="source-code">class Event:</p>
			<p class="source-code">     def __init__(self, name):</p>
			<p class="source-code">         self.name = name</p>
			<p class="source-code"> </p>
			<p class="source-code">     def __str__(self):</p>
			<p class="source-code">         return self.name</p>
			<p>The <strong class="source-inline">Widget</strong> class is the core class of the application. The <strong class="bold">parent</strong> aggregation shown in the UML diagram indicates that each widget can have a reference to a <strong class="source-inline">parent</strong> object, which, by convention, we assume is a <strong class="source-inline">Widget</strong> instance. Note, however, that according to the rules of inheritance, an instance of any of the subclasses of <strong class="source-inline">Widget</strong> (for example, an instance of <strong class="source-inline">MsgText</strong>) is also an instance of <strong class="source-inline">Widget</strong>. The default value of <strong class="source-inline">parent</strong> is <strong class="source-inline">None</strong>, as illustrated in the following code snippet:</p>
			<p class="source-code">class Widget:</p>
			<p class="source-code">     def __init__(self, parent=None):</p>
			<p class="source-code">         self.parent = parent</p>
			<p>The <strong class="source-inline">handle()</strong> method uses dynamic dispatching through <strong class="source-inline">hasattr()</strong> and <strong class="source-inline">getattr()</strong> to decide who is the handler of a specific request (event). If the widget that is asked to handle an event does not support it, there are two fallback mechanisms. If the widget has <a id="_idIndexMarker1400"/>a parent, then the <strong class="source-inline">handle()</strong> method of the parent is executed. If the widget has no parent but a <strong class="source-inline">handle_default()</strong> method, <strong class="source-inline">handle_default()</strong> is executed, as illustrated in the following code snippet:</p>
			<p class="source-code">def handle(self, event):</p>
			<p class="source-code">    handler = f'handle_{event}'</p>
			<p class="source-code">    if hasattr(self, handler):</p>
			<p class="source-code">    method = getattr(self, handler)</p>
			<p class="source-code">    method(event)</p>
			<p class="source-code">    elif self.parent is not None:</p>
			<p class="source-code">    self.parent.handle(event)</p>
			<p class="source-code">    elif hasattr(self, 'handle_default'):</p>
			<p class="source-code">    self.handle_default(event)</p>
			<p>At this point, you might have realized why the <strong class="source-inline">Widget</strong> and <strong class="source-inline">Event</strong> classes are only associated (no aggregation or composition relationships) in the UML class diagram. The association is used to show that the <strong class="source-inline">Widget</strong> class knows about the <strong class="source-inline">Event</strong> class but does not have any strict references to it, since an event needs to be passed only as a parameter to <strong class="source-inline">handle()</strong>.</p>
			<p><strong class="source-inline">MainWindow</strong>, <strong class="source-inline">MsgText</strong>, and <strong class="source-inline">SendDialog</strong> are all widgets with different behaviors. Not all these three widgets are expected to be able to handle the same events, and even if they can handle the same event, they might behave differently. <strong class="source-inline">MainWindow</strong> can only handle <strong class="source-inline">close</strong> and <strong class="source-inline">default</strong> events, as illustrated in the following code snippet:</p>
			<p class="source-code">class MainWindow(Widget):</p>
			<p class="source-code">     def handle_close(self, event):</p>
			<p class="source-code">         print(f'MainWindow: {event}')</p>
			<p class="source-code"> </p>
			<p class="source-code">     def handle_default(self, event):</p>
			<p class="source-code">         print(f'MainWindow Default: {event}')</p>
			<p><strong class="source-inline">SendDialog</strong> can only handle <strong class="source-inline">paint</strong> events, as illustrated in the following code snippet:</p>
			<p class="source-code">class SendDialog(Widget):</p>
			<p class="source-code">     def handle_paint(self, event):</p>
			<p class="source-code">         print(f'SendDialog: {event}')</p>
			<p>Finally, <strong class="source-inline">MsgText</strong> can only handle <strong class="source-inline">down</strong> events, as illustrated in the following code snippet:</p>
			<p class="source-code">class MsgText(Widget):</p>
			<p class="source-code">     def handle_down(self, event):</p>
			<p class="source-code">         print(f'MsgText: {event}')</p>
			<p>The <strong class="source-inline">main()</strong> function shows how we can create a few widgets and events and how the widgets react to those events. All events are sent to all the widgets. Note the parent relationship <a id="_idIndexMarker1401"/>of each widget. The <strong class="source-inline">sd</strong> object (an instance of <strong class="source-inline">SendDialog</strong>) has as its parent the <strong class="source-inline">mw</strong> object (an instance of <strong class="source-inline">MainWindow</strong>). However, not all objects need to have a parent that is an instance of <strong class="source-inline">MainWindow</strong>. For example, the <strong class="source-inline">msg</strong> object (an instance of <strong class="source-inline">MsgText</strong>) has the <strong class="source-inline">sd</strong> object as a parent, as illustrated in the following code snippet:</p>
			<p class="source-code">def main():</p>
			<p class="source-code">     mw = MainWindow()</p>
			<p class="source-code">     sd = SendDialog(mw)</p>
			<p class="source-code">     msg = MsgText(sd)</p>
			<p class="source-code"> </p>
			<p class="source-code">     for e in ('down', 'paint', 'unhandled', 'close'):</p>
			<p class="source-code">         evt = Event(e)</p>
			<p class="source-code">         print(f'Sending event -{evt}- to MainWindow')</p>
			<p class="source-code">         mw.handle(evt)</p>
			<p class="source-code">         print(f'Sending event -{evt}- to SendDialog')</p>
			<p class="source-code">         sd.handle(evt)</p>
			<p class="source-code">         print(f'Sending event -{evt}- to MsgText')</p>
			<p class="source-code">         msg.handle(evt)</p>
			<p>Executing <a id="_idIndexMarker1402"/>the <strong class="source-inline">python chain.py</strong> command gives us the following output:</p>
			<p class="source-code"><strong class="bold">Sending event -down- to MainWindow</strong></p>
			<p class="source-code"><strong class="bold">MainWindow Default: down</strong></p>
			<p class="source-code"><strong class="bold">Sending event -down- to SendDialog</strong></p>
			<p class="source-code"><strong class="bold">MainWindow Default: down</strong></p>
			<p class="source-code"><strong class="bold">Sending event -down- to MsgText</strong></p>
			<p class="source-code"><strong class="bold">MsgText: down</strong></p>
			<p class="source-code"><strong class="bold">Sending event -paint- to MainWindow</strong></p>
			<p class="source-code"><strong class="bold">MainWindow Default: paint</strong></p>
			<p class="source-code"><strong class="bold">Sending event -paint- to SendDialog</strong></p>
			<p class="source-code"><strong class="bold">SendDialog: paint</strong></p>
			<p class="source-code"><strong class="bold">Sending event -paint- to MsgText</strong></p>
			<p class="source-code"><strong class="bold">SendDialog: paint</strong></p>
			<p class="source-code"><strong class="bold">Sending event -unhandled- to MainWindow</strong></p>
			<p class="source-code"><strong class="bold">MainWindow Default: unhandled</strong></p>
			<p class="source-code"><strong class="bold">Sending event -unhandled- to SendDialog</strong></p>
			<p class="source-code"><strong class="bold">MainWindow Default: unhandled</strong></p>
			<p class="source-code"><strong class="bold">Sending event -unhandled- to MsgText</strong></p>
			<p class="source-code"><strong class="bold">MainWindow Default: unhandled</strong></p>
			<p class="source-code"><strong class="bold">Sending event -close- to MainWindow</strong></p>
			<p class="source-code"><strong class="bold">MainWindow: close</strong></p>
			<p class="source-code"><strong class="bold">Sending event -close- to SendDialog</strong></p>
			<p class="source-code"><strong class="bold">MainWindow: close</strong></p>
			<p class="source-code"><strong class="bold">Sending event -close- to MsgText</strong></p>
			<p class="source-code"><strong class="bold">MainWindow: close</strong></p>
			<p>There are some interesting things that we can see in the output. For instance, sending a <strong class="source-inline">down</strong> event to <strong class="source-inline">MainWindow</strong> ends up being handled by the default <strong class="source-inline">MainWindow</strong> handler. Another nice case is that although a <strong class="source-inline">close</strong> event cannot be handled directly by <strong class="source-inline">SendDialog</strong> and <strong class="source-inline">MsgText</strong>, all <strong class="source-inline">close</strong> events end up being handled properly by <strong class="source-inline">MainWindow</strong>. That's the beauty of using the <em class="italic">parent relationship</em> as a fallback mechanism.</p>
			<p>If you want to <a id="_idIndexMarker1403"/>spend some more creative time on the event example, you can replace the dumb <strong class="source-inline">print</strong> statements and add some actual behavior to the listed events. Of course, you are not limited to the listed events. Just add your favorite event and make it do something useful!</p>
			<p>Another exercise is to add a <strong class="source-inline">MsgText</strong> instance during runtime that has <strong class="source-inline">MainWindow</strong> as the parent and do the same for an event (add a new event to an existing widget). </p>
			<h1 id="_idParaDest-382"><a id="_idTextAnchor363"/>Summary</h1>
			<p>In this chapter, we covered the Chain of Responsibility design pattern. This pattern is useful to model requests and/or handle events when the number and type of handlers aren't known in advance. </p>
			<p>Overall, we have learned how to use this design pattern to facilitate loose coupling between the sender and the receiver(s). Some examples that we have seen where this is particularly beneficial include Java's servlet and Apple's Cocoa frameworks.</p>
			<p>That's it for the Chain of Responsibility pattern. In the next chapter, we will cover the Command pattern.</p>
			<h1 id="_idParaDest-383"><a id="_idTextAnchor364"/>Questions</h1>
			<p>The answers for the following questions can be found in the <em class="italic">Assessments</em> section at the end of the book.</p>
			<ol>
				<li value="1">What are the high-level benefits of the Chain of Responsibility pattern?</li>
				<li>How is the Chain of Responsibility pattern implemented in the Python example of the event-based system we considered?</li>
				<li>What is an example of a situation in which the Chain of Responsibility pattern is not useful?</li>
			</ol>
		</div>
	</div>
</div>
</body></html>