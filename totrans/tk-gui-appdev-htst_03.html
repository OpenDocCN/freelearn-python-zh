<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;Programmable Drum Machine"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Programmable Drum Machine</h1></div></div></div><p>We built a text editor in the last project. In the process, we looked at some common Tkinter widgets such as Menu, Buttons, Label, and Text. Now, let us now do some music. Let us build a cross-platform drum machine using Tkinter and some other Python modules.</p><div class="section" title="Mission Briefing"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec27"/>Mission Briefing</h1></div></div></div><p>In this project, we will build a <a id="id233" class="indexterm"/>programmable drum machine. The graphical user interface of the drum machine is based on Tkinter. You will be able to create an unlimited number of beat patterns using an unlimited number of drum samples. <a id="id234" class="indexterm"/>You can then store multiple riffs in a project and playback or edit the project later on.</p><div class="mediaobject"><img src="graphics/7941_03_01.jpg" alt="Mission Briefing"/></div><p>To create <a id="id235" class="indexterm"/>your own drum beat patterns, simply load some drum samples using the buttons on the left. You can change the units that constitute a beat pattern, which in turn decides the tempo of the rhythm. You can also decide the number of beats per units. Most western beats have four beats per unit, waltz would have three beats per unit, and some Indian and Arabic rhythms that I composed on this machine had 3 to 16 beats per unit!</p><div class="section" title="Why Is It Awesome?"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec51"/>Why Is It Awesome?</h2></div></div></div><p>Don't be misled by the small size of the GUI. This is a powerful drum machine that can match features offered<a id="id236" class="indexterm"/> by some large commercial drum machine programs. By the end of this project, you should be in a position to extend it to outdo some of the commercial drum programs out there.</p><p>Some of the key features of the machine include:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Large number of beats</li><li class="listitem" style="list-style-type: disc">Large number of patterns to accompany songs</li><li class="listitem" style="list-style-type: disc">Variable number of beats per pattern</li><li class="listitem" style="list-style-type: disc">Use of 16 bit, 44100 kHz WAV samples (mono or stereo)</li><li class="listitem" style="list-style-type: disc">Support for various file formats</li><li class="listitem" style="list-style-type: disc">Ability to save projects comprising of several patterns</li></ul></div><p>A few drum <a id="id237" class="indexterm"/>samples are provided in the <code class="literal">Loops</code> subdirectory; however, you can load any other drum sample. You can download a large number of samples for free from the Internet.</p><p>In the process of developing this program, we tweak Tkinter further and take a look at several important concepts and ideas that are normally encountered in GUI programming.</p></div><div class="section" title="Your Hotshot Objectives"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec52"/>Your Hotshot Objectives</h2></div></div></div><p>Some of the <a id="id238" class="indexterm"/>key objectives for taking up this project include:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Understanding how Tkinter is normally applied in context of OOP</li><li class="listitem" style="list-style-type: disc">Working with a few more Tkinter widgets such as Spinbox, Button, Entry, and Checkbutton</li><li class="listitem" style="list-style-type: disc">Working with the <code class="literal">grid</code> geometry manager</li><li class="listitem" style="list-style-type: disc">Working with ttk-themed widgets</li><li class="listitem" style="list-style-type: disc">Understanding threaded programming in relation to Tkinter</li><li class="listitem" style="list-style-type: disc">Working with other common modules from the Python standard library</li><li class="listitem" style="list-style-type: disc">Object persistence with the <code class="literal">pickle</code> module</li></ul></div><p>Apart from these key concepts, we discuss several other vital nuggets of GUI programming in the course of the project.</p></div><div class="section" title="Mission Checklist"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec53"/>Mission Checklist</h2></div></div></div><p>In this project, we <a id="id239" class="indexterm"/>will use some more built-in libraries from the standard Python distribution. This includes <code class="literal">Tkinter</code>, <code class="literal">ttk</code>, <code class="literal">tkFileDialog</code>, <code class="literal">tkMessageBox</code>, <code class="literal">os</code>, <code class="literal">time</code>, <code class="literal">threading</code>, <code class="literal">wave</code>, and <code class="literal">pickle</code> modules.</p><p>To verify that these modules do exist, simply run the following statement in the IDLE interactive prompt:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; import Tkinter, ttk, os, time, threading, wave, pickle, tkFileDialog, tkMessageBox</strong></span>
</pre></div><p>This should not cause an error as the standard Python distribution comes with these modules built into the distribution.</p><p>Other than this, you need to add an extra Python module called <code class="literal">pymedia</code>.</p><p>The <code class="literal">pymedia</code> module<a id="id240" class="indexterm"/> can be downloaded at <a class="ulink" href="http://pymedia.org/">http://pymedia.org/</a>.</p><p>After you have installed the module, you can verify it by importing it:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; import pymedia</strong></span>
</pre></div><p>If no errors are rported,<a id="id241" class="indexterm"/> you are ready to program the drum machine. Let's start!</p></div></div></div>
<div class="section" title="Setting up the GUI in OOP"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec28"/>Setting up the GUI in OOP</h1></div></div></div><p>The text editor program that <a id="id242" class="indexterm"/>we developed as our previous project was set up in procedural code. While it offered some benefit of quick coding, it essentially ran as a single process.</p><p>We started <a id="id243" class="indexterm"/>encountering global variables. The function definitions needed to be defined above the code that called them and most importantly the code was not reusable.</p><p>Therefore, we need some way to ensure that our code is more reusable. This is why programmers prefer to use <span class="strong"><strong>Object Oriented Programming</strong></span> (<span class="strong"><strong>OOP</strong></span>)<a id="id244" class="indexterm"/> to organize their code into classes.</p><p>OOP is a programming paradigm that shifts the focus onto the objects we want to manipulate rather than the logic required to manipulate them.</p><p>This is in contrast to procedural programming that views a program as a logical procedure that takes input, processes it, and produces some output.</p><p>OOP provides several benefits such as data abstraction, encapsulation, inheritance, and polymorphism. In addition, OOP provides a clear modular structure for programs. Code modification and maintenance is easy as new objects can be created without modifying the existing ones.</p><p>Let us build our drum program using OOP to illustrate some of these features.</p><div class="section" title="Prepare for Lift Off"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec54"/>Prepare for Lift Off</h2></div></div></div><p>An indicative OOP structure for our drum program could be as follows (see the code in <code class="literal">3.01.py</code>):</p><div class="informalexample"><pre class="programlisting">from Tkinter import *
class DrumMachine():
  def app(self):
    self.root = Tk()
    # all other code are called from here
    self.root.mainloop()

if __name__ == '__main__':
  dm = DrumMachine()
  dm.app()</pre></div><p>The description<a id="id245" class="indexterm"/> of the code is listed as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We create a class called <code class="literal">DrumMachine</code> and define a method <code class="literal">app()</code>to initialize the Toplevel window</li><li class="listitem" style="list-style-type: disc">If the program is run as a standalone program, a new object is created and the <code class="literal">app</code> method is called to create the Toplevel window</li><li class="listitem" style="list-style-type: disc">This code creates a blank Toplevel window</li></ul></div><p>Now that we have <a id="id246" class="indexterm"/>our Toplevel window ready, let us add some widgets to it. In this iteration we will lay the top bar, left bar (the area that lets us upload drum samples), the right bar (that has buttons to define the beat patterns), and play bar at the bottom (which has a <span class="strong"><strong>Play</strong></span> button, a <span class="strong"><strong>Stop</strong></span> button, and a <span class="strong"><strong>Loop</strong></span> check button).</p><p>The four areas have been demarcated in different squares to group widgets into separate frames, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/7941_03_02.jpg" alt="Prepare for Lift Off"/></div></div><div class="section" title="Engage Thrusters"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec55"/>Engage Thrusters</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First we will create the top bar. The top bar is one that holds the Spinbox widgets,<a id="id247" class="indexterm"/> which lets the user change the units and beats per unit in a rhythm pattern. These two together decide the tempo and the <a id="id248" class="indexterm"/>cyclical pattern of a rhythm as follows (see the code in <code class="literal">3.02.py</code>):<div class="informalexample"><pre class="programlisting">def create_top_bar(self):
  top_bar_frame = Frame(self.root)
  top_bar_frame.config(height=25)
  top_bar_frame.grid(row=0, columnspan=12, rowspan=10, padx=5, pady=5)
  Label(top_bar_frame, text='Units:').grid(row=0, column=4)
  self.units = IntVar()
  self.units.set(4)
  self.bpu_widget = Spinbox(top_bar_frame, from_=1, to=10, width=5, textvariable=self.units)
  self.bpu_widget.grid(row=0, column=5)
  Label(top_bar_frame, text='BPUs:').grid(row=0, column=6)
  self.bpu = IntVar()
  self.bpu.set(4)
  self.units_widget = Spinbox(top_bar_frame, from_=1, to=8, width=5, textvariable=self.bpu)
  self.units_widget.grid(row=0, column=7)</pre></div><p>The description of the code is listed as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We first create a new method in order to create the top bar. We add a frame <code class="literal">top_bar_frame</code> for the top bar and then add two spin boxes to keep track of the units and beats per unit values. We do not add <code class="literal">command</code> callbacks now. The callbacks will be added later.</li><li class="listitem" style="list-style-type: disc">We define two Tkinter variables <code class="literal">self.units</code> and <code class="literal">self.bpu</code> to hold the current value of both the Spinbox widgets. This is defined as an object variable (<code class="literal">self</code>) because we will need these variables outside the scope of this method.</li><li class="listitem" style="list-style-type: disc">The widgets are placed using the <code class="literal">grid</code> geometry manager.</li></ul></div></li><li class="listitem">Next we will create the left bar. The left bar is one that will let the user load drum samples. Each row in the left bar allows for loading one unique drum sample. The drum samples are normally small <code class="literal">.wav</code> or <code class="literal">.ogg</code> file samples for different drums such as bass, snare, tom, bell, claves, or samples that the user decides.<p>The buttons on the left bar will open an upload file. When the user uploads a drum sample, the name of the drum sample will automatically populate the Entry widget adjacent to that button.</p><p>Thus, each<a id="id249" class="indexterm"/> row has a Button and an Entry widget (refer to the code in <code class="literal">3.02.py</code>):</p><div class="informalexample"><pre class="programlisting">MAX_DRUM_NUM = 5
def create_left_pad(self):
  '''creating actual pattern editor pad'''
  left_frame = Frame(self.root)
  left_frame.grid(row=10, column=0, columnspan=6, sticky=W+E+N+S)
  tbicon = PhotoImage(file='images/openfile.gif')
  for i in range(0, MAX_DRUM_NUM):
    button = Button(left_frame, image=tbicon)
    button.image = tbicon
    button.grid(row=i, column=0, padx=5, pady=2)
    self.drum_entry = Entry(left_frame)
    self.drum_entry.grid(row=i, column=4, padx=7, pady=2)</pre></div><p>The description of the code is listed as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The maximum number of drum samples that can be loaded is defined as a constant <code class="literal">MAX_DRUM_NUM</code></li><li class="listitem" style="list-style-type: disc">We create another frame called <code class="literal">left_frame</code> to hold various widgets in this area</li><li class="listitem" style="list-style-type: disc">Iterating over a loop, we create Button and Entry widgets for as many drum samples as we need to allow the user to load</li></ul></div></li><li class="listitem">Next we will <a id="id250" class="indexterm"/>create the right bar. The right bar is the area that lets the user define the beat pattern. This area consists of a series of buttons. The number of row of buttons is equal to the number of drum samples that can be loaded. The number of columns of buttons is decided by the number of units and number of beats per unit selected by the user from the spin boxes in the top bar. The number of columns of buttons is equal to product of the number of units and beats per unit.<p>We are not connecting the spin boxes with the buttons right now. For now, let us place buttons in four columns for each individual drum sample that can be loaded as follows (refer to the code in <code class="literal">3.02.py</code>):</p><div class="informalexample"><pre class="programlisting">def create_right_pad(self):
  right_frame = Frame(self.root)
  right_frame.grid(row=10, column=6,sticky=W+E+N+S, padx=15, pady=2)
  self.button = [[0 for x in range(4)] for x in range(MAX_DRUM_NUM)]
  for i in range(MAX_DRUM_NUM):
    for j in range(4):
      self.button[i][j] = Button(right_frame, bg='grey55')
      self.button[i][j].grid(row=i, column=j)</pre></div><p>The <a id="id251" class="indexterm"/>description of the code is listed as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We create another frame <code class="literal">right_frame</code> to hold these buttons.</li><li class="listitem" style="list-style-type: disc">Using list comprehension, we create an empty list of size <code class="literal">4 *MAX_DRUM_NUM</code>.</li><li class="listitem" style="list-style-type: disc">For now, we simply add four columns of buttons to occupy the place. The number of rows of buttons are  kept equal to the maximum <a id="id252" class="indexterm"/>number of drum samples, to have one row of buttons corresponding to each sample.</li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note22"/>Note</h3><p>There is reason behind grouping widgets into different methods.</p><p>For example, we have created the left pad and the right pad using two separate methods <code class="literal">create_left_pad</code> and <code class="literal">create_right_pad</code>. If we had defined these two groups of widgets within the same method, the user would have to reload the drum samples every time the left buttons changed due to changes in BPU and units. This would have been counterproductive for the end user.</p><p>As a rule of thumb, it is always advisable to keep related widgets within a single method. However, the deciding class structure is more of an art than science to be learned and refined over a lifetime.</p></div></div></li><li class="listitem">Next we will create the play bar. The play bar at the bottom includes the <span class="strong"><strong>Play</strong></span> button,<a id="id253" class="indexterm"/> the <span class="strong"><strong>Stop</strong></span> button, and a <span class="strong"><strong>Loop</strong></span> check button. Refer to the code in <code class="literal">3.02.py</code>, as shown in the following code:<div class="informalexample"><pre class="programlisting">def create_play_bar(self):
  playbar_frame = Frame(self.root, height=15)
  ln = MAX_DRUM_NUM+10
  playbar_frame.grid(row=ln, columnspan=13, sticky=W+E, padx=15,pa dy=10)
  button = Button( playbar_frame, text ='Play')
  button.grid(row= ln, column=1, padx=1)
  button = Button( playbar_frame, text ='Stop')='Stop')
  button.grid(row= ln, column=3, padx=1)
  loop = BooleanVar()
  loopbutton = Checkbutton(playbar_frame, text='Loop',variable=loop)
  loopbutton.grid(row=ln, column=16, padx=1)</pre></div><p>The description<a id="id254" class="indexterm"/> of the code is listed as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The code is pretty self-explanatory. It creates a frame <code class="literal">playbar_frame</code> and puts two buttons and one check button within the frame.</li><li class="listitem" style="list-style-type: disc">A Tkinter <code class="literal">BooleanVar()</code> is created to track the status of Checkbutton.</li></ul></div></li><li class="listitem">Now that we have created all the widgets, its now time to actually display them by explicitly calling the methods that created them. We do that within the main loop of our program as follows (refer to the code in <code class="literal">3.02.py)</code>:<div class="informalexample"><pre class="programlisting">def app(self):
  self.root = Tk()
  self.root.title('Drum Beast')
  self.create_top_bar()
  self.create_left_pad()
  self.create_right_pad()
  self.create_play_bar()
  self.root.mainloop()</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note23"/>Note</h3><p>Rather than defining a separate method <code class="literal">app()</code> to run our main loop, we could also have run the main loop by creating an initialization method called <code class="literal">__init__</code>.</p><p>In that case, we would not have to call the <code class="literal">app()</code>method<a id="id255" class="indexterm"/> explicitly to run the program. However, in case someone ever needs to use this class in another program, it would<a id="id256" class="indexterm"/> have needlessly created a GUI.</p><p>Calling the<a id="id257" class="indexterm"/> <code class="literal">mainloop</code> function explicitly from the <code class="literal">app()</code> method leaves us room to use the code as a library for some other program.</p></div></div></li></ol></div></div><div class="section" title="Objective Complete – Mini Debriefing"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec56"/>Objective Complete – Mini Debriefing </h2></div></div></div><p>This completes our first iteration. In this iteration we have managed to create the basic structure of our drum program. This includes creating the top, left, right, and bottom frames that holds different widgets as per the requirement of the drum program.</p><p>We have also seen one of the most common ways of structuring the Tkinter GUI program in an object-oriented style of programming.</p></div></div>
<div class="section" title="Completing the pattern editor"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec29"/>Completing the pattern editor</h1></div></div></div><p>In the preceding iteration, <a id="id258" class="indexterm"/>we coded a dummy <code class="literal">create_right_pad</code> with four columns of buttons. However, in the scheme of our program, the number of columns of buttons depends upon the choice of <span class="strong"><strong>Units</strong></span> and beats per units (<span class="strong"><strong>BPU</strong></span>) values selected by the end user.</p><p>The number of columns of buttons should be equal to:</p><p>Number of Units x BPU</p><p>Furthermore, to demarcate each unit, each consecutive unit of buttons should be displayed in different colors. Moreover, when a button is clicked, its color should change to track the user-defined pattern, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/7941_03_03.jpg" alt="Completing the pattern editor"/></div><p>Let us add these<a id="id259" class="indexterm"/> three features to our drum editor.</p><div class="section" title="Engage Thrusters"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec57"/>Engage Thrusters</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, we will start by connecting buttons to the <span class="strong"><strong>Units</strong></span> and <span class="strong"><strong>BPU</strong></span> Spinbox widgets. The code is simple. We add <code class="literal">command</code> callbacks from both the Spinbox widgets in the top bar to call our <code class="literal">create_right_pad</code> method. Refer to the code in <code class="literal">3.03.py</code>:<div class="informalexample"><pre class="programlisting">self.units_widget = Spinbox(topbar_frame, from_=1, to=8, width=5, textvariable=self.units, <span class="strong"><strong>command= self.create_right_pad</strong></span>)
self.bpu_widget = Spinbox(topbar_frame, from_=1, to=10, width=5, textvariable=self.bpu, <span class="strong"><strong>command= self.create_right_pad</strong></span>)</pre></div><p>We then modify our existing <code class="literal">create_right_pad</code> method<a id="id260" class="indexterm"/> as follows, and in code <code class="literal">3.03.py</code>:</p><div class="informalexample"><pre class="programlisting">def create_right_pad(self):
  bpu = self.bpu.get()
  units = self.units.get()
  c = bpu * units
  right_frame = Frame(self.root)
  right_frame.grid(row=10, column=6,sticky=W+E+N+S, padx=15, pady=2)
  self.button = [[0 for x in range(c)] for x inrange(MAX_DRUM_NUM)]
  for i in range(MAX_DRUM_NUM):
    for j in range(c):
      color = 'grey55' if (j/bpu)%2 else 'khaki'
      self.button[i][j] = Button(right_frame,  bg=color, width=1, command=self.button_clicked(i,j,bpu))
      self.button[i][j].grid(row=i, column=j)</pre></div><p>The <a id="id261" class="indexterm"/>description of the code is listed as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Within our frame <code class="literal">right_frame</code>, we iterate through a double-nested loop creating a two-dimensional matrix where the number of rows is equal to the constant <code class="literal">MAX_DRUM_NUM</code>, while the number of columns is equal to the product of <span class="strong"><strong>Units</strong></span> and <span class="strong"><strong>BPU</strong></span>.</li><li class="listitem" style="list-style-type: disc">The color of each button is configured to either <code class="literal">grey55</code> or <code class="literal">khaki</code> depending on whether the factor <code class="literal">j/bpu</code> is even or odd.</li><li class="listitem" style="list-style-type: disc">Now if you run the code (code <code class="literal">3.03.py</code>), you will find the number of buttons changing as per selections you make in the units and bpu spin boxes. Moreover, each unit will be colored alternately in khaki and gray colors.</li><li class="listitem" style="list-style-type: disc">Notice how we have defined the <code class="literal">grid</code> geometry position of buttons in terms of variables <code class="literal">i</code> and <code class="literal">j</code>.</li></ul></div></li><li class="listitem">Now that the buttons respond to change in units and bpu, it is time that we change these buttons into toggle buttons. When a user clicks on any of the buttons, the color of the button should change to green. When the button is clicked again, the color reverts to its original color. We need this feature to define beat patterns.<p>We first add a <code class="literal">command</code> callback to our buttons, passing the button's row, column, and bpu as arguments to a new method <code class="literal">button_clicked</code> (refer to the code in <code class="literal">3.03.py</code>), as shown in the following code:</p><div class="informalexample"><pre class="programlisting">self.button[i][j] = (Button(right_frame, bg='grey55', width=1, command=self.Button_clicked(i,j,bpu)))</pre></div><p>We then define the <code class="literal">button_clicked</code> method as follows:</p><div class="informalexample"><pre class="programlisting">def button_clicked(self,i,j,bpu):
  def callback():                 
    btn = self.button[i][j]
    color = 'grey55' if (j/bpu)%2 else 'khaki'
    new_color = 'green' if btn.cget('bg') != 'green' else color
    btn.config(bg=new_color)
  return callback</pre></div><p>The <a id="id262" class="indexterm"/>description of the code is listed as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Our method <code class="literal">button_clicked</code> takes three arguments: <code class="literal">i, j</code>, and <code class="literal">bpu</code>. </li><li class="listitem" style="list-style-type: disc">The variables <code class="literal">i</code> and <code class="literal">j</code> let us track which button is clicked. However, note that the <code class="literal">command</code> callback <code class="literal">self.Button_clicked(i,j,bpu)</code> makes a reference to <code class="literal">i</code> and <code class="literal">j</code> when the button is not yet created. In order to track the button that is clicked by the user, we enclose a separate <code class="literal">callback()</code> function within our <code class="literal">self.button_clicked</code> function, which then returns a callback. Now our method will return a different value of <code class="literal">i</code> and <code class="literal">j</code> for each button record.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">bpu</code> argument is needed to calculate the original color of the button. This is needed to revert the color of button back to its original color if the button is toggled. Before we change the color of the button to green, we store its original color in a variable <code class="literal">color</code>.</li></ul></div></li></ol></div></div><div class="section" title="Objective Complete – Mini Debriefing"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec58"/>Objective Complete – Mini Debriefing</h2></div></div></div><p>We have now completed coding the right drum pad. In the process we have created a two-dimensional list of buttons <code class="literal">self.button</code>, where <code class="literal">self.button[i][j]</code> refers to the button at the <span class="emphasis"><em>i</em></span>th row and <span class="emphasis"><em>j</em></span>th column.</p><p>Each of these buttons can be toggled on or off to represent whether or not a drum sample is to be played for that particular button.</p><p>When a button is on, its color changes to green. If it is switched off, it reverts to its original color. This structure can be easily used to define a beat pattern.</p><p>In the process, we have seen more advanced usage of the Spinbox and Button widget.</p></div></div>
<div class="section" title="Loading drum samples"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec30"/>Loading drum samples</h1></div></div></div><p>Our main objective is to play sound files, in the order of a beat pattern decided by the user. To do this we need to add sound files to the drum machine.</p><p>Our program <a id="id263" class="indexterm"/>does not have any preloaded drum files. Instead, we want to let the user select from a wide variety of drum files. Thus, besides the normal drum, you can play a Japanese tsuzumi, an Indian tabla, Latin American bongo drums, or just about any other sound that you want to add to your rhythm. All you need is a small <code class="literal">.wav</code> or <code class="literal">.ogg</code> file containing that sound's sample.</p><div class="mediaobject"><img src="graphics/7941_03_04.jpg" alt="Loading drum samples"/></div><p>Let us code the ability to add this drum sample to our program.</p><p>The drum sample is to be loaded on the left bar, as shown in the preceding screenshot. We have already created buttons with folder icons to the left-hand side of our drum pad. The desired functionality is simple.</p><p>When a user clicks on any of the left buttons, they should open a file dialog letting the user choose a <code class="literal">.wav</code> or <code class="literal">.ogg</code> file. When the user selects the file and clicks on <span class="strong"><strong>Open</strong></span>, the Entry widget next to that button should be populated with the name of the file. Further, the location of the drum sample file should be added to a list for playing it later.</p><div class="section" title="Engage Thrusters"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec59"/>Engage Thrusters</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First we will import the required modules. To open the sound file, we will <a id="id264" class="indexterm"/>use the <code class="literal">tkFileDialog</code> module. We will also use the <code class="literal">tkMessageBox</code> module to display certain pop-up messages. We will also need to extract the filename of the given sound sample using the <code class="literal">os</code> module. Let us begin by importing the three modules (given in the following code) into our current namespace (refer to the same code present in <code class="literal">3.04.py</code>):<div class="informalexample"><pre class="programlisting">import tkFileDialog
import tkMessageBox
import os</pre></div></li><li class="listitem">Next, we will add Attributes to track the loaded samples. The user will invariably load more than one drum sample. Therefore, we need to track the Entry widget where the drum sample was loaded, the location of each of the drum samples, and a number indicating the current drum number. Accordingly, we create two lists called <code class="literal">self.widget_drum_name</code> and <code class="literal">self.widget_drum_file_name</code> to store the Entry widget instance and file location respectively.<p>We also declare a variable <code class="literal">self.current_drum_no</code> to track the current drum number.</p><p>We choose to initialize these variables and list under our initialization method <code class="literal">__init__</code> (refer to the code in <code class="literal">3.04.py</code>):</p><div class="informalexample"><pre class="programlisting">def __init__(self):
  self.widget_drum_name = []
  self.widget_drum_file_name = [0]*MAX_DRUM_NUM
  self.current_drum_no = 0</pre></div><p>We then modify our <code class="literal">create_left_pad</code> method to include a line that appends a list of all drum Entry widgets in our newly-created list <code class="literal">self.widget_drum_name</code>:</p><div class="informalexample"><pre class="programlisting">self.widget_drum_name.append(self.drum_entry)</pre></div></li><li class="listitem">We then add a <code class="literal">command</code> callback to the buttons in our <code class="literal">create_left_pad</code> method to load drum samples, as shown in the following code snippet:<div class="informalexample"><pre class="programlisting">button = Button(left_frame, image=tbicon, <span class="strong"><strong>command=self.drum_load(i)</strong></span>)</pre></div></li><li class="listitem">Finally, we code our <code class="literal">drum_load</code> method as follows (refer to the code in <code class="literal">3.04.py</code>):<div class="informalexample"><pre class="programlisting">def drum_load(self, drum_no):
  def callback(): 
    self.current_drum_no = drum_no
    try:
      file_name = tkFileDialog.askopenfilename(defaultextension=".wav", filetypes=[("Wave Files","*.wav"),("OGG Files","*.ogg")])Files","*.ogg")])
      if not file_name: return
      try:
        delself.widget_drum_file_name[drum_no]
      except: pass
      self.widget_drum_file_name.insert(drum_no, file_name)
      drum_name = os.path.basename(file_name)
      self.widget_drum_name[drum_no].delete(0, END)
      self.widget_drum_name[drum_no].insert(0, drum_name)
    except:
      tkMessageBox.showerror('Invalid', "Error loading drum samples")
    return callback</pre></div><p>The <a id="id265" class="indexterm"/>description of the code is listed as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We define a callback function within our function because we need to track several drum samples.</li><li class="listitem" style="list-style-type: disc">To track the widget, through which a sound sample has been loaded, we set the <code class="literal">self.current_drum_no</code> value to be equal to the <code class="literal">drum_num</code> value received as an argument from the button <code class="literal">command</code> callback.</li><li class="listitem" style="list-style-type: disc">In a <code class="literal">try</code> block, we use <code class="literal">tkFileDialog.askopenfilename</code> to get the filename of the drum sample. We then check whether a filename already exists in our filename list. If it does, we delete it.</li><li class="listitem" style="list-style-type: disc">Using <code class="literal">os.path.basename</code> from the <code class="literal">os</code> module, we obtain the filename from the file path and insert it into corresponding Entry widget.</li><li class="listitem" style="list-style-type: disc">If <code class="literal">askopenfilename</code> fails, we use <code class="literal">tkMessageBox.showerror</code> to display a custom error message.</li></ul></div></li></ol></div></div><div class="section" title="Objective Complete – Mini Debriefing"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec60"/>Objective Complete – Mini Debriefing </h2></div></div></div><p>In this iteration,<a id="id266" class="indexterm"/> we imported modules to handle dialogs and message boxes. We then added attributes to track drum samples. Finally, we added <code class="literal">command</code> callbacks to buttons which when clicked open a dialog for the user to select drum samples.</p><p>Our code is now capable of loading drum samples and storing all necessary records that we will require to play beat patterns.</p><p>Next, let us turn our attention to playing the beat samples as per a user-defined pattern.</p></div></div>
<div class="section" title="Playing the drum machine"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec31"/>Playing the drum machine</h1></div></div></div><p>Now that we have a mechanism to load drum samples and a mechanism to define beat patterns in place,<a id="id267" class="indexterm"/> let us add the ability to play these beat patterns. In many ways, this is the core of our program.</p><p>Let us first understand the functionality that we want to achieve here. Once the user has loaded one or more drum sample and has defined a beat pattern using the toggle buttons, we need to scan each column of the pattern to see if it finds a green button. If it finds one, our code should play the corresponding drum sample before moving ahead. Moreover, green buttons on the same column should play almost together, while there should be some time gap between each successive column, which would define the tempo of the music.</p><div class="section" title="Prepare for Lift Off"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec61"/>Prepare for Lift Off</h2></div></div></div><p>We will use the <code class="literal">pymedia</code> module to play the sound files. The<code class="literal"> pymedia </code>module can play a wide variety of sound formats such as <code class="literal">.wav</code>, <code class="literal">.ogg</code>, <code class="literal">.mp3</code>, <code class="literal">.avi</code>, <code class="literal">.divx</code>, <code class="literal">.dvd</code>, and <code class="literal">.cdda</code> on multiple operating systems.</p><p>Without getting into the details of how pymedia plays the sound files, the official documentation tells us that we can play audio files using the following code sample:</p><div class="informalexample"><pre class="programlisting">import time, wave, pymedia.audio.sound as sound 
f= wave.open( 'YOUR FILE NAME', 'rb' )
sampleRate= f.getframerate()
channels= f.getnchannels() 
format= sound.AFMT_S16_LE
snd= sound.Output( sampleRate, channels, format )
s= f.readframes( 300000 )
snd.play( s )</pre></div><p>If you run this piece of code as an independent script and supply the file location of a supported audio file in place of <code class="literal">'YOUR FILE NAME'</code>, this should play the media file on your computer.</p><p>Using this code <a id="id268" class="indexterm"/>sample, we will implement the play functionality for our drum machine.</p></div><div class="section" title="Engage Thrusters"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec62"/>Engage Thrusters</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Let us first import all of the necessary modules into our namespace (refer to the code in <code class="literal">3.05.py</code>):<div class="informalexample"><pre class="programlisting">import time
import wave
import pymedia.audio.sound as sound</pre></div></li><li class="listitem">Next, we will define the <code class="literal">play_sound</code> method as follows:<div class="informalexample"><pre class="programlisting">def play_sound(self, sound_filename):
  try:
    self.s = wave.open(sound_filename, 'rb')
    sample_rate = self.s.getframerate()
    channels = self.s.getnchannels()
    frmt = sound.AFMT_S16_LE
          self.snd= sound.Output(sample_rate, channels, frmt)
          s = self.s.readframes(300000)
    self.snd.play(s)
  except:
    pass</pre></div><p>This method simply takes the API provided by <code class="literal">pymedia</code> and wraps it into a method that takes a filename and plays it.</p></li><li class="listitem">Let us now define the <code class="literal">play</code> method that actually plays the beat samples:<div class="informalexample"><pre class="programlisting">def play(self):
  for i in range(len(self.button[0])):
    for item in self.button:
      try:
        if item[i].cget('bg') == 'green':
        if not self.widget_drum_file_name [self.button.index(item)]:continue
        sound_filename = self.widget_drum_file_name [self.button.index(item)]
         self.play_sound(sound_filename)
      except: continue
      time.sleep(3/4.0)</pre></div><p>The description of the code is listed as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We <a id="id269" class="indexterm"/>loop through all of the buttons scanning each column before moving to the next column. For every button, we use <code class="literal">widget.cget()</code> to check to see if its color is green.</li><li class="listitem" style="list-style-type: disc">If the color is green, we check if there is a corresponding drum sample loaded. If not, we ignore the green button and move to the next item in the loop using <code class="literal">continue</code>.</li><li class="listitem" style="list-style-type: disc">If the color is green and there is a corresponding drum sample loaded, we use the previously-defined <code class="literal">pymedia</code> wrapper method for playing audio to play that sample.</li><li class="listitem" style="list-style-type: disc">Before moving to the next column the code is made to sleep for a small interval. If the code is not made to sleep for a small duration, the program would play all the samples at a very rapid succession.</li><li class="listitem" style="list-style-type: disc">We have chosen to make the code sleep for a time period of one-eighth of a second. You can change this sleep time to vary the tempo.</li></ul></div></li></ol></div></div><div class="section" title="Objective Complete – Mini Debriefing"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec63"/>Objective Complete – Mini Debriefing </h2></div></div></div><p>In this iteration, we added the capability to play the loaded drum samples.</p><p>Our drum machine is now operational. You can load drum samples, define beat patterns, and when you click on the <span class="strong"><strong>Play</strong></span> button, the drum machine plays that beat pattern!</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note24"/>Note</h3><p>In this example, we decided whether or not to play a drum sample based on the color of the button. This has been used here for demonstration purposes. However, it is not a good practice to mix logic with appearance. A better idea would be to implement a data structure for buttons that would keep track of button state as "clicked" or "not-clicked", and then play the audio based on this button's state. Implementation of this dual button states is left as an exercise for you to explore.</p></div></div></div><div class="section" title="Classified Intel"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec64"/>Classified Intel</h2></div></div></div><p>In our previous code, we used <code class="literal">widget.cget()</code> to fetch the current value of the button's <code class="literal">bg</code> option to check if it is green. You can use <code class="literal">w.cget(key)</code> to return the current value of a widget option. Also, note that <code class="literal">cget()</code> always returns the value as a string even if you give a nonstring value when configuring the widget option.</p><p>Similar to <code class="literal">widget.cget()</code>method<a id="id270" class="indexterm"/>, Tkinter offers a wide variety of methods for all its widgets. For a list of basic widget methods, refer to the <span class="emphasis"><em>The basic widget methods</em></span> section in <a class="link" href="apb.html" title="Appendix B. Quick Reference Sheets">Appendix B</a>, <span class="emphasis"><em>Quick Reference Sheets</em></span>.</p><p>If you want<a id="id271" class="indexterm"/> to know all of the options configured for a particular widget, you may use the <code class="literal">widget.config()</code> method instead, as follows: (See the code in <code class="literal">3.06.py</code>)</p><div class="informalexample"><pre class="programlisting">from Tkinter import *
root = Tk()
widget = Button(root, text="#", bg='green')
widget.pack()
print widget.config()
print widget.config('bg')
root.mainloop()</pre></div><p>This code will print a dictionary showing all the key-value pairs for widget options and their values listed as tuples. For example, in the preceding code the line <code class="literal">print widget.config('bg')</code> prints a tuple:</p><div class="informalexample"><pre class="programlisting">('background', 'background', 'Background', &lt;border object at 022A1AC8&gt;, 'green')</pre></div></div></div>
<div class="section" title="Tkinter and threading"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec32"/>Tkinter and threading</h1></div></div></div><p>Our drum machine plays patterns in the way that we want it to. However, there is a small problem. The <code class="literal">play</code> method<a id="id272" class="indexterm"/> blocks the main loop of our Tkinter program. It does not relinquish control back to the main loop until it is done playing all of the sound samples.</p><p>This means that if you now want to click on the <span class="strong"><strong>Stop</strong></span> button<a id="id273" class="indexterm"/> or change some other widget, you will have to wait for the <code class="literal">play</code> loop to complete.</p><p>You might have noticed that when you hit the <span class="strong"><strong>Play</strong></span> button, it remains pressed for the time the sound loops are being played. During that time you cannot access any other widget in the Toplevel window.</p><p>This clearly is a glitch. We need some method to confer back the control to Tkinter main loop while the play is still in progress.</p><div class="section" title="Prepare for Lift Off"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec65"/>Prepare for Lift Off</h2></div></div></div><p>One of the simplest ways that we can achieve this is to use the <code class="literal">root.update()</code>method within our <code class="literal">play</code> loop. This updates the <code class="literal">root.mainloop()</code> method<a id="id274" class="indexterm"/> after each sound sample is played (see the commented code in <code class="literal">3.07.py</code>).</p><p>However, this is an inelegant method because the control is passed to the main loop with some staggering experienced in the GUI. Thus, you may experience a slight delay in responses of other widgets in the Toplevel.</p><p>Further, if some other event causes the method to be called, it could result in a nested event loop.</p><p>A better solution would be to run the <code class="literal">play</code> method from a separate thread. To do that let us employ the<a id="id275" class="indexterm"/> <code class="literal">threading</code> module of Python.</p></div><div class="section" title="Engage Thrusters"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec66"/>Engage Thrusters</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Let us first import the <code class="literal">threading</code> module into our namespace (refer to the code in <code class="literal">3.07.py</code>):<div class="informalexample"><pre class="programlisting">import threading</pre></div></li><li class="listitem">Now, let us create a method that calls the <code class="literal">self.play()</code> method<a id="id276" class="indexterm"/> to run in a separate thread. This redirects <code class="literal">play</code> through the threading model:<div class="informalexample"><pre class="programlisting">def play_in_thread(self):
  self.thread = threading.Thread(None, self.play, None, (), {})
  self.thread.start()</pre></div></li><li class="listitem">Finally, change the <code class="literal">command</code> callback for the <span class="strong"><strong>Play</strong></span> button in the <code class="literal">play_bar</code> method from the existing <code class="literal">self.play()</code> method to <code class="literal">self.play_in_thread()</code>:<div class="informalexample"><pre class="programlisting">button=Button(playbar_frame, text ='Play', command= self.play_in_thread)</pre></div><p>Now if you load some drum samples, define the beat patterns, and hit the <span class="strong"><strong>Play</strong></span> button, the sound will play in a separate thread without preventing the main loop from updating (refer to the code in <code class="literal">3.07.py</code>).</p></li><li class="listitem">The next step would be that of coding the <span class="strong"><strong>Stop</strong></span> button. The role of the <span class="strong"><strong>Stop</strong></span> button is simple; it merely stops the currently playing pattern. To do that, we first add a <code class="literal">command</code> callback to the <span class="strong"><strong>Stop</strong></span> button calling on a method <code class="literal">stop_play</code> as follows (see the code in <code class="literal">3.07.py</code>):<div class="informalexample"><pre class="programlisting">button=Button(playbar_frame, text='Stop', command= self.stop_play)</pre></div><p>Then we define the <code class="literal">stop_play</code> method<a id="id277" class="indexterm"/> as follows:</p><div class="informalexample"><pre class="programlisting">def stop_play(self):
  self.keep_playing = False</pre></div></li><li class="listitem">Our thread <a id="id278" class="indexterm"/>system now runs the <code class="literal">play</code> method from a separate thread. However, if the user clicks on the button more than once, this will spawn more threads, which will play the beat. To avoid this, the button should be configured with <code class="literal">state='disabled'</code>, and enabled again when the sequence finishes.<p>To disable the <span class="strong"><strong>Play</strong></span> button when the program starts running, we add the following line to our <code class="literal">play_in_thread</code> method (refer to the code in <code class="literal">3.07.py</code>):</p><div class="informalexample"><pre class="programlisting">self.start_button.config(state='disabled')</pre></div><p>Similarly, when the sequence finishes playing or the <span class="strong"><strong>Stop</strong></span> button is clicked, we want to enable the <span class="strong"><strong>Play</strong></span> button again. To enable it, we add the following line to our <code class="literal">play</code> and <code class="literal">stop_play</code> methods:</p><div class="informalexample"><pre class="programlisting">self.start_button.config(state='normal')</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note25"/>Note</h3><p>
<span class="strong"><strong>Tkinter and thread safety</strong></span>
</p><p>Tkinter is not<a id="id279" class="indexterm"/> thread safe. The Tkinter interpreter is valid only in the thread that runs the main loop. Any call to widgets must ideally be done from the thread that created the main loop. Invoking widget-specific commands from other threads is possible (as we do here), but is not reliable.</p><p>When you call a widget from another thread, the events get queued for the interpreter thread, which executes the command and passes the result back to the calling thread. If the main loop is running but not processing events, it sometimes results in unpredictable exceptions.</p></div></div><p>The only change we make to our existing <code class="literal">play</code> method is to include the entire code in a <code class="literal">try-except</code> block. We do this because Tkinter is not thread safe and can cause some unwanted exceptions when dealing with the <code class="literal">play</code> thread. The best we can do here is ignore those cases using a <code class="literal">try-except</code> block.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip12"/>Tip</h3><p>
<span class="strong"><strong>mtTkinter – a thread-safe version of Tkinter</strong></span>
</p><p>If you find yourself working on an inherently multithreaded project, you might consider looking at <a id="id280" class="indexterm"/>
<span class="strong"><strong>mtTkinter</strong></span>
<a id="id281" class="indexterm"/>
<span class="strong"><strong>—</strong></span>a thread-safe version of Tkinter. For more information on mtTkinter, visit <a class="ulink" href="http://Tkinter.unPythonic.net/wiki/mtTkinter">http://Tkinter.unPythonic.net/wiki/mtTkinter</a>.</p><p>For more<a id="id282" class="indexterm"/> specialized multiprocessing needs you may also want to take a look at<span class="emphasis"><em> multiprocessing module</em></span> or an <span class="emphasis"><em>event model</em></span> such as <span class="strong"><strong>Twisted</strong></span>.<a id="id283" class="indexterm"/>
</p></div></div></li><li class="listitem">The last<a id="id284" class="indexterm"/> step sees us code the <span class="strong"><strong>Loop</strong></span> Checkbutton. The role of the <span class="strong"><strong>Loop</strong></span> checkbox is simple. If the <span class="strong"><strong>Loop</strong></span> checkbox is unchecked, the pattern plays only once. If it is checked, the pattern keeps playing in an endless loop. The pattern stops playing only if the <span class="strong"><strong>Loop</strong></span> Checkbutton is unchecked or if the <span class="strong"><strong>Stop</strong></span> button is pressed.<p>We add a <code class="literal">command</code> callback to the <span class="strong"><strong>Loop</strong></span> checkbox:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>loopbutton = Checkbutton(playbar_frame</strong></span>, text='Loop', variable=loop, command=lambda: self.LoopPlay(loop.get())) )</pre></div><p>We then define the <code class="literal">loop_play</code> method as follows:</p><div class="informalexample"><pre class="programlisting">def loop_play(self, xval):
  self.loop = xval</pre></div><p>Equipped with these two variables, we modify our <code class="literal">play</code> method to keep playing while <code class="literal">self.keep_playing</code> is equal to <code class="literal">True</code> see the code in <code class="literal">3.07.py</code>).</p><p>If the value of <code class="literal">self.loop</code> is equal to <code class="literal">False</code>, we set the value of <code class="literal">self.keep_playing</code> equal to <code class="literal">False</code>, which breaks out of the play loop.</p></li></ol></div></div><div class="section" title="Objective Complete – Mini Debriefing"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec67"/>Objective Complete – Mini Debriefing </h2></div></div></div><p>This completes the project iteration. In this round, we refined our <code class="literal">play</code> method to play the audio files from a separate thread.</p><p>We used Python's built-in threaded module to play the loops in separate thread. We looked at some of the threading-related limitations of Tkinter and some ways in which we can overcome those limitations.</p><p>We also coded for the <span class="strong"><strong>Stop</strong></span> button and <span class="strong"><strong>Loop</strong></span> checkbox functionality.</p></div></div>
<div class="section" title="More beat patterns"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec33"/>More beat patterns</h1></div></div></div><p>Our drum program is now functional. You can load drum samples and define a beat pattern and our drum machine will play it out. Let us now extend our drum program so that we are  able to create more than <a id="id285" class="indexterm"/>one pattern in the same program.</p><p>Rather than a single drum pattern, now we will have a list of patterns. While playing the patterns, a user will be able to switch between many different beat patterns. This will allow the drummer to add variations to the performance.</p><div class="section" title="Engage Thrusters"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec68"/>Engage Thrusters</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The first thing we need to do is add a Spinbox widget in the top bar (as shown in the following screenshot), which will keep count of the number of patterns. We also add an Entry widget next to the Spinbox widget to keep track of the pattern name, which is decided by the number selected in the spin box.<div class="mediaobject"><img src="graphics/7941_03_05.jpg" alt="Engage Thrusters"/></div><p>This is added to the <code class="literal">create_top_bar</code> method<span class="emphasis"><em> </em></span>(refer to the code in <code class="literal">3.08.py</code>):</p><div class="informalexample"><pre class="programlisting">Label(top_bar_frame, text='Pattern Number:').grid(row=0, column=1)
self.patt = IntVar()
self.patt.set(0)
self.prevpatvalue = 0 # to trace last click
Spinbox(top_bar_frame, from_=0, to=9, width=5, textvariable=self.patt, command=self.record_pattern).grid(row=0, column=2)
self.pat_name = Entry(top_bar_frame)
self.pat_name.grid(row=0, column=3, padx=7,pady=2)
self.pat_name.insert(0, 'Pattern %s'%self.patt.get())
self.pat_name.config(state='readonly')</pre></div><p>The description of the code is listed as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The pattern number is stored in a Tkinter integer variable as <code class="literal">self.patt</code>.</li><li class="listitem" style="list-style-type: disc">The Entry widget that stores the corresponding pattern name is called <code class="literal">self.pat_name</code>. This widget is marked as "read only", as we do not want to allow the user to modify the name.</li><li class="listitem" style="list-style-type: disc">The Spinbox widget has a <code class="literal">command</code> callback to a new method <code class="literal">record_pattern</code>.</li></ul></div></li><li class="listitem">Let us<a id="id286" class="indexterm"/> now code the <code class="literal">record_pattern</code> method. The role of this method is to keep track of the state of a given pattern. Thus, for every pattern it needs to track the pattern number, units, BPU, drum samples loaded, and the beat pattern defined by the user for that pattern number. We will store this information in a list named <code class="literal">self.pattern_list</code>.<p>Our pattern spin box allows for adding 10 patterns. Therefore, we first initialize <code class="literal">self.pattern_list</code> as an empty list comprising of 10 empty spaces.</p><p>We initialize it in our class <code class="literal">__init__</code> method as follows (also seen in the code <code class="literal">3.08.py</code>):</p><div class="informalexample"><pre class="programlisting">self.pattern_list = [None]*10</pre></div><p>Let us now code the <code class="literal">record_pattern</code> method<a id="id287" class="indexterm"/>:</p><div class="informalexample"><pre class="programlisting">def record_pattern(self):
  pattern_num, bpu, units = self.patt.get(),self.bpu.get(), self.units.get()
  self.pat_name.config(state='normal')
  self.pat_name.delete(0, END)
  self.pat_name.insert(0, 'Pattern %s'%pattern_num)
  self.pat_name.config(state='readonly')
  prevpval = self.prevpatvalue
  self.prevpatvalue = pattern_num
  c = bpu*units
  self.buttonpickleformat =[[0] * c for x in range MAX_DRUM_NUM)]
  for i in range(MAX_DRUM_NUM):
    for j in range(c):
      if self.button[i][j].config('bg')[-1] == 'green':
        self.buttonpickleformat[i][j] = 'active'
        self.pattern_list[prevpval] = {'df': self.widget_drum_file_name, 'bl': self.buttonpickleformat, 'bpu':bpu, 'units':units}
  self.reconstruct_pattern(pattern_num, bpu, units)</pre></div><p>The <a id="id288" class="indexterm"/>description of the code is listed as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The first line simply fetches the value of the current pattern number, bout, and units for the pattern to be recorded.</li><li class="listitem" style="list-style-type: disc">The next four lines of this code do one simple job. For every change in pattern, it simply updates the corresponding Entry widget with the new name of the pattern. Since the Entry widget is "read only", we first configure its state as <code class="literal">normal</code> to allow us to enter text into the Entry widget. We then delete anything that might already be written in the widget and enter the new pattern name with the Python string formatting of <code class="literal">pattern_num'Pattern %s'%pattern_num</code>. Finally, we restore the entry widget to a <code class="literal">read only</code> state.</li><li class="listitem" style="list-style-type: disc">The next two lines keep track of the last Spinbox widget number.</li><li class="listitem" style="list-style-type: disc">The next four lines of code actually record the state of the user-defined pattern in a two-dimensional list named <code class="literal">self.buttonpickleformat</code>. The list is first initialized to an empty two-dimensional matrix, taking into consideration the size of the pattern maker.</li><li class="listitem" style="list-style-type: disc">The loop then goes through every single button in the current pattern. If the button is not selected (not green), it leaves the value as <code class="literal">0</code>. If the button is selected (green), the value at the corresponding place is changed from <code class="literal">0</code> to <code class="literal">active</code>. Using this list we can then easily reproduce the user-defined pattern later on.</li><li class="listitem" style="list-style-type: disc">Finally, all of this pattern-related data is stored as a list of the dictionary: <code class="literal">self.pattern_list[prevpval] = {'df': self.widget_drum_file_name, 'bl': self.buttonpickleformat, 'bpu':bpu, 'units':units}</code></li><li class="listitem" style="list-style-type: disc">The key <code class="literal">df</code> stores the list of drum filenames. The key <code class="literal">bl</code> stores the pattern defined by the button. The key <code class="literal">bpu</code> stores the BPU for that pattern, and the key <code class="literal">units</code> stores the units for that pattern.</li><li class="listitem" style="list-style-type: disc">Now that all of these items for a pattern are stored as a dictionary, we can easily use the dictionary to reconstruct the pattern. The last line calls the method<a id="id289" class="indexterm"/> <code class="literal">reconstruct_pattern()</code>, which actually does the reconstruction for us.</li></ul></div></li><li class="listitem">Now that <a id="id290" class="indexterm"/>we have stored pattern records, we need some method to reconstruct those patterns on our drum board. We define a new method <code class="literal">reconstruct_pattern</code> to handle it, as shown in the following code see the code in <code class="literal">3.08.py</code>):<div class="informalexample"><pre class="programlisting">    def reconstruct_pattern(self,pattern_num, bpu, units):
        self.widget_drum_file_name = [0]*MAX_DRUM_NUM
        try:
            self.df = self.pattern_list[pattern_num]['df']
            for i in range(len(self.df)):
                    file_name = self.df[i]
                    if file_name == 0:
                        self.widget_drum_name[i].delete(0, END)
                        continue
                    self.widget_drum_file_name.insert(i, file_name)
                    drum_name = os.path.basename(file_name)
                    self.widget_drum_name[i].delete(0, END)
                    self.widget_drum_name[i].insert(0, drum_name)
        except:            
                for i in range(MAX_DRUM_NUM):
                    try: self.df
                    except:self.widget_drum_name[i].delete(0, END)
        try:
            bpu = self.pattern_list[pattern_num]['bpu']
            units = self.pattern_list[pattern_num]['units']
        except:
            return
        self.bpu_widget.delete(0, END)
        self.bpu_widget.insert(0, bpu)
        self.units_widget.delete(0, END)
        self.units_widget.insert(0, units)
        self.create_right_pad()
        c = bpu * units
        self.create_right_pad()
        try:
            for i in range(MAX_DRUM_NUM):
                for j in range(c):
                    if self.pattern_list[pattern_num]['bl'][i][j] == 'active':
                       self.button[i][j].config(bg='green')
        except:return</pre></div><p>This code<a id="id291" class="indexterm"/> can be broken into three broad parts:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Reconstructing drum sample uploads</li><li class="listitem" style="list-style-type: disc">Reconstructing BPU and units</li><li class="listitem" style="list-style-type: disc">Reconstructing beat patterns</li></ul></div><p>Having reconstructed these three things, we can easily replay any beat pattern. A brief description of each of these is as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The list of drum filenames for a given pattern can easily be acquired from the key-value pair of the dictionary item <code class="literal">self.pattern_list[pattern_num]['df']</code>. We then iterate through items in this list and fill up the Entry widgets with each drum sample's filename.</li></ul></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We then fetch the value of BPU and units from the dictionary keys <code class="literal">self.pattern_list[pattern_num]['bpu']</code> and <code class="literal">self.pattern_list[pattern_num]['units']</code>. We insert these values in their respective Spinbox widgets and then call the <code class="literal">create_right_pad()</code> method<a id="id292" class="indexterm"/>, which places the desired number of buttons on the right pad.</li><li class="listitem" style="list-style-type: disc">In the last iteration, we fetch the value of dictionary key <code class="literal">self.pattern_list[pattern_num]['bl']</code>, which gives us the position of the green buttons. Iterating through a loop, we check if a particular button is to be set to <code class="literal">active</code>. If yes, we change the color of the button to green.</li><li class="listitem" style="list-style-type: disc">Combined together, we can now load the previously recorded drum samples, set their <span class="strong"><strong>Units</strong></span> and <span class="strong"><strong>BPU</strong></span> values, and reconstruct the beat pattern as per previously set values.</li><li class="listitem" style="list-style-type: disc">At each stage, the code checks if it cannot reconstruct a particular pattern because of invalid file markup. If it does find some invalid markup, it breaks out of the code using appropriate exception handling.</li></ul></div></li></ol></div><p>Hit the <span class="strong"><strong>Play</strong></span> button<a id="id293" class="indexterm"/> and the drum machine will start rolling sound. Change the pattern number and define a new beat pattern. The new pattern will start playing. Revert to older patterns and the older patterns start playing again (refer to the code in <code class="literal">3.08.py</code>).</p></div><div class="section" title="Objective Complete – Mini Debriefing"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec69"/>Objective Complete – Mini Debriefing </h2></div></div></div><p>We've completed coding our drum machine to support the storing of multiple beat patterns, and the ability to play these patterns simply by changing the pattern number. This gives the user the ability to make different beats for the intro, verse, chorus, bridge, and other parts of a song.</p><p>In the process, we saw how to use Python's built-in data types to store custom data and to reproduce them in any required way.</p></div></div>
<div class="section" title="Object persistence"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec34"/>Object persistence</h1></div></div></div><p>In the preceding iteration, we added the capability to define multiple beat patterns. However, the beat patterns can be played only on a single script run. When the program is closed and restarted, all previous pattern data is lost.</p><p>We need a way to persist or store the beat patterns beyond a single program run. We need the ability to store values in some form of file storage and reload, play, and even edit the patterns. We need some form of <a id="id294" class="indexterm"/>object persistence.</p><div class="section" title="Prepare for Lift Off"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec70"/>Prepare for Lift Off</h2></div></div></div><p>Python provides several modules for object persistence. The <a id="id295" class="indexterm"/>module that we will use for <a id="id296" class="indexterm"/>persistence is called the <a id="id297" class="indexterm"/>
<span class="strong"><strong>pickle module</strong></span>. This is a standard library of Python.</p><p>An object represented as a string of bytes is called <span class="strong"><strong>pickle</strong></span>
<a id="id298" class="indexterm"/> in Python. <span class="strong"><strong>Pickling</strong></span>
<a id="id299" class="indexterm"/>, also known as <span class="strong"><strong>object serialization</strong></span>
<a id="id300" class="indexterm"/>, lets us convert our object into a string of bytes. The process reconstructing of the object back from the string of bytes is called <span class="strong"><strong>unpickling</strong></span>
<a id="id301" class="indexterm"/> or <span class="strong"><strong>deserialization</strong></span>.<a id="id302" class="indexterm"/>
</p><p>More information about the <code class="literal">pickle</code> module is available at <a class="ulink" href="http://docs.python.org/2/library/pickle.html">http://docs.python.org/2/library/pickle.html</a>.</p><p>Let us illustrate it with a simple example:</p><div class="informalexample"><pre class="programlisting">import pickle
party_menu= ['Bread', 'Salad', 'Bordelaise','Wine', 'Truffles']
pickle.dump(party_menu, open( "mymenu.p", "wb" ) )</pre></div><p>First, we serialize <a id="id303" class="indexterm"/>or pickle our list <code class="literal">PartyMenu</code> using <code class="literal">pickle.dump</code> and save it in an external file <code class="literal">mymenu.p</code>.</p><p>We later <a id="id304" class="indexterm"/>retrieve the object using <code class="literal">pickle.load</code>:</p><div class="informalexample"><pre class="programlisting">import pickle
menu= pickle.load( open( "mymenu.p", "rb" ) )
print menu # ['Bread', 'Salad', 'Bordelaise', 'Wine', 'Truffles']</pre></div><p>Remember that in our previous iteration, we created a list, called <code class="literal">self.pattern_list</code>, where each item of the list is a dictionary that stores information about one single beat pattern.</p><p>If we need to reuse this information, we only need to pickle this <code class="literal">self.pattern_list</code>. Having saved the object, we can later easily unpickle the file to reconstruct our beat patterns.</p></div><div class="section" title="Engage Thrusters"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec71"/>Engage Thrusters</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We first need to add three top menu items to our program, as shown in the following screenshot:<div class="mediaobject"><img src="graphics/7941_03_06.jpg" alt="Engage Thrusters"/></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>File</strong></span> | <span class="strong"><strong>Load Project</strong></span></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>File</strong></span> | <span class="strong"><strong>Save Project</strong></span></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>File</strong></span> | <span class="strong"><strong>Exit</strong></span></li></ul></div><p>While we are creating our menu items let us also add an <span class="strong"><strong>About</strong></span> menu item:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>About</strong></span> | <span class="strong"><strong>About</strong></span></li></ul></div><p>Here,<a id="id305" class="indexterm"/> we are particularly interested in saving the <a id="id306" class="indexterm"/>project (pickling), and loading the project back (unpickling). The code for menu items is defined in a separate method called <code class="literal">create_top_menu</code>, as shown in the following code (also refer to the code in <code class="literal">3.09.py</code>):</p><div class="informalexample"><pre class="programlisting">def create_top_menu(self):
  self.menubar = Menu(self.root)
  self.filemenu = Menu(self.menubar, tearoff=0 ) 
  self.filemenu.add_command(label="Load Project",command=self.load_project )
  self.filemenu.add_command(label="Save Project",command=self.save_project)
  self.filemenu.add_separator()
  self.filemenu.add_command(label="Exit",command=self.exit_app) 
  self.menubar.add_cascade(label="File",menu=self.filemenu)
  self.aboutmenu = Menu(self.menubar, tearoff=0 ) 
  self.aboutmenu.add_command(label="About",command=self.about)
  self.menubar.add_cascade(label="About",menu=self.aboutmenu)
  self.root.config(menu=self.menubar)   </pre></div><p>The code is self-explanatory. We have created similar menu items in our last two projects. Finally, to display this menu, we call this method from our <code class="literal">Main</code> method.</p></li><li class="listitem">To pickle our object, we first import the <code class="literal">pickle</code> module into the current namespace as follows (see the code in <code class="literal">3.09.py</code>):<div class="informalexample"><pre class="programlisting">import pickle</pre></div><p>The <span class="strong"><strong>Save Project</strong></span> menu has a <code class="literal">command</code> callback attached to <code class="literal">self.save_project</code>, which is where we define the pickling process:</p><div class="informalexample"><pre class="programlisting">def save_project(self):
  self.record_pattern() #make sure last pattern is recorded
  file_name = tkFileDialog.asksaveasfilename(filetypes=[('Drum Beat File','*.bt')] , title="Save project as...")
  pickle.dump(self.pattern_list,open( file_name, "wb" ) "wb" ) )
  self.root.title(os.path.basename(filenamefile_name) + " - DrumBeast")</pre></div><p>The <a id="id307" class="indexterm"/>description of the code is listed as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Recall that<a id="id308" class="indexterm"/> a pattern is added to <code class="literal">self.pattern_list</code> only when the pattern number is changed by the user. In situations where a user might have defined a beat pattern but may not have clicked on the pattern number's Spinbox widget, the pattern is not included in <code class="literal">self.pattern_list</code>. To make sure it is added, we first call <code class="literal">self.record_pattern</code> to capture this beat pattern.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">save_project</code> method is called when the user clicks on the <span class="strong"><strong>Save Project</strong></span> menu, hence, we need to give the user an option to save the project in a file. We have chosen to define a new file extension (<code class="literal">.bt</code>) to keep track of our beat patterns.</li><li class="listitem" style="list-style-type: disc">When the user specifies the filename with <code class="literal">.bt</code> extension, the data in the <code class="literal">self.pattern_list</code> object is dumped into the file using <code class="literal">pickle.dump</code>.</li><li class="listitem" style="list-style-type: disc">Lastly, the title of the Toplevel window is changed to reflect the filename.</li></ul></div></li><li class="listitem">We are done pickling the object. Let us now code the unpickling process.<p>The unpickling process is handled by a method <code class="literal">load_project</code>, which is called from the <span class="strong"><strong>Load Project</strong></span> menu as follows:</p><div class="informalexample"><pre class="programlisting">def load_project(self):
  file_name = tkFileDialog.askopenfilename(filetypes=[('Drum Beat File','*.bt')], title='Load Project') 
  if file_name == '':return
  self.root.title(os.path.basename(file_name) + " - DrumBeast")
  fh = open(file_name,"rb") # open the file in reading mode
  try:
    while True: # load from the file until EOF is reached
      self.pattern_list = pickle.load(fh)
  exceptEOFError:
    pass
  fh.close()
  try:
    self.Reconstruct_pattern(0,pattern_listself.pattern_list[0]['bpu'],pattern_listself.pattern_list[0]['units'])
  except:
    tkMessageBox.showerror("Error","An unexpected erroroccurred trying to reconstruct patterns")</pre></div><p>The <a id="id309" class="indexterm"/>description of the code is listed as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">When a user<a id="id310" class="indexterm"/> clicks on the <span class="strong"><strong>Load Project</strong></span> menu, the first line of the method prompts him/her with an <span class="strong"><strong>Open File</strong></span> window. When the user specifies a previously pickled file with a <code class="literal">.bt</code> extension, the filename is stored in a variable called <code class="literal">file_name</code>.</li><li class="listitem" style="list-style-type: disc">If the filename returned is <code class="literal">none</code> because the user cancels the <span class="strong"><strong>Open File</strong></span> dialog, nothing is done.</li><li class="listitem" style="list-style-type: disc">If filename is supplied, the title of the Toplevel window is changed to add the filename. The file is then opened in read mode, and the contents of the file are read into <code class="literal">self.pattern_list</code> using <code class="literal">pickle.load</code>.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">self.pattern_list</code> now contains the list of beat patterns defined in the previous pickle. The file is closed and the first pattern of <code class="literal">self.pattern_list</code> is reconstructed in the drum machine. If there are more than one patterns defined in the serialized file, you can view each of the patterns simply by changing the pattern number Spinbox widget.</li><li class="listitem" style="list-style-type: disc">Try playing any of the patterns, and you should be able to replay the pattern exactly as it was defined at the time of pickling.<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip13"/>Tip</h3><p>Pickling, though great for serialization, is vulnerable to malicious or erroneous data. You may want to use pickle only if the data is from a trusted source, or if proper validation mechanisms are in place.</p><p>You may also find the <code class="literal">json</code> module useful for serializing objects in <span class="strong"><strong>JSON</strong></span> and <span class="strong"><strong>ElementTree</strong></span>
<a id="id311" class="indexterm"/>, or <a id="id312" class="indexterm"/>
<span class="strong"><strong>xml.minidom</strong></span> libraries relevant for parsing XML data.</p></div></div></li></ul></div></li><li class="listitem">Now, let <a id="id313" class="indexterm"/>us complete coding our <code class="literal">exit</code> and <code class="literal">about</code> commands:<div class="informalexample"><pre class="programlisting">def about(self):
  tkMessageBox.showinfo("About", "About Info")

def exit_app(self):
  if tkMessageBox.askokcancel("Quit", "Really Quit?"):
    self.root.destroy()</pre></div><p>And add this line to our <code class="literal">app</code> method to override the <span class="strong"><strong>Close</strong></span> button of the Toplevel window:</p><div class="informalexample"><pre class="programlisting">self.root.protocol('WM_DELETE_WINDOW', self.exit_app)</pre></div><p>This is<a id="id314" class="indexterm"/> self-explanatory. We have done similar coding in our previous project.</p></li></ol></div></div><div class="section" title="Objective Complete – Mini Debriefing"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec72"/>Objective Complete – Mini Debriefing </h2></div></div></div><p>In this iteration, we used Python's built-in <code class="literal">pickle</code> module to pickle and unpickle the beat patterns defined by the user.</p><p>This now lets us save patterns defined by the user. We have also provided the ability to load, replay, and edit the project later.</p><p>Now, if you define one or more beat patterns in your program you can save the project with a <code class="literal">.bt</code> file extension. You can later load the project and start working on it from the place where you had last left it.</p><p>While we were dealing with the top menu we also completed the code for the <span class="strong"><strong>About</strong></span> and <span class="strong"><strong>Exit</strong></span> menu items.</p></div></div>
<div class="section" title="ttk-themed widgets"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec35"/>ttk-themed widgets</h1></div></div></div><p>We are almost done programming our<a id="id315" class="indexterm"/> drum machine. However, we would like to end this project by introducing you to the ttk-themed widgets.</p><div class="section" title="Prepare for Lift Off"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec73"/>Prepare for Lift Off</h2></div></div></div><p>On many platforms such as Windows and X11, Tkinter does not bind to the native platform widgets. The Tk toolkit (and Tkinter) originally appeared on X-Window systems, hence, it adopted the motif look and feel, which was the de facto standard for GUI development on X-Window systems. When Tk was ported to other platforms, such as Windows and Mac OS, this Motif style started appearing out of place with the look of these platforms.</p><p>Due to this, <a id="id316" class="indexterm"/>some even argue that Tkinter widgets are rather ugly and do not integrate well with such desktop environments.</p><p>Another criticism of Tkinter is based on the fact that Tkinter mixes logic and styling by allowing both to be changed as widget options.</p><p>It was also criticized to lack any kind of theming support. While we saw an example of centralized styling via the option database, the method required styling to be done at the widget level. It does not allow for selective styling of two button widgets differently, as an example. This made it difficult for developers to implement visual consistency for similar groups of widgets while differentiating them from other groups of widgets. As a result of this, many GUI developers moved to Tkinter alternatives such as <span class="strong"><strong>wxPython</strong></span>
<a id="id317" class="indexterm"/>, <span class="strong"><strong>glade</strong></span>
<a id="id318" class="indexterm"/>, <span class="strong"><strong>PyQT</strong></span>
<a id="id319" class="indexterm"/>, and others.</p><p>With Tkinter 8.5, the makers of Tkinter have tried to address all these concerns by introducing the <code class="literal">ttk</code> module, which may be considered as an advance to the original Tkinter module.</p><p>Let us take a look at some of the features offered by the ttk-themed widgets module.</p><p>One of the first things that <code class="literal">ttk</code> does is that it provides a set of built-in themes that allows Tk widgets to look like the native desktop environment in which the application is running.</p><p>Additionally, it introduces six new widgets: <a id="id320" class="indexterm"/>Combobox<a id="id321" class="indexterm"/>, <a id="id322" class="indexterm"/>Notebook<a id="id323" class="indexterm"/>, <a id="id324" class="indexterm"/>Progressbar<a id="id325" class="indexterm"/>, <a id="id326" class="indexterm"/>Separator<a id="id327" class="indexterm"/>, <a id="id328" class="indexterm"/>Sizegrip,<a id="id329" class="indexterm"/> and Treeview<a id="id330" class="indexterm"/> to the list of widgets, in addition to supporting 11 core Tkinter widgets, which are Button, <a id="id331" class="indexterm"/>Checkbutton, Entry, Frame, Label, LabelFrame, Menubutton, PanedWindow, Radiobutton, Scale, and Scrollbar.</p><p>To use the <code class="literal">ttk</code> module, we first import it into the current namespace:</p><div class="informalexample"><pre class="programlisting">import ttk</pre></div><p>You can display the <code class="literal">ttk</code> widgets as follows see the code in <code class="literal">3.10.py</code>):</p><div class="informalexample"><pre class="programlisting">ttk.Button(root, text='ttk Button').grid(row=1, column=1)
ttk.Checkbutton(root, text='tkCheckButton').grid(row=2, column=1)</pre></div><p>For a <a id="id332" class="indexterm"/>comparison of displays between the normal Tkinter widgets and the counterpart ttk widgets, see the code in <code class="literal">3.10.py</code>, which produces a window, as shown in the following screenshot. Notice how the widgets look like more native widgets on your platform.</p><div class="mediaobject"><img src="graphics/7941_03_07.jpg" alt="Prepare for Lift Off"/></div><p>
<code class="literal">3.10.py</code> also shows dummy examples of all the new widgets introduced in the <code class="literal">ttk</code> module.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip15"/>Tip</h3><p>You can even override the basic Tkinter widgets by importing <code class="literal">ttk</code> after <code class="literal">Tkinter</code> as follows:</p><div class="informalexample"><pre class="programlisting">from Tkinter import *
from ttk import *</pre></div><p>This causes all widgets common to Tk and ttk to be replaced by ttk widgets.</p><p>This has the direct benefit of using the new widgets, which gives a better look and feel across platforms.</p><p>However, the disadvantage of this kind of import, is that you cannot distinguish the module from which the widget classes are imported. This is important because <code class="literal">Tkinter</code> and <code class="literal">ttk</code> widget classes are not completely interchangeable. In this case, an unambiguous solution is to import them, as shown in the following codeimport Tkinter as tk</p><div class="informalexample"><pre class="programlisting">import ttk</pre></div></div></div><p>While most of the configuration options for Tkinter and ttk widgets are common, ttk-themed widgets do not support styling options such as <code class="literal">fg</code>, <code class="literal">bg</code>, <code class="literal">relief</code>, <code class="literal">border</code>, and more. This <a id="id333" class="indexterm"/>is purposefully removed from ttk in an attempt to keep logic and styling in different controls.</p><p>Instead, all styling-related options are handled by the respective style names. In a standard <code class="literal">ttk</code> module, each widget has an associated style name. You can retrieve the default style name of a widget using the <code class="literal">widget.winfo_class()</code> method.</p><p>For instance consider a ttk button:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; b = ttk.Button()</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; b.winfo_class()</strong></span>
</pre></div><p>This prints <span class="strong"><strong>Tbutton</strong></span>, which is the default style name for <code class="literal">ttk.Button</code>. For a list of default ttk style names for different widgets, refer to the <span class="emphasis"><em>The ttk widgets</em></span> section in <a class="link" href="apb.html" title="Appendix B. Quick Reference Sheets">Appendix B</a>, <span class="emphasis"><em>Quick Reference Sheets</em></span>.</p><p>In addition to the default style, you can assign a custom style class to a widget or group of widgets. To set up a new style you use:</p><div class="informalexample"><pre class="programlisting">x = ttk.Style()</pre></div><p>To configure the style options for a default style, you use the command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>x.configure('mystyle.Defaultstyle', **styling options)</strong></span>
</pre></div><p>To use the new style on a widget you use the command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>ttk.Widget(root, style='mystyle.Defaultstyle')</strong></span>
</pre></div><p>Next we will discuss about ttk theming.</p><p>Style is used to control the appearance for individual widgets. Themes, on the other hand, control the appearance of the entire GUI. More simply put, a theme is a collection of styles. Grouping<a id="id334" class="indexterm"/> styles into themes lets the user switch designs for the entire GUI all at once. Like styles, all themes are uniquely identified by their name. The list of available themes can be obtained as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; x = ttk.Style()</strong></span>
<span class="strong"><strong>&gt;&gt;&gt;x.theme_names()</strong></span>
<span class="strong"><strong>('winnative', 'clam', 'alt', 'default', 'classic', 'xpnative')</strong></span>
</pre></div><p>To obtain the name of the currently active theme:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt;x.theme_use()</strong></span>
<span class="strong"><strong>'xpnative'</strong></span>
</pre></div><p>You can change to another theme using:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>x.theme_use('yournewthemename')</strong></span>
</pre></div><p>Let us see various styling- and theming-related options of ttk through a dummy example (refer to the code in <code class="literal">3.11.py</code>, which produces a window like the one shown in the following screenshot):</p><div class="mediaobject"><img src="graphics/7941_03_08.jpg" alt="Prepare for Lift Off"/></div><div class="informalexample"><pre class="programlisting">from Tkinter import *
import ttk
root= Tk()
x = ttk.Style()
x.configure('.', font='Arial 14', foreground='brown', background='yellow')
x.configure('danger.TButton', font='Times 12', foreground='red', padding=1)
ttk.Label(root, text='global style').pack()
ttk.Button(root, text='custom style', style='danger.TButton').pack()
# Different  styling for different widget states
x.map("s.TButton", foreground=[('pressed', 'red'), ('active', 'blue')])
ttk.Button(text="state style", style="s.TButton").pack()
# Overriding current theme styles 
curr_theme = x.theme_use()
x.theme_settings(curr_theme, { "TEntry": { "configure":  {"padding": 2}, "map": {"foreground": [("focus", "red")]}  }})
ttk.Entry().pack()
root.mainloop()</pre></div><p>The description <a id="id335" class="indexterm"/>of the code is listed as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The first three lines of code imports <code class="literal">Tkinter</code> and <code class="literal">ttk,</code> and sets up a new root window.</li><li class="listitem" style="list-style-type: disc">The next line <code class="literal">x = ttk.Style()</code> is where you give a name <code class="literal">x</code> to your style.</li><li class="listitem" style="list-style-type: disc">The next line configures a program-wide style configuration using <code class="literal">x.configure</code>. The dot character (<code class="literal">.</code>), which is the first argument of <code class="literal">configure</code>, means that this style would apply to the Toplevel window and to all its child elements. This is the reason why all of our widgets get to have a yellow background.</li><li class="listitem" style="list-style-type: disc">The next line creates an extension (<code class="literal">danger</code>) to the default style (<code class="literal">TButton</code>). This is how you create custom styles, which are variations to a base default style.</li><li class="listitem" style="list-style-type: disc">The next line creates a <code class="literal">ttk.label</code> widget. Since we have not specified any style for this widget, it inherits the global style specified for the Toplevel window.</li><li class="listitem" style="list-style-type: disc">The next line creates a <code class="literal">ttk.button</code> widget and specifies it to be styled using our custom style definition of <code class="literal">'danger.TButton.'</code> This is why the foreground color of this button turns red. Notice how it still inherits the background color, yellow ,from the global Toplevel style that we defined earlier.</li><li class="listitem" style="list-style-type: disc">The next two lines of code demonstrate how ttk allows for styling different widget states. In this example we styled different states for a <code class="literal">ttk.button</code> widget to display in different colors. Go ahead and click on this second button to see how different styles apply to different states of a button. Here we use <code class="literal">map(style, query_options, **kw)</code> to specify dynamic values of style for changes in state of the widget.</li><li class="listitem" style="list-style-type: disc">The next line fetches the current applicable theme. It then overrides some of the options for the theme's Entry widget using:<div class="informalexample"><pre class="programlisting">x.theme_settings('themename', ***options)</pre></div></li></ul></div><p>Now that we know how to make <a id="id336" class="indexterm"/>our widgets look more like native platform widgets, let us change the <span class="strong"><strong>Play</strong></span> and <span class="strong"><strong>Stop</strong></span> buttons for our drum machine to <code class="literal">ttk.button</code>. Let us also change the <span class="strong"><strong>Loop</strong></span> check button<a id="id337" class="indexterm"/> from Tkinter Checkbutton to ttk Checkbutton.</p></div><div class="section" title="Engage Thrusters"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec74"/>Engage Thrusters</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We first import <code class="literal">ttk</code> into our namespace and append <code class="literal">ttk</code> to the <code class="literal">play</code> and <code class="literal">stop</code> buttons as follows (see the code in <code class="literal">3.12.py</code>):<div class="informalexample"><pre class="programlisting">import ttk</pre></div></li><li class="listitem">We then simply modify the buttons and check button in the <code class="literal">create_play_bar</code> method as follows:<div class="informalexample"><pre class="programlisting">button = ttk.Button()
loopbutton = ttk.Checkbutton(**options)</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note26"/>Note</h3><p>Note that these changes make the button and checkbutton look closer to the native widgets of your working platform.</p></div></div><p>Also, note that we cannot modify the Tkinter buttons that we have used in our pattern editor. This is because our code extensively plays on the button's background color to decide logic. The ttk buttons do not have the configurable <code class="literal">bg</code> option, hence, cannot be used for buttons in our right drum pad.</p></li><li class="listitem">As a quick ending exercise let us add an image in the right-hand side of the play bar. Let us also add an icon for our Toplevel window (refer to the code in <code class="literal">3.12.py</code>):<p>To add an image we add this to our <code class="literal">create_play_bar</code> method<a id="id338" class="indexterm"/>:</p><div class="informalexample"><pre class="programlisting">photo = PhotoImage(file='images/sig.gif')
label = Label(playbar_frame, image=photo)
label.image = photo
label.grid(row=ln, column=35, padx=1, sticky=E)</pre></div><p>To add a Toplevel icon, we add the following line to our <code class="literal">Main</code> method<a id="id339" class="indexterm"/>:</p><div class="informalexample"><pre class="programlisting">if os.path.isfile('images/beast.ico'):self.root.iconbitmap('images/beast.ico')</pre></div></li></ol></div></div><div class="section" title="Objective Complete – Mini Debriefing"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec75"/>Objective Complete – Mini Debriefing </h2></div></div></div><p>This concludes<a id="id340" class="indexterm"/> the last iteration of this project. In this iteration, we first saw how and why to use ttk-themed widgets to improve the look and feel of our programs.</p><p>We then used ttk buttons and ttk checkbuttons in our drum program to improve its look. We also saw the reasons why certain Tkinter buttons in our program could not be replaced by ttk buttons.</p></div></div>
<div class="section" title="Mission Accomplished"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec36"/>Mission Accomplished</h1></div></div></div><p>We have come a long way in our experiments with Tkinter. In this project we made a highly-functional drum machine with loads of features.</p><p>In the process, we touched upon several vital concepts that go into the making of a GUI program with Tkinter.</p><p>To summarize, we touched upon the following vital concepts of Tkinter-based GUI programs:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Structuring Tkinter program as classes and objects</li><li class="listitem" style="list-style-type: disc">Working with more Tkinter widgets such as Spinbox, Button, Entry, and Checkbutton</li><li class="listitem" style="list-style-type: disc">Using the <code class="literal">grid</code> geometry manager for structuring complex layout</li><li class="listitem" style="list-style-type: disc">Understanding threaded programming in relation to Tkinter</li><li class="listitem" style="list-style-type: disc">Working with other common modules from the Python standard library</li><li class="listitem" style="list-style-type: disc">Object persistence with the <code class="literal">pickle</code> module</li><li class="listitem" style="list-style-type: disc">Working with ttk-themed widgets</li></ul></div></div>
<div class="section" title="A Hotshot Challenge"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec37"/>A Hotshot Challenge</h1></div></div></div><p>The drum machine <a id="id341" class="indexterm"/>needs your attention. As a part of your Hotshot challenge, add the following features to your drum machine:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The current application checks if the button is green in color to decide whether the button is in the pressed state. Modify the code so that this logic is not decided based on the color of the button, but by a separate variable that keeps track of the selected buttons.</li><li class="listitem" style="list-style-type: disc">Add a tempo scale to your drum machine, which lets the user change the tempo of the beats using a slider.</li><li class="listitem" style="list-style-type: disc">Add volume control for each drum sample, allowing the user to change the volume individually for each drum sample.</li><li class="listitem" style="list-style-type: disc">Add a mute <a id="id342" class="indexterm"/>button for each drum sample. If the Checkbutton is clicked for a given drum sample, the sound is not played for that row. This way, a user can stop a complete row from playing without changing the patterns in that row.</li><li class="listitem" style="list-style-type: disc">Add a time clock to your drum machine, which displays the time elapsed since the last press of the play button.</li></ul></div></div></body></html>