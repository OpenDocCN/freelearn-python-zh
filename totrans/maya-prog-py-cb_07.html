<html><head></head><body><div class="chapter" title="Chapter&#xA0;7.&#xA0;Scripting for Rendering"><div class="titlepage"><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Scripting for Rendering</h1></div></div></div><p>In this chapter, we'll be looking at the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Creating and editing lights</li><li class="listitem" style="list-style-type: disc">Creating GUI to control all lights</li><li class="listitem" style="list-style-type: disc">Creating cameras from code</li><li class="listitem" style="list-style-type: disc">Rendering a sprite sheet</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec51"/>Introduction</h1></div></div></div><p>So far, we've looked at ways scripting can help with modeling, texturing, rigging, and animation. Once all of that is done, all that's left is to actually render out your scene. In this chapter, we'll be looking at how to set up lights and cameras, as well as how to render out scenes.</p></div></div>
<div class="section" title="Creating and editing lights"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec52"/>Creating and editing lights</h1></div></div></div><p>In this <a id="id261" class="indexterm"/>example, we'll be building a script to quickly and easily set up a simple <a id="id262" class="indexterm"/>three-point lighting setup via script.</p><p>This will end up providing us with a nice overview of creating different types of lights with script, as well as leaving us with a handy tool.</p><div class="mediaobject"><img src="graphics/4657_07_01.jpg" alt="Creating and editing lights"/><div class="caption"><p>The result of running the script-key, fill, and back lights all pointed at the origin</p></div></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec140"/>Getting ready</h2></div></div></div><p>For best <a id="id263" class="indexterm"/>results, make sure that you have an object with a decent level of <a id="id264" class="indexterm"/>detail in your scene before running the script.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec141"/>How to do it...</h2></div></div></div><p>Create a new file and add the following code:</p><div class="informalexample"><pre class="programlisting">import maya.cmds as cmds

def createLightRig():

    offsetAmount = 10
    lightRotation = 30

    newLight = cmds.spotLight(rgb=(1, 1, 1), name="KeyLight")
    lightTransform = cmds.listRelatives(newLight, parent=True)
    keyLight = lightTransform[0]

    newLight = cmds.spotLight(rgb=(0.8, 0.8, 0.8), name="FillLight")
    lightTransform = cmds.listRelatives(newLight, parent=True)
    fillLight = lightTransform[0]

    newLight = cmds.directionalLight(rgb=(0.2, 0.2, 0.2), name="BackLight")
    lightTransform = cmds.listRelatives(newLight, parent=True)
    backLight = lightTransform[0]

    cmds.move(0, 0, offsetAmount, keyLight)
    cmds.move(0, 0, 0, keyLight + ".rotatePivot")
    cmds.rotate(-lightRotation, lightRotation, 0, keyLight)

    cmds.move(0, 0, offsetAmount, fillLight)
    cmds.move(0, 0, 0, fillLight + ".rotatePivot")
    cmds.rotate(-lightRotation, -lightRotation, 0, fillLight)

    cmds.move(0, 0, offsetAmount, backLight)
    cmds.move(0, 0, 0, backLight + ".rotatePivot")
    cmds.rotate(180 + lightRotation, 0, 0, backLight)

    rigNode = cmds.group(empty=True, name="LightRig")

    cmds.parent(keyLight, rigNode)
    cmds.parent(fillLight, rigNode)
    cmds.parent(backLight, rigNode)

    cmds.select(rigNode, replace=True)

createLightRig()</pre></div><p>Run the <a id="id265" class="indexterm"/>preceding code, and you'll see that you're left with three lights created—two<a id="id266" class="indexterm"/> spotlights and one directional light.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec142"/>How it works...</h2></div></div></div><p>We'll be creating three lights—two spotlights and one directional light. To simplify the positioning, we'll create a few helper variables:</p><div class="informalexample"><pre class="programlisting">offsetAmount = 10
lightRotation = 30</pre></div><p>The <code class="literal">offsetAmount</code> variable will be the amount by which each of the lights is moved away from the origin, and <code class="literal">lightRotation</code> will control the amount by which the lights are rotated. Next, we create the first of our lights—the key light:</p><div class="informalexample"><pre class="programlisting">newLight = cmds.spotLight(rgb=(1, 1, 1), name="KeyLight")</pre></div><p>Creating the light is easy enough; we just call the <code class="literal">spotLight</code> command. While we're at it, we'll use the <code class="literal">rgb</code> flag to set the color of the light (full intensity white), and we'll set the name to easily identify the light later. We store the result to a <code class="literal">newLight</code> variable.</p><p>One <a id="id267" class="indexterm"/>slight<a id="id268" class="indexterm"/> complication arises in that the light creation command returns the name of the shape node, rather than the transform. Because setting up the position and rotation requires making changes to the transform, we'll use the <code class="literal">listRelatives</code> command to grab the associated transform node:</p><div class="informalexample"><pre class="programlisting">lightTransform = cmds.listRelatives(newLight, parent=True)</pre></div><p>As we've seen in previous examples, we have to account for the fact that the <code class="literal">listRelatives</code> command always returns a list of nodes, even if there's at most one possible node (as is the case with the parent flag). We store the first entry to a variable that we'll use to identify our light for the rest of the script:</p><div class="informalexample"><pre class="programlisting">keyLight = lightTransform[0]</pre></div><p>At this point, we've created the first of our three lights. We'll do the exactly same thing to create a second spotlight for our fill light, with the only difference is that we start it off with something a bit less than full white:</p><div class="informalexample"><pre class="programlisting">newLight = cmds.spotLight(rgb=(0.8, 0.8, 0.8), name="FillLight")
lightTransform = cmds.listRelatives(newLight, parent=True)
fillLight = lightTransform[0]</pre></div><p>Finally, we set up our back light. We start it out with a dark gray light, and we create a directional light rather than a spot:</p><div class="informalexample"><pre class="programlisting">newLight = cmds.directionalLight(rgb=(0.2, 0.2, 0.2), name="BackLight")
lightTransform = cmds.listRelatives(newLight, parent=True)
backLight = lightTransform[0]</pre></div><p>Now that we have all of our lights created, we're ready to set their positions and rotations to give us a nice default three-light setup. To do this, we'll be taking the following steps for each light:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Move the light a set distance away from the origin along the z-axis.</li><li class="listitem">Move the light's rotational pivot back to the origin.</li><li class="listitem">Set the light's rotation to give us the position we want.</li></ol></div><p>We could also calculate the light positions directly using some trigonometry, but having the lights each rotate around the origin will not only make the script more straightforward, but will also make it easier to change after creation.</p><p>First off, we move the light along the z-axis:</p><div class="informalexample"><pre class="programlisting">cmds.move(0, 0, offsetAmount, keyLight)</pre></div><p>Once we've done this, we want to move the rotate pivot back to the origin. We'll use the move command for that as well:</p><div class="informalexample"><pre class="programlisting">cmds.move(0, 0, 0, keyLight + ".rotatePivot")</pre></div><p>Note that <a id="id269" class="indexterm"/>we append <code class="literal">.rotatePivot</code> to the name of the light so that we move just the pivot and not the light itself. Also note that we're moving it to (0,0,0). This will end up giving us what we want because the move command defaults to absolute coordinates. So, moving by (0,0,0) is actually telling Maya to move the object in question to the origin.</p><p>Once we've <a id="id270" class="indexterm"/>done it, we can use the rotate command to rotate the light in question around the origin. For the key light, we'll rotate it around the <span class="emphasis"><em>x</em></span>-axis to move it up and around the <span class="emphasis"><em>y-</em></span>axis to move it to the right. Note that we negate the value for the <span class="emphasis"><em>x</em></span>-axis so that the light is rotated counter-clockwise rather than clockwise around the <span class="emphasis"><em>x</em></span>-axis. This will ensure that the light moves up, rather than down, relative to the <span class="emphasis"><em>X</em></span>-<span class="emphasis"><em>Z</em></span> plane:</p><div class="informalexample"><pre class="programlisting">cmds.rotate(-lightRotation, lightRotation, 0, keyLight)</pre></div><p>We repeat the preceding code two more times to set up our fill and back lights with default positions:</p><div class="informalexample"><pre class="programlisting">cmds.move(0, 0, offsetAmount, fillLight)
cmds.move(0, 0, 0, fillLight + ".rotatePivot")
cmds.rotate(-lightRotation, -lightRotation, 0, fillLight)</pre></div><p>The fill light is rotated around the <span class="emphasis"><em>x</em></span>-axis by the same amount as the key light, but in the opposite direction around the <span class="emphasis"><em>y</em></span>-axis:</p><div class="informalexample"><pre class="programlisting">cmds.move(0, 0, offsetAmount, backLight)
cmds.move(0, 0, 0, backLight + ".rotatePivot")
cmds.rotate(180 + lightRotation, 0, 0, backLight)</pre></div><p>And the back light is rotated around the <span class="emphasis"><em>x</em></span>-axis by 180 degrees (to place it behind the origin) plus our <code class="literal">lightRotation</code> value to move it above the origin.</p><p>At this point, we have three lights with default settings and positions, but we'll want to make the entire rig easier to manipulate. To do this, we'll create a new transform node and add all three lights as children.</p><p>To create the new transform node, we'll use the group command with the <code class="literal">empty</code> flag, to allow us to create an empty group. We'll also be sure to set the base name with the name flag:</p><div class="informalexample"><pre class="programlisting">rigNode = cmds.group(empty=True, name="LightRig")</pre></div><p>Once we've done this, we use the parent command to make all three lights the children of the <code class="literal">LightRig</code> node:</p><div class="informalexample"><pre class="programlisting">cmds.parent(keyLight, rigNode)
cmds.parent(fillLight, rigNode)
cmds.parent(backLight, rigNode)</pre></div><p>As a final <a id="id271" class="indexterm"/>touch, we make sure that we have the parent node selected, with a call to select, with the <code class="literal">replace</code> option:</p><div class="informalexample"><pre class="programlisting">cmds.select(rigNode, replace=True)</pre></div><p>It's always a <a id="id272" class="indexterm"/>good practice, when creating new nodes or groups of nodes, to leave the newly created object(s) selected at the end of your script so that the end user can easily make further changes as necessary (such as moving the entire rig around).</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec143"/>There's more...</h2></div></div></div><p>In this example, we set the color of the lights to different values to make the fill and back lights have less of an effect. Alternatively, we could set all of the lights to be a single color and use the intensity to provide variation. This might end up looking like the following:</p><div class="informalexample"><pre class="programlisting">    keyLightShape = cmds.spotLight(rgb=(1, 1, 1), intensity=1, name="KeyLight")
    fillLightShape = cmds.spotLight(rgb=(1,1,1), intensity=0.8, name="FillLight")
    backLightShape = cmds.directionalLight(rgb=(1,1,1), intensity=0.2, name="BackLight")</pre></div><p>The preceding code would give us three lights that are all white, but at varying intensities. If you want to set the intensity of a light after creating it, you can do so with the <code class="literal">setAttr</code> command. For example, if we wanted to change the intensity of <code class="literal">keyLight</code> after the fact, we could do the following:</p><div class="informalexample"><pre class="programlisting">cmds.setAttr(keyLightShape + ".intensity", 0.5)</pre></div><p>One nice possible addition to the script might be to better account for varying scales of geometry. In the current version, we can use the scale of that parent group to increase or decrease the spacing of the lights. A slightly better way would be to pass in a value for the offset amount to our function. We could also pass in a value for the rotation amount to support a wider range of use cases.</p><p>Doing this would lead us to take the following code:</p><div class="informalexample"><pre class="programlisting">def createLightRig():
    offsetAmount = 10
    lighRotation = 30
    newLight = cmds.spotLight(rgb=(1, 1, 1), name="KeyLight")
    # rest of script</pre></div><p>It will be changed to:</p><div class="informalexample"><pre class="programlisting">def createLightRig(offsetAmount, lightRotation):
    newLight = cmds.spotLight(rgb=(1, 1, 1), name="KeyLight")
    # rest of script</pre></div></div></div>
<div class="section" title="Creating GUI to control all lights"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec53"/>Creating GUI to control all lights</h1></div></div></div><p>Most scenes <a id="id273" class="indexterm"/>will end up containing multiple lights, and controlling them all can get to be a real hassle. In this example, we'll be creating GUI that will present the user with an easy way to control the colors of all the lights in the scene.</p><p>Running the script with three lights in the scene would result in something like the following:</p><div class="mediaobject"><img src="graphics/4657_07_02.jpg" alt="Creating GUI to control all lights"/></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec144"/>Getting ready</h2></div></div></div><p>Make sure that you have at least a few lights in your scene. Alternatively, use the three-point lighting example above to quickly set up a system of lights.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec145"/>How to do it...</h2></div></div></div><p>Create a new file and add the following code:</p><div class="informalexample"><pre class="programlisting">import maya.cmds as cmds
from functools import partial

class LightBoard():

    def __init__(self):

        self.lights = []
        self.lightControls = []
        self.lightNum = 0

        if (cmds.window("ahLightRig", exists=True)):
            cmds.deleteUI("ahLightRig")

        self.win = cmds.window("ahLightRig", title="Light Board")
        cmds.columnLayout()

        lights = cmds.ls(lights=True)

        for light in lights:
            self.createLightControl(light)

        cmds.showWindow(self.win)

    def updateColor(self, lightID, *args):
        newColor = cmds.colorSliderGrp(self.lightControls[lightID], query=True, rgb=True)
        cmds.setAttr(self.lights[lightID]+ '.color', newColor[0], newColor[1], newColor[2], type="double3")

    def createLightControl(self, lightShape):

        parents = cmds.listRelatives(lightShape, parent=True)
        lightName = parents[0]

        color = cmds.getAttr(lightShape + '.color')
        changeCommandFunc = partial(self.updateColor, self.lightNum)

        newSlider = cmds.colorSliderGrp(label=lightName, rgb=color[0], changeCommand=changeCommandFunc)

        self.lights.append(lightShape)
        self.lightControls.append(newSlider)

        self.lightNum += 1

LightBoard()</pre></div><p>Run the <a id="id274" class="indexterm"/>preceding script, and you'll get a new window with a control for each light in the scene. The control will provide both a color swatch and a slider, and changing it will cause the relevant light's color to update.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec146"/>How it works...</h2></div></div></div><p>The first thing to note is that we're adding a second <code class="literal">import</code> statement:</p><div class="informalexample"><pre class="programlisting">import maya.cmds as cmds
from functools import partial</pre></div><p>The <code class="literal">functools</code> library provides capabilities to create functions and work with them as variables. This will come in handy later when we're wiring up our controls.</p><p>The next <a id="id275" class="indexterm"/>thing to note is that we're once again setting up a proper class for this example. Because we're going to need to maintain a list of all the lights in the scene (as well as a list of the controls for each one), wrapping our script in a proper class is the best way to go.</p><p>Having said this, let's move onto our <code class="literal">__init__</code> function. We start off by initializing some member variables—one to hold a list of lights, one to hold a list of controls, and one to help us link the proper light to the proper control:</p><div class="informalexample"><pre class="programlisting">def __init__(self):

    self.lights = []
    self.lightControls = []
    self.lightNum = 0</pre></div><p>We then perform our boilerplate initialization work for a new window—creating a window, setting its title, and adding a column layout. Before we create the window, we first delete the previous one (if it exists):</p><div class="informalexample"><pre class="programlisting">        if (cmds.window("ahLightRig", exists=True)):
            cmds.deleteUI("ahLightRig")</pre></div><p>Once we've done this, we create our window, being sure to pass in the same name we checked for:</p><div class="informalexample"><pre class="programlisting">self.win = cmds.window(("ahLightRig", title="Light Board")
cmds.columnLayout()</pre></div><p>Now we're ready to set up our controls. We'll need to create one for each light in the scene, which means we first have to get a list of all the lights. Luckily for us, the ls command makes that easy. All we have to do is to set the <code class="literal">lights</code> flag to <code class="literal">true</code>:</p><div class="informalexample"><pre class="programlisting">lights = cmds.ls(lights=True)</pre></div><p>Note that there are a few different flags (<code class="literal">lights</code>, <code class="literal">cameras</code>, and <code class="literal">geometry</code>) that can be used with the <code class="literal">ls</code> command to grab specific types of objects. If you want to grab nodes of a type that doesn't have a specific flag, you can do that too; just use either the <code class="literal">type</code> or <code class="literal">exactType</code> flags and specify the type of node you're looking for.</p><p>Once we have a list of all the objects in the scene, we run through the list and create a control for each one, using our <code class="literal">createLightControl</code> method, which we'll get to next.</p><p>Once all the controls have been created, we show the window to the user:</p><div class="informalexample"><pre class="programlisting">for light in lights:
    self.createLightControl(light)

cmds.showWindow(self.win)</pre></div><p>Before we dive into actually creating our controls, we'll need to have a function that can be used to update a given light to the color in a given slider. For that, we create the following function:</p><div class="informalexample"><pre class="programlisting">def updateColor(self, lightID, *args):
    newColor = cmds.colorSliderGrp(self.lightControls[lightID], query=True, rgb=True)
    cmds.setAttr(self.lights[lightID]+ '.color', newColor[0], newColor[1], newColor[2], type="double3")</pre></div><p>The <a id="id276" class="indexterm"/>function looks like it takes three arguments, but only one really matters. First, since we're building this script as a class, we have to account for the fact that Python will pass the class instance to every member function, which we do with the self argument. Next is the thing we actually care about, in this case, an integer representing which control/light to work with. Finally, we have a catch-all in <code class="literal">*args</code>.</p><p>Using <code class="literal">*args</code> will provide a way to grab a variable number of arguments into a single array. This is necessary, as many UI controls will pass extra data to functions that they call. We don't actually want to make use of that in this case, but if we left out the <code class="literal">*args</code>, we would end up with Maya passing three arguments in to a function that only takes two, generating an error.</p><p>The argument that we <span class="emphasis"><em>do</em></span> care about, <code class="literal">lightID</code>, tells us which light/control to work with. Both the lights and the controls are stored in class member variables—<code class="literal">self.lights</code> and <code class="literal">self.lightControls</code>. In order to set a given light to a given slider, we have to first get the current value of the slider by running the <code class="literal">colorSliderGrp</code> command in query mode, as follows:</p><div class="informalexample"><pre class="programlisting">newColor = cmds.colorSliderGrp(self.lightControls[lightID], query=True, rgb=True)</pre></div><p>Note that we pass in an entry in our <code class="literal">self.lightControls</code> array to specify the control, we run the command in query mode, and we set the <code class="literal">rgb</code> flag to <code class="literal">True</code> to tell Maya that it's the specific attribute that we're querying.</p><p>Once we've done it, we use <code class="literal">setAttr</code> to set the color of the corresponding light to the given red, green, and blue values. We'll use <code class="literal">setAttr</code> to do that, but we'll need to make sure that we specify the type because we'll be using multiple values.</p><div class="informalexample"><pre class="programlisting">cmds.setAttr(self.lights[lightID]+ '.color', newColor[0], newColor[1], newColor[2], type="double3")</pre></div><p>Okay, so at this point, we have a function that we can call to update a given light to the current color value of a given slider. So, if we were to call the function, we would set the first light to the current color of the first slider:</p><div class="informalexample"><pre class="programlisting">self.updateColor(0)</pre></div><p>That's a big part of what we need, but we'll want to make sure that this gets called every time a slider's value is changed.</p><p>On to creating an individual control. We create a function that takes a given light and does the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Stores a reference to the light so we can later alter its properties</li><li class="listitem" style="list-style-type: disc">Creates a new <code class="literal">colorSliderGrp</code> control for the light</li></ul></div><p>The<a id="id277" class="indexterm"/> function will pass the light we want to create a control for, and we'll once again need to account for the fact that Python passes in the class instance itself, giving us the following function signature:</p><div class="informalexample"><pre class="programlisting">    def createLightControl(self, lightShape):</pre></div><p>Within the function, we'll start out by grabbing the transform node associated with the light. That's not strictly necessary because the node that we'll want to alter (to set color) is the actual shape node. However, it's a lot nicer to have our controls labeled something like <code class="literal">Key Light</code> rather than <code class="literal">keyLightShape</code>. Grabbing the transform is done in the same way that we did it in the previous example:</p><div class="informalexample"><pre class="programlisting">parents = cmds.listRelatives(lightShape, parent=True)
lightName = parents[0]</pre></div><p>Before we create the control, there are a few things we'll want to do first. We'll want to make sure that the <code class="literal">colorSliderGrp</code> starts out with the same color value as the light. To do it, we'll need to grab the light's current color with the <code class="literal">getAttr</code> (get attribute) command:</p><div class="informalexample"><pre class="programlisting">color = cmds.getAttr(light + '.color')</pre></div><p>The <code class="literal">getAttr</code> command is a real workhorse, and (as is the case with many other commands) it always returns an array because some of the uses to which it can be put will return multiple values. What's a bit surprising about its behavior in this specific case is that we'll end up with a one-element array, with that one element being itself a three-element list of the red, green, and blue values. So, when we make use of the color variable, we'll need to use <code class="literal">color[0]</code>, instead of (as you would likely suspect) just <code class="literal">color</code>.</p><p>The next thing that we'll want to do is to create the function that gets called when the slider has its value changed. In the case of a <code class="literal">colorSliderGrp</code> control, this includes both moving the slider or clicking on the color swatch to select a color. In either case, we'll want to respond by running some code to update our light's color value.</p><p>Here's where it gets tricky because the function we call will need to be aware of the specific UI control to grab data from, as well as the specific light to apply changes to.</p><p>We'll create the slider with the <code class="literal">colorSliderGrp</code> command, which provides a flag, <code class="literal">changeCommand</code>, which can be used to specify a command that should be run every time the slider's value changes.</p><p>If we wanted the slider to run a function that took zero arguments when it changes, we could do the following:</p><div class="informalexample"><pre class="programlisting">newSlider = cmds.colorSliderGrp(label=lightName, rgb=color[0], changeCommand=self.someFunction)</pre></div><p>However, in <a id="id278" class="indexterm"/>this case, we want to call our <code class="literal">updateColor</code> function, while passing in an integer to specify which light/control to update. You might be tempted to do something like the following:</p><div class="informalexample"><pre class="programlisting">newSlider = cmds.colorSliderGrp(label=lightName, rgb=color[0], changeCommand=self.updateColor(0))</pre></div><p>Unfortunately, it's not quite that simple. The preceding code would cause Python to actually run the <code class="literal">updateColor</code> function at the time we create the control. As a result, the actual value of the <code class="literal">changeCommand</code> flag would be whatever the return value of self.<code class="literal">updateColor</code> is (in this case, <code class="literal">None</code>).</p><p>That's where the partial command, included in the <code class="literal">functools</code> library, comes in. We can use the <code class="literal">partial</code> function to create a copy of a function with specific arguments baked in. It's almost as if we had written a separate function for each light and slider combo. We'll use the <code class="literal">partial</code> command to create a copy of our <code class="literal">self.updateColor</code> command, with a number representing the current light baked in, as follows:</p><div class="informalexample"><pre class="programlisting">changeCommandFunc = partial(self.updateColor, self.lightNum)</pre></div><p>The first argument to partial is a function. Note the lack of parentheses after <code class="literal">self.updateColor</code>, indicating that we're making use of the function itself, rather than running it. After the function, we can pass in one or more arguments to bind to the function. For example, if we had the following function:</p><div class="informalexample"><pre class="programlisting">def printANum(number):
    print(number)</pre></div><p>And we used partial in the following way:</p><div class="informalexample"><pre class="programlisting">newFunction = partial(printANum, 23)</pre></div><p>The value of <code class="literal">newFunction</code> would itself be a new function with exactly the same behavior as if we had called <code class="literal">printANum(23)</code>.</p><p>So, at this point in the script, our <code class="literal">changeCommandFunc</code> variable holds a new function that will have identical behavior to calling our <code class="literal">updateColor</code> function with a specific input. With this, we're ready to create our slider:</p><div class="informalexample"><pre class="programlisting">newSlider = cmds.colorSliderGrp(label=lightName, rgb=color[0], changeCommand=changeCommandFunc)</pre></div><p>We use our <code class="literal">lightName</code> variable to label the slider and pass in our color variable (note the <code class="literal">[0]</code>, since it's an array) to make sure that the slider starts with the current color of the light.</p><p>We're almost done, except for a bit of bookkeeping. We'll want to make sure that we maintain references to both the slider and the light to which it corresponds. To do this, we insert the <a id="id279" class="indexterm"/>light's shape node (originally passed in to the <code class="literal">createLightControl</code> function) into the class member variable, lights. We also insert the newly created slider into the <code class="literal">lightControls</code> list:</p><div class="informalexample"><pre class="programlisting">self.lights.append(light)
self.lightControls.append(newSlider)</pre></div><p>Finally, we increment our <code class="literal">lightNum</code> variable by one so that the next time through the function, we'll pass the correct value into the <code class="literal">partial</code> command:</p><div class="informalexample"><pre class="programlisting">self.lightNum += 1</pre></div><p>And that's it! We're done creating our class, and finish off our script with a command to create an instance:</p><div class="informalexample"><pre class="programlisting">LightBoard()</pre></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec147"/>There's more...</h2></div></div></div><p>In this example, we created controls to alter the color of the lights in the scene. It's likely that you would also want to control the intensity of the lights as well. That could be done easily enough by creating an additional control (likely either <code class="literal">floatField</code> or <code class="literal">floatSlider</code>) in the <code class="literal">createLightControl</code> function. Either way, you would want to:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a separate class member variable to hold references to the intensity controls.</li><li class="listitem">Make sure that changing the value on the intensity slider also calls the <code class="literal">updateColor</code> function.</li><li class="listitem">In the <code class="literal">updateColor</code> function, make sure that you grab the current value of the control and use it to set the intensity of the light with the <code class="literal">setAttr</code> command.</li></ol></div></div></div>
<div class="section" title="Creating cameras from code"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec54"/>Creating cameras from code</h1></div></div></div><p>In this <a id="id280" class="indexterm"/>example, we'll be looking at how to use code to create cameras. We'll create a collection of four orthographic cameras, suitable for use in rendering out multiple views of an object for use as assets for an isometric game.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note09"/>Note</h3><p>Isometric games have a long history and are characterized by using 2D assets to create a three-quarters overhead view of a game environment. This approach was very common before full 3D games became the norm, and it still shows up often in web and mobile games. Creating assets for isometric games often means rendering out a view for each side of an object and making sure that there is no perspective distortion in the rendering, which is exactly what we'll be doing in this example.</p></div></div><div class="mediaobject"><img src="graphics/4657_07_03.jpg" alt="Creating cameras from code"/><div class="caption"><p>The result of the script-four orthographic cameras, all pointed at the origin</p></div></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec148"/>Getting ready</h2></div></div></div><p>For best <a id="id281" class="indexterm"/>results, make sure that you have some geometry in your scene, placed at the origin.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec149"/>How to do it...</h2></div></div></div><p>Create a new file and add the following code:</p><div class="informalexample"><pre class="programlisting">import maya.cmds as cmds

def makeCameraRig():
    aimLoc = cmds.spaceLocator()

    offset = 10

    for i in range(0, 4):
        newCam = cmds.camera(orthographic=True)
        cmds.aimConstraint(aimLoc[0], newCam[0], aimVector=(0,0,- 1))

        xpos = 0
        ypos = 6
        zpos = 0

        if (i % 2 == 0):
            xpos = -offset
        else:
            xpos = offset

        if (i &gt;= 2):
            zpos = -offset
        else:
            zpos = offset

        cmds.move(xpos, ypos, zpos, newCam[0])

makeCameraRig()</pre></div><p>Run the script, and you should have four isometric cameras, all looking at the origin.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec150"/>How it works...</h2></div></div></div><p>Making a <a id="id282" class="indexterm"/>camera is easy enough; all we need to do is to use the <code class="literal">camera</code> command. However, there's no direct way to create a camera and aim setup with code. Instead, we have to manually create an aim constraint for each of the cameras we create.</p><p>We start our script by creating a locator to serve as the target for the aim constraint.</p><div class="informalexample"><pre class="programlisting">aimLoc = cmds.spaceLocator()</pre></div><p>The locator will be positioned at the origin by default, which is fine for our purposes. Now that we have an aim object, we're ready to create our cameras. We kick off a for loop to create four cameras, one for each of the diagonal directions.</p><p>Actually, creating the camera is simple; we just call the <code class="literal">camera</code> command. In this case, we'll want to have orthographic cameras, so we'll set the <code class="literal">orthographic</code> flag to <code class="literal">true</code>:</p><div class="informalexample"><pre class="programlisting">for i in range(0, 4):
    newCam = cmds.camera(orthographic=True)</pre></div><p>Next, we'll set up the aim constraint. To create an aim constraint, we need to pass in two transform nodes, with the first being the target and the second being the one that will have its rotations controlled. Note that because both the <code class="literal">spaceLocator</code> and <code class="literal">camera</code> commands return two nodes (one transform, one shape), we'll need to specify the first index of the variables we used to hold the results.</p><div class="mediaobject"><img src="graphics/4657_07_04.jpg" alt="How it works..."/><div class="caption"><p>A default camera, pointed down the negative z-axis</p></div></div><p>We'll also <a id="id283" class="indexterm"/>want to make sure that our cameras look down their axis at the locator by setting the proper aim vector. Because the default position of a camera will have it looking along the z-axis in the negative direction, we'll want to use (0, 0, -1) as the aim vector.</p><p>Putting this all together gives us the following line to create the <code class="literal">aim</code> constraint:</p><div class="informalexample"><pre class="programlisting">cmds.aimConstraint(aimLoc[0], newCam[0], aimVector=(0,0,-1))</pre></div><p>Now we just need to move the camera to the proper location. Because the aim constraint will take care of the rotations, all we have to worry about is the position. In this case, we want to make sure that each camera lies on a line that is some multiple of 45 degrees from the origin. To do this, we'll want to make sure that the <span class="emphasis"><em>X</em></span> and <span class="emphasis"><em>Z</em></span> positions have the same magnitude, with only the signs changing from camera to camera.</p><p>First off, we'll create variables for each of the x, y, and z positions, with the <code class="literal">ypos</code> variable being set to a default value:</p><div class="informalexample"><pre class="programlisting">xpos = 0
ypos = 6
zpos = 0</pre></div><p>For X and Z, we'll want to have values for each of the four quadrants- (+,+), (+,-), (-,-), and (-,+). To do this, we'll have one of the values be negative when our index is odd, and the other be negative when the index is greater than or equal to <code class="literal">2</code>:</p><div class="informalexample"><pre class="programlisting">if (i % 2 == 0):
    xpos = -offset
else:
    xpos = offset

if (i &gt;= 2):
    zpos = -offset
else:
    zpos = offset</pre></div><p>Note that we're making use of the <code class="literal">offset</code> variable, which was set outside of the loop.</p><p>Having<a id="id284" class="indexterm"/> done this, we use the <code class="literal">move</code> command to position the camera at the proper location.</p><div class="informalexample"><pre class="programlisting">cmds.move(xpos, ypos, zpos, newCam[0])</pre></div><p>And with this, we're done!</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec151"/>There's more...</h2></div></div></div><p>In this example, we created an <code class="literal">aim</code> constraint to replicate the behavior that one gets when creating a <span class="emphasis"><em>Camera and Aim</em></span> from Maya's UI. The nice thing about this is that we can move the locator in order to change the look at location.</p><p>If all we wanted was to have the camera look at a given location though, we could do it with the <code class="literal">viewPlace</code> command, which can both move a camera and rotate it to look at a given location. For example, if we wanted to have a camera positioned at (5,6,5) and looking at a point slightly above the origin (let's say 0,2,0), we could do the following:</p><div class="informalexample"><pre class="programlisting">newCam = cmds.camera()
cmds.viewPlace(newCam[0], eye=(5,6,5), lookAt=(0, 2, 0))</pre></div><p>We also only scratched the surface of what can be done when creating cameras; you'll often want to set things such as the near/far clip planes, depth of field, and so on. You can either set such things directly on creation or use <code class="literal">setAttr</code> to alter them after the fact. For more details, be sure to consult the documentation for the <code class="literal">camera</code> command.</p></div></div>
<div class="section" title="Rendering a sprite sheet"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec55"/>Rendering a sprite sheet</h1></div></div></div><p>In this <a id="id285" class="indexterm"/>example, we'll be building a tool to render out multiple views of an object to a single image. This could be used to create a sprite sheet for use in an isometric game.</p><p>In the course of the example, we'll use both Maya's Python library (to render out frames) and the <span class="strong"><strong>Python Imaging Library</strong></span> (<span class="strong"><strong>PIL</strong></span>) to<a id="id286" class="indexterm"/> combine them into a single image.</p><div class="mediaobject"><img src="graphics/4657_07_05.jpg" alt="Rendering a sprite sheet"/><div class="caption"><p>Four views rendered out and combined into a single image</p></div></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec152"/>Getting ready</h2></div></div></div><p>Make <a id="id287" class="indexterm"/>sure that you have an object in your scene and it is at the origin. Also make sure that you have some number of cameras set up. You can either do it manually, or refer to the previous example on how to create cameras from script.</p><p>You'll also want to make sure that you have PIL installed on your system. The best way to do that is to grab Pillow (a fork of PIL). More information on <a id="id288" class="indexterm"/>Pillow can be found at <a class="ulink" href="http://pillow.readthedocs.io/en/3.2.x/">http://pillow.readthedocs.io/en/3.2.x/</a>.</p><p>In order to install Pillow in a (relatively) painless way, you'll probably want to grab PIP, which is a robust <a id="id289" class="indexterm"/>package manager for Python. For more information on PIP, check <a class="ulink" href="https://pypi.python.org/pypi/pip">https://pypi.python.org/pypi/pip</a>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec153"/>How to do it...</h2></div></div></div><p>Create a new file and add the following code:</p><div class="informalexample"><pre class="programlisting">import maya.cmds as cmds
import os
from PIL import Image

FRAME_WIDTH = 400
FRAME_HEIGHT = 300

def renderSpriteSheet():
    allCams = cmds.listCameras()

    customCams = []

    for cam in allCams:
        if (cam not in ["front", "persp", "side", "top"]):
            customCams.append(cam)

    # make sure we're rendering TGAs
    cmds.setAttr("defaultRenderGlobals.imageFormat", 19)

    # create a new image
    fullImage = Image.new("RGBA", (FRAME_WIDTH*len(customCams), FRAME_HEIGHT), "black")

    # run through each camera, rendering the view and adding it to the mage
        for i in range(0, len(customCams)):
        result = cmds.render(customCams[i], x=FRAME_WIDTH, y=FRAME_HEIGHT)
        tempImage = Image.open(result)
        fullImage.paste(tempImage, (i*FRAME_WIDTH,0))

    basePath = cmds.workspace(query=True, rootDirectory=True)
    fullPath = os.path.join(basePath, "images", "frames.tga")
    fullImage.save(fullPath)

renderSpriteSheet()</pre></div><p>Run the <a id="id290" class="indexterm"/>script, and you should get a new image, named <code class="literal">frames.tga</code> in the <code class="literal">images</code> directory of your project folder, containing a view from each of the (nonstandard) cameras. If you haven't set up a project, the images will be in the default project directory. If you want them to be in a specific location, be sure to set your project before running the script.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec154"/>How it works...</h2></div></div></div><p>First off, we're importing a few additional libraries to make the script work. First is the <code class="literal">os</code> library, to let us combine paths and file names in a safe, cross-platform way. Then, we also import the Image module from PIL, which we'll use to create our combined image:</p><div class="informalexample"><pre class="programlisting">import maya.cmds as cmds
import os
from PIL import Image</pre></div><p>Next, we define a couple of variables that we'll use to set the size of our rendered images. We'll use that both to set the render size, as well as to calculate the size of the combined image:</p><div class="informalexample"><pre class="programlisting">FRAME_WIDTH = 400
FRAME_HEIGHT = 300</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note10"/>Note</h3><p>Note that the variables are all caps, that is by no means necessary. Capitalized variables are often used to indicate constants that are used in multiple places and don't vary during the course of a script. The dimensions of the frames to render are a good example of that kind of variable, so I've given them all-caps names, but feel free to use a different style if you so choose.</p></div></div><p>Now we're <a id="id291" class="indexterm"/>ready to get started rendering out images. To do it, we'll want to first get a list of all the cameras in our scene, then filter out the default views. We <span class="emphasis"><em>could</em></span> use the ls command to do it, but it's easier to use the <code class="literal">listCameras</code> command:</p><div class="informalexample"><pre class="programlisting">allCams = cmds.listCameras()</pre></div><p>To ignore the default camera views, we'll start by creating a new (empty) list, then running through our <code class="literal">allCams</code> list. Each camera that is <span class="emphasis"><em>not</em></span> in the list of defaults gets added, leaving us with a handy list of all the nondefault cameras in the scene.</p><div class="informalexample"><pre class="programlisting">customCams = []

for cam in allCams:
    if (cam not in ["front", "persp", "side", "top"]):
        customCams.append(cam)</pre></div><p>At this point, we have a list of all the cameras that we'll want to render out. Before we render anything, we'll want to make sure that we're rendering the proper image format. In this case, we'll render out Targa files because they're both uncompressed and include an alpha channel:</p><div class="informalexample"><pre class="programlisting">    cmds.setAttr("defaultRenderGlobals.imageFormat", 19)</pre></div><p>To set the image type, we use the <code class="literal">setAttr</code> command, but the value is less clear than we might like. It just so happens that the <code class="literal">targa</code> format happens to correspond to 19. Other common formats include JPG (8), PNG (32), and PSD (31). To check the value of any given format, open the render globals window, select the desired format from the dropdown, and observe the output in the script editor.</p><p>Before we start rendering our images, we'll want to use PIL to create a larger image to hold all of the frames. We'll create a single image that has the same height as our render size and a width equal to the render width multiplied by the number of cameras. We'll also set up the image to default to black:</p><div class="informalexample"><pre class="programlisting">fullImage = Image.new("RGBA", (FRAME_WIDTH*len(customCams), FRAME_HEIGHT), "black")</pre></div><p>Note that we pass in <code class="literal">RGBA</code> to set the image mode to full color plus alpha. With our base image created, we're ready to run through our cameras and render each frame.</p><p>For each camera, we'll want to:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Render the current view at our specified width and height</li><li class="listitem" style="list-style-type: disc">Paste the rendered image into the combined image</li></ul></div><p>To render out a given view, we use the <code class="literal">render</code> command with three arguments-the camera to render from, followed by the width and the height for the rendered image:</p><div class="informalexample"><pre class="programlisting">result = cmds.render(customCams[i], x=FRAME_WIDTH, y=FRAME_HEIGHT)</pre></div><p>We store the result of the <code class="literal">render</code> command into a result variable for later use. It's important to note that the output isn't the image itself, but rather the path to the image (something like <code class="literal">/Documents/maya/projects/default/images/tmp/MyScene.tga</code>).</p><p>Now<a id="id292" class="indexterm"/> that we've rendered out the image, we'll want to use PIL to create the second <code class="literal">Image</code> object from the specified path:</p><div class="informalexample"><pre class="programlisting">tempImg = Image.open(result)</pre></div><p>We use <code class="literal">Image.open</code> instead of <code class="literal">Image.create</code> because we want to create an image from a given file, rather than a new blank image. Finally, we copy the new image into our combined image with the <code class="literal">paste</code> command:</p><div class="informalexample"><pre class="programlisting">fullImage.paste(tempImg, (i*FRAME_WIDTH,0))</pre></div><p>PIL's paste command allows one image to be pasted into another at a specific location. In this case, we call it on our <code class="literal">fullImage</code> image and pass in the image we just rendered out (<code class="literal">tempImg</code>), as well as a tuple for the location. The <span class="emphasis"><em>Y</em></span> location is locked to <code class="literal">0</code> in all cases, and the <span class="emphasis"><em>X</em></span> location is set to <code class="literal">FRAME_WIDTH</code> multiplied by the loop index so that our images are placed in an orderly horizontal line.</p><p>Once we've finished that loop, we're ready to save out the combined image. There are any number of places we could put it, but it probably makes sense to put it somewhere in our project directory. To do that, we'll need to first grab the current project directory using the <code class="literal">workspace</code> command in the query mode as follows:</p><div class="informalexample"><pre class="programlisting">basePath = cmds.workspace(query=True, rootDirectory=True)</pre></div><p>Where you save the image is up to you, but in this case, I decided to go with saving it out as <code class="literal">frames.tga</code> in the <code class="literal">images</code> folder of the project directory. We could build up the path by adding strings, but using Python's <code class="literal">os</code> library to join the path guarantees that our script will have better cross-platform support:</p><div class="informalexample"><pre class="programlisting">fullPath = os.path.join(basePath, "images", "frames.tga")</pre></div><p>Finally, we call <code class="literal">Image.save</code> on our <code class="literal">fullImage</code> variable and pass in the path we just created:</p><div class="informalexample"><pre class="programlisting">fullImage.save(fullPath)</pre></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec155"/>There's more...</h2></div></div></div><p>Although there is certainly a wide range of options offered by Maya's rendering capabilities, some things may be easier to achieve by postprocessing after the fact. The PIL is quite powerful and well worth digging into. If you ever find yourself needed to perform 2D operations on your renders, it's quite possible that doing so with the PIL could be a good choice.</p><p>This<a id="id293" class="indexterm"/> script, or something like it, could easily be used to build a robust asset pipeline for an isometric game. You could easily add the ability to send the combined image to a central server along with metadata on the particular structure or object. We'll look at sending data across the Web in <a class="link" href="ch09.html" title="Chapter 9. Communicating with the Web">Chapter 9</a>, <span class="emphasis"><em>Communicating with the Web</em></span>.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec156"/>See also</h2></div></div></div><p>PIL is capable of a great deal more than what we used it for in this example. For more details, you'll <a id="id294" class="indexterm"/>want to dig into the documentation on <span class="emphasis"><em>effbot.org</em></span> (<a class="ulink" href="http://effbot.org/imagingbook/pil-index.htm">http://effbot.org/imagingbook/pil-index.htm</a>).</p></div></div></body></html>