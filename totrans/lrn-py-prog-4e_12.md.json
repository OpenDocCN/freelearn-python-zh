["```py\n<?php\n$a = 2;\n$b = \"2\";\necho $a + $b; // prints: 4\n?> \n```", "```py\n# example.strongly.typed.py\na = 2\nb = \"2\"\nprint(a + b) \n```", "```py\n$ python ch12/example.strongly.typed.py\nTraceback (most recent call last):\n  File \"ch12/example.strongly.typed.py\", line 3, in <module>\n    print(a + b)\n          ~~^~~\nTypeError: unsupported operand type(s) for +: 'int' and 'str' \n```", "```py\nString name = \"John Doe\";\nint age = 60; \n```", "```py\n# duck.typing.py\nclass Circle:\n    def __init__(self, radius):\n        self.radius = radius\n    def area(self):\n        return 3.14159 * (self.radius**2)\nclass Rectangle:\n    def __init__(self, width, height):\n        self.width = width\n        self.height = height\n    def area(self):\n        return self.width * self.height\ndef print_shape_info(shape):\n    print(f\"{shape.__class__.__name__} area: {shape.area()}\")\ncircle = Circle(5)\nrectangle = Rectangle(4, 6)\nprint_shape_info(circle)  # Circle area: 78.53975\nprint_shape_info(rectangle)  # Rectangle area: 24 \n```", "```py\n# annotations/basic.py\ndef greeter(name):\n    return f\"Hello, {name}!\" \n```", "```py\n# annotations/basic.py\ndef **greeter_annotated****(name:** **str****) ->** **str****:**\n    return f\"Hello, {name}!\" \n```", "```py\n# annotations/basic.py\ndef greeter_annotated_age(name: str, age: int) -> str:\n    return f\"Hello, {name}! You are {age} years old.\" \n```", "```py\n# annotations/any.py\nfrom typing import Any\ndef square(n):\n    return n**2\ndef square_annotated(n: Any) -> Any:\n    return n**2 \n```", "```py\n# annotations/any.py\nfrom typing import Any\ndef reverse(items: list) -> list:\n    return list(reversed(items))\ndef reverse_any(items: list[Any]) -> list[Any]:\n    return list(reversed(items)) \n```", "```py\n# annotations/type.aliases.py\ntype DatabasePort = int\ndef connect_to_database(host: str, port: DatabasePort):\n    print(f\"Connecting to {host} on port {port}...\") \n```", "```py\n# annotations/optional.py\ndef greeter(name: str = \"stranger\") -> str:\n    return f\"Hello, {name}!\" \n```", "```py\n# annotations/optional.py\ndef greeter_optional(name: Optional[str] = None) -> str:\n    if name is not None:\n        return f\"Hello, {name}!\"\n    return \"No-one to greet!\" \n```", "```py\n# annotations/union.py\nfrom typing import Union\ndef connect_to_database(host: str, port: Union[int, str]):\n    print(f\"Connecting to {host} on port {port}...\") \n```", "```py\n# annotations/union.py\ndef connect_to_db(host: str, port: int | str):\n    print(f\"Connecting to {host} on port {port}...\") \n```", "```py\n# annotations/optional.py\ndef another_greeter(name: str | None = None) -> str:\n    if name is not None:\n        return f\"Hello, {name}!\"\n    return \"No-one to greet!\" \n```", "```py\n# annotations/generics.py\ndef last**[T]****list****[T]****T**(items: ) ->  | None:\n    return items[-1] if items else None \n```", "```py\n# annotations/generics.py\nfrom typing import TypeVar\nU = TypeVar(\"U\")\ndef first(items: list[U]) -> U | None:\n    return items[0] if items else None \n```", "```py\n# annotations/variables.py\nx: int = 10\nx: float = 3.14\nx: bool = True\nx: str = \"Hello!\"\nx: bytes = b\"Hello!\"\n# Python 3.9+\nx: list[int] = [7, 14, 21]\nx: set[int] = {1, 2, 3}\nx: dict[str, float] = {\"planck\": 6.62607015e-34}\n# Python 3.8 and earlier\nfrom typing import List, Set, Dict\nx: List[int] = [7, 14, 21]\nx: Set[int] = {1, 2, 3}\nx: Dict[str, float] = {\"planck\": 6.62607015e-34}\n# Python 3.10+\nx: list[int | str] = [0, 1, 1, 2, \"fibonacci\", \"rules\"]\n# Python 3.9 and earlier\nfrom typing import Union\nx: list[Union[int, str]] = [0, 1, 1, 2, \"fibonacci\", \"rules\"] \n```", "```py\n# annotations/containers.py\n# The type checker assumes all elements of the list are integers\na: list[int] = [1, 2, 3]\n# We cannot specify two types for the elements of the list\n# it only accepts a single type argument\nb: list[int, str] = [1, 2, 3, \"four\"]  # Wrong!\n# The type checker will infer that all keys in `c` are strings\n# and all values are integers or strings\nc: dict[str, int | str] = {\"one\": 1, \"two\": \"2\"} \n```", "```py\n# annotations/tuples.fixed.py\n# Tuple `a` is assigned to a tuple of length 1,\n# with a single string element.\na: tuple[str] = (\"hello\",)\n# Tuple `b` is assigned to a tuple of length 2,\n# with an integer and a string element.\nb: tuple[int, str] = (1, \"one\")\n# Type checker error: the annotation indicates a tuple of\n# length 1, but the tuple has 3 elements.\nc: tuple[float] = (3.14, 1.0, -1.0)  # Wrong! \n```", "```py\n# annotations/tuples.named.py\nfrom typing import NamedTuple\nclass Person(NamedTuple):\n    name: str\n    age: int\nfab = Person(\"Fab\", 48)\nprint(fab)  # Person(name='Fab', age=48)\nprint(fab.name)  # Fab\nprint(fab.age)  # 48\nprint(fab[0])  # Fab\nprint(fab[1])  # 48 \n```", "```py\n# annotations/tuples.named.py\nimport collections\nPerson = collections.namedtuple(\"Person\", [\"name\", \"age\"]) \n```", "```py\n# annotations/tuples.named.py\nclass Point(NamedTuple):\n    x: int\n    y: int\n    z: int = 0\np = Point(1, 2)\nprint(p)  # Point(x=1, y=2, z=0) \n```", "```py\n# annotations/tuples.any.length.py\nfrom typing import Any\n# We use the ellipsis to indicate that the tuple can have any\n# number of elements.\na: tuple[int, ...] = (1, 2, 3)\n# All the following are valid, because the tuple can have any\n# number of elements.\na = ()\na = (7,)\na = (7, 8, 9, 10, 11)\n# But this is an error, because the tuple can only have integers\na = (\"hello\", \"world\")\n# We can specify a tuple that must be empty\nb: tuple[()] = ()\n# Finally, if we annotate a tuple like this:\nc: tuple = (1, 2, 3)\n# The type checker will treat it as if we had written:\nc: tuple[Any, ...] = (1, 2, 3)\n# And because of that, all the below are valid:\nc = ()\nc = (\"hello\", \"my\", \"friend\") \n```", "```py\n# annotations/collections.abcs.py\nfrom collections.abc import Mapping, Sequence\ndef average_bad(v: list[float]) -> float:\n    return sum(v) / len(v)\ndef average(v: Sequence[float]) -> float:\n    return sum(v) / len(v)\ndef greet_user_bad(user: dict[str, str]) -> str:\n    return f\"Hello, {user['name']}!\"\ndef greet_user(user: Mapping[str, str]) -> str:\n    return f\"Hello, {user['name']}!\" \n```", "```py\n# annotations/collections.abcs.py\ndef add_defaults_bad(\n    data: Mapping[str, str]\n) -> **Mapping**[str, str]:\n    defaults = {\"host\": \"localhost\", \"port\": \"5432\"}\n    return {**defaults, **data}\ndef add_defaults(data: Mapping[str, str]) -> **dict**[str, str]:\n    defaults = {\"host\": \"localhost\", \"port\": \"5432\"}\n    return {**defaults, **data} \n```", "```py\n# annotations/collections.abc.iterable.py\nfrom collections.abc import Iterable\ndef process_items(items: Iterable) -> None:\n    for item in items:\n        print(item) \n```", "```py\n# annotations/collections.abc.iterable.py\nfrom collections.abc import Callable\ndef process_callback(\n    arg: str, callback: Callable[[str], str]\n) -> str:\n    return callback(arg)\ndef greeter(name: str) -> str:\n    return f\"Hello, {name}!\"\ndef reverse(name: str) -> str:\n    return name[::-1] \n```", "```py\n# annotations/collections.abc.iterable.py\nprint(process_callback(\"Alice\", greeter))  # Hello, Alice!\nprint(process_callback(\"Alice\", reverse))  # ecilA \n```", "```py\n# annotations/self.py\nfrom typing import Self\nfrom collections.abc import Iterable\nfrom dataclasses import dataclass\n@dataclass\nclass Point:\n    x: float = 0.0\n    y: float = 0.0\n    z: float = 0.0\n    def magnitude(self) -> float:\n        return (self.x**2 + self.y**2 + self.z**2) ** 0.5\n    @classmethod\n    def sum_points(cls, points: Iterable[**Self**]) -> **Self**:\n        return cls(\n            sum(p.x for p in points),\n            sum(p.y for p in points),\n            sum(p.z for p in points),\n        ) \n```", "```py\n# annotations/variable.parameters.py\ndef add_query_params(\n    ***urls:** **str**, ****query_params:** **str**\n) -> list[str]:\n    params = \"&\".join(f\"{k}={v}\" for k, v in query_params.items())\n    return [f\"{url}?{params}\" for url in urls]\nurls = add_query_params(\n    \"https://example1.com\",\n    \"https://example2.com\",\n    \"https://example3.com\",\n    limit=\"10\",\n    offset=\"20\",\n    sort=\"desc\",\n)\nprint(urls)\n# ['https://example1.com?limit=10&offset=20&sort=desc',\n#  'https://example2.com?limit=10&offset=20&sort=desc',\n#  'https://example3.com?limit=10&offset=20&sort=desc'] \n```", "```py\n# annotations/protocols.py\nfrom typing import Iterable, Protocol\nclass SupportsStart(Protocol):\n    def start(self) -> None: ...\nclass Worker:  # No SupportsStart base class.\n    def __init__(self, name: str) -> None:\n        self.name = name\n    def start(self) -> None:\n        print(f\"Starting worker {self.name}\")\ndef start_workers(workers: Iterable[SupportsStart]) -> None:\n    for worker in workers:\n        worker.start()\nworkers = [Worker(\"Alice\"), Worker(\"Bob\")]\nstart_workers(workers) \n```", "```py\nStarting worker Alice\nStarting worker Bob \n```", "```py\n# annotations/protocols.subclassing.py\nfrom typing import Iterable, Protocol\nclass SupportsStart(Protocol):\n    def start(self) -> None: ...\nclass SupportsStop(Protocol):\n    def stop(self) -> None: ...\nclass SupportsWorkCycle(**SupportsStart, SupportsStop, Protocol**):\n    pass\nclass Worker:\n    def __init__(self, name: str) -> None:\n        self.name = name\n    def start(self) -> None:\n        print(f\"Starting worker {self.name}\")\n    def stop(self) -> None:\n        print(f\"Stopping worker {self.name}\")\ndef start_workers(workers: Iterable[SupportsWorkCycle]) -> None:\n    for worker in workers:\n        worker.start()\n        worker.stop()\nworkers = [Worker(\"Alice\"), Worker(\"Bob\")]\nstart_workers(workers) \n```", "```py\n$ pip install mypy \n```", "```py\n$ mypy program.py some_folder another_folder \n```", "```py\n$ mypy --help \n```", "```py\n# mypy_src/simple_function.py\ndef hypothenuse(a, b):\n    return (a**2 + b**2) ** 0.5 \n```", "```py\n$ mypy simple_function.py\nSuccess: no issues found in 1 source file \n```", "```py\n$ mypy --strict mypy_src/simple_function.py\nmypy_src/simple_function.py:4:\n    error: Function is missing a type annotation  [no-untyped-def]\nFound 1 error in 1 file (checked 1 source file) \n```", "```py\n# mypy_src/simple_function_annotated.py\ndef hypothenuse(a: float, b: float) -> float:\n    return (a**2 + b**2) ** 0.5 \n```", "```py\n$ mypy simple_function_annotated.py \nSuccess: no issues found in 1 source file \n```", "```py\nprint(hypothenuse(3, 4))  # This is fine\nprint(hypothenuse(3.5, 4.9))  # This is also fine\nprint(hypothenuse(complex(1, 2), 10))  # Type checker error \n```", "```py\n$ mypy mypy_src/simple_function_annotated.py\nmypy_src/simple_function_annotated.py:10:\n    error: Argument 1 to \"hypothenuse\" has incompatible\n    type \"complex\"; expected \"float\"  [arg-type]\nFound 1 error in 1 file (checked 1 source file) \n```", "```py\n# mypy_src/case.py\nfrom collections.abc import Iterable\ndef title(names: Iterable[str]) -> list[str]:\n    return [name.title() for name in names]\nprint(title([\"ALICE\", \"bob\"]))  # ['Alice', 'Bob'] - mypy OK\nprint(title([b\"ALICE\", b\"bob\"]))  # [b'Alice', b'Bob'] - mypy ERR \n```", "```py\n$ mypy mypy_src/case.py\nmypy_src/case.py:10:\n    error: List item 0 has incompatible type \"bytes\";\n    expected \"str\"  [list-item]\nmypy_src/case.py:10:\n    error: List item 1 has incompatible type \"bytes\";\n    expected \"str\"  [list-item]\nFound 2 errors in 1 file (checked 1 source file) \n```", "```py\n# mypy_src/case.fixed.py\nfrom collections.abc import Iterable\ndef title(names: Iterable[**str** **|** **bytes**]) -> list[**str** **|** **bytes**]:\n    return [name.title() for name in names]\nprint(title([\"ALICE\", \"bob\"]))  # ['Alice', 'Bob'] - mypy OK\nprint(title([b\"ALICE\", b\"bob\"]))  # [b'Alice', b'Bob'] - mypy OK \n```"]