- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Closer Look at the ARM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already introduced the ARM processor. Now, we will look at it in a little
    more depth. The ARM family of processors is probably the best vehicle to teach
    computer architecture. In particular, it is very easy to learn because of its
    streamlined instruction set and simple register model compared to many other microprocessors.Moreover,
    the ARM has some very interesting features, such as predicated execution when
    an instruction can either be executed or ignored, depending on the processor status.
    The introduction of the Raspberry Pi in computer education could not have happened
    at a better time because it enables students to get hands-on experience of the
    remarkable ARM architecture.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduce the ARM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describe its register set
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examine variations in add and subtract operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cover the ARM’s multiplication instruction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduce logical operations and shifting operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explain flow control and the ARM’s conditional execution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Because this chapter is an extension of the previous chapter, no new hardware
    or software is required. All you need is Raspberry Pi, configured as a general-purpose
    computer. The only software needed is a text editor to create assembly language
    programs and the GCC assembler and loader.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the ARM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ARM processor family has been a remarkable success story, not least because
    so many other microprocessors became popular for a few years and then declined
    into obscurity (e.g., 6502, Cyrix 486, and Itanium). At the time of its release,
    the Motorola 68K was widely thought of as far more elegant and powerful than Intel’s
    8086\. Indeed, the 68K was a true 32-bit machine at a time when the 8086 was a
    16-bit machine. The 68K was adopted by Apple’s Mac, the Atari, and Amiga computers
    – all major players in the home computer market. How could Intel’s humble 8086
    possibly ever have competed? Well, IBM selected the 8086 family for its new personal
    computer and the rest is history. Motorola later dropped out of the semiconductor
    business.
  prefs: []
  type: TYPE_NORMAL
- en: In the late 1980s, a new company, Advanced RISC Machines, was founded to create
    high-performance microprocessors. The architecture of their machines followed
    the register-to-register paradigm of the RISC architecture, rather than Intel
    and Motorola’s more complicated CISC instruction sets. The ARM was born.
  prefs: []
  type: TYPE_NORMAL
- en: Not only has ARM survived when many of the earlier microprocessors failed –
    it has also prospered and successfully targeted the world of mobile devices, such
    as netbooks, tablets, and cell phones. ARM incorporates some interesting architectural
    features that have given it a competitive advantage over its rivals.
  prefs: []
  type: TYPE_NORMAL
- en: ARM is, in fact, a *fabless* company – that is, it develops the architecture
    of computers and allows other companies to manufacture those computers. The term
    *fabless* is derived from fab (short for fabrication).
  prefs: []
  type: TYPE_NORMAL
- en: Before we describe ARM’s instructions, we will discuss its register set because
    all ARM data-processing instructions operate on the contents of its registers
    (a prime feature of the RISC computer).
  prefs: []
  type: TYPE_NORMAL
- en: Because the ARM’s architecture has developed over the years, and because there
    are different versions of the ARM architecture in use, a teacher of it has a problem.
    Which version should be used to illustrate a computer architecture course? In
    this chapter, we will use the ARMv4 32-bit architecture, which has 32-bit instructions.
    Some ARM processors can switch between 32-bit and 16-bit instruction states (the
    16-bit state is called the *Thumb* state). The Thumb state is intended to run
    very compact code in embedded control systems. We will not cover the Thumb state
    here.
  prefs: []
  type: TYPE_NORMAL
- en: The ARM found in Raspberry Pi 4 has a 64-bit architecture that is very different
    from earlier 32-bit ARMs. However, since the 32-bit ARM architecture is used in
    most teaching texts and Raspberry Pi 4 supports it, we will use the 32-bit architecture
    here. In order to be consistent with other books using the ARM to illustrate computer
    architecture, most of the material here is based on ARMv4T 32-bit architecture.
    ARM’s 32-bit architectures are now referred to by the term AArch32, distinguishing
    them from ARM’s new 64-bit architecture, AArch64.
  prefs: []
  type: TYPE_NORMAL
- en: Overview of the ARM’s architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ARM’s architecture is interesting because it has elements of both the conventional
    CISC architecture such as Motorola’s 68K and Intel’s 32/64-bit architectures,
    together with the more radical streamlined RISC architecture of processors such
    as MIPS and RISC-V.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we will examine the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The ARM’s register set
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arithmetic instructions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Special addition and subtraction instructions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiplication and ARM’s multiplication and addition instruction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bitwise instruction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shifting operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We don’t cover data movement operations in detail here. We have already encountered
    the `mov` operation that can be used to load a literal into a register – for example,
    `mov r1,#12`. Similarly, the `str` and `ldr` instructions load a register from
    memory and store a register in memory, respectively. A typical example is `ldr
    r4,[r5]` and `str r0,[r9]`. These two instructions use *register indirect addressing*,
    and we will devote the next chapter to them.
  prefs: []
  type: TYPE_NORMAL
- en: Arm register set
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unlike the popular MIPS processor with its 32 general-purpose registers, ARM
    has just 16 registers, `r0` to `r15`, and a *status register*. Remarkably, the
    ARM’s registers are not all the same – that is, some are special-purpose registers.
    *Figure 10**.1* illustrates the ARM’s register set.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1 – The ARM’s register set](img/Figure_10.01_B19624.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.1 – The ARM’s register set
  prefs: []
  type: TYPE_NORMAL
- en: Fourteen registers, `r0` to `r13`, are indeed general-purpose in the sense that
    they all behave in the same way – for example, anything you can do with `r5`,
    you can do with `r10`. Registers `r13`, `r14`, and `r15` are not general-purpose
    because they have additional functions.
  prefs: []
  type: TYPE_NORMAL
- en: Strictly speaking, `r13` is a general-purpose register, but by convention, it’s
    reserved for use as a stack pointer. If you work on a project in a team, you should
    respect this convention. Otherwise, you do not have to follow the convention,
    and you can use `r13` in any way you wish.
  prefs: []
  type: TYPE_NORMAL
- en: Register `r14` has an additional function imposed by the hardware. It is a *link
    register* and can be written `lr` or `r14` in assembly programs. The ARM has an
    instruction, branch with link (`bl)`, that lets you jump to a point in the program
    (i.e., a branch) and save the address of the next instruction in sequence in the
    link register. In other words, the instruction saves the next `pc` address in
    `r14` and then jumps to the specified target. Later, you can return by copying
    the address in the link register to the pc with `mov pc,lr` or `mov 15,r14`. This
    is a faster subroutine call and return mechanism than the conventional `bsr` and
    `rts` pair of instructions that use a stack to store the return address.
  prefs: []
  type: TYPE_NORMAL
- en: Register `r15` is a truly different register from all the others and can never
    be used as a general-purpose register (even though you can apply some instructions
    to it as if it were general-purpose). Register `r15` is the *program counter*
    that contains the address of the next instruction to be executed and is normally
    written `pc` rather than `r15` in ARM code. Putting the program counter in a general
    register is very rare in the world of computer architecture. Note that, in practice,
    `pc` contains an address that is 8 bytes ahead of the current `pc` because of
    the way that the ARM is internally organized.
  prefs: []
  type: TYPE_NORMAL
- en: We will look at the ARM’s data processing instructions first, rather than the
    data movement operations. We take this approach because data movement instructions
    are more complicated, since they involve complex addressing modes.
  prefs: []
  type: TYPE_NORMAL
- en: Arithmetic instructions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s begin with ARM’s arithmetic instructions that perform operations on data
    representing *numeric quantities*:'
  prefs: []
  type: TYPE_NORMAL
- en: Addition          `add`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Subtraction        `sub`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparison        `cmp` (technically, `compare` is not a data-processing operation)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiplication        `mul`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shifting            `lsl, lsr, asl, asr,` `ror, rrx`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Addition, subtraction, and comparison
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Addition is a simple operation that adds two operands to generate a sum and
    a carryout. In decimal arithmetic, adding 4 + 5 gives 9\. Adding 4 + 9 gives 13
    ; that is, a result of 3 and a carry-out of 1\. Computers deal with this by storing
    the carryout in the carry bit. ARM instructions require you to add the suffix
    `s` if you wish to update condition code flags after an operation – that is, you
    need to write `add`s `r1,r2,r3`.
  prefs: []
  type: TYPE_NORMAL
- en: The ARM is a 32-bit machine. How do you add 64-bit numbers? Suppose that two
    64-bit numbers are `A` and `B`, where AL is the lower-order 32 bits of A, and
    AU is the upper-32 bits of `A`. Similarly, BL is the lower-order 32 bits of `B`,
    and BU is the upper-32 bits of `B`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We first add AL to BL and record the carry. Then we add together AU and BU,
    plus any carry generated from the addition of the lower-order pair. In ARM assembler
    language, this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The second addition, `adc`, means, *add with carry*, and adds any carry out
    from the previous addition. We’ve used CL, AL, BL, and so on, rather than `r1`,
    `r2`, and `r3` to demonstrate that these are upper- and lower-order parts of a
    number distributed between two registers. We can extend this principle to perform
    extended-precision arithmetic with integers of any length.
  prefs: []
  type: TYPE_NORMAL
- en: The ARM also provides a simple subtract operation, `sub`, together with a `sbc`
    or *subtract with carry* instruction to support extended-precision subtraction,
    which operate like the corresponding `adc`.
  prefs: []
  type: TYPE_NORMAL
- en: As well as `sub` and `sbc`, the ARM has a *reverse* subtract operation, where
    `rsc` r1, `r2`, `r3` perform the subtraction of `r2` from `r3`. This instruction
    may seem strange and unnecessary because you can simply reverse the order of the
    second two registers, can’t you? However, ARM lacks a *negation* instruction that
    subtracts a number from zero ; for example, the negative of `r0` is `0 – [r0]`.
    The reverse subtraction operation can be used to do this because `rsb` r1`,r1,#0`
    is equivalent to `neg r1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A comparison operation compares two values by subtracting one from the other
    – for example, we can compare 3 with 5\. Suppose the two elements being compared
    are `A` and `B`. If you perform `A` – `B` and the answer is zero, then `A` and
    `B` are equal. If the result is positive, `A > B`, and if it’s negative, `A <
    B`. A comparison is a subtraction where you don’t care about the result ; only
    its sign, whether it’s zero, whether a carry was generated. Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The operation `cmp` r1,`r2` evaluates `[r1] – [r2]` and updates the `Z`, `C`,
    `N`, and `V` bits. We can then perform operations such as `beq next` that branch
    to label `next` if `r1` and `r2` are equal. We said that you need to append `s`
    to update condition codes. Comparison operations are exceptions because setting
    condition codes is what they do. You can write `cmps` if you want, since it’s
    the same as `cmp`.
  prefs: []
  type: TYPE_NORMAL
- en: There are two types of integer comparison. Consider (in 8 bits) the `A = 00000001`
    and `B = 11111111` binary values. Which is the larger? You might think that it’s
    `B`, since `B = 255` and `A = 1`. That’s true. However, if these were assigned
    `2`s complement numbers, `A` would be `1` and `B` would be `-1`; therefore, `A`
    is the larger. Like all processors, ARM provides two sets of branch operations,
    one for unsigned arithmetic and one for signed arithmetic. A programmer must select
    the appropriate branch depending on whether they use signed or unsigned arithmetic.
    The simulators we constructed earlier all provided unsigned branches only.
  prefs: []
  type: TYPE_NORMAL
- en: Multiplication
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'ARM’s multiply instruction, `mul` Rd`,Rm,Rs`, generates the low-order 32 bits
    of the 64-bit product `Rm` `x Rs`. When using `mul`, you should ensure that the
    result does not go out of range because multiplying two m-bit numbers yields a
    `2m`-bit product. This instruction doesn’t let you multiply the contents of a
    register by a constant – that is, you can’t perform `mul` r9`,r4,#14`. Moreover,
    you can’t use the *same* register to specify both the Rd destination and the `Rm`
    operand. These restrictions are due to the implementation of this instruction
    in hardware. The following code demonstrates the use of ARM’s multiplication to
    multiply 23 by 25:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We’ve already seen that ARM has a *multiply and accumulate instruction*, `mla`,
    with a *four-operand* format `mla` Rd,`Rm`,`Rs`,`Rn`, whose RTL definition is
    `[Rd]` ← `[Rm]` x `[Rs] + [Rn]`. The 32-bit by 32-bit multiplication is truncated
    to the lower-order 32 bits. Like the multiplication, `Rd` must not be the same
    as `Rm` (although this restriction was removed in the ARMv6 and later architectures).
  prefs: []
  type: TYPE_NORMAL
- en: ARM’s *multiply and accumulate* instruction supports the calculation of an *inner-product*
    by performing one multiplication and addition per instruction. The inner-product
    is used in multimedia applications – for example, if vector a consists of the
    *n* components a1, a2, … an and vector b consists of the *n* components b1, b2,
    ... , bn, then the *inner product* of a and b is the scalar value s = **a·b**
    = a1·b1 + a2·b2 + … + an·bn.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now demonstrate an application of the multiply and accumulate operations.
    Although we have not yet covered the ARM’s addressing modes, the following example
    includes the instruction `ldr` r0`,[r5],#4` that loads register `r0` with an element
    from the array pointed at by register `r5`, and then it updates `r5` to point
    at the next element (4 bytes on):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: What about division? The ARMv4 architecture lacks a division instruction as
    part of its basic architecture (some variants of ARM such as the ARMv7 architecture
    do incorporate division). If you wish to do division on the ARM, you have to write
    a short program that uses an iterative loop involving shifting and subtracting
    to perform the division (rather like pencil and paper long division).
  prefs: []
  type: TYPE_NORMAL
- en: Bitwise logical operations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The ARM provides the basic `AND`, `OR`, `NOT`, and `EOR` (exclusive or) bitwise
    logical operations supported by most processors. These are used to set, clear,
    and toggle the individual bits of a word, as we already saw when assembling instructions.
    There is also an unusual *bit clear* operation, `bic`, that `AND`s its first operand
    with the *complement of the corresponding bits* of its second operand – that is,
    ci = ai ∧ bi.
  prefs: []
  type: TYPE_NORMAL
- en: The ARM’s NOT operation is written as `mvn` rd,rs. This move instruction negates,
    inverts the bits of the source register and copies them to the destination register.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following examples illustrate logical operations on r1 = 110010102 and
    r0 = 000011112:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Logical instruction** | **Operation** | **Final value** **in r2** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `and` r2`,r1,r0` | 11001010 ∧ 00001111 | 00001010 |'
  prefs: []
  type: TYPE_TB
- en: '| `or` r2`,r1,r0` | 11001010 + 00001111 | 11001111 |'
  prefs: []
  type: TYPE_TB
- en: '| `mvn` r2`,r1` | īōōīōīō￼ | 00110101 |'
  prefs: []
  type: TYPE_TB
- en: '| `eor` r2`,r1,r0` | 11001010 ⊕ 00001111￼ | 11000101 |'
  prefs: []
  type: TYPE_TB
- en: '| `bic` r2`,r1,r0` | 11001010 ∧ ōōōōīīīī | 11000000 |'
  prefs: []
  type: TYPE_TB
- en: When you design instruction sets, one of the major tasks is to construct binary
    codes for instructions. These operations make it easy to implement the manipulation
    of bits. For example, suppose variable `sR1` specifies source register 1, and
    `sR2` specifies source register 2, and we have to construct a 16-bit binary code,
    `C`, with the format `xxxxx`aaa`xx`bbb`xxx`. Source bits `a` are in `sR1` and
    source bits `b` are in `sR2` in the lower-order three bits.
  prefs: []
  type: TYPE_NORMAL
- en: 'We must insert the bits of `sR1` and `sR2` at the appropriate places without
    changing any other bits of `C`. In Python, we can do this with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We can readily translate this into ARM assembly language using `AND`, `OR`,
    and shift operations. Assume `sR1` is in `r1`, `sR2` is in `r2`, and `C` is in
    register `r0`. Moreover, assume that the register bits are already in place in
    their respective registers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Shift operations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Python can shift bits left using the `<<` operator, or right using the `>>`
    operator. ARM’s assembly language lacks explicit instructions such as `LSR` or
    `LSL` that shift bits right or left. However, it does have pseudo-instructions
    such as `lsl` r1,`r3`,`#4` that shift the contents of `r3` four places left, transferring
    the result to `r1`. The ARM’s *actual* approach to shifting is rather more unusual,
    complicated, and *versatile*.
  prefs: []
  type: TYPE_NORMAL
- en: The ARM includes shifting as part of conventional data operations. Consider
    `add` r1`,r2,r3`, which adds `r3` to `r2` and puts the result in `r1`. ARM allows
    you to shift the second operand *before* it is used in a data processing operation.
    You can write `add r1,r2,r3, lsl r4` (see *Figure 10**.2* for an explanation of
    the second destination field).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2 – The structure of a dynamic shift operation](img/Figure_10.02_B19624.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.2 – The structure of a dynamic shift operation
  prefs: []
  type: TYPE_NORMAL
- en: 'This instruction takes the second source operand, r3, and performs a logical
    shift left. The number of left shifts is determined by the contents of r4\. You
    can also implement a fixed shift using a constant with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this case, register r3 is shifted left by three bits before it is added to
    `r2`. A shift is called *dynamic* if the number of shifts is specified by a register,
    since you can change the number of shifts at runtime by changing the shift count.
    If the number of shifts is given by a literal (constant), it cannot be changed
    at runtime. This is a *static* shift.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ARM’s shift combines a data-processing operation with shifting (speeding
    up data processing), and it lets you specify four registers in an instruction.
    What do you do if you require a plain vanilla shift without including a data-processing
    instruction? You can use the `MOV` instruction, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Today, ARM assemblers let you write the pseudo-instruction `lsl` r1`,r3,#4`
    and automatically substitute the move instruction `mov` r1`,r1,lsr #4`, using
    a shifted second operand.'
  prefs: []
  type: TYPE_NORMAL
- en: Shift types
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: All shifts look the same from the middle of a string of bits – that is, the
    bits move one (or more) places left or right. However, what happens to the bits
    at the end? When bits are shifted in a register, at one end, a bit will drop out.
    That bit can disappear into oblivion, go to the carry bit, or move around to the
    other end in a circular fashion. At the end where a bit is vacated, the new bit
    can be set to `0`, `1`, the same as the carry bit, or the bit that fell off the
    other end.
  prefs: []
  type: TYPE_NORMAL
- en: 'The variations in the way that the bit shifted in is treated by computers correspond
    to specific types of shift – *logical*, *arithmetic*, *rotate*, and *rotate through
    carry*. Let’s look at some shift operations (*table 10.1*):'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Source string** | **Direction** | **Number** **of shifts** | **Destination
    string** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0`110011111010111` | Left | 1 | `110011111010111`*0* |'
  prefs: []
  type: TYPE_TB
- en: '| 01`10011111010111` | Left | 2 | `10011111010111`*00* |'
  prefs: []
  type: TYPE_TB
- en: '| 011`0011111010111` | Left | 3 | `0011111010111`*000* |'
  prefs: []
  type: TYPE_TB
- en: '| `011001111101011`1 | Right | 1 | *0*`011001111101011` |'
  prefs: []
  type: TYPE_TB
- en: '| `01100111110101`11 | Right | 2 | *00*`01100111110101` |'
  prefs: []
  type: TYPE_TB
- en: '| `0110011111010`111 | Right | 3 | *000*`0110011111010` |'
  prefs: []
  type: TYPE_TB
- en: Table 10.1 – ARM's logical shift operations
  prefs: []
  type: TYPE_NORMAL
- en: 'The bits in the destination string in italic are the bits shifted in, and the
    bits in the source string in bold are the bits lost (dropped) after the shift.
    This type of shift is a *logical* shift:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Logical shift**: The bits shifted are moved one or more places left or right.
    Bits fall off at one end and zeros enter at the other end. The last bit shifted
    out is copied to the carry flag. *Figure 10**.3* illustrates the logical shift
    left and the logical shift right.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 10.3 – Logical shifts](img/Figure_10.03_B19624.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.3 – Logical shifts
  prefs: []
  type: TYPE_NORMAL
- en: '**Arithmetic shift**: This arithmetic shift treats the number being shifted
    as a signed twos complement value. An arithmetic shift left is the same as a logical
    shift for left shifts. For right shifts, the most-significant bit is propagated
    right. This shift treats the operand as a signed value, which is either divided
    by two (shift right one bit) or multiplied by two (shift left one bit), as *Figure*
    *10**.4* demonstrates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The purpose of an arithmetic shift is to preserve the sign of a twos complement
    number, when it takes part in a shifting operation that represents division by
    the power of 2\. For example, the 8-bit value `10001111` becomes `01000111` when
    shifted right *logically*, but 11`000111` when shifted right *arithmetically*.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 10.4* illustrates the arithmetic shift left and shift right. The ARM
    has an `asr` operation but not `asl`, because `asl` is identical to `LSL` – that
    is, you use a logical shift left because it is exactly the same as asl.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.4 – Arithmetic shifts](img/Figure_10.04_B19624.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.4 – Arithmetic shifts
  prefs: []
  type: TYPE_NORMAL
- en: '`01101110` being rotated left, one bit at a time:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 10.5 – Example of successive rotate operations](img/Figure_10.05_B19624.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.5 – Example of successive rotate operations
  prefs: []
  type: TYPE_NORMAL
- en: The rotate operation is *non-destructive* – that is, no bit is lost or changed
    by the operation. It is very useful in operations such as counting the number
    of `1`s in a bit string. *Figure 10.6* illustrates the *rotate* operation. Note
    that the ARM does *not* have a rotate right instruction – that is, there is no
    `ror`. Since rotate is a circular operation, shifting an *m*-bit word *p* places
    right is achieved by shifting `32-p` places left; consequently, `ror r0,r1,#4`
    is achieved by `rol r0,r1,#28`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.6 – Rotate operations (ARM does not implement ROL)](img/Figure_10.06_B19624.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.6 – Rotate operations (ARM does not implement ROL)
  prefs: []
  type: TYPE_NORMAL
- en: A variation of the rotate operation is the *rotate through carry*, where the
    carry bit is considered as part of the word being shifted – that is, an *n*-bit
    word becomes an *n+1* bit word. *Figure 10.7* demonstrates a rotate through carry
    operation, where the carry shifted out is copied into the carry bit, and the old
    value of the carry bit becomes the new bit shifted in. This operation is used
    in chained arithmetic (it’s the analog of the *add with carry and subtract with
    borrow* operations).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.7 – Rotate through carry](img/Figure_10.07_B19624.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.7 – Rotate through carry
  prefs: []
  type: TYPE_NORMAL
- en: 'ARM implements only the following five shifts (a programmer can synthesize
    the rest):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`rrx`, which rotates bits right through carry (*Figure 10.7*), behaves differently
    from other shifts. First, only one direction of shift is permitted; there is no
    left shift through carry. Second, the ARM supports both *static* and *dynamic*
    shifts for all other shift operations, whereas `rrx` allows only one single shift.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Although there is no rotate left operation, you can readily implement it by
    means of a rotate right operation. The following example demonstrates the rotation,
    both left and right, of a 4-bit value. After four rotations, the number is unchanged.
    As you can see, there is symmetry between left and right rotations. For a 32-bit
    value, an *n*-bit shift left is identical to a 32-*n* bit shift right:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Rotate right  | Rotate left |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1101 | Start | 1101 | Start |'
  prefs: []
  type: TYPE_TB
- en: '| 1110 | Rotate right 1 | 1011 | Rotate left 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 0111 | Rotate right 2 | 0111 | Rotate left 2 |'
  prefs: []
  type: TYPE_TB
- en: '| 1011 | Rotate right 3 | 1110 | Rotate left 3 |'
  prefs: []
  type: TYPE_TB
- en: '| 1101 | Rotate right 4 | 1101 | Rotate left 4 |'
  prefs: []
  type: TYPE_TB
- en: Table 10.2 - Comparing successive left and right rotates
  prefs: []
  type: TYPE_NORMAL
- en: Consider `adcs` r0,`r0`,`r0` (add with carry and set status flags). This adds
    the contents of `r0` to the contents of `r0`, plus the carry bit, to generate
    `2 x [r0] + C`. Shifting left is equivalent to multiplying by 2\. Moving the carry
    bit into the least-significant position is equivalent to adding the carry bit
    to get `2 x [r0] + C`. Appending `S` to the instruction forces the `CCR` to be
    updated, which ensures that any carryout is loaded into the C-bit. Consequently,
    `adcs` r0,`r0`,`r0` and `rlx` r0 are equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: Using shift operations to merge data
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In the following example, we extract the least-significant byte from each of
    the three registers and put them together in a new word. The literals are in a
    hexadecimal format. Assume that the registers are, initially, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`r1` = `XXXXXX`AA   `r1` is source 1, the Xs represent don’t care values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`r2` = `XXXXXX`BB   `r2` is source 2'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`r3` = `XXXXXX`CC   `r3` is source 3'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`r4` = `00`CCBBAA   `r4` is the final result'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is a brute-force approach. A better alternative is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, consider `r0 = 0x0000`AA, `r1 = 0x000000`BB, and `r2 = 0x12345678`. We
    wish to merge the four registers to get `0x`AABB`5678`. We can do this with just
    three instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`add r2,r1,r2,lsl #16` adds `r1` to `r2` after `r2` has been shifted left 16
    times. The 16-bit left shift moves the lower-order 16-bits of `r2` into the upper-order
    16-bits, and it clears the lower-order 16 bits by shifting in zeros. We’ve preserved
    the old lower-order half of `r2`, and we’ve cleared the new lower-order 16 bits
    ready to insert the bytes from `r0` and `r1`. add r2`,r2,r0,lsl #8` inserts the
    low-order byte of `r0` into bits 8 to 15 of `r2`, since `r0` is first shifted
    left by 8 bits. Since zeros are shifted into `r0`, this operation doesn’t affect
    bits 0 to 7 of `r2`. Executing `mov` r2`,r2,ror #16` performs a 16-bit rotation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next example of shifting demonstrates how we can implement `if x < 0: x
    = 0`. This construct sets the `x` variable to zero if `x` is negative (i.e., `msb`
    is `1`); otherwise, `x` is unchanged. The ARM code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The arithmetic shift right propagates the sign-bit 31 times, leaving `0x00000000`
    for a positive number and `0xFFFFFFFF` for a negative number. The `bic` operation
    `AND`s the first operand and the complement of the second. If `r0` was positive,
    all bits are `AND`ed, with 1 leaving `r0` unchanged. If `r0` was negative, the
    bits are `AND`ed, with `0` leaving `0`. Therefore, a positive `x` is unchanged
    and a negative `x` is set to `0`.
  prefs: []
  type: TYPE_NORMAL
- en: The next section looks at a class of instruction that does not move data or
    process data; it determines which instruction will be executed next.
  prefs: []
  type: TYPE_NORMAL
- en: Flow control instructions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Computers execute instructions sequentially unless a branch causes a jump to
    an out-of-sequence instruction, or the flow of instructions is interrupted when
    a subroutine is called. The instruction flow is also changed when an interrupt
    occurs (we don’t deal with interrupts here).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will look at the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Unconditional branches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conditional branches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unconditional branches
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'ARM’s unconditional branch is expressed as `b target`, where `target` denotes
    the *branch target address* (the address of the next instruction to be executed).
    The unconditional branch forces a jump (branch) from one point in a program to
    another. It is exactly the same as the unconditional branch we introduced earlier.
    The following ARM code demonstrates how the unconditional branch is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The ARM’s branch instructions use a 24-bit literal to provide a twos complement
    relative offset. This is shifted left twice to create a 26-bit *byte* offset,
    which is added to the current program counter to obtain the 32-bit target address.
    The branch range is 32 MB from the current PC (in either direction). Remember
    that consecutive instruction addresses differ by four.
  prefs: []
  type: TYPE_NORMAL
- en: Conditional branch
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'ARM’s conditional branches consist of a mnemonic Bcc and a target address.
    The subscript defines one of 16 conditions that must be satisfied for the branch
    to be taken. If the condition is `true`, execution continues at the branch target
    address. If the condition is not `true`, the next instruction in sequence is executed.
    Consider the flowing example in ARM assembly language that implements the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The *conditional branch* instruction tests flag bits in the processor’s condition
    code register and then takes the branch if the tested condition is true. Since
    the condition code register includes a zero bit (`Z`), negative bit (`N`), carry
    bit (`C`), and overflow bit (`V`), there are eight conditional branches based
    on the state of a single bit (four that branch on true and four that branch on
    `false`). *Table 10.3* defines all the ARM’s conditional branches. Note that there
    is a branch *always* and a branch *never* instruction.
  prefs: []
  type: TYPE_NORMAL
- en: Branch instructions can be applied to *signed* or *unsigned* data. Consider
    the four-bit values `x = 0011` and y = 1001\. We want to branch if `y` is greater
    than `x`. Using unsigned arithmetic, `x = 3` and `y` is `9`, so y > x. However,
    if we regard these as signed values, then `x = 3` and `y = -7`, so `y < x`. Clearly,
    we have to select an unsigned comparison for unsigned arithmetic and a signed
    comparison for signed arithmetic.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Encoding** | **Mnemonic** | **Branch on** **flag status** | **Execute**
    **on condition** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0000 | EQ | Z set | Equal (i.e., zero) |'
  prefs: []
  type: TYPE_TB
- en: '| 0001 | NE | Z clear | Not equal (i.e., not zero) |'
  prefs: []
  type: TYPE_TB
- en: '| 0010 | CS or HS | C set | Unsigned higher or same |'
  prefs: []
  type: TYPE_TB
- en: '| 0011 | CC or LO | C clear | Unsigned lower |'
  prefs: []
  type: TYPE_TB
- en: '| 0100 | MI | N set | Negative |'
  prefs: []
  type: TYPE_TB
- en: '| 0101 | PL | N clear | Positive or zero |'
  prefs: []
  type: TYPE_TB
- en: '| 0110 | VS | V set | Overflow |'
  prefs: []
  type: TYPE_TB
- en: '| 0111 | VC | V clear | No overflow |'
  prefs: []
  type: TYPE_TB
- en: '| 1000 | HI | C set and Z clear | Unsigned higher |'
  prefs: []
  type: TYPE_TB
- en: '| 1001 | LS | C clear or Z set | Unsigned lower or same |'
  prefs: []
  type: TYPE_TB
- en: '| 1010 | GE | N set and V set, or N clear and V clear | Signed greater or equal
    |'
  prefs: []
  type: TYPE_TB
- en: '| 1011 | LT | N set and V clear, or N clear and V set | Signed less than |'
  prefs: []
  type: TYPE_TB
- en: '| 1100 | GT | Z clear, and either N set and V set, or N clear and V clear |
    Signed greater than |'
  prefs: []
  type: TYPE_TB
- en: '| 1101 | LE | Z set, or N set and V clear, or N clear and V set | Signed less
    than or equal |'
  prefs: []
  type: TYPE_TB
- en: '| 1110 | AL | Unconditional | Always (default) |'
  prefs: []
  type: TYPE_TB
- en: '| 1111 | NV |  | Never (reserved) |'
  prefs: []
  type: TYPE_TB
- en: Table 10.3 – ARM’s conditional execution and branch control mnemonics
  prefs: []
  type: TYPE_NORMAL
- en: Some microprocessors have *synonyms* for conditional branch operations – that
    is, a branch condition has two mnemonics. For example, branch on carry set `(bcs)`
    can be written branch on higher or same `(bhs)`, because `C = 1` implements the
    ( `>` ) operation in unsigned arithmetic. Similarly, `bcc` can be written branch
    on lower `(blo)`, because the carry clear implements an unsigned comparison that
    is lower.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the best examples of the use of conditional branching is in repetitive
    structures. Consider the `while` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The final section of this chapter looks at ARM’s *conditional execution mechanism*,
    which provides a means of squashing or *annulling* instructions – that is, you
    can choose to run or not run an instruction at runtime. This is a feature found
    on very, very few processors. However, this mechanism provides the ARM with a
    very interesting means of speeding execution by creating compact code.
  prefs: []
  type: TYPE_NORMAL
- en: Conditional executions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, we will deal with just one topic, conditional executing, and we will demonstrate
    how you can ignore an instruction if it does not fulfill a specified criterion
    (related to the condition control status bits). This mechanism enables programmers
    to write more compact code.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the `add` instruction. When the computer reads it from memory, it is
    executed, exactly like almost every other computer. The ARM is different; each
    of its instructions is *conditionally executed* – that is, an instruction is executed
    only if a specific condition is met; otherwise, it is bypassed (annulled or squashed).
    Each ARM instruction is associated with a logical condition (one of the 16 in
    *Table 10.3*). If the stated condition is true, the instruction is executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'A suffix indicates conditional execution by appending `condition` – for example,
    `add`eqr1`,r2,r3` specifies that the addition is performed *only if the Z-bit
    in the CCR is set*. The RTL form of this operation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'There is, of course, nothing to stop you from combining conditional execution
    and shifting, since the branch and shift fields of an instruction are independent.
    You can write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This is interpreted as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'To demonstrate the power of conditional execution, consider the following Python
    statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Translated into ARM code using conditional execution, we can write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'After the test, the operation is either executed or not executed, depending
    on the result of the test. Now, consider a construct with a compound predicate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The first line, `cmp` r0`,r1`, compares `a` and `b`. The next line, `cmp`eqr2`,r3`,
    executes a conditional comparison only if the result of the first line was true
    (i.e., `a == b`). The third line, `add`eqr4`,r4,#1`, is executed only if the previous
    line was true (i.e., `c == d`) to implement `e = e + 1`. Without conditional execution,
    we might write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This conventional approach to compound logical conditions requires five instructions.
    You can also handle some testing with multiple conditions. Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the same register assignments as before, we can use conditional execution
    to implement this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Using conventional non-conditional execution, we would have to write the following
    to implement this algorithm. This is rather less elegant than the previous version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In the next example, we use conditional execution to obtain the absolute value
    of a signed integer – that is, if the integer is negative, it is converted into
    the corresponding positive value. For example (in 8 bits), -2 is `11111110`, which
    would be converted into `00000010` (i.e., +2).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use ARM’s `teq` instruction `teq` is similar to `CMP`, but `teq` does
    not set the `V` and `C` flags during the test. `teq` is useful to test for negative
    values *because the N-bit is set to 1 if the number tested* *is negative*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Here, the operand in `r0` is tested, and the N-bit is set if it is negative
    and is clear if it is positive. The conditional instruction, `rsb`mi, is not executed
    if the tested operand was positive (no change is necessary). If the number was
    negative, the reverse substation performs `0 – r0`, which reverses its sign and
    makes it positive.
  prefs: []
  type: TYPE_NORMAL
- en: Sequential conditional execution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since a compare or an arithmetic operation updates the `C`, `N`, `V`, and `Z`
    bits, we can perform up to four conditional acts after one comparison. The following
    example converts uppercase ASCII-encoded characters to lowercase characters –
    for example, ''M'' would be converted to ''m.'' Bit 5 of an ASCII character is
    zero for uppercase letters and one for lowercase letters. Consider the code that
    first checks whether a character is in the range of ''A'' to ''Z'' and converts
    it to lowercase if it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The first instruction, `cmp`, checks whether the character is 'A' or greater
    by subtracting the ASCII code for 'A.' If it is, the `rsb`ges checks that the
    character is less than 'Z.' This test is performed only if the character in `r0`
    is greater or equal to 'A.' We use reverse subtraction because we want to test
    whether the ASCII code for Z minus the ASCII code for the character is positive.
    If we are in range, the conditional `orr` is executed, and an uppercase to lowercase
    conversion is performed by setting bit 5.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at how operands are specified – that is, we
    will look at addressing modes.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we’ve extended our knowledge of the ARM beyond the basic data-processing
    instructions we encountered in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We began with the ARM’s register set, which is different from almost every other
    processor. RISC processors generally have 32 general-purpose registers. The ARM
    has only 16 registers.
  prefs: []
  type: TYPE_NORMAL
- en: Two of the ARM’s registers have a special purpose. Register `r14` is called
    a *link register* and is used by the branch with link instructions to restore
    return addresses. Otherwise, it is a general-purpose register. Register `r15`
    is the program counter, and that is very unusual indeed. This makes the ARM a
    very interesting device because you can change the program counter by operating
    on `r15`.
  prefs: []
  type: TYPE_NORMAL
- en: We also looked at shifting operations. Shifting simply involves bits moving
    one or more places left or right. However, as bits are in registers or memory
    locations, a shift involves bits moving into one and dropping out the other. The
    different types of shifts are determined by what happens to those bits that are
    shifted in or out at the ends of the number.
  prefs: []
  type: TYPE_NORMAL
- en: We discovered that the ARM has another unusual feature because it doesn’t provide
    pure shift instructions. Instead, it can apply a shift to the second operand in
    a conventional data processing operation. The ARM can execute an `add` r0`,r1,r2,
    lsl r3` instruction that shifts the contents of register `r2` left by the value
    in `r3`. The shifted value is then added to `r1`, and the result is transferred
    to `r0`. This mechanism provides a *free shift* because you can do a shift and
    not have to pay any penalty to execute it.
  prefs: []
  type: TYPE_NORMAL
- en: Probably the most intriguing feature of the ARM is its ability to perform conditional
    execution – that is, before an instruction is executed, the condition code bits
    are checked. For example, `add`eq `r0,r1,r2` performs an addition only if the
    z-bit is set to `1`. This is a very powerful operation, and you can use it to
    write compact code.
  prefs: []
  type: TYPE_NORMAL
- en: Sadly, it appears that conditional execution is a clever technique whose time
    has passed. It’s not a cost-effective operation today. Conditional execution reduces
    the number of branches in a program and the number of clock cycles required to
    execute a program. Advances in computer technology have made conditional execution
    redundant in new CPU designs.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at the ARM’s addressing modes – one of the
    highlights of this processor.
  prefs: []
  type: TYPE_NORMAL
