- en: Chapter 10. Tools to Improve Test-Driven Development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up to this point, we have mostly been looking at how to write and run tests.
    In this chapter, we will turn our attention to integrating the tests with the
    wider development environment. Having tests integrated into the development environment
    is important because it allows us to set up an automated process through which
    tests are executed regularly. We will also look at other tools that can improve
    the way we do TDD—from other test runners to libraries that make asserting easier.
  prefs: []
  type: TYPE_NORMAL
- en: TDD tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We looked at the nose2 test runner earlier in this book. Python has other popular
    third-party test runners. Python also has a number of libraries to make assertions
    more flexible and readable. These libraries can be used with both `unittest` compatible
    tests and the function style tests supported by third-party test runners. Let
    us take a look at some of these TDD tools.
  prefs: []
  type: TYPE_NORMAL
- en: py.test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Like nose2, py.test is another popular third-party test runner. py.test supports
    many features like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Writing tests as ordinary functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Python's `assert` statement to perform asserts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ability to skip tests or mark tests as expected failures.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixtures with setup and teardown support.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extensible plugin framework, with plugins available to do popular functionality
    such as XML output, coverage reporting, and running tests in parallel across multiple
    processors or cores.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tag tests with attributes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration with popular tools.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'One of py.test''s most unique features is funcargs. Take a look at the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this code, the `test_stock_update` function takes a parameter called `goog`.
    Additionally, we have a function called `goog`, which is marked with the `pytest.fixture`
    decorator. PyTest will match these two, call the appropriate fixture, and pass
    in the return value as a parameter to the test.
  prefs: []
  type: TYPE_NORMAL
- en: 'This solves the following two problems:'
  prefs: []
  type: TYPE_NORMAL
- en: It enables us to pass fixture values to function style test cases without having
    to resort to globals.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instead of writing a large fixture, we can create many small ones, and the test
    cases only use the fixtures that they need. This makes it easier to read test
    cases as we don't have to look at a large fixture setup that has different lines
    of setup meant for different tests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The above example only scratches the surface of funcargs. `py.test` supports
    a number of other usage scenarios with funcargs. Definitely check out this popular
    test runner.
  prefs: []
  type: TYPE_NORMAL
- en: py.test versus nose2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There isn't a lot to choose between nose2 and py.test. nose2 has a unique feature
    in writing tests using layers, while py.test has a unique feature in funcargs.
    Apart from that, both support running of `unittest` test cases, both have a robust
    plugin framework, and both can be integrated with all the tools we discuss in
    this chapter. The decision between them really comes down to a personal choice
    between layers versus funcargs, or if one supports a particular plugin that we
    really want. Definitely take a look at py.test at its homepage at [http://pytest.org/latest/](http://pytest.org/latest/).
  prefs: []
  type: TYPE_NORMAL
- en: Trial
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Trial is a unit test runner that was originally built for testing Python's Twisted
    framework. Trial supports running vanilla unit tests written using the `unittest`
    module, as well as advanced features specifically for supporting applications
    based on network programming—clients, servers, and the like. The most important
    of these is support for asynchronous programming models, where a method might
    return immediately, but the actual return value is received later on. This is
    usually done using a concept called `Deferred`. Since this is a deep and niche
    topic, we won't go into a detailed discussion in this book. Just keep in mind
    that if you are doing anything with network programming, event-based systems,
    or asynchronous programming, then you should check out Trial at its homepage at
    [http://twistedmatrix.com/trac/wiki/TwistedTrial](http://twistedmatrix.com/trac/wiki/TwistedTrial).
  prefs: []
  type: TYPE_NORMAL
- en: Sure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sure is a Python library to help write assertions that are easier to read. It
    is a Python port of the should.js JavaScript library.
  prefs: []
  type: TYPE_NORMAL
- en: 'With Sure, we can take the following test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'And, rewrite it to look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice how the assert has been replaced with a statement that reads like regular
    English. Sure adds a bunch of attributes to all objects to allow us to write asserts
    like this.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is how our float test would look like in Sure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'And, the following is how we would check for expected exceptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Sure also supports using Python''s `assert` statement as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Sure supports a large number of expressions like the one above to express a
    multitude of assertion conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Sure uses some monkey patching to add these attributes to all objects. The monkey
    patching is done once the `import sure` statement is executed. For this reason,
    be careful to use Sure only on unit test files and not in any production file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Monkey patching can be disabled by setting the `SURE_DISABLE_NEW_SYNTAX` environment
    variable to true before running tests. When monkey patching is disabled, Sure
    supports an alternate syntax using the expect function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Full details on all available methods and syntax are available on the Sure homepage
    at [http://falcao.it/sure/intro.html](http://falcao.it/sure/intro.html).
  prefs: []
  type: TYPE_NORMAL
- en: Since assertions are plain functions, we can use this library even when writing
    function style tests supported by nose2 and py.test.
  prefs: []
  type: TYPE_NORMAL
- en: PyHamcrest
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PyHamcrest is a Python port of the Java Hamcrest library. This is another library
    to enable us to write cleaner and more flexible asserts.
  prefs: []
  type: TYPE_NORMAL
- en: 'PyHamcrest defines its own `assert_that` function and a number of matchers
    such as `equal_to`. Using them, we can write a test like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'PyHamcrest also has a system for writing custom matchers by inheriting from
    the `BaseMatcher` class. The following is a custom matcher that checks whether
    a stock has the crossover signal returning a particular value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The class defines two methods: `_matches` and `describe_to`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `_matches` method takes the first parameter for the `assert_that` function
    call and returns whether it matches the given condition or not. In this case,
    we call the `get_crossover_signal` method and check whether it matches the signal
    that we were expecting.
  prefs: []
  type: TYPE_NORMAL
- en: The `describe_to` method returns a text description that is used for the message
    displayed when the assertion fails.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also define a convenience function `is_buy_on`, which returns a matcher
    to match the `StockSignal.buy` signal as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'With this, we can write a test like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Like Sure, PyHamcrest assertions are plain functions and are suitable for use
    in function style tests supported by nose2 and py.test. You can visit PyHamcrest's
    homepage at [https://github.com/hamcrest/PyHamcrest](https://github.com/hamcrest/PyHamcrest).
  prefs: []
  type: TYPE_NORMAL
- en: Integrating with build tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It just takes a single line to execute our test cases. Then why would we want
    to integrate with build tools? Build tools support pre-requisites, so by integrating
    with such tools, we can ensure the tests are run before performing a critical
    task. An example would be to run all the tests before deploying the code to production.
  prefs: []
  type: TYPE_NORMAL
- en: Paver
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Paver is a popular Python-based build tool. It is built around the concept of
    tasks. Tasks are a sequence of commands that perform a particular action, such
    as building the application or running unit tests. Tasks are coded in regular
    Python and placed in a file called `pavement.py` in the project root.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to create a task that will run our unit tests. The following is how
    we can do that in Paver:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The task above simply runs a command to execute the `unittest` module. We use
    the `@consume_args` decorator, which tells Paver to take all the command line
    parameters and pass it to this task.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run this Paver task, we simply execute the following on the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If we are using nose2, then we can modify the task as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have the task, then we can use it in other tasks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This will run the `test` task every time the `deploy` task is executed. Only
    if the tests pass will the deployment of the code take place.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating with packaging tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Packaging refers to how Python packages are generally distributed to users.
    Unless we are writing proprietary commercial software, we will want to distribute
    the unit tests along with the code and allow the end user to run the tests and
    verify that everything is working.
  prefs: []
  type: TYPE_NORMAL
- en: Packaging tools have been one of the most confusing parts of the Python ecosystem.
    There have been a number of different frameworks that, at different points, have
    been "the right way" to do things. As this book is being written, setuptools is
    the recommended way to package Python modules, so let us take a look at that first.
  prefs: []
  type: TYPE_NORMAL
- en: Setuptools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Setuptools supports a test command for running the test suite. All we need
    to do is to configure it. We do this by specifying the `test_suite` parameter
    in `setup.py` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'When we do this, setuptools will pick up and run all the tests with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The configuration above will only run the `unittest` compatible tests. We can''t
    run any nose2 tests nor can we use nose2 plugins. Fortunately, nose2 also supports
    integration with setuptools. The `nose2.collector.collector` function returns
    a compatible test suite which setuptools can run. The following test suite executes
    all the tests found by nose2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `tests_require` parameter can be set to the packages that are required for
    running tests. We put `nose2` here, so even if the end user doesn't have nose2
    installed, setuptools will install it for us before running the tests. If we use
    any third-party nose2 plugins, we can add those to the list here.
  prefs: []
  type: TYPE_NORMAL
- en: We can't pass any parameters when running tests this way. All configuration
    needs to be done in `nose2.cfg`. If there are some special settings that we would
    like to use only with the `setuptools` test command, we can put those in a special
    `setup.cfg` file. The settings in this file are used only when the nose tests
    are run via setuptools.
  prefs: []
  type: TYPE_NORMAL
- en: To integrate py.test with setuptools, we need to use the `cmdclass` technique
    that we use in the `distutils` integration in the following.
  prefs: []
  type: TYPE_NORMAL
- en: Distutils
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python comes bundled with its own packaging system called **distutils**. Although
    setuptools is the preferred way, we might sometimes want to stick with distutils
    because it is bundled in the standard library.
  prefs: []
  type: TYPE_NORMAL
- en: 'Distutils supports adding custom commands to setup.py. We''re going to use
    that feature to add a command that will run our tests. The following is what it
    looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `cmdclass` option allows us to pass in a dict containing command names mapped
    to a command class. We configure the test command and map it to our `TestCommand`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `TestCommand` class inherits from distutil''s `Command` class. The `Command`
    class is an abstract base class; subclasses will need to create the `user_options`
    list as well as implement three methods: `initialize_options`, `finalize_options`,
    and `run`. We don''t need to do anything in the first two methods, so we keep
    them empty.'
  prefs: []
  type: TYPE_NORMAL
- en: The only method we need for our command is the `run` method. This method is
    called by distutils when the command is to be executed, and our implementation
    simply runs the shell command and returns the appropriate exit value.
  prefs: []
  type: TYPE_NORMAL
- en: The same technique can be used to run the nose2 tests or py.test tests as well.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating with continuous integration tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Continuous integration tools allow us to validate the integrity of our application
    by running the test suite on every commit. We can configure them to raise an alert
    if any of the tests are failing, or even if the test coverage level drops too
    low.
  prefs: []
  type: TYPE_NORMAL
- en: Jenkins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Jenkins is a popular Java-based continuous integration system. Integrating with
    Jenkins requires the nose2 runner because we will need to get output in an XML
    format.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need to do is to configure Jenkins to run the unit tests
    as a part of the build. To do this, we add a shell step to the build and enter
    the command to run the tests. We need to enable the JUnit XML plugin and get coverage
    in XML format, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Jenkins](img/3125_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We then need to tell Jenkins where to find the unit test results. Select the
    **Publish JUnit test result report** checkbox and enter the location of the nose2
    unit test XML file, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Jenkins](img/3125_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Enable the **Publish Cobertura Coverage Report** and select the location of
    the coverage XML output file, as shown in the following screenshot. The plugin
    also allows us to set alert limits for Line coverage. This will fail the build
    if coverage levels drop below the threshold specified here.
  prefs: []
  type: TYPE_NORMAL
- en: '![Jenkins](img/3125_10_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the configuration is done, Jenkins will run tests on every build, and
    give us a nice trend report of the unit tests as well as coverage statistics,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Jenkins](img/3125_10_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can also dig in deeper to see details about specific suites or tests from
    within Jenkins, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Jenkins](img/3125_10_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Travis CI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Travis CI is the hot new kid on the block, becoming very popular in the Python
    community for open source packages, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Travis CI](img/3125_10_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As a hosted service, it doesn''t require any installation. Configuring Travis
    to run our unit tests is a breeze. All we need to do is to add the command to
    run the tests into the `script` section of the `.travis.yml` configuration file
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: That's it. Now Travis will execute the command with every commit and let us
    know if the tests fail for any reason.
  prefs: []
  type: TYPE_NORMAL
- en: Other tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: tox
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: tox is a framework for maintaining a Python package across multiple versions
    of Python. For example, we can easily test that everything is working in Python
    2.6 and Python 3.4\. It works by creating virtual environments for each version
    and then running the unit tests under that environment.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: tox uses the virtualenv tool for creating virtual environments. This tool is
    bundled in the standard library with Python 3.4 and can be installed from PyPi
    for older version of Python. We don't cover this tool in this book, but if you
    aren't using it already, then do take a look at it.
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical `tox` configuration file looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The configuration includes the list of Python versions to test against. Each
    environment can have its own dependencies installed that we require to run the
    tests as well as the command required to run the tests. This command can be the
    vanilla `unittest` command, or a third-party runner such as nose2 or py.test.
  prefs: []
  type: TYPE_NORMAL
- en: When tox is executed, it creates a virtual environment for each of the Python
    versions, installs the required dependencies, and runs our tests in that environment.
    tox can be integrated with continuous integration systems so that compatibility
    is maintained with each commit.
  prefs: []
  type: TYPE_NORMAL
- en: Sphinx
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sphinx is a documentation framework commonly used with Python projects. Sphinx
    supports embedding snippets of code examples within the documentation. Sphinx
    also has `sphinx.ext.doctest` plugin that can extract these code examples as doctests
    and run them to ensure that the documentation doesn't break.
  prefs: []
  type: TYPE_NORMAL
- en: The `sphinx.ext.doctest` plugin supports doctest fixtures for setup and teardown,
    and doctest options. Sphinx with the doctest plugin is a good option when our
    application requires a full-blown documentation system.
  prefs: []
  type: TYPE_NORMAL
- en: IDE integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We haven't talked about IDE integration yet. This is because most of the popular
    Python IDEs have built-in support for running unit tests from within the IDE.
    It is almost a basic feature these days. In addition, there are plugins available
    for popular text editors such as vim, emacs, and Sublime Text 3\. We won't cover
    each and every one of these since they are too numerous. It only takes a quick
    online search to get the configuration or plugins we need to run tests from within
    our favorite IDE or text editor.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you looked at some popular third-party tools to help us improve
    our TDD practice. Some of the tools such as `py.test` and `trial` are test runners
    with some unique features. Others such as `sure` and `pyhamcrest` are libraries
    that help us write cleaner tests. You looked at how we can integrate our unit
    tests into the wider development process: from putting them into the build environment
    and integrating with continuous integration tools, to enabling the `test` command
    when packaging our code. We then took a look at how we can maintain a package
    against multiple versions of Python and integrating tests into Sphinx so that
    our documentation doesn''t break.'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix A. Answers to Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This Appendix contains answers to the exercises presented throughout this book.
    Keep in mind that there is no single correct solution for any of these exercises.
    There are many possible solutions, each with their own advantages and disadvantages.
    Wherever possible, I have mentioned why I took a certain path, so that you can
    see my reasoning and compare the pros and cons with the solution that you have
    come up with.
  prefs: []
  type: TYPE_NORMAL
- en: Red-Green-Refactor – The TDD Cycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This exercise asks us to add support for updates which come out of order, that
    is, a newer update is followed by an older update. We need to use the timestamp
    to determine which update is newer and which is older.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a test case for this requirement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In the test above, we first give the update for February 13, followed by the
    update for February 12\. We then assert that the price attribute returns the latest
    price (for February 13). The test fails of course.
  prefs: []
  type: TYPE_NORMAL
- en: In order to make this test pass, we can't simply add the latest update to the
    end of the `price_history` list. We need to check the timestamp and insert it
    accordingly into the list, keeping it sorted by timestamp.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `bisect` module provided in the Python standard library contains the `insort_left`
    function that inserts into a sorted list. We can use this function as follows
    (remember to import bisect at the top of the file):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to have a sorted list, the `price_history` list needs to keep a list
    of tuples, with the timestamp as the first element. This will keep the list sorted
    by the timestamp. When we make this change, it breaks our other methods that expect
    the list to contain the price alone. We need to modify them as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: With the above changes, all our existing tests as well as the new test start
    passing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the tests passing, we can look at refactoring the code to
    make it easier to read. Since the `price_history` list now contains tuples, we
    have to refer to the price element by tuple index, leading to statements list
    `price_history[-1][1]`, which are not very clear. We can make this clearer by
    using a named tuple that allows us to assign names to the tuple values. Our refactored
    Stock class now looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: After the change, we run the tests to ensure that everything still works.
  prefs: []
  type: TYPE_NORMAL
- en: Code Smells and Refactoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This exercise asks us to refactor the `Stock` class and extract all the moving
    average related calculations into a new class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the code that we start with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, there are a number of calculations relating to identifying the
    moving average window and then calculating the moving average value. These calculations
    really deserve to be in their own class.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start with, we create an empty `MovingAverage` class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to make a design decision on how we want this class to be used.
    Let us decide that the class should take an underlying timeseries and should be
    able to compute the moving average at any point based on that timeseries. With
    this design, the class needs to take the timeseries and the duration of the moving
    average as parameters, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now extract the moving average calculation into this class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the same moving average calculation code from `Stock.get_signal_crossover`.
    The only notable point is that an exception is raised if there is not enough data
    to perform the calculation. Let us define this exception in the `timeseries.py`
    file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now use this method in `Stock.get_signal_crossover` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Run the tests, and all 21 tests should pass.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we extract the calculation to a class, we find that the temporary variables
    that we created during *Replace Calculation with Temporary Variable* section in
    [Chapter 3](ch03.html "Chapter 3. Code Smells and Refactoring"), *Code Smells
    and Refactoring* are not really required. The code is equally self-explanatory
    without them, so we can now get rid of them, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'A final cleanup: now that we have moving average classes, we can replace the
    parameters to the `_is_crossover_below_to_above` method to take the moving average
    class instead of the individual values. The method now becomes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'And we can change the `get_crossover_signal` method to call this with the new
    parameters as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: With this, our Extract Class refactoring is complete.
  prefs: []
  type: TYPE_NORMAL
- en: The `get_crossover_signal` class is now extremely easy to read and understand.
  prefs: []
  type: TYPE_NORMAL
- en: Notice how the design for the `MovingAverage` class builds on top of the `TimeSeries`
    class that we extracted earlier. As we refactor code and extract classes, we often
    find that the many classes get reused in other contexts. This is the advantage
    of having small classes with a single responsibility.
  prefs: []
  type: TYPE_NORMAL
- en: The refactoring into a separate class also allowed us to remove the temporary
    variables that we had created earlier, and made the parameters for the crossover
    condition much simpler. Again, these are side effects of having small classes
    with single responsibilities.
  prefs: []
  type: TYPE_NORMAL
- en: Appendix B. Working with Older Python Versions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This book has been written for Python 3.4\. The version of `unittest` that comes
    with the Python 2.x standard library is an older version that doesn't support
    all the features that we discussed in this book. Additionally, the `mock` library
    was only made a part of the standard library from Python 3.3 onward.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, all the features present in the newer versions of Python have
    been backported under the `unittest2` library. We can install this version from
    PyPi with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Once installed, we have to use the `unittest2` library in all references like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: With these changes, we will be able to use all the features that we have been
    discussing in this book in all versions from Python 2.5 onward.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same goes for the mocking library as well. The `mock` library was only
    added to the standard library with Python 3.3\. The current mock library has been
    backported and is also available from PyPi. We can install it with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'And we import it with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We can then use all the mocking goodness discussed in this book with earlier
    versions of Python as well.
  prefs: []
  type: TYPE_NORMAL
- en: Writing code that is compatible across versions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many Python modules these days are designed to run under multiple Python versions,
    especially supporting Python 2.x as well as Python 3.x versions. We will want
    to run the same tests in both versions, and to do this, we will need to write
    our code in such a way that the tests are compatible with both the versions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python''s import mechanism gives us the flexibility we need to do this. At
    the top of the file, we import `unittest` like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: What this does is to first try and import `unittest2`. If we are running Python
    2.x, then we should have installed this already. If it succeeds, then the module
    is imported and the module reference is renamed to `unittest`.
  prefs: []
  type: TYPE_NORMAL
- en: If we get an `ImportError`, then we are running Python 3.x, in which case we
    can import the `unittest` module bundled in the standard library.
  prefs: []
  type: TYPE_NORMAL
- en: Later in the code, we can just reference the `unittest` module and it will work
    normally.
  prefs: []
  type: TYPE_NORMAL
- en: This mechanism depends on the `unittest2` module being always installed when
    using Python 2.x version. This is easily achieved by putting the `unittest2` module
    as a dependency for only Python 2.x in our pip requirements file.
  prefs: []
  type: TYPE_NORMAL
- en: 'A similar approach works for mocks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Here we first try to import the `mock` library provided as a part of the `unittest`
    standard library module. This is available in Python 3.3 onward. If the import
    succeeds, then the mock library is imported. If it fails, it means that we are
    running an older Python version, so we directly import the `mock` library that
    we installed from PyPi.
  prefs: []
  type: TYPE_NORMAL
- en: Note how we use the line `from unittest import mock` instead of `import unittest.mock`.
    This is so that we end up with the same module reference name in both the cases.
    Once the import is done, we can reference the `mock` module in our code and it
    will work across Python versions.
  prefs: []
  type: TYPE_NORMAL
- en: Running tests from the command line
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Throughout the book, we have used the following syntax to run our tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The ability to directly run a module with the `-m` flag was only introduced
    with Python 2.7\. This syntax will not work if we are using an older version of
    Python. Instead, the `unittest2` module from PyPi contains a `unit2` script that
    mimics this behavior. The command line parameters remain the same, so we get the
    following the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'And the above command now becomes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: If we use a build tool, it becomes fairly simple to check the version of Python
    and execute the appropriate command, thereby allowing the developer to run the
    tests in a uniform way, irrespective of the Python version being used.
  prefs: []
  type: TYPE_NORMAL
- en: With these changes in place, we will be able to use all the features described
    in this book, while being able to support Python 2.x and Python 3.x uniformly.
  prefs: []
  type: TYPE_NORMAL
- en: Running the examples in this book
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code examples in this book have been written for Python 3.4\. They use some
    syntax that is not available in older versions of Python. Therefore, there are
    a few places we will need to change the code if we want to run the examples in,
    say, Python 2.6.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The entire source code with all the changes below is available online at [https://github.com/siddhi/test_driven_python](https://github.com/siddhi/test_driven_python).
    Get this code if you would like to run the example code in this book under Python
    2.6, 2.7, 3.0, 3.1, 3.2, or 3.3
  prefs: []
  type: TYPE_NORMAL
- en: 'The following changes are required:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Enum`: The `Enum` library is not in the standard library with older Python
    versions. It has been backported and can be installed from PyPi. Install the `Enum34`
    library to use this feature.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`set` syntax: Newer versions of Python support the single curly braces shorthand
    syntax to create `set` objects like`{"MSFT"}`. In older versions, we will need
    to explicitly create sets with this equivalent longhand syntax: `set(["MSFT"])`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`print` statement: `print` is defined as a statement in Python 2.x, so we cannot
    call it as a function, neither can we mock it out. We can get around this by adding
    the line `from __future__ import print_function` to the top of all the files that
    use `print`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`builtins`: The `builtins` module is called `__builtin__` in Python 2.x. Therefore,
    we need to use `__builtin__.print` or `__builtin__.open` when we want to mock
    the `print` or `open` functions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`yield from` expression: This expression is not available in older Python versions.
    It has to be replaced with an iteration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mock_open`: This mock helper only mocks the `read` method in the backported
    version. It doesn''t support mocking iteration on the file object. So, we need
    to change the implementation to not use iteration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With these changes, the examples in this book will work on Python 2.6 onward.
  prefs: []
  type: TYPE_NORMAL
