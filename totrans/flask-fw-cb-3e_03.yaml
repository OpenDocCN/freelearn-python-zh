- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data Modeling in Flask
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covers one of the most important aspects of any application, which
    is the interaction with the database systems. In this chapter, you will see how
    Flask can connect to database systems, define models, and query the databases
    for the retrieval and feeding of data. Flask has been designed to be flexible
    enough to support any database. The simplest way would be to use the direct `SQLite3`
    package, which is a *DB-API 2.0* interface and does not give an actual **object-relational
    mapping** (**ORM**). Here, we need to write SQL queries to talk with the database.
    This approach is not recommended for large projects, as it can eventually become
    a nightmare to maintain the application. Also, with this approach, the models
    are virtually non-existent and everything happens in the view functions, and it
    is not a good practice to write database queries in your view functions.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will talk about creating an ORM layer for our Flask applications
    with SQLAlchemy for relational database systems, which is recommended and widely
    used for applications of any size. Also, we will have a glance over how to write
    a Flask app with a NoSQL database system.
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: ORM implies how our application’s data models store and deal with data at a
    conceptual level. A powerful ORM makes the designing and querying of business
    logic easy and streamlined.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating an SQLAlchemy DB instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a basic product model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a relational category model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Migrating databases using Alembic and Flask-Migrate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Indexing model data with Redis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Opting for the NoSQL way with MongoDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an SQLAlchemy DB instance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SQLAlchemy is a Python SQL toolkit and provides ORM, which combines the flexibility
    and power of SQL with the feel of Python’s object-oriented nature. In this recipe,
    we will understand how to create an SQLAlchemy database instance that can be used
    to perform any database operation that shall be covered in future recipes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Flask-SQLAlchemy is the extension that provides the SQLAlchemy interface for
    Flask. This extension can simply be installed by using `pip` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing to keep in mind with Flask-SQLAlchemy is the application configuration
    parameter, which tells SQLAlchemy about the location of the database to be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`SQLALCHEMY_DATABASE_URI` is a combination of the database protocol, any authentication
    needed, and also the name of the database. In the case of SQLite, this would look
    something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In the case of PostgreSQL, it would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This extension then provides a class named `Model`, which helps define models
    for our application. Read more about database URLs at [https://docs.sqlalchemy.org/en/14/core/engines.html#database-urls](https://docs.sqlalchemy.org/en/14/core/engines.html#database-urls).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: The SQLite database URI is OS-specific, meaning the URI would be different for
    Unix/macOS/Linux and Windows. Please refer to the documentation at [https://docs.sqlalchemy.org/en/14/core/engines.html#sqlite](https://docs.sqlalchemy.org/en/14/core/engines.html#sqlite)
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: For all database systems other than SQLite, separate libraries are needed. For
    example, for using PostgreSQL, you need `psycopg2`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s create a small application in this recipe to understand the basic database
    connection with Flask. We will build over this application in the next few recipes.
    Here, we will just see how to create a `db` instance and validate its existence.
    The file’s structure would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we start with `flask_app/run.py`. This is the usual `run` file that
    we have read about previously in this book in multiple recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we configure our application configuration file, `flask_app/my_app/__init__.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, we first configure our application to point `SQLALCHEMY_DATABASE_URI`
    to a specific location. Then, we create an object of `SQLAlchemy` with the name
    `db`. As the name suggests, this is the object that will handle all our ORM-related
    activities. As mentioned earlier, this object has a class named `Model`, which
    provides the base for creating models in Flask. Any class can just subclass or
    inherit the `Model` class to create models, which will act as database tables.
  prefs: []
  type: TYPE_NORMAL
- en: Now, if we open the `http://127.0.0.1:5000` URL in a browser, we will see nothing.
    This is because we have just configured the database connection for this application
    and there is nothing to be seen on the browser. However, you can always head to
    the location specified in `app.config` for the database location to see the newly
    created `test.db` file.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, you may want a single SQLAlchemy `db` instance to be used across
    multiple applications, or to create an application dynamically. In such cases,
    it is not preferable to bind the `db` instance to a single application. Here,
    you will have to work with the application context to achieve the desired outcome.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, register the application with SQLAlchemy differently, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: The preceding approach can be taken up while initializing the app with any Flask
    extension and is very common when dealing with real-life applications.
  prefs: []
  type: TYPE_NORMAL
- en: Now, all the operations that were earlier possible globally with the `db` instance
    will require a Flask application context at all times.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Flask application context is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, you can use context manager, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next couple of recipes will extend the current application to make a complete
    application, which will help us to understand the ORM layer better.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a basic product model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will create an application that will help us to store products
    to be displayed on the catalog section of a website. It should be possible to
    add products to the catalog and then delete them as and when required. As you
    saw in the last chapter, this is possible to do using non-persistent storage as
    well. Here, however, we will store data in a database to have persistent storage.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The new directory layout would appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'First of all, start by modifying the application configuration file, `flask_catalog/my_app/__init__.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The last statement in the file is `db.create_all()`, which tells the application
    to create all the tables in the database specified. So, as soon as the application
    runs, all the tables will be created if they are not already there. Since you
    are not in an application request at this point, create a context manually using
    `with app.app_context():`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now is the time to create models that are placed in `flask_catalog/my_app/catalog/models.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In this file, we have created a model named `Product`, which has three fields,
    namely `id`, `name`, and `price`. `id` is a self-generated field in the database,
    which will store the ID of the record and is the primary key. `name` is a field
    of the `string` type, and `price` is a field of the `float` type.
  prefs: []
  type: TYPE_NORMAL
- en: Now, add a new file for views, which is `lask_catalog/my_app/catalog/views.py`.
    In this file, we have multiple view methods, which control how we deal with the
    product model and the web application in general.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The preceding method handles how the home page or the application landing page
    looks or responds to users. You would most probably want to use a template for
    rendering this in your applications. We will cover this in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The preceding method controls the output to be shown when a user looks for a
    specific product using its ID. We filter for the product using the ID and then
    return its information if a product is found, or else abort with a `404` error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding method returns a list of all products in the database in JSON
    format. If no product is found, it simply returns an empty JSON: `{}`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The preceding method controls the creation of a product in the database. We
    first get the information from the `request` object and then create a `Product`
    instance from this information.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we add this `Product` instance to the database session and finally, use
    `commit` to save the record to the database.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the beginning, the database is empty and has no products. This can be confirmed
    by opening `http://127.0.0.1:5000/products` in a browser. This would result in
    an empty JSON response, or `{}`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, first, we would want to create a product. For this, we need to send a
    `POST` request, which can easily be sent from the Python prompt using the `requests`
    library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'To confirm whether the product is now in the database, we can again open `http://127.0.0.1:5000/products`
    in the browser. This time, it will show a JSON dump of the product details, which
    will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Creating a relational category model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our previous recipe, we created a simple product model, which had a couple
    of fields. In practice, however, applications are much more complex and have various
    relationships between their tables. These relationships can be one-to-one, one-to-many,
    many-to-one, or many-to-many. In this recipe, we will try to understand some of
    these relationships with the help of an example.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s say we want to have product categories where each category can have multiple
    products, but each product should have only one category. Let’s do this by modifying
    some files from the application in the last recipe. We will make modifications
    to both models and views. In models, we will add a `Category` model, and, in views,
    we will add new methods to handle category-related calls and also modify the existing
    methods to accommodate the newly added feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, modify the `models.py` file to add the `Category` model and make some
    modifications to the `Product` model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding `Product` model, check the newly added fields for `category_id`
    and `category`. `category_id` is the foreign key to the `Category` model, and
    `category` represents the relationship table. As evident from the definitions
    themselves, one of them is a relationship, and the other uses this relationship
    to store the foreign key value in the database. This is a simple many-to-one relationship
    from `product` to `category`. Also, notice the `backref` argument in the `category`
    field; this argument allows us to access products from the `Category` model by
    writing something as simple as `category.products` in our views. This acts like
    a one-to-many relationship from the other end.
  prefs: []
  type: TYPE_NORMAL
- en: Important information
  prefs: []
  type: TYPE_NORMAL
- en: Just adding the field to the model would not get reflected in the database right
    away. You might need to drop the whole database and then run the application again
    or run migrations, which shall be covered in the next recipe, *Migrating databases
    using Alembic* *and Flask-Migrate*.
  prefs: []
  type: TYPE_NORMAL
- en: For SQLite, you can simply delete the database file that was created while initializing
    the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `Category` model that has just one field called `name`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, modify `views.py` to accommodate the change in the models. Make the first
    change in the `products()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have just one change where we send the `category` name in the product’s
    JSON data, which is being generated to be returned as a response when a request
    is made to the preceding endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the `create_product()` method to look for the category before creating
    the product:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here, we will first search for an existing category with the category name in
    the request. If an existing category is found, we will use the same in the product
    creation; otherwise, we will create a new category.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new method, `create_category()`, to handle the creation of a category:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is a relatively simple method for creating a category using
    the name provided in the request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new method, `categories()`, to handle the listing of all categories
    and corresponding products:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The preceding method does a bit of tricky stuff. Here, we fetched all the categories
    from the database and then, for each category, we fetched all the products and
    then returned all the data as a JSON dump.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe works very similarly to the preceding recipe, *Creating a basic*
    *product model*.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a product with a category, make a `POST` request to the `/``product-create`
    endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'To view how the data now looks when fetched from the database, open `http://127.0.0.1:5000/categories`
    in your browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer to the *Creating a basic product model* recipe to understand the context
    of this recipe and how this recipe works for a browser, given that its workings
    are very similar to the previous one.
  prefs: []
  type: TYPE_NORMAL
- en: Migrating databases using Alembic and Flask-Migrate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Updating database schema is an important use case for all applications, as it
    involves adding or removing tables and/or columns or changing column types. One
    way is to drop the database and then create a new one using `db.drop_all()` and
    `db.create_all()`. However, this approach cannot be followed for applications
    in production or even in staging. We would like to migrate our database to match
    the newly updated model with all the data intact.
  prefs: []
  type: TYPE_NORMAL
- en: For this, we have **Alembic**, a Python-based tool for managing database migrations,
    which uses SQLAlchemy as the underlying engine. Alembic provides automatic migrations
    to a great extent with some limitations (of course, we cannot expect any tool
    to be seamless). As the icing on the cake, we have a Flask extension called **Flask-Migrate**,
    which eases the process of migrations even more. In this recipe, we will cover
    the basics of database migration techniques using Alembic and Flask-Migrate.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First of all, run the following command to install `Flask-Migrate`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This will also install Alembic, among a number of other dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To enable migrations, we need to modify our app definition a bit. Let’s understand
    how such a config appears if we modify the same for our `catalog` application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following lines of code show how `my_app/__init__.py` appears:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'If we pass `--help` to the `flask` command while running it as a script, the
    terminal will show all the available options, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 3.1 – Database migration\uFEFF option](img/B19111_03_1.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – Database migration option
  prefs: []
  type: TYPE_NORMAL
- en: 'To initialize migrations, run the `init` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Important information
  prefs: []
  type: TYPE_NORMAL
- en: 'For the migration commands to work, the Flask application should be locatable;
    otherwise, you will get the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Error: Could not locate a Flask application. Use the ''flask --app'' option,
    ''FLASK_APP'' environment variable, or a ''wsgi.py'' or ''app.py'' file in the`
    `current directory.`'
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, simply export the Flask application to the environment variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '`export FLASK_APP="my_app.__init__.py"`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Or, simply with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`export FLASK_APP=my_app`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once changes are made to the models, call the `migrate` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'To make the changes reflect on the database, call the `upgrade` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, let’s say we modify the model of our `product` table to add a new field
    called
  prefs: []
  type: TYPE_NORMAL
- en: '`company`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of `migrate` will be something like the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we can see that Alembic compares the new model with the
    database table and detects a newly added column for `company` in the `product`
    table (created by the `Product` model).
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, the output of `upgrade` will be something like the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Here, Alembic performs the upgrade of the database for the migration detected
    earlier. We can see a hex code in the preceding output. This represents the revision
    of the migration performed. This is for internal use by Alembic to track the changes
    to database tables.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer to the *Creating a basic product model* recipe for the context of this
    recipe around the catalog models for `product`.
  prefs: []
  type: TYPE_NORMAL
- en: Indexing model data with Redis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There may be some features we want to implement but do not want to have persistent
    storage for them. In such a use case, it is a good approach to have these stored
    in cache-like storage temporarily – for example, when we want to show a list of
    recently viewed products to visitors on a website. In this recipe, we will understand
    how to use Redis as an effective cache to store non-persistent data that can be
    accessed at a high speed.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will do this with the help of Redis, which can be installed using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Make sure that you run the Redis server for the connection to happen. To install
    and run a Redis server, refer to [http://redis.io/topics/quickstart](http://redis.io/topics/quickstart).
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we need to have the connection open to Redis. This can be done by adding
    the following lines of code to `my_app/__init__.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We can do this in our application file, where we will define the app, or in
    the views file, where we will use it. It is preferred that you do this in the
    application file because then, the connection will be open throughout the application,
    and the `redis` object can be used by just importing it where required.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will maintain a `set` in Redis, which will store the products visited recently.
    This will be populated whenever a product is visited. The entry will expire in
    10 minutes. This change goes in `views.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding method, note the `set()` and `expire()` methods on the `redis`
    object. First, set the product ID using the `product_key` value in the Redis store.
    Then, set the `expire` time of the key to `600` seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: It would be a good practice to fetch the `expire` time – that is, `600` – from
    a configuration value. This can be set on the application object in `my_app/__init__.py`,
    and can then be fetched from there.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will look for the keys that are still alive in the cache and then fetch
    the products corresponding to these keys and return them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An entry is added to the store whenever a user visits a product, and the entry
    is kept there for 600 seconds (10 minutes). Now, this product will be listed in
    the recent products list for the next 10 minutes unless it is visited again, which
    will reset the time to 10 minutes again.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test this, add a few products to your database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Then, visit some products by simply opening the product URLs in the browser
    – for example, `http://127.0.0.1:5000/product/1` and `http://127.0.0.1:5000/product/3`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, open `http://127.0.0.1:5000/recent-products` in the browser to view the
    list of recent products:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Opting for the NoSQL way with MongoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, the data to be used in the application we are building may not be
    structured at all; it may be semi-structured, or there may be some data whose
    schema changes frequently over time. In such cases, we would refrain from using
    an RDBMS, as it adds to the pain and is difficult to scale and maintain. For such
    cases, it would be desirable to use a NoSQL database.
  prefs: []
  type: TYPE_NORMAL
- en: Also, as a result of fast and quick development in the currently prevalent development
    environment, it is not always possible to design the perfect schema the first
    time. NoSQL provides the flexibility to modify the schema without much hassle.
  prefs: []
  type: TYPE_NORMAL
- en: In production environments, the database usually grows to a huge size over a
    period of time. This drastically affects the performance of the overall system.
    Vertical and horizontal scaling techniques are available, but they can be very
    costly at times. In such cases, a NoSQL database can be considered, as it is designed
    from scratch for similar purposes. The ability of NoSQL databases to run on large
    multiple clusters and handle huge volumes of data generated with high velocity
    makes them a good choice when looking to handle scaling issues with traditional
    RDBMSes.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will use MongoDB to learn how to integrate NoSQL with Flask.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are many extensions available for using Flask with MongoDB. We will use
    `Flask-MongoEngine`, as it provides a good level of abstraction, which makes it
    easy to understand. It can be installed using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Remember to run the MongoDB server for the connection to happen. For more details
    on installing and running MongoDB, refer to [http://docs.mongodb.org/manual/installation/](http://docs.mongodb.org/manual/installation/).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, manually create a database in MongoDB using the command line. Let’s
    name this database `my_catalog`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is a rewrite of our catalog application using MongoDB. The first
    change comes to our configuration file, `my_app/__init__.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: Note that instead of the usual SQLAlchemy-centric settings, we now have `MONGODB_SETTINGS`.
    Here, we just specify the name of the database to use, which, in our case, is
    `my_catalog`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will create a `Product` model using MongoDB fields. This happens as
    usual in the models file, `my_app/catalog/models.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Important information
  prefs: []
  type: TYPE_NORMAL
- en: Now would be a good time to look at the MongoDB fields used to create the preceding
    model and their similarity to the SQLAlchemy fields used in the previous recipes.
    Here, instead of an `ID` field, we have a `key`, which stores the unique identifier
    that will be used to uniquely identify a record. Also, note the class that is
    inherited by `Product` while creating the model. In the case of SQLAlchemy, it
    is `db.Model`, and in the case of MongoDB, it is `db.Document`. This is in accordance
    with how these database systems work. SQLAlchemy works with conventional RDBMSes,
    but MongoDB is a NoSQL document database system.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the views file, namely, `my_app/catalog/views.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: You will notice that it is very similar to the views created for the SQLAlchemy-based
    models. There are just a few differences in the methods that are called from the
    MongoEngine extension, and these should be easy to understand.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, add products to the database by using the `/``product-create` endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, validate the product addition by visiting the `http://127.0.0.1:5000/products`
    endpoint in the browser. The following is the resultant JSON value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer to the *Creating a basic product model* recipe to understand how this
    application is structured.
  prefs: []
  type: TYPE_NORMAL
