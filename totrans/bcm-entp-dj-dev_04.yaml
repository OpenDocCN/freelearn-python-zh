- en: '*Chapter 3*: Models, Relations, and Inheritance'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Models** represent tables, also known as objects, within a database. Django
    provides a simple way to map objects to a project''s underlying database(s). We
    will use this mapping system to work with other components of Django in later
    chapters of this book, such as a template, view, or form, to name a few. Anything
    that relies on accessing data from within a database will rely on the models that
    we create. If a project connects to an external database system or the project
    uses an API to interact with data, then there is no need to create any models
    in that situation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Writing model classes to create database tables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using standard field types and third-party field types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring field validators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linking tables through field relationships
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with model meta classes and options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using model methods and method decorators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Practicing extending models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing using the Django shell as a tool to perform queries and add data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a model manager to format and control data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To work with the code in this chapter, the following tools will need to be
    installed on your local machine:'
  prefs: []
  type: TYPE_NORMAL
- en: Python version 3.9 – used as the underlying programming language for the project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Django version 4.0 – used as the backend framework of the project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: pip package manager – used to manage third-party Python/Django packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will continue to work with the solution created in [*Chapter 2*](B17243_02_ePub.xhtml#_idTextAnchor037),
    *Project Configuration*. However, it is not necessary to use the Visual Studio
    IDE. The main project itself can be run using another IDE or independently using
    a terminal or command-line window from within the project root folder. This is
    where the `manage.py` file resides. Whatever editor or IDE you are using, a virtual
    environment will also be needed to work with the Django project. Instructions
    for how to create a project and virtual environment can be found in [*Chapter
    2*](B17243_02_ePub.xhtml#_idTextAnchor037), *Project Configuration*. You will
    need a database to store the data contained in your project. PostgreSQL was chosen
    for the examples in the previous chapter; however, any database type that you
    choose for your project can be used to work with the examples in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'All of the code created in this chapter can be found in the GitHub repository
    for this book: [https://github.com/PacktPublishing/Becoming-an-Enterprise-Django-Developer](https://github.com/PacktPublishing/Becoming-an-Enterprise-Django-Developer).
    The bulk of the code depicted in this chapter can be found in the `/becoming_a_django_entdev/becoming_a_django_entdev/chapter_3/`
    directory.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the *Code in Action*: [https://bit.ly/3zZ68RS](https://bit.ly/3zZ68RS)'
  prefs: []
  type: TYPE_NORMAL
- en: Preparing for this chapter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Start by creating a new app in your project called `chapter_3` by following
    the steps discussed in [*Chapter 2*](B17243_02_ePub.xhtml#_idTextAnchor037), *Project
    Configuration*, under the subsection titled *Creating a Django app*. As discussed
    in that section, don't forget to change the value of the `name =` variable for
    your app class found in the `/becoming_a_django_entdev/becoming_a_django_entdev/chapter_3/apps.py`
    file to now point to the path where you installed your app. Be sure to also include
    this app in your `INSTALLED_APPS` variable found in the `settings.py` file as
    well.
  prefs: []
  type: TYPE_NORMAL
- en: Writing model classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each model in your project represents a table within your database. The fields
    that are created in those models all relate to columns within that table. Django
    provides a technique called `settings.py` file of a project. The ORM technique
    is a process used to convert data between two systems of incompatible data types.
    This means that Django takes the headache out of working directly with **Structured
    Query Language** (**SQL**) to perform queries. The Django ORM irons out odd differences
    between the various database types when interpreting SQL, making it a universal
    tool for working with all data structures. Now, you and your developers can focus
    more on developing and less on the headaches involved. Django does not require
    the use of SQL as a standard writing practice. However, if you want or need to,
    Django does provide a way to use basic SQL when performing query operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, imagine we are building a site that allows a user to view a page providing
    details about a specific car, commonly referred to as a detail page/view. Let''s
    say we are building a basic site just to store and look up details about cars
    that are listed for sale. A user could do this for a number of reasons; perhaps
    they are renting, buying, leasing, or selling a car. In any scenario, we would
    need a table that represents a vehicle object, another table for the model of
    the vehicle (not to be confused with a Django model), and another table for the
    engine type. In a real-world scenario, your project may consist of many other
    tables and the structure of these tables may also differ in many ways. In this
    particular exercise, we won''t create a model for the manufacturer, also known
    as the make of a vehicle. The manufacturer will be created as a set in order to
    demonstrate certain concepts for educational purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `models.py` file of the `chapter_3` directory that was just created,
    write three empty classes, one for each of the tables related to our vehicle exercise,
    following this example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create one class each for `Vehicle`, `VehicleModel`, and `Engine`. We will name
    the class pertaining to a model of a vehicle as `VehicleModel` instead of `Model`
    in order to prevent confusion as we work through each exercise.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the preceding example, three classes were created that do absolutely nothing
    at this time by writing the `pass` statement directly in them. This is a tool
    to add to your toolbox for writing skeleton code and allowing other components
    to continue to function while you write. Python will give you errors if nothing
    is placed in a class and when you are ready to write code for that class, remove
    the `pass` statement and replace it with your actual code.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The names given to model classes can be almost anything you would like, but
    they cannot be any of the reserved Python keywords, such as `True`, `False`, `class`,
    `pass`, and `import`. Name your classes anything that makes sense when you are
    using them elsewhere in your code. You can use uppercase or lowercase letters,
    but when Django creates your tables, the names will always be lowercase. This
    is why it is unacceptable to name two different classes the same name with different
    letter casings. For example, if we named two classes `class Vehicle` and `class
    vehicle`, Django would then tell us we have the following `RuntimeError` when
    attempting to make migrations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This is why it is better to adopt a writing style that uses one or the other
    letter casing and stick with that pattern throughout your project.
  prefs: []
  type: TYPE_NORMAL
- en: Let's discuss the various field types that exist and see which ones we can use
    for our vehicle exercises.
  prefs: []
  type: TYPE_NORMAL
- en: Standard field types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Right out of the box, Django offers numerous **Standard Field Types** to choose
    from. The following tables can be used as cheat sheets when writing your models:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17243_03_Table1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/B17243_03_Table2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For a complete breakdown of all of the field types to choose from, you can
    visit the official Django documentation on field types here: [https://docs.djangoproject.com/en/4.0/ref/models/fields/](https://docs.djangoproject.com/en/4.0/ref/models/fields/).'
  prefs: []
  type: TYPE_NORMAL
- en: Field arguments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Every field class will accept `verbose_name`, `blank`, and `null` arguments
    on our fields quite often. `verbose_name` will specify the human-readable name
    for a field. We should specify a `max_length` argument for any `CharField` instances
    that we use, to limit the character length of that field. Without setting a `max_length`
    argument, the character length limit is theoretically unlimited. However, you
    are limited by the physical restrictions of the database that you are using; the
    limit would then be several thousand or hundreds of thousands of characters instead
    of the literal infinite limit. The `null` and `blank` arguments are almost considered
    the same thing, except that the `null` argument says that the database can store
    a null value for any empty records. The `blank` argument is related to validation
    performed on that field, at the database level, to check whether a user attempted
    to enter a null value when saving or creating that record in the database.
  prefs: []
  type: TYPE_NORMAL
- en: A `default` argument will be used to assign a value to a field by default, should
    a value not be provided at the time an object is created or updated. Default values
    are used in circumstances where, say, data is being migrated into your database
    from an outside source, with data that isn't in synchronization with the constraints
    set on your tables. For example, if you had a field argument set to `null=False`
    and you imported data that contained a null value, errors would likely result.
    Say you had a `BooleanField` with the `default=True`/`False` argument, and then
    performed the same data import; then, all those null values would be converted
    to `True`/`False` automatically during your import. A `default` argument can be
    applied to virtually every field type.
  prefs: []
  type: TYPE_NORMAL
- en: The `choices` argument allows us to pass in a predefined set of choices that
    contain a value and a human-readable interpretation of that value. Choices can
    be used on `CharField` and `BooleanField` instances, as well as a handful of other
    field types. They can be made into a drop-down select box or be used in a collection
    of checkboxes or radio buttons. The `choices` argument accepts a list of tuples,
    where each tuple consists of the first element being the value of the field and
    the second element being the human-readable string representation of that value.
    For this exercise, we will be converting the human-interpreted *yes/no* choices
    into a computer-interpreted *true/false* value on a `BooleanField`. We will also
    apply this technique to the manufacturer/make field later in this chapter, in
    order to store an integer value.
  prefs: []
  type: TYPE_NORMAL
- en: Another argument that can be useful is the `editable=False` attribute. This
    attribute would render a field hidden in any form object within a template. This
    field would not be visible or editable by the user in any way. The `unique=True`
    argument can also be useful. This argument states that two rows/records in your
    table cannot have the same value for that particular field. This would be useful
    if, say, an email field is used as a unique identifier for a model, preventing
    duplicates from existing. We would get conflicting results with errors telling
    us that the email address already exists when saving or creating a new record.
  prefs: []
  type: TYPE_NORMAL
- en: Model field arguments differ from form field arguments in that the model arguments
    will apply rules to your columns on the database level. Your form field arguments,
    which we will cover in [*Chapter 5*](B17243_05_ePub.xhtml#_idTextAnchor152), *Django
    Forms*, are rules that only apply to a field as it is used within a particular
    form. This means you can set `blank=True` on a model field, making it not required
    on the database level but in a `required=True` form field set, making it required
    for that particular form. Alternatively, we could make that field required in
    all forms by setting the constraint at the database level using `blank=False`.
    Keep that in mind when writing your model classes.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's begin writing the different fields that are needed for our vehicle
    scenario.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a standard field type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: From the Django fields list provided earlier, we will use `CharField` for each
    of the models. `CharField` will be used to provide a name for each item as we
    add them to the database, except for the `Vehicle` model class. For the `Vehicle`
    model, we will use `CharField` as the `BooleanField` on the `Vehicle` model, to
    store a value indicating whether or not this vehicle has been sold. This is the
    field where we will create a list of *yes/no* choices to use instead of the *true/false*
    values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to create the fields for each of your model classes. Remember
    to remove the `pass` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In your `/chapter_3/models.py` file, create the set of *yes/no* choices above
    your model classes and below your `import` statements, as depicted:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following field to your `VehicleModel` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following field to your `Engine` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following fields to your `Vehicle` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `name` field on the `VehicleModel` class shown previously will use the `unique`
    argument, allowing only names that do not already exist in that table. The `name`
    field on the `Engine` class will not use the `unique` argument, so we can allow
    engines of the same name but assign them to different vehicle models. The `YESNO_CHOICES`
    variable is used as a global variable placed outside of any model class so that
    it can be used in many fields if needed. If a variable or set of choices is extremely
    unique, then it is best practice to place it above your field declarations, within
    the model class that is it being used in. You could also store these variables
    in an entirely separate file as well, as long as the code remains clean and simple.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The preceding code is a relaxed style of the PEP-8 style guide where we are
    placing each argument on its own line, separated by a comma while also following
    basic Python indentation rules. Most of the code throughout this book will be
    written in this way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the Django `makemigration` and `migrate` commands, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Every time a model is changed, created, or deleted, these Django migration commands
    will need to be executed in order to prevent runtime errors. They can be executed
    from either your IDE or within a command line or terminal window, executed from
    within your project's root directory, where your `manage.py` file lives. Refer
    to [*Chapter 2*](B17243_02_ePub.xhtml#_idTextAnchor037), *Project Configuration*,
    in the subsection titled *Building initial table structures* to learn more about
    the different ways to execute these commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'If those two Django migration commands were successful, three more tables will
    have been created in your database. When viewed from within your PgAdmin tool
    or any other database management tool that you decided to use, those tables will
    look similar to as in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – PgAdmin – created vehicle, model, and engine tables'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.1_B17243.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.1 – PgAdmin – created vehicle, model, and engine tables
  prefs: []
  type: TYPE_NORMAL
- en: If we needed to use fields that don't come standard in Django, such as `AddressField`,
    `MoneyField`, or `PhoneField`, we would have to install packages and also configure
    settings before we can use them. Let's prepare our project next to let us do just
    that, by integrating `MoneyField` into these examples.
  prefs: []
  type: TYPE_NORMAL
- en: Third-party field types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A `django-address` package uses the Google Maps API to suggest addresses related
    to what the user has typed as the user is typing into a single text field. This
    means that the package provides the model class as well as the form field class
    it creates and any other related tools. Related tools such as, all of the JavaScript
    and CSS libraries that help a form work. The `django-image-cropping` tool is also
    very powerful: it allows a user to upload an image and let the user crop the image
    however they desire.'
  prefs: []
  type: TYPE_NORMAL
- en: There is a package specifically made to handle currency called `django-money`.
    This package takes `DecimalField` from the list of standard field types and provides
    many different actions that involve working with money in a financial industry-accepted
    way. The `django-money` package provides definitions for all currencies that exist
    today and includes their corresponding currency sign. In addition to performing
    arithmetic operations, such as addition and subtraction, currencies can also be
    converted from one sign to another using current exchange rates. This means that
    this package will communicate with an API to retrieve that information.
  prefs: []
  type: TYPE_NORMAL
- en: The `django-phone-field` package will accept a phone number that is rather versatile.
    The phone field allows for country codes and accepts special characters so that
    it can be masked to any format you need. The `django-ckeditor` package is a tool
    used for adding rich text editors to your pages, allowing users to enter HTML
    into one of your form fields. If you're using django CMS, they also make a version
    of the django-ckeditor package specifically for use with the django CMS package.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a short list of third-party field types to add to your field type cheat
    sheet from before:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AddressField` – [https://pypi.org/project/django-address/](https://pypi.org/project/django-address/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ImageCropField` – [https://pypi.org/project/django-image-cropping/](https://pypi.org/project/django-image-cropping/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MoneyField` – [https://pypi.org/project/django-money/](https://pypi.org/project/django-money/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PhoneField` – [https://pypi.org/project/django-phone-field/](https://pypi.org/project/django-phone-field/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RichTextField` – [https://pypi.org/project/django-ckeditor/](https://pypi.org/project/django-ckeditor/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (*django CMS*) `RichTextField` – [https://pypi.org/project/djangocms-text-ckeditor/](https://pypi.org/project/djangocms-text-ckeditor/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we will add `MoneyField` to our `Vehicle` model class.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a third-party field type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since some of the fields, such as `AddressField`, require obtaining a personal
    Google API key directly from Google, we will not be using that field type. We
    will only demonstrate using one of these third-party field types and then move
    on to the next topic.
  prefs: []
  type: TYPE_NORMAL
- en: 'To include `MoneyField` in a project, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add `django-money` to your `requirements.txt` file and install it in your virtual
    environment or run the following command to manually install this package. Make
    sure your virtual environment is already activated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In your `settings.py` file, add the following app to your `INSTALLED_APPS`
    list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Make sure it is located above your local apps and below all of your `django.contrib`
    apps, as shown previously, where it is placed before the `chapter_3` app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `MoneyField`, you can specify the different currencies available in your
    project within the `settings.py` file. In the following example, we specify the
    US dollar and European euro as the two currencies available in this project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following highlighted `import` statement to the top of your `/chapter_3/models.py`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In your `Vehicle` class, add the price field shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You will also need to use the field arguments depicted in the preceding example
    (adjust the values as needed).
  prefs: []
  type: TYPE_NORMAL
- en: Let's explore what validation we can apply to the field types that we are using.
  prefs: []
  type: TYPE_NORMAL
- en: Model field validators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Field validators are database-level rules that can be set on model fields.
    They are useful in situations where instead of `DecimalField`, using a `max_length`
    argument to control the character length, we are defining a minimum or maximum
    numeric value. A Django `ValidationError` if that criterion is not met. Since
    this is a callable, you can write your own function to suit your needs or use
    one of the many different callable functions that come included with Django. For
    instance, we could use the `MinValueValidator` and `MaxValueValidator` functions
    when specifying a constraint for a minimum or maximum numeric value. You can view
    a complete list of validator functions provided by Django here: [https://docs.djangoproject.com/en/4.0/ref/validators/](https://docs.djangoproject.com/en/4.0/ref/validators/).'
  prefs: []
  type: TYPE_NORMAL
- en: Setting a field validator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`MoneyField` offers a few of its own field validators that add constraints
    on currency values of whatever type is defined in your project. The money validators
    take the leg work out of using a Django `DecimalValidator` or writing your own
    callable method.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to set your validator on the existing `Vehicle` model:'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of your `/chapter_3/models.py` file, and just below your existing
    `import` statements, add the following `import` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Whether it is a standard Django field validator or another one provided by
    a third-party package, it will go in the validator argument of a field, as shown
    on the `price` field of the `Vehicle` model here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These functions usually take in one or more arguments themselves. In this example,
    we are specifying the parameters for the minimum and maximum currency values.
    The preceding example states that all Euro (`EUR`) values should be between 500
    and 500,000 Euros and the American dollar values (`USD)` should be between 400
    and 400,000 dollars. These are rough estimates used for demonstration only and
    are not exact conversion rates.
  prefs: []
  type: TYPE_NORMAL
- en: Currently, our three model classes exist independently from one another. This
    means they are not linked to each other in any way just yet. We will need them
    to be related to one another before we are done. Next, we will be linking those
    tables by working with model field relationships.
  prefs: []
  type: TYPE_NORMAL
- en: Working with model field relationships
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Django provides three relationship types for linking tables:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Many****–****to****–****one**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Many****–****to****–****many**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**One****–****to****–****one**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A *many-to-one* relationship is defined by using a `ForeignKey` field, and the
    other two relationship types are defined using the self-explanatory `ManyToManyField`
    and `OneToOneField`. These fields are named appropriately after the relationship
    type that they represent.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will discuss the key components of working with model field relationships.
  prefs: []
  type: TYPE_NORMAL
- en: Field arguments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The three field types, `ForeignKey`, `ManyToManyField`, and `OneToOneField`,
    all accept the standard `default`, `blank`, and `verbose_name` field arguments
    that other field types accept. The `null` argument will have no effect on a `ManyToManyField`
    and will only apply to the `ForeignKey` and `OneToOneField` types. Two of these
    field types—`ForeignKey` and `OneToOneField`—require at least two positional arguments,
    the first being the model class that the field relates to and the second being
    the `on_delete` argument. Positional means they need to be in that order and required
    means they must be specified. The `on_delete` argument specifies what the database
    will do with records from related tables if a parent or child object is deleted.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `on_delete` choices include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`models.CASCADE` – used to automatically delete any related objects when an
    object is deleted from that table.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`models.PROTECT` – used to prevent deletion of any of the objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`models.RESTRICT` – used to prevent deletion in certain scenarios.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`models.SET_DEFAULT` – used to set the field of related objects to a default
    value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`models.SET_NULL` – used to set the field of related objects to a null value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`models.SET()` – accepts a callable to write your own function for setting
    a value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`models.DO_NOTHING` – will take no action; using this option could cause **IntegrityError**
    and should be used with caution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will set the value for the `on_delete` argument to `models.CASCADE`, ensuring
    that if a `Vehicle` is deleted from the database, nothing will happen to the related
    `VehicleModel` and `Engine` objects. But if we deleted a `VehicleModel` or `Engine`
    object from the database, the related `Vehicle` that depends on that soon-to-be-deleted
    object will also be deleted. If we want to preserve `Vehicle` in the scenario
    of when either of those two is deleted, we should use the `models.SET_DEFAULT`
    value instead.
  prefs: []
  type: TYPE_NORMAL
- en: The three field types—`ForeignKey`, `ManyToManyField`, and `OneToOneField`—all
    allow for us to follow relationships forward and backward when performing queries,
    which means if you query a parent object, you can follow that lookup forward to
    get all of its child objects. A reverse lookup would mean you query a child object
    and follow its lookup backward to get its parent object. These forward and reverse
    relationships are defined on fields by using the `related_name` and `related_query_name`
    arguments, which will soon be demonstrated.
  prefs: []
  type: TYPE_NORMAL
- en: A `ForeignKey` field and `ManyToManyField` can accept a `limit_choices_to` argument,
    which applies a filter to the related queries. The `limit_choices_to` argument
    will accept a dictionary or Q object. It will also accept a callable function
    that returns either a dictionary or Q object.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'A `filter()`, `all()`, or `order_by()` statement cannot provide. To learn more
    about complex lookups with Q objects, visit the official Django documentation
    here: [https://docs.djangoproject.com/en/4.0/topics/db/queries/#complex-lookups-with-q-objects](https://docs.djangoproject.com/en/4.0/topics/db/queries/#complex-lookups-with-q-objects).
    To learn more about performing queries in general, jump ahead to the section titled
    *Performing queries* later in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Continuing on with our vehicle classes, we can apply some of these model relations
    and arguments to the classes we already wrote. They will help us link a hypothetical
    `Seller` to a `Vehicle`, a `Vehicle` to a `VehicleModel`, and that `VehicleModel`
    to an `Engine`.
  prefs: []
  type: TYPE_NORMAL
- en: Field type – ForeignKey
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will be using a `ForeignKey` field to represent a *many-to-one* relationship
    between the `Vehicle` class and the `VehicleModel` and `Engine` classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to create your `ForeignKey` field:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In your `/chapter_3/models.py` file, add the following two fields to your existing
    `Vehicle` model class, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In your `/chapter_3/models.py` file, add the following field to your existing
    `Engine` model class, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, run your Django migration commands one more time, as discussed in the
    subsection titled *Building initial table structures* in [*Chapter 2*](B17243_02_ePub.xhtml#_idTextAnchor037),
    *Project Configuration*. You can see the two fields that we created, `vehicle_model`
    and `engine`, are now in the list of columns shown in our database management
    tool:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.2 – PgAdmin – ForeignKey field'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.2_B17243.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.2 – PgAdmin – ForeignKey field
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, these fields are shown as `vehicle_model_id` and
    `engine_id`. The `_id` suffix automatically gets added to the column name in your
    database.
  prefs: []
  type: TYPE_NORMAL
- en: Field type – ManyToManyField
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here, we will represent a *many-to-many* field relationship between a seller
    and the vehicles they are selling with a `ManyToManyField` type. `ManyToManyField`
    will not accept the `on_delete` argument. Instead, when a child or parent is deleted,
    the other will always remain in your database since many other objects could relate
    to it as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to create `ManyToManyField`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In your `/chapter_3/models.py` file, create a new `Seller` model class with
    a `name` field and a `vehicle` field to use as your *many-to-many* relationship.
    Your code should now resemble the following example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will link `ManyToManyField` to the `Vehicle` model class in the first positional
    argument. It's given a `related_name` argument with a value of `vehicle_sellers`
    and a `related_query_name` argument with a value of `vehicle_seller`. These two
    arguments are used for linking and mapping to this field later on in [*Chapter
    10*](B17243_10_ePub.xhtml#_idTextAnchor293), *Database Management*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go ahead and run your Django migration commands one more time. You should see
    the columns that were created for this table in your database management tool,
    similar to the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.3 – pgAdmin – ManyToManyField'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.3_B17243.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.3 – pgAdmin – ManyToManyField
  prefs: []
  type: TYPE_NORMAL
- en: We should also see any additional tables that automatically get created, which
    are used to manage the relationships between `Seller` and `Vehicle`. That table
    is shown in the preceding screenshot as **chapter_3_seller_vehicle**.
  prefs: []
  type: TYPE_NORMAL
- en: Mutable versus immutable objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Mutability** is a fundamental concept of the Python language and is broken
    down into mutable and immutable objects. An object is said to be **mutable** if
    its values can change over time. If an object''s value will not change, then that
    object is said to be **immutable**. In Python, an object''s mutability is also
    defined by the data type that it is. For example, mutable objects are represented
    using a *list*, *dictionary*, *set*, or *QuerySet*. Immutable objects are defined
    by using the *bool*, *decimal*, *float*, *int*, *range*, *string*, and *tuple*
    data types. Queries will perform better if the object being searched is immutable
    rather than mutable. Most of the time, the difference is miniscule, literally
    in nano-or milliseconds. When your project goes live and your database starts
    to collect thousands, if not millions, of records, the time it takes to query
    something will then be noticed when it takes seconds, if not minutes or tens of
    minutes, to complete a single query.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, we could represent a set of choices as a `PositiveIntegerField`
    using a tuple object to associate a human-readable string representation to a
    numeric integer value. Take the make/manufacturer of a vehicle that was mentioned
    earlier in this chapter. We don't really need a table to store this information
    unless we have other related information that needs to be stored or have a project
    requirement stating that the user should have the ability to add/edit these choices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hardcoding these values as an immutable data type can be done by following
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `/chapter_3/models.py` file, add the following set above your model
    classes and below your `import` statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use that set as the value of the `choices` argument of your `make` field within
    your `Vehicle` class, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, let's discuss what the `Meta` subclass is and how it is used to control
    the behavior of models even more than what we have already done.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Meta subclass
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Meta`. It is not required and completely optional but it does make using Django
    much more useful when it is included in your models. Metadata provides all of
    the "other" information that is not defined in model field arguments. The settings
    that are defined inside this class are called **meta options,** and there are
    quite a lot to choose from. We will go over only some of the most commonly used
    options in the following sections and how they can be helpful. A complete breakdown
    of all of the options is available here: [https://docs.djangoproject.com/en/4.0/ref/models/options/](https://docs.djangoproject.com/en/4.0/ref/models/options/).'
  prefs: []
  type: TYPE_NORMAL
- en: Meta options – verbose_name and verbose_name_plural
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can use the `verbose_name` and `verbose_name_plural` options to specify what
    human-readable text is used in areas of the Django admin site or if we look it
    up later in the code that we write. We will introduce the Django admin site in
    [*Chapter 6*](B17243_06_ePub.xhtml#_idTextAnchor190), *Exploring the Django Admin
    Site*.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add these options to your model classes, using the class named `VehicleModel`,
    set these two verbose options to read as `Vehicle Model` and `Vehicle Models`,
    as depicted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Now, throughout your code and the Django admin site, these values will be used
    as the singular and plural representations of your object(s).
  prefs: []
  type: TYPE_NORMAL
- en: Meta option – ordering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `ordering` option is used when obtaining a list of objects. This setting
    will accept one or many fields as a parameter to order by default if no other
    ordering rules have been specified when the query is performed. It will order
    in ascending order unless a dash (`–`) character has been placed before the value;
    if a dash is used, then the results will appear in descending order instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add this option to your model classes, we can order the `VehicleModel` class
    by `name` in ascending order, and then again in descending order, as shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The first example, commented out in the previous code block, shows us that we
    can order by additional fields, separated by a comma as well as in ascending order.
    The last example in the preceding code block depicts ordering the results in descending
    order alphabetically, from Z to A.
  prefs: []
  type: TYPE_NORMAL
- en: Meta option – indexes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `indexes` option relates to a standard data architecture concept called
    `indexes` meta option.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to add this option to your model classes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To index the name field on the `VehicleModel` class, it would be written as
    shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding example creates three separate indexes, one for the name in ascending
    order, one in descending order, and another for lowercase-only names in ascending
    order.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, run your Django migration commands one more time. In your command-line
    or terminal window, the following messages should appear:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If we don''t specify a `name=` attribute, as was not done in the first index
    of the preceding example, Django will name it using its default naming convention
    instead. This is what resulted in the name `chapter_3_v_name_055414_idx` for the
    first index message in the preceding example. The preceding example imports a
    class from the `django.db.models.functions` library, called `Lower`. The `Lower`
    class allows us to create an index on all of the lowercase character representations
    for the `name` field in the last index in the previous code block. There are numerous
    database functions that Django provides, and a complete breakdown of these functions
    can be found in the official Django documentation here: [https://docs.djangoproject.com/en/4.0/ref/models/database-functions/](https://docs.djangoproject.com/en/4.0/ref/models/database-functions/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The indexes for each table are usually shown within a database management tool.
    For example, in PgAdmin, navigate the data tree from within the **Browser** tab
    to find the **chapter_3_vehiclemodel** indexes. It is a very deep navigation:
    go to **PostgreSQL 13** | **Databases** | **local_postgresql** | **Schemas** |
    **public** | **Tables** | **chapter_3_vehiclemodel** | **Indexes** and you should
    see your indexes, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – PgAdmin – model indexes'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.4_B17243.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.4 – PgAdmin – model indexes
  prefs: []
  type: TYPE_NORMAL
- en: Meta option – db_table
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, a project might have so many models that they start to conflict with
    each other or it just becomes too confusing to manage. The `db_table` option is
    used to specify the name of the table in a database. If this option is not set,
    by default Django will name your tables using the `{{ app_name }}_{{ model_name
    }}` naming convention. We can use this option to specify a unique table name on
    a case-by-case basis that differs from the default naming convention.
  prefs: []
  type: TYPE_NORMAL
- en: For example, let's create a new class named `engine2`, in lowercase this time.
    This way, we know that the lowercase classes are meant for side practice, separate
    from the main classes, which will be named with the first letter capitalized.
    Here, we will add the number `RuntimeError`, which was mentioned earlier in this
    chapter, in the *Writing model classes* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to add this option to your model classes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `/chapter_3/models.py` file, create the `engine2` class and copy the
    name field from the `Engine` class into it, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `Meta` subclass and set the `db_table` option as depicted here.
    Do not use this option on the `Engine` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Set the value of `db_table` to `'chapter_3_practice_engine'`, as shown.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, run your Django migration commands one more time. In your database management
    tool, such as PgAdmin, the `chapter_3` tables should look similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.5 – PgAdmin – db_table option'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.5_B17243.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.5 – PgAdmin – db_table option
  prefs: []
  type: TYPE_NORMAL
- en: We can see the `engine2` model class. Another valuable meta option that you
    may find yourself using a lot is the abstract option. This is primarily used for
    extending model classes and is best explained later in the section titled *Extending
    models* of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Before we extend model classes, let's explore using model methods and method
    decorators.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Model methods are custom functions written within a model class that provide
    added functionality related to a single record within a table. They let us create
    our own business logic and format field data as we need to. Django provides us
    with several default methods and we can also write our own custom methods. Custom
    methods can combine fields and return data derived from those two or more fields.
    Decorators are sometimes used in combination with model methods to provide even
    more functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some methods can let us perform special operations when an object is saved
    and/or deleted at the database level. Other methods are used when queries are
    performed or when rendering an object within a template. We will discuss some
    of the methods that Django provides and then demonstrate their uses. For a complete
    breakdown of the full capabilities of using Django''s model methods, visit their
    documentation, found here: [https://docs.djangoproject.com/en/4.0/topics/db/models/#model-methods](https://docs.djangoproject.com/en/4.0/topics/db/models/#model-methods).'
  prefs: []
  type: TYPE_NORMAL
- en: Writing methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Writing a model method is similar to writing a `Meta` subclass, except instead
    of writing a class, we are now writing a function inside that class using the
    `def` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'The four most helpful and most used methods are defined here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`def save(self, *args, **kwargs)` – used to override the save action of this
    model at the database level. You can inject your own logic either before or after
    the save has occurred by tapping into this method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`def delete(self, *args, **kwargs)` – this is similar to the `save` method,
    except that you can add your own logic before or after an object has been deleted
    at the database level.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`def get_absolute_url(self)` – used by Django to formulate a canonical URL
    for that object. This is used to redefine the default behavior of how Django creates
    a URL structure for these objects. This is also the URL used within the Django
    admin site to access this object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`def __str__(self)` – used to redefine the default manner that Django will
    use to create a string representation of a single record within that table.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will use the `__str__()` method to demonstrate how to override a Django-provided
    method and access methods throughout the code of your project.
  prefs: []
  type: TYPE_NORMAL
- en: Model method – __str__
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using the same `MAKE_CHOICES` tuple that was created earlier, we will override
    the `__str__()` method to formulate a custom name for all `Vehicle` objects. The
    default string representation of a `Vehicle` object that we will define will use
    the following naming convention, `{{ vehicle make }} {{ vehicle model }}`, with
    a space in between.
  prefs: []
  type: TYPE_NORMAL
- en: 'To configure this method in your `Vehicle` class, in your `/chapter_3/models.py`
    file, write the `__str__()` method, as depicted in the following code block, in
    your existing `Vehicle` model class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: It's easy to see that model methods are just functions that take in an instance
    of itself, perform an operation of some kind on itself, and then return the transformed
    value. The value in the preceding example is a string, and for the `__str__()`
    method, it should always return a string, whereas other methods, including custom
    methods that you create, can return any other data type, such as an *integer*,
    *dictionary*, *QuerySet*, or *date/time* object, to name a few.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's discuss writing our own custom model methods, one that Django does
    not provide for us.
  prefs: []
  type: TYPE_NORMAL
- en: Custom model method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A custom method would come in handy if say we want to display a more in-depth
    name than what the `__str__()` method already does for a model class. For example,
    let's include the engine type in addition to the information returned from the
    `__str__()` method. The naming convention will be `{{ vehicle make }} {{ vehicle
    model }} – {{ vehicle engine }}`, with the space and dash in between.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create your own model method on the `Vehicle` class, in your `/chapter_3/models.py`
    file, create a new method within your `Vehicle` model and call it `full_vehicle_name()`,
    as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example uses the same logic found in the `__str__()` method. We
    are just calling that method from within the custom method using the `self.__str__()`
    expression, instead of writing the same code in two different places.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will apply a decorator around the newly created custom method, changing
    how we interact with this data.
  prefs: []
  type: TYPE_NORMAL
- en: Decorators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A decorator is a standard Python design pattern that allows developers to extend
    the functionality of an object without permanently changing the behavior of that
    object. The concept of decorators can be applied to virtually any class or method
    that exists in a project. We will be applying this concept to the `full_vehicle_name()`
    method that we just created, to change it from a callable to now a meta property
    of that model.
  prefs: []
  type: TYPE_NORMAL
- en: Decorator – @property
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A `@property` decorator allows us to write a method to act as a regular property
    of a model instance, rather than act as a function. Using this decorator, we can
    access `full_vehicle_name` just like we would any other field found in that table.
    The only thing we cannot do is save data as we would for any other field, because
    that property is not technically its own column in that table to store data in.
  prefs: []
  type: TYPE_NORMAL
- en: 'With no `@property` decorator present, data would be accessed similar to the
    following demonstration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'With the `@property` decorator present, the `print` statement would be written
    similar to the following demonstration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'To wrap your method in a `@property` decorator, in your `/chapter_3/models.py`
    file, within the `Vehicle` model class, create a new method called `fullname()`,
    as depicted here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example will perform the same task as the `full_vehicle_name()`
    method except with the `@property` decorator applied. When we perform query operations
    later, in the section titled *Performing queries*, we will compare the difference
    between the two methods to see how that data is returned and used.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have discussed most of the core concepts of what makes up a Django
    model, let's practice extending these models in an effort to keep to a **Don't
    Repeat Yourself** (**DRY**) style of writing.
  prefs: []
  type: TYPE_NORMAL
- en: Extending models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`User` model, which is a very common model to extend.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will practice extending our practice model called `engine2` and then
    extend the Django `User` model, turning it into the `Seller` model. This would
    make the `Seller` object related to a `Vehicle` and also act as a `User`, provided
    with permission-based roles and permission group capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Extending basic model classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Extending regular model classes is pretty easy to do. Follow these steps to
    extend the `engine2` practice class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In your `/chapter_3/models.py` file, in the class named `engine2`, keep the
    name field as is and then add a new field called `vehicle_model`, with the `related_name`
    attribute value that is depicted in the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make sure your `engine2` class has the following `Meta` class options:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We basically want `engine2` to resemble the `Engine` class exactly, except that
    we want to keep the original class untouched and write a new class called `engine3`
    constructed from `engine2`. We also have to give the `vehicle_model` field in
    the `engine2` class a new and unique value for the `related_name` argument. Otherwise,
    when we run the Django migration commands, we will experience conflicting errors
    with the `Engine` class. In the `engine2` class, specify the `abstract = True`
    option as we did in the preceding example. That option allows us to use that class
    as a parent class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, create a new class called `engine3` below your `engine2` class, as depicted
    in the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `engine3` class shown here, we are not creating a `Meta` subclass and
    we will only give it one field. We also replaced `models.Model` with `engine2`.
    That is where we pass in the name of the class that we want to construct the new
    class from, otherwise known as extending or inheriting from that parent class.
  prefs: []
  type: TYPE_NORMAL
- en: Running your Django migration commands now will result in an error, telling
    us that the `chapter_3_practice_engine` table already exists. To prevent this,
    we can do one of two things. We could rename the `Meta` class option `db_table`
    of the `engine2` class or we can drop all of the tables in the database and start
    fresh.
  prefs: []
  type: TYPE_NORMAL
- en: Dropping database tables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since, currently, we do not have any real data to worry about and because we
    are so early in the development life cycle, it's okay to drop our tables. It is
    acceptable because we are still getting started with building the skeleton code
    of our project. We are also working with a local database, meaning we won't disrupt
    other developers' workflows by performing this task. Dropping your tables can
    be done using any database management tool.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to drop your tables using PgAdmin:'
  prefs: []
  type: TYPE_NORMAL
- en: In PgAdmin, navigate to **Tools** | **Query Tool**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the tab that opens, enter the following two commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Execute these commands by hitting the **Execute/Refresh** button or pressing
    *F5* on your keyboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will also need to delete all migration files found in any migrations folder,
    such as the `/chapter_3/migrations/` and `/chapter_3/migrations/__pycache__/`
    folders.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Every time tables are dropped, data is lost. The next time the Django migration
    commands are executed, the `createsuperuser` command should be executed and/or
    data fixtures loaded.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Execute your Django migration commands one more time. The following screenshot
    shows that all of the fields and `Meta` class options that existed before in the
    `engine2` class now exist in the `engine3` class even though we did not write
    them for the `engine3` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.6 – PgAdmin – extended engine'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.6_B17243.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.6 – PgAdmin – extended engine
  prefs: []
  type: TYPE_NORMAL
- en: We can see this because the `Meta` class `db_table = 'chapter_3_practice_engine'`
    option is placed in the `engine2` class and is what the `engine3` table is named.
    No table was created for the `engine2` class because it is configured as an abstract
    class. We also see that the two fields, `name` and `vehicle_model`, from the `engine2`
    class also get applied to the `engine3` class.
  prefs: []
  type: TYPE_NORMAL
- en: Let's extend the built-in Django `User` class next.
  prefs: []
  type: TYPE_NORMAL
- en: Extending the Django User model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Extending the Django `User` model will transform the `Seller` model, making
    it act as a `User` in the system. This means you can create a user profile that
    will have fields that do not come standard with Django; it will have fields that
    we create. This is done by constructing the `Seller` class using the `AbstractUser`
    or `AbstractBaseUser` class as the parent class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to extend your `User` class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In your `/chapter_3/models.py` file, in the `Seller` class, replace `models.Model`
    with the `AbstractUser` parent class and include the `import` statement shown
    here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: An `AbstractUser` class will allow us to keep all of the original fields that
    exist in the `User` model. If we want to create a brand-new `User` model from
    scratch, use the `AbstractBaseUser` parent class instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to adjust the value of the `AUTH_USER_MODEL` variable in the `settings.py`
    file, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Use the `app_name.model_name` naming convention, paying attention to model class
    letter casing. Without adjusting this value, we will get a `User` model for this
    project; instead, the `Seller` model will be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we try to run the Django migration commands now, Django will ask us to assign
    a default value to the username and password fields. Since a username field needs
    to be unique, we can''t just set a default value for this object easily because
    that will result in duplicate usernames. The reason this will happen is that we
    destroyed the previous `auth_user` tables in the database and created an entirely
    new set of relations for a `User`. Go ahead and drop your tables just like you
    did in the previous subsection, titled *Dropping database tables*. Now run the
    Django migrations commands. The following screenshot shows the `chapter_3_seller`
    table now has many other fields that we did not write:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.7 – PgAdmin – user model extension'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.7_B17243.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.7 – PgAdmin – user model extension
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have covered the basics of writing and extending models, let's use
    the Django shell to perform queries. We can use the Django shell to see the results
    of queries without having to learn about rendering templates first, which is what
    all of [*Chapter 4*](B17243_04_ePub.xhtml#_idTextAnchor116), *URLs, Views, and
    Templates*, will cover.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Django shell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Django shell** is a powerful tool to add to any toolbox. It will activate
    the Python interactive interpreter and uses the Django database abstraction API
    to let us connect directly to the database(s) configured in a project. With this,
    we can write Python and perform queries directly from a terminal or command-line
    window.
  prefs: []
  type: TYPE_NORMAL
- en: 'To activate the Django shell, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your terminal or command-line window and navigate to the root of your
    project. Make sure your virtual environment has been activated and then execute
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should see it print out the following information about the `InteractiveConsole`
    that was launched:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Your console will now display three right-angle brackets, where you can begin
    writing and executing Python code one line at a time. Theoretically, you could
    input an entire script this way, but it will not be saved anywhere, and your code
    will be lost when the window is closed or the `InteractiveConsole` is terminated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that this shell is activated, let's add sample data and perform a few queries
    to observe how it behaves.
  prefs: []
  type: TYPE_NORMAL
- en: Running basic Python scripts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Earlier in this chapter, in the subsection titled *Mutable versus immutable
    objects*, it was mentioned that a Python string is one of the immutable data types
    that exist. An immutable string is one that cannot be reassigned a character at
    a particular index of that string after it has been created. This means that what
    is allowed is reassigning the value to that string altogether, and what is not
    allowed is changing the value of a character at a particular index. This is a
    basic fundamental of Python, and those who are new to Python can find this to
    be confusing. In this next example, we will demonstrate how to use the Django
    shell and at the same time demonstrate what makes a string immutable:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Launch the Python interactive interpreter by running the following Django shell
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Assign a new variable called `myvar` and give it an initial value of `my_string`,
    as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'By executing the second statement shown in the previous code block, where we
    try to remove the underscore from the string at index `2`, we are receiving an
    error stating `TypeError: ''str'' object does not support item assignment`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we just reassign the value of the `myvar` variable, as is done in the following
    code block, we will be able to remove the underscore this way:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding example, the first `print` statement returns `my_string` and
    then, after we change the value of `myvar`, the next `print` statement returns
    `mystring`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could use string indexes to look up characters and combine them but we cannot
    reassign a character at an index. The following example would remove the underscore
    by looking up characters at specified index ranges:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Type `exit()` to quit using the interactive interpreter and return to using
    your `manage.py` commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that we know how to execute basic Python scripts in the interactive interpreter,
    let's use this tool to generate a custom `SECRET_KEY` and set a project's `.env`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Generating a SECRET_KEY variable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `SECRET_KEY` variable in Django is used as a hash to secure things, such as
    your sessions, cookie storage, password tokenization, and all other methods of
    cryptographic signing that act to secure your site. Instead of using an online
    tool to generate this key, where the transmission either to or from that source
    could be compromised, you could generate your own using the Django shell. All
    we are doing is generating a random string. There is nothing special about this
    operation; you could technically use any combination of letters and numbers that
    you enter on a keyboard too. While this is not necessary since Django already
    generates a unique key for us when we create a new Django project, it is a useful
    step to allow us to create different keys to use on each of our Heroku environments.
    This way, we don't share the same `SECRET_KEY`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To generate your own `SECRET_KEY`, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Activate the Django shell in your terminal or command-line window and then
    import the method shown in the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The method shown here comes from the package called `secret_key_generator`,
    which we installed in [*Chapter 2*](B17243_02_ePub.xhtml#_idTextAnchor037), *Project
    Configuration*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, execute the following `print` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Take the key that gets printed onscreen and use it to set or reset your environment
    variables. To reset your variables, just follow the same steps as were discussed
    in [*Chapter 2*](B17243_02_ePub.xhtml#_idTextAnchor037), *Project Configuration*,
    under the subsection titled *Remote variables* and it will update your value with
    the new value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The preceding shell command also created for us a text file called `.secret.txt`,
    found in the root of your project, where your `manage.py` file is located. You
    can delete the `.sectret.txt` file as it is not needed.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's use the Django shell to add data to our tables next, allowing us
    to use the Django shell to perform queries after that.
  prefs: []
  type: TYPE_NORMAL
- en: Saving data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating and saving objects to your database using the Django shell is easy.
    After we have activated the Django shell, we need to import the models that we
    want to work with into memory just like when we import something at the top of
    any `.py` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to create and save data using the Django shell:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import your vehicle class objects using the `InteractiveConsole` window by
    executing the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These objects will be available for you to use until that window is closed or
    the `exit()` command is executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'While these objects are loaded, it only takes the two lines of code shown in
    the following code block to create a new object and then save it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding lines will create and then save a `VehicleModel` object with the
    name of `Enclave Avenir` into the `chapter_3_vehiclemodel` table. In the creation
    of the `vehicle_model` object previously, we provided values to all of the fields
    that exist for that class. The value of the `make` field uses the numeric value
    of the tuple that we created earlier, called `MAKE_CHOICES`.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if we try to create an `Engine` object using a numeric value for the
    `vehicle_model` field, then we will be given a `ValueError`, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In order to successfully create an `Engine` object, we first have to create
    a `VehicleModel` object as we did for the `vehicle_model` temporary object in
    *step 2*. Then, use that variable to set as the value of the `model` field instead
    of using a numeric integer, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*Step 4* of the preceding example will likely result in an error due to us
    adding the `unique = True` argument to the `name` field of the `VehicleModel`
    class. This is also because we just created an object using the same name in *step
    2*. You can get around that by providing a unique name or disregarding it and
    moving forward. This error was made intentionally for learning purposes. The error
    you receive should look like the one shown in the following code block, indicating
    that you have duplicate entries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: To get around this, we need to use the `update_or_create()` method instead of
    the `save()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we try to create and then save an engine with a `vehicle_model` field that
    has not been already saved to the database, we will get a `ValueError` informing
    us that there is an unsaved related object present. If you wish to see this, create
    the `vehicle_model` object using the following values. Then, use that object to
    assign as the value of the `vehicle_model` field on the `engine` object and try
    to save:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Once you try to save that `engine`, the error shown in the preceding code block
    would print to your screen, which is the reason why we need to save each related
    object before creating an object that they rely on.
  prefs: []
  type: TYPE_NORMAL
- en: Let's discuss using the `update_or_create()` method next.
  prefs: []
  type: TYPE_NORMAL
- en: Model method – update_or_create()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We use the `update_or_create()` method instead of the `save()` method to create
    or modify an existing object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to use this method:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure the Django shell is activated and then execute the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding example should have been successful. If it was, then you received
    no errors, and you'll see the three right-angle brackets waiting for your next
    input command.
  prefs: []
  type: TYPE_NORMAL
- en: Using a database management tool such as PgAdmin, check to see that you have
    a `VehicleModel` record in your table with the name `Enclave Avenir`. The `defaults`
    argument in the preceding example is an optional argument that defines the values
    that you want to set if this operation creates a new record. Without it, the system
    will default to values set on your model fields instead.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this step, we will add a `Vehicle` to the database. It requires the use
    of a `Money` class to create a `Money` object. To use the `Money` class, execute
    the following `import` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, execute the following three `update_or_create()` commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The commands in this subsection should have all resulted in success without
    errors.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If a vehicle with the same VIN as the one shown previously is already created
    for you by importing the data found in the `chapter_3` data fixture, then you
    can just change the `vin` value in the preceding example to a new and unique `vin`
    value. This allows you to witness a new record being added to your table when
    viewed in a database management tool such as PgAdmin.
  prefs: []
  type: TYPE_NORMAL
- en: Let's discuss loading the `chapter_3` data fixture next.
  prefs: []
  type: TYPE_NORMAL
- en: Loading the chapter_3 data fixture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Instead of providing steps on how to create all of the data that will be needed
    to demonstrate the exercises throughout the rest of this chapter and this book,
    we will be adding data from a data fixture. Adding data can be done in a much
    simpler way than how it was done from within the Django shell. We will discuss
    this concept in more depth and create our own fixtures later in [*Chapter 10*](B17243_10_ePub.xhtml#_idTextAnchor293),
    *Database Management*. For now, make sure the `/becoming_a_django_entdev/becoming_a_django_entdev/chapter_3/fixtures/`
    folder and all of the files found in this folder from the code of this book are
    copied into your `/chapter_3/` app folder. The `chapter_3` fixture will provide
    enough data for us to work with the remaining examples of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'To load your data fixture make sure you have exited your Django shell and that
    your virtual environment is active and then execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: If you have issues with importing this fixture, double-check that your table
    structures match the structures of the models provided with the code of this book
    in the `chapter_3` app.
  prefs: []
  type: TYPE_NORMAL
- en: The alternative would be to follow the steps in the *Saving data* subsection
    of this chapter to add your own sample data one painstaking item at a time. Create
    and save as many objects as you would like using those examples. If you were to
    create a `Vehicle` object, it would be done in the same way as creating an `Engine`
    object, except now you are defining the values of two related objects instead
    of one in order to save successfully. We just need to have a few objects to play
    around with in the next exercises of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Performing queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Performing queries using the Django shell will give us some insight into how
    queries work. In the following subsections, we will discuss some common methods
    that are used.
  prefs: []
  type: TYPE_NORMAL
- en: Model method – all()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `all()` method returns all records found in the table for that model object.
    This method will return a QuerySet in the following format, representing all entries
    that it finds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'The `chapter_3` data fixture only provides three VehicleModel and that is why
    a collection of only three objects is returned to us. Your results may vary. One
    of the reasons why we created a `__str__()` method, as was done earlier in this
    chapter, in the subsection titled *Model method – __str__*, is so that it could
    be represented in a logical way in code usage such as this, where the object name
    that gets printed out is a name that makes sense to us and not something that
    won''t make sense. Without the `__str__()` method defined in the `VehicleModel`
    class, the QuerySet would have been returned to us in a manner that looks like
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: We would have no way to distinguish which object is which and what order they
    are in just by looking at the collection printed in this code block.
  prefs: []
  type: TYPE_NORMAL
- en: Model method – get()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `get()` method is used to target a specific database record.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to see this method in action:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use `get()` to target the `vin` value of a vehicle when performing a query,
    as is done here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Using the single object that was returned to us, run the `print` statement
    again using the `full_vehicle_name()` method that we created earlier, to see the
    difference in the results that are generated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, use the other `fullname` method with the `@property` decorator to return
    the exact same results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Django is using the format that we defined earlier in the `__str__` method to
    generate a string that gets printed to the screen in *step 1*. We already know
    that the `vin` field is set to `unique = True`, meaning there will never be two
    objects with the same `vin` value in the database, so we know that it is safe
    to use the `get()` method in all the preceding steps. If there are numerous items
    with the same value and a `get()` method is used, then you will need to use a
    `filter()` method instead.
  prefs: []
  type: TYPE_NORMAL
- en: Model method – filter()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `filter()` method is used to look up records in a database that may have
    the same field values. This method will return a collection of results instead
    of a single result. The collection will be returned to us as a `QuerySet`. For
    example, we can filter the `VehicleModel` table, which we already know contains
    three rows.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example will filter the `make` field by the value of `Buick`,
    to return a collection of only two objects instead of three:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Queries can get much more complex than using a simple `all()`, `get()`, or
    `filter()` method. Q objects provide more complicated queries as well. For a complete
    breakdown of how to use Q objects in Django, visit the documentation here: https://docs.djangoproject.com/en/4.0/ref/models/querysets/#q-objects.'
  prefs: []
  type: TYPE_NORMAL
- en: We can even obtain a summary of objects using arithmetic functions, which brings
    us to our next subsection, discussing aggregates.
  prefs: []
  type: TYPE_NORMAL
- en: Aggregates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Django provides an easy way to generate a summary of a collection of objects,
    known as **aggregates**. What this means is that we can perform a query and use
    any one of the many **aggregation functions** that Django provides. This can be
    used to generate an average price for all the vehicles, generate an average price
    of just the sold vehicles, or generate a total count of vehicles for a particular
    seller. While there is a lot of information regarding the topic of aggregates
    and annotates, we will discuss some basic usages. A complete guide to generating
    aggregates in Django can be found here: [https://docs.djangoproject.com/en/4.0/ref/models/querysets/#aggregation-functions](https://docs.djangoproject.com/en/4.0/ref/models/querysets/#aggregation-functions).'
  prefs: []
  type: TYPE_NORMAL
- en: Model method – aggregate()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Aggregates are used to generate a summary of every object in a QuerySet. To
    get an average price of every vehicle that exists in that table, we can use the
    `Avg` aggregate function. The argument that we pass into the `Avg` function is
    the field that we want to perform this operation on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to practice using aggregates:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import your `Vehicle` model and the `Avg` class objects, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Perform a query lookup using the `all()` method combined with the `aggregate()`
    method, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Print your `vehicles` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The summary is returned as a dictionary object.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can get the value of the `price__avg` key by executing the following `print`
    statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The result of the average is, of course, not actually formatted in any particular
    currency type yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can format it in US dollars by applying the same `Money()` conversion that
    we did before when we created and then saved our first vehicle in the database,
    by executing the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Where we wrote `Vehicle.objects.all().aggregate()` in *step 2* previously,
    the `all()` method is redundant. The `aggregate()` method basically does the same
    thing as the `all()` method, meaning we could write our statement as follows and
    produce the same results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also replace the `all()` method with any of the standard query methods,
    such as `get()` or `filter()`, as depicted in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: Let's discuss annotations next.
  prefs: []
  type: TYPE_NORMAL
- en: Model method – annotate()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Annotations are used when we have objects that relate to other objects in a
    QuerySet and we want to generate a summary of every related object in that QuerySet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to practice using annotations:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the following commands to provide a query of all sellers that exist
    in a table and then generate a count of only the sold vehicles that it finds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Alter the preceding `filter` statement to count only the unsold vehicles, as
    shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We need to specify the index at `sellers[0]` because a `filter()` method will
    always return a collection of objects, even if the query only results in one object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Print the `sellers` collection to the screen, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can see that there is only one `Seller` in the database at this time. We
    got the numbers `2` and then `5` as the results, for a total of seven vehicles
    that relate to that seller.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will discuss model managers and how they can be used to perform advanced
    queries.
  prefs: []
  type: TYPE_NORMAL
- en: Writing model managers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We now know that when we want to apply logic that pertains to a single object
    within a table, we will look into writing a model method. An advanced Django concept
    can allow us to add logic that would relate to the entire table of objects instead.
    That would be written using a `objects` manager, as in when we write a query statement
    such as `MyModel.objects.all()`. Since the `objects` manager is already created
    for us, there is technically no need for us to create a model manager at all.
    However, custom model managers can be used in a project to provide additional
    methods that the entire table uses. We will discuss a simple use of this concept
    that adds filters to a table. To learn more about how model managers can be used
    in more depth, visit the official Django documentation, found here: [https://docs.djangoproject.com/en/4.0/topics/db/managers/](https://docs.djangoproject.com/en/4.0/topics/db/managers/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Take the following steps to apply a filter, separating the vehicle objects
    by make/manufacturer. Here, we will write a manager for the `Buick` vehicles and
    another manager for the `Chevy` vehicles. In a large project, it would also be
    wise to place your managers in a separate `managers.py` file and import them into
    `models.py` before using them. Let''s just add them all to the `models.py` file
    for now:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `/chapter_3/models.py` file, add the following two model manager classes
    above your model classes and below any existing `import` statements, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `/chapter_3/models.py` file, add the following three model manager statements
    to your existing `Vehicle` class, below the model fields found in that class and
    above the `Meta` subclass, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, open your terminal or command-line window and activate your virtual environment
    and the Django shell. Then, import the `Vehicle` model into `InteractiveConsole`,
    as is done here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Execute the following `objects` manager `count()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Execute the following `buick_objects` manager `count()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Execute the following `chevy_objects` manager `count()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What we get in return are the vehicles that relate to each manager that we created,
    starting with the `objects` manager, then `buick_objects` and `chevy_objects`.
    This counts the filtered objects instead of providing us with a total count of
    all objects in that table. Even though we are still using the `all()` method,
    we only get all of the objects related to that filter. We also apply the `count()`
    method to print a numeric count of what gets returned in a QuerySet versus printing
    the names of each object, as was depicted in previous query examples.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned that models are building blocks of everything else
    we build that accesses data in a database. They provide the containers where all
    of a project's data will exist as a data storage device for this application.
    We now have a toolbox with tools related to the structure of the tables, such
    as the columns that exist or rules/constraints that we apply to them. Other tools
    help us to link these tables together that build the relationships between those
    tables. We also know how to transform the data that we have to provide other data
    not kept in those tables, but rather derived from it. Some of the concepts add
    performance power by doing work in the background, indexing data, and reducing
    the time that it takes to look up information. Querying objects is also a complex
    subject and there is a lot of material regarding it; use the concepts in this
    chapter to help guide you through researching more advanced ways of querying data,
    to help with complex real-world scenarios. Later, in [*Chapter 10*](B17243_10_ePub.xhtml#_idTextAnchor293),
    *Database Management*, we will discuss other tricks that help to enhance database
    performance when performing database queries.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's take the models that we created in this chapter and render that
    data onto an actual web page, finally viewing something within a browser. These
    will be the URLs, views, and templates that we create in the next chapter.
  prefs: []
  type: TYPE_NORMAL
