- en: Chapter 5. Acting on Frame Changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Besides the many places we have encountered where Python can be used in Blender,
    we will now look at scripts that may be used to act on certain events. These scripts
    come in two flavors—**script links** and **space** **handlers**.
  prefs: []
  type: TYPE_NORMAL
- en: '**Script links** are scripts that may be associated with Blender objects (`Meshes`,
    `Cameras`, and so on, but also `Scenes` and `World` objects) and that can be set
    up to run automatically on the following occasions:'
  prefs: []
  type: TYPE_NORMAL
- en: Just before rendering a frame
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Just after rendering a frame
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a frame is changed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When an object is updated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the object data is updated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Scene objects may have script links associated with them that may be invoked
    on two additional occasions:'
  prefs: []
  type: TYPE_NORMAL
- en: On loading a `.blend` file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On saving a `.blend` file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Space handlers are Python scripts that are invoked each time the 3D view window
    is redrawn or a key or mouse action is detected. Their primary use is to extend
    the capabilities of Blender's user interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn:'
  prefs: []
  type: TYPE_NORMAL
- en: What script links and space handlers are
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to perform activities on each frame change in an animation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to associate additional information with an object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to make an object appear or disappear by changing its layout or changing
    its transparency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to implement a scheme to associate a different mesh with an object on each
    frame
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to augment the functionality of the 3D View
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animating the visibility of objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An often recurring issue in making an animation is the wish to make an object
    disappear or fade away at a certain frame, either for the sake of the effect itself
    or to replace the object by another one to achieve some dramatic impact (such
    as an explosion or a bunny rabbit changing into a ball).
  prefs: []
  type: TYPE_NORMAL
- en: There are many ways to engineer these effects, and most of them are not specifically
    tied to script links reacting on a frame change (many can simply be keyed as well).
    Nevertheless, we will look at two techniques that may easily be adapted to all
    sorts of situations, even ones that are not easily keyed. For example, we demand
    some specific behavior of a parameter that is easy to formulate in an expression
    but awkward to catch in an IPO.
  prefs: []
  type: TYPE_NORMAL
- en: Fading a material
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our first example will change the **diffuse** **color** of a material. It would
    be just as simple to change the transparency, but it is easier to see changes
    in diffuse color in illustrations.
  prefs: []
  type: TYPE_NORMAL
- en: Our goal is to fade the diffuse color from black to white and back again, spaced
    over a period of two seconds. We therefore define a function `setcolor()` that
    takes a material and changes its diffuse color (the `rgbColor` attribute). It
    assumes a frame rate of 25 frames per second and, therefore, the first line fetches
    the current frame number and performs a *modulo* operation to determine what fraction
    of the current whole second is elapsed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The highlighted line in the following code snippet determines whether we are
    in an odd or even second. If we are in an even second, we ramp up the diffuse
    color to white so we just keep our computed fraction. If we are in an odd second,
    we tone down the diffuse color to black so we subtract the fraction from the maximum
    possible value (`25`). Finally, we scale our value to lie between `0` and `1`
    and assign it to all three color components to obtain a shade of gray:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The script ends with an important check: `Blender.bylink` is `True` only if
    this script is called as a script handler and in that case `Blender.event` holds
    the event type. We only want to act on frame changes so that is what we check
    for here. If these conditions are satisfied, we pass `Blender.link` to our `setcolor()`
    function as it holds the object our `scriptlink` script is associated with—in
    this case that will be a `Material` object. (This script is available as `MaterialScriptLink.py`
    in `scriptlinks.blend`.)'
  prefs: []
  type: TYPE_NORMAL
- en: The next thing on our list is to associate the script with the object whose
    material we want to change. We therefore select the object and in the **Buttons**
    **Window** we select the **Script** **panel**. In the **Scriptlinks** tab, we
    enable script links and select the **MaterialScriptLinks** button. (If there is
    no **MaterialScriptLinks** button then the selected object has no material assigned
    to it. Make sure it has.) There should now be a label **Select** **Script** **link**
    visible with a **New** button. Clicking on **New** will show a dropdown with available
    script links (files in the text editor). In this case, we will select `MaterialScriptLink.py`
    and we are done. We can now test our script link by changing the frame in the
    3D view (with the arrow keys). The color of our object should change with the
    changing frame number. (If the color doesn't seem to change, check whether solid
    or shaded viewing is on in the 3D view.)
  prefs: []
  type: TYPE_NORMAL
- en: '![Fading a material](img/0400-05-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Changing layers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we want to change the **visibility** of an object, changing the layer(s)
    it is assigned to is a more general and powerful technique than changing material
    properties. Changing its assigned layer has, for instance, the advantage that
    we can make the object completely invisible for lamps that are configured to illuminate
    only certain layers and many aspects of an animation (for example, deflection
    of particles by force fields) may be limited to certain layers as well. Also,
    changing layers is not limited to objects with associated materials. You can just
    as easily change the layer of a `Lamp` or `Camera`.
  prefs: []
  type: TYPE_NORMAL
- en: For our next example, we want to assign an object to layer 1 if the number of
    elapsed seconds is even and to layer 2 if the number of seconds is odd. The script
    to implement this is very similar to our material changing script. The real work
    is done by the function `setlayer()`. The first line calculates the layer the
    object should be on in the current frame and the next line (highlighted) assigns
    the list of layer indices (consisting of a single layer in this case) to the `layers`
    attribute of the object. The final two lines of the `setlayer()` function ensure
    that the layer's change is actually visible in Blender.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As in our previous script, the final lines of our script check whether we are
    called as a script link and on a frame change event, and if so, pass the associated
    object to the `setlayer()` function. (The script is available as `OddEvenScriptlink.py`
    in `scriptlinks.blend`.)
  prefs: []
  type: TYPE_NORMAL
- en: All that is left to do is to assign the script as a `scriptlink` to a selected
    object. Again, this is accomplished in the **Buttons** **Window** | **Script**
    **panel** by clicking on **Enabling** **Script** **Links** in the **Scriptlinks**
    tab (if necessary, it might still be selected because of our previous example.
    It is a global choice, that is, it is enabled or disabled for all objects). This
    time, we select the object `scriptlinks` instead of the material `scriptlinks`
    and click on **New** to select `OddEvenScriptlink.py` from the dropdown.
  prefs: []
  type: TYPE_NORMAL
- en: Countdown—animating a timer with script links
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the possibilities of using a script link that acts on frame changes is
    the ability to modify the actual mesh either by changing the vertices of a `Mesh`
    object or by associating a completely different mesh with a Blender object. This
    is not possible when using IPOs as these are limited to shape keys that interpolate
    between predefined shapes with the same mesh topology (the same number of vertices
    connected in the same way). The same is true for curves and text objects.
  prefs: []
  type: TYPE_NORMAL
- en: One application of that technique is to implement a `counter` object that will
    display the number of seconds since the start of the animation. This is accomplished
    by changing the text of a `Text3d` object by way of its `setText()` method. The
    `setcounter()` function in the following code does exactly that together with
    the necessary actions to update Blender's display. (The script is available as
    `CounterScriptLink.py` in `scriptlinks.blend`.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This script may be associated as a script link with any `Text3d` object as shown
    before. However, if run with *Alt* *+* *P* from the text editor it will create
    a new `Text3d` object and will associate itself to this object as a script link.
    The highlighted lines show how we check for this just like in the previous scripts,
    but in this case we take some action when not called as a script link as well
    (the `else` clause). The final two highlighted lines show how we associate the
    script with the newly created object. First, we remove (clear) any script links
    with the same name that might have been associated earlier. This is done to prevent
    associating the same script link more than once, which is valid but hardly useful.
    Next, we add the script as a script link that will be called when a frame change
    occurs. The screenshot shows the 3D view with a frame from the animation together
    with the **Buttons** **window** (top-left) that lists the association of the script
    link with the object.
  prefs: []
  type: TYPE_NORMAL
- en: '![Countdown—animating a timer with script links](img/0400-05-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that although it is possible to *associate* a script link with a Blender
    object from within a Python script, script links must be *enabled* manually for
    them to actually run! (In the **ScriptLinks** tab.) There is no functionality
    in the Blender Python API to do this from a script.
  prefs: []
  type: TYPE_NORMAL
- en: I'll keep an eye on you
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, when working with a complex object, it is difficult to keep track
    of a relevant feature as it may be obscured by other parts of the geometry. In
    such a situation, it would be nice to highlight certain vertices in a way that
    keeps them visible, no matter the orientation, and independent of the *edit* mode.
  prefs: []
  type: TYPE_NORMAL
- en: '**Space** **handlers** provide us with a way to perform actions each time the
    3D view window is redrawn or a key or mouse action is detected. These actions
    may include drawing inside the 3D view area as well, so we will be able to add
    **highlights** at any position we like.'
  prefs: []
  type: TYPE_NORMAL
- en: How do we determine which vertices we would like to highlight? Blender already
    provides us with a uniform way to group collections of vertices as vertex groups
    so all we have to do is let the user indicate which vertex group he would like
    to highlight. We then store the name of this selected vertex group as an object
    property. Object properties are designed to be used in the game engine but there
    is no reason why we shouldn't reuse them as a way to persistently store our choice
    of vertex group.
  prefs: []
  type: TYPE_NORMAL
- en: 'So again, we have a script that will be called in two ways: as a space handler
    (that is, each time the 3D view window is redrawn to highlight our vertices) or
    by running it from the text editor with *Alt + P* to prompt the user to choose
    a vertex group to highlight.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Code outline: AuraSpaceHandler.py'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following outline shows which steps we will take in each situation:'
  prefs: []
  type: TYPE_NORMAL
- en: Get active object and mesh.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If running standalone:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get list of vertex groups
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Prompt user for choice
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Store choice as property of object
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Else:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get the property that holds the vertex group
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Get a list of vertex coordinates
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For each vertex:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: draw a small disk
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The resulting code is available as `AuraSpaceHandler.py` in `scriptlinks.blend`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: It starts with a line of comment that is essential, as it signals to Blender
    that this is a space handler script that can be associated with the 3D view (no
    other area can have space handlers associated at present) and should be called
    on a `redraw` event.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The script proper then proceeds to retrieve the active object from the current
    scene and gets the object's mesh if it is a `Mesh`. At the highlighted line, we
    check if we are running as space handler and if so, we fetch the property that
    we named `Highlight`. The data of this property is the name of the vertex group
    that we want to highlight. We proceed by getting a list of all vertices in this
    vertex group and by getting the matrix of the object. We need this because vertex
    locations are stored relative to the object's matrix. We then construct a list
    of vertex locations and pass this along with the name of the vertex group to the
    `drawAuras()` function that will take care of the actual drawing.
  prefs: []
  type: TYPE_NORMAL
- en: The second highlighted line marks the beginning of the code that will be executed
    when we run the script from the text editor. It creates a string consisting of
    the names of all vertex groups associated with the active object separated by
    pipe characters (`|`) and prepended by a suitable title. This string is passed
    to `PopMenu()` which will display the menu, and will either return with the user's
    choice or with `-1`, if nothing was chosen.
  prefs: []
  type: TYPE_NORMAL
- en: If there was a vertex group chosen, we try to retrieve the `Highlight` property.
    If this succeeds we set its data to the name of the chosen vertex group. If the
    property did not yet exist, we add a new one with the name `Highlight` and again
    with the name of the chosen vertex group as data.
  prefs: []
  type: TYPE_NORMAL
- en: Next we have to make sure that `scriptlinks` are enabled (**Buttons** **window**
    | **Scripts** **panel** | **Scriptlinks**. Click on **enable** **scriptlinks**
    if not yet selected.). Note that to Blender it makes no difference whether we
    are dealing with space handlers or script links as far as enabling them is concerned.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final step in using our space handler is associating it with the 3D view.
    To do this toggle the entry `Draw: AuraSpaceHandler.py` in the view (**Space**
    **Handler** **Scripts** menu of the 3D view).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Code outline: AuraSpaceHandler.py](img/0400-05-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using themes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The code we haven''t seen yet deals with the actual drawing of the highlights
    and the name of the vertex group to identify what we are highlighting. It starts
    off by determining the colors we will use for the highlights and the text by retrieving
    these from the current theme. This way the user can customize these colors in
    a convenient way from the **User** **Preferences** window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The first line will retrieve a list of **themes** that are present. The first
    one is the active theme. From this theme we retrieve the `VIEW3D` theme space
    and its `text_hi` attribute is a list of four integers representing a RGBA color.
    The list comprehension discards the alpha component and converts it to a list
    of three floats in the range [0, 1] that we will use as our text color. Likewise,
    we construct the color of the highlights from the `active` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our next challenge is to draw a disk-shaped highlight at a specified location.
    As the size of the disk is quite small (it can be adjusted by altering the `size`
    variable), we can approximate it well enough by an octagonal shape. We store the
    list of x, y coordinates of such an octagon in the `diskvertices` list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The actual drawing of the octagon depends heavily on the functions provided
    by Blender's `BGL` module (highlighted in the previous code). We start by stating
    that we will be drawing a polygon and then add a vertex for each tuple in the
    `diskvertices` list. The location passed to `drawDisk()` will be the center and
    the vertices will all lie on a circle with a radius equal to `size`. When we call
    the `glEnd()` function, the filled-in polygon will be drawn in the current color.
  prefs: []
  type: TYPE_NORMAL
- en: You might wonder how these drawing functions know how to translate locations
    in 3D to coordinates on the screen and there is indeed more here than meets the
    eye as we will see in the next section of code. The necessary function calls to
    inform the graphics system how to convert 3D coordinates to screen coordinates
    is not implemented in the `drawDisk()` function (preceding code snippet). This
    is because calculating this information for each disk separately would incur an
    unnecessary performance penalty as this information is the same for each disk
    we draw.
  prefs: []
  type: TYPE_NORMAL
- en: 'We therefore define a function, `drawAuras()`, which will take a list of locations
    and a `groupname` argument (a string). It will calculate the transformation parameters,
    call `drawDisk()` for each location in the list, and will then add the group name
    as an on-screen label at approximately just right of the center the highlights.
    Blender''s `Window` module provides us with the `GetPerspMatrix()` function that
    will retrieve the matrix that will correctly convert a point in 3D space to a
    point on the screen. This 4 by 4 matrix is a Python object that will have to be
    converted to a single list of floats that can be used by the graphics system.
    The highlighted lines in the following code take care of that. The next three
    lines reset the projection mode and tell the graphics system to use our suitably
    converted perspective matrix to calculate screen coordinates. Note that changing
    these projection modes and other graphics settings does not affect how Blender
    itself draws things on screen, as these settings are saved before calling our
    script handler and restored afterward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: With the preliminary calculations out of the way we can set the color we will
    draw our disks in with the `glColor3f()` function. As we stored the color as a
    list of three floats and the `glColor3f()` function takes three separate arguments,
    we unpack this list with the asterisk operator. Next, we call `drawDisk()` for
    each item in `locations`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Blender OpenGL functions:**'
  prefs: []
  type: TYPE_NORMAL
- en: The documentation of Blenders `BGL` module lists a large number of functions
    from the **OpenGL** library. Many of these functions come in a large number of
    variants that perform the same action but receive their arguments in different
    ways. For example, `BGL.glRasterPos3f()` is a close relation to `BGL.glRasterPos3fv()`
    that will take a list of three single-precision float values instead of three
    separate arguments. For more information, refer to the API documentation of the
    `Blender.BGL` and `Blender.Draw` modules and the OpenGL reference manual on [http://www.opengl.org/sdk/docs/man/](http://www.opengl.org/sdk/docs/man/).
  prefs: []
  type: TYPE_NORMAL
- en: If the number of highlights we have drawn is not zero, we set the drawing color
    to `textcolor` and then calculate the average coordinates of all the highlights.
    We then use the `glRasterPos3f()` function to set the starting position of the
    text that we want to draw to these average coordinates with some extra space added
    to the x-coordinate to offset the text a little to the right. Blender's `Draw.Text()`
    function will then draw the group name in a small font at the chosen location.
  prefs: []
  type: TYPE_NORMAL
- en: Revisiting mesh—making an impression
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although **softbody** and **cloth** simulators that are available in Blender
    do an excellent job in many situations, sometimes you want to have more control
    over the way a mesh is deformed or simulate some specific behavior that is not
    quite covered by Blender's built-in simulators. This exercise shows how to calculate
    the deformation of a mesh that is touched, but not penetrated by another mesh.
    This is not meant to be physically accurate. The aim is to give believable results
    for solid things touching an easily deformable or gooey surface such as a finger
    taking a lick of butter or a wheel running through a soft shoulder.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following illustration gives some impression of what is possible. The tracks
    are created by animating a rolling car tire on a subdivided plane:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Revisiting mesh—making an impression](img/0400-05-04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the following part, we will refer to the object mesh being deformed as the
    source and the object, or objects, doing the deforming as targets. In a sense,
    this is much like a constraint and we might have implemented these deformations
    as pycontraints. However, that wouldn't be feasible because constraints get evaluated
    each time the source or targets move; thereby causing the user interface to come
    to a grinding halt as calculating the intersections and the resulting deformation
    of meshes is computationally intensive. Therefore, we choose an approach where
    we calculate and cache the results each time the frame is changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our script will have to serve several functions, it must:'
  prefs: []
  type: TYPE_NORMAL
- en: Calculate and cache the deformations on each frame change
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change vertex coordinates when cached information is present
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And when run standalone, the script should:'
  prefs: []
  type: TYPE_NORMAL
- en: Save or restore the original mesh
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prompt the user for targets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Associate itself as a script link with the source object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Possibly remove itself as a script link
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An important consideration in designing the script is how we will store or
    cache the original mesh and the intermediate, deformed meshes. Because we will
    not change the topology of the mesh (that is, the way vertices are connected to
    each other), but just the vertex coordinates, it will be sufficient to store just
    those coordinates. That leaves us with the question: where to store this information.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we do not want to write our own persistent storage solution, we have two
    options:'
  prefs: []
  type: TYPE_NORMAL
- en: Use Blender's registry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Associate the data with the source object as a property
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blender's **registry** is easy to use but we must have some method of associating
    the data with an object because it is possible that the user might want to associate
    more than one object with an impression calculation. We could use the name of
    the object as a key, but if the user would change that name, we would lose the
    reference with the stored information while the script link functionality would
    still be there. This would leave the user responsible for removing the stored
    data if the name of the object was changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Associating all data as a **property** would not suffer from any renaming and
    the data would be cleared when the object is deleted, but the types of data that
    may be stored in a property are limited to an integer, a floating point value,
    or a string. There are ways to convert arbitrary data to strings by using Python''s
    standard `pickle` module, but, unfortunately, this scenario is thwarted by two
    problems:'
  prefs: []
  type: TYPE_NORMAL
- en: Vertex coordinates in Blender are `Vector` instances and these do not support
    the pickle protocol
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The size of **string properties** is limited to 127 characters and that is far
    too small to store even a single frame of vertex coordinates for a moderately
    sized mesh
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Despite the drawbacks of using the registry, we will use it to devise two functions—one
    to store vertex coordinates for a given frame number and one to retrieve that
    data and apply it to the vertices of the mesh. First, we define a utility function
    `ckey()` that will return a key to use with the registry functions based on the
    name of the object whose mesh data we want to cache:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Not all registries are the same**'
  prefs: []
  type: TYPE_NORMAL
- en: Do not confuse Blender's registry with the Windows registry. Both serve the
    similar purpose of providing a persistent storage for all sorts of data, but both
    are distinct entities. The actual data for Blender registry items that are written
    to disk resides in `.blender/scripts/bpydata/config/` by default and this location
    may be altered by setting the `datadir` property with `Blender.Set()`.
  prefs: []
  type: TYPE_NORMAL
- en: Our `storemesh()` function will take an object and a frame number as arguments.
    Its first action is to extract just the vertex coordinates from the mesh data
    associated with the object. Next, it retrieves any data stored in Blender's registry
    for the object that we are dealing with and we pass the extra `True` parameter
    to indicate that if there is no data present in memory, `GetKey()` should check
    for it on disk. If there is no data stored for our object whatsoever, `GetKey()`
    will return `None`, in which case we initialize our cache to an empty dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: Subsequently, we store our mesh coordinates in this dictionary indexed by the
    frame number (highlighted in the next code snippet). We convert this integer frame
    number to a string to be used as the actual key because Blender's `SetKey()` function
    assumes all of the keys to be strings when saving registry data to disk, and will
    raise an exception if it encounters an integer. The final line calls `SetKey()`
    again with an extra `True` argument to indicate that we want the data to be stored
    to disk as well.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `retrievemesh()` function will take an object and a frame number as arguments.
    If it finds cached data for the given object and frame, it will assign the stored
    vertex coordinates to vertices in the mesh. We first define two new exceptions
    to indicate some specific error conditions `retrievemesh()` may encounter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`retrievemesh()` will raise the `NoSuchProperty` exception if the object has
    no associated cached mesh data and a `NoFrameCached` exception if the data is
    present but not for the indicated frame. The highlighted line in the next code
    deserves some attention. We fetch the associated mesh data of the object with
    `mesh=True`. This will yield a wrapped mesh, not a copy, so any vertex data we
    access or alter will refer to the actual data. Also, we encounter Python''s built-in
    `zip()` function that will take two lists and returns a list consisting of tuples
    of two elements, one from each list. It effectively lets us traverse two lists
    in parallel. In our case, these lists are a list of vertices and a list of coordinates
    and we simply convert these coordinates to vectors and assign them to the co-attribute
    of each vertex:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'To complete our set of cache functions we define a function `clearcache()`
    that will attempt to remove the registry data associated with our object. The
    `try … except …` clause will ensure that the absence of stored data is silently
    ignored:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The user interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our script will not only be used as a script link associated with an object
    but it will also be used standalone (by pressing *Alt + P* in the text editor
    for example) to provide the user with the means to identify a target that will
    make the impression to clear the cache, and to associate the script link with
    the active object. If used in this fashion, it will present the end user with
    a few pop-up menus, both shown in the screenshots. The first one shows the possible
    actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The user interface](img/0400-05-05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The second screenshot shows the pop up offered to select an object from a list
    of `Mesh` objects that the user can choose to make an impression:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The user interface](img/0400-05-06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We first define a utility function that will be used by the pop-up menu that
    will present the user with a choice of `Mesh` objects to be used as a target to
    make an impression. `getmeshobjects()` will take a `scene` argument and will return
    a list of names of all `Mesh` objects. As depicted in the screenshot, the list
    of target objects includes the source object as well. Although this is legal,
    it is debatable whether this is very useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The menu itself is implemented by the `targetmenu()` function defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: It will fetch the list of all of the `Mesh` objects in the scene and present
    this list as a choice to the user by using Blender's `Draw.PupMenu()` function.
    If the user selects one of the menu entries (the return value will be positive
    and non-zero, see the highlighted line of the preceding code), it will store the
    name of this `Mesh` object as a property associated with our object. `impresstarget`
    is defined elsewhere as the name for the property. First, the code checks whether
    there already is such a property associated with the object by calling the `getProperty()`
    method and setting the properties data, if there is. If `getProperty()` raises
    an exception because the property does not yet exist, we then add the new property
    to the object and assign data to it with a single call to the `addProperty()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main user interface is defined in the top level of the script. It verifies
    that it is not running as a script link and then presents the user with a number
    of choices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Any valid choice will clear the cache (highlighted) and the subsequent checks
    perform the necessary actions associated with each individual choice: **Add/Replace
    scriptlink** will remove the script link, if it is already present, to prevent
    duplicates and then add it to the active object. It then presents the target menu
    to select a `Mesh` object to use to make an impression. As we already cleared
    the cache, the second choice, **Clear cache**, will do nothing specific, so we
    just pass. **Remove All** will try to remove the cache and attempt to dissociate
    itself as a script link and the final **New target** menu will present the target
    selection menu to allow the user to select a new target object without removing
    any cached results.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we *are* running as a script link we first check that we are acting on a
    `FrameChanged` event and then try to retrieve any stored vertex coordinates for
    the current frame (highlighted in the next code). If there is no previously stored
    data, we have to calculate the effects of the target object for this frame. We
    therefore get a list of target objects for the object under consideration by calling
    the utility function `gettargetobjects()` (for now, a list of just one object
    will be returned) and for each object we calculate the effect on our mesh by calling
    `impress()`. Then, we store these possibly changed vertex coordinates and update
    the display list so that the Blender GUI knows how to display our altered mesh:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: That leaves us with the actual calculation of the impression of a target object
    on our mesh.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating an impression
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When determining the effect of a target object making an impression, we will
    approach this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For each vertex in the mesh receiving the impression:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Determine if it is located inside the target object and if so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the location of the vertex to the location of the closest vertex on the
    object making the impression
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There are some important issues to address here. The location of a vertex in
    a mesh is stored relative to the object's transformation matrix. In other words,
    if we want to compare vertex coordinates in two different meshes, we have to transform
    each vertex by the transformation matrices of their respective objects before
    doing any comparison.
  prefs: []
  type: TYPE_NORMAL
- en: Also, a `Blender.Mesh` object has a `pointInside()` method that will return
    `True` if a given point is inside the mesh. This will, however, only work reliably
    on closed meshes so the user has to verify that the objects that will make the
    impression are in fact closed. (They may have interior bubbles but their surfaces
    must not contain edges that are not shared by exactly two faces. These so-called
    non-manifold edges can be selected in *edge* *select* mode by selecting **Select
    | Non Manifold** in the 3D view or pressing *Ctrl + Shift + Alt + M*.)
  prefs: []
  type: TYPE_NORMAL
- en: Finally, moving vertices to the closest vertex on the target object may be quite
    inaccurate when the target mesh is rather coarse. Performance wise, however, it
    is good to have relatively few points—as our algorithm is rather inefficient because
    by first determining whether a point is inside a mesh and then separately calculating
    the closest vertex duplicates a lot of calculations. However, as the performance
    is acceptable even for meshes consisting of hundreds of points, we stick with
    our approach, as it keeps our code simple and saves us having to write and test
    very intricate code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation starts with a function to return the distance to and the
    coordinates of the vertex closest to a given point `pt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `impress()` function itself takes a source and a target object as arguments
    and will modify the mesh data of the source object if the target mesh makes an
    impression. The first thing that it does is retrieve the transformation matrices
    of the objects. As indicated before, these will be needed to transform the coordinates
    of the vertices so that they might be compared. We also retrieve the inverse matrix
    of the source object. This will be needed to transform coordinates back to the
    space of the source object.
  prefs: []
  type: TYPE_NORMAL
- en: The highlighted line retrieves the wrapped mesh data of the source object. We
    need wrapped data because we might want to change some of the vertex coordinates.
    The next two lines retrieve copies of the mesh data. We also need copies because
    the transformation we will perform may not affect the actual mesh data. Instead
    of copying we could have left out the `mesh=True` argument, which would have given
    us a reference to an `Nmesh` object instead of a `Mesh` object. However, `Nmesh`
    objects are not wrapped and are marked as deprecated. Also, they lack the `pointInside()`
    method we need, so we opt for copying the meshes ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we transform these mesh copies by their respective object transform matrices.
    Using the `transform()` method of these meshes saves us from iterating over each
    vertex and multiplying the vertex coordinates by the transform matrix ourselves,
    and this method is probably a bit faster as well as `transform()` is completely
    implemented in C:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The final part of the `impress()` function loops over all of the vertices in
    the transformed source mesh and checks if the vertex lies enclosed within the
    (transformed) target mesh. If they are, it determines which vertex on the target
    mesh is closest and sets the affected vertex in the original mesh to these coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: This original mesh is not transformed, so we have to transform this closest
    point back to the object space of the source object by multiplying the coordinates
    with the inverse transformation matrix. Because transformation calculations are
    expensive, modifying the transformed mesh and transforming the complete mesh back
    at the end may take a considerate amount of time. Keeping a reference to the untransformed
    mesh and just transforming back individual points may, therefore, be preferable
    when only relatively few vertices are affected by the impression. The full script
    is available as `ImpressScriptLink.py` in `scriptlinks.blend`. The following illustration
    shows what is possible. Here we made a small animation of a ball (an icosphere)
    rolling along and descending into the mud (a subdivided plane).
  prefs: []
  type: TYPE_NORMAL
- en: '![Calculating an impression](img/0400-05-07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When working with the script it is important to keep in mind that when the impression
    is calculated, none of the vertices of the mesh that receives the impression should
    be located inside the target before it moves. If that happens it is possible for
    a vertex to be swept along with the movement of the target, distorting the source
    mesh along the way. For example, to make the illustration of the wheel track in
    the mud, we animate a rolling wheel along a path, calculating the impressions
    it makes at every frame. In the first frame that we animate we should make sure
    that the wheel is not touching the floor plane that will be distorted because
    if a vertex of the floor plane is inside the wheel and close to the inner rim,
    it will be moved to the closest vertex on that rim. If the wheel rolls slowly,
    this vertex will stay close to that inner rim and will thereby be effectively
    glued to that moving inner rim, ripping up the floor plane in the process. The
    same disruptive process may occur if the target object is very small compared
    to the source mesh or moving very fast. In these circumstances a vertex may penetrate
    the target object so fast that the closest vertex will not be on the leading surface
    making the impression but somewhere else in the target which will result in vertices
    being pulled outward instead of pushed inward. In the illustration of the rolling
    tractor tire, we carefully positioned the tire at frame one to sit just to the
    right of the subdivided plane before we key framed the rolling motion towards
    the left. The picture shown is taken at frame 171 without any smoothing or materials
    applied to the plane.
  prefs: []
  type: TYPE_NORMAL
- en: '![Calculating an impression](img/0400-05-08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we learned how to link change to the progress of the animation
    frames and how to associate state information with an object. We also saw how
    to change layers, for example to render an object invisible. Specifically we saw:'
  prefs: []
  type: TYPE_NORMAL
- en: What script links and space handlers are
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to perform activities on each frame change in an animation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to associate additional information with an object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to make an object appear or disappear by changing lay or changing its transparency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to implement a scheme to associate a different mesh with an object on each
    frame
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to augment the functionality of the 3DView
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next up: adding shape keys and IPOs.'
  prefs: []
  type: TYPE_NORMAL
