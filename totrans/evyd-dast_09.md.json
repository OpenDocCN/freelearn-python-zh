["```py\n    public Int16 Data; \n    public Node Left; \n    public Node Right; \n\n```", "```py\n    public List<Node> Children \n    { \n        get \n        { \n            List<Node> children = new List<Node>(); \n            if (this.Left != null)  \n            { \n                children.Add(this.Left); \n            } \n            if (this.Right != null)  \n            { \n                children.Add(this.Right); \n            } \n            return children; \n        } \n    } \n\n```", "```py\n    public Node(Int16 data) \n    { \n        this.Data = data; \n    } \n\n```", "```py\n    public bool InsertData(Int16 data) \n    { \n        Node node = new Node (data); \n        return this.InsertNode(node); \n    } \n\n    public bool InsertNode(Node node) \n    { \n        if (node == null || node.Data == this.Data) \n        { \n            return false; \n        } \n        else if (node.Data < this.Data)  \n        { \n            if (this.Left == null)  \n            { \n                this.Left = node; \n                return true; \n            }  \n            else  \n            { \n                return this.Left.InsertNode(node); \n            } \n       } \n       else \n       { \n           if (this.Right == null)  \n           { \n                this.Right = node; \n                return true; \n           }   \n           else  \n           { \n               return this.Right.InsertNode(node); \n           } \n        } \n    } \n\n```", "```py\n    public bool Graft(Node node) \n    { \n        if (node == null)  \n        { \n            return false; \n        } \n\n        List<Node> nodes = node.ListTree(); \n        foreach (Node n in nodes)  \n        { \n            this.InsertNode(n); \n        } \n\n        return true; \n    } \n\n```", "```py\n    public Node RemoveData(Int16 data) \n    { \n        Node node = new Node (data); \n        return this.RemoveNode(node); \n    } \n\n    public Node RemoveNode(Node node) \n    { \n        if (node == null) \n        { \n            return null; \n        } \n\n        Node retNode; \n        Node modNode; \n        List<Node> treeList = new List<Node>(); \n\n        if (this.Data == node.Data) \n        { \n            //Root match \n            retNode = new Node(this.Data); \n            modNode = this; \n            if (this.Children.Count == 0)  \n            { \n                return this; //Root has no childen \n            } \n        } \n        else if (this.Left.Data == node.Data)  \n        { \n            retNode = new Node(this.Left.Data); \n            modNode = this.Left; \n        }   \n        else if (this.Right.Data == node.Data) \n        { \n            retNode = new Node(this.Right.Data); \n            modNode = this.Right; \n       } \n       else  \n       { \n           foreach (Node child in this.Children)  \n           { \n               if (child.RemoveNode(node) != null)  \n               { \n                   return child; \n               } \n           } \n\n           //No match in tree \n           return null;  \n       } \n\n       //Reorder the tree \n       if (modNode.Left != null)  \n       { \n            modNode.Data = modNode.Left.Data; \n            treeList.AddRange(modNode.Left.ListTree()); \n            modNode.Left = null; \n        }  \n        else if (modNode.Right != null)  \n        { \n            modNode.Data = modNode.Right.Data; \n            treeList.AddRange(modNode.Right.ListTree()); \n            modNode.Right = null; \n        }  \n        else  \n        { \n            modNode = null; \n        } \n\n        foreach (Node n in treeList)  \n        { \n            modNode.InsertNode(n); \n        } \n\n        //Finished \n        return retNode; \n    } \n\n```", "```py\n    public Node Prune(Node root) \n    { \n        Node matchNode; \n        if (this.Data == root.Data) \n        { \n            //Root match \n            Node b = this.CopyTree(); \n            this.Left = null; \n            this.Right = null; \n            return b; \n        } \n        else if (this.Left.Data == root.Data)  \n        { \n            matchNode = this.Left; \n        }  \n        else if (this.Right.Data == root.Data) \n        { \n            matchNode = this.Right; \n        } \n        else  \n        { \n            foreach (Node child in this.Children)  \n            { \n                if (child.Prune(root) != null)  \n                { \n                    return child; \n                } \n            } \n\n            //No match in tree \n            return null;  \n        } \n\n        Node branch = matchNode.CopyTree(); \n        matchNode = null; \n\n        return branch; \n    } \n\n```", "```py\n    public Node FindData(Int16 data) \n    { \n        Node node = new Node (data); \n        return this.FindNode(node); \n    } \n\n    public Node FindNode(Node node) \n    { \n        if (node.Data == this.Data)  \n        { \n            return this; \n        } \n\n        foreach (Node child in this.Children)  \n        {  \n            Node result = child.FindNode(node); \n            if (result != null)  \n            { \n                return result; \n            } \n        } \n\n        return false; \n    } \n\n```", "```py\n    public Node CopyTree() \n    { \n        Node n = new Node (this.Data); \n        if (this.Left != null) \n        { \n            n.Left = this.Left.CopyTree(); \n        } \n\n        if(this.Right != null) \n        { \n            n.Right = this.Right.CopyTree(); \n        } \n        return n; \n    } \n\n```", "```py\n    public List<Node> ListTree() \n    { \n        List<Node> result = new List<Node>(); \n        result.Add(new Node(this.Data()); \n        foreach (Node child in this.Children) \n        { \n            result.AddRange(child.ListTree()); \n        } \n        return result; \n    } \n\n```", "```py\n    public int Data; \n    public Node left; \n    public Node right; \n\n    public List<Node> getChildren() \n    { \n        List<Node> children = new LinkedList<Node>(); \n        if (this.Left != null) \n        { \n            children.add(this.Left); \n        } \n        if (this.Right != null) \n        { \n            children.add(this.Right); \n        } \n        return children; \n    } \n\n```", "```py\n    public Node(int data) \n    { \n        this.Data = data; \n    } \n\n```", "```py\n    public boolean insertData(int data) \n    { \n        Node node = new Node (data); \n        return this.insertNode(node); \n    } \n\n    public boolean insertNode(Node node) \n    { \n        if (node == null || node.Data == this.Data) \n        { \n            return false; \n        } \n        else if (node.Data < this.Data) \n        { \n            if (this.Left == null) \n            { \n                this.Left = node; \n                return true; \n            } \n            else \n            { \n                return this.Left.insertNode(node); \n            } \n        } \n        else \n        { \n            if (this.Right == null) \n            { \n                this.Right = node; \n                return true; \n            } \n            else \n            { \n                return this.Right.insertNode(node); \n            } \n        } \n    } \n\n```", "```py\n    public boolean graft(Node node) \n    { \n        if (node == null) \n        { \n            return false; \n        } \n\n        List<Node> nodes = node.listTree(); \n        for (Node n : nodes) \n        { \n            this.insertNode(n); \n        } \n        return true; \n    } \n\n```", "```py\n    public Node removeData(int data) \n    { \n        Node node = new Node(data); \n        return this.removeNode(node); \n    } \n\n    public Node removeNode(Node node) \n    { \n        if (node == null) \n        {   \n            return null; \n        } \n\n        Node retNode; \n        Node modNode; \n        List<Node> treeList = new LinkedList<Node>(); \n\n        if (this.Data == node.Data) \n        { \n            //Root match \n            retNode = new Node(this.Data); \n            modNode = this; \n            if (this.getChildren().size() == 0) \n            { \n                return this; //Root has no childen \n            } \n        } \n        else if (this.Left.Data == node.Data) \n        { \n            //Match found \n            retNode = new Node(this.Left.Data); \n            modNode = this.Left; \n        } \n        else if (this.Right.Data == node.Data) \n        { \n            //Match found \n            retNode = new Node(this.Right.Data); \n            modNode = this.Right; \n        } \n        else \n        { \n            for (Node child : this.getChildren()) \n            { \n                if (child.removeNode(node) != null) \n                { \n                    return child; \n                } \n            } \n\n            //No match in tree \n            return null; \n        } \n\n        //Reorder the tree \n        if (modNode.Left != null) \n        { \n            modNode.Data = modNode.Left.Data; \n            treeList.addAll(modNode.Left.listTree()); \n            modNode.Left = null; \n        } \n        else if (modNode.Right != null) \n        { \n            modNode.Data = modNode.Right.Data; \n            treeList.addAll(modNode.Right.listTree()); \n            modNode.Right = null; \n        } \n        else \n        { \n            modNode = null; \n        } \n\n        for (Node n : treeList) \n        { \n            modNode.insertNode(n); \n        } \n\n        //Finished \n        return retNode; \n    } \n\n```", "```py\n    public Node prune(Node root) \n    { \n        if (root == null) \n        { \n            return null; \n        } \n\n        Node matchNode; \n        if (this.Data == root.Data) \n        { \n            //Root match \n            Node b = this.copyTree(); \n            this.Left = null; \n            this.Right = null; \n            return b; \n        } \n        else if (this.Left.Data == root.Data) \n        { \n            matchNode = this.Left; \n        } \n        else if (this.Right.Data == root.Data) \n        { \n            matchNode = this.Right; \n        } \n        else \n        { \n            for (Node child : this.getChildren()) \n            { \n                if (child.prune(root) != null) \n                { \n                    return child; \n                } \n            } \n\n            //No match in tree \n            return null; \n        }  \n\n        Node branch = matchNode.copyTree(); \n        matchNode = null; \n\n        return branch; \n    } \n\n```", "```py\n    public Node findData(int data) \n    { \n        Node node = new Node (data); \n        return this.findNode(node); \n    } \n\n    public Node findNode(Node node) \n    { \n        if (node.Data == this.Data) \n        { \n            return this; \n        } \n\n        for (Node child : this.getChildren()) \n        { \n            Node result = child.findNode(node); \n            if (result != null) \n            { \n                return result; \n            } \n        } \n\n        return null; \n    } \n\n```", "```py\n    public Node copyTree() \n    { \n        Node n = new Node(this.Data); \n        if (this.Left != null) \n        { \n            n.Left = this.Left.copyTree(); \n        } \n\n        if(this.Right != null) \n        { \n            n.Right = this.Right.copyTree(); \n        } \n        return n; \n    } \n\n```", "```py\n    public List<Node> listTree() { \n        List<Node> result = new LinkedList<Node>(); \n        result.add(new Node(this.Data)); \n        for (Node child : this.getChildren()) \n        { \n            result.addAll(child.listTree()); \n        } \n        return result; \n    } \n\n```", "```py\n    -(instancetype)initNodeWithData:(NSInteger)data \n    { \n        if (self = [super init]) \n        { \n            _data = data; \n        } \n        return self; \n    } \n\n```", "```py\n    -(NSInteger)data \n    { \n        return _data; \n    } \n\n    -(EDSNode*)left \n    { \n        return _left; \n    } \n\n    -(EDSNode*)right \n    { \n        return _right; \n    } \n\n    -(NSArray*)children \n    { \n        return [NSArray arrayWithObjects:_left, _right, nil]; \n    } \n\n```", "```py\n    -(BOOL)insertData:(NSInteger)data \n    { \n        EDSNode *node = [[EDSNode alloc] initNodeWithData:data]; \n        return [self insertNode:node]; \n    } \n\n    -(BOOL)insertNode:(EDSNode*)node \n    { \n        if (!node || [self findNode:node]) \n        { \n            return NO; \n        } \n        else if (node.data < _data) \n        { \n            if (!_left) \n            { \n                _left = node; \n                return YES; \n            } \n            else \n            { \n                return [_left insertNode:node]; \n            } \n        } \n        else \n        { \n            if (!_right) \n            { \n                _right = node; \n                return YES; \n            }  \n            else  \n            { \n                return [_right insertNode:node]; \n            } \n        } \n    } \n\n```", "```py\n    -(BOOL)graft:(EDSNode*)node \n    { \n        if (!node) \n        { \n            return NO; \n        } \n\n        NSArray *nodes = [node listTree]; \n        for (EDSNode *n in nodes) \n        { \n            [self insertNode:n]; \n        } \n\n        return true; \n    } \n\n```", "```py\n    -(EDSNode*)removeData:(NSInteger)data \n    { \n        EDSNode *node = [[EDSNode alloc] initNodeWithData:data]; \n        return [self removeNode:node]; \n    } \n\n    -(EDSNode*)removeNode:(EDSNode*)node \n    { \n        if (!node) \n        { \n            return NO; \n        } \n\n        EDSNode *retNode; \n        EDSNode *modNode; \n        NSMutableArray *treeList = [NSMutableArray array]; \n\n        if (self.data == node.data) \n        { \n            //Root match \n            retNode = [[EDSNode alloc] initNodeWithData:self.data]; \n            modNode = self; \n            if ([self.children count] == 0) \n            { \n                return self; //Root has no childen \n            } \n        } \n        else if (_left.data == node.data) \n        { \n            //Match found \n            retNode = [[EDSNode alloc] initNodeWithData:_left.data]; \n            modNode = _left; \n        } \n        else if (_right.data == node.data) \n        { \n            //Match found \n            retNode = [[EDSNode alloc] initNodeWithData:_right.data]; \n            modNode = _right; \n        } \n        else \n        { \n            for (EDSNode *child in self.children) \n            { \n                if ([child removeNode:node]) \n                { \n                    return child; \n                } \n            } \n\n            //No match in tree \n            return nil; \n        } \n\n        //Reorder the tree \n        if (modNode.left) \n        { \n            modNode.data = modNode.left.data; \n            [treeList addObjectsFromArray:[modNode.left listTree]]; \n            modNode.left = nil; \n        } \n        else if (modNode.right) \n        { \n            modNode.data = modNode.right.data; \n            [treeList addObjectsFromArray:[modNode.right listTree]]; \n            modNode.right = nil; \n        }   \n        else  \n        { \n            modNode = nil; \n        } \n\n        for (EDSNode *n in treeList) \n        { \n            [modNode insertNode:n]; \n        } \n\n        //Finished \n        return retNode; \n    } \n\n```", "```py\n    -(EDSNode*)prune:(EDSNode*)root \n    { \n        if (!root) \n        { \n            return nil; \n        } \n\n        EDSNode *matchNode; \n        if (self.data == root.data) \n        { \n            //Root match \n            EDSNode *b = [self copyTree]; \n            self.left = nil; \n            self.right = nil; \n            return b; \n        } \n        else if (self.left.data == root.data) \n        { \n            matchNode = self.left; \n        } \n        else if (self.right.data == root.data) \n        { \n            matchNode = self.right; \n        } \n        else \n        { \n            for (EDSNode *child in self.children) \n            { \n                if ([child prune:root]) \n                { \n                    return child; \n                } \n            } \n\n            //No match in tree \n            return nil; \n        } \n\n        EDSNode *branch = [matchNode copyTree]; \n        matchNode = nil; \n\n        return branch; \n    } \n\n```", "```py\n    -(EDSNode*)findData:(NSInteger)data \n    { \n        EDSNode *node = [[EDSNode alloc] initNodeWithData:data]; \n        return [self findNode:node]; \n    } \n\n    -(EDSNode*)findNode:(EDSNode*)node \n    { \n        if (node.data == self.data) \n        { \n            return self; \n        } \n\n        for (EDSNode *child in self.children) \n        { \n            EDSNode *result = [child findNode:node]; \n            if (result) \n            { \n                return result; \n            } \n        } \n\n        return nil; \n    } \n\n```", "```py\n    -(EDSNode*)copyTree \n    { \n        EDSNode *n = [[EDSNode alloc] initNodeWithData:self.data]; \n        if (self.left) \n        { \n            n.left = [self.left copyTree]; \n        } \n\n        if(self.right) \n        { \n            n.right = [self.right copyTree]; \n        } \n        return n; \n    } \n\n```", "```py\n    -(NSArray*)listTree \n    { \n        NSMutableArray *result = [NSMutableArray array]; \n        [result addObject:[[EDSNode alloc] initNodeWithData:self.data]]; \n        for (EDSNode *child in self.children) { \n            [result addObjectsFromArray:[child listTree]]; \n        } \n        return [result copy]; \n    } \n\n```", "```py\n    public var data: Int \n    public var left: Node? \n    public var right: Node? \n\n    public var children: Array<Node> { \n        return [left!, right!] \n    } \n\n```", "```py\n    public init (nodeData: Int) \n    { \n        data = nodeData \n    } \n\n```", "```py\n    public func insertData(data: Int) -> Bool \n    { \n        return insertNode(node: Node(nodeData:data)) \n    } \n\n    public func insertNode(node: Node?) -> Bool \n    { \n        if (node == nil) \n        { \n            return false \n        } \n\n        if ((findNode(node: node!)) != nil) \n        { \n            return false \n        } \n        else if (node!.data < data) \n        { \n            if (left == nil) \n            { \n                left = node \n                return true \n            } \n            else \n            { \n                return left!.insertNode(node: node) \n            } \n        } \n        else \n        { \n            if (right == node) \n            { \n                right = node \n                return true \n            } \n            else \n            { \n                return right!.insertNode(node: node) \n            } \n        } \n    } \n\n```", "```py\n    public func graft(node: Node?) -> Bool \n    { \n        if (node == nil) \n        { \n            return false \n        } \n\n        let nodes: Array = node!.listTree() \n        for n in nodes \n        { \n            self.insertNode(node: n) \n        } \n\n        return true \n    } \n\n```", "```py\n    public func removeData(data: Int) -> Node? \n    { \n        return removeNode(node: Node(nodeData:data)) \n    } \n\n    public func removeNode(node: Node?) -> Node? \n    { \n        if (node == nil) \n        { \n            return nil \n        } \n\n        var retNode: Node \n        var modNode: Node? \n        var treeList = Array<Node>() \n\n        if (self == node!) \n        { \n            //Root match \n            retNode = Node(nodeData: self.data) \n            modNode = self \n            if (children.count == 0) \n            { \n                return self //Root has no childen \n            } \n        } \n        else if (left! == node!) \n        { \n            //Match found \n            retNode = Node(nodeData: left!.data) \n            modNode = left! \n        } \n        else if (right! == node!) \n        { \n            //Match found \n            retNode = Node(nodeData: right!.data) \n            modNode = right! \n        } \n        else \n        { \n            for child in self.children \n            { \n                if (child.removeNode(node: node) != nil) \n                { \n                    return child \n                } \n            } \n\n            //No match in tree \n            return nil \n        } \n\n        //Reorder the tree \n        if ((modNode!.left) != nil) \n        { \n            modNode! = modNode!.left! \n            treeList = modNode!.left!.listTree() \n            modNode!.left = nil \n        } \n        else if ((modNode!.right) != nil) \n        { \n            modNode! = modNode!.right! \n            treeList = modNode!.right!.listTree() \n            modNode!.right = nil \n        }  \n        else  \n        { \n            modNode = nil \n        } \n\n        for n in treeList \n        { \n            modNode!.insertNode(node: n) \n        } \n\n        //Finished \n        return retNode \n    } \n\n```", "```py\n    public func prune(root: Node?) -> Node? \n    { \n        if (root == nil) \n        { \n            return nil \n        } \n\n        var matchNode: Node? \n        if (self == root!) \n        { \n            //Root match \n            let b = self.copyTree() \n            self.left = nil \n            self.right = nil \n            return b \n        } \n        else if (self.left! == root!) \n        { \n            matchNode = self.left! \n        } \n        else if (self.right! == root!) \n        { \n            matchNode = self.right! \n        } \n        else \n        { \n            for child in self.children \n            { \n                if (child.prune(root: root!) != nil) \n                { \n                    return child \n                } \n            } \n\n            //No match in tree \n            return nil; \n        } \n\n        let branch = matchNode!.copyTree() \n        matchNode = nil \n\n        return branch \n    } \n\n```", "```py\n    public func findData(data: Int) -> Node? \n    { \n        return findNode(node: Node(nodeData:data)) \n    } \n\n    public func findNode(node: Node) -> Node? \n    { \n        if (node == self) \n        { \n            return self \n        } \n\n        for child in children \n        { \n            let result = child.findNode(node: node) \n            if (result != nil) \n            { \n                return result \n            } \n        } \n\n        return nil \n    } \n\n```", "```py\n    public func copyTree() -> Node \n    { \n        let n = Node(nodeData: self.data) \n\n        if (self.left != nil) \n        { \n            n.left = self.left!.copyTree() \n        } \n\n        if(self.right != nil) \n        { \n            n.right = self.right!.copyTree() \n        } \n\n        return n \n    } \n\n```", "```py\n    public func listTree() -> Array<Node> \n    { \n        var result = Array<Node>() \n        result.append(self) \n        for child in children \n        { \n            result.append(contentsOf: child.listTree()) \n        } \n        return result \n    } \n\n```", "```py\n    public func == (lhs: Node, rhs: Node) -> Bool { \n        return (lhs.data == rhs.data) \n    } \n\n```", "```py\n    public static int Fibonacci(int n)   \n    {   \n        if (n == 0) return 0; //Base case   \n        if (n == 1) return 1; //Base case   \n        return Fibonacci(n - 1) + Fibonacci(n - 2);   \n    } \n\n```"]