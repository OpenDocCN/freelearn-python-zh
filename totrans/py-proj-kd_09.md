# 第九章。迷你网球

在上一章中，你学习了 pygame 中的基本模块、类和函数。你学习这些函数是为了能够构建一个名为**迷你网球**的新游戏。迷你网球将是一款双人游戏，使用键盘上的按键来控制两个挡板，挡板来回击球。虽然当你观看这个游戏时，它看起来很简单，但制作一个可玩的游戏需要很多不同的部分。

# 游戏编程原则简介

本章中有很多游戏编程原则适用于我们的项目。首先，记住空间中对象的运动是我们创造的幻觉。与现实不同，我们创建的对象看起来会移动，因为我们会在不同的地方定期绘制和重绘对象。

我们讨论的另一个原则是游戏循环。游戏循环非常重要，因为它控制着游戏中需要发生的所有事情，包括对象的移动和重绘。游戏循环的时间安排很重要，因为这会告诉计算机游戏循环需要运行多少次。每次游戏循环的运行也被称为**帧**，游戏循环运行的速率被称为**帧率**。

最后，考虑到玩家如何与游戏互动是游戏设计的一个重要部分。这意味着我们将考虑玩家如何使用键盘，以及他们的分数如何存储在程序的内存中并在屏幕的某个位置显示。

# 游戏计划

在我们开始编写任何代码行之前，我们需要打开我们的 Python 壳、终端和文本编辑器。在我们编写和测试本章中的代码行时，我们将在这三个工具之间来回切换。调整你的显示器，以便你可以在每个窗口之间舒适地切换。

在设置好你的工作区后，转到文本编辑器窗口。我们将使用注释在文本编辑器窗口中概述我们的游戏，这样我们可以更好地组织我们的工作。

# 创建游戏部分的概述

我们将分四个部分来制作这个游戏。游戏的部分如下：

+   第一部分：导入、全局变量和绘图

+   第二部分：移动挡板

+   第三部分：移动球

+   第四部分：绘制屏幕和跟踪分数

在你的文本编辑器中创建一个名为`tiny.py`的文件。然后，将以下行输入到你的`tiny.py`文件中：

```py
# imports, globals and drawing

# moving the paddles
# moving the ball
# keeping score

```

在输入前面的行之后，保存你的文件。现在这个文件提供了一个创建游戏所需工作的概述。你的文件看起来会是这样：

![创建游戏部分的概述](img/B04681_09_01.jpg)

我们正在遵循一种特定的方法来制作这款迷你网球游戏。需要注意的是，编写这款游戏代码有*许多*可能的方式。我们在这里所采用的方法使我们能够回顾在这本书中学到的所有概念。在本章的结尾以及下一章中，我们将讨论一些更高级（且更简洁）的编码技术，这些技术可以帮助你使这款游戏执行更多操作，并且更有效率。不过，现在，让我们开始这款游戏吧！

# 第一部分 – 导入、全局变量和绘图

在本节中，我们将编写所有代码来设置游戏的不同部分。这包括导入库、定义所有全局变量，以及告诉计算机如何绘制屏幕、球和挡板。

## 导入库

我们编写的第一行代码将用于将必要的库导入到游戏中，包括 pygame。在游戏中，我们将使用三个库：pygame、math 和 random。正如我们在上一章所讨论的，pygame 使我们能够在游戏中添加视觉元素。Python 附带的标准库 random，使我们能够在游戏中选择和使用随机数。Python 附带的 math 库允许进行浮点数运算。要在你的代码中使用这些模块和库，请在`tiny.py`文件中#导入、全局变量和绘图注释下面输入以下几行代码：

```py
import pygame
import random
import time

```

### 小贴士

确保现在你已经添加了一些新行，保存你的`tiny.py`文件。养成尽可能频繁保存代码的习惯。

如果代码中的注释有助于你组织思路，你可以添加注释。现在，我们还将初始化 pygame，以便我们能够使用所有功能，包括启动屏幕、绘制图形和运行游戏循环。要初始化 pygame，我们使用`init()`函数。要初始化它，在你的导入下面输入以下两行代码：

```py
 # initialize pygame
 pygame.init()

```

使用`pygame.init()`启动 pygame 进程，pygame 进程将持续运行，直到玩家退出 pygame 时程序停止运行。这使我们能够在整个游戏中访问 pygame 内部的所有内容。随着我们继续编写游戏，你会看到这一点有多么重要。现在，再次保存你的`tiny.py`文件：

![导入库](img/B04681_09_02.jpg)

## 引入全局变量

现在我们已经导入了所需的库，我们将为游戏的一些部分创建全局变量。提醒一下，全局变量，或称全局变量，是我们可以在整个文件中使用的变量。我们将为所有希望使用的颜色设置全局变量。我们还为屏幕、挡板和球设置了全局变量。

## 定义颜色

首先，我们将为每种颜色创建全局变量。正如我们在第八章中学习的，颜色，在*pygame*中，由括号内列出的三个不同的数字表示，也称为元组。为了避免重复编写这些数字，我们将为每种颜色创建一个全局变量，这样我们就可以在整个游戏中使用所有颜色的名称。

根据您喜欢的颜色，您可能希望为所有颜色或仅为一小部分创建全局变量。实际上，决定添加哪些颜色到您的代码中完全取决于您。以下是一份您可能在游戏中希望使用的常见颜色列表。您应该将每种颜色的代码添加得与这里显示的完全一致：

```py
 red = (255, 0, 0)
 orange = (255, 127, 0)
 yellow = (255, 255, 0)
 green: (0, 255, 0)
 blue = (0, 0, 255)
 violet = (127, 0, 255)
 brown = (102, 51, 0)
 black = (0, 0, 0)
 white = (255, 255, 255)

```

上述列表显示了您可以在游戏代码中包含的基本颜色。如果您想包含更高级的颜色，您可以在搜索引擎中搜索`rgb 颜色代码表`，例如 Google，您会发现每种颜色都有不同的变化，您可以根据自己的喜好进行更改，例如浅蓝色或深蓝色。一旦您将所有颜色更改到您喜欢的样子，请确保保存您的作品：

![定义颜色](img/B04681_09_03.jpg)

## 调整屏幕大小

我们还将使用全局变量来定义屏幕显示的部分。这使我们能够显示主屏幕的大小、颜色和文本。以下是颜色全局变量；我们将添加以下代码行以定义屏幕的宽度和高度：

```py
 # screen globals
 screen_width = 600
 screen_height = 400

```

现在我们已经创建了`screen_width`和`screen_height`变量，我们可以在整个代码中使用这些变量，这使得我们的代码更容易阅读。此外，如果我们决定更改屏幕宽度或高度，我们可以在这个全局变量中逐个更改，而我们的所有代码仍然可以正常运行。

## 绘制屏幕

因此，`screen_width`和`screen_height`变量是 pygame 设置实际游戏屏幕所需的基本信息。pygame 有一个名为`pygame.display.set_mode()`的函数，它接受`screen_width`和`screen_height`变量来设置屏幕显示。现在，编写`pygame.display.set_mode ((screen_width, screen_height))`确实很长，尤其是如果我们一直这样做的话。相反，我们将将其设置为名为`game_screen`的全局变量：

```py
 game_screen = pygame.display.set_mode((screen_width, screen_height))

```

## 创建屏幕标签

我们接下来使用的函数集将设置屏幕顶部的文本和游戏屏幕的字体。第一行代码定义了我们想要看到的文本字符串，在下一行中，我们定义了字体和大小。如果字体和大小不可用，字体将默认使用系统上最初设置的字体。这对于 Windows、Mac 和 Linux 系统都是正确的：

```py
 pygame.display.set_caption("Tiny Tennis")
 font = pygame.font.SysFont("monospace", 75)

```

因此，我们现在已经设置了创建游戏屏幕所需的所有基本变量。保存您的作品，当您准备好时，继续创建我们需要的球、挡板和计分的全局变量。您的屏幕代码应该看起来像以下代码示例：

![创建屏幕标签](img/B04681_09_04.jpg)

## 球 - 起始位置

在“迷你网球”游戏中，球是游戏最重要的部分之一。我们需要做很多事情来让它工作。首先，我们需要给球一些全局特性，以便它可以被绘制和重绘，从而产生运动的错觉。

首先，我们需要设置球的 *x*，*y* 坐标。通过为这个坐标创建一个全局变量，我们可以告诉计算机在哪里重绘球，而无需为球的每次移动编写特殊的代码。我们将设置 `x` 和 `y` 的默认值，使球从屏幕中心开始。将以下几行代码写入你的 `tiny.py` 文件：

```py
 # ball globals
 ball_x = int(screen_width / 2)
 ball_y = int(screen_height / 2)

```

## 球 - 设置速度和方向

现在我们已经告诉球默认从屏幕中心开始，我们需要通过给出移动的 `x` 和 `y` 坐标来告诉球移动多远：

```py
 ball_xv = 3
 ball_yv = 3

```

`ball_xv = 3` 表示球每次重绘时将在 *x* 轴上移动 `3` 像素。`ball_yv = 3` 表示球每次屏幕重绘时将在 *y* 轴上移动 `3` 像素。这很好，因为它将帮助我们保持球以我们喜欢的速度和方向移动。在这里，*v = 速度*，这是速度（大小）和方向（*x,y*）的量。所以当我们说 `ball_xv = 3` 时，我们实际上是在说 *球每次屏幕重绘时沿 x 轴以 3 像素的速度移动*。

## 球 - 设置大小

我们将要定义的关于球最后的东西是它的半径。半径是球总宽度的二分之一，如像素所示。通过设置半径，我们设置了大小。将以下代码行写入你的 `tiny.py` 文件以表示球半径：

```py
 ball_r = 20

```

现在我们已经定义了球的特点，请确保保存文件。没有人愿意重写正在工作的代码行！看看这个代码段的例子：

![球 - 设置大小](img/B04681_09_05.jpg)

## 球拍 - 起始位置和大小

在我们的游戏中，我们将有两个球拍。回想一下，在本章的开头，提到我们做某些事情的方式不止一种。有更高级的方法来制作球拍，但了解球拍的每个部分非常重要，因此我们将非常简单地分解我们的代码。一旦你完成了这个游戏，你可以做一些关于创建对象的研究，并尝试将球拍作为对象创建。

我们将给我们的球拍四个特性：*x* 轴上的起始位置，*y* 轴上的起始位置，宽度和高度。这些数字都是像素表示。在球的全局变量下方，在第 34 行，将以下五行代码添加到你的 `tiny.py` 文件中：

```py
 # draw paddle 1
 paddle1_x = 10
 paddle1_y = 10
 paddle1_w = 25
 paddle1_h = 100

```

你可能已经注意到我们编写的代码是针对`paddle1`的。Tiny 网球需要两个挡板。我们希望给每个玩家一个公平的开始，所以我们将创建`paddle2`，使其大小相等，但位于`paddle1`的对侧。为了创建第二个挡板，从第 40 行开始，写下以下五行代码：

```py
 # draw paddle 2
 paddle2_x = screen_width - 35
 paddle2_y = 10
 paddle2_w = 25
 paddle2_h = 100

```

你会注意到挡板 2 的`x`坐标结合了`screen_width`变量，这是最大的`x`坐标数（`600`），然后减去挡板的宽度（`25`）加上挡板 1 的`x`坐标值（`10`）。这种数学运算使我们能够确保挡板与屏幕右侧的距离与屏幕左侧的距离相同。如果你感到困惑，将代码复制到你的文件中并保存。你可以调整数字并查看挡板如何根据每个值变化：

![Paddles – starting location and size](img/B04681_09_06.jpg)

# 初始化分数

为了有一个分数，我们将为每个玩家创建一个变量，该变量从默认分数零开始。由于这是一个全局变量，就像其他整数一样，它将在游戏循环运行时改变。现在，我们只需要为每个玩家提供占位符。因此，从第 46 行开始，将以下代码行添加到你的游戏中：

```py
 # initialize score
 player1_score = 0
 player2_score = 0

```

我们现在已经创建了所有必要的全局变量，以便编写易于理解的代码。记住，这些被称为全局变量，因为它们可以在整个代码文件中使用。保存你的文件。然后，将你的代码与这个截图中的完成代码进行比较：

![Initializing the score](img/B04681_09_07.jpg)

# 测试部分 1

现在我们已经导入了库，初始化了 pygame，并为颜色、屏幕、球和挡板创建了全局变量，我们可以运行我们的第一个测试来检查一切是否正常。为了测试游戏，你需要在终端/命令提示符中找到你保存`tiny.py`文件的目录。在早期的游戏中，我们在桌面上创建了此目录。一旦你导航到保存`tiny.py`的目录，你就可以从终端/命令提示符中运行以下命令来查看你的游戏进度：

```py
 python tiny.py

```

当你运行这个命令时，你应该会看到一个窗口弹出然后关闭。窗口不会保持打开，因为我们还没有编写运行游戏的任何代码；然而，如果代码运行且终端/命令提示符中没有错误，那么你可以有信心继续前进。

如果你的代码中有错误，现在是修复它们的好时机。一些可能发生的常见错误包括语法错误（使用错误的符号）、拼写错误（如拼写 Python 关键字错误）或尝试从错误的目录运行你的文件。如果你有错误，检查这些常见错误，并修复代码中的错误。

如果你遇到的不是上述常见错误之一，你总是可以通过进行网络搜索来提问，了解你遇到的问题。即使是经验丰富的开发者也很常见，他们会使用网络搜索来寻找帮助以修复错误，而且有许多网站和博客是由人们维护的，以帮助他人学习。

# 第二部分 – 移动球拍

现在我们终于可以编写将使我们的球拍出现在屏幕上并允许我们控制球拍的代码了。

这是我们有机会使用我们在前面章节中学到的逻辑和循环的地方。在像 Tiny Tennis 这样的游戏中，许多决策都非常快地做出。计算机擅长根据我们的指令做出快速决策。以下是下一节中将包含的代码部分：

+   创建 `while` 循环

+   键盘事件

我们将逐步编写这些代码，然后通过运行代码来测试是否有任何错误。建议你在开始编码之前阅读整个部分，以便知道可以期待什么。一旦你阅读完所有内容，乐趣就开始了！

## 循环前动作

在我们实际创建 `while` 循环之前，我们将编写两个动作。第一个是确保当光标移过游戏屏幕时，光标消失，这样就不会造成干扰。在 pygame 中有一个特殊的功能来实现这种行为：

```py
 pygame.mouse.set_visible(0)

```

通过将可见性设置为 `0`，我们使鼠标/光标对游戏不可见。由于我们不需要在游戏中使用鼠标，这样做对我们来说是可以接受的。

第二个动作是设置我们的 `while` 循环的全局变量。我们将把我们的主游戏循环变量命名为 `do_main`。我们将设置 `do_main = True`：

```py
 do_main = True

```

### 小贴士

记住，语法和大小写（大写或小写）很重要。注意 *大写* 字母 *T*，并确保完全按照它复制。记住，*True* 是一个布尔值，需要用大写 *T* 来书写。现在，我们已经准备好编写我们的 `while` 循环了。

## 创建 `while` 循环

我们的游戏循环将是一个 `while` 循环。我们将使用 `do_main` 作为我们的 `True` 语句。因此，你将会有另一行代码看起来像这样：

```py
 while do_main:

```

确保你在行的末尾放置一个冒号 (`:`)。此外，游戏循环中的所有其他代码行至少缩进一次，因为它们都需要在循环内运行才能执行。以下是 `while` 循环的截图：

![创建 `while` 循环](img/B04681_09_08.jpg)

## 移动球拍 – 键盘事件

`while` 循环中的第一组事件是键盘事件。这些事件发生在按键或一组按键被按下时。这些事件使用 `if`/`elif` 逻辑。所有这些事件至少缩进一个制表符，有些则缩进两个或更多制表符。记住，在 Python 中缩进是一种组织工具，有助于我们跟踪某些代码应该在何时运行。

注意截图中的第 54 行代码。在第 54 行，我们将创建一个名为 pressed 的变量，并将其设置为`pygame.key.get_pressed()`函数。这将给我们一个更短的函数引用。将此代码输入到第 54 行：

```py
 pressed = pygame.key.get_pressed()

```

在第 55 行，我们使用`pygame.key.set_repeat()`函数。这告诉计算机，一旦按下某个键，该键执行的动作应继续，直到用户松开该键。将下一行代码输入到你的`tiny.py`文件的第 55 行：

```py
 pygame.key.set_repeat()

```

现在我们已经设置了键盘事件的变量和特性，我们将创建第一个循环，一个用于查找玩家是否退出的`for`循环。使用`for`循环，我们将遍历使用`pygame.event.get()`函数找到的每个事件。如果事件是*QUIT*事件，则`while`循环将自动结束。你会注意到我们在这里也使用了我们的`if`逻辑，以便告诉计算机在找到退出事件时做出决定。为了创建这个`for`循环，你将编写以下代码行，从你的代码文件的第 56 行开始：

```py
 for event in pygame.event.get():
 if event.type == pygame.QUIT:
 do_main = False

```

现在我们已经告诉计算机如何以及何时结束`while`循环，我们可以告诉计算机在按下某些键时应该做什么。对于我们的 Tiny Tennis 游戏，我们需要分配键来退出游戏，以及控制 1 号和 2 号橡皮球的键。

### 注意

想要选择不同于本书中使用的键？你可以在 pygame 网站上找到如何使用每个键盘键的完整列表，网址为[`www.pygame.org/docs/ref/key.html`](http://www.pygame.org/docs/ref/key.html)。

## 退出游戏 – Esc 键

要退出游戏，我们将使用*Esc*键。你会注意到我们使用了 pressed 变量，后面跟着*Esc*键的键码。从第 60 行开始，输入以下两行代码：

```py
 if pressed[pygame.K_ESCAPE]:
 do_main = False

```

代码行数告诉计算机，如果按下*Esc*键，则`do_main`全局变量应设置为`False`。当`do_main`设置为布尔值`False`时，`while`循环将停止。我们将在稍后编写结束游戏的代码。

## 橡皮球控制 – 玩家 1

为了让玩家 1 的橡皮球向上移动，我们将使用*W*键。为了让玩家 1 的橡皮球向下移动，我们将使用*S*键。这些是非常典型的用于电脑游戏控制的键。注意哪些字母是大写，哪些是小写，并确保从第 63 行开始完全复制它们：

```py
 if pressed[pygame.K_w]:
 paddle1_y -= 5
 elif pressed[pygame.K_s]:
 paddle1_y += 5

```

## 橡皮球控制 – 玩家 2

玩家 2 也需要有键盘控制，以便在玩家 1 同时上下移动橡皮球时移动他的/她的橡皮球。这意味着我们必须为第二个橡皮球分配不同的键。对于这个游戏，我们使用上箭头键来移动 2 号橡皮球向上，使用下箭头键来移动 2 号橡皮球向下。将以下代码行输入到你的`tiny.py`文件中，从第 68 行开始：

```py
 if pressed[pygame.K_UP]:
 paddle2_y -= 5
 elif pressed[pygame.K_DOWN]:
 paddle2_y += 5

```

### 小贴士

保存你的工作！

# 增加和减少值（-= 和 +=）

你会注意到代码中的**-**= 和 **+**= 符号。这些符号用作增加或减少某个值值的快捷方式。在移动挡板的代码中，我们使用这些符号在按下挡板键时添加或减去值。 -= 和 += 符号对于每次用户移动挡板时设置正确的挡板位置都非常重要。

# 测试部分 2

是时候再次测试我们的代码了。在你的终端/命令提示符中，找到你保存`tiny.py`文件的目录。在早期的游戏中，我们在桌面上创建了此目录。一旦你导航到保存`tiny.py`的目录，你可以在终端/命令提示符中运行以下命令来查看你的游戏进度：

```py
 python tiny.py

```

在这次测试中，你将看到一个窗口打开，顶部写着**Tiny Tennis**，其他部分完全空白。请看以下截图：

![测试部分 2](img/B04681_09_09.jpg)

如果你遇到了错误，请记住检查你的代码是否有拼写错误、语法错误和大小写错误。

# 第三部分 – 移动球

现在我们已经编写并测试了挡板的代码，我们需要编写移动球的代码。我们将通过一些代码更改球的位置，并创建一个称为碰撞检测的东西。

## 移动球 – 更新位置

首先，我们需要根据我们在全局变量中设置的球的速度，不断计算球的`x`和`y`坐标。这允许我们在玩游戏的过程中不断更新。为了确保球的`x`和`y`坐标随着球的运动而更新，你将输入以下代码行，从第 74 行开始：

```py
 # location of ball is updated
 ball_x += ball_xv
 ball_y += ball_yv

```

## 碰撞检测

我们接下来的任务是编写一个称为**碰撞检测**的代码。这意味着我们可以编程让计算机知道两个物体何时相互碰撞。我们还可以告诉计算机当物体碰撞时我们希望它做什么。在 Tiny Tennis 中，我们想要检测三种类型的碰撞：

+   球与屏幕顶部和底部的碰撞

+   挡板与屏幕顶部和底部的碰撞

+   球与挡板的碰撞

### 球与屏幕顶部和底部的碰撞

接下来，我们将使用我们的`if`语句来定义如果球击中屏幕的顶部或底部会发生什么。基本上，我们希望球在击中屏幕的顶部或底部时弹回。从你的`tiny.py`文件的第 77 行开始输入以下代码：

```py
 # collision of ball with top/bottom of screen
 if ball_y - ball_r <= 0 or ball_y + ball_r >= screen_height:
 ball_yv *= -1

```

第一行，以`if`开头，基本上表示*如果从 y 坐标减去半径且结果小于或等于零，或者如果将半径加到 y 坐标且结果大于屏幕高度数（400），那么就对此采取行动*。

冒号之后的代码的第二行告诉我们该做什么：*球的 y 坐标速度应反向*。代码的第二行`ball_yv *= -1`意味着`y`坐标的速度被反转，因为它乘以了`-1`。任何数乘以`-1`都会变成其原始符号的相反数，在这种情况下，反转符号意味着反转球的方向。

那么，为什么这段代码能工作呢？让我们来思考一下。顶部的`y`坐标是零。如果球试图穿过顶部，它的`y`值将小于零，这意味着它将超出屏幕。为了使球保持在屏幕上，我们在`y`坐标值小于零时改变球的方向。

底部的`y`坐标是`400`。因此，如果球的`y`值大于`400`，那么我们就改变球的方向，让它向上移动。我们通过将球的速度乘以`-1`来实现这些方向变化，从而改变方向。

在继续之前，比较你的代码与以下代码：

![球与屏幕上下方的碰撞](img/B04681_09_10.jpg)

### 球拍与屏幕上下方的碰撞

我们希望球拍在达到屏幕的顶部或底部时停止。为了实现这一点，我们需要创建一个代码，它可以识别球拍的`y`值，然后阻止球拍移动超过创建屏幕边界的两个`y`值。这两个值是屏幕顶部的`0`和屏幕底部的`400`。将以下代码行复制到你的程序中，从第 81 行开始。确保你的缩进级别是正确的：

```py
 # collision of paddle with top/bottom of screen
 if paddle1_y < 0:
 paddle1_y = 0
 elif paddle1_y + paddle1_h > screen_height:
 paddle1_y = screen_height - paddle1_h

 if paddle2_y < 0:
 paddle2_y = 0
 elif paddle2_y + paddle2_h > screen_height:
 paddle2_y = screen_height - paddle2_h

```

这段代码与球代码的工作方式不同，因为我们不希望球拍在屏幕周围弹跳！相反，我们希望球拍在碰到屏幕的上下方时停止。所以，你会注意到，每当球拍 1 或球拍 2 超出屏幕的障碍（`0`和`400`），球拍值就会重置为*等于*边界值`0`或`400`，具体取决于*球拍的位置在哪里*（是在屏幕顶部还是底部？）。完成添加此代码后，保存你的工作。

### 球与球拍的碰撞

球与球拍的碰撞将决定球击中球拍时会发生什么。有两个球拍，如果你能添加一些使用井号`#`作为注释的代码来跟踪左侧球拍（球拍 1）和右侧球拍（球拍 2）的代码，这将很有帮助。

现在我们已经进行了一些碰撞检测，让我们考虑球和挡板。当球击中挡板时，我们想让球看起来像是从挡板弹回的。因此，我们需要确保球和挡板碰撞的结果是球反转并朝相反方向移动。这实际上是我们用来让球从屏幕边缘弹回的行为，但现在我们需要概述挡板 1 和挡板 2 的所有部分。将这些代码行复制到你的文件中：

```py
 # left paddle
 if ball_x < paddle1_x + paddle1_w and ball_y >= paddle1_y and ball_y <= paddle1_y + paddle1_h:
 ball_xv *= -1
 # right paddle
 if ball_x > paddle2_x and ball_y >= paddle2_y and ball_y <= paddle2_y + paddle2_h:
 ball_xv *= -1

```

看看这张截图，比较一下你的代码：

![球与挡板的碰撞](img/B04681_09_11.jpg)

# 测试 – 第三部分

你几乎完成了游戏的编写！现在是我们再次测试代码的时候了。在你的终端/命令提示符中，找到你保存`tiny.py`文件的目录。你可以从终端/命令提示符中运行以下命令来检查游戏到目前为止的进度：

```py
 python tiny.py

```

在这次测试中，如果一切正常，你的结果将与第二部分的测试相同。将打开一个空白屏幕，并被称为 Tiny Tennis。恭喜你！

如果你的程序在运行时出现一些错误，查看错误信息以检查你是否能找出问题所在。寻找语法错误、拼写错误、缩进错误或代码中的任何其他错误。确保你使用空格进行缩进，而不是制表符，否则你也可能会遇到问题。

# 第四部分 – 绘制屏幕并跟踪得分

因此，我们知道球会从屏幕的顶部和底部以及挡板弹回。然而，如果用户用挡板没有接住球，球会发生什么？玩家和他们的得分会发生什么变化？

在这个游戏部分，我们使用`x`坐标的位置来判断球是否在屏幕上，或者它是否已经过了挡板，现在在屏幕外。我们使用`if`语句告诉计算机该做什么。`x`轴的`0`坐标是屏幕的最左侧。如果球的`x`值小于`0`，那么另一边的玩家（玩家 2）得了一分，因为玩家 1 没有挡住球。如果你阅读代码行，你会注意到我们将`ball_x`和`ball_y`坐标重置为屏幕中心，以便新游戏可以开始。将以下四行代码复制到游戏中以放置此逻辑：

```py
 if ball_x <= 0:
 player2_score += 1
 ball_x = int(screen_width / 2)
 ball_y = int(screen_height / 2)

```

你会注意到接下来的四行代码几乎完全相同，只有两个变化。球的`x`值现在正在与最大屏幕宽度`600`进行比较。如果球的`x`值大于`600`，这意味着玩家没有接住球，球现在在屏幕外。现在，玩家 1 得分了，因为玩家 2 没有挡住球。为了确保这个逻辑也在游戏中，将以下四行代码复制到你的文件中：

```py
 elif ball_x >= screen_width:
 player1_score += 1
 ball_x = int(screen_width / 2)
 ball_y = int(screen_height / 2)

```

![第四部分 – 绘制屏幕和跟踪分数](img/B04681_09_12.jpg)

### 小贴士

确保你保存了你的工作！

## 渲染屏幕 – 显示发生了什么

我们需要编写的最后一部分代码是重绘屏幕和所有对象的代码，这样运动的画面就会看起来像真的发生了。接下来的几行代码绘制了我们游戏中的五个对象。没有必要使用变量名来绘制挡板、网或球，除非这样做确实使它们更容易找到，如果你想要修复或更改代码的这一部分。同样，这些代码行是缩进的，这样它们就位于 `while` 循环内部：

```py
 game_screen.fill(black)
 paddle_1 = pygame.draw.rect(game_screen, white, (paddle1_x, paddle1_y, paddle1_w, paddle1_h), 0)
 paddle_2 = pygame.draw.rect(game_screen, white, (paddle2_x, paddle2_y, paddle2_w, paddle2_h), 0)
 net = pygame.draw.line(game_screen, yellow, (300,5), (300,400))
 ball = pygame.draw.circle(game_screen, red, (ball_x, ball_y), ball_r, 0)

```

`game_screen.fill(black)` 代码使用我们的 `game_screen` 变量，并告诉 `fill()` 函数通过在括号中放入颜色 `black` 来使我们的屏幕变黑。你注意到我们在这一行代码中使用了两个全局变量 `game_screen` 和 `black` 吗？想象一下，如果没有这些变量，代码会变得多长。想象一下，它可能更难阅读和修改。

你会注意到 `pygame.draw.rect()` 函数被用来绘制挡板，因为它们只是矩形。挡板有以下特性：

+   游戏屏幕（告诉它们应该去哪里）

+   颜色

+   一个 `x` 坐标

+   一个 `y` 坐标（提供起始位置）

+   宽度

+   高度

如果你查看 `line()` 和 `circle()` 对象，你会注意到它们与矩形并没有太大的区别。它们都有 `game_screen` 和颜色属性。线对象接受定义线长、宽度和 *x* 值的参数。圆对象接受定义 `game_screen`、颜色和球特性的参数。由于我们在本章早期使用全局变量定义了球特性，因此我们可以在 `circle()` 代码中使用它们。

## 显示玩家分数

我们接下来的几行代码将在屏幕上绘制玩家分数：

```py
 score_text = font.render(str(player1_score) + " " + str(player2_score), 1, white)
 game_screen.blit(score_text, (screen_width / 2 - score_text.get_width() / 2, 10))

```

我们游戏分数代码的最上面一行提供了 `score_text` 变量的定义，该变量用于我们刚刚添加的代码的第二行。每次我们的屏幕重绘时，`game_screen.blit()` 函数都会复制我们的分数文本，因为如果两个玩家都没有错过球，分数文本可能长时间不会改变。

最后，`pygame.display.update()` 函数更新了程序存储的新信息所显示的图像。因为计算机的速度可以无限快于人类，所以我们添加了一个 `sleep` 选项，允许我们控制更新的间隔：

```py
 pygame.display.update()
 time.sleep(0.016666667)

```

# 结束程序

代码的最后一行将是结束 pygame 的初始化，这是我们代码开始时执行的。为了结束这个，我们将在代码的最外层缩进级别输入 `pygame.quit()`。这将放在 `while` 循环之外，这样它只会在 `while` 循环停止运行时发生：

```py
 pygame.quit()

```

一旦你输入了这些，你的最终游戏代码行应该看起来像这样：

![结束程序](img/B04681_09_13.jpg)

一旦你将你的代码与章节中的截图进行双重检查，确保保存你的`tiny.py`文件。现在你准备好真正对你的游戏进行测试了！

# 玩 Tiny 网球！

Tiny 网球最好的部分是你可以自己玩，这使得测试游戏和实验游戏的各个部分变得容易。现在，当你从你的终端运行文件时，应该会弹出一个看起来像这样的窗口：

![玩 Tiny 网球！](img/B04681_09_14.jpg)

球应该立即向屏幕的一侧或另一侧移动。你可以通过确保屏幕两侧的球拍能够击中球并且它们不会超出屏幕空间来测试游戏。你可以测试得分机制，确保适当的玩家在越过对方玩家时获得每击的分数。然后，你可以邀请其他人和你一起玩游戏。

如果你对游戏的部分不满意，你可以更改它们。例如，你可能会为球、球拍和屏幕选择不同的颜色。也许你希望球拍更长或更短，或者更薄。也许你想要通过改变半径来使球更大或更小。

你可能会决定想要球拍移动得更快，以便游戏更具挑战性，或者如果你正在为年幼的孩子设计游戏，你可能希望球拍移动得更慢。设计选择是出于许多原因，现在你有一个可玩的游戏，你可能会决定做出一些不同的设计决策。

你可以通过复制你的游戏代码并测试你的副本中的任何修改来测试你的决策。保留你工作代码的备份是个好主意，这样如果你编写了有错误的代码，你就有了一个可以返回并重新开始的地方。

# 摘要

恭喜你构建了你的第一个游戏！你学到了很多可以做的事情。然而，代码最伟大的地方在于，做任何事情都有很多种方法。有些方法更容易理解，但可能没有其他方法那么高效。有些代码非常高效，但可能不容易被其他程序员理解。最好的代码既容易理解，又以尽可能高效的方式编写。

在上一章中，我们使用了一种易于理解但可能不是最有效率的代码组合。这是因为我们在学习 pygame 中的许多新原则，而且像碰撞检测这样的东西可能很难编写。在你玩了几款游戏之后，你可能会决定以不同的方式做事！

在下一章中，我们将回顾这本书中学到的所有内容，我们还将看看 Python 在世界上的一些其他用途，因为 Python 是一种非常有用的语言。最后一章见！
