<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Throttling, Filtering, Testing, and Deploying an API with Django 2.1</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will use additional features included in Django 2.1 and Django REST Framework to improve our RESTful API. We will also write, execute, and improve unit tests and learn a few things related to deployment. We will look at the following:</p>
<ul>
<li>Install packages with the <kbd>requirements.txt</kbd> file to work with filters, throttling, and tests</li>
<li>Understand filtering, searching, and ordering classes</li>
<li>Configure filtering, searching, and ordering for views</li>
<li>Execute HTTP requests to test filtering, searching, and ordering features</li>
<li>Filter, search, and order in the Browsable API</li>
<li>Understand throttling classes and goals</li>
<li>Configure throttling policies</li>
<li>Execute HTTP requests to test throttle policies</li>
<li>Setting up unit tests with <kbd>pytest</kbd></li>
<li>Write the first round of unit tests</li>
<li>Run unit tests with <kbd>pytest</kbd></li>
<li>Improve testing coverage</li>
<li>Run Django RESTful APIs on the cloud</li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Installing packages with the requirements.txt file to work with filters, throttling, and tests</h1>
                </header>
            
            <article>
                
<p>Make sure you quit Django development server. You just need to press <span class="KeyPACKT"><em>Ctrl</em> + <em>C</em></span> in the Terminal or Command Prompt window in which it is running.</p>
<p>Now, we will install many additional packages to work with filtering capabilities and to be able to easily run tests and measure their code coverage. Make sure you have activated the virtual environment we have created in the previous chapter, named <kbd>Django01</kbd>. After you activate the virtual environment, it is time to run many commands that will be the same for macOS, Linux, and Windows.</p>
<p>Now, we will edit the existing <kbd>requirements.txt</kbd> file to specify the additional packages that our application requires to ...</p></article></section></div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Understanding filtering, searching, and ordering classes</h1>
                </header>
            
            <article>
                
<p class="mce-root">In the previous chapter, we took advantage of the pagination features available in Django REST Framework to specify how we wanted large results sets to be split into individual pages of data. However, we have always been working with the entire <kbd>queryset</kbd> as the result set; that is, we didn't apply any filter.</p>
<div class="packt_tip">Django REST Framework makes it easy to customize filtering, searching, and sorting capabilities for the views we have already coded.</div>
<p>Open the <kbd>settings.py</kbd> file in the <kbd>games_service/games_service</kbd> folder. Add the following highlighted lines after the first line that declares the dictionary named <kbd>REST_FRAMEWORK</kbd> to add the new <kbd>'DEFAULT_FILTER_BACKENDS'</kbd> setting key. Don't remove the lines that will appear after the new highlighted lines. We don't show them to avoid repeating code. The code file for the sample is included in the <kbd>restful_python_2_08_01</kbd> folder, in the <kbd>Django01/games-service/games_service/settings.py</kbd> file:</p>
<pre>REST_FRAMEWORK = { 
  <strong>  'DEFAULT_FILTER_BACKENDS': ( 
        'django_filters.rest_framework.DjangoFilterBackend', 
        'rest_framework.filters.SearchFilter', 
        'rest_framework.filters.OrderingFilter'),</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>The value for the <kbd>'DEFAULT_FILTER_BACKENDS'</kbd> settings key specifies a global setting with a tuple of string whose values indicate the default classes that we want to use for filter backends. We will use the following three classes:</p>
<table style="border-collapse: collapse" border="1">
<tbody>
<tr>
<td>
<p>Module</p>
</td>
<td>
<p>Class name</p>
</td>
<td>
<p>Owner</p>
</td>
</tr>
<tr>
<td>
<p><kbd>django_filters.rest_framework</kbd></p>
</td>
<td>
<p><kbd>DjangoFilterBackend</kbd></p>
</td>
<td>
<p>Django filter</p>
</td>
</tr>
<tr>
<td>
<p><kbd>rest_framework.filters</kbd></p>
</td>
<td>
<p><kbd>SearchFilter</kbd></p>
</td>
<td>
<p>Django REST Framework</p>
</td>
</tr>
<tr>
<td>
<p><kbd>rest_framework.filters</kbd></p>
</td>
<td>
<p><kbd>OrderingFilter</kbd></p>
</td>
<td>
<p>Django REST Framework</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>The <kbd>DjangoFilterBackend</kbd> class provides field-filtering capabilities through the recently installed <kbd>django-filer</kbd> package. We can specify the set of fields we want to be able to filter against or create a <kbd>django_filters.rest_framework.FilterSet</kbd> class with more customized settings and associate it with the desired view.</p>
<p>The <kbd>SearchFilter</kbd> class provides single query parameter-based searching capabilities and is based on the Django admin's search function. We can specify the set of fields we want to include for the search, and the client will be able to filter items by making queries that search on these fields with a single query. This is useful when we want to make it possible for a request to search on multiple fields with a single query.</p>
<p>The <kbd>OrderingFilter</kbd> class allows the client that composes the request to control how the results are ordered with a single query parameter. We can specify which fields may be ordered against.</p>
<div class="packt_tip">Note that we can also configure the filter backends by including any of the previously enumerated classes in a tuple and assigning it to the <kbd>filter_backends</kbd> class attribute for the desired generic view. However, in this case, we will use the default configuration for all our class-based views.</div>
<p>Whenever we design a RESTful API, we have to make sure we provide the required features with a properly optimized usage of the available resources. Hence, we have to be careful to make the fields we configure available in the filtering, searching, and ordering features. The configurations we make in these features will have an impact on the queries that Django's integrated ORM will generate and execute on the database. We must definitely make sure that we have the appropriate database optimizations that take into account the queries that will be executed.</p>
<p>Stay in the <kbd>settings.py</kbd> file in the <kbd>games_service/games_service</kbd> folder. Add the following highlighted lines after the first line that declares the dictionary, named <kbd>INSTALLED_APPS</kbd>, to add <kbd>'django_filters'</kbd> as a newly installed application for the Django project.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Don't remove the lines that will appear after the new highlighted lines. We don't show them to avoid repeating code. The code file for the sample is included in the <kbd>restful_python_2_08_01</kbd> folder, in the <kbd>Django01/games-service/games_service/settings.py</kbd> file:</p>
<pre>INSTALLED_APPS = [ 
   <strong> # Django Filters 
    'django_filters',</strong> </pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Configuring filtering, searching, and ordering for views</h1>
                </header>
            
            <article>
                
<p>Open the <kbd>views.py</kbd> file in the <kbd>games_service/games</kbd> folder. Add the following code after the last line that declares the imports, before the declaration of the <kbd>UserList</kbd> class. The code file for the sample is included in the <kbd>restful_python_2_08_01</kbd> folder, in the <kbd>Django01/games-service/games/views.py</kbd> file:</p>
<pre>from rest_framework import filters 
from django_filters import AllValuesFilter, DateTimeFilter, NumberFilter 
from django_filters.rest_framework import FilterSet </pre>
<p>Stay editing the <kbd>views.py</kbd> file in the <kbd>games_service/games</kbd> folder. Add the following highlighted lines to the <kbd>EsrbRatingList</kbd> class declared in the <kbd>views.py</kbd> file. Don't remove the existing lines for this class that isn't shown to ...</p></article></section></div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Executing HTTP requests to test filtering, searching, and ordering</h1>
                </header>
            
            <article>
                
<p>Now, we can launch Django's development server to compose and send HTTP requests. Execute any of the following two commands, based on your needs to access the API in other devices or computers connected to your LAN:</p>
<pre>    <strong>python manage.py runserver</strong>
    <strong>python manage.py runserver 0.0.0.0:8000</strong>
  </pre>
<p>After we run any of the previous commands, the development server will start listening at port <kbd>8000</kbd>.</p>
<p>Now, we will write a command to compose and send an HTTP <kbd>GET</kbd> request to retrieve all the ESRB ratings whose description matches <kbd>T (Teen)</kbd>. The code file for the sample is included in the <kbd>restful_python_2_08_01</kbd> folder, in the <kbd>Django01/cmd/cmd801.txt</kbd> file:</p>
<pre>    <strong>http ":8000/esrb-ratings/?description=T+(Teen)"</strong></pre>
<p>The following is the equivalent <kbd>curl</kbd> command. The code file for the sample is included in the <kbd>restful_python_2_08_01</kbd> folder, in the <kbd>Django01/cmd/cmd802.txt</kbd> file:</p>
<pre>    <strong>curl -iX GET "localhost:8000/esrb-ratings/?description=T+(Teen)"</strong></pre>
<p>The following lines show a sample response with the single ESRB rating whose description matches the specified description in the filter. The following lines only show the JSON body without the headers:</p>
<pre>    <strong>{</strong>
    <strong>    "count": 1,</strong>
    <strong>    "next": null,</strong>
    <strong>    "previous": null,</strong>
    <strong>    "results": [</strong>
    <strong>        {</strong>
    <strong>            "description": "T (Teen)",</strong>
    <strong>            "games": [</strong>
    <strong>                "http://localhost:8000/games/4/",</strong>
    <strong>                "http://localhost:8000/games/3/",</strong>
    <strong>                "http://localhost:8000/games/6/",</strong>
    <strong>                "http://localhost:8000/games/12/",</strong>
    <strong>                "http://localhost:8000/games/7/",</strong>
    <strong>                "http://localhost:8000/games/13/",</strong>
    <strong>                "http://localhost:8000/games/9/",</strong>
    <strong>                "http://localhost:8000/games/11/",</strong>
    <strong>                "http://localhost:8000/games/5/",</strong>
    <strong>                "http://localhost:8000/games/8/",</strong>
    <strong>                "http://localhost:8000/games/10/"</strong>
    <strong>            ],</strong>
    <strong>            "id": 2,</strong>
    <strong>            "url": "http://localhost:8000/esrb-ratings/2/"</strong>
    <strong>        }</strong>
    <strong>    ]</strong>
    <strong>}</strong>
  </pre>
<p>Now, we will write a command to compose and send an HTTP <kbd>GET</kbd> request to retrieve all the games whose related ESRB rating is <kbd>1</kbd> and the value for the <kbd>played_times</kbd> field is equal to <kbd>10</kbd>. We want to sort the results by <kbd>release_date</kbd> in descending order, and therefore, we specify <kbd>-release_date</kbd> in the value for <kbd>ordering</kbd>. The hyphen (<kbd>-</kbd>) before the field name specifies the ordering feature to use descending order, instead of the default ascending order. Make sure you replace <kbd>1</kbd> with the <kbd>id</kbd> value of the ESRB rating whose description is <kbd>AO (Adults Only)</kbd>. The code file for the sample is included in the <kbd>restful_python_2_08_01</kbd> folder, in the <kbd>Django01/cmd/cmd803.txt</kbd> file:</p>
<pre><strong>http ":8000/games/?esrb_rating=1&amp;played_times=10&amp;ordering=-release_date"</strong>
  </pre>
<p>The following is the equivalent <kbd>curl</kbd> command. The code file for the sample is included in the <kbd>restful_python_2_08_01</kbd> folder, in the <kbd>Django01/cmd/cmd804.txt</kbd> file:</p>
<pre><strong>curl -iX GET <br/>"localhost:8000/games/?esrb_rating=1&amp;played_times=10&amp;ordering=-release_date"</strong>
  </pre>
<p>The following lines show a sample response with the single game that matches the specified criteria in the filter. The following lines only show the JSON body without the headers:</p>
<pre>    <strong>{</strong>
    <strong>    "count": 1,</strong>
    <strong>    "next": null,</strong>
    <strong>    "previous": null,</strong>
    <strong>    "results": [</strong>
    <strong>        {</strong>
    <strong>            "esrb_rating": "AO (Adults Only)",</strong>
    <strong>            "name": "Mutant Football League: Dynasty Edition",</strong>
    <strong>            "owner": "your_games_super_user",</strong>
    <strong>            "played_once": true,</strong>
    <strong>            "played_times": 10,</strong>
    <strong>            "release_date": "2018-10-20T03:02:00.776594Z",</strong>
    <strong>            "url": "http://localhost:8000/games/2/"</strong>
    <strong>        }</strong>
    <strong>    ]</strong>
    <strong>}</strong>
  </pre>
<p>In the <kbd>GameList</kbd> class, we specified <kbd>'esrb_rating'</kbd> as one of the strings in the <kbd>filterset_fields</kbd> tuple of string. Thus, we had to use the ESRB rating <kbd>id</kbd> in the filter.</p>
<p>Now, we will run a command that will compose and send an HTTP <kbd>GET</kbd> request that uses a filter on the game's name related to a registered score. The <kbd>PlayerScoreFilter</kbd> class provides us a filter to the name of the related game in <kbd>game_name</kbd>. We will combine the filter with another filter on the player's name related to a registered score. The <kbd>PlayerScoreFilter</kbd> class provides us a way to filter to the name of the related player in <kbd>player_name</kbd>. Both conditions specified in the criteria must be met, and therefore, the filters are combined with the <kbd>AND</kbd> operator. The code file for the sample is included in the <kbd>restful_python_2_08_01</kbd> folder, in the <kbd>Django01/cmd/cmd805.txt</kbd> file:</p>
<pre><strong>http ":8000/player-<br/>scores/?player_name=Enzo+Scocco&amp;game_name=Battlefield+V"</strong>
  </pre>
<p>The following is the equivalent <kbd>curl</kbd> command. The code file for the sample is included in the <kbd>restful_python_2_08_01</kbd> folder, in the <kbd>Django01/cmd/cmd806.txt</kbd> file:</p>
<pre><strong>curl -iX GET "localhost:8000/player-<br/>scores/?player_name=Enzo+Scocco&amp;game_name=Battlefield+V"</strong>
  </pre>
<p>The following lines show a sample response with the score that matches the specified criteria in the filters. The following lines only show the JSON body without the headers:</p>
<pre>    <strong>{</strong>
    <strong>    "count": 1,</strong>
    <strong>    "next": null,</strong>
    <strong>    "previous": null,</strong>
    <strong>    "results": [</strong>
    <strong>        {</strong>
    <strong>            "game": "Battlefield V",</strong>
    <strong>            "id": 3,</strong>
    <strong>            "player": "Enzo Scocco",</strong>
    <strong>            "score": 43200,</strong>
    <strong>            "score_date": "2019-01-01T03:02:00.776594Z",</strong>
    <strong>            "url": "http://localhost:8000/player-scores/3/"</strong>
    <strong>        }</strong>
    <strong>    ]</strong>
    <strong>}</strong>
  </pre>
<p>We will compose and send an HTTP <kbd>GET</kbd> request to retrieve all the scores that match the following criteria, sorted by <kbd>score</kbd> in descending order:</p>
<ul>
<li>The <kbd>score</kbd> value is between 17,000 and 45,000</li>
<li>The <kbd>score_date</kbd> value is between 2019-01-01 and 2019-01-31</li>
</ul>
<p>The following command composes and sends the previously explained HTTP <kbd>GET</kbd> request. The code file for the sample is included in the <kbd>restful_python_2_08_01</kbd> folder, in the <kbd>Django01/cmd/cmd807.txt</kbd> file:</p>
<pre><strong>http ":8000/player-scores/?from_score_date=2019-01-01&amp;to_score_date=2019-01-<br/>31&amp;min_score=17000&amp;max_score=45000&amp;ordering=-score"</strong>
  </pre>
<p>The following is the equivalent <kbd>curl</kbd> command. The code file for the sample is included in the <kbd>restful_python_2_08_01</kbd> folder, in the <kbd>Django01/cmd/cmd808.txt</kbd> file:</p>
<pre><strong>curl -iX GET "localhost:8000/player-scores/?from_score_date=2019-01-01&amp;to_score_date=2019-01-<br/>31&amp;min_score=17000&amp;max_score=45000&amp;ordering=-score"</strong>
  </pre>
<p>The following lines show a sample response with the three games that match the specified criteria in the filters. The following lines only show the JSON body without the headers:</p>
<pre>    <strong>{</strong>
    <strong>    "count": 3,</strong>
    <strong>    "next": null,</strong>
    <strong>    "previous": null,</strong>
    <strong>    "results": [</strong>
    <strong>        {</strong>
    <strong>            "game": "Battlefield V",</strong>
    <strong>            "id": 3,</strong>
    <strong>            "player": "Enzo Scocco",</strong>
    <strong>            "score": 43200,</strong>
    <strong>            "score_date": "2019-01-01T03:02:00.776594Z",</strong>
    <strong>            "url": "http://localhost:8000/player-scores/3/"</strong>
    <strong>        },</strong>
    <strong>        {</strong>
    <strong>            "game": "Battlefield V",</strong>
    <strong>            "id": 1,</strong>
    <strong>            "player": "Gaston Hillar",</strong>
    <strong>            "score": 17500,</strong>
    <strong>            "score_date": "2019-01-01T03:02:00.776594Z",</strong>
    <strong>            "url": "http://localhost:8000/player-scores/1/"</strong>
    <strong>        },</strong>
    <strong>        {</strong>
    <strong>            "game": "Mutant Football League: Dynasty Edition",</strong>
    <strong>            "id": 4,</strong>
    <strong>            "player": "Enzo Scocco",</strong>
    <strong>            "score": 17420,</strong>
    <strong>            "score_date": "2019-01-01T05:02:00.776594Z",</strong>
    <strong>            "url": "http://localhost:8000/player-scores/4/"</strong>
    <strong>        }</strong>
    <strong>    ]</strong>
    <strong>}</strong>
  </pre>
<div class="packt_tip">In the previous requests, none of the responses had more than one page. If the response requires more than one page, the values for the <kbd>previous</kbd> and <kbd>next</kbd> keys will display the URLs that include the combination of the filters, search, ordering, and pagination. Django combines all the features to build the appropriate URLs.</div>
<p>We will compose and send an HTTP request to retrieve all the games whose <kbd>name</kbd> starts with <kbd>'S'</kbd>. We will use the search feature that we configured to restrict the search behavior to a starts-with match on the <kbd>name</kbd> field. The code file for the sample is included in the <kbd>restful_python_2_08_01</kbd> folder, in the <kbd>Django01/cmd/cmd809.txt</kbd> file:</p>
<pre>    <strong>http ":8000/games/?search=H"</strong></pre>
<p>The following is the equivalent <kbd>curl</kbd> command. The code file for the sample is included in the <kbd>restful_python_2_08_01</kbd> folder, in the <kbd>Django01/cmd/cmd810.txt</kbd> file:</p>
<pre>    <strong>curl -iX GET "localhost:8000/games/?search=H"</strong></pre>
<p>The following lines show a sample response with the two games that match the specified search criteria; that is, those games whose names start with <kbd>'H'</kbd>. The following lines only show the JSON body without the headers:</p>
<pre>    <strong>{</strong>
    <strong>    "count": 2,</strong>
    <strong>    "next": null,</strong>
    <strong>    "previous": null,</strong>
    <strong>    "results": [</strong>
    <strong>        {</strong>
    <strong>            "esrb_rating": "T (Teen)",</strong>
    <strong>            "name": "Heavy Fire: Red Shadow",</strong>
    <strong>            "owner": "your_games_super_user",</strong>
    <strong>            "played_once": false,</strong>
    <strong>            "played_times": 0,</strong>
    <strong>            "release_date": "2018-06-21T03:02:00.776594Z",</strong>
    <strong>            "url": "http://localhost:8000/games/3/"</strong>
    <strong>        },</strong>
    <strong>        {</strong>
    <strong>            "esrb_rating": "T (Teen)",</strong>
    <strong>            "name": "Honor and Duty: D-Day",</strong>
    <strong>            "owner": "your_games_super_user",</strong>
    <strong>            "played_once": false,</strong>
    <strong>            "played_times": 0,</strong>
    <strong>            "release_date": "2018-06-21T03:02:00.776594Z",</strong>
    <strong>            "url": "http://localhost:8000/games/6/"</strong>
    <strong>        }</strong>
    <strong>    ]</strong>
    <strong>}</strong>
  </pre>
<p>So far, we have been using the default search and ordering query parameters: <kbd>'search'</kbd> and <kbd>'ordering'</kbd>. We just need to specify the desired names as strings in the <kbd>SEARCH_PARAM</kbd> and the <kbd>ORDERING_PARAM</kbd> settings in the <kbd>settings.py</kbd> file in the <kbd>games_service/games_service</kbd> folder.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Filtering, searching and ordering in the Browsable API</h1>
                </header>
            
            <article>
                
<p>We can take advantage of the Browsable API to easily test filtering, searching, and ordering features through a web browser. Open a web browser and enter <kbd>http://localhost:8000/player-scores/</kbd>. Replace <kbd>localhost</kbd> with the IP of the computer that is running the Django development server if you use another computer or device to run the browser.</p>
<p>The Browsable API will compose and send an HTTP <kbd>GET</kbd> request to <kbd>/player-scores/</kbd> and will display the results of its execution; that is, the headers and the JSON player scores list. You will notice there is a new <span class="packt_screen">Filters</span> button located at the left-hand side of the <span class="packt_screen">OPTIONS</span> button.</p>
<p>Click on <span class="packt_screen">Filters</span> and the Browsable API will display the <span class="packt_screen">Filters</span> dialog box, ...</p></article></section></div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Understanding throttling classes and goals</h1>
                </header>
            
            <article>
                
<p>So far, we haven't established any limits on the usage of our API, and therefore, both authenticated and unauthenticated users can compose and send as many requests as they want to. We only took advantage of the pagination features available in Django REST Framework to specify how we wanted large result sets to be split into individual pages of data. However, any user can compose and send thousands of requests to be processed without any kind of limitation.</p>
<p>Obviously, it is not a good idea to deploy such an API encapsulated in a microservice in a cloud platform. A wrong usage of the API by any user could cause the microservice to consume a huge amount of resources, and the cloud platform bills would reflect this situation.</p>
<p>We will use the throttling capabilities available in Django REST Framework to configure the following global limitations to the usage of our API, based on whether the requests come from unauthenticated or authenticated users. We will define the following configuration:</p>
<ul>
<li><strong>Unauthenticated users</strong>: They will be able to run a maximum of <kbd>5</kbd> requests per hour</li>
<li><strong>Authenticated users</strong>: They will be able to run a maximum of <kbd>20</kbd> requests per hour</li>
</ul>
<p>In addition, we want to configure a maximum of 25 requests per hour to the ESRB ratings-related views, no matter whether the user is authenticated or not.</p>
<p>Django REST Framework provides three throttling classes (as listed in the following table), in the <kbd>rest_framework.throttling</kbd> module. All of them are subclasses of the <kbd>SimpleRateThrottle</kbd> superclass, which is a subclass of the <kbd>BaseThrottle</kbd> superclass. The classes allow us to set the maximum number of requests per period that will be computed based on different mechanisms to determine the previous request information to specify the scope. The previous request information for throttling is stored in the cache and the classes override the <kbd>get_cache_key</kbd> method that determines the scope:</p>
<table style="border-collapse: collapse" border="1">
<tbody>
<tr>
<td>
<p>Throttling class name</p>
</td>
<td>
<p>Description</p>
</td>
</tr>
<tr>
<td>
<p><kbd>AnonRateThrottle</kbd></p>
</td>
<td>
<p>This class limits the rate of requests that an anonymous user can make. The IP address of the request is the unique cache key. Hence, bear in mind that all the requests coming from the same IP address will accumulate the total number of requests.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>UserRateThrottle</kbd></p>
</td>
<td>
<p>This class limits the rate of requests that a specific user can make. For authenticated users, the authenticated user <kbd>id</kbd> is the unique cache key. For anonymous users, the IP address of the request is the unique cache key.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>ScopedRateThrottle</kbd></p>
</td>
<td>
<p>This class limits the rate of requests for specific parts of the API identified with the value assigned to the <kbd>throttle_scope</kbd> property. The class is useful when we want to restrict access to specific parts of the API with different rates.</p>
</td>
</tr>
</tbody>
</table>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Configuring throttling policies</h1>
                </header>
            
            <article>
                
<p>We will use a combination of the three throttling classes to achieve our previously explained goals. Make sure you quit the Django development server. Remember that you just need to press <span class="KeyPACKT"><em>Ctrl</em> + <em>C</em></span> in the Terminal or Command Prompt window in which it is running.</p>
<p>Open the <kbd>settings.py</kbd> file in the <kbd>games_service/games_service</kbd> folder. Add the following highlighted lines after the first line that declares the dictionary named <kbd>REST_FRAMEWORK</kbd> to add the new <kbd>'DEFAULT_THROTTLE_CLASSES'</kbd> and <kbd>'DEFAULT_THROTTLE_RATES'</kbd> setting keys. Don't remove the lines that will appear after the new highlighted lines. We don't show them to avoid repeating code. The code file for the sample is included in the <kbd>restful_python_2_08_02</kbd> folder, ...</p></article></section></div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Improving testing coverage</h1>
                </header>
            
            <article>
                
<p>Now, we will write additional test functions to improve the testing coverage. Specifically, we will write unit tests related to the player class-based views: <kbd>PlayerList</kbd> and <kbd>PlayerDetail</kbd>. Stay in the <kbd>tests.py</kbd> file in the <kbd>games_service/games</kbd> folder. Add the following code after the last line to declare a new function and new test functions. The code file for the sample is included in the <kbd>restful_python_2_08_03</kbd> folder, in the <kbd>Django01/games-service/games/tests.py</kbd> file:</p>
<pre><strong>def create_player(client, name, gender):</strong> 
    url = reverse('player-list') 
    player_data = {'name': name, 'gender': gender} 
    player_response = client.post(url, player_data, format='json') 
    return player_response 
 
 
<strong>@pytest.mark.django_db 
def test_create_and_retrieve_player(client):</strong> 
    """ 
    Ensure we can create a new Player and then retrieve it 
    """ 
    new_player_name = 'Will.i.am' 
    new_player_gender = Player.MALE 
    response = create_player(client, new_player_name, new_player_gender) 
    assert response.status_code == status.HTTP_201_CREATED 
    assert Player.objects.count() == 1 
    assert Player.objects.get().name == new_player_name </pre>
<p>The code declares the <kbd>create_player</kbd> function that receives the desired <kbd>name</kbd> and <kbd>gender</kbd> for the new player as arguments. The method builds the URL and the data dictionary to compose and send an HTTP <kbd>POST</kbd> method to the view associated with the <kbd>player-list</kbd> view name, and returns the response generated by this request. The code uses the received <kbd>client</kbd> to access the <kbd>APIClient</kbd> instance that allows us to easily compose and send HTTP requests for testing. Many test functions will call the <kbd>create_player</kbd> function to create a player, and then compose and send other HTTP requests to the API.</p>
<p>The <kbd>test_create_and_retrieve_player</kbd> test function tests whether we can create a new <kbd>Player</kbd> object and then retrieve it. The method calls the previously explained <kbd>create_player</kbd> function and then uses <kbd>assert</kbd> to check for the following expected results:</p>
<ul>
<li>The <kbd>status_code</kbd> for the response is HTTP <kbd>201 Created</kbd> (<kbd>status.HTTP_201_CREATED</kbd>)</li>
<li>The total number of <kbd>Player</kbd> objects retrieved from the database is <kbd>1</kbd></li>
<li>The <kbd>name</kbd> attribute of the <kbd>Player</kbd> object retrieved from the database matches the description specified when we created the object</li>
<li>The <kbd>gender</kbd> attribute of the <kbd>Player</kbd> object retrieved from the database matches the description specified when we created the object</li>
</ul>
<p>Stay in the <kbd>tests.py</kbd> file in the <kbd>games_service/games</kbd> folder. Add the following code after the last line to declare new test functions. The code file for the sample is included in the <kbd>restful_python_2_08_03</kbd> folder, in the <kbd>Django01/games-service/games/tests.py</kbd> file:</p>
<pre><strong>@pytest.mark.django_db 
def test_create_duplicated_player(client):</strong> 
    """ 
    Ensure we can create a new Player and we cannot create a duplicate 
    """ 
    url = reverse('player-list') 
    new_player_name = 'Fergie' 
    new_player_gender = Player.FEMALE 
    post_response1 = create_player(client, new_player_name, new_player_gender) 
    assert post_response1.status_code == status.HTTP_201_CREATED 
    post_response2 = create_player(client, new_player_name, new_player_gender) 
    assert post_response2.status_code == status.HTTP_400_BAD_REQUEST 
 
 
<strong>@pytest.mark.django_db 
def test_retrieve_players_list(client):</strong> 
    """ 
    Ensure we can retrieve a player 
    """ 
    new_player_name = 'Vanessa Perry' 
    new_player_gender = Player.FEMALE 
    create_player(client, new_player_name, new_player_gender) 
    url = reverse('player-list') 
    get_response = client.get(url, format='json') 
    assert get_response.status_code == status.HTTP_200_OK 
    assert get_response.data['count'] == 1 
    assert get_response.data['results'][0]['name'] == new_player_name 
    assert get_response.data['results'][0]['gender'] == new_player_gender</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The code declares the following test functions whose names start with the <kbd>test_</kbd> prefix:</p>
<ul>
<li><kbd>test_create_duplicated_player</kbd>: This test function tests whether the unique constraints make it possible for us to create two players with the same name. The second time we compose and send an HTTP <kbd>POST</kbd> request with a duplicate player name, we should receive an HTTP <kbd>400 Bad Request</kbd> status code (<kbd>status.HTTP_400_BAD_REQUEST</kbd>).</li>
<li><kbd>test_retrieve_player_list</kbd>: This test function tests whether we can retrieve a specific player by its <kbd>id</kbd> with an HTTP <kbd>GET</kbd> request.</li>
</ul>
<p>We just coded a few tests related to players to improve test coverage. However, we should definitely write more tests to cover all the features included in our API. </p>
<p> </p>
<p>Now, we will use the <kbd>pytest</kbd> command to run the tests again. Make sure you run the following command in the Terminal or Command Prompt window in which you have activated the virtual environment, and that you are located within the <kbd>games_service</kbd> folder that has the <kbd>manage.py</kbd> file:</p>
<pre>    <strong>pytest -v</strong></pre>
<p>The following lines show the sample output:</p>
<pre>    <strong>============================== test session starts <br/>    ==============================</strong>
    <strong>platform darwin -- Python 3.6.6, pytest-3.9.3, py-1.7.0, pluggy-<br/>    0.8.0 -- /Users/gaston/HillarPythonREST2/Django01/bin/python3</strong>
    <strong>cachedir: .pytest_cache</strong>
    <strong>Django settings: games_service.settings (from ini file)</strong>
    <strong>rootdir: /Users/gaston/HillarPythonREST2/Django01/games_service, <br/>    inifile: pytest.ini</strong>
    <strong>plugins: django-3.4.3, cov-2.6.0</strong>
    <strong>collected 8 items                                                               </strong>
    
    <strong>games/tests.py::test_create_and_retrieve_esrb_rating PASSED               <br/>    [ 12%]</strong>
    <strong>games/tests.py::test_create_duplicated_esrb_rating PASSED                 <br/>    [ 25%]</strong>
    <strong>games/tests.py::test_retrieve_esrb_ratings_list PASSED                    <br/>    [ 37%]</strong>
    <strong>games/tests.py::test_update_game_category PASSED                          <br/>    [ 50%]</strong>
    <strong>games/tests.py::test_filter_esrb_rating_by_description PASSED             <br/>    [ 62%]</strong>
    <strong>games/tests.py::test_create_and_retrieve_player PASSED                    <br/>    [ 75%]</strong>
    <strong>games/tests.py::test_create_duplicated_player PASSED                      <br/>    [ 87%]</strong>
    <strong>games/tests.py::test_retrieve_players_list PASSED                         <br/>    [100%]</strong>
    
    <strong>=========================== 8 passed in 1.48 seconds <br/>    ============================</strong>
  </pre>
<p>The output provided details indicating that <kbd>pytest</kbd> executed <kbd>8</kbd> tests and all of them passed. It is possible to work with <kbd>pytest</kbd> fixtures to reduce boilerplate code in the previously coded functions. However, we are focused on making the functions easy to understand. Then, you can use the code as a baseline and improve it by taking full advantage of additional features provided by Pytest fixtures and <kbd>pytest-django</kbd>.</p>
<div class="packt_tip">We just created a few unit tests to understand how we can code them. However, of course, it would be necessary to write more tests to provide appropriate coverage of all the featured and execution scenarios included in the API.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Executing HTTP requests to test throttling policies</h1>
                </header>
            
            <article>
                
<p>Launch Django's development server to compose and send HTTP requests. Execute either of the following two commands based on your needs:</p>
<pre>    <strong>python manage.py runserver</strong>
    <strong>python manage.py runserver 0.0.0.0:8000</strong></pre>


<p>Now, we will write commands to compose and send HTTP requests many times. In order to do so, we will learn how to achieve this goal with any of the following options combined with <kbd>http</kbd> and <kbd>curl</kbd> commands. Select the most appropriate one based on your needs. Don't forget that you will need to have the virtual environment activated in any of the options you select to run the commands when you use the <kbd>http</kbd> command:</p>
<ul>
<li>macOS: Terminal with a Bash shell.</li>
<li>Linux: Terminal with a Bash shell.</li>
<li>Windows: ...</li></ul></article></section></div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Setting up unit tests with pytest</h1>
                </header>
            
            <article>
                
<p>Create a new <kbd>pytest.ini</kbd> file within the <kbd>games_service</kbd> folder (the same folder that has the <kbd>manage.py</kbd> file). The following lines show the code that specifies the desired configuration for Pytest. The code file for the sample is included in the <kbd>restful_python_2_08_02</kbd> folder, in the <kbd>Django01/game_service/manage.py</kbd> file:</p>
<pre>[pytest] 
DJANGO_SETTINGS_MODULE = games_service.settings 
python_files = tests.py test_*.py *_tests.py </pre>
<p>The <kbd>DJANGO_SETTINGS_MODULE</kbd> configuration variable specifies that we want to use the <kbd>settings.py</kbd> file located in the <kbd>games_service/games_service</kbd> folder as the settings module for Django when tests are executed.</p>
<p>The <kbd>python_files</kbd> configuration variable indicates the filters that <kbd>pytest</kbd> will use to find modules with test functions.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Writing the first round of unit tests</h1>
                </header>
            
            <article>
                
<p>Now, we will write the first round of unit tests. Specifically, we will write unit tests related to the ESRB rating class-based views: <kbd>EsrbRatingList</kbd> and <kbd>EsrbRatingDetail</kbd>.</p>
<p>Open the <kbd>tests.py</kbd> file in the <kbd>games_service/games</kbd> folder. Replace the existing code with the following lines that declare many <kbd>import</kbd> statements and two functions. The code file for the sample is included in the <kbd>restful_python_2_08_02</kbd> folder, in the <kbd>Django01/games-service/games/tests.py</kbd> file:</p>
<pre>import pytest 
from django.urls import reverse 
from django.utils.http import urlencode 
from rest_framework import status 
from games import views 
from games.models import EsrbRating 
 
 
<strong>def create_esrb_rating(client, description): 
</strong> url = reverse(views.EsrbRatingList.name) ...</pre></article></section></div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Running unit tests with pytest</h1>
                </header>
            
            <article>
                
<p>Now, run the following command to create a test database, run all the migrations, and use <kbd>pytest</kbd>, in combination with the <kbd>pytest-django</kbd> plugin, to discover and execute all the tests we created. The test runner will execute all the methods that start with the <kbd>test_</kbd> prefix in the <kbd>tests.py</kbd> file and will display the results. Make sure you run the command in the Terminal or Command Prompt window in which you have activated the virtual environment, and that you are located within the <kbd>games_service</kbd> folder that has the <kbd>manage.py</kbd> file:</p>
<pre>    <strong>pytest -v</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<div class="packt_tip">The tests won't make changes to the database we have been using when running request on the API through <kbd>pytest</kbd>.</div>
<p>The test runner will execute all the functions defined in the <kbd>tests.py</kbd> that start with the <kbd>test_</kbd> prefix and will display the results. We use the <kbd>-v</kbd> option to instruct <kbd>pytest</kbd> to print the test function names and statuses in the verbose mode.</p>
<p>The following lines show the sample output:</p>
<pre>    <strong>============================== test session starts <br/>    ==============================</strong>
    <strong>platform darwin -- Python 3.6.6, pytest-3.9.3, py-1.7.0, pluggy-<br/>    0.8.0 -- /Users/gaston/HillarPythonREST2/Django01/bin/python3</strong>
    <strong>cachedir: .pytest_cache</strong>
    <strong>Django settings: games_service.settings (from ini file)</strong>
    <strong>rootdir: /Users/gaston/HillarPythonREST2/Django01/games_service, <br/>    inifile: pytest.ini</strong>
    <strong>plugins: django-3.4.3, cov-2.6.0</strong>
    <strong>collected 5 items                                                               </strong>
    
    <strong>games/tests.py::test_create_and_retrieve_esrb_rating PASSED               <br/>    [ 20%]</strong>
    <strong>games/tests.py::test_create_duplicated_esrb_rating PASSED                 <br/>    [ 40%]</strong>
    <strong>games/tests.py::test_retrieve_esrb_ratings_list PASSED                    <br/>    [ 60%]</strong>
    <strong>games/tests.py::test_update_game_category PASSED                          <br/>    [ 80%]</strong>
    <strong>games/tests.py::test_filter_esrb_rating_by_description PASSED             <br/>    [100%]</strong>
    
    <strong>=========================== 5 passed in 1.68 seconds <br/>    ============================</strong>
  </pre>
<p>The output provides details indicating that the test runner executed <kbd>5</kbd> tests, and all of them passed.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Running Django RESTful APIs on the cloud</h1>
                </header>
            
            <article>
                
<p>One of the biggest drawbacks related to Django and Django REST Framework is that each HTTP request is blocking. Thus, whenever the Django server receives an HTTP request, it doesn't start working on any other HTTP requests in the incoming queue until the server sends the response for the first HTTP request is received.</p>
<p>However, one of the great advantages of RESTful Web Services is that they are stateless; that is, they shouldn't keep a client state on any server. Our API is a good example of a stateless RESTful Web Service. Thus, we can make the API run on as many servers as necessary to achieve our scalability goals. Obviously, we must take into account that we can easily transform the database server ...</p></article></section></div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Test your knowledge</h1>
                </header>
            
            <article>
                
<p>Let's see whether you can answer the following questions correctly:</p>
<ol>
<li>Which of the following fixtures provided by the <kbd>pytest-django</kbd> plugin allow us to access the <kbd>APIClient</kbd> instance that makes it easy for us to compose and send HTTP requests for testing?
<ol>
<li><kbd>client</kbd></li>
<li><kbd>api_client</kbd></li>
<li><kbd>http</kbd></li>
</ol>
</li>
</ol>
<ol start="2">
<li>Which of the following decorators declared in <kbd>pytest-django</kbd> indicate that a test function needs to work with the test database?
<ol>
<li><kbd>@pytest.django.db</kbd></li>
<li><kbd>@pytest.mark.django_db</kbd></li>
<li><kbd>@pytest.mark.db</kbd></li>
</ol>
</li>
</ol>
<ol start="3">
<li>The <kbd>ScopedRateThrottle</kbd> class:
<ol>
<li>Limits the rate of requests that a specific user can make</li>
<li>Limits the rate of requests for specific parts of the API identified with the value assigned to the <kbd>throttle_scope</kbd> <span>property</span></li>
<li>Limits the rate of requests that an anonymous user can make</li>
</ol>
</li>
</ol>
<ol start="4">
<li>The <kbd>UserRateThrottle</kbd> class:
<ol>
<li>Limits the rate of requests that a specific user can make</li>
<li>Limits the rate of requests for specific parts of the API identified with the value assigned to the <kbd>throttle_scope</kbd> <span>property</span></li>
<li>Limits the rate of requests that an anonymous user can make</li>
</ol>
</li>
</ol>
<ol start="5">
<li>The <kbd>DjangoFilterBackend</kbd> class:
<ol>
<li>Provides single query parameter-based searching capabilities and is based on the Django admin's search function</li>
<li>Allows the client to control how the results are ordered with a single query parameter</li>
<li>Provides field filtering capabilities</li>
</ol>
</li>
</ol>
<p class="mce-root"/>
<p class="mce-root"/>
<ol start="6">
<li>The <kbd>SearchFilter</kbd> class:
<ol>
<li>Provides single query parameter-based searching capabilities and is based on the Django admin's search function</li>
<li>Allows the client to control how the results are ordered with a single query parameter</li>
<li>Provides field filtering capabilities</li>
</ol>
</li>
</ol>
<ol start="7">
<li>Which of the following class attributes specifies the <kbd>FilterSet</kbd> subclass that we want to use for a class-based view?
<ol>
<li><kbd>filters_class</kbd></li>
<li><kbd>filtering_class</kbd></li>
<li><kbd>filterset_class</kbd></li>
</ol>
</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we took advantage of many features included in Django REST Framework to define throttling policies. We used the filtering, searching, and ordering of classes to make it easy to configure filters, search queries, and the desired order for the results in HTTP requests. We used the Browsable API feature to test these new features included in our API.</p>
<p>We wrote the first round of unit tests and set the necessary configuration to use the popular and modern <kbd>pytest</kbd> Python unit test framework with Django REST Framework. Then, we wrote additional unit tests to improve test coverage. Finally, we understood many considerations for deployment and scalability in the cloud.</p>
<p>Now that we have built a complex API with Django REST Framework ...</p></article></section></div>



  </body></html>