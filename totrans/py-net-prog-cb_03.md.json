["```py\n#!/usr/bin/env python\n# Python Network Programming Cookbook -- Chapter – 3\n# This program is optimized for Python 2.7.\n# It may run on any other version with/without modifications.\n\nimport argparse\nLOCAL_SERVER_HOST = 'localhost'\nREMOTE_SERVER_HOST = 'www.google.com'\nBUFSIZE = 4096\nimport asyncore\nimport socket\n```", "```py\nclass PortForwarder(asyncore.dispatcher):\n    def __init__(self, ip, port, remoteip,remoteport,backlog=5):\n        asyncore.dispatcher.__init__(self)\n        self.remoteip=remoteip\n        self.remoteport=remoteport\n        self.create_socket(socket.AF_INET,socket.SOCK_STREAM)\n        self.set_reuse_addr()\n        self.bind((ip,port))\n        self.listen(backlog)\n    def handle_accept(self):\n        conn, addr = self.accept()\n        print \"Connected to:\",addr\n        Sender(Receiver(conn),self.remoteip,self.remoteport)\n```", "```py\nclass Receiver(asyncore.dispatcher):\n    def __init__(self,conn):\n        asyncore.dispatcher.__init__(self,conn)\n        self.from_remote_buffer=''\n        self.to_remote_buffer=''\n        self.sender=None\n    def handle_connect(self):\n        pass\n    def handle_read(self):\n        read = self.recv(BUFSIZE)\n        self.from_remote_buffer += read\n    def writable(self):\n        return (len(self.to_remote_buffer) > 0)\n    def handle_write(self):\n        sent = self.send(self.to_remote_buffer)\n        self.to_remote_buffer = self.to_remote_buffer[sent:]\n    def handle_close(self):\n        self.close()\n        if self.sender:\n            self.sender.close()\nclass Sender(asyncore.dispatcher):\n    def __init__(self, receiver, remoteaddr,remoteport):\n        asyncore.dispatcher.__init__(self)\n        self.receiver=receiver\n        receiver.sender=self\n        self.create_socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.connect((remoteaddr, remoteport))\n    def handle_connect(self):\n        pass\n    def handle_read(self):\n        read = self.recv(BUFSIZE)\n        self.receiver.to_remote_buffer += read\n    def writable(self):\n        return (len(self.receiver.from_remote_buffer) > 0)\n    def handle_write(self):\n        sent = self.send(self.receiver.from_remote_buffer)\n        self.receiver.from_remote_buffer = self.receiver.from_remote_buffer[sent:]\n    def handle_close(self):\n        self.close()\n        self.receiver.close()\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser(description='Port forwarding example')\n    parser.add_argument('--local-host', action=\"store\", dest=\"local_host\", default=LOCAL_SERVER_HOST)\n    parser.add_argument('--local-port', action=\"store\", dest=\"local_port\", type=int, required=True)\n    parser.add_argument('--remote-host', action=\"store\", dest=\"remote_host\",  default=REMOTE_SERVER_HOST)\n    parser.add_argument('--remote-port', action=\"store\", dest=\"remote_port\", type=int, default=80)\n    given_args = parser.parse_args() \n    local_host, remote_host = given_args.local_host, given_args.remote_host\n    local_port, remote_port = given_args.local_port, given_args.remote_port\n    print \"Starting port forwarding local %s:%s => remote %s:%s\" % (local_host, local_port, remote_host, remote_port)\n    PortForwarder(local_host, local_port, remote_host, remote_port)\n    asyncore.loop()\n```", "```py\n$ python 3_1_port_forwarding.py --local-port=8800 \nStarting port forwarding local localhost:8800 => remote www.google.com:80 \n\n```", "```py\nConnected to: ('127.0.0.1', 38557)\n\n```", "```py\nimport subprocess\nimport shlex\n\ncommand_line = \"ping -c 1 www.google.com\"\nargs = shlex.split(command_line)\ntry:\n      subprocess.check_call(args,stdout=subprocess.PIPE,\\\nstderr=subprocess.PIPE)\n    print \"Google web server is up!\"\nexcept subprocess.CalledProcessError:\n    print \"Failed to get ping.\"\n```", "```py\n#!/usr/bin/env python\n# Python Network Programming Cookbook -- Chapter – 3\n# This program is optimized for Python 2.7.\n# It may run on any other version with/without modifications.\n\nimport os\nimport argparse\nimport socket\nimport struct\nimport select\nimport time\n\nICMP_ECHO_REQUEST = 8 # Platform specific\nDEFAULT_TIMEOUT = 2\nDEFAULT_COUNT = 4 \n\nclass Pinger(object):\n    \"\"\" Pings to a host -- the Pythonic way\"\"\"\n    def __init__(self, target_host, count=DEFAULT_COUNT, timeout=DEFAULT_TIMEOUT):\n        self.target_host = target_host\n        self.count = count\n        self.timeout = timeout\n    def do_checksum(self, source_string):\n        \"\"\"  Verify the packet integritity \"\"\"\n        sum = 0\n        max_count = (len(source_string)/2)*2\n        count = 0\n        while count < max_count:\n            val = ord(source_string[count + 1])*256 + ord(source_string[count])\n            sum = sum + val\n            sum = sum & 0xffffffff \n            count = count + 2\n        if max_count<len(source_string):\n            sum = sum + ord(source_string[len(source_string) - 1])\n            sum = sum & 0xffffffff \n        sum = (sum >> 16)  +  (sum & 0xffff)\n        sum = sum + (sum >> 16)\n        answer = ~sum\n        answer = answer & 0xffff\n        answer = answer >> 8 | (answer << 8 & 0xff00)\n        return answer\n\n    def receive_pong(self, sock, ID, timeout):\n        \"\"\"\n        Receive ping from the socket.\n        \"\"\"\n        time_remaining = timeout\n        while True:\n            start_time = time.time()\n            readable = select.select([sock], [], [], time_remaining)\n            time_spent = (time.time() - start_time)\n            if readable[0] == []: # Timeout\n                return\n\n            time_received = time.time()\n            recv_packet, addr = sock.recvfrom(1024)\n            icmp_header = recv_packet[20:28]\n            type, code, checksum, packet_ID, sequence = struct.unpack(\n                \"bbHHh\", icmp_header\n            )\n            if packet_ID == ID:\n                bytes_In_double = struct.calcsize(\"d\")\n                time_sent = struct.unpack(\"d\", recv_packet[28:28 + bytes_In_double])[0]\n                return time_received - time_sent\n\n            time_remaining = time_remaining - time_spent\n            if time_remaining <= 0:\n                return\n```", "```py\n    def send_ping(self, sock,  ID):\n        \"\"\"\n        Send ping to the target host\n        \"\"\"\n        target_addr  =  socket.gethostbyname(self.target_host)\n        my_checksum = 0\n        # Create a dummy header with a 0 checksum.\n        header = struct.pack(\"bbHHh\", ICMP_ECHO_REQUEST, 0, my_checksum, ID, 1)\n        bytes_In_double = struct.calcsize(\"d\")\n        data = (192 - bytes_In_double) * \"Q\"\n        data = struct.pack(\"d\", time.time()) + data\n        # Get the checksum on the data and the dummy header.\n        my_checksum = self.do_checksum(header + data)\n        header = struct.pack(\n            \"bbHHh\", ICMP_ECHO_REQUEST, 0, socket.htons(my_checksum), ID, 1\n        )\n        packet = header + data\n        sock.sendto(packet, (target_addr, 1))\n```", "```py\n    def ping_once(self):\n        \"\"\"\n        Returns the delay (in seconds) or none on timeout.\n        \"\"\"\n        icmp = socket.getprotobyname(\"icmp\")\n        try:\n            sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, icmp)\n        except socket.error, (errno, msg):\n            if errno == 1:\n                # Not superuser, so operation not permitted\n                msg +=  \"ICMP messages can only be sent from root user processes\"\n                raise socket.error(msg)\n        except Exception, e:\n            print \"Exception: %s\" %(e)\n        my_ID = os.getpid() & 0xFFFF\n        self.send_ping(sock, my_ID)\n        delay = self.receive_pong(sock, my_ID, self.timeout)\n        sock.close()\n        return delay\n```", "```py\n    def ping(self):\n        \"\"\"\n        Run the ping process\n        \"\"\"\n        for i in xrange(self.count):\n            print \"Ping to %s...\" % self.target_host,\n            try:\n                delay  =  self.ping_once()\n            except socket.gaierror, e:\n                print \"Ping failed. (socket error: '%s')\" % e[1]\n                break\n            if delay  ==  None:\n               print \"Ping failed. (timeout within %ssec.)\" % \\  \\\n                      self.timeout\n            else:\n                delay  =  delay * 1000\n                print \"Get pong in %0.4fms\" % delay\n\nif __name__ == '__main__':\n    parser = argparse.ArgumentParser(description='Python ping')\n    parser.add_argument('--target-host', action=\"store\", dest=\"target_host\", required=True)\n    given_args = parser.parse_args()  \n    target_host = given_args.target_host\n    pinger = Pinger(target_host=target_host)\n    pinger.ping()\n```", "```py\n$ sudo python 3_2_ping_remote_host.py --target-host=www.google.com \nPing to www.google.com... Get pong in 7.6921ms \nPing to www.google.com... Get pong in 7.1061ms \nPing to www.google.com... Get pong in 8.9211ms \nPing to www.google.com... Get pong in 7.9899ms \n\n```", "```py\n#!/usr/bin/env python\n# Python Network Programming Cookbook -- Chapter – 3\n# This program is optimized for Python 2.7.\n# It may run on any other version with/without modifications.\n\nimport argparse\nimport socket\nimport errno\nfrom time import time as now\n\nDEFAULT_TIMEOUT = 120\nDEFAULT_SERVER_HOST = 'localhost'\nDEFAULT_SERVER_PORT = 80\n\nclass NetServiceChecker(object):\n    \"\"\" Wait for a network service to come online\"\"\"\n    def __init__(self, host, port, timeout=DEFAULT_TIMEOUT):\n        self.host = host\n        self.port = port\n        self.timeout = timeout\n        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n    def end_wait(self):\n        self.sock.close()\n\n    def check(self):\n        \"\"\" Check the service \"\"\"\n        if self.timeout:\n            end_time = now() + self.timeout\n\n        while True:\n            try:\n                if self.timeout:\n                    next_timeout = end_time - now()\n                    if next_timeout < 0:\n                        return False\n                    else:\n                        print \"setting socket next timeout %ss\"\\\n                       %round(next_timeout)\n                        self.sock.settimeout(next_timeout)\n                self.sock.connect((self.host, self.port))\n            # handle exceptions\n            except socket.timeout, err:\n                if self.timeout:\n                    return False\n            except socket.error, err:\n                print \"Exception: %s\" %err\n            else: # if all goes well\n                self.end_wait()\n                return True\n\nif __name__ == '__main__':\n    parser = argparse.ArgumentParser(description='Wait for Network Service')\n    parser.add_argument('--host', action=\"store\", dest=\"host\",  default=DEFAULT_SERVER_HOST)\n    parser.add_argument('--port', action=\"store\", dest=\"port\", type=int, default=DEFAULT_SERVER_PORT)\n    parser.add_argument('--timeout', action=\"store\", dest=\"timeout\", type=int, default=DEFAULT_TIMEOUT)\n    given_args = parser.parse_args() \n    host, port, timeout = given_args.host, given_args.port, given_args.timeout\n    service_checker = NetServiceChecker(host, port, timeout=timeout)\n    print \"Checking for network service %s:%s ...\" %(host, port)\n    if service_checker.check():\n        print \"Service is available again!\"\n```", "```py\n$ python 3_3_wait_for_remote_service.py \nWaiting for network service localhost:80 ... \nsetting socket next timeout 120.0s \nService is available again!\n\n```", "```py\nException: [Errno 103] Software caused connection abort \nsetting socket next timeout 104.189137936 \nException: [Errno 111] Connection refused \nsetting socket next timeout 104.186291933 \nException: [Errno 103] Software caused connection abort \nsetting socket next timeout 104.186164856 \nService is available again!\n\n```", "```py\n$ /sbin/ifconfig\n\n```", "```py\n#!/usr/bin/env python\n# Python Network Programming Cookbook -- Chapter – 3\n# This program is optimized for Python 2.7.\n# It may run on any other version with/without modifications.\nimport sys\nimport socket\nimport fcntl\nimport struct\nimport array\n\nSIOCGIFCONF = 0x8912 #from C library sockios.h\nSTUCT_SIZE_32 = 32\nSTUCT_SIZE_64 = 40\nPLATFORM_32_MAX_NUMBER =  2**32\nDEFAULT_INTERFACES = 8\n\ndef list_interfaces():\n    interfaces = []\n    max_interfaces = DEFAULT_INTERFACES\n    is_64bits = sys.maxsize > PLATFORM_32_MAX_NUMBER\n    struct_size = STUCT_SIZE_64 if is_64bits else STUCT_SIZE_32\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) \n    while True:\n        bytes = max_interfaces * struct_size\n        interface_names = array.array('B', '\\0' * bytes)\n        sock_info = fcntl.ioctl( \n            sock.fileno(),\n            SIOCGIFCONF,\n            struct.pack('iL', bytes,interface_names.buffer_info()[0])\n        )\n        outbytes = struct.unpack('iL', sock_info)[0]\n        if outbytes == bytes:\n            max_interfaces *= 2  \n        else: \n            break\n    namestr = interface_names.tostring()\n    for i in range(0, outbytes, struct_size):\n        interfaces.append((namestr[i:i+16].split('\\0', 1)[0]))\n    return interfaces\n\nif __name__ == '__main__':\n    interfaces = list_interfaces()\n    print \"This machine has %s network interfaces: %s.\" %(len(interfaces), interface)\n```", "```py\n$ python 3_4_list_network_interfaces.py \nThis machine has 2 network interfaces: ['lo', 'eth0'].\n\n```", "```py\n#!/usr/bin/env python\n# Python Network Programming Cookbook -- Chapter – 3\n# This program is optimized for Python 2.7.\n# It may run on any other version with/without modifications.\n\nimport argparse\nimport sys\nimport socket\nimport fcntl\nimport struct\nimport array\n\ndef get_ip_address(ifname):\n    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    return socket.inet_ntoa(fcntl.ioctl(\n        s.fileno(),\n        0x8915,  # SIOCGIFADDR\n        struct.pack('256s', ifname[:15])\n    )[20:24])\n\nif __name__ == '__main__':\n    #interfaces =  list_interfaces()\n    parser = argparse.ArgumentParser(description='Python networking utils')\n    parser.add_argument('--ifname', action=\"store\", dest=\"ifname\", required=True)\n    given_args = parser.parse_args() \n    ifname = given_args.ifname    \n    print \"Interface [%s] --> IP: %s\" %(ifname, get_ip_address(ifname)) \n```", "```py\n$ python 3_5_get_interface_ip_address.py --ifname=eth0 \nInterface [eth0] --> IP: 10.0.2.15 \n\n```", "```py\n$ pip install python-nmap\n\n```", "```py\n#!/usr/bin/env python\n# Python Network Programming Cookbook -- Chapter – 3\n# This program is optimized for Python 2.7.\n# It may run on any other version with/without modifications.\n\nimport argparse\nimport socket\nimport struct\nimport fcntl\nimport nmap\nSAMPLE_PORTS = '21-23'\n\ndef get_interface_status(ifname):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    ip_address = socket.inet_ntoa(fcntl.ioctl(\n        sock.fileno(),\n        0x8915, #SIOCGIFADDR, C socket library sockios.h\n        struct.pack('256s', ifname[:15])\n    )[20:24])\n\n    nm = nmap.PortScanner()         \n    nm.scan(ip_address, SAMPLE_PORTS)      \n    return nm[ip_address].state()          \n\nif  __name__ == '__main__':\n    parser = argparse.ArgumentParser(description='Python networking utils')\n    parser.add_argument('--ifname', action=\"store\", dest=\"ifname\", required=True)\n    given_args = parser.parse_args() \n    ifname = given_args.ifname    \n    print \"Interface [%s] is: %s\" %(ifname, get_interface_status(ifname))      \n```", "```py\n$ python 3_6_find_network_interface_status.py --ifname=eth0 \nInterface [eth0] is: up\n\n```", "```py\n#!/usr/bin/env python\n# Python Network Programming Cookbook -- Chapter – 3\n# This program is optimized for Python 2.7.\n# It may run on any other version with/without modifications.\n# This recipe requires scapy-2.2.0 or higher \n\nimport argparse\nimport time\nimport sched\nfrom scapy.all import sr, srp, IP, UDP, ICMP, TCP, ARP, Ether\nRUN_FREQUENCY = 10\nscheduler = sched.scheduler(time.time, time.sleep)\n\ndef detect_inactive_hosts(scan_hosts):\n    \"\"\" \n    Scans the network to find scan_hosts are live or dead\n    scan_hosts can be like 10.0.2.2-4 to cover range. \n    See Scapy docs for specifying targets.   \n    \"\"\"\n    global scheduler\n    scheduler.enter(RUN_FREQUENCY, 1, detect_inactive_hosts, (scan_hosts, ))\n    inactive_hosts = []\n    try:\n        ans, unans = sr(IP(dst=scan_hosts)/ICMP(),retry=0, timeout=1)\n        ans.summary(lambda(s,r) : r.sprintf(\"%IP.src% is alive\"))\n        for inactive in unans:\n            print \"%s is inactive\" %inactive.dst\n            inactive_hosts.append(inactive.dst)\n        print \"Total %d hosts are inactive\" %(len(inactive_hosts))\n    except KeyboardInterrupt:\n        exit(0)\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser(description='Python networking utils')\n    parser.add_argument('--scan-hosts', action=\"store\", dest=\"scan_hosts\", required=True)\n    given_args = parser.parse_args() \n    scan_hosts = given_args.scan_hosts    \n    scheduler.enter(1, 1, detect_inactive_hosts, (scan_hosts, ))\n    scheduler.run()\n```", "```py\n$ sudo python 3_7_detect_inactive_machines.py --scan-hosts=10.0.2.2-4\nBegin emission:\n.*...Finished to send 3 packets.\n.\nReceived 6 packets, got 1 answers, remaining 2 packets\n10.0.2.2 is alive\n10.0.2.4 is inactive\n10.0.2.3 is inactive\nTotal 2 hosts are inactive\nBegin emission:\n*.Finished to send 3 packets.\nReceived 3 packets, got 1 answers, remaining 2 packets\n10.0.2.2 is alive\n10.0.2.4 is inactive\n10.0.2.3 is inactive\nTotal 2 hosts are inactive\n\n```", "```py\n#!/usr/bin/env python\n# Python Network Programming Cookbook -- Chapter – 3\n# This program is optimized for Python 2.7.\n# It may run on any other version with/without modifications.\n\nimport socket\nimport os\n\nBUFSIZE = 1024\n\ndef test_socketpair():\n    \"\"\" Test Unix socketpair\"\"\"\n    parent, child = socket.socketpair()\n\n    pid = os.fork()\n    try:\n        if pid:\n            print \"@Parent, sending message...\"\n            child.close()\n            parent.sendall(\"Hello from parent!\")\n            response = parent.recv(BUFSIZE)\n            print \"Response from child:\", response\n            parent.close()\n\n        else:\n            print \"@Child, waiting for message from parent\"\n            parent.close()\n            message = child.recv(BUFSIZE)\n            print \"Message from parent:\", message\n            child.sendall(\"Hello from child!!\")\n            child.close()\n    except Exception, err:\n        print \"Error: %s\" %err\n\nif __name__ == '__main__':\n    test_socketpair()\n```", "```py\n$ python 3_8_ipc_using_socketpairs.py\n@Parent, sending message... \n@Child, waiting for message from parent \nMessage from parent: Hello from parent! \nResponse from child: Hello from child!! \n\n```", "```py\n#!/usr/bin/env python\n# Python Network Programming Cookbook -- Chapter – 3\n# This program is optimized for Python 2.7.\n# It may run on any other version with/without modifications.\n\nimport socket\nimport os\nimport time\n\nSERVER_PATH = \"/tmp/python_unix_socket_server\"\n\ndef run_unix_domain_socket_server():\n    if os.path.exists(SERVER_PATH):\n        os.remove( SERVER_PATH )\n\n    print \"starting unix domain socket server.\"\n    server = socket.socket( socket.AF_UNIX, socket.SOCK_DGRAM )\n    server.bind(SERVER_PATH)\n\n    print \"Listening on path: %s\" %SERVER_PATH\n    while True:\n        datagram = server.recv( 1024 )\n        if not datagram:\n            break\n        else:\n            print \"-\" * 20\n            print datagram\n        if \"DONE\" == datagram:\n            break\n    print \"-\" * 20\n    print \"Server is shutting down now...\"\n    server.close()\n    os.remove(SERVER_PATH)\n    print \"Server shutdown and path removed.\"\n\nif __name__ == '__main__':\n    run_unix_domain_socket_server()\n```", "```py\n#!/usr/bin/env python\n# Python Network Programming Cookbook -- Chapter - 3\n# This program is optimized for Python 2.7.\n# It may run on any other version with/without modifications.\n\nimport socket\nimport sys\n\nSERVER_PATH = \"/tmp/python_unix_socket_server\"\n\ndef run_unix_domain_socket_client():\n    \"\"\" Run \"a Unix domain socket client \"\"\"\n    sock = socket.socket(socket.AF_UNIX, socket.SOCK_DGRAM)\n\n    # Connect the socket to the path where the server is listening\n    server_address = SERVER_PATH \n    print \"connecting to %s\" % server_address\n    try:\n        sock.connect(server_address)\n    except socket.error, msg:\n        print >>sys.stderr, msg\n        sys.exit(1)\n\n    try:\n        message = \"This is the message.  This will be echoed back!\"\n        print  \"Sending [%s]\" %message\n        sock.sendall(message)\n        amount_received = 0\n        amount_expected = len(message)\n\n        while amount_received < amount_expected:\n            data = sock.recv(16)\n            amount_received += len(data)\n            print >>sys.stderr, \"Received [%s]\" % data\n\n    finally:\n        print \"Closing client\"\n        sock.close()\n\nif __name__ == '__main__':\n    run_unix_domain_socket_client()\n```", "```py\n$ python 3_9a_unix_domain_socket_server.py \nstarting unix domain socket server. \nListening on path: /tmp/python_unix_socket_server\n-------------------- \nThis is the message.  This will be echoed back!\n\n```", "```py\n$ python 3_9b_unix_domain_socket_client.py \nconnecting to /tmp/python_unix_socket_server \nSending [This is the message.  This will be echoed back!]\n\n```", "```py\n$ cat /proc/net/if_inet6 \n00000000000000000000000000000001 01 80 10 80       lo \nfe800000000000000a0027fffe950d1a 02 40 20 80     eth0 \n\n```", "```py\n$ pip install   netifaces\n\n```", "```py\n#!/usr/bin/env python\n# Python Network Programming Cookbook -- Chapter – 3\n# This program is optimized for Python 2.7.\n# It may run on any other version with/without modifications.\n# This program depends on Python module netifaces => 0.8\nimport socket\nimport argparse\nimport netifaces as ni\n\ndef inspect_ipv6_support():\n    \"\"\" Find the ipv6 address\"\"\"\n    print \"IPV6 support built into Python: %s\" %socket.has_ipv6\n    ipv6_addr = {}\n    for interface in ni.interfaces():\n        all_addresses = ni.ifaddresses(interface)\n        print \"Interface %s:\" %interface\n        for family,addrs in all_addresses.iteritems():\n            fam_name = ni.address_families[family]\n            print '  Address family: %s' % fam_name\n            for addr in addrs:\n                if fam_name == 'AF_INET6':\n                    ipv6_addr[interface] = addr['addr']\n                print     '    Address  : %s' % addr['addr']\n                nmask = addr.get('netmask', None)\n                if nmask:\n                    print '    Netmask  : %s' % nmask\n                bcast = addr.get('broadcast', None)\n                if bcast:\n                    print '    Broadcast: %s' % bcast\n    if ipv6_addr:\n        print \"Found IPv6 address: %s\" %ipv6_addr\n    else:\n        print \"No IPv6 interface found!\"  \n\nif __name__ == '__main__':\n    inspect_ipv6_support()\n```", "```py\n$ python 3_10_check_ipv6_support.py \nIPV6 support built into Python: True \nInterface lo: \n Address family: AF_PACKET \n Address  : 00:00:00:00:00:00 \n Address family: AF_INET \n Address  : 127.0.0.1 \n Netmask  : 255.0.0.0 \n Address family: AF_INET6 \n Address  : ::1 \n Netmask  : ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff \nInterface eth0: \n Address family: AF_PACKET \n Address  : 08:00:27:95:0d:1a \n Broadcast: ff:ff:ff:ff:ff:ff \n Address family: AF_INET \n Address  : 10.0.2.15 \n Netmask  : 255.255.255.0 \n Broadcast: 10.0.2.255 \n Address family: AF_INET6 \n Address  : fe80::a00:27ff:fe95:d1a\n Netmask  : ffff:ffff:ffff:ffff:: \nFound IPv6 address: {'lo': '::1', 'eth0': 'fe80::a00:27ff:fe95:d1a'}\n\n```", "```py\n#!/usr/bin/env python\n# Python Network Programming Cookbook -- Chapter – 3\n# This program is optimized for Python 2.7.\n# It may run on any other version with/without modifications.\n\nimport socket\nimport netifaces as ni\nimport netaddr as na\n\ndef extract_ipv6_info():\n    \"\"\" Extracts IPv6 information\"\"\"\n    print \"IPV6 support built into Python: %s\" %socket.has_ipv6\n    for interface in ni.interfaces():\n        all_addresses = ni.ifaddresses(interface)\n        print \"Interface %s:\" %interface\n        for family,addrs in all_addresses.iteritems():\n            fam_name = ni.address_families[family]\n            #print '  Address family: %s' % fam_name\n            for addr in addrs:\n                if fam_name == 'AF_INET6':\n                    addr = addr['addr']\n                    has_eth_string = addr.split(\"%eth\")\n                    if has_eth_string:\n       addr = addr.split(\"%eth\")[0]\n       print \"    IP Address: %s\" %na.IPNetwork(addr)\n       print \"    IP Version: %s\" %na.IPNetwork(addr).version\n       print \"    IP Prefix length: %s\" %na.IPNetwork(addr).prefixlen\n       print \"    Network: %s\" %na.IPNetwork(addr).network\n       print \"    Broadcast: %s\" %na.IPNetwork(addr).broadcast\nif __name__ == '__main__':\n    extract_ipv6_info()\n```", "```py\n$ python 3_11_extract_ipv6_prefix.py \nIPV6 support built into Python: True \nInterface lo: \n IP Address: ::1/128 \n IP Version: 6 \n IP Prefix length: 128 \n Network: ::1 \n Broadcast: ::1 \nInterface eth0: \n IP Address: fe80::a00:27ff:fe95:d1a/128 \n IP Version: 6 \n IP Prefix length: 128 \n Network: fe80::a00:27ff:fe95:d1a \n Broadcast: fe80::a00:27ff:fe95:d1a \n\n```", "```py\n#!/usr/bin/env python\n# Python Network Programming Cookbook -- Chapter - 3\n# This program is optimized for Python 2.7.\n# It may run on any other version with/without modifications.\n\nimport argparse \nimport socket\nimport sys\n\nHOST = 'localhost'\n\ndef echo_server(port, host=HOST):\n    \"\"\"Echo server using IPv6 \"\"\"\n    for res in socket.getaddrinfo(host, port, socket.AF_UNSPEC, \t\t\t\tsocket.SOCK_STREAM, 0, socket.AI_PASSIVE):\n        af, socktype, proto, canonname, sa = res\n        try:\n            sock = socket.socket(af, socktype, proto)\n        except socket.error, err:\n            print \"Error: %s\" %err\n\n        try:\n            sock.bind(sa)\n            sock.listen(1)\n            print \"Server listening on %s:%s\" %(host, port)\n        except socket.error, msg:\n            sock.close()\n            continue\n        break\n        sys.exit(1)\n    conn, addr = sock.accept()\n    print 'Connected to', addr\n    while True:\n        data = conn.recv(1024)\n        print \"Received data from the client: [%s]\" %data\n        if not data: break\n        conn.send(data)\n        print \"Sent data echoed back to the client: [%s]\" %data\n    conn.close()\n\nif __name__ == '__main__':\n    parser = argparse.ArgumentParser(description='IPv6 Socket Server Example')\n    parser.add_argument('--port', action=\"store\", dest=\"port\", type=int, required=True)\n    given_args = parser.parse_args() \n    port = given_args.port\n    echo_server(port)\n```", "```py\n#!/usr/bin/env python\n# Python Network Programming Cookbook -- Chapter - 3\n# This program is optimized for Python 2.7.\n\n# It may run on any other version with/without modifications.\n\nimport argparse\nimport socket\nimport sys\n\nHOST = 'localhost'\nBUFSIZE = 1024\n\ndef ipv6_echo_client(port, host=HOST):\n    for res in socket.getaddrinfo(host, port, socket.AF_UNSPEC, socket.SOCK_STREAM):\n        af, socktype, proto, canonname, sa = res\n        try:\n            sock = socket.socket(af, socktype, proto)\n        except socket.error, err:\n            print \"Error:%s\" %err\n        try:\n            sock.connect(sa)\n        except socket.error, msg:\n            sock.close()\n            continue\n    if sock is None:\n        print 'Failed to open socket!'\n        sys.exit(1)\n    msg = \"Hello from ipv6 client\"\n    print \"Send data to server: %s\" %msg\n    sock.send(msg)\n    while True:\n        data = sock.recv(BUFSIZE)\n        print 'Received from server', repr(data)\n        if not data: \n            break\n    sock.close()\nif __name__ == '__main__': \n    parser = argparse.ArgumentParser(description='IPv6 socket client example')\n    parser.add_argument('--port', action=\"store\", dest=\"port\", type=int, required=True)\n    given_args = parser.parse_args() \n    port = given_args.port\n    ipv6_echo_client(port)\n```", "```py\n$ python 3_12a_ipv6_echo_server.py --port=8800 \nServer lisenting on localhost:8800 \nConnected to ('127.0.0.1', 35034) \nReceived data from the client: [Hello from ipv6 client] \nSent data echoed back to the client: [Hello from ipv6 client] \n\n```", "```py\n$ python 3_12b_ipv6_echo_client.py --port=8800 \nSend data to server: Hello from ipv6 client \nReceived from server 'Hello from ipv6 client' \n\n```"]