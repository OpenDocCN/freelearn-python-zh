["```py\n    C:\\Program>Files\\MongoDB\\Server\\7.0\\bin. You need to open the terminal in this location to run the daemon or run:\n\n    ```", "```py\n\n    ```", "```py\n$ pip install sqlalchemy\n```", "```py\n    from sqlalchemy.orm import DeclarativeBase\n    class Base(DeclarativeBase):\n        pass\n    ```", "```py\n    from sqlalchemy.orm import (\n        Mapped,\n        mapped_column\n    )\n    class User(Base):\n        __tablename__ = \"user\"\n        id: Mapped[int] = mapped_column(\n            primary_key=True,\n        )\n        name: Mapped[str]\n        email: Mapped[str]\n    ```", "```py\n    DATABASE_URL = \"sqlite:///./test.db\"\n    ```", "```py\n    from sqlalchemy import create_engine\n    engine = create_engine(DATABASE_URL)\n    ```", "```py\n    Base.metadata.create_all(bind=engine)\n    ```", "```py\nfrom sqlalchemy.orm import sessionmaker\nSessionLocal = sessionmaker(\n    autocommit=False, autoflush=False, bind=engine\n)\n```", "```py\nfrom database import SessionLocal\ndef get_db()\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n```", "```py\nfrom fastapi import Depends, FastAPI\nfrom sqlalchemy.orm import Session\nfrom database import SessionLocal\napp = FastAPI()\n@app.get(\"/users/\")\ndef read_users(db: Session = Depends(get_db)):\n    users = db.query(User).all()\n    return users\n```", "```py\n$ uvicorn main:app –-reload\n```", "```py\nclass UserBody(BaseModel):\n    name: str\n    email: str\n@app.post(\"/user\")\ndef add_new_user(\n    user: UserBody,\n    db: Session = Depends(get_db)\n):\n    new_user = User(\n        name=user.name,\n        email=user.email\n    )\n    db.add(new_user)\n    db.commit()\n    db.refresh(new_user)\n    return new_user\n```", "```py\nfrom fastapi import HTTPException\n@app.get(\"/user\")\ndef get_user(\n    user_id: int,\n    db: Session = Depends(get_db)\n    ):\n    user = (\n        db.query(User).filter(\n            User.id == user_id\n        ).first()\n    )\n    if user is None:\n        raise HTTPException(\n            status_code=404,\n            detail=\"User not found\"\n        )\n    return user\n```", "```py\n@app.post(\"/user/{user_id}\")\ndef update_user(\n    user_id: int,\n    user: UserBody,\n    db: Session = Depends(get_db),\n):\n    db_user = (\n        db.query(User).filter(\n            User.id == user_id\n        ).first()\n    )\n    if db_user is None:\n        raise HTTPException(\n            status_code=404,\n            detail=\"User not found\"\n        )\n    db_user.name = user.name\n    db_user.email = user.email\n    db.commit()\n    db.refresh(db_user)\n    return db_user\n```", "```py\n@app.delete(\"/user\")\ndef delete_user(\n    user_id: int, db: Session = Depends(get_db)\n):\n    db_user = (\n        db.query(User).filter(\n            User.id == user_id\n        ).first()\n    )\n    if db_user is None:\n        raise HTTPException(\n            status_code=404,\n            detail=\"User not found\"\n        )\n    db.delete(db_user)\n    db.commit()\n    return {\"detail\": \"User deleted\"}\n```", "```py\n$ uvicorn main:app\n```", "```py\n$ pip install pymongo\n```", "```py\n    From pymongo import MongoClient\n    client = MongoClient()\n    database = client.mydatabase\n    ```", "```py\n    user_collection = database[\"users\"]\n    ```", "```py\n    from database import user_collection\n    from fastapi import FastAPI, HTTPException\n    from pydantic import BaseModel\n    app = FastAPI()\n    class User(BaseModel):\n        name: str\n        email: str\n    @app.get(\"/users\")\n    def read_users() -> list[User]:\n        return [user for user in user_collection.find()]\n    ```", "```py\n    $ mongod\n    ```", "```py\n    $ C:\\Program>Files\\MongoDB\\Server\\7.0\\bin\\mongod\n    ```", "```py\n$ uvicorn main:app\n```", "```py\nclass UserResponse(User):\n    id: str\n@app.post(\"/user\")\ndef create_user(user: User):\n    result = user_collection.insert_one(\n        user.model_dump(exclude_none=True)\n    )\n    user_response = UserResponse(\n        id=str(result.inserted_id),\n         *user.model_dump()\n    )\n    return user_response\n```", "```py\nfrom bson import ObjectId\n@app.get(\"/user\")\ndef get_user(user_id: str):\n    db_user = user_collection.find_one(\n        {\n            \"_id\": ObjectId(user_id)\n            if ObjectId.is_valid(user_id)\n            else None\n        }\n    )\n    if db_user is None:\n        raise HTTPException(\n            status_code=404,\n            detail=\"User not found\"\n        )\n    user_response = UserResponse(\n        id=str(db_user[\"_id\"]), **db_user\n    )\n    return user_response\n```", "```py\n$ uvicorn main:app\n```", "```py\n$ pip install pydantic[email]\n```", "```py\nfrom typing import Optional\nfrom pydantic import BaseModel, EmailStr\nclass UserCreate(BaseModel):\n    name: str\nname is a required string and email must be a valid email address. FastAPI will automatically use this model to validate incoming data for any endpoint that expects a UserCreate object.\nLet’s say you try to add a user at the `POST /user` endpoint with an invalid user information body, as shown here:\n\n```", "```py\n\n You will get a `422` response with a message body specifying the invalid fields.\nSerialization and deserialization concepts\n**Serialization** is the process of converting complex data types, such as Pydantic models or database models, into simpler formats such as JSON, which can be easily transmitted over the network. **Deserialization** is the reverse process, converting incoming data into complex Python types.\nFastAPI handles serialization and deserialization automatically using Pydantic models. When you return a Pydantic model from an endpoint, FastAPI serializes it to JSON. Conversely, when you accept a Pydantic model as an endpoint parameter, FastAPI deserializes the incoming JSON data into the model.\nFor example, the `get_user` endpoint from the NoSQL example can be improved further like so:\n\n```", "```py\nfrom pydantic import BaseModel, EmailStr, field_validator\nclass User(BaseModel):\n    name: str\n    email: EmailStr\n    age: int\n@field_validator(\"age\")\n    def validate_age(cls, value):\n        if value < 18 or value > 100:\n            raise ValueError(\n                \"Age must be between 18 and 100\"\n            )\nage field of the User model is between 18 and 100.\nIf the validation fails, a descriptive error message is automatically returned to the client.\n`list`, `dict`, and custom types, allowing you to define models that closely represent your data structures.\nFor instance, you can have a model with a list of items:\n\n```", "```py\nuploads_and_downloads/\n|─ uploads/\n|─ main.py\n```", "```py\nfrom fastapi import FastAPI, File, UploadFile\napp = FastAPI()\n@app.post(\"/uploadfile\")\nasync def upload_file(\n    file: UploadFile = File(...)):\n    return {\"filename\": file.filename}\n```", "```py\nimport shutil\nfrom fastapi import FastAPI, File, UploadFile\napp = FastAPI()\n@app.post(\"/uploadfile\")\nasync def upload_file(\n    file: UploadFile = File(...),\n):\n    with open(\nf\"uploads/{file.filename}\", \"wb\"\n    ) as buffer:\n        shutil.copyfileobj(file.file, buffer)\n    return {\"filename\": file.filename}\n```", "```py\nfrom fastapi.responses import FileResponse\n@app.get(\n    \"/downloadfile/{filename}\",\n    response_class=FileResponse,\n)\nasync def download_file(filename: str):\n    if not Path(f\"uploads/{filename}\").exists():\n        raise HTTPException(\n            status_code=404,\n            detail=f\"file {filename} not found\",\n        )\n    return FileResponse(\n        path=f\"uploads/{filename}\", filename=filename\n    )\n```", "```py\n    from fastapi import FastAPI\n    app = FastAPI()\n    ```", "```py\n    import time\n    @app.get(\"/sync\")\n    def read_sync():\n        time.sleep(2)\n        return {\n            \"message\": \"Synchrounouns blocking endpoint\"\n        }\n    ```", "```py\n    import asyncio\n    @app.get(\"/async\")\n    async def read_async():\n        await asyncio.sleep(2)\n        return {\n            \"message\": \n            \"Asynchronous non-blocking endpoint\"\n        }\n    ```", "```py\n    import uvicorn\n    from main import app\n    def run_server():\n        uvicorn.run(app, port=8000, log_level=\"error\")\n    ```", "```py\n    from contextlib import contextmanager\n    from multiprocessing import Process\n    @contextmanager\n    def run_server_in_process():\n        p = Process(target=run_server)\n        p.start()\n        time.sleep(2)  # Give the server a second to start\n        print(\"Server is running in a separate process\")\n        yield\n        p.terminate()\n    ```", "```py\n    async def make_requests_to_the_endpoint(\n        n: int, path: str\n    ):\n        async with AsyncClient(\n            base_url=\"http://localhost:8000\"\n        ) as client:\n            tasks = (\n                client.get(path, timeout=float(\"inf\"))\n                for _ in range(n)\n            )\n            await asyncio.gather(*tasks)\n    ```", "```py\n    async def main(n: int = 10):\n        with run_server_in_process():\n            begin = time.time()\n            await make_requests_to_the_endpoint(n,\n                                                \"/sync\")\n            end = time.time()\n            print(\n                f\"Time taken to make {n} requests \"\n                f\"to sync endpoint: {end - begin} seconds\"\n            )\n            begin = time.time()\n            await make_requests_to_the_endpoint(n,\n                                                \"/async\")\n            end = time.time()\n            print(\n                f\"Time taken to make {n} requests \"\n                f\"to async endpoint: {end - begin}\n                seconds\"\n            )\n    ```", "```py\n    if __name__ == \"__main__\":\n        asyncio.run(main())\n    ```", "```py\n10, your output will likely resemble the one on my machine:\n\n```", "```py\n\n It looks like there is no improvement at all with using asyncio programming.\nNow, try to set the number of calls to `100`:\n\n```", "```py\n\n The output will likely be more like this:\n\n```", "```py\n\n This improvement is certainly noteworthy, and it’s all thanks to the use of asynchronous functions.\nThere’s more…\nAsynchronous data operations can significantly improve the performance of your application, particularly when dealing with high-latency operations such as database access. By not blocking the main thread while waiting for these operations to complete, your application remains responsive and capable of handling other incoming requests or tasks.\nIf you already wrote CRUD operations synchronously, as we did in the previous recipe, *Understanding CRUD operations with SQLAlchemy*, implementing asynchronous CRUD operations in FastAPI involves modifying your standard CRUD functions so that they’re asynchronous with the `sqlalchemy[asyncio]` library. Similarly to SQL, for NoSQL, you will need to use the `motor` package, which is the asynchronous MongoDB client built on top of `pymongo`.\nHowever, it’s crucial to use asynchronous programming judiciously. Not all parts of your application will benefit from asynchrony, and in some cases, it can introduce complexity. Here are some best practices for using asynchronous programming in FastAPI:\n\n*   **Use Async for I/O-bound operations**: Asynchronous programming is most beneficial for I/O-bound operations (such as database access, file operations, and network requests). CPU-bound tasks that require heavy computation might not benefit as much from asynchrony.\n*   **Database transactions**: When working with databases asynchronously, be mindful of transactions. Ensure that your transactions are correctly managed to maintain the integrity of your data. This often involves using context managers (async with) to handle sessions and transactions.\n*   **Error handling**: Asynchronous code can make error handling trickier, especially with multiple concurrent tasks. Use try-except blocks to catch and handle exceptions appropriately.\n*   `async` and `await` in your test cases as needed.\n\nBy understanding and applying these concepts, you can build applications that are not only robust but also capable of performing optimally under various load conditions. This knowledge is a valuable addition to your skillset as a modern web developer working with FastAPI.\nSee also\nAn overview of the concurrency use of the `asyncio` library in FastAPI can be found on the documentation page:\n\n*   *FastAPI* *C**oncurrency*: [https://fastapi.tiangolo.com/async/](https://fastapi.tiangolo.com/async/)\n\nTo integrate `async`/`await` syntax with **SQLAlchemy**, you can have a look at documentation support:\n\n*   *SQLAlchemy* *Asyncio*: [https://docs.sqlalchemy.org/en/20/orm/extensions/asyncio.xhtml](https://docs.sqlalchemy.org/en/20/orm/extensions/asyncio.xhtml)\n\n[*Chapter 6*](B21025_06.xhtml#_idTextAnchor193), *Integrating FastAPI with SQL Databases*, will focus on SQL database interactions. Here, you can find examples of integrating `asyncio` with `sqlalchemy`.\nTo integrate `asyncio` with `motor`, which is built on top of `pymongo`:\n\n*   *Motor asynchronous* *driver*: [https://motor.readthedocs.io/en/stable/](https://motor.readthedocs.io/en/stable/)\n\nIn [*Chapter 7*](B21025_07.xhtml#_idTextAnchor227), *Integrating FastAPI with NoSQL Databases*, you will find examples of motor integration with FastAPI.\nSecuring sensitive data and best practices\nIn the realm of web development, the security of sensitive data is paramount.\nThis recipe is a checklist of best practices for securing sensitive data in your FastAPI applications.\nGetting ready\nFirst and foremost, it’s crucial to understand the types of data that need protection. *Sensitive data* can include anything from passwords and tokens to personal user details. Handling such data requires careful consideration and adherence to security best practices.\nUnderstanding the types of data that require protection sets the foundation for implementing robust security measures, such as leveraging environment variables for sensitive configurations, a key aspect of data security in app development.\nInstead of hardcoding these values in your source code, they should be stored in environment variables, which can be accessed securely within your application. This approach not only enhances security but also makes your application more flexible and easier to configure across different environments.\nAnother important practice is encrypting sensitive data, particularly passwords. FastAPI doesn’t handle encryption directly, but you can use libraries such as `bcrypt` or `passlib` to hash and verify passwords securely.\nThis recipe will provide a checklist of good practices to apply to secure sensitive data.\nHow to do it…\nSecurely handling data in FastAPI involves more than just encryption; it encompasses a range of practices that are designed to protect data throughout its life cycle in your application.\nHere is a list of good practices to apply when securing your application.\n\n*   **Validation and sanitization**: Use the Pydantic model to validate and sanitize incoming data, as shown in the *Working with data validation and serialization* recipe. Ensure the data conforms to expected formats and values, reducing the risk of injection attacks or malformed data causing issues.\n\n    Be cautious with data that will be output to users or logs. Sensitive information should be redacted or anonymized to prevent accidental disclosure.\n\n*   **Access control**: Implement robust access control mechanisms to ensure that users can only access the data they are entitled to. This can involve **role-based access control** (**RBAC**), permission checks and properly managing user authentication. You will discover more about this in the *Setting up* *RBAC* recipe in [*Chapter 4*](B21025_04.xhtml#_idTextAnchor122), *Authentication* *and Authorization*.\n*   **Secure communication**: Use HTTPS to encrypt data in transit. This prevents attackers from intercepting sensitive data that’s sent to or received from your application.\n*   **Database security**: Ensure that your database is securely configured. Use secure connections, avoid exposing database ports publicly, and apply the principle of least privilege to database access.\n*   **Regular updates**: Keep your dependencies, including FastAPI and its underlying libraries, up to date. This helps protect your application from vulnerabilities discovered in older versions of the software.\n\nSome of them will be covered in detail throughout this book.\nThere’s more…\nManaging sensitive data extends beyond immediate security practices and involves considerations for data storage, transmission, and even deletion.\nHere’s a checklist of more general practices so that you can secure your data, regardless of whatever code you are writing:\n\n*   **Data storage**: Store sensitive data only when necessary. If you don’t need to store data such as credit card numbers or personal identification numbers, then don’t. When storage is necessary, ensure it is encrypted and that access is tightly controlled.\n*   **Data transmission**: Be cautious when transmitting sensitive data. Use secure APIs and ensure that any external services you interact with also follow security best practices.\n*   **Data retention and deletion**: Have clear policies on data retention and deletion. When data is no longer needed, ensure it is deleted securely, leaving no trace in backups or logs.\n*   **Monitoring and logging**: Implement monitoring to detect unusual access patterns or potential breaches. However, be careful with what you log. Avoid logging sensitive data and ensure that logs are stored securely and are only accessible to authorized personnel.\n\nBy applying these practices, you can significantly enhance the security posture of your applications, protecting both your users and your organization from potential data breaches and ensuring compliance with data protection regulations. As a developer, understanding and implementing data security is not just a skill but a responsibility in today’s digital landscape. In the next chapter, we will learn how to build an entire RESTful API with FastAPI.\n\n```", "```py\n\n```", "```py\n\n```"]