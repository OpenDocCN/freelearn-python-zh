<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Advanced RESTful API Patterns</h1>
                </header>
            
            <article>
                
<p>Every software designer agrees that design patterns, and solving familiar yet recurring design problems by implementing design patterns, are inevitable in the modern software design-and-development life cycle. In general, there are various API design patterns, and in our earlier chapter, we covered a few fundamental RESTful API patterns. We'll delve into few advanced API design patterns in this chapter, as those patterns are necessary for real-time RESTful services and what the software industry needed at this moment.</p>
<p>This chapter is part two of API design patterns; the intention is to cover a number of advanced design patterns, such as versioning, and backend for frontend. Once readers have gone through this chapter, they should know how to implement the following patterns:</p>
<ul>
<li>Versioning</li>
<li>Authorization</li>
<li>Uniform contract</li>
<li>Entity endpoint</li>
<li>Endpoint redirection</li>
<li>Idempotent</li>
<li>Bulk operations</li>
<li>Circuit breaker</li>
<li>API facade</li>
<li>Backend for frontend</li>
</ul>
<div class="packt_infobox">Please don't forget to go through the Investor Service code examples and learn the advance pattern implementations as well.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>As this chapter deals with advanced patterns, we expect that readers have knowledge of a few basic software design patterns and practices, Java's programming ability,Spring framework, and RESTful services.</p>
<p>To run this chapter's sample code, please refer to <a href="bdb7c23e-8c80-4a89-af31-e40d1b4c1d36.xhtml" target="_blank">Chapter 3,</a> <em>Essential RESTful API Patterns<span>, </span></em>for the additional technical requirement and information on how to run the sample codes provided here.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">RESTful API advanced patterns</h1>
                </header>
            
            <article>
                
<p>We covered few critical RESTful patterns in the earlier chapter; now it's time to get into more advanced patterns and get our hands dirty to provide our customers and app developers with the best-possible RESTful services implementation. Let's start learning how to implement versioning for our services.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Versioning</h1>
                </header>
            
            <article>
                
<p>Many books and articles recommend avoiding versioning APIs if possible. However, it's not practical to believe that we'll develop one API that caters to almost every requirement within the first release and never changes, so we avoid versioning altogether. A few others recommend providing different URIs for different (major) version changes. Ideally, we'd manage APIs just like website URLs (most of the time the URL address never changes, regardless of any changes/implementations).</p>
<p>The general rules of thumb we'd like to follow when versioning APIs are as follows:</p>
<ul>
<li>Upgrade the API to a new major version when the new implementation breaks the existing customer implementations</li>
<li>Upgrade the API to a new minor version of the API when the new implementation provides enhancements and bug fixes; however, ensure that the implementation takes care of backward-compatibility and has no impact on the existing customer implementations</li>
</ul>
<p>Let's consider that we need to manage the versions in our API; there are four different ways that we can implement the versioning, and we will see each type in the following sections.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Versioning through the URI path</h1>
                </header>
            
            <article>
                
<p>The major and minor version changes can be a part of the <span class="MsoIntenseEmphasis">URI</span>, for example, to represent <kbd>v1</kbd> or <kbd>v2</kbd> of the API the URI can be <kbd>http://localhost:9090/v1/investors</kbd> or <kbd>http://localhost:9090/v2/investors</kbd>, respectively.</p>
<p>The code implementation of the <span class="MsoIntenseEmphasis">URI</span> path versioning within our investor service examples is shown in the following code snippet:</p>
<pre>@GetMapping({"/v1/investors","/v1.1/investors","/v2/investors"})<br/>  public List&lt;Investor&gt; fetchAllInvestors()<br/>    {<br/>       return investorService.fetchAllInvestors();<br/>    }</pre>
<p>The output of this code is as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ef8d6d77-07f1-4b04-89b8-4338b44fed22.png"/></p>
<p>The preceding screenshot shows the Postman execution of the URI path-versioning example.</p>
<p>URI path changes according to the version violates the RESTful principles of URI and its resource representation (two different URIs represent the same resources—the only difference is <kbd>v1</kbd>, <kbd>v2</kbd>, and so on, in our example). However, URI path versioning is a popular way of managing API versions due to its simple implementation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Versioning through query parameters</h1>
                </header>
            
            <article>
                
<p>The other simple method for implementing the version reference is to make it part of the request parameters, as we see in the following examples—<kbd>http://localhost:9090/investors?version=1</kbd>,<kbd> http://localhost:9090/investors?version=2.1.0</kbd>:</p>
<pre>@GetMapping("/investors")<br/>public List&lt;Investor&gt; fetchAllInvestorsForGivenVersionAsParameter(<br/>@RequestParam("version") String version)<br/>throws VersionNotSupportedException {<br/>if (!(version.equals("1.1") || version.equals("1.0"))) {<br/>throw new VersionNotSupportedException("version " + version);<br/>}<br/>return investorService.fetchAllInvestors();<br/>}</pre>
<p>The output of this is as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/58f88ef3-5e1c-4134-80b5-ae18620aeab4.png"/></p>
<p>The preceding screenshot shows the implementation of versioning through parameters within our sample.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Versioning through custom headers</h1>
                </header>
            
            <article>
                
<p>Define a new header that contains the version number in the request as part of request header itself. A custom header allows the client to maintain the same URIs, regardless of any version upgrades. This implementation is the kind of content-negotiation that we saw in <a href="edae86df-d90e-4b4c-9ada-4de80edaef71.xhtml" target="_blank">Chapter 2</a>, <em><span>Design Strategy, Guidelines, and Best Practices</span></em> and we'll see it in the next section as well. The following code snippet will help us understand the version implementation through a custom header named <kbd>x-resource-version</kbd>. Please note that the custom header name can be any name; in our example, we name it <kbd>x-resource-version</kbd>:</p>
<pre>@GetMapping("/investorsbycustomheaderversion")<br/>public List&lt;Investor&gt; fetchAllInvestors...(<br/>@RequestHeader("x-resource-version") String version)<br/>throws VersionNotSupportedException {<br/>return getResultsAccordingToVersion(version);<br/>}</pre>
<p>The output of the preceding code is as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/739fc842-0022-4445-b372-e02e5bf7d622.png"/></p>
<p>The preceding screenshot is an example of versioning through the <kbd>x-resource-version</kbd> custom header and executing the same code example with postman.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Versioning through content-negotiation</h1>
                </header>
            
            <article>
                
<p>Providing the version information through the <span class="packt_screen">Accept</span> (request) header along with the content-type (media) in response is the preferred way as this helps to version APIs without any impact on the URI. As we've already learned about content-negotiation, in <a href="edae86df-d90e-4b4c-9ada-4de80edaef71.xhtml">Chapter 2</a>, <em><span>Design Strategy, Guidelines, and Best Practices</span></em>, let's jump to a code implementation of versioning through <span class="packt_screen">Accept</span> and <span class="packt_screen">Content-Type</span>:</p>
<pre>@GetMapping(value = "/investorsbyacceptheader",<br/>headers = "Accept=application/investors-v1+json,<br/>application/investors-v1.1+json")<br/>public List&lt;Investor&gt; fetchAllInvestorsForGiven..()<br/>throws VersionNotSupportedException {<br/>return getResultsAccordingToVersion("1.1");<br/>}</pre>
<p>The following screenshot is the output of the preceding code:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a61c3d39-725e-4418-a1bc-64ee56ea21ef.png"/></p>
<p>The preceding screenshot of the postman tool depicts the execution of our investor service app versioning through the <span class="packt_screen">Accept</span> header. Please observe the response header content-type as well.</p>
<p>As we have seen, each type of versioning methodology has advantages and disadvantages, so we need to determine the right approach on a case-by-case basis. However, the content-negotiation and custom headers are a proponent of RESTful-compliant services. We will move on to one of the essential pattern authentication and authorization.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Authorization</h1>
                </header>
            
            <article>
                
<p>So far, we've built a sample application investor service with various incorporated patterns. Now, how do we ensure our REST API implementation is accessible only to genuine users and not to everyone? In our example, the investor's list should not be visible to all users, and the stocks URI should not be exposed to anyone other than the legitimate investor. Here comes the Authorization header to help us out. We'll use a scheme called <strong>basic authentication</strong> as it solves our current requirement. Please note that there are different schemes, such as basic authentication, <strong>hash-based message authentication</strong> (<strong>HMAC</strong>), <strong>JSON Web Token</strong> (<strong>JWT</strong>), and OAuth 2.0 bearer authentication token scheme, that are available to secure the REST APIs. However, for this section, we are implementing simple basic authentication through the authorization header, and we'll cover OAuth 2.0 in detail in <a href="adb6e30f-4e7f-49d7-bf62-7dddebd4afc5.xhtml" target="_blank">Chapter 6</a>, <em>RESTful Services API Testing and Security</em>.</p>
<p>Let's start with a simple overview of basic authentication. It's a standard HTTP header (RESTful API constraint compliant) with the user's credentials encoded in Base64. The credentials (username and password) are encoded in the format of username—password. Please note that the credentials are encoded not encrypted, and it's vulnerable to specific security attacks, so it's inevitable that the rest API implementing basic authentication will communicate over SSL (https).</p>
<p>We will also need to understand authentication versus authorization. The authentication verifies who (user) is accessing the APIs, and authorization is whether the accessing user has privileges or is authorized to access the API resources. Admin users of our investor service example are authorized to see all the investors, and individual users aren't authorized to see other investors' information.</p>
<p>The Spring security framework provides an out-of-the-box security implementation, and we'll use Spring-provided functionalities to secure our API. As we are going to discuss more security implementations in <a href="5f63aa25-ec1b-41a2-afef-4c4ab7ab1cfd.xhtml" target="_blank">Chapter 9</a>, <em>A More In-depth View of the RESTful Services Paradigm</em><span>, </span>we'll stick to a basic authentication implementation in this chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Authorization with the default key</h1>
                </header>
            
            <article>
                
<p>Securing the REST API with basic authentication is exceptionally simplified by the Spring security framework. Merely adding the following entries in <kbd>pom.xml</kbd> provides basic authentication to our investor service app:</p>
<pre>&lt;dependency&gt;<br/>&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/>&lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;<br/>&lt;/dependency&gt;</pre>
<p>Now rebuild <span class="QuoteChar">(<kbd>mvn clean package</kbd>)</span> the application and restart it. It's time to test our APIs with the postman tool. When we hit the URL, unlike our earlier examples, we'll see an error complaining <span class="MsoIntenseEmphasis"><kbd>Full authorization required to access this resource</kbd></span>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ae6b7bf4-3260-405a-b013-faa999ef1472.png"/></p>
<p>The preceding error is due to the addition of spring-security into our <kbd>pom.xml</kbd> file. How are we going to access our REST API now? Don't worry, on the console where we started our app, we can observe a text using the default security password or search for it in our log file. That's the key for anyone to access our API. The following screenshot shows this:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/eddef983-d7e3-4657-9bf5-4f9ad082fff9.png"/></p>
<p>As we see in the preceding screenshot, our console displays the password that we can use to access our API, and so let's use it for the same URL that we have got error earlier:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/24c652c5-e03d-4861-ba6d-33b5c3a2615b.png"/></p>
<p>As we observe in the previous screenshot, we need to provide <span class="MsoIntenseEmphasis"><span class="packt_screen">BasicAuth</span></span> as the <span class="MsoIntenseEmphasis"><span class="packt_screen">Authorization</span></span> header for the API that we are accessing; we will see the results now without any authentication errors. Please note that the <span class="packt_screen">Authorization</span> header that carries the <kbd>XYZKL...</kbd> token prefixed with <kbd>Basic</kbd>, as we use the HTTP <span class="packt_screen">Authentication</span> header to enforce REST API authentication.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Authorization with credentials</h1>
                </header>
            
            <article>
                
<p>In many real-time situations, we need to use specific credentials to access the API and not the default one; in such cases, we can enhance our investor service application and secure it with our custom credentials by using few additional out-of-the-box spring modules.</p>
<p>In our investor service, we will have a new class, called <kbd>PatronAuthConfig.java</kbd>, which helps the app to enforce the credentials to the URLs that we would like to secure:</p>
<pre>@Configuration 
@EnableWebSecurity 
public class PatronsAuthConfig extends WebSecurityConfigurerAdapter { 
..... </pre>
<p>As we see in the preceding code block, with a few annotations, we can implement the security. The following code snippet shows an override method implementation as well as a few lines of code:</p>
<pre>@Override 
protected void configure(AuthenticationManagerBuilder authMgrBldr) throws Exception { 
  authMgrBldr.inMemoryAuthentication()                      .passwordEncoder(org.springframework.security.crypto.password.NoOpPasswordEncoder.getInstance())                  .withUser(DEFAULT_USER_ID).password(DEFAULT_USER_SECRET).authorities.... 
      } 
 
@Override 
protected void configure(HttpSecurity httpSec) throws Exception { 
httpSec.csrf()..... 
..... </pre>
<p>The following code does the magic of forcing authorization headers to validate for credentials in each request:</p>
<pre>httpSec.csrf().disable().authorizeRequests().and()<br/>.authorizeRequests().antMatchers(NO_RESTRICT_WELCOME_URI)<br/>.permitAll().antMatchers("/investors/admin")<br/>.hasAuthority(DEFAULT_ADMIN_ROLE).antMatchers("/investors/invr*/**")<br/>.access("hasAuthority('"+DEFAULT_USER_ROLE+"')").anyRequest()<br/>.authenticated().and().httpBasic().and().logout();</pre>
<p>Please note that our example uses the following username and password along with two roles. We've provided the sample execution script and postman scripts to execute various scenarios by just clicking the labels:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td style="width: 125px"><strong>User Id</strong></td>
<td style="width: 188px"><strong>Password</strong></td>
<td style="width: 96px"><strong>Role</strong></td>
</tr>
<tr>
<td style="width: 125px"><kbd>admin</kbd></td>
<td style="width: 188px"><kbd>admSecret</kbd></td>
<td style="width: 96px"><kbd>ADMIN</kbd></td>
</tr>
<tr>
<td style="width: 125px"><kbd>user</kbd></td>
<td style="width: 188px"><kbd>usrSecret</kbd></td>
<td style="width: 96px"><kbd>USER</kbd></td>
</tr>
</tbody>
</table>
<p><span>Now, please observe the following screenshot:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f28eb49c-7bac-49da-8ab8-4640c0e03b51.png"/></p>
<p>The preceding screenshot depicts a sample run of one rest API call that needs admin credentials as the authentication header and shows result for valid credentials. On the left-hand side, we can see various test cases; each one has the necessary prerequisites. Now we need to run them one by one and observe the results of each case. Ensure to see the authentication headers as well for each execution.</p>
<div class="packt_tip">The only difference between the investor services example in <a href="bdb7c23e-8c80-4a89-af31-e40d1b4c1d36.xhtml">Chapter 3</a>, <em>Essential RESTful API Patterns,</em> and this authentication example is that we have added a new class, <kbd>PatronsAuthConfig.java</kbd>, that extends the configuration for authentication with the <span class="packt_screen">Authorization</span> header implementation.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Uniform contract</h1>
                </header>
            
            <article>
                
<p>As we mentioned earlier in the <em>API versioning</em> section, services will always evolve with additional capabilities, enhancements, and defects fixes, however, now a service consumer can consume the latest version of our services without the need to keep changing their implementation or REST API endpoints. Also, the service consumer needs to be aware of the latest and evolving details of those service contracts.</p>
<p>The uniform contract pattern comes to the rescue to overcome these problems. The pattern suggests the following measures:</p>
<ul>
<li>Standardize the service contract and make it uniform across any service endpoints</li>
<li>Abstract the service endpoints from individual services capabilities</li>
<li>Follow the REST principles where the endpoints use only HTTP verbs, and express the underlying resources executable actions only with HTTP verbs</li>
</ul>
<p>Please refer to the API versioning examples in the <em>API versioning</em> section as the implementation is already available and it has the flavor (<span>please refer our investor service examples with <kbd>GET</kbd>, <kbd>POST</kbd>, <kbd>DELETE</kbd>, and so on</span>) of the uniform contract. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Entity endpoints</h1>
                </header>
            
            <article>
                
<p>If service clients want to interact with entities, such as investors, and their stocks without needing them to manage a compound identifier for both investor and stock, we need a pattern called <strong>entity endpoint</strong>. Entity endpoints suggest exposing each entity as individual lightweight endpoints of the service they reside in, so the service consumers get the global addressability of service entities:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e14e1db2-4090-4592-800a-7ee0dcef4368.png" style="width:41.83em;height:42.00em;"/></p>
<p>The preceding screenshot illustrates how a service consumer can access individual entity endpoints instead of service endpoints. The entity endpoints expose reusable enterprise resources, so service consumers can reuse and share the entity resources.</p>
<p>Our rest service, the investor service, exposes a couple of entity endpoints, such as <kbd><span class="MsoIntenseEmphasis">/investors/investorId</span></kbd>, and <kbd><span class="MsoIntenseEmphasis">investor/stockId</span></kbd> , and they are few examples of entity endpoints that our service consumer can reuse and standardize.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Endpoint redirection</h1>
                </header>
            
            <article>
                
<p>Changing service endpoints isn't always ideal, However, if it needs to, will the service client know about it and use the new endpoint? Yes, with standard HTTP return codes, <kbd>3xx</kbd>, and with the <strong>Location</strong> header, then by receiving <kbd>301 Moved permanently</kbd> or <kbd>307 Temporary Redirect</kbd>, the service client can act accordingly. The endpoint redirection pattern suggests returning standard HTTP headers and provides an automatic reference of stale endpoints to the current endpoints:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f5eeeb69-01ff-4962-9994-e0ab4bd7f7b7.png" style="width:42.17em;height:41.42em;"/></p>
<p>As we can see, the service consumers may call the new endpoints that are found in the <strong>Location</strong> header.</p>
<p>Please refer to our investor service example for header implementations if you want to play around with 3xx codes and <strong>Location</strong> headers.</p>
<p>Please note that with the HATEOAS implementation at the services, the client could potentially avoid these endpoint redirections.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Idempotent</h1>
                </header>
            
            <article>
                
<p>Imagine a bank's debit API failed immediately after deducting some amount from the client account. However, the client doesn't know about it (as it didn't get any response from the server) and reissues the call to debit! Alas, the client loses money. So how can a service implementation handle messages/data and produce the same results, even after multiple calls?</p>
<div class="packt_infobox">The dictionary meaning of idempotent is <em>representing an element of a set that is untouched when it involves some operations or is otherwise operated on by itself.</em></div>
<p><strong>Idempotent</strong> is one of the fundamental resilience and scalable patterns, as it decouples the service implementation nodes across distributed systems. Whether dealing with data or messages, the services should always have designed for sticking to Idempotent in nature.</p>
<p>There is a simple solution: use the idempotent capabilities of the HTTP web APIs, whereby services can provide a guarantee that any number of repeated calls due to intermittent failures of communication to the service is safe, and process those multiple calls from the server without any side effects.</p>
<p>Please refer to <a href="bdb7c23e-8c80-4a89-af31-e40d1b4c1d36.xhtml">Chapter 3</a>, <em>Essential RESTful API Patterns</em>, for examples of <kbd>DELETE</kbd>, <kbd>PUT</kbd>, and <kbd>PATCH</kbd>, as those are all typical implementation of idempotent services; that is, even after we call <kbd>DELETE</kbd> multiple times for the same stock, it's safe; and the same applies to  <kbd>PUT</kbd> as well.</p>
<p>When it comes to dealing with concurrency, the services can be enhanced with E-Tag and send back a <kbd>409</kbd> conflict response to inform the client that the <span>resource </span>called is in an inconsistent state.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Bulk operation</h1>
                </header>
            
            <article>
                
<p>We have seen many REST API patterns and their implementations. However, we have yet to discuss an essential pattern, called <strong>bulk operations</strong>, within the REST API. It's inevitable that our design should thrive, which will reduce performance bottlenecks, such as response time, and the number of round trips between the server and clients.</p>
<p>Marking a list of emails as read in our email client could be an example of a bulk operation; the customer chooses more than one email to tag as <kbd>Read</kbd>, and one REST API call does the job instead of multiple calls to an underlying API.</p>
<p>Let's take our investor service API: if a client wants to create a set of stocks for their portfolio rather than one by one, the client needs to call our REST endpoint as many times as the number of stocks that they wanted to create. If they need to update 100 stocks, they need to call the endpoint 100 times, and indeed, it isn't an elegant solution. The bulk operations pattern comes to the rescue in such scenarios, without compromising the REST principles. Let's see how our investor services can be modified to provide bulk operations.</p>
<p>The investor service accepts <kbd>PATCH</kbd> for a single element, and we need to think about enhancing the same resource to also accept multiple insertions, or we can have another separate URI to support a bulk operation. Having another URI for the same resource isn't a clean approach as it may deviate from the RESTful principle, and so let's move ahead with the same <kbd>PATCH</kbd> request to support the update of more than one stock through the request. The following two approaches are suggested for implementing bulk operations:</p>
<ul>
<li>Content-based bulk operation</li>
<li>Custom-header action-identifier-based bulk operation</li>
</ul>
<p>Our code example follows both approaches; please note that we don't use any specifics of the framework-provided annotations for the bulk operation. However, we continue to use the custom header and the enhanced request body to support a list of stocks in the client request. The following screenshot depicts the difference in the requests for a non-bulk operation and bulk-operation patch request along with headers:</p>
<p class="mce-root CDPAlignCenter CDPAlign"><img src="assets/4534b4fa-69fc-4f8b-b2be-7ffa7fc10b99.png"/></p>
<p>The following code snippet from the <kbd>InvestorController</kbd> class enforces the custom header, and the list of the <kbd>Stock</kbd> object, unlike the <kbd>PUT</kbd><span> example</span> in <a href="bdb7c23e-8c80-4a89-af31-e40d1b4c1d36.xhtml">Chapter 3</a>, <em>Essential RESTful API Patterns</em>, (accepts only one <kbd>Stock</kbd> object):</p>
<pre>@PatchMapping("/investors/{investorId}/stocks") 
  public ResponseEntity&lt;Void&gt; updateStockOfTheInvestorPortfolio(@PathVariable String investorId, @RequestHeader(value = "x-bulk-patch") Optional&lt;Boolean&gt; isBulkPatch,                  @RequestBody List&lt;Stock&gt; stocksTobeUpdated) throws CustomHeaderNotFoundException { 
            // without custom header we are not going to process this bulk operation 
            if (!isBulkPatch.isPresent()) { 
                  throw new CustomHeaderNotFoundException("x-bulk-patch not found in your headers"); 
            } 
      investorService.bulkUpdateOfStocksByInvestorId(investorId, stocksTobeUpdated); 
            return ResponseEntity.noContent().build(); 
      } </pre>
<p>By running our <kbd>PATCH</kbd> example, we can understand the bulk operations of the RESTful API by grouping multiple items in one request. Please note that the bulk operations may involve many other aspects, such as E-tag, asynchronous executions, or parallel-stream implementation to make it effective. However, we aren't covering these special topics here, and we encourage readers to refer to the <em>Sources, references, and further reading </em>section for resources.</p>
<div class="packt_infobox"><span class="packt_screen">Bulk operations versus batch operations</span><strong><br/></strong><br/>
Bulk operations deal with a single target operation on a varied list of business objects within a single REQ, and batch operations (not covered in this chapter) deal with a heterogeneous and homogeneous list of business objects, but with multiple REQs.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Circuit breaker</h1>
                </header>
            
            <article>
                
<p>We regularly encounter circuit breakers; the circuit breaker is an automatic switch designed to protect entire electrical circuits from damage due to excess current load as a result of a short circuit or overload.</p>
<p>The same concept applies when services interact with many other services. Failure due to any (network) issue can potentially create catastrophic effects across the application, and preventing cascading impacts is the sole aim of a circuit-breaker pattern. Hence, this pattern helps subsystems to fail gracefully and also prevents complete system failure <span>as a result of a</span> subsystem failures:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b70fe87f-468c-4e3e-baa7-dc0909f91f82.png" style="width:43.33em;height:14.25em;"/></p>
<p>The preceding screenshot illustrates the circuit-breaker concept in which one of the downstream services is non-communicable. However, the circuit breaker implementation handles it in such a way that the <strong>API</strong> continues to serve its multiple clients.</p>
<p>Before we delve into the implementation, let's understand the three different states that constitute the circuit breaker:</p>
<ul>
<li><strong>Closed</strong>: This is when all the service interconnections are intact (closed), and all the calls go through intended services. This state needs to keep track of failures to determine threshold limits. If the number of failures exceeds threshold limits, the services will move to the open state to avoid cascading impacts.</li>
<li><strong>Open</strong><span>: The open state of the services is responsible for returning errors without really executing their intended functions.</span></li>
<li><strong>Half-open</strong><span>: Once the services land in the open state, it should periodically (timeout) check for failures that made the services be in the open state. Moreover, if those failures are still occuring, it continues to keep the services in the open state until the next check. If the failures are no longer detected, the responsibility of this state is to trigger back to the closed state for the continuous function.</span></li>
</ul>
<p>It's time to get our hands dirty with the circuit-breaker implementation. We'll use spring annotations, along with an incredibly dominant open source library called <strong><span class="MsoIntenseEmphasis">hysterix</span></strong>, and we can implement the entire concept with very little effort.</p>
<p>We need to have a minimum of two services to explain the circuit-breaker implementation, so we are creating circuit-breaker-service and circuit-breaker-consumer services, which will have the circuit-breaker pattern implemented. The following sections elucidate the investor services implementation of circuit-breaker.</p>
<p>Bring up any service that we've already developed, or, to simplify we have a lightweight service called <strong>circuit-breaker-service</strong>, and please note that this service doesn't have any specific implementation for circuit-breaker.</p>
<p>Now for the critical part of our implementation; that is, a new service called <strong>circuit-breaker-service-consumer</strong>, which will have all the necessary circuit-breaker implementations, along with a call to our first service (circuit-breaker-service). Let's perform the following steps:</p>
<p>Add the hysterix dependency to our <kbd>pom.xml</kbd> (<kbd>circuit-breaker-service-consumer/pom.xml</kbd>):</p>
<pre>&lt;dependency&gt;<br/>&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;<br/>&lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;<br/>&lt;version&gt;2.0.1.RELEASE&lt;/version&gt;<br/>&lt;/dependency&gt;</pre>
<p>Annotate <kbd>InvestorController</kbd> to enable circuit-breaker and introduce a new method for us to test (<kbd>circuit-breaker-service-consumer/com/**/InvestorController.java</kbd>):</p>
<pre><strong>@EnableCircuitBreaker<br/></strong>@RestController<br/>public class InvestorController {<br/>@Autowired<br/>private InvestorService investorService;<br/><span class="MsoIntenseEmphasis">// call the downstream service circuit-breaker-servic</span>e<strong><br/></strong>@GetMapping(value="/welcome", produces="text/plain;charset=UTF-8")<br/>public String welcomePageWhichProducesCharset() {<br/>return investorService.circuitBreakerImplWelcome();<br/>}</pre>
<p>Use the <em>Hystrix</em> command and create a method for the circuit-breaker implementation as well as a fallback method, as can be seen in the following code block. We will have two methods: one for the actual call (<kbd>InvestorService.java/circuitBreakerImplWelcome</kbd>) and another for fallback (<kbd>InvestoreService.java/welcomeUrlFailureFallback</kbd>), so that in case there are failures with the actual call, the app will call the fallback method:</p>
<pre><span class="MsoIntenseEmphasis"> <strong>@HystrixCommand(fallbackMethod="welcomeUrlFailureFallback")<br/></strong></span>public String circuitBreakerImplWelcome() {<br/>logger.info("reached circuit breaker consumer circuit breaker impl");<br/>RestTemplate restTemplate = new RestTemplate();<br/>URI circuitBreakerServiceURI = URI.create(CIRCUIT_BREAKER_SERVICE_URL);<br/>return restTemplate.getForObject(circuitBreakerServiceURI, String.class);<br/>}<br/>// fall back method for welcome page failures<br/><strong>public</strong><br/> <strong>String</strong><br/> <span class="MsoIntenseEmphasis">welcomeUrlFailureFallback</span><br/> <strong>(){<br/></strong>logger.info("lucky we have a fallback method");<br/>return WELCOME_URI_FALLBACK_MESG;<br/>}</pre>
<p>Cool, isn't it! Implementing the circuit-breaker with <em>Hysterix</em> is that simple. Now, let's build and run our services by following these steps:</p>
<ol>
<li>Open a terminal and build circuit-breaker-service (<kbd>mvn clean package</kbd> of circuit-breaker-service)</li>
<li>Bring up circuit-breaker-service</li>
<li>Open a new terminal and build circuit-breaker-service-consumer</li>
<li>Bring up circuit-breaker-service-consumer</li>
<li>Open Postman and run <kbd>http://localhost:9090/welcome</kbd></li>
<li>Observe the Japanese welcome text</li>
<li>Now, execute the circuit-breaker experimentation</li>
<li>Stop the circuit-breaker-service that we started in step 2</li>
<li>Run step 5 again, and now observe the English message</li>
</ol>
<p>Yes, the circuit-breaker fallback is activated, and so we see the English message, not the Japanese message, as the circuit-breaker-service is down. However, the <kbd>/welcome</kbd> URI didn't break.</p>
<p>The following screenshot captured various phases for verifying the circuit-breaker implementation:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a6f18627-1693-4a6f-bfe1-e791d4a460b4.png" style="width:44.08em;height:46.33em;"/></p>
<p>The following screenshot is another phase of this:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/2cd57a68-7473-4762-8fc1-2b273d4f9671.png" style="width:47.08em;height:46.42em;"/></p>
<p>As we can observe in the preceding screenshots, in the pre-implementation of circuit-breaker, the <kbd><span class="MsoIntenseEmphasis">/welcome</span></kbd> call is failing and shows console message connection errors as well. However, after we implement circuit-breaker, the same call shows the content from the fallback method, even though the connections with the circuit-breaker-service are still failing.</p>
<p>Readers and designers are encouraged to test and enhance circuit-breaker-consumer with more fallback methods for other method calls as well.</p>
<div class="packt_tip">The downside of the circuit-breaker pattern is that the applications/services involved may experience slight performance hits. However, it's a good trade-off for many real-world applications.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Combining the circuit pattern and the retry pattern</h1>
                </header>
            
            <article>
                
<p>As software designers, we understand the importance of gracefully handling application failures and failure operations. We may achieve better results by combining the retry pattern and the circuit breaker pattern as it provides the application with greater flexibility in handling failures.</p>
<p>The retry patterns enable the application to retry failed operations, expecting those operations to become operational and eventually succeed. However, it may result in a <strong>denial of service</strong> (<strong>DoS</strong>) attack within our application. The circuit-breaker pattern prevents an application from performing an operation that's likely to fail. How about an intelligent retry mechanism that's sensitive to any failures returned by the circuit breaker that indicates no transient failures, and so the application abandons any further retry attempts?</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">API facade</h1>
                </header>
            
            <article>
                
<p>We knew the pattern called <strong>facade</strong> from GoF, which abstracts the complex subsystem from the callers and exposes only necessary details as interfaces to the end user. API facade' is also aligned with the same definitions and implementations.</p>
<p>Let’s have a look at the following diagram, which depicts a simple implementation of multiple service calls from a client with and without the API facade pattern implementation:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/cb797c53-fd6f-4a9c-ba89-3ff368e9431d.png"/></p>
<p>As we can see in the preceding diagram, the client is calling one API facade to make it simpler and more meaningful in cases where the clients need multiple service calls. However, that can be implemented with a single API endpoint instead of the client calling multiple endpoints. The API facades provide high scalability and high performance as well.</p>
<p><span>Our investor services have implemented a simple API facade implementation for its delete operations. As we saw earlier, the delete methods call the design for intent methods. However, we have made the <em>design for the intent</em> method abstract to the caller by introducing a simple interface to our investor services. That brings the facade to our API.</span></p>
<p>The interface for the delete service is shown as follows:</p>
<pre><strong>public</strong> <strong>interface</strong> DeleteServiceFacade {<br/><strong>    boolean</strong><span> deleteAStock(String investorId, String stockTobeDeletedSymbol);<br/></span>    <strong>boolean<span> deleteStocksInBulk(String investorId, List&lt;String&gt; stocksSymbolsList);<br/>}<br/></span></strong></pre>
<p>The implementation for the delete service interface is shown in the following code snippet:</p>
<pre>@Component<br/>public class DeleteServiceFacadeImpl implements DeleteServiceFacade {<br/>   private static final Logger logger = LoggerFactory.getLogger(InvestorService.class);<br/>   private InvestorServicesFetchOperations investorServicesFetchOperations = new InvestorServicesFetchOperations();<br/>       @Override<br/>       public boolean deleteAStock(String investorId, String stockTobeDeletedSymbol) {<br/>             boolean deletedStatus = false;<br/>             Stock stockTobeDeleted = investorServicesFetchOperations.fetchSingleStockByInvestorIdAndStockSymbol(investorId,<br/>                          stockTobeDeletedSymbol);<br/>             if (stockTobeDeleted != null) {<br/>                    Investor investor = investorServicesFetchOperations.fetchInvestorById(investorId);<br/>                    deletedStatus = investor.getStocks().remove(stockTobeDeleted);<br/>             }<br/>             designForIntentCascadePortfolioDelete(investorId, deletedStatus);<br/>             return deletedStatus;<br/>      }<br/>.....<br/>.....</pre>
<p>As a simple exercise, we encourage the reader to implement our circuit breaker service call as an API facade and to also complete the bulk delete method within the delete service.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Backend for frontend</h1>
                </header>
            
            <article>
                
<p>So far, we have developed various restful service APIs and endpoints so that any app developer can start to use it. However, we need to ensure those services will cater to various types of devices, since its real purpose is to serve any customer using any device, and not only for desktop users or as web-based applications.</p>
<p>Providing a better user experience across any device is vital, regardless of its backend services, and having figured out all possible best practices of developing RESTful services become meaningless if we aren't providing a better mechanism to use those services by heterogeneous end users and to their devices.</p>
<p><strong>Backend for frontend</strong> (<strong>BFF</strong>) is a pattern first described by Sam Newman; it helps to bridge any API design gaps. BFF suggests introducing a layer between the user experience and the resources it calls. It also helps API designers to avoid customizing a single backend (services) for multiple interfaces:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/8d474933-241c-44be-9196-14c92592d5c8.png"/></p>
<p>The preceding diagram depicts a simple implementation of the BFF pattern in the form of exclusive interfaces for both desktop and mobile devices. Each interface can define its necessary and unique requirements that cater to frontend requirements without worrying about impacting other frontend implementations.</p>
<p>Let's examine a number of specific requirements of each interface so that we understand why we need to have multiple interfaces for the same backend services:</p>
<ul>
<li>Response payload formatting and size may differ for each client</li>
<li>Performance bottlenecks and optimization <span>requirements </span>due to the number of calls to be made to services</li>
<li>When in need of shared or general purpose backend services, but with less development and maintenance overhead</li>
</ul>
<p>BFF may not fit in cases such as multiple interfaces making the same requests to the backend, or using only one interface to interact with the backend services.</p>
<p>Please note that there are drawbacks with BFF, and exercise caution when deciding on separate, exclusive APIs/interfaces, as it warrants additional and lifelong maintenance, security improvement within layers, additional customized designs that lead to lapses in security, and defect leaks.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>Learning the patterns with a few code examples always provides us with great insights. In this chapter, we discussed versioning our APIs, securing APIs with authorization, and enabling the service clients with uniform contract, entity endpoint, and endpoint redirection implementations. We also learned about Idempotent and its importance, which powers APIs with bulk operations. The most important part of this chapter is the circuit-breaker implementation with <em>Hysterix</em>, where we envisioned and implemented the resiliency patterns of API designs.</p>
<p>Having covered various advanced patterns, we concluded the chapter with the BFF pattern, and we learned how it reduces churns within the cross-implementation team by helping them to develop an exclusive interface for target environments.</p>
<p>In the next chapter, we'll cover RESTful API gateways, which should be an equally exciting read for API designers.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<ul>
<li>RESTful Java Patterns and Best Practices: <a href="https://www.packtpub.com/application-development/restful-java-patterns-and-best-practices">https://www.packtpub.com/application-development/restful-java-patterns-and-best-practices</a></li>
</ul>


            </article>

            
        </section>
    </body></html>