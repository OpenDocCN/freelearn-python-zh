- en: Programming in ROS - Commands and Tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter focuses on running ROS within GoPiGo3\. In the previous chapter,
    we did the same for a remote laptop, and in the next chapter, we will teach you
    how to make both a robot and your laptop work together as a single ROS environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will finally learn how to use ROS in the depth required
    for the advanced chapters later on, which deal with robot navigation and machine
    learning. ROS can be hard to use at the beginning due to the following factors:'
  prefs: []
  type: TYPE_NORMAL
- en: It is command-line-based.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It handles asynchronous events.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is a distributed computing environment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Paradoxically, these are the three features that make it really powerful for
    programming robots. The  effort you've invested will be worth it, as you will
    soon discover.
  prefs: []
  type: TYPE_NORMAL
- en: 'By working through this chapter, you will become familiar with ROS''s command-line
    interaction and understand the scope of several types of ROS command. You will
    get used to working with the most frequently used communication pattern in ROS:
    publish-subscribe. To access real-time robot data while ROS is running, you will
    be introduced to the *rqt* GUI tools, which ease the work of developing and debugging
    an application. Additionally, ROS parameters will be introduced to give you an
    overview of their power to manage robot configuration at a high level.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be covering the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the physical robot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A quick introduction to ROS programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to write a ROS package (**case study 1**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An overview of ROS commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and running publisher and subscriber nodes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automating the execution of nodes with roslaunch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ROS GUI development tools (**case study 2**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use ROS parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will provide explanations of these concepts based on two practical case
    studies:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Case study 1**: Publishing and reading distance sensors'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Case study 2**: Acquiring and visualizing images from the Pi camera'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There is a third case study dealing with robot control and simulation – **case
    study 3**: robot drives (motors and encoders) – which as a practical example will
    support the concepts that will be covered in [Chapter 7](0653ab6b-8710-41e7-9c01-5024865e3e27.xhtml),
    *Robot Control and Simulation.*'
  prefs: []
  type: TYPE_NORMAL
- en: So, we have three case studies and, as a result of both this chapter and the
    next chapter, we will have our first complete version of the ROS package for GoPiGo3\.
    This will be the foundation on which smart robot behaviors will be built in the
    remaining chapters of the book.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code files for this chapter are available at [https://github.com/PacktPublishing/Hands-On-ROS-for-Robotics-Programming/tree/master/Chapter6_ROS_programming](https://github.com/PacktPublishing/Hands-On-ROS-for-Robotics-Programming/tree/master/Chapter6_ROS_programming).
  prefs: []
  type: TYPE_NORMAL
- en: 'When you have completed the Raspberry Pi setup, as explained in the *Setting
    up a physical robot *section, clone the book repository ([https://github.com/PacktPublishing/Hands-On-ROS-for-Robotics-Programming](https://github.com/PacktPublishing/Hands-On-ROS-for-Robotics-Programming))
    in your home folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember this location in order to keep a check of your work because, in this
    chapter, our intention is that you create all the code by yourself. Alternatively,
    if you decide to use the provided code, you will just need to copy the `Chapter6_ROS_programming` folder to
    the ROS workspace as usual:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The ROS workspace in the robot is initialized in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a physical robot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned in [Chapter 3](f3ecc0de-28c4-4140-9a9c-ed351c68d121.xhtml), *Getting
    Started with ROS*, we will now start working with a physical robot. Therefore,
    the first thing to do is to prepare the software you need to be running in the
    Raspberry Pi. This section will guide you through the process step by step.
  prefs: []
  type: TYPE_NORMAL
- en: Downloading and setting up Ubuntu Mate 18.04
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Mate** is, at the time of writing, the recommended Ubuntu desktop to run
    under Raspberry Pi. It is a complete Ubuntu distribution with a nice desktop interface.
    Follow these steps to make it run in your GoPiGo3:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download the image from [https://ubuntu-mate.org/download/](https://ubuntu-mate.org/download/),
    selecting the Raspberry Pi version (recommended): AArch32 (ARMv7). Burn the image
    onto a micro SD card. Afterward, place it in the slot in the Raspberry Pi, plug
    in a mouse and keyboard, connect to an HDMI screen, and then power on the board.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first time you initiate it, a setup assistant will guide you through the
    process of configuring the operating system. In this book, we assume that the
    Ubuntu user is named `pi`. Change the code as necessary if you use another username.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure that you connect to the local WiFi by selecting a network from the
    list that is deployed when clicking on the wireless icon in the upper-right corner
    of the screen. It is strongly recommended that you add a second mobile WiFi network
    preferably like the one that your smartphone provides. This will avoid the need
    to connect to the HDMI screen, keyboard, and mouse when you move the robot away
    from home in the future.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The following instructions are optional and are believed to provide a friendlier
    way to access the Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: Access customization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more friendly access to your system, it is recommended that you allow your
    Ubuntu user to access `sudo` without a password:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In a terminal, type the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add this line at the end of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Save your changes and exit so that they take effect.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Updating your system and installing basic utilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By running the following command, first you will update the Ubuntu repositories
    in your system; afterward, the system packages will be upgraded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You will need a `git` package in order to clone the repositories of code. If
    this is not on your system, then you can install it using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also add another useful package, `tree`, in order to get information
    from the filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `tree` package is a utility that enables you to view the content of a folder
    and its subfolders at the same time, representing it visually via a tree structure.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling SSH access
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is common to have issues with the SSH server that comes preinstalled with
    Ubuntu:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid any problems, remove the OpenSSH package and install it again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Enable the service so that it starts on boot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Confirm that the SSH server is up and running:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: At this stage, you should be able to log in from this host to any other SSH-enabled
    Ubuntu server, such as your laptop.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a VNC server (x11vnc)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'OpenSSH allows us to log in remotely to our Raspberry Pi using a terminal.
    We will also equip our robot with another remote way of connection, that is, by
    accessing its desktop. In order to do this, we will use `x11vnc`, a package that
    implements a remote desktop using **Virtual Network Computing** (**VNC**):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the Ubuntu repositories and install:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now create a password to connect with a client:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Type in a password and remember it. The password is stored in `/home/pi/.vnc`
    assuming that the current user is `pi`. Then, start the `x11vnc` server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to start the server without needing a password, just remove the
    option from the command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now you are ready to connect with a client using a VNC client such as RealVNC ([https://www.realvnc.com/download/viewer/](https://www.realvnc.com/download/viewer/)).
  prefs: []
  type: TYPE_NORMAL
- en: Setting up autostart on boot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We want `x11vnc` to start automatically when we reboot or power on the Pi.
    Hence, create a script named `x11vnc.service` at location` /lib/systemd/system/`,
    perform the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'While editing, add the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, enable and start the newly created service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: To connect with the RealVNC viewer from a remote PC, enter the IP address of
    the Raspberry Pi followed by the display number, that is, `<IP address>:<display
    number>`. If no display is specified, then it takes `0` as default. Hence, the `0`
    value will be assigned to the first server you launch (which is your unique server).
  prefs: []
  type: TYPE_NORMAL
- en: As you are running VNC with the default port, `5900`, you do not need to specify
    it for the connection. If this is not the case, you should specify the custom
    port in the connection string.
  prefs: []
  type: TYPE_NORMAL
- en: Forcing the HDMI output and screen layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For debugging purposes, it is useful to make sure that you can always access
    the Ubuntu Mate desktop from a screen, even though the system does not start with
    it. In order to achieve this, you have to modify the configuration options of
    the Raspberry Pi:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The content of the file will be accessible on the screen. Uncomment the following
    lines, setting the shown values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The last two lines enforce the following display: at 1440 x 900 at 60 Hz. If
    you want to increase this to full HD resolution (1080 px), then you can do so
    as follows, depending on the refresh rate:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For a 50 Hz monitor, use the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'For a 60 Hz monitor, use the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: These commands make it easy to get 1080 px.
  prefs: []
  type: TYPE_NORMAL
- en: The Geany IDE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ubuntu Mate comes with a lightweight editor called **Pluma**. While it is good
    for editing, it does not include a terminal window or other common characteristics
    that are found in a typical development environment. For this reason, we will
    install **Geany**, a lightweight IDE suitable for running on a Raspberry Pi that
    supports common programming languages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We will be mainly using Python, so Geany is perfect for us.
  prefs: []
  type: TYPE_NORMAL
- en: Installing drivers for the GoPiGo3 and DI Sensors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we will prepare the system to work with GoPiGo3\. Dexter Industries supplies
    automated scripts to accomplish all the installations tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: The GoPiGo3 library, with the following script [https://dexterindustries.com/update_gopigo3](https://dexterindustries.com/update_gopigo3)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The DI Sensors library, with the following script [https://dexterindustries.com/update_sensors](https://dexterindustries.com/update_sensors)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The relevant steps are provided in the official documentation at [https://dexterindustries.com/update_gopigo3](https://gopigo3.readthedocs.io/en/master/quickstart.html#program-your-gopigo3).
    In short, you only have to open a terminal and execute following two commands,
    one after another:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The installation process takes several minutes, so be patient. When finished,
    you will see the following new icons on your desktop:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b738f345-95fb-4067-8e5e-050fa293c275.png)'
  prefs: []
  type: TYPE_IMG
- en: 'These additional utilities are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Advanced Communication Options**: This icon is used to enable Bluetooth and/or
    infrared receivers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Line Follower Calibration**: This icon is used to adjust sensor sensibility
    to the current illumination conditions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**gopigo3_control_panel**: This icon is used to drive the robot with a simple
    panel shown on the screen.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Test and Troubleshoot**: This utility generates a log file for your robot
    that can be sent to the manufacturer so that it can provide technical support.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As an example, double-click on the **Test and Troubleshoot** icon. It will
    generate a log file of your robot that should look like the following globally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: At this point, your operating system is ready to run any GoPiGo3 code, that
    is, the Python scripts that we used in [Chapter 2](7a2b1b82-c666-42df-9f10-9777eabe82df.xhtml), *Unit
    Testing of GoPiGo3*.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the Pi Camera
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The setup is done in steps 1-2\. First, we will enable access to the camera
    hardware from the Raspberry Pi, and second, we will install the Python module
    to handle the camera:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to edit the `/boot/config.txt` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we add these two lines at the end:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can get the same result by adding these lines from the command
    line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, install the Python module as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'To check that the camera works properly, create this Python script and name
    it `captureFile.py` (you can find it inside the `piCamera` folder in the code
    for this chapter):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Give execution permissions and run the Python module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The camera will be active for 2 seconds. Check that the red LED on the camera
    board is on. This is a visual sign that it is acquiring images. After this period,
    the LED will switch off and you should find – in the same path as the script –
    a new file called `test.jpg`. If you open it, you should see what the camera was
    viewing at the end of those 2 seconds; this is performed by: `camera.capture(test.jpg)`.
  prefs: []
  type: TYPE_NORMAL
- en: The last step in getting ready with the Raspberry Pi is to install ROS.
  prefs: []
  type: TYPE_NORMAL
- en: Installing ROS Melodic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The instructions on the ROS Melodic installation page ([http://wiki.ros.org/melodic/Installation/Ubuntu](http://wiki.ros.org/melodic/Installation/Ubuntu))
    are pretty clear and straightforward. We include them here for the sake of completeness:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, add the ROS source repositories:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, set up your keys:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: If you don't get a validated key, then it might have been changed (for security
    reasons). If that's the case, then go to the official installation page ([http://wiki.ros.org/melodic/Installation/Ubuntu](http://wiki.ros.org/melodic/Installation/Ubuntu)),
    search for the line, and then replace it with the new one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, update your sources:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Install the desktop version of ROS so that you can take advantage of the Mate
    desktop environment. This will allow you to use ROS GUI tools (such as rqt or RViz):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Initialize `rosdep`. This is the component that enables you to easily install
    system dependencies for your source code to compile. It also requires you to run
    some core components in ROS:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Set up the ROS environment for your interactive shell session:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'To avoid having to run this command each time, you can open a new terminal
    and include it in your `.bashrc` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Now all that remains is to configure the Pi Camera. Let's do that next.
  prefs: []
  type: TYPE_NORMAL
- en: Installing a Pi Camera ROS package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As part of the ROS installation, we should include software that will allow
    you to access the Pi Camera from ROS. The most used package is that from Ubiquity
    Robotics, and it is hosted on GitHub at [https://github.com/UbiquityRobotics/raspicam_node](https://github.com/UbiquityRobotics/raspicam_node).
  prefs: []
  type: TYPE_NORMAL
- en: To install the package, we first need to have a ROS workspace and to have mastered
    some practical concepts for cloning and creating ROS packages. This installation
    will be accomplished later on in the chapter; you will find it in the *Case study
    2 – ROS GUI development tools – the Pi Camera* *globally*.
  prefs: []
  type: TYPE_NORMAL
- en: Hence, let's proceed now to create a workspace and add the first package inside
    it.
  prefs: []
  type: TYPE_NORMAL
- en: A quick introduction to ROS programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section is devoted to explaining an easy ROS example with GoPiGo3\. By
    doing this, we can put our robot to work quickly so that, in later sections, we
    can deal with ROS commands and tools in a practical way, applying such commands
    and understanding what they do.
  prefs: []
  type: TYPE_NORMAL
- en: This very simple example is based on the distance sensor in GoPiGo3\. It consists
    of publishing sensor readings and accessing them from other ROS nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the workspace
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To start using contributed ROS packages or to create your own, you will need
    to have a workspace in which to put the code. The step-by-step procedure to accomplish
    such a task is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From a bash terminal, create a folder and initialize the workspace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The initialization is as simple as creating a symlink to a file definition
    located in the ROS installation folder. If you list files in the `src` folder,
    then you will see the new `CMakeLists.txt` file pointing to `/opt/ros/melodic/share/catkin/cmake/toplevel.cmake`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, build the workspace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add it to your ROS environment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can automate the execution of this command by including
    it at the end of your `.bashrc` file. To do so, execute the following command,
    and, afterward, run the file so that its contents take effect in the system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, you should have the following two lines at the end of the file
    (the first one is for the ROS global environment, while the second is for your
    private workspace):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Everything is now ready to include the ROS packages we need. In the following
    section, we will add two of them: one cloning an existing repository and another
    one creating a package from scratch.'
  prefs: []
  type: TYPE_NORMAL
- en: Cloning a ROS package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the cloning option, we are going to use a basic GoPiGo3 ROS package that is
    publicly available in GitHub from [https://github.com/ros-gopigo/gopigo3_node](https://github.com/ros-gopigo/gopigo3_node).
    Change to the `src` folder, which is the location where we will place all ROS
    packages, and then clone the source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Every time you add a new package, you have to rebuild the workspace so that
    ROS is aware of its existence and can add it to the execution environment. Hence,
    run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Now, you will see a number of lines indicating the progress in % and what the
    current building step is doing. If everything is okay, the last line displays
    100% complete and returns the control to the command line. This means that you
    have just successfully installed the `gopigo3_node` package.
  prefs: []
  type: TYPE_NORMAL
- en: Our first execution of a ROS node
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since ROS will be running on the Raspberry Pi, you will have to remotely connect
    to it. In order to do so, open a VNC connection to GoPiGo. Then, open a terminal
    in its desktop and install Terminator (the same utility we used in [Chapter 3](f3ecc0de-28c4-4140-9a9c-ed351c68d121.xhtml), *Getting
    Started with ROS*) to have as many terminals as you need in the same window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Move to the location of the newly added ROS package and list the files inside:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see several Python files for controlling GoPiGo3 sensors and drives.
    Assuming that you have installed the GoPiGo3 and DI Sensors libraries, as explained
    in the *Setting up a physical robot *section, open Terminator and divide the window
    into at least three terminals. We are going to execute the `distance_sensor.py` file
    under ROS. For that, we will need to issue three commands as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is globally what each command performs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`T1` launches the roscore process. This is necessary for all subsequent processes
    that can communicate in ROS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`T2` executes the `distance_sensor` node, which takes the readings and publishes
    them under the `/distance_sensor/distance` topic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`T3` listens to published data in real time and prints a new message each time
    a reading is acquired.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following screenshot, you can see what each terminal shows. Each reading
    of the sensor delivers a message that has several fields. Later on, in the *Case
    study 1 – writing a ROS package – distance sensor* section, we will explain how
    this message is created. For now, it is enough that you know that the `range`
    field, boxed in red, is the sensor measurement in a meters:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cd92f53f-4cd4-4a06-acaf-b52e18252b40.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To take just the last measurement, simply run the following command, where
    the number after *-n* indicates how many messages you want to print, which, in
    our case, is 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The next step will be to create your own ROS package. The code we are going
    to write makes the same package as the `distance_sensor.py` script but uses the `EasyDistanceSensor` class
    (from the `di_sensors.easy_distance_sensor` library) instead of the full `DistanceSensor` version
    (from the `di_sensors.distance_sensor` library), which was used by the script
    in the package that we cloned previously.
  prefs: []
  type: TYPE_NORMAL
- en: Case study 1 – writing a ROS distance-sensor package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, you will create a ROS package from scratch and produce the
    code to provide minimal ROS functionality with GoPiGo3, that is, reading its distance
    sensor. Be aware that the code you previously cloned at this location is the working
    solution for what your code is expected to do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: We encourage you to try to build the ROS package by yourself, following the
    explanations that are provided next in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, let''s set up a folder in the workspace where we will place the package
    files:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Move to the `src` location in the `catkin_ws worspace` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a package called `mygopigo`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'This command creates two files of the package definition `CMakeLists.txt` and
    `package.xml`, which were already introduced in the previous chapter. As there
    is a new package, you should rebuild the workspace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'If, at some point, you wish to change the project name, then you need to complete
    these three steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Edit in the `<name>mygopigo</name>` tag in package.xml.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Edit the line project (`mygopigo`) in CMakeLists.txt, where the project has
    to be the same as the `package.xml` <name> tag.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rebuild the workspace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The folder under which the files of the package are stored can be named however
    you like – it does not have to be the same as the package name.
  prefs: []
  type: TYPE_NORMAL
- en: Producing your source code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `mygopigo` folder is ready so that we can create the package structure
    and place the files:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `src` folder inside the package – note that this is a convention
    we use to standardize where the code is placed in repositories:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The `roscd` ROS command is equivalent to the Linux bash `cd` command. Its advantage
    is that you only have to specify the package name in order to move to the package''s
    folder, which is `~/catkin_ws/src/mygopigo/`. Then, create a Python file to acquire
    data from the distance sensor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Copy and paste the following lines globally inside the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: This is the unit test file for the distance sensor that we reviewed in the previous
    chapter. We will explain how to convert it into a ROS-integrated script.
  prefs: []
  type: TYPE_NORMAL
- en: ROS requires that source code be in files with the following execution permission: `$
    chmod +x distance-sensor.py`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run, just invoke it from the command line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: This will print the measured distance in centimeters every 0.1 seconds. At this
    point, the code is still pure Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now explain what changes need to be carried out so that it can be integrated
    into ROS:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, import the modules required by ROS:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The `rospy` library is the Python client and `sensor_msgs.msg` defines message
    types for handling data from sensors within ROS. In our particular case, we only
    need the `Range` type message, which is what we will need for the distance sensor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python''s `time` library is no longer required since `rospy` provides methods
    to handle time features in ROS. Hence, you may remove the line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we put the code under the `main()` function definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'We launch a ROS node called `distance_sensor`, define a publisher called `pub_distance`,
    set the characteristics of the sensor in the `msg_range message`, and specify
    the rate we want to read the sensor at, which is 1 Hz. We complete the code of
    the main function by running an infinite loop that takes a reading of the sensor
    in each iteration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'In each iteration, this code saves the sensor data in the `msg_range` instance,
    publishes the message to the `/distance_sensor/distance` topic, and runtime-delays
    the next reading to respect the specified rate. Finally, we tell Python to run
    the `main()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: In the following subsections, we will cover more information about these pieces
    of code in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Including the required libraries – rospy and msgs.msg
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following two lines import the required ROS libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'These libraries are explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`rospy` ([http://wiki.ros.org/rospy](http://wiki.ros.org/rospy)): This is the
    official Python client for ROS. It implements  API methods so that you can integrate
    ROS nodes coded in Python.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sensor_msgs` ([http://wiki.ros.org/sensor_msgs](http://wiki.ros.org/sensor_msgs)):
    This is the ROS package that lets you handle different types of ROS message depending
    on the sensors and drives of your robot; for example, `BatteryState`, `FluidPressure`,
    and `LaserScan`. In the case of the distance sensor, we use the `Range` type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assigning a node name to the script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This task is accomplished using the `init_node` method of the `rospy` library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Using the `distance_sensor` name, we will reference the distance sensor node
    anywhere in ROS.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the publisher
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The publisher is a function – again, a `rospy` method that permits you to assign
    to the `pub_distance` variable the result of the measurement, which, in our case,
    is of the `Range` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The value between the quotation marks is the topic name, `~distance`. The prepended
    symbol, `~`, is equivalent to `<name of node>/`, which, in our case, is `distance_sensor`.
    Following this, the namespace topic will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The `queue_size` parameter specifies how many messages ROS keeps in memory to
    ensure that the subscriber nodes read them. A value of `10` is a good default.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the msg_range object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The distance sensor uses the message type defined in the `Range` class of the
    `sensor_msgs.msg` library, whose structure is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'These are the fields that will be part of any message involving the data flow
    from the sensor, and its syntax is explained in detail in the documentation ([http://docs.ros.org/api/sensor_msgs/html/msg/Range.html](http://docs.ros.org/api/sensor_msgs/html/msg/Range.html)).
    All the fields are specific characteristics of the sensor except for the measurement
    itself, `range`. Hence, the following snippet gives a particular definition for
    our distance sensor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Here, the first line initiates the `msg_range` variable to be of the `Range()` type.
    In the `header.frame_id` field, we indicate the physical magnitude we are going
    to measure, which is `distance`.
  prefs: []
  type: TYPE_NORMAL
- en: The `radiation` type is set to `INFRARED` (there is no option to set this to `LASER`,
    but specifying it as `INFRARED` is more adequate than the other option, `ULTRASOUND`,
    for which you would have a wide field of view instead of a straight ray). `LASER`
    is directional, as is `INFRARED`, so it is better to use this type.
  prefs: []
  type: TYPE_NORMAL
- en: The last two lines specify the maximum (3 meters) and minimum (2 centimeters)
    distances the sensor can measure.
  prefs: []
  type: TYPE_NORMAL
- en: Changing units to the International System of Units
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Adopting the **International System of Units** (**SI**) is the ROS convention
    stated in its specification ([https://www.ros.org/reps/rep-0103.html](https://www.ros.org/reps/rep-0103.html)).
    Since the `read()` method provides measurements in centimeters, we only have to
    divide by 100 to obtain the distance in meters and feed this to the system according
    to the ROS standard:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: This value will be inserted afterward into the `msg_range` object, which we
    will cover next.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a measured distance and timestamp to the msg_range object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the `msg_range.range` field, we allocate the measured distance, and in the
    other field –  `msg_range.header.stamp` – we allocate the current timestamp:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The timestamp is obtained from the `Time.now()` method of the `rospy` library.
    In this way, we have a full record of the measurement.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the reading frequency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using the `Rate` method, we can set the reading frequency to 1 Hz (this is
    equal to 1 sample per second; in SI units) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'We do this by defining a ROS parameter at the same time whose name is as follows
    (remember the meaning of the `~` symbol):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: With this setup, the sensor will be read once per second.
  prefs: []
  type: TYPE_NORMAL
- en: Running an infinite loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We run the infinite loop using a specific ROS method from `rospy`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Its syntax is self-explanatory, that is, it will run unless ROS is shutdown.
  prefs: []
  type: TYPE_NORMAL
- en: Publishing each new event
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We publish a new `msg_range` message each time a measure is available by using
    the `pub_distance` publisher defined previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Waiting until the next reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To ensure we respect the acquisition rate of 1 Hz, we apply the `sleep` method
    to the `rate` object that we defined above (for which we set a frequency of 1
    Hz, that is, one cycle per second):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Bear in mind that this does not block ROS execution (it just blocks the script
    of this node), that is, just the code of this `distance_sensor` node. If there
    were other nodes in the environment, then they would have their own independent
    execution threads. If you were using a native asynchronous language such as JavaScript,
    then you could also run asynchronous code within the node and also avoid the blockage
    in the execution of the script, that is, your node could be executing other lines
    while waiting for the next sensor reading
  prefs: []
  type: TYPE_NORMAL
- en: If you are curious about this, you can investigate the ROS client library, `rosnodejs` ([https://www.npmjs.com/package/rosnodejs](https://www.npmjs.com/package/rosnodejs)),
    which allows you to write nodes in the JavaScript language. At this point, remember
    that one of the cool characteristics of ROS is that you can mix the same ROS graph
    nodes written in Python with nodes written in JavaScript or in any of the other
    ROS client libraries ([http://wiki.ros.org/Client%20Libraries](http://wiki.ros.org/Client%20Libraries)).
  prefs: []
  type: TYPE_NORMAL
- en: Launching the ROS execution environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have understood how the Python script integrates with ROS, we will
    execute it in one terminal as part of the ROS runtime environment using the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Prepare your divided Terminator window again for better visibility, and then
    run each of the following commands in independent terminals:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'The first one launches the ROS master node. The second one is the script we
    have just explained, while the third allows us to watch messages published under
    the `/distance_sensor/distance` topic in real time. This is what you should see:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/89d44587-8ad5-4888-aaec-aaf266d05997.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, draw the ROS graph to get a visual insight into how nodes and topics
    are wired:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'A new window pops up showing the current ROS graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/53110697-034d-4eb7-af1b-37cdbc51f858.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, you can see that it reproduces what we are doing in the three terminals:
    we execute the `/easyDistance_sensor` node, which is publishing sensor data at
    the `/easyDistance_sensor/distance` topic, and then we show the readings with
    a topic subscription node, `/rostopic_2797_156571927410`.'
  prefs: []
  type: TYPE_NORMAL
- en: After going through this example, we will use it to illustrate the various ROS
    commands and tools that you have available.
  prefs: []
  type: TYPE_NORMAL
- en: Working with ROS commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the first part of this section, we will cover three categories: commands
    to be used inside bash (shell), ROS execution commands, and information commands.'
  prefs: []
  type: TYPE_NORMAL
- en: Shell commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Shell commands are bundled into a ROS core package, `rosbash` ([http://wiki.ros.org/rosbash](http://wiki.ros.org/rosbash)).
    Let's move on to see what each one provides.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the current location
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we will cover `roscd`, which is equivalent to the Linux bash `cd` command.
    Its advantage is that you only have to specify the package name in order to move
    to the location of the package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'This will take you to the **`~/catkin_ws/src/mygopigo/` **folder. You can also
    navigate through the package folder structure by appending the relative path of
    the desired location. For example, to move to the `src` folder of the `mygopigo` package,
    use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '`roscd` is equivalent to the Linux `cd` command. It will change the prompt
    to the directory of any ROS package in your system by referencing its path with
    the package name. No matter what the actual path is, ROS will automatically drive
    you there.'
  prefs: []
  type: TYPE_NORMAL
- en: Listing files and folders inside a package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, we have `rosls`, which is the equivalent of Linux `ls`. To list the source
    code of your package wherever you are, simply write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '`rosls` allows you to easily list files and folders inside any ROS package in
    your system by referencing its path with the package name. No matter what the
    actual path is, ROS will automatically take you there.'
  prefs: []
  type: TYPE_NORMAL
- en: Editing any file inside a package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, we have `rosed`, which opens a terminal editor, such as `nano`, so
    that you can modify any file in the package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'For `rosed` to work properly, you have to specify an editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'To make it part of your configuration, add the preceding line to the end of
    your `.bashrc` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '`rosed` is equivalent to launching the Linux terminal editor, which is `nano`.  It
    will allow you to edit any file inside a ROS package by simply telling it the
    package name, no matter which subfolder the file is actually in.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This command is a convenient way to modify a file when you are connected remotely
    to the robot and you only have a terminal to interact with. If you are on a desktop
    session, you can even use a desktop IDE if you wish:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: In this case, you are calling the editor on the fly and superseding the default
    set in `.bashrc`.
  prefs: []
  type: TYPE_NORMAL
- en: Execution commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 3](f3ecc0de-28c4-4140-9a9c-ed351c68d121.xhtml), *Getting Started
    with ROS*, we already introduced the `roscore` and `rosrun` commands for running
    our first project.
  prefs: []
  type: TYPE_NORMAL
- en: The central process of the ROS environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`roscore` is the first process you have to launch so that the ROS environment
    works.`roscore` allows nodes to communicate between themselves. It has no parameters,
    so write this line in a terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '`roscore` launches the master node, which is the central process of your ROS
    environment and keeps all nodes that are actually running connected.'
  prefs: []
  type: TYPE_NORMAL
- en: Executing a single node
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`rosrun` allows you to manually launch a node from a package. The syntax is
    quite simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'The script includes a declaration of a node. In the case of our `distance-sensor.py` example,
    this is accomplished in the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, to launch the node, write this command in another terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'After these two commands, you already have a ROS functional environment that
    provides sensor readings. The node also prints the current measure in the terminal
    process, transformed into millimeters (there is no need to open another terminal
    to listen to the topic). The usage of millimeters is just for visualization purposes.
    The ROS message keeps its distance units as meters, which you can check by subscribing
    to the topic in another terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '`rosrun` allows you to launch a single node from a package. It is a command
    for performing manual node execution within your ROS environment.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have `roslaunch`. This is the most relevant execution command since
    it allows you to describe a robot with an XML file. You can declare its nodes
    and link each one with the scripts that execute it. We will view this command
    in more detail in the *Automating the execution of a node using roslaunch* section.
  prefs: []
  type: TYPE_NORMAL
- en: Information commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This category groups several commands that allow you to extract information
    from ROS environment as well as interactively modify some values. All of the commands
    are prepended with `ros-`. Simply writing the command in the terminal, supplies help
    with the different options regarding how to use each of them. A brief description
    and an example for each command are provided next.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring topics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`rostopic` provides information about published topics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'This lists all the topics that are currently alive. From the list, you can
    access the real-time feed of any of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Exploring nodes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`rosnode`provides information about nodes that are alive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'This lists all the nodes of the current ROS graph. From the list, you can access
    information about any of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Here, `info` will provide you with useful information about the `distance_sensor` node.
    Do not confuse this with the name of the Python script where the node is declared, `distance-sensor.py`.
    The `rosnode` command always refers to the name of the node.
  prefs: []
  type: TYPE_NORMAL
- en: The rosmsg command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`rosmsg`provides information about the types of message used by topics during
    runtime. To give you a practical example, we select the `distance_sensor/distance` topic
    and get the following information about it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'This command tells us that the topic has a message type of `sensor_msgs/Range`.
    Then, `rosmsg` informs us of the message structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: The output of this command is what we showed and explained in the *Setting up
    the msg_range object* subsection of the *Case study 1 – writing a ROS package –
    distance sensor* section. In the next chapter, we will provide extended explanations
    about the new message types we will be using in the GoPiGo3 ROS package.
  prefs: []
  type: TYPE_NORMAL
- en: The rosbag command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This command allows you to save a session and play it back on demand. Let''s
    look at how to do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Press *Ctrl* + *C* in the T2 terminal when you want to end the recording. Type `rosbag
    info <bag filename>` into `T2` to get information about the recorded file (the
    default name for the file is composed by the sequence `date-time-topic_name`,
    and it is given the `.bag` extension):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Bear in mind that the bag file is placed in the location from which you launched
    the recording session in the `T2` terminal.
  prefs: []
  type: TYPE_NORMAL
- en: The recorded bag file allows to reproduce the topic history whenever we want,
    just as we do when we play a recorded song. One example of a typical situation
    where you would use this is to replay the robot behavior without the robot itself,
    using ROS on your laptop. This method eases debugging of the application and enables
    you to drastically reduce the number of times you need to run the software in
    the actual robot.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s play it back in the Raspberry Pi by running the following set
    of commands, which include the visualization of the ROS graph (the `rqt_graph` command)
    and the measured distance over time (the `rqt_plot` command):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: In this snippet, we have introduced a new command, `rqt_plot`, that will be
    explained later in the *Case study 2– ROS GUI development tools – the Pi camera* section.
    Briefly, it plots a selected ROS topic over time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you can playback the session on the laptop bylaunching the same set of
    commands. You will get the following result for `rqt_plot`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6093c672-283b-4a00-a5e9-8d2a0c59231b.png)'
  prefs: []
  type: TYPE_IMG
- en: From the point of view of ROS, the result is exactly the same as if you were
    running the actual launch file in GoPiGo3\. The difference, with respect to the
    figures, is due to the fact that you have ROS Kinetic on your laptop, while the
    robot has the Melodic version (which is more recent).
  prefs: []
  type: TYPE_NORMAL
- en: Packages and the catkin workspace
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some commands in this section have already been used when configuring your
    ROS environment. Let''s briefly review them now:'
  prefs: []
  type: TYPE_NORMAL
- en: '`catkin_init_workspace`initializes a new workspace, as you did at the beginning
    of this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`catkin_create_pkg`creates a new package.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`catkin_make` builds a workspace and should be invoked each time you add a
    package or remove one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These are the essential commands. Nevertheless, there are some additional commands
    that are worth mentioning:'
  prefs: []
  type: TYPE_NORMAL
- en: '`catkin_find`lists the working folders of your ROS environment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rospack`provides information about a ROS package, be it from the core, contributed,
    or made by yourself. If you want to know which ROS packages are installed when
    dealing with GoPiGo, you can do so with this command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: The only caution you should have is that all of them should have the letters `gopigo` within
    their name so that `grep` can filter them without missing any.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have provided an overview of the most frequent commands.
    Take all the time that you need to feel comfortable using them as you will be
    continuously using them when working with ROS. In the next section, we will extend
    our knowledge of the publish-subscribe pattern by explaining the syntax of the
    subscriber node, which is the node that will read messages from the selected topic.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and running publisher and subscriber nodes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you have understood how the requirement, `distance-sensor.py`, publisher
    script works, then the following subscriber script should be pretty straightforward
    to follow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'This snippet corresponds to the `distance-sensor_subscriber.py` file in the
    `./pkg_mygopigo/src` folder of the code for this chapter. The main difference
    in the subscriber script is that, since we are listening to a topic, we do not
    need to specify a rate of execution. We simply loop forever with the following
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Whenever a message is received in the topic, a callback function will be executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, this callback function is defined to print the measured distance
    in millimeters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the script within ROS by using several terminals in the Terminator window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'Take a look at the terminal window, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/81801fe8-0f93-436c-bae6-90c564c73ed0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following is globally the ROS graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4d8030c9-7fce-4e2b-b257-c32b88a7a8a4.png)'
  prefs: []
  type: TYPE_IMG
- en: There are two nodes listening to the same topic. One is the subscriber script
    we have explained with the `/distance_subscriber` node, and the other is the node
    created by the `rostopic echo` command.
  prefs: []
  type: TYPE_NORMAL
- en: So far, you have manually launched each ROS node. In the next section, you will
    learn how to do it programmatically to run the robot software as an automated
    task.
  prefs: []
  type: TYPE_NORMAL
- en: Automating the execution of nodes using roslaunch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once you have decided which nodes you want to run as part of your robot, you
    can automate the launch process for all scripts by using the `roslaunch` command.
    Its syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'For our example, this is pretty simple as there is only one node. The launch
    file is in the repository at `./pkg_mygopigo/launch/easyDistance.launch` and its
    syntax is based on XML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'The `<launch>` tag delineates the robot description. Then, you include one `<node>` tag
    for each node you want to launch. In our case, there is only one: the `distance_sensor` node.
    The description of its attributes is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name`: The designation to identify the node. This supersedes the given name in
    the line of the script:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'We set a different name in this launch file, `easyDistance_sensor`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pkg`: This is the name of the package, which is `mygopigo`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`type`: This is a reference to the script that launches the node, `easyDistance.py`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`output`: We specify the screen (the default is the log that directs the output
    to `$ROS_HOME/log`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once you understand the XML launch file, repeat the process of raising up the
    robot, but, this time, use the automated way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '`roslaunch` implicitly initiates `roscore`. You should see the same output
    as when you run it manually with `rosrun`. Obviously, `roslaunch` is really useful
    when you have to launch many nodes at the same time. We will see examples of this
    later.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the script within ROS by using several terminals under the Terminator window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'Take a look at the following terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f3760ca9-60e7-4f59-acc7-a4fa33d2a883.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is the ROS graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a51490a0-db4f-4816-92f0-cbdf9d454f52.png)'
  prefs: []
  type: TYPE_IMG
- en: You will find exactly the same result as in the previous section. Let's now
    look at the ROS visual tools that ease our life as a software robotics developer.
  prefs: []
  type: TYPE_NORMAL
- en: Case study 2 – ROS GUI development tools – the Pi Camera
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we mentioned at the end of the *Installing ROS Melodic* section, in order
    to be able to use the camera, we first need to install its ROS package. Since
    the binaries are not available for ROS Melodic (only for Kinetic), we need to
    build the package from the source, and this is a perfect example in that you will
    know how to do it with any other package. Let''s do this with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to your `catkin` workspace and download the source code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'There are some dependencies to be installed for ROS. To carry out this task,
    we are going to create the `30-ubiquity.list` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'Afterward, run the ROS dependencies update as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'Now install the ROS dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile the new package as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: If you were using `catkin_make` without any option, the build process would 
    traverse all the packages in the workspace. So, this snippet shows you how to
    compile a single package while ignoring the rest. The second line allows you to
    switch back to enable building all the packages the next item you need to compile
    the workspace.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run the Pi Camera node, simply launch the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'If you own the previous Pi Camera version, `V1`, use the following instead:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in another terminal, run the image viewer utility that comes with the
    package to check that the camera is working properly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see a new window similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f324979f-5367-46df-8fe9-2b27319c96bd.png)'
  prefs: []
  type: TYPE_IMG
- en: If you move the robot, you will find that the image also changes, so you are
    watching a live camera stream. Now we are ready to proceed with practical explanations
    for the ROS GUI development tools, which is the scope of this section.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing the ROS graph using rqt_graph
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By issuing this command, you can visualize the current ROS graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'It will show the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c09ca960-8abf-4fa1-89c9-5e9610c89ca9.png)'
  prefs: []
  type: TYPE_IMG
- en: '`raspicam_node` is the root node of the package that interfaces with the physical
    Pi Camera. It publishes images in the `/raspicam_node/image/compressed` topic.
    The other node, `imv_view`, from the process in the `T2` terminal, launches a
    window where you can watch the live stream (as shown in the preceding section).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, inspecting the topic''s `raspicam_node` provides the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: You can find in the list the node that the `imv_view` node is subscribed to,
    which is `/raspicam_node/image/compressed`.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying image data using rqt_image_view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This plugin allows you to visualize image data that is published in a ROS topic.
    Kill the previous two terminals and launch the following new ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'In the upper-left drop-down list, select the topic of the image that you want
    to visualize. It needs to be in compressed format as it is published by `raspicam_node`.
    The following screenshot shows the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/34696f23-cd46-48b4-ad83-36d3d1e675a0.png)'
  prefs: []
  type: TYPE_IMG
- en: In the event you have several topics with image data, the plugin allows you
    to interactively select what feed to watch and also change between them on demand.
  prefs: []
  type: TYPE_NORMAL
- en: Graphing time series of sensor data with rqt_plot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is a plugin to visualize two-dimensional data. As we want to see two-dimensional
    data, let''s briefly switch to the distance sensor case study so that we can view
    the measured distance over time. The process is straightforward: launch the robot,
    list the topics, and then launch the plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'In the upper-left box, write the name of the topic you want to visualize, that
    is, `/distance_sensor/distance` as per `T2`. A window will pop up showing the
    distance to the obstacle over time:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6c5007ce-e548-48c7-a300-68aba2c0d44f.png)'
  prefs: []
  type: TYPE_IMG
- en: The green line, `msg_range.range`, is the actual measurement. The other fields
    of the `msg_range` object (this is the content of `topic/distance_sensor/distance`)
    display the maximum and minimum values of all the measurements: `msg_range.max_range`
    and `msg_range.min_range`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Playing a recorded ROS session with rqt_bag
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `rqt_bag` plugin plays a bag file, which is the same as the `rosbag` command
    explained in the *ROS commands* section. Here, the advantage is that you have
    interactive control of the playback: you can jump to any instant, play single
    time steps, rewind to the beginning, and so on. Let''s examine this with the distance
    sensor case study first, and then with the Pi Camera.'
  prefs: []
  type: TYPE_NORMAL
- en: Distance sensor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can perform the playback wherever you want, using the robot or the laptop.
    As with `rosbag`, you will need prior access to a `roscore` process, then you
    can issue `rqt_bag`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'A new window pops up. Select the bag file to play, that is, `2019-08-15-20-36-36_distanceSensor.bag`, right-click
    on the windows, and then mark the `/distance_sensor/distance` topic to be published.
    Run the same set of commands as when you used `rosbag`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following screenshot, you can check that the result is the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ecc4d4cb-1789-4fa3-9735-abb2fe0a8467.png)'
  prefs: []
  type: TYPE_IMG
- en: Now we will play the image stream from the Pi Camera case study.
  prefs: []
  type: TYPE_NORMAL
- en: The Pi Camera
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we need to record a session with the robot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the information about the recorded file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'You can perform the playback wherever you want, using the robot or the laptop.
    In this case, the image data is bulkier. So, it is much better to play the session
    on the laptop. Launch the processes as before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'In the launched `rqt_bag` plugin, select the bag file to play, which is `2019-08-15-20-44-53_raspicamImage.bag`,
    right-click on the windows, and then mark the `/raspicam_node/image/compressed`
    topic to be published. Afterward, run the following set of commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'In the upper-left drop-down list of `rqt_image_view`, select the topic of the
    image that you want to visualize. It needs to be in compressed format as it is published
    by `raspicam_node`. In the following screenshot, you can check that the result
    is the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/11f0baf0-73ae-4571-b9f6-c5924762d91d.png)'
  prefs: []
  type: TYPE_IMG
- en: While playing the *bag* file, you can check that the image stream is very fluent
    thanks to the fact that your laptop has a powerful GPU compared to what the Raspberry
    Pi provides. So, it is clear that, when you are dealing with computer vision tasks,
    you will take advantage of this visualization capability of robot sessions within
    your laptop.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing robot features using ROS parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'ROS parameters store the global configuration of the robot. This is a convenient
    way in which to define your application so that you can abstract the functionality
    to a high level and make it available for the end user. We are going to illustrate
    how ROS parameters work by using a `rqt` plugin that allows for dynamically reconfiguring
    of some of them. It is as it sounds; you can modify robot characteristics on the
    fly:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Launch `raspicam_node` and then the `rqt` plugins:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'Your desktop should show the following two windows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e4624f05-067b-4e2b-b110-4f568f7c7533.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Check the parameters on the right-hand side and focus on the brightness (the
    box marked in red). Modify its value from `51` to `81` and then check the result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4128ffb6-35cd-40f7-bc82-09489fc000e3.png)'
  prefs: []
  type: TYPE_IMG
- en: Wow! You can dynamically modify the configuration of the robot without needing
    to restart it.
  prefs: []
  type: TYPE_NORMAL
- en: 'You also have the `rosbash` command, which allows you to inspect the parameters.
    List them with the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, get the state of the one we have dynamically modified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: If you have arrived at this point and understand the concepts in the practical
    exercises, you now know almost everything that you need to work with ROS from
    now on.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we have established the basis for programming in ROS. You
    have built your own package with a simple GoPiGo3 functionality: reading a distance
    sensor in order to work on programming concepts. You have also learned how to
    read Pi Camera images and make them available to ROS for further processing, which
    is the starting point for performing computer vision tasks.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, you will put the two ROS worlds together: the robot and
    your laptop. This way, once you have the GoPiGo3 package running in the robot,
    you will have the power to undertake all computing and processing tasks from your
    powerful laptop.'
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the difference between ROS topics and ROS messages?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A) Both stand for the data transmitted from one node to the other.
  prefs: []
  type: TYPE_NORMAL
- en: B) A topic is how you identify a transmission channel and a message is one sample
    of the content that flows through that channel.
  prefs: []
  type: TYPE_NORMAL
- en: C) Any topic name has to be unique, while several topics can transmit the same
    message.
  prefs: []
  type: TYPE_NORMAL
- en: Which command would use to record a ROS session?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A) `rosbag`
  prefs: []
  type: TYPE_NORMAL
- en: B) `rosrecord`
  prefs: []
  type: TYPE_NORMAL
- en: C) `roswrite`
  prefs: []
  type: TYPE_NORMAL
- en: Can a ROS node have a publisher and a subscriber at the same time?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A) Yes, if the topic subscriber is the same as the topic publisher.
  prefs: []
  type: TYPE_NORMAL
- en: 'B) No, because it would imply a programming conflict: a node with a publisher
    loops at a constant rate, that is, `rate.sleep()`, while a node with a subscriber
    only runs an iteration if it receives a message, that is, `rospy.spin()`.'
  prefs: []
  type: TYPE_NORMAL
- en: C) Yes, and the node is driven by the subscriber, that is, the node broadcasts
    a new message each time it receives a message from the topic it is subscribed
    to.
  prefs: []
  type: TYPE_NORMAL
- en: How many `roslaunch` commands can you run in the same ROS session?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A) As many as you need; `roslaunch` is a description file that tells ROS what
    nodes to launch when the command is called.
  prefs: []
  type: TYPE_NORMAL
- en: B) Just one, because `roslaunch` implicitly runs a `roscore` process, and you
    can only have one ROS master node in the session.
  prefs: []
  type: TYPE_NORMAL
- en: C) If you need two sets of nodes, it is recommended that you launch each of
    them manually when you need to add each to the execution environment. Then, start
    a `roscore` process and later execute a `rosrun` for every new node you need.
  prefs: []
  type: TYPE_NORMAL
- en: Is there a programmatic way to visualize an image that is published in a ROS
    topic?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A) Yes, using `rqt_plot`
  prefs: []
  type: TYPE_NORMAL
- en: B) Yes, using `rqt_image_view`
  prefs: []
  type: TYPE_NORMAL
- en: C) Yes, using `rqt_image_view`, but it is necessary that the image is in a compressed
    format
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To go deeper into the concepts we have explained in this chapter, you can follow
    the following references and tutorials:'
  prefs: []
  type: TYPE_NORMAL
- en: ROS technical overview: [http://wiki.ros.org/ROS/Technical%20Overview](http://wiki.ros.org/ROS/Technical%20Overview)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ROS cheatsheet: [https://kapeli.com/cheat_sheets/ROS.docset/Contents/Resources/Documents/index](https://kapeli.com/cheat_sheets/ROS.docset/Contents/Resources/Documents/index)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ROS command line – the `rosbash` commands: [http://wiki.ros.org/rosbash](http://wiki.ros.org/rosbash)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Master node – the `roscore` command and process: [http://wiki.ros.org/roscore](http://wiki.ros.org/roscore)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ROS topics – the `rostopic` command description: [http://wiki.ros.org/rostopic](http://wiki.ros.org/rostopic)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ROS nodes – the  `rosnode` command description: [http://wiki.ros.org/rosnode](http://wiki.ros.org/rosnode)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Messages – the `rosmsg` command description: [http://wiki.ros.org/rosmsg](http://wiki.ros.org/rosmsg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ROS parameters – the `rosparam` command description: [http://wiki.ros.org/rosparam](http://wiki.ros.org/rosparam)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Record sessions – the `rosbag` command description: [http://wiki.ros.org/rosbag](http://wiki.ros.org/rosbag)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recording and playing back data with `rosbag`: [http://wiki.ros.org/rosbag/Tutorials/Recording%20and%20playing%20back%20data](http://wiki.ros.org/rosbag/Tutorials/Recording%20and%20playing%20back%20data)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Catkin command-line tools: [https://catkin-tools.readthedocs.io](https://catkin-tools.readthedocs.io)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Pi Camera official documentation: [https://picamera.readthedocs.io](https://picamera.readthedocs.io)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ROS `rqt` GUI tools: [http://wiki.ros.org/rqt](http://wiki.ros.org/rqt)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `rqt_graph` plugin: [http://wiki.ros.org/rqt_graph](http://wiki.ros.org/rqt_graph)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `rqt_image_view` plugin: [http://wiki.ros.org/rqt_image_view](http://wiki.ros.org/rqt_image_view)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `rqt_plot` plugin: [http://wiki.ros.org/rqt_plot](http://wiki.ros.org/rqt_plot)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `rqt_bag` plugin: [http://wiki.ros.org/rqt_bag](http://wiki.ros.org/rqt_bag)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using `rqt` tools for analysis – `rqt_console`, `rqt_graph`, and `urdf_to_graphviz`:
    [http](https://industrial-training-master.readthedocs.io/en/melodic/_source/session6/Using-rqt-tools-for-analysis.html)[s://industrial-training-master.readthedocs.io/en/melodic/_source/session6/Using-rqt-tools-for-analysis.html](https://industrial-training-master.readthedocs.io/en/melodic/_source/session6/Using-rqt-tools-for-analysis.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
