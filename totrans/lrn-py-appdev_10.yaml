- en: Chapter 10. Simple GUI Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章 简单的GUI应用程序
- en: All the chapters so far were about learning to write better application code
    in Python. Starting with a simple program, we saw how to develop robust and efficient
    applications. We touched upon several important areas of software development.
    More specifically, we covered exception handling, deploying applications, documentation,
    adopting best practices, unit testing, refactoring, design patterns, and performance
    improvements. The key concepts were explained using various command-line applications
    that were progressively improved.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止的所有章节都是关于学习如何用Python编写更好的应用程序代码。从一个简单的程序开始，我们看到了如何开发健壮和高效的应用程序。我们触及了软件开发的重要领域。更具体地说，我们涵盖了异常处理、部署应用程序、文档、采用最佳实践、单元测试、重构、设计模式和性能改进。关键概念是通过各种逐步改进的命令行应用程序进行解释的。
- en: Where do we go from here? Beyond the command line, there are applications that
    present an interactive user interface. Desktop, mobile GUI applications, or web
    applications come under this category. Also, there are applications targeted for
    specific domains such as network and database programming. These are broad topics,
    and each has its own set of goodies that will help make the application robust.
    Nonetheless, the techniques we have learned in this book provide a solid foundation
    for all these domains.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要做什么？除了命令行之外，还有提供交互式用户界面的应用程序。桌面、移动GUI应用程序或Web应用程序都属于这一类别。此外，还有针对特定领域（如网络和数据库编程）的应用程序。这些都是广泛的话题，每个领域都有其独特的优点，有助于使应用程序更加健壮。尽管如此，本书中学到的技术为所有这些领域提供了一个坚实的基础。
- en: This last chapter is designed to give you just a flavor of one such domain.
    It will be a superficial introduction to desktop GUI application development using
    Python.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这最后一章旨在让您对这样一个领域有一个基本的了解。它将是对使用Python进行桌面GUI应用程序开发的浅显介绍。
- en: Note
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: GUI programming is too big of a beast to fit into a single chapter. Let's do
    that anyway, keeping in mind that there is plenty of opportunity to learn beyond
    what is discussed here. The chapter won't show you how to create full-fledged,
    complex GUI applications. Rather, we will just dip a toe into GUI application
    development using Python's Tkinter library.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: GUI编程太大，无法在一个章节中涵盖。尽管如此，我们仍然会这样做，同时考虑到有大量的机会可以在这里讨论之外学习。本章不会向您展示如何创建完整的、复杂的GUI应用程序。相反，我们只是用Python的Tkinter库浅尝辄止地涉足GUI应用程序开发。
- en: 'Here is how the rest of the chapter is organized:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何组织本章剩余内容的：
- en: The chapter will start with an overview of the available GUI frameworks.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章将从对可用的GUI框架的概述开始。
- en: Next, we will see what event-driven programming is, followed by a primer on
    the Tkinter library.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们将看到什么是事件驱动编程，然后是Tkinter库的入门介绍。
- en: What follows next is our first project, a simple GUI application that uses Tkinter.
    It is essentially the GUI version of the first ever application we developed in
    [Chapter 1](ch01.html "Chapter 1. Developing Simple Applications"), *Developing
    Simple Applications*.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来的是我们的第一个项目，一个使用Tkinter的简单GUI应用程序。它本质上是我们第1章中开发的第一个应用程序的GUI版本，即*开发简单应用程序*。
- en: The next section will serve as an introduction to the **Model-view-controller**
    (**MVC**) architecture. This will be followed by our second project, where the
    earlier application is rewritten to implement the MVC architecture.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一节将作为对**模型-视图-控制器**（**MVC**）架构的介绍。这将随后是我们的第二个项目，其中之前的应用程序被重写以实现MVC架构。
- en: The chapter will also talk about testing GUI applications. This will be a high-level
    discussion, and won't involve writing any code.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章还将讨论测试GUI应用程序。这将是一个高级讨论，不会涉及编写任何代码。
- en: This being the last chapter, we will conclude it, and hence the book, with a
    brief discussion on various application frontiers.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于这是最后一章，因此我们将通过简要讨论各种应用程序前沿来结束本章，并因此结束本书。
- en: Overview of GUI frameworks
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GUI框架概述
- en: A user interface is typically something that a user can see and use to communicate
    with the application. So far, we have presented a text-based user interface. For
    example, in the *Attack of the Orcs* application, the user was prompted to specify
    a hut number, and based on the number entered, further actions were taken.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 用户界面通常是用户可以看到并用来与应用程序进行通信的东西。到目前为止，我们已经介绍了一种基于文本的用户界面。例如，在*奥克之攻*应用程序中，用户被提示指定小屋编号，并根据输入的编号采取进一步的操作。
- en: A **Graphical User Interface** (**GUI**), on the other hand, presents an interface
    to the user that may have buttons, icons, text fields, graphics, and so on. There
    are several Python GUI frameworks available. Many of these are based on cross-platform
    technologies such as Tk, Qt, wxWidgets, and others. Let's briefly discuss some
    of the most popular frameworks. The purpose is to just make you aware of the GUI
    technologies available.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，**图形用户界面**（**GUI**）向用户提供了一个可能包含按钮、图标、文本字段、图形等的界面。有几种 Python 图形用户界面框架可供选择。其中许多基于跨平台技术，如
    Tk、Qt、wxWidgets 等。让我们简要讨论一些最受欢迎的框架。目的是让您了解可用的 GUI 技术。
- en: Tkinter
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Tkinter
- en: '**Tkinter** provides Python bindings or interface to the open source Tk GUI
    widget toolkit. For more information on Tk, see its official website, [http://www.tcl.tk/](http://www.tcl.tk/).
    It is available as a standard module in Python. What this means is that as long
    as Python is installed, we do not need any additional installations to use it.
    In this book, we will demonstrate basic GUI concepts using the Tkinter library.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**Tkinter** 提供了 Python 绑定或接口到开源的 Tk 图形用户界面小部件工具包。有关 Tk 的更多信息，请参阅其官方网站，[http://www.tcl.tk/](http://www.tcl.tk/)。它作为
    Python 的标准模块提供。这意味着只要安装了 Python，我们就不需要任何额外的安装来使用它。在本书中，我们将使用 Tkinter 库演示基本的 GUI
    概念。'
- en: PyQt
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PyQt
- en: '**PyQt** ([https://wiki.python.org/moin/PyQt](https://wiki.python.org/moin/PyQt))
    is a widely used Python GUI library. It is one of the most mature frameworks out
    there. It essentially provides Python bindings for a popular Qt GUI application
    development framework. In order to use this framework, you need to install Qt
    first.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**PyQt** ([https://wiki.python.org/moin/PyQt](https://wiki.python.org/moin/PyQt))
    是一个广泛使用的 Python 图形用户界面库。它是目前最成熟的框架之一。它本质上提供了对流行的 Qt 图形用户界面应用程序开发框架的 Python 绑定。为了使用这个框架，您首先需要安装
    Qt。'
- en: It is worth noting here that Qt has different licensing schemes depending on
    the project. For example, if your project is an open source distribution, licensed
    under the terms of LGPL or GPL, you can use Qt freely. If you are using it for
    a commercial purpose, you have to purchase a license. Visit the Qt website, [https://www.qt.io/](https://www.qt.io/),
    for more details.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，Qt 根据项目不同有不同的许可方案。例如，如果您的项目是开源发行版，根据 LGPL 或 GPL 条款许可，您可以自由使用 Qt。如果您将其用于商业目的，您必须购买许可证。有关详细信息，请访问
    Qt 网站，[https://www.qt.io/](https://www.qt.io/)。
- en: PySide
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PySide
- en: PySide is another Python binding for the Qt GUI framework. It is a free software,
    released under the LGPL license. PySide supports Windows, Mac, and Linux OS. For
    more information, see [https://wiki.qt.io/PySide](https://wiki.qt.io/PySide).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: PySide 是 Qt 图形用户界面框架的另一个 Python 绑定。它是一个免费软件，在 LGPL 许可下发布。PySide 支持 Windows、Mac
    和 Linux 操作系统。有关更多信息，请参阅 [https://wiki.qt.io/PySide](https://wiki.qt.io/PySide)。
- en: Kivy
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kivy
- en: This is one of the most promising open source frameworks for creating cross-platform
    interactive user interfaces. With kivy, you can rapidly develop native multi-touch
    apps for mobile or desktop. It provides a design language called Kv for GUI design.
    The kivy website lists many supported operating systems including Windows, Mac
    OS X , Ubuntu, and Android for which an installer is available.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这是创建跨平台交互式用户界面的最有前途的开源框架之一。使用 kivy，您可以快速为移动或桌面开发原生多点触控应用程序。它提供了一个名为 Kv 的设计语言用于
    GUI 设计。kivy 网站列出了许多支持的操作系统，包括 Windows、Mac OS X、Ubuntu 和 Android，为这些操作系统提供了安装程序。
- en: Tip
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you are using a different OS not listed on the kivy website, the installation
    could be a challenge. For example, at the time of writing this book, there is
    no installer available for **Red Hat Enterprise Linux** (**RHEL**) version 6.x.
    The other option is to build it from source code. But that could be a challenge
    if you are not familiar with the code compilation and building process. If you
    really want to use it, you could also install it in a virtual machine running
    one of the supported OS.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是不在 kivy 网站上列出的操作系统，安装可能会是一个挑战。例如，在撰写本书时，没有为 **Red Hat Enterprise Linux**（**RHEL**）版本
    6.x 提供安装程序。另一个选择是从源代码构建它。但如果您不熟悉代码编译和构建过程，这可能是一个挑战。如果您真的想使用它，您也可以在运行支持操作系统的虚拟机中安装它。
- en: wxPython
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: wxPython
- en: This package provides a wrapper for **wxWidgets**, a cross-platform GUI library.
    It is an open source toolkit, and according to the project website ([http://www.wxpython.org](http://www.wxpython.org)),
    the supported platforms include 32-bit Windows, many Unix-like operating systems,
    and Mac OS X.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 此软件包为**wxWidgets**提供了一个包装器，它是一个跨平台的GUI库。这是一个开源工具包，根据项目网站([http://www.wxpython.org](http://www.wxpython.org))，支持的平台包括32位Windows、许多类Unix操作系统和Mac
    OS X。
- en: While there are many choices available at our disposal, in this chapter we will
    use the built-in Tkinter module mentioned earlier. The scope will be limited to
    developing a simple application that demonstrates some of the major components
    of GUI-based application development.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们有多种选择可供选择，但在这个章节中，我们将使用前面提到的内置Tkinter模块。范围将限于开发一个演示基于GUI应用程序开发主要组件的简单应用程序。
- en: GUI programming design considerations
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GUI编程设计考虑因素
- en: Although the focus of this chapter is on developing simple GUI applications,
    it is worth taking a moment to briefly discuss some important practical design
    considerations or guidelines for developing user interfaces. These guidelines
    will also come in handy for web-based or mobile applications. Some aspects that
    we are about to discuss should actually be part of your GUI application development
    life cycle.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然本章的重点是开发简单的GUI应用程序，但花一点时间简要讨论一些重要的实际设计考虑因素或指南，对于开发用户界面来说是有价值的。这些指南对于基于Web或移动应用程序也很有用。我们即将讨论的一些方面实际上应该是您GUI应用程序开发生命周期的一部分。
- en: Understanding user requirements
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解用户需求
- en: The first and foremost task is to put yourself in the shoes of the end user.
    You are developing the GUI application for consumption by the end users. It is
    important to take their feedback on the features that they would like to see.
    This is typically a part of requirements gathering.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 第一和最重要的任务是站在最终用户的立场上。你正在为最终用户开发GUI应用程序。了解他们希望看到的功能的反馈是非常重要的。这通常是需求收集的一部分。
- en: Developing a user story
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发用户故事
- en: OK, so you know what features are requested, and have prepared a list that would
    be supported in the upcoming version. It is often useful to prepare a mock user
    interface that illustrates how various features could be accessed and how they
    interact. The mock user interface could be in the form of a simple presentation.
    You can then take feedback from the development team as well as from the key users
    of the product. This will allow you to immediately identify the problems, if any,
    or refine your design strategy even before writing a single line of code. Such
    discussions with the key stakeholders could also unearth future requirements that
    you have not thought through. This, in turn, will help you refine the software
    architecture to make provisions for such requirements. Next, let's learn about
    some of the design principles.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，你知道了所需的功能，并准备了一个将在即将推出的版本中支持的功能列表。准备一个模拟用户界面，说明如何访问各种功能以及它们如何交互，通常是有用的。这个模拟用户界面可以是一个简单的演示。然后你可以从开发团队以及产品的关键用户那里获取反馈。这将使你能够立即识别问题（如果有的话），或者在编写代码之前就完善你的设计策略。与关键利益相关者的此类讨论也可能揭示出你尚未考虑的未来需求。这反过来又可以帮助你完善软件架构，为这些需求做出规定。接下来，让我们了解一些设计原则。
- en: Simplicity and accessibility
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简洁性和易用性
- en: 'The GUI should be simple enough to make the most frequently used tasks easy
    to access. What the developers think as *simple* may not always go well with the
    end users. Getting user feedback and going through design iterations play an important
    role. In general, keep the following things in mind when designing for simplicity:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: GUI应该足够简单，以便最常用的任务易于访问。开发者认为的“简单”可能并不总是与最终用户相匹配。获取用户反馈和进行设计迭代起着重要作用。在设计简洁性时，通常需要记住以下几点：
- en: It matters how you lay out the various components in the application window.
    Is it intuitive? Is it easily accessible?
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在应用程序窗口中布局各种组件很重要。这是直观的吗？是否易于访问？
- en: Place frequently used and important functionality prominently in the UI.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在用户界面(UI)中突出显示常用和重要的功能。
- en: Try to hide advanced or less frequently used features. If possible, you could
    create an expert level mode in your GUI where these features appear prominently.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽量隐藏高级或不太常用的功能。如果可能的话，你可以在你的图形用户界面(GUI)中创建一个专家模式，让这些功能突出显示。
- en: Have default values wherever applicable.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在适用的情况下设置默认值。
- en: Common user actions should be easy to execute. For example, if changing the
    background color is a common task, allow users to access this option with a click
    of a button or with a keyboard shortcut.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见用户操作应该容易执行。例如，如果更改背景颜色是一个常见任务，允许用户通过点击按钮或使用键盘快捷键来访问此选项。
- en: Try not to put too many things in the default display. Reduce the clutter.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽量不要在默认显示中放入太多东西。减少杂乱。
- en: Of course, this is not a complete list, and things will change depending on
    the application and the domain.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这不是一个完整的列表，具体内容会根据应用程序和领域的变化而变化。
- en: Consistency
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一致性
- en: The user interface should be consistent. If you have similar features, they
    should have a similar look and feel, similar steps to execute, and so on. The
    placement of standard features or functions should not change. For example, in
    a text editor, the **Open** button is typically placed near the top-left corner
    of the application window. This default position should remain constant.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 用户界面应该是统一的。如果你有类似的功能，它们应该有类似的外观和感觉，类似的执行步骤，等等。标准功能或功能的位置不应改变。例如，在文本编辑器中，**打开**按钮通常放置在应用程序窗口的右上角。这个默认位置应该保持不变。
- en: Predictability and familiarity
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可预测性和熟悉性
- en: When a button is clicked, the user should be able to predict the next course
    of action. A trivial example is the **Save As...** button—when clicked, the user
    anticipates a dialog with the option to specify a location and file format. Why?
    Because he or she is familiar with using a similar function in some other application.
    Further, the user would anticipate some default directory location to save the
    file. The UI should not surprise the user by changing this behavior.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当按钮被点击时，用户应该能够预测下一步的操作。一个简单的例子是**另存为...**按钮——当点击时，用户期待一个对话框，可以选择指定位置和文件格式。为什么？因为他或她熟悉在其他应用程序中使用类似的功能。此外，用户会期待一些默认目录位置来保存文件。UI不应该通过改变这种行为来让用户感到惊讶。
- en: Similarly, when you design an icon, it should speak for itself. For example,
    a gear icon typically indicates some sort of configurable settings. The UI design
    should be such that the user can easily guess the next action to perform in a
    particular situation, be it exiting the current mode or going back to the previous
    step, and so on.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，当你设计图标时，它应该能够自我表达。例如，齿轮图标通常表示某种可配置的设置。UI设计应该是用户可以轻松猜测在特定情况下下一步要执行的操作，无论是退出当前模式还是返回上一步，等等。
- en: Miscellaneous design considerations
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他设计考虑因素
- en: 'We have covered some of the important factors you should know before designing
    a GUI. There are many other design principles. Some of these principles are tied
    to the aspects that we''ve already discussed. A few of these can be listed as
    follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了一些在设计GUI之前你应该知道的重要因素。还有很多其他的设计原则。其中一些原则与我们之前讨论的方面相关。以下是一些可以列举的原则：
- en: The GUI should have a visual appeal and clarity.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GUI应该具有视觉吸引力和清晰度。
- en: It should be comprehensible. In other words, new users should quickly get up
    to speed.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该是可理解的。换句话说，新用户应该能够快速上手。
- en: It should anticipate common problems, and gracefully handle user errors.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该预见常见问题，并优雅地处理用户错误。
- en: Event-driven programming
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件驱动编程
- en: In an algorithm-driven program, the flow of the program is dictated by the predefined
    steps written in that program. The program may prompt the user with these instructions
    for an input. An example is a command-line application asking for user input in
    a predefined order.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个由算法驱动的程序中，程序的流程是由该程序中预定义的步骤决定的。程序可能会提示用户输入这些指令。一个例子是命令行应用程序按照预定义的顺序请求用户输入。
- en: In contrast, applications with a graphical user interface let the user dictate
    the program flow. The application waits for the user actions, and then responds
    to those actions. For example, if you are reading a PDF copy of a book, you can
    perform actions like jumping to the next page, zooming-in, scrolling down, or
    closing the window by clicking on the appropriate buttons. Here, you are essentially
    telling the application what to do next. This is called event-driven programming.
    Here, the control flow of the program is governed by the triggered events. The
    application responds to these events as they occur. The response could be changing
    the state of the graphical element or running some background task, and so on.
    For example, if the user clicks a button representing the next page, the application
    will display the next page of the book. Next, let's briefly talk about a few important
    concepts in event-driven programming.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，具有图形用户界面的应用程序允许用户决定程序流程。应用程序等待用户操作，然后对这些操作做出响应。例如，如果你正在阅读一本书的PDF副本，你可以执行诸如跳转到下一页、放大、滚动或通过点击适当的按钮关闭窗口等操作。在这里，你实际上是在告诉应用程序接下来要做什么。这被称为事件驱动编程。在这里，程序的流程控制由触发的事件控制。应用程序在事件发生时对这些事件做出响应。响应可能是改变图形元素的状态或运行一些后台任务等。例如，如果用户点击代表下一页的按钮，应用程序将显示书的下一页。接下来，让我们简要谈谈事件驱动编程中的一些重要概念。
- en: Event
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件
- en: In simple terms, an event represents an action happening inside the GUI window.
    An event could be triggered by various sources. For example, when a user clicks
    a mouse button, it generates a click event; pressing a key on the keyboard is
    recognized as another event, and so on. An event could also be generated without
    a direct user input. For example, the application might have completed running
    some calculations in the background, and now wants to update the contents presented
    by the GUI. This could automatically trigger some update event that would redraw
    the view.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，事件代表在GUI窗口内发生的一个动作。事件可能由各种来源触发。例如，当用户点击鼠标按钮时，它生成一个点击事件；按下键盘上的键被识别为另一个事件，等等。事件也可能在没有直接用户输入的情况下生成。例如，应用程序可能在后台完成了一些计算，现在想要更新GUI显示的内容。这可能会自动触发一些更新事件，从而重新绘制视图。
- en: Event handling
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件处理
- en: When an event is triggered, the application responds to that event. For example,
    when you click on the close button of a browser, you expect the browser window
    to close. In this example, closing the window is the application's response to
    the click event generated due to user action. In other words, the application
    has a *listener* object that *handles* this click event. Every GUI framework provides
    a way to *bind* (or *connect*) an event to a handling function.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个事件被触发时，应用程序会对该事件做出响应。例如，当你点击浏览器的关闭按钮时，你期望浏览器窗口关闭。在这个例子中，关闭窗口是应用程序对由于用户操作而生成点击事件的响应。换句话说，应用程序有一个*监听器*对象来*处理*这个点击事件。每个GUI框架都提供了一种将事件*绑定*（或*连接*）到处理函数的方法。
- en: Event loop
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件循环
- en: The event loop is the main controlling loop of the GUI program. When you start
    the application, the main loop is started, and it waits for the events to occur.
    It monitors the event sources, and dispatches the events when they occur.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 事件循环是GUI程序的主要控制循环。当你启动应用程序时，主循环开始，并等待事件发生。它监视事件源，并在事件发生时调度事件。
- en: 'With this short introduction, let''s summarize what we have learned about event-driven
    programming:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个简短的介绍，让我们总结一下关于事件驱动编程我们已经学到了什么：
- en: The overall flow of program execution is governed by events
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序执行的整体流程由事件控制
- en: The application runs (the main loop starts) and waits for events to occur
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序运行（主循环开始）并等待事件发生
- en: When an event is triggered, the application code, which is listening to the
    events, responds by running a specific handling function
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个事件被触发时，监听事件的程序代码会通过运行一个特定的处理函数来做出响应
- en: Thus, the flow of a program depends on the triggered events
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此，程序的流程取决于触发的事件
- en: GUI programming with Tkinter
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Tkinter进行GUI编程
- en: As mentioned earlier, a GUI provides a way to interact with an application.
    Instead of a text-based input, the user is presented with elements such as text
    boxes, radio buttons, tool bars, and so on. This section will introduce you to
    the basics of GUI programming with Tkinter. This library is available as a standard
    module in Python.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，GUI提供了一种与应用程序交互的方式。用户不是通过基于文本的输入，而是通过文本框、单选按钮、工具栏等元素进行交互。本节将介绍使用Tkinter进行GUI编程的基础。这个库是Python的标准模块之一。
- en: Tkinter documentation links
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Tkinter文档链接
- en: Let's document some links for a handy reference. The official Tkinter documentation
    page can be found at [https://docs.python.org/3/library/tkinter.html#module-tkinter](https://docs.python.org/3/library/tkinter.html#module-tkinter).
    This page lists several external references. A good introduction is available
    at [http://effbot.org/tkinterbook](http://effbot.org/tkinterbook). Of course,
    you can always perform a web search with search terms like python and Tkinter
    to find more resources.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为方便参考记录一些链接。官方Tkinter文档页面可在[https://docs.python.org/3/library/tkinter.html#module-tkinter](https://docs.python.org/3/library/tkinter.html#module-tkinter)找到。此页面列出了多个外部参考。一个很好的介绍可在[http://effbot.org/tkinterbook](http://effbot.org/tkinterbook)找到。当然，你可以始终使用如python和Tkinter之类的搜索词进行网络搜索以找到更多资源。
- en: Alternatively, you can quickly find the supported functionality and documentation
    using the Python interpreter!
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以快速使用Python解释器查找支持的功能和文档！
- en: '[PRE0]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding command lists the supported classes, functions, and so on. To
    pull out a docstring, you can call the `__doc__` on a given attribute. The following
    example shows a docstring for `mainloop()` in Tkinter:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令列出了支持的类、函数等。要提取文档字符串，可以在给定的属性上调用`__doc__`。以下是一个Tkinter中`mainloop()`的文档字符串示例：
- en: '[PRE1]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The mainloop() in Tkinter
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Tkinter中的mainloop()
- en: 'In the discussion on event-driven programming, we learned about the main controlling
    loop. Writing an event loop or the main loop in Tkinter is very simple. The following
    code fragment shows the main loop in action. This is the simplest possible GUI
    application that you can write using Tkinter:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在关于事件驱动编程的讨论中，我们学习了主控制循环。在Tkinter中编写事件循环或主循环非常简单。以下代码片段展示了主循环的作用。这是你可以用Tkinter编写的最简单的GUI应用程序：
- en: '[PRE2]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s talk through this code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行分析这段代码：
- en: The first statement imports the `Tk` class from the `tkinter` module.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一条语句从`tkinter`模块中导入`Tk`类。
- en: Next, we create a main application window by instantiating the `Tk` class. It
    is represented by the variable `mainwin`. In Tkinter terminology, it is often
    referred to as root or master. In this chapter, we will call it `mainwin`.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们通过实例化`Tk`类创建一个主应用程序窗口。它由变量`mainwin`表示。在Tkinter术语中，它通常被称为root或master。在本章中，我们将称之为`mainwin`。
- en: The main event loop is started by calling the `mainloop()` method.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过调用`mainloop()`方法启动主事件循环。
- en: The output of this simple program is shown next. You can run it as any other
    Python program. The code can also be found in the supporting material for this
    chapter (see the file `mainloop_example.py`). Depending on your operating system
    and environment, the look and feel of this window may vary.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 下文展示了这个简单程序的结果。你可以像运行其他Python程序一样运行它。代码也可以在本书的支持材料中找到（请参阅文件`mainloop_example.py`）。根据你的操作系统和环境，这个窗口的外观和感觉可能会有所不同。
- en: '[PRE3]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '![The mainloop() in Tkinter](img/B05034_10_04.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![Tkinter中的mainloop()](img/B05034_10_04.jpg)'
- en: Tip
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: In Python 2.x, there is a minor change in the `import` statement. The module
    `tkinter` is available as Tkinter (first letter capital) for Python version 2\.
    The supporting code already takes care of this with the following conditional
    `import`. The rest of the code remains the same.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python 2.x中，`import`语句有细微的变化。对于Python版本2，模块`tkinter`作为Tkinter（首字母大写）可用。支持代码已经通过以下条件`import`处理了这个问题。其余代码保持不变。
- en: '[PRE4]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Simple GUI application – Take 1
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单GUI应用程序 – 第一次尝试
- en: We just saw how to start a `mainloop()` method. Let's go one step further, and
    add some widgets to this application. Observe the following code. You can also
    see the file `simple_application_1.py` in this chapter's code bundle.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到了如何启动`mainloop()`方法。让我们更进一步，向这个应用程序添加一些小部件。观察以下代码。你还可以在本章的代码包中看到文件`simple_application_1.py`。
- en: '![Simple GUI application – Take 1](img/B05034_10_05.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![简单的GUI应用程序 – 第一次尝试](img/B05034_10_05.jpg)'
- en: 'The code comments pretty much explain what the code does. It is summarized
    next:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 代码注释基本上解释了代码的功能。以下是总结：
- en: 'We start by importing the necessary classes and options from the `tkinter`
    module. Note that you could also do the following: `from tkinter import *`. However,
    the best practices that we saw earlier in the book do not recommend doing that.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们首先从`tkinter`模块导入必要的类和选项。注意，你也可以这样做：`from tkinter import *`。然而，我们在本书中之前看到的最佳实践并不推荐这样做。
- en: Next, the main window size is specified using the `geometry()` method. This
    is optional.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，使用`geometry()`方法指定主窗口的大小。这是可选的。
- en: The next few lines of the code create two widgets, a `Label` widget that will
    show the text `Hello World!`, and a `Button`, which will terminate the application
    on being clicked.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来的几行代码创建了两个小部件，一个将显示文本`Hello World!`的`Label`小部件，以及一个`Button`，当点击时会终止应用程序。
- en: We need some way to arrange these widgets inside the application window. This
    is referred to as geometry or layout management. There are three options to do
    that. What is illustrated here is the `pack()` method. More on geometry management
    later.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要某种方式来安排这些小部件在应用程序窗口内的布局。这被称为几何或布局管理。有三种方法可以做到这一点。这里展示的是`pack()`方法。关于几何管理的更多内容将在后面讨论。
- en: When the **Exit** button is clicked, we need some way to process this event.
    This is accomplished with the command option that is assigned to a callback function.
    In this example, we simply terminate the application window and also the `mainloop()`
    by calling `mainwin.destroy()`.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当点击**退出**按钮时，我们需要某种方式来处理这个事件。这是通过将命令选项分配给回调函数来完成的。在这个例子中，我们简单地终止应用程序窗口，并通过调用`mainwin.destroy()`来终止`mainloop()`。
- en: Tip
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Recall that Python functions are first-class objects. See [Chapter 6](ch06.html
    "Chapter 6. Design Patterns"), *Design Patterns* where we discussed on this. The
    callback function, `mainwin.destroy`, is assigned to the command variable.
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 回想一下，Python 函数是一等对象。参见[第 6 章](ch06.html "第 6 章。设计模式")，*设计模式*，我们在那里讨论了这一点。回调函数`mainwin.destroy`被分配给命令变量。
- en: 'Running this application from the command line displays a simple GUI window
    like so:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 从命令行运行此应用程序将显示一个简单的 GUI 窗口，如下所示：
- en: '[PRE5]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '![Simple GUI application – Take 1](img/B05034_10_06.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![简单的 GUI 应用程序 – 第 1 次](img/B05034_10_06.jpg)'
- en: If you click on the **Exit** button, it will terminate the main application
    window.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你点击**退出**按钮，它将终止主应用程序窗口。
- en: '| *Looks like Sir Foo is not quite impressed with this simple script...* |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| *看起来福爵士对这个简单的脚本并不太满意...* |'
- en: '![Simple GUI application – Take 1](img/B05034_10_09.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![简单的 GUI 应用程序 – 第 1 次](img/B05034_10_09.jpg)'
- en: '| *For bigger and complex applications, it is better to follow the object-oriented
    programming approach.**Let''s rewrite this application, and wrap it in a class.
    However, keep in mind that it is just a baby step towards creating a better application.
    Later in the chapter, you will learn about the MVC architecture, and a basic example
    on implementing it in your GUI application.* |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| *对于更大和更复杂的应用程序，遵循面向对象编程方法会更好。**让我们重写这个应用程序，并将其封装在一个类中。然而，请记住，这只是一个朝着创建更好的应用程序迈出的小小一步。在本章的后面部分，你将学习关于
    MVC 架构，以及如何在 GUI 应用程序中实现它的基本示例。* |'
- en: Simple GUI application – Take 2
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单 GUI 应用程序 – 第 2 次
- en: 'It is time to add some object-oriented flavor to the mix. The application in
    the previous section can be rewritten as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候给这个混合物添加一些面向对象的风味了。上一节中的应用程序可以重写如下：
- en: '![Simple GUI application – Take 2](img/B05034_10_10.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![简单的 GUI 应用程序 – 第 2 次](img/B05034_10_10.jpg)'
- en: 'Let''s briefly discuss the preceding code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要地讨论一下前面的代码：
- en: Compare this code against the previous code.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将此代码与之前的代码进行比较。
- en: The `MyGame` class is where we create the widgets and define the main logic.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MyGame`类是我们创建小部件和定义主要逻辑的地方。'
- en: Notice that the command callback function for the button is set to `exit_btn_callback`.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意，按钮的命令回调函数被设置为`exit_btn_callback`。
- en: What this means is that when the **Exit** button is pressed, it will invoke
    `exit_btn_callback()` instead of calling `mainwin.destroy()` directly.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这意味着当按下**退出**按钮时，它将调用`exit_btn_callback()`而不是直接调用`mainwin.destroy()`。
- en: This is just to show you how to specify a different callback function. You can
    always set it back to `command=mainwin.destroy()`.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这只是为了向你展示如何指定不同的回调函数。你总是可以将它设置回`command=mainwin.destroy()`。
- en: 'The rest of the code is self-explanatory. You can execute it to get the same
    `Hello world!` window as in the first program. The command is shown next:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的代码是自我解释的。你可以执行它以获得与第一个程序相同的`Hello world!`窗口。命令如下所示：
- en: '[PRE6]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `simple_application_2.py` file in the supporting code bundle essentially
    has the program we just reviewed.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 支持代码包中的 `simple_application_2.py` 文件基本上包含了我们刚才审查的程序。
- en: Tip
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'In all the examples, we will use the `Tk` instance `mainwin` as the master
    or parent object of the widgets created. In practice, it is often useful to create
    a container to hold other widgets in the GUI. The container could be an instance
    of the `Frame` class or any other widget depending on the application. For example,
    you could write the following:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有示例中，我们将使用 `Tk` 实例 `mainwin` 作为创建的小部件的主对象或父对象。在实践中，创建一个容器来在 GUI 中包含其他小部件通常很有用。该容器可以是
    `Frame` 类的实例或任何其他小部件，具体取决于应用程序。例如，您可以编写以下内容：
- en: '[PRE7]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now that we know how to create a simple application with a graphical user interface,
    let's move ahead and talk about the various widgets available in the Tkinter library.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了如何创建一个具有图形用户界面的简单应用程序，让我们继续讨论 Tkinter 库中可用的各种小部件。
- en: GUI Widgets in Tkinter
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Tkinter 中的 GUI 小部件
- en: In this section, we will briefly cover some of the frequently used widgets.
    Note that the widgets we are about to cover are not specific to a GUI library.
    However, the following discussion is tailored for the Tkinter library. For example,
    you will find a `Menu` widget in many GUI libraries. Tkinter provides it with
    the class `Menu`, the PyQt library calls it `QMenu`, and so on.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将简要介绍一些常用的小部件。请注意，我们即将介绍的小部件并不特定于任何 GUI 库。然而，以下讨论是针对 Tkinter 库量身定制的。例如，您将在许多
    GUI 库中找到一个 `Menu` 小部件。Tkinter 通过 `Menu` 类提供它，PyQt 库将其称为 `QMenu` 等。
- en: Tip
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'What we are about to see is far from being a comprehensive list. You are encouraged
    to explore the following wiki page that lists several other GUI elements: [https://en.wikipedia.org/wiki/List_of_graphical_user_interface_elements](https://en.wikipedia.org/wiki/List_of_graphical_user_interface_elements).'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们即将看到的内容远非详尽无遗。我们鼓励您探索以下维基页面，该页面列出了其他几个 GUI 元素：[https://en.wikipedia.org/wiki/List_of_graphical_user_interface_elements](https://en.wikipedia.org/wiki/List_of_graphical_user_interface_elements)。
- en: A widget is an element of a graphical user interface that enables user interaction.
    In other words, the user can do certain actions like pressing a button and interacting
    with the GUI.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 小部件是图形用户界面中的一个元素，它允许用户交互。换句话说，用户可以执行某些操作，如按下按钮并与 GUI 交互。
- en: We already saw how to create the `Label` and `Button` widgets. The following
    table summarizes some important widget classes in Tkinter.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何创建 `Label` 和 `Button` 小部件。以下表格总结了 Tkinter 中一些重要的小部件类。
- en: '| Widget Class | Basic Syntax | Description |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| 小部件类 | 基本语法 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `Menu` |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| `Menu` |'
- en: '[PRE8]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '| This widget represents a menu, such as a menu bar or a pop-up menu. It contains
    menu items. |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| 此小部件表示一个菜单，例如菜单栏或弹出菜单。它包含菜单项。 |'
- en: '| `Frame` |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `Frame` |'
- en: '[PRE9]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '| This is typically used as a container to hold other widgets. The frame widget
    also has its own grid layout, and like many other widgets, you can specify the
    background color, border, and other properties. |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| 这通常用作容器来包含其他小部件。框架小部件也有自己的网格布局，并且像许多其他小部件一样，您可以指定背景颜色、边框和其他属性。 |'
- en: '| `Canvas` |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| `Canvas` |'
- en: '[PRE10]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '| This is a graphics widget. This is where you can draw or write stuff. For
    example, you can render shapes, plots, images, or use this widget to write text.
    |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| 这是一个图形小部件。这是您可以绘制或写入内容的地方。例如，您可以渲染形状、图表、图像，或者使用此小部件来写入文本。|'
- en: '| `Label` |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| `Label` |'
- en: '[PRE11]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '| In a label, you can add a text or an image. When you click on a label, no
    event is triggered. Instead, you can update a label in response to some other
    event generated elsewhere. |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| 在标签中，您可以添加文本或图像。当您点击标签时，不会触发事件。相反，您可以在其他地方生成某些事件响应时更新标签。|'
- en: '| `Button` |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| `Button` |'
- en: '[PRE12]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The optional `command` argument could also be assigned to any user-defined function.
    | A simple button widget. When pressed or released, it triggers an event. |
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 可选的 `command` 参数也可以分配给任何用户定义的函数。| 一个简单的按钮小部件。当按下或释放时，它触发一个事件。|
- en: '| `Radiobutton` |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| `Radiobutton` |'
- en: '[PRE13]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: A group of radio buttons is tied to a common variable, `var`. When you click
    on a radio button, the value of that variable is changed to a predefined one given
    by the value. | The radio button widget allows a user to choose only a single
    value from a given set of values. It can contain a text or an image. |
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 一组单选按钮与一个公共变量 `var` 相关联。当您点击单选按钮时，该变量的值会更改为一个预定义的值，该值由值指定。| 单选按钮小部件允许用户从给定的一组值中选择单个值。它可以包含文本或图像。|
- en: '| `Checkbutton` |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `Checkbutton` |'
- en: '[PRE14]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The variable `var` has value of 1 when the check button is selected, otherwise
    the value is set to 0\. This is the default behavior. | This widget allows setting
    two different values to a variable. Typical usage is to toggle the state (on or
    off selection) of a variable. |
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当复选框被选中时，变量`var`的值为1，否则值设置为0。这是默认行为。| 此小部件允许将两个不同的值设置到变量中。典型用法是切换变量的状态（开启或关闭选择）。|
- en: '|'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE15]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '|'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE16]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You can then add elements to this list box using the `insert()` method as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以使用以下`insert()`方法向此列表框添加元素：
- en: '[PRE17]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '| This widget is used for showing a list of alternatives. The user can select
    one or many elements from the `Listbox` widget. |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| 这个小部件用于显示一系列选项。用户可以从`Listbox`小部件中选择一个或多个元素。|'
- en: '|'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE18]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '|'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE19]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '| This is a text entry widget that allows you to display or input text. In
    some other GUI frameworks, it is referred to as a line-edit widget. |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| 这是一个文本输入小部件，允许您显示或输入文本。在其他一些GUI框架中，它被称为行编辑小部件。|'
- en: The basic syntax shown in the previous table is for illustrative purpose only.
    You can specify many other options. The `parent` argument given to the widget
    represents the parent or the base widget.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 上表中显示的基本语法仅用于说明目的。您可以指定许多其他选项。传递给小部件的`parent`参数表示父小部件或基本小部件。
- en: Tip
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'In this book, we will just use the bare minimum options while creating widgets.
    You could further configure each of these widgets by specifying the appropriate
    optional arguments, or by calling the relevant methods. For further learning,
    follow the various references listed on the official Tkinter documentation page
    at the following link: [https://docs.python.org/3/library/tkinter.html#module-tkinter](https://docs.python.org/3/library/tkinter.html#module-tkinter).'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将在创建小部件时仅使用最基本选项。您可以通过指定适当的可选参数或调用相关方法来进一步配置这些小部件。为了进一步学习，请参考以下链接中官方Tkinter文档页面上列出的各种参考资料：[https://docs.python.org/3/library/tkinter.html#module-tkinter](https://docs.python.org/3/library/tkinter.html#module-tkinter)。
- en: Geometry management
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 几何管理
- en: Layout or geometry management is about organizing various widgets within the
    GUI. In Tkinter, this layout management is accomplished with something referred
    to as geometry managers. There are three different geometry managers to organize
    the widgets, namely *grid*, *pack*, and *place*. Among these, the grid manager
    is the recommended choice. Further in this chapter, we will demonstrate the use
    of a grid manager.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 布局或几何管理涉及在GUI中组织各种小部件。在Tkinter中，这种布局管理是通过称为几何管理器的机制实现的。有三种不同的几何管理器来组织小部件，即*网格*、*包装*和*放置*。在这些中，网格管理器是推荐的选择。在本章的后续内容中，我们将演示网格管理器的使用。
- en: Grid geometry manager
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 网格几何管理器
- en: The grid manager offers flexibility in arranging various widgets, and is also
    very easy to use.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 网格管理器在安排各种小部件方面提供了灵活性，并且也非常容易使用。
- en: The parent widget of the grid manager (for example, a frame or a dialog) is
    treated as a table with rows and columns.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网格管理器的父小部件（例如，一个框架或对话框）被视为一个具有行和列的表格。
- en: The smallest element of this table is a cell, which has a height and a width.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此表格的最小元素是一个单元格，它具有高度和宽度。
- en: You can place other widgets in such cells. It is also possible to have a widget
    that spans more than one cells.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在这样的单元格中放置其他小部件。也可以有一个跨越多个单元格的小部件。
- en: The height of each row in the table is determined by the height of the tallest
    cell (or a widget) in that cell. Likewise, the width of each column in this table
    is governed by the widest cell in that column.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表格中每行的高度由该行中最高的单元格（或小部件）的高度决定。同样，表格中每列的宽度由该列中最宽的单元格控制。
- en: Each row and column in a grid geometry manager can be configured with a weight
    option. Weight determines how much a specific row or column can expand if the
    master widget has free space available. The weight can be specified using the
    methods `grid_rowconfigure` or `grid_columnconfigure` for rows and columns respectively.
    The default value for weight is 0.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网格几何管理器中的每一行和每一列都可以使用权重选项进行配置。权重决定了如果主小部件有可用空间时，特定行或列可以扩展多少。可以使用`grid_rowconfigure`或`grid_columnconfigure`方法分别指定行和列的权重。默认权重值为0。
- en: 'The following screenshot shows a representative grid layout:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了一个代表性的网格布局：
- en: '![Grid geometry manager](img/B05034_10_03.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![网格几何管理器](img/B05034_10_03.jpg)'
- en: In the preceding image, some `Label` widgets are arranged in a grid layout.
    The label text **Cell[0,0]** indicates that we have put this label in row 0 and
    column 0 of the grid. Observe that for **Cell[3,0]**, it shows a label whose width
    occupies four columns. Similarly, **Cell [1,3]** is a label whose height spans
    two rows.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图像中，一些 `Label` 小部件被排列在网格布局中。标签文本 **Cell[0,0]** 表示我们将此标签放置在网格的第 0 行和第 0 列。观察
    **Cell[3,0]**，它显示一个宽度占用四个列的标签。同样，**Cell [1,3]** 是一个高度跨越两行的标签。
- en: Pack geometry manager
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 包布局管理器
- en: 'In our first Tkinter application, we''ve already used the pack geometry manager
    to arrange the widgets. As a refresher, here is the relevant piece of code (the
    `pack` method):'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个 Tkinter 应用程序中，我们已经使用了包布局管理器来排列小部件。作为一个复习，这里是有关的代码片段（`pack`方法）：
- en: '[PRE20]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The pack geometry manager provides options such as expand, fill, and side to
    control widget placement. It is useful when you want to arrange multiple widgets,
    either side by side or overlapping each other. The other use case is when you
    want the widget to occupy the whole container that is holding it.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 包布局管理器提供了如扩展、填充和侧边等选项来控制小部件的位置。当您想要排列多个小部件，无论是并排还是重叠时，它非常有用。另一种用例是当您希望小部件占据包含它的整个容器时。
- en: Tip
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Using both grid and pack geometry manager in the same main window could lead
    to undesirable results. Do not use these layout managers together.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一个主窗口中使用网格和包布局管理器可能会导致不理想的结果。不要一起使用这些布局管理器。
- en: Place geometry manager
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 位置布局管理器
- en: The place geometry manager allows you to specify the absolute or relative position
    of the widget and its size. It finds use in some special scenarios. We will not
    be discussing this geometry manager further. In most cases, you could, instead,
    use the grid geometry manager.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 位置布局管理器允许您指定小部件及其大小的绝对或相对位置。它在某些特殊场景中有用。我们不会进一步讨论这个布局管理器。在大多数情况下，您可以使用网格布局管理器代替。
- en: Events in Tkinter
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Tkinter 中的事件
- en: Let's briefly talk about the various events supported in Tkinter, and the syntax
    that describes them.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要地谈谈 Tkinter 支持的各种事件及其描述的语法。
- en: Event types
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事件类型
- en: The following table shows some of the most frequently used event types. Read
    the documentation to learn about other event types not listed here. The next section,
    *Event descriptors*, will elaborate on how to use an event type to describe an
    event.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 下表显示了最常用的几种事件类型。阅读文档以了解这里未列出的其他事件类型。下一节 *事件描述符* 将详细说明如何使用事件类型来描述事件。
- en: '| Event name | Description |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| 事件名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Button` (or `ButtonPress`) | One of the mouse buttons is pressed. Which
    one? That is determined by the `detail` field of the event descriptor (see the
    next section). |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| `Button`（或`ButtonPress`）| 鼠标按钮之一被按下。是哪一个？这由事件描述符的`detail`字段确定（见下一节）。 |'
- en: '| `ButtonRelease` | One of the mouse buttons (that was pressed earlier) is
    released. |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| `ButtonRelease` | （之前按下的）鼠标按钮之一被释放。 |'
- en: '| `Enter` | The mouse pointer entered a widget. This has nothing to do with
    the *Enter* or *return* key on the keyboard. |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| `Enter` | 鼠标指针进入了一个小部件。这与键盘上的 *Enter* 或 *return* 键无关。 |'
- en: '| `Leave` | The mouse pointer left a widget. |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| `Leave` | 鼠标指针离开了一个小部件。 |'
- en: '| `KeyPress` | A keyboard key is pressed. Which one? That is determined in
    the `detail` field of the event descriptor. |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| `KeyPress` | 一个键盘键被按下。是哪一个？这由事件描述符的`detail`字段确定。 |'
- en: '| `KeyRelease` | A keyboard key is released. |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| `KeyRelease` | 一个键盘键被释放。 |'
- en: '| `FocusIn` | A widget gets an input focus. |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| `FocusIn` | 一个小部件获得输入焦点。 |'
- en: '| `FocusOut` | A widget no longer has the input focus. |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| `FocusOut` | 小部件不再具有输入焦点。 |'
- en: Event descriptors
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事件描述符
- en: 'Tkinter has a special syntax for describing an event. It is a string with the
    following general form:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter 有一个特殊的语法来描述事件。它是一个具有以下一般形式的字符串：
- en: '[PRE21]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The event specified is enclosed within the angular brackets `<>`.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定的事件被括号`<>`包围。
- en: The type specifies the type of the event, such as a mouse click.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型指定了事件的类型，例如鼠标点击。
- en: The modifier and detail specifiers are optional.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修饰符和详细指定符是可选的。
- en: The modifier is the event modifier. Imagine that the Control button is pressed
    along with a mouse button. Here, the Control button is the event modifier, whereas
    the mouse button press is the type of the event.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修饰符是事件修饰符。想象一下，当按下鼠标按钮时，同时按下了控制按钮。在这里，控制按钮是事件修饰符，而鼠标按钮的按下是事件的类型。
- en: The detail specifier gives more information about the type of the event. If
    the type is a mouse click, the details will describe whether it is the left mouse
    button, the right button, or the middle one.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 详细指定符提供了关于事件类型的更多信息。如果类型是鼠标点击，则详细信息将描述它是左鼠标按钮、右按钮还是中间按钮。
- en: The following table summarizes some of the common event specifiers.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格总结了某些常见的事件指定符。
- en: '| Event syntax | Description |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| 事件语法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `<Button-1>` | Mouse button 1 pressed (the left mouse button). |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| `<Button-1>` | 按下鼠标按钮 1（左鼠标按钮）。 |'
- en: '| `<Button-2>` | Mouse button 2 pressed (middle button, if available). |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| `<Button-2>` | 鼠标按钮 2 被按下（如果有中间按钮）。 |'
- en: '| `<Button-3>` | Mouse button 3 pressed (the right-most button). |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| `<Button-3>` | 按下鼠标按钮 3（最右边的按钮）。 |'
- en: '| `<KeyPress-B>` | The *B* key is pressed. Likewise, you can write for other
    keys, such as `<KeyPress-G>`. |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| `<KeyPress-B>` | 按下 *B* 键。同样，你也可以为其他键编写，例如 `<KeyPress-G>`。 |'
- en: '| `<Return>` | Return key pressed. |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| `<Return>` | 按下回车键。 |'
- en: '| `<Configure>` | Size of the widget is changed (for example, window resized).
    The new size is stored as the width and height attributes of the event object.
    |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| `<Configure>` | 小部件的大小已更改（例如，窗口大小调整）。新大小存储为事件对象的宽度和高度属性。 |'
- en: '| `<Shift-Button-1>` | The *Shift* key is pressed along with the left mouse
    button. |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| `<Shift-Button-1>` | 按下 *Shift* 键的同时按下左鼠标按钮。 |'
- en: Event object attributes
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事件对象属性
- en: An instance of the `Event` class holds the information that describes the event.
    The following table lists some important attributes of the `Event` class.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`Event` 类的实例持有描述事件的详细信息。以下表格列出了 `Event` 类的一些重要属性。'
- en: '| Event attribute | Description |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| 事件属性 | 描述 |'
- en: '| --- | --- |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `widget` | The widget object which triggered this event. |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| `widget` | 触发此事件的部件对象。 |'
- en: '| `x`, `y` | The current mouse position in pixels. |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| `x`, `y` | 当前鼠标位置的像素。 |'
- en: '| `x_root`, `y_root` | Mouse position in pixels, relative to the top-left corner.
    |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| `x_root`, `y_root` | 以像素为单位，相对于左上角的鼠标位置。 |'
- en: '| `width`, `height` | The changed size (width and height) for the `<Configure>`
    type of events. |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| `width`, `height` | `<Configure>` 类型事件的更改大小（宽度和高度）。 |'
- en: Event handling in Tkinter
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Tkinter 中的事件处理
- en: Earlier in the chapter, we learned about events and event handling (see the
    section *Event-driven programming*). In this section, we will see how to bind
    the various events triggered due to user interactions, with the appropriate handling
    functions.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的早期，我们学习了事件和事件处理（参见 *事件驱动编程* 部分）。在本节中，我们将了解如何将用户交互引起的各种事件与适当的处理函数绑定。
- en: Command callback (Button widget)
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命令回调（按钮小部件）
- en: 'Recall that when we wrote our first Tkinter application, we tied a callback
    function to the `command` argument of the `Button` widget. The relevant line of
    code is reproduced next for easy reference:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，当我们编写第一个 Tkinter 应用程序时，我们将回调函数绑定到 `Button` 小部件的 `command` 参数。下面是相关代码行的复制，以便于参考：
- en: '[PRE22]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: When you click on the **Exit** button, it calls `mainwin.destroy()`, represented
    by the `command` argument. It should be noted that while the `Button` widget supports
    command callback, this feature is not available for all the supported widgets.
    For that, Tkinter provides the `bind()` method, which is defined on all widgets.
    The `bind()` method is just one of the levels of event binding in Tkinter. Let's
    talk about a few event-binding levels next.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 当你点击**退出**按钮时，它会调用 `mainwin.destroy()`，这由 `command` 参数表示。需要注意的是，虽然 `Button`
    小部件支持命令回调，但此功能并非所有支持的部件都可用。为此，Tkinter 提供了 `bind()` 方法，该方法定义在所有小部件上。`bind()` 方法只是
    Tkinter 事件绑定级别中的一级。接下来，让我们谈谈几个事件绑定级别。
- en: The bind() method
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: bind() 方法
- en: 'This method provides an instance level binding. It binds an event to a specific
    widget instance. Another way to think of this is as an ability to specify the
    exact GUI element that is sensitive to a particular event. The basic syntax is
    as follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法提供实例级别绑定。它将事件绑定到特定的小部件实例。另一种思考方式是，这可以指定对特定事件敏感的确切 GUI 元素。基本语法如下：
- en: '[PRE23]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: It should be noted that you can also use this method for the `toplevel` window.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，你也可以使用此方法为 `toplevel` 窗口。
- en: For ease of understanding, let's represent the optional argument sequence as
    `even_descriptor` and `func` as `event_handler`. The third optional argument add
    can be specified as a string `+`. It allows you to add a new function to an existing
    binding. We will not discuss the `add` argument here. Refer to the documentation
    for further details.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于理解，让我们将可选参数序列表示为`even_descriptor`，将`func`表示为`event_handler`。第三个可选参数`add`可以指定为字符串`+`。它允许你向现有绑定添加一个新函数。我们在此不讨论`add`参数。请参阅文档以获取更多详细信息。
- en: '[PRE24]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the preceding statement, `widget` is any widget that generates one or more
    events. For example, the widget could be a `Button`, an `Entry` widget, and the
    like. The `event_descriptor` is the actual event triggered, for instance, a key
    press, or a click, and so on. `event_handler` is the function that gets called
    when the event is triggered.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的语句中，`widget`是生成一个或多个事件的任何小部件。例如，该小部件可以是`Button`、`Entry`小部件等。`event_descriptor`是实际触发的事件，例如按键或点击等。`event_handler`是当事件被触发时被调用的函数。
- en: Let's see how to use this method for the `Button` widget, in place of a command
    callback. Apart from the syntax, we also need to define a callback function that
    handles the generated event. Let's rewrite the code illustrated in the section,
    *Simple GUI application*.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用此方法来处理`Button`小部件，而不是命令回调。除了语法之外，我们还需要定义一个处理生成的事件的回调函数。让我们重写*简单GUI应用程序*部分中展示的代码。
- en: '![The bind() method](img/B05034_10_07.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![bind()方法](img/B05034_10_07.jpg)'
- en: Observe that we have defined a new event handling function, `exit_btn_clicked()`,
    that takes the event object (`evt`) as an argument. The first argument to bind
    represents the type of event or the event format. In this example, `<Button-1>`
    represents a left mouse button press over the widget. In this chapter, we will
    only use the `bind()` method. But before we go further, let's briefly talk about
    the other levels of binding.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们已经定义了一个新的事件处理函数`exit_btn_clicked()`，它接受事件对象（`evt`）作为参数。绑定到`bind`的第一个参数表示事件类型或事件格式。在这个例子中，`<Button-1>`表示在控件上按下左鼠标按钮。在本章中，我们只会使用`bind()`方法。但在我们进一步讨论之前，让我们简要地谈谈其他绑定级别。
- en: The bind_class() method
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`bind_class()`方法'
- en: 'This method provides a class-level binding. It binds an event to a specific
    widget class. The basic syntax is shown next:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法提供类级别的绑定。它将一个事件绑定到特定的小部件类。基本语法如下所示：
- en: '[PRE25]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the preceding syntax, `className` is a string representing the name of the
    widget class. The other arguments are the same as discussed in the previous section.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的语法中，`className`是一个表示小部件类名的字符串。其他参数与上一节中讨论的相同。
- en: 'Imagine that all the `Button` widgets in your application represent some numbers.
    You can configure all of them to respond to the right mouse click event such that
    each returns the square of that number. In this example, you can use the `bind_class`
    method like so:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 假想你应用程序中的所有`Button`小部件代表一些数字。你可以配置它们以响应右键点击事件，使得每个都返回该数字的平方。在这个例子中，你可以像这样使用`bind_class`方法：
- en: '[PRE26]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here, it is assumed that you have defined a function, `compute_square`.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，假设你已经定义了一个函数，`compute_square`。
- en: The bind_all() method
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`bind_all()`方法'
- en: 'This method provides an application-level binding. As the name suggests, this
    method binds an event to all the widgets at the application level. For example,
    in some game application, you might want to configure a key to pause the game
    regardless of the widget under focus. In such situations, you can use this method.
    The basic syntax is as follows:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法提供应用级别的绑定。正如其名所示，此方法将事件绑定到应用级别的所有小部件。例如，在某些游戏应用中，你可能想要配置一个键来暂停游戏，无论当前焦点的小部件是什么。在这种情况下，你可以使用此方法。基本语法如下：
- en: '[PRE27]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Tip
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Tkinter supports something referred to as bind tags. Every widget has its own
    list of bind tags. These determine the order in which the events associated with
    a widget are processed. The built-in method `bindtags()` can be used to set or
    get the tags associated with a widget. See the documentation for further details.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter支持称为绑定标签的功能。每个小部件都有自己的绑定标签列表。这些标签决定了与控件相关的事件处理的顺序。内置方法`bindtags()`可以用来设置或获取与控件关联的标签。请参阅文档以获取更多详细信息。
- en: Project-1 – Attack of the Orcs V10.0.0
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目-1 – 兽人攻击 V10.0.0
- en: '| *You have developed a robust and popular command-line application, **Attack
    of the Orcs**. While the users are happy with the current version, there is a
    new and growing demand. The users now want a graphical user interface for the
    application!* |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| *你已经开发了一个强大且流行的命令行应用程序，**兽人攻击**。虽然用户对当前版本很满意，但现在有一个新的和不断增长的需求。用户现在希望应用程序有一个图形用户界面！*
    |'
- en: It is time to work on another simple program. Remember the first ever command-line
    application we wrote in [Chapter 1](ch01.html "Chapter 1. Developing Simple Applications"),
    *Developing Simple Applications*? Let's use the same theme, and develop an equivalent
    GUI program.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候开始另一个简单的程序了。还记得我们在[第1章](ch01.html "第1章. 开发简单应用程序")中编写的第一个命令行应用程序吗，*开发简单应用程序*？让我们使用相同的主题，开发一个等效的GUI程序。
- en: Background scenario
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 背景场景
- en: 'As a refresher, here is the game theme we saw in [Chapter 1](ch01.html "Chapter 1. Developing
    Simple Applications"), *Developing Simple Applications*:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 作为复习，以下是我们在[第1章](ch01.html "第1章. 开发简单应用程序")中看到的游戏主题，*开发简单应用程序*：
- en: '| *On his way through a dense forest, Sir Foo spotted a small isolated settlement.
    Tired and hoping to replenish his food stock, he decided to take a detour. As
    he approached the village, he saw five huts. There was no one to be seen around.
    Hesitantly, he decided to enter a hut...* |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| *在穿越茂密森林的路上，福爵士发现了一个小型的孤立定居点。又累又希望补充食物储备，他决定绕道而行。当他接近村庄时，他看到了五座小屋。周围看不到任何人。犹豫了一下，他决定进入一座小屋...*
    |'
- en: Problem statement
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题说明
- en: '| *The task is to design a* *simple GUI program. The player selects one of
    the five huts where Sir Foo can rest. The huts are randomly occupied either by
    a friend or an enemy. Some huts might also be left unoccupied. The player wins
    if the selected hut is either unoccupied or has a friendly unit inside.* |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| *任务是设计一个* *简单的GUI程序。玩家可以选择福爵士可以休息的五座小屋中的一座。小屋可能被朋友或敌人占据，也可能空着。如果玩家选择的小屋是空的或有友军单位在里面，则玩家获胜。*
    |'
- en: The following screenshot shows what's coming up. But don't get too excited!
    It is quite a simple game that will help you learn some important GUI programming
    aspects.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了即将发生的事情。但不要太过兴奋！这是一个相当简单的游戏，将帮助你学习一些重要的GUI编程方面。
- en: '![Problem statement](img/B05034_10_08.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![问题说明](img/B05034_10_08.jpg)'
- en: When you click on a hut, it will check who the occupant is, and then pop up
    a message box declaring the winner. That's pretty much it!
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 当你点击一个小屋时，它会检查居住者是谁，然后弹出一个消息框宣布获胜者。就是这样！
- en: Writing the code
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写代码
- en: We will use the code provided in the `hutgame.py` file. Download this file and
    also the two images, `Hut_small.gif` and `Jungle_small.gif` from the code bundle
    for this chapter.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `hutgame.py` 文件中提供的代码。请从本章的代码包中下载此文件以及两个图像，`Hut_small.gif` 和 `Jungle_small.gif`。
- en: Tip
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It is recommended that you open the file `hutgame.py` as a handy reference while
    reading the following discussion. Quite often, it is useful to skim through the
    full code in a source code editor for better understanding!
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 建议你在阅读以下讨论时打开文件 `hutgame.py` 作为便捷的参考。在源代码编辑器中快速浏览完整代码通常很有帮助！
- en: 'We will start with the main execution code:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从主执行代码开始：
- en: '![Writing the code](img/B05034_10_12.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![编写代码](img/B05034_10_12.jpg)'
- en: 'Let''s talk through this code:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析一下这段代码：
- en: Compare this with the main execution block in the section *Simple GUI application
    – Take 2*. Notice that there isn't much of a difference.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将它与“简单GUI应用程序 - 第二次尝试”部分中的主执行块进行比较。注意，两者之间没有太大的区别。
- en: We set the size and a title for the application window with the `geometry` and
    `title` methods. The `mainwin.resizable` call freezes the window size. This is
    optional, but will make sure the background image nicely fits the window.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用 `geometry` 和 `title` 方法设置应用程序窗口的大小和标题。`mainwin.resizable` 调用冻结窗口大小。这是可选的，但可以确保背景图像完美地适应窗口。
- en: The `HutGame` class is where we create the widgets and define the main logic.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HutGame` 类是我们创建小部件和定义主要逻辑的地方。'
- en: The main event loop is started by calling `mainloop()`.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过调用 `mainloop()` 启动主事件循环。
- en: Overview of the class HutGame
  id: totrans-278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HutGame 类概述
- en: 'Before reviewing any code in the class `HutGame`, let''s get the big picture
    first. The important methods of this class are shown in the following diagram:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在审查 `HutGame` 类中的任何代码之前，让我们先了解整体情况。这个类的关键方法如下图中所示：
- en: '![Overview of the class HutGame](img/B05034_10_11_uml_hutgame_1.jpg)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![HutGame 类概述](img/B05034_10_11_uml_hutgame_1.jpg)'
- en: As illustrated, these methods can be broadly divided into three groups based
    on the functionality. We will talk about this grouping later when we discuss the
    MVC architecture. Let's review the various methods in this class next.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如上图所示，这些方法可以根据功能大致分为三组。我们将在讨论 MVC 架构时再讨论这种分组。接下来，让我们回顾一下这个类中的各种方法。
- en: Tip
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**A note to more experienced readers!**'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '**给更有经验的读者的一则笔记！**'
- en: In the following few sections, we will discuss the methods of the class `HutGame`.
    You might find this discussion a bit verbose! Optionally, you can just review
    the code from the file `hutgame.py`. The code is documented reasonably well. If
    something is not clear, come back and read the relevant section!
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将讨论 `HutGame` 类的方法。你可能会觉得这个讨论有点冗长！你可以选择只查看 `hutgame.py` 文件中的代码。代码有很好的文档说明。如果有什么不清楚的地方，请返回并阅读相关部分！
- en: The __init__ method
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: The __init__ method
- en: 'Take a look at the code that gets called when `HutGame` is instantiated:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 看看当 `HutGame` 被实例化时调用的代码：
- en: '![The __init__ method](img/B05034_10_13.jpg)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![The __init__ method](img/B05034_10_13.jpg)'
- en: 'The following is a description of the `__init__` method:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对 `__init__` 方法的描述：
- en: The `PhotoImage` class is used for displaying a background image in widgets
    such as labels, buttons, and so on. It supports the GIF image format. There is
    also a way to load an image using **Python Imaging Library** (**PIL**). We won't
    discuss those details here.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PhotoImage` 类用于在标签、按钮等控件中显示背景图像。它支持 GIF 图像格式。还有使用 **Python Imaging Library**（**PIL**）加载图像的方法。我们在这里不会讨论这些细节。'
- en: We will use `hut_image` on a `RadioButton`, and `village_image` will be set
    as the application background.
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将在 `RadioButton` 上使用 `hut_image`，并将 `village_image` 设置为应用程序的背景。
- en: The `self.setup()` call ensures that widgets are created and appropriately placed
    in the application window.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.setup()` 调用确保控件被创建并适当地放置在应用程序窗口中。'
- en: The occupy_huts method
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: The occupy_huts method
- en: 'The following method is the same as the one illustrated in the first example
    of [Chapter 1](ch01.html "Chapter 1. Developing Simple Applications"), *Developing
    Simple Applications*:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方法与 [第 1 章](ch01.html "第 1 章。开发简单应用程序") 中的第一个示例相同，即 *开发简单应用程序*：
- en: '![The occupy_huts method](img/B05034_10_14.jpg)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![The occupy_huts method](img/B05034_10_14.jpg)'
- en: There are exactly five huts. This code essentially populates the `self.huts`
    list with a random choice of occupant from the given `occupants` list.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 确切有五个小屋。这段代码基本上是从给定的 `occupants` 列表中随机选择居民来填充 `self.huts` 列表。
- en: The create_widgets method
  id: totrans-296
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: The create_widgets method
- en: 'As the name suggests, this method is about creating the widgets for our application.
    Actually, there aren''t many widgets. We just have a label to display some information
    and a bunch of radio buttons to represent the huts. The method is shown next:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，这个方法涉及创建我们应用程序的控件。实际上，控件并不多。我们只有一个标签来显示一些信息，以及一些代表小屋的单选按钮。方法如下所示：
- en: '![The create_widgets method](img/B05034_10_15.jpg)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![The create_widgets method](img/B05034_10_15.jpg)'
- en: 'The preceding method can be explained as follows:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 上述方法可以这样解释：
- en: '`self.var` is a Tkinter variable. It is an instance of a variable class supported
    by Tkinter. Here, it represents an integer variable (`IntVar` class). Likewise.
    there are other classes such as `StringVar` to deal with string variables, and
    so on.'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.var` 是一个 Tkinter 变量。它是 Tkinter 支持的变量类的一个实例。在这里，它代表一个整型变量（`IntVar` 类）。同样，还有其他类，如
    `StringVar`，用于处理字符串变量等。'
- en: Simply put, the Tkinter variables enable tracking changes. We have five radio
    buttons that are tied to the single Tkinter variable, `self.var`. A value option
    can be specified for each radio button. This value gets assigned to `self.var`
    when the radio button is selected.
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简而言之，Tkinter 变量使跟踪更改成为可能。我们有五个与单个 Tkinter 变量 `self.var` 相关联的单选按钮。可以为每个单选按钮指定一个值选项。当单选按钮被选中时，这个值会被分配给
    `self.var`。
- en: The dictionary `r_btn_config` is used to set configuration options common to
    all the radio buttons. It is passed as an argument to `Radiobutton`.
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字典 `r_btn_config` 用于设置所有单选按钮的共同配置选项。它作为参数传递给 `Radiobutton`。
- en: An example would help in understanding how a radio button works. The button
    `self.r4` has an associated value of `4`, which represents the hut number. When
    you select the button, this value gets assigned to `self.var`. This invokes `self.radio_btn_pressed()`,
    the command callback for the button.
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个例子有助于理解单选按钮的工作原理。按钮 `self.r4` 有一个关联的值 `4`，代表小屋编号。当你选择按钮时，这个值会被分配给 `self.var`。这会调用
    `self.radio_btn_pressed()`，即按钮的命令回调函数。
- en: '`self.background_label` is used to set a village background for our application
    window. There are other ways to accomplish this. We won''t be discussing such
    customization details in this book.'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.background_label`用于为我们的应用程序窗口设置村庄背景。还有其他方法可以实现这一点。在这本书中，我们不会讨论此类自定义细节。'
- en: '![The create_widgets method](img/B05034_10_16.jpg)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![创建小部件方法](img/B05034_10_16.jpg)'
- en: '| *Certainly! Have a look at the following application window where some of
    these widgets or configuration options are annotated.* |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| *当然！请查看以下应用程序窗口，其中一些小部件或配置选项已标注。* |'
- en: '![The create_widgets method](img/B05034_10_17.jpg)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
  zh: '![创建小部件方法](img/B05034_10_17.jpg)'
- en: The setup_layout method
  id: totrans-308
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置布局方法
- en: 'The following code fragment shows the `setup_layout()` method. and how it is
    invoked in the top-level `setup()` method:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了`setup_layout()`方法以及它在顶级`setup()`方法中的调用方式：
- en: '![The setup_layout method](img/B05034_10_18.jpg)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
  zh: '![设置布局方法](img/B05034_10_18.jpg)'
- en: Tip
  id: totrans-311
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The grid layout offers a lot of flexibility in arranging widgets. In this illustration,
    we are just scratching the surface of Tkinter! To gain expertise, you should create
    your own GUI widgets, and experiment with different layout configuration options.
    Refer to the documentation for other available options.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 网格布局在安排小部件方面提供了很多灵活性。在这幅插图中，我们只是触及了Tkinter的表面！要获得专业知识，您应该创建自己的GUI小部件，并尝试不同的布局配置选项。请参阅文档了解其他可用选项。
- en: 'Now let''s talk through this code snippet:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来分析这段代码：
- en: Recall that we can assign a relative `weight` to a specific row or a column
    in a grid layout. This is accomplished using the `grid_rowconfigure` and `grid_columnconfigure`
    methods. `weight` determines how much free space the row or column will occupy
    relative to the others. A default value of 0 means it won't grow even if there
    is free space available.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记住，我们可以在网格布局中为特定的行或列分配一个相对`weight`。这是通过使用`grid_rowconfigure`和`grid_columnconfigure`方法实现的。`weight`决定了行或列相对于其他行或列将占用多少空闲空间。默认值0表示即使有可用空间，它也不会增长。
- en: In this example, `row 1` of the container is given a relative weight or `1`,
    allowing it to expand and occupy more free space. Likewise, the `column 0` and
    `column 4` are assigned with a relative weight of `1`. Experiment with this option,
    and see how it influences the layout. The other option to try out is pad, which
    adds padding to the widget.
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这个例子中，容器中的`第1行`被赋予一个相对权重或`1`，允许它扩展并占用更多空闲空间。同样，`第0列`和`第4列`被分配了相对权重`1`。尝试这个选项，看看它如何影响布局。另一个要尝试的选项是`pad`，它为小部件添加填充。
- en: For `background_label`, we use the `place()` geometry manager. The label is
    anchored at `(0, 0)`. The arguments `relwidth` and `relheight` indicate the fraction
    of the height and width of the parent. The value of 1.0 means the label size will
    be the same as its parent (the main application window).
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`background_label`，我们使用`place()`几何管理器。标签锚定在`(0, 0)`。`relwidth`和`relheight`参数表示父窗口的高度和宽度的分数。1.0的值意味着标签的大小将与它的父窗口（主应用程序窗口）相同。
- en: The `sticky` option for `info_label` ensures the widget is aligned along the
    four edges of the cell. The value `nsew` aligns the widgets along the north, south,
    east, and west cell edges respectively. You can also specify a few values, for
    example, `sticky='ew'` will align the widget along the left and right edges.
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`info_label`的`sticky`选项确保小部件沿单元格的四个边缘对齐。值`nsew`分别沿北、南、东、西单元格边缘对齐小部件。您还可以指定几个值，例如，`sticky=''ew''`将小部件沿左右边缘对齐。'
- en: The radio_btn_pressed and enter_hut methods
  id: totrans-318
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: radio_btn_pressed和enter_hut方法
- en: 'Let''s review these methods together. In the `create_widgets()` method, we
    specified the command option as indicated in the following code fragment:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一起回顾这些方法。在`create_widgets()`方法中，我们指定了命令选项，如下代码片段所示：
- en: '![The radio_btn_pressed and enter_hut methods](img/B05034_10_19.jpg)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
  zh: '![radio_btn_pressed和enter_hut方法](img/B05034_10_19.jpg)'
- en: '`radio_btn_pressed` is a command callback for all the radio buttons. It is
    shown next:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '`radio_btn_pressed`是所有单选按钮的命令回调。它如下所示：'
- en: '![The radio_btn_pressed and enter_hut methods](img/B05034_10_20.jpg)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
  zh: '![radio_btn_pressed和enter_hut方法](img/B05034_10_20.jpg)'
- en: The method just calls `self.enter_hut`. When the radio button is selected, it
    updates the value stored in the Tkinter variable, `self.var`. This value is nothing
    but the hut number assigned to the selected hut, and can be obtained by calling
    the `get()` method of Tkinter's `IntVar` class.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法只是调用 `self.enter_hut`。当单选按钮被选中时，它更新存储在 Tkinter 变量 `self.var` 中的值。这个值不过是分配给所选小屋的小屋编号，可以通过调用
    Tkinter 的 `IntVar` 类的 `get()` 方法来获取。
- en: 'Let''s take a look at the `enter_hut` method:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `enter_hut` 方法：
- en: '![The radio_btn_pressed and enter_hut methods](img/B05034_10_21.jpg)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
  zh: '![radio_btn_pressed 和 enter_hut 方法](img/B05034_10_21.jpg)'
- en: The preceding code is self-explanatory. It checks the occupant, and announces
    the result. The winner announcement is done with a `messagebox` widget.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是自我解释的。它检查居住者，并宣布结果。获胜者公告是通过 `messagebox` 小部件完成的。
- en: The announce_winner method
  id: totrans-327
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`announce_winner` 方法'
- en: 'This is the last method we will review:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将要审查的最后一个方法：
- en: '![The announce_winner method](img/B05034_10_22.jpg)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
  zh: '![announce_winner 方法](img/B05034_10_22.jpg)'
- en: In the preceding method, we use the `messagebox` module in Tkinter to show an
    information box. This module provides several other types of dialog boxes. Refer
    to the documentation for more details.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述方法中，我们使用 Tkinter 的 `messagebox` 模块来显示信息框。此模块提供了几种其他类型的对话框。有关更多详细信息，请参阅文档。
- en: Running the application
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行应用程序
- en: 'It is time for some action! Run this application as follows:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候采取一些行动了！按照以下方式运行此应用程序：
- en: '[PRE28]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This last command should display the GUI window shown earlier. The following
    screenshot shows the game in action. First you select one of the huts:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一条命令应该显示之前显示的 GUI 窗口。以下截图显示了游戏的实际运行情况。首先，你选择一个小屋：
- en: '![Running the application](img/B05034_10_23.jpg)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
  zh: '![运行应用程序](img/B05034_10_23.jpg)'
- en: When you click on the radio button, it displays the information box notifying
    the winner.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 当你点击单选按钮时，它会显示通知获胜者的信息框。
- en: '![Running the application](img/B05034_10_24.jpg)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
  zh: '![运行应用程序](img/B05034_10_24.jpg)'
- en: MVC architecture
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MVC 架构
- en: 'MVC is a widely used software architectural pattern in GUI-based applications.
    It has three components, namely a *model* that deals with the business logic,
    a *view* for the user interface, and a *controller* to handle the user input,
    manipulate data, and update the view. The following is a simplified schematic
    that shows the basic interactions between the various components:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: MVC 是基于 GUI 的应用程序中广泛使用的软件架构模式。它有三个组件，即处理业务逻辑的 *模型*、用于用户界面的 *视图* 和处理用户输入、操作数据并更新视图的
    *控制器*。以下是一个简化的示意图，展示了各个组件之间的基本交互：
- en: '![MVC architecture](img/B05034_10_01.jpg)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
  zh: '![MVC 架构](img/B05034_10_01.jpg)'
- en: Let's further discuss each of these components.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步讨论这些组件的每个部分。
- en: Model
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模型
- en: The model component of the MVC architecture represents the data of the application.
    It also represents the core business logic that acts on such data. The model has
    no knowledge of the view or the controller. When the data in the model changes,
    it just notifies its listeners about this change. In this context, the controller
    object is its listener.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: MVC 架构中的模型组件代表应用程序的数据。它还代表作用于这些数据的核心业务逻辑。模型对视图或控制器没有任何了解。当模型中的数据发生变化时，它只是通知其监听器这一变化。在这种情况下，控制器对象是其监听器。
- en: View
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视图
- en: The view component is the user interface. It is responsible for displaying the
    current state of the model to the user, and also provides a means for the user
    to interact with the application. If a user action (like the click of a button)
    changes this state, the view is refreshed to display that change.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 视图组件是用户界面。它负责向用户显示模型的当前状态，并为用户提供与应用程序交互的手段。如果用户操作（如按钮点击）改变了这一状态，视图将刷新以显示这一变化。
- en: Controller
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制器
- en: In some sense, the controller enables a handshake between the model and the
    view. It monitors the changes to the model. When the user interacts with something
    in the view, the controller works in the background and handles the events triggered
    by the user actions, such as a mouse click. The handling function can further
    update the model. When the model's state changes, the controller updates the view
    to reflect those changes.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在某种意义上，控制器使得模型和视图之间能够进行握手。它监控模型的变化。当用户与视图中的某个元素交互时，控制器在后台工作并处理由用户操作触发的事件，例如鼠标点击。处理函数可以进一步更新模型。当模型的状态发生变化时，控制器更新视图以反映这些变化。
- en: '![Controller](img/B05034_10_02.jpg)'
  id: totrans-348
  prefs: []
  type: TYPE_IMG
  zh: '![控制器](img/B05034_10_02.jpg)'
- en: '| *You are right. The individual MVC components and their working would be
    better understood with an illustration. Let''s use a trivial example given earlier
    in the section **Event-driven programming***. |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '| *你说得对。通过插图可以更好地理解 MVC 的各个组件及其工作原理。让我们使用本节中先前给出的简单示例**事件驱动编程**。 |'
- en: 'Imagine you have opened a PDF file for reading. In this context, MVC and its
    components could be explained as follows:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你打开了 PDF 文件进行阅读。在这种情况下，MVC 及其组件可以这样解释：
- en: The PDF reader is the running application.
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PDF 阅读器是运行中的应用程序。
- en: It will show the contents of the file you have opened, and will also have buttons
    to navigate through the file. This is the view component that deals with the user
    interface.
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将显示你打开的文件的内容，并且还将有按钮用于在文件中导航。这是处理用户界面的视图组件。
- en: To jump to the next page, you interact with the view and click on the next page
    button. This is a user input that generates an event.
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要跳转到下一页，你需要与视图交互并点击下一页按钮。这是一个用户输入，它生成一个事件。
- en: Such an event is internally handled by the controller, which then updates the
    model, or, in this context, retrieves the relevant data on the requested page.
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这样的事件由控制器内部处理，然后更新模型，或者在这个上下文中，检索请求页面的相关数据。
- en: The model 's state has changed. The controller further communicates with the
    view for updating it with the new contents.
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型的状态已更改。控制器进一步与视图通信，以更新其新内容。
- en: The view is refreshed, and finally, you see the desired page.
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图被刷新，最后，你看到所需的页面。
- en: Advantages of MVC
  id: totrans-357
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MVC 的优势
- en: The MVC architecture has been traditionally used in desktop GUI applications,
    and is also widely used in web application development. As this is a three-component
    architecture, one major advantage it offers is code reuse across several applications.
    For example, imagine you have multiple applications with different user interfaces,
    all needing the same business logic. With MVC architecture, you could just reuse
    the business logic represented by the model object across these applications.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: MVC 架构传统上用于桌面 GUI 应用程序，并且在网络应用程序开发中也得到了广泛的应用。由于这是一个三组件架构，它提供的一个主要优势是跨多个应用程序的代码重用。例如，假设你有多款具有不同用户界面的应用程序，它们都需要相同的企业逻辑。使用
    MVC 架构，你可以简单地重用模型对象在这些应用程序中表示的企业逻辑。
- en: Moreover, the MVC enables user interface developers to focus on the UI code
    without worrying much about the code that handles the business logic. Likewise,
    the developers working on the business logic can concentrate on that piece of
    code alone without losing sleep over the choice of UI widgets and the related
    code. This is referred to as *separation of concerns*. The model is concerned
    about the business logic or data, the view worries about the user interface, and
    the controller code is concerned about things such as enabling view manipulation
    and handling the input.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，MVC 允许用户界面开发者专注于 UI 代码，不必过多担心处理企业逻辑的代码。同样，专注于企业逻辑的开发者可以专注于那部分代码，而无需为 UI 小部件和相关的代码选择而烦恼。这被称为*关注点分离*。模型关注企业逻辑或数据，视图关注用户界面，控制器代码关注诸如启用视图操作和处理输入等问题。
- en: Project 2 – Attack of the Orcs v10.1.0
  id: totrans-360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目 2 – Attack of the Orcs v10.1.0
- en: Let's work on another small project. In fact, this is exactly the same hut game
    we developed in *Project-1 – Attack of the Orcs V10.0.0* earlier. The difference
    is the underlying architecture. We will rewrite the program to implement the MVC
    architecture.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再做一个小型项目。实际上，这正是我们在 *Project-1 – Attack of the Orcs V10.0.0* 中开发的相同的小屋游戏。区别在于底层架构。我们将重写程序以实现
    MVC 架构。
- en: Revisiting the HutGame class
  id: totrans-362
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新审视 HutGame 类
- en: 'In the first project, we wrote the `HutGame` class. Let''s pull up the diagram
    representing the high-level structure of this class:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个项目中，我们编写了 `HutGame` 类。让我们拉出表示这个类高级结构的图：
- en: '![Revisiting the HutGame class](img/B05034_10_25.jpg)'
  id: totrans-364
  prefs: []
  type: TYPE_IMG
  zh: '![重新审视 HutGame 类](img/B05034_10_25.jpg)'
- en: Based on the functionality, the methods of this class can be roughly placed
    into three categories, namely model, view, and the controller. The preceding diagram
    shows this division. We also need to further update a few of these methods.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 根据功能，这个类的函数可以大致分为三类，即模型、视图和控制器。前面的图示显示了这种划分。我们还需要进一步更新其中的一些方法。
- en: Creating MVC classes
  id: totrans-366
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 MVC 类
- en: In the previous section, we earmarked the methods of the old class `HutGame`
    into three broad categories. It is now time to say goodbye to this class. We will
    break it down and split its methods among the three new classes, `Model`, `View`,
    and `Controller`. Of course, you can give more descriptive names to the classes,
    but let's continue to call them by the aforementioned names.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们将旧类`HutGame`的方法分为三大类。现在是时候告别这个类了。我们将将其分解，并将它的方法分配给三个新的类，即`Model`、`View`和`Controller`。当然，你可以给这些类起更描述性的名字，但让我们继续使用上述名称。
- en: Observe the following UML-like representation that shows the classes in which
    these methods are parked. Only the important attributes are listed here.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 观察以下类似于UML的表示，它显示了这些方法所在的类。这里只列出了重要的属性。
- en: '![Creating MVC classes](img/B05034_10_26.jpg)'
  id: totrans-369
  prefs: []
  type: TYPE_IMG
  zh: '![创建MVC类](img/B05034_10_26.jpg)'
- en: Tip
  id: totrans-370
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: In [Chapter 1](ch01.html "Chapter 1. Developing Simple Applications"), *Developing
    Simple Applications*, we briefly talked about UML-like representation. One way
    to create such diagrams is to use [https://www.draw.io](https://www.draw.io).
    It is a free, online diagram software for making flowcharts, UML diagrams, and
    so on.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html "第1章. 开发简单应用程序")，*开发简单应用程序*中，我们简要地讨论了类似于UML的表示。创建此类图的一种方法是通过使用[https://www.draw.io](https://www.draw.io)。这是一个免费、在线的图表软件，用于制作流程图、UML图等。
- en: Now that we know how the classes are laid out, let's understand how these classes
    exchange information.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了类的布局，让我们了解这些类是如何交换信息的。
- en: Communication between MVC objects
  id: totrans-373
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MVC对象之间的通信
- en: 'Before diving into the details on how MVC objects communicate, let''s first
    list down a few important points about the MVC architecture:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入探讨MVC对象如何通信的细节之前，让我们首先列出关于MVC架构的一些重要观点：
- en: The controller knows about the model as well as the view
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制器不仅了解模型，还了解视图
- en: The model is unaware of the other two, namely the controller and the view
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型对其他两个（即控制器和视图）一无所知
- en: The view (just like the model) knows nothing about the controller and the model
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图（就像模型一样）对控制器和模型一无所知
- en: There could be some other variants of the MVC architecture. In this book, we
    will stick to the aforementioned points, and design a solution.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: MVC架构可能有其他一些变体。在这本书中，我们将坚持上述观点，并设计一个解决方案。
- en: Controller to Model or View communication
  id: totrans-379
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 控制器到模型或视图通信
- en: Let's begin the discussion by learning how a controller sends the information
    to either the model or the view.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从学习控制器如何将信息发送到模型或视图开始讨论。
- en: 'The `Controller` object can directly talk to the `Model` and `View` instances
    using `self.model` and `self.view` respectively. For example, it can just call
    a `View` method like so:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '`Controller`对象可以直接通过`self.model`和`self.view`分别与`Model`和`View`实例进行通信。例如，它可以这样调用一个`View`方法：'
- en: '[PRE29]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This is pretty straightforward. Now let's see how it receives the data from
    either the model or the view.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单。现在让我们看看它是如何从模型或视图接收数据的。
- en: Model to Controller communication
  id: totrans-384
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模型到控制器通信
- en: How does the controller receive information from the model? For example, in
    the hut game scenario, a winner is determined depending on who is inside the selected
    hut. Once the winner is determined, the `Model` class needs to communicate it
    to the `Controller` class. This is accomplished with the `model_change_handler()`
    method of the `Controller` class. It is invoked whenever the state of the `Model`
    class changes.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器是如何从模型接收信息的？例如，在棚屋游戏场景中，胜利者是根据谁在所选的棚屋内来确定的。一旦确定了胜利者，`Model`类就需要将其传达给`Controller`类。这是通过`Controller`类的`model_change_handler()`方法实现的。每当`Model`类的状态发生变化时，该方法就会被调用。
- en: '![Model to Controller communication](img/B05034_10_27.jpg)'
  id: totrans-386
  prefs: []
  type: TYPE_IMG
  zh: '![模型到控制器通信](img/B05034_10_27.jpg)'
- en: '| *Good question! The* `Model` *class knows nothing about* `Controller` *and*
    `View`*. Then how does* `Controller` *know that* `Model` *has changed? Let''s
    see that next.* |'
  id: totrans-387
  prefs: []
  type: TYPE_TB
  zh: '| *好问题！* `Model` *类对* `Controller` *和* `View` *一无所知。那么* `Controller` *是如何知道*
    `Model` *发生了变化的？让我们看看下一个问题。* |'
- en: The `Controller` class can receive information from the `Model` class in various
    ways. Let's briefly talk about two such approaches.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '`Controller`类可以通过多种方式从`Model`类接收信息。让我们简要地讨论两种这样的方法。'
- en: Using method assignment
  id: totrans-389
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用方法分配
- en: Recall that in Python, you can assign a method to a variable. The chapter on
    design patterns talked about the first-class objects in greater detail. The following
    line of code can be added to `Controller.__init__`.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在Python中，你可以将一个方法赋值给一个变量。设计模式章节详细讨论了第一类对象。以下行代码可以添加到`Controller.__init__`中。
- en: '[PRE30]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then, in the `Model` class, you could call `self.changed()`, like so:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`Model`类中，你可以调用`self.changed()`，如下所示：
- en: '[PRE31]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This automatically notifies `Controller` that the model has changed. While this
    is very convenient, we will instead use a publish-subscribe API which makes things
    even simpler.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 这会自动通知`Controller`模型已更改。虽然这非常方便，但我们将改用发布-订阅API，这使得事情更加简单。
- en: Using a publish-subscribe pattern
  id: totrans-395
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用发布-订阅模式
- en: 'Publish-subscribe is a messaging pattern. The publisher can be any program
    that broadcasts some data to a topic. There could be one or more applications
    that are listening to this topic. These are called the subscribers, who receive
    the published data. The publisher does not know (or does not need to know) anything
    about the subscribers. Similarly, a subscriber has no knowledge of the publisher.
    The following schematic gives a high-level overview of a publish-subscribe system:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 发布-订阅是一种消息模式。发布者可以是任何向一个主题广播一些数据的程序。可能有一个或多个应用程序正在监听这个主题。这些被称为订阅者，他们接收发布的数据。发布者不知道（或不需要知道）关于订阅者的任何信息。同样，订阅者对发布者也没有任何了解。以下示意图给出了发布-订阅系统的高级概述：
- en: '![Using a publish-subscribe pattern](img/B05034_10_28.jpg)'
  id: totrans-397
  prefs: []
  type: TYPE_IMG
  zh: '![使用发布-订阅模式](img/B05034_10_28.jpg)'
- en: The publish-subscribe concept can be better understood with a real-world analogy.
    Imagine an online retailer running a weekly flash sale. You have opted in to receive
    notifications in the form of SMS or e-mail alerts. There are several other customers
    who would also like to get notified about the sale.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 通过现实世界的类比可以更好地理解发布-订阅的概念。想象一个在线零售商每周进行闪购。你已经选择接收以短信或电子邮件警报形式的通知。还有几位其他客户也希望得到关于销售的通知。
- en: In a publish-subscribe world, the online retailer is a publisher who broadcasts
    the sale information (the data) to a topic, say *flash sale*. You and several
    other customers are the subscribers to this topic. Likewise, the online retailer
    can publish some other information as different topics, for instance, *Friday
    sale*, *Half price sale*, and so on. Each topic could have several subscribers.
    If you are not subscribed to *Friday sale* , you won't get any notifications sent
    to that topic.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在发布-订阅的世界里，在线零售商是一个发布者，将销售信息（数据）广播到主题，比如*闪购*。你和几位其他客户是这个主题的订阅者。同样，在线零售商可以以不同的主题发布其他信息，例如，*周五特卖*，*半价特卖*等等。每个主题可能有多个订阅者。如果你没有订阅*周五特卖*，你将不会收到发送到该主题的任何通知。
- en: PyPubSub package
  id: totrans-400
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: PyPubSub包
- en: 'How do we implement a publish-subscribe framework in Python? One option is
    to write the code from scratch. Instead, we will just use a Python package called
    `pypubsub`. It provides a publish-subscribe API that simplifies the design and
    improves code readability and testability. The package can be installed as follows:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何在Python中实现一个发布-订阅框架？一个选项是从头开始编写代码。相反，我们将只使用一个名为`pypubsub`的Python包。它提供了一个发布-订阅API，简化了设计并提高了代码的可读性和可测试性。该包可以按照以下方式安装：
- en: '[PRE32]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here is a simple example that shows a typical usage. In fact, this syntax is
    all we need in this chapter.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个简单的例子，展示了典型的用法。实际上，这个语法就是本章所需的所有内容。
- en: '![PyPubSub package](img/B05034_10_31.jpg)'
  id: totrans-404
  prefs: []
  type: TYPE_IMG
  zh: '![PyPubSub包](img/B05034_10_31.jpg)'
- en: 'When you run this script, it produces the following output:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这个脚本时，它会产生以下输出：
- en: '[PRE33]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The first argument to `pub.subscribe()` is the function you want to subscribe
    to a given topic. The topic name here is WINNER ANNOUNCMENT. The last line of
    the code shows how to broadcast a message to a specific topic using `pub.sendMessage()`.
    The first argument to `pub.sendMessage()` is the topic name. You can specify any
    number of optional arguments, just make sure that the subscriber function accepts
    all those arguments! In this example, it sends data as the only optional argument.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '`pub.subscribe()`的第一个参数是你想要订阅的特定主题的函数。这里的主题名是WINNER ANNOUNCMENT。代码的最后一行显示了如何使用`pub.sendMessage()`向特定主题广播消息。`pub.sendMessage()`的第一个参数是主题名。你可以指定任意数量的可选参数，只需确保订阅者函数接受所有这些参数！在这个例子中，它只发送数据作为唯一的可选参数。'
- en: Tip
  id: totrans-408
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'For more information on the PyPubSub package, see the project home page: [http://pubsub.sourceforge.net/](http://pubsub.sourceforge.net/)'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于PyPubSub包的信息，请参阅项目主页：[http://pubsub.sourceforge.net/](http://pubsub.sourceforge.net/)
- en: 'PyDispatcher is an alternative to the PyPubSub package. While we won''t be
    using it, here is a link to the project: [https://pypi.python.org/pypi/PyDispatcher](https://pypi.python.org/pypi/PyDispatcher)'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: PyDispatcher是PyPubSub包的替代品。虽然我们不会使用它，但这里有一个项目的链接：[https://pypi.python.org/pypi/PyDispatcher](https://pypi.python.org/pypi/PyDispatcher)
- en: View to Controller communication
  id: totrans-411
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`View`到`Controller`的通信'
- en: Just like `Model`, there is no direct communication link from the `View` object
    to the `Controller` object. When the user presses a radio button, the controller
    needs to be notified. We can employ similar approaches, as discussed in the previous
    section. For example, you can assign a method of `Controller` to a `View` method.
    Alternatively, you can use the publish-subscribe API to talk to the `Controller`
    object.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`Model`一样，`View`对象到`Controller`对象之间没有直接的通信链接。当用户按下单选按钮时，控制器需要被通知。我们可以采用类似前一个章节中讨论的方法。例如，你可以将`Controller`的一个方法分配给`View`方法。或者，你可以使用发布-订阅API与`Controller`对象通信。
- en: Communication between View and Model
  id: totrans-413
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`View`和`Model`之间的通信'
- en: 'Let''s discuss how `View` and `Model` talk to each other:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一下`View`和`Model`是如何相互交流的：
- en: When the user presses a radio button, `View` communicates with `Controller`
    using one of the approaches discussed earlier
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户按下单选按钮时，`View`使用之前讨论过的一种方法与`Controller`通信
- en: The `Controller` object then talks to `Model` instructing it to update
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后`Controller`对象与`Model`通信，指示其更新
- en: The state of `Model` is updated, and the results are communicated back to `Controller`
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Model`的状态被更新，并将结果反馈给`Controller`'
- en: '`Controller` asks `View` to update the display'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Controller`要求`View`更新显示'
- en: Note
  id: totrans-419
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**View and Model communication using a publish-subscribe API**:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用发布-订阅API进行`View`和`Model`通信**：'
- en: You could potentially use the publish-subscribe framework to establish a communication
    channel between the `Model` and the `View` object. Note that this still keeps
    the basic rules intact. `Model` does not know anything about the `View` object.
    It just publishes the data to a given topic. `View` doesn't have any knowledge
    of the `Model` object. It is just registered as a subscriber to the same topic
    where `Model` is broadcasting the data. Thus, whenever there is a change of state
    in `Model`, `View` could get a notification through the publish-subscribe API.
    Likewise for the communication from `View` to `Model`. The potential flip-side
    is that these publish-subscribe signals are essentially global variables, and
    could bring in the painful issues associated with them. So use it with caution!
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用发布-订阅框架在`Model`和`View`对象之间建立通信通道。请注意，这仍然保持了基本规则。`Model`对`View`对象一无所知。它只是将数据发布到指定的主题。`View`对`Model`对象也没有任何了解。它只是注册为订阅者，订阅`Model`广播数据的同一主题。因此，每当`Model`的状态发生变化时，`View`可以通过发布-订阅API获得通知。同样，对于从`View`到`Model`的通信也是如此。潜在的负面影响是，这些发布-订阅信号本质上是全球变量，可能会带来与之相关的痛苦问题。所以请谨慎使用！
- en: For this project however, we will stick to the classical approach, where the
    communication happens through `Controller`.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于这个项目，我们将坚持使用经典方法，其中通信是通过`Controller`发生的。
- en: Reviewing the code
  id: totrans-423
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看代码
- en: So far, you have got a high-level overview of the new classes and how they communicate
    with each other. In the first project, we already reviewed most of the methods
    listed under each new class. That said, to implement the MVC architecture we need
    to make a few changes. Let's review only a few important methods from the file
    `hutgame_mvc.py`. Note that all the classes have been put in the same file. As
    an exercise, split the individual classes in their own module!
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经得到了关于新类及其相互通信方式的高级概述。在第一个项目中，我们已经审查了每个新类下列出的大多数方法。话虽如此，为了实现MVC架构，我们需要做一些修改。让我们仅从文件`hutgame_mvc.py`中回顾几个重要的方法。请注意，所有类都放在了同一个文件中。作为一个练习，将单独的类放入它们自己的模块中！
- en: Tip
  id: totrans-425
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: As we won't be reviewing each and every line of the code, you should download
    the file `hutgame_mvc.py` and also the two images, `Hut_small.gif` and `Jungle_small.gif`
    from the code bundle for this chapter. Keep the source file handy while reading
    the upcoming discussion. Quite often, it is useful to skim through the full code
    for better understanding!
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不会逐行审查代码，您应该下载本章代码包中的文件 `hutgame_mvc.py` 以及两张图片，`Hut_small.gif` 和 `Jungle_small.gif`。在阅读即将到来的讨论时，请保留源文件。通常，快速浏览完整代码有助于更好地理解！
- en: The main execution code is shown next. It is almost identical to the one we
    saw in the first project. The only difference is `game_app` (shown highlighted).
    It is now an instance of the `Controller` class instead of `HutGame`. In fact,
    there is no `HutGame` class for this project! Recall that we broke it down, creating
    three new classes.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 主要执行代码如下。它与我们在第一个项目中看到的是几乎相同的。唯一的区别是 `game_app`（已突出显示）。现在它是一个 `Controller` 类的实例，而不是
    `HutGame`。实际上，本项目没有 `HutGame` 类！回想一下，我们将其分解，创建了三个新的类。
- en: '![Reviewing the code](img/B05034_10_29.jpg)'
  id: totrans-428
  prefs: []
  type: TYPE_IMG
  zh: '![Reviewing the code](img/B05034_10_29.jpg)'
- en: The Controller class
  id: totrans-429
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 控制器类
- en: 'The `Controller` class is quite small, as shown next:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示，`Controller` 类相当小：
- en: '![The Controller class](img/B05034_10_30.jpg)'
  id: totrans-431
  prefs: []
  type: TYPE_IMG
  zh: '![The Controller class](img/B05034_10_30.jpg)'
- en: Let's talk through the code. You can skip reading these bullets if you have
    already understood it!
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析一下代码。如果您已经理解了它，可以跳过阅读这些要点！
- en: The `Controller` class is composed of `Model` and `View` instances. This allows
    it to directly call the functionality from these classes.
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Controller` 类由 `Model` 和 `View` 实例组成。这使得它可以直接调用这些类的功能。'
- en: The `self.view.set_callbacks()` function essentially assigns the `radio_btn_pressed`
    method to an appropriate attribute of `View`. What this simply means is that whenever
    the user presses a radio button, this method is invoked. See the section *View
    to Controller communication* for more details.
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.view.set_callbacks()` 函数本质上是将 `radio_btn_pressed` 方法分配给 `View` 的一个适当属性。简单来说，这意味着每当用户按下单选按钮时，就会调用此方法。请参阅
    *视图到控制器通信* 部分，以获取更多详细信息。'
- en: The `Controller` class receives data from the `Model` instance by subscribing
    to the topic, `"WINNER ANNOUNCEMENT"`. We have already seen an example of the
    `pub.subscribe()` function. Simply put, the method `model_change_handler` is called
    whenever the winner is announced.
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Controller` 类通过订阅主题 `"WINNER ANNOUNCEMENT"` 从 `Model` 实例接收数据。我们已经看到了 `pub.subscribe()`
    函数的一个例子。简单来说，每当宣布赢家时，就会调用 `model_change_handler` 方法。'
- en: The method `model_change_handler` calls the appropriate `View` method to display
    a message that announces the winner.
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`model_change_handler` 方法调用适当的 `View` 方法来显示宣布赢家信息的消息。'
- en: The Model class
  id: totrans-437
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模型类
- en: There aren't many changes in the `Model` class. The only significant change
    is the highlighted line of the given code (the call to `pub.sendMessage`) in the
    `enter_hut` method. The details of the other methods are not shown. These methods
    are shown with their code collapsed in the editor.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '`Model` 类中没有太多变化。唯一的重大变化是给定代码中突出显示的行（`enter_hut` 方法中的 `pub.sendMessage` 调用）。其他方法的细节没有显示。这些方法在编辑器中以代码折叠的形式显示。'
- en: '![The Model class](img/B05034_10_32.jpg)'
  id: totrans-439
  prefs: []
  type: TYPE_IMG
  zh: '![The Model class](img/B05034_10_32.jpg)'
- en: Compare this method against the one we wrote in the first project. Notice that
    it does not call `View.announce_winner` directly. Instead, it notifies the `Controller`
    instance using the `pub.sendMessage()`. The rest of the code remains unchanged,
    and you can have a look at the `hutgame_mvc.py` file for further details.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 将此方法与我们第一个项目中编写的代码进行比较。请注意，它没有直接调用 `View.announce_winner`。相反，它使用 `pub.sendMessage()`
    通知 `Controller` 实例。其余代码保持不变，您可以查看 `hutgame_mvc.py` 文件以获取更多详细信息。
- en: Tip
  id: totrans-441
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: As noted in the section *Communication between View and Model*, you could potentially
    use the same publish-subscribe framework to notify the `Model` state changes to
    the `View` and vice versa.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 如 *视图与模型之间的通信* 部分所述，您可以使用相同的发布-订阅框架来通知 `Model` 的状态变化给 `View`，反之亦然。
- en: Note
  id: totrans-443
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Object-relational mapper (ORM)**:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '**对象关系映射器 (ORM)**:'
- en: Simply put, it is a library that enables you to use an object-oriented language
    like Python to access and update the data sitting in a database. In Python, DJango
    ORM and SQLAlchemy are among the popular ORM libraries. You can do a web search
    on these libraries to find useful resources.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，这是一个库，它使您能够使用像 Python 这样的面向对象语言来访问和更新数据库中的数据。在 Python 中，Django ORM 和 SQLAlchemy
    是流行的 ORM 库之一。您可以在网上搜索这些库以找到有用的资源。
- en: 'Model classes and ORMs: This book does not cover anything related to web or
    database application programming, but it is worth mentioning the following. It
    is quite common for the `Model` classes to inherit from the ORMs, and represent
    database tables where each object is a row in the table. Writing unit tests for
    such systems could be a challenge, as you typically don''t want to actually hit
    the database every time these tests run. In [Chapter 5](ch05.html "Chapter 5. Unit
    Testing and Refactoring"), *Unit Testing and Refactoring* we saw how to use Python''s
    mock library. Quite often, mock is useful for unit testing such systems (it is
    not covered in this book).'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 模型类和ORM：本书不涵盖与Web或数据库应用程序编程相关的任何内容，但值得提及的是，`Model`类通常继承自ORM，并代表数据库表，其中每个对象都是表中的一行。为这样的系统编写单元测试可能是一个挑战，因为你通常不希望在每次运行这些测试时实际击中数据库。在第5章中，我们看到了如何使用Python的mock库。mock通常对单元测试这样的系统很有用（本书未涵盖）。
- en: The View class
  id: totrans-447
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视图类
- en: The `View` class is illustrated next. The only significant change is the method
    by the name `set_callbacks`. The other methods are shown with their code collapsed.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了`View`类。唯一显著的变化是名为`set_callbacks`的方法。其他方法以代码折叠的形式展示。
- en: '![The View class](img/B05034_10_33.jpg)'
  id: totrans-449
  prefs: []
  type: TYPE_IMG
  zh: '![The View class](img/B05034_10_33.jpg)'
- en: 'Recall that in the `Controller.__init__` method, we have the following code:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在`Controller.__init__`方法中，我们有以下代码：
- en: '[PRE34]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The preceding code states that the `radio_btn_pressed` attribute of the `View`
    class represents the method `radio_btn_pressed()` of the `Controller` class. The
    rest of the code is identical to the one seen in the first project.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码表明，`View`类的`radio_btn_pressed`属性代表`Controller`类的`radio_btn_pressed()`方法。其余的代码与第一个项目中的代码相同。
- en: Running the application
  id: totrans-453
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行应用程序
- en: 'In this project, we did not add any new features to the GUI. The idea was to
    just show a rudimentary example on implementing the MVC architecture. You can
    run this application as follows:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们没有向GUI添加任何新功能。我们的想法只是展示一个实现MVC架构的初步示例。你可以按照以下步骤运行此应用程序：
- en: '[PRE35]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This should show the same GUI window and features as in the first project.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会显示与第一个项目相同的GUI窗口和功能。
- en: Testing GUI applications
  id: totrans-457
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试图形用户界面应用程序
- en: In a complex and feature-rich GUI application, the user is presented with many
    choices of widgets, menus, keyboard shortcuts, and so on. As seen earlier in the
    chapter, the event-driven nature of GUI programs lets the user dictate the program
    flow. This often presents many possible ways for the user to perform certain operations
    to arrive at the desired output.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个复杂且功能丰富的图形用户界面应用程序中，用户会看到许多小部件、菜单、键盘快捷键等选择。如本章前面所述，GUI程序的事件驱动特性让用户可以决定程序流程。这通常为用户提供了许多执行特定操作以获得所需输出的可能方式。
- en: Tip
  id: totrans-459
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'It should be noted that we are not going to write any code here. This is just
    a high-level discussion that touches upon a few important testing considerations.
    For further learning on this topic, start with the following wiki page: [https://en.wikipedia.org/wiki/Graphical_user_interface_testing](https://en.wikipedia.org/wiki/Graphical_user_interface_testing).'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，我们在这里不会编写任何代码。这只是一个高级讨论，涉及到一些重要的测试考虑因素。关于这个主题的进一步学习，请从以下维基页面开始：[https://en.wikipedia.org/wiki/Graphical_user_interface_testing](https://en.wikipedia.org/wiki/Graphical_user_interface_testing)。
- en: Imagine a GUI application that allows selecting some object in the application
    window, for example, a folder icon on the desktop. The user can hover the mouse
    over the icon to highlight that object, and then click on it to select it. Alternatively,
    he can do a window selection, where a selection window is drawn around the object
    to select it. Yet another alternative could be using a combination of keys on
    the keyboard. While the user is happy that he can accomplish the task in different
    ways, it becomes a challenge for the developer to write a bug-free code.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个图形用户界面应用程序，它允许在应用程序窗口中选择某个对象，例如，桌面上的文件夹图标。用户可以将鼠标悬停在图标上以突出显示该对象，然后点击它以选择它。或者，他可以进行窗口选择，在对象周围绘制选择窗口以选择它。另一种选择可能是使用键盘上的组合键。虽然用户很高兴能够以不同的方式完成任务，但这对于开发者来说编写无错误的代码却是一个挑战。
- en: The nature of event-driven programming makes it difficult to write a robust
    code and comprehensive tests to account for the majority of the user input scenarios.
    The bugs would creep in one way or the other. Of course, this varies depending
    on the application and testing strategy, but it is typically a problem for large
    and complex GUI applications.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 事件驱动编程的本质使得编写健壮的代码和全面的测试来应对大多数用户输入场景变得困难。错误可能会以某种方式悄悄出现。当然，这取决于应用程序和测试策略，但通常是大型和复杂GUI应用程序的一个问题。
- en: Testing considerations
  id: totrans-463
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试考虑因素
- en: There are various testing strategies to make the GUI application code more robust.
    Let's touch upon a few important testing considerations.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种测试策略可以使GUI应用程序代码更加健壮。让我们探讨一些重要的测试考虑因素。
- en: Unit testing and MVC
  id: totrans-465
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单元测试和MVC
- en: A unit test helps you test an individual chunk of the code. An integration test
    is where you have many unit tests grouped together to test a larger functionality.
    In a regression test, you typically have a combination of unit and integration
    tests. Here, the tests are rerun to ensure that nothing is broken. A good regression
    test framework is crucial as the first line of defense against the bugs. Unit
    testing generally helps in addressing some common problems. In an earlier chapter,
    we already covered this topic with examples from a command-line application.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试可以帮助你测试代码的某个部分。集成测试是指将多个单元测试组合在一起以测试更大的功能。在回归测试中，你通常会有单元和集成测试的组合。在这里，测试会重新运行以确保没有东西被破坏。一个好的回归测试框架对于作为防止错误的防线至关重要。单元测试通常有助于解决一些常见问题。在早期章节中，我们已经通过命令行应用程序的示例介绍了这个主题。
- en: The MVC architecture of the GUI program further helps in making the code robust.
    The separation of concerns or breaking down of the code into the model, view,
    and controller components allows us to write unit tests for particular types of
    error. For example, in some applications, you may anticipate `ZeroDivisionError`
    in the `Model` class instead of the `View` class. So you could write focused unit
    tests for the `Model` class to gracefully handle such situations.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: GUI程序的MVC架构进一步有助于使代码更加健壮。关注点的分离或代码分解为模型、视图和控制组件，使我们能够为特定类型的错误编写单元测试。例如，在某些应用程序中，你可能会在`Model`类而不是`View`类中预测到`ZeroDivisionError`。因此，你可以为`Model`类编写专注于这种情况的单元测试，以便优雅地处理此类情况。
- en: Manual testing
  id: totrans-468
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 手动测试
- en: While having a good regression test suite helps with the common issues, the
    event-driven nature of the program often presents scenarios that are not accounted
    for. In manual testing, the software tester manually checks the working of the
    application by playing with different features provided in the GUI. If something
    is not working as expected, the tester creates a bug report to document the instructions
    to reproduce the problem. Many hidden bugs surface in the manual testing phase.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然一个好的回归测试套件有助于解决常见问题，但程序的事件驱动特性经常提出未被考虑的场景。在手动测试中，软件测试人员通过操作GUI中提供的不同功能来手动检查应用程序的工作情况。如果某些功能不符合预期，测试人员会创建一个错误报告来记录重现问题的说明。许多隐藏的错误在手动测试阶段出现。
- en: With the growing complexity of the program, the repetitive manual testing job
    becomes overwhelming for the testers. This is where automated GUI testing comes
    to the rescue.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 随着程序复杂性的增加，重复的手动测试工作对测试人员来说变得令人难以承受。这就是自动化GUI测试发挥作用的地方。
- en: Automated GUI testing
  id: totrans-471
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动化GUI测试
- en: Here, the testing tool records the user actions to create tests. If you run
    such a test, the user actions are repeated automatically in the same sequence.
    This allows quick identification of the broken functionality.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，测试工具记录用户操作以创建测试。如果你运行此类测试，用户操作会自动以相同的顺序重复。这允许快速识别损坏的功能。
- en: Tip
  id: totrans-473
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Automated testing should not replace manual testing. Unless the tool has artificial
    intelligence built into it, you still need someone to test the new features, and
    use the existing ones in ways not tried before. In general, automated testing
    should complement the manual GUI testing activity.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化测试不应取代手动测试。除非工具中集成了人工智能，否则你仍然需要有人来测试新功能，并以之前未尝试过的方式使用现有功能。通常，自动化测试应补充手动GUI测试活动。
- en: There are several open source and commercial tools available for automated GUI
    testing in Python. The following table summarizes a few prominent, freely available
    tools for GUI test automation. For a comprehensive list, see the Python wiki page
    at [https://wiki.python.org/moin/PythonTestingToolsTaxonomy](https://wiki.python.org/moin/PythonTestingToolsTaxonomy).
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，有几种开源和商业工具可用于自动 GUI 测试。以下表格总结了几个突出的、免费可用的 GUI 自动化测试工具。要获取完整列表，请参阅
    Python 维基页面 [https://wiki.python.org/moin/PythonTestingToolsTaxonomy](https://wiki.python.org/moin/PythonTestingToolsTaxonomy)。
- en: '| Tool name and link | Notes |'
  id: totrans-476
  prefs: []
  type: TYPE_TB
  zh: '| 工具名称和链接 | 备注 |'
- en: '| --- | --- |'
  id: totrans-477
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Sikuli (SikuliX) [http://www.sikuli.org/](http://www.sikuli.org/) | Supported
    on Windows, Mac, and some Linux OS. Visit the website to check if your OS is supported.
    |'
  id: totrans-478
  prefs: []
  type: TYPE_TB
  zh: '| Sikuli (SikuliX) [http://www.sikuli.org/](http://www.sikuli.org/) | 支持Windows、Mac和一些Linux操作系统。访问网站以检查您的操作系统是否受支持。
    |'
- en: '| StoryText [https://pypi.python.org/pypi/StoryText](https://pypi.python.org/pypi/StoryText)
    | Supported GUI frameworks include Tkinter, PyGTK, wxPython, and others. See the
    website for the complete list. |'
  id: totrans-479
  prefs: []
  type: TYPE_TB
  zh: '| StoryText [https://pypi.python.org/pypi/StoryText](https://pypi.python.org/pypi/StoryText)
    | 支持的 GUI 框架包括 Tkinter、PyGTK、wxPython 等。请访问网站以获取完整列表。 |'
- en: '| Dogtail [https://fedorahosted.org/dogtail/](https://fedorahosted.org/dogtail/)
    | Intended for Linux OS like Fedora. Check if it is compatible with your OS. |'
  id: totrans-480
  prefs: []
  type: TYPE_TB
  zh: '| Dogtail [https://fedorahosted.org/dogtail/](https://fedorahosted.org/dogtail/)
    | 旨在用于类似 Fedora 的 Linux 操作系统。检查它是否与您的操作系统兼容。 |'
- en: One of the frailties of such automated testing systems is that the innocent-looking
    GUI changes may require you to change a lot of tests, and depending on the complexity
    of your GUI application, this could be a hassle.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 这种自动化测试系统的弱点之一是，看似无辜的 GUI 变化可能需要您更改大量测试，并且根据您的 GUI 应用程序的复杂性，这可能会很麻烦。
- en: Exercises
  id: totrans-482
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Here is a list of a few things you could do to further improve the GUI application.
    With one exception, the solutions are not provided for these exercises.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些您可以进一步改进 GUI 应用程序的方法。除了一个例外，这些练习的解决方案没有提供。
- en: Put the `Model`, `View` and, `Controller` classes in their own modules!
  id: totrans-484
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Model`、`View` 和 `Controller` 类放入它们自己的模块中！
- en: Use the publish-subscribe API for communication from `View` to `Controller`.
    You can refer to the file `hutgame_mvc_pubsub.py` for a solution.
  id: totrans-485
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用发布-订阅 API 从 `View` 到 `Controller` 进行通信。您可以参考文件 `hutgame_mvc_pubsub.py` 以获取解决方案。
- en: 'Add more widgets such as a menu bar and buttons. Implement the **Restart Game**
    button. When clicked, the game should restart. Do the following when this button
    is clicked:'
  id: totrans-486
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加更多小部件，如菜单栏和按钮。实现**重新启动游戏**按钮。当点击时，游戏应该重新启动。当此按钮被点击时，执行以下操作：
- en: Randomly distribute the occupants again by calling `occupy_huts()`.
  id: totrans-487
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过调用 `occupy_huts()` 再次随机分配居民。
- en: Clear the state of the radio buttons. All the buttons should be deselected.
  id: totrans-488
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清除单选按钮的状态。所有按钮都应该被取消选中。
- en: Add exception handling to the application.
  id: totrans-489
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向应用程序添加异常处理。
- en: Try to generalize the `View.add_callbacks` method so that it can be used to
    set more callback functions.
  id: totrans-490
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试将 `View.add_callbacks` 方法泛化，使其能够用于设置更多的回调函数。
- en: Further reading
  id: totrans-491
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'This book has touched upon several important aspects of application development.
    The key concepts were taught primarily by developing command-line applications.
    As noted earlier in the chapter, there are many applications that require you
    to learn domain-specific techniques. For example, in this chapter, we learned
    about the MVC architecture commonly implemented in GUI applications. Let''s conclude
    this chapter, and hence the book, with a brief discussion on some of the important
    application domains. This will just give you some useful pointers (with lots of
    links!) to the relevant libraries or application frameworks. To avoid clutter,
    the URLs with further information are provided separately at the end of this section.
    The following is a list of other important application domains; however, this
    is far from being an exhaustive list:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 本书已涉及应用程序开发的几个重要方面。关键概念主要通过开发命令行应用程序来教授。如本章前面所述，有许多应用程序需要您学习特定领域的技巧。例如，在本章中，我们学习了在
    GUI 应用程序中常见实现的 MVC 架构。让我们通过简要讨论一些重要的应用程序领域来结束本章，以及本书。这将为您提供一些有用的指针（附带大量链接！）到相关的库或应用程序框架。为了避免混乱，有关更多信息的相关网址将单独提供在本节末尾。以下是一个其他重要应用程序领域的列表；然而，这远非一个详尽的列表：
- en: 'Web and mobile application development:'
  id: totrans-493
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 网页和移动应用程序开发：
- en: These are important application development domains. To learn Python Web application
    development, you can start exploring the Flask or DJango frameworks in Python.
    Knowledge of MVC will also help you here. For mobile application development,
    the kivy library is probably a good start.
  id: totrans-494
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些是重要的应用开发领域。要学习 Python 网络应用程序开发，你可以从探索 Python 中的 Flask 或 Django 框架开始。了解 MVC
    也会有所帮助。对于移动应用程序开发，kivy 库可能是一个好的起点。
- en: 'Applications involving databases:'
  id: totrans-495
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 涉及数据库的应用程序：
- en: A **database management system** (**DBMS**) is another important application
    domain. In a nutshell, DBMS provides you a way to create, access, and manage your
    data. Python has several libraries that enable talking to a database.
  id: totrans-496
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**数据库管理系统**（**DBMS**）是另一个重要的应用领域。简而言之，DBMS 提供了一种创建、访问和管理数据的方式。Python 有几个库可以让你与数据库进行通信。'
- en: SQLite3 is a simple, light-weight relational database system. The module sqlite3
    is a built-in Python module that provides a DB-API 2.0 compliant SQL interface.
    There are several client libraries written in Python that provide a way to talk
    to a database. For example, the PyMongo module provides tools to work with MongoDB,
    and so on.
  id: totrans-497
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: SQLite3 是一个简单、轻量级的数据库系统。sqlite3 模块是 Python 的内置模块，它提供了一个符合 DB-API 2.0 的 SQL 接口。有几个用
    Python 编写的客户端库提供了与数据库通信的方式。例如，PyMongo 模块提供了与 MongoDB 一起工作的工具，等等。
- en: 'Machine and deep learning:'
  id: totrans-498
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 机器学习和深度学习：
- en: In the data science domain, the use of machine learning and deep learning libraries
    is growing rapidly. The knowledge of GPU programming would help here.
  id: totrans-499
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在数据科学领域，机器学习和深度学习库的使用正在迅速增长。了解 GPU 编程知识在这里会有所帮助。
- en: Tip
  id: totrans-500
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Data science applications almost always involve visualizing some data. It is
    very convenient to use IPython or Jupyter notebooks to write and share interactive
    data science applications. See [http://jupyter.org/](http://jupyter.org/)for more
    details.
  id: totrans-501
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 数据科学应用程序几乎总是涉及数据的可视化。使用 IPython 或 Jupyter 笔记本编写和共享交互式数据科学应用程序非常方便。有关更多详细信息，请参阅[http://jupyter.org/](http://jupyter.org/)。
- en: For machine learning, you can explore Apache Spark. This is a general-purpose
    cluster computing system that provides high-level APIs in Python and other languages.
    MLlib is Apache Spark's scalable machine learning library. For deep-learning applications,
    Caffe and Tensorflow are among the popular deep-learning frameworks.
  id: totrans-502
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于机器学习，你可以探索 Apache Spark。这是一个通用集群计算系统，它为 Python 和其他语言提供了高级 API。MLlib 是 Apache
    Spark 的可扩展机器学习库。对于深度学习应用，Caffe 和 Tensorflow 是流行的深度学习框架之一。
- en: 'Internet of Things:'
  id: totrans-503
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 物联网：
- en: This is is yet another rapidly emerging field where Python is one of the favored
    languages for developing applications. Here you could use Python to not only process
    data (Analytics applications) on the server side but also have a Python client
    running on the end device. You can find use of the publish-subscribe messaging
    pattern in such applications, where the device publishes data to a topic, and
    the server side application is a subscriber that receives this data.
  id: totrans-504
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是一个快速发展的领域，Python 是开发应用程序时最受欢迎的语言之一。在这里，你可以使用 Python 不仅在服务器端处理数据（分析应用程序），还可以在终端设备上运行
    Python 客户端。在这些应用程序中，你可以找到使用发布-订阅消息模式的例子，其中设备将数据发布到主题，而服务器端应用程序是一个接收这些数据的订阅者。
- en: 'Multimedia and game applications:'
  id: totrans-505
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 多媒体和游戏应用程序：
- en: 'This is broad topic, and there are several frameworks and libraries available
    for developing multimedia applications:'
  id: totrans-506
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是一个广泛的话题，有几个框架和库可用于开发多媒体应用程序：
- en: Python wiki documents many tools that deal with audio and video processing.
    **GStreamer**, **MoviePy**, and **MLT** are among the popular frameworks. See
    also the PyMedia module.
  id: totrans-507
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 维基文档了许多处理音频和视频的工具。**GStreamer**、**MoviePy** 和 **MLT** 是流行的框架之一。还可以查看
    PyMedia 模块。
- en: There are quite a few options for image processing. Check out scikit-image,
    Opencv, and pillow (a fork of Python Imaging Library or PIL).
  id: totrans-508
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像处理有很多选项。查看 scikit-image、Opencv 和 pillow（Python Imaging Library 或 PIL 的分支）。
- en: There are many libraries useful for developing game- and animation-related applications.
    Check out PyGame and Pyglet. Again, you can find a comprehensive list on the Python
    wiki page.
  id: totrans-509
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有很多库对开发游戏和动画相关应用程序很有用。查看 PyGame 和 Pyglet。再次提醒，你可以在 Python 维基页面上找到完整的列表。
- en: The following table lists a few useful web links that provide more information
    on various tools or domains discussed earlier.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 下表列出了一些有用的网络链接，提供了有关先前讨论的各种工具或领域的更多信息。
- en: Tip
  id: totrans-511
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: At the time of writing this book, all the web links (URLs) presented throughout
    the book are accessible. As noted in [Chapter 1](ch01.html "Chapter 1. Developing
    Simple Applications"), *Developing Simple Applications*, these links might end
    up being broken over time. If that ever happens, do a web search with the appropriate
    search terms. For example, if you find the link to the PyMongo module broken,
    you can Google search PyMongo Python MongoDB to find some useful resources!
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，书中所有提供的网页链接（URL）都是可访问的。正如 [第 1 章](ch01.html "第 1 章。开发简单应用程序") 中所述，*开发简单应用程序*，这些链接可能会随着时间的推移而失效。如果发生这种情况，请使用适当的搜索词进行网络搜索。例如，如果你发现
    PyMongo 模块的链接已损坏，你可以通过 Google 搜索 PyMongo Python MongoDB 来找到一些有用的资源！
- en: '| Tool or application domain | Web link for further information |'
  id: totrans-513
  prefs: []
  type: TYPE_TB
  zh: '| 工具或应用程序领域 | 进一步信息的网页链接 |'
- en: '| --- | --- |'
  id: totrans-514
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Flask | [http://flask.pocoo.org](http://flask.pocoo.org) |'
  id: totrans-515
  prefs: []
  type: TYPE_TB
  zh: '| Flask | [http://flask.pocoo.org](http://flask.pocoo.org) |'
- en: '| Django | [https://www.djangoproject.com](https://www.djangoproject.com) |'
  id: totrans-516
  prefs: []
  type: TYPE_TB
  zh: '| Django | [https://www.djangoproject.com](https://www.djangoproject.com) |'
- en: '| Kivy | [https://kivy.org](https://kivy.org) |'
  id: totrans-517
  prefs: []
  type: TYPE_TB
  zh: '| Kivy | [https://kivy.org](https://kivy.org) |'
- en: '| sqlite3 | [https://docs.python.org/3/library/sqlite3.html](https://docs.python.org/3/library/sqlite3.html)
    |'
  id: totrans-518
  prefs: []
  type: TYPE_TB
  zh: '| sqlite3 | [https://docs.python.org/3/library/sqlite3.html](https://docs.python.org/3/library/sqlite3.html)
    |'
- en: '| PyMongo | [https://api.mongodb.com/python/current/](https://api.mongodb.com/python/current/)
    |'
  id: totrans-519
  prefs: []
  type: TYPE_TB
  zh: '| PyMongo | [https://api.mongodb.com/python/current/](https://api.mongodb.com/python/current/)
    |'
- en: '| Jupyter notebook | [http://jupyter.org/](http://jupyter.org/) |'
  id: totrans-520
  prefs: []
  type: TYPE_TB
  zh: '| Jupyter 笔记本 | [http://jupyter.org/](http://jupyter.org/) |'
- en: '| Apache Spark | [https://spark.apache.org](https://spark.apache.org) |'
  id: totrans-521
  prefs: []
  type: TYPE_TB
  zh: '| Apache Spark | [https://spark.apache.org](https://spark.apache.org) |'
- en: '| Caffe framework | [http://caffe.berkeleyvision.org](http://caffe.berkeleyvision.org)
    |'
  id: totrans-522
  prefs: []
  type: TYPE_TB
  zh: '| Caffe 框架 | [http://caffe.berkeleyvision.org](http://caffe.berkeleyvision.org)
    |'
- en: '| Tensorflow | [https://www.tensorflow.org/](https://www.tensorflow.org/) |'
  id: totrans-523
  prefs: []
  type: TYPE_TB
  zh: '| Tensorflow | [https://www.tensorflow.org/](https://www.tensorflow.org/) |'
- en: '| **Internet of Things** (**IoT**) | [https://en.wikipedia.org/wiki/Internet_of_things](https://en.wikipedia.org/wiki/Internet_of_things)
    |'
  id: totrans-524
  prefs: []
  type: TYPE_TB
  zh: '| **物联网** (**IoT**) | [https://en.wikipedia.org/wiki/Internet_of_things](https://en.wikipedia.org/wiki/Internet_of_things)
    |'
- en: '| Audio, video processing | [https://wiki.python.org/moin/AudioVideo](https://wiki.python.org/moin/AudioVideo)
    |'
  id: totrans-525
  prefs: []
  type: TYPE_TB
  zh: '| 音频、视频处理 | [https://wiki.python.org/moin/AudioVideo](https://wiki.python.org/moin/AudioVideo)
    |'
- en: '| Game and animations | [https://wiki.python.org/moin/PythonGameLibraries](https://wiki.python.org/moin/PythonGameLibraries)
    |'
  id: totrans-526
  prefs: []
  type: TYPE_TB
  zh: '| 游戏和动画 | [https://wiki.python.org/moin/PythonGameLibraries](https://wiki.python.org/moin/PythonGameLibraries)
    |'
- en: Summary
  id: totrans-527
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter served as an introduction to the Python GUI programming. Starting
    with an overview of the different GUI frameworks, it touched upon some important
    practical design considerations for developing user interfaces. You saw what event-driven
    programming is, and learned about events and event handling. With a quick introduction
    to Tkinter library, we developed a simple Hut Game, an equivalent GUI version
    of the first ever application developed in [Chapter 1](ch01.html "Chapter 1. Developing
    Simple Applications"), *Developing Simple Applications*.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 本章作为 Python GUI 编程的入门介绍。从不同 GUI 框架的概述开始，讨论了开发用户界面的一些重要实际设计考虑因素。你了解了事件驱动编程是什么，以及事件和事件处理。通过快速介绍
    Tkinter 库，我们开发了简单的 Hut 游戏，这是 [第 1 章](ch01.html "第 1 章。开发简单应用程序") 中第一个应用程序的 GUI
    版本，*开发简单应用程序*。
- en: The second half of the chapter introduced you to the MVC architecture, and we
    transformed the Hut Game to implement this architecture. The chapter concluded
    with a high-level discussion on testing GUI applications.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的后半部分介绍了 MVC 架构，并将 Hut 游戏转换为实现此架构。本章以对 GUI 应用程序测试的高级讨论结束。
- en: '![Summary](img/B05034_10_34.jpg)'
  id: totrans-530
  prefs: []
  type: TYPE_IMG
  zh: '![摘要](img/B05034_10_34.jpg)'
