- en: Chapter 10. Simple GUI Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the chapters so far were about learning to write better application code
    in Python. Starting with a simple program, we saw how to develop robust and efficient
    applications. We touched upon several important areas of software development.
    More specifically, we covered exception handling, deploying applications, documentation,
    adopting best practices, unit testing, refactoring, design patterns, and performance
    improvements. The key concepts were explained using various command-line applications
    that were progressively improved.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Where do we go from here? Beyond the command line, there are applications that
    present an interactive user interface. Desktop, mobile GUI applications, or web
    applications come under this category. Also, there are applications targeted for
    specific domains such as network and database programming. These are broad topics,
    and each has its own set of goodies that will help make the application robust.
    Nonetheless, the techniques we have learned in this book provide a solid foundation
    for all these domains.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: This last chapter is designed to give you just a flavor of one such domain.
    It will be a superficial introduction to desktop GUI application development using
    Python.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: GUI programming is too big of a beast to fit into a single chapter. Let's do
    that anyway, keeping in mind that there is plenty of opportunity to learn beyond
    what is discussed here. The chapter won't show you how to create full-fledged,
    complex GUI applications. Rather, we will just dip a toe into GUI application
    development using Python's Tkinter library.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how the rest of the chapter is organized:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: The chapter will start with an overview of the available GUI frameworks.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we will see what event-driven programming is, followed by a primer on
    the Tkinter library.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What follows next is our first project, a simple GUI application that uses Tkinter.
    It is essentially the GUI version of the first ever application we developed in
    [Chapter 1](ch01.html "Chapter 1. Developing Simple Applications"), *Developing
    Simple Applications*.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next section will serve as an introduction to the **Model-view-controller**
    (**MVC**) architecture. This will be followed by our second project, where the
    earlier application is rewritten to implement the MVC architecture.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The chapter will also talk about testing GUI applications. This will be a high-level
    discussion, and won't involve writing any code.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This being the last chapter, we will conclude it, and hence the book, with a
    brief discussion on various application frontiers.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overview of GUI frameworks
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A user interface is typically something that a user can see and use to communicate
    with the application. So far, we have presented a text-based user interface. For
    example, in the *Attack of the Orcs* application, the user was prompted to specify
    a hut number, and based on the number entered, further actions were taken.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: A **Graphical User Interface** (**GUI**), on the other hand, presents an interface
    to the user that may have buttons, icons, text fields, graphics, and so on. There
    are several Python GUI frameworks available. Many of these are based on cross-platform
    technologies such as Tk, Qt, wxWidgets, and others. Let's briefly discuss some
    of the most popular frameworks. The purpose is to just make you aware of the GUI
    technologies available.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，**图形用户界面**（**GUI**）向用户提供了一个可能包含按钮、图标、文本字段、图形等的界面。有几种 Python 图形用户界面框架可供选择。其中许多基于跨平台技术，如
    Tk、Qt、wxWidgets 等。让我们简要讨论一些最受欢迎的框架。目的是让您了解可用的 GUI 技术。
- en: Tkinter
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Tkinter
- en: '**Tkinter** provides Python bindings or interface to the open source Tk GUI
    widget toolkit. For more information on Tk, see its official website, [http://www.tcl.tk/](http://www.tcl.tk/).
    It is available as a standard module in Python. What this means is that as long
    as Python is installed, we do not need any additional installations to use it.
    In this book, we will demonstrate basic GUI concepts using the Tkinter library.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**Tkinter** 提供了 Python 绑定或接口到开源的 Tk 图形用户界面小部件工具包。有关 Tk 的更多信息，请参阅其官方网站，[http://www.tcl.tk/](http://www.tcl.tk/)。它作为
    Python 的标准模块提供。这意味着只要安装了 Python，我们就不需要任何额外的安装来使用它。在本书中，我们将使用 Tkinter 库演示基本的 GUI
    概念。'
- en: PyQt
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PyQt
- en: '**PyQt** ([https://wiki.python.org/moin/PyQt](https://wiki.python.org/moin/PyQt))
    is a widely used Python GUI library. It is one of the most mature frameworks out
    there. It essentially provides Python bindings for a popular Qt GUI application
    development framework. In order to use this framework, you need to install Qt
    first.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**PyQt** ([https://wiki.python.org/moin/PyQt](https://wiki.python.org/moin/PyQt))
    是一个广泛使用的 Python 图形用户界面库。它是目前最成熟的框架之一。它本质上提供了对流行的 Qt 图形用户界面应用程序开发框架的 Python 绑定。为了使用这个框架，您首先需要安装
    Qt。'
- en: It is worth noting here that Qt has different licensing schemes depending on
    the project. For example, if your project is an open source distribution, licensed
    under the terms of LGPL or GPL, you can use Qt freely. If you are using it for
    a commercial purpose, you have to purchase a license. Visit the Qt website, [https://www.qt.io/](https://www.qt.io/),
    for more details.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，Qt 根据项目不同有不同的许可方案。例如，如果您的项目是开源发行版，根据 LGPL 或 GPL 条款许可，您可以自由使用 Qt。如果您将其用于商业目的，您必须购买许可证。有关详细信息，请访问
    Qt 网站，[https://www.qt.io/](https://www.qt.io/)。
- en: PySide
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PySide
- en: PySide is another Python binding for the Qt GUI framework. It is a free software,
    released under the LGPL license. PySide supports Windows, Mac, and Linux OS. For
    more information, see [https://wiki.qt.io/PySide](https://wiki.qt.io/PySide).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: PySide 是 Qt 图形用户界面框架的另一个 Python 绑定。它是一个免费软件，在 LGPL 许可下发布。PySide 支持 Windows、Mac
    和 Linux 操作系统。有关更多信息，请参阅 [https://wiki.qt.io/PySide](https://wiki.qt.io/PySide)。
- en: Kivy
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kivy
- en: This is one of the most promising open source frameworks for creating cross-platform
    interactive user interfaces. With kivy, you can rapidly develop native multi-touch
    apps for mobile or desktop. It provides a design language called Kv for GUI design.
    The kivy website lists many supported operating systems including Windows, Mac
    OS X , Ubuntu, and Android for which an installer is available.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这是创建跨平台交互式用户界面的最有前途的开源框架之一。使用 kivy，您可以快速为移动或桌面开发原生多点触控应用程序。它提供了一个名为 Kv 的设计语言用于
    GUI 设计。kivy 网站列出了许多支持的操作系统，包括 Windows、Mac OS X、Ubuntu 和 Android，为这些操作系统提供了安装程序。
- en: Tip
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you are using a different OS not listed on the kivy website, the installation
    could be a challenge. For example, at the time of writing this book, there is
    no installer available for **Red Hat Enterprise Linux** (**RHEL**) version 6.x.
    The other option is to build it from source code. But that could be a challenge
    if you are not familiar with the code compilation and building process. If you
    really want to use it, you could also install it in a virtual machine running
    one of the supported OS.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是不在 kivy 网站上列出的操作系统，安装可能会是一个挑战。例如，在撰写本书时，没有为 **Red Hat Enterprise Linux**（**RHEL**）版本
    6.x 提供安装程序。另一个选择是从源代码构建它。但如果您不熟悉代码编译和构建过程，这可能是一个挑战。如果您真的想使用它，您也可以在运行支持操作系统的虚拟机中安装它。
- en: wxPython
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: wxPython
- en: This package provides a wrapper for **wxWidgets**, a cross-platform GUI library.
    It is an open source toolkit, and according to the project website ([http://www.wxpython.org](http://www.wxpython.org)),
    the supported platforms include 32-bit Windows, many Unix-like operating systems,
    and Mac OS X.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 此软件包为**wxWidgets**提供了一个包装器，它是一个跨平台的GUI库。这是一个开源工具包，根据项目网站([http://www.wxpython.org](http://www.wxpython.org))，支持的平台包括32位Windows、许多类Unix操作系统和Mac
    OS X。
- en: While there are many choices available at our disposal, in this chapter we will
    use the built-in Tkinter module mentioned earlier. The scope will be limited to
    developing a simple application that demonstrates some of the major components
    of GUI-based application development.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们有多种选择可供选择，但在这个章节中，我们将使用前面提到的内置Tkinter模块。范围将限于开发一个演示基于GUI应用程序开发主要组件的简单应用程序。
- en: GUI programming design considerations
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GUI编程设计考虑因素
- en: Although the focus of this chapter is on developing simple GUI applications,
    it is worth taking a moment to briefly discuss some important practical design
    considerations or guidelines for developing user interfaces. These guidelines
    will also come in handy for web-based or mobile applications. Some aspects that
    we are about to discuss should actually be part of your GUI application development
    life cycle.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然本章的重点是开发简单的GUI应用程序，但花一点时间简要讨论一些重要的实际设计考虑因素或指南，对于开发用户界面来说是有价值的。这些指南对于基于Web或移动应用程序也很有用。我们即将讨论的一些方面实际上应该是您GUI应用程序开发生命周期的一部分。
- en: Understanding user requirements
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解用户需求
- en: The first and foremost task is to put yourself in the shoes of the end user.
    You are developing the GUI application for consumption by the end users. It is
    important to take their feedback on the features that they would like to see.
    This is typically a part of requirements gathering.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 第一和最重要的任务是站在最终用户的立场上。你正在为最终用户开发GUI应用程序。了解他们希望看到的功能的反馈是非常重要的。这通常是需求收集的一部分。
- en: Developing a user story
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发用户故事
- en: OK, so you know what features are requested, and have prepared a list that would
    be supported in the upcoming version. It is often useful to prepare a mock user
    interface that illustrates how various features could be accessed and how they
    interact. The mock user interface could be in the form of a simple presentation.
    You can then take feedback from the development team as well as from the key users
    of the product. This will allow you to immediately identify the problems, if any,
    or refine your design strategy even before writing a single line of code. Such
    discussions with the key stakeholders could also unearth future requirements that
    you have not thought through. This, in turn, will help you refine the software
    architecture to make provisions for such requirements. Next, let's learn about
    some of the design principles.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，你知道了所需的功能，并准备了一个将在即将推出的版本中支持的功能列表。准备一个模拟用户界面，说明如何访问各种功能以及它们如何交互，通常是有用的。这个模拟用户界面可以是一个简单的演示。然后你可以从开发团队以及产品的关键用户那里获取反馈。这将使你能够立即识别问题（如果有的话），或者在编写代码之前就完善你的设计策略。与关键利益相关者的此类讨论也可能揭示出你尚未考虑的未来需求。这反过来又可以帮助你完善软件架构，为这些需求做出规定。接下来，让我们了解一些设计原则。
- en: Simplicity and accessibility
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简洁性和易用性
- en: 'The GUI should be simple enough to make the most frequently used tasks easy
    to access. What the developers think as *simple* may not always go well with the
    end users. Getting user feedback and going through design iterations play an important
    role. In general, keep the following things in mind when designing for simplicity:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: GUI应该足够简单，以便最常用的任务易于访问。开发者认为的“简单”可能并不总是与最终用户相匹配。获取用户反馈和进行设计迭代起着重要作用。在设计简洁性时，通常需要记住以下几点：
- en: It matters how you lay out the various components in the application window.
    Is it intuitive? Is it easily accessible?
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在应用程序窗口中布局各种组件很重要。这是直观的吗？是否易于访问？
- en: Place frequently used and important functionality prominently in the UI.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在用户界面(UI)中突出显示常用和重要的功能。
- en: Try to hide advanced or less frequently used features. If possible, you could
    create an expert level mode in your GUI where these features appear prominently.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽量隐藏高级或不太常用的功能。如果可能的话，你可以在你的图形用户界面(GUI)中创建一个专家模式，让这些功能突出显示。
- en: Have default values wherever applicable.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在适用的情况下设置默认值。
- en: Common user actions should be easy to execute. For example, if changing the
    background color is a common task, allow users to access this option with a click
    of a button or with a keyboard shortcut.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见用户操作应该容易执行。例如，如果更改背景颜色是一个常见任务，允许用户通过点击按钮或使用键盘快捷键来访问此选项。
- en: Try not to put too many things in the default display. Reduce the clutter.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽量不要在默认显示中放入太多东西。减少杂乱。
- en: Of course, this is not a complete list, and things will change depending on
    the application and the domain.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这不是一个完整的列表，具体内容会根据应用程序和领域的变化而变化。
- en: Consistency
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一致性
- en: The user interface should be consistent. If you have similar features, they
    should have a similar look and feel, similar steps to execute, and so on. The
    placement of standard features or functions should not change. For example, in
    a text editor, the **Open** button is typically placed near the top-left corner
    of the application window. This default position should remain constant.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 用户界面应该是统一的。如果你有类似的功能，它们应该有类似的外观和感觉，类似的执行步骤，等等。标准功能或功能的位置不应改变。例如，在文本编辑器中，**打开**按钮通常放置在应用程序窗口的右上角。这个默认位置应该保持不变。
- en: Predictability and familiarity
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可预测性和熟悉性
- en: When a button is clicked, the user should be able to predict the next course
    of action. A trivial example is the **Save As...** button—when clicked, the user
    anticipates a dialog with the option to specify a location and file format. Why?
    Because he or she is familiar with using a similar function in some other application.
    Further, the user would anticipate some default directory location to save the
    file. The UI should not surprise the user by changing this behavior.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当按钮被点击时，用户应该能够预测下一步的操作。一个简单的例子是**另存为...**按钮——当点击时，用户期待一个对话框，可以选择指定位置和文件格式。为什么？因为他或她熟悉在其他应用程序中使用类似的功能。此外，用户会期待一些默认目录位置来保存文件。UI不应该通过改变这种行为来让用户感到惊讶。
- en: Similarly, when you design an icon, it should speak for itself. For example,
    a gear icon typically indicates some sort of configurable settings. The UI design
    should be such that the user can easily guess the next action to perform in a
    particular situation, be it exiting the current mode or going back to the previous
    step, and so on.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，当你设计图标时，它应该能够自我表达。例如，齿轮图标通常表示某种可配置的设置。UI设计应该是用户可以轻松猜测在特定情况下下一步要执行的操作，无论是退出当前模式还是返回上一步，等等。
- en: Miscellaneous design considerations
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他设计考虑因素
- en: 'We have covered some of the important factors you should know before designing
    a GUI. There are many other design principles. Some of these principles are tied
    to the aspects that we''ve already discussed. A few of these can be listed as
    follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了一些在设计GUI之前你应该知道的重要因素。还有很多其他的设计原则。其中一些原则与我们之前讨论的方面相关。以下是一些可以列举的原则：
- en: The GUI should have a visual appeal and clarity.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GUI应该具有视觉吸引力和清晰度。
- en: It should be comprehensible. In other words, new users should quickly get up
    to speed.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该是可理解的。换句话说，新用户应该能够快速上手。
- en: It should anticipate common problems, and gracefully handle user errors.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该预见常见问题，并优雅地处理用户错误。
- en: Event-driven programming
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件驱动编程
- en: In an algorithm-driven program, the flow of the program is dictated by the predefined
    steps written in that program. The program may prompt the user with these instructions
    for an input. An example is a command-line application asking for user input in
    a predefined order.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个由算法驱动的程序中，程序的流程是由该程序中预定义的步骤决定的。程序可能会提示用户输入这些指令。一个例子是命令行应用程序按照预定义的顺序请求用户输入。
- en: In contrast, applications with a graphical user interface let the user dictate
    the program flow. The application waits for the user actions, and then responds
    to those actions. For example, if you are reading a PDF copy of a book, you can
    perform actions like jumping to the next page, zooming-in, scrolling down, or
    closing the window by clicking on the appropriate buttons. Here, you are essentially
    telling the application what to do next. This is called event-driven programming.
    Here, the control flow of the program is governed by the triggered events. The
    application responds to these events as they occur. The response could be changing
    the state of the graphical element or running some background task, and so on.
    For example, if the user clicks a button representing the next page, the application
    will display the next page of the book. Next, let's briefly talk about a few important
    concepts in event-driven programming.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，具有图形用户界面的应用程序允许用户决定程序流程。应用程序等待用户操作，然后对这些操作做出响应。例如，如果你正在阅读一本书的PDF副本，你可以执行诸如跳转到下一页、放大、滚动或通过点击适当的按钮关闭窗口等操作。在这里，你实际上是在告诉应用程序接下来要做什么。这被称为事件驱动编程。在这里，程序的流程控制由触发的事件控制。应用程序在事件发生时对这些事件做出响应。响应可能是改变图形元素的状态或运行一些后台任务等。例如，如果用户点击代表下一页的按钮，应用程序将显示书的下一页。接下来，让我们简要谈谈事件驱动编程中的一些重要概念。
- en: Event
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件
- en: In simple terms, an event represents an action happening inside the GUI window.
    An event could be triggered by various sources. For example, when a user clicks
    a mouse button, it generates a click event; pressing a key on the keyboard is
    recognized as another event, and so on. An event could also be generated without
    a direct user input. For example, the application might have completed running
    some calculations in the background, and now wants to update the contents presented
    by the GUI. This could automatically trigger some update event that would redraw
    the view.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，事件代表在GUI窗口内发生的一个动作。事件可能由各种来源触发。例如，当用户点击鼠标按钮时，它生成一个点击事件；按下键盘上的键被识别为另一个事件，等等。事件也可能在没有直接用户输入的情况下生成。例如，应用程序可能在后台完成了一些计算，现在想要更新GUI显示的内容。这可能会自动触发一些更新事件，从而重新绘制视图。
- en: Event handling
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件处理
- en: When an event is triggered, the application responds to that event. For example,
    when you click on the close button of a browser, you expect the browser window
    to close. In this example, closing the window is the application's response to
    the click event generated due to user action. In other words, the application
    has a *listener* object that *handles* this click event. Every GUI framework provides
    a way to *bind* (or *connect*) an event to a handling function.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个事件被触发时，应用程序会对该事件做出响应。例如，当你点击浏览器的关闭按钮时，你期望浏览器窗口关闭。在这个例子中，关闭窗口是应用程序对由于用户操作而生成点击事件的响应。换句话说，应用程序有一个*监听器*对象来*处理*这个点击事件。每个GUI框架都提供了一种将事件*绑定*（或*连接*）到处理函数的方法。
- en: Event loop
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件循环
- en: The event loop is the main controlling loop of the GUI program. When you start
    the application, the main loop is started, and it waits for the events to occur.
    It monitors the event sources, and dispatches the events when they occur.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 事件循环是GUI程序的主要控制循环。当你启动应用程序时，主循环开始，并等待事件发生。它监视事件源，并在事件发生时调度事件。
- en: 'With this short introduction, let''s summarize what we have learned about event-driven
    programming:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个简短的介绍，让我们总结一下关于事件驱动编程我们已经学到了什么：
- en: The overall flow of program execution is governed by events
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序执行的整体流程由事件控制
- en: The application runs (the main loop starts) and waits for events to occur
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序运行（主循环开始）并等待事件发生
- en: When an event is triggered, the application code, which is listening to the
    events, responds by running a specific handling function
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个事件被触发时，监听事件的程序代码会通过运行一个特定的处理函数来做出响应
- en: Thus, the flow of a program depends on the triggered events
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此，程序的流程取决于触发的事件
- en: GUI programming with Tkinter
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Tkinter进行GUI编程
- en: As mentioned earlier, a GUI provides a way to interact with an application.
    Instead of a text-based input, the user is presented with elements such as text
    boxes, radio buttons, tool bars, and so on. This section will introduce you to
    the basics of GUI programming with Tkinter. This library is available as a standard
    module in Python.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，GUI提供了一种与应用程序交互的方式。用户不是通过基于文本的输入，而是通过文本框、单选按钮、工具栏等元素进行交互。本节将介绍使用Tkinter进行GUI编程的基础。这个库是Python的标准模块之一。
- en: Tkinter documentation links
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Tkinter文档链接
- en: Let's document some links for a handy reference. The official Tkinter documentation
    page can be found at [https://docs.python.org/3/library/tkinter.html#module-tkinter](https://docs.python.org/3/library/tkinter.html#module-tkinter).
    This page lists several external references. A good introduction is available
    at [http://effbot.org/tkinterbook](http://effbot.org/tkinterbook). Of course,
    you can always perform a web search with search terms like python and Tkinter
    to find more resources.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为方便参考记录一些链接。官方Tkinter文档页面可在[https://docs.python.org/3/library/tkinter.html#module-tkinter](https://docs.python.org/3/library/tkinter.html#module-tkinter)找到。此页面列出了多个外部参考。一个很好的介绍可在[http://effbot.org/tkinterbook](http://effbot.org/tkinterbook)找到。当然，你可以始终使用如python和Tkinter之类的搜索词进行网络搜索以找到更多资源。
- en: Alternatively, you can quickly find the supported functionality and documentation
    using the Python interpreter!
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以快速使用Python解释器查找支持的功能和文档！
- en: '[PRE0]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding command lists the supported classes, functions, and so on. To
    pull out a docstring, you can call the `__doc__` on a given attribute. The following
    example shows a docstring for `mainloop()` in Tkinter:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令列出了支持的类、函数等。要提取文档字符串，可以在给定的属性上调用`__doc__`。以下是一个Tkinter中`mainloop()`的文档字符串示例：
- en: '[PRE1]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The mainloop() in Tkinter
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Tkinter中的mainloop()
- en: 'In the discussion on event-driven programming, we learned about the main controlling
    loop. Writing an event loop or the main loop in Tkinter is very simple. The following
    code fragment shows the main loop in action. This is the simplest possible GUI
    application that you can write using Tkinter:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在关于事件驱动编程的讨论中，我们学习了主控制循环。在Tkinter中编写事件循环或主循环非常简单。以下代码片段展示了主循环的作用。这是你可以用Tkinter编写的最简单的GUI应用程序：
- en: '[PRE2]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s talk through this code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行分析这段代码：
- en: The first statement imports the `Tk` class from the `tkinter` module.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一条语句从`tkinter`模块中导入`Tk`类。
- en: Next, we create a main application window by instantiating the `Tk` class. It
    is represented by the variable `mainwin`. In Tkinter terminology, it is often
    referred to as root or master. In this chapter, we will call it `mainwin`.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们通过实例化`Tk`类创建一个主应用程序窗口。它由变量`mainwin`表示。在Tkinter术语中，它通常被称为root或master。在本章中，我们将称之为`mainwin`。
- en: The main event loop is started by calling the `mainloop()` method.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过调用`mainloop()`方法启动主事件循环。
- en: The output of this simple program is shown next. You can run it as any other
    Python program. The code can also be found in the supporting material for this
    chapter (see the file `mainloop_example.py`). Depending on your operating system
    and environment, the look and feel of this window may vary.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 下文展示了这个简单程序的结果。你可以像运行其他Python程序一样运行它。代码也可以在本书的支持材料中找到（请参阅文件`mainloop_example.py`）。根据你的操作系统和环境，这个窗口的外观和感觉可能会有所不同。
- en: '[PRE3]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '![The mainloop() in Tkinter](img/B05034_10_04.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![Tkinter中的mainloop()](img/B05034_10_04.jpg)'
- en: Tip
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: In Python 2.x, there is a minor change in the `import` statement. The module
    `tkinter` is available as Tkinter (first letter capital) for Python version 2\.
    The supporting code already takes care of this with the following conditional
    `import`. The rest of the code remains the same.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python 2.x中，`import`语句有细微的变化。对于Python版本2，模块`tkinter`作为Tkinter（首字母大写）可用。支持代码已经通过以下条件`import`处理了这个问题。其余代码保持不变。
- en: '[PRE4]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Simple GUI application – Take 1
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单GUI应用程序 – 第一次尝试
- en: We just saw how to start a `mainloop()` method. Let's go one step further, and
    add some widgets to this application. Observe the following code. You can also
    see the file `simple_application_1.py` in this chapter's code bundle.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到了如何启动`mainloop()`方法。让我们更进一步，向这个应用程序添加一些小部件。观察以下代码。你还可以在本章的代码包中看到文件`simple_application_1.py`。
- en: '![Simple GUI application – Take 1](img/B05034_10_05.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![简单的GUI应用程序 – 第一次尝试](img/B05034_10_05.jpg)'
- en: 'The code comments pretty much explain what the code does. It is summarized
    next:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 代码注释基本上解释了代码的功能。以下是总结：
- en: 'We start by importing the necessary classes and options from the `tkinter`
    module. Note that you could also do the following: `from tkinter import *`. However,
    the best practices that we saw earlier in the book do not recommend doing that.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们首先从`tkinter`模块导入必要的类和选项。注意，你也可以这样做：`from tkinter import *`。然而，我们在本书中之前看到的最佳实践并不推荐这样做。
- en: Next, the main window size is specified using the `geometry()` method. This
    is optional.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，使用`geometry()`方法指定主窗口的大小。这是可选的。
- en: The next few lines of the code create two widgets, a `Label` widget that will
    show the text `Hello World!`, and a `Button`, which will terminate the application
    on being clicked.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来的几行代码创建了两个小部件，一个将显示文本`Hello World!`的`Label`小部件，以及一个`Button`，当点击时会终止应用程序。
- en: We need some way to arrange these widgets inside the application window. This
    is referred to as geometry or layout management. There are three options to do
    that. What is illustrated here is the `pack()` method. More on geometry management
    later.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要某种方式来安排这些小部件在应用程序窗口内的布局。这被称为几何或布局管理。有三种方法可以做到这一点。这里展示的是`pack()`方法。关于几何管理的更多内容将在后面讨论。
- en: When the **Exit** button is clicked, we need some way to process this event.
    This is accomplished with the command option that is assigned to a callback function.
    In this example, we simply terminate the application window and also the `mainloop()`
    by calling `mainwin.destroy()`.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当点击**退出**按钮时，我们需要某种方式来处理这个事件。这是通过将命令选项分配给回调函数来完成的。在这个例子中，我们简单地终止应用程序窗口，并通过调用`mainwin.destroy()`来终止`mainloop()`。
- en: Tip
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Recall that Python functions are first-class objects. See [Chapter 6](ch06.html
    "Chapter 6. Design Patterns"), *Design Patterns* where we discussed on this. The
    callback function, `mainwin.destroy`, is assigned to the command variable.
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 回想一下，Python 函数是一等对象。参见[第 6 章](ch06.html "第 6 章。设计模式")，*设计模式*，我们在那里讨论了这一点。回调函数`mainwin.destroy`被分配给命令变量。
- en: 'Running this application from the command line displays a simple GUI window
    like so:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 从命令行运行此应用程序将显示一个简单的 GUI 窗口，如下所示：
- en: '[PRE5]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '![Simple GUI application – Take 1](img/B05034_10_06.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![简单的 GUI 应用程序 – 第 1 次](img/B05034_10_06.jpg)'
- en: If you click on the **Exit** button, it will terminate the main application
    window.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你点击**退出**按钮，它将终止主应用程序窗口。
- en: '| *Looks like Sir Foo is not quite impressed with this simple script...* |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| *看起来福爵士对这个简单的脚本并不太满意...* |'
- en: '![Simple GUI application – Take 1](img/B05034_10_09.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![简单的 GUI 应用程序 – 第 1 次](img/B05034_10_09.jpg)'
- en: '| *For bigger and complex applications, it is better to follow the object-oriented
    programming approach.**Let''s rewrite this application, and wrap it in a class.
    However, keep in mind that it is just a baby step towards creating a better application.
    Later in the chapter, you will learn about the MVC architecture, and a basic example
    on implementing it in your GUI application.* |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| *对于更大和更复杂的应用程序，遵循面向对象编程方法会更好。**让我们重写这个应用程序，并将其封装在一个类中。然而，请记住，这只是一个朝着创建更好的应用程序迈出的小小一步。在本章的后面部分，你将学习关于
    MVC 架构，以及如何在 GUI 应用程序中实现它的基本示例。* |'
- en: Simple GUI application – Take 2
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单 GUI 应用程序 – 第 2 次
- en: 'It is time to add some object-oriented flavor to the mix. The application in
    the previous section can be rewritten as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候给这个混合物添加一些面向对象的风味了。上一节中的应用程序可以重写如下：
- en: '![Simple GUI application – Take 2](img/B05034_10_10.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![简单的 GUI 应用程序 – 第 2 次](img/B05034_10_10.jpg)'
- en: 'Let''s briefly discuss the preceding code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要地讨论一下前面的代码：
- en: Compare this code against the previous code.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将此代码与之前的代码进行比较。
- en: The `MyGame` class is where we create the widgets and define the main logic.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MyGame`类是我们创建小部件和定义主要逻辑的地方。'
- en: Notice that the command callback function for the button is set to `exit_btn_callback`.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意，按钮的命令回调函数被设置为`exit_btn_callback`。
- en: What this means is that when the **Exit** button is pressed, it will invoke
    `exit_btn_callback()` instead of calling `mainwin.destroy()` directly.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这意味着当按下**退出**按钮时，它将调用`exit_btn_callback()`而不是直接调用`mainwin.destroy()`。
- en: This is just to show you how to specify a different callback function. You can
    always set it back to `command=mainwin.destroy()`.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这只是为了向你展示如何指定不同的回调函数。你总是可以将它设置回`command=mainwin.destroy()`。
- en: 'The rest of the code is self-explanatory. You can execute it to get the same
    `Hello world!` window as in the first program. The command is shown next:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的代码是自我解释的。你可以执行它以获得与第一个程序相同的`Hello world!`窗口。命令如下所示：
- en: '[PRE6]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `simple_application_2.py` file in the supporting code bundle essentially
    has the program we just reviewed.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 支持代码包中的 `simple_application_2.py` 文件基本上包含了我们刚才审查的程序。
- en: Tip
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'In all the examples, we will use the `Tk` instance `mainwin` as the master
    or parent object of the widgets created. In practice, it is often useful to create
    a container to hold other widgets in the GUI. The container could be an instance
    of the `Frame` class or any other widget depending on the application. For example,
    you could write the following:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有示例中，我们将使用 `Tk` 实例 `mainwin` 作为创建的小部件的主对象或父对象。在实践中，创建一个容器来在 GUI 中包含其他小部件通常很有用。该容器可以是
    `Frame` 类的实例或任何其他小部件，具体取决于应用程序。例如，您可以编写以下内容：
- en: '[PRE7]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now that we know how to create a simple application with a graphical user interface,
    let's move ahead and talk about the various widgets available in the Tkinter library.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了如何创建一个具有图形用户界面的简单应用程序，让我们继续讨论 Tkinter 库中可用的各种小部件。
- en: GUI Widgets in Tkinter
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Tkinter 中的 GUI 小部件
- en: In this section, we will briefly cover some of the frequently used widgets.
    Note that the widgets we are about to cover are not specific to a GUI library.
    However, the following discussion is tailored for the Tkinter library. For example,
    you will find a `Menu` widget in many GUI libraries. Tkinter provides it with
    the class `Menu`, the PyQt library calls it `QMenu`, and so on.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将简要介绍一些常用的小部件。请注意，我们即将介绍的小部件并不特定于任何 GUI 库。然而，以下讨论是针对 Tkinter 库量身定制的。例如，您将在许多
    GUI 库中找到一个 `Menu` 小部件。Tkinter 通过 `Menu` 类提供它，PyQt 库将其称为 `QMenu` 等。
- en: Tip
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'What we are about to see is far from being a comprehensive list. You are encouraged
    to explore the following wiki page that lists several other GUI elements: [https://en.wikipedia.org/wiki/List_of_graphical_user_interface_elements](https://en.wikipedia.org/wiki/List_of_graphical_user_interface_elements).'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们即将看到的内容远非详尽无遗。我们鼓励您探索以下维基页面，该页面列出了其他几个 GUI 元素：[https://en.wikipedia.org/wiki/List_of_graphical_user_interface_elements](https://en.wikipedia.org/wiki/List_of_graphical_user_interface_elements)。
- en: A widget is an element of a graphical user interface that enables user interaction.
    In other words, the user can do certain actions like pressing a button and interacting
    with the GUI.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 小部件是图形用户界面中的一个元素，它允许用户交互。换句话说，用户可以执行某些操作，如按下按钮并与 GUI 交互。
- en: We already saw how to create the `Label` and `Button` widgets. The following
    table summarizes some important widget classes in Tkinter.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何创建 `Label` 和 `Button` 小部件。以下表格总结了 Tkinter 中一些重要的小部件类。
- en: '| Widget Class | Basic Syntax | Description |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| 小部件类 | 基本语法 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `Menu` |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| `Menu` |'
- en: '[PRE8]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '| This widget represents a menu, such as a menu bar or a pop-up menu. It contains
    menu items. |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| 此小部件表示一个菜单，例如菜单栏或弹出菜单。它包含菜单项。 |'
- en: '| `Frame` |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `Frame` |'
- en: '[PRE9]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '| This is typically used as a container to hold other widgets. The frame widget
    also has its own grid layout, and like many other widgets, you can specify the
    background color, border, and other properties. |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| 这通常用作容器来包含其他小部件。框架小部件也有自己的网格布局，并且像许多其他小部件一样，您可以指定背景颜色、边框和其他属性。 |'
- en: '| `Canvas` |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| `Canvas` |'
- en: '[PRE10]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '| This is a graphics widget. This is where you can draw or write stuff. For
    example, you can render shapes, plots, images, or use this widget to write text.
    |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| 这是一个图形小部件。这是您可以绘制或写入内容的地方。例如，您可以渲染形状、图表、图像，或者使用此小部件来写入文本。|'
- en: '| `Label` |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| `Label` |'
- en: '[PRE11]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '| In a label, you can add a text or an image. When you click on a label, no
    event is triggered. Instead, you can update a label in response to some other
    event generated elsewhere. |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| 在标签中，您可以添加文本或图像。当您点击标签时，不会触发事件。相反，您可以在其他地方生成某些事件响应时更新标签。|'
- en: '| `Button` |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| `Button` |'
- en: '[PRE12]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The optional `command` argument could also be assigned to any user-defined function.
    | A simple button widget. When pressed or released, it triggers an event. |
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 可选的 `command` 参数也可以分配给任何用户定义的函数。| 一个简单的按钮小部件。当按下或释放时，它触发一个事件。|
- en: '| `Radiobutton` |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| `Radiobutton` |'
- en: '[PRE13]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: A group of radio buttons is tied to a common variable, `var`. When you click
    on a radio button, the value of that variable is changed to a predefined one given
    by the value. | The radio button widget allows a user to choose only a single
    value from a given set of values. It can contain a text or an image. |
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 一组单选按钮与一个公共变量 `var` 相关联。当您点击单选按钮时，该变量的值会更改为一个预定义的值，该值由值指定。| 单选按钮小部件允许用户从给定的一组值中选择单个值。它可以包含文本或图像。|
- en: '| `Checkbutton` |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `Checkbutton` |'
- en: '[PRE14]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The variable `var` has value of 1 when the check button is selected, otherwise
    the value is set to 0\. This is the default behavior. | This widget allows setting
    two different values to a variable. Typical usage is to toggle the state (on or
    off selection) of a variable. |
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '|'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You can then add elements to this list box using the `insert()` method as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '| This widget is used for showing a list of alternatives. The user can select
    one or many elements from the `Listbox` widget. |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
- en: '|'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '|'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '| This is a text entry widget that allows you to display or input text. In
    some other GUI frameworks, it is referred to as a line-edit widget. |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
- en: The basic syntax shown in the previous table is for illustrative purpose only.
    You can specify many other options. The `parent` argument given to the widget
    represents the parent or the base widget.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this book, we will just use the bare minimum options while creating widgets.
    You could further configure each of these widgets by specifying the appropriate
    optional arguments, or by calling the relevant methods. For further learning,
    follow the various references listed on the official Tkinter documentation page
    at the following link: [https://docs.python.org/3/library/tkinter.html#module-tkinter](https://docs.python.org/3/library/tkinter.html#module-tkinter).'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Geometry management
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Layout or geometry management is about organizing various widgets within the
    GUI. In Tkinter, this layout management is accomplished with something referred
    to as geometry managers. There are three different geometry managers to organize
    the widgets, namely *grid*, *pack*, and *place*. Among these, the grid manager
    is the recommended choice. Further in this chapter, we will demonstrate the use
    of a grid manager.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Grid geometry manager
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The grid manager offers flexibility in arranging various widgets, and is also
    very easy to use.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: The parent widget of the grid manager (for example, a frame or a dialog) is
    treated as a table with rows and columns.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The smallest element of this table is a cell, which has a height and a width.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can place other widgets in such cells. It is also possible to have a widget
    that spans more than one cells.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The height of each row in the table is determined by the height of the tallest
    cell (or a widget) in that cell. Likewise, the width of each column in this table
    is governed by the widest cell in that column.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each row and column in a grid geometry manager can be configured with a weight
    option. Weight determines how much a specific row or column can expand if the
    master widget has free space available. The weight can be specified using the
    methods `grid_rowconfigure` or `grid_columnconfigure` for rows and columns respectively.
    The default value for weight is 0.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot shows a representative grid layout:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '![Grid geometry manager](img/B05034_10_03.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
- en: In the preceding image, some `Label` widgets are arranged in a grid layout.
    The label text **Cell[0,0]** indicates that we have put this label in row 0 and
    column 0 of the grid. Observe that for **Cell[3,0]**, it shows a label whose width
    occupies four columns. Similarly, **Cell [1,3]** is a label whose height spans
    two rows.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Pack geometry manager
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In our first Tkinter application, we''ve already used the pack geometry manager
    to arrange the widgets. As a refresher, here is the relevant piece of code (the
    `pack` method):'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The pack geometry manager provides options such as expand, fill, and side to
    control widget placement. It is useful when you want to arrange multiple widgets,
    either side by side or overlapping each other. The other use case is when you
    want the widget to occupy the whole container that is holding it.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using both grid and pack geometry manager in the same main window could lead
    to undesirable results. Do not use these layout managers together.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Place geometry manager
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The place geometry manager allows you to specify the absolute or relative position
    of the widget and its size. It finds use in some special scenarios. We will not
    be discussing this geometry manager further. In most cases, you could, instead,
    use the grid geometry manager.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Events in Tkinter
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's briefly talk about the various events supported in Tkinter, and the syntax
    that describes them.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Event types
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following table shows some of the most frequently used event types. Read
    the documentation to learn about other event types not listed here. The next section,
    *Event descriptors*, will elaborate on how to use an event type to describe an
    event.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '| Event name | Description |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
- en: '| `Button` (or `ButtonPress`) | One of the mouse buttons is pressed. Which
    one? That is determined by the `detail` field of the event descriptor (see the
    next section). |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
- en: '| `ButtonRelease` | One of the mouse buttons (that was pressed earlier) is
    released. |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
- en: '| `Enter` | The mouse pointer entered a widget. This has nothing to do with
    the *Enter* or *return* key on the keyboard. |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
- en: '| `Leave` | The mouse pointer left a widget. |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
- en: '| `KeyPress` | A keyboard key is pressed. Which one? That is determined in
    the `detail` field of the event descriptor. |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
- en: '| `KeyRelease` | A keyboard key is released. |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
- en: '| `FocusIn` | A widget gets an input focus. |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
- en: '| `FocusOut` | A widget no longer has the input focus. |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
- en: Event descriptors
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Tkinter has a special syntax for describing an event. It is a string with the
    following general form:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The event specified is enclosed within the angular brackets `<>`.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The type specifies the type of the event, such as a mouse click.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The modifier and detail specifiers are optional.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The modifier is the event modifier. Imagine that the Control button is pressed
    along with a mouse button. Here, the Control button is the event modifier, whereas
    the mouse button press is the type of the event.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The detail specifier gives more information about the type of the event. If
    the type is a mouse click, the details will describe whether it is the left mouse
    button, the right button, or the middle one.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following table summarizes some of the common event specifiers.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '| Event syntax | Description |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
- en: '| `<Button-1>` | Mouse button 1 pressed (the left mouse button). |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
- en: '| `<Button-2>` | Mouse button 2 pressed (middle button, if available). |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
- en: '| `<Button-3>` | Mouse button 3 pressed (the right-most button). |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
- en: '| `<KeyPress-B>` | The *B* key is pressed. Likewise, you can write for other
    keys, such as `<KeyPress-G>`. |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
- en: '| `<Return>` | Return key pressed. |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
- en: '| `<Configure>` | Size of the widget is changed (for example, window resized).
    The new size is stored as the width and height attributes of the event object.
    |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
- en: '| `<Shift-Button-1>` | The *Shift* key is pressed along with the left mouse
    button. |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
- en: Event object attributes
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An instance of the `Event` class holds the information that describes the event.
    The following table lists some important attributes of the `Event` class.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '| Event attribute | Description |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
- en: '| `widget` | The widget object which triggered this event. |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
- en: '| `x`, `y` | The current mouse position in pixels. |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
- en: '| `x_root`, `y_root` | Mouse position in pixels, relative to the top-left corner.
    |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
- en: '| `width`, `height` | The changed size (width and height) for the `<Configure>`
    type of events. |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
- en: Event handling in Tkinter
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Earlier in the chapter, we learned about events and event handling (see the
    section *Event-driven programming*). In this section, we will see how to bind
    the various events triggered due to user interactions, with the appropriate handling
    functions.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Command callback (Button widget)
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Recall that when we wrote our first Tkinter application, we tied a callback
    function to the `command` argument of the `Button` widget. The relevant line of
    code is reproduced next for easy reference:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: When you click on the **Exit** button, it calls `mainwin.destroy()`, represented
    by the `command` argument. It should be noted that while the `Button` widget supports
    command callback, this feature is not available for all the supported widgets.
    For that, Tkinter provides the `bind()` method, which is defined on all widgets.
    The `bind()` method is just one of the levels of event binding in Tkinter. Let's
    talk about a few event-binding levels next.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: The bind() method
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This method provides an instance level binding. It binds an event to a specific
    widget instance. Another way to think of this is as an ability to specify the
    exact GUI element that is sensitive to a particular event. The basic syntax is
    as follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: It should be noted that you can also use this method for the `toplevel` window.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: For ease of understanding, let's represent the optional argument sequence as
    `even_descriptor` and `func` as `event_handler`. The third optional argument add
    can be specified as a string `+`. It allows you to add a new function to an existing
    binding. We will not discuss the `add` argument here. Refer to the documentation
    for further details.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the preceding statement, `widget` is any widget that generates one or more
    events. For example, the widget could be a `Button`, an `Entry` widget, and the
    like. The `event_descriptor` is the actual event triggered, for instance, a key
    press, or a click, and so on. `event_handler` is the function that gets called
    when the event is triggered.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how to use this method for the `Button` widget, in place of a command
    callback. Apart from the syntax, we also need to define a callback function that
    handles the generated event. Let's rewrite the code illustrated in the section,
    *Simple GUI application*.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '![The bind() method](img/B05034_10_07.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
- en: Observe that we have defined a new event handling function, `exit_btn_clicked()`,
    that takes the event object (`evt`) as an argument. The first argument to bind
    represents the type of event or the event format. In this example, `<Button-1>`
    represents a left mouse button press over the widget. In this chapter, we will
    only use the `bind()` method. But before we go further, let's briefly talk about
    the other levels of binding.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: The bind_class() method
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This method provides a class-level binding. It binds an event to a specific
    widget class. The basic syntax is shown next:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the preceding syntax, `className` is a string representing the name of the
    widget class. The other arguments are the same as discussed in the previous section.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that all the `Button` widgets in your application represent some numbers.
    You can configure all of them to respond to the right mouse click event such that
    each returns the square of that number. In this example, you can use the `bind_class`
    method like so:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here, it is assumed that you have defined a function, `compute_square`.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: The bind_all() method
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This method provides an application-level binding. As the name suggests, this
    method binds an event to all the widgets at the application level. For example,
    in some game application, you might want to configure a key to pause the game
    regardless of the widget under focus. In such situations, you can use this method.
    The basic syntax is as follows:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Tip
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Tkinter supports something referred to as bind tags. Every widget has its own
    list of bind tags. These determine the order in which the events associated with
    a widget are processed. The built-in method `bindtags()` can be used to set or
    get the tags associated with a widget. See the documentation for further details.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: Project-1 – Attack of the Orcs V10.0.0
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '| *You have developed a robust and popular command-line application, **Attack
    of the Orcs**. While the users are happy with the current version, there is a
    new and growing demand. The users now want a graphical user interface for the
    application!* |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
- en: It is time to work on another simple program. Remember the first ever command-line
    application we wrote in [Chapter 1](ch01.html "Chapter 1. Developing Simple Applications"),
    *Developing Simple Applications*? Let's use the same theme, and develop an equivalent
    GUI program.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Background scenario
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As a refresher, here is the game theme we saw in [Chapter 1](ch01.html "Chapter 1. Developing
    Simple Applications"), *Developing Simple Applications*:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '| *On his way through a dense forest, Sir Foo spotted a small isolated settlement.
    Tired and hoping to replenish his food stock, he decided to take a detour. As
    he approached the village, he saw five huts. There was no one to be seen around.
    Hesitantly, he decided to enter a hut...* |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
- en: Problem statement
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| *The task is to design a* *simple GUI program. The player selects one of
    the five huts where Sir Foo can rest. The huts are randomly occupied either by
    a friend or an enemy. Some huts might also be left unoccupied. The player wins
    if the selected hut is either unoccupied or has a friendly unit inside.* |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
- en: The following screenshot shows what's coming up. But don't get too excited!
    It is quite a simple game that will help you learn some important GUI programming
    aspects.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '![Problem statement](img/B05034_10_08.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
- en: When you click on a hut, it will check who the occupant is, and then pop up
    a message box declaring the winner. That's pretty much it!
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: Writing the code
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will use the code provided in the `hutgame.py` file. Download this file and
    also the two images, `Hut_small.gif` and `Jungle_small.gif` from the code bundle
    for this chapter.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is recommended that you open the file `hutgame.py` as a handy reference while
    reading the following discussion. Quite often, it is useful to skim through the
    full code in a source code editor for better understanding!
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start with the main execution code:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing the code](img/B05034_10_12.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
- en: 'Let''s talk through this code:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: Compare this with the main execution block in the section *Simple GUI application
    – Take 2*. Notice that there isn't much of a difference.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We set the size and a title for the application window with the `geometry` and
    `title` methods. The `mainwin.resizable` call freezes the window size. This is
    optional, but will make sure the background image nicely fits the window.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `HutGame` class is where we create the widgets and define the main logic.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The main event loop is started by calling `mainloop()`.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overview of the class HutGame
  id: totrans-278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before reviewing any code in the class `HutGame`, let''s get the big picture
    first. The important methods of this class are shown in the following diagram:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '![Overview of the class HutGame](img/B05034_10_11_uml_hutgame_1.jpg)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
- en: As illustrated, these methods can be broadly divided into three groups based
    on the functionality. We will talk about this grouping later when we discuss the
    MVC architecture. Let's review the various methods in this class next.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**A note to more experienced readers!**'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: In the following few sections, we will discuss the methods of the class `HutGame`.
    You might find this discussion a bit verbose! Optionally, you can just review
    the code from the file `hutgame.py`. The code is documented reasonably well. If
    something is not clear, come back and read the relevant section!
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: The __init__ method
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Take a look at the code that gets called when `HutGame` is instantiated:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '![The __init__ method](img/B05034_10_13.jpg)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
- en: 'The following is a description of the `__init__` method:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: The `PhotoImage` class is used for displaying a background image in widgets
    such as labels, buttons, and so on. It supports the GIF image format. There is
    also a way to load an image using **Python Imaging Library** (**PIL**). We won't
    discuss those details here.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will use `hut_image` on a `RadioButton`, and `village_image` will be set
    as the application background.
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `self.setup()` call ensures that widgets are created and appropriately placed
    in the application window.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The occupy_huts method
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following method is the same as the one illustrated in the first example
    of [Chapter 1](ch01.html "Chapter 1. Developing Simple Applications"), *Developing
    Simple Applications*:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '![The occupy_huts method](img/B05034_10_14.jpg)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
- en: There are exactly five huts. This code essentially populates the `self.huts`
    list with a random choice of occupant from the given `occupants` list.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: The create_widgets method
  id: totrans-296
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As the name suggests, this method is about creating the widgets for our application.
    Actually, there aren''t many widgets. We just have a label to display some information
    and a bunch of radio buttons to represent the huts. The method is shown next:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '![The create_widgets method](img/B05034_10_15.jpg)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
- en: 'The preceding method can be explained as follows:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '`self.var` is a Tkinter variable. It is an instance of a variable class supported
    by Tkinter. Here, it represents an integer variable (`IntVar` class). Likewise.
    there are other classes such as `StringVar` to deal with string variables, and
    so on.'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simply put, the Tkinter variables enable tracking changes. We have five radio
    buttons that are tied to the single Tkinter variable, `self.var`. A value option
    can be specified for each radio button. This value gets assigned to `self.var`
    when the radio button is selected.
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The dictionary `r_btn_config` is used to set configuration options common to
    all the radio buttons. It is passed as an argument to `Radiobutton`.
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An example would help in understanding how a radio button works. The button
    `self.r4` has an associated value of `4`, which represents the hut number. When
    you select the button, this value gets assigned to `self.var`. This invokes `self.radio_btn_pressed()`,
    the command callback for the button.
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`self.background_label` is used to set a village background for our application
    window. There are other ways to accomplish this. We won''t be discussing such
    customization details in this book.'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![The create_widgets method](img/B05034_10_16.jpg)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
- en: '| *Certainly! Have a look at the following application window where some of
    these widgets or configuration options are annotated.* |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
- en: '![The create_widgets method](img/B05034_10_17.jpg)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
- en: The setup_layout method
  id: totrans-308
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following code fragment shows the `setup_layout()` method. and how it is
    invoked in the top-level `setup()` method:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '![The setup_layout method](img/B05034_10_18.jpg)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
- en: Tip
  id: totrans-311
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The grid layout offers a lot of flexibility in arranging widgets. In this illustration,
    we are just scratching the surface of Tkinter! To gain expertise, you should create
    your own GUI widgets, and experiment with different layout configuration options.
    Refer to the documentation for other available options.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s talk through this code snippet:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: Recall that we can assign a relative `weight` to a specific row or a column
    in a grid layout. This is accomplished using the `grid_rowconfigure` and `grid_columnconfigure`
    methods. `weight` determines how much free space the row or column will occupy
    relative to the others. A default value of 0 means it won't grow even if there
    is free space available.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this example, `row 1` of the container is given a relative weight or `1`,
    allowing it to expand and occupy more free space. Likewise, the `column 0` and
    `column 4` are assigned with a relative weight of `1`. Experiment with this option,
    and see how it influences the layout. The other option to try out is pad, which
    adds padding to the widget.
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For `background_label`, we use the `place()` geometry manager. The label is
    anchored at `(0, 0)`. The arguments `relwidth` and `relheight` indicate the fraction
    of the height and width of the parent. The value of 1.0 means the label size will
    be the same as its parent (the main application window).
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `sticky` option for `info_label` ensures the widget is aligned along the
    four edges of the cell. The value `nsew` aligns the widgets along the north, south,
    east, and west cell edges respectively. You can also specify a few values, for
    example, `sticky='ew'` will align the widget along the left and right edges.
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The radio_btn_pressed and enter_hut methods
  id: totrans-318
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s review these methods together. In the `create_widgets()` method, we
    specified the command option as indicated in the following code fragment:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '![The radio_btn_pressed and enter_hut methods](img/B05034_10_19.jpg)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
- en: '`radio_btn_pressed` is a command callback for all the radio buttons. It is
    shown next:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '![The radio_btn_pressed and enter_hut methods](img/B05034_10_20.jpg)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
- en: The method just calls `self.enter_hut`. When the radio button is selected, it
    updates the value stored in the Tkinter variable, `self.var`. This value is nothing
    but the hut number assigned to the selected hut, and can be obtained by calling
    the `get()` method of Tkinter's `IntVar` class.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the `enter_hut` method:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '![The radio_btn_pressed and enter_hut methods](img/B05034_10_21.jpg)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
- en: The preceding code is self-explanatory. It checks the occupant, and announces
    the result. The winner announcement is done with a `messagebox` widget.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: The announce_winner method
  id: totrans-327
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is the last method we will review:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '![The announce_winner method](img/B05034_10_22.jpg)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
- en: In the preceding method, we use the `messagebox` module in Tkinter to show an
    information box. This module provides several other types of dialog boxes. Refer
    to the documentation for more details.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: Running the application
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is time for some action! Run this application as follows:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This last command should display the GUI window shown earlier. The following
    screenshot shows the game in action. First you select one of the huts:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: '![Running the application](img/B05034_10_23.jpg)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
- en: When you click on the radio button, it displays the information box notifying
    the winner.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '![Running the application](img/B05034_10_24.jpg)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
- en: MVC architecture
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'MVC is a widely used software architectural pattern in GUI-based applications.
    It has three components, namely a *model* that deals with the business logic,
    a *view* for the user interface, and a *controller* to handle the user input,
    manipulate data, and update the view. The following is a simplified schematic
    that shows the basic interactions between the various components:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '![MVC architecture](img/B05034_10_01.jpg)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
- en: Let's further discuss each of these components.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: Model
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The model component of the MVC architecture represents the data of the application.
    It also represents the core business logic that acts on such data. The model has
    no knowledge of the view or the controller. When the data in the model changes,
    it just notifies its listeners about this change. In this context, the controller
    object is its listener.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: View
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The view component is the user interface. It is responsible for displaying the
    current state of the model to the user, and also provides a means for the user
    to interact with the application. If a user action (like the click of a button)
    changes this state, the view is refreshed to display that change.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: Controller
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In some sense, the controller enables a handshake between the model and the
    view. It monitors the changes to the model. When the user interacts with something
    in the view, the controller works in the background and handles the events triggered
    by the user actions, such as a mouse click. The handling function can further
    update the model. When the model's state changes, the controller updates the view
    to reflect those changes.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '![Controller](img/B05034_10_02.jpg)'
  id: totrans-348
  prefs: []
  type: TYPE_IMG
- en: '| *You are right. The individual MVC components and their working would be
    better understood with an illustration. Let''s use a trivial example given earlier
    in the section **Event-driven programming***. |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
- en: 'Imagine you have opened a PDF file for reading. In this context, MVC and its
    components could be explained as follows:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: The PDF reader is the running application.
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will show the contents of the file you have opened, and will also have buttons
    to navigate through the file. This is the view component that deals with the user
    interface.
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To jump to the next page, you interact with the view and click on the next page
    button. This is a user input that generates an event.
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Such an event is internally handled by the controller, which then updates the
    model, or, in this context, retrieves the relevant data on the requested page.
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The model 's state has changed. The controller further communicates with the
    view for updating it with the new contents.
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The view is refreshed, and finally, you see the desired page.
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advantages of MVC
  id: totrans-357
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The MVC architecture has been traditionally used in desktop GUI applications,
    and is also widely used in web application development. As this is a three-component
    architecture, one major advantage it offers is code reuse across several applications.
    For example, imagine you have multiple applications with different user interfaces,
    all needing the same business logic. With MVC architecture, you could just reuse
    the business logic represented by the model object across these applications.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, the MVC enables user interface developers to focus on the UI code
    without worrying much about the code that handles the business logic. Likewise,
    the developers working on the business logic can concentrate on that piece of
    code alone without losing sleep over the choice of UI widgets and the related
    code. This is referred to as *separation of concerns*. The model is concerned
    about the business logic or data, the view worries about the user interface, and
    the controller code is concerned about things such as enabling view manipulation
    and handling the input.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: Project 2 – Attack of the Orcs v10.1.0
  id: totrans-360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's work on another small project. In fact, this is exactly the same hut game
    we developed in *Project-1 – Attack of the Orcs V10.0.0* earlier. The difference
    is the underlying architecture. We will rewrite the program to implement the MVC
    architecture.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: Revisiting the HutGame class
  id: totrans-362
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the first project, we wrote the `HutGame` class. Let''s pull up the diagram
    representing the high-level structure of this class:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: '![Revisiting the HutGame class](img/B05034_10_25.jpg)'
  id: totrans-364
  prefs: []
  type: TYPE_IMG
- en: Based on the functionality, the methods of this class can be roughly placed
    into three categories, namely model, view, and the controller. The preceding diagram
    shows this division. We also need to further update a few of these methods.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: Creating MVC classes
  id: totrans-366
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, we earmarked the methods of the old class `HutGame`
    into three broad categories. It is now time to say goodbye to this class. We will
    break it down and split its methods among the three new classes, `Model`, `View`,
    and `Controller`. Of course, you can give more descriptive names to the classes,
    but let's continue to call them by the aforementioned names.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: Observe the following UML-like representation that shows the classes in which
    these methods are parked. Only the important attributes are listed here.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating MVC classes](img/B05034_10_26.jpg)'
  id: totrans-369
  prefs: []
  type: TYPE_IMG
- en: Tip
  id: totrans-370
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In [Chapter 1](ch01.html "Chapter 1. Developing Simple Applications"), *Developing
    Simple Applications*, we briefly talked about UML-like representation. One way
    to create such diagrams is to use [https://www.draw.io](https://www.draw.io).
    It is a free, online diagram software for making flowcharts, UML diagrams, and
    so on.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how the classes are laid out, let's understand how these classes
    exchange information.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: Communication between MVC objects
  id: totrans-373
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before diving into the details on how MVC objects communicate, let''s first
    list down a few important points about the MVC architecture:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: The controller knows about the model as well as the view
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The model is unaware of the other two, namely the controller and the view
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The view (just like the model) knows nothing about the controller and the model
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There could be some other variants of the MVC architecture. In this book, we
    will stick to the aforementioned points, and design a solution.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: Controller to Model or View communication
  id: totrans-379
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's begin the discussion by learning how a controller sends the information
    to either the model or the view.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Controller` object can directly talk to the `Model` and `View` instances
    using `self.model` and `self.view` respectively. For example, it can just call
    a `View` method like so:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This is pretty straightforward. Now let's see how it receives the data from
    either the model or the view.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: Model to Controller communication
  id: totrans-384
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: How does the controller receive information from the model? For example, in
    the hut game scenario, a winner is determined depending on who is inside the selected
    hut. Once the winner is determined, the `Model` class needs to communicate it
    to the `Controller` class. This is accomplished with the `model_change_handler()`
    method of the `Controller` class. It is invoked whenever the state of the `Model`
    class changes.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: '![Model to Controller communication](img/B05034_10_27.jpg)'
  id: totrans-386
  prefs: []
  type: TYPE_IMG
- en: '| *Good question! The* `Model` *class knows nothing about* `Controller` *and*
    `View`*. Then how does* `Controller` *know that* `Model` *has changed? Let''s
    see that next.* |'
  id: totrans-387
  prefs: []
  type: TYPE_TB
- en: The `Controller` class can receive information from the `Model` class in various
    ways. Let's briefly talk about two such approaches.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: Using method assignment
  id: totrans-389
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Recall that in Python, you can assign a method to a variable. The chapter on
    design patterns talked about the first-class objects in greater detail. The following
    line of code can be added to `Controller.__init__`.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then, in the `Model` class, you could call `self.changed()`, like so:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This automatically notifies `Controller` that the model has changed. While this
    is very convenient, we will instead use a publish-subscribe API which makes things
    even simpler.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: Using a publish-subscribe pattern
  id: totrans-395
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Publish-subscribe is a messaging pattern. The publisher can be any program
    that broadcasts some data to a topic. There could be one or more applications
    that are listening to this topic. These are called the subscribers, who receive
    the published data. The publisher does not know (or does not need to know) anything
    about the subscribers. Similarly, a subscriber has no knowledge of the publisher.
    The following schematic gives a high-level overview of a publish-subscribe system:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: '![Using a publish-subscribe pattern](img/B05034_10_28.jpg)'
  id: totrans-397
  prefs: []
  type: TYPE_IMG
- en: The publish-subscribe concept can be better understood with a real-world analogy.
    Imagine an online retailer running a weekly flash sale. You have opted in to receive
    notifications in the form of SMS or e-mail alerts. There are several other customers
    who would also like to get notified about the sale.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: In a publish-subscribe world, the online retailer is a publisher who broadcasts
    the sale information (the data) to a topic, say *flash sale*. You and several
    other customers are the subscribers to this topic. Likewise, the online retailer
    can publish some other information as different topics, for instance, *Friday
    sale*, *Half price sale*, and so on. Each topic could have several subscribers.
    If you are not subscribed to *Friday sale* , you won't get any notifications sent
    to that topic.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: PyPubSub package
  id: totrans-400
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'How do we implement a publish-subscribe framework in Python? One option is
    to write the code from scratch. Instead, we will just use a Python package called
    `pypubsub`. It provides a publish-subscribe API that simplifies the design and
    improves code readability and testability. The package can be installed as follows:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here is a simple example that shows a typical usage. In fact, this syntax is
    all we need in this chapter.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: '![PyPubSub package](img/B05034_10_31.jpg)'
  id: totrans-404
  prefs: []
  type: TYPE_IMG
- en: 'When you run this script, it produces the following output:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The first argument to `pub.subscribe()` is the function you want to subscribe
    to a given topic. The topic name here is WINNER ANNOUNCMENT. The last line of
    the code shows how to broadcast a message to a specific topic using `pub.sendMessage()`.
    The first argument to `pub.sendMessage()` is the topic name. You can specify any
    number of optional arguments, just make sure that the subscriber function accepts
    all those arguments! In this example, it sends data as the only optional argument.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-408
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For more information on the PyPubSub package, see the project home page: [http://pubsub.sourceforge.net/](http://pubsub.sourceforge.net/)'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: 'PyDispatcher is an alternative to the PyPubSub package. While we won''t be
    using it, here is a link to the project: [https://pypi.python.org/pypi/PyDispatcher](https://pypi.python.org/pypi/PyDispatcher)'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: View to Controller communication
  id: totrans-411
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Just like `Model`, there is no direct communication link from the `View` object
    to the `Controller` object. When the user presses a radio button, the controller
    needs to be notified. We can employ similar approaches, as discussed in the previous
    section. For example, you can assign a method of `Controller` to a `View` method.
    Alternatively, you can use the publish-subscribe API to talk to the `Controller`
    object.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: Communication between View and Model
  id: totrans-413
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s discuss how `View` and `Model` talk to each other:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: When the user presses a radio button, `View` communicates with `Controller`
    using one of the approaches discussed earlier
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Controller` object then talks to `Model` instructing it to update
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The state of `Model` is updated, and the results are communicated back to `Controller`
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Controller` asks `View` to update the display'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  id: totrans-419
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**View and Model communication using a publish-subscribe API**:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: You could potentially use the publish-subscribe framework to establish a communication
    channel between the `Model` and the `View` object. Note that this still keeps
    the basic rules intact. `Model` does not know anything about the `View` object.
    It just publishes the data to a given topic. `View` doesn't have any knowledge
    of the `Model` object. It is just registered as a subscriber to the same topic
    where `Model` is broadcasting the data. Thus, whenever there is a change of state
    in `Model`, `View` could get a notification through the publish-subscribe API.
    Likewise for the communication from `View` to `Model`. The potential flip-side
    is that these publish-subscribe signals are essentially global variables, and
    could bring in the painful issues associated with them. So use it with caution!
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: For this project however, we will stick to the classical approach, where the
    communication happens through `Controller`.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing the code
  id: totrans-423
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, you have got a high-level overview of the new classes and how they communicate
    with each other. In the first project, we already reviewed most of the methods
    listed under each new class. That said, to implement the MVC architecture we need
    to make a few changes. Let's review only a few important methods from the file
    `hutgame_mvc.py`. Note that all the classes have been put in the same file. As
    an exercise, split the individual classes in their own module!
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-425
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we won't be reviewing each and every line of the code, you should download
    the file `hutgame_mvc.py` and also the two images, `Hut_small.gif` and `Jungle_small.gif`
    from the code bundle for this chapter. Keep the source file handy while reading
    the upcoming discussion. Quite often, it is useful to skim through the full code
    for better understanding!
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: The main execution code is shown next. It is almost identical to the one we
    saw in the first project. The only difference is `game_app` (shown highlighted).
    It is now an instance of the `Controller` class instead of `HutGame`. In fact,
    there is no `HutGame` class for this project! Recall that we broke it down, creating
    three new classes.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: '![Reviewing the code](img/B05034_10_29.jpg)'
  id: totrans-428
  prefs: []
  type: TYPE_IMG
- en: The Controller class
  id: totrans-429
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Controller` class is quite small, as shown next:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: '![The Controller class](img/B05034_10_30.jpg)'
  id: totrans-431
  prefs: []
  type: TYPE_IMG
- en: Let's talk through the code. You can skip reading these bullets if you have
    already understood it!
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: The `Controller` class is composed of `Model` and `View` instances. This allows
    it to directly call the functionality from these classes.
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `self.view.set_callbacks()` function essentially assigns the `radio_btn_pressed`
    method to an appropriate attribute of `View`. What this simply means is that whenever
    the user presses a radio button, this method is invoked. See the section *View
    to Controller communication* for more details.
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Controller` class receives data from the `Model` instance by subscribing
    to the topic, `"WINNER ANNOUNCEMENT"`. We have already seen an example of the
    `pub.subscribe()` function. Simply put, the method `model_change_handler` is called
    whenever the winner is announced.
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The method `model_change_handler` calls the appropriate `View` method to display
    a message that announces the winner.
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Model class
  id: totrans-437
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There aren't many changes in the `Model` class. The only significant change
    is the highlighted line of the given code (the call to `pub.sendMessage`) in the
    `enter_hut` method. The details of the other methods are not shown. These methods
    are shown with their code collapsed in the editor.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: '![The Model class](img/B05034_10_32.jpg)'
  id: totrans-439
  prefs: []
  type: TYPE_IMG
- en: Compare this method against the one we wrote in the first project. Notice that
    it does not call `View.announce_winner` directly. Instead, it notifies the `Controller`
    instance using the `pub.sendMessage()`. The rest of the code remains unchanged,
    and you can have a look at the `hutgame_mvc.py` file for further details.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-441
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As noted in the section *Communication between View and Model*, you could potentially
    use the same publish-subscribe framework to notify the `Model` state changes to
    the `View` and vice versa.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-443
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Object-relational mapper (ORM)**:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: Simply put, it is a library that enables you to use an object-oriented language
    like Python to access and update the data sitting in a database. In Python, DJango
    ORM and SQLAlchemy are among the popular ORM libraries. You can do a web search
    on these libraries to find useful resources.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: 'Model classes and ORMs: This book does not cover anything related to web or
    database application programming, but it is worth mentioning the following. It
    is quite common for the `Model` classes to inherit from the ORMs, and represent
    database tables where each object is a row in the table. Writing unit tests for
    such systems could be a challenge, as you typically don''t want to actually hit
    the database every time these tests run. In [Chapter 5](ch05.html "Chapter 5. Unit
    Testing and Refactoring"), *Unit Testing and Refactoring* we saw how to use Python''s
    mock library. Quite often, mock is useful for unit testing such systems (it is
    not covered in this book).'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: The View class
  id: totrans-447
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `View` class is illustrated next. The only significant change is the method
    by the name `set_callbacks`. The other methods are shown with their code collapsed.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: '![The View class](img/B05034_10_33.jpg)'
  id: totrans-449
  prefs: []
  type: TYPE_IMG
- en: 'Recall that in the `Controller.__init__` method, we have the following code:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The preceding code states that the `radio_btn_pressed` attribute of the `View`
    class represents the method `radio_btn_pressed()` of the `Controller` class. The
    rest of the code is identical to the one seen in the first project.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: Running the application
  id: totrans-453
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this project, we did not add any new features to the GUI. The idea was to
    just show a rudimentary example on implementing the MVC architecture. You can
    run this application as follows:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This should show the same GUI window and features as in the first project.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: Testing GUI applications
  id: totrans-457
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a complex and feature-rich GUI application, the user is presented with many
    choices of widgets, menus, keyboard shortcuts, and so on. As seen earlier in the
    chapter, the event-driven nature of GUI programs lets the user dictate the program
    flow. This often presents many possible ways for the user to perform certain operations
    to arrive at the desired output.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-459
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It should be noted that we are not going to write any code here. This is just
    a high-level discussion that touches upon a few important testing considerations.
    For further learning on this topic, start with the following wiki page: [https://en.wikipedia.org/wiki/Graphical_user_interface_testing](https://en.wikipedia.org/wiki/Graphical_user_interface_testing).'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: Imagine a GUI application that allows selecting some object in the application
    window, for example, a folder icon on the desktop. The user can hover the mouse
    over the icon to highlight that object, and then click on it to select it. Alternatively,
    he can do a window selection, where a selection window is drawn around the object
    to select it. Yet another alternative could be using a combination of keys on
    the keyboard. While the user is happy that he can accomplish the task in different
    ways, it becomes a challenge for the developer to write a bug-free code.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: The nature of event-driven programming makes it difficult to write a robust
    code and comprehensive tests to account for the majority of the user input scenarios.
    The bugs would creep in one way or the other. Of course, this varies depending
    on the application and testing strategy, but it is typically a problem for large
    and complex GUI applications.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: Testing considerations
  id: totrans-463
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are various testing strategies to make the GUI application code more robust.
    Let's touch upon a few important testing considerations.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing and MVC
  id: totrans-465
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A unit test helps you test an individual chunk of the code. An integration test
    is where you have many unit tests grouped together to test a larger functionality.
    In a regression test, you typically have a combination of unit and integration
    tests. Here, the tests are rerun to ensure that nothing is broken. A good regression
    test framework is crucial as the first line of defense against the bugs. Unit
    testing generally helps in addressing some common problems. In an earlier chapter,
    we already covered this topic with examples from a command-line application.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: The MVC architecture of the GUI program further helps in making the code robust.
    The separation of concerns or breaking down of the code into the model, view,
    and controller components allows us to write unit tests for particular types of
    error. For example, in some applications, you may anticipate `ZeroDivisionError`
    in the `Model` class instead of the `View` class. So you could write focused unit
    tests for the `Model` class to gracefully handle such situations.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: Manual testing
  id: totrans-468
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While having a good regression test suite helps with the common issues, the
    event-driven nature of the program often presents scenarios that are not accounted
    for. In manual testing, the software tester manually checks the working of the
    application by playing with different features provided in the GUI. If something
    is not working as expected, the tester creates a bug report to document the instructions
    to reproduce the problem. Many hidden bugs surface in the manual testing phase.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: With the growing complexity of the program, the repetitive manual testing job
    becomes overwhelming for the testers. This is where automated GUI testing comes
    to the rescue.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: Automated GUI testing
  id: totrans-471
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here, the testing tool records the user actions to create tests. If you run
    such a test, the user actions are repeated automatically in the same sequence.
    This allows quick identification of the broken functionality.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-473
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Automated testing should not replace manual testing. Unless the tool has artificial
    intelligence built into it, you still need someone to test the new features, and
    use the existing ones in ways not tried before. In general, automated testing
    should complement the manual GUI testing activity.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: There are several open source and commercial tools available for automated GUI
    testing in Python. The following table summarizes a few prominent, freely available
    tools for GUI test automation. For a comprehensive list, see the Python wiki page
    at [https://wiki.python.org/moin/PythonTestingToolsTaxonomy](https://wiki.python.org/moin/PythonTestingToolsTaxonomy).
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: '| Tool name and link | Notes |'
  id: totrans-476
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-477
  prefs: []
  type: TYPE_TB
- en: '| Sikuli (SikuliX) [http://www.sikuli.org/](http://www.sikuli.org/) | Supported
    on Windows, Mac, and some Linux OS. Visit the website to check if your OS is supported.
    |'
  id: totrans-478
  prefs: []
  type: TYPE_TB
- en: '| StoryText [https://pypi.python.org/pypi/StoryText](https://pypi.python.org/pypi/StoryText)
    | Supported GUI frameworks include Tkinter, PyGTK, wxPython, and others. See the
    website for the complete list. |'
  id: totrans-479
  prefs: []
  type: TYPE_TB
- en: '| Dogtail [https://fedorahosted.org/dogtail/](https://fedorahosted.org/dogtail/)
    | Intended for Linux OS like Fedora. Check if it is compatible with your OS. |'
  id: totrans-480
  prefs: []
  type: TYPE_TB
- en: One of the frailties of such automated testing systems is that the innocent-looking
    GUI changes may require you to change a lot of tests, and depending on the complexity
    of your GUI application, this could be a hassle.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-482
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here is a list of a few things you could do to further improve the GUI application.
    With one exception, the solutions are not provided for these exercises.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: Put the `Model`, `View` and, `Controller` classes in their own modules!
  id: totrans-484
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the publish-subscribe API for communication from `View` to `Controller`.
    You can refer to the file `hutgame_mvc_pubsub.py` for a solution.
  id: totrans-485
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add more widgets such as a menu bar and buttons. Implement the **Restart Game**
    button. When clicked, the game should restart. Do the following when this button
    is clicked:'
  id: totrans-486
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Randomly distribute the occupants again by calling `occupy_huts()`.
  id: totrans-487
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Clear the state of the radio buttons. All the buttons should be deselected.
  id: totrans-488
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Add exception handling to the application.
  id: totrans-489
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try to generalize the `View.add_callbacks` method so that it can be used to
    set more callback functions.
  id: totrans-490
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-491
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This book has touched upon several important aspects of application development.
    The key concepts were taught primarily by developing command-line applications.
    As noted earlier in the chapter, there are many applications that require you
    to learn domain-specific techniques. For example, in this chapter, we learned
    about the MVC architecture commonly implemented in GUI applications. Let''s conclude
    this chapter, and hence the book, with a brief discussion on some of the important
    application domains. This will just give you some useful pointers (with lots of
    links!) to the relevant libraries or application frameworks. To avoid clutter,
    the URLs with further information are provided separately at the end of this section.
    The following is a list of other important application domains; however, this
    is far from being an exhaustive list:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: 'Web and mobile application development:'
  id: totrans-493
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These are important application development domains. To learn Python Web application
    development, you can start exploring the Flask or DJango frameworks in Python.
    Knowledge of MVC will also help you here. For mobile application development,
    the kivy library is probably a good start.
  id: totrans-494
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Applications involving databases:'
  id: totrans-495
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A **database management system** (**DBMS**) is another important application
    domain. In a nutshell, DBMS provides you a way to create, access, and manage your
    data. Python has several libraries that enable talking to a database.
  id: totrans-496
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: SQLite3 is a simple, light-weight relational database system. The module sqlite3
    is a built-in Python module that provides a DB-API 2.0 compliant SQL interface.
    There are several client libraries written in Python that provide a way to talk
    to a database. For example, the PyMongo module provides tools to work with MongoDB,
    and so on.
  id: totrans-497
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Machine and deep learning:'
  id: totrans-498
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the data science domain, the use of machine learning and deep learning libraries
    is growing rapidly. The knowledge of GPU programming would help here.
  id: totrans-499
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Tip
  id: totrans-500
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Data science applications almost always involve visualizing some data. It is
    very convenient to use IPython or Jupyter notebooks to write and share interactive
    data science applications. See [http://jupyter.org/](http://jupyter.org/)for more
    details.
  id: totrans-501
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For machine learning, you can explore Apache Spark. This is a general-purpose
    cluster computing system that provides high-level APIs in Python and other languages.
    MLlib is Apache Spark's scalable machine learning library. For deep-learning applications,
    Caffe and Tensorflow are among the popular deep-learning frameworks.
  id: totrans-502
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Internet of Things:'
  id: totrans-503
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is is yet another rapidly emerging field where Python is one of the favored
    languages for developing applications. Here you could use Python to not only process
    data (Analytics applications) on the server side but also have a Python client
    running on the end device. You can find use of the publish-subscribe messaging
    pattern in such applications, where the device publishes data to a topic, and
    the server side application is a subscriber that receives this data.
  id: totrans-504
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Multimedia and game applications:'
  id: totrans-505
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This is broad topic, and there are several frameworks and libraries available
    for developing multimedia applications:'
  id: totrans-506
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Python wiki documents many tools that deal with audio and video processing.
    **GStreamer**, **MoviePy**, and **MLT** are among the popular frameworks. See
    also the PyMedia module.
  id: totrans-507
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: There are quite a few options for image processing. Check out scikit-image,
    Opencv, and pillow (a fork of Python Imaging Library or PIL).
  id: totrans-508
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many libraries useful for developing game- and animation-related applications.
    Check out PyGame and Pyglet. Again, you can find a comprehensive list on the Python
    wiki page.
  id: totrans-509
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The following table lists a few useful web links that provide more information
    on various tools or domains discussed earlier.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-511
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At the time of writing this book, all the web links (URLs) presented throughout
    the book are accessible. As noted in [Chapter 1](ch01.html "Chapter 1. Developing
    Simple Applications"), *Developing Simple Applications*, these links might end
    up being broken over time. If that ever happens, do a web search with the appropriate
    search terms. For example, if you find the link to the PyMongo module broken,
    you can Google search PyMongo Python MongoDB to find some useful resources!
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: '| Tool or application domain | Web link for further information |'
  id: totrans-513
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-514
  prefs: []
  type: TYPE_TB
- en: '| Flask | [http://flask.pocoo.org](http://flask.pocoo.org) |'
  id: totrans-515
  prefs: []
  type: TYPE_TB
- en: '| Django | [https://www.djangoproject.com](https://www.djangoproject.com) |'
  id: totrans-516
  prefs: []
  type: TYPE_TB
- en: '| Kivy | [https://kivy.org](https://kivy.org) |'
  id: totrans-517
  prefs: []
  type: TYPE_TB
- en: '| sqlite3 | [https://docs.python.org/3/library/sqlite3.html](https://docs.python.org/3/library/sqlite3.html)
    |'
  id: totrans-518
  prefs: []
  type: TYPE_TB
- en: '| PyMongo | [https://api.mongodb.com/python/current/](https://api.mongodb.com/python/current/)
    |'
  id: totrans-519
  prefs: []
  type: TYPE_TB
- en: '| Jupyter notebook | [http://jupyter.org/](http://jupyter.org/) |'
  id: totrans-520
  prefs: []
  type: TYPE_TB
- en: '| Apache Spark | [https://spark.apache.org](https://spark.apache.org) |'
  id: totrans-521
  prefs: []
  type: TYPE_TB
- en: '| Caffe framework | [http://caffe.berkeleyvision.org](http://caffe.berkeleyvision.org)
    |'
  id: totrans-522
  prefs: []
  type: TYPE_TB
- en: '| Tensorflow | [https://www.tensorflow.org/](https://www.tensorflow.org/) |'
  id: totrans-523
  prefs: []
  type: TYPE_TB
- en: '| **Internet of Things** (**IoT**) | [https://en.wikipedia.org/wiki/Internet_of_things](https://en.wikipedia.org/wiki/Internet_of_things)
    |'
  id: totrans-524
  prefs: []
  type: TYPE_TB
- en: '| Audio, video processing | [https://wiki.python.org/moin/AudioVideo](https://wiki.python.org/moin/AudioVideo)
    |'
  id: totrans-525
  prefs: []
  type: TYPE_TB
- en: '| Game and animations | [https://wiki.python.org/moin/PythonGameLibraries](https://wiki.python.org/moin/PythonGameLibraries)
    |'
  id: totrans-526
  prefs: []
  type: TYPE_TB
- en: Summary
  id: totrans-527
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter served as an introduction to the Python GUI programming. Starting
    with an overview of the different GUI frameworks, it touched upon some important
    practical design considerations for developing user interfaces. You saw what event-driven
    programming is, and learned about events and event handling. With a quick introduction
    to Tkinter library, we developed a simple Hut Game, an equivalent GUI version
    of the first ever application developed in [Chapter 1](ch01.html "Chapter 1. Developing
    Simple Applications"), *Developing Simple Applications*.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: The second half of the chapter introduced you to the MVC architecture, and we
    transformed the Hut Game to implement this architecture. The chapter concluded
    with a high-level discussion on testing GUI applications.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
- en: '![Summary](img/B05034_10_34.jpg)'
  id: totrans-530
  prefs: []
  type: TYPE_IMG
