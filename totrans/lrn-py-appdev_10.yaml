- en: Chapter 10. Simple GUI Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the chapters so far were about learning to write better application code
    in Python. Starting with a simple program, we saw how to develop robust and efficient
    applications. We touched upon several important areas of software development.
    More specifically, we covered exception handling, deploying applications, documentation,
    adopting best practices, unit testing, refactoring, design patterns, and performance
    improvements. The key concepts were explained using various command-line applications
    that were progressively improved.
  prefs: []
  type: TYPE_NORMAL
- en: Where do we go from here? Beyond the command line, there are applications that
    present an interactive user interface. Desktop, mobile GUI applications, or web
    applications come under this category. Also, there are applications targeted for
    specific domains such as network and database programming. These are broad topics,
    and each has its own set of goodies that will help make the application robust.
    Nonetheless, the techniques we have learned in this book provide a solid foundation
    for all these domains.
  prefs: []
  type: TYPE_NORMAL
- en: This last chapter is designed to give you just a flavor of one such domain.
    It will be a superficial introduction to desktop GUI application development using
    Python.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: GUI programming is too big of a beast to fit into a single chapter. Let's do
    that anyway, keeping in mind that there is plenty of opportunity to learn beyond
    what is discussed here. The chapter won't show you how to create full-fledged,
    complex GUI applications. Rather, we will just dip a toe into GUI application
    development using Python's Tkinter library.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how the rest of the chapter is organized:'
  prefs: []
  type: TYPE_NORMAL
- en: The chapter will start with an overview of the available GUI frameworks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we will see what event-driven programming is, followed by a primer on
    the Tkinter library.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What follows next is our first project, a simple GUI application that uses Tkinter.
    It is essentially the GUI version of the first ever application we developed in
    [Chapter 1](ch01.html "Chapter 1. Developing Simple Applications"), *Developing
    Simple Applications*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next section will serve as an introduction to the **Model-view-controller**
    (**MVC**) architecture. This will be followed by our second project, where the
    earlier application is rewritten to implement the MVC architecture.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The chapter will also talk about testing GUI applications. This will be a high-level
    discussion, and won't involve writing any code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This being the last chapter, we will conclude it, and hence the book, with a
    brief discussion on various application frontiers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overview of GUI frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A user interface is typically something that a user can see and use to communicate
    with the application. So far, we have presented a text-based user interface. For
    example, in the *Attack of the Orcs* application, the user was prompted to specify
    a hut number, and based on the number entered, further actions were taken.
  prefs: []
  type: TYPE_NORMAL
- en: A **Graphical User Interface** (**GUI**), on the other hand, presents an interface
    to the user that may have buttons, icons, text fields, graphics, and so on. There
    are several Python GUI frameworks available. Many of these are based on cross-platform
    technologies such as Tk, Qt, wxWidgets, and others. Let's briefly discuss some
    of the most popular frameworks. The purpose is to just make you aware of the GUI
    technologies available.
  prefs: []
  type: TYPE_NORMAL
- en: Tkinter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Tkinter** provides Python bindings or interface to the open source Tk GUI
    widget toolkit. For more information on Tk, see its official website, [http://www.tcl.tk/](http://www.tcl.tk/).
    It is available as a standard module in Python. What this means is that as long
    as Python is installed, we do not need any additional installations to use it.
    In this book, we will demonstrate basic GUI concepts using the Tkinter library.'
  prefs: []
  type: TYPE_NORMAL
- en: PyQt
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**PyQt** ([https://wiki.python.org/moin/PyQt](https://wiki.python.org/moin/PyQt))
    is a widely used Python GUI library. It is one of the most mature frameworks out
    there. It essentially provides Python bindings for a popular Qt GUI application
    development framework. In order to use this framework, you need to install Qt
    first.'
  prefs: []
  type: TYPE_NORMAL
- en: It is worth noting here that Qt has different licensing schemes depending on
    the project. For example, if your project is an open source distribution, licensed
    under the terms of LGPL or GPL, you can use Qt freely. If you are using it for
    a commercial purpose, you have to purchase a license. Visit the Qt website, [https://www.qt.io/](https://www.qt.io/),
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: PySide
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PySide is another Python binding for the Qt GUI framework. It is a free software,
    released under the LGPL license. PySide supports Windows, Mac, and Linux OS. For
    more information, see [https://wiki.qt.io/PySide](https://wiki.qt.io/PySide).
  prefs: []
  type: TYPE_NORMAL
- en: Kivy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is one of the most promising open source frameworks for creating cross-platform
    interactive user interfaces. With kivy, you can rapidly develop native multi-touch
    apps for mobile or desktop. It provides a design language called Kv for GUI design.
    The kivy website lists many supported operating systems including Windows, Mac
    OS X , Ubuntu, and Android for which an installer is available.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are using a different OS not listed on the kivy website, the installation
    could be a challenge. For example, at the time of writing this book, there is
    no installer available for **Red Hat Enterprise Linux** (**RHEL**) version 6.x.
    The other option is to build it from source code. But that could be a challenge
    if you are not familiar with the code compilation and building process. If you
    really want to use it, you could also install it in a virtual machine running
    one of the supported OS.
  prefs: []
  type: TYPE_NORMAL
- en: wxPython
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This package provides a wrapper for **wxWidgets**, a cross-platform GUI library.
    It is an open source toolkit, and according to the project website ([http://www.wxpython.org](http://www.wxpython.org)),
    the supported platforms include 32-bit Windows, many Unix-like operating systems,
    and Mac OS X.
  prefs: []
  type: TYPE_NORMAL
- en: While there are many choices available at our disposal, in this chapter we will
    use the built-in Tkinter module mentioned earlier. The scope will be limited to
    developing a simple application that demonstrates some of the major components
    of GUI-based application development.
  prefs: []
  type: TYPE_NORMAL
- en: GUI programming design considerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although the focus of this chapter is on developing simple GUI applications,
    it is worth taking a moment to briefly discuss some important practical design
    considerations or guidelines for developing user interfaces. These guidelines
    will also come in handy for web-based or mobile applications. Some aspects that
    we are about to discuss should actually be part of your GUI application development
    life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding user requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first and foremost task is to put yourself in the shoes of the end user.
    You are developing the GUI application for consumption by the end users. It is
    important to take their feedback on the features that they would like to see.
    This is typically a part of requirements gathering.
  prefs: []
  type: TYPE_NORMAL
- en: Developing a user story
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: OK, so you know what features are requested, and have prepared a list that would
    be supported in the upcoming version. It is often useful to prepare a mock user
    interface that illustrates how various features could be accessed and how they
    interact. The mock user interface could be in the form of a simple presentation.
    You can then take feedback from the development team as well as from the key users
    of the product. This will allow you to immediately identify the problems, if any,
    or refine your design strategy even before writing a single line of code. Such
    discussions with the key stakeholders could also unearth future requirements that
    you have not thought through. This, in turn, will help you refine the software
    architecture to make provisions for such requirements. Next, let's learn about
    some of the design principles.
  prefs: []
  type: TYPE_NORMAL
- en: Simplicity and accessibility
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The GUI should be simple enough to make the most frequently used tasks easy
    to access. What the developers think as *simple* may not always go well with the
    end users. Getting user feedback and going through design iterations play an important
    role. In general, keep the following things in mind when designing for simplicity:'
  prefs: []
  type: TYPE_NORMAL
- en: It matters how you lay out the various components in the application window.
    Is it intuitive? Is it easily accessible?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Place frequently used and important functionality prominently in the UI.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try to hide advanced or less frequently used features. If possible, you could
    create an expert level mode in your GUI where these features appear prominently.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Have default values wherever applicable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common user actions should be easy to execute. For example, if changing the
    background color is a common task, allow users to access this option with a click
    of a button or with a keyboard shortcut.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try not to put too many things in the default display. Reduce the clutter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, this is not a complete list, and things will change depending on
    the application and the domain.
  prefs: []
  type: TYPE_NORMAL
- en: Consistency
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The user interface should be consistent. If you have similar features, they
    should have a similar look and feel, similar steps to execute, and so on. The
    placement of standard features or functions should not change. For example, in
    a text editor, the **Open** button is typically placed near the top-left corner
    of the application window. This default position should remain constant.
  prefs: []
  type: TYPE_NORMAL
- en: Predictability and familiarity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a button is clicked, the user should be able to predict the next course
    of action. A trivial example is the **Save As...** button—when clicked, the user
    anticipates a dialog with the option to specify a location and file format. Why?
    Because he or she is familiar with using a similar function in some other application.
    Further, the user would anticipate some default directory location to save the
    file. The UI should not surprise the user by changing this behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, when you design an icon, it should speak for itself. For example,
    a gear icon typically indicates some sort of configurable settings. The UI design
    should be such that the user can easily guess the next action to perform in a
    particular situation, be it exiting the current mode or going back to the previous
    step, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Miscellaneous design considerations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have covered some of the important factors you should know before designing
    a GUI. There are many other design principles. Some of these principles are tied
    to the aspects that we''ve already discussed. A few of these can be listed as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The GUI should have a visual appeal and clarity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should be comprehensible. In other words, new users should quickly get up
    to speed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should anticipate common problems, and gracefully handle user errors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event-driven programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In an algorithm-driven program, the flow of the program is dictated by the predefined
    steps written in that program. The program may prompt the user with these instructions
    for an input. An example is a command-line application asking for user input in
    a predefined order.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, applications with a graphical user interface let the user dictate
    the program flow. The application waits for the user actions, and then responds
    to those actions. For example, if you are reading a PDF copy of a book, you can
    perform actions like jumping to the next page, zooming-in, scrolling down, or
    closing the window by clicking on the appropriate buttons. Here, you are essentially
    telling the application what to do next. This is called event-driven programming.
    Here, the control flow of the program is governed by the triggered events. The
    application responds to these events as they occur. The response could be changing
    the state of the graphical element or running some background task, and so on.
    For example, if the user clicks a button representing the next page, the application
    will display the next page of the book. Next, let's briefly talk about a few important
    concepts in event-driven programming.
  prefs: []
  type: TYPE_NORMAL
- en: Event
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In simple terms, an event represents an action happening inside the GUI window.
    An event could be triggered by various sources. For example, when a user clicks
    a mouse button, it generates a click event; pressing a key on the keyboard is
    recognized as another event, and so on. An event could also be generated without
    a direct user input. For example, the application might have completed running
    some calculations in the background, and now wants to update the contents presented
    by the GUI. This could automatically trigger some update event that would redraw
    the view.
  prefs: []
  type: TYPE_NORMAL
- en: Event handling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When an event is triggered, the application responds to that event. For example,
    when you click on the close button of a browser, you expect the browser window
    to close. In this example, closing the window is the application's response to
    the click event generated due to user action. In other words, the application
    has a *listener* object that *handles* this click event. Every GUI framework provides
    a way to *bind* (or *connect*) an event to a handling function.
  prefs: []
  type: TYPE_NORMAL
- en: Event loop
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The event loop is the main controlling loop of the GUI program. When you start
    the application, the main loop is started, and it waits for the events to occur.
    It monitors the event sources, and dispatches the events when they occur.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this short introduction, let''s summarize what we have learned about event-driven
    programming:'
  prefs: []
  type: TYPE_NORMAL
- en: The overall flow of program execution is governed by events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The application runs (the main loop starts) and waits for events to occur
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When an event is triggered, the application code, which is listening to the
    events, responds by running a specific handling function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thus, the flow of a program depends on the triggered events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GUI programming with Tkinter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned earlier, a GUI provides a way to interact with an application.
    Instead of a text-based input, the user is presented with elements such as text
    boxes, radio buttons, tool bars, and so on. This section will introduce you to
    the basics of GUI programming with Tkinter. This library is available as a standard
    module in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Tkinter documentation links
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's document some links for a handy reference. The official Tkinter documentation
    page can be found at [https://docs.python.org/3/library/tkinter.html#module-tkinter](https://docs.python.org/3/library/tkinter.html#module-tkinter).
    This page lists several external references. A good introduction is available
    at [http://effbot.org/tkinterbook](http://effbot.org/tkinterbook). Of course,
    you can always perform a web search with search terms like python and Tkinter
    to find more resources.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, you can quickly find the supported functionality and documentation
    using the Python interpreter!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command lists the supported classes, functions, and so on. To
    pull out a docstring, you can call the `__doc__` on a given attribute. The following
    example shows a docstring for `mainloop()` in Tkinter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The mainloop() in Tkinter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the discussion on event-driven programming, we learned about the main controlling
    loop. Writing an event loop or the main loop in Tkinter is very simple. The following
    code fragment shows the main loop in action. This is the simplest possible GUI
    application that you can write using Tkinter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s talk through this code:'
  prefs: []
  type: TYPE_NORMAL
- en: The first statement imports the `Tk` class from the `tkinter` module.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we create a main application window by instantiating the `Tk` class. It
    is represented by the variable `mainwin`. In Tkinter terminology, it is often
    referred to as root or master. In this chapter, we will call it `mainwin`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The main event loop is started by calling the `mainloop()` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The output of this simple program is shown next. You can run it as any other
    Python program. The code can also be found in the supporting material for this
    chapter (see the file `mainloop_example.py`). Depending on your operating system
    and environment, the look and feel of this window may vary.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '![The mainloop() in Tkinter](img/B05034_10_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Python 2.x, there is a minor change in the `import` statement. The module
    `tkinter` is available as Tkinter (first letter capital) for Python version 2\.
    The supporting code already takes care of this with the following conditional
    `import`. The rest of the code remains the same.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Simple GUI application – Take 1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We just saw how to start a `mainloop()` method. Let's go one step further, and
    add some widgets to this application. Observe the following code. You can also
    see the file `simple_application_1.py` in this chapter's code bundle.
  prefs: []
  type: TYPE_NORMAL
- en: '![Simple GUI application – Take 1](img/B05034_10_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The code comments pretty much explain what the code does. It is summarized
    next:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by importing the necessary classes and options from the `tkinter`
    module. Note that you could also do the following: `from tkinter import *`. However,
    the best practices that we saw earlier in the book do not recommend doing that.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, the main window size is specified using the `geometry()` method. This
    is optional.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next few lines of the code create two widgets, a `Label` widget that will
    show the text `Hello World!`, and a `Button`, which will terminate the application
    on being clicked.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need some way to arrange these widgets inside the application window. This
    is referred to as geometry or layout management. There are three options to do
    that. What is illustrated here is the `pack()` method. More on geometry management
    later.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the **Exit** button is clicked, we need some way to process this event.
    This is accomplished with the command option that is assigned to a callback function.
    In this example, we simply terminate the application window and also the `mainloop()`
    by calling `mainwin.destroy()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Recall that Python functions are first-class objects. See [Chapter 6](ch06.html
    "Chapter 6. Design Patterns"), *Design Patterns* where we discussed on this. The
    callback function, `mainwin.destroy`, is assigned to the command variable.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Running this application from the command line displays a simple GUI window
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '![Simple GUI application – Take 1](img/B05034_10_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you click on the **Exit** button, it will terminate the main application
    window.
  prefs: []
  type: TYPE_NORMAL
- en: '| *Looks like Sir Foo is not quite impressed with this simple script...* |'
  prefs: []
  type: TYPE_TB
- en: '![Simple GUI application – Take 1](img/B05034_10_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '| *For bigger and complex applications, it is better to follow the object-oriented
    programming approach.**Let''s rewrite this application, and wrap it in a class.
    However, keep in mind that it is just a baby step towards creating a better application.
    Later in the chapter, you will learn about the MVC architecture, and a basic example
    on implementing it in your GUI application.* |'
  prefs: []
  type: TYPE_TB
- en: Simple GUI application – Take 2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is time to add some object-oriented flavor to the mix. The application in
    the previous section can be rewritten as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Simple GUI application – Take 2](img/B05034_10_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s briefly discuss the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: Compare this code against the previous code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `MyGame` class is where we create the widgets and define the main logic.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notice that the command callback function for the button is set to `exit_btn_callback`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What this means is that when the **Exit** button is pressed, it will invoke
    `exit_btn_callback()` instead of calling `mainwin.destroy()` directly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is just to show you how to specify a different callback function. You can
    always set it back to `command=mainwin.destroy()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The rest of the code is self-explanatory. You can execute it to get the same
    `Hello world!` window as in the first program. The command is shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `simple_application_2.py` file in the supporting code bundle essentially
    has the program we just reviewed.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In all the examples, we will use the `Tk` instance `mainwin` as the master
    or parent object of the widgets created. In practice, it is often useful to create
    a container to hold other widgets in the GUI. The container could be an instance
    of the `Frame` class or any other widget depending on the application. For example,
    you could write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now that we know how to create a simple application with a graphical user interface,
    let's move ahead and talk about the various widgets available in the Tkinter library.
  prefs: []
  type: TYPE_NORMAL
- en: GUI Widgets in Tkinter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will briefly cover some of the frequently used widgets.
    Note that the widgets we are about to cover are not specific to a GUI library.
    However, the following discussion is tailored for the Tkinter library. For example,
    you will find a `Menu` widget in many GUI libraries. Tkinter provides it with
    the class `Menu`, the PyQt library calls it `QMenu`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'What we are about to see is far from being a comprehensive list. You are encouraged
    to explore the following wiki page that lists several other GUI elements: [https://en.wikipedia.org/wiki/List_of_graphical_user_interface_elements](https://en.wikipedia.org/wiki/List_of_graphical_user_interface_elements).'
  prefs: []
  type: TYPE_NORMAL
- en: A widget is an element of a graphical user interface that enables user interaction.
    In other words, the user can do certain actions like pressing a button and interacting
    with the GUI.
  prefs: []
  type: TYPE_NORMAL
- en: We already saw how to create the `Label` and `Button` widgets. The following
    table summarizes some important widget classes in Tkinter.
  prefs: []
  type: TYPE_NORMAL
- en: '| Widget Class | Basic Syntax | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Menu` |'
  prefs: []
  type: TYPE_TB
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '| This widget represents a menu, such as a menu bar or a pop-up menu. It contains
    menu items. |'
  prefs: []
  type: TYPE_TB
- en: '| `Frame` |'
  prefs: []
  type: TYPE_TB
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '| This is typically used as a container to hold other widgets. The frame widget
    also has its own grid layout, and like many other widgets, you can specify the
    background color, border, and other properties. |'
  prefs: []
  type: TYPE_TB
- en: '| `Canvas` |'
  prefs: []
  type: TYPE_TB
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '| This is a graphics widget. This is where you can draw or write stuff. For
    example, you can render shapes, plots, images, or use this widget to write text.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Label` |'
  prefs: []
  type: TYPE_TB
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '| In a label, you can add a text or an image. When you click on a label, no
    event is triggered. Instead, you can update a label in response to some other
    event generated elsewhere. |'
  prefs: []
  type: TYPE_TB
- en: '| `Button` |'
  prefs: []
  type: TYPE_TB
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The optional `command` argument could also be assigned to any user-defined function.
    | A simple button widget. When pressed or released, it triggers an event. |
  prefs: []
  type: TYPE_NORMAL
- en: '| `Radiobutton` |'
  prefs: []
  type: TYPE_TB
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: A group of radio buttons is tied to a common variable, `var`. When you click
    on a radio button, the value of that variable is changed to a predefined one given
    by the value. | The radio button widget allows a user to choose only a single
    value from a given set of values. It can contain a text or an image. |
  prefs: []
  type: TYPE_NORMAL
- en: '| `Checkbutton` |'
  prefs: []
  type: TYPE_TB
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The variable `var` has value of 1 when the check button is selected, otherwise
    the value is set to 0\. This is the default behavior. | This widget allows setting
    two different values to a variable. Typical usage is to toggle the state (on or
    off selection) of a variable. |
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then add elements to this list box using the `insert()` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '| This widget is used for showing a list of alternatives. The user can select
    one or many elements from the `Listbox` widget. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '| This is a text entry widget that allows you to display or input text. In
    some other GUI frameworks, it is referred to as a line-edit widget. |'
  prefs: []
  type: TYPE_TB
- en: The basic syntax shown in the previous table is for illustrative purpose only.
    You can specify many other options. The `parent` argument given to the widget
    represents the parent or the base widget.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this book, we will just use the bare minimum options while creating widgets.
    You could further configure each of these widgets by specifying the appropriate
    optional arguments, or by calling the relevant methods. For further learning,
    follow the various references listed on the official Tkinter documentation page
    at the following link: [https://docs.python.org/3/library/tkinter.html#module-tkinter](https://docs.python.org/3/library/tkinter.html#module-tkinter).'
  prefs: []
  type: TYPE_NORMAL
- en: Geometry management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Layout or geometry management is about organizing various widgets within the
    GUI. In Tkinter, this layout management is accomplished with something referred
    to as geometry managers. There are three different geometry managers to organize
    the widgets, namely *grid*, *pack*, and *place*. Among these, the grid manager
    is the recommended choice. Further in this chapter, we will demonstrate the use
    of a grid manager.
  prefs: []
  type: TYPE_NORMAL
- en: Grid geometry manager
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The grid manager offers flexibility in arranging various widgets, and is also
    very easy to use.
  prefs: []
  type: TYPE_NORMAL
- en: The parent widget of the grid manager (for example, a frame or a dialog) is
    treated as a table with rows and columns.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The smallest element of this table is a cell, which has a height and a width.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can place other widgets in such cells. It is also possible to have a widget
    that spans more than one cells.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The height of each row in the table is determined by the height of the tallest
    cell (or a widget) in that cell. Likewise, the width of each column in this table
    is governed by the widest cell in that column.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each row and column in a grid geometry manager can be configured with a weight
    option. Weight determines how much a specific row or column can expand if the
    master widget has free space available. The weight can be specified using the
    methods `grid_rowconfigure` or `grid_columnconfigure` for rows and columns respectively.
    The default value for weight is 0.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot shows a representative grid layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Grid geometry manager](img/B05034_10_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding image, some `Label` widgets are arranged in a grid layout.
    The label text **Cell[0,0]** indicates that we have put this label in row 0 and
    column 0 of the grid. Observe that for **Cell[3,0]**, it shows a label whose width
    occupies four columns. Similarly, **Cell [1,3]** is a label whose height spans
    two rows.
  prefs: []
  type: TYPE_NORMAL
- en: Pack geometry manager
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In our first Tkinter application, we''ve already used the pack geometry manager
    to arrange the widgets. As a refresher, here is the relevant piece of code (the
    `pack` method):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The pack geometry manager provides options such as expand, fill, and side to
    control widget placement. It is useful when you want to arrange multiple widgets,
    either side by side or overlapping each other. The other use case is when you
    want the widget to occupy the whole container that is holding it.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using both grid and pack geometry manager in the same main window could lead
    to undesirable results. Do not use these layout managers together.
  prefs: []
  type: TYPE_NORMAL
- en: Place geometry manager
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The place geometry manager allows you to specify the absolute or relative position
    of the widget and its size. It finds use in some special scenarios. We will not
    be discussing this geometry manager further. In most cases, you could, instead,
    use the grid geometry manager.
  prefs: []
  type: TYPE_NORMAL
- en: Events in Tkinter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's briefly talk about the various events supported in Tkinter, and the syntax
    that describes them.
  prefs: []
  type: TYPE_NORMAL
- en: Event types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following table shows some of the most frequently used event types. Read
    the documentation to learn about other event types not listed here. The next section,
    *Event descriptors*, will elaborate on how to use an event type to describe an
    event.
  prefs: []
  type: TYPE_NORMAL
- en: '| Event name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Button` (or `ButtonPress`) | One of the mouse buttons is pressed. Which
    one? That is determined by the `detail` field of the event descriptor (see the
    next section). |'
  prefs: []
  type: TYPE_TB
- en: '| `ButtonRelease` | One of the mouse buttons (that was pressed earlier) is
    released. |'
  prefs: []
  type: TYPE_TB
- en: '| `Enter` | The mouse pointer entered a widget. This has nothing to do with
    the *Enter* or *return* key on the keyboard. |'
  prefs: []
  type: TYPE_TB
- en: '| `Leave` | The mouse pointer left a widget. |'
  prefs: []
  type: TYPE_TB
- en: '| `KeyPress` | A keyboard key is pressed. Which one? That is determined in
    the `detail` field of the event descriptor. |'
  prefs: []
  type: TYPE_TB
- en: '| `KeyRelease` | A keyboard key is released. |'
  prefs: []
  type: TYPE_TB
- en: '| `FocusIn` | A widget gets an input focus. |'
  prefs: []
  type: TYPE_TB
- en: '| `FocusOut` | A widget no longer has the input focus. |'
  prefs: []
  type: TYPE_TB
- en: Event descriptors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Tkinter has a special syntax for describing an event. It is a string with the
    following general form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The event specified is enclosed within the angular brackets `<>`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The type specifies the type of the event, such as a mouse click.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The modifier and detail specifiers are optional.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The modifier is the event modifier. Imagine that the Control button is pressed
    along with a mouse button. Here, the Control button is the event modifier, whereas
    the mouse button press is the type of the event.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The detail specifier gives more information about the type of the event. If
    the type is a mouse click, the details will describe whether it is the left mouse
    button, the right button, or the middle one.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following table summarizes some of the common event specifiers.
  prefs: []
  type: TYPE_NORMAL
- en: '| Event syntax | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `<Button-1>` | Mouse button 1 pressed (the left mouse button). |'
  prefs: []
  type: TYPE_TB
- en: '| `<Button-2>` | Mouse button 2 pressed (middle button, if available). |'
  prefs: []
  type: TYPE_TB
- en: '| `<Button-3>` | Mouse button 3 pressed (the right-most button). |'
  prefs: []
  type: TYPE_TB
- en: '| `<KeyPress-B>` | The *B* key is pressed. Likewise, you can write for other
    keys, such as `<KeyPress-G>`. |'
  prefs: []
  type: TYPE_TB
- en: '| `<Return>` | Return key pressed. |'
  prefs: []
  type: TYPE_TB
- en: '| `<Configure>` | Size of the widget is changed (for example, window resized).
    The new size is stored as the width and height attributes of the event object.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `<Shift-Button-1>` | The *Shift* key is pressed along with the left mouse
    button. |'
  prefs: []
  type: TYPE_TB
- en: Event object attributes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An instance of the `Event` class holds the information that describes the event.
    The following table lists some important attributes of the `Event` class.
  prefs: []
  type: TYPE_NORMAL
- en: '| Event attribute | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `widget` | The widget object which triggered this event. |'
  prefs: []
  type: TYPE_TB
- en: '| `x`, `y` | The current mouse position in pixels. |'
  prefs: []
  type: TYPE_TB
- en: '| `x_root`, `y_root` | Mouse position in pixels, relative to the top-left corner.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `width`, `height` | The changed size (width and height) for the `<Configure>`
    type of events. |'
  prefs: []
  type: TYPE_TB
- en: Event handling in Tkinter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Earlier in the chapter, we learned about events and event handling (see the
    section *Event-driven programming*). In this section, we will see how to bind
    the various events triggered due to user interactions, with the appropriate handling
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: Command callback (Button widget)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Recall that when we wrote our first Tkinter application, we tied a callback
    function to the `command` argument of the `Button` widget. The relevant line of
    code is reproduced next for easy reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: When you click on the **Exit** button, it calls `mainwin.destroy()`, represented
    by the `command` argument. It should be noted that while the `Button` widget supports
    command callback, this feature is not available for all the supported widgets.
    For that, Tkinter provides the `bind()` method, which is defined on all widgets.
    The `bind()` method is just one of the levels of event binding in Tkinter. Let's
    talk about a few event-binding levels next.
  prefs: []
  type: TYPE_NORMAL
- en: The bind() method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This method provides an instance level binding. It binds an event to a specific
    widget instance. Another way to think of this is as an ability to specify the
    exact GUI element that is sensitive to a particular event. The basic syntax is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: It should be noted that you can also use this method for the `toplevel` window.
  prefs: []
  type: TYPE_NORMAL
- en: For ease of understanding, let's represent the optional argument sequence as
    `even_descriptor` and `func` as `event_handler`. The third optional argument add
    can be specified as a string `+`. It allows you to add a new function to an existing
    binding. We will not discuss the `add` argument here. Refer to the documentation
    for further details.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding statement, `widget` is any widget that generates one or more
    events. For example, the widget could be a `Button`, an `Entry` widget, and the
    like. The `event_descriptor` is the actual event triggered, for instance, a key
    press, or a click, and so on. `event_handler` is the function that gets called
    when the event is triggered.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how to use this method for the `Button` widget, in place of a command
    callback. Apart from the syntax, we also need to define a callback function that
    handles the generated event. Let's rewrite the code illustrated in the section,
    *Simple GUI application*.
  prefs: []
  type: TYPE_NORMAL
- en: '![The bind() method](img/B05034_10_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Observe that we have defined a new event handling function, `exit_btn_clicked()`,
    that takes the event object (`evt`) as an argument. The first argument to bind
    represents the type of event or the event format. In this example, `<Button-1>`
    represents a left mouse button press over the widget. In this chapter, we will
    only use the `bind()` method. But before we go further, let's briefly talk about
    the other levels of binding.
  prefs: []
  type: TYPE_NORMAL
- en: The bind_class() method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This method provides a class-level binding. It binds an event to a specific
    widget class. The basic syntax is shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding syntax, `className` is a string representing the name of the
    widget class. The other arguments are the same as discussed in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that all the `Button` widgets in your application represent some numbers.
    You can configure all of them to respond to the right mouse click event such that
    each returns the square of that number. In this example, you can use the `bind_class`
    method like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Here, it is assumed that you have defined a function, `compute_square`.
  prefs: []
  type: TYPE_NORMAL
- en: The bind_all() method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This method provides an application-level binding. As the name suggests, this
    method binds an event to all the widgets at the application level. For example,
    in some game application, you might want to configure a key to pause the game
    regardless of the widget under focus. In such situations, you can use this method.
    The basic syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Tkinter supports something referred to as bind tags. Every widget has its own
    list of bind tags. These determine the order in which the events associated with
    a widget are processed. The built-in method `bindtags()` can be used to set or
    get the tags associated with a widget. See the documentation for further details.
  prefs: []
  type: TYPE_NORMAL
- en: Project-1 – Attack of the Orcs V10.0.0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '| *You have developed a robust and popular command-line application, **Attack
    of the Orcs**. While the users are happy with the current version, there is a
    new and growing demand. The users now want a graphical user interface for the
    application!* |'
  prefs: []
  type: TYPE_TB
- en: It is time to work on another simple program. Remember the first ever command-line
    application we wrote in [Chapter 1](ch01.html "Chapter 1. Developing Simple Applications"),
    *Developing Simple Applications*? Let's use the same theme, and develop an equivalent
    GUI program.
  prefs: []
  type: TYPE_NORMAL
- en: Background scenario
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As a refresher, here is the game theme we saw in [Chapter 1](ch01.html "Chapter 1. Developing
    Simple Applications"), *Developing Simple Applications*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| *On his way through a dense forest, Sir Foo spotted a small isolated settlement.
    Tired and hoping to replenish his food stock, he decided to take a detour. As
    he approached the village, he saw five huts. There was no one to be seen around.
    Hesitantly, he decided to enter a hut...* |'
  prefs: []
  type: TYPE_TB
- en: Problem statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| *The task is to design a* *simple GUI program. The player selects one of
    the five huts where Sir Foo can rest. The huts are randomly occupied either by
    a friend or an enemy. Some huts might also be left unoccupied. The player wins
    if the selected hut is either unoccupied or has a friendly unit inside.* |'
  prefs: []
  type: TYPE_TB
- en: The following screenshot shows what's coming up. But don't get too excited!
    It is quite a simple game that will help you learn some important GUI programming
    aspects.
  prefs: []
  type: TYPE_NORMAL
- en: '![Problem statement](img/B05034_10_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you click on a hut, it will check who the occupant is, and then pop up
    a message box declaring the winner. That's pretty much it!
  prefs: []
  type: TYPE_NORMAL
- en: Writing the code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will use the code provided in the `hutgame.py` file. Download this file and
    also the two images, `Hut_small.gif` and `Jungle_small.gif` from the code bundle
    for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is recommended that you open the file `hutgame.py` as a handy reference while
    reading the following discussion. Quite often, it is useful to skim through the
    full code in a source code editor for better understanding!
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start with the main execution code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing the code](img/B05034_10_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s talk through this code:'
  prefs: []
  type: TYPE_NORMAL
- en: Compare this with the main execution block in the section *Simple GUI application
    – Take 2*. Notice that there isn't much of a difference.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We set the size and a title for the application window with the `geometry` and
    `title` methods. The `mainwin.resizable` call freezes the window size. This is
    optional, but will make sure the background image nicely fits the window.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `HutGame` class is where we create the widgets and define the main logic.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The main event loop is started by calling `mainloop()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overview of the class HutGame
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before reviewing any code in the class `HutGame`, let''s get the big picture
    first. The important methods of this class are shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Overview of the class HutGame](img/B05034_10_11_uml_hutgame_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As illustrated, these methods can be broadly divided into three groups based
    on the functionality. We will talk about this grouping later when we discuss the
    MVC architecture. Let's review the various methods in this class next.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**A note to more experienced readers!**'
  prefs: []
  type: TYPE_NORMAL
- en: In the following few sections, we will discuss the methods of the class `HutGame`.
    You might find this discussion a bit verbose! Optionally, you can just review
    the code from the file `hutgame.py`. The code is documented reasonably well. If
    something is not clear, come back and read the relevant section!
  prefs: []
  type: TYPE_NORMAL
- en: The __init__ method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Take a look at the code that gets called when `HutGame` is instantiated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The __init__ method](img/B05034_10_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following is a description of the `__init__` method:'
  prefs: []
  type: TYPE_NORMAL
- en: The `PhotoImage` class is used for displaying a background image in widgets
    such as labels, buttons, and so on. It supports the GIF image format. There is
    also a way to load an image using **Python Imaging Library** (**PIL**). We won't
    discuss those details here.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will use `hut_image` on a `RadioButton`, and `village_image` will be set
    as the application background.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `self.setup()` call ensures that widgets are created and appropriately placed
    in the application window.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The occupy_huts method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following method is the same as the one illustrated in the first example
    of [Chapter 1](ch01.html "Chapter 1. Developing Simple Applications"), *Developing
    Simple Applications*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The occupy_huts method](img/B05034_10_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There are exactly five huts. This code essentially populates the `self.huts`
    list with a random choice of occupant from the given `occupants` list.
  prefs: []
  type: TYPE_NORMAL
- en: The create_widgets method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As the name suggests, this method is about creating the widgets for our application.
    Actually, there aren''t many widgets. We just have a label to display some information
    and a bunch of radio buttons to represent the huts. The method is shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The create_widgets method](img/B05034_10_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding method can be explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`self.var` is a Tkinter variable. It is an instance of a variable class supported
    by Tkinter. Here, it represents an integer variable (`IntVar` class). Likewise.
    there are other classes such as `StringVar` to deal with string variables, and
    so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simply put, the Tkinter variables enable tracking changes. We have five radio
    buttons that are tied to the single Tkinter variable, `self.var`. A value option
    can be specified for each radio button. This value gets assigned to `self.var`
    when the radio button is selected.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The dictionary `r_btn_config` is used to set configuration options common to
    all the radio buttons. It is passed as an argument to `Radiobutton`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An example would help in understanding how a radio button works. The button
    `self.r4` has an associated value of `4`, which represents the hut number. When
    you select the button, this value gets assigned to `self.var`. This invokes `self.radio_btn_pressed()`,
    the command callback for the button.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`self.background_label` is used to set a village background for our application
    window. There are other ways to accomplish this. We won''t be discussing such
    customization details in this book.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![The create_widgets method](img/B05034_10_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '| *Certainly! Have a look at the following application window where some of
    these widgets or configuration options are annotated.* |'
  prefs: []
  type: TYPE_TB
- en: '![The create_widgets method](img/B05034_10_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The setup_layout method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following code fragment shows the `setup_layout()` method. and how it is
    invoked in the top-level `setup()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The setup_layout method](img/B05034_10_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The grid layout offers a lot of flexibility in arranging widgets. In this illustration,
    we are just scratching the surface of Tkinter! To gain expertise, you should create
    your own GUI widgets, and experiment with different layout configuration options.
    Refer to the documentation for other available options.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s talk through this code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: Recall that we can assign a relative `weight` to a specific row or a column
    in a grid layout. This is accomplished using the `grid_rowconfigure` and `grid_columnconfigure`
    methods. `weight` determines how much free space the row or column will occupy
    relative to the others. A default value of 0 means it won't grow even if there
    is free space available.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this example, `row 1` of the container is given a relative weight or `1`,
    allowing it to expand and occupy more free space. Likewise, the `column 0` and
    `column 4` are assigned with a relative weight of `1`. Experiment with this option,
    and see how it influences the layout. The other option to try out is pad, which
    adds padding to the widget.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For `background_label`, we use the `place()` geometry manager. The label is
    anchored at `(0, 0)`. The arguments `relwidth` and `relheight` indicate the fraction
    of the height and width of the parent. The value of 1.0 means the label size will
    be the same as its parent (the main application window).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `sticky` option for `info_label` ensures the widget is aligned along the
    four edges of the cell. The value `nsew` aligns the widgets along the north, south,
    east, and west cell edges respectively. You can also specify a few values, for
    example, `sticky='ew'` will align the widget along the left and right edges.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The radio_btn_pressed and enter_hut methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s review these methods together. In the `create_widgets()` method, we
    specified the command option as indicated in the following code fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The radio_btn_pressed and enter_hut methods](img/B05034_10_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '`radio_btn_pressed` is a command callback for all the radio buttons. It is
    shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The radio_btn_pressed and enter_hut methods](img/B05034_10_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The method just calls `self.enter_hut`. When the radio button is selected, it
    updates the value stored in the Tkinter variable, `self.var`. This value is nothing
    but the hut number assigned to the selected hut, and can be obtained by calling
    the `get()` method of Tkinter's `IntVar` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the `enter_hut` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The radio_btn_pressed and enter_hut methods](img/B05034_10_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding code is self-explanatory. It checks the occupant, and announces
    the result. The winner announcement is done with a `messagebox` widget.
  prefs: []
  type: TYPE_NORMAL
- en: The announce_winner method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is the last method we will review:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The announce_winner method](img/B05034_10_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding method, we use the `messagebox` module in Tkinter to show an
    information box. This module provides several other types of dialog boxes. Refer
    to the documentation for more details.
  prefs: []
  type: TYPE_NORMAL
- en: Running the application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is time for some action! Run this application as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This last command should display the GUI window shown earlier. The following
    screenshot shows the game in action. First you select one of the huts:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running the application](img/B05034_10_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you click on the radio button, it displays the information box notifying
    the winner.
  prefs: []
  type: TYPE_NORMAL
- en: '![Running the application](img/B05034_10_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: MVC architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'MVC is a widely used software architectural pattern in GUI-based applications.
    It has three components, namely a *model* that deals with the business logic,
    a *view* for the user interface, and a *controller* to handle the user input,
    manipulate data, and update the view. The following is a simplified schematic
    that shows the basic interactions between the various components:'
  prefs: []
  type: TYPE_NORMAL
- en: '![MVC architecture](img/B05034_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let's further discuss each of these components.
  prefs: []
  type: TYPE_NORMAL
- en: Model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The model component of the MVC architecture represents the data of the application.
    It also represents the core business logic that acts on such data. The model has
    no knowledge of the view or the controller. When the data in the model changes,
    it just notifies its listeners about this change. In this context, the controller
    object is its listener.
  prefs: []
  type: TYPE_NORMAL
- en: View
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The view component is the user interface. It is responsible for displaying the
    current state of the model to the user, and also provides a means for the user
    to interact with the application. If a user action (like the click of a button)
    changes this state, the view is refreshed to display that change.
  prefs: []
  type: TYPE_NORMAL
- en: Controller
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In some sense, the controller enables a handshake between the model and the
    view. It monitors the changes to the model. When the user interacts with something
    in the view, the controller works in the background and handles the events triggered
    by the user actions, such as a mouse click. The handling function can further
    update the model. When the model's state changes, the controller updates the view
    to reflect those changes.
  prefs: []
  type: TYPE_NORMAL
- en: '![Controller](img/B05034_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '| *You are right. The individual MVC components and their working would be
    better understood with an illustration. Let''s use a trivial example given earlier
    in the section **Event-driven programming***. |'
  prefs: []
  type: TYPE_TB
- en: 'Imagine you have opened a PDF file for reading. In this context, MVC and its
    components could be explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The PDF reader is the running application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will show the contents of the file you have opened, and will also have buttons
    to navigate through the file. This is the view component that deals with the user
    interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To jump to the next page, you interact with the view and click on the next page
    button. This is a user input that generates an event.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Such an event is internally handled by the controller, which then updates the
    model, or, in this context, retrieves the relevant data on the requested page.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The model 's state has changed. The controller further communicates with the
    view for updating it with the new contents.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The view is refreshed, and finally, you see the desired page.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advantages of MVC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The MVC architecture has been traditionally used in desktop GUI applications,
    and is also widely used in web application development. As this is a three-component
    architecture, one major advantage it offers is code reuse across several applications.
    For example, imagine you have multiple applications with different user interfaces,
    all needing the same business logic. With MVC architecture, you could just reuse
    the business logic represented by the model object across these applications.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, the MVC enables user interface developers to focus on the UI code
    without worrying much about the code that handles the business logic. Likewise,
    the developers working on the business logic can concentrate on that piece of
    code alone without losing sleep over the choice of UI widgets and the related
    code. This is referred to as *separation of concerns*. The model is concerned
    about the business logic or data, the view worries about the user interface, and
    the controller code is concerned about things such as enabling view manipulation
    and handling the input.
  prefs: []
  type: TYPE_NORMAL
- en: Project 2 – Attack of the Orcs v10.1.0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's work on another small project. In fact, this is exactly the same hut game
    we developed in *Project-1 – Attack of the Orcs V10.0.0* earlier. The difference
    is the underlying architecture. We will rewrite the program to implement the MVC
    architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Revisiting the HutGame class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the first project, we wrote the `HutGame` class. Let''s pull up the diagram
    representing the high-level structure of this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Revisiting the HutGame class](img/B05034_10_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Based on the functionality, the methods of this class can be roughly placed
    into three categories, namely model, view, and the controller. The preceding diagram
    shows this division. We also need to further update a few of these methods.
  prefs: []
  type: TYPE_NORMAL
- en: Creating MVC classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, we earmarked the methods of the old class `HutGame`
    into three broad categories. It is now time to say goodbye to this class. We will
    break it down and split its methods among the three new classes, `Model`, `View`,
    and `Controller`. Of course, you can give more descriptive names to the classes,
    but let's continue to call them by the aforementioned names.
  prefs: []
  type: TYPE_NORMAL
- en: Observe the following UML-like representation that shows the classes in which
    these methods are parked. Only the important attributes are listed here.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating MVC classes](img/B05034_10_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In [Chapter 1](ch01.html "Chapter 1. Developing Simple Applications"), *Developing
    Simple Applications*, we briefly talked about UML-like representation. One way
    to create such diagrams is to use [https://www.draw.io](https://www.draw.io).
    It is a free, online diagram software for making flowcharts, UML diagrams, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how the classes are laid out, let's understand how these classes
    exchange information.
  prefs: []
  type: TYPE_NORMAL
- en: Communication between MVC objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before diving into the details on how MVC objects communicate, let''s first
    list down a few important points about the MVC architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: The controller knows about the model as well as the view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The model is unaware of the other two, namely the controller and the view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The view (just like the model) knows nothing about the controller and the model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There could be some other variants of the MVC architecture. In this book, we
    will stick to the aforementioned points, and design a solution.
  prefs: []
  type: TYPE_NORMAL
- en: Controller to Model or View communication
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's begin the discussion by learning how a controller sends the information
    to either the model or the view.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Controller` object can directly talk to the `Model` and `View` instances
    using `self.model` and `self.view` respectively. For example, it can just call
    a `View` method like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This is pretty straightforward. Now let's see how it receives the data from
    either the model or the view.
  prefs: []
  type: TYPE_NORMAL
- en: Model to Controller communication
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: How does the controller receive information from the model? For example, in
    the hut game scenario, a winner is determined depending on who is inside the selected
    hut. Once the winner is determined, the `Model` class needs to communicate it
    to the `Controller` class. This is accomplished with the `model_change_handler()`
    method of the `Controller` class. It is invoked whenever the state of the `Model`
    class changes.
  prefs: []
  type: TYPE_NORMAL
- en: '![Model to Controller communication](img/B05034_10_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '| *Good question! The* `Model` *class knows nothing about* `Controller` *and*
    `View`*. Then how does* `Controller` *know that* `Model` *has changed? Let''s
    see that next.* |'
  prefs: []
  type: TYPE_TB
- en: The `Controller` class can receive information from the `Model` class in various
    ways. Let's briefly talk about two such approaches.
  prefs: []
  type: TYPE_NORMAL
- en: Using method assignment
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Recall that in Python, you can assign a method to a variable. The chapter on
    design patterns talked about the first-class objects in greater detail. The following
    line of code can be added to `Controller.__init__`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the `Model` class, you could call `self.changed()`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This automatically notifies `Controller` that the model has changed. While this
    is very convenient, we will instead use a publish-subscribe API which makes things
    even simpler.
  prefs: []
  type: TYPE_NORMAL
- en: Using a publish-subscribe pattern
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Publish-subscribe is a messaging pattern. The publisher can be any program
    that broadcasts some data to a topic. There could be one or more applications
    that are listening to this topic. These are called the subscribers, who receive
    the published data. The publisher does not know (or does not need to know) anything
    about the subscribers. Similarly, a subscriber has no knowledge of the publisher.
    The following schematic gives a high-level overview of a publish-subscribe system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using a publish-subscribe pattern](img/B05034_10_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The publish-subscribe concept can be better understood with a real-world analogy.
    Imagine an online retailer running a weekly flash sale. You have opted in to receive
    notifications in the form of SMS or e-mail alerts. There are several other customers
    who would also like to get notified about the sale.
  prefs: []
  type: TYPE_NORMAL
- en: In a publish-subscribe world, the online retailer is a publisher who broadcasts
    the sale information (the data) to a topic, say *flash sale*. You and several
    other customers are the subscribers to this topic. Likewise, the online retailer
    can publish some other information as different topics, for instance, *Friday
    sale*, *Half price sale*, and so on. Each topic could have several subscribers.
    If you are not subscribed to *Friday sale* , you won't get any notifications sent
    to that topic.
  prefs: []
  type: TYPE_NORMAL
- en: PyPubSub package
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'How do we implement a publish-subscribe framework in Python? One option is
    to write the code from scratch. Instead, we will just use a Python package called
    `pypubsub`. It provides a publish-subscribe API that simplifies the design and
    improves code readability and testability. The package can be installed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Here is a simple example that shows a typical usage. In fact, this syntax is
    all we need in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '![PyPubSub package](img/B05034_10_31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When you run this script, it produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The first argument to `pub.subscribe()` is the function you want to subscribe
    to a given topic. The topic name here is WINNER ANNOUNCMENT. The last line of
    the code shows how to broadcast a message to a specific topic using `pub.sendMessage()`.
    The first argument to `pub.sendMessage()` is the topic name. You can specify any
    number of optional arguments, just make sure that the subscriber function accepts
    all those arguments! In this example, it sends data as the only optional argument.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For more information on the PyPubSub package, see the project home page: [http://pubsub.sourceforge.net/](http://pubsub.sourceforge.net/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'PyDispatcher is an alternative to the PyPubSub package. While we won''t be
    using it, here is a link to the project: [https://pypi.python.org/pypi/PyDispatcher](https://pypi.python.org/pypi/PyDispatcher)'
  prefs: []
  type: TYPE_NORMAL
- en: View to Controller communication
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Just like `Model`, there is no direct communication link from the `View` object
    to the `Controller` object. When the user presses a radio button, the controller
    needs to be notified. We can employ similar approaches, as discussed in the previous
    section. For example, you can assign a method of `Controller` to a `View` method.
    Alternatively, you can use the publish-subscribe API to talk to the `Controller`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: Communication between View and Model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s discuss how `View` and `Model` talk to each other:'
  prefs: []
  type: TYPE_NORMAL
- en: When the user presses a radio button, `View` communicates with `Controller`
    using one of the approaches discussed earlier
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Controller` object then talks to `Model` instructing it to update
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The state of `Model` is updated, and the results are communicated back to `Controller`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Controller` asks `View` to update the display'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**View and Model communication using a publish-subscribe API**:'
  prefs: []
  type: TYPE_NORMAL
- en: You could potentially use the publish-subscribe framework to establish a communication
    channel between the `Model` and the `View` object. Note that this still keeps
    the basic rules intact. `Model` does not know anything about the `View` object.
    It just publishes the data to a given topic. `View` doesn't have any knowledge
    of the `Model` object. It is just registered as a subscriber to the same topic
    where `Model` is broadcasting the data. Thus, whenever there is a change of state
    in `Model`, `View` could get a notification through the publish-subscribe API.
    Likewise for the communication from `View` to `Model`. The potential flip-side
    is that these publish-subscribe signals are essentially global variables, and
    could bring in the painful issues associated with them. So use it with caution!
  prefs: []
  type: TYPE_NORMAL
- en: For this project however, we will stick to the classical approach, where the
    communication happens through `Controller`.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing the code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, you have got a high-level overview of the new classes and how they communicate
    with each other. In the first project, we already reviewed most of the methods
    listed under each new class. That said, to implement the MVC architecture we need
    to make a few changes. Let's review only a few important methods from the file
    `hutgame_mvc.py`. Note that all the classes have been put in the same file. As
    an exercise, split the individual classes in their own module!
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we won't be reviewing each and every line of the code, you should download
    the file `hutgame_mvc.py` and also the two images, `Hut_small.gif` and `Jungle_small.gif`
    from the code bundle for this chapter. Keep the source file handy while reading
    the upcoming discussion. Quite often, it is useful to skim through the full code
    for better understanding!
  prefs: []
  type: TYPE_NORMAL
- en: The main execution code is shown next. It is almost identical to the one we
    saw in the first project. The only difference is `game_app` (shown highlighted).
    It is now an instance of the `Controller` class instead of `HutGame`. In fact,
    there is no `HutGame` class for this project! Recall that we broke it down, creating
    three new classes.
  prefs: []
  type: TYPE_NORMAL
- en: '![Reviewing the code](img/B05034_10_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Controller class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Controller` class is quite small, as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Controller class](img/B05034_10_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let's talk through the code. You can skip reading these bullets if you have
    already understood it!
  prefs: []
  type: TYPE_NORMAL
- en: The `Controller` class is composed of `Model` and `View` instances. This allows
    it to directly call the functionality from these classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `self.view.set_callbacks()` function essentially assigns the `radio_btn_pressed`
    method to an appropriate attribute of `View`. What this simply means is that whenever
    the user presses a radio button, this method is invoked. See the section *View
    to Controller communication* for more details.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Controller` class receives data from the `Model` instance by subscribing
    to the topic, `"WINNER ANNOUNCEMENT"`. We have already seen an example of the
    `pub.subscribe()` function. Simply put, the method `model_change_handler` is called
    whenever the winner is announced.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The method `model_change_handler` calls the appropriate `View` method to display
    a message that announces the winner.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Model class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There aren't many changes in the `Model` class. The only significant change
    is the highlighted line of the given code (the call to `pub.sendMessage`) in the
    `enter_hut` method. The details of the other methods are not shown. These methods
    are shown with their code collapsed in the editor.
  prefs: []
  type: TYPE_NORMAL
- en: '![The Model class](img/B05034_10_32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Compare this method against the one we wrote in the first project. Notice that
    it does not call `View.announce_winner` directly. Instead, it notifies the `Controller`
    instance using the `pub.sendMessage()`. The rest of the code remains unchanged,
    and you can have a look at the `hutgame_mvc.py` file for further details.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As noted in the section *Communication between View and Model*, you could potentially
    use the same publish-subscribe framework to notify the `Model` state changes to
    the `View` and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Object-relational mapper (ORM)**:'
  prefs: []
  type: TYPE_NORMAL
- en: Simply put, it is a library that enables you to use an object-oriented language
    like Python to access and update the data sitting in a database. In Python, DJango
    ORM and SQLAlchemy are among the popular ORM libraries. You can do a web search
    on these libraries to find useful resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Model classes and ORMs: This book does not cover anything related to web or
    database application programming, but it is worth mentioning the following. It
    is quite common for the `Model` classes to inherit from the ORMs, and represent
    database tables where each object is a row in the table. Writing unit tests for
    such systems could be a challenge, as you typically don''t want to actually hit
    the database every time these tests run. In [Chapter 5](ch05.html "Chapter 5. Unit
    Testing and Refactoring"), *Unit Testing and Refactoring* we saw how to use Python''s
    mock library. Quite often, mock is useful for unit testing such systems (it is
    not covered in this book).'
  prefs: []
  type: TYPE_NORMAL
- en: The View class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `View` class is illustrated next. The only significant change is the method
    by the name `set_callbacks`. The other methods are shown with their code collapsed.
  prefs: []
  type: TYPE_NORMAL
- en: '![The View class](img/B05034_10_33.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Recall that in the `Controller.__init__` method, we have the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code states that the `radio_btn_pressed` attribute of the `View`
    class represents the method `radio_btn_pressed()` of the `Controller` class. The
    rest of the code is identical to the one seen in the first project.
  prefs: []
  type: TYPE_NORMAL
- en: Running the application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this project, we did not add any new features to the GUI. The idea was to
    just show a rudimentary example on implementing the MVC architecture. You can
    run this application as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This should show the same GUI window and features as in the first project.
  prefs: []
  type: TYPE_NORMAL
- en: Testing GUI applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a complex and feature-rich GUI application, the user is presented with many
    choices of widgets, menus, keyboard shortcuts, and so on. As seen earlier in the
    chapter, the event-driven nature of GUI programs lets the user dictate the program
    flow. This often presents many possible ways for the user to perform certain operations
    to arrive at the desired output.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It should be noted that we are not going to write any code here. This is just
    a high-level discussion that touches upon a few important testing considerations.
    For further learning on this topic, start with the following wiki page: [https://en.wikipedia.org/wiki/Graphical_user_interface_testing](https://en.wikipedia.org/wiki/Graphical_user_interface_testing).'
  prefs: []
  type: TYPE_NORMAL
- en: Imagine a GUI application that allows selecting some object in the application
    window, for example, a folder icon on the desktop. The user can hover the mouse
    over the icon to highlight that object, and then click on it to select it. Alternatively,
    he can do a window selection, where a selection window is drawn around the object
    to select it. Yet another alternative could be using a combination of keys on
    the keyboard. While the user is happy that he can accomplish the task in different
    ways, it becomes a challenge for the developer to write a bug-free code.
  prefs: []
  type: TYPE_NORMAL
- en: The nature of event-driven programming makes it difficult to write a robust
    code and comprehensive tests to account for the majority of the user input scenarios.
    The bugs would creep in one way or the other. Of course, this varies depending
    on the application and testing strategy, but it is typically a problem for large
    and complex GUI applications.
  prefs: []
  type: TYPE_NORMAL
- en: Testing considerations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are various testing strategies to make the GUI application code more robust.
    Let's touch upon a few important testing considerations.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing and MVC
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A unit test helps you test an individual chunk of the code. An integration test
    is where you have many unit tests grouped together to test a larger functionality.
    In a regression test, you typically have a combination of unit and integration
    tests. Here, the tests are rerun to ensure that nothing is broken. A good regression
    test framework is crucial as the first line of defense against the bugs. Unit
    testing generally helps in addressing some common problems. In an earlier chapter,
    we already covered this topic with examples from a command-line application.
  prefs: []
  type: TYPE_NORMAL
- en: The MVC architecture of the GUI program further helps in making the code robust.
    The separation of concerns or breaking down of the code into the model, view,
    and controller components allows us to write unit tests for particular types of
    error. For example, in some applications, you may anticipate `ZeroDivisionError`
    in the `Model` class instead of the `View` class. So you could write focused unit
    tests for the `Model` class to gracefully handle such situations.
  prefs: []
  type: TYPE_NORMAL
- en: Manual testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While having a good regression test suite helps with the common issues, the
    event-driven nature of the program often presents scenarios that are not accounted
    for. In manual testing, the software tester manually checks the working of the
    application by playing with different features provided in the GUI. If something
    is not working as expected, the tester creates a bug report to document the instructions
    to reproduce the problem. Many hidden bugs surface in the manual testing phase.
  prefs: []
  type: TYPE_NORMAL
- en: With the growing complexity of the program, the repetitive manual testing job
    becomes overwhelming for the testers. This is where automated GUI testing comes
    to the rescue.
  prefs: []
  type: TYPE_NORMAL
- en: Automated GUI testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here, the testing tool records the user actions to create tests. If you run
    such a test, the user actions are repeated automatically in the same sequence.
    This allows quick identification of the broken functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Automated testing should not replace manual testing. Unless the tool has artificial
    intelligence built into it, you still need someone to test the new features, and
    use the existing ones in ways not tried before. In general, automated testing
    should complement the manual GUI testing activity.
  prefs: []
  type: TYPE_NORMAL
- en: There are several open source and commercial tools available for automated GUI
    testing in Python. The following table summarizes a few prominent, freely available
    tools for GUI test automation. For a comprehensive list, see the Python wiki page
    at [https://wiki.python.org/moin/PythonTestingToolsTaxonomy](https://wiki.python.org/moin/PythonTestingToolsTaxonomy).
  prefs: []
  type: TYPE_NORMAL
- en: '| Tool name and link | Notes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Sikuli (SikuliX) [http://www.sikuli.org/](http://www.sikuli.org/) | Supported
    on Windows, Mac, and some Linux OS. Visit the website to check if your OS is supported.
    |'
  prefs: []
  type: TYPE_TB
- en: '| StoryText [https://pypi.python.org/pypi/StoryText](https://pypi.python.org/pypi/StoryText)
    | Supported GUI frameworks include Tkinter, PyGTK, wxPython, and others. See the
    website for the complete list. |'
  prefs: []
  type: TYPE_TB
- en: '| Dogtail [https://fedorahosted.org/dogtail/](https://fedorahosted.org/dogtail/)
    | Intended for Linux OS like Fedora. Check if it is compatible with your OS. |'
  prefs: []
  type: TYPE_TB
- en: One of the frailties of such automated testing systems is that the innocent-looking
    GUI changes may require you to change a lot of tests, and depending on the complexity
    of your GUI application, this could be a hassle.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here is a list of a few things you could do to further improve the GUI application.
    With one exception, the solutions are not provided for these exercises.
  prefs: []
  type: TYPE_NORMAL
- en: Put the `Model`, `View` and, `Controller` classes in their own modules!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the publish-subscribe API for communication from `View` to `Controller`.
    You can refer to the file `hutgame_mvc_pubsub.py` for a solution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add more widgets such as a menu bar and buttons. Implement the **Restart Game**
    button. When clicked, the game should restart. Do the following when this button
    is clicked:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Randomly distribute the occupants again by calling `occupy_huts()`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Clear the state of the radio buttons. All the buttons should be deselected.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Add exception handling to the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try to generalize the `View.add_callbacks` method so that it can be used to
    set more callback functions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This book has touched upon several important aspects of application development.
    The key concepts were taught primarily by developing command-line applications.
    As noted earlier in the chapter, there are many applications that require you
    to learn domain-specific techniques. For example, in this chapter, we learned
    about the MVC architecture commonly implemented in GUI applications. Let''s conclude
    this chapter, and hence the book, with a brief discussion on some of the important
    application domains. This will just give you some useful pointers (with lots of
    links!) to the relevant libraries or application frameworks. To avoid clutter,
    the URLs with further information are provided separately at the end of this section.
    The following is a list of other important application domains; however, this
    is far from being an exhaustive list:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Web and mobile application development:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These are important application development domains. To learn Python Web application
    development, you can start exploring the Flask or DJango frameworks in Python.
    Knowledge of MVC will also help you here. For mobile application development,
    the kivy library is probably a good start.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Applications involving databases:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A **database management system** (**DBMS**) is another important application
    domain. In a nutshell, DBMS provides you a way to create, access, and manage your
    data. Python has several libraries that enable talking to a database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: SQLite3 is a simple, light-weight relational database system. The module sqlite3
    is a built-in Python module that provides a DB-API 2.0 compliant SQL interface.
    There are several client libraries written in Python that provide a way to talk
    to a database. For example, the PyMongo module provides tools to work with MongoDB,
    and so on.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Machine and deep learning:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the data science domain, the use of machine learning and deep learning libraries
    is growing rapidly. The knowledge of GPU programming would help here.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Data science applications almost always involve visualizing some data. It is
    very convenient to use IPython or Jupyter notebooks to write and share interactive
    data science applications. See [http://jupyter.org/](http://jupyter.org/)for more
    details.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For machine learning, you can explore Apache Spark. This is a general-purpose
    cluster computing system that provides high-level APIs in Python and other languages.
    MLlib is Apache Spark's scalable machine learning library. For deep-learning applications,
    Caffe and Tensorflow are among the popular deep-learning frameworks.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Internet of Things:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is is yet another rapidly emerging field where Python is one of the favored
    languages for developing applications. Here you could use Python to not only process
    data (Analytics applications) on the server side but also have a Python client
    running on the end device. You can find use of the publish-subscribe messaging
    pattern in such applications, where the device publishes data to a topic, and
    the server side application is a subscriber that receives this data.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Multimedia and game applications:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This is broad topic, and there are several frameworks and libraries available
    for developing multimedia applications:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Python wiki documents many tools that deal with audio and video processing.
    **GStreamer**, **MoviePy**, and **MLT** are among the popular frameworks. See
    also the PyMedia module.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: There are quite a few options for image processing. Check out scikit-image,
    Opencv, and pillow (a fork of Python Imaging Library or PIL).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many libraries useful for developing game- and animation-related applications.
    Check out PyGame and Pyglet. Again, you can find a comprehensive list on the Python
    wiki page.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The following table lists a few useful web links that provide more information
    on various tools or domains discussed earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At the time of writing this book, all the web links (URLs) presented throughout
    the book are accessible. As noted in [Chapter 1](ch01.html "Chapter 1. Developing
    Simple Applications"), *Developing Simple Applications*, these links might end
    up being broken over time. If that ever happens, do a web search with the appropriate
    search terms. For example, if you find the link to the PyMongo module broken,
    you can Google search PyMongo Python MongoDB to find some useful resources!
  prefs: []
  type: TYPE_NORMAL
- en: '| Tool or application domain | Web link for further information |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Flask | [http://flask.pocoo.org](http://flask.pocoo.org) |'
  prefs: []
  type: TYPE_TB
- en: '| Django | [https://www.djangoproject.com](https://www.djangoproject.com) |'
  prefs: []
  type: TYPE_TB
- en: '| Kivy | [https://kivy.org](https://kivy.org) |'
  prefs: []
  type: TYPE_TB
- en: '| sqlite3 | [https://docs.python.org/3/library/sqlite3.html](https://docs.python.org/3/library/sqlite3.html)
    |'
  prefs: []
  type: TYPE_TB
- en: '| PyMongo | [https://api.mongodb.com/python/current/](https://api.mongodb.com/python/current/)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Jupyter notebook | [http://jupyter.org/](http://jupyter.org/) |'
  prefs: []
  type: TYPE_TB
- en: '| Apache Spark | [https://spark.apache.org](https://spark.apache.org) |'
  prefs: []
  type: TYPE_TB
- en: '| Caffe framework | [http://caffe.berkeleyvision.org](http://caffe.berkeleyvision.org)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Tensorflow | [https://www.tensorflow.org/](https://www.tensorflow.org/) |'
  prefs: []
  type: TYPE_TB
- en: '| **Internet of Things** (**IoT**) | [https://en.wikipedia.org/wiki/Internet_of_things](https://en.wikipedia.org/wiki/Internet_of_things)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Audio, video processing | [https://wiki.python.org/moin/AudioVideo](https://wiki.python.org/moin/AudioVideo)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Game and animations | [https://wiki.python.org/moin/PythonGameLibraries](https://wiki.python.org/moin/PythonGameLibraries)
    |'
  prefs: []
  type: TYPE_TB
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter served as an introduction to the Python GUI programming. Starting
    with an overview of the different GUI frameworks, it touched upon some important
    practical design considerations for developing user interfaces. You saw what event-driven
    programming is, and learned about events and event handling. With a quick introduction
    to Tkinter library, we developed a simple Hut Game, an equivalent GUI version
    of the first ever application developed in [Chapter 1](ch01.html "Chapter 1. Developing
    Simple Applications"), *Developing Simple Applications*.
  prefs: []
  type: TYPE_NORMAL
- en: The second half of the chapter introduced you to the MVC architecture, and we
    transformed the Hut Game to implement this architecture. The chapter concluded
    with a high-level discussion on testing GUI applications.
  prefs: []
  type: TYPE_NORMAL
- en: '![Summary](img/B05034_10_34.jpg)'
  prefs: []
  type: TYPE_IMG
