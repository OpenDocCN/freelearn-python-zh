<html><head></head><body><div class="chapter" title="Chapter&#xA0;8.&#xA0;Testing and Deploying an API with Flask"><div class="titlepage"><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Testing and Deploying an API with Flask</h1></div></div></div><p>In this chapter, we will configure, write, and execute unit tests and learn a few things related to deployment. We will:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Set up unit tests</li><li class="listitem" style="list-style-type: disc">Create a database for testing</li><li class="listitem" style="list-style-type: disc">Write a first round of unit tests</li><li class="listitem" style="list-style-type: disc">Run unit tests and check testing coverage</li><li class="listitem" style="list-style-type: disc">Improve testing coverage</li><li class="listitem" style="list-style-type: disc">Understand strategies for deployments and scalability</li></ul></div><div class="section" title="Setting up unit tests"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec95"/>Setting up unit tests</h1></div></div></div><p>We will use <code class="literal">nose2</code> to make it easier to discover and run unit tests. We will measure test coverage, and therefore, we will install the necessary package to allow us to run coverage with <code class="literal">nose2</code>. First, we will install the <code class="literal">nose2</code> and <code class="literal">cov-core</code> packages in our virtual environment. The <code class="literal">cov-core</code> package will allow us to measure test coverage with <code class="literal">nose2</code>. Then, we will create a new PostgreSQL database that we will use for testing. Finally, we will create the configuration file for the testing environment.</p><p>Make sure you quit the Flask's development server. Remember that you just need to press <span class="emphasis"><em>
<span class="strong"><strong>Ctrl</strong></span>
</em></span> + <span class="emphasis"><em>
<span class="strong"><strong>C</strong></span>
</em></span> in the terminal or the Command Prompt window in which it is running. We just need to run the following command to install the <code class="literal">nose2</code> package:</p><pre class="programlisting">
<span class="strong"><strong>pip install nose2</strong></span>
</pre><p>The last lines of the output will indicate that the <code class="literal">django-nose</code> package has been successfully installed.</p><pre class="programlisting">
<span class="strong"><strong>Collecting nose2</strong></span>
<span class="strong"><strong>Collecting six&gt;=1.1 (from nose2)</strong></span>
<span class="strong"><strong>  Downloading six-1.10.0-py2.py3-none-any.whl</strong></span>
<span class="strong"><strong>Installing collected packages: six, nose2</strong></span>
<span class="strong"><strong>Successfully installed nose2-0.6.5 six-1.10.0</strong></span>
</pre><p>We just need to run the following command to install the <code class="literal">cov-core</code> package that will also install the <code class="literal">coverage</code> dependency:</p><pre class="programlisting">
<span class="strong"><strong>pip install cov-core</strong></span>
</pre><p>The last lines for the output will indicate that the <code class="literal">django-nose</code> package has been successfully installed:</p><pre class="programlisting">
<span class="strong"><strong>Collecting cov-core</strong></span>
<span class="strong"><strong>Collecting coverage&gt;=3.6 (from cov-core)</strong></span>
<span class="strong"><strong>Installing collected packages: coverage, cov-core</strong></span>
<span class="strong"><strong>Successfully installed cov-core-1.15.0 coverage-4.2</strong></span>
</pre><p>Now, we will create the PostgreSQL database that we will use as a repository for our testing environment. You will have to download and install a PostgreSQL database, in case you aren't already running it on the testing environment on your computer or in a testing server.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip57"/>Tip</h3><p>Remember to make sure that the PostgreSQL bin folder is included in the <code class="literal">PATH</code> environmental variable. You should be able to execute the <code class="literal">psql</code> command-line utility from your current Terminal or Command Prompt.</p></div></div><p>We will use the PostgreSQL command-line tools to create a new database named <code class="literal">test_messages</code>. In case you already have a PostgreSQL database with this name, make sure that you use another name in all the commands and configurations. You can perform the same task with any PostgreSQL GUI tool. In case you are developing on Linux, it is necessary to run the commands as the <code class="literal">postgres</code> user. Run the following command in macOS or Windows to create a new database named <code class="literal">test_messages</code>. Note that the command won't generate any output:</p><pre class="programlisting">
<span class="strong"><strong>createdb test_messages</strong></span>
</pre><p>In Linux, run the following command to use the <code class="literal">postgres</code> user:</p><pre class="programlisting">
<span class="strong"><strong>sudo -u postgres createdb test_messages</strong></span>
</pre><p>Now, we will use the <code class="literal">psql</code> command-line tool to run some SQL statements to grant privileges on the database to a user. In case you are using a different server than the development server, you will have to create the user before granting privileges. In macOS or Windows, run the following command to launch psql:</p><pre class="programlisting">
<span class="strong"><strong>psql</strong></span>
</pre><p>In Linux, run the following command to use the postgres user</p><pre class="programlisting">
<span class="strong"><strong>sudo -u psql</strong></span>
</pre><p>Then, run the following SQL statements and finally enter \q to exit the psql command-line tool. Replace user_name with your desired user name to use in the new database and password with your chosen password. We will use the user name and password in the Flask testing configuration. You don't need to run the steps in case you are already working with a specific user in PostgreSQL and you have already granted privileges to the database for the user:</p><pre class="programlisting">
<span class="strong"><strong>GRANT ALL PRIVILEGES ON DATABASE test_messages TO user_name;</strong></span>
<span class="strong"><strong>\q</strong></span>
</pre><p>Create a new <code class="literal">test_config.py</code> file within the <code class="literal">api</code> folder. The following lines show the code that declares variables that determine the configuration for Flask and SQLAlchemy for our testing environment. The <code class="literal">SQL_ALCHEMY_DATABASE_URI</code> variable generates a SQLAlchemy URI for the PostgreSQL database that we will use to run all the migrations before starting tests and we will drop all the elements after executing all the tests. Make sure you specify the desired test database name in the value for <code class="literal">DB_NAME</code> and that you configure the user, password, host, and port based on your PostgreSQL configuration for the testing environment. In case you followed the previous steps, use the settings specified in these steps. The code file for the sample is included in the <code class="literal">restful_python_chapter_08_01</code> folder.</p><pre class="programlisting">import os &#13;
 &#13;
 &#13;
basedir = os.path.abspath(os.path.dirname(__file__)) &#13;
DEBUG = True &#13;
PORT = 5000 &#13;
HOST = "127.0.0.1" &#13;
SQLALCHEMY_ECHO = False &#13;
SQLALCHEMY_TRACK_MODIFICATIONS = True &#13;
SQLALCHEMY_DATABASE_URI = "postgresql://{DB_USER}:{DB_PASS}@{DB_ADDR}/{DB_NAME}".format(DB_USER="user_name", DB_PASS="password", DB_ADDR="127.0.0.1", DB_NAME="test_messages") &#13;
SQLALCHEMY_MIGRATE_REPO = os.path.join(basedir, 'db_repository') &#13;
TESTING = True &#13;
SERVER_NAME = '127.0.0.1:5000' &#13;
PAGINATION_PAGE_SIZE = 5 &#13;
PAGINATION_PAGE_ARGUMENT_NAME = 'page' &#13;
#Disable CSRF protection in the testing configuration &#13;
WTF_CSRF_ENABLED = False &#13;
</pre><p>As we did with the similar test file we created for our development environment, we will specify the previously created module as an argument to a function that will create a Flask app that we will use for testing. This way, we have one module that specifies all the values for the different configuration variables for our testing environment and another module that creates a <span class="emphasis"><em>Flask</em></span> app for our testing environment. It is also possible to create a class hierarchy with one class for each environment we want to use. However, in our sample case, it is easier to create a new configuration file for our testing environment.</p></div></div>
<div class="section" title="Writing a first round of unit tests"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec96"/>Writing a first round of unit tests</h1></div></div></div><p>Now, we will write a first round of unit tests. Specifically, we will write unit tests related to the user and message category resources: <code class="literal">UserResource</code>, <code class="literal">UserListResource</code>, <code class="literal">CategoryResource</code>, and <code class="literal">CategoryListResource</code>. Create a new <code class="literal">tests</code> sub-folder within the <code class="literal">api</code> folder. Then, create a new <code class="literal">test_views.py</code> file within the new <code class="literal">api/tests</code> sub-folder. Add the following lines, that declare many <code class="literal">import</code> statements and the first methods for the <code class="literal">InitialTests</code> class. The code file for the sample is included in the <code class="literal">restful_python_chapter_08_01</code> folder:</p><pre class="programlisting">from app import create_app &#13;
from base64 import b64encode &#13;
from flask import current_app, json, url_for &#13;
from models import db, Category, Message, User &#13;
import status &#13;
from unittest import TestCase &#13;
 &#13;
 &#13;
class InitialTests(TestCase): &#13;
  <span class="strong"><strong>  def setUp(self):</strong></span> &#13;
        self.app = create_app('test_config') &#13;
        self.test_client = self.app.test_client() &#13;
        self.app_context = self.app.app_context() &#13;
        self.app_context.push() &#13;
        self.test_user_name = 'testuser' &#13;
        self.test_user_password = 'T3s!p4s5w0RDd12#' &#13;
        db.create_all() &#13;
 &#13;
 <span class="strong"><strong>   def tearDown(self):</strong></span> &#13;
        db.session.remove() &#13;
        db.drop_all() &#13;
        self.app_context.pop() &#13;
 &#13;
   <span class="strong"><strong> def get_accept_content_type_headers(self):</strong></span> &#13;
        return { &#13;
            'Accept': 'application/json', &#13;
            'Content-Type': 'application/json' &#13;
        } &#13;
 &#13;
  <span class="strong"><strong>  def get_authentication_headers(self, username, password):</strong></span> &#13;
        authentication_headers = self.get_accept_content_type_headers() &#13;
        authentication_headers['Authorization'] = \ &#13;
            'Basic ' + b64encode((username + ':' + password).encode('utf-&#13;
             8')).decode('utf-8') &#13;
        return authentication_headers &#13;
</pre><p>The <code class="literal">InitialTests</code> class is a subclass of <code class="literal">unittest.TestCase</code>. The class overrides the <code class="literal">setUp</code> method that will be executed before each test method runs. The method calls the <code class="literal">create_app</code> function, declared in the <code class="literal">app</code> module, with <code class="literal">'test_config'</code> as an argument. The function will set up a Flask app with this module as the configuration file, and therefore, the app will use the previously created configuration file that specifies the desired values for our testing database and environment. Then, the code sets the testing attribute for the recently created <code class="literal">app</code> to <code class="literal">True</code> in order for the exception to propagate to the test client.</p><p>The next line calls the <code class="literal">self.app.test_client</code> method to create a test client for the previously created Flask application and saves the test client in the <code class="literal">test_client</code> attribute. We will use the test client in our test methods to easily compose and send requests to our API. Then, the code saves and pushes the application context and creates two attributes with the user name and password we will use for our tests. Finally, the method calls the <code class="literal">db.create_all</code> method to create all the necessary tables in our test database configured in the <code class="literal">test_config.py</code> file.</p><p>The <code class="literal">InitialTests</code> class overrides the <code class="literal">tearDown</code> method that will be executed after each test method runs. The code removes the SQLAlchemy session, drops all the tables that we created in the test database before starting the execution of the tests, and pops the application context. This way, after each test finishes its execution, the test database will be empty again.</p><p>The <code class="literal">get_accept_content_type_headers</code> method builds and returns a dictionary (<code class="literal">dict</code>) with the values of the <code class="literal">Accept</code> and <code class="literal">Content-Type</code> header keys set to <code class="literal">'application/json'</code>. We will call this method in our tests whenever we have to build a header to compose our requests without authentication.</p><p>The <code class="literal">get_authentication_headers</code> method calls the previously explained <code class="literal">get_accept_content_type_headers</code> method to generate the header key-value pairs without authentication. Then, the code adds the necessary value to the <code class="literal">Authorization</code> key with the appropriate encoding to provide the user name and password received in the <code class="literal">username</code> and <code class="literal">password</code> arguments. The last line returns the generated dictionary that includes authentication information. We will call this method in our tests whenever we have to build a header to compose our requests with authentication. We will use the user name and password we stored in attributes the <code class="literal">setUp</code> method.</p><p>Open the previously created <code class="literal">test_views.py</code> file within the new <code class="literal">api/tests</code> sub-folder. Add the following lines that declare many methods for the <code class="literal">InitialTests</code> class. The code file for the sample is included in the <code class="literal">restful_python_chapter_08_01</code> folder.</p><pre class="programlisting">
<span class="strong"><strong>    def test_request_without_authentication(self):</strong></span> &#13;
        """ &#13;
        Ensure we cannot access a resource that requirest authentication without an appropriate authentication header &#13;
        """ &#13;
        response = self.test_client.get( &#13;
            url_for('api.messagelistresource', _external=True), &#13;
            headers=self.get_accept_content_type_headers()) &#13;
        self.assertTrue(response.status_code == status.HTTP_401_UNAUTHORIZED) &#13;
 &#13;
   <span class="strong"><strong> def create_user(self, name, password):</strong></span> &#13;
        url = url_for('api.userlistresource', _external=True) &#13;
        data = {'name': name, 'password': password} &#13;
        response = self.test_client.post( &#13;
            url,  &#13;
            headers=self.get_accept_content_type_headers(), &#13;
            data=json.dumps(data)) &#13;
        return response &#13;
 &#13;
  <span class="strong"><strong>  def create_category(self, name):</strong></span> &#13;
        url = url_for('api.categorylistresource', _external=True) &#13;
        data = {'name': name} &#13;
        response = self.test_client.post( &#13;
            url,  &#13;
            headers=self.get_authentication_headers(self.test_user_name, &#13;
            self.test_user_password), &#13;
            data=json.dumps(data)) &#13;
        return response &#13;
 &#13;
 <span class="strong"><strong>   def test_create_and_retrieve_category(self):</strong></span> &#13;
        """ &#13;
        Ensure we can create a new Category and then retrieve it &#13;
        """ &#13;
        create_user_response = self.create_user(self.test_user_name,&#13;
        self.test_user_password) &#13;
        self.assertEqual(create_user_response.status_code,&#13;
        status.HTTP_201_CREATED) &#13;
        new_category_name = 'New Information' &#13;
        post_response = self.create_category(new_category_name) &#13;
        self.assertEqual(post_response.status_code, status.HTTP_201_CREATED) &#13;
        self.assertEqual(Category.query.count(), 1) &#13;
        post_response_data = json.loads(post_response.get_data(as_text=True)) &#13;
        self.assertEqual(post_response_data['name'], new_category_name) &#13;
        new_category_url = post_response_data['url'] &#13;
        get_response = self.test_client.get( &#13;
            new_category_url, &#13;
            headers=self.get_authentication_headers(self.test_user_name,&#13;
            self.test_user_password)) &#13;
        get_response_data = json.loads(get_response.get_data(as_text=True)) &#13;
        self.assertEqual(get_response.status_code, status.HTTP_200_OK) &#13;
        self.assertEqual(get_response_data['name'], new_category_name) &#13;
</pre><p>The <code class="literal">test_request_without_authentication</code> method tests whether we have been rejected access to a resource that requires authentication when we don't provide an appropriate authentication header with the request. The method uses the test client to compose and send an HTTP <code class="literal">GET</code> request to the URL generated for the <code class="literal">'api.messagelistresource'</code> resource to retrieve the list of messages. We need an authenticated request to retrieve the list of messages. However, the code calls the <code class="literal">get_authentication_headers</code> method to set the value for the headers argument in the call to <code class="literal">self.test_client.get</code>, and therefore, the code generates a request without authentication. Finally, the method uses <code class="literal">assertTrue</code> to check that the <code class="literal">status_code</code> for the response is HTTP 401 Unauthorized (<code class="literal">status.HTTP_401_UNAUTHORIZED</code>).</p><p>The <code class="literal">create_user</code> method uses the test client to compose and send an HTTP <code class="literal">POST</code> request to the URL generated for the <code class="literal">'api.userlistresource'</code> resource to create a new user with the name and password received as arguments. We don't need an authenticated request to create a new user, and therefore, the code calls the previously explained <code class="literal">get_accept_content_type_headers</code> method to set the value for the headers argument in the call to <code class="literal">self.test_client.post</code>. Finally, the code returns the response from the <code class="literal">POST</code> request. Whenever we have to create an authenticated request, we will call the <code class="literal">create_user</code> method to create a new user.</p><p>The <code class="literal">create_category</code> method uses the test client to compose and send an HTTP <code class="literal">POST</code> request to the URL generated for the <code class="literal">'api.categorylistresource'</code> resource to create a new <code class="literal">Category</code> with the name received as an argument. We need an authenticated request to create a new <code class="literal">Category</code>, and therefore, the code calls the previously explained <code class="literal">get_authentication_headers</code> method to set the value for the headers argument in the call to <code class="literal">self.test_client.post</code>. The user name and password are set to <code class="literal">self.test_user_name</code> and <code class="literal">self.test_user_password</code>. Finally, the code returns the response from the <code class="literal">POST</code> request. Whenever we have to create a category, we will call the <code class="literal">create_category</code> method after the appropriate user that authenticates the request has been created.</p><p>The <code class="literal">test_create_and_retrieve_category</code> method tests whether we can create a new <code class="literal">Category</code> and then retrieve it. The method calls the previously explained <code class="literal">create_user</code> method to create a new user and then use it to authenticate the HTTP <code class="literal">POST</code> request generated in the <code class="literal">create_game_category</code> method. Then, the code composes and sends an HTTP <code class="literal">GET</code> method to retrieve the recently created Category with the URL received in the response of the previous HTTP <code class="literal">POST</code> request. The method uses <code class="literal">assertEqual</code> to check for the following expected results:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">status_code</code> for the HTTP <code class="literal">POST</code> response is HTTP 201 Created (<code class="literal">status.HTTP_201_CREATED</code>)</li><li class="listitem" style="list-style-type: disc">The total number of <code class="literal">Category</code> objects retrieved from the database is <code class="literal">1</code></li><li class="listitem" style="list-style-type: disc">The <code class="literal">status_code</code> for the HTTP <code class="literal">GET</code> response is HTTP 200 OK (<code class="literal">status.HTTP_200_OK</code>)</li><li class="listitem" style="list-style-type: disc">The value for the <code class="literal">name</code> key in the HTTP <code class="literal">GET</code> response is equal to the name specified for the new category</li></ul></div><p>Open the previously created <code class="literal">test_views.py</code> file within the new <code class="literal">api/tests</code> sub-folder. Add the following lines that declare many methods for the <code class="literal">InitialTests</code> class. The code file for the sample is included in the <code class="literal">restful_python_chapter_08_01</code> folder.</p><pre class="programlisting">
<span class="strong"><strong>    def test_create_duplicated_category(self):</strong></span> &#13;
        """ &#13;
        Ensure we cannot create a duplicated Category &#13;
        """ &#13;
        create_user_response = self.create_user(self.test_user_name,&#13;
        self.test_user_password) &#13;
        self.assertEqual(create_user_response.status_code,&#13;
        status.HTTP_201_CREATED) &#13;
        new_category_name = 'New Information' &#13;
        post_response = self.create_category(new_category_name) &#13;
        self.assertEqual(post_response.status_code, status.HTTP_201_CREATED) &#13;
        self.assertEqual(Category.query.count(), 1) &#13;
        post_response_data = json.loads(post_response.get_data(as_text=True)) &#13;
        self.assertEqual(post_response_data['name'], new_category_name) &#13;
        second_post_response = self.create_category(new_category_name) &#13;
        self.assertEqual(second_post_response.status_code,&#13;
        status.HTTP_400_BAD_REQUEST) &#13;
        self.assertEqual(Category.query.count(), 1) &#13;
 &#13;
  <span class="strong"><strong>  def test_retrieve_categories_list(self):</strong></span> &#13;
        """ &#13;
        Ensure we can retrieve the categories list &#13;
        """ &#13;
        create_user_response = self.create_user(self.test_user_name,&#13;
        self.test_user_password) &#13;
        self.assertEqual(create_user_response.status_code,&#13;
        status.HTTP_201_CREATED) &#13;
        new_category_name_1 = 'Error' &#13;
        post_response_1 = self.create_category(new_category_name_1) &#13;
        self.assertEqual(post_response_1.status_code, status.HTTP_201_CREATED) &#13;
        new_category_name_2 = 'Warning' &#13;
        post_response_2 = self.create_category(new_category_name_2) &#13;
        self.assertEqual(post_response_2.status_code, status.HTTP_201_CREATED) &#13;
        url = url_for('api.categorylistresource', _external=True) &#13;
        get_response = self.test_client.get( &#13;
            url, &#13;
            headers=self.get_authentication_headers(self.test_user_name,&#13;
            self.test_user_password)) &#13;
        get_response_data = json.loads(get_response.get_data(as_text=True)) &#13;
        self.assertEqual(get_response.status_code, status.HTTP_200_OK) &#13;
        self.assertEqual(len(get_response_data), 2) &#13;
        self.assertEqual(get_response_data[0]['name'], new_category_name_1) &#13;
        self.assertEqual(get_response_data[1]['name'], new_category_name_2) &#13;
 &#13;
   &#13;
        """ &#13;
        Ensure we can update the name for an existing category &#13;
        """ &#13;
        create_user_response = self.create_user(self.test_user_name,&#13;
        self.test_user_password) &#13;
        self.assertEqual(create_user_response.status_code,&#13;
        status.HTTP_201_CREATED) &#13;
        new_category_name_1 = 'Error 1' &#13;
        post_response_1 = self.create_category(new_category_name_1) &#13;
        self.assertEqual(post_response_1.status_code, status.HTTP_201_CREATED) &#13;
        post_response_data_1 = json.loads(post_response_1.get_data(as_text=True)) &#13;
        new_category_url = post_response_data_1['url'] &#13;
        new_category_name_2 = 'Error 2' &#13;
        data = {'name': new_category_name_2} &#13;
        patch_response = self.test_client.patch( &#13;
            new_category_url,  &#13;
            headers=self.get_authentication_headers(self.test_user_name,&#13;
            self.test_user_password), &#13;
            data=json.dumps(data)) &#13;
        self.assertEqual(patch_response.status_code, status.HTTP_200_OK) &#13;
        get_response = self.test_client.get( &#13;
            new_category_url, &#13;
            headers=self.get_authentication_headers(self.test_user_name,&#13;
            self.test_user_password)) &#13;
        get_response_data = json.loads(get_response.get_data(as_text=True)) &#13;
        self.assertEqual(get_response.status_code, status.HTTP_200_OK) &#13;
        self.assertEqual(get_response_data['name'], new_category_name_2)</pre><p>The class declares the following methods whose name start with the <code class="literal">test_</code> prefix:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">test_create_duplicated_ category</code>: Tests whether the unique constraints don't make it possible for us to create two categories with the same name or not. The second time we compose and send an HTTP <code class="literal">POST</code> request with a duplicate category name, we must receive an HTTP 400 Bad Request status code (<code class="literal">status.HTTP_400_BAD_REQUEST</code>) and the total number of <code class="literal">Category</code> objects retrieved from the database must be <code class="literal">1</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">test_retrieve_categories_list</code>: Tests whether we can retrieve the categories list or not. First, the method creates two categories and then it makes sure that the retrieved list includes the two created categories.</li><li class="listitem" style="list-style-type: disc"><code class="literal">test_update_game_category</code>: Tests whether we can update a single field for a category, specifically, its name field. The code makes sure that the name has been updated.</li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip58"/>Tip</h3><p>Note that each test that requires a specific condition in the database must execute all the necessary code for the database to be in this specific condition. For example, in order to update an existing category, first we must create a new category and then we can update it. Each test method will be executed without data from the previously executed test methods in the database, that is, each test will run with a database cleaned of data from previous tests.</p></div></div></div>
<div class="section" title="Running unit tests with nose2 and checking testing coverage"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec97"/>Running unit tests with nose2 and checking testing coverage</h1></div></div></div><p>Now, run the following command to create all the necessary tables in our test database and use the <code class="literal">nose2</code> test running to execute all the tests we created. The test runner will execute all the methods for our <code class="literal">InitialTests</code> class that start with the <code class="literal">test_</code> prefix and will display the results.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip59"/>Tip</h3><p>The tests won't make changes to the database we have been using when working on the API. Remember that we configured the <code class="literal">test_messages</code> database as our test database.</p></div></div><p>Remove the <code class="literal">api.py</code> file we created in the previous chapter from the <code class="literal">api</code> folder because we don't want the tests coverage to take into account this file. Go to the <code class="literal">api</code> folder and run the following command within the same virtual environment that we have been using. We will use the <code class="literal">-v</code> option to instruct <code class="literal">nose2</code> to print test case names and statuses. The <code class="literal">--with-coverage</code> option turns on test coverage reporting generation:</p><pre class="programlisting">
<span class="strong"><strong>nose2 -v --with-coverage</strong></span>
</pre><p>The following lines show the sample output.</p><pre class="programlisting">
<span class="strong"><strong>test_create_and_retrieve_category (test_views.InitialTests) ... ok</strong></span>
<span class="strong"><strong>test_create_duplicated_category (test_views.InitialTests) ... ok</strong></span>
<span class="strong"><strong>test_request_without_authentication (test_views.InitialTests) ... ok</strong></span>
<span class="strong"><strong>test_retrieve_categories_list (test_views.InitialTests) ... ok</strong></span>
<span class="strong"><strong>test_update_category (test_views.InitialTests) ... ok</strong></span>
<span class="strong"><strong>--------------------------------------------------------</strong></span>
<span class="strong"><strong>Ran 5 tests in 3.973s</strong></span>
<span class="strong"><strong>OK</strong></span>
<span class="strong"><strong>----------- coverage: platform win32, python 3.5.2-final-0 --</strong></span>
<span class="strong"><strong>Name                  Stmts   Miss  Cover</strong></span>
<span class="strong"><strong>-----------------------------------------</strong></span>
<span class="strong"><strong>app.py                    9      0   100%</strong></span>
<span class="strong"><strong>config.py                11     11     0%</strong></span>
<span class="strong"><strong>helpers.py               23     18    22%</strong></span>
<span class="strong"><strong>migrate.py                9      9     0%</strong></span>
<span class="strong"><strong>models.py               101     27    73%</strong></span>
<span class="strong"><strong>run.py                    4      4     0%</strong></span>
<span class="strong"><strong>status.py                56      5    91%</strong></span>
<span class="strong"><strong>test_config.py           12      0   100%</strong></span>
<span class="strong"><strong>tests\test_views.py      96      0   100%</strong></span>
<span class="strong"><strong>views.py                204    109    47%</strong></span>
<span class="strong"><strong>-----------------------------------------</strong></span>
<span class="strong"><strong>TOTAL                   525    183    65% </strong></span>
</pre><p>By default, <code class="literal">nose2</code> looks for modules whose names start with the <code class="literal">test</code> prefix. In this case, the only module that matches the criteria is the <code class="literal">test_views</code> module. In the modules that match the criteria, <code class="literal">nose2</code> loads tests from all the subclasses of <code class="literal">unittest.TestCase</code> and the functions whose names start with the <code class="literal">test</code> prefix.</p><p>The output provides details indicating that the test runner discovered and executed five tests and all of them passed. The output displays the method name and the class name for each method in the <code class="literal">InitialTests</code> class that started with the <code class="literal">test_</code> prefix and represented a test to be executed.</p><p>The test code coverage measurement report provided by the <code class="literal">coverage</code> package uses the code analysis tools and the tracing hooks included in the Python standard library to determine which lines of code are executable and have been executed. The report provides a table with the following columns:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Name</code>: The Python module name.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Stmts</code>: The count of executable statements for the Python module.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Miss</code>: The number of executable statements missed, that is, the ones that weren't executed.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Cover</code>: The coverage of executable statements expressed as a percentage.</li></ul></div><p>We definitely have a very low coverage for <code class="literal">views.py</code> and <code class="literal">helpers.py</code> based on the measurements shown in the report. In fact, we just wrote a few tests related to categories and users, and therefore, it makes sense that the coverage is really low for the views. We didn't create tests related to messages.</p><p>We can run the <code class="literal">coverage</code> command with the <code class="literal">-m</code> command-line option to display the line numbers of the missing statements in a new <code class="literal">Missing</code> column:</p><pre class="programlisting">
<span class="strong"><strong>coverage report -m</strong></span>
</pre><p>The command will use the information from the last execution and will display the missing statements. The next lines show a sample output that corresponds to the previous execution of the unit tests:</p><pre class="programlisting">
<span class="strong"><strong>Name                  Stmts   Miss  Cover   Missing</strong></span>
<span class="strong"><strong>---------------------------------------------------</strong></span>
<span class="strong"><strong>app.py                    9      0   100%</strong></span>
<span class="strong"><strong>config.py                11     11     0%   7-20</strong></span>
<span class="strong"><strong>helpers.py               23     18    22%   13-19, 23-44</strong></span>
<span class="strong"><strong>migrate.py                9      9     0%   7-19</strong></span>
<span class="strong"><strong>models.py               101     27    73%   28-29, 44, 46, 48, 50, 52, 54, 73-75, 79-86, 103, 127-137</strong></span>
<span class="strong"><strong>run.py                    4      4     0%   7-14</strong></span>
<span class="strong"><strong>status.py                56      5    91%   2, 6, 10, 14, 18</strong></span>
<span class="strong"><strong>test_config.py           12      0   100%</strong></span>
<span class="strong"><strong>tests\test_views.py      96      0   100%</strong></span>
<span class="strong"><strong>views.py                204    109    47%   43-45, 51-58, 63-64, 67, 71-72, 83-87, 92-94, 97-124, 127-135, 140-147, 150-181, 194-195, 198, 205-206, 209-212, 215-223, 235-236, 239, 250-253</strong></span>
<span class="strong"><strong>---------------------------------------------------</strong></span>
<span class="strong"><strong>TOTAL                   525    183    65%</strong></span>
</pre><p>Now, run the following command to get annotated HTML listings detailing missed lines:</p><pre class="programlisting">
<span class="strong"><strong>coverage html</strong></span>
</pre><p>Open the <code class="literal">index.html</code> HTML file generated in the <code class="literal">htmlcov</code> folder with your Web browser. The following picture shows an example report that coverage generated in HTML format:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_001.jpg" alt="Running unit tests with nose2 and checking testing coverage"/></div><p>
</p><p>Click or tap <code class="literal">views.py</code> and the Web browser will render a Web page that displays the statements that were run, the missing ones and the excluded, with different colors. We can click or tap on the <span class="strong"><strong>run</strong></span>, <span class="strong"><strong>missing</strong></span> and <span class="strong"><strong>excluded</strong></span> buttons to show or hide the background color that represents the status for each line of code. By default, the missing lines of code will be displayed with a pink background. Thus, we must write unit tests that target these lines of code to improve our test coverage:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_002.jpg" alt="Running unit tests with nose2 and checking testing coverage"/></div><p>
</p></div>
<div class="section" title="Improving testing coverage"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec98"/>Improving testing coverage</h1></div></div></div><p>Now, we will write additional unit tests to improve the testing coverage. Specifically, we will write unit tests related to messages and users. Open the existing <code class="literal">api/tests/test_views.py</code> file and insert the following lines after the last line, within the <code class="literal">InitialTests</code> class. We need a new <code class="literal">import</code> statement and we will declare the new <code class="literal">PlayerTests</code> class. The code file for the sample is included in the <code class="literal">restful_python_chapter_08_02</code> folder:</p><pre class="programlisting">
<span class="strong"><strong>    def create_message(self, message, duration, category):</strong></span> &#13;
        url = url_for('api.messagelistresource', _external=True) &#13;
        data = {'message': message, 'duration': duration, 'category': category} &#13;
        response = self.test_client.post( &#13;
            url,  &#13;
            headers=self.get_authentication_headers(self.test_user_name,&#13;
            self.test_user_password), &#13;
            data=json.dumps(data)) &#13;
        return response &#13;
 &#13;
    <span class="strong"><strong>def test_create_and_retrieve_message(self):</strong></span> &#13;
        """ &#13;
        Ensure we can create a new message and then retrieve it &#13;
        """ &#13;
        create_user_response = self.create_user(self.test_user_name,&#13;
        self.test_user_password) &#13;
        self.assertEqual(create_user_response.status_code,&#13;
        status.HTTP_201_CREATED) &#13;
        new_message_message = 'Welcome to the IoT world' &#13;
        new_message_category = 'Information' &#13;
        post_response = self.create_message(new_message_message, 15,&#13;
        new_message_category) &#13;
        self.assertEqual(post_response.status_code, status.HTTP_201_CREATED) &#13;
        self.assertEqual(Message.query.count(), 1) &#13;
        # The message should have created a new catagory &#13;
        self.assertEqual(Category.query.count(), 1) &#13;
        post_response_data = json.loads(post_response.get_data(as_text=True)) &#13;
        self.assertEqual(post_response_data['message'], new_message_message) &#13;
        new_message_url = post_response_data['url'] &#13;
        get_response = self.test_client.get( &#13;
            new_message_url, &#13;
            headers=self.get_authentication_headers(self.test_user_name,&#13;
            self.test_user_password)) &#13;
        get_response_data = json.loads(get_response.get_data(as_text=True)) &#13;
        self.assertEqual(get_response.status_code, status.HTTP_200_OK) &#13;
        self.assertEqual(get_response_data['message'], new_message_message) &#13;
        self.assertEqual(get_response_data['category']['name'],&#13;
        new_message_category) &#13;
 &#13;
 <span class="strong"><strong>   def test_create_duplicated_message(self):</strong></span> &#13;
        """ &#13;
        Ensure we cannot create a duplicated Message &#13;
        """ &#13;
        create_user_response = self.create_user(self.test_user_name,&#13;
        self.test_user_password) &#13;
        self.assertEqual(create_user_response.status_code,&#13;
        status.HTTP_201_CREATED) &#13;
        new_message_message = 'Welcome to the IoT world' &#13;
        new_message_category = 'Information' &#13;
        post_response = self.create_message(new_message_message, 15,&#13;
        new_message_category) &#13;
        self.assertEqual(post_response.status_code, status.HTTP_201_CREATED) &#13;
        self.assertEqual(Message.query.count(), 1) &#13;
        post_response_data = json.loads(post_response.get_data(as_text=True)) &#13;
        self.assertEqual(post_response_data['message'], new_message_message) &#13;
        new_message_url = post_response_data['url'] &#13;
        get_response = self.test_client.get( &#13;
            new_message_url, &#13;
            headers=self.get_authentication_headers(self.test_user_name,&#13;
            self.test_user_password)) &#13;
        get_response_data = json.loads(get_response.get_data(as_text=True)) &#13;
        self.assertEqual(get_response.status_code, status.HTTP_200_OK) &#13;
        self.assertEqual(get_response_data['message'], new_message_message) &#13;
        self.assertEqual(get_response_data['category']['name'],&#13;
        new_message_category) &#13;
        second_post_response = self.create_message(new_message_message, 15,&#13;
        new_message_category) &#13;
        self.assertEqual(second_post_response.status_code,&#13;
        status.HTTP_400_BAD_REQUEST) &#13;
        self.assertEqual(Message.query.count(), 1) &#13;
</pre><p>The preceding code adds many methods to the <code class="literal">InitialTests</code> class. The <code class="literal">create_message</code> method receives the desired <code class="literal">message</code>, <code class="literal">duration</code>, and <code class="literal">category</code> (category name) for the new message as arguments. The method builds the URL and the data dictionary to compose and send an HTTP <code class="literal">POST</code> method, create a new message, and return the response generated by this request. Many test methods will call the <code class="literal">create_message</code> method to create a message and then compose and send other HTTP requests to the API.</p><p>The class declares the following methods whose names start with the <code class="literal">test_</code> prefix:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">test_create_and_retrieve_message</code>: Tests whether we can create a new <code class="literal">Message</code> and then retrieve it.</li><li class="listitem" style="list-style-type: disc"><code class="literal">test_create_duplicated_message</code>: Tests whether the unique constraints don't make it possible for us to create two messages with the same message. The second time we compose and send an HTTP <code class="literal">POST</code> request with a duplicate message, we must receive an <code class="literal">HTTP 400 Bad Request</code> status code (<code class="literal">status.HTTP_400_BAD_REQUEST</code>) and the total number of <code class="literal">Message</code> objects retrieved from the database must be <code class="literal">1</code>.</li></ul></div><p>Open the existing <code class="literal">api/tests/test_views.py</code> file and insert the following lines after the last line, within the <code class="literal">InitialTests</code> class. The code file for the sample is included in the <code class="literal">restful_python_chapter_08_02</code> folder:</p><pre class="programlisting">
<span class="strong"><strong>    def test_retrieve_messages_list(self):</strong></span> &#13;
        """ &#13;
        Ensure we can retrieve the messages paginated list &#13;
        """ &#13;
        create_user_response = self.create_user(self.test_user_name,&#13;
        self.test_user_password) &#13;
        self.assertEqual(create_user_response.status_code,&#13;
        status.HTTP_201_CREATED) &#13;
        new_message_message_1 = 'Welcome to the IoT world' &#13;
        new_message_category_1 = 'Information' &#13;
        post_response = self.create_message(new_message_message_1, 15,&#13;
        new_message_category_1) &#13;
        self.assertEqual(post_response.status_code, status.HTTP_201_CREATED) &#13;
        self.assertEqual(Message.query.count(), 1) &#13;
        new_message_message_2 = 'Initialization of the board failed' &#13;
        new_message_category_2 = 'Error' &#13;
        post_response = self.create_message(new_message_message_2, 10,&#13;
        new_message_category_2) &#13;
        self.assertEqual(post_response.status_code, status.HTTP_201_CREATED) &#13;
        self.assertEqual(Message.query.count(), 2) &#13;
        get_first_page_url = url_for('api.messagelistresource', _external=True) &#13;
        get_first_page_response = self.test_client.get( &#13;
            get_first_page_url, &#13;
            headers=self.get_authentication_headers(self.test_user_name,&#13;
            self.test_user_password)) &#13;
        get_first_page_response_data =&#13;
        json.loads(get_first_page_response.get_data(as_text=True)) &#13;
        self.assertEqual(get_first_page_response.status_code, status.HTTP_200_OK) &#13;
        self.assertEqual(get_first_page_response_data['count'], 2) &#13;
        self.assertIsNone(get_first_page_response_data['previous']) &#13;
        self.assertIsNone(get_first_page_response_data['next']) &#13;
        self.assertIsNotNone(get_first_page_response_data['results']) &#13;
        self.assertEqual(len(get_first_page_response_data['results']), 2) &#13;
        self.assertEqual(get_first_page_response_data['results'][0]['message'],&#13;
        new_message_message_1) &#13;
        self.assertEqual(get_first_page_response_data['results'][1]['message'],&#13;
        new_message_message_2) &#13;
        get_second_page_url = url_for('api.messagelistresource', page=2) &#13;
        get_second_page_response = self.test_client.get( &#13;
            get_second_page_url, &#13;
            headers=self.get_authentication_headers(self.test_user_name,&#13;
            self.test_user_password)) &#13;
        get_second_page_response_data =&#13;
        json.loads(get_second_page_response.get_data(as_text=True)) &#13;
        self.assertEqual(get_second_page_response.status_code,&#13;
        status.HTTP_200_OK) &#13;
        self.assertIsNotNone(get_second_page_response_data['previous']) &#13;
        self.assertEqual(get_second_page_response_data['previous'],&#13;
        url_for('api.messagelistresource', page=1)) &#13;
        self.assertIsNone(get_second_page_response_data['next']) &#13;
        self.assertIsNotNone(get_second_page_response_data['results']) &#13;
        self.assertEqual(len(get_second_page_response_data['results']), 0) &#13;
     &#13;
</pre><p>The previous code added a <code class="literal">test_retrieve_messages_list</code> method to the <code class="literal">InitialTests</code> class. This method tests whether we can retrieve the paginated messages list. First, the method creates two messages and then it makes sure that the retrieved list includes the two created messages in the first page. In addition, the method makes sure that the second page doesn't include any message and that the value for the previous page includes the URL for the first page.</p><p>Open the existing <code class="literal">api/tests/test_views.py</code> file and insert the following lines after the last line, within the <code class="literal">InitialTests</code> class. The code file for the sample is included in the <code class="literal">restful_python_chapter_08_02</code> folder:</p><pre class="programlisting">
<span class="strong"><strong>    def test_update_message(self):</strong></span> &#13;
        """ &#13;
        Ensure we can update a single field for an existing message &#13;
        """ &#13;
        create_user_response = self.create_user(self.test_user_name,&#13;
        self.test_user_password) &#13;
        self.assertEqual(create_user_response.status_code,&#13;
        status.HTTP_201_CREATED) &#13;
        new_message_message_1 = 'Welcome to the IoT world' &#13;
        new_message_category_1 = 'Information' &#13;
        post_response = self.create_message(new_message_message_1, 30,&#13;
        new_message_category_1) &#13;
        self.assertEqual(post_response.status_code, status.HTTP_201_CREATED) &#13;
        self.assertEqual(Message.query.count(), 1) &#13;
        post_response_data = json.loads(post_response.get_data(as_text=True)) &#13;
        new_message_url = post_response_data['url'] &#13;
        new_printed_times = 1 &#13;
        new_printed_once = True &#13;
        data = {'printed_times': new_printed_times, 'printed_once':&#13;
        new_printed_once} &#13;
        patch_response = self.test_client.patch( &#13;
            new_message_url,  &#13;
            headers=self.get_authentication_headers(self.test_user_name,&#13;
            self.test_user_password), &#13;
            data=json.dumps(data)) &#13;
        self.assertEqual(patch_response.status_code, status.HTTP_200_OK) &#13;
        get_response = self.test_client.get( &#13;
            new_message_url, &#13;
            headers=self.get_authentication_headers(self.test_user_name,&#13;
            self.test_user_password)) &#13;
        get_response_data = json.loads(get_response.get_data(as_text=True)) &#13;
        self.assertEqual(get_response.status_code, status.HTTP_200_OK) &#13;
        self.assertEqual(get_response_data['printed_times'], new_printed_times) &#13;
        self.assertEqual(get_response_data['printed_once'], new_printed_once) &#13;
     &#13;
   <span class="strong"><strong> def test_create_and_retrieve_user(self):</strong></span> &#13;
        """ &#13;
        Ensure we can create a new User and then retrieve it &#13;
        """ &#13;
        new_user_name = self.test_user_name &#13;
        new_user_password = self.test_user_password &#13;
        post_response = self.create_user(new_user_name, new_user_password) &#13;
        self.assertEqual(post_response.status_code, status.HTTP_201_CREATED) &#13;
        self.assertEqual(User.query.count(), 1) &#13;
        post_response_data = json.loads(post_response.get_data(as_text=True)) &#13;
        self.assertEqual(post_response_data['name'], new_user_name) &#13;
        new_user_url = post_response_data['url'] &#13;
        get_response = self.test_client.get( &#13;
            new_user_url, &#13;
            headers=self.get_authentication_headers(self.test_user_name,&#13;
            self.test_user_password)) &#13;
        get_response_data = json.loads(get_response.get_data(as_text=True)) &#13;
        self.assertEqual(get_response.status_code, status.HTTP_200_OK) &#13;
        self.assertEqual(get_response_data['name'], new_user_name) &#13;
</pre><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The previous code added the following two methods to the <code class="literal">InitialTests</code> class-<code class="literal">test_update_message</code>-tests whether we can update more than one fields for a message, specifically, the values for the <code class="literal">printed_times</code> and <code class="literal">printed_once</code> fields. The code makes sure that both fields have been updated.</li><li class="listitem" style="list-style-type: disc"><code class="literal">test_create_and_retrieve_user</code>: Tests whether we can create a new <code class="literal">User</code> and then retrieve it.</li></ul></div><p>We just coded a few tests related to messages and one test related to users in order to improve test coverage and notice the impact on the test coverage report.</p><p>Now, run the following command within the same virtual environment we have been using:</p><pre class="programlisting">
<span class="strong"><strong>nose2 -v --with-coverage</strong></span>
</pre><p>The following lines show the sample output:</p><pre class="programlisting">
<span class="strong"><strong>test_create_and_retrieve_category (test_views.InitialTests) ... ok</strong></span>
<span class="strong"><strong>test_create_and_retrieve_message (test_views.InitialTests) ... ok</strong></span>
<span class="strong"><strong>test_create_and_retrieve_user (test_views.InitialTests) ... ok</strong></span>
<span class="strong"><strong>test_create_duplicated_category (test_views.InitialTests) ... ok</strong></span>
<span class="strong"><strong>test_create_duplicated_message (test_views.InitialTests) ... ok</strong></span>
<span class="strong"><strong>test_request_without_authentication (test_views.InitialTests) ... ok</strong></span>
<span class="strong"><strong>test_retrieve_categories_list (test_views.InitialTests) ... ok</strong></span>
<span class="strong"><strong>test_retrieve_messages_list (test_views.InitialTests) ... ok</strong></span>
<span class="strong"><strong>test_update_category (test_views.InitialTests) ... ok</strong></span>
<span class="strong"><strong>test_update_message (test_views.InitialTests) ... ok</strong></span>
<span class="strong"><strong>------------------------------------------------------------------</strong></span>
<span class="strong"><strong>Ran 10 tests in 25.938s</strong></span>
<span class="strong"><strong>OK</strong></span>
<span class="strong"><strong>----------- coverage: platform win32, python 3.5.2-final-0 -------</strong></span>
<span class="strong"><strong>Name                  Stmts   Miss  Cover</strong></span>
<span class="strong"><strong>-----------------------------------------</strong></span>
<span class="strong"><strong>app.py                    9      0   100%</strong></span>
<span class="strong"><strong>config.py                11     11     0%</strong></span>
<span class="strong"><strong>helpers.py               23      1    96%</strong></span>
<span class="strong"><strong>migrate.py                9      9     0%</strong></span>
<span class="strong"><strong>models.py               101     11    89%</strong></span>
<span class="strong"><strong>run.py                    4      4     0%</strong></span>
<span class="strong"><strong>status.py                56      5    91%</strong></span>
<span class="strong"><strong>test_config.py           16      0   100%</strong></span>
<span class="strong"><strong>tests\test_views.py     203      0   100%</strong></span>
<span class="strong"><strong>views.py                204     66    68%</strong></span>
<span class="strong"><strong>-----------------------------------------</strong></span>
<span class="strong"><strong>TOTAL                   636    107    83% </strong></span>
</pre><p>The output provided details indicating that the test runner executed <code class="literal">10</code> tests and all of them passed. The test code coverage measurement report provided by the <code class="literal">coverage</code> package increased the <code class="literal">Cover</code> percentage of the <code class="literal">views.py</code> module from <code class="literal">47%</code> in the previous run to <code class="literal">68%</code>. In addition, the percentage of the <code class="literal">helpers.py</code> module increased from <code class="literal">22%</code> to <code class="literal">96%</code> because we wrote tests that used pagination. The new additional tests we wrote executed additional code in different modules, and therefore, there is an impact in the coverage report.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip60"/>Tip</h3><p>We just created a few unit tests to understand how we can code them. However, of course, it would be necessary to write more tests to provide an appropriate coverage of all the featured and execution scenarios included in the API.</p></div></div></div>
<div class="section" title="Understanding strategies for deployments and scalability"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec99"/>Understanding strategies for deployments and scalability</h1></div></div></div><p>Flask is a lightweight microframework for the Web. However, as happens with Django, one of the biggest drawbacks related to Flask and Flask-RESTful is that each HTTP request is blocking. Thus, whenever the Flask server receives an HTTP request, it doesn't start working on any other HTTP requests in the incoming queue until the server sends the response for the first HTTP request it received.</p><p>We used Flask to develop a RESTful Web Service. They key advantage of these kind of Web Services is that they are stateless, that is, they shouldn't keep a client state on any server. Our API is a good example of a stateless RESTful Web Service with Flask and Flask RESTful. Thus, we can make the API run on as many servers as necessary to achieve our scalability goals. Obviously, we must take into account that we can easily transform the database server in our scalability bottleneck.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip61"/>Tip</h3><p>Nowadays, we have a huge number of cloud-based alternatives to deploy a RESTful Web Service that uses Flask and Flask-RESTful and make it extremely scalable.</p></div></div><p>We always have to make sure that we profile the API and the database before we deploy the first version of our API. It is very important to make sure that the generated queries run properly on the underlying database and that the most popular queries do not end up in sequential scans. It is usually necessary to add the appropriate indexes to the tables in the database.</p><p>We have been using basic HTTP authentication. We can improve it with a token-based authentication. We must make sure that the API runs under HTTPS in production environments. In addition, we must make sure that we change the following line in the <code class="literal">api/config.py</code> file:</p><pre class="programlisting">DEBUG = True &#13;
</pre><p>We must always turn off debug mode in production, and therefore, we must replace the previous line with the following one:</p><pre class="programlisting">DEBUG = False &#13;
</pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip62"/>Tip</h3><p>It is convenient to use a different configuration file for production. However, another approach that is becoming extremely popular, especially for cloud-native applications, is to store configuration in the environment. If we want to deploy cloud-native RESTful Web Services and follow the guidelines established in the twelve-factor App, we should store config in the environment.</p></div></div><p>Each platform includes detailed instructions to deploy our application. All of them will require us to generate the <code class="literal">requirements.txt</code> file that lists the application dependencies together with their versions. This way, the platforms will be able to install all the necessary dependencies listed in the file.</p><p>Run the following <code class="literal">pip freeze</code> to generate the <code class="literal">requirements.txt</code> file.</p><pre class="programlisting">
<span class="strong"><strong>pip freeze &gt; requirements.txt</strong></span>
</pre><p>The following lines show the contents of a sample generated <code class="literal">requirements.txt</code> file. However, bear in mind that many packages increase their version number quickly and you might see different versions in your configuration:</p><pre class="programlisting">
<span class="strong"><strong>alembic==0.8.8</strong></span>
<span class="strong"><strong>aniso8601==1.1.0</strong></span>
<span class="strong"><strong>click==6.6</strong></span>
<span class="strong"><strong>cov-core==1.15.0</strong></span>
<span class="strong"><strong>coverage==4.2</strong></span>
<span class="strong"><strong>Flask==0.11.1</strong></span>
<span class="strong"><strong>Flask-HTTPAuth==3.2.1</strong></span>
<span class="strong"><strong>flask-marshmallow==0.7.0</strong></span>
<span class="strong"><strong>Flask-Migrate==2.0.0</strong></span>
<span class="strong"><strong>Flask-RESTful==0.3.5</strong></span>
<span class="strong"><strong>Flask-Script==2.0.5</strong></span>
<span class="strong"><strong>Flask-SQLAlchemy==2.1</strong></span>
<span class="strong"><strong>itsdangerous==0.24</strong></span>
<span class="strong"><strong>Jinja2==2.8</strong></span>
<span class="strong"><strong>Mako==1.0.4</strong></span>
<span class="strong"><strong>MarkupSafe==0.23</strong></span>
<span class="strong"><strong>marshmallow==2.10.2</strong></span>
<span class="strong"><strong>marshmallow-sqlalchemy==0.10.0</strong></span>
<span class="strong"><strong>nose2==0.6.5</strong></span>
<span class="strong"><strong>passlib==1.6.5</strong></span>
<span class="strong"><strong>psycopg2==2.6.2</strong></span>
<span class="strong"><strong>python-dateutil==2.5.3</strong></span>
<span class="strong"><strong>python-editor==1.0.1</strong></span>
<span class="strong"><strong>pytz==2016.6.1</strong></span>
<span class="strong"><strong>six==1.10.0</strong></span>
<span class="strong"><strong>SQLAlchemy==1.0.15</strong></span>
<span class="strong"><strong>Werkzeug==0.11.11</strong></span>
</pre></div>
<div class="section" title="Test your knowledge"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec100"/>Test your knowledge</h1></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">By default, <code class="literal">nose2</code> looks for modules whose names start with the following prefix:<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem"><code class="literal">test</code></li><li class="listitem"><code class="literal">run</code></li><li class="listitem"><code class="literal">unittest</code></li></ol></div><p>
</p></li><li class="listitem">By default, <code class="literal">nose2</code> loads tests from all the subclasses of the following class:<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem"><code class="literal">unittest.Test</code></li><li class="listitem"><code class="literal">unittest.TestCase</code></li><li class="listitem"><code class="literal">unittest.RunTest</code></li></ol></div><p>
</p></li><li class="listitem">The <code class="literal">setUp</code> method in a subclass of <code class="literal">unittest.TestCase</code>:<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Is executed before each test method runs.</li><li class="listitem">Is executed only once before all the tests start their execution.</li><li class="listitem">Is executed only once after all the tests finish their execution.</li></ol></div><p>
</p></li><li class="listitem">The <code class="literal">tearDown</code> method in a subclass of <code class="literal">unittest.TestCase</code>:<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Is executed after each test method runs.</li><li class="listitem">Is executed before each test method runs.</li><li class="listitem">Is executed after a test method only when it fails.</li></ol></div><p>
</p></li><li class="listitem">If we declare a <code class="literal">get_accept_content_type_headers</code> method within a subclass of <code class="literal">unittest.TestCase</code>, by default, <code class="literal">nose2</code>:<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Will load this method as a test.</li><li class="listitem">Will load this method as the <code class="literal">setUp</code> method for each test.</li><li class="listitem">Won't load this method as a test.</li></ol></div><p>
</p></li></ol></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec101"/>Summary</h1></div></div></div><p>In this chapter, we set up a testing environment. We installed nose2 to make it easy to discover and execute unit tests, and we created a new database to be used for testing. We wrote a first round of unit tests, measured test coverage, and then we wrote additional unit tests to improve test coverage. Finally, we understood many considerations for deployment and scalability.</p><p>Now that we have built a complex API with Flask combined with Flask RESTful, and we tested it, we will move to another popular Python Web framework, Tornado, which is what we are going to discuss in the next chapter.</p></div></body></html>