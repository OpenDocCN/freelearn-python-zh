- en: Vision Processing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's really amazing what we can do using a simple combination of sensors and
    actuators. After all, these are the things that make robots what they are known
    for. There is a vast numbers of sensors available on the market today that we
    can use. We can put hundreds of sensors over a robot, but there is one thing that
    subsides the power of all other sensors. It's the camera. Sensors give us data
    about our physical environment, whereas the camera lets us see it. So, it is quite
    an important sensor to consider. In this chapter, we will go ahead and see how
    we can couple a camera to our Raspberry Pi and start computing with the image
    data that we get.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The basics of images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preparing Raspberry Pi for vision processing application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing OpenCV
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Image recognition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The basics of images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we say camera, we don't necessarily think of it as a sensor, even tough
    it is one. However, it is slightly different from all the sensors that we have
    studied until now. Most of the sensors are consisting of one sensing element such
    as proximity sensing, temperature sensing, or passive IR sensing. With a camera,
    what we are doing is capturing light; now, rather than having one light sensor,
    we have multiple, in fact an array of millions of these sensors grouped together
    on a single chip. But the story does not end here, and these sensors not only
    capture just light, but also different intensities of light; they can sense the
    color spectrum and its relative brightness. Every sensing element that does this
    functionality is named a **pixel**. Most of these pixels generate an RGB value,
    which is nothing but the intensity of red, green, and blue color. Why RGB, you
    might think? These are primary colors, and mixing these colors up in the right
    quantities results in making different shades of colors.
  prefs: []
  type: TYPE_NORMAL
- en: So, if we have a value of these colors, we can recreate the colors that we want.
    As we earlier understood, there are millions of these pixels in any camera, making
    up the length and the breadth of the image-sensing chip. The data from these image-sensing
    elements makes up the image. So far so good. But why are we talking about this? The
    reason is, this is how a camera sees the world and just to not how we see it.
    Biological vision is entirely a different story. So, we need to understand how
    the camera works and what the raw data that it gives is to go ahead and do the
    vision processing.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's get back to the pixels and their data. As there are millions of these
    pixels, there must be millions of readings of these pixels, and these readings
    would be in the form of RGB values. Now, this data must be arranged in a specific
    form so as to understand which pixel data we are dealing with. If it is not arranged,
    then none of this data would make any sense.
  prefs: []
  type: TYPE_NORMAL
- en: As you learned previously, an array/list is the best way to store large, structured
    data, and if you look at the data from the image, then it is nothing but the values
    of RGB for individual structured pixels. Perfect! So, now we know what we are
    dealing with and how we have to deal with it. Or do we?
  prefs: []
  type: TYPE_NORMAL
- en: As you may recollect, the images we are talking about here are made by millions
    of pixels. So, the pixel data would also be in the magnitude of millions as well.
    This data is extremely huge, as we are not just talking about millions of pixels
    but each RGB value. In other words, every single pixel will give us three values,
    that is, the value of red, green, and blue. In other words, it's a lot of data.
    Normal lists cannot handle this much of data; hence, we have to install a special
    library named **NumPy** to take care of this vast arrays. In this chapter, there
    are multiple dependencies that we will have to install and update in order for
    the Raspberry Pi to go ahead and do vision processing. We will see how we will
    install it.
  prefs: []
  type: TYPE_NORMAL
- en: Now moving forward, we have the data of every single pixel in a very structured
    way, but what are we exactly going to do with it? Well as you have learned in
    the previous chapters, when we have data in a structured form, then we can go
    ahead and do multiple operations as we have done in the previous chapter of lists.
    The data we are dealing with here is somewhat in a specific domain. That is, we
    know that the data we would be receiving would be image data. Hence, there are
    certain very specific libraries that has been made to do the tasks with ease.
    One of the most commonly used vision processing algorithm is OpenCV. It is widely
    used, and there are multiple functions in this library that are very specific
    to dealing with image data itself. So with a single command, you should be able
    to capture image, and with another command, we would be able to put filters over
    the image. No not the Instagram filters, but the filters that will segregate a
    specific type of object in the image from others.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we would also be able to output the data in the desired image format.
    So, it is quite interesting on what all we can do with OpenCV. But do keep in
    mind that this is an introductory lesson. OpenCV itself can be a topic for an
    entire book, but here, I'm trying to give you all a heads-up regarding the vision
    processing. You would be learning the basic commands and how to use it to make
    out projects.
  prefs: []
  type: TYPE_NORMAL
- en: Now it is time to stop talking and start doing stuff. So, let's see what all
    we have to do.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing Raspberry Pi for vision processing application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first thing you need to do is to make sure that you have ample time on
    your side and perhaps some popcorn to pass on the time. Because what we are about
    to start can be slightly long. How long, perhaps a few hours. If you have a slow
    internet connection, then you might even be spending an entire day. Also, one
    thing to note is that with time, there are various new updates that might come
    along on both the software and hardware end. This might mean that some of the
    commands might not work or might need some modification. A bit of Google might
    help in that situation. So, don''t get worried if something doesn''t work at the
    first go. Having said this, let''s start by making your Raspberry Pi ready and
    make sure that we have all the prerequisites for the vision processing. First,
    we need to prepare our Raspberry Pi for vision processing application. To start
    it off, ensure that you are always connected to the internet at all times once
    that box is checked, then go ahead and fire up the terminal on your Raspberry
    Pi. Once you are on it, you need to type the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/252614d1-3a6a-4073-a93d-b8e694d3cd3d.png)'
  prefs: []
  type: TYPE_IMG
- en: Therefore, the first command downloads the updates for the operating system
    of your Raspberry Pi, and the second line will go ahead and download the upgrades
    for the OS of your Raspberry Pi. Did you get what I am saying? No? Let me tell
    you a bit more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Your Raspberry Pi's OS has multiple packages that are used to do different activities.
    Now over the time, these packages get added functionalities, so when you update
    OS, you basically update the functionalities of the packages on your OS. This
    being one thing, sometimes new packages are also added to your Raspberry Pi's
    OS. They can be for various added functionalities. So an upgrade adds the new
    packages on to your operating system.
  prefs: []
  type: TYPE_NORMAL
- en: You must be asking why is all this necessary? Good question. There are multiple
    libraries that we will be using to make our code work. Now, the developer who
    made these would want his libraries to be better than ever and to do that he uses
    the latest packages of the Raspberry Pi. So now when you are trying to use the
    developer's libraries, then there is a good chance that it might need the latest
    packages and updates for it to run. Hence, it's always a good idea to update and
    upgrade your OS every few weeks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Until now, we have only downloaded those updates and upgrades. We haven''t
    really installed them. So to install them, we need to type the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you do this, you might like to restart your Raspberry Pi so that everything
    is up and running smoothly. To do this, you can go ahead and restart it manually,
    or you can take the pro way by wiring this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/08908a0a-c1b1-4293-8909-bb7486fc6b1e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Perfect, so now our system is up to date. Now we need to install some more
    packages that are specific to image processing. Without these packages, it would
    be very hard to do any vision processing . These individual commands can take
    some time to go through, but just be patient and download it and then I''ll explain
    what all of these are doing.  So without much delay, let''s go ahead and install
    these one by one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/e63510b5-c4a5-4060-afef-cc144d586695.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/9185f990-a822-43fd-8987-f1a9e966bc9d.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/014af506-acb2-48e3-a1e0-7b34b38fe10e.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/1ef2c495-1153-4913-8139-6b79006bf0f4.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/d8f11a8c-2ba6-48ec-9dfc-c918321b6e52.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/41a9c65d-2cfd-4d97-8617-95cb9893f3a7.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/cac5ce6f-b451-4d6e-b2d6-337cd531c81e.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/365aa3c5-d52f-4132-9ad4-aaad093ce886.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/345f6a90-3af1-40a1-ac1f-aa973ca054f2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once done, your system will be ready with all the prerequisites required by
    the OS to do vision processing. Now, let''s understand what each one of them is
    doing:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sudo apt-get install build-essential git cmake pkg-config`: This line is installing
    all the developer tools that you might need.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sudo apt-get install libavcodec-dev libavformat-dev libswscale-dev libv4l-dev` and `sudo
    apt-get install libxvidcore-dev libx264-dev`: In this line, we are installing
    video packages and codecs. This will make sure that the system is ready with I/O
    as the videos that we might be throwing at it later.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sudo apt-get install libjpeg8-dev libtiff5-dev libjasper-dev libpng12-dev`:
    As we installed the packages for videos, we are doing the same for the images
    as well.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sudo apt-get install libgtk2.0-dev`: We are installing a subpackage named
    the `gkt` development library. It is obvious that whenever we are processing some
    images, then we might also like to output it, perhaps in the form of images and
    simple GUI, and this library tells us to do exactly the same.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sudo apt-get install libatlas-base-dev gfortran`: Vision processing is a CPU-intensive
    task and when we are dealing with something that is not as powerful as a supercomputer,
    we must make sure that we are not wasting any CPU horsepower. To do this, we need
    to optimize the entire process, and this library helps us do that.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sudo apt-get install python2.7-dev python3-dev`: Now in this line, we are
    installing Python 2.7 and Python 3 header files. This necessary as without them,
    we would not be able to compile our code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, in all the preceding commands, we installed the dependencies of vision
    processing or in other words, the dependencies of OpenCV that we will be using
    to do the vision processing. Now it is time to prepare the environment of the
    Python so that we can run OpenCV. Go ahead, open the terminal, and type the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/7f53a5e0-bff3-41bf-a889-b0e8715f7033.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/9f0b080f-5c13-407b-b29c-b25494192166.png)![](img/9f0b080f-5c13-407b-b29c-b25494192166.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/f95894a9-ea6b-44b0-b633-c116ee95716c.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/b731cf0d-6729-43b3-9a2b-12d8c1e02f28.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s see what we have done:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cd~`: **cd** stands for **change of directory**, and the `~` sign stands for
    the main directory. So basically, we are switching to the main directory and the
    things that will be doing from here on will be done in the main directory itself.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wget -O opencv.zip https://github.com/Itseez/opencv/archive/3.4.0.zip`: This
    is pretty straightforward; we are downloading the OpenCV files from GitHub.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unzip opencv.zip`: Once we have downloaded all the files, we need to unzip
    those in order to use it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wget -O opencv_contrib.zip https://github.com/Itseez/opencv_contrib/archive/3.4.0`:
    Now we are downloading `contrib` files. That is, these are added extra functionalities
    that have been developed for the OpenCV over and above the functionalities it
    already has.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unzip opencv_contrib.zip`: Now this is a no-brainier. We are unzipping the
    `contrib` files that we have just downloaded.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Perfect! I know it''s taking a long time, and it''s slightly a task. But this
    is something that is undeniably necessary and without this, we would not be able
    to go ahead and do the vision processing on our system. So now that we have done
    all of the preceding tasks, we need to then set up the Python. Let''s go ahead
    and do it, then we will see why this is necessary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/e3eda02c-1985-49b3-84fb-355d35e9b060.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/9bfdbd5e-44e9-445d-b734-e1810393f26d.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/fbc21f6c-b2e9-43ba-a77d-d25f72ff9ab5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s see what this is all about:'
  prefs: []
  type: TYPE_NORMAL
- en: '`wget https://bootstrap.pypa.io/get-pip.py`: Now we are getting the `pip` package.
    The basic work of PIP is to manage the packages over the Python system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sudo python get-pip.py`: Now once we have got the package, it is time to run
    it and to do that we simply need to write the command.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sudo pip install virtualenv virtualenvwrapper`: This command is really interesting.
    What this is doing is installing something named `virtualenwrapper`. Now, this
    is an extension that lets us use the programs in a virtual environment. Why is
    this necessary? Well, it is a lifesaver when we talk about running various programs,
    which has various prerequisites. So, this helps us keeping all the programs running
    just fine by making a virtual environment where we have all the prerequisites
    already ready.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sudo rm -rf ~/.cache/pip`: We are simply using this command to clear the cache.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, after we are done with this. We would have to open the `.profile` file.
    To do this, we need to type the `sudo nano ~/.profile` command. This command will
    open the profile and then once it is open, copy following commands at the end
    of the files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/118706c3-a737-4fbb-a010-5b594b212818.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Why did we do this? Basically, the terminal needs to know where the virtual
    environment is, and by doing this, the terminal will get to know it. Now, again,
    fire up the terminal; we have to load a few more things. So, this is what we need
    to do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now after you are done with all of these commands, let''s see what they means
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '`source ~/.profile`: This is to make sure that everything is set up'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mkvirtualenv cv`: This is making a new environment named `cv`, and this is
    where we will be running all of the programs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`source ~/.profile`: Now as we have made a new virtual environment, we need
    to again make sure that everything is set up, and to do that, we need to type
    this line again'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`workon cv`: This command will tell the system that we are working on the virtual
    environment that we have just created by the name of  `cv`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pip install numpy`: This is a very important step; `numpy` is a library that
    helps us manage huge multidimensional arrays'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After you have performed all the preceding commands, the time has finally come
    to install the OpenCV, and we need to use the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'OK, so what did we do here? Let''s see:'
  prefs: []
  type: TYPE_NORMAL
- en: The `workon cv` command is simple; we are telling Python that we have to work
    on a virtual environment by the name of `cv`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `cd ~/opencv-3.4.0/` command, we are changing the directory and moving
    inside the folder of the installed OpenCV.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `mkdir build` command, we are making a new folder named `build`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `cd build` command, again we are using the basic `cd` command. This is
    changing the directory to which we have just made by the name `build`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next command is `cmake`. What this does is compile whatever it is told to. So,
    in the entire next command, we are installing various settings onto our Python.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have started compiling various settings, and now the next command is fairly
    important. Let''s see what it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Now, this command tells the Raspberry Pi how many cores it has to do while vision
    processing. Essentially, Raspberry Pi has four cores in total, so by giving a
    command of `-j4`, we are telling the Pi that we would be using all the four cores.
    Obviously, you would be thinking that it is always a good idea to use all the
    horsepower that we have. But that's certainly not the case. As, if we use all
    the cores, then it might not be able to do any other tasks. Not even take commands
    from the user. So, if you want to do some simultaneous task that let's say takes
    the vision processing data and applies it to do something else, then it might
    not be possible as you would have exhausted all the CPU compute power in the processing
    itself. However, for now, it is not the case. Hence, for the sake of time, we
    will be using all the cores.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now finally, the time has come at last that we install the OpenCV. So let''s
    see how we have to do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As you would have guessed, `sudo make install` is compiling OpenCV, and `sudo
    ldconfig` creates cache and links to the important and recently shared libraries.
  prefs: []
  type: TYPE_NORMAL
- en: 'OK, so you think we are done. Well no, we need to finish the installation process,
    but there are a few additional steps. This is the last step, so just be patient
    for a little bit longer, and we should be there without any problems. Here are
    the steps that you need to do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'As you have installed all the preceding steps, now OpenCV should be installed
    in this part of the directory. We are using an `ls` command, which is used to
    list the directories in the certain location. Once you are done with this, the
    system will revert back with the output shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/36e18c46-cc00-4982-b78c-2f2d53e9c4fd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, once this step is done, then we need to verify that everything we
    have done till now has been completed successfully. So, to do that, we simply
    need to run these commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `workon cv ` command will be used every time we need to work on OpenCV,
    so once that command is done, then the command `python` will open the Python library.
    If in any case the Python library is not installed properly, then it will revert
    with some errors, which means that the steps were not successful in which case
    you would have to install the OpenCV again. If everything is fine, then it will
    return the details, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b71ff518-cccc-412c-93d8-129c13c4fb73.png)'
  prefs: []
  type: TYPE_IMG
- en: Wo-hoo! At last, we have completed the installation. Now we are all set and
    ready to do vision processing over Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: Image recognition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, to go ahead and start doing vision processing, let''s connect the camera
    to Raspberry Pi. Once you have done that, you need to write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Before you actually compile this code, let me tell you what exactly we are
    doing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding line, we are importing the library `numpy` as `np`, or in
    other words, we have imported the library, and every time we need to call is we
    simply need to write `np`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding line, we are telling Raspberry Pi to capture the video from
    a specific port. Now you must be thinking that how do we know which port it is
    connected to?
  prefs: []
  type: TYPE_NORMAL
- en: The thing with ports is that, unlike GPIOs, they are not hardware dependent
    rather they are software allocated. So, if your camera is the first device to
    be connected to the USB port, then it is very likely to be connected to port `0`.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, a USB camera is the only piece of hardware that we are adding;
    hence, we can be very sure that it will be at port `0` only.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now the command is not only for port selection. The primary work for it is
    to capture the video from the camera. Now, every time we need to call it by our
    given name `cap` rather than the entire function itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding line, we are using the function `cv.VideoCapture(0)` by the
    name of `cap`. We are also using a function named `read()`. Now, what this will
    do is that it will return two things. First, it will return a Boolean value, or
    in another words, a true or a false. That is, whether the image has been captured
    successfully or not. The second reading, which we are more concerned with, is
    entire  frame read from the image. This whole data would be stored in form of
    an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In this line, we are using the library `cv2` and a function of the library
    named `imshow()`. What this does is that it shows the image that has been captured
    by the camera. Now going ahead, we have two arguments that are being passed, that
    is, `"Frame"` and `image`. Frame is the name of the window that would show us
    the captured image. Further to this, we have the second argument `image`. Now
    as we remember, we have stored the image in the variable named `image`. So, it
    will directly show what we have already stored in the previous line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In this line, we are doing something amazing. The `cvtColour()` function is
    a converter. What does it convert? As we know, the image is made of an array of
    two-dimensional pixels. What this function does is convert the values that our
    camera gives into the desired value of the user.
  prefs: []
  type: TYPE_NORMAL
- en: Let me explain this in a bit more detail. The camera that we are using gives
    us RGB image. So whatever we can see is a mix of carried brightness of these three
    colors. Now for our detection, we would like to convert it into hue, saturation,
    and value. Why are we doing that you may as, first it makes the task pretty easy
    for us. So to understand this, let's see what this hue, saturation, and value
    is.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hue basically represents the color we are talking about. Every hue value represents
    a specific color, and the saturation is the color intensity. So the more the saturation,
    the deeper it is, and the lower the saturation, the more faint the color is. Finally,
    value—this term can be confusing; this basically means how much black is there
    in the images. So let me give you a rough example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/375231a6-4584-47e8-bc92-0012f550d7a9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now the first image shows you the hue: `100`, saturation: `100`, and value: `100`.
    Hence, black is zero, the color is green, and saturation is `100`%. In the subsequent
    picture, you can see the color has faded when the saturation is kept on a lower
    percentage. Finally, when value is reduced in the next image, then the color gets
    really dark.'
  prefs: []
  type: TYPE_NORMAL
- en: So now coming back to the point, why hue saturation value? So now to detect
    any color, we simply need one unit instead of three different unit forming that
    color hence making the job simpler. There are various other reasons to do so as
    well. But at this time, it is not a concern for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now moving forward, we have passed on two arguments—`image`, which is where
    the converting algorithm will take the raw data from, second is `cv.Colour_BGR2HSV`,
    which basically tells us the algorithm to use during the conversion. So as we
    have already discussed, we have to convert the RGB values to **hue saturation
    values** (**HSV**). Finally, these values will be returned to a variable named
    `hsv`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In this line, we are giving the upper and lower range values, which needs to
    be detected. As you can see, we are detecting a green color; hence, we would be
    providing the upper and lower values for both the ends. If you want to change
    the color that you want to detect, then you simply need to change this value and
    the job will be done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we are segregating the objects that are falling in this color range and
    giving the value to an array. This is done by a section function named `inRange()`.
    So, there are three arguments that we need to pass. First, which image does it
    need to work on, what is the lower range value that it needs to detect, and the
    upper range value that we have provided as `hsv`, `lowerGreen`, `upperGreen`.
    The result of this would be an array that would have the value of the image that
    has all color to be blacked out and only the color that lies in the specific color
    range to be shown in a plain white color:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '`bitwise_and` is a function of `cv2` library; what it does is simply logical
    and of the two values of the array. The arguments that we are passing are `image`
    and the image with `mask`, or in other words, we are passing two images—one being
    the raw and the other being the `mask`. With this function, we are ending those
    two images. The result of this would an image that has a black background all
    around and the object that lies in the specific color range will be shown in a
    proper color image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We have previously used a function named `cv2.inRange`, and what it did was
    to filter out the specific color ranges that we had defined. Now, that function
    gave us a new array by the name of `mask`. What it had is an array that has all
    the value as null, except for those who fall into the specific color range. The
    image in the range would be the only one to be shown here. This would result in
    an image that is black all around except for the points wherein the color is in
    the specified range resulting in a white image. In our program, we are using `cv2.inRange`
    and storing the value into a variable named `mask`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `cv2.imshow()` function is something that we used before as well. This
    simply shows the resultant image of the array. Hence, we have given the command `cv2.imshow(''mask'',mask)`;
    hence, it would open a window by the name of `''mask''`, and thereafter in that
    window, it would show the resulting image stored in the `mask` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We are doing a similar thing here. In the previous lines, we have used the
    function named `cv2.bitwise_and()`. This was used to do the logical and of two
    image arrays, that is, `image` and `mask`, the result of which was `res`; hence,
    it would show us the image corresponding to it. Now that we have done the logical
    part of `image` and `mask`, the output will be an image that would be black all
    around, but the portion falling into our chosen category to be shown in their
    original color:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now this is interesting. The `cv2.waitKey()` function gives us the value of
    the key pressed. But the problem is that it returns a 32-bit integer value. However,
    when we talk about ASCII, it returns only 8 bit of data. Hence, we would have
    to only look for this 8 bits out of the 32-bit integer value returned by the `waitKey()`
    function. Now to do that, we are doing a logical `and` of the value received by
    the `waitKey()` and a hexadecimal number `0xFF` what this hexadecimal translates
    to is `11111111` in decimal. So when we add the 32-bit int to the hexadecimal
    number, we would only be left with the last 8-bit value, which is also the only relevant
    part for us. Hence, the value of key would a 8-bit ASCII value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we are taking a simple `if` statement and comparing the value of key to `ord(''q'')`.
    What the `ord` function does is that it takes in the argument and converts it
    into the ASCII value. So, in this function, if *q* key is pressed, then the loop
    would break and the program would come out of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This is a very simple command. It will close all the windows that we have opened
    using `cv2.imshow()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Using this function, we are releasing the camera. Hence, making this resource
    free and ready to be used by any other program.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to compute image data that we got from coupling
    the image to Raspberry Pi. In the next chapter, you will learn how to make a guard
    robot that can perform facial recognition.
  prefs: []
  type: TYPE_NORMAL
