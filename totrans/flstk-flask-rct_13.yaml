- en: '13'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Error Handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Error handling** is a critical component in the user experience of any web
    application. **Flask** provides several built-in tools and options for handling
    errors in a clean and efficient manner. The goal of error handling is to catch
    and respond to errors that may occur during the execution of your application
    such as runtime errors, exceptions, and invalid user inputs.'
  prefs: []
  type: TYPE_NORMAL
- en: Flask provides a built-in debugger that can be used to catch and diagnose errors
    during development. So, why is the concept of error handling so important in any
    web application? An error-handling mechanism provides meaningful error messages
    to users when things go south when expected to go north, helping to maintain the
    overall quality of the user experience. Also, proactive error handling makes debugging
    easy.
  prefs: []
  type: TYPE_NORMAL
- en: If error-handling implementation is well thought out, then debugging issues
    and identifying the root causes of problems in the application becomes easier.
    As a developer, you would also want to increase the reliability of your application
    by anticipating and handling potential errors. This invariably makes your application
    more reliable and less likely to break under unexpected conditions.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will explore the different strategies and techniques for
    handling errors in Flask web applications. You will understand and learn how to
    use the built-in **Flask debugger**, implement **error handlers**, and create
    custom **error pages** in order to provide meaningful feedback to the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the Flask debugger
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating error handlers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating custom error pages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tracking events in your application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending error emails to administrators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The complete code for this chapter is available on GitHub at: [https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter13](https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter13).'
  prefs: []
  type: TYPE_NORMAL
- en: Using the Flask debugger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Flask as a lightweight Python web framework is widely used for building web
    applications. One of the out-of-the-box benefits of using Flask is its built-in
    debugger, which provides a powerful tool for identifying and fixing errors in
    your application.
  prefs: []
  type: TYPE_NORMAL
- en: When an error occurs in your Flask application, the debugger will automatically
    be activated. The debugger will provide detailed information about the error,
    including a stack trace, source code context, and any variables that were in scope
    at the time the error occurred. This information is golden for determining the
    root cause of the error and possible ideas for fixing it.
  prefs: []
  type: TYPE_NORMAL
- en: The Flask debugger also provides some interactive tools that can be used to
    inspect the state of your application and understand what is happening. For instance,
    you can evaluate expressions and examine the values of variables. You can also
    set breakpoints in your code, and step through your code line by line to see how
    it is executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s examine this code snippet for illustration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this instance, you can set a breakpoint at the line before `c = a + b`, as
    done in the preceding code, and run the application. When the breakpoint is hit,
    you can enter the debugger and inspect the values of `a`, `b`, and `c`. You can
    also evaluate expressions and see their results. For instance, to evaluate the
    expression `a + b`, you can type `a + b` in the debugger’s command prompt and
    hit *Enter*. The result, `30`, will be displayed. You can also step through your
    code line by line by using the `n` command to go to the next line, and the `c`
    command to continue execution until the next breakpoint.
  prefs: []
  type: TYPE_NORMAL
- en: In this way, you can use the Flask debugger’s interactive tools to understand
    what is happening in your application and debug it more effectively. This can
    be especially useful when dealing with large or complex code bases. The Flask
    debugger’s interactive tools are useful when it is difficult to understand what
    is causing an error without additional tools and information.
  prefs: []
  type: TYPE_NORMAL
- en: Aside from interactive tools, Flask also provides a debug mode that can be enabled
    to provide more detailed error messages. When the debug mode is enabled, Flask
    will display detailed error pages with information about the error including a
    stack trace and the source code context. This information can be extremely helpful
    for debugging complex issues.
  prefs: []
  type: TYPE_NORMAL
- en: To enable the Flask debugger, simply set the `debug` configuration value to
    `True` in your Flask application. In this book project, we set this parameter
    in the `.env` file. You should only use this in development, as it can reveal
    sensitive information about your application to anyone who has access to it.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, Flask allows third-party extensions that can be used to enhance
    the debugging experience. For instance, `Flask-DebugToolbar` provides a toolbar
    that can be added to your application to display information about the current
    request and its context.
  prefs: []
  type: TYPE_NORMAL
- en: Flask’s built-in debugger is a powerful tool that can help you quickly identify
    and fix errors in your application. Whether you are working on a small project
    or an enterprise-grade application, the debugger provides valuable information
    that can help you resolve issues and improve the reliability and performance of
    your application.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will discuss and implement error handlers in Flask web applications.
  prefs: []
  type: TYPE_NORMAL
- en: Creating error handlers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Flask also provides a mechanism for handling errors called error handlers. Error
    handlers are functions that are invoked when a specific error occurs in your application.
    These functions can be used to return custom error pages, log information about
    the error, or perform any other action that is appropriate for the error. To define
    an error handler in the Flask web application, you need to use the `errorhandler`
    decorator.
  prefs: []
  type: TYPE_NORMAL
- en: The decorator takes the error code as its argument, and the function that it
    decorates is the error handler that will be invoked when that error occurs. The
    error handler function takes an error object as its argument, which provides information
    about the error that occurred. This information can be used to provide a more
    detailed error response to the client or to log additional information about the
    error for debugging purposes.
  prefs: []
  type: TYPE_NORMAL
- en: In Flask backend and **React** frontend applications, error handling is a crucial
    step in ensuring a smooth user experience. As mentioned earlier, the goal of error
    handlers is to provide meaningful feedback to the user when something goes wrong,
    rather than simply returning a generic error message.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, you can define error handlers for errors `400`, `404`, and `500`.
  prefs: []
  type: TYPE_NORMAL
- en: Flask backend
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following code shows error handlers that are created for the HTTP error
    codes `404` (not found), `400` (bad request), and `500` (internal server error):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `not_found`, `bad_request`, and `internal_server_error` functions return
    a `JSON` response containing an error message, along with the corresponding HTTP
    error codes.
  prefs: []
  type: TYPE_NORMAL
- en: React frontend
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the React frontend, you can handle these errors by making an HTTP request
    to the Flask backend and checking the response for errors. For example, you can
    use **Axios** in React:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The preceding error-handling code illustrates a React frontend communicating
    with a Flask backend API. The code imports `React`, `useState`, and `useEffect`
    hooks, as well as the `axios` library for making API requests. The code then defines
    a functional `Speakers` component that makes an API `GET` request to the `/api/v1/speakers`
    endpoint at the backend.
  prefs: []
  type: TYPE_NORMAL
- en: The `useEffect` hook is used to manage the API call, and the response is handled
    in a `.then()` block for success or a `.catch()` block for errors. In the `.catch()`
    block, the error response status is checked and a specific error message is set
    based on the status code. For instance, if the status code is `404`, `Resource
    not found` will be set as the error.
  prefs: []
  type: TYPE_NORMAL
- en: The error message is then displayed in the UI using conditional rendering, with
    the `No error` text being displayed if there is no error. The error message is
    stored in the state using the `useState` hook, with the initial value being `null`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will discuss and implement custom error pages in Flask web applications.
  prefs: []
  type: TYPE_NORMAL
- en: Creating custom error pages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to error handlers in Flask, you can also create custom error pages
    that provide a better user experience. When an error occurs in your application,
    the error handler can return a custom error page with information about the error,
    instructions for resolving the issue, or any other content that may be appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: To create a custom error page in Flask, simply create an error handler as described
    in the preceding section and return a `JSON` response that contains the content
    for the error page.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, let’s take a look at the `JSON` response containing a custom
    error message in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code returns a `JSON` response containing an error message, along
    with the corresponding HTTP error codes, when a `404` error occurs. Let’s define
    the React frontend to handle the UI with an `ErrorPage` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code shows the `ErrorPage` component that takes an error prop
    and displays it in the error message. You can use this component in your application
    to display the custom error page whenever an error occurs.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can simply add the `ErrorPage` component to the rest of the application.
    For instance, use the following code to add the `ErrorPage` component to the `Speaker`
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will discuss how to track and log events in Flask web applications.
  prefs: []
  type: TYPE_NORMAL
- en: Tracking events in your application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Flask allows you to track events in your application in an elegant way. This
    is critical to identifying potential issues. By tracking events, you can get a
    better understanding of what is happening in your application and make informed
    decisions about how to improve the situation.
  prefs: []
  type: TYPE_NORMAL
- en: There are several ways to track events in Flask, including using built-in logging
    functionality, third-party logging services, or custom code tracking. For instance,
    you can use the Python `logging` module to log information about your application
    activities to a file or to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the logging module is easy; simply import `logging` into your Flask application
    and configure it to log information at the appropriate level. For instance, the
    following code configures the logging module to log information to a file named
    `error.log`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code demonstrates the implementation of the logging module in
    a Flask web application. The code sets up a logger object using the `logging.getLogger(__name__)`
    method. The logger is set to the debug level with `logger.setLevel(logging.DEBUG)`.
    A `FileHandler` object is created with `file_handler = logging.FileHandler('error.log')`,
    and the handler is set to the debug level as well with `file_handler.setLevel(logging.DEBUG)`.
  prefs: []
  type: TYPE_NORMAL
- en: The handler is added to the logger object with `logger.addHandler(file_handler)`.
    In the `logger()` function, there are four logging methods called `debug()`, `info()`,
    `warning()`, and `error()`. These methods log messages to the log file with the
    respective log levels (debug, info, warning, and error). The messages logged are
    simple string messages.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, when tracking events in Flask applications, you can use a third-party
    logging service. Using third-party logging services with Flask can provide more
    advanced logging features such as centralized log management, real-time log searching,
    and alerting.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, you can use cloud-based log management services such as **AWS
    CloudWatch**, **Loggly**, and **Papertrail**.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s examine briefly the implementation of AWS CloudWatch. AWS CloudWatch is
    a logging service that provides log management and monitoring for AWS resources.
    To use AWS CloudWatch with Flask, you can use the **CloudWatch Logs** API to send
    log data directly to AWS CloudWatch.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps implement logging in Flask applications using AWS CloudWatch:'
  prefs: []
  type: TYPE_NORMAL
- en: Set up an AWS account and create a **CloudWatch** **Log Group**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install the `boto3` library, which provides a Python interface to the AWS CloudWatch
    API. Install `Boto2` with `pip install boto3` and ensure your virtual environment
    is activated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In your Flask application, import the `boto3` library and configure it with
    your AWS credentials.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a logger and set its log level to the desired level of verbosity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In your application code, use the logger to log messages at various levels such
    as info, warning, error, and so on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure the logger to send logs to AWS CloudWatch. This can be done by creating
    a custom handler that sends log messages to CloudWatch using the `boto3` library.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deploy your Flask application and monitor your logs in AWS CloudWatch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s explore the code implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The full source code can be found on GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding code shows the implementation of how to use the `boto3` library
    to send logs from a Flask application to AWS CloudWatch. It works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `boto3` library is imported and a default session is set up with the specified
    `AWS access key ID`, `secret access key`, and `region name`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A logger object is created using the `logging` module and the logging level
    is set to `DEBUG`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A `CloudWatch` client object is created using the `boto3` library.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A custom handler class named `CloudWatchHandler` is created that inherits from
    the `logging.Handler` class and overrides its `emit` method. In the `emit` method,
    the log message is formatted and sent to `AWS CloudWatch` using the `put_log_events`
    method of the `CloudWatch` client.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An instance of the `CloudWatchHandler` class is created and its logging level
    is set to `DEBUG`. This handler is then added to the logger object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A route named `/logging_with_aws_cloudwatch` is created that generates log messages
    of different levels (`debug`, `info`, `warning`, and `error`) using the logger
    object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Handling errors and tracking events in your Flask application is crucial to
    ensuring its reliability and robustness. With Flask’s built-in debugger, error
    handlers, custom error pages, logging, and third-party logging libraries, you
    can easily diagnose and resolve problems as they show up in Flask application
    development.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you are able to implement Flask’s built-in debugger, error handlers,
    custom error pages, logging, and third-party logging libraries, wouldn’t it be
    nice if you had the means for the admins to receive email messages about errors
    in your application logs in real time?
  prefs: []
  type: TYPE_NORMAL
- en: Let’s work through how this can be implemented in Flask.
  prefs: []
  type: TYPE_NORMAL
- en: Sending error emails to administrators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sending error emails to administrators provides an efficient way to notify them
    about errors and issues in your Flask application. This allows you to quickly
    identify and resolve problems before they escalate into bigger issues and negatively
    impact the user experience. The benefits include timely identification and resolution
    of errors, improved system reliability, and reduced downtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s delve into an example of sending error emails to administrators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code demonstrates the implementation of sending error emails
    to notify administrators about errors in a Flask application. It works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The code uses the `smtplib` and `email.mime.text` libraries to create and send
    an email message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `send_email(error)` function takes an error message as a parameter and creates
    an email message using the `MIMEText` object. The `subject`, `sender email address`,
    `recipient email address`, and `error message` are set for the email. The email
    is then sent using the `smtplib` library through the local email server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Flask’s `errorhandler` decorator is used to catch any `500` internal server
    errors that occur in the application. The `internal_server_error` function is
    called when an error `500` occurs, and it calls the `send_email` function with
    the error message passed as a parameter. The function returns a response to the
    user indicating that an error occurred and an email was sent to the administrator.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Error handling has been an essential aspect of software development from time
    immemorial. It is crucial to ensure that your Flask web application can handle
    errors effectively. We discussed the Flask debugger, error handlers, and custom
    error pages. With these, you can provide meaningful feedback to users and help
    maintain the stability and reliability of your application.
  prefs: []
  type: TYPE_NORMAL
- en: As full stack developers, we reinforced the importance of keeping in mind that
    error handling is a continuous process. You should regularly review and update
    your error-handling strategies to ensure that your application remains robust
    and resilient. We also considered logging errors and sending notifications to
    administrators so that you can quickly identify and resolve any issues that may
    arise.
  prefs: []
  type: TYPE_NORMAL
- en: In short, a bug-free development experience remains a mirage for any professional
    developer. You should be prepared to effectively handle expected and unexpected
    errors in your web applications. By doing so, your application will continue to
    deliver value to your users, even in the face of unexpected errors and failures.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will explore modular development in Flask using **Blueprints**. With
    Blueprints and modular architecture, you can easily maintain and scale your React-Flask
    web applications.
  prefs: []
  type: TYPE_NORMAL
