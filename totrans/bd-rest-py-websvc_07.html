<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch07"/>Chapter 7.  Improving and Adding Authentication to an API with Flask </h1></div></div></div><p>In this chapter, we will improve the RESTful API that we started in the previous chapter and we will add authentication related security to it. We will:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Improve unique constraints in the models</li><li class="listitem" style="list-style-type: disc">Update fields for a resource with the <code class="literal">PATCH</code> method</li><li class="listitem" style="list-style-type: disc">Code a generic pagination class</li><li class="listitem" style="list-style-type: disc">Add pagination features to the API</li><li class="listitem" style="list-style-type: disc">Understand the steps to add authentication and permissions</li><li class="listitem" style="list-style-type: disc">Add a user model</li><li class="listitem" style="list-style-type: disc">Create a schema to validate, serialize and deserialize users</li><li class="listitem" style="list-style-type: disc">Add authentication to resources</li><li class="listitem" style="list-style-type: disc">Create resource classes to handle users</li><li class="listitem" style="list-style-type: disc">Run migrations to generate the user table</li><li class="listitem" style="list-style-type: disc">Compose requests with the necessary authentication</li></ul></div><div><div><div><div><h1 class="title"><a id="ch07lvl1sec82"/>Improving unique constraints in the models</h1></div></div></div><p>When we created the <code class="literal">Category</code> model, we specified the <code class="literal">True</code> value for the unique argument when we created the <code class="literal">db.Column</code> instance named <code class="literal">name</code>. As a result, the migrations generated the necessary unique constraint to make sure that the <code class="literal">name</code> field has unique values in the <code class="literal">category</code> table. This way, the database won't allow us to insert duplicate values for <code class="literal">category.name</code>. However, the error message generated when we try to do so is not clear.</p><p>Run the following command to create a category with a duplicate name. There is already an existing category with the name equal to <code class="literal">'Information'</code>:</p><pre class="programlisting">
<strong>http POST :5000/api/categories/ name='Information'</strong>
</pre><p>The following is the equivalent <code class="literal">curl</code> command:</p><pre class="programlisting">
<strong>curl -iX POST -H "Content-Type: application/json" -d '{"name":"Information"}'
    :5000/api/categories/</strong>
</pre><p>The previous command will compose and send a <code class="literal">POST</code> HTTP request with the specified JSON key-value pair. The unique constraint in the <code class="literal">category.name</code> field won't allow the database table to persist the new category. Thus, the request will return an HTTP <code class="literal">400 Bad Request</code> status code with an integrity error message. The following lines show a sample response:</p><pre class="programlisting">
<strong>HTTP/1.0 400 BAD REQUEST</strong>
<strong>Content-Length: 282</strong>
<strong>Content-Type: application/json</strong>
<strong>Date: Mon, 15 Aug 2016 03:53:27 GMT</strong>
<strong>Server: Werkzeug/0.11.10 Python/3.5.1</strong>
<strong>{</strong>
<strong>    "error": "(psycopg2.IntegrityError) duplicate key value violates unique
         constraint "category_name_key"\nDETAIL:  Key (name)=(Information)
         already exists.\n [SQL: 'INSERT INTO category (name) VALUES (%(name)s)
         RETURNING category.id'] [parameters: {'name': 'Information'}]"</strong>
<strong>}</strong>
</pre><p>Obviously, the error message is extremely technical and provides too many details about the database and the query that failed. We might parse the error message to automatically generate a more user friendly error message. However, instead of doing so, we want to avoid trying to insert a row that we know will fail. We will add code to make sure that a category is unique before we try to persist it. Of course, there is still a chance to receive the previously shown error if somebody inserts a category with the same name between the time we run our code, indicating that a category name is unique, and persist the changes in the database. However, the chances are lower and we can reduce the changes of the previously shown error message to be shown.</p><div><div><h3 class="title"><a id="tip52"/>Tip</h3><p>In a production-ready REST API we should never return the error messages returned by SQLAlchemy or any other database-related data, as it might include sensitive data that we don't want the users of our API to be able to retrieve. In this case, we are returning all the errors for debugging purposes and to be able to improve our API.</p></div></div><p>Now, we will add a new class method to the <code class="literal">Category</code> class to allow us to determine whether a name is unique or not. Open the <code class="literal">api/models.py</code> file and add the following lines within the declaration of the <code class="literal">Category</code> class. The code file for the sample is included in the <code class="literal">restful_python_chapter_07_01</code> folder:</p><pre class="programlisting">    @classmethod 
    def is_unique(cls, id, name): 
        existing_category = cls.query.filter_by(name=name).first() 
        if existing_category is None: 
            return True 
        else: 
            if existing_category.id == id: 
                return True 
            else: 
                return False 
</pre><p>The new <code class="literal">Category.is_unique</code> class method receives the <code class="literal">id</code> and the <code class="literal">name</code> for the category that we want to make sure that has a unique name. If the category is a new one that hasn't been saved yet, we will receive a 0 for the <code class="literal">id</code> value. Otherwise, we will receive the category id in the argument.</p><p>The method calls the <code class="literal">query.filter_by</code> method for the current class to retrieve a category whose name matches the other category name. In case there is a category that matches the criteria, the method will return <code class="literal">True</code> only if the id is the same one than the one received in the argument. In case no category matches the criteria, the method will return <code class="literal">True</code>.</p><p>We will use the previously created class method to check whether a category is unique or not before creating and persisting it in the <code class="literal">CategoryListResource.post</code> method. Open the <code class="literal">api/views.py</code> file and replace the existing <code class="literal">post</code> method declared in the <code class="literal">CategoryListResource</code> class with the following lines. The lines that have been added or modified are highlighted. The code file for the sample is included in the <code class="literal">restful_python_chapter_07_01</code> folder:</p><pre class="programlisting">    def post(self): 
        request_dict = request.get_json() 
        if not request_dict: 
            resp = {'message': 'No input data provided'} 
            return resp, status.HTTP_400_BAD_REQUEST 
        errors = category_schema.validate(request_dict) 
        if errors: 
            return errors, status.HTTP_400_BAD_REQUEST 
        <strong>category_name = request_dict['name'] 
        if not Category.is_unique(id=0, name=category_name): 
            response = {'error': 'A category with the same name already exists'} 
            return response, status.HTTP_400_BAD_REQUEST</strong> 
        try:  
     <strong>       category = Category(category_name)</strong> 
            category.add(category) 
            query = Category.query.get(category.id) 
            result = category_schema.dump(query).data 
            return result, status.HTTP_201_CREATED 
            except SQLAlchemyError as e: 
            db.session.rollback() 
            resp = {"error": str(e)} 
            return resp, status.HTTP_400_BAD_REQUEST 
</pre><p>Now, we will perform the same validation in the <code class="literal">CategoryResource.patch</code> method. Open the <code class="literal">api/views.py</code> file and replace the existing <code class="literal">patch</code> method declared in the <code class="literal">CategoryResource</code> class with the following lines. The lines that have been added or modified are highlighted. The code file for the sample is included in the <code class="literal">restful_python_chapter_07_01</code> folder:</p><pre class="programlisting">    def patch(self, id): 
        category = Category.query.get_or_404(id) 
        category_dict = request.get_json() 
        if not category_dict: 
            resp = {'message': 'No input data provided'} 
            return resp, status.HTTP_400_BAD_REQUEST 
        errors = category_schema.validate(category_dict) 
        if errors: 
            return errors, status.HTTP_400_BAD_REQUEST 
        try: 
            if 'name' in category_dict: 
                category_name = category_dict['name']  
                <strong>if Category.is_unique(id=id, name=category_name): 
                    category.name = category_name 
                else: 
                    response = {'error': 'A category with the same name already</strong>
<strong>                     exists'} 
                    return response, status.HTTP_400_BAD_REQUEST</strong> 
            category.update() 
            return self.get(id) 
                except SQLAlchemyError as e: 
                db.session.rollback() 
                resp = {"error": str(e)} 
                return resp, status.HTTP_400_BAD_REQUEST 
</pre><p>Run the following command to again create a category with a duplicate name:</p><pre class="programlisting">
<strong>http POST :5000/api/categories/ name='Information'</strong>
</pre><p>The following is the equivalent <code class="literal">curl</code> command:</p><pre class="programlisting">
<strong>curl -iX POST -H "Content-Type: application/json" -d '{"name":"Information"}'
    :5000/api/categories/</strong>
</pre><p>The previous command will compose and send a <code class="literal">POST</code> HTTP request with the specified JSON key-value pair. The changes we made will generate a response with a user friendly error message and will avoid trying to persist the changes. The request will return an HTTP <code class="literal">400 Bad Request</code> status code with the error message in the JSON body. The following lines show a sample response:</p><pre class="programlisting">
<strong>HTTP/1.0 400 BAD REQUEST</strong>
<strong>Content-Length: 64</strong>
<strong>Content-Type: application/json</strong>
<strong>Date: Mon, 15 Aug 2016 04:38:43 GMT</strong>
<strong>Server: Werkzeug/0.11.10 Python/3.5.1</strong>
<strong>{</strong>
<strong>    "error": "A category with the same name already exists"</strong>
<strong>}</strong>
</pre><p>Now, we will add a new <code class="literal">class</code> method to the <code class="literal">Message</code> class to allow us to determine whether a message is unique or not. Open the <code class="literal">api/models.py</code> file and add the following lines within the declaration of the <code class="literal">Message</code> class. The code file for the sample is included in the <code class="literal">restful_python_chapter_07_01</code> folder:</p><pre class="programlisting">    @classmethod 
    def is_unique(cls, id, message): 
        existing_message = cls.query.filter_by(message=message).first() 
        if existing_message is None: 
            return True 
        else: 
            if existing_message.id == id: 
                return True 
            else: 
                return False 
</pre><p>The new <code class="literal">Message.is_unique</code> class method receives the <code class="literal">id</code> and the <code class="literal">message</code> for the message that we want to make sure that has a unique value for the message field. If the message is a new one that hasn't been saved yet, we will receive a <code class="literal">0</code> for the <code class="literal">id</code> value. Otherwise, we will receive the message id in the argument.</p><p>The method calls the <code class="literal">query.filter_by</code> method for the current class to retrieve a message whose message field matches the other message's message. In case there is a message that matches the criteria, the method will return <code class="literal">True</code> only if the id is the same one than the one received in the argument. In case no message matches the criteria, the method will return <code class="literal">True</code>.</p><p>We will use the previously created class method to check whether a message is unique or not before creating and persisting it in the <code class="literal">MessageListResource.post</code> method. Open the <code class="literal">api/views.py</code> file and replace the existing <code class="literal">post</code> method declared in the <code class="literal">MessageListResource</code> class with the following lines. The lines that have been added or modified are highlighted. The code file for the sample is included in the <code class="literal">restful_python_chapter_07_01</code> folder:</p><pre class="programlisting">    def post(self): 
        request_dict = request.get_json() 
        if not request_dict: 
            response = {'message': 'No input data provided'} 
            return response, status.HTTP_400_BAD_REQUEST 
        errors = message_schema.validate(request_dict) 
        if errors: 
            return errors, status.HTTP_400_BAD_REQUEST 
       <strong> message_message = request_dict['message'] 
        if not Message.is_unique(id=0, message=message_message): 
            response = {'error': 'A message with the same message already</strong>
<strong>            exists'} 
            return response, status.HTTP_400_BAD_REQUEST</strong> 
        try: 
            category_name = request_dict['category']['name'] 
            category = Category.query.filter_by(name=category_name).first() 
            if category is None: 
                # Create a new Category 
                category = Category(name=category_name) 
                db.session.add(category) 
            # Now that we are sure we have a category 
            # create a new Message 
            <strong>message = Message( 
                message=message_message, 
                duration=request_dict['duration'], 
                category=category)</strong> 
            message.add(message) 
            query = Message.query.get(message.id) 
            result = message_schema.dump(query).data 
            return result, status.HTTP_201_CREATED 
        except SQLAlchemyError as e: 
            db.session.rollback() 
            resp = {"error": str(e)} 
            return resp, status.HTTP_400_BAD_REQUEST 
</pre><p>Now, we will perform the same validation in the <code class="literal">MessageResource.patch</code> method. Open the <code class="literal">api/views.py</code> file and replace the existing <code class="literal">patch</code> method declared in the <code class="literal">MessageResource</code> class with the following lines. The lines that have been added or modified are highlighted. The code file for the sample is included in the <code class="literal">restful_python_chapter_07_01</code> folder:</p><pre class="programlisting">    def patch(self, id): 
        message = Message.query.get_or_404(id) 
        message_dict = request.get_json(force=True) 
        if 'message' in message_dict: 
            <strong>message_message = message_dict['message']  
            if Message.is_unique(id=id, message=message_message): 
                message.message = message_message 
            else: 
                response = {'error': 'A message with the same message already</strong>
<strong>                exists'} 
                return response, status.HTTP_400_BAD_REQUEST</strong> 
        if 'duration' in message_dict: 
            message.duration = message_dict['duration'] 
        if 'printed_times' in message_dict: 
            message.printed_times = message_dict['printed_times'] 
        if 'printed_once' in message_dict: 
            message.printed_once = message_dict['printed_once'] 
        dumped_message, dump_errors = message_schema.dump(message) 
        if dump_errors: 
            return dump_errors, status.HTTP_400_BAD_REQUEST 
        validate_errors = message_schema.validate(dumped_message) 
        if validate_errors: 
            return validate_errors, status.HTTP_400_BAD_REQUEST 
        try: 
            message.update() 
            return self.get(id) 
        except SQLAlchemyError as e: 
                db.session.rollback() 
                resp = {"error": str(e)} 
                return resp, status.HTTP_400_BAD_REQUEST 
</pre><p>Run the following command to create a message with a duplicate value for the message field:</p><pre class="programlisting">
<strong>http POST :5000/api/messages/ message='Checking temperature sensor' duration=25 category="Information"</strong>
</pre><p>The following is the equivalent <code class="literal">curl</code> command:</p><pre class="programlisting">
<strong>curl -iX POST -H "Content-Type: application/json" -d '{"message":"Checking temperature sensor", "duration":25, "category": "Information"}' :5000/api/messages/</strong>
</pre><p>The previous command will compose and send a <code class="literal">POST</code> HTTP request with the specified JSON key-value pair. The changes we made will generate a response with a user friendly error message and will avoid trying to persist the changes in the message. The request will return an HTTP <code class="literal">400 Bad Request</code> status code with the error message in the JSON body. The following lines show a sample response:</p><pre class="programlisting">
<strong>HTTP/1.0 400 BAD REQUEST</strong>
<strong>Content-Length: 66</strong>
<strong>Content-Type: application/json</strong>
<strong>Date: Mon, 15 Aug 2016 04:55:46 GMT</strong>
<strong>Server: Werkzeug/0.11.10 Python/3.5.1</strong>
<strong>{</strong>
<strong>    "error": "A message with the same message already exists"</strong>
<strong>}</strong>
</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec83"/>Updating fields for a resource with the PATCH method</h1></div></div></div><p>As we explained in <a class="link" href="ch06.html" title="Chapter 6.  Working with Models, SQLAlchemy, and Hyperlinked APIs in Flask">Chapter 6</a>
<em>, Working with Models, SQLAlchemy, and Hyperlinked APIs in Flask</em>, our API is able to update a single field for an existing resource, and therefore, we provide an implementation for the <code class="literal">PATCH</code> method. For example, we can use the <code class="literal">PATCH</code> method to update an existing message and set the value for its <code class="literal">printed_once</code> and <code class="literal">printed_times</code> fields to <code class="literal">true</code> and <code class="literal">1</code>. We don't want to use the <code class="literal">PUT</code> method because this method is meant to replace an entire message. The <code class="literal">PATCH</code> method is meant to apply a delta to an existing message, and therefore, it is the appropriate method to just change the value of those two fields.</p><p>Now, we will compose and send an HTTP request to update an existing message, specifically, to update the value of the <code class="literal">printed_once</code> and <code class="literal">printed_times</code> fields. Because we just want to update two fields, we will use the <code class="literal">PATCH</code> method instead of <code class="literal">PUT</code>. Make sure you replace <code class="literal">1</code> with the id or primary key of an existing message in your configuration:</p><pre class="programlisting">
<strong>http PATCH :5000/api/messages/1 printed_once=true printed_times=1</strong>
</pre><p>The following is the equivalent <code class="literal">curl</code> command:</p><pre class="programlisting">
<strong>curl -iX PATCH -H "Content-Type: application/json" -d '{"printed_once":"true", "printed_times":1}' :5000/api/messages/1</strong>
</pre><p>The previous command will compose and send a <code class="literal">PATCH</code> HTTP request with the following specified JSON key-value pairs:</p><pre class="programlisting">{ 
    "printed_once": true, 
    "printed_times": 1 
} 
</pre><p>The request has a number after <code class="literal">/api/messages/</code>, and therefore, it will match <code class="literal">'/messages/&lt;int:id&gt;'</code> and run the <code class="literal">MessageResource.patch</code> method, that is, the <code class="literal">patch</code> method for the <code class="literal">MessageResource</code> class. If a <code class="literal">Message</code> instance with the specified id exists, the code will retrieve the values for the <code class="literal">printed_times</code> and <code class="literal">printed_once</code> keys in the request dictionary update the <code class="literal">Message</code> instance and validate it.</p><p>If the updated <code class="literal">Message</code> instance is valid, the code will persist the changes in the database and the call to the method will return an HTTP <code class="literal">200 OK</code> status code and the recently updated <code class="literal">Message</code> instance serialized to JSON in the response body. The following lines show a sample response:</p><pre class="programlisting">
<strong>HTTP/1.0 200 OK</strong>
<strong>Content-Length: 368</strong>
<strong>Content-Type: application/json</strong>
<strong>Date: Tue, 09 Aug 2016 22:38:39 GMT</strong>
<strong>Server: Werkzeug/0.11.10 Python/3.5.1</strong>
<strong>{</strong>
<strong>    "category": {</strong>
<strong>        "id": 1, </strong>
<strong>        "name": "Information", </strong>
<strong>        "url": "http://localhost:5000/api/categories/1"</strong>
<strong>    }, </strong>
<strong>    "creation_date": "2016-08-08T12:18:43.260474+00:00", </strong>
<strong>    "duration": 5, </strong>
<strong>    "id": 1, </strong>
<strong>    "message": "Checking temperature sensor", </strong>
<strong>    "printed_once": true, </strong>
<strong>    "printed_times": 1, </strong>
<strong>    "url": "http://localhost:5000/api/messages/1"</strong>
<strong>}</strong>
</pre><p>We can run the commands explained in <a class="link" href="ch06.html" title="Chapter 6.  Working with Models, SQLAlchemy, and Hyperlinked APIs in Flask">Chapter 6</a>
<em>, </em>
<em>Working with Models, SQLAlchemy, and Hyperlinked APIs in Flask</em>, to check the contents of the tables that the migrations created in the PostgreSQL database. We will notice that the <code class="literal">printed_times</code> and <code class="literal">printed_once</code> values have been updated for the row in the message table. The following screenshot shows the contents for the updated row of the <code class="literal">message</code> table in a PostgreSQL database after running the HTTP request. The screenshot shows the results of executing the following SQL query: <code class="literal">SELECT * FROM message WHERE id = 1</code>:</p><p>
</p><div><img src="img/image_07_001.jpg" alt="Updating fields for a resource with the PATCH method"/></div><p>
</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec84"/>Coding a generic pagination class</h1></div></div></div><p>Our database has a few rows for each of the tables that persist the models we have defined. However, after we start working with our API in a real-life production environment, we will have hundreds of messages, and therefore, we will have to deal with large result sets. Thus, we will create a generic pagination class and we will use it to easily specify how we want large results sets to be split into individual pages of data.</p><p>First, we will compose and send HTTP requests to create <code class="literal">9</code> messages that belong to one of the categories we have created: <code class="literal">Information</code>. This way, we will have a total of 12 messages persisted in the database. We had 3 messages and we add 9 more.</p><pre class="programlisting">
<strong>http POST :5000/api/messages/ message='Initializing light controller' duration=25 category="Information"</strong>
<strong>http POST :5000/api/messages/ message='Initializing light sensor' duration=20 category="Information"</strong>
<strong>http POST :5000/api/messages/ message='Checking pressure sensor' duration=18 category="Information"</strong>
<strong>http POST :5000/api/messages/ message='Checking gas sensor' duration=14 category="Information"</strong>
<strong>http POST :5000/api/messages/ message='Setting ADC resolution' duration=22 category="Information"</strong>
<strong>http POST :5000/api/messages/ message='Setting sample rate' duration=15 category="Information"</strong>
<strong>http POST :5000/api/messages/ message='Initializing pressure sensor' duration=18 category="Information"</strong>
<strong>http POST :5000/api/messages/ message='Initializing gas sensor' duration=16 category="Information"</strong>
<strong>http POST :5000/api/messages/ message='Initializing proximity sensor' duration=5 category="Information"</strong>
</pre><p>The following are the equivalent <code class="literal">curl</code> commands:</p><pre class="programlisting">
<strong>curl -iX POST -H "Content-Type: application/json" -d '{"message":" Initializing light controller", "duration":25, "category": "Information"}' :5000/api/messages/</strong>
<strong>curl -iX POST -H "Content-Type: application/json" -d '{"message":"Initializing light sensor", "duration":20, "category": "Information"}' :5000/api/messages/</strong>
<strong>curl -iX POST -H "Content-Type: application/json" -d '{"message":"Checking pressure sensor", "duration":18, "category": "Information"}' :5000/api/messages/</strong>
<strong>curl -iX POST -H "Content-Type: application/json" -d '{"message":"Checking gas sensor", "duration":14, "category": "Information"}' :5000/api/messages/</strong>
<strong>curl -iX POST -H "Content-Type: application/json" -d '{"message":"Setting ADC resolution", "duration":22, "category": "Information"}' :5000/api/messages/</strong>
<strong>curl -iX POST -H "Content-Type: application/json" -d '{"message":"Setting sample rate", "duration":15, "category": "Information"}' :5000/api/messages/</strong>
<strong>curl -iX POST -H "Content-Type: application/json" -d '{"message":"Initializing pressure sensor", "duration":18, "category": "Information"}' :5000/api/messages/</strong>
<strong>curl -iX POST -H "Content-Type: application/json" -d '{"message":"Initializing gas sensor", "duration":16, "category": "Information"}' :5000/api/messages/</strong>
<strong>curl -iX POST -H "Content-Type: application/json" -d '{"message":"Initializing proximity sensor", "duration":5, "category": "Information"}' :5000/api/messages/</strong>
</pre><p>The previous commands will compose and send nine <code class="literal">POST</code> HTTP requests with the specified JSON key-value pairs. The request specifies <code class="literal">/api/messages/</code>, and therefore, it will match <code class="literal">'/messages/'</code> and run the <code class="literal">MessageListResource.post</code> method, that is, the <code class="literal">post</code> method for the <code class="literal">MessageListResource</code> class.</p><p>Now, we have 12 messages in our database. However, we don't want to retrieve the 12 messages when we compose and send a <code class="literal">GET</code> HTTP request to <code class="literal">/api/messages/</code>. We will create a customizable generic pagination class to include a maximum of 5 resources in each individual page of data.</p><p>Open the <code class="literal">api/config.py</code> file and add the following lines that declare two variables that configure the global pagination settings. The code file for the sample is included in the <code class="literal">restful_python_chapter_07_01</code> folder:</p><pre class="programlisting">PAGINATION_PAGE_SIZE = 5 
PAGINATION_PAGE_ARGUMENT_NAME = 'page' 
</pre><p>The value for the <code class="literal">PAGINATION_PAGE_SIZE</code> variable specifies a global setting with the default value for the page size, also known as limit. The value for the <code class="literal">PAGINATION_PAGE_ARGUMENT_NAME</code> specifies a global setting with the default value for the argument name that we will use in our requests to specify the page number we want to retrieve.</p><p>Create a new <code class="literal">helpers.py</code> file within the <code class="literal">api</code> folder. The following lines show the code that creates a new <code class="literal">PaginationHelper</code> class. The code file for the sample is included in the <code class="literal">restful_python_chapter_07_01</code> folder:</p><pre class="programlisting">from flask import url_for 
from flask import current_app 
 
 
class PaginationHelper(): 
    def __init__(self, request, query, resource_for_url, key_name, schema): 
        self.request = request 
        self.query = query 
        self.resource_for_url = resource_for_url 
        self.key_name = key_name 
        self.schema = schema 
        self.results_per_page = current_app.config['PAGINATION_PAGE_SIZE'] 
        self.page_argument_name =
        current_app.config['PAGINATION_PAGE_ARGUMENT_NAME'] 
 
    def paginate_query(self): 
        # If no page number is specified, we assume the request wants page #1 
        page_number = self.request.args.get(self.page_argument_name, 1, type=int) 
        paginated_objects = self.query.paginate( 
            page_number, 
            per_page=self.results_per_page, 
            error_out=False) 
        objects = paginated_objects.items 
        if paginated_objects.has_prev: 
            previous_page_url = url_for( 
                self.resource_for_url,  
                page=page_number-1,  
                _external=True) 
        else: 
            previous_page_url = None 
        if paginated_objects.has_next: 
            next_page_url = url_for( 
                self.resource_for_url, 
                page=page_number+1, 
                _external=True) 
        else: 
            next_page_url = None 
        dumped_objects = self.schema.dump(objects, many=True).data 
        return ({ 
            self.key_name: dumped_objects, 
            'previous': previous_page_url, 
            'next': next_page_url, 
            'count': paginated_objects.total 
        }) 
</pre><p>The <code class="literal">PaginationHelper</code> class declares a constructor, that is, the <code class="literal">__init__</code> method that received many arguments and uses them to initialize the attributes with the same names:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">request</code>: The Flask request object that will allow the <code class="literal">paginate_query</code> method to retrieve the page number value specified with the HTTP request.</li><li class="listitem" style="list-style-type: disc"><code class="literal">query</code>: The SQLAlchemy query that the <code class="literal">paginate_query</code> method has to paginate.</li><li class="listitem" style="list-style-type: disc"><code class="literal">resource_for_url</code>: A string with the resource name that the <code class="literal">paginate_query</code> method will use to generate the full URLs for the previous page and the next page.</li><li class="listitem" style="list-style-type: disc"><code class="literal">key_name</code>: A string with the key name that the <code class="literal">paginate_query</code> method will use to return the serialized objects.</li><li class="listitem" style="list-style-type: disc"><code class="literal">schema</code>: The Flask-Marshmallow <code class="literal">Schema</code> subclass that the <code class="literal">paginate_query</code> method must use to serialize the objects.</li></ul></div><p>In addition, the constructor reads and saves the values for the configuration variables we added to the <code class="literal">config.py</code> file in the <code class="literal">results_per_page</code> and <code class="literal">page_argument_name</code> attributes.</p><p>The class declares the <code class="literal">paginate_query</code> method. First, the code retrieves the page number specified in the request and saves it in the <code class="literal">page_number</code> variable. In case no page number is specified, the code assumes that request requires the first page. Then, the code calls the <code class="literal">self.query.paginate</code> method to retrieve the page number specified by <code class="literal">page_number</code> of the paginated result of objects from the database, with a number of results per page indicated by the value of the <code class="literal">self.results_per_page</code> attribute. The next line saves the paginated items from the <code class="literal">paginated_object.items</code> attribute in the <code class="literal">objects</code> variable.</p><p>If the value for the <code class="literal">paginated_objects.has_prev</code> attribute is <code class="literal">True</code>, it means that there is a previous page available. In this case, the code calls the <code class="literal">flask.url_for</code> function to generate the full URL for the previous page with the value of the <code class="literal">self.resource_for_url</code> attribute. The <code class="literal">_external</code> argument is set to <code class="literal">True</code> because we want to provide the full URL.</p><p>If the value for the <code class="literal">paginated_objects.has_next</code> attribute is <code class="literal">True</code>, it means that there is a next page available. In this case, the code calls the <code class="literal">flask.url_for</code> function to generate the full URL for the next page with the value of the <code class="literal">self.resource_for_url</code> attribute.</p><p>Then, the code calls the <code class="literal">self.schema.dump</code> method to serialize the partial results previously saved in the <code class="literal">object</code> variable, with the <code class="literal">many</code> argument set to <code class="literal">True</code>. The <code class="literal">dumped_objects</code> variable saves the reference to the <code class="literal">data</code> attribute of the results returned by the call to the <code class="literal">dump</code> method.</p><p>Finally, the method returns a dictionary with the following key-value pairs:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">self.key_name</code>: The serialized partial results saved in the <code class="literal">dumped_objects</code> variable.</li><li class="listitem" style="list-style-type: disc"><code class="literal">'previous'</code>: The full URL for the previous page saved in the <code class="literal">previous_page_url</code> variable.</li><li class="listitem" style="list-style-type: disc"><code class="literal">'previous'</code>: The full URL for the next page saved in the <code class="literal">next_page_url</code> variable.</li><li class="listitem" style="list-style-type: disc"><code class="literal">'count'</code>: The total number of objects available in the complete resultset retrieved from the <code class="literal">paginated_objects.total</code> attribute.</li></ul></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec85"/>Adding pagination features</h1></div></div></div><p>Open the <code class="literal">api/views.py</code> file and replace the code for the <code class="literal">MessageListResource.get</code> method with the highlighted lines in the next listing. In addition, make sure that you add the import statement. The code file for the sample is included in the <code class="literal">restful_python_chapter_07_01</code> folder:</p><pre class="programlisting">from helpers import PaginationHelper 
 
 
class MessageListResource(Resource): 
    <strong>def get(self): 
        pagination_helper = PaginationHelper( 
            request, 
            query=Message.query, 
            resource_for_url='api.messagelistresource', 
            key_name='results', 
            schema=message_schema) 
        result = pagination_helper.paginate_query() 
        return result</strong>
</pre><p>The new code for the <code class="literal">get</code> method creates an instance of the previously explained <code class="literal">PaginationHelper</code> class named <code class="literal">pagination_helper</code> with the <code class="literal">request</code> object as the first argument. The named arguments specify the <code class="literal">query</code>, <code class="literal">resource_for_url</code>, <code class="literal">key_name</code>, and <code class="literal">schema</code> that the <code class="literal">PaginationHelper</code> instance has to use to provide a paginated query result.</p><p>The next line calls the <code class="literal">pagination_helper.paginate_query</code> method that will return the results of the paginated query with the page number specified in the request. Finally, the method returns the results of the call to this method that include the previously explained dictionary. In this case, the paginated resultset with the messages will be rendered as a value of the <code class="literal">'results'</code> key, specified in the <code class="literal">key_name</code> argument.</p><p>Now, we will compose and send an HTTP request to retrieve all the messages, specifically an HTTP <code class="literal">GET</code> method to <code class="literal">/api/messages/</code>.</p><pre class="programlisting">
<strong>http :5000/api/messages/</strong>
</pre><p>The following is the equivalent curl command:</p><pre class="programlisting">
<strong>curl -iX GET :5000/api/messages/</strong>
</pre><p>The new code for the <code class="literal">MessageListResource.get</code> method will work with pagination and the result will provide us the first 5 messages (<code class="literal">results</code> key), the total number of messages for the query (<code class="literal">count</code> key) and a link to the next (<code class="literal">next</code> key) and previous (<code class="literal">previous</code> key) pages. In this case, the resultset is the first page, and therefore, the link to the previous page (previous <code class="literal">key</code>) is <code class="literal">null</code>. We will receive a <code class="literal">200 OK</code> status code in the response header and the 5 messages in the <code class="literal">results</code> array:</p><pre class="programlisting">
<strong>HTTP/1.0 200 OK</strong>
<strong>Content-Length: 2521</strong>
<strong>Content-Type: application/json</strong>
<strong>Date: Wed, 10 Aug 2016 18:26:44 GMT</strong>
<strong>Server: Werkzeug/0.11.10 Python/3.5.1</strong>
<strong>{</strong>
<strong>    "count": 12, </strong>
<strong>    "results": [</strong>
<strong>        {</strong>
<strong>            "category": {</strong>
<strong>                "id": 1, </strong>
<strong>                "name": "Information", </strong>
<strong>                "url": "http://localhost:5000/api/categories/1"</strong>
<strong>            }, </strong>
<strong>            "creation_date": "2016-08-08T12:27:30.124511+00:00", </strong>
<strong>            "duration": 8, </strong>
<strong>            "id": 2, </strong>
<strong>            "message": "Checking light sensor", </strong>
<strong>            "printed_once": false, </strong>
<strong>            "printed_times": 0, </strong>
<strong>            "url": "http://localhost:5000/api/messages/2"</strong>
<strong>        }, </strong>
<strong>        {</strong>
<strong>            "category": {</strong>
<strong>                "id": 3, </strong>
<strong>                "name": "Error", </strong>
<strong>                "url": "http://localhost:5000/api/categories/3"</strong>
<strong>            }, </strong>
<strong>            "creation_date": "2016-08-08T14:20:22.103752+00:00", </strong>
<strong>            "duration": 10, </strong>
<strong>            "id": 3, </strong>
<strong>            "message": "Temperature sensor error", </strong>
<strong>            "printed_once": false, </strong>
<strong>            "printed_times": 0, </strong>
<strong>            "url": "http://localhost:5000/api/messages/3"</strong>
<strong>        }, </strong>
<strong>        {</strong>
<strong>            "category": {</strong>
<strong>                "id": 1, </strong>
<strong>                "name": "Information", </strong>
<strong>                "url": "http://localhost:5000/api/categories/1"</strong>
<strong>            }, </strong>
<strong>            "creation_date": "2016-08-08T12:18:43.260474+00:00", </strong>
<strong>            "duration": 5, </strong>
<strong>            "id": 1, </strong>
<strong>            "message": "Checking temperature sensor", </strong>
<strong>            "printed_once": true, </strong>
<strong>            "printed_times": 1, </strong>
<strong>            "url": "http://localhost:5000/api/messages/1"</strong>
<strong>        }, </strong>
<strong>        {</strong>
<strong>            "category": {</strong>
<strong>                "id": 1, </strong>
<strong>                "name": "Information", </strong>
<strong>                "url": "http://localhost:5000/api/categories/1"</strong>
<strong>            }, </strong>
<strong>            "creation_date": "2016-08-09T20:18:26.648071+00:00", </strong>
<strong>            "duration": 25, </strong>
<strong>            "id": 4, </strong>
<strong>            "message": "Initializing light controller", </strong>
<strong>            "printed_once": false, </strong>
<strong>            "printed_times": 0, </strong>
<strong>            "url": "http://localhost:5000/api/messages/4"</strong>
<strong>        }, </strong>
<strong>        {</strong>
<strong>            "category": {</strong>
<strong>                "id": 1, </strong>
<strong>                "name": "Information", </strong>
<strong>                "url": "http://localhost:5000/api/categories/1"</strong>
<strong>            }, </strong>
<strong>            "creation_date": "2016-08-09T20:19:16.174807+00:00", </strong>
<strong>            "duration": 20, </strong>
<strong>            "id": 5, </strong>
<strong>            "message": "Initializing light sensor", </strong>
<strong>            "printed_once": false, </strong>
<strong>            "printed_times": 0, </strong>
<strong>            "url": "http://localhost:5000/api/messages/5"</strong>
<strong>        }</strong>
<strong>    ], </strong>
<strong>    "next": "http://localhost:5000/api/messages/?page=2", </strong>
<strong>    "previous": null</strong>
<strong>}</strong>
</pre><p>In the previous HTTP request, we didn't specify any value for the <code class="literal">page</code> parameter, and therefore the <code class="literal">paginate_query</code> method in the <code class="literal">PaginationHelper</code> class requests the first page to the paginated query. If we compose and send the following HTTP request to retrieve the first page of all the messages by specifying 1 for the <code class="literal">page</code> value, the API will provide the same results shown before:</p><pre class="programlisting">
<strong>http ':5000/api/messages/?page=1'</strong>
</pre><p>The following is the equivalent curl command:</p><pre class="programlisting">
<strong>curl -iX GET ':5000/api/messages/?page=1'</strong>
</pre><div><div><h3 class="title"><a id="tip53"/>Tip</h3><p>The code in the <code class="literal">PaginationHelper</code> class considers that first page is page number 1. Thus, we don't work with zero-based numbering for pages.</p></div></div><p>Now, we will compose and send an HTTP request to retrieve the next page, that is, the second page for the messages, specifically an HTTP <code class="literal">GET</code> method to <code class="literal">/api/messages/</code> with the <code class="literal">page</code> value set to <code class="literal">2</code>. Remember that the value for the <code class="literal">next</code> key returned in the JSON body of the previous result provides us with the full URL to the next page:</p><pre class="programlisting">
<strong>http ':5000/api/messages/?page=2'</strong>
</pre><p>The following is the equivalent <code class="literal">curl</code> command:</p><pre class="programlisting">
<strong>curl -iX GET ':5000/api/messages/?page=2'</strong>
</pre><p>The result will provide us the second set of the five message resource (<code class="literal">results</code> key), the total number of messages for the query (<code class="literal">count</code> key), a link to the next (<code class="literal">next</code> key), and previous (<code class="literal">previous</code> key) pages. In this case, the resultset is the second page, and therefore, the link to the previous page (previous <code class="literal">key</code>) is <code class="literal">http://localhost:5000/api/messages/?page=1</code>. We will receive a <code class="literal">200 OK</code> status code in the response header and the 5 messages in the <code class="literal">results</code> array.</p><pre class="programlisting">
<strong>HTTP/1.0 200 OK</strong>
<strong>Content-Length: 2557</strong>
<strong>Content-Type: application/json</strong>
<strong>Date: Wed, 10 Aug 2016 19:51:50 GMT</strong>
<strong>Server: Werkzeug/0.11.10 Python/3.5.1</strong>
<strong>{</strong>
<strong>    "count": 12, </strong>
<strong>    "next": "http://localhost:5000/api/messages/?page=3", </strong>
<strong>    "previous": "http://localhost:5000/api/messages/?page=1", </strong>
<strong>    "results": [</strong>
<strong>        {</strong>
<strong>            "category": {</strong>
<strong>                "id": 1, </strong>
<strong>                "name": "Information", </strong>
<strong>                "url": "http://localhost:5000/api/categories/1"</strong>
<strong>            }, </strong>
<strong>            "creation_date": "2016-08-09T20:19:22.335600+00:00", </strong>
<strong>            "duration": 18, </strong>
<strong>            "id": 6, </strong>
<strong>            "message": "Checking pressure sensor", </strong>
<strong>            "printed_once": false, </strong>
<strong>            "printed_times": 0, </strong>
<strong>            "url": "http://localhost:5000/api/messages/6"</strong>
<strong>        }, </strong>
<strong>        {</strong>
<strong>            "category": {</strong>
<strong>                "id": 1, </strong>
<strong>                "name": "Information", </strong>
<strong>                "url": "http://localhost:5000/api/categories/1"</strong>
<strong>            }, </strong>
<strong>            "creation_date": "2016-08-09T20:19:26.189009+00:00", </strong>
<strong>            "duration": 14, </strong>
<strong>            "id": 7, </strong>
<strong>            "message": "Checking gas sensor", </strong>
<strong>            "printed_once": false, </strong>
<strong>            "printed_times": 0, </strong>
<strong>            "url": "http://localhost:5000/api/messages/7"</strong>
<strong>        }, </strong>
<strong>        {</strong>
<strong>            "category": {</strong>
<strong>                "id": 1, </strong>
<strong>                "name": "Information", </strong>
<strong>                "url": "http://localhost:5000/api/categories/1"</strong>
<strong>            }, </strong>
<strong>            "creation_date": "2016-08-09T20:19:29.854576+00:00", </strong>
<strong>            "duration": 22, </strong>
<strong>            "id": 8, </strong>
<strong>            "message": "Setting ADC resolution", </strong>
<strong>            "printed_once": false, </strong>
<strong>            "printed_times": 0, </strong>
<strong>            "url": "http://localhost:5000/api/messages/8"</strong>
<strong>        }, </strong>
<strong>        {</strong>
<strong>            "category": {</strong>
<strong>                "id": 1, </strong>
<strong>                "name": "Information", </strong>
<strong>                "url": "http://localhost:5000/api/categories/1"</strong>
<strong>            }, </strong>
<strong>            "creation_date": "2016-08-09T20:19:33.838977+00:00", </strong>
<strong>            "duration": 15, </strong>
<strong>            "id": 9, </strong>
<strong>            "message": "Setting sample rate", </strong>
<strong>            "printed_once": false, </strong>
<strong>            "printed_times": 0, </strong>
<strong>            "url": "http://localhost:5000/api/messages/9"</strong>
<strong>        }, </strong>
<strong>        {</strong>
<strong>            "category": {</strong>
<strong>                "id": 1, </strong>
<strong>                "name": "Information", </strong>
<strong>                "url": "http://localhost:5000/api/categories/1"</strong>
<strong>            }, </strong>
<strong>            "creation_date": "2016-08-09T20:19:37.830843+00:00", </strong>
<strong>            "duration": 18, </strong>
<strong>            "id": 10, </strong>
<strong>            "message": "Initializing pressure sensor", </strong>
<strong>            "printed_once": false, </strong>
<strong>            "printed_times": 0, </strong>
<strong>            "url": "http://localhost:5000/api/messages/10"</strong>
<strong>        }</strong>
<strong>    ]</strong>
<strong>}</strong>
</pre><p>Finally, we will compose and send an HTTP request to retrieve the last page, that is, the third page for the messages, specifically an HTTP <code class="literal">GET</code> method to <code class="literal">/api/messages/</code> with the <code class="literal">page</code> value set to <code class="literal">3</code>. Remember that the value for the next key returned in the JSON body of the previous result provides us with the URL to the next page:</p><pre class="programlisting">
<strong>http ':5000/api/messages/?page=3'</strong>
</pre><p>The following is the equivalent curl command:</p><pre class="programlisting">
<strong>curl -iX GET ':5000/api/messages/?page=3'</strong>
</pre><p>The result will provide us the last set with two message resources (<code class="literal">results</code> key), the total number of messages for the query (<code class="literal">count</code> key), a link to the next (<code class="literal">next</code> key), and previous (<code class="literal">previous</code> key) pages. In this case, the resultset is the last page, and therefore, the link to the next page (<code class="literal">next</code> key) is <code class="literal">null</code>. We will receive a <code class="literal">200 OK</code> status code in the response header and the 2 messages in the <code class="literal">results</code> array:</p><pre class="programlisting">
<strong>HTTP/1.0 200 OK</strong>
<strong>Content-Length: 1090</strong>
<strong>Content-Type: application/json</strong>
<strong>Date: Wed, 10 Aug 2016 20:02:00 GMT</strong>
<strong>Server: Werkzeug/0.11.10 Python/3.5.1</strong>
<strong>{</strong>
<strong>    "count": 12, </strong>
<strong>    "next": null, </strong>
<strong>    "previous": "http://localhost:5000/api/messages/?page=2", </strong>
<strong>    "results": [</strong>
<strong>        {</strong>
<strong>            "category": {</strong>
<strong>                "id": 1, </strong>
<strong>                "name": "Information", </strong>
<strong>                "url": "http://localhost:5000/api/categories/1"</strong>
<strong>            }, </strong>
<strong>            "creation_date": "2016-08-09T20:19:41.645628+00:00", </strong>
<strong>            "duration": 16, </strong>
<strong>            "id": 11, </strong>
<strong>            "message": "Initializing gas sensor", </strong>
<strong>            "printed_once": false, </strong>
<strong>            "printed_times": 0, </strong>
<strong>            "url": "http://localhost:5000/api/messages/11"</strong>
<strong>        }, </strong>
<strong>        {</strong>
<strong>            "category": {</strong>
<strong>                "id": 1, </strong>
<strong>                "name": "Information", </strong>
<strong>                "url": "http://localhost:5000/api/categories/1"</strong>
<strong>            }, </strong>
<strong>            "creation_date": "2016-08-09T20:19:45.304391+00:00", </strong>
<strong>            "duration": 5, </strong>
<strong>            "id": 12, </strong>
<strong>            "message": "Initializing proximity sensor", </strong>
<strong>            "printed_once": false, </strong>
<strong>            "printed_times": 0, </strong>
<strong>            "url": "http://localhost:5000/api/messages/12"</strong>
<strong>        }</strong>
<strong>    ]</strong>
<strong>}</strong>
</pre></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec86"/>Understanding the steps to add authentication and permissions</h1></div></div></div><p>Our current version of the API processes all the incoming requests without requiring any kind of authentication. We will use a Flask extension and other packages to use an HTTP authentication scheme to identify the user that originated the request or the token that signed the request. Then, we will use these credentials to apply the permissions that will determine whether the request must be permitted or not. Unluckily, neither Flask nor Flask-RESTful provides an authentication framework that we can easily plug and configure. Thus, we will have to write code to perform many tasks related to authentication and permissions.</p><p>We want to be able to create a new user without any authentication. However, all the other API calls are only going to be available for authenticated users.</p><p>First, we will install a Flask extension to make it easier for us to work with HTTP authentication, <code class="literal">Flask-HTTPAuth</code>, and a package to allow us to hash a password and check whether a provided password is valid or not, <code class="literal">passlib</code>.</p><p>We will create a new <code class="literal">User</code> model that will represent a user. The model will provide methods to allow us to hash a password and verify whether a password provided for a user is valid or not. We will create a <code class="literal">UserSchema</code> class to specify how we want to serialize and deserialize a user.</p><p>Then, we will configure the Flask extension to work with our <code class="literal">User</code> model to verify passwords and set the authenticated user associated with a request. We will make changes to the existing resources to require authentication and we will new resources to allow us to retrieve existing users and create a new one. Finally, we will configure the routes for the resources related to users.</p><p>Once we have completed the previously mentioned tasks, we will run migrations to generate the new table that persists the users in the database. Then, we will compose and send HTTP requests to understand how the authentication and permissions work with our new version of the API.</p><p>Make sure you quit the Flask development server. Remember that you just need to press <em>
<strong>Ctrl</strong>
</em> + <em>
<strong>C</strong>
</em> in the terminal or a Command Prompt window in which it is running. It is time to run many commands that will be the same for either macOS, Linux, or Windows. We can install all the necessary packages with pip with a single command. However, we will run two independent commands to make it easier to detect any problems in case a specific installation fails.</p><p>Now, we must run the following command to install Flask-HTTPAuth with pip. This package makes it easy to add basic HTTP authentication to any Flask application:</p><pre class="programlisting">
<strong>pip install Flask-HTTPAuth</strong>
</pre><p>The last lines for the output will indicate the <code class="literal">Flask-HTTPAuth</code> package has been successfully installed:</p><pre class="programlisting">
<strong>Installing collected packages: Flask-HTTPAuth</strong>
<strong>  Running setup.py install for Flask-HTTPAuth</strong>
<strong>Successfully installed Flask-HTTPAuth-3.2.1</strong>
</pre><p>Run the following command to install passlib with pip. This package is a popular one that provides a comprehensive password hashing framework that supports more than 30 schemes. We definitely don't want to write our own error-prone and probably highly insecure password hashing code, and therefore, we will take advantage of a library that provides these services:</p><pre class="programlisting">
<strong>pip install passlib</strong>
</pre><p>The last lines for the output will indicate the <code class="literal">passlib</code> package has been successfully installed:</p><pre class="programlisting">
<strong>Installing collected packages: passlib</strong>
<strong>Successfully installed passlib-1.6.5</strong>
</pre></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec87"/>Adding a user model</h1></div></div></div><p>Now, we will create the model that we will use to represent and persist the user. Open the <code class="literal">api/models.py</code> file and add the following lines after the declaration of the <code class="literal">AddUpdateDelete</code> class. Make sure that you add the import statements. The code file for the sample is included in the <code class="literal">restful_python_chapter_07_02</code> folder:</p><pre class="programlisting">from passlib.apps import custom_app_context as password_context 
import re 
 
 
class User(db.Model, AddUpdateDelete): 
    id = db.Column(db.Integer, primary_key=True) 
    name = db.Column(db.String(50), unique=True, nullable=False) 
    # I save the hashed password 
    hashed_password = db.Column(db.String(120), nullable=False) 
    creation_date = db.Column(db.TIMESTAMP, server_default=db.func.current_timestamp(), nullable=False) 
 
    def verify_password(self, password): 
        return password_context.verify(password, self.hashed_password) 
 
    def check_password_strength_and_hash_if_ok(self, password): 
        if len(password) &lt; 8: 
            return 'The password is too short', False 
        if len(password) &gt; 32: 
            return 'The password is too long', False 
        if re.search(r'[A-Z]', password) is None: 
            return 'The password must include at least one uppercase letter',
            False 
        if re.search(r'[a-z]', password) is None: 
            return 'The password must include at least one lowercase letter',
            False 
        if re.search(r'\d', password) is None: 
            return 'The password must include at least one number', False 
        if re.search(r"[ !#$%&amp;'()*+,-./[\\\]^_`{|}~"+r'"]', password) is None: 
            return 'The password must include at least one symbol', False 
        self.hashed_password = password_context.encrypt(password) 
        return '', True 
 
    def __init__(self, name): 
        self.name = name 
</pre><p>The code declares the <code class="literal">User</code> model, specifically a subclasses of both the <code class="literal">db.Model</code> and the <code class="literal">AddUpdateDelete</code> classes. We specified the field types, maximum lengths and defaults for the following three attributes-<code class="literal">id</code>, <code class="literal">name</code>, <code class="literal">hashed_password</code> and <code class="literal">creation_date</code>. These attributes represent fields without any relationship, and therefore, they are instances of the <code class="literal">db.Column</code> class. The model declares an <code class="literal">id</code> attribute and specifies the <code class="literal">True</code> value for the <code class="literal">primary_key</code> argument to indicate it is the primary key. SQLAlchemy will use the data to generate the necessary table in the PostgreSQL database.</p><p>The <code class="literal">User</code> class declares the following methods:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">check_password_strength_and_hash_if_ok</code>: This method uses the <code class="literal">re</code> module that provides regular expression matching operations to check whether the <code class="literal">password</code> received as an argument fulfils many qualitative requirements. The code requires the password to be longer than eight characters, with a maximum of 32 characters. The password must include at least one uppercase letter, one lowercase letter, one number, and one symbol. The code checks the results of many calls to the <code class="literal">re.search</code> method to determine whether the received password fulfils each requirement. In case any of the requirements isn't fulfilled, the code returns a tuple with an error message and <code class="literal">False</code>. Otherwise, the code calls the <code class="literal">encrypt</code> method for the <code class="literal">passlib.apps.custom_app_context</code> instance imported as <code class="literal">password_context</code>, with the received <code class="literal">password</code> as an argument. The <code class="literal">encrypt</code> method chooses a reasonably strong scheme based on the platform, with the default settings for rounds selection and the code saves the hashed password in the <code class="literal">hash_password</code> attribute. Finally, the code returns a tuple with an empty string and <code class="literal">True</code>, indicating that the password fulfilled the qualitative requirements and it was hashed.</li></ul></div><div><div><h3 class="title"><a id="tip54"/>Tip</h3><p>By default, the <code class="literal">passlib</code> library will use the SHA-512 scheme for 64-bit platforms and SHA-256 for 32-bit platforms. In addition, the minimum number of rounds will be set to 535,000. We will use the default configuration values for this example. However, you must take into account that these values might require too much processing time for each request that has to validate the password. You should definitely select the most appropriate algorithm and number of rounds based on your security requirements.</p></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">verify_password</code>: This method calls the <code class="literal">verify</code> method for the <code class="literal">passlib.apps.custom_app_context</code> instance imported as <code class="literal">password_context</code>, with the received <code class="literal">password</code> and the stored hashed password for the user, <code class="literal">self.hashed_password</code>, as the arguments. The <code class="literal">verify</code> method hashes the received password and returns <code class="literal">True</code> only if the hashed received password matches the stored hashed password. We never restore the saved password to its original state. We just compare hashed values.</li></ul></div><p>The model declares a constructor, that is, the <code class="literal">__init__</code> method. This constructor receives the user name in the <code class="literal">name</code> argument and saves it in an attribute with the same name.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec88"/>Creating a schemas to validate, serialize, and deserialize users</h1></div></div></div><p>Now, we will create the Flask-Marshmallow schema that we will use to validate, serialize and deserialize the previously declared <code class="literal">User</code> model. Open the <code class="literal">api/models.py</code> file and add the following code after the existing lines. The code file for the sample is included in the <code class="literal">restful_python_chapter_07_02</code> folder:</p><pre class="programlisting">class UserSchema(ma.Schema): 
    id = fields.Integer(dump_only=True) 
    name = fields.String(required=True, validate=validate.Length(3)) 
    url = ma.URLFor('api.userresource', id='&lt;id&gt;', _external=True) 
</pre><p>The code declares the <code class="literal">UserSchema</code> schema, specifically a subclass of the <code class="literal">ma.Schema</code> class. Remember that the previous code we wrote for the <code class="literal">api/models.py</code> file created a <code class="literal">flask_marshmallow.Mashmallow</code> instance named <code class="literal">ma</code>.</p><p>We declare the attributes that represent fields as instances of the appropriate class declared in the <code class="literal">marshmallow.fields</code> module. The <code class="literal">UserSchema</code> class declares the <code class="literal">name</code> attribute as an instance of <code class="literal">fields.String</code>. The <code class="literal">required</code> argument is set to <code class="literal">True</code> to specify that the field cannot be an empty string. The <code class="literal">validate</code> argument is set to <code class="literal">validate.Length(3)</code> to specify that the field must have a minimum length of 3 characters.</p><p>The validation for the password isn't included in the schema. We will use the <code class="literal">check_password_strength_and_hash_if_ok</code> method defined in the <code class="literal">User</code> class to validate the password.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec89"/>Adding authentication to resources</h1></div></div></div><p>We will configure the <code class="literal">Flask-HTTPAuth</code> extension to work with our <code class="literal">User</code> model to verify passwords and set the authenticated user associated with a request. We will declare a custom function that this extension will use as a callback to verify a password. We will create a new base class for our resources that will require authentication. Open the <code class="literal">api/views.py</code> file and add the following code after the last line that uses the <code class="literal">import</code> statement and before the lines that declares the <code class="literal">Blueprint</code> instance . The code file for the sample is included in the <code class="literal">restful_python_chapter_07_02</code> folder:</p><pre class="programlisting">from flask_httpauth import HTTPBasicAuth 
from flask import g 
from models import User, UserSchema 
 
 
auth = HTTPBasicAuth() 
 
 
@auth.verify_password 
def verify_user_password(name, password): 
    user = User.query.filter_by(name=name).first() 
    if not user or not user.verify_password(password): 
        return False 
    g.user = user 
    return True 
 
 
class AuthRequiredResource(Resource): 
    method_decorators = [auth.login_required] 
</pre><p>First, we create an instance of the <code class="literal">flask_httpauth.HTTPBasicAuth</code> class named <code class="literal">auth</code>. Then, we declare the <code class="literal">verify_user_password</code> function that receives a name and a password as arguments. The function uses the <code class="literal">@auth.verify_password</code> decorator to make this function become the callback that <code class="literal">Flask-HTTPAuth</code> will use to verify the password for a specific user. The function retrieves the user whose name matches the <code class="literal">name</code> specified in the argument and saves its reference in the <code class="literal">user</code> variable. If a user is found, the code checks the results of the <code class="literal">user.verify_password</code> method with the received password as an argument.</p><p>If either a user isn't found or the call to <code class="literal">user.verify_password</code> returns <code class="literal">False</code>, the function returns <code class="literal">False</code> and the authentication will fail. If the call to <code class="literal">user.verify_password</code> returns <code class="literal">True</code>, the function stores the authenticated <code class="literal">User</code> instance in the user attribute for the <code class="literal">flask.g</code> object.</p><div><div><h3 class="title"><a id="tip55"/>Tip</h3><p>The <code class="literal">flask.g</code> object is a proxy that allows us to store on this whatever we want to share for one request only. The <code class="literal">user</code> attribute we added to the <code class="literal">flask.g</code> object will be only valid for the active request and it will return different values for each different request. This way, it is possible to use <code class="literal">flask.g.user</code> in another function or method called during a request to access details about the authenticated user for the request.</p></div></div><p>Finally, we declared the <code class="literal">AuthRequiredResource</code> class as a subclass of <code class="literal">flask_restful.Resource</code>. We just specified <code class="literal">auth.login_required</code> as one of the members of the list that we assign to the <code class="literal">method_decorators</code> property inherited from the base class. This way, all the methods declared in a resource that uses the new <code class="literal">AuthRequiredResource</code> class as its superclass will have the <code class="literal">auth.login_required</code> decorator applied to them, and therefore, any method that is called to the resource will require authentication.</p><p>Now, we will replace the base class for the existing resource classes to make them inherit from <code class="literal">AuthRequiredResource</code> instead of <code class="literal">Resource</code>. We want any of the requests that retrieve or modify categories and messages to be authenticated.</p><p>The following lines show the declarations for the four resource classes:</p><pre class="programlisting">class MessageResource(Resource): 
class MessageListResource(Resource): 
class CategoryResource(Resource): 
class CategoryListResource(Resource): 
</pre><p>Open the <code class="literal">api/views.py</code> file and replace <code class="literal">Resource</code> by <code class="literal">AuthRequiredResource</code> in the previously shown four lines that declare the resource classes. The following lines show the new code for each resource class declaration:</p><pre class="programlisting">class MessageResource(AuthRequiredResource): 
class MessageListResource(AuthRequiredResource): 
class CategoryResource(AuthRequiredResource): 
class CategoryListResource(AuthRequiredResource): 
</pre></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec90"/>Creating resource classes to handle users</h1></div></div></div><p>We just want to be able to create users and use them to authenticate requests. Thus, we will just focus on creating resource classes with just a few methods. We won't create a complete user management system.</p><p>We will create the resource classes that represent the user and the collection of users. First, we will create a <code class="literal">UserResource</code> class that we will use to represent a user resource. Open the <code class="literal">api/views.py</code> file and add the following lines after the line that creates the <code class="literal">Api</code> instance. The code file for the sample is included in the <code class="literal">restful_python_chapter_07_02</code> folder:</p><pre class="programlisting">class UserResource(AuthRequiredResource): 
    def get(self, id): 
        user = User.query.get_or_404(id) 
        result = user_schema.dump(user).data 
        return result 
</pre><p>The <code class="literal">UserResource</code> class is a subclass of the previously coded <code class="literal">AuthRequiredResource</code> and declares a <code class="literal">get</code> methods that will be called when the <code class="literal">HTTP</code> method with the same name arrives as a request on the represented resource. The method receives the id of the user that has to be retrieved in the <code class="literal">id</code> argument. The code calls the <code class="literal">User.query.get_or_404</code> method to return an HTTP <code class="literal">404 Not Found</code> status in case there is no user with the requested id in the underlying database. In case the user exists, the code calls the <code class="literal">user_schema.dump</code> method with the retrieved user as an argument to use the <code class="literal">UserSchema</code> instance to serialize the <code class="literal">User</code> instance whose <code class="literal">id</code> matches the specified <code class="literal">id</code>. The <code class="literal">dump</code> method takes the <code class="literal">User</code> instance and applies the field filtering and output formatting specified in the <code class="literal">UserSchema</code> class. The field filtering specifies that we don't want the hashed password to be serialized. The code returns the <code class="literal">data</code> attribute of the result returned by the <code class="literal">dump</code> method, that is, the serialized message in JSON format as the body, with the default HTTP <code class="literal">200 OK</code> status code.</p><p>Now, we will create a <code class="literal">UserListResource</code> class that we will use to represent the collection of users. Open the <code class="literal">api/views.py</code> file and add the following lines after the code that creates the <code class="literal">UserResource</code> class. The code file for the sample is included in the <code class="literal">restful_python_chapter_07_02</code> folder:</p><pre class="programlisting">class UserListResource(Resource): 
    @auth.login_required 
    def get(self): 
        pagination_helper = PaginationHelper( 
            request, 
            query=User.query, 
            resource_for_url='api.userlistresource', 
            key_name='results', 
            schema=user_schema) 
        result = pagination_helper.paginate_query() 
        return result 
 
    def post(self): 
        request_dict = request.get_json() 
        if not request_dict: 
            response = {'user': 'No input data provided'} 
            return response, status.HTTP_400_BAD_REQUEST 
        errors = user_schema.validate(request_dict) 
        if errors: 
            return errors, status.HTTP_400_BAD_REQUEST 
        name = request_dict['name'] 
        existing_user = User.query.filter_by(name=name).first() 
        if existing_user is not None: 
            response = {'user': 'An user with the same name already exists'} 
            return response, status.HTTP_400_BAD_REQUEST 
        try: 
            user = User(name=name) 
            error_message, password_ok = \ 
                user.check_password_strength_and_hash_if_ok(request_dict['password']) 
            if password_ok: 
                user.add(user) 
                query = User.query.get(user.id) 
                result = user_schema.dump(query).data 
                return result, status.HTTP_201_CREATED 
            else: 
                return {"error": error_message}, status.HTTP_400_BAD_REQUEST 
        except SQLAlchemyError as e: 
            db.session.rollback() 
            resp = {"error": str(e)} 
            return resp, status.HTTP_400_BAD_REQUEST 
</pre><p>The <code class="literal">UserListResource</code> class is a subclass of <code class="literal">flask_restful.Resource</code> because we don't want all the methods to require authentication. We want to be able to create a new user without being authenticated, and therefore, we apply the <code class="literal">@auth.login_required</code> decorator only for the <code class="literal">get</code> method. The <code class="literal">post</code> method doesn't require authentication. The class declares the following two methods that will be called when the <code class="literal">HTTP</code> method with the same name arrives as a request on the represented resource:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">get</code>: This method returns a list with all the <code class="literal">User</code> instances saved in the database. First, the code calls the <code class="literal">User.query.all</code> method to retrieve all the <code class="literal">User</code> instances persisted in the database. Then, the code calls the <code class="literal">user_schema.dump</code> method with the retrieved messages and the <code class="literal">many</code> argument set to <code class="literal">True</code> to serialize the iterable collection of objects. The <code class="literal">dump</code> method will take each <code class="literal">User</code> instance retrieved from the database and apply the field filtering and output formatting specified the <code class="literal">CategorySchema</code> class. The code returns the <code class="literal">data</code> attribute of the result returned by the dump method, that is, the serialized messages in JSON format as the body, with the default HTTP <code class="literal">200 OK</code> status code.</li><li class="listitem" style="list-style-type: disc"><code class="literal">post</code>: This method retrieves the key-value pairs received in the JSON body, creates a new <code class="literal">User</code> instance and persists it in the database. First, the code calls the <code class="literal">request.get_json</code> method to retrieve the key-value pairs received as arguments with the request. Then, the code calls the <code class="literal">user_schema.validate</code> method to validate the new user built with the retrieved key-value pairs. In this case, the call to this method will just validate the <code class="literal">name</code> field for the user. In case there were validation errors, the code returns the validation errors and an HTTP <code class="literal">400 Bad Request</code> status. If the validation is successful, the code checks whether an user with the same name already exists in the database or not to return an appropriate error for the field that must be unique. If the user name is unique, the code creates a new user with the specified <code class="literal">name</code> and calls its <code class="literal">check_password_strength_and_hash_if_ok</code> method. If the provided password fulfils all the quality requirements, the code persists the user with its hashed password in the database. Finally, the code returns the serialized saved user in JSON format as the body, with the HTTP <code class="literal">201 Created</code> status code:</li></ul></div><p>The following table shows the method of our previously created classes related to usres that we want to be executed for each combination of <code class="literal">HTTP</code> verb and scope.</p><div><table border="1"><colgroup><col/><col/><col/><col/></colgroup><tbody><tr><td>
<p>
<strong>HTTP verb</strong>
</p>
</td><td>
<p>
<strong>Scope</strong>
</p>
</td><td>
<p>
<strong>Class and method</strong>
</p>
</td><td>
<p>
<strong>Requires authentication</strong>
</p>
</td></tr><tr><td>
<p>
<code class="literal">GET</code>
</p>
</td><td>
<p>Collection of users</p>
</td><td>
<p>UserListResource.get</p>
</td><td>
<p>Yes</p>
</td></tr><tr><td>
<p>
<code class="literal">GET</code>
</p>
</td><td>
<p>User</p>
</td><td>
<p>UserResource.get</p>
</td><td>
<p>Yes</p>
</td></tr><tr><td>
<p>
<code class="literal">POST</code>
</p>
</td><td>
<p>Collection of users</p>
</td><td>
<p>UserListResource.post</p>
</td><td>
<p>No</p>
</td></tr></tbody></table></div><p>We must make the necessary resource routing configurations to call the appropriate methods and pass them all the necessary arguments by defining URL rules. The following lines configure the resource routing for the user related resources to the api. Open the <code class="literal">api/views.py</code> file and add the following lines at the end of the code. The code file for the sample is included in the <code class="literal">restful_python_chapter_07_02</code> folder:</p><pre class="programlisting">api.add_resource(UserListResource, '/users/') 
api.add_resource(UserResource, '/users/&lt;int:id&gt;') 
</pre><p>Each call to the <code class="literal">api.add_resource</code> method routes a URL to one of the previously coded user related resources. When there is a request to the API and the URL matches one of the URLs specified in the <code class="literal">api.add_resource</code> method, Flask will call the method that matches the <code class="literal">HTTP</code> verb in the request for the specified class.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec91"/>Running migrations to generate the user table</h1></div></div></div><p>Now, we will run many scripts to run migrations and generate the necessary table in the PostgreSQL database. Make sure you run the scripts in the terminal or the Command Prompt window in which you have activated the virtual environment and that you are located in the <code class="literal">api</code> folder.</p><p>Run the first script that populates the migration script with the detected changes in the models. In this case, it is the second time we populate the migration script, and therefore, the migration script will generate the new table that will persist our new <code class="literal">User</code> model: <code class="literal">model</code>:</p><pre class="programlisting">
<strong>python migrate.py db migrate</strong>
</pre><p>The following lines show the sample output generated after running the previous script. Your output will be different according to the base folder in which you have created the virtual environment.</p><pre class="programlisting">
<strong>INFO [alembic.runtime.migration] Context impl PostgresqlImpl.</strong>
<strong>INFO [alembic.runtime.migration] Will assume transactional DDL.</strong>
<strong>INFO [alembic.autogenerate.compare] Detected added table 'user'</strong>
<strong>INFO [alembic.ddl.postgresql] Detected sequence named 'message_id_seq' as owned by integer column 'message(id)', assuming SERIAL and omitting</strong>
<strong>Generating</strong>
<strong>  /Users/gaston/PythonREST/Flask02/api/migrations/versions/c8c45e615f6d_.py ... done</strong>
</pre><p>The output indicates that the <code class="literal">api/migrations/versions/c8c45e615f6d_.py</code> file includes the code to create the <code class="literal">user</code> tables. The following lines show the code for this file that was automatically generated based on the models. Notice that the file name will be different in your configuration. The code file for the sample is included in the <code class="literal">restful_python_chapter_06_01</code> folder:</p><pre class="programlisting">"""empty message 
 
Revision ID: c8c45e615f6d 
Revises: 417543056ac3 
Create Date: 2016-08-11 17:31:44.989313 
 
""" 
 
# revision identifiers, used by Alembic. 
revision = 'c8c45e615f6d' 
down_revision = '417543056ac3' 
 
from alembic import op 
import sqlalchemy as sa 
 
 
def upgrade(): 
    ### commands auto generated by Alembic - please adjust! ### 
    op.create_table('user', 
    sa.Column('id', sa.Integer(), nullable=False), 
    sa.Column('name', sa.String(length=50), nullable=False), 
    sa.Column('hashed_password', sa.String(length=120), nullable=False), 
    sa.Column('creation_date', sa.TIMESTAMP(), server_default=sa.text('CURRENT_TIMESTAMP'), nullable=False), 
    sa.PrimaryKeyConstraint('id'), 
    sa.UniqueConstraint('name') 
    ) 
    ### end Alembic commands ### 
 
 
def downgrade(): 
    ### commands auto generated by Alembic - please adjust! ### 
    op.drop_table('user') 
    ### end Alembic commands ### 
</pre><p>The code defines two functions: <code class="literal">upgrade</code> and <code class="literal">downgrade</code>. The <code class="literal">upgrade</code> function runs the necessary code to create the <code class="literal">user</code> table by making calls to <code class="literal">alembic.op.create_table</code>. The <code class="literal">downgrade</code> function runs the necessary code to go back to the previous version.</p><p>Run the second script to upgrade the database:</p><pre class="programlisting">
<strong>python migrate.py db upgrade</strong>
</pre><p>The following lines show the sample output generated after running the previous script:</p><pre class="programlisting">
<strong>INFO  [alembic.runtime.migration] Context impl PostgresqlImpl.</strong>
<strong>INFO  [alembic.runtime.migration] Will assume transactional DDL.</strong>
<strong>INFO  [alembic.runtime.migration] Running upgrade 417543056ac3 -&gt;
    c8c45e615f6d, empty message</strong>
</pre><p>The previous script called the <code class="literal">upgrade</code> function defined in the automatically generated <code class="literal">api/migrations/versions/c8c45e615f6d_.py</code> script. Don't forget that the file name will be different in your configuration.</p><p>After we run the previous scripts, we can use the PostgreSQL command line or any other application that allows us to easily verify the contents of the PostreSQL database to check the new table that the migration generated. Run the following command to list the generated tables. In case the database name you are using is not named <code class="literal">messages</code>, make sure you use the appropriate database name:</p><pre class="programlisting">
<strong>psql --username=user_name --dbname=messages --command="\dt"</strong>
</pre><p>The following lines show the output with all the generated table names. The migrations upgrade generate a new table named <code class="literal">user</code>.</p><pre class="programlisting">
<strong>
<strong>                    List of relations</strong>
</strong>
<strong>
<strong> Schema |      Name       | Type  |   Owner   </strong>
</strong>
<strong>
<strong>--------+-----------------+-------+-----------</strong>
</strong>
<strong>
<strong> public | alembic_version | table | user_name</strong>
</strong>
<strong>
<strong> public | category        | table | user_name</strong>
</strong>
<strong>
<strong> public | message         | table | user_name</strong>
</strong>
<strong>
<strong> public | user            | table | user_name</strong>
</strong>
<strong>(4 rows)</strong>
</pre><p>SQLAlchemy generated the user table with its primary key, its unique constraint on the name field and the password field based on the information included in our <code class="literal">User</code> model.</p><p>The following command will allow you to check the contents of the user table after we compose and send HTTP requests to the RESTful API and create new users. The commands assume that you are running PostgreSQL on the same computer in which you are running the command:</p><pre class="programlisting">
<strong>psql --username=user_name --dbname=messages --command="SELECT * FROM
    public.user;"</strong>
</pre><p>Now, we can run the <code class="literal">api/run.py</code> script that launches Flask's development. Execute the following command in the <code class="literal">api</code> folder:</p><pre class="programlisting">
<strong>python run.py</strong>
</pre><p>After we execute the previous command, the development server will start listening at port <code class="literal">5000</code>.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec92"/>Composing requests with the necessary authentication</h1></div></div></div><p>Now, we will compose and send an HTTP request to retrieve the first page of the messages without authentication credentials:</p><pre class="programlisting">
<strong>http POST ':5000/api/messages/?page=1'</strong>
</pre><p>The following is the equivalent <code class="literal">curl</code> command:</p><pre class="programlisting">
<strong>curl -iX GET ':5000/api/messages/?page=1'</strong>
</pre><p>We will receive a <code class="literal">401 Unauthorized</code> status code in the response header. The following lines show a sample response:</p><pre class="programlisting">
<strong>HTTP/1.0 401 UNAUTHORIZED</strong>
<strong>Content-Length: 19</strong>
<strong>Content-Type: text/html; charset=utf-8</strong>
<strong>Date: Mon, 15 Aug 2016 01:16:36 GMT</strong>
<strong>Server: Werkzeug/0.11.10 Python/3.5.1</strong>
<strong>WWW-Authenticate: Basic realm="Authentication Required"</strong>
</pre><p>If we want to retrieve messages, that is, to make a <code class="literal">GET</code> request to <code class="literal">/api/messages/</code>, we need to provide authentication credentials using HTTP authentication. However, before we can do this, it is necessary to create a new user. We will use the new user to test our new resource classes related to users and our changes in the permissions policies.</p><pre class="programlisting">
<strong>http POST :5000/api/users/ name='brandon' password='brandonpassword'</strong>
</pre><p>The following is the equivalent <code class="literal">curl</code> command:</p><pre class="programlisting">
<strong>curl -iX POST -H "Content-Type: application/json" -d '{"name": "brandon",
    "password": "brandonpassword"}' :5000/api/users/</strong>
</pre><div><div><h3 class="title"><a id="tip56"/>Tip</h3><p>Of course, the creation of a user and the execution of the methods that require authentication should only be possible under HTTPS. This way, the username and the password would be encrypted.</p></div></div><p>The previous command will compose and send a <code class="literal">POST</code> HTTP request with the specified JSON key-value pairs. The requests specify <code class="literal">/api/user/</code>, and therefore, it will match the <code class="literal">'/users/'</code> URL route for the <code class="literal">UserList</code> resource and run the <code class="literal">UserList.post</code> method that doesn't require authentication. The method doesn't receive arguments because the URL route doesn't include any parameters. As the HTTP verb for the request is <code class="literal">POST</code>, Flask calls the <code class="literal">post</code> method.</p><p>The previously specified password only includes lowercase letters, and therefore, it doesn't fulfil all the qualitative requirements we have specified for the passwords in the <code class="literal">User.check_password_strength_and_hash_if_ok</code> method. Thus, We will receive a <code class="literal">400 Bad Request</code> status code in the response header and the error message indicating the requirement that the password didn't fulfil in the JSON body. The following lines show a sample response:</p><pre class="programlisting">HTTP/1.0 400 BAD REQUEST 
Content-Length: 75 
Content-Type: application/json 
Date: Mon, 15 Aug 2016 01:29:55 GMT 
Server: Werkzeug/0.11.10 Python/3.5.1 
 
{ 
    "error": "The password must include at least one uppercase letter" 
} 
</pre><p>The following command will create a user with a valid password:</p><pre class="programlisting">
<strong>http POST :5000/api/users/ name='brandon' password='iA4!V3riS#c^R9'</strong>
</pre><p>The following is the equivalent <code class="literal">curl</code> command:</p><pre class="programlisting">
<strong>curl -iX POST -H "Content-Type: application/json" -d '{"name": "brandon", "password": "iA4!V3riS#c^R9"}' :5000/api/users/</strong>
</pre><p>If the new <code class="literal">User</code> instance is successfully persisted in the database, the call will return an <code class="literal">HTTP 201 Created</code> status code and the recently persisted <code class="literal">User</code> serialized to JSON in the response body. The following lines show an example response for the HTTP requests, with the new <code class="literal">User</code> object in the JSON responses. Note that the response includes the URL, <code class="literal">url</code>, for the created user and doesn't include any information related to the password.</p><pre class="programlisting">
<strong>HTTP/1.0 201 CREATED</strong>
<strong>Content-Length: 87</strong>
<strong>Content-Type: application/json</strong>
<strong>Date: Mon, 15 Aug 2016 01:33:23 GMT</strong>
<strong>Server: Werkzeug/0.11.10 Python/3.5.1</strong>
<strong>{</strong>
<strong>    "id": 1, </strong>
<strong>    "name": "brandon", </strong>
<strong>    "url": "http://localhost:5000/api/users/1"</strong>
<strong>}</strong>
</pre><p>We can run the previously explained command to check the contents of the <code class="literal">user</code> table that the migrations created in the PostgreSQL database. We will notice that the <code class="literal">hashed_password</code> field contents are hashed for the new row in the <code class="literal">user</code> table. The following screenshot shows the contents for the new row of the <code class="literal">user</code> table in a PostgreSQL database after running the HTTP request:</p><p>
</p><div><img src="img/image_07_002.jpg" alt="Composing requests with the necessary authentication"/></div><p>
</p><p>If we want to retrieve the first page of messages, that is, to make a <code class="literal">GET</code> request to <code class="literal">/api/messages/</code>, we need to provide authentication credentials using HTTP authentication. Now, we will compose and send an HTTP request to retrieve the first page of messages with authentication credentials, that is, with the user name and the password we have recently created:</p><pre class="programlisting">
<strong>http -a 'brandon':'iA4!V3riS#c^R9' ':5000/api/messages/?page=1'</strong>
</pre><p>The following is the equivalent <code class="literal">curl</code> command:</p><pre class="programlisting">
<strong>curl --user 'brandon':'iA4!V3riS#c^R9' -iX GET ':5000/api/messages/?page=1'</strong>
</pre><p>The user will be successfully authenticated and we will be able to process the request to retrieve the first page of messages. With all the changes we have made to our API, unauthenticated requests can only create a new user.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec93"/>Test your knowledge</h1></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">The <code class="literal">flask.g</code> object is:<div><ol class="orderedlist arabic"><li class="listitem">A proxy that provides access to the current request.</li><li class="listitem">An instance of the <code class="literal">flask_httpauth.HTTPBasicAuth</code> class.</li><li class="listitem">A proxy that allows us to store on this whatever we want to share for one request only.</li></ol></div><p>
</p></li><li class="listitem">The <code class="literal">passlib</code> package provides:<div><ol class="orderedlist arabic"><li class="listitem">A password hashing framework that supports more than 30 schemes.</li><li class="listitem">An authentication framework that automatically adds models for users and permissios to a Flask application.</li><li class="listitem">A lightweight web framework that replaces Flask.</li></ol></div><p>
</p></li><li class="listitem">The <code class="literal">auth.verify_password</code> decorator applied to a function:<div><ol class="orderedlist arabic"><li class="listitem">Makes this function become the callback that <code class="literal">Flask-HTTPAuth</code> will use to hash the password for a specific user.</li><li class="listitem">Makes this function become the callback that <code class="literal">SQLAlchmey</code> will use to verify the password for a specific user.</li><li class="listitem">Makes this function become the callback that <code class="literal">Flask-HTTPAuth</code> will use to verify the password for a specific user.</li></ol></div><p>
</p></li><li class="listitem">When you assign a list that includes <code class="literal">auth.login_required</code> to the <code class="literal">method_decorators</code> property of any subclass of <code class="literal">flask_restful.Resource</code>, considering that auth is an instance of the <code class="literal">flask_httpauth.HTTPBasicAuth()</code>:<div><ol class="orderedlist arabic"><li class="listitem">All the methods declared in the resource will have the <code class="literal">auth.login_required</code> decorator applied to them.</li><li class="listitem">The <code class="literal">post</code> method declared in the resource will have <code class="literal">auth.login_required</code> decorator applied to it.</li><li class="listitem">Any of the following methods declared in the resource will have <code class="literal">auth.login_required</code> decorator applied to them: <code class="literal">delete</code>, <code class="literal">patch</code>, <code class="literal">post</code> and <code class="literal">put</code>.</li></ol></div><p>
</p></li><li class="listitem">Which of the following lines retrieves the integer value for the <code class="literal">'page'</code> argument from the request object, considering that the code would be running within a method defined in a subclass of <code class="literal">flask_restful.Resource</code> class?<div><ol class="orderedlist arabic"><li class="listitem"><code class="literal">page_number = request.get_argument('page', 1, type=int)</code></li><li class="listitem"><code class="literal">page_number = request.args.get('page', 1, type=int)</code></li><li class="listitem"><code class="literal">page_number = request.arguments.get('page', 1, type=int)</code></li></ol></div><p>
</p></li></ol></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec94"/>Summary</h1></div></div></div><p>In this chapter, we improved the RESTful API in many ways. We added user friendly error messages when resources aren't unique. We tested how to update single or multiple fields with the <code class="literal">PATCH</code> method and we created our own generic pagination class.</p><p>Then, we started working with authentication and permissions. We added a user model and we updated the database. We made many changes in the different pieces of code to achieve a specific security goal and we took advantage of Flask-HTTPAuth and passlib to use HTTP authentication in our API.</p><p>Now that we have built an improved a complex API that uses pagination and authentication, we will use additional abstractions included in the framework and we will code, execute, and improve unit test, which is what we are going to discuss in the next chapter.</p></div></body></html>