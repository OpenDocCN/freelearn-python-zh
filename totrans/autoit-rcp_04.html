<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0;Playing with SMS and Voice Notifications"><div class="titlepage"><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Playing with SMS and Voice Notifications</h1></div></div></div><p>Cloud telephony is the technology that moves your phone system to the cloud. This has made sure that we can now explore the possibilities of automation with SMS and voice notifications. This chapter begins with an introduction to cloud telephony and covers automation of business use cases with text and voice messages in Python.</p><p>In this chapter, we will cover the following recipes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Registering with a cloud telephony provider</li><li class="listitem" style="list-style-type: disc">Sending text messages</li><li class="listitem" style="list-style-type: disc">Receiving SMS messages</li><li class="listitem" style="list-style-type: disc">SMS workflows for Domino's</li><li class="listitem" style="list-style-type: disc">Sending voice messages</li><li class="listitem" style="list-style-type: disc">Receiving voice calls</li><li class="listitem" style="list-style-type: disc">Building your own customer service software</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec36"/>Introduction</h1></div></div></div><p>In the previous few chapters, we looked at working with plain text and <span class="strong"><strong>comma-separated value</strong></span> (<span class="strong"><strong>CSV</strong></span>) files, and then we extended our scope to learn about working with Excel worksheets, Word documents, and PDF files. Excel, Word, and PDF files are available in the binary format and support mathematical operations, tables, charting, and many other operations. We also looked at interesting business use cases that can be automated with Python.</p><p>In this chapter, we take a look at an interesting world of cloud telephony. With the advent of the Internet, businesses have moved their communication systems to the cloud as well. Internet-based hosted telephony has replaced the conventional telephone equipment, such as PBX. This has opened up a world of possibilities of using cloud telephony to solve business needs, and that too, in Python. Using cloud telephony for your business allows you to make and receive multiple calls and SMS simultaneously. Services like call transfers, recording, bulk SMS are some of the awesome features cloud telephony can be leveraged for.
Cloud telephony ensures management of business needs without compromising on quality, cost, and without having to invest in any additional infrastructure.</p><p>The recipes in this chapter will focus on the Python modules that help us in sending/receiving SMS messages and voice calls. We'll learn how to register with a cloud telephony provider, use Python APIs, and automate interesting business flows. Specifically, we will work with the <a class="ulink" href="https://www.twilio.com/">Twilio</a> telephony provider and use the following Python modules in this chapter:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Flask</code> (<a class="ulink" href="http://flask.pocoo.org/">http://flask.pocoo.org/</a>)</li><li class="listitem" style="list-style-type: disc"><code class="literal">twilio</code> (<a class="ulink" href="https://pypi.python.org/pypi/twilio">https://pypi.python.org/pypi/twilio</a>)</li></ul></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note12"/>Note</h3><p>While we'll learn about the Twilio cloud telephony provider, there are other providers as well. Each of these has a great API set and works with Python libraries. If you choose to implement your solution, you can have a look at a few of them at <a class="ulink" href="http://www.capterra.com/telephony-software/">http://www.capterra.com/telephony-software/</a>.</p></div></div></div></div>
<div class="section" title="Registering with a cloud telephony provider"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec37"/>Registering with a cloud telephony provider</h1></div></div></div><p>To work with cloud-based telephony services, we need to register for an account with a telephony provider. There are a couple of popular cloud providers that you can find when you search on the Internet. For this chapter, we use Twilio (<a class="ulink" href="https://www.twilio.com/">https://www.twilio.com/</a>). Let's see how to register for an account.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec95"/>Getting ready</h2></div></div></div><p>In order to use cloud telephony APIs, we need to register for an account with Twilio so that we can get the <span class="strong"><strong>AccountSID</strong></span> and <span class="strong"><strong>AuthToken</strong></span>. We'd also need to rent numbers for the recipes in the SMS and voice sections. Let's learn how to work with Twilio APIs in this recipe.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec96"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">On your computer, open your favorite browser and browse to <a class="ulink" href="https://www.twilio.com/try-twilio">https://www.twilio.com/try-twilio</a>:<p>
</p><div class="mediaobject"><img alt="How to do it..." src="graphics/image_05_001.jpg"/></div><p>
</p></li><li class="listitem">Once you create an account, log in to it and add a few funds from the <span class="strong"><strong>Billing</strong></span> page that is available as a dropdown option on your account dashboard. You can also directly browse to the <span class="strong"><strong>Billing</strong></span> page at <a class="ulink" href="https://www.twilio.com/user/billing">https://www.twilio.com/user/billing</a> if you're already logged in:<p>
</p><div class="mediaobject"><img alt="How to do it..." src="graphics/image_05_002.jpg"/></div><p>
</p></li><li class="listitem">To make Twilio API calls, we need <span class="strong"><strong>AccountSID</strong></span> and <span class="strong"><strong>AuthToken</strong></span>. We can get these details by clicking on the <span class="strong"><strong>Account</strong></span> section from the dropdown or directly browsing to <a class="ulink" href="https://www.twilio.com/user/account/settings">https://www.twilio.com/user/account/settings</a>. On this page, you will get the API credentials as shown in the following screenshot. Don't worry about two-factor authentication for now, but make sure <span class="strong"><strong>SSL Certification Validation</strong></span> is enabled for your account:<p>
</p><div class="mediaobject"><img alt="How to do it..." src="graphics/image_05_003.jpg"/></div><p>
</p></li><li class="listitem">Okay, that's good. Now, let's rent a phone number by directly browsing to <a class="ulink" href="https://www.twilio.com/user/account/phone-numbers/search">https://www.twilio.com/user/account/phone-numbers/search</a>.</li><li class="listitem">Once you click on <span class="strong"><strong>Buy a Number</strong></span>, you'll see a page where you can rent a number based on the country and prefix or area code. Here, I have chosen country as <span class="strong"><strong>United States</strong></span> and prefix as <code class="literal">510</code>. I'm also renting a number that is capable of handling both <span class="strong"><strong>SMS</strong></span> messages and <span class="strong"><strong>Voice</strong></span> calls:<p>
</p><div class="mediaobject"><img alt="How to do it..." src="graphics/image_05_004.jpg"/></div><p>
</p></li><li class="listitem">Now, click on the <span class="strong"><strong>Advanced Search</strong></span> option at the bottom of this page to get all the options, as shown in the following screenshot. You can go ahead with the default settings <span class="strong"><strong>All</strong></span> or choose to rent <span class="strong"><strong>Local</strong></span> or <span class="strong"><strong>Toll-Free</strong></span> numbers. Based on the local rules of a region or country, renting numbers requires you to provide your address proof, but you don't need all this and could select the <span class="strong"><strong>Any</strong></span> option. <span class="strong"><strong>Beta Numbers</strong></span> are newly added numbers to Twilio from specific countries, added to support a list of countries. We don't have to care about this option in this recipe, so we keep it blank:<p>
</p><div class="mediaobject"><img alt="How to do it..." src="graphics/image_05_005.jpg"/></div><p>
</p></li><li class="listitem">When you click on <span class="strong"><strong>Search</strong></span>, this page will take you to the results screen where you can choose to buy any of the available numbers. Make sure you buy a number that has both <span class="strong"><strong>Voice</strong></span> and <span class="strong"><strong>SMS</strong></span> enabled. Toll-free numbers are costly, and it's best to buy a <span class="strong"><strong>Local</strong></span> number for this exercise:<p>
</p><div class="mediaobject"><img alt="How to do it..." src="graphics/image_05_006.jpg"/></div><p>
</p></li><li class="listitem">Cool! If you're already through this, then congratulations! You're now all set to start learning about using SMS messages and voice calls with Python APIs.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec97"/>How it works...</h2></div></div></div><p>As stated earlier, to work with Twilio APIs, we need to register for an account. Twilio creates an account for us and provides us with a unique <span class="strong"><strong>AccountSID</strong></span> and <span class="strong"><strong>AuthToken</strong></span>, which will validate our requests and make sure that our account gets billed for the API calls we make.</p><p>Phone numbers in Twilio are used as caller IDs to send text messages or voice calls. Caller ID (also known as calling line identification) is a caller's number that is flashed on the called party's equipment (landline or mobile). In this case, the number we rented from Twilio will be used as the caller ID.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec98"/>There's more...</h2></div></div></div><p>We looked at how to create an account, get <span class="strong"><strong>AccountSID</strong></span> and <span class="strong"><strong>AuthToken</strong></span>, and generate a phone number with Twilio. Let's now make use of these in the next recipe.</p></div></div>
<div class="section" title="Sending text messages"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec38"/>Sending text messages</h1></div></div></div><p>Let's look at our first recipe on working with text messages. In this recipe, we will send a message to the recipient via SMS. Please note that you may also now have to charge your account for performing the next set of operations.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec99"/>Getting ready</h2></div></div></div><p>We start by sending SMS messages with the Twilio APIs. Let's look at how to do it in this section. Before doing that, let's create a Python virtual environment and install <code class="literal">flask</code> and <code class="literal">twilio</code> modules with the following steps.</p><p>Note that we will use <code class="literal">flask</code> to host a simple web service, which will be called by the telephony provider Twilio. The <span class="emphasis"><em>flask</em></span> app will then perform the required business operation based on the callback from Twilio. We will know more about this when we look at the recipes.</p><p>Setting up a virtual environment and installing modules needs to be done from the command line of your computer. We use Python <code class="literal">pip</code> to install the <code class="literal">flask</code> and <code class="literal">twilio</code> modules:</p><pre class="programlisting">
<span class="strong"><strong>virtualenv ~/book/ch05/</strong></span>
<span class="strong"><strong>source ~/book/ch05/</strong></span>
<span class="strong"><strong>pip install flask</strong></span>
<span class="strong"><strong>Collecting flask==0.10.1</strong></span>
<span class="strong"><strong>  Downloading Flask-0.10.1.tar.gz (544kB)</strong></span>
<span class="strong"><strong>    100% |████████████████████████████████| 544kB 774kB/s </strong></span>
<span class="strong"><strong>Collecting Werkzeug&gt;=0.7 (from flask==0.10.1)</strong></span>
<span class="strong"><strong>  Downloading Werkzeug-0.11.10-py2.py3-none-any.whl (306kB)</strong></span>
<span class="strong"><strong>    100% |████████████████████████████████| 307kB 1.5MB/s </strong></span>
<span class="strong"><strong>Collecting Jinja2&gt;=2.4 (from flask==0.10.1)</strong></span>
<span class="strong"><strong>  Downloading Jinja2-2.8-py2.py3-none-any.whl (263kB)</strong></span>
<span class="strong"><strong>    100% |████████████████████████████████| 266kB 2.4MB/s </strong></span>
<span class="strong"><strong>Collecting itsdangerous&gt;=0.21 (from flask==0.10.1)</strong></span>
<span class="strong"><strong>  Downloading itsdangerous-0.24.tar.gz (46kB)</strong></span>
<span class="strong"><strong>    100% |████████████████████████████████| 49kB 6.2MB/s </strong></span>
<span class="strong"><strong>Collecting MarkupSafe (from Jinja2&gt;=2.4-&gt;flask==0.10.1)</strong></span>
<span class="strong"><strong>  Downloading MarkupSafe-0.23.tar.gz</strong></span>
<span class="strong"><strong>Building wheels for collected packages: flask, itsdangerous, MarkupSafe</strong></span>
<span class="strong"><strong>  Running setup.py bdist_wheel for flask</strong></span>
<span class="strong"><strong>  Stored in directory: /Users/chetan/Library/Caches/pip/wheels/b6/09/65/5fcf16f74f334a215447c26769e291c41883862fe0dc7c1430</strong></span>
<span class="strong"><strong>  Running setup.py bdist_wheel for itsdangerous</strong></span>
<span class="strong"><strong>  Stored in directory: /Users/chetan/Library/Caches/pip/wheels/fc/a8/66/24d655233c757e178d45dea2de22a04c6d92766abfb741129a</strong></span>
<span class="strong"><strong>  Running setup.py bdist_wheel for MarkupSafe</strong></span>
<span class="strong"><strong>  Stored in directory: /Users/chetan/Library/Caches/pip/wheels/a3/fa/dc/0198eed9ad95489b8a4f45d14dd5d2aee3f8984e46862c5748</strong></span>
<span class="strong"><strong>Successfully built flask itsdangerous MarkupSafe</strong></span>
<span class="strong"><strong>Installing collected packages: Werkzeug, MarkupSafe, Jinja2, itsdangerous, flask</strong></span>
<span class="strong"><strong>Successfully installed Jinja2-2.8 MarkupSafe-0.23 Werkzeug-0.11.10 flask-0.10.1 itsdangerous-0.24</strong></span>
</pre><p>Next, install <code class="literal">twilio</code> using the following command:</p><pre class="programlisting">
<span class="strong"><strong>pip install Twilio</strong></span>
<span class="strong"><strong>Collecting twilio</strong></span>
<span class="strong"><strong>  Downloading twilio-5.4.0.tar.gz (193kB)</strong></span>
<span class="strong"><strong>    100% |████████████████████████████████| 196kB 2.2MB/s </strong></span>
<span class="strong"><strong>Collecting httplib2&gt;=0.7 (from twilio)</strong></span>
<span class="strong"><strong>  Downloading httplib2-0.9.2.zip (210kB)</strong></span>
<span class="strong"><strong>    100% |████████████████████████████████| 212kB 2.0MB/s </strong></span>
<span class="strong"><strong>Collecting six (from twilio)</strong></span>
<span class="strong"><strong>  Downloading six-1.10.0-py2.py3-none-any.whl</strong></span>
<span class="strong"><strong>Collecting pytz (from twilio)</strong></span>
<span class="strong"><strong>  Downloading pytz-2016.6.1-py2.py3-none-any.whl (481kB)</strong></span>
<span class="strong"><strong>    100% |████████████████████████████████| 483kB 1.0MB/s </strong></span>
<span class="strong"><strong>Building wheels for collected packages: twilio, httplib2</strong></span>
<span class="strong"><strong>  Running setup.py bdist_wheel for twilio</strong></span>
<span class="strong"><strong>  Stored in directory: /Users/chetan/Library/Caches/pip/wheels/91/16/85/2ea21326cf1aad3e32f88d9e81723088e1e43ceb9eac935a9b</strong></span>
<span class="strong"><strong>  Running setup.py bdist_wheel for httplib2</strong></span>
<span class="strong"><strong>  Stored in directory: /Users/chetan/Library/Caches/pip/wheels/c7/67/60/e0be8ccfc1e08f8ff1f50d99ea5378e204580ea77b0169fb55</strong></span>
<span class="strong"><strong>Successfully built twilio httplib2</strong></span>
<span class="strong"><strong>Installing collected packages: httplib2, six, pytz, twilio</strong></span>
<span class="strong"><strong>Successfully installed httplib2-0.9.2 pytz-2016.6.1 six-1.10.0 twilio-5.4.0</strong></span>
</pre></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec100"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Let's start by creating a configuration that has our Twilio <span class="strong"><strong>AccountSID</strong></span> and <span class="strong"><strong>AuthToken</strong></span>. We also add our rented number as caller ID to the configuration and also add the custom number to whom the message will be sent. You can add your own number in this field to see if it works for you.</li><li class="listitem">Our configuration file looks as follows, and we store it as <code class="literal">config.py</code>:<pre class="programlisting">        TWILIO_ACCOUNT_SID = 'Account SID' &#13;
        TWILIO_AUTH_TOKEN = 'Auth Token' &#13;
        CALLERID = '+Rented Number' &#13;
        MYNUMBER = '+Your Number' &#13;
</pre></li><li class="listitem">Now, let's write our application that will actually send out this message. We store this as <code class="literal">send_sms.py</code> and import the configuration from <code class="literal">config.py</code>:<pre class="programlisting">        import config &#13;
        from flask import Flask &#13;
        from twilio.rest import TwilioRestClient &#13;
 &#13;
        app = Flask(__name__) &#13;
        client = TwilioRestClient(config.TWILIO_ACCOUNT_SID, &#13;
                                  config.TWILIO_AUTH_TOKEN) &#13;
 &#13;
        message = client.messages.create( &#13;
            to=config.MYNUMBER, &#13;
            from_=config.CALLERID, &#13;
            body="Hey, this is cool!") &#13;
</pre></li><li class="listitem">We run this code by going to the Terminal or from your favorite editor. Check your mobile and you should have a message from your rented number saying, <span class="strong"><strong>Hey, this is cool!</strong></span> Indeed, this is cool! Your message can take 2-3 minutes to arrive depending on your carrier and network congestion, so be patient. See the following screenshot for the received message:<p>
</p><div class="mediaobject"><img alt="How to do it..." src="graphics/image_05_007.jpg"/></div><p>
</p></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec101"/>How it works...</h2></div></div></div><p>First, we created a configuration file and filled it with all the required fields. In the <code class="literal">send_sms.py</code> file, we imported this configuration file by importing <code class="literal">config.py</code> and also imported the required modules such as <code class="literal">flask</code> and the <code class="literal">twilio</code> Python module.</p><p>We then created the <code class="literal">twilio</code> object, <code class="literal">client</code>, by using the class, <code class="literal">TwilioRestClient</code>, which is imported from the <code class="literal">twilio.rest</code> module. An object is created with <span class="strong"><strong>AccountSID</strong></span> and <span class="strong"><strong>AuthToken</strong></span>.</p><p>We then use the <code class="literal">create()</code> method of the <code class="literal">client.messages</code> class and send a message. Here <code class="literal">to</code> is the number to which the message is sent, <code class="literal">from_</code> is the caller ID, and <code class="literal">body</code> is the text to be sent. Wondering why <code class="literal">from_</code> instead of <code class="literal">from</code>? Well, that's because <code class="literal">from</code> will conflict with Python's <code class="literal">from</code> keyword, which is used to import modules.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec102"/>There's more...</h2></div></div></div><p>Trivial, isn't it?! Sending a text message to our number was a breeze. Now, can you write your own application? Let's see what you can think of. Probably, send me a message to invite me to your birthday party!</p><p>But hey, what's the fun if we don't know how to receive an incoming message? Let's learn how to do this in the next section.</p></div></div>
<div class="section" title="Receiving SMS messages"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec39"/>Receiving SMS messages</h1></div></div></div><p>While you were thinking of the various use cases of sending SMS messages, you must have felt that the capability of receiving a text message is equally important. So, let's look at it with an auto-response-messaging app.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec103"/>Getting ready</h2></div></div></div><p>For this recipe, we will use the <span class="strong"><strong>ngrok</strong></span> software. The ngrok (<a class="ulink" href="https://ngrok.com/">https://ngrok.com/</a>) software helps you tunnel your local machine to the Internet. It means that you can expose your local server behind NAT or Firewall to the Internet. Really powerful utility! For the next recipe, download ngrok (<a class="ulink" href="https://ngrok.com/download">https://ngrok.com/download</a>) and run it on port 5000 using the command from your Terminal. If you're connected to the Internet you should see an instance up and running for you:</p><pre class="programlisting">
<span class="strong"><strong>./ngrok http 5000</strong></span>
</pre><p>The following screenshot shows how ngrok has made your app visible to the Internet and on the URL, <code class="literal">https://&lt;uuid&gt;.ngrok.io/</code>:</p><p>
</p><div class="mediaobject"><img alt="Getting ready" src="graphics/image_05_008.jpg"/></div><p>
</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note13"/>Note</h3><p>Don't start ngrok yet, we start ngrok during our recipe.</p></div></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec104"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Let's start by writing our server to receive SMSes. We'll call this <code class="literal">recv_sms.py</code>. The code for the server looks as follows:<pre class="programlisting">        from flask import Flask&#13;
        import twilio.twiml&#13;
        app = Flask(__name__)&#13;
        @app.route("/insms", methods=['GET', 'POST'])&#13;
        def respond_sms():&#13;
            resp = twilio.twiml.Response()&#13;
            resp.message("Thanks for your query. We will&#13;
                          get back to you soon")&#13;
        return str(resp)&#13;
        if __name__ == "__main__":&#13;
        app.run(debug=True)</pre></li><li class="listitem">Run the server with Python from your Terminal with the following command:<pre class="programlisting">
<span class="strong"><strong>        python recv_sms.py</strong></span>
</pre></li><li class="listitem">Start ngrok with the following command:<pre class="programlisting">
<span class="strong"><strong>        ./ngrok http 5000</strong></span>
</pre></li><li class="listitem">Nice, we got our server running. Let's configure our Twilio number by adding a <span class="strong"><strong>Request URL</strong></span>. For doing this, log in to Twilio, go to the <span class="strong"><strong>Phone Numbers</strong></span> section, and click on your rented number. Here, go to the messaging section and enter your <span class="strong"><strong>Request URL</strong></span> as shown in the following screenshot. Make sure that the URL points to the ngrok instance that was fired up in the previous step:<p>
</p><div class="mediaobject"><img alt="How to do it..." src="graphics/image_05_009.jpg"/></div><p>
</p></li></ol></div><p>And we're done! So, when someone sends a message to your rented number, they will receive an auto response saying <span class="strong"><strong>Thanks for your query. We will get back to you soon</strong></span>.</p><p>Awesome! That's great, but hey, how did it work?</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec105"/>How it works...</h2></div></div></div><p>The server that accepts the incoming message is written in <code class="literal">Flask</code> and runs on port 5000. This makes the server run on a local machine. To make it available on the Internet, we fire <code class="literal">ngrok</code> and make it run on the same port as the Flask server, which is port 5000.</p><p>We configure the Twilio phone number to route the incoming messages to our Flask server. To achieve this, we add the request URL to Twilio. So, whenever a message is sent to the rented number, it gets routed to our Flask server via ngrok. In our app, we have routed it to <code class="literal">https://&lt;ngrokId&gt;.ngrok.io/insms</code>.</p><p>If you look at our Flask server, we already a have a route configured with the URL, <code class="literal">/insms</code>. This route gets a <code class="literal">POST</code> call from the Twilio server (thanks to the <span class="strong"><strong>Request URL</strong></span> setting), which then responds back with the message, <span class="strong"><strong>Thanks for your query. We will get back to you soon</strong></span>.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec106"/>There's more...</h2></div></div></div><p>You learnt about sending and receiving text messages using Twilio. I know you're already thinking about your use cases and how you can leverage text messages to resolve them. Let's look at an example from the food retail industry.</p></div></div>
<div class="section" title="SMS workflows for Domino's"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec40"/>SMS workflows for Domino's</h1></div></div></div><p>John, the owner of a Domino's Pizza outlet in the US, is looking for ways to improve his pizza sales. One way to improve the sales would be to focus on making the process of ordering pizzas easier. He also wants to automate the workflows so that he can keep his customers updated on the order and delivery status. He also feels that while the Internet is great, customers may also want to order pizzas when they are in areas where the network reception is weak. What do you think he must do?</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec107"/>Getting ready</h2></div></div></div><p>Let's think about the use case and write down what all we'd need? Here are a few things I can think of:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Ability to receive incoming messages</li><li class="listitem" style="list-style-type: disc">Maintain and query the status of order</li><li class="listitem" style="list-style-type: disc">Send outgoing status message</li></ul></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec108"/>How to do it...</h2></div></div></div><p>Let's look at the solution and then understand how it works for the Domino's shop.</p><p>The following code snippet is divided into three main aspects: the ability to receive incoming messages with the <code class="literal">flask</code> route, maintaining the status of the order for customers who query their orders, and the ability to send outbound messages from the <span class="emphasis"><em>Flask</em></span> app:</p><pre class="programlisting">        from flask import Flask, request &#13;
        import twilio.twiml &#13;
 &#13;
        class Pizza: &#13;
            def __init__(self): &#13;
                self.status = None &#13;
 &#13;
            def setStatus(self, status): &#13;
                self.status = status &#13;
 &#13;
            def getStatus(self): &#13;
                return self.status &#13;
 &#13;
         app = Flask(__name__) &#13;
        @app.route("/insms", methods=['GET', 'POST']) &#13;
        def respond_sms(): &#13;
            content = request.POST['Body'] &#13;
            resp = twilio.twiml.Response() &#13;
            if content == 'ORDER': &#13;
                resp.message("Thanks! We're already on your order!") &#13;
                pizza = Pizza() &#13;
                pizza.setStatus('complete') &#13;
                return str(resp) &#13;
     &#13;
            if content == 'STATUS': &#13;
                pizza = Pizza() &#13;
                status = pizza.getStatus() &#13;
                if status == 'complete': &#13;
                    resp.message("Your order is ready!") &#13;
                    return str(resp) &#13;
                else: &#13;
                    resp.message("Sorry! could not locate your order!") &#13;
                    return str(resp) &#13;
     &#13;
                else: &#13;
                    resp.message("Sorry! Wrong selection") &#13;
                    return str(resp)         &#13;
 &#13;
        if __name__ == "__main__": &#13;
                app.run(debug=True) &#13;
</pre></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec109"/>How it works...</h2></div></div></div><p>We already have an app to receive the incoming messages. So, we use this app and extend it for our needs. Our rented number becomes a Domino's number, which is flashed on their advertising boards:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">In our use case, we have decided to use two keywords, <code class="literal">ORDER</code> and <code class="literal">STATUS</code>, which Domino's customers can use.</li><li class="listitem" style="list-style-type: disc">When customers send the message, <code class="literal">ORDER</code>, to Domino's, they can place an order for a pizza of their choice. The pizza shop positively responds to the order by saying they're already working on it.</li><li class="listitem" style="list-style-type: disc">When the customers want to know the status of their order, they can check it with a text saying, <code class="literal">STATUS</code>. In our case, when the customer queries for his order, he gets a response from the pizza shop saying that his order is ready. Imagine the satisfaction the customer gets when he reads this response.</li><li class="listitem" style="list-style-type: disc">Customers feel it's so easy to place an order and know its status. They'll certainly start ordering more! Well, at least I will.</li><li class="listitem" style="list-style-type: disc">John is so happy that he decides to give a pay rise to his IT manager, and incidentally, that happens to be you! Cool, isn't it?</li></ul></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec110"/>There's more...</h2></div></div></div><p>Now, if you note the messages sent by or to the pizza shop, they are sent to a rented number. How about sending the messages to a custom code like <span class="strong"><strong>DOMP</strong></span> (abbreviation for Domino's Pizza)? Yes, you can achieve that using SMS Short codes; they're not free and you need to buy them at a hefty price.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec111"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We have come to the end of all the recipes for SMS messages. Hope you learnt a few things and will implement a few of them for your benefit. Can you try sending MMS messages, such as an offer to your esteemed customers with the Domino's logo? That's something for you to explore.</li><li class="listitem" style="list-style-type: disc">In the next recipe, we will start working on voice calls and appreciate what they can offer. Can we do some awesome stuff with voice messages? Let's look at them in the next set of recipes.</li></ul></div></div></div>
<div class="section" title="Sending voice messages"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec41"/>Sending voice messages</h1></div></div></div><p>Heard of VoIP? Yes, <span class="strong"><strong>Voice over Internet Protocol</strong></span>. <span class="strong"><strong>VoIP</strong></span> (an abbreviation) is a group of technologies used for the delivery of voice and multimedia over Internet Protocol networks, such as the Internet itself. VoIP has opened up a whole new world for communication on the Internet with products such as Skype and Google Talk offering communication solutions in the consumer and enterprise domain.</p><p>Telephony API providers such as Twilio also use the VoIP protocol to send voice messages. You will learn how to make or receive voice calls using the Twilio APIs in this section. So, let's jump in and start using the APIs!</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec112"/>Getting ready</h2></div></div></div><p>In this recipe, we use the <code class="literal">twilio</code> and <code class="literal">flask</code> modules like we used in the previous recipe for SMS. So, no new installations are needed for this section.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec113"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We start by creating our configuration file. Sending a voice message is as trivial as sending a text message. We need the Twilio <span class="strong"><strong>AccountSID</strong></span> and <span class="strong"><strong>AuthToken</strong></span> here as well. We'd need the caller ID and the number to send the voice message to. Here's how our configuration looks:<pre class="programlisting">        TWILIO_ACCOUNT_SID = '&lt;Account SID&gt;' &#13;
        TWILIO_AUTH_TOKEN = '&lt;Auth Token&gt;' &#13;
        CALLERID = '&lt;Rented Number&gt;' &#13;
        MYNUMBER = '&lt;Number to call&gt;'   &#13;
</pre><p>
</p></li><li class="listitem">Let's now go ahead and write the code for our Flask server. The following code helps us in making voice calls using the Twilio Python APIs. We save the file as <code class="literal">voice_outbound.py</code>:<pre class="programlisting">        import config &#13;
        from flask import Flask, Response, request &#13;
        from twilio import twiml &#13;
        from twilio.rest import TwilioRestClient &#13;
  &#13;
        app = Flask(__name__) &#13;
        client = TwilioRestClient(config.TWILIO_ACCOUNT_SID, &#13;
                                  config.TWILIO_AUTH_TOKEN) &#13;
  &#13;
        @app.route('/call', methods=['POST']) &#13;
        def outbound_call(): &#13;
            response = twiml.Response() &#13;
            call = client.calls.create( &#13;
                to=config.MYNUMBER, &#13;
                from_=config.CALLERID, &#13;
                record='true', &#13;
            ) &#13;
            return Response(str(response), 200,&#13;
        mimetype="application/xml") &#13;
 &#13;
        if __name__ == '__main__': &#13;
        app.run(debug=True) &#13;
 &#13;
</pre><p>
</p></li><li class="listitem">Run the Flask server with the following command. This will run our Flask server on the default port 5000:<pre class="programlisting">
<span class="strong"><strong>        python voice_outbound.py</strong></span>
</pre></li><li class="listitem">Start ngrok with the following command on port 5000. This will make sure that our server is available on the Internet with the tunneling facility provided by ngrok. Copy the URL on which ngrok is running. It will be in the format, <code class="literal">https://&lt;ngrokid&gt;.ngrok.io/</code>, like we saw in previous section:<pre class="programlisting">
<span class="strong"><strong>        ./ngrok http 5000</strong></span>
</pre><p>Our server is now ready to make calls, so just go ahead and make a <code class="literal">POST</code> request to <code class="literal">https://&lt;ngrokid&gt;.ngrok.io/call</code>, and you should receive a call to your number as added in the configuration file.</p><p>Wow, that's cool! But what happens when you pick up the call? Your call gets disconnected. Why? That's because in Twilio, every voice call is accompanied with a callback URL, which will execute the next set of instructions once the call gets picked. This is not defined in our code, and hence, the call gets disconnected with an error. Let's fix this.</p></li><li class="listitem">So, let's add the answer callback URL and complete our server code:<pre class="programlisting">        import config &#13;
        from flask import Flask, Response, request &#13;
        from twilio import twiml &#13;
        from twilio.rest import TwilioRestClient &#13;
  &#13;
        app = Flask(__name__) &#13;
        client = TwilioRestClient(config.TWILIO_ACCOUNT_SID, &#13;
                                  config.TWILIO_AUTH_TOKEN) &#13;
  &#13;
        @app.route('/call', methods=['POST']) &#13;
        def outbound_call(): &#13;
            response = twiml.Response() &#13;
            call = client.calls.create( &#13;
                to=config.MYNUMBER, &#13;
                from_=config.CALLERID, &#13;
                record='true', &#13;
                url=config.BASE_URL + '/answer_url', &#13;
            ) &#13;
            return Response(str(response), 200,&#13;
                            mimetype="application/xml") &#13;
 &#13;
 &#13;
        @app.route('/answer_url', methods=['POST']) &#13;
        def answer_url(): &#13;
            response = twiml.Response() &#13;
            response.addSay("Hey! You are awesome. Thanks for answering.") &#13;
            return Response(str(response), 200,&#13;
                            mimetype="application/xml") &#13;
 &#13;
        if __name__ == '__main__': &#13;
            app.run(debug=True) &#13;
</pre></li><li class="listitem">If you look at the <code class="literal">url</code> parameter in the <code class="literal">outbound_call()</code> method, it points to <code class="literal">BASE_URL</code>. This is the same as the ngrok URL suffixed with <code class="literal">/answer_url</code>. Now, if you make a <code class="literal">POST</code> request to <code class="literal">https://&lt;ngrokid&gt;.ngrok.io/call</code>, your number will receive a call. Once you pick up the call, a callback <code class="literal">POST</code> request is made to <code class="literal">https://&lt;ngrokid&gt;.ngrok.io/answer_url</code> and you'll hear the message "<span class="emphasis"><em>Hey! You are awesome. Thanks for answering</em></span>". Wow!</li><li class="listitem">Here's how the server logs would be:<pre class="programlisting">        * Detected change in '/Users/chetan/book/ch05/app.py',&#13;
          reloading &#13;
        * Restarting with stat &#13;
        * Debugger is active! &#13;
        * Debugger pin code: 608-057-122 &#13;
 &#13;
        127.0.0.1 - - [16/Jul/2016 21:35:14] "POST &#13;
                       /call HTTP/1.1" 200 - &#13;
        127.0.0.1 - - [16/Jul/2016 21:35:22] "POST &#13;
                       /answer_url HTTP/1.1" 200 - &#13;
</pre></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec114"/>How it works...</h2></div></div></div><p>So, how does it work? After doing the SMS section, this should be pretty straightforward to understand. We will go through the code step by step:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We first create a <code class="literal">twilio</code> object, <code class="literal">client</code>, with the <code class="literal">TwilioRestClient</code> class from the <code class="literal">twilio.rest</code> module.</li><li class="listitem">We define a route in our Flask app, <code class="literal">/call</code>, which accepts the <code class="literal">POST</code> method calls. This route makes a voice call to our number.</li><li class="listitem">The actual call is made in the <code class="literal">outbound_call()</code> route method with the help of the <code class="literal">create()</code> method of the <code class="literal">client.calls</code> class.</li><li class="listitem">In the <code class="literal">create()</code> call, we define the parameters, such as:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">to</code>: This is the mobile/landline number that is called</li><li class="listitem" style="list-style-type: disc"><code class="literal">from_</code>: This is the rented number from Twilio</li><li class="listitem" style="list-style-type: disc"><code class="literal">record</code>: This will decide if the call should be recorded</li><li class="listitem" style="list-style-type: disc"><code class="literal">url</code>: This is the callback answer <code class="literal">url</code> that gets called when the voice call is answered</li></ul></div></li><li class="listitem">In the Flask app, we have also defined a new route, <code class="literal">/answer_url</code>, which gets called when the call is picked up. Now, this is interesting to understand. Twilio works on the philosophy of TwiML, also known as the Twilio markup language. If you look at the markup, it is pretty much an XML markup. TwiML is a set of instructions that can be used to tell Twilio what it needs to do with an incoming SMS or voice call. So, the <code class="literal">addSay()</code> method is the same as:<pre class="programlisting">        &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;Response&gt;&#13;
        &lt;Say&gt;Hey! You are awesome. Thanks for answering&lt;/Say&gt;&#13;
        &lt;/Response&gt; &#13;
</pre></li></ol></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec115"/>There's more...</h2></div></div></div><p>So, we learnt how to send voice calls to a given number and how the answer callback URL gets called when the call is answered. Now, let's learn how to handle an incoming voice call.</p></div></div>
<div class="section" title="Receiving voice calls"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec42"/>Receiving voice calls</h1></div></div></div><p>Receiving voice calls is an important facet to developing apps using cloud telephony. A lot of business cases (as you'd have imagined) are dependent on incoming voice calls. Let's look at handling incoming voice calls using the Twilio APIs.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec116"/>Getting ready</h2></div></div></div><p>In this recipe, we use the <code class="literal">twilio</code> and <code class="literal">flask</code> modules like we used in the previous recipe for SMS. So, no new installations are needed for this section.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec117"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We start by creating our configuration file. We need the Twilio <span class="strong"><strong>AccountSID</strong></span> and <span class="strong"><strong>AuthToken</strong></span> here as well. We don't need any caller ID in this case as the rented number itself is the caller ID.</li><li class="listitem">Now, let's look at our Flask server, the code for which is given in the following. We call this as <code class="literal">voice_inbound.py</code>:<pre class="programlisting">        from flask import Flask, Response, request &#13;
        from twilio import twiml &#13;
        from twilio.rest import TwilioRestClient &#13;
 &#13;
        app = Flask(__name__) &#13;
        client = TwilioRestClient(config.TWILIO_ACCOUNT_SID, &#13;
                                  config.TWILIO_AUTH_TOKEN) &#13;
 &#13;
        @app.route('/incall', methods=['POST']) &#13;
        def inbound_call(): &#13;
            response = twiml.Response() &#13;
            response.addSay("Thanks for calling our customer &#13;
                             service." "Please hold while we &#13;
                             connect you to our advisors.") &#13;
            return Response(str(response), 200,&#13;
                            mimetype="application/xml") &#13;
 &#13;
        if __name__ == '__main__': &#13;
            app.run(debug=True) &#13;
</pre></li><li class="listitem">Run the Flask server with the following command. This will run our Flask server on the default port 5000:<pre class="programlisting">
<span class="strong"><strong>        python voice_outbound.py</strong></span>
</pre></li><li class="listitem">Start ngrok with the following command on port 5000. This will make sure that our server is available on the Internet with the tunneling facility provided by ngrok. Copy the URL on which ngrok is running. It will be in the format, <code class="literal">https://&lt;ngrokid&gt;.ngrok.io/</code>, like we saw in the previous section:<pre class="programlisting">
<span class="strong"><strong>        ./ngrok http 5000</strong></span>
</pre></li><li class="listitem">Now, log in to Twilio and configure the rented number for incoming voice calls. We configure the <span class="strong"><strong>Request URL</strong></span> to point to the ngrok URL. See the following screenshot to know how to add the <span class="strong"><strong>Request URL</strong></span> to your rented number:<p>
</p><div class="mediaobject"><img alt="How to do it..." src="graphics/image_05_010.jpg"/></div><p>
</p></li><li class="listitem">Once you have the servers running and the settings configured on Twilio, make a call to your rented number through Skype or Google Talk. This will make a <code class="literal">POST</code> call to our Flask server, which in turn will respond with a TwiML response saying, <span class="emphasis"><em>Thanks for calling our customer service. Please hold while we connect you to our advisors</em></span>.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec118"/>How it works...</h2></div></div></div><p>The server that accepts the incoming message is written in Flask and runs on port 5000. This is local to our machine, and to make it available on the Internet, we create a tunnel with ngrok.</p><p>Now, when the rented number is called by anyone, Twilio looks up for the <span class="strong"><strong>Request URL</strong></span> and makes a request to this URL, suggesting that there is an incoming call to the rented number.</p><p>Our flask server defines a route, <code class="literal">/incall</code> (to match with the <span class="strong"><strong>Request URL</strong></span>), which gets called when our rented number receives an incoming call. The <code class="literal">/incall</code> route, in turn, creates a TwiML response that adds <code class="literal">&lt;Say&gt;</code> to the <code class="literal">&lt;Response&gt;</code> markup, and the caller gets to the message added in the <code class="literal">&lt;Say&gt;</code> XML.</p><p>The following screenshot shows how the TwiML response looks in Twilio. By the way, every call or SMS received or sent can be seen from the Twilio interface:</p><p>
</p><div class="mediaobject"><img alt="How it works..." src="graphics/image_05_011.jpg"/></div><p>
</p></div></div>
<div class="section" title="Building your own customer service software"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec43"/>Building your own customer service software</h1></div></div></div><p>Paul is responsible for customer service at his company. The company has a nice looking fancy website that has a facility to receive customer grievances or questions over chat. Paul often receives feedback from his customers that the chat system is not useful as they would like to get in touch with someone from the company when they hit product issues and would like to get these resolved quickly. Can you make Paul's life easier?</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec119"/>Getting ready</h2></div></div></div><p>Let's think about the use case and write down what all we'd need? Here are a few things I can think of:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Ability to receive incoming calls</li><li class="listitem" style="list-style-type: disc">Transfer the call to a customer support engineer</li></ul></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec120"/>How to do it...</h2></div></div></div><p>Let's look at the solution and then understand how it would work for Paul.</p><p>In this code snippet, we will add the ability to receive incoming calls to the rented numbers and also add the functionality of call transfer:</p><pre class="programlisting">        import config &#13;
        from flask import Flask, Response, request &#13;
        from twilio import twiml &#13;
        from twilio.rest import TwilioRestClient &#13;
 &#13;
        app = Flask(__name__) &#13;
        client = TwilioRestClient(config.TWILIO_ACCOUNT_SID, &#13;
                                  config.TWILIO_AUTH_TOKEN) &#13;
 &#13;
        @app.route('/call', methods=['POST']) &#13;
        def inbound_call(): &#13;
            call_sid = request.form['CallSid'] &#13;
            response = twiml.Response() &#13;
            response.dial().conference(call_sid) &#13;
            call = client.calls.create(to=config.MYNUMBER, &#13;
                                       from_=config.CALLERID, &#13;
                                       url=config.BASE_URL + &#13;
                                       '/conference/' + call_sid) &#13;
            return Response(str(response), 200,&#13;
                            mimetype="application/xml") &#13;
 &#13;
 &#13;
        @app.route('/conference/&lt;conference_name&gt;', &#13;
                    methods=['GET', 'POST']) &#13;
        def conference_line(conference_name): &#13;
            response = twiml.Response() &#13;
        response.dial(hangupOnStar=True).conference(&#13;
                          conference_name) &#13;
            return Response(str(response), 200,&#13;
                            mimetype="application/xml") &#13;
 &#13;
        if __name__ == '__main__': &#13;
            app.run(debug=True) &#13;
</pre></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec121"/>How it works...</h2></div></div></div><p>We have already created an app that receives incoming calls. We extend this app to our use case so that when a customer calls the rented number, a <code class="literal">POST</code> call is made to the <code class="literal">/call</code> route as defined by the <code class="literal">inbound_call()</code> method.</p><p>Our <code class="literal">flask</code> route takes the incoming call and adds it to a conference with the help of the TwiML instruction set. Conference, as you know, is a group of calls bridged with each other in one conference.</p><p>The <code class="literal">response.dial().conference(conference_name)</code> method is the method that helps us in adding a call leg to the conference. This is how the TwiML looks; you can see the <code class="literal">&lt;Response&gt;</code> tag under which we have the <code class="literal">&lt;Dial&gt;</code> and <code class="literal">&lt;Conference&gt;</code> tags:</p><p>
</p><div class="mediaobject"><img alt="How it works..." src="graphics/image_05_012.jpg"/></div><p>
</p><p>The <code class="literal">flask</code> route makes sure it makes an outgoing call to the customer support engineer (identified by <code class="literal">MYNUMBER</code>). The outgoing call to the customer support engineer is configured with the <code class="literal">url</code> parameter (the answer URL like we saw in our outgoing voice call section). So, when the support engineer picks up the call, the callback answer URL gets called and the engineer call leg is also added to the same conference as the incoming call leg.</p><p>Both the call legs, the incoming call from the customer and the outgoing call made to the support engineer, are now in one conference and can have a conversation. The customer gets his questions resolved in a jiffy and Paul is happy. Cool!</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec122"/>There's more...</h2></div></div></div><p>You learned how to build your own SMS and voice applications by using the cloud telephony APIs. However, if you're really interested in leveraging the already built solutions for your needs, you can look up to some standard software applications, such as CallHub (<a class="ulink" href="https://callhub.io/">https://callhub.io/</a>), which will help you automate your use cases efficiently at reasonable costs. You can also build your own call center solution with their APIs. So, what are you building next?</p><p>I'm sure you enjoyed the chapter; let's have some more fun in the next chapter. Let's see what we have in store!</p></div></div></body></html>