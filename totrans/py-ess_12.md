# 第十二章：脚本、模块、包、库和应用程序

虽然在与 Python 的 **读取-评估-打印循环**（**REPL**）`>>>` 提示符一起工作时很容易，但我们的真正目标是创建 Python 应用程序文件。一个 Python 文件可能是一个脚本，这意味着当它被 Python 程序执行时应该能够做一些有用的工作。一个文件可能是一个模块，这意味着它被设计为导入以提供有用的定义。Python 模块的目录是一个 **包**。这些都是由语言实现的正式定义。

更通用的术语如 **库**、**应用程序**或 **框架** 并没有由语言正式化。我们有在 Python 中实现这些常见概念的方法。我们可以将模块或包的集合视为库。例如，*Python 标准库*是一个包含大量模块和包的大集合。一个“应用程序”至少是一个脚本。更复杂的应用程序可能涉及脚本以及几个额外的模块和包。框架将是一个 Python 应用程序，我们将向其中注入定制的模块或包。许多框架还将包括非 Python 文件：一个网络框架可能包括大量的 HTML 和 CSS；一个 GUI 框架可能包括图像文件和字体。

我们将探讨创建和运行脚本文件。我们还将探讨创建模块和模块包。最后，我们将探讨一个非常巧妙的 Python 功能，它允许我们编写既可以作为脚本使用也可以作为模块使用的脚本。这种设计模式允许我们构建基于其他应用程序的复合应用程序。

# 脚本文件规则

Python 脚本文件必须遵循一条简单的规则：*它必须是纯文本格式*。在某些情况下，一个不恰当的文件名可能会导致问题，因此我们将提供两条经常有帮助的建议：

+   内容必须是纯文本；理想情况下使用 UTF-8 编码，尽管 ASCII 也很流行。

+   文件名应遵循 Python 标识符规则。它应以字母开头，并仅使用字母、数字和下划线 `_` 字符。以 `__`（两个下划线）开头和结尾的文件名是保留的，并且对 Python 有特殊含义。

+   扩展名应为 `.py`。

这两条额外的建议对于编写模块和包是必不可少的，但编写简单的脚本并不需要。

脚本简单地说是一系列语句；它与我们在 REPL 提示符 `>>>` 中可能执行的操作相同，只有一个区别：脚本没有隐式的打印输出。我们必须在脚本中使用 `print()` 函数来查看任何结果。在更大的应用程序中，我们经常使用 `logging` 模块来生成更复杂的输出。在某些情况下，随着应用程序的成熟，我们将仔细替换我们放入早期技术激增中的所有 `print()` 函数，用 `logging.debug()` 函数替换。

要运行脚本，我们需要将其作为输入提供给 Python 程序。我们将探讨三种常见的方法来实现这一点。

# 通过文件名运行脚本

运行脚本的常见方式是将文件名提供给 Python 命令。假设我们在名为`Chapter_12`的目录中有一个名为`ch12_script1.py`的文件。

在 Linux 和 Mac OS X 中，完整名称将是`Chapter_12/ch12_script1.py`。在 Windows 中，完整文件名将是`Chapter_12\ch12_script1.py`。在剩余的示例中，我们将坚持使用 Linux 标准的文件名。

这是我们通过提供文件名来运行脚本的方式：

```py
MacBookPro-SLott:Code slott$ python3 Chapter_12/ch12_script1.py
Temperature °C: 8
C=8°, F=46°

```

这个输出显示了操作系统提示符。我们输入的`python3`命令被突出显示。提示符和脚本的输出也被显示出来。这个例子对于使用 Python 2 作为内部语言的操作系统来说是典型的；我们必须区分我们新的 Python 3 和操作系统的内部`python`命令。

应用程序提示我们，我们输入了 8 摄氏度。输出显示 8°C 大约是 46°F。我们需要穿上外套。

脚本文件`ch12_script1.py`看起来像这样：

```py
c= float(input("Temperature °C: "))
f = 32+9*c/5
print("C={c:.0f}°, F={f:.0f}°".format(c=c,f=f))
```

该脚本使用`input()`函数在控制台提示交互式用户。输出通过简单的`print()`函数显示。

我们保持脚本较小，以强调脚本可以运行的方式。与此相关的用户体验（UX）问题有很多，但这不是本节的重点。

## 通过模块名称运行脚本

在大多数情况下，我们的脚本可以安装在 Python 库中的`site-packages`目录内，或者我们可以使用`PYTHONPATH`环境变量扩展 Python 路径，包括脚本的位置。这两种方法中的任何一种都可以使脚本文件在 Python 的搜索路径上可见。

要在`site-packages`中安装脚本，我们可以依赖 Python 的`distutils`包。我们将创建一个`setup.py`文件，该文件描述了我们想要安装的模块。然后我们可以运行`python3 setup.py install`，将我们的模块放置到`site-packages`目录中。像`pip`和`easy-install`这样的安装程序需要按照这个标准模式使用`distutils`。

我们还可以定位`site-packages`目录，并将我们的模块手动复制到该目录。这个位置因操作系统而异。这个目录是`sys.path`变量中的最后一个项目。

设置`PYTHONPATH`环境变量是另一种选择。我们可以使用 Linux 的`export`命令来更改环境变量。我们经常将其放在`~/.bash_profile`文件中。对于 Windows，我们必须更改设置环境变量的高级系统设置。我们可以通过`PYTHONPATH`变量轻松创建包含许多模块的私有库，使其可见。

一旦我们的模块在 Python 的搜索路径上可见，我们可以像这样执行模块：

```py
MacBookPro-SLott:Code slott$ python3 -m Chapter_12.ch12_script1
Temperature °C: 8
C=8°, F=46°

```

当我们提供`-m`选项时，我们正在命名一个要执行的模块。在这个例子中，我们使用了一个限定名称：`Chapter_12`是一个包，`ch12_script1`是这个包内的模块。我们将在后面的部分中查看包；包基本上是模块文件可以找到的目录。

## 使用操作系统 shell 规则运行脚本

我们运行脚本的第三种方式是通过使脚本文件可执行，并在脚本文件和 Python3 程序之间建立操作系统关联。

在 Linux 和 Mac OS X 中，文件关联是通过文件的第一行设置的。我们经常将类似以下内容作为文件的第一行，以关联给定的`.py`文件和 Python3 程序：

```py
#!/usr/bin/env python3
```

这将使用操作系统的`env`程序来定位并启动`python3`环境。shell 将整个文件作为输入提供给名为`#!`行的程序。这意味着`env`程序将以脚本文件作为输入启动。`env`程序将准备环境，然后将文件交给 Python3 程序。

要在 Linux 和 Mac OS X 中将文件标记为可执行，我们使用`chmod +x`命令。我们可以这样做来标记我们的脚本为可执行：

```py
MacBookPro-SLott:Code slott$ chmod +x Chapter_12/ch12_script1.py

```

此命令将执行`x`选项添加到文件的模式中。当我们执行`ls -l`时，我们会在文件详情中看到这一点。

在 Windows 中，所有文件都被认为是可执行的。文件扩展名与程序的关联是通过 Windows 控制面板完成的。这个设置是在你安装 Python 时设置的。

一旦文件被标记为可执行，我们只需提供名称就可以运行它：

```py
MacBookPro-SLott:Code slott$ Chapter_12/ch12_script1.py

```

在 Windows 中，`.py`文件扩展名绑定到 Python 程序，Windows 将启动 Python，并将此文件名作为输入。文件名与脚本的绑定在应用程序之外。

在 Linux 和 Mac OS X 中，处理基于文件的神奇第一行。Linux shell 检查文件的模式，以确认它是可执行的。然后它读取文件的前几个字节。在这种情况下，前几个字节是`#!`，这标志着文件是一个脚本。脚本的第一行完整地包含了必须用于处理此脚本命令。在这种情况下，命令是`/usr/bin/env python3`。shell 使用这个程序作为输入启动这个程序。

## 选择好的脚本名称

脚本名称应保持简短且具有意义。与文件名一样，通常最好避免复杂的前缀和后缀。Linux 或 Windows DOS 命令提供了一些关于什么使脚本名称好（和不好）的指导。最好的例子之一是`git`命令，它有众多的子命令。而不是发明几十个看起来复杂的名称，**git**使用一个简单的命令名作为前缀。

用于解析命令行参数的`argparse`模块很好地支持了这一点。我们可以定义一些适用于所有子命令的常见参数。我们还可以定义仅适用于每个子命令的独特参数。

为了保持这本书的代码按照出版流程组织，脚本名称很长。这些名称中的冗余（`Chapter_12/ch12_...`）不是最佳实践，应尽可能避免。与变量名和函数名一样，脚本名称应保持合理短且有意义。

# 创建可重用模块

在 Python 中，模块是软件重用的单元。当我们有一个必须出现在多个脚本中的特性时，我们会把这个特性放入一个模块中，并将该模块导入到每个共享该特性的脚本中。

需要注意“重用”这个词的两个略有不同的含义如下：

+   我们可以通过定义类层次结构在应用程序内实现局部重用。继承是共享相关对象代码的一种优雅方式。我们通常会在单个模块文件中定义所有这些相关类。

+   我们可以定义一个模块以实现跨应用程序的较少局部重用。

要创建一个可导入的模块，我们只需确保 Python 文件可见于 Python 搜索路径的一部分目录中。由于本地目录总是可见的，我们只需在当前工作目录中创建一个文件即可创建一个模块。

设计用于导入的模块应主要由`import`、`class`和`def`语句组成。我们也可以使用赋值语句来创建模块全局变量，但我们需要谨慎处理多少工作。通过赋值、`class`、`def`或`import`创建的任何名称都将位于该模块的命名空间中。

模块只导入一次。`import`实现会检查全局已加载模块的缓存，即`sys.modules`，以查看模块是否已知。正因为如此，实际上执行某种处理的模块只会这样做一次。之后，导入就会被忽略。这种行为使得在导入模块内部创建全局**单例**对象变得容易。

在`import`时进行大量处理的模块示例有`this`和`antigravity`。当我们执行`import this`或`import antigravity`时，这些模块将立即执行一些有趣的处理。一旦被导入一次，它们就不会再这样做。虽然在一些特定情况下很有用，但这不是一个通用的模式。

### 小贴士

我们通常期望一个`import`语句提供类、函数和模块全局变量的定义。

我们通常不期望`import`语句执行有用的处理。

模块可以定义一个独特的异常。我们可能想在模块中创建一个名为`Error`的通用异常类。它可能看起来像这样：

```py
class Error(Exception): pass
```

因为当模块被导入时，这个名称将由模块名称限定，所以我们能够通过`some_module.Error`来引用这个异常。它可能看起来像这样：

```py
import some_module
try:
    some_module.some_function()
except some_module.Error as e:
    logger.exception("some_function broke: {0}".format(e))
```

模块名`some_module`作为`Error`类定义来源的一个很好的限定符。我们不需要给`Error`类一个更复杂、全局唯一的名称。

# 创建混合库/应用程序模块

脚本可以导入模块，也许定义一些函数或类，但它总是会执行相关的处理。我们的第一个示例脚本只有三条相关的处理语句：两个赋值语句和一个打印结果的函数声明。这展示了 Python 的理想，即没有任何样板代码的程序；我们试图避免只是开销的语法。

完美清洁脚本方法的可能缺点是创建单元测试困难。每个单元测试都必须作为子进程调用脚本；这可能涉及相当多的操作系统开销。单元测试的目标是隔离每个单元——每个函数、类、模块、包或脚本——以便可以单独测试。让操作系统启动脚本文件似乎并没有得到适当的隔离。

此外，随着应用程序的成熟，一个好的脚本可能成为更大、更全面的应用程序中的一个组件。从脚本文件中创建复合应用程序可能会变得困难。从函数或类中创建复合过程则容易得多。

这导致了对脚本以下建议的结构：

```py
def c_to_f():
    c= float(input("Temperature °C: "))
    f = 32+9*c/5
    print("C={c:.0f}°, F={f:.0f}°".format(c=c,f=f))

if __name__ == "__main__":
    c_to_f()
```

我们已经将脚本用 `def` 语句包装起来，使其成为一个函数。然后我们编写了一个 `if` 语句，通过检查 `__name__` 变量来区分主脚本和导入的模块。`if` 语句做出以下条件：

+   当模块被导入时，Python 将全局变量 `__name__` 设置为实际的模块名称

+   当作为主脚本运行时，Python 将全局变量 `__name__` 设置为 `__main__`

这种模式可以用来编写运行其自身单元测试的库模块。我们可以在一个永远不会作为主脚本的库模块中包含以下内容：

```py
if __name__ == "__main__":
    import doctest
    doctest.testmod( verbose=1 )
```

这将运行嵌入在文档字符串中的所有单元测试。我们将在第十四章第十四章。完善 – 单元测试、打包和文档中更详细地讨论测试，*完善 – 单元测试、打包和文档*。

# 创建包

包是一个包含模块文件和一个附加文件的目录。每个包都必须有一个 `__init__.py` 文件。此文件必须存在，通常是空的。

Tim Peters 的诗歌《Python 之禅》提供了以下建议：

> *扁平优于嵌套*。

理想是尽可能地将 Python 应用程序组织成模块的扁平集合。深度嵌套、复杂的包层次结构并不被认为是有帮助的。

我们可以使用两种方式使用包。我们可以导入包的一部分模块。例如，标准库有一个包含几个 XML 解析模块的 XML 包。我们可以使用 `import xml.etree` 从 XML 包中导入 `etree` 模块。在这种情况下，`__init__.py` 文件有一个注释和子包列表。

在其他情况下，我们可以将包作为一个模块整体导入。例如，当我们编写 `import collections` 时，实际上我们导入的是模块 `collections/__init__.py`。

`__init__.py` 文件是整个包的最高级模块。它可以是一个空文件，在这种情况下，我们只能从包内部选择特定的模块。或者 `__init__.py` 文件可能包含内容，允许我们将整个包导入为一个单一的复杂结构。

# 设计替代实现

我们可以轻松地提供给定功能的替代实现。如果我们想要更高的速度、更高的精度或更少的内存使用，我们应该能够导入给定库的替代定义。

我们可以通过比较 `math` 和 `cmath` 模块来具体说明这个原则。以下是他们之间差异的一个例子：

```py
>>> import math
>>> import cmath
>>> math.sqrt(-1)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ValueError: math domain error
>>> cmath.sqrt(-1)
1j
```

`math` 模块包含一个平方根函数，我们使用 `math.sqrt()` 来调用它。这个函数只产生实数值结果，并且当遇到非实数值的表达式时必须抛出异常。

`cmath` 模块也包含一个平方根函数。`cmath.sqrt()` 函数可以返回复数值而不是抛出异常。由于这两个包非常相似，我们可以以多种方式相互替换。

这两个模块提供了一组类似的函数定义。模块内的组件具有相同的名称。作为命名空间的模块有不同的名称，以区分定义的来源。

这种技术通常用于支持不同的平台。我们可以在包内部创建具有平台特定模块的包。包的最高级 `__init__.py` 可以选择导入哪个模块并提供平台特定的定义。我们也可以使用这种方法来编写必须在不同环境中运行的商业软件：开发、质量保证和最终生产。一个包可以包含不同的配置模块。标准库中的 `os` 包展示了这个概念。

# 查看包搜索路径

我们可以通过导入 `sys` 包来查看 Python 的搜索路径 `sys.path`：

```py
>>> import sys
>>> sys.path
['', '/Library/Frameworks/Python.framework/Versions/3.3/lib/python3.3/site-packages/setuptools-2.0.2-py3.3.egg',
*…, etc.*
'/Library/Frameworks/Python.framework/Versions/3.3/lib/python33.zip',
'/Library/Frameworks/Python.framework/Versions/3.3/lib/python3.3',
'/Library/Frameworks/Python.framework/Versions/3.3/lib/python3.3/plat-darwin',
'/Library/Frameworks/Python.framework/Versions/3.3/lib/python3.3/lib-dynload',
'/Library/Frameworks/Python.framework/Versions/3.3/lib/python3.3/site-packages']
```

我们已经省略了输出中的许多行，以展示标准库如何融入我们开发 Python 代码的方式。这个搜索模块的位置列表是由 `sites` 包在 Python 启动时构建的。

零长度目录名 `''` 是第一个。这意味着当前工作目录是首选的模块定位位置。这允许我们从本地目录导入我们自己的模块。在我们的本地目录之后，会搜索多个位置，最后以 `.../site-packages` 目录结束。

接下来的名称组，从 `setuptools-2.0.2-py3.3.egg` 开始，是所有以下载的 `.egg` 文件形式添加到这个安装中的外部包的列表。确切列表会因安装而异。这些名称是由 `pip` 和 `easy_install` 程序创建的。

当我们设置`PYTHONPATH`环境变量时，这些名称会被拼接到各种已安装包的路径*之后*。以`python33.zip`开始的最后一组名称是 Python 附带的一些常见模块列表。最后一项列出的是库的通用 site-packages 部分。如果你下载了一个包并运行该包的`setup.py`脚本，它将被复制到这个目录中，Python 将会找到它。

`sys.path`对象是一个正确的可变列表。我们可以在脚本文件中动态地更改路径。这可能会使得确定脚本所依赖的所有模块变得困难。几乎总是更清晰的是明确地依赖于正确安装的模块或设置`PYTHONPATH`环境变量。

# 摘要

在本章中，我们探讨了组织软件的高级方法。一个函数包含许多语句，一个类包含许多方法函数，一个模块可以包含许多类和函数。一个包可以包含许多模块。

我们已经探讨了执行 Python 脚本的各种方法。由于我们需要在许多不同的上下文中执行软件，所以我们有很大的灵活性。通常，我们会关注通过模块名而不是文件名来执行 Python 程序。这种区别很小。由于一个模块必须在搜索路径上，我们可以创建一个包含脚本以及任何支持模块和库的目录，并确保这个目录被命名为`PYTHONPATH`。

我们已经探讨了如何创建包含定义的库模块，这些模块将被导入到其他脚本中。这是我们主要的重用方法。我们还探讨了如何创建一个作为库模块可重用的脚本。这支持单元测试以及我们软件的成熟。

在第十三章中，我们将探讨一些更高级的编程技术。这些技术将使我们能够创建更复杂的类和函数定义。我们可以使用这些设计模式来编写更灵活和可重用的软件。
