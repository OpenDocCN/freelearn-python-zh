<html><head></head><body>
		<div id="_idContainer105">
			<h1 id="_idParaDest-252" class="chapter-number"><a id="_idTextAnchor256"/><st c="0">9</st></h1>
			<h1 id="_idParaDest-253"><a id="_idTextAnchor257"/><st c="2">Securing Flask Applications</st></h1>
			<p><st c="29">Like any web application, Flask applications have vulnerabilities that require protection from external attacks, which exploit these software defects. </st><st c="181">These cyber-attacks are mainly due to broken access control problems, </st><strong class="bold"><st c="251">Cross-Site Scripting</st></strong><st c="271"> (</st><strong class="bold"><st c="273">XSS</st></strong><st c="276">), </st><strong class="bold"><st c="280">Cross-Site Request Forgery</st></strong><st c="306"> (</st><strong class="bold"><st c="308">CSRF</st></strong><st c="312">), </st><strong class="bold"><st c="316">Server-Side Request Forgery </st></strong><st c="344">(</st><strong class="bold"><st c="345">SSRF</st></strong><st c="349">), </st><strong class="bold"><st c="353">SQL Injection</st></strong><st c="366">, and </st><strong class="bold"><st c="372">Denial-of-Service</st></strong><st c="389"> (</st><strong class="bold"><st c="391">DoS</st></strong><st c="394">), as well as outdated modules </st><span class="No-Break"><st c="426">and libraries.</st></span></p>
			<p><st c="440">Implementing security measures must be an utmost priority of any Flask application, especially if it is more dependent on external modules when building its models, repository layers, and workflow-related transactions. </st><st c="660">Using third-party libraries can inflict risks to the Flask applications because some library codes can contain coding errors or vulnerabilities. </st><st c="805">This is especially true for codes sourced from outdated third-party modules and libraries with </st><span class="No-Break"><st c="900">unreliable sources.</st></span></p>
			<p><st c="919">It is easier to build Flask components and features with external modules, such as implementing the authentication and authorization measures using the </st><strong class="bold"><st c="1072">Authlib</st></strong><st c="1079"> module instead of composing it from the ground up. </st><st c="1131">To decrease the chance of, if not avoid, web attacks, one should devise a security plan that will employ only reliable and updated modules. </st><st c="1271">This will protect the application from </st><span class="No-Break"><st c="1310">outside attackers.</st></span></p>
			<p><st c="1328">The main goal of this chapter is to provide possible security solutions for Flask applications to avoid some of the well-known web attacks using Flaskâ€™s built-in components, as well as some up-to-date and reliable </st><span class="No-Break"><st c="1543">third-party libraries.</st></span></p>
			<p><st c="1565">Here are the topics that we will cover in the context of helping us secure our </st><span class="No-Break"><st c="1645">Flask applications:</st></span></p>
			<ul>
				<li><st c="1664">Adding protection from </st><span class="No-Break"><st c="1688">web vulnerabilities</st></span></li>
				<li><st c="1707">Securing </st><span class="No-Break"><st c="1717">response data</st></span></li>
				<li><st c="1730">Managing </st><span class="No-Break"><st c="1740">user credentials</st></span></li>
				<li><st c="1756">Implementing web </st><span class="No-Break"><st c="1774">form authentication</st></span></li>
				<li><st c="1793">Preventing </st><span class="No-Break"><st c="1805">CSRF attacks</st></span></li>
				<li><st c="1817">Implementing user authentication </st><span class="No-Break"><st c="1851">and authorization</st></span></li>
				<li><st c="1868">Controlling the view or </st><span class="No-Break"><st c="1893">API access</st></span></li>
			</ul>
			<h1 id="_idParaDest-254"><a id="_idTextAnchor258"/><st c="1903">Technical requirements</st></h1>
			<p><st c="1926">This chapter is about a </st><strong class="bold"><st c="1951">vaccine reporting and management system</st></strong><st c="1990"> that showcases security solutions for preventing attacks from outside the system. </st><st c="2073">Its web forms explain how to impose sanitation and validation to avoid injection attacks and XSS. </st><st c="2171">Specifically, its login form discusses how to save credentials to the browser. </st><st c="2250">Also, it highlights views that render unsanitized data from user requests. </st><st c="2325">Most importantly, this application provides options on authentication and authorization procedures applicable and accepted by Flask to secure and manage the access control of its web forms and API resources. </st><st c="2533">By the way, the application has several versions that serve as specimens in depicting various security issues and the solutions on how to manage them. </st><st c="2684">All the projects use </st><strong class="source-inline"><st c="2705">Flask[async]</st></strong><st c="2717"> features, including asynchronous </st><strong class="source-inline"><st c="2751">Flask-SQLAlchemy</st></strong><st c="2767"> transactions. </st><st c="2782">They are available </st><span class="No-Break"><st c="2801">at </st></span><a href="https://github.com/PacktPublishing/Mastering-Flask-Web-Development/tree/main/ch09"><span class="No-Break"><st c="2804">https://github.com/PacktPublishing/Mastering-Flask-Web-Development/tree/main/ch09</st></span></a><span class="No-Break"><st c="2885">.</st></span></p>
			<h1 id="_idParaDest-255"><a id="_idTextAnchor259"/><st c="2886">Adding protection from web vulnerabilities</st></h1>
			<p><st c="2929">SQL injection, SSRF, and XSS attacks are the most common web vulnerabilities that corrupt many web applications. </st><st c="3043">They also affect any applications that use HTTP-based transactions, such as </st><strong class="source-inline"><st c="3119">POST</st></strong><st c="3123">, </st><strong class="source-inline"><st c="3125">PUT</st></strong><st c="3128">, </st><strong class="source-inline"><st c="3130">PATCH</st></strong><st c="3135">, and </st><strong class="source-inline"><st c="3141">DELETE</st></strong><st c="3147">. SQL injection occurs when an attacker infiltrates the backend datastore that manages the content of the trusted application. </st><st c="3274">Embedded </st><a id="_idIndexMarker774"/><st c="3283">malicious SQL code can tamper with the data, rendering unwanted pages or destroying the database. </st><st c="3381">XSS attacks commonly insert malicious scripts into the pages of the application to steal cookies, session data, and sensitive credentials from the system. </st><st c="3536">On the other hand, CSRF occurs inside an authenticated environment. </st><st c="3604">It happens when a valid user performs an HTTP transaction and a malicious script lurking in the browser usurps valid credentials with bogus and invalid ones to lead transactions to </st><span class="No-Break"><st c="3785">untrusted systems.</st></span></p>
			<h2 id="_idParaDest-256"><a id="_idTextAnchor260"/><st c="3803">Applying form validation to request data</st></h2>
			<p><st c="3844">One solution to avoid these attacks is to design a form validation that will not cost several lines of code or add more performance</st><a id="_idIndexMarker775"/><st c="3976"> overhead to the view or API functions. </st><st c="4016">The </st><strong class="bold"><st c="4020">Flask-WTF</st></strong><st c="4029"> module, for instance, can provide a </st><strong class="source-inline"><st c="4066">FlaskForm</st></strong><st c="4075"> class that sub-classes form models with attributes mapped to the appropriate field classes. </st><st c="4168">Each field class (e.g., </st><strong class="source-inline"><st c="4192">StringField</st></strong><st c="4203">, </st><strong class="source-inline"><st c="4205">BooleanField</st></strong><st c="4217">, </st><strong class="source-inline"><st c="4219">DateField</st></strong><st c="4228">, or </st><strong class="source-inline"><st c="4233">TimeField</st></strong><st c="4242">) has properties and built-in validators (e.g., </st><strong class="source-inline"><st c="4291">Length()</st></strong><st c="4299">, </st><strong class="source-inline"><st c="4301">Email()</st></strong><st c="4308">, or </st><strong class="source-inline"><st c="4313">DataRequired()</st></strong><st c="4327">) with support on custom validators </st><a id="_idIndexMarker776"/><st c="4364">when the validation procedure requires intricate conditions. </st><st c="4425">With the validators in place, it can more or less protect the application from exploits. </st><st c="4514">Further discussion on using Flask-WTF is included in </st><a href="B19383_04.xhtml#_idTextAnchor087"><span class="No-Break"><em class="italic"><st c="4567">Chapter 4</st></em></span></a><span class="No-Break"><st c="4576">.</st></span></p>
			<p><st c="4577">If the application is non-web or web-based and does not need form model classes, </st><strong class="bold"><st c="4659">Flask-Gladiator</st></strong><st c="4674"> is the suitable form </st><a id="_idIndexMarker777"/><st c="4696">validation tool to check incoming request data. </st><st c="4744">Flask-Gladiator is a general server-side data validation module that can impose basic validation rules on incoming request parameters, such as type checking, string length evaluation, pattern matching, input masking, and checking whether values fall within a specific range. </st><st c="5019">In </st><a href="B19383_06.xhtml#_idTextAnchor143"><span class="No-Break"><em class="italic"><st c="5022">Chapter 6</st></em></span></a><st c="5031">, we used Flask-Validator for validating symbolic equations and mathematical expressions as form inputs. </st><st c="5136">To use flask-gladiator, install the module using the following </st><span class="No-Break"><strong class="source-inline"><st c="5199">pip</st></strong></span><span class="No-Break"><st c="5202"> command:</st></span></p>
			<pre class="console"><st c="5211">
pip install flask-gladiator</st></pre>			<p><st c="5239">After the installation, the module does not need further setup. </st><st c="5304">It can be used readily when building the validation rules, such as in the following validation rules that scrutinize the incoming </st><span class="No-Break"><st c="5434">administratorâ€™s profile:</st></span></p>
			<pre class="source-code">
<strong class="bold"><st c="5458">import gladiator as glv</st></strong>
<strong class="bold"><st c="5482">from gladiator.core import ValidationResult</st></strong><st c="5526">
def validate_form(form_data):
    field_validations = (
        ('adminid', </st><strong class="bold"><st c="5591">glv.required</st></strong><st c="5603">, </st><strong class="bold"><st c="5605">glv.length_max(12)</st></strong><st c="5623">),
        ('username', glv.required, </st><strong class="bold"><st c="5654">glv.type_(str)</st></strong><st c="5668">),
        ('firstname', glv.required, glv.length_max(50), </st><strong class="bold"><st c="5720">glv.regex_('[a-zA-Z][a-zA-Z ]+')</st></strong><st c="5752">),
        ('midname', glv.required, glv.length_max(50), glv.regex_('[a-zA-Z][a-zA-Z ]+')),
        ('lastname', glv.required, glv.length_max(50), glv.regex_('[a-zA-Z][a-zA-Z ]+')),
        ('email', glv.required, glv.length_max(25), </st><strong class="bold"><st c="5963">glv.format_email</st></strong><st c="5979">),
        ('mobile', glv.required, glv.length_max(15)),
        ('position', glv.required,  glv.length_max(100)),
        ('status', glv.required, </st><strong class="bold"><st c="6103">glv.in_(['true', 'false'])</st></strong><st c="6129">),
        ('gender', glv.required, glv.in_(['male', 'female'])),
    )
    </st><strong class="bold"><st c="6190">result:ValidationResult = glv.validate(field_validations, form_data)</st></strong><st c="6258">
    return </st><strong class="bold"><st c="6266">result.success</st></strong></pre>			<p><st c="6280">The most essential component of the </st><strong class="source-inline"><st c="6317">gladiator</st></strong><st c="6326"> module is the </st><strong class="source-inline"><st c="6341">validate()</st></strong><st c="6351"> method, which has two</st><a id="_idIndexMarker778"/><st c="6373"> required parameters: </st><strong class="source-inline"><st c="6395">form_data</st></strong><st c="6404"> and </st><strong class="source-inline"><st c="6409">validators</st></strong><st c="6419">. The validators are placed in a tuple of tuples, as </st><a id="_idIndexMarker779"/><st c="6472">shown in the preceding code, wherein each tuple contains the request parameter name followed by all its validators. </st><st c="6588">Our </st><strong class="source-inline"><st c="6592">ch09-web-passphrase</st></strong><st c="6611"> project uses the </st><span class="No-Break"><st c="6629">following validators:</st></span></p>
			<ul>
				<li><strong class="source-inline"><st c="6650">required()</st></strong><st c="6661">: Requires the parameter to have </st><span class="No-Break"><st c="6695">a value.</st></span></li>
				<li><strong class="source-inline"><st c="6703">length_max()</st></strong><st c="6716">: Checks whether the given string length is lower than or equal to a </st><span class="No-Break"><st c="6786">maximum value.</st></span></li>
				<li><strong class="source-inline"><st c="6800">type_()</st></strong><st c="6808">: Checks the type of the request data (e.g., a form parameter is always </st><span class="No-Break"><st c="6881">a string).</st></span></li>
				<li><strong class="source-inline"><st c="6891">regex_ ()</st></strong><st c="6901">: Matches the string to a </st><span class="No-Break"><st c="6928">regular expression.</st></span></li>
				<li><strong class="source-inline"><st c="6947">format_email()</st></strong><st c="6962">: Checks whether the request data follows the </st><span class="No-Break"><st c="7009">email regex.</st></span></li>
				<li><strong class="source-inline"><st c="7021">in_()</st></strong><st c="7027">: Checks whether the value is within the list </st><span class="No-Break"><st c="7074">of options.</st></span></li>
			</ul>
			<p><st c="7085">The list shows only a few of the many validator functions that the </st><strong class="source-inline"><st c="7153">gladiator</st></strong><st c="7162"> module can provide to establish the validation</st><a id="_idIndexMarker780"/><st c="7209"> rules. </st><st c="7217">Now, the </st><strong class="source-inline"><st c="7226">validate()</st></strong><st c="7236"> method returns a </st><strong class="source-inline"><st c="7254">ValidationResult</st></strong><st c="7270"> object, which has a boolean </st><strong class="source-inline"><st c="7299">success</st></strong><st c="7306"> variable that yields </st><strong class="source-inline"><st c="7328">True</st></strong><st c="7332"> if all the validators have no</st><a id="_idIndexMarker781"/><st c="7362"> hits. </st><st c="7369">Otherwise, it yields </st><strong class="source-inline"><st c="7390">False</st></strong><st c="7395">. The following code shows how the </st><strong class="source-inline"><st c="7430">ch09-web-passphrase</st></strong><st c="7449">â€™s </st><strong class="source-inline"><st c="7453">add_admin_profile()</st></strong><st c="7472"> method utilizes the given </st><strong class="source-inline"><st c="7499">validate_form()</st></strong> <span class="No-Break"><st c="7514">view function:</st></span></p>
			<pre class="source-code"><st c="7529">
@current_app.route('/admin/profile/add', methods=['GET', 'POST'])
async def add_admin_profile():
    if not session.get("user"):
        return redirect('/login/auth')
    â€¦ â€¦ â€¦ â€¦ â€¦ â€¦
    if request.method == 'GET':
        return render_template('admin/add_admin_profile.html', admin=admin_rec), 200
    else:
        result = validate_form(request.form)
        if result == False:
            flash(f'Validation problem.', 'error')
            return render_template('admin/add_admin_profile.html', admin=admin_rec), 200
        â€¦ â€¦ â€¦ â€¦ â€¦ â€¦
        return render_template('admin/add_admin_profile.html', admin=admin_rec), 200</st></pre>			<p><st c="8070">Now, filtering malicious text can be effective if we combine the validation and sanitation of this form data. </st><st c="8181">Sanitizing inputs </st><a id="_idIndexMarker782"/><st c="8199">means encoding special</st><a id="_idIndexMarker783"/><st c="8221"> characters that might trigger the execution of malicious scripts from </st><span class="No-Break"><st c="8292">the browser.</st></span></p>
			<h2 id="_idParaDest-257"><a id="_idTextAnchor261"/><st c="8304">Sanitizing form inputs</st></h2>
			<p><st c="8327">Aside from validation, view or API functions must also sanitize incoming request data by converting special characters and suspicious </st><a id="_idIndexMarker784"/><st c="8462">symbols to purely text so that XML- and HTML-based templates can render them without side effects. </st><st c="8561">This process is</st><a id="_idIndexMarker785"/><st c="8576"> known as </st><strong class="bold"><st c="8586">escaping</st></strong><st c="8594">. The </st><strong class="source-inline"><st c="8600">markupsafe</st></strong><st c="8610"> module has an </st><strong class="source-inline"><st c="8625">escape()</st></strong><st c="8633"> method that can normalize request data with query strings that intend to control the JavaScript codes, modify the UI experience, or tamper browser cookies when Jinja2 templates render them. </st><st c="8824">The following snippet is a portion of the </st><strong class="source-inline"><st c="8866">add_admin_profile()</st></strong><st c="8885"> view function that sanitizes the form data after </st><span class="No-Break"><strong class="source-inline"><st c="8935">gladiator</st></strong></span><span class="No-Break"> <a id="_idTextAnchor262"/><st c="8944">validation:</st></span></p>
			<pre class="source-code"><st c="8956">
@current_app.route('/admin/profile/add', methods=['GET', 'POST'])
async def add_admin_profile():
    â€¦ â€¦ â€¦ â€¦ â€¦ â€¦
    result = validate_form(request.form)
    if result == False:
        flash(f'Validation problem.', 'error')
        return render_template('admin/add_admin_profile.html', admin=admin_rec), 200
    username = request.form['username']
    â€¦ â€¦ â€¦ â€¦ â€¦ â€¦
    admin_details = {
        "adminid": escape(request.form['adminid'].strip()),
        "username": escape(request.form['username'].strip()),
        "firstname": escape(request.form['firstname'].strip()),
        â€¦ â€¦ â€¦ â€¦ â€¦ â€¦
        "gender": escape(request.form['gender'].strip())
    }
    admin = Administrator(**admin_details)
    result = await repo.insert_admin(admin)
    if result == False:
        flash(f'Error adding â€¦ profile.', 'error')
    else:
        flash(f'Successfully added a user â€¦ )
    return render_template('admin/add_admin_profile.html', admin=admin_rec), 200</st></pre>			<p><st c="9792">Removing leading and trailing whitespaces or defined suspicious characters using Pythonâ€™s </st><strong class="source-inline"><st c="9883">strip()</st></strong><st c="9890"> method with the escaping process may lower the risk of injection and XSS attacks. </st><st c="9973">However, be sure that the validation rules and sanitation techniques combined will neither ruin the performance of the view or API function nor change the actual request data. </st><st c="10149">Also, tight </st><a id="_idIndexMarker786"/><st c="10161">validation rules can affect the overall runtime performance, so choose the appropriate number and types of validators for </st><span class="No-Break"><st c="10283">every form.</st></span></p>
			<p><st c="10294">To avoid SQL injection, use </st><a id="_idIndexMarker787"/><st c="10323">an ORM such as </st><strong class="bold"><st c="10338">SQLAlchemy</st></strong><st c="10348">, </st><strong class="bold"><st c="10350">Pony</st></strong><st c="10354">, or </st><strong class="bold"><st c="10359">Peewee</st></strong><st c="10365"> that can provide a</st><a id="_idIndexMarker788"/><st c="10384"> more abstract form of SQL transactions and even escape utilities to sanitize column </st><a id="_idIndexMarker789"/><st c="10469">values before persistence. </st><st c="10496">Avoid using native and dynamic queries where the field values are concatenated to the query string because they are prone to manipulation </st><span class="No-Break"><st c="10634">and exploitation.</st></span></p>
			<p><st c="10651">Sanitation can also be applied to response data to </st><a id="_idIndexMarker790"/><st c="10703">avoid another type of attack called the </st><strong class="bold"><st c="10743">Server-Side Template Injection</st></strong><st c="10773"> (</st><strong class="bold"><st c="10775">SSTI</st></strong><st c="10779">). </st><st c="10783">Let us now discuss how to protect the application from SSTIs by managing the</st><a id="_idIndexMarker791"/> <span class="No-Break"><st c="10859">response data.</st></span></p>
			<h1 id="_idParaDest-258"><a id="_idTextAnchor263"/><st c="10874">Securing response data</st></h1>
			<p><st c="10897">Jinja2 has a built-in escaping mechanism to avoid SSTIs. </st><st c="10955">SSTIs allow attackers to inject malicious template scripts or fragments that can run in the background. </st><st c="11059">These then ruin the response or perform unwanted</st><a id="_idIndexMarker792"/><st c="11107"> executions that can ruin server-side operations. </st><st c="11157">Thus, applying the </st><strong class="source-inline"><st c="11176">safe</st></strong><st c="11180"> filter in Jinja templates to perform dynamic content augmentation is not a good practice. </st><st c="11271">The </st><strong class="source-inline"><st c="11275">safe</st></strong><st c="11279"> filter turns off the Jinja2â€™s escaping mechanism and allows for running these malicious attacks. </st><st c="11377">In connection with this, avoid </st><a id="_idIndexMarker793"/><st c="11408">using </st><strong class="bold"><st c="11414">dynamic hypertext links</st></strong><st c="11437"> using the </st><strong class="source-inline"><st c="11448">&lt;a&gt;</st></strong><st c="11451"> tag in templates (e.g., </st><strong class="source-inline"><st c="11476">&lt;a href="{{ var_link }}"&gt;Click Me&lt;/a&gt;</st></strong><st c="11513">). </st><st c="11517">Instead, utilize the </st><strong class="source-inline"><st c="11538">url_for()</st></strong><st c="11547"> utility method to call dynamic view functions because it validates and checks whether the Jinja variable in the expression is a valid view name. </st><a href="B19383_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic"><st c="11693">Chapter 1</st></em></span></a><st c="11702"> discusses how to apply </st><strong class="source-inline"><st c="11726">url_for()</st></strong> <span class="No-Break"><st c="11735">for hyperlinks.</st></span></p>
			<p><st c="11751">On the other hand, there are also issues in Flask that need handling to prevent injection attacks on the Jinja templates, such as managing how the view functions will render the context data and add security </st><span class="No-Break"><st c="11960">response headers.</st></span></p>
			<h2 id="_idParaDest-259"><a id="_idTextAnchor264"/><st c="11977">Rendering Jinja2 variables</st></h2>
			<p><st c="12004">There is no ultimate solution to avoid injection but to</st><a id="_idIndexMarker794"/><st c="12060"> apply escaping to context data before rendering them to Jinja2 templates. </st><st c="12135">Moreover, avoid using </st><strong class="source-inline"><st c="12157">render_template_string()</st></strong><st c="12181"> even if this is part of the Flask framework. </st><st c="12227">Rendering HTML page-generated content may accidentally run malicious data from inputs overlooked by</st><a id="_idIndexMarker795"/><st c="12326"> filtering and escaping. </st><st c="12351">It is always good practice to place all HTML content in a file with an</st><strong class="source-inline"><st c="12421">.html</st></strong><st c="12426"> extension, or XML content in a </st><strong class="source-inline"><st c="12458">.xml</st></strong><st c="12462"> file, to enable Jinja2â€™s default escaping feature. </st><st c="12514">Then, render them using the </st><strong class="source-inline"><st c="12542">render_template()</st></strong><st c="12559"> method with or without the escaped and validated context data. </st><st c="12623">All our projects use </st><strong class="source-inline"><st c="12644">render_template()</st></strong><st c="12661"> in rendering </st><span class="No-Break"><st c="12675">Jinja2 templates.</st></span></p>
			<p><st c="12692">Security response headers must also be part of the response object when rendering every view template. </st><st c="12796">Let us explore these security response headers and learn where to </st><span class="No-Break"><st c="12862">build them.</st></span></p>
			<h2 id="_idParaDest-260"><a id="_idTextAnchor265"/><st c="12873">Adding security response headers</st></h2>
			<p><st c="12906">HTTP security response headers are directives used by many web applications to mitigate vulnerability attacks, such as XXS and public exposure of user details. </st><st c="13067">They are headers added in the response object </st><a id="_idIndexMarker796"/><st c="13113">during the rendition</st><a id="_idIndexMarker797"/><st c="13133"> of the Jinja2 templates or JSON results. </st><st c="13175">Some of these headers include </st><span class="No-Break"><st c="13205">the following:</st></span></p>
			<ul>
				<li><strong class="bold"><st c="13219">Content-Type</st></strong><st c="13232">: This indicates the original media type of the resource rendered; by default, it is HTML. </st><st c="13324">If it is HTML, it is necessary to indicate the </st><strong class="source-inline"><st c="13371">UTF-8</st></strong><st c="13376"> charset to </st><span class="No-Break"><st c="13388">avoid XSS.</st></span></li>
				<li><strong class="bold"><st c="13398">X-Content-Type-Options</st></strong><st c="13421">: This tells the browser to follow the indicated </st><strong class="source-inline"><st c="13471">content-type</st></strong><st c="13483">. It also blocks the browserâ€™s </st><strong class="source-inline"><st c="13514">media-type</st></strong><st c="13524"> sniffing, so its value should </st><span class="No-Break"><st c="13555">be </st></span><span class="No-Break"><strong class="source-inline"><st c="13558">nosniff</st></strong></span><span class="No-Break"><st c="13565">.</st></span></li>
				<li><strong class="bold"><st c="13566">X-Frame-Options</st></strong><st c="13582">: This indicates whether the browser is allowed to load the page in a </st><strong class="source-inline"><st c="13653">&lt;frame&gt;</st></strong><st c="13660">, </st><strong class="source-inline"><st c="13662">&lt;iframe&gt;</st></strong><st c="13670">, </st><strong class="source-inline"><st c="13672">&lt;embed&gt;</st></strong><st c="13679">, or </st><strong class="source-inline"><st c="13684">&lt;objects&gt;</st></strong><st c="13693">. Possible values include </st><strong class="source-inline"><st c="13719">DENY</st></strong><st c="13723"> and </st><strong class="source-inline"><st c="13728">SAMEORIGIN</st></strong><st c="13738">. The </st><strong class="source-inline"><st c="13744">DENY</st></strong><st c="13748"> option disallows rending pages on a frame, while </st><strong class="source-inline"><st c="13798">SAMEORIGIN</st></strong><st c="13808"> allows rendering a page on a frame with the same URL site as </st><span class="No-Break"><st c="13870">the page.</st></span></li>
				<li><strong class="bold"><st c="13879">Strict-Transport-Security</st></strong><st c="13905">: This indicates that the browser can only access the page through the </st><span class="No-Break"><st c="13977">HTTPS protocol.</st></span></li>
			</ul>
			<p><st c="13992">In our </st><strong class="source-inline"><st c="14000">ch09-web-passphrase</st></strong><st c="14019"> project, the global </st><strong class="source-inline"><st c="14040">@after_request</st></strong><st c="14054"> function creates a list of security response headers for every view function call. </st><st c="14138">The following code snippet in the </st><strong class="source-inline"><st c="14172">main.py</st></strong><st c="14179"> module shows this </st><span class="No-Break"><st c="14198">function implementation:</st></span></p>
			<pre class="source-code">
<strong class="bold"><st c="14222">@app.after_request</st></strong><st c="14241">
def create_sec_resp_headers(response):
    response.headers['Content-Type'] = 'text/html; charset=UTF-8'
    response.headers['X-Content-Type-Options'] = 'nosniff'
    response.headers['X-Frame-Options'] = 'SAMEORIGIN'
    response.headers['Strict-Transport-Security'] = 'Strict-Transport-Security: max-age=63072000; includeSubDomains; preload'
    return response</st></pre>			<p><st c="14586">Here,  </st><strong class="source-inline"><st c="14593">Content-Type</st></strong><st c="14605">, </st><strong class="source-inline"><st c="14607">X-Content-Type-Options</st></strong><st c="14629">, </st><strong class="source-inline"><st c="14631">X-Frame-Options</st></strong><st c="14646">, and </st><strong class="source-inline"><st c="14652">Strict-Transport-Security</st></strong><st c="14677"> are the most essential response headers for web applications. </st><st c="14740">By the way, </st><strong class="source-inline"><st c="14752">SAMEORIGIN</st></strong><st c="14762"> is the ideal value for </st><strong class="source-inline"><st c="14786">X-Frame-Options</st></strong><st c="14801"> because it prevents view pages from </st><a id="_idIndexMarker798"/><st c="14838">displaying outside the site domain of the </st><a id="_idIndexMarker799"/><st c="14880">project, mitigating </st><strong class="bold"><st c="14900">clickjacking</st></strong><st c="14912"> attacks. </st><span class="No-Break"><em class="italic"><st c="14922">Figure 9</st></em></span><em class="italic"><st c="14930">.1</st></em><st c="14932"> shows the response </st><a id="_idIndexMarker800"/><st c="14952">header tracked down by the browser after rendering the </st><strong class="source-inline"><st c="15007">/</st></strong><span class="No-Break"><strong class="source-inline"><st c="15008">admin/profile/add</st></strong></span><span class="No-Break"><st c="15025"> view.</st></span></p>
			<div>
				<div id="_idContainer100" class="IMG---Figure">
					<img src="image/B19383_09_001.jpg" alt="Figure 9.1 â€“ The response headers when running the view function"/><st c="15031"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="15768">Figure 9.1 â€“ The response headers when running the view function</st></p>
			<p><st c="15832">On the other hand, another</st><a id="_idIndexMarker801"/><st c="15859"> way to manage security response headers is </st><a id="_idIndexMarker802"/><st c="15903">through the Flask module </st><strong class="bold"><st c="15928">Flask-Talisman</st></strong><st c="15942">, or </st><strong class="bold"><st c="15947">Talisman</st></strong><st c="15955"> for</st><a id="_idIndexMarker803"/><st c="15959"> short. </st><st c="15967">To use it, install the </st><strong class="source-inline"><st c="15990">flask-talisman</st></strong><st c="16004"> module using the following </st><span class="No-Break"><strong class="source-inline"><st c="16032">pip</st></strong></span><span class="No-Break"><st c="16035"> command:</st></span></p>
			<pre class="console"><st c="16044">
pip install flask-talisman</st></pre>			<p><st c="16071">Afterward, instantiate the </st><strong class="source-inline"><st c="16099">Talisman</st></strong><st c="16107"> class in the </st><strong class="source-inline"><st c="16121">create_app()</st></strong><st c="16133"> method and integrate the module into the Flask application by adding and configuring the web applicationâ€™s security response headers using Talisman libraries, as shown in the </st><span class="No-Break"><st c="16309">following snippet:</st></span></p>
			<pre class="source-code">
<strong class="bold"><st c="16327">from flask_talisman import Talisman</st></strong><st c="16363">
def create_app(config_file):
    app = Flask(__name__,template_folder= '../modules/pages', static_folder= '../modules/resources')
    app.config.from_file(config_file, toml.load)
    â€¦ â€¦ â€¦ â€¦ â€¦ â€¦
    </st><strong class="bold"><st c="16547">talisman = Talisman(app)</st></strong><st c="16571">
    csp = {
        'default-src': [
            '\'self\'',
            'https://code.jquery.com',
            'https://cdnjs.com',
            'https://cdn.jsdelivr.net',
        ]
    }
    hsts = {
        'max-age': 31536000,
        'includeSubDomains': True
    }
    </st><strong class="bold"><st c="16747">talisman.force_https = True</st></strong><st c="16774">
    talisman.force_file_save = True
    </st><strong class="bold"><st c="16807">talisman.x_xss_protection = True</st></strong><strong class="bold"><st c="16839">talisman.session_cookie_secure = True</st></strong><st c="16877">
    talisman.frame_options_allow_from = 'https://www.google.com'
    </st><strong class="bold"><st c="16939">talisman.content_security_policy = csp</st></strong><strong class="bold"><st c="16977">talisman.strict_transport_security = hsts</st></strong></pre>			<p><st c="17019">Talisman provides an easier and Pythonic way to</st><a id="_idIndexMarker804"/><st c="17067"> set up the </st><strong class="bold"><st c="17079">Content Security Policy</st></strong><st c="17102"> (</st><strong class="bold"><st c="17104">CSP</st></strong><st c="17107">). </st><st c="17111">The CSP header </st><a id="_idIndexMarker805"/><st c="17126">restricts which web resources and sites to load on the browser through its policy directives (e.g., </st><strong class="source-inline"><st c="17226">default-src</st></strong><st c="17237">, </st><strong class="source-inline"><st c="17239">image-src</st></strong><st c="17248">, </st><strong class="source-inline"><st c="17250">style-src</st></strong><st c="17259">, </st><strong class="source-inline"><st c="17261">media-src</st></strong><st c="17270">, </st><strong class="source-inline"><st c="17272">object-src</st></strong><st c="17282"> ). </st><st c="17286">In our configuration, JS files must only come from </st><strong class="source-inline"><st c="17337">https://code.jquery.com</st></strong><st c="17360">, </st><strong class="source-inline"><st c="17362">https://cdnjs.com</st></strong><st c="17379">, </st><strong class="source-inline"><st c="17381">https://cdn.jsdelivr.net</st></strong><st c="17405">, and the localhost, while both CSS and images must be fetched from the localhost as indicated in </st><strong class="source-inline"><st c="17503">default-src</st></strong><st c="17514">, the fallback resources for each view page. </st><st c="17559">Specifying </st><strong class="source-inline"><st c="17570">script-src</st></strong><st c="17580"> with specific JS sources, </st><strong class="source-inline"><st c="17607">style-src</st></strong><st c="17616"> with CSS resources, and </st><strong class="source-inline"><st c="17641">image-src</st></strong><st c="17650"> with the targeted images will bypass the </st><span class="No-Break"><strong class="source-inline"><st c="17692">default-src</st></strong></span><span class="No-Break"><st c="17703"> setting.</st></span></p>
			<p><st c="17712">Aside from CSP, the Talisman can add </st><strong class="source-inline"><st c="17750">X-XSS-Protection</st></strong><st c="17766">, </st><strong class="source-inline"><st c="17768">Referrer-Policy</st></strong><st c="17783">, and </st><strong class="source-inline"><st c="17789">Set-Cookie</st></strong><st c="17799">, as well as the headers previously included in the response by the </st><strong class="source-inline"><st c="17867">@after_request</st></strong><st c="17881"> function. </st><st c="17892">Caution is needed in combining the two approaches because overlapping of header settings </st><span class="No-Break"><st c="17981">may happen.</st></span></p>
			<p><st c="17992">Adding the </st><strong class="source-inline"><st c="18004">Strict-Transport-Security</st></strong><st c="18029"> header in the response and setting the </st><strong class="source-inline"><st c="18069">force_https</st></strong><st c="18080"> of Talismanâ€™s property to </st><strong class="source-inline"><st c="18107">True</st></strong><st c="18111"> requires running the application in HTTPS mode. </st><st c="18160">Let us explore the latest and easiest way to enable HTTPS for a </st><span class="No-Break"><st c="18224">Flask application.</st></span></p>
			<h2 id="_idParaDest-261"><a id="_idTextAnchor266"/><st c="18242">Using HTTPS to run request/response transactions</st></h2>
			<p><st c="18291">HTTPS is a TLS-encrypted HTTP protocol. </st><st c="18332">It establishes secured communication between the transmitter and receiver of data, protecting</st><a id="_idIndexMarker806"/><st c="18425"> the cookies, URLs, and sensitive information </st><a id="_idIndexMarker807"/><st c="18471">that flows during the exchange. </st><st c="18503">It also guards the integrity of the data and the userâ€™s authenticity since it requires the userâ€™s private key to allow access. </st><st c="18630">With that, to enable the HTTPS protocol, the WSGI server must run with a public and private key certificate generated by an SSL key generator. </st><st c="18773">By convention, the certificate must be saved inside the project directory or somewhere safe in the host server. </st><st c="18885">This chapter</st><a id="_idIndexMarker808"/><st c="18897"> utilizes the </st><strong class="bold"><st c="18911">OpenSSL</st></strong><st c="18918"> tool to produce </st><span class="No-Break"><st c="18935">the certificate.</st></span></p>
			<p><st c="18951">Install the latest </st><strong class="source-inline"><st c="18971">pyopenssl</st></strong><st c="18980"> using the following </st><span class="No-Break"><strong class="source-inline"><st c="19001">pip</st></strong></span><span class="No-Break"><st c="19004"> command:</st></span></p>
			<pre class="console"><st c="19013">
pip install pyopenssl</st></pre>			<p><st c="19035">Now, to run the application, include the</st><a id="_idIndexMarker809"/><st c="19076"> private and public keys in </st><strong class="source-inline"><st c="19104">run()</st></strong><st c="19109"> through its </st><strong class="source-inline"><st c="19122">ssl_context</st></strong><st c="19133"> parameter. </st><st c="19145">The following </st><strong class="source-inline"><st c="19159">main.py</st></strong><st c="19166"> snippet shows how to run the application using HTTPS </st><a id="_idIndexMarker810"/><st c="19220">on a </st><span class="No-Break"><st c="19225">development server:</st></span></p>
			<pre class="source-code"><st c="19244">
app, celery_app, auth = create_app('../config_dev.toml')
â€¦ â€¦ â€¦ â€¦ â€¦ â€¦
if __name__ == '__main__':
    </st><strong class="bold"><st c="19341">app.run(ssl_context=('cert.pem', 'key.pem'))</st></strong></pre>			<p><st c="19385">Running the </st><strong class="source-inline"><st c="19398">python main.py</st></strong><st c="19412"> command with the </st><strong class="source-inline"><st c="19430">ssl_context</st></strong><st c="19441"> parameter will show a log on the terminal console, as shown in </st><span class="No-Break"><em class="italic"><st c="19505">Figure 9</st></em></span><span class="No-Break"><em class="italic"><st c="19513">.2</st></em></span><span class="No-Break"><st c="19515">:</st></span></p>
			<div>
				<div id="_idContainer101" class="IMG---Figure">
					<img src="image/B19383_09_002.jpg" alt="Figure 9.2 â€“ The server log when running on HTTPS"/><st c="19517"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="19742">Figure 9.2 â€“ The server log when running on HTTPS</st></p>
			<p><st c="19791">When opening the </st><strong class="source-inline"><st c="19809">https://127.0.0.1:5000/</st></strong><st c="19832"> link on a browser, a warning page will pop up on the screen, such as the one depicted in </st><span class="No-Break"><em class="italic"><st c="19922">Figure 9</st></em></span><em class="italic"><st c="19930">.3</st></em><st c="19932">, indicating that we are entering a secured page from a </st><span class="No-Break"><st c="19988">non-secured browser.</st></span></p>
			<div>
				<div id="_idContainer102" class="IMG---Figure">
					<img src="image/B19383_09_003.jpg" alt="Figure 9.3 â€“ A warning page on opening secured links"/><st c="20008"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="20319">Figure 9.3 â€“ A warning page on opening secured links</st></p>
			<p><st c="20371">Another way to run Flask applications</st><a id="_idIndexMarker811"/><st c="20409"> on an HTTP protocol is to include the key files in the command line, such as </st><strong class="source-inline"><st c="20487">python main.py --cert=cert.pem --key=key.pem</st></strong><st c="20531">. In the production environment, we run Flask applications according to the procedure followed by the </st><a id="_idIndexMarker812"/><st c="20633">secured </st><span class="No-Break"><st c="20641">production server.</st></span></p>
			<p><st c="20659">Encryption does not apply only when establishing an HTTP connection but also when securing sensitive user information such as usernames and passwords. </st><st c="20811">In the next section, we will discuss the</st><a id="_idIndexMarker813"/><st c="20851"> different ways of </st><strong class="bold"><st c="20870">hashing</st></strong><st c="20877"> and encrypting </st><span class="No-Break"><st c="20893">user credentials.</st></span></p>
			<h1 id="_idParaDest-262"><a id="_idTextAnchor267"/><st c="20910">Managing user credentials</st></h1>
			<p><st c="20936">The most common procedure for protecting any application from attacks is to control access to the userâ€™s sensitive details, such as their username and password. </st><st c="21098">Direct use of saved raw user credentials for login </st><a id="_idIndexMarker814"/><st c="21149">validation will not protect the application from attacks unless the application derives passphrases from the passwords, saves them into the database, and applies them for user </st><span class="No-Break"><st c="21325">validation instead.</st></span></p>
			<p><st c="21344">This topic will</st><a id="_idIndexMarker815"/><st c="21360"> cover password</st><a id="_idIndexMarker816"/><st c="21375"> hashing using </st><strong class="bold"><st c="21390">Hashlib</st></strong><st c="21397"> and </st><strong class="bold"><st c="21402">Bcrypt</st></strong><st c="21408">, password encryption using </st><strong class="bold"><st c="21436">symmetric cryptography</st></strong><st c="21458">, and </st><a id="_idIndexMarker817"/><st c="21464">utilizing the </st><strong class="source-inline"><st c="21478">sqlalchemy_utils</st></strong><st c="21494"> module for the seamless and automatic encryption of </st><span class="No-Break"><st c="21547">sensitive data.</st></span></p>
			<h2 id="_idParaDest-263"><a id="_idTextAnchor268"/><st c="21562">Encrypting user passwords</st></h2>
			<p><st c="21588">Generating a passphrase from the username and password of the user is the typical and easiest way to protect the </st><a id="_idIndexMarker818"/><st c="21702">application from attackers who want to crack down or hack a user account. </st><st c="21776">In Flask, there are two ways to generate a passphrase from </st><span class="No-Break"><st c="21835">user credentials:</st></span></p>
			<ul>
				<li><strong class="bold"><st c="21852">The hashing process</st></strong><st c="21872">: A one-way </st><a id="_idIndexMarker819"/><st c="21885">approach that involves generating a fixed-length passphrase of the </st><span class="No-Break"><st c="21952">original text.</st></span></li>
				<li><strong class="bold"><st c="21966">The encryption process</st></strong><st c="21989">: A two-way </st><a id="_idIndexMarker820"/><st c="22002">approach that involves generating a variable-length text using random symbols that can be traced back to its </st><span class="No-Break"><st c="22111">original text.</st></span></li>
			</ul>
			<p><st c="22125">The </st><strong class="source-inline"><st c="22130">ch09-api-bcrypt</st></strong><st c="22145"> and </st><strong class="source-inline"><st c="22150">ch09-auth-basic</st></strong><st c="22165"> projects use hashing to manage the passwords of a user. </st><st c="22222">The </st><strong class="source-inline"><st c="22226">ch09-auth-basic</st></strong><st c="22241"> project utilizes Hashlib as its primary hashing library for passphrase generation. </st><st c="22325">Flask has the </st><strong class="source-inline"><st c="22339">werkzeug.security</st></strong><st c="22356"> module that provides </st><strong class="source-inline"><st c="22378">generate_password_hash()</st></strong><st c="22402">, a function that uses Hashlibâ€™s </st><strong class="source-inline"><st c="22435">scrypt</st></strong><st c="22441"> algorithm to generate a passphrase from a text. </st><st c="22490">The projectâ€™s </st><strong class="source-inline"><st c="22504">add_signup()</st></strong><st c="22516"> API endpoint function that utilizes the </st><strong class="source-inline"><st c="22557">werkzeug.security</st></strong><st c="22574"> module in generating the passphrase from the userâ€™s password is </st><span class="No-Break"><st c="22639">as follows:</st></span></p>
			<pre class="source-code">
<strong class="bold"><st c="22650">from werkzeug.security import generate_password_hash</st></strong><st c="22703">
@current_app.post('/login/signup')
async def add_signup():
     login_json = request.get_json()
     </st><strong class="bold"><st c="22795">password = login_json["password"]</st></strong><strong class="bold"><st c="22828">passphrase = generate_password_hash(password)</st></strong><st c="22874">
     async with db_session() as sess:
         async with sess.begin():
           repo = LoginRepository(sess)
           login = Login(username=login_json["username"], </st><strong class="bold"><st c="23009">password=passphrase</st></strong><st c="23028">, role=login_json["role"])
           result = await repo.insert_login(login)
           if result == False:
             return jsonify(message="error in insert"), 201
           return jsonify(record=login_json), 200</st></pre>			<p><st c="23200">The </st><strong class="source-inline"><st c="23205">generate_password_hash()</st></strong><st c="23229"> method has </st><span class="No-Break"><st c="23241">three parameters:</st></span></p>
			<ul>
				<li><st c="23258">The actual password is</st><a id="_idIndexMarker821"/><st c="23281"> the </st><span class="No-Break"><st c="23286">first parameter.</st></span></li>
				<li><st c="23302">The hashing method is the second parameter with a default value </st><span class="No-Break"><st c="23367">of </st></span><span class="No-Break"><strong class="source-inline"><st c="23370">scrypt</st></strong></span><span class="No-Break"><st c="23376">.</st></span></li>
				<li><st c="23377">The </st><strong class="bold"><st c="23382">salt</st></strong><st c="23386"> length is the </st><span class="No-Break"><st c="23401">third parameter.</st></span></li>
			</ul>
			<p><st c="23417">The salt length will determine the number of alphanumerics that the method will use to generate a salt. </st><st c="23522">A salt is the additional alphanumerics with a fixed length that are added to the end of the password to make the passphrase more unbreachable or uncrackable. </st><st c="23680">The process of adding salt to hashing</st><a id="_idIndexMarker822"/><st c="23717"> is </st><span class="No-Break"><st c="23721">called </st></span><span class="No-Break"><strong class="bold"><st c="23728">salting</st></strong></span><span class="No-Break"><st c="23735">.</st></span></p>
			<p><st c="23736">On the other hand, the </st><strong class="source-inline"><st c="23760">werkzeug.security</st></strong><st c="23777"> module also supports </st><strong class="source-inline"><st c="23799">pbkdf2</st></strong><st c="23805"> as an option for the hashing method parameter. </st><st c="23853">However, it is less secure than the Scrypt algorithm. </st><st c="23907">Scrypt is a simple and effective hashing algorithm that requires salt to hash a password. </st><st c="23997">The </st><strong class="source-inline"><st c="24001">generate_password_hash()</st></strong><st c="24025"> method defaults the salt length to </st><strong class="source-inline"><st c="24061">16</st></strong><st c="24063">, which can be replaced anytime by passing any preferred length. </st><st c="24128">Moreover, Scrypt is memory intensive, since it needs storage to temporarily hold all the initial salted random alphanumerics</st><a id="_idIndexMarker823"/><st c="24252"> until it returns the </st><span class="No-Break"><st c="24274">final passphrase.</st></span></p>
			<p><st c="24291">Since there is no way to re-assemble the passphrase to extract the original text, the </st><strong class="source-inline"><st c="24378">werkzeug.security</st></strong><st c="24395"> module has a </st><strong class="source-inline"><st c="24409">check_password_hash()</st></strong><st c="24430"> method that returns </st><strong class="source-inline"><st c="24451">True</st></strong><st c="24455"> if the given text value matches the hashed value. </st><st c="24506">The following snippet validates the password of an authenticated user if it matches an account in the database with the same username but a </st><span class="No-Break"><st c="24646">hashed password:</st></span></p>
			<pre class="source-code">
<strong class="bold"><st c="24662">from werkzeug.security import check_password_hash</st></strong><st c="24712">
@auth.verify_password
def verify_password(username, password):
    task = get_user_task_wrapper.apply_async( args=[username])
    login:Login = task.get()
    if login == None:
        abort(403)
    </st><strong class="bold"><st c="24889">if check_password_hash(login.password, password)</st></strong><st c="24937">:
        </st><strong class="bold"><st c="24940">return login.username</st></strong><st c="24961">
    else:
        abort(403)</st></pre>			<p><st c="24978">The </st><strong class="source-inline"><st c="24983">check_password_hash()</st></strong><st c="25004"> method requires two parameters, namely the passphrase as the first and the original password as the second. </st><st c="25113">If the </st><strong class="source-inline"><st c="25120">werkzeug.security</st></strong><st c="25137"> module is not the option for your requirement due to its slowness, the </st><strong class="bold"><st c="25209">Hashlib</st></strong><st c="25216"> module, using</st><a id="_idIndexMarker824"/><st c="25230"> its </st><strong class="bold"><st c="25235">SHA-256</st></strong><st c="25242"> algorithm, is a better replacement. </st><st c="25279">However, do not forget to install the </st><strong class="source-inline"><st c="25317">hashlib</st></strong><st c="25324"> module using the following </st><strong class="source-inline"><st c="25352">pip</st></strong><st c="25355"> command before </st><span class="No-Break"><st c="25371">applying it:</st></span></p>
			<pre class="console"><st c="25383">
pip install hashlib</st></pre>			<p><st c="25403">On the other hand, </st><strong class="source-inline"><st c="25423">ch09-api-bcrypt</st></strong><st c="25438"> uses the Bcrypt algorithm to generate a passphrase for a password. </st><st c="25506">Since </st><strong class="bold"><st c="25512">Bcrypt</st></strong><st c="25518"> is an extension module, the initial step is to install it using the following </st><span class="No-Break"><strong class="source-inline"><st c="25597">pip</st></strong></span><span class="No-Break"><st c="25600"> command:</st></span></p>
			<pre class="console"><st c="25609">
pip install bcrypt</st></pre>			<p><st c="25628">Afterward, instantiate the </st><strong class="source-inline"><st c="25656">Bcrypt</st></strong><st c="25662"> class container in the </st><strong class="source-inline"><st c="25686">create_app()</st></strong><st c="25698"> factory method and integrate the</st><a id="_idIndexMarker825"/><st c="25731"> module into the Flask application through the </st><strong class="source-inline"><st c="25778">app</st></strong><st c="25781"> instance. </st><st c="25792">The following snippet shows the setup of the Bcrypt module in the </st><span class="No-Break"><st c="25858">Flask application:</st></span></p>
			<pre class="source-code">
<strong class="bold"><st c="25876">from flask_bcrypt import Bcrypt</st></strong>
<strong class="bold"><st c="25908">bcrypt = Bcrypt()</st></strong><st c="25926">
def create_app(config_file):
    app = Flask(__name__, template_folder='../modules/pages', static_folder='../modules/resources')
    app.config.from_file(config_file, toml.load)
    app.config.from_prefixed_env()
    â€¦ â€¦ â€¦ â€¦ â€¦ â€¦
    </st><strong class="bold"><st c="26140">bcrypt.init_app(app)</st></strong><st c="26160">
    â€¦ â€¦ â€¦ â€¦ â€¦ â€¦</st></pre>			<p><st c="26171">The </st><strong class="source-inline"><st c="26176">bcrypt</st></strong><st c="26182"> object will provide every module component with the utility methods to hash credential details such as passwords. </st><st c="26297">The following </st><strong class="source-inline"><st c="26311">ch09-api-bcrypt</st></strong><st c="26326">â€™s version of the </st><strong class="source-inline"><st c="26345">add_signup()</st></strong><st c="26357"> endpoint</st><a id="_idIndexMarker826"/><st c="26366"> hashes the password of an account using the imported </st><strong class="source-inline"><st c="26420">bcrypt</st></strong><st c="26426"> object before saving the userâ€™s credentials into </st><span class="No-Break"><st c="26476">the database:</st></span></p>
			<pre class="source-code">
<strong class="bold"><st c="26489">from modules import bcrypt</st></strong><st c="26516">
@current_app.post('/login/signup')
async def add_signup():
     login_json = request.get_json()
     password = login_json["password"]
     </st><strong class="bold"><st c="26642">passphrase = bcrypt.generate_password_hash(password)</st></strong><strong class="bold"><st c="26694">.decode('utf-8')</st></strong><st c="26710">
     async with db_session() as sess:
        async with sess.begin():
           repo = LoginRepository(sess)
           â€¦ â€¦ â€¦ â€¦ â€¦ â€¦
           result = await repo.insert_login(login)
           if result == False:
             return jsonify(message="error in insert"), 201
           return jsonify(record=login_json), 200</st></pre>			<p><st c="26955">Like Hashlib algorithms (e.g., </st><strong class="source-inline"><st c="26987">scrypt</st></strong><st c="26993"> or </st><strong class="source-inline"><st c="26997">pbkdf2</st></strong><st c="27003">), Bcrypt is not capable of extracting the original password from the passphrase. </st><st c="27086">However, it also has a </st><strong class="source-inline"><st c="27109">check_password_hash()</st></strong><st c="27130"> method, which validates whether a password has the correct passphrase. </st><st c="27202">However, compared to </st><a id="_idIndexMarker827"/><st c="27223">Hashlib, Bcrypt is more secure and modern because it uses the </st><strong class="bold"><st c="27285">Blowfish Cipher</st></strong><st c="27300"> algorithm. </st><st c="27312">Its only drawback is its slow </st><a id="_idIndexMarker828"/><st c="27342">hashing process, which may affect the applicationâ€™s </st><span class="No-Break"><st c="27394">overall performance.</st></span></p>
			<p><st c="27414">Aside from hashing, the encryption algorithms can also help secure the internal data of any Flask application, especially passwords. </st><st c="27548">A well-known module that can provide reliable encryption methods is the </st><strong class="source-inline"><st c="27620">cryptography</st></strong><st c="27632"> module. </st><st c="27641">So, let us first install the module using the following </st><strong class="source-inline"><st c="27697">pip</st></strong><st c="27700"> command before using its cryptographic recipes </st><span class="No-Break"><st c="27748">and utilities:</st></span></p>
			<pre class="console"><st c="27762">
pip install cryptography</st></pre>			<p><st c="27787">The </st><strong class="source-inline"><st c="27792">cryptography</st></strong><st c="27804"> module offers both symmetric and asymmetric cryptography. </st><st c="27863">The former uses one key to initiate the encryption and decryption algorithms, while the latter uses two keys: the public and private keys. </st><st c="28002">Since our application only needs one key to encrypt user credentials, it will use symmetric cryptography through the </st><strong class="source-inline"><st c="28119">Fernet</st></strong><st c="28125"> class, the utility class that implements symmetric cryptography for the module. </st><st c="28206">Now, after the installation, call </st><strong class="source-inline"><st c="28240">Fernet</st></strong><st c="28246"> in the </st><strong class="source-inline"><st c="28254">create_app()</st></strong><st c="28266"> method to generate a key through its </st><strong class="source-inline"><st c="28304">generate_key()</st></strong><st c="28318"> class </st><a id="_idIndexMarker829"/><st c="28325">method. </st><st c="28333">The following snippet in the factory method shows how the application created and kept the key for the </st><span class="No-Break"><st c="28436">entire runtime:</st></span></p>
			<pre class="source-code">
<strong class="bold"><st c="28451">from cryptography.fernet import Fernet</st></strong><st c="28490">
def create_app(config_file):
    app = Flask(__name__,  template_folder='../modules/pages', static_folder='../modules/resources')
    app.config.from_file(config_file, toml.load)
    â€¦ â€¦ â€¦ â€¦ â€¦ â€¦
    </st><strong class="bold"><st c="28673">with open("enc_key.txt", mode="w") as file:</st></strong><strong class="bold"><st c="28716">file.write(Fernet.generate_key().decode())</st></strong></pre>			<p><st c="28759">The </st><strong class="source-inline"><st c="28764">Fernet</st></strong><st c="28770"> token or secret key is a URL-safe base64-encoded alphanumeric that will instigate the encryption and </st><a id="_idIndexMarker830"/><st c="28872">decryption algorithms. </st><st c="28895">The application should store the key in a safe and inaccessible location during startup, such as saving it in a file inside a secured directory. </st><st c="29040">Missing the key will lead to </st><strong class="source-inline"><st c="29069">cryptography.fernet.InvalidToken</st></strong><st c="29101"> and </st><span class="No-Break"><strong class="source-inline"><st c="29106">cryptography.exceptions.InvalidSignature</st></strong></span><span class="No-Break"><st c="29146"> errors.</st></span></p>
			<p><st c="29154">After generating the secret key, instantiate the </st><strong class="source-inline"><st c="29204">Fernet</st></strong><st c="29210"> class with the key as the constructor argument to emit the </st><strong class="source-inline"><st c="29270">encrypt()</st></strong><st c="29279"> method. </st><st c="29288">The following </st><strong class="source-inline"><st c="29302">ch09-auth-digest</st></strong><st c="29318">â€™s version of </st><strong class="source-inline"><st c="29333">add_signup()</st></strong><st c="29345"> encrypts the user password </st><span class="No-Break"><st c="29373">using </st></span><span class="No-Break"><strong class="source-inline"><st c="29379">Fernet</st></strong></span><span class="No-Break"><st c="29385">:</st></span></p>
			<pre class="source-code">
<strong class="bold"><st c="29387">from cryptography.fernet import Fernet</st></strong><st c="29425">
@current_app.post('/login/signup')
async def add_signup():
     â€¦ â€¦ â€¦ â€¦ â€¦ â€¦
     password = login_json["password"]
     </st><strong class="bold"><st c="29531">with open("enc_key.txt", mode="r") as file:</st></strong><strong class="bold"><st c="29574">enc_key = bytes(file.read(), "utf-8")</st></strong><strong class="bold"><st c="29612">fernet = Fernet(enc_key)</st></strong><strong class="bold"><st c="29637">passphrase = fernet.encrypt(bytes(password, 'utf-8'))</st></strong><st c="29691">
     async with db_session() as sess:
         async with sess.begin():
           â€¦ â€¦ â€¦ â€¦ â€¦ â€¦
           result = await repo.insert_login(login)
           â€¦ â€¦ â€¦ â€¦ â€¦
           return jsonify(record=login_json), 200</st></pre>			<p><st c="29850">To instantiate </st><strong class="source-inline"><st c="29866">Fernet</st></strong><st c="29872">, </st><strong class="source-inline"><st c="29874">add_signup()</st></strong><st c="29886"> must extract the token from the file, convert it into bytes, and pass it as a constructor argument to the </st><strong class="source-inline"><st c="29993">Fernet</st></strong><st c="29999"> class. </st><st c="30007">The </st><strong class="source-inline"><st c="30011">Fernet</st></strong><st c="30017"> instance provides an </st><strong class="source-inline"><st c="30039">encrypt()</st></strong><st c="30048"> method that </st><a id="_idIndexMarker831"/><st c="30061">uses the </st><strong class="bold"><st c="30070">128-bit AES in CBC mode</st></strong><st c="30093"> and </st><strong class="bold"><st c="30098">HMAC with SHA-256</st></strong><st c="30115"> algorithms to encode the password in bytes. </st><st c="30160">It also has a </st><strong class="source-inline"><st c="30174">decrypt()</st></strong><st c="30183"> method to </st><a id="_idIndexMarker832"/><st c="30194">extract the original</st><a id="_idIndexMarker833"/><st c="30214"> password from the encrypted message. </st><st c="30252">The following is </st><strong class="source-inline"><st c="30269">ch09-auth-digest</st></strong><st c="30285">â€™s password validation scheme that retrieves the user credentials from the database with the encoded password and decrypts the encoded message to extract the </st><span class="No-Break"><st c="30444">actual password:</st></span></p>
			<pre class="source-code"><st c="30460">
@auth.get_password
def get_passwd(username):
    task = get_user_task_wrapper.apply_async( args=[username])
    login:Login = task.get()
    </st><strong class="bold"><st c="30590">with open("enc_key.txt", mode="r") as file:</st></strong><strong class="bold"><st c="30633">enc_key = bytes(file.read(), "utf-8")</st></strong><strong class="bold"><st c="30671">fernet = Fernet(enc_key)</st></strong><strong class="bold"><st c="30696">password = fernet.decrypt(login.password)</st></strong><strong class="bold"><st c="30738">.decode('utf-8')</st></strong><st c="30754">
    if login == None:
        return None
    else:
        return password</st></pre>			<p><st c="30806">Again, </st><strong class="source-inline"><st c="30814">get_passwd()</st></strong><st c="30826"> needs the token from the file to instantiate </st><strong class="source-inline"><st c="30872">Fernet</st></strong><st c="30878">. Using the </st><strong class="source-inline"><st c="30890">Fernet</st></strong><st c="30896"> instance, </st><strong class="source-inline"><st c="30907">get_passwd()</st></strong><st c="30919"> can emit the </st><strong class="source-inline"><st c="30933">decrypt()</st></strong><st c="30942"> method to reassemble the encrypted message and extract the actual password in the </st><strong class="source-inline"><st c="31025">UTF-8</st></strong><st c="31030"> format. </st><st c="31039">Compared to hashing, encryption involves reassembling plain text into an unreadable and uncrackable ciphertext </st><a id="_idIndexMarker834"/><st c="31150">using a token and reverting that ciphertext into its original readable form. </st><st c="31227">So, itâ€™s a two-way process, unlike </st><span class="No-Break"><st c="31262">in hashing.</st></span></p>
			<p><st c="31273">If the goal is to persist encoded data into the database without adding unnecessary cryptographic blunders that can slow down software performance, the solution is to </st><span class="No-Break"><st c="31441">use </st></span><span class="No-Break"><strong class="source-inline"><st c="31445">sqlalchemy_utils</st></strong></span><span class="No-Break"><st c="31461">.</st></span></p>
			<h2 id="_idParaDest-264"><a id="_idTextAnchor269"/><st c="31462">Using sqlalchemy_utils for encrypted columns</st></h2>
			<p><st c="31507">The </st><strong class="source-inline"><st c="31512">sqlalchemy_utils</st></strong><st c="31528"> module provides additional utility methods and column types to SQLAlchemy model classes, which include </st><strong class="source-inline"><st c="31632">StringEncryptedType</st></strong><st c="31651">. Since the module utilizes cryptographic</st><a id="_idIndexMarker835"/><st c="31692"> recipes of the cryptography </st><a id="_idIndexMarker836"/><st c="31721">module, be sure to install the latter before </st><strong class="source-inline"><st c="31766">sqlalchemy_utils</st></strong><st c="31782"> using the following </st><span class="No-Break"><strong class="source-inline"><st c="31803">pip</st></strong></span><span class="No-Break"><st c="31806"> command:</st></span></p>
			<pre class="console"><st c="31815">
pip install cryptography sqlalchemy_utils</st></pre>			<p><st c="31857">Afterward, design your model classes by applying </st><strong class="source-inline"><st c="31907">StringEncryptedType</st></strong><st c="31926"> to table columns that need </st><strong class="source-inline"><st c="31954">Fernet</st></strong><st c="31960">â€™s encryption, such as the </st><strong class="source-inline"><st c="31988">username</st></strong><st c="31996"> and </st><strong class="source-inline"><st c="32001">password</st></strong><st c="32009"> columns. </st><st c="32019">The following is the </st><strong class="source-inline"><st c="32040">Login</st></strong><st c="32045"> model class of the </st><strong class="source-inline"><st c="32065">ch09-web-passphrase</st></strong><st c="32084"> project with </st><strong class="source-inline"><st c="32098">username</st></strong><st c="32106"> and </st><strong class="source-inline"><st c="32111">password</st></strong><st c="32119"> columns </st><span class="No-Break"><st c="32128">of </st></span><span class="No-Break"><strong class="source-inline"><st c="32131">StringEncryptedType</st></strong></span><span class="No-Break"><st c="32150">:</st></span></p>
			<pre class="source-code">
<strong class="bold"><st c="32152">from sqlalchemy_utils import StringEncryptedType</st></strong>
<strong class="bold"><st c="32200">enc_key = "packt_pazzword"</st></strong><st c="32227">
class Login(Base):
   __tablename__ = 'login'
   id = Column(Integer, Sequence('login_id_seq', increment=1), primary_key = True)
   </st><strong class="bold"><st c="32351">username = Column(StringEncryptedType(String(20), enc_key), nullable=False, unique=True)</st></strong><strong class="bold"><st c="32439">password = Column(StringEncryptedType(String(50), enc_key), nullable=False)</st></strong><st c="32515">
   role = Column(Integer, nullable=False)
   â€¦ â€¦ â€¦ â€¦ â€¦ â€¦</st></pre>			<p><strong class="source-inline"><st c="32566">StringEncryptedType</st></strong><st c="32586"> automatically encrypts the column data during the </st><strong class="source-inline"><st c="32637">INSERT</st></strong><st c="32643"> transaction and decrypts the encoded field value during the </st><strong class="source-inline"><st c="32704">SELECT</st></strong><st c="32710"> statements. </st><st c="32723">To apply the utility class to the column, map it to the column field enclosing the actual SQLAlchemy column</st><a id="_idIndexMarker837"/><st c="32830"> type with the custom-generated </st><strong class="source-inline"><st c="32862">Fernet</st></strong><st c="32868"> token. </st><st c="32876">It may look like a column field wrapper that will filter and encrypt the inserted field value and decrypt it during retrieval. </st><st c="33003">No other additional coding from the </st><strong class="source-inline"><st c="33039">view</st></strong><st c="33043"> functions or repository layer is needed to perform the encryption</st><a id="_idIndexMarker838"/><st c="33109"> and decryption processes on these </st><span class="No-Break"><st c="33144">field values.</st></span></p>
			<p><st c="33157">When using </st><strong class="source-inline"><st c="33169">Flask-Migrate</st></strong><st c="33182">, add the </st><strong class="source-inline"><st c="33192">import sqlalchemy_utils</st></strong><st c="33215"> statement to the generated </st><strong class="source-inline"><st c="33243">env.py</st></strong><st c="33249"> and </st><strong class="source-inline"><st c="33254">script.py.mako</st></strong><st c="33268"> files inside the </st><strong class="source-inline"><st c="33286">migrations</st></strong><st c="33296"> folder after running the </st><strong class="source-inline"><st c="33322">db init</st></strong><st c="33329"> command and before running the </st><strong class="source-inline"><st c="33361">db migrate</st></strong><st c="33371"> and </st><strong class="source-inline"><st c="33376">db upgrade</st></strong><st c="33386"> operations. </st><st c="33399">The following are the modified </st><strong class="source-inline"><st c="33430">ch09-web-passphrase</st></strong><st c="33449"> migration files with the imported </st><span class="No-Break"><strong class="source-inline"><st c="33484">sqlalchemy_utils</st></strong></span><span class="No-Break"><st c="33500"> module:</st></span></p>
			<pre class="source-code"><st c="33508">
(env.py)
import logging
from logging.config import fileConfig
from flask import current_app
from alembic import context
</st><strong class="bold"><st c="33629">import sqlalchemy_utils</st></strong><st c="33652">
â€¦ â€¦ â€¦ â€¦ â€¦ â€¦
(script.py.mako)
"""${message}
Revision ID: ${up_revision}
Revises: ${down_revision | comma,n}
Create Date: ${create_date}
"""
from alembic import op
import sqlalchemy as sa
</st><strong class="bold"><st c="33838">import sqlalchemy_utils</st></strong><st c="33861">
${imports if imports else ""}
â€¦ â€¦ â€¦ â€¦ â€¦ â€¦</st></pre>			<p><st c="33903">The highlighted lines provided in</st><a id="_idIndexMarker839"/><st c="33937"> the given migration files are the proper places to add extra imports used in the SQLAlchemy model classes. </st><st c="34045">This includes not only the </st><strong class="source-inline"><st c="34072">sqlalchemy_util</st></strong><st c="34087"> classes but also other libraries that may help to establish the desired </st><span class="No-Break"><st c="34160">model layer.</st></span></p>
			<p><st c="34172">When customizing user authentication, the application utilizes the default Flask session to store user information, such as username. </st><st c="34307">This session saves information to the browser. </st><st c="34354">To protect the app from broken access control attacks, you can use a reliable authentication and authorization mechanism or apply server-side session handling through the </st><strong class="bold"><st c="34525">Flask-Session</st></strong><st c="34538"> module if custom session-based authentication suits </st><span class="No-Break"><st c="34591">your requirements.</st></span></p>
			<h2 id="_idParaDest-265"><a id="_idTextAnchor270"/><st c="34609">Utilizing the server-side sessions</st></h2>
			<p><st c="34644">In </st><a href="B19383_04.xhtml#_idTextAnchor087"><span class="No-Break"><em class="italic"><st c="34648">Chapter 4</st></em></span></a><st c="34657">, the </st><strong class="bold"><st c="34663">Flask-Session</st></strong><st c="34676"> module was integrated</st><a id="_idIndexMarker840"/><st c="34698"> into the Flask application to replace the browser-based session with a server-side one. </st><st c="34787">Storing important user details in the browser exposes the user details, as well as the application in general, to other user profiles without consent</st><a id="_idIndexMarker841"/><st c="34936"> and permission. </st><st c="34953">This is a perfect example of a broken access control scenario. </st><st c="35016">So, server-side session management is an acceptable solution to protect the application from exposing user information, such as </st><strong class="source-inline"><st c="35144">username</st></strong><st c="35152">, to </st><span class="No-Break"><st c="35157">the public.</st></span></p>
			<p><st c="35168">After setting up the </st><strong class="source-inline"><st c="35190">Session</st></strong><st c="35197"> class of the module through the </st><strong class="source-inline"><st c="35230">app</st></strong><st c="35233"> instance, Flaskâ€™s built-in </st><strong class="source-inline"><st c="35261">session</st></strong><st c="35268"> dictionary object can readily store session data on the server side. </st><st c="35338">The following </st><strong class="source-inline"><st c="35352">login_user()</st></strong><st c="35364"> view function stores the </st><strong class="source-inline"><st c="35390">username</st></strong><st c="35398"> of the credentia</st><a id="_idTextAnchor271"/><st c="35415">l to the server-side session after user </st><span class="No-Break"><st c="35456">credential </st></span><span class="No-Break"><a id="_idIndexMarker842"/></span><span class="No-Break"><st c="35467">confirmation:</st></span></p>
			<pre class="source-code"><st c="35480">
@current_app.route('/login/auth', methods=['GET', 'POST'])
async def login_user():
    if request.method == 'GET':
        return render_template('login/authenticate.html'), 200
    username = request.form['username'].strip()
    password = request.form['password'].strip()
    async with db_session() as sess:
        async with sess.begin():
            repo = LoginRepository(sess)
            records = await repo.select_login_username_passwd(username, password)
            login_rec = [rec.to_json() for rec in records]
            if len(login_rec) &gt;= 1:
                session["user"] = username
                return redirect('/menu')
            else:
                â€¦ â€¦ â€¦ â€¦ â€¦ â€¦
                return render_template('login/authenticate.html'), 200</st></pre>			<p><st c="36087">All session data needs to be cleared when logging out. </st><st c="36143">Removing all session data will </st><strong class="bold"><st c="36174">close</st></strong><st c="36179"> the session, protecting the application from exposing user information to others. </st><st c="36262">The following snippet shows the </st><strong class="source-inline"><st c="36294">logout()</st></strong><st c="36302"> view function of the </st><span class="No-Break"><strong class="source-inline"><st c="36324">ch09-web-paraphrase</st></strong></span><span class="No-Break"><st c="36343"> project:</st></span></p>
			<pre class="source-code"><st c="36352">
@current_app.route('/logout', methods=['GET'])
async def logout():
    </st><strong class="bold"><st c="36420">session["user"] = None</st></strong><st c="36442">
    return redirect('/login/auth')</st></pre>			<p><st c="36473">Aside from setting the</st><a id="_idIndexMarker843"/><st c="36496"> session attribute to </st><strong class="source-inline"><st c="36518">None</st></strong><st c="36522">, the </st><strong class="source-inline"><st c="36528">pop()</st></strong><st c="36533"> method of the </st><strong class="source-inline"><st c="36548">session</st></strong><st c="36555"> object can also help remove the session data. </st><st c="36602">Removing all session data is the same as invalidating the </st><span class="No-Break"><st c="36660">current session.</st></span></p>
			<p><st c="36676">Now, if custom web login implementation does not apply to your requirement, the </st><strong class="bold"><st c="36757">Flask-Login</st></strong><st c="36768"> module can offer built-in utilities for user login and logout. </st><st c="36832">Let us now discuss how to use Flask-Login for a </st><span class="No-Break"><st c="36880">Flask application.</st></span></p>
			<h1 id="_idParaDest-266"><a id="_idTextAnchor272"/><st c="36898">Implementing web form authentication</st></h1>
			<p><strong class="bold"><st c="36935">Flask-Login</st></strong><st c="36947"> is an extension </st><a id="_idIndexMarker844"/><st c="36964">module that provides utility methods to manage</st><a id="_idIndexMarker845"/><st c="37010"> user sessions, supports Bcrypt hashing, and equips helper classes to build the Flask-Login model and callback methods to secure view functions with user credentials. </st><st c="37177">To use </st><strong class="source-inline"><st c="37184">flask-login</st></strong><st c="37195">, install it first using the following </st><span class="No-Break"><strong class="source-inline"><st c="37234">pip</st></strong></span><span class="No-Break"><st c="37237"> command:</st></span></p>
			<pre class="console"><st c="37246">
pip install flask-login</st></pre>			<p><st c="37270">Also, install and set up the Flask-Session module for Flask-Login to store its user session in </st><span class="No-Break"><st c="37366">the filesystem.</st></span></p>
			<p><st c="37381">Then, to integrate Flask-login into the Flask application, instantiate its </st><strong class="source-inline"><st c="37457">LoginManager</st></strong><st c="37469"> class in the </st><strong class="source-inline"><st c="37483">create_app()</st></strong><st c="37495"> method and set it up through the </st><strong class="source-inline"><st c="37529">app</st></strong><st c="37532"> instance. </st><st c="37543">Define some of its properties such as </st><strong class="source-inline"><st c="37581">session_protection</st></strong><st c="37599">, which requires the installation of Flask-Bcrypt, and </st><strong class="source-inline"><st c="37654">login_view</st></strong><st c="37664">, which designates the </st><strong class="source-inline"><st c="37687">login view</st></strong><st c="37697"> function. </st><st c="37708">The following snippet </st><a id="_idIndexMarker846"/><st c="37730">shows the setup of Flask-Login for our </st><span class="No-Break"><strong class="source-inline"><st c="37769">ch09-web-login</st></strong></span><span class="No-Break"><st c="37783"> project:</st></span></p>
			<pre class="source-code">
<strong class="bold"><st c="37792">from flask_login import LoginManager</st></strong><st c="37829">
def create_app(config_file):
    app = Flask(__name__,template_folder= '../modules/pages', static_folder=   '../modules/resources')
    app.config.from_file(config_file, toml.load)
    app.config.from_prefixed_env()
    â€¦ â€¦ â€¦ â€¦ â€¦ â€¦
    </st><strong class="bold"><st c="38044">login_auth = LoginManager()</st></strong><strong class="bold"><st c="38071">login_auth.init_app(app)</st></strong><strong class="bold"><st c="38096">login_auth.session_protection = "strong"</st></strong><strong class="bold"><st c="38137">login_auth.login_view =</st></strong> <strong class="bold"><st c="38161">"modules.views.login.login_valid_user"</st></strong></pre>			<p><st c="38200">After the setup, add a </st><strong class="source-inline"><st c="38224">Login</st></strong><st c="38229"> model class to</st><a id="_idIndexMarker847"/><st c="38244"> the model layer through your desired ORM and sub-class it with the </st><strong class="source-inline"><st c="38312">UserMixin</st></strong><st c="38321"> helper class of the </st><strong class="source-inline"><st c="38342">flask-login</st></strong><st c="38353"> module. </st><st c="38362">The following is the </st><strong class="source-inline"><st c="38383">Login</st></strong><st c="38388"> model of our project that will persist the userâ€™s </st><strong class="source-inline"><st c="38439">id</st></strong><st c="38441">, </st><strong class="source-inline"><st c="38443">username</st></strong><st c="38451">, </st><strong class="source-inline"><st c="38453">passphrase</st></strong><st c="38463">, </st><span class="No-Break"><st c="38465">and </st></span><span class="No-Break"><strong class="source-inline"><st c="38469">role</st></strong></span><span class="No-Break"><st c="38473">:</st></span></p>
			<pre class="source-code">
<strong class="bold"><st c="38475">from flask_login import UserMixin</st></strong><st c="38508">
from sqlalchemy_utils import StringEncryptedType
enc_key = "packt_pazzword"
</st><strong class="bold"><st c="38585">class Login(UserMixin, Base):</st></strong><st c="38614">
   __tablename__ = 'login'
   id = Column(Integer, Sequence('login_id_seq', increment=1), primary_key = True)
   username = Column(StringEncryptedType(String(20), enc_key), nullable=False, unique=True)
   password = Column(StringEncryptedType(String(50), enc_key), nullable=False)
   role = Column(Integer, nullable=False)
   â€¦ â€¦ â€¦ â€¦ â€¦ â€¦</st></pre>			<p><st c="38934">Instead of utilizing the Flask-Bcrypt module, our application uses the built-in </st><strong class="source-inline"><st c="39015">StringEncryptedType</st></strong><st c="39034"> hashing mechanism from the </st><strong class="source-inline"><st c="39062">sqlalchemy_utils</st></strong><st c="39078"> module. </st><st c="39087">Now, the use of the </st><strong class="source-inline"><st c="39107">UserMixin</st></strong><st c="39116"> superclass allows the use of some properties, such as </st><strong class="source-inline"><st c="39171">is_authenticated</st></strong><st c="39187">, </st><strong class="source-inline"><st c="39189">is_active</st></strong><st c="39198">, and </st><strong class="source-inline"><st c="39204">is_anonymous</st></strong><st c="39216">, as well as some utility methods, such</st><a id="_idIndexMarker848"/><st c="39255"> as </st><strong class="source-inline"><st c="39259">get_id ()</st></strong><st c="39268">, provided by the </st><strong class="source-inline"><st c="39286">current_user</st></strong><st c="39298"> object from the </st><span class="No-Break"><strong class="source-inline"><st c="39315">flask_login</st></strong></span><span class="No-Break"><st c="39326"> module.</st></span></p>
			<p><st c="39334">Flask-Login stores the </st><strong class="source-inline"><st c="39358">id</st></strong><st c="39360"> of a user in the session after a successful login authentication. </st><st c="39427">With </st><strong class="source-inline"><st c="39432">Flask-Session</st></strong><st c="39445">, it will store the </st><strong class="source-inline"><st c="39465">id</st></strong><st c="39467"> somewhere that has been secured. </st><st c="39501">The </st><strong class="source-inline"><st c="39505">id</st></strong><st c="39507"> is vital to the </st><strong class="bold"><st c="39524">user loader callback function</st></strong><st c="39553">, which is the Flask-Login component that is responsible for retrieving the userâ€™s details</st><a id="_idIndexMarker849"/><st c="39643"> from the database. </st><st c="39663">The function automatically fetches the </st><strong class="source-inline"><st c="39702">id</st></strong><st c="39704"> from the session, retrieves the object using its </st><strong class="source-inline"><st c="39754">id</st></strong><st c="39756"> parameter and a repository class, and returns the </st><strong class="source-inline"><st c="39807">Login</st></strong><st c="39812"> object to the application. </st><st c="39840">Here is </st><strong class="source-inline"><st c="39848">ch09-web-login</st></strong><st c="39862">â€™s implementation for the </st><span class="No-Break"><st c="39889">user loader:</st></span></p>
			<pre class="source-code">
<strong class="bold"><st c="39901">@login_auth.user_loader</st></strong><st c="39925">
def load_user(</st><strong class="bold"><st c="39940">id</st></strong><st c="39943">):
    task = get_user_task_wrapper.apply_async(args=[id])
    result = task.get()
    </st><strong class="bold"><st c="40019">return result</st></strong></pre>			<p><st c="40032">In our project, the function is part of the </st><strong class="source-inline"><st c="40077">main.py</st></strong><st c="40084"> module. </st><st c="40093">Now, using the </st><strong class="source-inline"><st c="40108">get_user_task_wrapper()</st></strong><st c="40131"> Celery task, the </st><strong class="source-inline"><st c="40149">load_user()</st></strong><st c="40160"> uses the </st><strong class="source-inline"><st c="40170">select_login()</st></strong><st c="40184"> transaction of the </st><strong class="source-inline"><st c="40204">LoginRepository</st></strong><st c="40219"> to retrieve a </st><strong class="source-inline"><st c="40234">Login</st></strong><st c="40239"> record based on the given </st><strong class="source-inline"><st c="40266">id</st></strong><st c="40268"> parameter. </st><st c="40280">The application automatically calls </st><strong class="source-inline"><st c="40316">load_user()</st></strong><st c="40327"> for every request to </st><a id="_idIndexMarker850"/><st c="40349">access the views. </st><st c="40367">The continuous call to the callback function checks the validity of the user. </st><st c="40445">The returned </st><strong class="source-inline"><st c="40458">Login</st></strong><st c="40463"> object serves as a token that permits the user to access the application. </st><st c="40538">To declare a user loader callback function, create a function with one local </st><strong class="source-inline"><st c="40615">id</st></strong><st c="40617"> parameter and decorate it with the </st><strong class="source-inline"><st c="40653">userloader()</st></strong><st c="40665"> decorator of the </st><span class="No-Break"><strong class="source-inline"><st c="40683">LoginManager</st></strong></span><span class="No-Break"><st c="40695"> instance.</st></span></p>
			<p><st c="40705">The </st><strong class="source-inline"><st c="40710">login view</st></strong><st c="40720"> function caches the </st><strong class="source-inline"><st c="40741">Login</st></strong><st c="40746"> object, saves the </st><strong class="source-inline"><st c="40765">Login</st></strong><st c="40770">â€™s </st><strong class="source-inline"><st c="40774">id</st></strong><st c="40776"> to the session, and maps it to the </st><strong class="source-inline"><st c="40812">current_user</st></strong><st c="40824"> proxy object of the </st><strong class="source-inline"><st c="40845">flask_login</st></strong><st c="40856"> module. </st><st c="40865">The following snippet </st><a id="_idIndexMarker851"/><st c="40887">shows the </st><strong class="source-inline"><st c="40897">login view</st></strong><st c="40907"> function indicated in </st><span class="No-Break"><st c="40930">our setup:</st></span></p>
			<pre class="source-code">
<strong class="bold"><st c="40940">from flask_login import login_user</st></strong><st c="40975">
@current_app.route('/login/auth', methods=['GET', 'POST'])
</st><strong class="bold"><st c="41035">async def login_valid_user():</st></strong><st c="41064">
  if request.method == 'GET':
     return render_template('login/authenticate.html'), 200
  username = request.form['username'].strip()
  password = request.form['password'].strip()
  async with db_session() as sess:
      async with sess.begin():
         repo = LoginRepository(sess)
         records = await repo.select_login_username_passwd( username, password)
         if(len(records) &gt;= 1):
            </st><strong class="bold"><st c="41417">login_user(records[0])</st></strong><st c="41439">
            return render_template('login/signup.html'), 200
         else:
            â€¦ â€¦ â€¦ â€¦ â€¦ â€¦
           return render_template( 'login/authenticate.html'), 200</st></pre>			<p><st c="41562">If the </st><strong class="source-inline"><st c="41570">POST</st></strong><st c="41574">-submitted user credentials are correct based on the database validation, the </st><strong class="source-inline"><st c="41653">login view</st></strong><st c="41663"> function, namely our </st><strong class="source-inline"><st c="41685">login_valid_user()</st></strong><st c="41703">, should invoke the </st><strong class="source-inline"><st c="41723">login_user()</st></strong><st c="41735"> method of the </st><strong class="source-inline"><st c="41750">flask_login</st></strong><st c="41761"> module. </st><st c="41770">The view must pass the queried </st><strong class="source-inline"><st c="41801">Login</st></strong><st c="41806"> object containing the userâ€™s login credentials to the </st><strong class="source-inline"><st c="41861">login_user()</st></strong><st c="41873"> function. </st><st c="41884">Aside from the </st><strong class="source-inline"><st c="41899">Login</st></strong><st c="41904"> object, the method has other options, such as </st><span class="No-Break"><st c="41951">the following:</st></span></p>
			<ul>
				<li><strong class="source-inline"><st c="41965">remember</st></strong><st c="41974">: A boolean </st><a id="_idIndexMarker852"/><st c="41987">parameter that enables the </st><strong class="source-inline"><st c="42014">remember_me</st></strong><st c="42025"> feature, which allows the user session to be alive even after a browserâ€™s </st><span class="No-Break"><st c="42100">accidental exit.</st></span></li>
				<li><strong class="source-inline"><st c="42116">fresh</st></strong><st c="42122">: A boolean parameter that sets a user as </st><strong class="source-inline"><st c="42165">not fresh</st></strong><st c="42174"> if their session is valid right after the closing of </st><span class="No-Break"><st c="42228">a browser.</st></span></li>
				<li><strong class="source-inline"><st c="42238">force</st></strong><st c="42244">: A boolean parameter that forces a user to be </st><span class="No-Break"><st c="42292">logged in.</st></span></li>
				<li><strong class="source-inline"><st c="42302">duration</st></strong><st c="42311">: The amount of time before the </st><strong class="source-inline"><st c="42344">remember_me </st></strong><span class="No-Break"><st c="42356">cookie expires.</st></span></li>
			</ul>
			<p><st c="42371">After the successful authentication, users </st><a id="_idIndexMarker853"/><st c="42415">can now access the restricted views or APIs that are off-limits to non-authenticated users: those views with </st><strong class="source-inline"><st c="42524">@login_required</st></strong><st c="42539"> decorator. </st><st c="42551">The following is a samp</st><a id="_idTextAnchor273"/><st c="42574">le view function of our </st><strong class="source-inline"><st c="42599">ch09-web-login</st></strong><st c="42613"> that needs authenticated </st><span class="No-Break"><st c="42639">user access:</st></span></p>
			<pre class="source-code"><st c="42651">
from flask_login import login_required
@current_app.route('/doctor/profile/add', methods=['GET', 'POST'])
@login_required
async def add_doctor_profile():
    if request.method == 'GET':
        async with db_session() as sess:
            async with sess.begin():
                repo = LoginRepository(sess)
                records = await repo.select_all_doctor()
                doc_rec = [rec.to_json() for rec in records]
                return render_template('doctor/add_doctor_profile.html', docs=doc_rec), 200
    else:
        username = request.form['username']
        â€¦ â€¦ â€¦ â€¦ â€¦ â€¦
        return render_template('doctor/add_doctor_profile.html', doctors=doc_rec), 200</st></pre>			<p><st c="43215">Aside from the decorator, the </st><strong class="source-inline"><st c="43246">current_user</st></strong><st c="43258">â€™s </st><strong class="source-inline"><st c="43262">is_authenticated</st></strong><st c="43278"> property can also restrict the execution </st><a id="_idIndexMarker854"/><st c="43320">of some code fragments in the views and </st><span class="No-Break"><st c="43360">Jinja templates.</st></span></p>
			<p><st c="43376">Lastly, to complete the integration of </st><a id="_idIndexMarker855"/><st c="43416">Flask-Login, implement a </st><strong class="bold"><st c="43441">logout view</st></strong><st c="43452"> that calls the </st><strong class="source-inline"><st c="43468">logout_user()</st></strong><st c="43481"> utility of the </st><strong class="source-inline"><st c="43497">flask_login</st></strong><st c="43508"> module. </st><st c="43517">The following code is the logout view implementation for </st><span class="No-Break"><st c="43574">our project:</st></span></p>
			<pre class="source-code">
<strong class="bold"><st c="43586">from flask_login import logout_user</st></strong><st c="43622">
@current_app.route("/logout")
</st><strong class="bold"><st c="43653">async def logout():</st></strong><strong class="bold"><st c="43672">logout_user()</st></strong><st c="43686">
    return </st><strong class="bold"><st c="43694">redirect(url_for('login_valid_user'))</st></strong></pre>			<p><st c="43731">Be sure that the logout view redirects the user to the login view page instead of just rendering the login page to</st><a id="_idIndexMarker856"/><st c="43846"> avoid </st><strong class="bold"><st c="43853">HTTP status code 405</st></strong><st c="43873"> (</st><em class="italic"><st c="43875">Method Not Allowed</st></em><st c="43893">) </st><span class="No-Break"><st c="43896">during re-login.</st></span></p>
			<p><st c="43912">Does having a secured</st><a id="_idIndexMarker857"/><st c="43934"> web form authentication prevent CSRF attacks from happening? </st><st c="43996">Let us focus on protecting our applications from attackers who want to divert transactions to other </st><span class="No-Break"><st c="44096">suspicious sites.</st></span></p>
			<h1 id="_idParaDest-267"><a id="_idTextAnchor274"/><st c="44113">Preventing CSRF attacks</st></h1>
			<p><st c="44137">CSRF is an attack whereby authenticated users are duped into diverting sensitive data to hidden and malicious sites. </st><st c="44255">This attack happens</st><a id="_idIndexMarker858"/><st c="44274"> when users perform </st><strong class="source-inline"><st c="44294">POST</st></strong><st c="44298">, </st><strong class="source-inline"><st c="44300">DELETE</st></strong><st c="44306">, </st><strong class="source-inline"><st c="44308">PUT</st></strong><st c="44311">, or </st><strong class="source-inline"><st c="44316">PATCH</st></strong><st c="44321"> transactions, whereby form data are retrieved and submitted to the application. </st><st c="44402">In Flask, the most common solution is to use </st><strong class="source-inline"><st c="44447">Flask-WTF</st></strong><st c="44456"> because it has a built-in </st><strong class="source-inline"><st c="44483">CSRFProtect</st></strong><st c="44494"> class that globally protects every form transaction of the application. </st><st c="44567">Once enabled, </st><strong class="source-inline"><st c="44581">CSRFProtect</st></strong><st c="44592"> allows the generation of unique tokens for every form transaction. </st><st c="44660">Those form submissions that will not generate a token will cause </st><strong class="source-inline"><st c="44725">CSRFProtect</st></strong><st c="44736"> to trigger an error message, detecting a </st><span class="No-Break"><st c="44778">CSRF attack.</st></span></p>
			<p><a href="B19383_04.xhtml#_idTextAnchor087"><span class="No-Break"><em class="italic"><st c="44790">Chapter 4</st></em></span></a><st c="44800"> highlights the setup of the Flask-</st><strong class="source-inline"><st c="44835">WTF</st></strong><st c="44839"> module in a Flask application. </st><st c="44871">After its installation, import </st><strong class="source-inline"><st c="44902">CSRFProtect</st></strong><st c="44913"> and instantiate it in </st><strong class="source-inline"><st c="44936">create_app()</st></strong><st c="44948">, as shown in the following </st><span class="No-Break"><st c="44976">code snippet:</st></span></p>
			<pre class="source-code">
<strong class="bold"><st c="44989">from flask_wtf.csrf import CSRFProtect</st></strong><st c="45028">
def create_app(config_file):
    app = Flask(__name__,template_folder= '../modules/pages', static_folder= '../modules/resources')
    â€¦ â€¦ â€¦ â€¦ â€¦ â€¦
    </st><strong class="bold"><st c="45167">csrf = CSRFProtect(app)</st></strong></pre>			<p><st c="45190">However, this setup will need a </st><strong class="source-inline"><st c="45223">SECRET_KEY</st></strong><st c="45233"> or </st><strong class="source-inline"><st c="45237">WTF_CSRF_SECRET_KEY</st></strong><st c="45256"> to be defined in the configuration file. </st><st c="45298">Now, after integrating it into the application through the </st><strong class="source-inline"><st c="45357">app</st></strong><st c="45360"> instance, all </st><strong class="source-inline"><st c="45375">&lt;form&gt;</st></strong><st c="45381"> in Jinja templates must have the </st><strong class="source-inline"><st c="45415">{{ csrf_token() }}</st></strong><st c="45433"> component or a </st><strong class="source-inline"><st c="45449">&lt;input type="hidden" name="csrf_token" value = "{{ csrf_token() }}" /&gt;</st></strong><st c="45519"> component to impose </st><span class="No-Break"><st c="45540">CSRF protection.</st></span></p>
			<p><st c="45556">If there is no plan to use the entire </st><strong class="source-inline"><st c="45595">Flask-WTF</st></strong><st c="45604">, another </st><a id="_idIndexMarker859"/><st c="45614">option is to apply </st><span class="No-Break"><strong class="bold"><st c="45633">Flask-Seasurf</st></strong></span><span class="No-Break"><st c="45646"> instead.</st></span></p>
			<p><st c="45655">After showcasing the web-based authentication strategies, it is now time to discuss the different authentication types</st><a id="_idIndexMarker860"/><st c="45774"> for </st><span class="No-Break"><st c="45779">API-based applications.</st></span></p>
			<h1 id="_idParaDest-268"><a id="_idTextAnchor275"/><st c="45802">Implementing user authentication and authorization</st></h1>
			<p><st c="45853">There is a strong foundation of extension modules that can secure API services from unwanted access, such as the </st><strong class="bold"><st c="45967">Flask-HTTPAuth</st></strong><st c="45981"> module. </st><st c="45990">This</st><a id="_idIndexMarker861"/><st c="45994"> has the updated utility classes for </st><strong class="bold"><st c="46031">Basic</st></strong><st c="46036">, </st><strong class="bold"><st c="46038">Digest</st></strong><st c="46044">, and </st><strong class="bold"><st c="46050">Bearer token</st></strong><st c="46062"> authentication implementation and the Authlib module for building OAuth2 authorization servers based on various grants. </st><st c="46183">These two libraries are updated and reliable, and when combined with other safety procedures, such as password hashing and encryption, can provide baseline protection for Flask applications. </st><st c="46374">Let us start identifying the steps in employing the </st><strong class="source-inline"><st c="46426">Flask-HTTPAuth</st></strong><st c="46440"> module in </st><span class="No-Break"><st c="46451">our application.</st></span></p>
			<h2 id="_idParaDest-269"><a id="_idTextAnchor276"/><st c="46467">Utilizing the Flask-HTTPAuth module</st></h2>
			<p><st c="46503">After you have installed the </st><strong class="source-inline"><st c="46533">Flask-HTTPAuth</st></strong><st c="46547"> module and its extensions, it can provide its </st><strong class="source-inline"><st c="46594">HTTPBasicAuth</st></strong><st c="46607"> class to </st><a id="_idIndexMarker862"/><st c="46617">build Basic authentication, the </st><strong class="source-inline"><st c="46649">HTTPDigestAuth</st></strong><st c="46663"> class to implement Digest authentication, and the </st><strong class="source-inline"><st c="46714">HTTPTokenAuth</st></strong><st c="46727"> class for the Bearer token </st><span class="No-Break"><st c="46755">authentication scheme.</st></span></p>
			<h3><st c="46777">Basic authentication</st></h3>
			<p><st c="46798">Basic authentication requires </st><a id="_idIndexMarker863"/><st c="46829">an unencrypted base64 format of the userâ€™s </st><strong class="source-inline"><st c="46872">username</st></strong><st c="46880"> and </st><strong class="source-inline"><st c="46885">password</st></strong><st c="46893"> credentials through the </st><strong class="source-inline"><st c="46918">Authorization</st></strong><st c="46931"> request</st><a id="_idIndexMarker864"/><st c="46939"> header. </st><st c="46948">To implement this authentication type in Flask, instantiate the moduleâ€™s </st><strong class="source-inline"><st c="47021">HTTPBasicAuth</st></strong><st c="47034"> in </st><strong class="source-inline"><st c="47038">create_app()</st></strong><st c="47050"> and register the instance to the Flask </st><strong class="source-inline"><st c="47090">app</st></strong><st c="47093"> instance, as shown in the </st><span class="No-Break"><st c="47120">following snippet:</st></span></p>
			<pre class="source-code">
<strong class="bold"><st c="47138">from flask_httpauth import HTTPBasicAuth</st></strong><st c="47179">
def create_app(config_file):
    app = Flask(__name__,template_folder= '../modules/pages', static_folder= '../modules/resources')
    app.config.from_file(config_file, toml.load)
    â€¦ â€¦ â€¦ â€¦ â€¦ â€¦
    </st><strong class="bold"><st c="47363">global auth</st></strong><strong class="bold"><st c="47374">auth = HTTPBasicAuth()</st></strong></pre>			<p><st c="47397">Also, the </st><strong class="source-inline"><st c="47408">HTTPBasicAuth</st></strong><st c="47421"> implementation needs a callback function that will retrieve the username and password from the client, query </st><a id="_idIndexMarker865"/><st c="47531">the database to check the userâ€™s records, and return the valid username to the application if it </st><a id="_idIndexMarker866"/><st c="47628">exists, like in the </st><span class="No-Break"><st c="47648">following code:</st></span></p>
			<pre class="source-code"><st c="47663">
app, celery_app, </st><strong class="bold"><st c="47681">auth</st></strong><st c="47685"> = </st><strong class="bold"><st c="47688">create_app('../config_dev.toml')</st></strong><st c="47720">
â€¦ â€¦ â€¦ â€¦ â€¦ â€¦
</st><strong class="bold"><st c="47732">@auth.verify_password</st></strong><st c="47753">
def verify_password(</st><strong class="bold"><st c="47774">username, password</st></strong><st c="47793">):
    </st><strong class="bold"><st c="47797">task = get_user_task_wrapper.apply_async( args=[username])</st></strong><strong class="bold"><st c="47855">login:Login = task.get()</st></strong><st c="47880">
    if login == None:
        </st><strong class="bold"><st c="47899">abort(403)</st></strong><strong class="bold"><st c="47909">if check_password_hash(login.password,password) == True:</st></strong><strong class="bold"><st c="47966">return login.username</st></strong><st c="47988">
    else:
        </st><strong class="bold"><st c="47995">abort(403)</st></strong></pre>			<p><st c="48005">To be </st><strong class="source-inline"><st c="48012">HTTPBasicAuth</st></strong><st c="48025">â€™s callback function, the given </st><strong class="source-inline"><st c="48058">check_password()</st></strong><st c="48074"> must have the </st><strong class="source-inline"><st c="48089">username</st></strong><st c="48097"> and </st><strong class="source-inline"><st c="48102">password</st></strong><st c="48110"> parameters and should be annotated with </st><strong class="source-inline"><st c="48151">HTTPBasicAuth</st></strong><st c="48164">â€™s </st><strong class="source-inline"><st c="48168">verify_password()</st></strong><st c="48185"> decorator. </st><st c="48197">Our callback uses the Celery task to search and retrieve the </st><strong class="source-inline"><st c="48258">Login</st></strong><st c="48263"> object containing the </st><strong class="source-inline"><st c="48286">username</st></strong><st c="48294"> and </st><strong class="source-inline"><st c="48299">password</st></strong><st c="48307"> details and raises </st><strong class="bold"><st c="48327">HTTP status code 403</st></strong><st c="48347"> if the record does not exist. </st><st c="48378">If the authentication is successful, users will have permission to access all API methods decorated by </st><strong class="source-inline"><st c="48481">HTTPBasicAuth</st></strong><st c="48494">â€™s </st><span class="No-Break"><strong class="source-inline"><st c="48498">login_required()</st></strong></span><span class="No-Break"><st c="48514"> decorator.</st></span></p>
			<p><st c="48525">The </st><strong class="source-inline"><st c="48530">Flask-HTTPAuth</st></strong><st c="48544"> module has built-in authorization </st><a id="_idIndexMarker867"/><st c="48579">support. </st><st c="48588">If the basic authentication needs a</st><a id="_idIndexMarker868"/><st c="48623"> role-based authorization, the application only needs to have a separate callback function decorated by </st><strong class="source-inline"><st c="48727">get_user_roles()</st></strong><st c="48743"> from the </st><strong class="source-inline"><st c="48753">HTTPBasicAuth</st></strong><st c="48766"> class. </st><st c="48774">The following is </st><strong class="source-inline"><st c="48791">ch09-auth-basic</st></strong><st c="48806">â€™s callback function for retrieving user roles from </st><span class="No-Break"><st c="48859">its users:</st></span></p>
			<pre class="source-code">
<strong class="bold"><st c="48869">from werkzeug.datastructures.auth import Authorization</st></strong><st c="48924">
app, celery_app, </st><strong class="bold"><st c="48942">auth</st></strong><st c="48946"> = </st><strong class="bold"><st c="48949">create_app('../config_dev.toml')</st></strong><st c="48981">
â€¦ â€¦ â€¦ â€¦ â€¦ â€¦
</st><strong class="bold"><st c="48993">@auth.get_user_roles</st></strong><st c="49013">
def get_scope(</st><strong class="bold"><st c="49028">user:Authorization</st></strong><st c="49047">):
    task = get_user_task_wrapper.apply_async( args=[user.username])
    login:Login = task.get()
    </st><strong class="bold"><st c="49140">return str(login.role)</st></strong></pre>			<p><st c="49162">The given </st><strong class="source-inline"><st c="49173">get_scope()</st></strong><st c="49184"> automatically retrieves the </st><strong class="source-inline"><st c="49213">werkzeug.datastructures.auth.Authorization</st></strong><st c="49255"> object from the request. </st><st c="49281">The </st><strong class="source-inline"><st c="49285">Authorization</st></strong><st c="49298"> object contains the </st><strong class="source-inline"><st c="49319">username</st></strong><st c="49327"> on which the </st><strong class="source-inline"><st c="49341">get_user_task_wrapper()</st></strong><st c="49364"> Celery task will base its search for the </st><strong class="source-inline"><st c="49406">Login</st></strong><st c="49411"> record object of the user from the database. </st><st c="49457">The return value of the callback function can be a single role in string format or a list of </st><a id="_idIndexMarker869"/><st c="49550">roles attributed to the user. </st><st c="49580">The given </st><strong class="source-inline"><st c="49590">del_doctor_profile_id()</st></strong><st c="49613"> from the </st><strong class="source-inline"><st c="49623">ch09-auth-digest</st></strong><st c="49639"> project does not permit any authenticated users except for doctors whose </st><strong class="source-inline"><st c="49713">role</st></strong><st c="49717"> is equivalent to the </st><span class="No-Break"><strong class="source-inline"><st c="49739">1</st></strong></span><span class="No-Break"><st c="49740"> code:</st></span></p>
			<pre class="source-code"><st c="49746">
@current_app.delete('/doctor/profile/delete/&lt;int:id&gt;')
</st><strong class="bold"><st c="49802">@auth.login_required(role="1")</st></strong><st c="49832">
async def del_doctor_profile_id(id:int):
    async with db_session() as sess:
      async with sess.begin():
          repo = DoctorRepository(sess)
          â€¦ â€¦ â€¦ â€¦ â€¦ â€¦
          return jsonify(record="deleted record"), 200</st></pre>			<p><st c="50018">Here, </st><strong class="source-inline"><st c="50025">del_doctor_profile_id()</st></strong><st c="50048"> is an API function that deletes a doctorâ€™s profile information in the database. </st><st c="50129">No</st><a id="_idIndexMarker870"/><st c="50131"> role can perform the transaction but the doctor (</st><span class="No-Break"><strong class="source-inline"><st c="50181">role=1</st></strong></span><span class="No-Break"><st c="50188">) himself/herself.</st></span></p>
			<h3><st c="50207">Digest authentication</st></h3>
			<p><st c="50229">On the other hand, the moduleâ€™s </st><strong class="source-inline"><st c="50262">HTTPDigestAuth</st></strong><st c="50276"> builds a digest authentication scheme for the API-based applications, which</st><a id="_idIndexMarker871"/><st c="50352"> encrypts the credentials and some of its additional headers to the applications such as </st><strong class="source-inline"><st c="50441">realm</st></strong><st c="50446">, </st><strong class="source-inline"><st c="50448">nonce</st></strong><st c="50453">, </st><strong class="source-inline"><st c="50455">opaque</st></strong><st c="50461">, and </st><strong class="source-inline"><st c="50467">nonce count</st></strong><st c="50478">. Thus, it is more secure than </st><a id="_idIndexMarker872"/><st c="50509">the basic authentication scheme. </st><st c="50542">The following snippet shows how to set up digest authentication in the </st><span class="No-Break"><strong class="source-inline"><st c="50613">create_app()</st></strong></span><span class="No-Break"><st c="50625"> factory:</st></span></p>
			<pre class="source-code">
<strong class="bold"><st c="50634">from flask_httpauth import HTTPDigestAuth</st></strong><st c="50676">
def create_app(config_file):
    app = Flask(__name__,template_folder= '../modules/pages', static_folder= '../modules/resources')
    app.config.from_file(config_file, toml.load)
    â€¦ â€¦ â€¦ â€¦ â€¦ â€¦
    </st><strong class="bold"><st c="50860">global auth</st></strong><strong class="bold"><st c="50871">auth = HTTPDigestAuth()</st></strong></pre>			<p><st c="50895">The </st><strong class="source-inline"><st c="50900">HTTPDigestAuth</st></strong><st c="50914">â€™s constructors have five parameters, two of which have default values, namely </st><strong class="source-inline"><st c="50994">qop</st></strong><st c="50997"> and </st><strong class="source-inline"><st c="51002">algorithm</st></strong><st c="51011">. The </st><strong class="bold"><st c="51017">Quality of Protection</st></strong><st c="51038"> (</st><strong class="bold"><st c="51040">qop</st></strong><st c="51043">) option has the </st><strong class="source-inline"><st c="51061">auth</st></strong><st c="51065"> value, which means that the </st><a id="_idIndexMarker873"/><st c="51094">application is at the basic protection level of the digest scheme. </st><st c="51161">So far, the highest protection level is </st><strong class="source-inline"><st c="51201">auth-int</st></strong><st c="51209">, which is, at the time of writing this book, not yet functional in the </st><strong class="source-inline"><st c="51281">Flask-HTTPAuth</st></strong><st c="51295"> module. </st><st c="51304">The other parameter, </st><strong class="source-inline"><st c="51325">algorithm</st></strong><st c="51334">, has the </st><strong class="source-inline"><st c="51344">md5</st></strong><st c="51347"> default value for </st><a id="_idIndexMarker874"/><st c="51366">the encryption, but the requirement can change it to </st><strong class="source-inline"><st c="51419">md5-sess</st></strong><st c="51427"> or any supported encryption method. </st><st c="51464">Now, the three other optional </st><a id="_idIndexMarker875"/><st c="51494">parameters are </st><span class="No-Break"><st c="51509">the following:</st></span></p>
			<ul>
				<li><strong class="source-inline"><st c="51523">realm</st></strong><st c="51529">: This contains the </st><strong class="source-inline"><st c="51550">username</st></strong><st c="51558"> of the user and the name of the </st><span class="No-Break"><st c="51591">applicationâ€™s host.</st></span></li>
				<li><strong class="source-inline"><st c="51610">scheme</st></strong><st c="51617">: This is a replacement to the default value of the </st><strong class="source-inline"><st c="51670">Digest scheme</st></strong><st c="51683"> header in the </st><span class="No-Break"><strong class="source-inline"><st c="51698">WWW-Authenticate</st></strong></span><span class="No-Break"><st c="51714"> response.</st></span></li>
				<li><strong class="source-inline"><st c="51724">use_hw1_pw</st></strong><st c="51735">: If this is set to </st><strong class="source-inline"><st c="51756">True</st></strong><st c="51760">, the </st><strong class="source-inline"><st c="51766">get_password()</st></strong><st c="51780"> callback function must return a </st><span class="No-Break"><st c="51813">hashed password.</st></span></li>
			</ul>
			<p><st c="51829">In digest authentication, the user must submit their username, password, nonce, opaque, and nonce count to the application for verification. </st><span class="No-Break"><em class="italic"><st c="51971">Figure 9</st></em></span><em class="italic"><st c="51979">.4</st></em><st c="51981"> shows a postman client submitting the header information to the </st><span class="No-Break"><strong class="source-inline"><st c="52046">ch09-auth-digest</st></strong></span><span class="No-Break"><st c="52062"> app:</st></span></p>
			<div>
				<div id="_idContainer103" class="IMG---Figure">
					<img src="image/B19383_09_004.jpg" alt="Figure 9.4 â€“ The Digest authentication schemeâ€™s additional headers"/><st c="52067"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="52864">Figure 9.4 â€“ The Digest authentication schemeâ€™s additional headers</st></p>
			<p><st c="52930">A nonce is a unique base64 or hexadecimal string that the server generates for every </st><strong class="bold"><st c="53016">HTTP status code 401</st></strong><st c="53036"> response. </st><st c="53047">The content of the compressed string, usually the estimated timestamp when the client </st><a id="_idIndexMarker876"/><st c="53133">received the response, must be unique to </st><span class="No-Break"><st c="53174">every access.</st></span></p>
			<p><st c="53187">Also specified by the server is </st><strong class="bold"><st c="53220">opaque</st></strong><st c="53226">, a base64 or hexadecimal string value that the client needs to return to the </st><a id="_idIndexMarker877"/><st c="53304">server for validation if it is the same value as </st><span class="No-Break"><st c="53353">generated before.</st></span></p>
			<p><st c="53370">The nonce count value or </st><strong class="bold"><st c="53396">nc-value</st></strong><st c="53404"> is a non-repeating hexadecimal value, usually starting at </st><strong class="source-inline"><st c="53463">0000001</st></strong><st c="53470">, that checks the integrity of the user credentials and protects data from playback attacks. </st><st c="53563">The server increments its copy of the nc-value when it receives the same nonce value from a new request. </st><st c="53668">Every authentication request must bear a new nonce value. </st><st c="53726">Otherwise, it is </st><span class="No-Break"><st c="53743">a replay.</st></span></p>
			<p><strong class="source-inline"><st c="53752">Flask-HTTPAuth</st></strong><st c="53767">â€™s digest authentication scheme will only work if our API application provides the following </st><span class="No-Break"><st c="53861">callback implementations:</st></span></p>
			<pre class="source-code">
<strong class="bold"><st c="53886">server_nonce = "H9OVSzjcB57StMQFPInmX22uZ0Kwu_4JptsWrj0oPpU"</st></strong>
<strong class="bold"><st c="53947">server_opaque = "XJIXDX615CMGXXL0COHQQ0IJRG33OFTNGNFYT72VJ8XF5U3RYZ"</st></strong>
<strong class="bold"><st c="54016">@auth.generate_nonce</st></strong><st c="54037">
def gen_nonce():
    return server_nonce
</st><strong class="bold"><st c="54075">@auth.generate_opaque</st></strong><st c="54096">
def gen_opaque():
    return server_opaque</st></pre>			<p><st c="54135">The application must generate the nonce and opaque values using the likes of the </st><strong class="source-inline"><st c="54217">gen_nonce()</st></strong><st c="54228"> and </st><strong class="source-inline"><st c="54233">gen_opaque()</st></strong><st c="54245"> callbacks. </st><st c="54257">These are just trivial implementations of the methods in our </st><strong class="source-inline"><st c="54318">ch09-auth-digest</st></strong><st c="54334"> application and need better solutions that use a UUID generator</st><a id="_idIndexMarker878"/><st c="54398"> or a </st><strong class="source-inline"><st c="54404">secrets</st></strong><st c="54411"> module to generate the values. </st><st c="54443">The nonce generator callback must have a </st><strong class="source-inline"><st c="54484">generate_nonce()</st></strong><st c="54500"> decorator, while the opaque generator must be decorated by the </st><span class="No-Break"><strong class="source-inline"><st c="54564">generate_opaque()</st></strong></span><span class="No-Break"><st c="54581"> annotation.</st></span></p>
			<p><st c="54593">Aside from these generators, the authentication scheme also needs the following validators of nonce and opaque values that the server needs from the </st><span class="No-Break"><st c="54743">client request:</st></span></p>
			<pre class="source-code">
<strong class="bold"><st c="54758">@auth.verify_nonce</st></strong><st c="54777">
def verify_once(nonce):
    if nonce == server_nonce:
        return True
    else:
        return False
</st><strong class="bold"><st c="54859">@auth.verify_opaque</st></strong><st c="54878">
def verify_opaque(opaque):
    if opaque == server_opaque:
        return True
    else:
        return False</st></pre>			<p><st c="54964">The validators check whether the values from the request are correct based on the serverâ€™s corresponding values. </st><st c="55078">Now, the last </st><a id="_idIndexMarker879"/><st c="55092">requirement for the digest authentication to work is the </st><strong class="source-inline"><st c="55149">get_password()</st></strong><st c="55163"> callback that </st><a id="_idIndexMarker880"/><st c="55178">retrieves the password from the client for database validation of the userâ€™s existence, as shown in the </st><span class="No-Break"><st c="55282">following snippet:</st></span></p>
			<pre class="source-code">
<strong class="bold"><st c="55300">@auth.get_password</st></strong><st c="55319">
def get_passwd(username):
    print(username)
    task = get_user_task_wrapper.apply_async(args=[username])
    login:Login = task.get()
    â€¦ â€¦ â€¦ â€¦ â€¦ â€¦
    if login == None:
        </st><strong class="bold"><st c="55475">return None</st></strong><st c="55486">
    else:
        </st><strong class="bold"><st c="55493">return password</st></strong></pre>			<p><st c="55508">The application continuously calls the </st><strong class="source-inline"><st c="55548">get_password()</st></strong><st c="55562"> method every access to an API resource and provides the valid userâ€™s password as </st><span class="No-Break"><st c="55644">a token.</st></span></p>
			<h3><st c="55652">Bearer token authentication</st></h3>
			<p><st c="55680">Aside from Basic and Digest, the </st><strong class="source-inline"><st c="55714">Flask-HTTPAuth</st></strong><st c="55728"> module also supports the Bearer token authentication scheme by utilizing the </st><strong class="source-inline"><st c="55806">HTTPTokenAuth</st></strong><st c="55819"> class. </st><st c="55827">The following </st><strong class="source-inline"><st c="55841">create_app()</st></strong><st c="55853"> snippet</st><a id="_idIndexMarker881"/><st c="55861"> of the </st><strong class="source-inline"><st c="55869">ch09-auth-token</st></strong><st c="55884"> project sets</st><a id="_idIndexMarker882"/><st c="55897"> up the Bearer </st><span class="No-Break"><st c="55912">token authentication:</st></span></p>
			<pre class="source-code">
<strong class="bold"><st c="55933">from flask_httpauth import HTTPTokenAuth</st></strong><st c="55974">
def create_app(config_file):
    app = Flask(__name__,template_folder= '../modules/pages', static_folder=   '../modules/resources')
    app.config.from_file(config_file, toml.load)
    â€¦ â€¦ â€¦ â€¦ â€¦ â€¦
    </st><strong class="bold"><st c="56158">global auth</st></strong><strong class="bold"><st c="56169">auth = HTTPTokenAuth('Bearer')</st></strong></pre>			<p><st c="56200">This scheme requires an additional </st><strong class="source-inline"><st c="56236">token</st></strong><st c="56241"> column field of the </st><strong class="source-inline"><st c="56262">string</st></strong><st c="56268"> type in the </st><strong class="source-inline"><st c="56281">Login</st></strong><st c="56286"> model to persist the token associated with the user. </st><st c="56340">The application generates the token after the user signs up for login credentials. </st><st c="56423">Our application uses the </st><strong class="source-inline"><st c="56448">PyJWT</st></strong><st c="56453"> module for token generation, as depicted in the following </st><span class="No-Break"><st c="56512">endpoint function:</st></span></p>
			<pre class="source-code">
<strong class="bold"><st c="56530">from jwt import encode</st></strong>
<strong class="bold"><st c="56553">@current_app.post('/login/signup')</st></strong><st c="56588">
async def add_signup():
     login_json = request.get_json()
     password = login_json["password"]
     passphrase = generate_password_hash(password)
     </st><strong class="bold"><st c="56725">token = encode({'username': login_json["username"],</st></strong> <strong class="bold"><st c="56776">'exp': int(time()) + 3600},</st></strong> <strong class="bold"><st c="56804">current_app.config['SECRET_KEY'],</st></strong> <strong class="bold"><st c="56838">algorithm='HS256')</st></strong><st c="56857">
     async with db_session() as sess:
          async with sess.begin():
            repo = LoginRepository(sess)
            login = Login(username=login_json["username"], password=passphrase, </st><strong class="bold"><st c="57013">token=token</st></strong><st c="57024">,   role=login_json["role"])
            result = await repo.insert_login(login)
            â€¦ â€¦ â€¦ â€¦ â€¦ â€¦
            return jsonify(record=login_json), 200</st></pre>			<p><st c="57141">The tokenâ€™s </st><strong class="bold"><st c="57154">payload</st></strong><st c="57161"> contains the </st><strong class="source-inline"><st c="57175">username</st></strong><st c="57183"> and the tokenâ€™s supposed expiration time in seconds. </st><st c="57237">The encoding indicated in the given </st><strong class="source-inline"><st c="57273">add_signup()</st></strong><st c="57285">  API method is the </st><strong class="bold"><st c="57304">HS256</st></strong><st c="57309"> symmetric algorithm, and the secret key is the applicationâ€™s </st><strong class="source-inline"><st c="57371">SECRET_KEY</st></strong><st c="57381">. The token is always part of the</st><a id="_idIndexMarker883"/><st c="57414"> requestâ€™s </st><strong class="source-inline"><st c="57425">Authorization</st></strong><st c="57438"> header with the </st><strong class="source-inline"><st c="57455">Bearer</st></strong><st c="57461"> value. </st><st c="57469">Now, a callback function retrieves the bearer token from the request and checks whether it is the saved token of the user. </st><st c="57592">The </st><a id="_idIndexMarker884"/><st c="57596">following is </st><strong class="source-inline"><st c="57609">ch09-auth-token</st></strong><st c="57624">â€™s callback </st><span class="No-Break"><st c="57637">function implementation:</st></span></p>
			<pre class="source-code">
<strong class="bold"><st c="57661">from jwt import decode</st></strong>
<strong class="bold"><st c="57684">@auth.verify_token</st></strong><st c="57703">
def verify_token(token):
    try:
        </st><strong class="bold"><st c="57734">data = decode(token, app.config['SECRET_KEY'],</st></strong><strong class="bold"><st c="57780">algorithms=['HS256'])</st></strong><st c="57802">
    except:
        return False
    if 'username' in data:
        return data['username']</st></pre>			<p><st c="57870">The Bearer tokenâ€™s callback function must have the </st><strong class="source-inline"><st c="57922">verify_token()</st></strong><st c="57936"> method decorator. </st><st c="57955">It has the </st><strong class="source-inline"><st c="57966">token</st></strong><st c="57971"> parameter and it returns either a boolean value or the username. </st><st c="58037">It must use the same </st><strong class="bold"><st c="58058">JSON Web Token</st></strong><st c="58072"> (</st><strong class="bold"><st c="58074">JWT</st></strong><st c="58077">) library that generated the userâ€™s token during signup. </st><st c="58135">In</st><a id="_idIndexMarker885"/><st c="58137"> our project, the </st><strong class="source-inline"><st c="58155">PyJWT</st></strong><st c="58160"> module encodes and decodes </st><span class="No-Break"><st c="58188">the token.</st></span></p>
			<p><st c="58198">Like basic, the digest and bearer token </st><a id="_idIndexMarker886"/><st c="58239">authentication schemes use the </st><strong class="source-inline"><st c="58270">login_required()</st></strong><st c="58286"> decorator to impose restrictions on API endpoints. </st><st c="58338">Also, both can implement role-based authorization </st><a id="_idIndexMarker887"/><st c="58388">with the </st><span class="No-Break"><strong class="source-inline"><st c="58397">get_user_roles()</st></strong></span><span class="No-Break"><st c="58413"> callback.</st></span></p>
			<p><st c="58423">The next Flask module, </st><strong class="source-inline"><st c="58447">Authlib</st></strong><st c="58454">, has core classes and methods for implementing OAuth2, OpenID Connect, and JWT Token-based authentication schemes. </st><st c="58570">Let us now </st><span class="No-Break"><st c="58581">showcase it.</st></span></p>
			<h2 id="_idParaDest-270"><a id="_idTextAnchor277"/><st c="58593">Utilizing the Authlib module</st></h2>
			<p><strong class="bold"><st c="58622">Authlib</st></strong><st c="58630"> is a</st><a id="_idIndexMarker888"/><st c="58635"> replacement for the </st><strong class="bold"><st c="58656">Flask-OAuthlib</st></strong><st c="58670"> module. </st><st c="58679">It provides customizable classes that make the</st><a id="_idIndexMarker889"/><st c="58725"> module flexible to solve different security requirements. </st><st c="58784">Also, it is a big module because it</st><a id="_idIndexMarker890"/><st c="58819"> supports both </st><strong class="bold"><st c="58834">OAuth 1.0</st></strong><st c="58843"> and </st><strong class="bold"><st c="58848">OAuth 2.0</st></strong><st c="58857"> specifications. </st><st c="58874">Moreover, it can provide utilities for implementing </st><strong class="bold"><st c="58926">Resource Owner Password</st></strong><st c="58949">, </st><strong class="bold"><st c="58951">Implicit</st></strong><st c="58959">, </st><strong class="bold"><st c="58961">Authorization Code</st></strong><st c="58979">, and </st><strong class="bold"><st c="58985">Client Credential</st></strong><st c="59002"> authorization server types. </st><st c="59031">To utilize the </st><strong class="source-inline"><st c="59046">authlib</st></strong><st c="59053"> module, install its module using the following </st><span class="No-Break"><strong class="source-inline"><st c="59101">pip</st></strong></span><span class="No-Break"><st c="59104"> command:</st></span></p>
			<pre class="console"><st c="59113">
pip install authlib</st></pre>			<p><st c="59133">If the application to secure is not running on an HTTPS protocol, set the </st><strong class="source-inline"><st c="59208">AUTHLIB_INSECURE_TRANSPORT</st></strong><st c="59234"> environment variable to </st><strong class="source-inline"><st c="59259">1</st></strong><st c="59260"> or </st><strong class="source-inline"><st c="59264">True</st></strong><st c="59268"> for Authlib to work because it is for a </st><span class="No-Break"><st c="59309">secured environment.</st></span></p>
			<p><st c="59329">Unlike the HTTP Basic, Digest, and Bearer Token authentication schemes, the OAuth2.0 scheme uses an authorization server that provides several endpoints for authorization procedures, as well as issuing tokens, refreshing tokens, and revoking tokens. </st><st c="59580">The authorization server is always part of an application that protects its resources from malicious access and attacks. </st><st c="59701">Our </st><strong class="source-inline"><st c="59705">ch09-oauth2-password</st></strong><st c="59725"> project implements the Vaccine and Reports applications with the OAuth2 Resource Owner Password authorization scheme using Authlib. </st><st c="59858">The following </st><strong class="source-inline"><st c="59872">create_app()</st></strong><st c="59884"> factory method shows how to set up </st><span class="No-Break"><st c="59920">this scheme:</st></span></p>
			<pre class="source-code">
<strong class="bold"><st c="59932">from authlib.integrations.flask_oauth2 import AuthorizationServer</st></strong>
<strong class="bold"><st c="59998">from authlib.integrations.flask_oauth2 import ResourceProtector</st></strong><st c="60062">
from modules.security.oauth2_config import </st><strong class="bold"><st c="60106">PasswordGrant</st></strong><st c="60119">, </st><strong class="bold"><st c="60121">query_client</st></strong><st c="60133">, </st><strong class="bold"><st c="60135">save_token</st></strong>
<strong class="bold"><st c="60145">require_oauth = ResourceProtector()</st></strong>
<strong class="bold"><st c="60181">oauth_server = AuthorizationServer()</st></strong><st c="60218">
def create_app(config_file):
    app = Flask(__name__,template_folder= '../modules/pages', static_folder=   '../modules/resources')
    â€¦ â€¦ â€¦ â€¦ â€¦ â€¦
    oauth_server.init_app(app, query_client=</st><strong class="bold"><st c="60397">query_client</st></strong><st c="60410">, save_token=</st><strong class="bold"><st c="60423">save_token</st></strong><st c="60434">)
    oauth_server.register_grant(</st><strong class="bold"><st c="60465">PasswordGrant</st></strong><st c="60479">)</st></pre>			<p><st c="60481">The </st><strong class="source-inline"><st c="60485">AuthorizationServer</st></strong><st c="60504"> class manages the authentication requests and responses of the </st><a id="_idIndexMarker891"/><st c="60568">application. </st><st c="60581">It provides different types of endpoints that are suited to the authentication grant enforced by the application. </st><st c="60695">Now, instantiating the class is the first step in building the OAuth2 authorization server for clients or other applications. </st><st c="60821">It needs </st><strong class="source-inline"><st c="60830">query_client()</st></strong><st c="60844"> and </st><strong class="source-inline"><st c="60849">save_token()</st></strong><st c="60861"> for its token generation and the grant type of the </st><span class="No-Break"><st c="60913">authorization mechanism.</st></span></p>
			<p><st c="60937">Authlib </st><a id="_idIndexMarker892"/><st c="60946">provides the </st><strong class="source-inline"><st c="60959">ResourceOwnerPasswordCredentialsGrant</st></strong><st c="60996"> class to implement the </st><strong class="bold"><st c="61020">Resource Owner Password authorization standard</st></strong><st c="61066"> (</st><strong class="bold"><st c="61068">RFC 6749</st></strong><st c="61076">). </st><st c="61080">The class needs subclassing to override at least its </st><strong class="source-inline"><st c="61133">authenticate_user()</st></strong><st c="61152"> to perform validation before performing the </st><strong class="source-inline"><st c="61197">query_client()</st></strong><st c="61211"> and </st><strong class="source-inline"><st c="61216">save_token()</st></strong><st c="61228"> methods. </st><st c="61238">The following snippet shows the </st><strong class="source-inline"><st c="61270">ResourceOwnerPasswordCredentialsGrant</st></strong><st c="61307"> subclass of our </st><span class="No-Break"><strong class="source-inline"><st c="61324">ch09-oauth2-password</st></strong></span><span class="No-Break"><st c="61344"> project:</st></span></p>
			<pre class="source-code">
<strong class="bold"><st c="61353">from authlib.oauth2.rfc6749.grants import</st></strong> <strong class="bold"><st c="61395">ResourceOwnerPasswordCredentialsGrant</st></strong><st c="61433">
class PasswordGrant(</st><strong class="bold"><st c="61454">ResourceOwnerPasswordCredentialsGrant</st></strong><st c="61492">):
    </st><strong class="bold"><st c="61496">TOKEN_ENDPOINT_AUTH_METHODS</st></strong><st c="61523"> = [
      'client_secret_basic', 'client_secret_post' ]
    def authenticate_user(self, </st><strong class="bold"><st c="61602">username</st></strong><st c="61610">, </st><strong class="bold"><st c="61612">password</st></strong><st c="61620">):
         task = get_user_task_wrapper.apply_async(args=[username])
         login:Login = task.get()
         if login is not None and check_password_hash( login.password, password) == True:
            </st><strong class="bold"><st c="61788">return login</st></strong></pre>			<p><st c="61800">The </st><strong class="source-inline"><st c="61805">PasswordGrant</st></strong><st c="61818"> custom class is in the </st><strong class="source-inline"><st c="61842">/modules/security/oauth2_config.py</st></strong><st c="61876"> module with the </st><strong class="source-inline"><st c="61893">query_client()</st></strong><st c="61907"> and </st><strong class="source-inline"><st c="61912">save_token()</st></strong><st c="61924"> authorization server methods. </st><st c="61955">The first component of </st><strong class="source-inline"><st c="61978">PasswordGrant</st></strong><st c="61991"> to configure is its </st><strong class="source-inline"><st c="62012">TOKEN_ENDPOINT_AUTH_METHODS</st></strong><st c="62039">, which, from its default </st><strong class="source-inline"><st c="62065">public</st></strong><st c="62071"> value, needs to be set to </st><strong class="source-inline"><st c="62098">client_secret_basic</st></strong><st c="62117">, </st><strong class="source-inline"><st c="62119">client_secret_post</st></strong><st c="62137">, or both. </st><st c="62148">The </st><strong class="source-inline"><st c="62152">client_secret_basic</st></strong><st c="62171"> is a client authentication that passes client</st><a id="_idIndexMarker893"/><st c="62217"> secrets through a basic authentication scheme, while </st><strong class="source-inline"><st c="62271">client_secret_post</st></strong><st c="62289"> utilizes form parameters to pass client secrets to the authorization server. </st><st c="62367">On the other hand, the overridden </st><strong class="source-inline"><st c="62401">authenticate_user()</st></strong><st c="62420"> retrieves the </st><strong class="source-inline"><st c="62435">username</st></strong><st c="62443"> and </st><strong class="source-inline"><st c="62448">password</st></strong><st c="62456"> from the token generator endpoint through basic authentication or form submission. </st><st c="62540">It also retrieves the </st><strong class="source-inline"><st c="62562">Login</st></strong><st c="62567"> record object from the database through a </st><strong class="source-inline"><st c="62610">get_user_task_wrapper()</st></strong><st c="62633"> Celery task and validates the </st><strong class="source-inline"><st c="62664">Login</st></strong><st c="62669">â€™s hashed password with the retrieved password from the client. </st><st c="62734">The method returns the </st><strong class="source-inline"><st c="62757">Login</st></strong><st c="62762"> object that will signal the execution of the </st><strong class="source-inline"><st c="62808">query_client()</st></strong><st c="62822"> method. </st><st c="62831">The following snippet shows our </st><span class="No-Break"><strong class="source-inline"><st c="62863">query_client()</st></strong></span><span class="No-Break"><st c="62877"> implementation:</st></span></p>
			<pre class="source-code"><st c="62893">
def query_client(</st><strong class="bold"><st c="62911">client_id</st></strong><st c="62921">):
    task = get_client_task_wrapper.apply_async( args=[</st><strong class="bold"><st c="62975">client_id</st></strong><st c="62985">])
    client:Client = task.get()
    return client</st></pre>			<p><st c="63029">The </st><strong class="source-inline"><st c="63034">query_client()</st></strong><st c="63048"> is a necessary method of the </st><strong class="source-inline"><st c="63078">AuthorizationServer</st></strong><st c="63097"> instance. </st><st c="63108">Its goal is to find the client who requested the authentication and return the </st><strong class="source-inline"><st c="63187">Client</st></strong><st c="63193"> object. </st><st c="63202">It retrieves </st><a id="_idIndexMarker894"/><st c="63215">the </st><strong class="source-inline"><st c="63219">client_id</st></strong><st c="63228"> from the </st><strong class="source-inline"><st c="63238">AuthorizationServer </st></strong><st c="63258">endpoint and uses it to search for the </st><strong class="source-inline"><st c="63297">Client</st></strong><st c="63303"> object from the database. </st><st c="63330">The following snippet shows how to build the </st><strong class="source-inline"><st c="63375">Client</st></strong><st c="63381"> blueprint with </st><span class="No-Break"><strong class="source-inline"><st c="63397">Authlib</st></strong></span><span class="No-Break"><st c="63404">â€™s </st></span><span class="No-Break"><strong class="source-inline"><st c="63408">OAuth2ClientMixin</st></strong></span><span class="No-Break"><st c="63425">:</st></span></p>
			<pre class="source-code">
<strong class="bold"><st c="63427">from authlib.integrations.sqla_oauth2 import OAuth2ClientMixin</st></strong><st c="63489">
class Client(Base, </st><strong class="bold"><st c="63509">OAuth2ClientMixin</st></strong><st c="63526">):
    __tablename__ = 'oauth2_client'
    id = Column(Integer, Sequence('oauth2_client_id_seq', increment=1), primary_key = True)
    user_id = Column(String(20), ForeignKey('login.username'), unique=True)
    login = relationship('Login', back_populates="client")
    â€¦ â€¦ â€¦ â€¦ â€¦ â€¦</st></pre>			<p><st c="63788">Authlibâ€™s </st><strong class="source-inline"><st c="63799">OAuth2ClientMixin</st></strong><st c="63816"> will pad all the necessary column fields to the model class, including those that are optional. </st><st c="63913">The required pre-tokenization fields, such as </st><strong class="source-inline"><st c="63959">id</st></strong><st c="63961">, </st><strong class="source-inline"><st c="63963">user_id</st></strong><st c="63970"> or </st><strong class="source-inline"><st c="63974">username</st></strong><st c="63982">, </st><strong class="source-inline"><st c="63984">client_id</st></strong><st c="63993">, </st><strong class="source-inline"><st c="63995">client_id_issued_at</st></strong><st c="64014">, and </st><strong class="source-inline"><st c="64020">client_secret</st></strong><st c="64033">, must be submitted to the database during client signup before the authentication starts. </st><st c="64124">Now, if the client is valid, the </st><strong class="source-inline"><st c="64157">save_token()</st></strong><st c="64169"> will execute to retrieve the </st><strong class="source-inline"><st c="64199">access_token</st></strong><st c="64211"> from the authorization server and save it to the database. </st><st c="64271">The following snippet is our</st><a id="_idIndexMarker895"/><st c="64299"> implementation </st><span class="No-Break"><st c="64315">for </st></span><span class="No-Break"><strong class="source-inline"><st c="64319">save_token()</st></strong></span><span class="No-Break"><st c="64331">:</st></span></p>
			<pre class="source-code">
<strong class="bold"><st c="64333">from authlib.integrations.flask_oauth2.requests import FlaskOAuth2Request</st></strong><st c="64406">
def save_token(token_data, </st><strong class="bold"><st c="64434">request:FlaskOAuth2Request</st></strong><st c="64460">):
    if request.user:
        user_id = request.user.user_id
    else:
        user_id = request.client.user_id
    token_dict = dict()
    token_dict['client_id'] = request.client.client_id
    token_dict['user_id'] = user_id
    token_dict['issued_at'] = request.client.client_id_issued_at
    token_dict['access_token_revoked_at'] = 0
    token_dict['refresh_token_revoked_at'] = 0
    token_dict['scope'] = request.client.client_metadata["scope"]
    token_dict.update(token_data)
    token_str = dumps(token_dict)
    </st><strong class="bold"><st c="64922">task = add_token_task_wrapper.apply_async(</st></strong> <strong class="bold"><st c="64964">args=[token_str])</st></strong><strong class="bold"><st c="64982">task.get()</st></strong></pre>			<p><st c="64993">The </st><strong class="source-inline"><st c="64998">token_data</st></strong><st c="65008"> contains the </st><strong class="source-inline"><st c="65022">access_token</st></strong><st c="65034">, and the request has the </st><strong class="source-inline"><st c="65060">Client</st></strong><st c="65066"> data retrieved from the </st><strong class="source-inline"><st c="65091">query_client()</st></strong><st c="65105">. The method merges all these details into one </st><strong class="source-inline"><st c="65152">token_dict</st></strong><st c="65162">, instantiates</st><a id="_idIndexMarker896"/><st c="65176"> the </st><strong class="source-inline"><st c="65181">Token</st></strong><st c="65186"> class with </st><strong class="source-inline"><st c="65198">token_dict</st></strong><st c="65208"> as parameter, and stores the object record in the database. </st><st c="65269">The following is the blueprint of the </st><span class="No-Break"><strong class="source-inline"><st c="65307">Token</st></strong></span><span class="No-Break"><st c="65312"> model:</st></span></p>
			<pre class="source-code">
<strong class="bold"><st c="65319">from authlib.integrations.sqla_oauth2 import OAuth2TokenMixin</st></strong><st c="65381">
class Token(Base, </st><strong class="bold"><st c="65400">OAuth2TokenMixin</st></strong><st c="65416">):
    __tablename__ = 'oauth2_token'
    id = Column(Integer, Sequence('oauth2_token_id_seq', increment=1), primary_key=True)
    user_id = Column(String(40), ForeignKey('login.username'), nullable=False)
    login = relationship('Login', back_populates="token")
    â€¦ â€¦ â€¦ â€¦ â€¦ â€¦</st></pre>			<p><st c="65676">The </st><strong class="source-inline"><st c="65681">OAuth2TokenMixin</st></strong><st c="65697"> pads the </st><strong class="source-inline"><st c="65707">Token</st></strong><st c="65712"> class with the attributes related to </st><strong class="source-inline"><st c="65750">access_token</st></strong><st c="65762">, such as </st><strong class="source-inline"><st c="65772">id,</st></strong> <strong class="source-inline"><st c="65775">user_id</st></strong><st c="65783">, </st><strong class="source-inline"><st c="65785">client_id</st></strong><st c="65794">, </st><strong class="source-inline"><st c="65796">token_type</st></strong><st c="65806">, </st><strong class="source-inline"><st c="65808">refresh_token</st></strong><st c="65821">, and </st><strong class="source-inline"><st c="65827">scope</st></strong><st c="65832">. By the way, </st><strong class="source-inline"><st c="65846">scope</st></strong><st c="65851"> is a mandatory field in Authlib that restricts access to the API resources based on some access level </st><span class="No-Break"><st c="65954">or role.</st></span></p>
			<p><st c="65962">To trigger the authorization </st><a id="_idIndexMarker897"/><st c="65992">server, the client must access the </st><strong class="source-inline"><st c="66027">/oauth/token</st></strong><st c="66039"> endpoint through basic authentication or form-based transactions. </st><st c="66106">The following code shows the endpoint implementation of </st><span class="No-Break"><st c="66162">our application:</st></span></p>
			<pre class="source-code"><st c="66178">
from flask import current_app, request
</st><strong class="bold"><st c="66218">from modules import oauth_server</st></strong><st c="66250">
@current_app.route('/oauth/token', </st><strong class="bold"><st c="66286">methods=['POST']</st></strong><st c="66302">)
async def issue_token():
    </st><strong class="bold"><st c="66330">return oauth_server.create_token_response(</st></strong> <strong class="bold"><st c="66372">request=request)</st></strong></pre>			<p><st c="66389">Authlibâ€™s tokenization process always happens in the </st><strong class="source-inline"><st c="66443">POST</st></strong><st c="66447"> transaction mode. </st><span class="No-Break"><st c="66466">The </st></span><span class="No-Break"><strong class="source-inline"><st c="66470">Authorization</st></strong></span><strong class="source-inline"><st c="66483">
Server</st></strong><st c="66490"> object from the </st><strong class="source-inline"><st c="66507">create_app()</st></strong><st c="66519"> provides the </st><strong class="source-inline"><st c="66533">create_token_response()</st></strong><st c="66556"> with details that the method needs to return for the user to capture the </st><strong class="source-inline"><st c="66630">access_token()</st></strong><st c="66644">. Given the </st><strong class="source-inline"><st c="66656">client_id</st></strong><st c="66665"> of </st><strong class="source-inline"><st c="66669">Xd3LH9mveF524LOscPq4MzLY</st></strong><st c="66693"> and </st><strong class="source-inline"><st c="66698">client_secret</st></strong> <strong class="source-inline"><st c="66711">t8w56Y9OBRsxdVV9vrNwdtMzQ8gY4hkKLKf4b6F6RQZlT2zI</st></strong><st c="66760"> with the </st><strong class="source-inline"><st c="66770">sjctrags</st></strong><st c="66778"> username, the following </st><strong class="source-inline"><st c="66803">curl</st></strong><st c="66807"> command shows how to run the </st><strong class="source-inline"><st c="66837">/</st></strong><span class="No-Break"><strong class="source-inline"><st c="66838">oauth/token</st></strong></span><span class="No-Break"><st c="66849"> endpoint:</st></span></p>
			<pre class="console"><st c="66859">
curl -u Xd3LH9mveF524LOscPq4MzLY:t8w56Y9OBRsxdVV9vrNwdtMzQ 8gY4hkKLKf4b6F6RQZlT2zI -XPOST http://localhost:5000/oauth/token -F grant_type=password -F username=sjctrags -F password=sjctrags -F scope=user_admin -F token_endpoint_auth_method=client_secret_basic</st></pre>			<p><st c="67118">A sample result of executing </st><a id="_idIndexMarker898"/><st c="67148">the preceding command will contain the following details aside from </st><span class="No-Break"><st c="67216">the </st></span><span class="No-Break"><strong class="source-inline"><st c="67220">access_token</st></strong></span><span class="No-Break"><st c="67232">:</st></span></p>
			<pre class="source-code"><st c="67234">
{"access_token": "fVFyaS06ECKIKFVtIfVj3ykgjhQjtc80JwCKyTMlZ2", "expires_in": 864000, "scope": "user_admin", "token_type": "Bearer"}</st></pre>			<p><st c="67366">As indicated in the result, the </st><strong class="source-inline"><st c="67399">token_type</st></strong><st c="67409"> is </st><strong class="source-inline"><st c="67413">Bearer</st></strong><st c="67419">, so we can use the </st><strong class="source-inline"><st c="67439">access_token</st></strong><st c="67451"> to access or run an API endpoint through a bearer Token authentication, like in the following </st><span class="No-Break"><strong class="source-inline"><st c="67546">curl</st></strong></span><span class="No-Break"><st c="67550"> command:</st></span></p>
			<pre class="console"><st c="67559">
curl -H "Authorization: Bearer fVFyaS06ECKIKFVtIfVj3y kgjhQjtc80JwCKyTMlZ2" http://localhost:5000/doctor/profile/add</st></pre>			<p><st c="67676">A secured API endpoint must have the  </st><strong class="source-inline"><st c="67714">require_oauth("user_admin")</st></strong><st c="67741"> method decorator, wherein </st><strong class="source-inline"><st c="67768">require_oath</st></strong><st c="67780"> is the </st><strong class="source-inline"><st c="67788">ResourceProtector</st></strong><st c="67805"> instance from the </st><strong class="source-inline"><st c="67824">create_app()</st></strong><st c="67836">. A sample secured endpoint is the following </st><strong class="source-inline"><st c="67881">add_doctor_profile()</st></strong> <span class="No-Break"><st c="67901">API function:</st></span></p>
			<pre class="source-code">
<strong class="bold"><st c="67915">from modules import require_oauth</st></strong><st c="67949">
@current_app.route('/doctor/profile/add', methods = ['GET', 'POST'])
</st><strong class="bold"><st c="68019">@require_oauth("user_admin")</st></strong><st c="68047">
async def add_doctor_profile():
    â€¦ â€¦ â€¦ â€¦ â€¦ â€¦
      async with db_session() as sess:
        async with sess.begin():
          repo = DoctorRepository(sess)
          doc = Doctor(**doctor_json)
          result = await repo.insert_doctor(doc)
          â€¦ â€¦ â€¦ â€¦ â€¦ â€¦
          return jsonify(record=doctor_json), 200</st></pre>			<p><st c="68298">Aside from the Resource Owner Password grant, Authlib has an </st><strong class="source-inline"><st c="68360">AuthorizationCodeGrant</st></strong><st c="68382"> class to</st><a id="_idIndexMarker899"/><st c="68391"> implement an </st><strong class="bold"><st c="68405">OAuth2 authorization code grant</st></strong><st c="68436">, as well as </st><strong class="source-inline"><st c="68449">JWTBearerGrant</st></strong><st c="68463"> for implementing the </st><strong class="bold"><st c="68485">OAuth2 WT Token-based</st></strong><st c="68506"> authorization scheme using its own JWT library. </st><st c="68555">Our </st><strong class="source-inline"><st c="68559">ch09-oauth-code</st></strong><st c="68574"> project will </st><a id="_idIndexMarker900"/><st c="68588">showcase the full implementation</st><a id="_idIndexMarker901"/><st c="68620"> of the OAuth2 authorization code flow, while </st><strong class="source-inline"><st c="68666">ch09-oauth2-jwt</st></strong><st c="68681"> will implement the JWT authorization scheme (</st><strong class="bold"><st c="68727">RFC 7519</st></strong><st c="68736">) using the </st><span class="No-Break"><strong class="source-inline"><st c="68749">pyjwt</st></strong></span><span class="No-Break"><st c="68754"> module.</st></span></p>
			<p><st c="68762">If Flask supports popular and ultimate authentication and authorization modules, like Authlib, it also supports unpopular but reliable extension modules that can secure web-based and API-based Flask applications. </st><st c="68976">One of </st><a id="_idIndexMarker902"/><st c="68983">these modules is </st><em class="italic"><st c="69000">Flask-Limiter</st></em><st c="69013">, which can prevent </st><strong class="bold"><st c="69033">Denial of Service</st></strong><st c="69050"> (</st><strong class="bold"><st c="69052">DoS</st></strong><st c="69055">) attacks. </st><st c="69067">Let us now apply this module to our </st><span class="No-Break"><strong class="source-inline"><st c="69103">ch09-web-passphrase</st></strong></span><span class="No-Break"><st c="69122"> project.</st></span></p>
			<h1 id="_idParaDest-271"><a id="_idTextAnchor278"/><st c="69131">Controlling the view or API access</st></h1>
			<p><st c="69166">DoS attacks happen when a user maliciously accesses a web page or API multiple times to disrupt the traffic and make the</st><a id="_idIndexMarker903"/><st c="69287"> resources inaccessible to others. </st><strong class="source-inline"><st c="69322">Flask-Limiter</st></strong><st c="69335"> can provide an immediate solution by managing the number of access of a user to an API endpoint. </st><st c="69433">First, install the </st><strong class="source-inline"><st c="69452">Flask-Limiter</st></strong><st c="69465"> module using the following </st><span class="No-Break"><strong class="source-inline"><st c="69493">pip</st></strong></span><span class="No-Break"><st c="69496"> command:</st></span></p>
			<pre class="console"><st c="69505">
pip install flask-limiter</st></pre>			<p><st c="69531">Also, install the module dependency for caching its configuration details to the </st><span class="No-Break"><st c="69613">Redis server:</st></span></p>
			<pre class="console"><st c="69626">
pip install flask-limiter[redis]</st></pre>			<p><st c="69659">Now, we can set up the moduleâ€™s </st><strong class="source-inline"><st c="69692">Limiter</st></strong><st c="69699"> class in the </st><strong class="source-inline"><st c="69713">create_app()</st></strong><st c="69725"> factory method, like in the </st><span class="No-Break"><st c="69754">following snippet:</st></span></p>
			<pre class="source-code">
<strong class="bold"><st c="69772">from flask_limiter import Limiter</st></strong><st c="69806">
from flask_limiter.util import get_remote_address
def create_app(config_file):
    app = Flask(__name__,template_folder= '../modules/pages', static_folder=   '../modules/resources')
    â€¦ â€¦ â€¦ â€¦ â€¦ â€¦
    global limiter
    limiter = </st><strong class="bold"><st c="70020">Limiter</st></strong><st c="70027">(
      app=app, key_func=get_remote_address,
      default_limits=["30 per day", "5 per hour"],
      storage_uri="memory://", )</st></pre>			<p><st c="70139">Instantiating the </st><strong class="source-inline"><st c="70158">Limiter</st></strong><st c="70165"> class requires at least the </st><strong class="source-inline"><st c="70194">app</st></strong><st c="70197"> instance, the host of the application through the </st><strong class="source-inline"><st c="70248">get_remote_address()</st></strong><st c="70268">, the </st><strong class="source-inline"><st c="70274">default_limits</st></strong><st c="70288"> (e.g., </st><strong class="source-inline"><st c="70296">10 per hour</st></strong><st c="70307">, </st><strong class="source-inline"><st c="70309">10 per 2 hours</st></strong><st c="70323">, or </st><strong class="source-inline"><st c="70328">10/hour</st></strong><st c="70335">), and the storage URI for the Redis server. </st><st c="70381">The </st><strong class="source-inline"><st c="70385">Limiter</st></strong><st c="70392"> instance will </st><a id="_idIndexMarker904"/><st c="70407">provide each protected API with the </st><strong class="source-inline"><st c="70443">limit()</st></strong><st c="70450"> decorator that specifies the number of accesses not lower than the set default limit. </st><st c="70537">The following API is restricted not to be accessed by a user more than a </st><em class="italic"><st c="70610">maximum count of 5 times </st></em><span class="No-Break"><em class="italic"><st c="70635">per minute</st></em></span><span class="No-Break"><st c="70645">:</st></span></p>
			<pre class="source-code">
<strong class="bold"><st c="70647">from modules import limiter</st></strong><st c="70674">
@current_app.route('/login/auth', methods=['GET', 'POST'])
</st><strong class="bold"><st c="70734">@limiter.limit("5 per minute")</st></strong><st c="70764">
async def login_user():
    if request.method == 'GET':
        return render_template(  'login/authenticate.html'), 200
    username = request.form['username'].strip()
    password = request.form['password'].strip()
    async with db_session() as sess:
        async with sess.begin():
            repo = LoginRepository(sess)
            â€¦ â€¦ â€¦ â€¦ â€¦ â€¦
                return render_template( 'login/authenticate.html'), 200</st></pre>			<p><st c="71115">Running </st><strong class="source-inline"><st c="71124">login_user()</st></strong><st c="71136"> more than the </st><a id="_idIndexMarker905"/><st c="71151">limit will give us the message shown in </st><span class="No-Break"><em class="italic"><st c="71191">Figure 9</st></em></span><span class="No-Break"><em class="italic"><st c="71199">.5</st></em></span><span class="No-Break"><st c="71201">.</st></span></p>
			<div>
				<div id="_idContainer104" class="IMG---Figure">
					<img src="image/B19383_09_005.jpg" alt="Figure 9.5 â€“ Accessing /login/auth more than the limit"/><st c="71202"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="71287">Figure 9.5 â€“ Accessing /login/auth more than the limit</st></p>
			<p><st c="71341">Violating the number of access rules set by Talisman will lead users to its built-in error handling mechanism: the application rendering an error page with its </st><span class="No-Break"><st c="71502">error message.</st></span></p>
			<h1 id="_idParaDest-272"><a id="_idTextAnchor279"/><st c="71516">Summary</st></h1>
			<p><st c="71524">In this chapter, we learned that compared to FastAPI and Tornado, there is quite a list of extension modules that provide solutions to secure a Flask application against various attacks. </st><st c="71712">For instance, Flask-Seasurf and Flask-WTF can help minimize CSRF attacks. </st><st c="71786">When pursuing web authentication, Flask-Login can provide a reliable authentication mechanism with added password hashing and encryption mechanisms, as we learned in </st><span class="No-Break"><st c="71952">this chapter.</st></span></p>
			<p><st c="71965">On the other hand, Flask-HTTPAuth can provide API-based applications with HTTP basic, digest, and bearer token authentication schemes. </st><st c="72101">We learned that OAuth2 Authorization server grants and OAuth2 JWT Token-based types can also protect Flask applications from other </st><span class="No-Break"><st c="72232">applicationsâ€™ access.</st></span></p>
			<p><st c="72253">The Flask-Talisman ensures security rules on response headers to filter the outgoing response of every API endpoint. </st><st c="72371">Meanwhile, the Flask-Session module saves Flask sessions in the filesystem to avoid browser-based attacks. </st><st c="72478">Escaping, stripping of whitespaces, and form validation of incoming inputs using modules like Gladiator and Flask-WTF helps prevent injection attacks by eliminating suspicious text or alphanumerics in </st><span class="No-Break"><st c="72679">the inputs.</st></span></p>
			<p><st c="72690">This chapter proved that several updated and version-compatible modules can help protect our applications from malicious and unwanted attacks. </st><st c="72834">These modules can save time and effort compared to ground-up solutions in securing </st><span class="No-Break"><st c="72917">our applications.</st></span></p>
			<p><st c="72934">The next chapter will be about testing Flask components before running and deploying them to </st><span class="No-Break"><st c="73028">production servers.</st></span></p>
		</div>
	<div id="charCountTotal" value="73047"/>

		<div id="_idContainer106" class="Content">
			<h1 id="_idParaDest-273" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor280"/><st c="0">Part 3:Testing, Deploying, and Building Enterprise-Grade Applications</st></h1>
			<p><st c="70">In this last part, you will learn some options and workarounds to test, deploy, and run our Flask 3 applications. </st><st c="185">Moreover, you will also understand the process of integrating Flask applications into GraphQL, React forms, Flutter mobile applications, and other applications built with FastAPI, Django, Tornado, and Flask using the </st><span class="No-Break"><st c="402">interoperability feature.</st></span></p>
			<p><st c="427">This part includes the </st><span class="No-Break"><st c="451">following chapters:</st></span></p>
			<ul>
				<li><a href="B19383_10.xhtml#_idTextAnchor281"><em class="italic"><st c="470">Chapter 10</st></em></a><st c="481">, </st><em class="italic"><st c="483">Creating Test Cases for Flask</st></em></li>
				<li><a href="B19383_11.xhtml#_idTextAnchor306"><em class="italic"><st c="512">Chapter 11</st></em></a><st c="523">, </st><em class="italic"><st c="525">Deploying Flask Applications</st></em></li>
				<li><a href="B19383_12.xhtml#_idTextAnchor322"><em class="italic"><st c="553">Chapter 12</st></em></a><st c="564">, </st><em class="italic"><st c="566">Integrating Flask with Other Tools and Frameworks</st></em></li>
			</ul>
		</div>
		<div>
			<div id="_idContainer107">
			</div>
		</div>
		<div>
			<div id="_idContainer108" class="Basic-Graphics-Frame">
			</div>
		</div>
	<div id="charCountTotal" value="615"/></body></html>