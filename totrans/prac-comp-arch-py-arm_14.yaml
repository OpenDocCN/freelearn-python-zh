- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Subroutines and the Stack
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 子程序和栈
- en: A subroutine is a piece of code that is called from a point within a program
    and executed, and then a return is made to the instruction after the calling point.
    All computers use subroutines, but some computers provide a programmer with more
    facilities to implement subroutines than others.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 子程序是一段从程序中的某个点调用并执行的代码，然后返回到调用点之后的指令。所有计算机都使用子程序，但有些计算机为程序员提供了比其他计算机更多的实现子程序的功能。
- en: 'In this chapter, we will look at the ARM’s subroutine handling mechanisms –
    in particular, the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨ARM的子程序处理机制——特别是以下内容：
- en: The special branch and link instruction
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特殊的分支和链接指令
- en: The stack
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 栈
- en: A subroutine call and return
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子程序调用和返回
- en: Block move instructions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 块移动指令
- en: The Branch with link instruction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带链接指令的分支
- en: First, we discuss the ARM’s *branch and link* instruction, `bl`, which provides
    a quick and easy way to call a subroutine without using a stack mechanism.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们讨论ARM的`branch and link`（分支和链接）指令，`bl`，它提供了一种快速简单的方法来调用子程序，而不使用栈机制。
- en: 'There are two basic ways of implementing subroutine calls and returns. The
    classic CISC approach is `BSR` (branch to subroutine) and `RTS` (return from subroutine).
    The typical code might be as follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 实现子程序调用和返回有两种基本方法。经典的CISC方法是`BSR`（跳转到子程序）和`RTS`（从子程序返回）。典型的代码可能如下所示：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is simplicity in action. You call a piece of code, execute it, and return
    to the instruction after the calling point. Most RISC processors reject this mechanism
    because the subroutine call and return are complex instructions that save the
    return address on the stack during a call, and then pull the return address off
    the stack during a return. This is very convenient for a programmer but requires
    several CPU clock cycles to execute, and it does not fit into the one-cycle-per-instruction
    paradigm of the RISC processor.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是简单在行动中的体现。你调用一段代码，执行它，然后返回到调用点之后的指令。大多数RISC处理器拒绝这种机制，因为子程序调用和返回是复杂的指令，在调用期间将返回地址保存在栈上，然后在返回时从栈中取出返回地址。这对程序员来说非常方便，但需要几个CPU时钟周期来执行，并且不符合RISC处理器每条指令一周期的工作模式。
- en: The great advantage of the stack-based subroutine call/return is that you can
    nest subroutines and call subroutines from other subroutines, and the stack mechanism
    automatically deals with return addresses.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 基于栈的子程序调用/返回的巨大优势在于，你可以嵌套子程序，并从其他子程序中调用子程序，而栈机制会自动处理返回地址。
- en: You will soon see that you can implement this mechanism yourself on an ARM,
    but not by using two dedicated instructions. You have to write your own code.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你很快就会看到你可以在ARM上实现这种机制，但不是通过使用两个专用指令。你必须编写自己的代码。
- en: If you want a simple subroutine call and return (the subroutine is called a
    *leaf*), all you need to do is save the return address in a register (no external
    memory or stack is required). Then, to return, you just put the return address
    in the program counter – simple and fast. However, once you are in the subroutine,
    you can’t do the same thing again and call another subroutine. Doing that would
    destroy your existing saved return address.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要一个简单的子程序调用和返回（子程序被称为*叶子*），你所需要做的只是将返回地址保存在一个寄存器中（不需要外部内存或栈）。然后，要返回，你只需将返回地址放入程序计数器——简单快捷。然而，一旦你进入子程序，你就不能再做同样的事情并调用另一个子程序。这样做会破坏你现有的已保存的返回地址。
- en: The ARM’s subroutine mechanism is called *branch with link* and has the mnemonic
    `bl target`, where `target` is the symbolic address of the subroutine. The actual
    address is program counter-relative and is a 24-bit signed word that gives you
    a branch range of 223 words from the current PC. The range is 223 words in either
    direction from the PC (i.e., branch forward and branch back).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: ARM的子程序机制称为`branch with link`，其助记符为`bl target`，其中`target`是子程序的符号地址。实际地址是程序计数器相对的，是一个24位有符号字，提供了从当前PC开始的223个字的分支范围。范围是从PC的任意方向223个字（即向前分支和向后分支）。
- en: 'The branch with link instruction behaves like a branch instruction, but it
    also copies the return address (i.e., the address of the next instruction to be
    executed following a return into the link register `r14`. Let’s say you execute
    the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 带有链接指令的分支行为类似于分支指令，但它还会复制返回地址（即返回后要执行的下一个指令的地址到链接寄存器 `r14`。假设你执行以下操作：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The ARM executes a branch to the target address specified by the label `sub_A`.
    It also copies the program counter, held in register `r15`, into the link register
    `r14` to preserve the return address. At the end of the subroutine, you return
    by transferring the return address in `r14` to the program counter. You don’t
    need a special return instruction; you just write the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: ARM 执行一个跳转到由标签 `sub_A` 指定的目标地址的分支。它还将程序计数器（保存在寄存器 `r15` 中）复制到链接寄存器 `r14` 以保留返回地址。在子程序结束时，您通过将
    `r14` 中的返回地址转移到程序计数器来返回。您不需要特殊的返回指令；您只需写下以下内容：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let’s look at a simple example of the use of a subroutine. Suppose that you
    need to evaluate the `if x > 0 then` `x = 16x + 1 else x = 32x` function several
    times in a program. Assuming that the x parameter is in register `r0`, we can
    write the following subroutine:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看子程序使用的一个简单例子。假设您需要在程序中多次评估 `if x > 0 then` `x = 16x + 1 else x = 32x` 函数。假设
    x 参数在寄存器 `r0` 中，我们可以编写以下子程序：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: All you need to create a subroutine is an entry point (the label `Func1`) and
    a return point that restores the saved address by bl in the link register.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 创建子程序所需的一切只是一个入口点（标签 `Func1`）和一个返回点，该返回点通过在链接寄存器中 bl 恢复保存的地址。
- en: The stack
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 栈
- en: We’ve already described the stack. We’ll go over it again here because it’s
    probably the single most important data structure in computing. The stack is a
    pile that you add things on at the top and take things off, also from the top.
    If you take something off the stack, it is the last thing that was added to the
    stack. Consequently, the stack is called a **last in first out queue** (**LIFO**),
    in which items enter at one end and leave in the reverse order.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经描述了栈。我们在这里再次讨论它，因为它可能是计算中最重要的数据结构。栈是一个堆，您在顶部添加东西，也从顶部取出东西。如果您从栈中取出东西，它就是最后添加到栈中的东西。因此，栈被称为
    **后进先出队列**（**LIFO**），其中项目从一端进入，以相反的顺序离开。
- en: Computers implement stacks by using a pointer register to point at the top of
    the stack. The ARM uses `r13` as a stack pointer, or, to be precise, the ARM *mandates*
    the use of `r13` as a stack pointer. You can use `r0` to `r13` as a stack pointer
    if you wish. The use of `r13` is a *convention* designed to make code more readable
    and sharable.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机通过使用指针寄存器来指向栈顶来实现栈。ARM 使用 `r13` 作为栈指针，或者更准确地说，ARM *强制* 使用 `r13` 作为栈指针。如果您愿意，可以使用
    `r0` 到 `r13` 作为栈指针。使用 `r13` 是一种 *约定*，旨在使代码更易于阅读和共享。
- en: There are four variations of the stack. They all do the same thing but are implemented
    differently. The ARM supports all four variations, but we’ll use only one here
    for the sake of simplicity. A stack is stored in memory, which has no up or down
    in the normal human sense. When items are added to the stack, they can be added
    to the next location with a lower address or the next location with a higher address.
    By convention, most stacks are implemented so that the next item is stored at
    the *lower address*. We say that the stack grows *up* toward *lower* addresses
    (that’s because we number lines in a book from top to bottom, with line one at
    the top).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 栈有四种变体。它们都做同样的事情，但实现方式不同。ARM 支持所有四种变体，但为了简单起见，我们在这里只使用一种。栈存储在内存中，在正常的人类意义上没有上下之分。当项目添加到栈中时，它们可以添加到具有较低地址的下一个位置或具有较高地址的下一个位置。按照惯例，大多数栈都是这样实现的，即下一个项目存储在
    *较低地址*。我们说栈向 *较低* 地址 *增长*（这是因为我们按从上到下的顺序给书的行编号，第一行在顶部）。
- en: The other variation in the arrangement of stacks is that the stack pointer can
    either point to the top item on the stack, TOS, or point to the next free item
    on that stack. I will cover stacks where the stack pointer points to the top item
    on the stack (again, this is the most common convention).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 栈排列的其他变体是栈指针可以指向栈顶的项目，TOS，或者指向该栈上的下一个空闲项目。我将介绍栈指针指向栈顶的项目（再次强调，这是最常见的约定）。
- en: '*Figure 12**.1* illustrates a stack used to save subroutine return addresses.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12**.1* 展示了一个用于保存子程序返回地址的栈。'
- en: '![Figure 12.1 – Using the stack to save a return address, N](img/Figure_12.01_B19624.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.1 – 使用栈保存返回地址，N](img/Figure_12.01_B19624.jpg)'
- en: Figure 12.1 – Using the stack to save a return address, N
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.1 – 使用栈保存返回地址，N
- en: 'The stack pointer points at the top item on the stack, and when an item is
    added to the stack (pushed), the stack pointer is first decremented. When an item
    is removed from the stack, it is taken at the location indicated by the stack
    pointer, and the stack pointer is incremented (i.e., moved down). We can define
    the push and pull (pop) actions with relation to the **stack pointer** (**SP**)
    as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 栈指针指向栈顶元素，当向栈中添加一个项目（推送）时，栈指针首先减少。当从栈中移除一个项目时，它是在栈指针指示的位置取出的，然后栈指针增加（即向下移动）。我们可以根据
    **栈指针**（**SP**）定义推送和拉取（弹出）操作如下：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The stack pointer is decremented and incremented by four, since we follow the
    ARM convention that the memory is byte-addressed and stack items are one-word
    long (four bytes). The next section looks in greater detail at how a subroutine
    is called and an orderly return is made to the calling point.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 栈指针以四的倍数减少和增加，因为我们遵循 ARM 习惯，即内存是字节寻址的，栈项是一字长（四个字节）。下一节将更详细地探讨子程序的调用和有序返回到调用点。
- en: A subroutine call and return
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 子程序调用和返回
- en: 'To call a subroutine, you push the return address on the stack. CISC processors
    implement a subroutine call with `bsr target`. Because the ARM lacks a subroutine
    call instruction, you can write the following ARM code. Remember that we are dealing
    with 32-bit word push and pulls, and the stack must be incremented or decremented
    by four. Remember that `r15` and `SP` and `r13` and `lr` are interchangeable terms
    in ARM literature:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用子程序，你需要将返回地址压入栈中。CISC 处理器使用 `bsr target` 实现子程序调用。因为 ARM 缺少子程序调用指令，你可以编写以下
    ARM 代码。记住，我们处理的是 32 位字推送和拉取，栈必须以四的倍数增加或减少。记住，在 ARM 文献中 `r15` 和 `SP` 以及 `r13` 和
    `lr` 是可以互换的术语：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'There’s no ARM subroutine return instruction, so you implement one with the
    following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: ARM 没有子程序返回指令，所以你可以用以下方式实现：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following is a simple program that sets up a call and return using this
    mechanism. Note that we don’t set up the initial stack pointer. The ARM’s operating
    system does that:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个简单的程序，使用此机制设置调用和返回。注意，我们没有设置初始的栈指针。ARM 的操作系统会做这件事：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Figure 12**.2* demonstrates the output of the ARM simulator after running
    this code. We have included the disassembly window and the register windows. Note
    how the `mov` r2`,#0xFFFFFFFF` instruction has been transformed into the `mvn`
    r2`,#0` operation. Recall that `MVN``ldr r12,[sp],#+` has been renamed `pop {r12}`.
    This is equivalent to the pop stack operation (removing an item from the top of
    the stack).'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12.2* 展示了运行此代码后 ARM 模拟器的输出。我们包括了反汇编窗口和寄存器窗口。注意 `mov r2`,#0xFFFFFFFF` 指令已被转换为
    `mvn r2`,#0` 操作。回想一下 `MVN` 和 `ldr r12,[sp],#+` 已被重命名为 `pop {r12}`。这相当于弹出栈操作（从栈顶移除一个项目）。'
- en: 'Registers after execution of the code:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 执行代码后的寄存器：
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following is an execution of the code step by step. This is an example
    of a subroutine call and return:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对代码的逐步执行。这是一个子程序调用和返回的示例：
- en: '[PRE11]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the next section, we will look at one of the ARM’s most powerful and least
    RISC-like operations – the ability to move blocks of data between memory and multiple
    registers.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨 ARM 最强大且最不 RISC 式的操作之一——在内存和多个寄存器之间移动数据块的能力。
- en: Block move instructions
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 块移动指令
- en: 'In this section, we will learn how multiple registers can be moved. The fundamental
    concepts are as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何移动多个寄存器。基本概念如下：
- en: How to specify a group of registers
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何指定一组寄存器
- en: How to address memory
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何寻址内存
- en: How to sequence the storage of registers
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何对寄存器的存储进行排序
- en: The different types of block moves
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同类型的块移动
- en: 'A great feature of some CISC processors was that you could push a group of
    registers on the stack in a single instruction. RISC processors generally don’t
    have such an instruction because it conflicts with the one-operation-per-cycle
    design constraint that’s at the heart of the RISC philosophy. Surprisingly, the
    ARM implements a block move instruction that lets you copy a group of registers
    to or from memory in one operation (i.e., an instruction). The following ARM code
    demonstrates how to load registers `r1`,`r2`,`r3`,`r5` from memory:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 CISC 处理器的一个伟大特性是你可以用一条指令将一组寄存器推入栈中。RISC 处理器通常没有这样的指令，因为它与 RISC 理念核心的每周期一次操作的设计约束相冲突。令人惊讶的是，ARM
    实现了一个块移动指令，允许你在一次操作（即一条指令）中将一组寄存器复制到或从内存中。以下 ARM 代码演示了如何从内存中加载寄存器 `r1`、`r2`、`r3`、`r5`：
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ARM has a *block move to memory* instruction, `stm`, and a *block move from
    memory*, `ldm`, that copies groups of registers to and from memory. Block move
    instructions require a two-character suffix to describe how the data is accessed
    (e.g., `stm`ia or `ldm`db), as we shall see.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: ARM有一个 *块移动到内存* 指令 `stm` 和一个 *块移动从内存* 指令 `ldm`，用于将寄存器组从内存中复制到和从内存中复制。块移动指令需要一个两位后缀来描述数据是如何访问的（例如，`stm`ia
    或 `ldm`db），我们将看到。
- en: Conceptually, a block move is easy to understand because it is simply a *copy
    the contents of these registers to memory* operation, or vice versa. In practice,
    it is more complex. ARM provides a full set of options that determine how the
    move takes place – for example, whether the registers are moved from high-to-low
    or low-to-high memory addresses, or whether the memory pointer is updated before
    or after a transfer (just like a stack structure). In fact, block moves are just
    like the push and pull stack operations found on other computers.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 从概念上讲，块移动很容易理解，因为它仅仅是 *将这些寄存器的内容复制到内存中* 的操作，或者相反。在实践中，它更为复杂。ARM 提供了一套完整的选项，用于确定移动的方式
    – 例如，寄存器是从高地址到低地址还是从低地址到高地址移动，或者内存指针是在传输前后更新（就像堆栈结构一样）。实际上，块移动就像在其他计算机上找到的推和拉堆栈操作一样。
- en: 'Let’s move the contents of registers `r1`, `r2`, `r3`, and `r5` into sequential
    memory locations with `stm`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将寄存器 `r1`、`r2`、`r3` 和 `r5` 的内容移动到连续的内存位置，使用 `stm` 指令：
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This instruction copies registers `r1` to `r3`, and `r5` into sequential memory
    locations, using `r0` as a pointer register with auto-indexing (indicated by the
    `!` suffix). The ia suffix indicates that the index register `r0` is incremented
    *after* each transfer, with data transfer in order of *ascending* addresses. We’ll
    also see that this instruction can be written as `stm`fd (which is the same operation,
    but ARM provides two naming conventions for the same thing in their documentation).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 此指令将寄存器 `r1` 复制到 `r3`，并将 `r5` 移动到连续的内存位置，使用 `r0` 作为指针寄存器并自动索引（由 `!` 后缀表示）。ia后缀表示索引寄存器
    `r0` 在每次传输后增加，数据传输按照 *递增* 地址顺序进行。我们还将看到，此指令可以写成 `stm`fd（这是相同的操作，但ARM在其文档中为同一事物提供了两种命名约定）。
- en: Although ARM’s block move mode instructions have several variations, the lowest
    numbered register is always stored at the lowest address, followed by the next
    lowest numbered register at the next higher address, and so on (e.g., `r1`, then
    `r2`, `r3`, and `r5` in the preceding example).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然ARM的块移动模式指令有多种变化，但编号最低的寄存器总是存储在最低的地址，其次是下一个编号最低的寄存器在下一个更高的地址，依此类推（例如，前一个示例中的
    `r1`，然后是 `r2`、`r3` 和 `r5`）。
- en: 'Consider the following example of the block move. Because it’s a little more
    complicated than some instructions we’ve encountered, we will demonstrate its
    execution. I’ve included several features that are not strictly part of the demonstration
    but include features I use when experimenting. In particular, I use markers in
    both registers and memory so that I can follow debugging more easily. For example,
    in the memory block, I store the data words `0xFFFFFFFF` and `0xAAAAAAAA`. These
    serve no function other than to show me, at a glance, where my data area starts
    and stops when I debug memory. Similarly, I use values such as `0x11111111` as
    words to move from registers because I can easily follow them in debugging:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下块移动的示例。因为它比我们遇到的一些指令要复杂一些，我们将演示其执行。我包括了几个不是严格属于演示但包括我在实验中使用的功能。特别是，我在寄存器和内存中使用标记，以便我可以更容易地跟踪调试。例如，在内存块中，我存储了数据字
    `0xFFFFFFFF` 和 `0xAAAAAAAA`。这些数据除了让我一眼就能看到我在调试内存时数据区域开始和结束的位置外，没有其他功能。同样，我使用类似
    `0x11111111` 的值作为从寄存器移动的字，因为我可以在调试时轻松跟踪它们：
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This code sets up five registers with data that is easily visible when examining
    memory. Thirty-two bytes of memory are saved between two word markers at the end
    of the program with the `.space` directive. The start of this block is labeled
    `memory`, and `r0` points to it. Then the five registers are stored in memory.
    Instructions that carry out the block store are shaded in light gray, and the
    data area is shaded in dark gray.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码设置了五个寄存器，其数据在检查内存时很容易看到。程序末尾的两个字标记之间保存了32个字节的内存，使用 `.space` 指令。此块的开始被标记为
    `memory`，`r0` 指向它。然后这五个寄存器被存储在内存中。执行块存储的指令以浅灰色表示，数据区域以深灰色表示。
- en: The code we are initially interested in is for the five register loads that
    preset registers `r1` to `r5` with `0x11111111` to `0x55555555`, respectively.
    Register `r0` was set initially to `0xFFFFFFFF` just as a marker for debugging.
    The key instruction is stmia r0!,{r1-r3,r5}, whose purpose is to store the contents
    of registers `r1`, `r2`, `r3`, and `r5` in consecutive memory locations pointed
    at by r0.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最初感兴趣的代码是为五个寄存器加载而编写的，分别用`0x11111111`到`0x55555555`预设寄存器`r1`到`r5`。寄存器`r0`最初被设置为`0xFFFFFFFF`，仅作为调试的标记。关键指令是`stmia
    r0!,{r1-r3,r5}`，其目的是将寄存器`r1`、`r2`、`r3`和`r5`的内容存储在由`r0`指向的连续内存位置。
- en: 'The following Raspberry Pi output is from the `gdb` debugger. The source code
    is `blockMove1.s`. We’ve omitted some of the register values to make the listing
    more readable when registers haven’t changed or haven’t been used. Similarly,
    repetitive command lines have been omitted:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的树莓派输出来自`gdb`调试器。源代码是`blockMove1.s`。我们省略了一些寄存器值，以便在寄存器未更改或未使用时使列表更易于阅读。同样，重复的命令行也被省略了：
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Having looked at the registers, we will now proceed to execute a series of
    instructions. Note that we need to enter `si 1` once and then simply hit *Return*
    to repeat the operation:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看寄存器之后，我们现在将执行一系列指令。请注意，我们需要一次输入`si 1`，然后简单地按*Return*来重复操作：
- en: '[PRE16]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, let’s look at the registers we set up. Only registers of interest have
    been displayed. Note that `r0` points to the data at `0x200CC`. The system software
    is responsible for this address:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们设置的寄存器。只显示了感兴趣的寄存器。请注意，`r0`指向`0x200CC`处的数据。系统软件负责这个地址：
- en: '[PRE17]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: At this point, we’ve set up register `r0` as a pointer, and its value is `0x200cc`.
    This value has been determined by the assembler and loader. If you refer back
    to the source code, we used `ldr` r0`,adr`_mem to load `r0` via a pointer to the
    actual data stored in memory. This is because the software does not let us load
    a direct memory address.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经将寄存器`r0`设置为指针，其值为`0x200cc`。这个值是由汇编器和加载器确定的。如果您参考源代码，我们使用了`ldr r0,adr_mem`通过指向实际存储在内存中的数据的指针来加载`r0`。这是因为软件不允许我们直接加载内存地址。
- en: 'You can see that the registers have been set up with their *easy-to-trace*
    values. The next step is to examine memory using the `x/16xw gdb` command to display
    16 words of hexadecimal data:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，寄存器已经设置为易于追踪的值。下一步是使用`x/16xw gdb`命令检查内存，以显示16个十六进制数据字：
- en: '[PRE18]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The two markers we’ve stored in memory are in bold font. Now, let’s execute
    the stored multiple registers. Before that, we will copy the pointer to `r10`
    (again, that is just for my own debugging purposes) so that we can see what it
    was before the move. After the block move instruction, we display registers of
    interest:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们存储在内存中的两个标记以粗体显示。现在，让我们执行存储的多个寄存器。在此之前，我们将指针复制到`r10`（这只是为了我的调试目的）以便我们可以看到移动之前它的值。在块移动指令之后，我们显示感兴趣的寄存器：
- en: '[PRE19]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now for the proof of the pudding. Here’s the memory after the `x/16xw` display
    command. Note that the contents of the four registers have been stored in consecutive
    rising memory locations:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是检验成果的时候了。这是`x/16xw`显示命令之后的内存。请注意，四个寄存器的内存储存在连续递增的内存位置：
- en: '[PRE20]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Finally, we will execute the last two commands and display the register contents:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将执行最后两个命令并显示寄存器内容：
- en: '[PRE22]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You can see that the block move from the `ldmdb r0!,{r6-r9}` memory operation
    has copied the four registers from the memory and placed them in registers `r7`
    to `r9`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，从`ldmdb r0!,{r6-r9}`内存操作中，四个寄存器从内存中复制到寄存器`r7`到`r9`。
- en: Consider the suffix of ldm, which is db. Why `ldmdb`? When we transferred data
    to memory, we used the *increment after* suffix, where the pointer register is
    used to move the data to a memory location, and then it is incremented after the
    move. When we retrieve the data, we initially point at the location after the
    last value is moved. Consequently, to remove the items we stored in memory, we
    have to decrement the pointer before each move – hence the *decrement before*
    (`db`) suffix. For this reason, the instruction pair `stmia` and `ldmdb` correspond
    to the stack push and pull operations, respectively.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑`ldm`的后缀为`db`。为什么是`ldmdb`？当我们向内存传输数据时，我们使用了`*increment after*`后缀，其中指针寄存器用于将数据移动到内存位置，然后移动后增加。当我们检索数据时，我们最初指向最后一个值移动后的位置。因此，为了移除我们存储在内存中的项目，我们必须在每次移动之前递减指针——这就是`*decrement
    before*`（`db`）后缀的原因。因此，指令对`stmia`和`ldmdb`分别对应堆栈的压入和弹出操作。
- en: Disassembling the code
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 拆解代码
- en: The following is a disassembly of the code for this program. It’s been edited
    and reformatted for easier viewing. Some instructions have two lines. One line
    is the *original* instruction, as presented in the program. The following line
    is the instruction as interpreted by the assembler. This demonstrates how pseudo
    instructions such as `ldr` r1`,=0x111111` are handled.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对该程序代码的反汇编。它已被编辑和重新格式化，以便更容易查看。一些指令有两行。一行是 *原始* 指令，如程序中所示。下一行是汇编器解释的指令。这展示了伪指令如
    `ldr` r1`,=0x111111` 是如何处理的。
- en: 'The lines in bold require some further explanation, as shown here:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 粗体线需要进一步解释，如下所示：
- en: '[PRE23]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The following command uses x/32xw to display 32 consecutive words of memory
    in hexadecimal form so that we can observe what has happened in memory. Here’s
    where our use of markers such as 0xAAAAAAAA makes it easy to recognize where we
    are in memory.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令使用 x/32xw 以十六进制形式显示 32 个连续的字节，以便我们可以观察内存中发生了什么。这就是我们使用标记如 0xAAAAAAAA 使得识别内存中的位置变得容易的地方。
- en: '[PRE24]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Line 5* contains a `nop` instruction that does nothing (other than advance
    the PC to the next instruction). It can provide a placeholder for later code,
    or act as a debugging aid. Here, it provides a space for the first instruction
    to land on. The ARM lacks a `nop`, and the assembler translates `nop` to `mov
    r0,r0`. Like `nop`, this instruction achieves nothing!'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*第5行* 包含一个 `nop` 指令，它什么都不做（除了将 PC 移动到下一个指令）。它可以提供一个占位符供后续代码使用，或者作为调试辅助。在这里，它为第一个指令提供了一个着陆空间。ARM
    缺少 `nop`，汇编器将 `nop` 翻译为 `mov r0,r0`。像 `nop` 一样，这条指令什么也不做！'
- en: '`ldr` r0`,=0xFFFFFFFF` is interesting. The assembler uses ARM’s `mvn` to invert
    the bits of the operand before moving them. If the operand is `0`, the bits moved
    will be all `1`s, which is exactly what we want.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`ldr` r0`,=0xFFFFFFFF` 很有趣。汇编器使用 ARM 的 `mvn` 在移动之前反转操作数的位。如果操作数是 `0`，则移动的位将是全部
    `1`s，这正是我们想要的。'
- en: 'Instruction 7 demonstrates another pseudo-operation:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 指令 7 展示了另一个伪操作：
- en: '[PRE26]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The instruction requires a 32-bit literal, `0x11111111`, and that cannot be
    loaded as such. The compiler converts the instruction to a program counter-relative
    load from memory. The address is the current program counter, `0x0001007c`, plus
    the offset of `52` or `0x44`, plus the ARM PC’s 8-byte lead. At that target address,
    you will find the `0x11111111` constant stored.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 指令需要一个 32 位立即数，`0x11111111`，并且不能以这种方式加载。编译器将指令转换为程序计数器相关的内存加载。地址是当前程序计数器，`0x0001007c`，加上偏移量
    `52` 或 `0x44`，加上 ARM PC 的 8 字节前缀。在那个目标地址，你会找到存储的 `0x11111111` 常量。
- en: '*Instruction 12* uses a similar pseudo-instruction. In this case, it’s to get
    the address in memory for the store multiple registers to use:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*指令12* 使用了一个类似的伪指令。在这种情况下，它是为了获取内存中的地址，以便用于存储多个寄存器：'
- en: '[PRE27]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The code ends with `svc`, followed by the comment “*undefined*.” That’s because
    the disassembler tried to disassemble the data in memory, and it did not apply
    to a valid instruction.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 代码以 `svc` 结尾，后面跟着注释“*未定义*。”这是因为反汇编器试图反汇编内存中的数据，但它不适用于有效的指令。
- en: Block moves and stack operations
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 块移动和栈操作
- en: '*Figure 12**.2* to *Figure 12**.5* show the four variations of block move instructions
    in terms of the stack type. Recall that, in this text, I use only a *full descending*
    full stack mode, where the stack pointer points at the top of the stack and is
    decremented before a new item is added. The differences between these modes are
    the direction in which the stack grows (up or ascending and down or descending)
    and depend on whether the stack pointer points at the item at the top of the stack
    or the next free item on it. ARM’s literature uses four terms to describe stacks:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12**.2* 到 *图12**.5* 展示了根据栈类型的不同，块移动指令的四种变化。回想一下，在这篇文章中，我只使用了一种 *完全下降* 的全栈模式，其中栈指针指向栈顶，并在添加新项目之前递减。这些模式之间的区别在于栈增长的方向（向上或上升和向下或下降），并且取决于栈指针是否指向栈顶的项目或其上的下一个空闲项目。ARM
    的文献使用四个术语来描述栈：'
- en: FD    Full descending      *Figure 12**.2*
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FD    完全下降      *图12**.2*
- en: FA     Full ascending      *Figure 12**.3*
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FA     完全上升      *图12**.3*
- en: ED    Empty descending   *Figure 12**.4*
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ED    空下降   *图12**.4*
- en: EA    Empty ascending    *Figure 12**.5*
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EA    空上升    *图12**.5*
- en: Block moves improve the performance of code by loading or storing several registers
    with one instruction. They are also frequently used to save registers, before
    calling a subroutine and then restoring them after a return from it, as the following
    example demonstrates. In what follows, SP is the stack pointer – that is, `r13`
    (you can write either `r13` or sp in the ARM assembly language).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 块移动通过一条指令加载或存储多个寄存器来提高代码的性能。它们也常用于在调用子程序之前保存寄存器，并在从子程序返回后恢复它们，如下例所示。在以下内容中，SP是栈指针——即`r13`（在ARM汇编语言中，你可以写`r13`或sp）。
- en: When used by load operations, the suffix is *increment after*. When used by
    store operations, the suffix is *decrement before*.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当用于加载操作时，后缀是*之后增加*。当用于存储操作时，后缀是*之前减少*。
- en: '![Figure 12.2 – One of ARM’s four stack modes – full descending (FD, IA load,
    and DB store)](img/Figure_12.03_B19624.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图12.2 – ARM的四种栈模式之一——满下降（FD，IA加载和DB存储）](img/Figure_12.03_B19624.jpg)'
- en: Figure 12.2 – One of ARM’s four stack modes – full descending (FD, IA load,
    and DB store)
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2 – ARM的四种栈模式之一——满下降（FD，IA加载和DB存储）
- en: In a full descending stack, the stack pointer points at the item at the top
    of the stack (full), and when an item is added to the stack, the stack pointer
    is *decremented before* and when an item is removed, the stack is *incremented
    after*.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个满下降栈中，栈指针指向栈顶的项目（满），当向栈中添加一个项目时，栈指针*之前减少*，当移除一个项目时，栈*之后增加*。
- en: 'Consequently, we have the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们得到以下结果：
- en: '[PRE28]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As you can see, we can describe the instruction by either what it does (`db`
    or `ia`) or the type of stack (`fd`). It is rather unusual for assembly language
    designers to provide such options, and this is, initially, a little confusing.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们可以通过它所执行的操作（`db`或`ia`）或栈的类型（`fd`）来描述指令。对于汇编语言设计者来说，提供这样的选项相当不寻常，这最初可能会有些令人困惑。
- en: '![Figure 12.3 – One of ARM’s four stack modes – full ascending (FA, DA load,
    and IB store)](img/Figure_12.04_B19624.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图12.3 – ARM的四种栈模式之一——满上升（FA，DA加载和IB存储）](img/Figure_12.04_B19624.jpg)'
- en: Figure 12.3 – One of ARM’s four stack modes – full ascending (FA, DA load, and
    IB store)
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3 – ARM的四种栈模式之一——满上升（FA，DA加载和IB存储）
- en: In a full ascending stack, the stack pointer points at the item at the top of
    the stack (full), and when an item is added to the stack, the stack pointer is
    *incremented before*. When an item is removed, the stack is *decremented after*.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个满上升栈中，栈指针指向栈顶的项目（满），当向栈中添加一个项目时，栈指针*之前增加*。当移除一个项目时，栈*之后减少*。
- en: 'Consequently, we have the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们得到以下结果：
- en: '[PRE29]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '![Figure 12.4 – One of ARM’s four stack modes – empty descending (ED, IB load,
    and DA store)](img/Figure_12.05_B19624.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图12.4 – ARM的四种栈模式之一——空下降（ED，IB加载和DA存储）](img/Figure_12.05_B19624.jpg)'
- en: Figure 12.4 – One of ARM’s four stack modes – empty descending (ED, IB load,
    and DA store)
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.4 – ARM的四种栈模式之一——空下降（ED，IB加载和DA存储）
- en: 'In an empty descending stack, the stack pointer points at the item above the
    top of the stack (empty), and when an item is added to the stack, the stack pointer
    is incremented after. When an item is removed, the stack is decremented before.
    Consequently, we have the following:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个空的下降栈中，栈指针指向栈顶之上的项目（空），当向栈中添加一个项目时，栈指针随后增加。当移除一个项目时，栈在之前减少。因此，我们得到以下结果：
- en: '[PRE30]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '![Figure 12.5 – One of ARM’s four stack modes – empty ascending (EA, DB load,
    and IA store)](img/Figure_12.06_B19624.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图12.5 – ARM的四种栈模式之一——空上升（EA，DB加载和IA存储）](img/Figure_12.06_B19624.jpg)'
- en: Figure 12.5 – One of ARM’s four stack modes – empty ascending (EA, DB load,
    and IA store)
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.5 – ARM的四种栈模式之一——空上升（EA，DB加载和IA存储）
- en: 'We use the `fd` block move suffix to mean *full descending*. ARM lets you use
    two different naming conventions for block move instructions. You can write the
    pair `stmia` and `ldmdb`, or the pair `stmfd` and `ldmfd`; they are the same.
    Yes, it is confusing:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`fd`块移动后缀来表示*满下降*。ARM允许你为块移动指令使用两种不同的命名约定。你可以写`stmia`和`ldmdb`的配对，或者`stmfd`和`ldmfd`的配对；它们是相同的。是的，这很令人困惑：
- en: '[PRE31]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Since the program counter is also a user-visible register, we can simplify
    the code by including the PC as one of the registers we save:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 由于程序计数器也是一个用户可见的寄存器，我们可以通过将PC作为我们保存的寄存器之一来简化代码：
- en: '[PRE32]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The link register with the return address is pushed onto the stack, and then
    at the end, we pull the saved registers, including the value of the return address
    that is placed in the PC, to return.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 带有返回地址的链接寄存器被推入栈中，然后在最后，我们拉取保存的寄存器，包括放置在PC中的返回地址值，以返回。
- en: 'The block move provides a convenient means of copying data between memory regions.
    In the next example, we will copy 256 words from `pqr` to `xyz`. The block move
    instruction allows us to move eight registers at once, as the following code illustrates:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 块移动提供了一种方便的方法，可以在内存区域之间复制数据。在下一个示例中，我们将从`pqr`复制256个单词到`xyz`。块移动指令允许我们一次移动八个寄存器，如下面的代码所示：
- en: '[PRE33]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This ends the section on Raspberry Pi and the ARM assembly language. In this
    book, you have learned how a computer works and what it does. We’ve examined instructions
    sets, their encoding, and their execution. In the last four chapters, we looked
    at high-performance architecture with an imaginative design.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了关于树莓派和ARM汇编语言的章节。在这本书中，你学习了计算机的工作原理及其功能。我们检查了指令集、它们的编码和执行。在最后四章中，我们探讨了具有创新设计的高性能架构。
- en: Now, you should be able to write your own programs.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该能够编写自己的程序了。
- en: Summary
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: One of the key data structures in computing is the stack, or the LIFO queue.
    A stack is a queue with only one end – that is, new items enter at the same end
    as items leave. This single end is called the **top of** **stack** (**TOS**).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机中的关键数据结构之一是栈，或后进先出队列。栈是一个只有一端的队列——也就是说，新项从与项离开相同的端进入。这个单一端被称为**栈顶**（**TOS**）。
- en: The stack is important because it enables the mechanization of many computing
    processes, ranging from dealing with arithmetic expressions to translating languages.
    Here, we are interested in the stack as a means of ensuring that subroutines are
    called and returned from in a consistent, efficient, and fool-proof manner.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 栈之所以重要，是因为它使得许多计算过程实现机械化成为可能，从处理算术表达式到翻译语言。在这里，我们关注栈作为一种确保子程序以一致、高效和万无一失的方式被调用和返回的手段。
- en: A subroutine is a piece of code that can be called (invoked) from any point
    in a program and a return made to the calling point. This action requires the
    management of return addresses, and the stack is eminently suitable because the
    sequence of return addresses is the inverse sequence of the calling addresses
    – that is, the same as the order of items pushed and pulled from a stack.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 子程序是一段可以从程序中的任何位置调用（调用）并从调用点返回的代码。这一动作需要管理返回地址，而栈非常适合，因为返回地址的序列是调用地址的逆序列——也就是说，与从栈中推入和拉出项的顺序相同。
- en: We have looked at the ARM’s branch and link instruction, `bl`, that can be used
    to call a subroutine without the overhead of the stack. However, using the branch
    with link a second time overwrites the return address in the link register, and
    you then have to use a stack to preserve previous addresses.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经研究了ARM的分支和链接指令`bl`，它可以用来调用子程序而不需要栈的开销。然而，使用带有链接的分支第二次会覆盖链接寄存器中的返回地址，然后你必须使用栈来保存之前的地址。
- en: RISC computers, in principle, implement simple, one-cycle operations. The ARM
    has a very non-RISC like set of block-move instructions that allow you to move
    an entire group of instructions in a single operation. You can transfer up to
    16 registers to or from memory in one operation. The block move lets you pass
    parameters to and from a subroutine via the stack.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: RISC计算机在原则上实现简单、单周期操作。ARM有一组非常非RISC的块移动指令，允许你在单个操作中移动整个指令组。你可以在一个操作中将多达16个寄存器传输到或从内存。块移动让你可以通过栈将参数传递到和从子程序。
- en: There are four standard stack implementations. The stack pointer can point either
    to the item at the top of the stack, or to the free space above that item. Similarly,
    the stack can grow (as items are added) toward low addresses or toward high addresses.
    This gives four possible arrangements. However, most computers implement a stack
    that points to the top item on it that grows toward low addresses.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 有四种标准的栈实现。栈指针可以指向栈顶的项，或者指向该项之上的空闲空间。同样，栈可以朝向低地址或高地址增长（随着项的添加）。这提供了四种可能的排列。然而，大多数计算机实现的是指向其顶部项且朝向低地址增长的栈。
- en: An unusual feature of the ARM’s literature is that it has two naming conventions
    for stack organization. One convention uses the type of stack (pointing at the
    top or the next free item) and direction of the stack, whereas the other convention
    describes whether the stack is incremented/decremented before or after the operation
    – for example, `stm`ia `r0!,{r2-r6}` and `stm`ea `r0!,{r2-r6}` are identical operations.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ARM文献的一个不寻常的特点是它对栈组织的命名约定有两种。一种约定使用栈的类型（指向顶部或下一个空闲项）和栈的方向，而另一种约定描述了在操作之前或之后栈是增加还是减少——例如，`stm`ia
    `r0!,{r2-r6}`和`stm`ea `r0!,{r2-r6}`是相同的操作。
- en: In this book, we introduced the computer and demonstrated how it can be simulated
    with Python. By the end of [*Chapter 8*](B19624_08.xhtml#_idTextAnchor135), you
    should be able to design and simulate a computer instruction set, created to your
    own specification.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们介绍了计算机，并演示了如何使用Python进行模拟。到[*第8章*](B19624_08.xhtml#_idTextAnchor135)结束时，你应该能够设计和模拟一个符合你自定义规范的计算机指令集。
- en: Following the design of a hypothetical teaching computer, we looked at Raspberry
    Pi and the ARM microprocessor at its heart. This provides an introduction to real
    computers. We described the ARM’s instruction set architecture, explained how
    it operates, and explained how to write ARM assembly language programs and debug
    them on Raspberry Pi.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 按照一个假设的教学计算机的设计，我们考察了树莓派及其核心的ARM微处理器。这为真实计算机的介绍提供了基础。我们描述了ARM的指令集架构，解释了其工作原理，并说明了如何在树莓派上编写ARM汇编语言程序以及如何调试它们。
- en: Having reached the end of this book, you might like to consider designing your
    own ARM simulator.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束这本书之后，你可能想考虑设计你自己的ARM模拟器。
- en: Finally, we wil provide some appendices to enable you to find some of the pieces
    of information you will need most frequently.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将提供一些附录，以便你能够找到你最常需要的一些信息片段。
