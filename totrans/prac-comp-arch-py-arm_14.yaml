- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Subroutines and the Stack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A subroutine is a piece of code that is called from a point within a program
    and executed, and then a return is made to the instruction after the calling point.
    All computers use subroutines, but some computers provide a programmer with more
    facilities to implement subroutines than others.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will look at the ARM’s subroutine handling mechanisms –
    in particular, the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The special branch and link instruction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The stack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A subroutine call and return
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Block move instructions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Branch with link instruction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, we discuss the ARM’s *branch and link* instruction, `bl`, which provides
    a quick and easy way to call a subroutine without using a stack mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two basic ways of implementing subroutine calls and returns. The
    classic CISC approach is `BSR` (branch to subroutine) and `RTS` (return from subroutine).
    The typical code might be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This is simplicity in action. You call a piece of code, execute it, and return
    to the instruction after the calling point. Most RISC processors reject this mechanism
    because the subroutine call and return are complex instructions that save the
    return address on the stack during a call, and then pull the return address off
    the stack during a return. This is very convenient for a programmer but requires
    several CPU clock cycles to execute, and it does not fit into the one-cycle-per-instruction
    paradigm of the RISC processor.
  prefs: []
  type: TYPE_NORMAL
- en: The great advantage of the stack-based subroutine call/return is that you can
    nest subroutines and call subroutines from other subroutines, and the stack mechanism
    automatically deals with return addresses.
  prefs: []
  type: TYPE_NORMAL
- en: You will soon see that you can implement this mechanism yourself on an ARM,
    but not by using two dedicated instructions. You have to write your own code.
  prefs: []
  type: TYPE_NORMAL
- en: If you want a simple subroutine call and return (the subroutine is called a
    *leaf*), all you need to do is save the return address in a register (no external
    memory or stack is required). Then, to return, you just put the return address
    in the program counter – simple and fast. However, once you are in the subroutine,
    you can’t do the same thing again and call another subroutine. Doing that would
    destroy your existing saved return address.
  prefs: []
  type: TYPE_NORMAL
- en: The ARM’s subroutine mechanism is called *branch with link* and has the mnemonic
    `bl target`, where `target` is the symbolic address of the subroutine. The actual
    address is program counter-relative and is a 24-bit signed word that gives you
    a branch range of 223 words from the current PC. The range is 223 words in either
    direction from the PC (i.e., branch forward and branch back).
  prefs: []
  type: TYPE_NORMAL
- en: 'The branch with link instruction behaves like a branch instruction, but it
    also copies the return address (i.e., the address of the next instruction to be
    executed following a return into the link register `r14`. Let’s say you execute
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The ARM executes a branch to the target address specified by the label `sub_A`.
    It also copies the program counter, held in register `r15`, into the link register
    `r14` to preserve the return address. At the end of the subroutine, you return
    by transferring the return address in `r14` to the program counter. You don’t
    need a special return instruction; you just write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s look at a simple example of the use of a subroutine. Suppose that you
    need to evaluate the `if x > 0 then` `x = 16x + 1 else x = 32x` function several
    times in a program. Assuming that the x parameter is in register `r0`, we can
    write the following subroutine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: All you need to create a subroutine is an entry point (the label `Func1`) and
    a return point that restores the saved address by bl in the link register.
  prefs: []
  type: TYPE_NORMAL
- en: The stack
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ve already described the stack. We’ll go over it again here because it’s
    probably the single most important data structure in computing. The stack is a
    pile that you add things on at the top and take things off, also from the top.
    If you take something off the stack, it is the last thing that was added to the
    stack. Consequently, the stack is called a **last in first out queue** (**LIFO**),
    in which items enter at one end and leave in the reverse order.
  prefs: []
  type: TYPE_NORMAL
- en: Computers implement stacks by using a pointer register to point at the top of
    the stack. The ARM uses `r13` as a stack pointer, or, to be precise, the ARM *mandates*
    the use of `r13` as a stack pointer. You can use `r0` to `r13` as a stack pointer
    if you wish. The use of `r13` is a *convention* designed to make code more readable
    and sharable.
  prefs: []
  type: TYPE_NORMAL
- en: There are four variations of the stack. They all do the same thing but are implemented
    differently. The ARM supports all four variations, but we’ll use only one here
    for the sake of simplicity. A stack is stored in memory, which has no up or down
    in the normal human sense. When items are added to the stack, they can be added
    to the next location with a lower address or the next location with a higher address.
    By convention, most stacks are implemented so that the next item is stored at
    the *lower address*. We say that the stack grows *up* toward *lower* addresses
    (that’s because we number lines in a book from top to bottom, with line one at
    the top).
  prefs: []
  type: TYPE_NORMAL
- en: The other variation in the arrangement of stacks is that the stack pointer can
    either point to the top item on the stack, TOS, or point to the next free item
    on that stack. I will cover stacks where the stack pointer points to the top item
    on the stack (again, this is the most common convention).
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 12**.1* illustrates a stack used to save subroutine return addresses.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1 – Using the stack to save a return address, N](img/Figure_12.01_B19624.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.1 – Using the stack to save a return address, N
  prefs: []
  type: TYPE_NORMAL
- en: 'The stack pointer points at the top item on the stack, and when an item is
    added to the stack (pushed), the stack pointer is first decremented. When an item
    is removed from the stack, it is taken at the location indicated by the stack
    pointer, and the stack pointer is incremented (i.e., moved down). We can define
    the push and pull (pop) actions with relation to the **stack pointer** (**SP**)
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The stack pointer is decremented and incremented by four, since we follow the
    ARM convention that the memory is byte-addressed and stack items are one-word
    long (four bytes). The next section looks in greater detail at how a subroutine
    is called and an orderly return is made to the calling point.
  prefs: []
  type: TYPE_NORMAL
- en: A subroutine call and return
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To call a subroutine, you push the return address on the stack. CISC processors
    implement a subroutine call with `bsr target`. Because the ARM lacks a subroutine
    call instruction, you can write the following ARM code. Remember that we are dealing
    with 32-bit word push and pulls, and the stack must be incremented or decremented
    by four. Remember that `r15` and `SP` and `r13` and `lr` are interchangeable terms
    in ARM literature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'There’s no ARM subroutine return instruction, so you implement one with the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is a simple program that sets up a call and return using this
    mechanism. Note that we don’t set up the initial stack pointer. The ARM’s operating
    system does that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '*Figure 12**.2* demonstrates the output of the ARM simulator after running
    this code. We have included the disassembly window and the register windows. Note
    how the `mov` r2`,#0xFFFFFFFF` instruction has been transformed into the `mvn`
    r2`,#0` operation. Recall that `MVN``ldr r12,[sp],#+` has been renamed `pop {r12}`.
    This is equivalent to the pop stack operation (removing an item from the top of
    the stack).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Registers after execution of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is an execution of the code step by step. This is an example
    of a subroutine call and return:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will look at one of the ARM’s most powerful and least
    RISC-like operations – the ability to move blocks of data between memory and multiple
    registers.
  prefs: []
  type: TYPE_NORMAL
- en: Block move instructions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will learn how multiple registers can be moved. The fundamental
    concepts are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: How to specify a group of registers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to address memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to sequence the storage of registers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The different types of block moves
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A great feature of some CISC processors was that you could push a group of
    registers on the stack in a single instruction. RISC processors generally don’t
    have such an instruction because it conflicts with the one-operation-per-cycle
    design constraint that’s at the heart of the RISC philosophy. Surprisingly, the
    ARM implements a block move instruction that lets you copy a group of registers
    to or from memory in one operation (i.e., an instruction). The following ARM code
    demonstrates how to load registers `r1`,`r2`,`r3`,`r5` from memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: ARM has a *block move to memory* instruction, `stm`, and a *block move from
    memory*, `ldm`, that copies groups of registers to and from memory. Block move
    instructions require a two-character suffix to describe how the data is accessed
    (e.g., `stm`ia or `ldm`db), as we shall see.
  prefs: []
  type: TYPE_NORMAL
- en: Conceptually, a block move is easy to understand because it is simply a *copy
    the contents of these registers to memory* operation, or vice versa. In practice,
    it is more complex. ARM provides a full set of options that determine how the
    move takes place – for example, whether the registers are moved from high-to-low
    or low-to-high memory addresses, or whether the memory pointer is updated before
    or after a transfer (just like a stack structure). In fact, block moves are just
    like the push and pull stack operations found on other computers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s move the contents of registers `r1`, `r2`, `r3`, and `r5` into sequential
    memory locations with `stm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This instruction copies registers `r1` to `r3`, and `r5` into sequential memory
    locations, using `r0` as a pointer register with auto-indexing (indicated by the
    `!` suffix). The ia suffix indicates that the index register `r0` is incremented
    *after* each transfer, with data transfer in order of *ascending* addresses. We’ll
    also see that this instruction can be written as `stm`fd (which is the same operation,
    but ARM provides two naming conventions for the same thing in their documentation).
  prefs: []
  type: TYPE_NORMAL
- en: Although ARM’s block move mode instructions have several variations, the lowest
    numbered register is always stored at the lowest address, followed by the next
    lowest numbered register at the next higher address, and so on (e.g., `r1`, then
    `r2`, `r3`, and `r5` in the preceding example).
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example of the block move. Because it’s a little more
    complicated than some instructions we’ve encountered, we will demonstrate its
    execution. I’ve included several features that are not strictly part of the demonstration
    but include features I use when experimenting. In particular, I use markers in
    both registers and memory so that I can follow debugging more easily. For example,
    in the memory block, I store the data words `0xFFFFFFFF` and `0xAAAAAAAA`. These
    serve no function other than to show me, at a glance, where my data area starts
    and stops when I debug memory. Similarly, I use values such as `0x11111111` as
    words to move from registers because I can easily follow them in debugging:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This code sets up five registers with data that is easily visible when examining
    memory. Thirty-two bytes of memory are saved between two word markers at the end
    of the program with the `.space` directive. The start of this block is labeled
    `memory`, and `r0` points to it. Then the five registers are stored in memory.
    Instructions that carry out the block store are shaded in light gray, and the
    data area is shaded in dark gray.
  prefs: []
  type: TYPE_NORMAL
- en: The code we are initially interested in is for the five register loads that
    preset registers `r1` to `r5` with `0x11111111` to `0x55555555`, respectively.
    Register `r0` was set initially to `0xFFFFFFFF` just as a marker for debugging.
    The key instruction is stmia r0!,{r1-r3,r5}, whose purpose is to store the contents
    of registers `r1`, `r2`, `r3`, and `r5` in consecutive memory locations pointed
    at by r0.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following Raspberry Pi output is from the `gdb` debugger. The source code
    is `blockMove1.s`. We’ve omitted some of the register values to make the listing
    more readable when registers haven’t changed or haven’t been used. Similarly,
    repetitive command lines have been omitted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Having looked at the registers, we will now proceed to execute a series of
    instructions. Note that we need to enter `si 1` once and then simply hit *Return*
    to repeat the operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s look at the registers we set up. Only registers of interest have
    been displayed. Note that `r0` points to the data at `0x200CC`. The system software
    is responsible for this address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we’ve set up register `r0` as a pointer, and its value is `0x200cc`.
    This value has been determined by the assembler and loader. If you refer back
    to the source code, we used `ldr` r0`,adr`_mem to load `r0` via a pointer to the
    actual data stored in memory. This is because the software does not let us load
    a direct memory address.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see that the registers have been set up with their *easy-to-trace*
    values. The next step is to examine memory using the `x/16xw gdb` command to display
    16 words of hexadecimal data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The two markers we’ve stored in memory are in bold font. Now, let’s execute
    the stored multiple registers. Before that, we will copy the pointer to `r10`
    (again, that is just for my own debugging purposes) so that we can see what it
    was before the move. After the block move instruction, we display registers of
    interest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now for the proof of the pudding. Here’s the memory after the `x/16xw` display
    command. Note that the contents of the four registers have been stored in consecutive
    rising memory locations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we will execute the last two commands and display the register contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: You can see that the block move from the `ldmdb r0!,{r6-r9}` memory operation
    has copied the four registers from the memory and placed them in registers `r7`
    to `r9`.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the suffix of ldm, which is db. Why `ldmdb`? When we transferred data
    to memory, we used the *increment after* suffix, where the pointer register is
    used to move the data to a memory location, and then it is incremented after the
    move. When we retrieve the data, we initially point at the location after the
    last value is moved. Consequently, to remove the items we stored in memory, we
    have to decrement the pointer before each move – hence the *decrement before*
    (`db`) suffix. For this reason, the instruction pair `stmia` and `ldmdb` correspond
    to the stack push and pull operations, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Disassembling the code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following is a disassembly of the code for this program. It’s been edited
    and reformatted for easier viewing. Some instructions have two lines. One line
    is the *original* instruction, as presented in the program. The following line
    is the instruction as interpreted by the assembler. This demonstrates how pseudo
    instructions such as `ldr` r1`,=0x111111` are handled.
  prefs: []
  type: TYPE_NORMAL
- en: 'The lines in bold require some further explanation, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The following command uses x/32xw to display 32 consecutive words of memory
    in hexadecimal form so that we can observe what has happened in memory. Here’s
    where our use of markers such as 0xAAAAAAAA makes it easy to recognize where we
    are in memory.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '*Line 5* contains a `nop` instruction that does nothing (other than advance
    the PC to the next instruction). It can provide a placeholder for later code,
    or act as a debugging aid. Here, it provides a space for the first instruction
    to land on. The ARM lacks a `nop`, and the assembler translates `nop` to `mov
    r0,r0`. Like `nop`, this instruction achieves nothing!'
  prefs: []
  type: TYPE_NORMAL
- en: '`ldr` r0`,=0xFFFFFFFF` is interesting. The assembler uses ARM’s `mvn` to invert
    the bits of the operand before moving them. If the operand is `0`, the bits moved
    will be all `1`s, which is exactly what we want.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Instruction 7 demonstrates another pseudo-operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The instruction requires a 32-bit literal, `0x11111111`, and that cannot be
    loaded as such. The compiler converts the instruction to a program counter-relative
    load from memory. The address is the current program counter, `0x0001007c`, plus
    the offset of `52` or `0x44`, plus the ARM PC’s 8-byte lead. At that target address,
    you will find the `0x11111111` constant stored.
  prefs: []
  type: TYPE_NORMAL
- en: '*Instruction 12* uses a similar pseudo-instruction. In this case, it’s to get
    the address in memory for the store multiple registers to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The code ends with `svc`, followed by the comment “*undefined*.” That’s because
    the disassembler tried to disassemble the data in memory, and it did not apply
    to a valid instruction.
  prefs: []
  type: TYPE_NORMAL
- en: Block moves and stack operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Figure 12**.2* to *Figure 12**.5* show the four variations of block move instructions
    in terms of the stack type. Recall that, in this text, I use only a *full descending*
    full stack mode, where the stack pointer points at the top of the stack and is
    decremented before a new item is added. The differences between these modes are
    the direction in which the stack grows (up or ascending and down or descending)
    and depend on whether the stack pointer points at the item at the top of the stack
    or the next free item on it. ARM’s literature uses four terms to describe stacks:'
  prefs: []
  type: TYPE_NORMAL
- en: FD    Full descending      *Figure 12**.2*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: FA     Full ascending      *Figure 12**.3*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ED    Empty descending   *Figure 12**.4*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: EA    Empty ascending    *Figure 12**.5*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Block moves improve the performance of code by loading or storing several registers
    with one instruction. They are also frequently used to save registers, before
    calling a subroutine and then restoring them after a return from it, as the following
    example demonstrates. In what follows, SP is the stack pointer – that is, `r13`
    (you can write either `r13` or sp in the ARM assembly language).
  prefs: []
  type: TYPE_NORMAL
- en: When used by load operations, the suffix is *increment after*. When used by
    store operations, the suffix is *decrement before*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.2 – One of ARM’s four stack modes – full descending (FD, IA load,
    and DB store)](img/Figure_12.03_B19624.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.2 – One of ARM’s four stack modes – full descending (FD, IA load,
    and DB store)
  prefs: []
  type: TYPE_NORMAL
- en: In a full descending stack, the stack pointer points at the item at the top
    of the stack (full), and when an item is added to the stack, the stack pointer
    is *decremented before* and when an item is removed, the stack is *incremented
    after*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consequently, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we can describe the instruction by either what it does (`db`
    or `ia`) or the type of stack (`fd`). It is rather unusual for assembly language
    designers to provide such options, and this is, initially, a little confusing.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.3 – One of ARM’s four stack modes – full ascending (FA, DA load,
    and IB store)](img/Figure_12.04_B19624.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.3 – One of ARM’s four stack modes – full ascending (FA, DA load, and
    IB store)
  prefs: []
  type: TYPE_NORMAL
- en: In a full ascending stack, the stack pointer points at the item at the top of
    the stack (full), and when an item is added to the stack, the stack pointer is
    *incremented before*. When an item is removed, the stack is *decremented after*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consequently, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 12.4 – One of ARM’s four stack modes – empty descending (ED, IB load,
    and DA store)](img/Figure_12.05_B19624.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.4 – One of ARM’s four stack modes – empty descending (ED, IB load,
    and DA store)
  prefs: []
  type: TYPE_NORMAL
- en: 'In an empty descending stack, the stack pointer points at the item above the
    top of the stack (empty), and when an item is added to the stack, the stack pointer
    is incremented after. When an item is removed, the stack is decremented before.
    Consequently, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 12.5 – One of ARM’s four stack modes – empty ascending (EA, DB load,
    and IA store)](img/Figure_12.06_B19624.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.5 – One of ARM’s four stack modes – empty ascending (EA, DB load,
    and IA store)
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the `fd` block move suffix to mean *full descending*. ARM lets you use
    two different naming conventions for block move instructions. You can write the
    pair `stmia` and `ldmdb`, or the pair `stmfd` and `ldmfd`; they are the same.
    Yes, it is confusing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the program counter is also a user-visible register, we can simplify
    the code by including the PC as one of the registers we save:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The link register with the return address is pushed onto the stack, and then
    at the end, we pull the saved registers, including the value of the return address
    that is placed in the PC, to return.
  prefs: []
  type: TYPE_NORMAL
- en: 'The block move provides a convenient means of copying data between memory regions.
    In the next example, we will copy 256 words from `pqr` to `xyz`. The block move
    instruction allows us to move eight registers at once, as the following code illustrates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This ends the section on Raspberry Pi and the ARM assembly language. In this
    book, you have learned how a computer works and what it does. We’ve examined instructions
    sets, their encoding, and their execution. In the last four chapters, we looked
    at high-performance architecture with an imaginative design.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you should be able to write your own programs.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the key data structures in computing is the stack, or the LIFO queue.
    A stack is a queue with only one end – that is, new items enter at the same end
    as items leave. This single end is called the **top of** **stack** (**TOS**).
  prefs: []
  type: TYPE_NORMAL
- en: The stack is important because it enables the mechanization of many computing
    processes, ranging from dealing with arithmetic expressions to translating languages.
    Here, we are interested in the stack as a means of ensuring that subroutines are
    called and returned from in a consistent, efficient, and fool-proof manner.
  prefs: []
  type: TYPE_NORMAL
- en: A subroutine is a piece of code that can be called (invoked) from any point
    in a program and a return made to the calling point. This action requires the
    management of return addresses, and the stack is eminently suitable because the
    sequence of return addresses is the inverse sequence of the calling addresses
    – that is, the same as the order of items pushed and pulled from a stack.
  prefs: []
  type: TYPE_NORMAL
- en: We have looked at the ARM’s branch and link instruction, `bl`, that can be used
    to call a subroutine without the overhead of the stack. However, using the branch
    with link a second time overwrites the return address in the link register, and
    you then have to use a stack to preserve previous addresses.
  prefs: []
  type: TYPE_NORMAL
- en: RISC computers, in principle, implement simple, one-cycle operations. The ARM
    has a very non-RISC like set of block-move instructions that allow you to move
    an entire group of instructions in a single operation. You can transfer up to
    16 registers to or from memory in one operation. The block move lets you pass
    parameters to and from a subroutine via the stack.
  prefs: []
  type: TYPE_NORMAL
- en: There are four standard stack implementations. The stack pointer can point either
    to the item at the top of the stack, or to the free space above that item. Similarly,
    the stack can grow (as items are added) toward low addresses or toward high addresses.
    This gives four possible arrangements. However, most computers implement a stack
    that points to the top item on it that grows toward low addresses.
  prefs: []
  type: TYPE_NORMAL
- en: An unusual feature of the ARM’s literature is that it has two naming conventions
    for stack organization. One convention uses the type of stack (pointing at the
    top or the next free item) and direction of the stack, whereas the other convention
    describes whether the stack is incremented/decremented before or after the operation
    – for example, `stm`ia `r0!,{r2-r6}` and `stm`ea `r0!,{r2-r6}` are identical operations.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we introduced the computer and demonstrated how it can be simulated
    with Python. By the end of [*Chapter 8*](B19624_08.xhtml#_idTextAnchor135), you
    should be able to design and simulate a computer instruction set, created to your
    own specification.
  prefs: []
  type: TYPE_NORMAL
- en: Following the design of a hypothetical teaching computer, we looked at Raspberry
    Pi and the ARM microprocessor at its heart. This provides an introduction to real
    computers. We described the ARM’s instruction set architecture, explained how
    it operates, and explained how to write ARM assembly language programs and debug
    them on Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: Having reached the end of this book, you might like to consider designing your
    own ARM simulator.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we wil provide some appendices to enable you to find some of the pieces
    of information you will need most frequently.
  prefs: []
  type: TYPE_NORMAL
