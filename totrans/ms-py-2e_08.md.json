["```py\n>>> class Spam(object):\n...     eggs = 'my eggs'\n\n>>> Spam = type('Spam', (object,), dict(eggs='my eggs')) \n```", "```py\n>>> class Spam(object):\n...     eggs = 'my eggs'\n\n>>> spam = Spam()\n>>> spam.eggs\n'my eggs'\n>>> type(spam)\n<class ' ...Spam'>\n>>> type(Spam)\n<class 'type'>\n\n>>> Spam = type('Spam', (object,), dict(eggs='my eggs'))\n\n>>> spam = Spam()\n>>> spam.eggs\n'my eggs'\n>>> type(spam)\n<class '...Spam'>\n>>> type(Spam)\n<class 'type'> \n```", "```py\nclass Spam(object):\n    pass \n```", "```py\nclass Spam(object, metaclass=type):\n    pass \n```", "```py\n# The metaclass definition, note the inheritance of type instead\n# of object\n>>> class MetaSandwich(type):\n...     # Notice how the __new__ method has the same arguments\n...     # as the type function we used earlier?\n...     def __new__(metaclass, name, bases, namespace):\n...         name = 'SandwichCreatedByMeta'\n...         bases = (int,) + bases\n...         namespace['lettuce'] = 1\n...         return type.__new__(metaclass, name, bases, namespace) \n```", "```py\n>>> class Sandwich(object):\n...     pass\n\n>>> Sandwich.__name__\n'Sandwich'\n>>> issubclass(Sandwich, int)\nFalse\n>>> Sandwich.lettuce\nTraceback (most recent call last):\n    ...\nAttributeError: type object 'Sandwich' has no attribute 'lettuce' \n```", "```py\n>>> class Sandwich(object, metaclass=MetaSandwich):\n...     pass\n\n>>> Sandwich.__name__\n'SandwichCreatedByMeta'\n>>> issubclass(Sandwich, int)\nTrue\n>>> Sandwich.lettuce\n1 \n```", "```py\n>>> class AddClassAttributeMeta(type):\n...     def __init__(metaclass, name, bases, namespace, **kwargs):\n...         # The kwargs should not be passed on to the\n...         # type.__init__\n...         type.__init__(metaclass, name, bases, namespace)\n...\n...     def __new__(metaclass, name, bases, namespace, **kwargs):\n...         for k, v in kwargs.items():\n...             # setdefault so we don't overwrite attributes\n...             namespace.setdefault(k, v)\n...\n...         return type.__new__(metaclass, name, bases, namespace)\n\n>>> class WithArgument(metaclass=AddClassAttributeMeta, a=1234):\n...     pass\n\n>>> WithArgument.a\n1234\n>>> with_argument = WithArgument()\n>>> with_argument.a\n1234 \n```", "```py\n>>> class AddClassAttribute:\n...     def __init_subclass__(cls, **kwargs):\n...         super().__init_subclass__()\n...\n...         for k, v in kwargs.items():\n...             setattr(cls, k, v)\n\n>>> class WithAttribute(metaclass=AddClassAttributeMeta, a=1234):\n...     pass\n\n>>> WithAttribute.a\n1234\n>>> with_attribute = WithAttribute()\n>>> with_attribute.a\n1234 \n```", "```py\n>>> class Meta(type):\n...     @property\n...     def some_property(cls):\n...         return 'property of %r' % cls\n...\n...     def some_method(self):\n...         return 'method of %r' % self\n\n>>> class SomeClass(metaclass=Meta):\n...     pass\n\n# Accessing through the class definition\n>>> SomeClass.some_property\n\"property of <class '...SomeClass'>\"\n>>> SomeClass.some_method\n<bound method Meta.some_method of <class '__main__.SomeClass'>>\n>>> SomeClass.some_method()\n\"method of <class '__main__.SomeClass'>\"\n\n# Accessing through an instance\n>>> some_class = SomeClass()\n>>> some_class.some_property\nTraceback (most recent call last):\n    ...\nAttributeError: 'SomeClass' object has no attribute 'some_property'\n>>> some_class.some_method\nTraceback (most recent call last):\n    ...\nAttributeError: 'SomeClass' object has no attribute 'some_method' \n```", "```py\n>>> import abc\n\n>>> class AbstractClass(metaclass=abc.ABCMeta):\n...     @abc.abstractmethod\n...     def some_method(self):\n...         raise NotImplemented()\n\n>>> class ConcreteClass(AbstractClass):\n...     pass\n\n>>> ConcreteClass()\nTraceback (most recent call last):\n    ...\nTypeError: Can't instantiate abstract class ConcreteClass with\nabstract methods some_method\n\n>>> class ImplementedConcreteClass(ConcreteClass):\n...     def some_method():\n...         pass\n\n>>> instance = ImplementedConcreteClass() \n```", "```py\n>>> import abc\n\n>>> class AbstractClass(object, metaclass=abc.ABCMeta):\n...     @property\n...     @abc.abstractmethod\n...     def some_property(self):\n...         raise NotImplemented()\n...\n...     @classmethod\n...     @abc.abstractmethod\n...     def some_classmethod(cls):\n...         raise NotImplemented()\n...\n...     @staticmethod\n...     @abc.abstractmethod\n...     def some_staticmethod():\n...         raise NotImplemented()\n...\n...     @abc.abstractmethod\n...     def some_method():\n...         raise NotImplemented() \n```", "```py\nsome_method.__isabstractmethod__ = True \n```", "```py\n>>> class AbstractMeta(type):\n...     def __new__(metaclass, name, bases, namespace):\n...         cls = super().__new__(metaclass, name, bases,\n...                               namespace)\n...         cls.__abstractmethods__ = frozenset(('something',))\n...         return cls\n\n>>> class ConcreteClass(metaclass=AbstractMeta):\n...     pass\n\n>>> ConcreteClass()\nTraceback (most recent call last):\n    ...\nTypeError: Can't instantiate abstract class ConcreteClass with \nabstract methods something \n```", "```py\n>>> import functools\n\n>>> class AbstractMeta(type):\n...     def __new__(metaclass, name, bases, namespace):\n...         # Create the class instance\n...         cls = super().__new__(metaclass, name, bases,\n...                               namespace)\n...\n...         # Collect all local methods marked as abstract\n...         abstracts = set()\n...         for k, v in namespace.items():\n...             if getattr(v, '__abstract__', False):\n...                 abstracts.add(k)\n...\n...         # Look for abstract methods in the base classes and\n...         # add them to the list of abstracts\n...         for base in bases:\n...             for k in getattr(base, '__abstracts__', ()):\n...                 v = getattr(cls, k, None)\n...                 if getattr(v, '__abstract__', False):\n...                     abstracts.add(k)\n...\n...         # Store the abstracts in a frozenset so they cannot be\n...         # modified\n...         cls.__abstracts__ = frozenset(abstracts)\n...\n...         # Decorate the __new__ function to check if all\n...         # abstract functions were implemented\n...         original_new = cls.__new__\n...         @functools.wraps(original_new)\n...         def new(self, *args, **kwargs):\n...             for k in self.__abstracts__:\n...                 v = getattr(self, k)\n...                 if getattr(v, '__abstract__', False):\n...                     raise RuntimeError(\n...                         '%r is not implemented' % k)\n...\n...             return original_new(self, *args, **kwargs)\n...\n...         cls.__new__ = new\n...         return cls\n\n# Create a decorator that sets the '__abstract__' attribute\n>>> def abstractmethod(function):\n...     function.__abstract__ = True\n...     return function \n```", "```py\n>>> class ConcreteClass(metaclass=AbstractMeta):\n...     @abstractmethod\n...     def some_method(self):\n...         pass\n\n# Instantiating the function, we can see that it functions as the\n# regular ABCMeta does\n>>> ConcreteClass()\nTraceback (most recent call last):\n    ...\nRuntimeError: 'some_method' is not implemented \n```", "```py\n>>> import abc\n\n>>> class CustomList(abc.ABC):\n...     '''This class implements a list-like interface'''\n\n>>> class CustomInheritingList(list, abc.ABC):\n...     '''This class implements a list-like interface'''\n\n>>> issubclass(list, CustomList)\nFalse\n>>> issubclass(list, CustomInheritingList)\nFalse\n\n>>> CustomList.register(list)\n<class 'list'>\n\n# We can't make it go both ways, however\n>>> CustomInheritingList.register(list)\nTraceback (most recent call last):\n    ...\nRuntimeError: Refusing to create an inheritance cycle\n\n>>> issubclass(list, CustomList)\nTrue\n>>> issubclass(list, CustomInheritingList)\nFalse\n\n# We need to inherit list to make it work the other way around\n>>> issubclass(CustomList, list)\nFalse\n>>> isinstance(CustomList(), list)\nFalse\n>>> issubclass(CustomInheritingList, list)\nTrue\n>>> isinstance(CustomInheritingList(), list)\nTrue \n```", "```py\n>>> import abc\n\n>>> class UniversalClass(abc.ABC):\n...    @classmethod\n...    def __subclasshook__(cls, subclass):\n...        return True\n\n>>> issubclass(list, UniversalClass)\nTrue\n>>> issubclass(bool, UniversalClass)\nTrue\n>>> isinstance(True, UniversalClass)\nTrue\n>>> issubclass(UniversalClass, bool)\nFalse \n```", "```py\n>>> import abc\n\n>>> class Plugins(abc.ABCMeta):\n...     plugins = dict()\n...\n...     def __new__(metaclass, name, bases, namespace):\n...         cls = abc.ABCMeta.__new__(metaclass, name, bases,\n...                                   namespace)\n...         if isinstance(cls.name, str):\n...             metaclass.plugins[cls.name] = cls\n...         return cls\n...\n...     @classmethod\n...     def get(cls, name):\n...         return cls.plugins[name]\n\n>>> class PluginBase(metaclass=Plugins):\n...     @property\n...     @abc.abstractmethod\n...     def name(self):\n...         raise NotImplemented()\n\n>>> class PluginA(PluginBase):\n...     name = 'a'\n\n>>> class PluginB(PluginBase):\n...     name = 'b'\n\n>>> Plugins.get('a')\n<class '...PluginA'>\n\n>>> Plugins.plugins\n{'a': <class '...PluginA'>,\n 'b': <class '...PluginB'>} \n```", "```py\n# plugins/__init__.py\nfrom .base import Plugin\nfrom .base import Plugins\n\n__all__ = ['Plugin', 'Plugins'] \n```", "```py\n# plugins/base.py\nimport abc\n\nclass Plugins(abc.ABCMeta):\n    plugins = dict()\n\n    def __new__(metaclass, name, bases, namespace):\n        cls = abc.ABCMeta.__new__(\n            metaclass, name, bases, namespace)\n        metaclass.plugins[name.lower()] = cls\n        return cls\n\n    @classmethod\n    def get(cls, name):\n        return cls.plugins[name]\n\nclass Plugin(metaclass=Plugins):\n    pass \n```", "```py\nfrom . import base\n\nclass A(base.Plugin):\n    pass \n```", "```py\nimport importlib\n\n# Plugins class omitted for brevity\nclass PluginsOnDemand(Plugins):\n    @classmethod\n    def get(cls, name):\n        if name not in cls.plugins:\n            print('Loading plugins from plugins.%s' % name)\n            importlib.import_module('plugins.%s' % name)\n        return cls.plugins[name] \n```", "```py\nimport plugins\n\nprint(plugins.PluginsOnDemand.get('a'))\nprint(plugins.PluginsOnDemand.get('a')) \n```", "```py\nLoading plugins from plugins.a\n<class 'plugins.a.A'>\n<class 'plugins.a.A'> \n```", "```py\n# PluginsOnDemand class omitted for brevity\nclass PluginsThroughConfiguration(PluginsOnDemand):\n    @classmethod\n    def load(cls, *plugin_names):\n        for plugin_name in plugin_names:\n            cls.get(plugin_name) \n```", "```py\nimport plugins\n\nplugins.PluginsThroughConfiguration.load(\n    'a',\n    'b',\n)\n\nprint('After load')\nprint(plugins.PluginsThroughConfiguration.get('a'))\nprint(plugins.PluginsThroughConfiguration.get('a')) \n```", "```py\nLoading plugins from plugins.a\nLoading plugins from plugins.b\nAfter load\n<class 'plugins.a.A'>\n<class 'plugins.a.A'> \n```", "```py\nimport re\nimport pathlib\nimport importlib\n\nCURRENT_FILE = pathlib.Path(__file__)\nPLUGINS_DIR = CURRENT_FILE.parent\nMODULE_NAME_RE = re.compile('[a-z][a-z0-9_]*', re.IGNORECASE)\n\nclass PluginsThroughFilesystem(PluginsThroughConfiguration):\n    @classmethod\n    def autoload(cls):\n        for filename in PLUGINS_DIR.glob('*.py'):\n            # Skip __init__.py and other non-plugin files\n            if not MODULE_NAME_RE.match(filename.stem):\n                continue\n                cls.get(filename.stem)\n\n            # Skip this file\n            if filename == CURRENT_FILE:\n                continue\n\n            # Load the plugin\n            cls.get(filename.stem) \n```", "```py\nimport pprint\nimport plugins\n\nplugins.PluginsThroughFilesystem.autoload()\n\nprint('After load')\npprint.pprint(plugins.PluginsThroughFilesystem.plugins) \n```", "```py\nLoading plugins from plugins.a\nLoading plugins from plugins.b\nAfter load\n{'a': <class 'plugins.a.A'>,\n 'b': <class 'plugins.b.B'>,\n 'plugin': <class 'plugins.base.Plugin'>} \n```", "```py\nimport inspect\n\nclass Dataclass(type):\n    def _get_signature(namespace):\n        # Get the annotations from the class\n        annotations = namespace.get('__annotations__', dict())\n\n        # Signatures are immutable so we need to build the\n        # parameter list before creating the signature\n        parameters = []\n        for name, annotation in annotations.items():\n\n            # Create Parameter shortcut for readability\n            Parameter = inspect.Parameter\n            # Create the parameter with the correct type\n            # annotation and default. You could also choose to\n            # make the arguments keyword/positional only here\n            parameters.append(Parameter(\n                name=name,\n                kind=Parameter.POSITIONAL_OR_KEYWORD,\n                default=namespace.get(name, Parameter.empty),\n                annotation=annotation,\n            ))\n\n        return inspect.Signature(parameters)\n\n    def _create_init(namespace, signature):\n        # If init exists we don't need to do anything\n        if '__init__' in namespace:\n            return\n\n        # Create the __init__ method and use the signature to\n        # process the arguments\n        def __init__(self, *args, **kwargs):\n            bound = signature.bind(*args, **kwargs)\n            bound.apply_defaults()\n\n            for key, value in bound.arguments.items():\n                # Convert to the annotation to enforce types\n                parameter = signature.parameters[key]\n                # Set the casted value\n                setattr(self, key, parameter.annotation(value))\n\n        # Override the signature for __init__ so help() works\n        __init__.__signature__ = signature\n\n        namespace['__init__'] = __init__\n\n    def _create_repr(namespace, signature):\n        def __repr__(self):\n            arguments = []\n            for key, value in vars(self).items():\n                arguments.append(f'{key}={value!r}')\n            arguments = ', '.join(arguments)\n            return f'{self.__class__.__name__}({arguments})'\n\n        namespace['__repr__'] = __repr__\n\n    def __new__(metaclass, name, bases, namespace):\n        signature = metaclass._get_signature(namespace)\n        metaclass._create_init(namespace, signature)\n        metaclass._create_repr(namespace, signature)\n\n        cls = super().__new__(metaclass, name, bases, namespace)\n\n        return cls \n```", "```py\n>>> from T_10_dataclasses import Dataclass\n\n>>> class Sandwich(metaclass=Dataclass):\n...     spam: int\n...     eggs: int = 3\n\n>>> Sandwich(1, 2)\nSandwich(spam=1, eggs=2)\n\n>>> sandwich = Sandwich(4)\n>>> sandwich\nSandwich(spam=4, eggs=3)\n>>> sandwich.eggs\n3\n\n>>> help(Sandwich.__init__)\nHelp on function __init__ in ...\n<BLANKLINE>\n__init__(spam: int, eggs: int = 3)\n<BLANKLINE>\n\n>>> Sandwich('a')\nTraceback (most recent call last):\n    ...\nValueError: invalid literal for int() with base 10: 'a'\n>>> Sandwich('1234', 56.78)\nSandwich(spam=1234, eggs=56) \n```", "```py\nexec(body, globals(), namespace) \n```", "```py\n>>> import functools\n\n>>> def decorator(name):\n...     def _decorator(cls):\n...         @functools.wraps(cls)\n...         def __decorator(*args, **kwargs):\n...             print('decorator(%s)' % name)\n...             return cls(*args, **kwargs)\n...\n...         return __decorator\n...\n...     return _decorator\n\n>>> class SpamMeta(type):\n...     @decorator('SpamMeta.__init__')\n...     def __init__(self, name, bases, namespace, **kwargs):\n...         print('SpamMeta.__init__()')\n...         return type.__init__(self, name, bases, namespace)\n...\n...     @staticmethod\n...     @decorator('SpamMeta.__new__')\n...     def __new__(cls, name, bases, namespace, **kwargs):\n...         print('SpamMeta.__new__()')\n...         return type.__new__(cls, name, bases, namespace)\n...\n...     @classmethod\n...     @decorator('SpamMeta.__prepare__')\n...     def __prepare__(cls, names, bases, **kwargs):\n...         print('SpamMeta.__prepare__()')\n...         namespace = dict(spam=5)\n...         return namespace \n```", "```py\n>>> @decorator('Spam')\n... class Spam(metaclass=SpamMeta):\n...     @decorator('Spam.__init__')\n...     def __init__(self, eggs=10):\n...         print('Spam.__init__()')\n...         self.eggs = eggs\ndecorator(SpamMeta.__prepare__)\nSpamMeta.__prepare__()\ndecorator(SpamMeta.__new__)\nSpamMeta.__new__()\ndecorator(SpamMeta.__init__)\nSpamMeta.__init__()\n\n# Testing with the class object\n>>> spam = Spam\n>>> spam.spam\n5\n>>> spam.eggs\nTraceback (most recent call last):\n  ...\n  File \"<doctest T_11_order_of_operations.rst[6]>\", line 1, in ...\nAttributeError: 'function' object has no attribute 'eggs'\n\n# Testing with a class instance\n>>> spam = Spam()\ndecorator(Spam)\ndecorator(Spam.__init__)\nSpam.__init__()\n>>> spam.spam\n5\n>>> spam.eggs\n10 \n```", "```py\n>>> import itertools\n\n>>> class Field(object):\n...     counter = itertools.count()\n...\n...     def __init__(self, name=None):\n...         self.name = name\n...         self.index = next(Field.counter)\n...\n...     def __repr__(self):\n...         return '<%s[%d] %s>' % (\n...             self.__class__.__name__,\n...             self.index,\n...             self.name,\n...         )\n\n>>> class FieldsMeta(type):\n...     def __new__(metaclass, name, bases, namespace):\n...         cls = type.__new__(metaclass, name, bases, namespace)\n...         fields = []\n...         for k, v in namespace.items():\n...             if isinstance(v, Field):\n...                 fields.append(v)\n...                 v.name = v.name or k\n...\n...         cls.fields = sorted(fields, key=lambda f: f.index)\n...         return cls\n\n>>> class Fields(metaclass=FieldsMeta):\n...     spam = Field()\n...     eggs = Field()\n\n>>> Fields.fields\n[<Field[0] spam>, <Field[1] eggs>]\n\n>>> fields = Fields()\n>>> fields.eggs.index\n1\n>>> fields.spam.index\n0\n>>> fields.fields\n[<Field[0] spam>, <Field[1] eggs>] \n```", "```py\n>>> import collections\n\n>>> class Field(object):\n...     def __init__(self, name=None):\n...         self.name = name\n...\n...     def __repr__(self):\n...         return '<%s %s>' % (\n...             self.__class__.__name__,\n...             self.name,\n...         )\n\n>>> class FieldsMeta(type):\n...     @classmethod\n...     def __prepare__(metaclass, name, bases):\n...         return collections.OrderedDict()\n...\n...     def __new__(metaclass, name, bases, namespace):\n...         cls = type.__new__(metaclass, name, bases, namespace)\n...         cls.fields = []\n...         for k, v in namespace.items():\n...             if isinstance(v, Field):\n...                 cls.fields.append(v)\n...                 v.name = v.name or k\n...\n...         return cls\n\n>>> class Fields(metaclass=FieldsMeta):\n...     spam = Field()\n...     eggs = Field()\n\n>>> Fields.fields\n[<Field spam>, <Field eggs>]\n>>> fields = Fields()\n>>> fields.fields\n[<Field spam>, <Field eggs>] \n```", "```py\n    class SomeClass(metaclass=WrappingMeta, wrapper=some_wrapper): \n    ```"]