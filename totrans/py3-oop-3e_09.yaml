- en: The Iterator Pattern
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代器模式
- en: 'We''ve discussed how many of Python''s built-ins and idioms seem, at first
    blush, to fly in the face of object-oriented principles, but are actually providing
    access to real objects under the hood. In this chapter, we''ll discuss how the
    `for` loop, which seems so structured, is actually a lightweight wrapper around
    a set of object-oriented principles. We''ll also see a variety of extensions to
    this syntax that automatically create even more types of object. We will cover
    the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了Python的许多内置函数和惯用法乍一看似乎与面向对象原则相悖，但实际上是在底层提供对真实对象的访问。在本章中，我们将讨论看似结构化的`for`循环实际上是如何围绕一组面向对象原则的轻量级包装。我们还将看到对这个语法的各种扩展，这些扩展可以自动创建更多类型的对象。我们将涵盖以下主题：
- en: What design patterns are
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是设计模式
- en: The iterator protocol—one of the most powerful design patterns
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代器协议——最强大的设计模式之一
- en: List, set, and dictionary comprehensions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表、集合和字典推导式
- en: Generators and coroutines
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成器和协程
- en: Design patterns in brief
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简要介绍设计模式
- en: When engineers and architects decide to build a bridge, or a tower, or a building,
    they follow certain principles to ensure structural integrity. There are various
    possible designs for bridges (suspension and cantilever, for example), but if
    the engineer doesn't use one of the standard designs, and doesn't have a brilliant
    new design, it is likely the bridge he/she designs will collapse.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当工程师和建筑师决定建造一座桥梁、一座塔或一座建筑时，他们会遵循某些原则以确保结构完整性。桥梁（例如，悬索桥和悬臂桥）有各种可能的设计，但如果工程师不使用标准设计，也没有一个出色的全新设计，那么他/她设计的桥梁很可能会倒塌。
- en: Design patterns are an attempt to bring this same formal definition for correctly
    designed structures to software engineering. There are many different design patterns
    to solve different general problems. Design patterns typically solve a specific
    common problem faced by developers in some specific situation. The design pattern
    is then a suggestion as to the ideal solution for that problem, in terms of object-oriented
    design.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '设计模式试图将这种对正确设计的正式定义应用到软件工程中。有许多不同的设计模式来解决不同的普遍问题。设计模式通常解决开发者在某些特定情况下面临的具体常见问题。设计模式随后是对该问题的理想解决方案的建议，从面向对象设计的角度来说。 '
- en: Knowing a design pattern and choosing to use it in our software does not, however,
    guarantee that we are creating a *correct* solution. In 1907, the Québec Bridge
    (to this day, the longest cantilever bridge in the world) collapsed before construction
    was completed, because the engineers who designed it grossly underestimated the
    weight of the steel used to construct it. Similarly, in software development,
    we may incorrectly choose or apply a design pattern, and create software that
    *collapses* under normal operating situations or when stressed beyond its original
    design limits.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，了解设计模式并选择在我们的软件中使用它并不能保证我们正在创建一个*正确*的解决方案。1907年，魁北克桥（至今仍是世界上最长的悬臂桥）在建设完成前就倒塌了，因为设计它的工程师们极大地低估了用于建造它的钢材重量。同样，在软件开发中，我们可能会错误地选择或应用设计模式，并创建出在正常操作情况下或在超出原始设计极限的压力下会*崩溃*的软件。
- en: Any one design pattern proposes a set of objects interacting in a specific way
    to solve a general problem. The job of the programmer is to recognize when they
    are facing a specific version of such a problem, then to choose and adapt the
    general design in their precise needs.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 任何一种设计模式都提出了一组以特定方式交互的对象，以解决一个普遍问题。程序员的任务是识别他们面临的是这种问题的特定版本，然后选择并调整通用设计以适应他们的精确需求。
- en: In this chapter, we'll be covering the iterator design pattern. This pattern
    is so powerful and pervasive that the Python developers have provided multiple
    syntaxes to access the object-oriented principles underlying the pattern. We will
    be covering other design patterns in the next two chapters. Some of them have
    language support and some don't, but none of them is so intrinsically a part of
    the Python coder's daily life as the iterator pattern.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍迭代器设计模式。这个模式非常强大且普遍，以至于Python开发者提供了多种语法来访问模式背后的面向对象原则。我们将在下一章中介绍其他设计模式。其中一些有语言支持，而另一些则没有，但没有任何一个模式像迭代器模式那样内在地成为Python程序员日常生活的组成部分。
- en: Iterators
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代器
- en: 'In typical design pattern parlance, an iterator is an object with a `next()`
    method and a `done()` method; the latter returns `True` if there are no items
    left in the sequence. In a programming language without built-in support for iterators,
    the iterator would be looped over like this:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的设计模式术语中，迭代器是一个具有 `next()` 方法和 `done()` 方法的对象；后者如果序列中没有剩余的项目则返回 `True`。在没有内置迭代器支持的编程语言中，迭代器会被像这样遍历：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In Python, iteration is a special feature, so the method gets a special name,
    `__next__`. This method can be accessed using the `next(iterator)` built-in. Rather
    than a `done` method, Python's iterator protocol raises `StopIteration` to notify
    the loop that it has completed. Finally, we have the much more readable `foriteminiterator`
    syntax to actually access items in an iterator instead of messing around with
    a `while` loop. Let's look at these in more detail.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，迭代是一个特殊特性，因此该方法有一个特殊名称，即 `__next__`。此方法可以通过 `next(iterator)` 内置函数访问。而不是
    `done` 方法，Python 的迭代器协议通过抛出 `StopIteration` 来通知循环它已经完成。最后，我们有更易读的 `for item in
    iterator` 语法来实际访问迭代器中的项目，而不是在 `while` 循环中纠缠不清。让我们更详细地看看这些。
- en: The iterator protocol
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代器协议
- en: The `Iterator` abstract base class, in the `collections.abc` module, defines
    the iterator protocol in Python. As mentioned, it must have a `__next__` method
    that the `for` loop (and other features that support iteration) can call to get
    a new element from the sequence. In addition, every iterator must also fulfill
    the `Iterable` interface. Any class that provides an `__iter__` method is iterable.
    That method must return an `Iterator` instance that will cover all the elements
    in that class.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`Iterator` 抽象基类，位于 `collections.abc` 模块中，定义了 Python 中的迭代协议。正如之前提到的，它必须有一个 `__next__`
    方法，`for` 循环（以及其他支持迭代的特性）可以通过调用该方法从序列中获取新的元素。此外，每个迭代器还必须满足 `Iterable` 接口。任何提供了
    `__iter__` 方法的类都是可迭代的。该方法必须返回一个将覆盖该类中所有元素的 `Iterator` 实例。'
- en: 'This might sound a bit confusing, so have a look at the following example,
    but note that this is a very verbose way to solve this problem. It clearly explains
    iteration and the two protocols in question, but we''ll be looking at several
    more readable ways to get this effect later in this chapter:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能听起来有些令人困惑，所以请看一下下面的示例，但请注意，这是一种非常冗长的解决问题的方式。它清楚地解释了迭代和相关的两个协议，但我们在本章后面将探讨几种更易读的方式来实现这一效果：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This example defines an `CapitalIterable` class whose job is to loop over each
    of the words in a string and output them with the first letter capitalized. Most
    of the work of that iterable is passed to the `CapitalIterator` implementation.
    The canonical way to interact with this iterator is as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例定义了一个 `CapitalIterable` 类，其任务是遍历字符串中的每个单词，并将它们以首字母大写的方式输出。该可迭代对象的大部分工作都传递给了
    `CapitalIterator` 实现。与这个迭代器交互的规范方式如下：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This example first constructs an iterable and retrieves an iterator from it.
    The distinction may need explanation; the iterable is an object with elements
    that can be looped over. Normally, these elements can be looped over multiple
    times, maybe even at the same time or in overlapping code. The iterator, on the
    other hand, represents a specific location in that iterable; some of the items
    have been consumed and some have not. Two different iterators might be at different
    places in the list of words, but any one iterator can mark only one place.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例首先构建了一个可迭代对象，并从中检索了一个迭代器。这种区别可能需要解释；可迭代对象是一个具有可以遍历的元素的对象。通常，这些元素可以被多次遍历，甚至可能在同一时间或重叠的代码中。另一方面，迭代器代表可迭代对象中的特定位置；一些项目已经被消耗，而一些还没有。两个不同的迭代器可能在单词列表的不同位置，但任何一个迭代器只能标记一个位置。
- en: Each time `next()` is called on the iterator, it returns another token from
    the iterable, in order. Eventually, the iterator will be exhausted (won't have
    any more elements to return), in which case `Stopiteration` is raised, and we
    break out of the loop.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 每次在迭代器上调用 `next()` 时，它都会按顺序返回可迭代对象中的另一个标记。最终，迭代器将会耗尽（没有更多元素可以返回），在这种情况下，会抛出
    `Stopiteration` 异常，然后我们退出循环。
- en: 'Of course, we already know a much simpler syntax for constructing an iterator
    from an iterable:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们已经有了一种更简单的语法来从可迭代对象中构建迭代器：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, the `for` statement, in spite of not looking remotely object-oriented,
    is actually a shortcut to some obviously object-oriented design principles. Keep
    this in mind as we discuss comprehensions, as they, too, appear to be the polar
    opposite of an object-oriented tool. Yet, they use the exact same iteration protocol
    as `for` loops and are just another kind of shortcut.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，尽管`for`语句看起来并不像面向对象，但实际上它是某些显然面向对象设计原则的快捷方式。在我们讨论理解时，请记住这一点，因为它们也似乎与面向对象工具完全相反。然而，它们使用与`for`循环完全相同的迭代协议，只是另一种快捷方式。
- en: Comprehensions
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解
- en: Comprehensions are simple, but powerful, syntaxes that allow us to transform
    or filter an iterable object in as little as one line of code. The resultant object
    can be a perfectly normal list, set, or dictionary, or it can be a generator expression
    that can be efficiently consumed while keeping just one element in memory at a
    time.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 理解是简单但强大的语法，允许我们在一行代码中转换或过滤可迭代对象。结果对象可以是一个完全正常的列表、集合或字典，或者它可以是生成器表达式，可以在保持一次只保留一个元素在内存中的同时高效地消费。
- en: List comprehensions
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表理解
- en: List comprehensions are one of the most powerful tools in Python, so people
    tend to think of them as advanced. They're not. Indeed, I've taken the liberty
    of littering previous examples with comprehensions, assuming you would understand
    them. While it's true that advanced programmers use comprehensions a lot, it's
    not because they're advanced. It's because they're trivial, and handle some of
    the most common operations in software development.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 列表理解是Python中最强大的工具之一，因此人们倾向于认为它们是高级的。实际上并非如此。实际上，我已经在之前的例子中随意使用了理解，假设你会理解它们。虽然高级程序员确实经常使用理解，但这并不是因为它们是高级的。这是因为它们很简单，并且处理软件开发中最常见的操作。
- en: 'Let''s have a look at one of those common operations; namely, converting a
    list of items into a list of related items. Specifically, let''s assume we just
    read a list of strings from a file, and now we want to convert it to a list of
    integers. We know every item in the list is an integer, and we want to do some
    activity (say, calculate an average) on those numbers. Here''s one simple way
    to approach it:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看那些常见的操作之一；即，将一个项目的列表转换为相关项目的列表。具体来说，假设我们刚刚从一个文件中读取了一个字符串列表，现在我们想要将其转换为整数列表。我们知道列表中的每个项目都是一个整数，我们想要对这些数字进行一些操作（比如，计算平均值）。这里有简单的一种方法来处理它：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This works fine and it''s only three lines of code. If you aren''t used to
    comprehensions, you may not even think it looks ugly! Now, look at the same code
    using a list comprehension:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这工作得很好，而且只有三行代码。如果你不习惯使用理解，你可能甚至不会觉得它看起来很丑！现在，看看使用列表理解的相同代码：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We're down to one line and, importantly for performance, we've dropped an `append`
    method call for each item in the list. Overall, it's pretty easy to tell what's
    going on, even if you're not used to comprehension syntax.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只剩下一行，并且对于性能来说非常重要，我们已经为列表中的每个项目省略了`append`方法调用。总的来说，即使你不习惯理解语法，也很容易看出发生了什么。
- en: The square brackets indicate, as always, that we're creating a list. Inside
    this list is a `for` loop that iterates over each item in the input sequence.
    The only thing that may be confusing is what's happening between the list's opening
    brace and the start of the `for` loop. Whatever happens here is applied to *each*
    of the items in the input list. The item in question is referenced by the `num`
    variable from the loop. So, it's calling the `int` function for each element and
    storing the resulting integer in the new list.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 方括号，一如既往地表示我们正在创建一个列表。在这个列表内部有一个`for`循环，它会遍历输入序列中的每个项目。可能让人困惑的是列表开括号和`for`循环开始之间发生了什么。这里发生的任何操作都会应用到输入列表中的每个项目上。当前的项目通过循环中的`num`变量来引用。因此，它为每个元素调用`int`函数，并将结果整数存储在新列表中。
- en: That's all there is to a basic list comprehension. Comprehensions are highly
    optimized C code; list comprehensions are far faster than `for` loops when looping
    over a large number of items. If readability alone isn't a convincing reason to
    use them as much as possible, speed should be.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 基本列表理解就是这样。理解是高度优化的C代码；列表理解在遍历大量项目时比`for`循环要快得多。如果仅仅从可读性来看不足以说服你尽可能多地使用它们，那么速度应该可以。
- en: 'Converting one list of items into a related list isn''t the only thing we can
    do with a list comprehension. We can also choose to exclude certain values by
    adding an `if` statement inside the comprehension. Have a look:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个项目列表转换为相关列表并不是列表推导所能做的唯一事情。我们还可以选择通过在推导中添加一个`if`语句来排除某些值。看看这个例子：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: All that's different between this example and the previous one is the `if len(num)
    < 3` part. This extra code excludes any strings with more than two characters.
    The `if` statement is applied to each element **before** the `int` function, so
    it's testing the length of a string. Since our input strings are all integers
    at heart, it excludes any number over 99.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 与前一个例子相比，唯一不同的是`if len(num) < 3`这部分。这段额外的代码排除了任何超过两个字符的字符串。`if`语句是在`int`函数**之前**应用于每个元素的，因此它是在测试字符串的长度。由于我们的输入字符串本质上都是整数，所以它排除了任何大于99的数字。
- en: List comprehensions are used to map input values to output values, applying
    a filter along the way to include or exclude any values that meet a specific condition.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 列表推导用于将输入值映射到输出值，同时在过程中应用一个过滤器来包含或排除任何满足特定条件的值。
- en: 'Any iterable can be the input to a list comprehension. In other words, anything
    we can wrap in a `for` loop can also be placed inside a comprehension. For example,
    text files are iterable; each call to `__next__` on the file''s iterator will
    return one line of the file. We could load a tab-delimited file where the first
    line is a header row into a dictionary using the `zip` function:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 任何可迭代对象都可以作为列表推导的输入。换句话说，我们可以将任何可以放在`for`循环中的东西也放在推导中。例如，文本文件是可迭代的；文件迭代器的每次`__next__`调用都会返回文件的一行。我们可以使用`zip`函数将带有标题行的制表符分隔文件加载到字典中：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This time, I've added some whitespace to make it more readable (list comprehensions
    don't *have* to fit on one line). This example creates a list of dictionaries
    from the zipped header and split lines for each line in the file.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我添加了一些空白，使其更易于阅读（列表推导**不**一定要放在一行上）。这个例子创建了一个从文件中每个行的压缩标题和分割行生成的字典列表。
- en: Er, what? Don't worry if that code or explanation doesn't make sense; it's confusing.
    One list comprehension is doing a pile of work here, and the code is hard to understand,
    read, and ultimately, maintain. This example shows that list comprehensions aren't
    always the best solution; most programmers would agree that a `for` loop would
    be more readable than this version.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 哎，什么？如果这段代码或解释让你感到困惑，请不要担心；它确实很复杂。一个列表推导在这里做了很多工作，代码难以理解、阅读，最终也难以维护。这个例子表明列表推导并不总是最佳解决方案；大多数程序员都会同意使用`for`循环比这个版本更易读。
- en: 'Remember: the tools we are provided with should not be abused! Always pick
    the right tool for the job, which is always to write maintainable code.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 记住：我们提供的工具不应该被滥用！始终选择适合工作的正确工具，那就是始终编写可维护的代码。
- en: Set and dictionary comprehensions
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合和字典推导
- en: Comprehensions aren't restricted to lists. We can use a similar syntax with
    braces to create sets and dictionaries as well. Let's start with sets. One way
    to create a set is to wrap a list comprehension in the `set()` constructor, which
    converts it to a set. But why waste memory on an intermediate list that gets discarded,
    when we can create a set directly?
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 推导不仅限于列表。我们还可以使用类似的大括号语法来创建集合和字典。让我们从集合开始。创建集合的一种方法是将列表推导包裹在`set()`构造函数中，将其转换为集合。但为什么要在被丢弃的中间列表上浪费内存，当我们可以直接创建集合时？
- en: 'Here''s an example that uses a named tuple to model author/title/genre triads,
    and then retrieves a set of all the authors that write in a specific genre:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个使用命名元组来模拟作者/标题/类型三元组的例子，然后检索特定类型的所有作者集合：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The highlighted set comprehension sure is short in comparison to the demo-data
    setup! If we were to use a list comprehension, of course, Terry Pratchett would
    have been listed twice. As it is, the nature of sets removes the duplicates, and
    we end up with the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 与演示数据的设置相比，高亮的集合推导确实要短得多！如果我们使用列表推导，当然，特里·普拉切特会被列出两次。但事实上，集合的性质消除了重复项，我们最终得到以下结果：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Still using braces, we can introduce a colon to create a dictionary comprehension.
    This converts a sequence into a dictionary using *key:value* pairs. For example,
    it may be useful to quickly look up the author or genre in a dictionary if we
    know the title. We can use a dictionary comprehension to map titles to `books`
    objects:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然使用大括号，我们可以通过添加冒号来创建字典推导式。这会将序列转换为使用*键:值*对的字典。例如，如果我们知道标题，快速查找作者或类型可能很有用。我们可以使用字典推导式将标题映射到`books`对象：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, we have a dictionary, and can look up books by title using the normal syntax.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个字典，并且可以使用正常语法通过标题查找书籍。
- en: In summary, comprehensions are not advanced Python, nor are they *non-object-oriented* tools
    that should be avoided. They are simply a more concise and optimized syntax for
    creating a list, set, or dictionary from an existing sequence.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，列表推导不是高级Python，也不是应该避免的*非面向对象*工具。它们只是从现有序列创建列表、集合或字典的更简洁和优化的语法。
- en: Generator expressions
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成器表达式
- en: Sometimes we want to process a new sequence without pulling a new list, set,
    or dictionary into system memory. If we're just looping over items one at a time,
    and don't actually care about having a complete container (such as a list or dictionary)
    created, creating that container is a waste of memory. When processing one item
    at a time, we only need the current object available in memory at any one moment.
    But when we create a container, all the objects have to be stored in that container
    before we start processing them.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们想要处理一个新的序列，而不需要将新的列表、集合或字典拉入系统内存。如果我们只是逐个遍历项目，并且实际上不关心创建一个完整的容器（如列表或字典），那么创建该容器就是浪费内存。在逐个处理项目时，我们只需要在任何时刻内存中可用的当前对象。但是，当我们创建一个容器时，所有对象都必须在开始处理之前存储在该容器中。
- en: 'For example, consider a program that processes log files. A very simple log
    might contain information in this format:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个处理日志文件的程序。一个非常简单的日志可能包含以下格式的信息：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Log files for popular web servers, databases, or email servers can contain many
    gigabytes of data (I once had to clean nearly 2 terabytes of logs off a misbehaving
    system). If we want to process each line in the log, we can't use a list comprehension;
    it would create a list containing every line in the file. This probably wouldn't
    fit in RAM and could bring the computer to its knees, depending on the operating
    system.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 流行网络服务器、数据库或电子邮件服务器的日志文件可以包含许多GB的数据（我曾经不得不从一个行为不端的系统中清理近2TB的日志）。如果我们想要处理日志中的每一行，我们不能使用列表推导；它将创建一个包含文件中每一行的列表。这可能不会适合RAM，并且可能会根据操作系统使计算机瘫痪。
- en: If we used a `for` loop on the log file, we could process one line at a time
    before reading the next one into memory. Wouldn't be nice if we could use comprehension
    syntax to get the same effect?
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在日志文件上使用`for`循环，我们可以逐行处理，在将下一行读入内存之前。如果我们可以使用推导式语法达到相同的效果，那岂不是很好？
- en: This is where generator expressions come in. They use the same syntax as comprehensions,
    but they don't create a final container object. To create a generator expression,
    wrap the comprehension in `()` instead of `[]` or `{}`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是生成器表达式发挥作用的地方。它们使用与推导式相同的语法，但不会创建一个最终的容器对象。要创建一个生成器表达式，将推导式用`()`括起来而不是`[]`或`{}`。
- en: 'The following code parses a log file in the previously presented format and
    outputs a new log file that contains only the `WARNING` lines:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码解析了之前展示格式的日志文件，并输出一个只包含`WARNING`行的新的日志文件：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This program takes the two filenames on the command line, uses a generator
    expression to filter out the warnings (in this case, it uses the `if` syntax and
    leaves the line unmodified), and then outputs the warnings to another file. If
    we run it on our sample file, the output looks like this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序接受命令行上的两个文件名，使用生成器表达式过滤掉警告（在这种情况下，它使用`if`语法并保留行不变），然后将警告输出到另一个文件。如果我们运行它在我们提供的样本文件上，输出看起来像这样：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Of course, with such a short input file, we could have safely used a list comprehension,
    but if the file is millions of lines long, the generator expression will have
    a huge impact on both memory and speed.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，对于如此短的输入文件，我们可以安全地使用列表推导，但如果文件有数百万行长，生成器表达式将对内存和速度产生巨大影响。
- en: Wrapping a `for` expression in parenthesis creates a generator expression, not
    a tuple.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 将`for`表达式用括号括起来创建的是一个生成器表达式，而不是一个元组。
- en: Generator expressions are frequently most useful inside function calls. For
    example, we can call `sum`, `min`, or `max` on a generator expression instead
    of a list, since these functions process one object at a time. We're only interested
    in the aggregate result, not any intermediate container.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器表达式通常在函数调用中非常有用。例如，我们可以对生成器表达式调用 `sum`、`min` 或 `max` 而不是列表，因为这些函数一次处理一个对象。我们只对聚合结果感兴趣，而不是任何中间容器。
- en: In general, of the four options, a generator expression should be used whenever
    possible. If we don't actually need a list, set, or dictionary, but simply need
    to filter or convert items in a sequence, a generator expression will be most
    efficient. If we need to know the length of a list, or sort the result, remove
    duplicates, or create a dictionary, we'll have to use the comprehension syntax.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，在四个选项中，只要可能就应该使用生成器表达式。如果我们实际上不需要列表、集合或字典，但只需要过滤或转换序列中的项，生成器表达式将是最有效的。如果我们需要知道列表的长度，或者对结果进行排序、删除重复项或创建字典，我们就必须使用理解语法。
- en: Generators
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成器
- en: Generator expressions are actually a sort of comprehension too; they compress
    the more advanced (this time it really is more advanced!) generator syntax into
    one line. The greater generator syntax looks even less object-oriented than anything
    we've seen, but we'll discover that once again, it is a simple syntax shortcut
    to create a kind of object.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器表达式实际上也是一种理解方式；它们将更高级的（这次确实是更高级！）生成器语法压缩成一行。更高级的生成器语法看起来甚至比我们见过的任何东西都更不面向对象，但我们会再次发现，这只是一个简单的语法快捷方式来创建一种对象。
- en: 'Let''s take the log file example a little further. If we want to delete the
    `WARNING` column from our output file (since it''s redundant: this file contains
    only warnings), we have several options at various levels of readability. We can
    do it with a generator expression:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步探讨日志文件示例。如果我们想从输出文件中删除 `WARNING` 列（因为它重复了：这个文件只包含警告），我们有几种不同可读性的选项。我们可以用生成器表达式来做这件事：
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'That''s perfectly readable, though I wouldn''t want to make the expression
    much more complicated than that. We could also do it with a normal `for` loop:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这完全是可以读的，尽管我不希望将表达式复杂化到那种程度。我们也可以用普通的 `for` 循环来做这件事：
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: That's clearly maintainable, but so many levels of indent in so few lines is
    kind of ugly. More alarmingly, if we wanted to do something other than printing
    the lines out, we'd have to duplicate the looping and conditional code, too.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然是可维护的，但在这么少的行中却有很多缩进级别，看起来有点丑陋。更令人担忧的是，如果我们想做的不仅仅是打印行，我们还得复制循环和条件代码。
- en: 'Now let''s consider a truly object-oriented solution, without any shortcuts:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们考虑一个真正面向对象且没有捷径的解决方案：
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'No doubt about it: that is so ugly and difficult to read that you may not even
    be able to tell what''s going on. We created an object that takes a file object
    as input, and provides a `__next__` method like any iterator.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问：这看起来如此丑陋且难以阅读，你可能甚至都无法弄清楚发生了什么。我们创建了一个以文件对象为输入的对象，并提供了一个像任何迭代器一样的 `__next__`
    方法。
- en: This `__next__` method reads lines from the file, discarding them if they are
    not `WARNING` lines. When we encounter a `WARNING` line, we modify and return
    it. Then our `for` loop calls `__next__` again to process the subsequent `WARNING`
    line. When we run out of lines, we raise `StopIteration` to tell the loop we're
    finished iterating. It's pretty ugly compared to the other examples, but it's
    also powerful; now that we have a class in our hands, we can do whatever we want
    with it.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `__next__` 方法从文件中读取行，如果它们不是 `WARNING` 行则忽略它们。当我们遇到 `WARNING` 行时，我们修改并返回它。然后我们的
    `for` 循环再次调用 `__next__` 来处理后续的 `WARNING` 行。当我们没有更多的行时，我们引发 `StopIteration` 来告诉循环我们已经完成了迭代。与其它例子相比，这看起来相当丑陋，但它也很强大；现在我们手中有一个类，我们可以用它来做任何事情。
- en: 'With that background behind us, we finally get to see true generators in action.
    This next example does *exactly* the same thing as the previous one: it creates
    an object with a `__next__` method that raises `StopIteration` when it''s out
    of inputs:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在有了这个背景知识之后，我们终于可以看到真正的生成器在行动了。接下来的这个例子与上一个例子**完全**一样：它创建了一个具有 `__next__` 方法的对象，当它没有输入时将引发
    `StopIteration`：
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: OK, that's pretty readable, maybe... at least it's short. But what on earth
    is going on here? It makes no sense whatsoever. And what is `yield`, anyway?
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这看起来挺容易读的，也许吧... 至少它很短。但这里到底发生了什么？这完全说不通。那么，`yield` 究竟是什么意思呢？
- en: In fact, `yield` is the key to generators. When Python sees `yield` in a function,
    it takes that function and wraps it up in an object not unlike the one in our
    previous example. Think of the `yield` statement as similar to the `return` statement;
    it exits the function and returns a line. Unlike `return`, however, when the function
    is called again (via `next()`), it will start where it left off—on the line after
    the `yield` statement—instead of at the beginning of the function. In this example,
    there is no line *after* the `yield` statement, so it jumps to the next iteration
    of the `for` loop. Since the `yield` statement is inside an `if` statement, it
    only yields lines that contain `WARNING`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，`yield` 是生成器的关键。当 Python 在一个函数中看到 `yield` 时，它会将这个函数包装成一个对象，这个对象与我们在之前的例子中看到的不太一样。将
    `yield` 语句视为与 `return` 语句类似；它退出函数并返回一行。然而，与 `return` 不同的是，当函数再次被调用（通过 `next()`）时，它将从上次离开的地方开始——在
    `yield` 语句之后的行——而不是从函数的开始处。在这个例子中，`yield` 语句之后没有行，所以它跳到 `for` 循环的下一个迭代。由于 `yield`
    语句在 `if` 语句内部，它只产生包含 `WARNING` 的行。
- en: 'While it looks like this is just a function looping over the lines, it is actually
    creating a special type of object, a generator object:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然看起来这个函数只是在遍历行，但实际上它正在创建一个特殊类型的对象，一个生成器对象：
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: I passed an empty list into the function to act as an iterator. All the function does
    is create and return a generator object. That object has `__iter__` and `__next__`
    methods on it, just like the one we created in the previous example. (You can
    call the `dir` built-in function on it to confirm.) Whenever `__next__` is called,
    the generator runs the function until it finds a `yield` statement. It then returns
    the value from `yield`, and the next time `__next__` is called, it picks up where
    it left off.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我将一个空列表传递给函数，作为迭代器使用。这个函数所做的只是创建并返回一个生成器对象。这个对象上有 `__iter__` 和 `__next__` 方法，就像我们在之前的例子中创建的那样。（你可以通过调用
    `dir` 内置函数来确认。）每当调用 `__next__` 时，生成器会运行函数，直到找到 `yield` 语句。然后它返回 `yield` 的值，下一次调用
    `__next__` 时，它会从上次离开的地方继续。
- en: This use of generators isn't that advanced, but if you don't realize the function
    is creating an object, it can seem like magic. This example was quite simple,
    but you can get really powerful effects by making multiple calls to `yield` in
    a single function; on each loop, the generator will simply pick up at the most
    recent `yield` and continue to the next one.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这种生成器的用法并不复杂，但如果你不意识到函数正在创建一个对象，它可能会显得像魔法一样。这个例子相当简单，但通过在单个函数中多次调用 `yield`，你可以得到非常强大的效果；在每次循环中，生成器将简单地从最近的
    `yield` 处开始，并继续到下一个。
- en: Yield items from another iterable
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从另一个可迭代对象中产生项目
- en: Often, when we build a generator function, we end up in a situation where we
    want to yield data from another iterable object, possibly a list comprehension
    or generator expression we constructed inside the generator, or perhaps some external
    items that were passed into the function. This has always been possible by looping
    over the iterable and individually yielding each item. However, in Python version
    3.3, the Python developers introduced a new syntax to make it a little more elegant.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当我们构建一个生成器函数时，我们会陷入一个想要从另一个可迭代对象（可能是我们在生成器内部构建的列表推导式或生成器表达式，或者可能是传递给函数的外部项目）产生数据的局面。这始终是通过遍历可迭代对象并逐个产生每个项目来实现的。然而，在
    Python 3.3 版本中，Python 开发者引入了一种新的语法，使其更加优雅。
- en: Let's adapt the generator example a bit so that instead of accepting a sequence
    of lines, it accepts a filename. This would normally be frowned upon as it ties
    the object to a particular paradigm. When possible we should operate on iterators
    as input; this way the same function could be used regardless of whether the log
    lines came from a file, memory, or the web.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍微修改一下生成器例子，让它接受一个文件名而不是一系列行。这通常会被认为是不好的做法，因为它将对象绑定到特定的范式。当可能的时候，我们应该操作迭代器作为输入；这样，无论日志行是从文件、内存还是网络中来的，都可以使用相同的函数。
- en: 'This version of the code illustrates that your generator can do some basic
    setup before yielding information from another iterable (in this case, a generator
    expression):'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的版本说明了你的生成器可以在从另一个可迭代对象（在这种情况下，是一个生成器表达式）产生信息之前做一些基本的设置：
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This code combines the `for` loop from the previous example into a generator
    expression. Notice that this transformation didn't help anything; the previous
    example with a `for` loop was more readable.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将之前例子中的 `for` 循环结合成了一个生成器表达式。注意，这种转换并没有带来任何帮助；之前的 `for` 循环例子更易于阅读。
- en: 'So, let''s consider an example that is more readable than its alternative.
    It can be useful to construct a generator that yields data from multiple other
    generators. The `itertools.chain` function, for example, yields data from iterables
    in sequence until they have all been exhausted. This can be implemented far too
    easily using the `yield from` syntax, so let''s consider a classic computer science
    problem: walking a general tree.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们考虑一个比它的替代方案更易读的例子。构建一个生成器，从多个其他生成器中产生数据，可能是有用的。例如，`itertools.chain`函数按顺序从可迭代对象中产生数据，直到它们全部耗尽。这可以通过`yield
    from`语法非常容易地实现，所以让我们考虑一个经典的计算机科学问题：遍历一般树。
- en: 'A common implementation of the general tree data structure is a computer''s
    filesystem. Let''s model a few folders and files in a Unix filesystem so we can
    use `yield from` to walk them effectively:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一般树数据结构的一个常见实现是计算机的文件系统。让我们模拟Unix文件系统中的几个文件夹和文件，这样我们就可以使用`yield from`来有效地遍历它们：
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This setup code looks like a lot of work, but in a real filesystem, it would
    be even more involved. We''d have to read data from the hard drive and structure
    it into the tree. Once in memory, however, the code that outputs every file in
    the filesystem is quite elegant:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这个设置代码看起来工作量很大，但在实际的文件系统中，它会更复杂。我们不得不从硬盘读取数据并将其结构化到树中。然而，一旦在内存中，输出文件系统中每个文件的代码相当优雅：
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If this code encounters a directory, it recursively asks `walk()` to generate
    a list of all files subordinate to each of its children, and then yields all that
    data plus its own filename. In the simple case that it has encountered a normal
    file, it just yields that name.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个代码遇到一个目录，它会递归地调用`walk()`来生成其每个子目录下所有文件的列表，然后产生所有这些数据加上它自己的文件名。在它遇到一个普通文件的情况下，它只产生那个名字。
- en: As an aside, solving the preceding problem without using a generator is tricky
    enough that it is a common interview question. If you answer it as shown like
    this, be prepared for your interviewer to be both impressed and somewhat irritated
    that you answered it so easily. They will likely demand that you explain exactly
    what is going on. Of course, armed with the principles you've learned in this
    chapter, you won't have any problem. Good luck!
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 作为旁白，在不使用生成器的情况下解决前面的问题已经足够棘手，以至于它成为了一个常见的面试问题。如果你像这样回答，准备好你的面试官既会印象深刻又会有些恼火，因为你回答得太容易了。他们可能会要求你解释到底发生了什么。当然，有了你在本章中学到的原则，你不会有任何问题。祝你好运！
- en: The `yield from` syntax is a useful shortcut when writing chained generators.
    It was added to the language for a different reason, to support coroutines. It
    is not used all that much anymore, however, because it's usage has been replaced
    with `async` and `await` syntax. We'll see examples of both in the next section.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`yield from`语法在编写链式生成器时是一个有用的快捷方式。它被添加到语言中是为了支持协程。然而，它现在并不怎么使用了，因为它的用法已经被`async`和`await`语法所取代。我们将在下一节中看到这两个语法的示例。'
- en: Coroutines
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协程
- en: Coroutines are extremely powerful constructs that are often confused with generators.
    Many authors inappropriately describe coroutines as *generators with a bit of
    extra syntax*. This is an easy mistake to make, as, way back in Python 2.5, when
    coroutines were introduced, they were presented as *we added a* `send` *method
    to the generator syntax*. The difference is actually a lot more nuanced and will
    make more sense after you've seen a few examples.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 协程是非常强大的构造，常常与生成器混淆。许多作者不适当地将协程描述为“带有额外语法的生成器”。这是一个容易犯的错误，因为，在Python 2.5中，协程首次引入时，它们被展示为“我们在生成器语法中添加了一个`send`方法”。实际上，这种差异要微妙得多，在你看过几个例子之后会更有意义。
- en: Coroutines are pretty hard to understand. Outside the `asyncio` module, which
    we'll cover in the chapter on concurrency, they are not used all that often in
    the wild. You can definitely skip this section and happily develop in Python for
    years without ever encountering coroutines. There are a couple of libraries that
    use coroutines extensively (mostly for concurrent or asynchronous programming),
    but they are normally written such that you can use coroutines without actually
    understanding how they work! So, if you get lost in this section, don't despair.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 协程相当难以理解。在`asyncio`模块之外，我们将在并发章节中介绍，它们在野外并不常用。你完全可以跳过这一节，并快乐地用Python开发多年而不必遇到协程。有几个库广泛使用协程（主要用于并发或异步编程），但它们通常被编写成你可以使用协程而不必真正理解它们是如何工作的！所以，如果你在这一节中迷路了，不要绝望。
- en: 'If I haven''t scared you off, let''s get started! Here''s one of the simplest
    possible coroutines; it allows us to keep a running tally that can be increased
    by arbitrary values:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我没有吓到你，让我们开始吧！这里有一个最简单的协程之一；它允许我们保持一个可以由任意值增加的累计计数：
- en: '[PRE22]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This code looks like black magic that couldn''t possibly work, so let''s prove
    it works before going into a line-by-line description. This simple object could
    be used by a scoring application for a baseball team. Separate tallies could be
    kept for each team, and their score could be incremented by the number of runs
    accumulated at the end of every half-innings. Look at this interactive session:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码看起来像是黑魔法，不可能工作，所以在我们逐行描述之前，让我们证明它是有效的。这个简单的对象可以被用于棒球队伍的计分应用程序。可以为每个队伍分别记录计数，并在每个半局结束时累加的得分数量来增加他们的分数。看看这个交互会话：
- en: '[PRE23]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: First, we construct two `tally` objects, one for each team. Yes, they look like
    functions, but as with the generator objects in the previous section, the fact
    that there is a `yield` statement inside the function tells Python to put a great
    deal of effort into turning the simple function into an object.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们为每个队伍构建两个 `计数器` 对象。是的，它们看起来像函数，但就像前一部分中的生成器对象一样，函数内部存在 `yield` 语句的事实告诉
    Python 要投入大量精力将这个简单的函数转换成一个对象。
- en: We then call `next()` on each of the coroutine objects. This does the same thing
    as calling next on any generator, which is to say, it executes each line of code
    until it encounters a `yield` statement, returns the value at that point, and
    then *pauses* until the next `next()` call.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在每个协程对象上调用 `next()`。这与调用任何生成器的 `next()` 方法做的是同样的事情，也就是说，它执行每一行代码，直到遇到 `yield`
    语句，返回该点的值，然后 *暂停*，直到下一个 `next()` 调用。
- en: 'So far, then, there''s nothing new. But look back at the `yield` statement
    in our coroutine:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，没有什么新的。但是看看我们协程中的 `yield` 语句：
- en: '[PRE24]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Unlike with generators, this `yield` function looks like it's supposed to return
    a value and assign it to a variable. In fact, this is exactly what's happening.
    The coroutine is still paused at the `yield` statement and waiting to be activated
    again by another call to `next()`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 与生成器不同，这个 `yield` 函数看起来像是应该返回一个值并将其分配给一个变量。实际上，这正是正在发生的事情。协程仍然在 `yield` 语句处暂停，等待通过另一个
    `next()` 调用再次被激活。
- en: Except we don't call `next()`. As you see in the interactive session, we instead
    call to a method called `send()`. The `send()` method does *exactly* the same
    thing as `next()` except that in addition to advancing the generator to the next
    `yield` statement, it also allows you to pass in a value from outside the generator.
    This value is what gets assigned to the left side of the `yield` statement.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我们没有调用 `next()`。正如你在交互会话中看到的那样，我们而是调用了一个名为 `send()` 的方法。`send()` 方法与 `next()`
    完全相同，除了它除了将生成器推进到下一个 `yield` 语句之外，还允许你从生成器外部传递一个值。这个值就是分配给 `yield` 语句左侧的值。
- en: 'The thing that is really confusing for many people is the order in which this
    happens:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多人来说，真正令人困惑的是这个发生的顺序：
- en: '`yield` occurs and the generator pauses'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`yield` 发生并且生成器暂停'
- en: '`send()` occurs from outside the function and the generator wakes up'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`send()` 从函数外部发生，生成器醒来'
- en: The value sent in is assigned to the left side of the `yield` statement
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发送的值被分配给 `yield` 语句的左侧
- en: The generator continues processing until it encounters another `yield` statement
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成器继续处理，直到遇到另一个 `yield` 语句
- en: 'So, in this particular example, after we construct the coroutine and advance
    it to the `yield` statement with a single call to `next()`, each successive call
    to `send()` passes a value into the coroutine. We add this value to its score.
    Then we go back to the top of the `while` loop, and keep processing until we hit
    the `yield` statement. The `yield` statement returns a value, which becomes the
    return value of our most recent call to `send`. Don''t miss that: like `next()`,
    the `send()` method does not just submit a value to the generator, it also returns
    the value from the upcoming `yield` statement. This is how we define the difference
    between a generator and a coroutine: a generator only produces values, while a
    coroutine can also consume them.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这个特定的例子中，在我们构建协程并使用一次`next()`调用将其推进到`yield`语句之后，每次对`send()`的后续调用都会将一个值传递给协程。我们将这个值加到它的分数上。然后我们回到`while`循环的顶部，并继续处理，直到我们遇到`yield`语句。`yield`语句返回一个值，这成为我们最近一次`send`调用的返回值。不要错过这一点：像`next()`一样，`send()`方法不仅将一个值提交给生成器，还返回即将到来的`yield`语句的值。这就是我们定义生成器和协程之间差异的方式：生成器只产生值，而协程也可以消费它们。
- en: 'The behavior and syntax of `next(i)`, `i.__next__()`, and `i.send(value)` are
    rather unintuitive and frustrating. The first is a normal function, the second
    is a special method, and the last is a normal method. But all three do the same
    thing: advance the generator until it yields a value and pause. Further, the `next()`
    function and associated method can be replicated by calling `i.send(None)`. There
    is value to having two different method names here, since it helps the reader
    of our code easily see whether they are interacting with a coroutine or a generator.
    I just find the fact that in one case it''s a function call and in the other it''s
    a normal method somewhat irritating.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`next(i)`、`i.__next__()`和`i.send(value)`的行为和语法相当不直观且令人沮丧。第一个是一个普通函数，第二个是一个特殊方法，最后一个是一个普通方法。但三者都做同样的事情：推进生成器直到它产生一个值并暂停。此外，`next()`函数和相关方法可以通过调用`i.send(None)`来复制。在这里有两个不同的方法名称是有价值的，因为它有助于我们的代码读者轻松地看到他们是在与协程还是生成器交互。我只是觉得在一种情况下它是一个函数调用，而在另一种情况下它是一个普通方法有些令人烦恼。'
- en: Back to log parsing
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回到日志解析
- en: Of course, the previous example could easily have been coded using a couple
    of integer variables and calling `x += increment` on them. Let's look at a second
    example where coroutines actually save us some code. This example is a somewhat
    simplified (for pedagogical reasons) version of a problem I had to solve while
    working at Facebook.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，前面的例子可以很容易地使用几个整数变量和调用`x += increment`来编写。让我们看看第二个例子，其中协程实际上帮我们节省了一些代码。这个例子是一个为了教学目的而简化的（问题）版本，我在Facebook工作时必须解决的问题。
- en: 'The Linux kernel log contains lines that look almost, but not quite entirely,
    unlike this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Linux内核日志包含看起来几乎，但又不完全像这样的行：
- en: '[PRE25]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: There are a whole bunch of interspersed kernel log messages, some of which pertain
    to hard disks. The hard disk messages might be interspersed with other messages,
    but they occur in a predictable format and order. For each, a specific drive with
    a known serial number is associated with a bus identifier (such as `0:0:0:0`).
    A block device identifier (such as `sda`) is also associated with that bus. Finally,
    if the drive has a corrupt filesystem, it might fail with an XFS error.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多散布的内核日志消息，其中一些与硬盘有关。硬盘消息可能会与其他消息混合，但它们以可预测的格式和顺序出现。对于每一个，一个具有已知序列号的特定驱动器与一个总线标识符（例如`0:0:0:0`）相关联。一个块设备标识符（例如`sda`）也与该总线相关联。最后，如果驱动器有一个损坏的文件系统，它可能会因为XFS错误而失败。
- en: Now, given the preceding log file, the problem we need to solve is how to obtain
    the serial number of any drives that have XFS errors on them. This serial number
    might later be used by a data center technician to identify and replace the drive.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，鉴于前面的日志文件，我们需要解决的问题是如何获取任何有XFS错误的驱动器的序列号。这个序列号可能后来会被数据中心的技术人员用来识别和更换驱动器。
- en: We know we can identify the individual lines using regular expressions, but
    we'll have to change the regular expressions as we loop through the lines, since
    we'll be looking for different things depending on what we found previously. The
    other difficult bit is that if we find an error string, the information about
    which bus contains that string as well as the serial number have already been
    processed. This can easily be solved by iterating through the lines of the file
    in reverse order.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道我们可以使用正则表达式来识别单独的行，但我们需要在循环遍历行时更改正则表达式，因为我们将根据之前找到的内容寻找不同的事情。另一个困难之处在于，如果我们找到一个错误字符串，包含该字符串的总线信息以及序列号已经处理过了。这可以通过按相反的顺序迭代文件中的行来轻松解决。
- en: 'Before you look at this example, be warned—the amount of code required for
    a coroutine-based solution is scarily small:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在你看这个例子之前，要警告你——基于协程的解决方案所需的代码量非常小：
- en: '[PRE26]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This code neatly divides the job into two separate tasks. The first task is
    to loop over all the lines and spit out any lines that match a given regular expression.
    The second task is to interact with the first task and give it guidance as to
    what regular expression it is supposed to be searching for at any given time.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码巧妙地将工作分为两个单独的任务。第一个任务是循环遍历所有行并输出任何匹配给定正则表达式的行。第二个任务是与第一个任务交互，并指导它在任何给定时间应该搜索什么正则表达式。
- en: Look at the `match_regex` coroutine first. Remember, it doesn't execute any
    code when it is constructed; rather, it just creates a coroutine object. Once
    constructed, someone outside the coroutine will eventually call `next()` to start
    the code running. Then it stores the state of two variables `filename` and `regex`.
    It then reads all the lines in the file and iterates over them in reverse. Each
    line is compared to the regular expression that was passed in until it finds a
    match. When the match is found, the coroutine yields the first group from the
    regular expression and waits.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 首先看看`match_regex`协程。记住，它在构造时不会执行任何代码；相反，它只是创建一个协程对象。一旦构造完成，协程外部的人最终会调用`next()`来启动代码的运行。然后它存储两个变量`filename`和`regex`的状态。然后它读取文件中的所有行，并按相反的顺序迭代它们。每一行都会与传入的正则表达式进行比较，直到找到匹配项。当找到匹配项时，协程产生正则表达式的第一个组并等待。
- en: At some point in the future, other code will send in a new regular expression
    to search for. Note that the coroutine never cares what regular expression it
    is trying to match; it's just looping over lines and comparing them to a regular
    expression. It's somebody else's responsibility to decide what regular expression
    to supply.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在未来的某个时刻，其他代码将发送一个新的正则表达式来搜索。请注意，协程永远不会关心它试图匹配的正则表达式是什么；它只是在循环遍历行并将它们与正则表达式进行比较。决定提供什么正则表达式是别人的责任。
- en: In this case, that somebody else is the `get_serials` generator. It doesn't
    care about the lines in the file; in fact, it isn't even aware of them. The first
    thing it does is create a `matcher` object from the `match_regex` coroutine constructor,
    giving it a default regular expression to search for. It advances the coroutine
    to its first `yield` and stores the value it returns. It then goes into a loop
    that instructs the `matcher` object to search for a bus ID based on the stored
    device ID, and then a serial number based on that bus ID.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，其他人就是`get_serials`生成器。它不关心文件中的行；实际上，它甚至没有意识到它们的存在。它首先做的事情是从`match_regex`协程构造函数创建一个`matcher`对象，给它一个默认的正则表达式来搜索。它将协程推进到它的第一个`yield`，并存储它返回的值。然后它进入一个循环，指示`matcher`对象根据存储的设备ID搜索一个总线ID，然后根据该总线ID搜索一个序列号。
- en: It idly yields that serial number to the outside `for` loop before instructing
    the matcher to find another device ID and repeat the cycle.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在指示匹配器找到另一个设备ID并重复循环之前，它先无用地将序列号产生到外部的`for`循环中。
- en: Basically, the coroutine's job is to search for the next important line in the
    file, while the generator's (`get_serial`, which uses the `yield` syntax without
    assignment) job is to decide which line is important. The generator has information
    about this particular problem, such as what order lines will appear in the file.
    The coroutine, on the other hand, could be plugged into any problem that required
    searching a file for given regular expressions.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，协程的任务是搜索文件中的下一个重要行，而生成器（使用`yield`语法但不进行赋值的`get_serial`）的任务是决定哪一行是重要的。生成器有关于这个特定问题的信息，比如文件中行的出现顺序。另一方面，协程可以插入到任何需要搜索文件中给定正则表达式的任何问题中。
- en: Closing coroutines and throwing exceptions
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关闭协程和抛出异常
- en: Normal generators signal their exit from inside by raising `StopIteration`.
    If we chain multiple generators together (for example, by iterating over one generator
    from inside another), the `StopIteration` exception will be propagated outward.
    Eventually, it will hit a `for` loop that will see the exception and know that
    it's time to exit the loop.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 正常生成器通过抛出`StopIteration`来在内部发出退出信号。如果我们将多个生成器链式连接在一起（例如，通过在一个生成器内部迭代另一个生成器），`StopIteration`异常将会向外传播。最终，它将遇到一个`for`循环，该循环将看到这个异常并知道是时候退出循环了。
- en: Even though they use a similar syntax, coroutines don't normally follow the
    iteration mechanism. Instead of pulling data through one until an exception is
    encountered, data is usually pushed into it (using `send`). The entity doing the
    pushing is normally the one in charge of telling the coroutine when it's finished.
    It does this by calling the `close()` method on the coroutine in question.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它们使用类似的语法，但协程通常不遵循迭代机制。而不是通过一个直到遇到异常，数据通常被推入其中（使用`send`）。执行推入操作的是通常负责告诉协程何时完成的实体。它通过在相关的协程上调用`close()`方法来完成这个操作。
- en: When called, the `close()` method will raise a `GeneratorExit` exception at
    the point the coroutine was waiting for a value to be sent in. It is normally
    good policy for coroutines to wrap their `yield` statements in a `try`...`finally`
    block so that any cleanup tasks (such as closing associated files or sockets)
    can be performed.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用时，`close()`方法将在协程等待发送值的地方抛出`GeneratorExit`异常。对于协程来说，通常是一个好的做法，将它们的`yield`语句包裹在`try`...`finally`块中，这样就可以执行任何清理任务（例如关闭相关的文件或套接字）。
- en: If we need to raise an exception inside a coroutine, we can use the `throw()`
    method in a similar way. It accepts an exception type with optional `value` and
    `traceback` arguments. The latter is useful when we encounter an exception in
    one coroutine and want to cause an exception to occur in an adjacent coroutine
    while maintaining the traceback.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要在协程内部抛出异常，我们可以使用类似的方式使用`throw()`方法。它接受一个异常类型，并带有可选的`value`和`traceback`参数。后者在我们遇到一个协程中的异常时很有用，我们想在相邻的协程中引发异常，同时保持跟踪记录。
- en: The previous example could be written without coroutines and would be about
    equally readable. The truth is, correctly managing all the state between coroutines
    is pretty difficult, especially when you take things like context managers and
    exceptions into account. Luckily, the Python standard library contains a package
    called `asyncio` that can manage all of this for you. We'll cover that in the
    chapter on concurrency. In general, I recommend you avoid using bare coroutines
    unless you are specifically coding for asyncio. The logging example could almost
    be considered an *anti-pattern*; a design pattern that should be avoided rather
    than embraced.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子可以不使用协程来编写，并且阅读起来几乎一样。事实上，正确管理协程之间的所有状态相当困难，尤其是在考虑上下文管理器和异常的情况下。幸运的是，Python标准库中包含一个名为`asyncio`的包，可以为你管理所有这些。我们将在并发章节中介绍这一点。一般来说，我建议你除非你专门为`asyncio`编码，否则避免使用裸协程。日志记录示例几乎可以被认为是一种*反模式*；一种应该避免而不是采纳的设计模式。
- en: The relationship between coroutines, generators, and functions
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协程、生成器和函数之间的关系
- en: We've seen coroutines in action, so now let's go back to that discussion of
    how they are related to generators. In Python, as is so often the case, the distinction
    is quite blurry. In fact, all coroutines are generator objects, and authors often
    use the two terms interchangeably. Sometimes, they describe coroutines as a subset
    of generators (only generators that return values from yield are considered coroutines).
    This is technically true in Python, as we've seen in the previous sections.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了协程的实际应用，现在让我们回到它们与生成器相关性的讨论。在Python中，正如经常发生的那样，这种区别相当模糊。事实上，所有协程都是生成器对象，作者经常互换使用这两个术语。有时，他们将协程描述为生成器的一个子集（只有从`yield`返回值的生成器才被认为是协程）。在Python中，这从先前的章节中我们已经看到，在技术上是真的。
- en: However, in the greater sphere of theoretical computer science, coroutines are
    considered the more general principles, and generators are a specific type of
    coroutine. Further, normal functions are yet another distinct subset of coroutines.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在理论计算机科学的更广泛领域，协程被认为是更通用的原则，生成器是协程的一种特定类型。此外，普通函数是协程的另一个独立的子集。
- en: A coroutine is a routine that can have data passed in at one or more points
    and get it out at one or more points. In Python, the point where data is passed
    in and out is the `yield` statement.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 协程是一种可以在一个或多个点接收数据并在一个或多个点输出数据的例程。在Python中，数据传入和退出的点是`yield`语句。
- en: A function, or subroutine, is the simplest type of coroutine. You can pass data
    in at one point, and get data out at one other point when the function returns.
    While a function can have multiple `return` statements, only one of them can be
    called for any given invocation of the function.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 函数，或子程序，是最简单的协程类型。你可以在一个点传入数据，当函数返回时在另一个点获取数据。虽然函数可以有多个`return`语句，但在任何给定函数调用中只能调用其中一个。
- en: Finally, a generator is a type of coroutine that can have data passed in at
    one point, but can pass data out at multiple points. In Python, the data would
    be passed out at a `yield` statement, but you can't pass data back in. If you
    called `send`, the data would be silently discarded.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，生成器是一种可以在一个点传入数据但在多个点输出数据的协程类型。在Python中，数据会在`yield`语句处输出，但不能传入数据。如果你调用`send`，数据将被静默丢弃。
- en: So, in theory, generators are types of coroutines, functions are types of coroutines,
    and there are coroutines that are neither functions nor generators. That's simple
    enough, eh? So, why does it feel more complicated in Python?
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，从理论上讲，生成器是协程类型，函数是协程类型，还有一些既不是函数也不是生成器的协程。这很简单，对吧？那么，为什么在Python中感觉更复杂呢？
- en: In Python, generators and coroutines are both constructed using a syntax that
    **looks** like we are constructing a function. But the resulting object is not
    a function at all; it's a totally different kind of object. Functions are, of
    course, also objects. But they have a different interface; functions are callable
    and return values, generators have data pulled out using `next()`, and coroutines
    have data pushed in using `send`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，生成器和协程都使用一种**看起来**像我们在构建函数的语法来构建。但生成的对象根本不是函数；它是一种完全不同的对象。当然，函数也是对象。但它们有不同的接口；函数是可调用的并返回值，生成器使用`next()`提取数据，协程使用`send()`推送数据。
- en: There is an alternate syntax for coroutines using the `async` and `await` keywords. The
    syntax makes it clearer that the code is a coroutine and further breaks the deceiving
    symmetry between coroutines and generators. The syntax doesn't work very well
    without building a full event loop, so we will skip it until we cover `asyncio`
    in the concurrency chapter.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 协程还有一个使用`async`和`await`关键字的不同语法。这种语法使得代码是协程的事实更加清晰，并进一步打破了协程和生成器之间欺骗性的对称性。这种语法在没有构建完整的事件循环的情况下工作得不是很好，所以我们将在并发章节介绍`asyncio`之前跳过它。
- en: Case study
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 案例研究
- en: One of the fields in which Python is the most popular these days is data science.
    In honor of that fact, let's implement a basic machine learning algorithm.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 目前Python最受欢迎的领域之一是数据科学。为了纪念这一事实，让我们实现一个基本的机器学习算法。
- en: Machine learning is a huge topic, but the general idea is to make predictions
    or classifications about future data by using knowledge gained from past data.
    Uses of such algorithms abound, and data scientists are finding new ways to apply
    machine learning every day. Some important machine learning applications include
    computer vision (such as image classification or facial recognition), product
    recommendation, identifying spam, and self-driving cars.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 机器学习是一个巨大的主题，但基本思想是利用从过去数据中获得的知识来对未来的数据进行预测或分类。此类算法的应用非常广泛，数据科学家每天都在寻找新的应用机器学习的方法。一些重要的机器学习应用包括计算机视觉（如图像分类或人脸识别）、产品推荐、识别垃圾邮件和自动驾驶汽车。
- en: 'So as not to digress into an entire book on machine learning, we''ll look at
    a simpler problem: given an RGB color definition, what name would humans identify
    that color as?'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免深入到一本关于机器学习的整本书，我们将看看一个更简单的问题：给定一个RGB颜色定义，人类会将其识别为哪种颜色？
- en: 'There are more than 16 million colors in the standard RGB color space, and
    humans have come up with names for only a fraction of them. While there are thousands
    of names (some quite ridiculous; just go to any car dealership or paint store),
    let''s build a classifier that attempts to divide the RGB space into the basic
    colors:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 标准RGB颜色空间中有超过1600万种颜色，而人类只为其中的一小部分想出了名字。虽然有一些名字（有些相当荒谬；只需去任何汽车经销商或油漆店看看），但让我们构建一个分类器，尝试将RGB空间划分为基本颜色：
- en: Red
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 红色
- en: Purple
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 紫色
- en: Blue
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蓝色
- en: Green
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绿色
- en: Yellow
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 黄色
- en: Orange
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 橙色
- en: Gray
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 灰色
- en: Pink
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 粉色
- en: (In my testing, I classified whitish and blackish colors as gray, and brownish
    colors as orange.)
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: （在我的测试中，我将白色和黑色颜色分类为灰色，将棕色颜色分类为橙色。）
- en: 'The first thing we need is a dataset to train our algorithm on. In a production
    system, you might scrape a *list of colors* website or survey thousands of people.
    Instead, I created a simple application that renders a random color and asks the
    user to select one of the preceding eight options to classify it. I implemented
    it using `tkinter`, the user interface toolkit that ships with Python. I''m not
    going to go into the details of what this script does, but here it is in its entirety
    for completeness (it''s a trifle long, so you may want to pull it from Packt''s
    GitHub repository with the examples for this book instead of typing it in):'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要的是一个用于训练我们算法的数据集。在生产系统中，你可能需要抓取一个 *颜色列表* 网站，或者调查数千人。相反，我创建了一个简单的应用程序，它会渲染一个随机颜色，并要求用户从前面的八个选项中选择一个来对其进行分类。我使用
    `tkinter`（Python 附带的用户界面工具包）实现了它。我不会详细介绍这个脚本的细节，但为了完整性，这里提供它的全部内容（它有点长，所以你可能想从
    Packt 的 GitHub 仓库中获取这本书的示例，而不是手动输入）：
- en: '[PRE27]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: You can easily add more buttons for other colors if you like. You may get tripped
    up on the layout; the second and third argument to `create_color_button` represent
    the row and column of a two column grid that the button goes in. Once you have
    all your colors in place, you will want to move the **Quit** button to the last
    row.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你喜欢，可以轻松地添加更多按钮以供其他颜色选择。你可能会在布局上遇到困难；`create_color_button` 函数的第二个和第三个参数代表按钮所在的二维网格的行和列。一旦你将所有颜色放置到位，你可能会想将
    **退出** 按钮移至最后一行。
- en: 'For the purposes of this case study, the important thing to know about this
    application is the output. It creates a **C****omma-Separated Value** (**CSV**)
    file named `colors.csv`. This file contains two CSVs: the label the user assigned
    to the color, and the hex RGB value for the color. Here''s an example:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本案例研究的目的，了解此应用程序的输出很重要。它创建了一个名为 `colors.csv` 的 **逗号分隔值**（**CSV**）文件。此文件包含两个
    CSV 文件：用户分配给颜色的标签以及颜色的十六进制 RGB 值。以下是一个示例：
- en: '[PRE28]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: I made over 250 datapoints before I got bored and decided it was time to start
    machine learning on my dataset. My datapoints are shipped with the examples for
    this chapter if you would like to use it (nobody's ever told me I'm colorblind,
    so it should be somewhat reasonable).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在我感到无聊并决定开始对我的数据集进行机器学习之前，我制作了超过 250 个数据点。如果你想使用它，这些数据点与本章的示例一起提供（没有人告诉我我是色盲，所以它应该是有一定合理性的）。
- en: We'll be implementing one of the simpler machine learning algorithms, referred
    to as *k-nearest neighbor*. This algorithm relies on some kind of *distance* calculation
    between points in the dataset (in our case, we can use a three-dimensional version
    of the Pythagorean theorem). Given a new datapoint, it finds a certain number
    (referred to as *k*, which is the *k* in *k-nearest*) of datapoints that are closest
    to it when measured by that distance calculation. Then it combines those datapoints
    in some way (an average might work for linear calculations; for our classification
    problem, we'll use the mode), and returns the result.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现一种简单的机器学习算法，称为 *k 近邻*。此算法依赖于数据集中点之间的某种 *距离* 计算（在我们的情况下，我们可以使用三维版本的勾股定理）。给定一个新数据点，它找到一定数量的数据点（称为
    *k*，即 *k* 近邻中的 *k*），这些数据点在距离计算中被测量为最接近。然后它以某种方式组合这些数据点（对于线性计算，平均值可能适用；对于我们的分类问题，我们将使用众数），并返回结果。
- en: We won't go into too much detail about what the algorithm does; rather, we'll
    focus on some of the ways we can apply the iterator pattern or iterator protocol
    to this problem.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会过多地介绍算法做了什么；相反，我们将关注一些我们可以将迭代器模式或迭代器协议应用于此问题的方法。
- en: 'Let''s now write a program that performs the following steps in order:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们编写一个程序，按照以下步骤顺序执行：
- en: Load the sample data from the file and construct a model from it.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从文件中加载样本数据并据此构建模型。
- en: Generate 100 random colors.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成 100 种随机颜色。
- en: Classify each color and output it to a file in the same format as the input.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将每种颜色进行分类，并以与输入相同的格式输出到文件。
- en: 'The first step is a fairly simple generator that loads CSV data and converts
    it into a format that is amenable to our needs:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是一个相当简单的生成器，它加载 CSV 数据并将其转换为适合我们需求的形式：
- en: '[PRE29]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We haven't seen the `csv.reader` function before. It returns an iterator over
    the lines in the file. Each value returned by the iterator is a list of strings,
    as separated by commas. So, the line `Green,#6edd13` is returned as `["Green",
    "#6edd13"]`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前没有见过`csv.reader`函数。它返回文件中行的迭代器。迭代器返回的每个值都是一个字符串列表，由逗号分隔。因此，行`Green,#6edd13`返回为`["Green",
    "#6edd13"]`。
- en: The `load_colors` generator then consumes that iterator, one line at a time,
    and yields a tuple of RGB values as well as the label. It is quite common for
    generators to be chained in this way, where one iterator calls another that calls
    another and so on. You may want to look at the `itertools` module in the Python
    Standard Library for a whole host of such ready-made generators waiting for you.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`load_colors`生成器随后逐行消费这个迭代器，并产生一个RGB值的元组以及标签。以这种方式链式使用生成器是很常见的，其中一个迭代器调用另一个，然后又调用另一个，依此类推。你可能想查看Python标准库中的`itertools`模块，那里有许多现成的生成器等待你使用。'
- en: 'The RGB values in this case are tuples of integers between 0 and 255\. The
    conversion from hex to RGB is a bit tricky, so we pulled it out into a separate
    function:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，RGB值是介于0到255之间的整数元组。从十六进制到RGB的转换有点棘手，所以我们将其提取到一个单独的函数中：
- en: '[PRE30]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This generator expression is doing a lot of work. It takes a string such as `"#12abfe"`
    as input and returns a tuple such as `(18, 171, 254)`. Let's break it down from
    back to front.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这个生成器表达式正在做很多工作。它接受一个如`"#12abfe"`这样的字符串作为输入，并返回一个如`(18, 171, 254)`这样的元组。让我们从后往前分析它。
- en: The `range` call will return the numbers `[1, 3, 5]`. These represent the indexes
    of the three color channels in the hex string. The index, `0`, is skipped, since
    it represents the character `"#"`, which we don't care about. For each of the
    three numbers, it extracts the two character string between `i` and `i+2`. For
    the preceding example string , that would be `12`, `ab`, and `fe`. Then it converts
    this string value to an integer. The `16` passed as the second argument to the
    `int` function tells the function to use base-16 (hexadecimal) instead of the
    usual base-10 (decimal) for the conversion.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`range`调用将返回数字`[1, 3, 5]`。这些代表十六进制字符串中三个颜色通道的索引。索引`0`被跳过，因为它代表字符`"#"`，我们对此不感兴趣。对于这三个数字中的每一个，它提取`i`和`i+2`之间的两个字符字符串。对于前面的示例字符串，这将分别是`12`、`ab`和`fe`。然后它将这个字符串值转换为整数。传递给`int`函数的第二个参数`16`告诉函数在转换时使用十六进制（十六进制）而不是通常的十进制（十进制）基数。'
- en: Given how difficult the generator expression is to read, do you think it should
    have been represented in a different format? It could be created as a sequence
    of multiple generator expressions, for example, or be unrolled into a normal generator
    function with `yield` statements. Which would you prefer?
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 由于生成器表达式难以阅读，你认为它应该以不同的格式表示吗？它可以创建为多个生成器表达式的序列，例如，或者展开为一个带有`yield`语句的正常生成器函数。你更喜欢哪一个？
- en: In this case, I am comfortable trusting the function name to explain what the
    ugly line of code is doing.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我放心地相信函数名可以解释那行丑陋的代码在做什么。
- en: Now that we've loaded the *training data* (manually classified colors, we need
    some new data to test how well the algorithm is working. We can do this by generating
    a hundred random colors, each composed of three random numbers between 0 and 255.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经加载了*训练数据*（手动分类的颜色），我们需要一些新的数据来测试算法的效果。我们可以通过生成一百种随机颜色来实现，每种颜色由0到255之间的三个随机数组成。
- en: 'There are so many ways this can be done:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多种实现方式：
- en: A list comprehension with a nested generator expression: `[tuple(randint(0,255)
    for c in range(3)) for r in range(100)]`
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个带有嵌套生成器表达式的列表解析：`[tuple(randint(0,255) for c in range(3)) for r in range(100)]`
- en: A basic generator function
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个基本的生成器函数
- en: A class that implements the `__iter__` and `__next__` protocols
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个实现`__iter__`和`__next__`协议的类
- en: Push the data through a pipeline of coroutines
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据通过协程管道推送
- en: Even just a basic `for` loop
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 甚至只是一个基本的`for`循环
- en: 'The generator version seems to be most readable, so let''s add that function
    to our program:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器版本看起来最易读，所以让我们将这个函数添加到我们的程序中：
- en: '[PRE31]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Notice how we parameterize the number of colors to generate. We can now reuse
    this function for other color-generating tasks in the future.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何参数化要生成的颜色数量。现在我们可以重用这个函数来处理未来的其他颜色生成任务。
- en: 'Now, before we do the classification step, we need a function to calculate
    the *distance* between two colors. Since it''s possible to think of colors as
    being three dimensional (red, green, and blue could map to the *x*, *y*, and *z*
    axes, for example), let''s use a little basic math:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们进行分类步骤之前，我们需要一个函数来计算两种颜色之间的*距离*。由于颜色可以被认为是三维的（例如，红色、绿色和蓝色可以映射到*x*、*y*和*z*轴），让我们使用一点基本的数学：
- en: '[PRE32]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This is a pretty basic-looking function; it doesn't look like it's even using
    the iterator protocol. There's no `yield` function, no comprehensions. However,
    there is a `for` loop, and that call to the `zip` function is doing some real
    iteration as well (if you aren't familiar with it, `zip` yields tuples, each containing
    one element from each input iterator).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数看起来相当基础；它看起来甚至没有使用迭代器协议。没有`yield`函数，没有理解。然而，有一个`for`循环，并且那个`zip`函数的调用实际上在进行一些真正的迭代（如果你不熟悉它，`zip`产生元组，每个元组包含来自每个输入迭代器的元素）。
- en: 'This distance calculation is the three-dimensional version of the Pythagorean
    theorem you may remember from school: *a² + b² = c²*. Since we are using three
    dimensions, I guess it would actually be *a² + b² + c² = d²*. The distance is
    technically the square root of *a² + b² + c²*, but there isn''t any need to perform
    the somewhat expensive `sqrt` calculation since the squared distances are all
    the same relative size to each other.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这种距离计算是你可能从学校学到的三维版本的勾股定理：*a² + b² = c²*。由于我们使用三个维度，我想它实际上应该是*a² + b² + c² =
    d²*。距离在技术上是指*a² + b² + c²*的平方根，但由于平方距离彼此之间相对大小相同，所以没有必要执行相对昂贵的`sqrt`计算。
- en: 'Now that we have some plumbing in place, let''s do the actual k-nearest neighbor
    implementation. This routine can be thought of as consuming and combining the
    two generators we''ve already seen (`load_colors` and `generate_colors`):'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经建立了一些管道，让我们进行实际的k最近邻实现。这个例程可以被认为是消费和组合我们之前看到的两个生成器（`load_colors`和`generate_colors`）：
- en: '[PRE33]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We first convert the `model_colors` generator to a list because it has to be
    consumed multiple times, once for each of the `target_colors`.  If we didn't do
    this, we would have to load the colors from the source file repeatedly, which
    would perform a lot of unnecessary disk reads.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将`model_colors`生成器转换为列表，因为它必须被多次消费，一次用于每个`target_colors`。如果我们不这样做，我们就必须反复从源文件中加载颜色，这将执行很多不必要的磁盘读取。
- en: The downside of this decision is that the entire list has to be stored in memory
    all at once. If we had a massive dataset that didn't fit in memory, it would actually
    be necessary to reload the generator from disk each time (though we'd actually
    be looking at different machine learning algorithms in that case).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这个决定的缺点是整个列表必须一次性存储在内存中。如果我们有一个庞大的数据集，它无法适应内存，那么实际上每次都需要从磁盘重新加载生成器（尽管在这种情况下，我们实际上会查看不同的机器学习算法）。
- en: The `nearest_neighbors` generator loops over each target color (a three-tuple,
    such as `(255, 14, 168)`) and calls the `color_distance` function on it inside
    a generator expression. The `sorted` call surrounding that generator expression
    then sorts the results by their first element, which is the distance. It is a
    complicated piece of code and isn't object-oriented at all. You may want to break
    it down into a normal `for` loop to ensure you understand what the generator expression
    is doing.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`nearest_neighbors`生成器遍历每个目标颜色（一个三元组，例如`(255, 14, 168)`），并在生成器表达式中调用它内部的`color_distance`函数。围绕该生成器表达式的`sorted`调用然后按其第一个元素（即距离）对结果进行排序。这是一段复杂的代码，并且根本不是面向对象的。你可能想要将其分解为正常的`for`循环，以确保你理解生成器表达式正在做什么。'
- en: The `yield` statement is a bit less complicated. For each RGB three-tuple from
    the `target_colors` generator, it yields the target, and a list comprehension
    of the `num_neighbors` (that's the *k* in *k-nearest*, by the way. Many mathematicians
    and, by extension, data scientists, have a horrible tendency to use unintelligible
    one-letter variable names) closest colors.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`yield`语句稍微简单一些。对于`target_colors`生成器中的每个RGB三元组，它产生目标和一个包含`num_neighbors`（也就是*k*，在*k*最近邻中。许多数学家和数据科学家都有一种糟糕的倾向，使用难以理解的单一字母变量名）最近颜色的列表。'
- en: 'The contents of each element in the list comprehension is an element from the
    `model_colors` generator; that is, a tuple of a tuple of three RGB values and
    the string name that was manually entered for that color. So, one element might
    look like this: `((104, 195, 77), ''Green'')`. The first thing I think when I
    see nested tuples like that is, *that is not the right datastructure*. The RGB
    color should probably be represented as a named tuple, and the two attributes
    should maybe go on a dataclass.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 列表推导式中的每个元素内容都是`model_colors`生成器中的一个元素；也就是说，是一个包含三个RGB值和为该颜色手动输入的字符串名称的元组。所以，一个元素可能看起来像这样：`((104,
    195, 77), 'Green')`。当我看到这样的嵌套元组时，我首先想到的是，*这不是正确的数据结构*。RGB颜色可能应该用命名元组来表示，而这两个属性可能应该放在数据类中。
- en: 'We can now add *another* generator to the chain to figure out what name we
    should give this target color:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以向链中添加另一个生成器，以确定我们应该给这个目标颜色起什么名字：
- en: '[PRE34]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This generator is unpacking the tuple returned by `nearest_neighbors` into the
    three-tuple target and the five nearest datapoints. It uses a `Counter` to find
    the name that appears most often among the colors that were returned. There is
    yet another generator expression in the `Counter` constructor; this one extracts
    the second element (the color name) from each datapoint. Then it yields a tuple
    RGB value and the guessed name. An example of the return value is `(91, 158, 250)
    Blue`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这个生成器正在将`nearest_neighbors`返回的元组解包成三个元组的目标和五个最近的数据点。它使用`Counter`来找到在返回的颜色中出现次数最多的名称。在`Counter`构造函数中还有一个另一个生成器表达式；这个生成器从每个数据点中提取第二个元素（颜色名称）。然后它产生一个RGB值和猜测的名称。返回值的例子是`(91,
    158, 250) Blue`。
- en: 'We can write a function that accepts the output from the `name_colors` generator
    and writes it to a CSV file, with the RGB colors represented as hex values:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写一个函数，该函数接受`name_colors`生成器的输出并将其写入CSV文件，RGB颜色以十六进制值表示：
- en: '[PRE35]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This is a function, not a generator. It's consuming the generator in a `for`
    loop, but it's not yielding anything. It constructs a CSV writer and outputs rows
    of name, hex value (for example, `Purple,#7f5f95`) pairs for each of the target
    colors. The only thing that might be confusing in here is the contents of the
    format string. The `:02x` modifier used with each of the `r`,`g`, and `b` channels
    outputs the number as a zero-padded two-digit hexadecimal number.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个函数，不是一个生成器。它在`for`循环中消耗生成器，但没有产生任何东西。它构建了一个CSV写入器，并为每个目标颜色输出名称、十六进制值（例如，`Purple,#7f5f95`）的行。这里可能让人困惑的是格式字符串的内容。与每个`r`、`g`和`b`通道一起使用的`:02x`修饰符将数字输出为零填充的两个十六进制数字。
- en: 'Now all we have to do is connect these various generators and pipelines together,
    and kick off the process with a single function call:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需要将这些不同的生成器和管道连接起来，并通过单个函数调用启动过程：
- en: '[PRE36]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: So, this function, unlike almost every other function we've defined, is a perfectly
    normal function without any `yield` statements or `for` loops. It doesn't do any
    iteration at all.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这个函数，与我们所定义的几乎所有其他函数不同，是一个完全正常的函数，没有任何`yield`语句或`for`循环。它根本不做任何迭代。
- en: 'It does, however, construct three generators. Can you see all three?:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 它确实构建了三个生成器。你能看到这三个吗？：
- en: '`load_colors` returns a generator'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`load_colors`返回一个生成器'
- en: '`generate_colors` returns a generator'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`generate_colors`返回一个生成器'
- en: '`name_guess` returns a generator'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name_guess`返回一个生成器'
- en: The `name_guess` generator consumes the first two generators. It, in turn, is
    then consumed by the `write_results` function.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`name_guess`生成器消耗前两个生成器。然后，它被`write_results`函数消耗。'
- en: 'I wrote a second Tkinter app to check the accuracy of the algorithm. It is
    similar to the first app, except it renders each color and the label associated
    with that color. Then you have to manually click Yes or No if the label matches
    the color. For my example data, I got around 95% accuracy. This could be improved
    by implementing the following:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我编写了第二个Tkinter应用程序来检查算法的准确性。它与第一个应用程序类似，但它渲染每个颜色及其相关的标签。然后你必须手动点击是或否，如果标签与颜色匹配。对于我的示例数据，我得到了大约95%的准确性。这可以通过实现以下方法来改进：
- en: Adding more color names
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加更多颜色名称
- en: Adding more training data by manually classifying more colors
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过手动分类更多颜色来添加更多训练数据
- en: Tweaking the value of `num_neighbors`
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调整`num_neighbors`的值
- en: Using a more advanced machine learning algorithm
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用更先进的机器学习算法
- en: 'Here''s the code for the output checking app, though I recommend downloading
    the example code instead. This would be tedious to type in:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出检查应用程序的代码，尽管我建议下载示例代码。这会非常麻烦：
- en: '[PRE37]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: You might be wondering, *what does any of this have to do with object-oriented
    programming? There isn't even one class in this code!*. In some ways, you'd be
    right; generators are not commonly considered object-oriented. However, the functions
    that create them return objects; in fact, you could think of those functions as
    constructors. The constructed object has an appropriate `__next__()` method. Basically,
    the generator syntax is a syntax shortcut for a particular kind of object that
    would be quite verbose to create without it.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道，“这与面向对象编程有什么关系？这段代码甚至没有使用一个类！”。在某种程度上，你是对的；生成器通常不被认为是面向对象的。然而，创建它们的函数返回对象；实际上，你可以将这些函数视为构造函数。构建的对象有一个适当的`__next__()`方法。基本上，生成器语法是一种语法快捷方式，用于创建一种在没有它的情况下会相当冗长的特定类型的对象。
- en: 'As a sort of historical note, the second edition of this book used coroutines
    to solve this problem instead of basic generators. I decided to switch it to generators
    in the third edition for a few reasons:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种历史性的注释，本书的第二版使用协程而不是基本生成器来解决此问题。我决定在第三版中将它改为生成器，原因有几个：
- en: Nobody ever uses coroutines in real life outside of `asyncio`, which we'll cover
    in the chapter on concurrency. I felt I was wrongly encouraging people to use
    coroutines to solve problems when they are extremely rarely the right tool.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了`asyncio`之外，没有人会在现实生活中使用协程，我们将在并发章节中介绍`asyncio`。我觉得我错误地鼓励人们使用协程来解决问题，而实际上协程极其罕见地是正确的工具。
- en: The coroutine version is longer and more convoluted with more boilerplate than
    the generator version.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与生成器版本相比，协程版本更长、更复杂，并且有更多的模板代码。
- en: The coroutine version didn't demonstrate enough of the other features discussed
    in this chapter, such as list comprehensions and generator expressions.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协程版本没有展示出本章讨论的其他足够多的特性，例如列表推导和生成器表达式。
- en: In case you might find the coroutine-based implementation to be historically
    interesting, I included a copy of that code with the rest of the downloadable
    example code for this chapter.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你可能对基于协程的实现感到历史上有兴趣，我在本章的下载示例代码中包含了这个代码的副本。
- en: Exercises
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: If you don't use comprehensions in your daily coding very often, the first thing
    you should do is search through some existing code and find some `for` loops.
    See whether any of them can be trivially converted to a generator expression or
    a list, set, or dictionary comprehension.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你平时很少在代码中使用推导，你应该首先搜索一些现有的代码，找到一些`for`循环。看看它们是否可以轻易地转换为生成器表达式、列表、集合或字典推导。 '
- en: Test the claim that list comprehensions are faster than `for` loops. This can
    be done with the built-in `timeit` module. Use the help documentation for the
    `timeit.timeit` function to find out how to use it. Basically, write two functions
    that do the same thing, one using a list comprehension, and one using a `for`
    loop to iterate over several thousand items. Pass each function into `timeit.timeit`,
    and compare the results. If you're feeling adventurous, compare generators and
    generator expressions as well. Testing code using `timeit` can become addictive,
    so bear in mind that code does not need to be hyperfast unless it's being executed
    an immense number of times, such as on a huge input list or file.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 测试列表推导比`for`循环更快的说法。这可以通过内置的`timeit`模块来完成。使用`timeit.timeit`函数的帮助文档来了解如何使用它。基本上，写两个执行相同操作的功能，一个使用列表推导，另一个使用`for`循环遍历数千个项目。将每个函数传递给`timeit.timeit`，并比较结果。如果你觉得冒险，也可以比较生成器和生成器表达式。使用`timeit`测试代码可能会变得上瘾，所以请记住，除非代码被大量执行，例如在巨大的输入列表或文件上，否则代码不需要非常快。
- en: Play around with generator functions. Start with basic iterators that require
    multiple values (mathematical sequences are canonical examples; the Fibonacci
    sequence is overused if you can't think of anything better). Try some more advanced
    generators that do things such as take multiple input lists and somehow yield
    values that merge them. Generators can also be used on files; can you write a
    simple generator that shows lines that are identical in two files?
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用生成器函数。从需要多个值的简单迭代器开始（数学序列是典型的例子；如果你想不到更好的例子，斐波那契序列可能会被过度使用）。尝试一些更高级的生成器，它们可以执行诸如合并多个输入列表并从中产生值等操作。生成器也可以用于文件；你能写一个简单的生成器，显示两个文件中相同的行吗？
- en: Coroutines abuse the iterator protocol but don't actually fulfill the iterator
    pattern. Can you build a non-coroutine version of the code that gets a serial
    number from a log file? Take an object-oriented approach so that you can store
    an additional state on a class. You'll learn a lot about coroutines if you can
    create an object that is a drop-in replacement for the existing coroutine.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 协程滥用迭代器协议，但实际上并不满足迭代器模式。你能构建一个非协程版本的代码，从日志文件中获取序列号吗？采用面向对象的方法，以便你可以在类上存储额外的状态。如果你能创建一个对象，它可以替代现有的协程，那么你将学到很多关于协程的知识。
- en: The case study for this chapter has a lot of odd tuples of tuples being passed
    around that are hard to keep track of. See whether you can replace those return
    values with more object-oriented solutions. Also, experiment with moving some
    of the functions that share data (for example, `model_colors` and `target_colors`)
    into a class. That should reduce the number of arguments that have to be passed
    into most of the generators since they can look them up on `self`.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的案例研究有很多奇特的元组元组传递，难以跟踪。看看你是否可以用更面向对象的方法替换那些返回值。此外，尝试将一些共享数据的函数（例如，`model_colors`和`target_colors`）移动到一个类中。这应该会减少大多数生成器需要传递的参数数量，因为它们可以在`self`中查找它们。
- en: Summary
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned that design patterns are useful abstractions that
    provide best-practice solutions for common programming problems. We covered our
    first design pattern, the iterator, as well as numerous ways that Python uses
    and abuses this pattern for its own nefarious purposes. The original iterator
    pattern is extremely object-oriented, but it is also rather ugly and verbose to
    code around. However, Python's built-in syntax abstracts the ugliness away, leaving
    us with a clean interface to these object-oriented constructs.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解到设计模式是有用的抽象，为常见的编程问题提供了最佳实践解决方案。我们介绍了我们的第一个设计模式——迭代器，以及Python使用和滥用此模式的各种方式，以实现其自身的邪恶目的。原始的迭代器模式非常面向对象，但编写代码时既丑陋又冗长。然而，Python的内置语法抽象掉了这种丑陋，为我们提供了面向对象构造的干净接口。
- en: Comprehensions and generator expressions can combine container construction
    with iteration in a single line. Generator objects can be constructed using the
    `yield` syntax. Coroutines look like generators on the outside but serve a much
    different purpose.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 理解和生成器表达式可以将容器构造与迭代结合到一行中。可以使用`yield`语法构造生成器对象。协程在外观上类似于生成器，但它们服务于完全不同的目的。
- en: We'll cover several more design patterns in the next two chapters.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的两章中，我们将介绍更多设计模式。
