<html><head></head><body>
<section id="chapter-13-the-pymonad-library" class="level2 chapterHead" data-number="0.17">&#13;
<h2 class="chapterHead" data-number="0.17"><span class="titlemark"> 13</span><br/>&#13;
<span id="x1-26600013"/>The PyMonad Library</h2>&#13;
<p>A monad allows us to impose an order on an expression evaluation in an otherwise lenient language. We can use a monad to insist that an expression such as <span class="obeylines-h"><span class="verb"><code class="inlineCode">a</code><code class="inlineCode"> +</code><code class="inlineCode"> b</code><code class="inlineCode"> +</code><code class="inlineCode"> c</code></span></span> is evaluated in left-to-right order. This can interfere with the compiler’s ability to optimize expression evaluation. This is necessary, however, when we want files to have their content read or written in a specific order: a monad is a way to assure that the <span class="obeylines-h"><span class="verb"><code class="inlineCode">read()</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">write()</code></span></span> functions are evaluated in a particular order.</p>&#13;
<p>Languages that are lenient and have optimizing compilers benefit from monads imposing order on the evaluation of expressions. Python, for the most part, is strict and does not optimize, meaning there are few practical requirements for monads in Python.</p>&#13;
<p>While the PyMonad package contains a variety of monads and other functional tools, much of the package was designed to help folks understand functional programming using Python syntax. We’ll focus on a few features to help clarify this point of view.</p>&#13;
<p>In this chapter, we’ll look at the following:</p>&#13;
<ul>&#13;
<li><p>Downloading and installing PyMonad</p></li>&#13;
<li><p>The idea of currying and how this applies to functional composition</p></li>&#13;
<li><p>The PyMonad star operator for creating composite functions</p></li>&#13;
<li><p>Functors and techniques for currying data items with more generalized functions</p></li>&#13;
<li><p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">bind()</code></span></span> operation, using the Python <span class="obeylines-h"><span class="verb"><code class="inlineCode">&gt;&gt;</code></span></span> operator, to create ordered monads</p></li>&#13;
<li><p>We’ll also explain how to build a Markov chain simulation using PyMonad techniques</p></li>&#13;
</ul>&#13;
<p>What’s important is that Python doesn’t require the use of monads. In many cases, the reader will be able to rewrite the example using pure Python constructs. Doing this kind of rewrite can help solidify one’s understanding of functional programming. <span id="x1-266001r268"/></p>&#13;
<section id="downloading-and-installing" class="level3 sectionHead" data-number="0.17.1">&#13;
<h3 class="sectionHead" data-number="0.17.1"><span class="titlemark">13.1 </span> <span id="x1-2670001"/>Downloading and installing</h3>&#13;
<p>The PyMonad<span id="dx1-267001"/> package is available on the <span class="keyWord">Python Package Index </span>(<span class="keyWord">PyPI</span>). In order<span id="dx1-267002"/> to add PyMonad to your environment, you’ll need to use the <span class="obeylines-h"><span class="verb"><code class="inlineCode">python</code><code class="inlineCode"> -m</code><code class="inlineCode"> pip</code><code class="inlineCode"> pymonad</code></span></span> command to install it.</p>&#13;
<div id="tcolobox-266" class="infobox note">&#13;
&#13;
&#13;
<p>This book used version 2.4.0 to test all of the examples. Visit <a href="https://pypi.python.org/pypi/PyMonad" class="url">https://pypi.python.org/pypi/PyMonad</a> for more information.</p>&#13;
&#13;
</div>&#13;
<p>Once the PyMonad<span id="dx1-267003"/> package is installed, you can confirm it using the following commands:</p>&#13;
<div id="tcolobox-267" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; import pymonad &#13;
&gt;&gt;&gt; help(pymonad)</code></pre>&#13;
&#13;
</div>&#13;
<p>This will display the module’s docstring and confirm that things really are properly installed.</p>&#13;
<p>The overall project name, PyMonad, uses mixed case. The installed Python package name that we import, <span class="obeylines-h"><span class="verb"><code class="inlineCode">pymonad</code></span></span>, is all lower case. <span id="x1-267007r275"/></p>&#13;
</section>&#13;
<section id="functional-composition-and-currying" class="level3 sectionHead" data-number="0.17.2">&#13;
<h3 class="sectionHead" data-number="0.17.2"><span class="titlemark">13.2 </span> <span id="x1-2680002"/>Functional composition and currying</h3>&#13;
<p>Some functional<span id="dx1-268001"/> languages work by transforming a multi-argument function syntax into a collection of single argument functions. This process<span id="dx1-268002"/> is called <span class="keyWord">currying</span>: it’s named after logician Haskell Curry, who developed the theory from earlier concepts. We’ve looked at currying in depth in <a href="Chapter_11.xhtml#x1-23500011"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 11</span></a>, <a href="Chapter_11.xhtml#x1-23500011"><span class="cmti-10x-x-109">The Toolz Package</span></a>. We’ll revisit it from the PyMonad perspective here.</p>&#13;
<p>Currying is a technique<span id="dx1-268003"/> for transforming a multi-argument function into higher-order single argument functions. In a simple case, consider a function <span class="italic">f</span>(<span class="italic">x,y</span>) <span class="cmsy-10x-x-109">→ </span><span class="italic">z</span>; given two arguments <span class="italic">x </span>and <span class="italic">y</span>; this will return some resulting value, <span class="italic">z</span>. We can curry the function <span class="italic">f</span>(<span class="italic">x,y</span>) into into two functions: <span class="italic">f</span><sub><span class="cmmi-8">c</span><span class="cmr-8">1</span></sub>(<span class="italic">x</span>) <span class="cmsy-10x-x-109">→ </span><span class="italic">f</span><sub><span class="cmmi-8">c</span><span class="cmr-8">2</span></sub>(<span class="italic">y</span>) and <span class="italic">f</span><sub><span class="cmmi-8">c</span><span class="cmr-8">2</span></sub>(<span class="italic">y</span>) <span class="cmsy-10x-x-109">→ </span><span class="italic">z</span>. Given the first argument value, <span class="italic">x</span>, evaluating the function <span class="italic">f</span><sub><span class="cmmi-8">c</span><span class="cmr-8">1</span></sub>(<span class="italic">x</span>) returns a new one-argument function, <span class="italic">f</span><sub><span class="cmmi-8">c</span><span class="cmr-8">2</span></sub>(<span class="italic">y</span>). This second function can be given the second argument value, <span class="italic">y</span>, and it returns the desired result, <span class="italic">z</span>.</p>&#13;
<p>We can evaluate a curried function in Python with concrete argument values as follows: <span class="obeylines-h"><span class="verb"><code class="inlineCode">f_c1(2)(3)</code></span></span>. We apply the curried function to the first argument value of 2, creating a new function. Then, we apply that new function to the second argument value of 3.</p>&#13;
<p>Let’s look at a concrete example in Python. For example, we have a function like the following one:</p>&#13;
<pre id="listing-271" class="lstlisting"><code>from pymonad.tools import curry  # type: ignore[import] &#13;
 &#13;
@curry(4)  # type: ignore[misc] &#13;
def systolic_bp( &#13;
    bmi: float, age: float, gender_male: float, treatment: float &#13;
) -&gt; float: &#13;
    return ( &#13;
        68.15 + 0.58 * bmi + 0.65 * age + 0.94 * gender_male + 6.44 * treatment &#13;
    )</code></pre>&#13;
<p>This is a simple, multiple-regression-based model for systolic blood pressure. This predicts blood pressure from body mass index (BMI), age, gender (a value of 1 means male), and history of previous treatment (a value of 1 means previously treated). For more information on the model and how it’s derived, visit <a href="http://sphweb.bumc.bu.edu/otlt/MPH-Modules/BS/BS704_Multivariable/BS704_Multivariable7.html" class="url">http://sphweb.bumc.bu.edu/otlt/MPH-Modules/BS/BS704_Multivariable/BS704_Multivariable7.html</a>.</p>&#13;
<p>We can use the <span class="obeylines-h"><span class="verb"><code class="inlineCode">systolic_bp()</code></span></span> function with all four arguments, as follows:</p>&#13;
<div id="tcolobox-268" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; systolic_bp(25, 50, 1, 0) &#13;
116.09 &#13;
 &#13;
&gt;&gt;&gt; systolic_bp(25, 50, 0, 1) &#13;
121.59</code></pre>&#13;
&#13;
</div>&#13;
<p>A male person with a BMI of 25, age 50, and no previous treatment is predicted to have a blood pressure near 116. The second example<span id="dx1-268019"/> shows a similar woman with a history of treatment who will likely have a blood pressure of 121.</p>&#13;
<p>Because we’ve used the <span class="obeylines-h"><span class="verb"><code class="inlineCode">@curry</code></span></span> decorator, we can create intermediate results that are similar to partially applied functions. Take a look at the following command snippet that creates a new function, <span class="obeylines-h"><span class="verb"><code class="inlineCode">treated()</code></span></span>:</p>&#13;
<pre>&gt;&gt;&gt; treated = systolic_bp(25, 50, 0)&#13;
&gt;&gt;&gt; treated(0)&#13;
115.15&#13;
&gt;&gt;&gt; treated(1)&#13;
121.59&#13;
</pre>&#13;
<p>In the preceding case, we evaluated the <span class="obeylines-h"><span class="verb"><code class="inlineCode">systolic_bp(25,</code><code class="inlineCode"> 50,</code><code class="inlineCode"> 0)</code></span></span> expression to create a curried function and assigned this to the <span class="obeylines-h"><span class="verb"><code class="inlineCode">treated</code></span></span> variable. This built a new function, <span class="obeylines-h"><span class="verb"><code class="inlineCode">treated</code></span></span>, with values for some of the parameters. The BMI, age, and gender values don’t typically change for a given patient. We can now apply the new <span class="obeylines-h"><span class="verb"><code class="inlineCode">treated()</code></span></span> function to the remaining argument value to get different blood pressure expectations based on patient history.</p>&#13;
<p>Here’s an example of creating some additional curried functions:</p>&#13;
<div id="tcolobox-269" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; g_t = systolic_bp(25, 50) &#13;
&gt;&gt;&gt; g_t(1, 0) &#13;
116.09 &#13;
&gt;&gt;&gt; g_t(0, 1) &#13;
121.59</code></pre>&#13;
&#13;
</div>&#13;
<p>This is a gender-based treatment function based on our initial model. We must provide both the needed gender and treatment<span id="dx1-268032"/> argument values to get a final value from the model.</p>&#13;
<p>This is similar in some respects to the <span class="obeylines-h"><span class="verb"><code class="inlineCode">functools.partial()</code></span></span> function. The important difference is that currying creates a function that can work in a variety of ways. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">functools.partial()</code></span></span> function creates a more specialized function that can only be used with the given set of bound values. For more information, see <a href="Chapter_10.xhtml#x1-21700010"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 10</span></a>, <a href="Chapter_10.xhtml#x1-21700010"><span class="cmti-10x-x-109">The Functools</span> <span class="cmti-10x-x-109">Module</span></a>. <span id="x1-268033r273"/></p>&#13;
<section id="using-curried-higher-order-functions" class="level4 subsectionHead" data-number="0.17.2.1">&#13;
<h4 class="subsectionHead" data-number="0.17.2.1"><span class="titlemark">13.2.1 </span> <span id="x1-2690001"/>Using curried higher-order functions</h4>&#13;
<p>An important application<span id="dx1-269001"/> of currying shows up when we use it on higher-order functions. We can, for example, curry the <span class="obeylines-h"><span class="verb"><code class="inlineCode">reduce</code></span></span> function, as follows:</p>&#13;
<div id="tcolobox-270" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; from pymonad.tools import curry &#13;
&gt;&gt;&gt; from functools import reduce &#13;
 &#13;
&gt;&gt;&gt; creduce = curry(2, reduce)</code></pre>&#13;
&#13;
</div>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">creduce()</code></span></span> function is a curried function; we can now use it to create functions by providing some of the required argument values. In the next example, we will use <span class="obeylines-h"><span class="verb"><code class="inlineCode">operator.add</code></span></span> as one of the two argument values to reduce. We can create a new function, and assign this to <span class="obeylines-h"><span class="verb"><code class="inlineCode">my_sum</code></span></span>.</p>&#13;
<p>We can create and use this new <span class="obeylines-h"><span class="verb"><code class="inlineCode">my_sum()</code></span></span> function as shown in the following example:</p>&#13;
<div id="tcolobox-271" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; from operator import add &#13;
 &#13;
&gt;&gt;&gt; my_sum = creduce(add) &#13;
&gt;&gt;&gt; my_sum([1,2,3]) &#13;
6</code></pre>&#13;
&#13;
</div>&#13;
<p>We can also use our curried <span class="obeylines-h"><span class="verb"><code class="inlineCode">creduce()</code></span></span> function with other binary operators to create other reductions. The following shows how to create a reduction function that finds the maximum value in a sequence:</p>&#13;
<div id="tcolobox-272" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; my_max = creduce(lambda x,y: x if x &gt; y else y) &#13;
&gt;&gt;&gt; my_max([2,5,3]) &#13;
5</code></pre>&#13;
&#13;
</div>&#13;
<p>We defined our own version of the default <span class="obeylines-h"><span class="verb"><code class="inlineCode">max()</code></span></span> function using a lambda object that picks the larger of two values. We could use the built-in <span class="obeylines-h"><span class="verb"><code class="inlineCode">max()</code></span></span> function for this. More usefully, we could use more sophisticated comparisons<span id="dx1-269017"/> among items to locate a local maxima. For geofencing applications, we might have a maximum east-west function separate from a maximum north-south function.</p>&#13;
<p>We can’t easily create the more general form of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">max()</code></span></span> function using the PyMonad <span class="obeylines-h"><span class="verb"><code class="inlineCode">curry()</code></span></span> function. This implementation is focused on positional parameters. Trying to use the <span class="obeylines-h"><span class="verb"><code class="inlineCode">key=</code></span></span> keyword parameter adds too much complexity to make the technique work toward our overall goals of succinct and expressive functional programs.</p>&#13;
<p>The built-in reductions including the <span class="obeylines-h"><span class="verb"><code class="inlineCode">max()</code></span></span>, <span class="obeylines-h"><span class="verb"><code class="inlineCode">min()</code></span></span>, and <span class="obeylines-h"><span class="verb"><code class="inlineCode">sorted()</code></span></span> functions all rely on an optional <span class="obeylines-h"><span class="verb"><code class="inlineCode">key=</code></span></span> keyword parameter paradigm. Creating curried versions means we need variants of these that accept a function as the first argument in the same way as the <span class="obeylines-h"><span class="verb"><code class="inlineCode">filter()</code></span></span>, <span class="obeylines-h"><span class="verb"><code class="inlineCode">map()</code></span></span>, and <span class="obeylines-h"><span class="verb"><code class="inlineCode">reduce()</code></span></span> functions do. We could also create our own library of more consistent higher-order curried functions. These functions would rely exclusively on positional parameters, and follow the pattern of providing the function first and the values last. <span id="x1-269018r277"/></p>&#13;
</section>&#13;
<section id="functional-composition-with-pymonad" class="level4 subsectionHead" data-number="0.17.2.2">&#13;
<h4 class="subsectionHead" data-number="0.17.2.2"><span class="titlemark">13.2.2 </span> <span id="x1-2700002"/>Functional composition with PyMonad</h4>&#13;
<p>One of the significant<span id="dx1-270001"/> benefits of using curried<span id="dx1-270002"/> functions is the ability to combine them through functional composition. We looked at functional composition in <a href="Chapter_05.xhtml#x1-1000005"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 5</span></a>, <a href="Chapter_05.xhtml#x1-1000005"><span class="cmti-10x-x-109">Higher-Order Functions</span></a>, and <a href="Chapter_12.xhtml#x1-25000012"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 12</span></a>, <a href="Chapter_12.xhtml#x1-25000012"><span class="cmti-10x-x-109">Decorator Design</span> <span class="cmti-10x-x-109">Techniques</span></a>.</p>&#13;
<p>When we’ve created a curried function, we can more easily perform function composition to create a new, more complex curried function. In this case, the PyMonad package defines the <span class="obeylines-h"><span class="verb"><code class="inlineCode">*</code></span></span> operator for composing two functions. To explain how this works, we’ll define two curried functions that we can compose. First, we’ll define a function that computes the product, and then we’ll define a function<span id="dx1-270003"/> that computes<span id="dx1-270004"/> a specialized range of values.</p>&#13;
<p>Here’s our first function, which computes the product:</p>&#13;
<pre id="listing-272" class="lstlisting"><code>import operator &#13;
 &#13;
prod = creduce(operator.mul)</code></pre>&#13;
<p>This is based on our curried <span class="obeylines-h"><span class="verb"><code class="inlineCode">creduce()</code></span></span> function that was defined previously. It uses the <span class="obeylines-h"><span class="verb"><code class="inlineCode">operator.mul()</code></span></span> function to compute a <span class="cmti-10x-x-109">times-reduction </span>of an iterable: we can call a product a times-reduce of a sequence.</p>&#13;
<p>Here’s our second curried function that will produce a range of even or odd values:</p>&#13;
<pre id="listing-273" class="lstlisting"><code>from collections.abc import Iterable &#13;
 &#13;
@curry(1)  # type: ignore[misc] &#13;
def alt_range(n: int) -&gt; Iterable[int]: &#13;
    if n == 0: &#13;
        return range(1, 2)  # Only the value [1] &#13;
    elif n % 2 == 0: &#13;
        return range(2, n+1, 2)  # Even &#13;
    else: &#13;
        return range(1, n+1, 2)  # Odd</code></pre>&#13;
<p>The result of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">alt_range()</code></span></span> function will be even values or odd values. It will have only odd values up to (and including) <span class="obeylines-h"><span class="verb"><code class="inlineCode">n</code></span></span>, if <span class="obeylines-h"><span class="verb"><code class="inlineCode">n</code></span></span> is odd. If <span class="obeylines-h"><span class="verb"><code class="inlineCode">n</code></span></span> is even, it will have only even values up to <span class="obeylines-h"><span class="verb"><code class="inlineCode">n</code></span></span>. The sequences are important for implementing the semifactorial or double factorial function, <span class="italic">n</span>!!.</p>&#13;
<p>Here’s how we can combine the <span class="obeylines-h"><span class="verb"><code class="inlineCode">prod()</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">alt_range()</code></span></span> functions to compute a result:</p>&#13;
<div id="tcolobox-273" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; prod(alt_range(9)) &#13;
945</code></pre>&#13;
&#13;
</div>&#13;
<p>One very interesting use of curried functions is the idea of creating a composition of those functions that can be applied to argument<span id="dx1-270021"/> values. The PyMonad package provides operators for this, but they can be confusing. What seems better is making use of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">Compose</code></span></span> subclass of <span class="obeylines-h"><span class="verb"><code class="inlineCode">Monad</code></span></span>.</p>&#13;
<p>We can use <span class="obeylines-h"><span class="verb"><code class="inlineCode">Compose</code></span></span> to implement functional<span id="dx1-270022"/> composition in a direct way. The following example shows how we can compose our <span class="obeylines-h"><span class="verb"><code class="inlineCode">alt_range()</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">prod()</code></span></span> functions to compute the semifactorial:</p>&#13;
<div id="tcolobox-274" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; from pymonad.reader import Compose &#13;
&gt;&gt;&gt; semi_fact = Compose(alt_range).then(prod) &#13;
&gt;&gt;&gt; semi_fact(9) &#13;
945</code></pre>&#13;
&#13;
</div>&#13;
<p>We’ve built a <span class="obeylines-h"><span class="verb"><code class="inlineCode">Compose</code></span></span> monad from the <span class="obeylines-h"><span class="verb"><code class="inlineCode">alt_range()</code></span></span> function composed with the <span class="obeylines-h"><span class="verb"><code class="inlineCode">prod()</code></span></span> function. The resulting function can be applied to an argument value to compute a result from the composition of the two functions.</p>&#13;
<p>Using curried functions can help to clarify a complex computation by eliding some of the argument-passing details.</p>&#13;
<div id="tcolobox-275" class="packt_tip">&#13;
&#13;
&#13;
<p>Note that the <span class="obeylines-h"><span class="verb"><code class="inlineCode">then()</code></span></span> method imposes a strict ordering: first, compute the range. Once that is done, use the result to compute the final product.</p>&#13;
&#13;
</div>&#13;
<p><span id="x1-270028r276"/></p>&#13;
</section>&#13;
</section>&#13;
<section id="functors-making-everything-a-function" class="level3 sectionHead" data-number="0.17.3">&#13;
<h3 class="sectionHead" data-number="0.17.3"><span class="titlemark">13.3 </span> <span id="x1-2710003"/>Functors – making everything a function</h3>&#13;
<p>The idea of a <span class="keyWord">functor </span>is a functional<span id="dx1-271001"/> representation of a piece of simple data. A functor version of the number 3.14 is a function of zero arguments that returns this value. Consider the following example:</p>&#13;
<div id="tcolobox-276" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; pi = lambda: 3.14 &#13;
&gt;&gt;&gt; pi() &#13;
3.14</code></pre>&#13;
&#13;
</div>&#13;
<p>We created a zero-argument lambda object that returns a Python float object.</p>&#13;
<p>When we apply a curried<span id="dx1-271006"/> function to a functor, we’re creating a new curried functor. This generalizes the idea of applying a function to an argument to get a value by using functions to represent the arguments, the values, and the functions themselves.</p>&#13;
<p>Once everything in our program is a function, then all processing becomes a variation on the theme of functional composition. To recover the underlying Python object, we can use the <span class="obeylines-h"><span class="verb"><code class="inlineCode">value</code></span></span> attribute of a functor object to get a Python-friendly, simple type that we can use in uncurried code.</p>&#13;
<p>Since this kind of programming is based on functional composition, no calculation needs to be done until we actually demand a value using the <span class="obeylines-h"><span class="verb"><code class="inlineCode">value</code></span></span> attribute. Instead of performing a lot of intermediate calculations, our program defines intermediate complex objects that can produce a value when requested. In principle, this composition can be optimized by a clever compiler or runtime system.</p>&#13;
<p>In order to work politely with functions that have multiple arguments, PyMonad offers a <span class="obeylines-h"><span class="verb"><code class="inlineCode">to_arguments()</code></span></span> method. This is a handy way to clarify the argument value being provided to a curried function. We’ll see an example of this below, after introducing the <span class="obeylines-h"><span class="verb"><code class="inlineCode">Maybe</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">Just</code></span></span> monads.</p>&#13;
<p>We can wrap a Python object with a subclass of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">Maybe</code></span></span> monad. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">Maybe</code></span></span> monad is interesting, because it gives us a way to deal gracefully with missing data. The approach we used in <a href="Chapter_12.xhtml#x1-25000012"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 12</span></a>, <a href="Chapter_12.xhtml#x1-25000012"><span class="cmti-10x-x-109">Decorator Design Techniques</span></a>, was to decorate built-in functions to make them <span class="obeylines-h"><span class="verb"><code class="inlineCode">None</code></span></span>-aware. The approach taken by the PyMonad library is to decorate the data to distinguish something that’s <span class="cmti-10x-x-109">just an</span> <span class="cmti-10x-x-109">object </span>from <span class="cmti-10x-x-109">nothing</span>.</p>&#13;
<p>There are two subclasses of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">Maybe</code></span></span> monad:</p>&#13;
<ul>&#13;
<li><p><span class="obeylines-h"><span class="verb"><code class="inlineCode">Nothing</code></span></span></p></li>&#13;
<li><p><span class="obeylines-h"><span class="verb"><code class="inlineCode">Just(</code></span></span> <span class="cmti-10x-x-109">some Python object </span><span class="obeylines-h"><span class="verb"><code class="inlineCode">)</code></span></span></p></li>&#13;
</ul>&#13;
<p>We use <span class="obeylines-h"><span class="verb"><code class="inlineCode">Nothing</code></span></span> similarly to the Python value of <span class="obeylines-h"><span class="verb"><code class="inlineCode">None</code></span></span>. This is how we represent missing data. We use <span class="obeylines-h"><span class="verb"><code class="inlineCode">Just()</code></span></span> to wrap all other Python objects. These are also functors, offering function-like representations of constant values.</p>&#13;
<p>We can use a curried function<span id="dx1-271007"/> with these <span class="obeylines-h"><span class="verb"><code class="inlineCode">Maybe</code></span></span> objects to tolerate missing data gracefully. Here’s a short example:</p>&#13;
<div id="tcolobox-277" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; from pymonad.maybe import Maybe, Just, Nothing &#13;
 &#13;
&gt;&gt;&gt; x1 = Maybe.apply(systolic_bp).to_arguments(Just(25), Just(50), Just(1), Just(0)) &#13;
&gt;&gt;&gt; x1.value &#13;
116.09 &#13;
 &#13;
&gt;&gt;&gt; x2 = Maybe.apply(systolic_bp).to_arguments(Just(25), Just(50), Just(1), Nothing) &#13;
&gt;&gt;&gt; x2 &#13;
Nothing &#13;
&gt;&gt;&gt; x2.value is None &#13;
True</code></pre>&#13;
&#13;
</div>&#13;
<p>This shows us how a monad can provide an answer instead of raising a <span class="obeylines-h"><span class="verb"><code class="inlineCode">TypeError</code></span></span> exception. This can be very handy when working with large, complex datasets in which data could be missing or invalid.</p>&#13;
<div id="tcolobox-278" class="packt_tip">&#13;
&#13;
&#13;
<p>We must use the <span class="obeylines-h"><span class="verb"><code class="inlineCode">value</code></span></span> attribute to extract the simple Python value for uncurried Python code.</p>&#13;
&#13;
</div>&#13;
<p><span id="x1-271020r278"/></p>&#13;
<section id="using-the-lazy-listmonad-monad" class="level4 subsectionHead" data-number="0.17.3.1">&#13;
<h4 class="subsectionHead" data-number="0.17.3.1"><span class="titlemark">13.3.1 </span> <span id="x1-2720001"/>Using the lazy ListMonad() monad</h4>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">ListMonad()</code></span></span> monad can be confusing<span id="dx1-272001"/> at first. It’s extremely lazy, unlike Python’s built-in list type. When we evaluate the a <span class="obeylines-h"><span class="verb"><code class="inlineCode">list(range(10))</code></span></span> expression, the <span class="obeylines-h"><span class="verb"><code class="inlineCode">list()</code></span></span> function will evaluate the <span class="obeylines-h"><span class="verb"><code class="inlineCode">range()</code></span></span> object to create a list with 10 items. The PyMonad <span class="obeylines-h"><span class="verb"><code class="inlineCode">ListMonad()</code></span></span> monad, however, is too lazy to even do this evaluation.</p>&#13;
<p>Here’s the comparison:</p>&#13;
<div id="tcolobox-279" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; list(range(10)) &#13;
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9] &#13;
 &#13;
&gt;&gt;&gt; from pymonad.list import ListMonad &#13;
&gt;&gt;&gt; ListMonad(range(10)) &#13;
[range(0, 10)]</code></pre>&#13;
&#13;
</div>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">ListMonad()</code></span></span> monad did not evaluate the <span class="obeylines-h"><span class="verb"><code class="inlineCode">range()</code></span></span> object’s iterable sequence of values; it preserved it without being evaluated. A <span class="obeylines-h"><span class="verb"><code class="inlineCode">ListMonad()</code></span></span> monad is useful for collecting functions without evaluating them.</p>&#13;
<p>We can evaluate the <span class="obeylines-h"><span class="verb"><code class="inlineCode">ListMonad()</code></span></span> monad later as required:</p>&#13;
<div id="tcolobox-280" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; from pymonad.list import ListMonad &#13;
 &#13;
&gt;&gt;&gt; x = ListMonad(range(10)) &#13;
&gt;&gt;&gt; x &#13;
[range(0, 10)] &#13;
&gt;&gt;&gt; x[0] &#13;
range(0, 10) &#13;
&gt;&gt;&gt; list(x[0]) &#13;
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</code></pre>&#13;
&#13;
</div>&#13;
<p>We created a lazy <span class="obeylines-h"><span class="verb"><code class="inlineCode">ListMonad()</code></span></span> object which contained a <span class="obeylines-h"><span class="verb"><code class="inlineCode">range()</code></span></span> object. Then we extracted and evaluated a <span class="obeylines-h"><span class="verb"><code class="inlineCode">range()</code></span></span> object at position 0 in that list.</p>&#13;
<p>A <span class="obeylines-h"><span class="verb"><code class="inlineCode">ListMonad()</code></span></span> object won’t evaluate<span id="dx1-272019"/> a generator function. It treats any iterable argument as a single iterator object. We can, later, apply the function being contained by the monad.</p>&#13;
<p>Here’s a curried version of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">range()</code></span></span> function. This has a lower bound of 1 instead of 0. It’s handy for some mathematical work because it allows us to avoid the complexity of the positional arguments in the built-in <span class="obeylines-h"><span class="verb"><code class="inlineCode">range()</code></span></span> function:</p>&#13;
<pre id="listing-274" class="lstlisting"><code>from collections.abc import Iterator &#13;
from pymonad.tools import curry &#13;
 &#13;
@curry(1)  # type: ignore[misc] &#13;
def range1n(n: int) -&gt; range: &#13;
    if n == 0: return range(1, 2)  # Only the value 1 &#13;
    return range(1, n+1)</code></pre>&#13;
<p>We wrapped<span id="dx1-272027"/> the built-in <span class="obeylines-h"><span class="verb"><code class="inlineCode">range()</code></span></span> function to make it curryable by the PyMonad package.</p>&#13;
<p>Since a <span class="obeylines-h"><span class="verb"><code class="inlineCode">ListMonad</code></span></span> object is a functor, we can map functions to the <span class="obeylines-h"><span class="verb"><code class="inlineCode">ListMonad</code></span></span> object. The function is applied to each item in the <span class="obeylines-h"><span class="verb"><code class="inlineCode">ListMonad</code></span></span> object.</p>&#13;
<p>Here’s an example:</p>&#13;
<div id="tcolobox-281" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; from pymonad.reader import Compose &#13;
&gt;&gt;&gt; from pymonad.list import ListMonad &#13;
 &#13;
&gt;&gt;&gt; fact = Compose(range1n).then(prod) &#13;
&gt;&gt;&gt; seq1 = ListMonad(*range(20)) &#13;
 &#13;
&gt;&gt;&gt; f1 = seq1.map(fact) &#13;
&gt;&gt;&gt; f1[:10] &#13;
[1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880]</code></pre>&#13;
&#13;
</div>&#13;
<p>We defined a composite function, <span class="obeylines-h"><span class="verb"><code class="inlineCode">fact()</code></span></span>, which was built from the <span class="obeylines-h"><span class="verb"><code class="inlineCode">prod()</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">range1n()</code></span></span> functions shown previously. This is the factorial function. We created a <span class="obeylines-h"><span class="verb"><code class="inlineCode">ListMonad()</code></span></span> functor, <span class="obeylines-h"><span class="verb"><code class="inlineCode">seq1</code></span></span>, which is a sequence of 20 values. We mapped the <span class="obeylines-h"><span class="verb"><code class="inlineCode">fact()</code></span></span> function to the <span class="obeylines-h"><span class="verb"><code class="inlineCode">seq1</code></span></span> functor, which created a sequence of factorial values, <span class="obeylines-h"><span class="verb"><code class="inlineCode">f1</code></span></span>. Finally, we extracted the first 10 of these values.</p>&#13;
<p>Here’s another little function that we’ll use to extend this example:</p>&#13;
<pre id="listing-275" class="lstlisting"><code>from pymonad.tools import curry &#13;
 &#13;
@curry(1)  # type: ignore[misc] &#13;
def n21(n: int) -&gt; int: &#13;
    return 2*n+1</code></pre>&#13;
<p>This little <span class="obeylines-h"><span class="verb"><code class="inlineCode">n21()</code></span></span> function does a simple<span id="dx1-272043"/> computation. It’s curried, however, so we can apply it to a functor such as a <span class="obeylines-h"><span class="verb"><code class="inlineCode">ListMonad()</code></span></span> object. Here’s the next part of the preceding example:</p>&#13;
<div id="tcolobox-282" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; semi_fact = Compose(alt_range).then(prod) &#13;
&gt;&gt;&gt; f2 = seq1.map(n21).then(semi_fact) &#13;
&gt;&gt;&gt; f2[:10] &#13;
[1, 3, 15, 105, 945, 10395, 135135, 2027025, 34459425, 654729075]</code></pre>&#13;
&#13;
</div>&#13;
<p>We’ve defined a composite function from the <span class="obeylines-h"><span class="verb"><code class="inlineCode">prod()</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">alt_range()</code></span></span> functions shown previously. The value of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">f2</code></span></span> object is built by mapping our small <span class="obeylines-h"><span class="verb"><code class="inlineCode">n21()</code></span></span> function applied to the <span class="obeylines-h"><span class="verb"><code class="inlineCode">seq1</code></span></span> sequence. This creates a new sequence. We then applied the <span class="obeylines-h"><span class="verb"><code class="inlineCode">semi_fact()</code></span></span> function to each object in this new sequence to create a sequence of values that are parallels to the <span class="obeylines-h"><span class="verb"><code class="inlineCode">f1</code></span></span> sequence of values.</p>&#13;
<p>We can now map the <span class="obeylines-h"><span class="verb"><code class="inlineCode">/</code></span></span> operator, <span class="obeylines-h"><span class="verb"><code class="inlineCode">operator.truediv</code></span></span>, to these two parallel sequences of values, <span class="obeylines-h"><span class="verb"><code class="inlineCode">f1</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">f2</code></span></span>:</p>&#13;
<div id="tcolobox-283" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; import operator &#13;
&gt;&gt;&gt; 2 * sum(map(operator.truediv, f1, f2)) &#13;
3.1415919276751456</code></pre>&#13;
&#13;
</div>&#13;
<p>The built-in <span class="obeylines-h"><span class="verb"><code class="inlineCode">map()</code></span></span> function will apply the given operator to both functors, yielding a sequence of fractions that we can add.</p>&#13;
<p>We defined a fairly complex calculation using a few functional composition techniques and a functor class definition. This is based on a computation for the arctangent. Here’s the full definition for this calculation:</p>&#13;
<div class="math-display" style="text-align:center">&#13;
<img src="../Images/file119.jpg" class="math-display" alt=" ∑ ---n!---- π = 2 (2n + 1)!! 0≤n&lt;∞ "/>&#13;
</div>&#13;
<p>Ideally, we prefer not to use a fixed-size <span class="obeylines-h"><span class="verb"><code class="inlineCode">ListMonad</code></span></span> object with only twenty values. We’d prefer to have a lazy and potentially<span id="dx1-272053"/> infinite sequence of integer values, allowing us an approximation of arbitrary accuracy. We could then use curried versions of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">sum()</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">takewhile()</code></span></span> functions to find the sum of values in the sequence until the values are too small to contribute to the result.</p>&#13;
<p>This rewrite to use the <span class="obeylines-h"><span class="verb"><code class="inlineCode">takewhile()</code></span></span> function is left as an exercise for the reader. <span id="x1-272054r279"/></p>&#13;
</section>&#13;
</section>&#13;
<section id="monad-bind-function" class="level3 sectionHead" data-number="0.17.4">&#13;
<h3 class="sectionHead" data-number="0.17.4"><span class="titlemark">13.4 </span> <span id="x1-2730004"/>Monad bind() function</h3>&#13;
<p>The name of the PyMonad library comes<span id="dx1-273001"/> from the functional programming concept of a monad, a function that has a strict order. The underlying assumption behind much functional programming is that functional evaluation is liberal: it can be optimized or rearranged as necessary. A monad provides an exception that imposes a strict left-to-right order.</p>&#13;
<p>Python, as we have seen, is already strict. It doesn’t <span class="cmti-10x-x-109">require </span>monads. We can, however, still apply the concept in places where it can help clarify a complex algorithm. We’ll look at an example, below, of using a monad-based approach to designing a simulation based on Markov chains.</p>&#13;
<p>The technology for imposing strict evaluation is a binding between a monad and a function that will return a monad. A <span class="cmti-10x-x-109">flat </span>expression will become nested bindings that can’t be reordered by an optimizing compiler. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">then()</code></span></span> method of a monad imposes this strict ordering.</p>&#13;
<p>In other languages, such as Haskell, a monad is crucial for file input and output where strict ordering is required. Python’s imperative mode is much like a Haskell <span class="obeylines-h"><span class="verb"><code class="inlineCode">do</code></span></span> block, which has an implicit Haskell <span class="obeylines-h"><span class="verb"><code class="inlineCode">&gt;&gt;=</code></span></span> operator to force the statements to be evaluated in order. PyMonad uses the <span class="obeylines-h"><span class="verb"><code class="inlineCode">then()</code></span></span> method for this binding. <span id="x1-273002r281"/></p>&#13;
</section>&#13;
<section id="implementing-simulation-with-monads" class="level3 sectionHead" data-number="0.17.5">&#13;
<h3 class="sectionHead" data-number="0.17.5"><span class="titlemark">13.5 </span> <span id="x1-2740005"/>Implementing simulation with monads</h3>&#13;
<p>Monads are expected<span id="dx1-274001"/> to pass through<span id="dx1-274002"/> a kind of <span class="cmti-10x-x-109">pipeline</span>: a monad will be passed as an argument to a function and a similar monad will be returned as the value of the function. The functions must be designed to accept and return similar structures.</p>&#13;
<p>We’ll look at a monad-based pipeline that can be used for simulation of a process. This kind of simulation is sometimes called<span id="dx1-274003"/> a <span class="keyWord">Monte Carlo </span>simulation. In this case, the simulation will create a <span class="keyWord">Markov chain</span>.</p>&#13;
<p>A Markov<span id="dx1-274004"/> chain is a model<span id="dx1-274005"/> for a series of potential events. The probability of each event depends only on the state attained in the previous event. Each state of the overall system had a set of probabilities that define the events and related state changes. It fits well with games that involve random chance, like dice or cards. It also fits well with industrial processes where small random effects can ”ripple through” the system, leading to effects that may not appear to be—directly—related to tiny initial problems.</p>&#13;
<p>Our example involves some rules for a fairly complex simulation. We can visualize the following state changes shown in <span class="cmti-10x-x-109">Figure </span><span class="cmti-10x-x-109">13.1</span> as creating a chain of events that ends with either a Pass or Fail event. The number of events has a lower bound of 1.</p>&#13;
<figure>&#13;
<img src="../Images/file120.jpg" alt="Figure 13.1: Markov chain generator "/>&#13;
<figcaption aria-hidden="true"><span class="id">Figure 13.1: </span><span class="content">Markov chain generator </span></figcaption>&#13;
</figure>&#13;
<p>The state transition probabilities are stated as fractions, <img src="../Images/file121.jpg" class="frac" data-align="middle" alt="n- 36"/>, because this particular Markov chain generator comes from a game that uses two dice. There are 36 possible outcomes from a roll of the dice. When considering the sum of the two dice, the 10 distinct values have probabilities ranging from <img src="../Images/file122.jpg" class="frac" data-align="middle" alt="-1 36"/> for the values 2 and 12, to <img src="../Images/file123.jpg" class="frac" data-align="middle" alt=" 6 36"/> for the value 7.</p>&#13;
<p>Because this is based on a game, the actual algorithm is somewhat simpler than the diagram of the state transitions. The trick in simplifying the algorithm description is combining a number of similar behaviors into a single state defined by a parameter, <span class="italic">p</span>.</p>&#13;
<p>The algorithm’s use of an internal state. For designers new to functional programming, this is a bit of a problem. The solution that we’ve shown in other examples is to expose the state as a parameter to a function.</p>&#13;
<p>We’ll start with a presentation of the algorithm with explicit state.</p>&#13;
<div class="algorithm">&#13;
<figure>&#13;
<img src="../Images/Algo_13.1.JPG" class="math" alt="Algorithm 9: Markov chain generator "/>&#13;
<figcaption aria-hidden="true"><span class="id">Algorithm 9: </span><span class="content">Markov chain generator </span></figcaption>&#13;
</figure>&#13;
</div>&#13;
<p>The algorithm<span id="dx1-274010"/> can be seen as requiring<span id="dx1-274011"/> a state change. Alternatively, we can look at this as a sequence of operations to append to the Markov chain, rather than a state change. There’s one function that must be used first to create an initial outcome or establish the value of <span class="italic">p</span>. Another, recursive function is used after that to iterate until an outcome is determined. In this way, this pairs-of-functions approach fits the monad design pattern nicely.</p>&#13;
<p>To build Markov chains, we’ll need a source of random numbers:</p>&#13;
<pre id="listing-276" class="lstlisting"><code>import random &#13;
 &#13;
def rng() -&gt; tuple[int, int]: &#13;
    return (random.randint(1,6), random.randint(1,6)) &#13;
 &#13;
from collections.abc import Callable &#13;
from typing import TypeAlias &#13;
 &#13;
DiceT: TypeAlias = Callable[[], tuple[int, int]]</code></pre>&#13;
<p>The preceding function will generate a pair of dice for us. We also included a type hint, <span class="obeylines-h"><span class="verb"><code class="inlineCode">DiceT</code></span></span>, that can be used to describe any similar function that returns a tuple with two integers. The type hint will be used in later functions as a shorthand for any similar random number generator.</p>&#13;
<p>Here’s our expectations from the overall chain generator based on the game algorithm:</p>&#13;
<pre id="listing-277" class="lstlisting"><code>from pymonad.maybe import Maybe, Just &#13;
 &#13;
def game_chain(dice: DiceT) -&gt; Maybe: &#13;
    outcome = ( &#13;
        Just(("", 0, [])) &#13;
        .then(initial_roll(dice)) &#13;
        .then(point_roll(dice)) &#13;
    ) &#13;
    return outcome</code></pre>&#13;
<p>We create an initial monad, <span class="obeylines-h"><span class="verb"><code class="inlineCode">Just(("",</code><code class="inlineCode"> 0,</code><code class="inlineCode"> []))</code></span></span>, to define the essential type we’re going to work with. A game will produce a three-tuple with the outcome text, the point value, and a sequence of rolls. At the start of each game, a default three-tuple establishes the three-tuple type.</p>&#13;
<p>We pass this monad<span id="dx1-274030"/> to two other functions. This will create a resulting<span id="dx1-274031"/> monad, <span class="obeylines-h"><span class="verb"><code class="inlineCode">outcome</code></span></span>, with the results of the game. We use the <span class="obeylines-h"><span class="verb"><code class="inlineCode">then()</code></span></span> method to connect the functions in the specific order they must be executed. In a language with an optimizing compiler, this will prevent the expression from being rearranged.</p>&#13;
<p>We will get the value of the monad at the end using the <span class="obeylines-h"><span class="verb"><code class="inlineCode">value</code></span></span> attribute. Since the monad objects are lazy, this request is what triggers the evaluation of the various monads to create the required output.</p>&#13;
<p>Each resulting sequence of three-tuples is a Markov chain we can analyze to determine the overall statistical properties. We’re often interested in the expected lengths of the chains. This can be difficult to predict from the initial model or the algorithm.</p>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">initial_roll()</code></span></span> function has the <span class="obeylines-h"><span class="verb"><code class="inlineCode">rng()</code></span></span> function curried as the first argument. The monad will become the second argument to this function. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">initial_roll()</code></span></span> function can roll the dice and apply the <span class="cmti-10x-x-109">come out </span>rule to determine if we have a pass, a fail, or a point.</p>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">point_roll()</code></span></span> function also has the <span class="obeylines-h"><span class="verb"><code class="inlineCode">rng()</code></span></span> function curried as the first argument. The monad will become the second argument. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">point_roll()</code></span></span> function can then roll the dice to see if the game is resolved. If the game is unresolved, this function will operate recursively to continue looking for a resolution.</p>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">initial_roll()</code></span></span> function looks like this:</p>&#13;
<pre id="listing-278" class="lstlisting"><code>from pymonad.tools import curry &#13;
from pymonad.maybe import Maybe, Just &#13;
 &#13;
@curry(2)  # type: ignore[misc] &#13;
def initial_roll(dice: DiceT, status: Maybe) -&gt; Maybe: &#13;
    d = dice() &#13;
    if sum(d) in (7, 11): &#13;
        return Just(("pass", sum(d), [d])) &#13;
    elif sum(d) in (2, 3, 12): &#13;
        return Just(("fail", sum(d), [d])) &#13;
    else: &#13;
        return Just(("point", sum(d), [d]))</code></pre>&#13;
<p>The dice are rolled once to determine<span id="dx1-274044"/> if the initial outcome is pass, fail, or establish the point. We return an appropriate monad<span id="dx1-274045"/> value that includes the outcome, a point value, and the roll of the dice that led to this state. The point values for an immediate pass and immediate fail aren’t really meaningful. We could sensibly return a 0 value here, since no point was really established.</p>&#13;
<div id="tcolobox-284" class="packt_tip">&#13;
&#13;
&#13;
<p>For developers using tools<span id="dx1-274046"/> like <span class="keyWord">pylint</span>, the <span class="obeylines-h"><span class="verb"><code class="inlineCode">status</code></span></span> argument isn’t used. This creates a warning that needs to be silenced. Adding a <span class="obeylines-h"><span class="verb"><code class="inlineCode">#</code><code class="inlineCode"> pylint:</code><code class="inlineCode"> disable=</code></span></span></p>&#13;
<p><span class="obeylines-h"><span class="verb"><code class="inlineCode">unused-argument</code></span></span> comment will silence the warning.</p>&#13;
&#13;
</div>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">point_roll()</code></span></span> function looks like this:</p>&#13;
<pre id="listing-279" class="lstlisting"><code>from pymonad.tools import curry &#13;
from pymonad.maybe import Maybe, Just &#13;
 &#13;
@curry(2)  # type: ignore[misc] &#13;
def point_roll(dice: DiceT, status: Maybe) -&gt; Maybe: &#13;
    prev, point, so_far = status &#13;
    if prev != "point": &#13;
        # won or lost on a previous throw &#13;
        return Just(status) &#13;
 &#13;
    d = dice() &#13;
    if sum(d) == 7: &#13;
        return Just(("fail", point, so_far+[d])) &#13;
    elif sum(d) == point: &#13;
        return Just(("pass", point, so_far+[d])) &#13;
    else: &#13;
        return ( &#13;
            Just(("point", point, so_far+[d])) &#13;
            .then(point_roll(dice)) &#13;
        )</code></pre>&#13;
<p>We decomposed the status<span id="dx1-274067"/> monad into the three individual values of the tuple. We could have used small lambda<span id="dx1-274068"/> objects to extract the first, second, and third values. We could also have used the <span class="obeylines-h"><span class="verb"><code class="inlineCode">operator.itemgetter()</code></span></span> function to extract the tuple’s items. Instead, we used multiple assignment.</p>&#13;
<p>If a point was not established, the previous state will be <span class="cmti-10x-x-109">pass </span>or <span class="cmti-10x-x-109">fail</span>. The game was resolved during the <span class="obeylines-h"><span class="verb"><code class="inlineCode">initial_roll()</code></span></span> function, and this function simply returns the status monad.</p>&#13;
<p>If a point was established, the state will be <span class="cmti-10x-x-109">point</span>. The dice is rolled and rules applied to this new roll. If roll is 7, the game is a lost and a final monad is returned. If the roll is the point, the game is won and the appropriate monad is returned. Otherwise, a slightly revised monad is passed to the <span class="obeylines-h"><span class="verb"><code class="inlineCode">point_roll()</code></span></span> function. The revised status monad includes this roll in the history of rolls.</p>&#13;
<p>A typical output looks like this:</p>&#13;
<div id="tcolobox-285" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; game_chain() &#13;
(’fail’, 5, [(2, 3), (1, 3), (1, 5), (1, 6)])</code></pre>&#13;
&#13;
</div>&#13;
<p>The final monad has a string that shows the outcome. It has the point that was established and the sequence of dice rolls leading to the final outcome.</p>&#13;
<p>We can use simulation to examine different outcomes to gather statistics on this complex, stateful process. This kind of Markov-chain model can reflect a number of odd edge cases that lead to surprising distributions of results.</p>&#13;
<p>A great deal of clever Monte Carlo simulation can be built with a few simple, functional programming design techniques. The monad, in particular, can help to structure these kinds of calculations when there are complex orders or internal states. <span id="x1-274072r282"/></p>&#13;
</section>&#13;
<section id="additional-pymonad-features" class="level3 sectionHead" data-number="0.17.6">&#13;
<h3 class="sectionHead" data-number="0.17.6"><span class="titlemark">13.6 </span> <span id="x1-2750006"/>Additional PyMonad features</h3>&#13;
<p>One of the other features<span id="dx1-275001"/> of PyMonad is the confusingly named <span class="keyWord">monoid</span>. This comes directly from mathematics and it refers to a group of data elements that have an operator and an identity element, and the group is closed with respect to that operator. Here’s an example of what this means: when we think of natural numbers, the add operator, and an identity element 0, this is a proper monoid. For positive integers, with an operator <span class="obeylines-h"><span class="verb"><code class="inlineCode">*</code></span></span>, and an identity value of 1, we also have a monoid; strings using <span class="obeylines-h"><span class="verb"><code class="inlineCode">+</code></span></span> as an operator and an empty string as an identity element also qualify.</p>&#13;
<p>PyMonad includes a number of predefined monoid classes. We can extend this to add our own monoid class. The intent is to limit a compiler to certain kinds of optimization. We can also use the monoid class to create data structures which accumulate a complex value, perhaps including a history of previous operations.</p>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">pymonad.list</code></span></span> is an example of a monoid. The identity element is an empty list, defined by <span class="obeylines-h"><span class="verb"><code class="inlineCode">ListMonad()</code></span></span>. The addition operation defines list concatenation. The monoid is an aspect of the overall <span class="obeylines-h"><span class="verb"><code class="inlineCode">ListMonad()</code></span></span> class.</p>&#13;
<p>Much of this package helps provide deeper insights into functional programming. To paraphrase the documentation, this is an easy way to learn about functional programming in, perhaps, a slightly more forgiving environment. Rather than learning an entire language and toolset to compile and run functional programs, we can just experiment with interactive Python.</p>&#13;
<p>Pragmatically, we don’t need too many of these features because Python is already stateful and offers strict evaluation of expressions. There’s no practical reason to introduce stateful objects in Python, or strictly ordered evaluation. We can write useful programs in Python by mixing functional concepts with Python’s imperative implementation. For that reason, we won’t delve more deeply into PyMonad. <span id="x1-275002r285"/></p>&#13;
</section>&#13;
<section id="summary-12" class="level3 sectionHead" data-number="0.17.7">&#13;
<h3 class="sectionHead" data-number="0.17.7"><span class="titlemark">13.7 </span> <span id="x1-2760007"/>Summary</h3>&#13;
<p>In this chapter, we looked at how we can use the PyMonad library to express some functional programming concepts directly in Python. The module contains many important functional programming techniques.</p>&#13;
<p>We looked at the idea of currying, a function that allows combinations of arguments to be applied to create new functions. Currying a function also allows us to use functional composition to create more complex functions from simpler pieces. We looked at functors that wrap simple data objects to make them into functions that can also be used with functional composition.</p>&#13;
<p>Monads are a way to impose a strict evaluation order when working with an optimizing compiler and lazy evaluation rules. In Python, we don’t have a good use case for monads because Python is an imperative programming language under the hood. In some cases, imperative Python may be more expressive and succinct than a monad construction.</p>&#13;
<p>In the next chapter, we’ll look at the multiprocessing and multithreading techniques that are available to us. These packages become particularly helpful in a functional programming context. When we eliminate a complex shared state and design around non-strict processing, we can leverage parallelism to improve the performance. <span id="x1-276001r286"/></p>&#13;
</section>&#13;
<section id="exercises-12" class="level3 sectionHead" data-number="0.17.8">&#13;
<h3 class="sectionHead" data-number="0.17.8"><span class="titlemark">13.8 </span> <span id="x1-2770008"/>Exercises</h3>&#13;
<p>This chapter’s exercises are based on code available from Packt Publishing on GitHub. See <a href="https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition" class="url">https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition</a>.</p>&#13;
<p>In some cases, the reader will notice that the code provided on GitHub includes partial solutions to some of the exercises. These serve as hints, allowing the reader to explore alternative solutions.</p>&#13;
<p>In many cases, exercises will need unit test cases to confirm they actually solve the problem. They are often identical to the unit test cases provided in the GitHub repository. The reader should replace the book’s example function name with their own solution to confirm that it works. <span id="x1-277001r280"/></p>&#13;
<section id="revise-the-arctangent-series" class="level4 subsectionHead" data-number="0.17.8.1">&#13;
<h4 class="subsectionHead" data-number="0.17.8.1"><span class="titlemark">13.8.1 </span> <span id="x1-2780001"/>Revise the arctangent series</h4>&#13;
<p>In <a href="#x1-2720001"><span class="cmti-10x-x-109">Using the lazy ListMonad() monad</span></a>, we showed a computation for <span class="italic">π </span>that involved summing fractions from a series that used factorials, <span class="italic">n</span>!, and double factorials, (2<span class="italic">n </span>+ 1)!!.</p>&#13;
<p>The examples use a sequence <span class="obeylines-h"><span class="verb"><code class="inlineCode">seq1</code><code class="inlineCode"> =</code><code class="inlineCode"> ListMonad(*range(20))</code></span></span> with only 20 values. This choice of 20 was arbitrary, and intended only to keep the intermediate results small enough to visualize.</p>&#13;
<p>A better choice is to use use curried versions of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">sum()</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">takewhile()</code></span></span> functions to find the sum of values in the sequence until the values are too small to contribute to the result.</p>&#13;
<p>Rewrite the approximation to compute <span class="italic">π </span>to an accuracy of 10<sup><span class="cmsy-8">−</span><span class="cmr-8">15</span></sup>. This is close to the limit of what 64-bit floating-point values can represent. <span id="x1-278001r288"/></p>&#13;
</section>&#13;
<section id="statistical-computations" class="level4 subsectionHead" data-number="0.17.8.2">&#13;
<h4 class="subsectionHead" data-number="0.17.8.2"><span class="titlemark">13.8.2 </span> <span id="x1-2790002"/>Statistical computations</h4>&#13;
<p>Given a list of values, <span class="obeylines-h"><span class="verb"><code class="inlineCode">v</code></span></span>, we can create a useful monad with <span class="obeylines-h"><span class="verb"><code class="inlineCode">Just(v)</code></span></span>. We can use built-in functions like <span class="obeylines-h"><span class="verb"><code class="inlineCode">sum()</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">len()</code></span></span> with the <span class="obeylines-h"><span class="verb"><code class="inlineCode">Just.map()</code></span></span> method to compute the values required for mean, variance, and standard deviation.</p>&#13;
<div class="math-display" style="text-align:center">&#13;
<img src="../Images/file125.jpg" class="math-display" alt=" ∑ x mean (D ) =---x∈D--- count(D ) "/>&#13;
</div>&#13;
<div class="math-display" style="text-align:center">&#13;
<img src="../Images/file126.jpg" class="math-display" alt=" ∑ (x-−-mean-(D-))2 var(D ) = count (D )− 1 x∈D "/>&#13;
</div>&#13;
<div class="math-display" style="text-align:center">&#13;
<img src="../Images/file127.jpg" class="math-display" alt=" ∘ ------- stdev(D ) = var(D ) "/>&#13;
</div>&#13;
<p>After implementing these functions using PyMonad, compare these definitions with more conventional Python language techniques. Does the presence of a monad structure help with these relatively simple computations? <span id="x1-279001r289"/></p>&#13;
</section>&#13;
<section id="data-validation" class="level4 subsectionHead" data-number="0.17.8.3">&#13;
<h4 class="subsectionHead" data-number="0.17.8.3"><span class="titlemark">13.8.3 </span> <span id="x1-2800003"/>Data validation</h4>&#13;
<p>The PyMonad library includes an <span class="obeylines-h"><span class="verb"><code class="inlineCode">Either</code></span></span> class of monads. This is similar to the <span class="obeylines-h"><span class="verb"><code class="inlineCode">Maybe</code></span></span> class of monads. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">Maybe</code></span></span> monad can have just a value, or nothing, providing a <span class="obeylines-h"><span class="verb"><code class="inlineCode">None</code></span></span>-like object. An <span class="obeylines-h"><span class="verb"><code class="inlineCode">Either</code></span></span> monad has two subclasses, <span class="obeylines-h"><span class="verb"><code class="inlineCode">Left</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">Right</code></span></span>. If we use <span class="obeylines-h"><span class="verb"><code class="inlineCode">Right</code></span></span> instances for valid data, we can use <span class="obeylines-h"><span class="verb"><code class="inlineCode">Left</code></span></span> instances for error messages that identify invalid data.</p>&#13;
<p>The above concept suggests that a <span class="obeylines-h"><span class="verb"><code class="inlineCode">try:/except:</code></span></span> statement can be used. If no Python exception is raised, the result is a <span class="obeylines-h"><span class="verb"><code class="inlineCode">Right(v)</code></span></span>. If an exception is raised, a <span class="obeylines-h"><span class="verb"><code class="inlineCode">Left</code></span></span> can be returned with the exception’s error message.</p>&#13;
<p>This permits a <span class="obeylines-h"><span class="verb"><code class="inlineCode">Compose</code></span></span> or <span class="obeylines-h"><span class="verb"><code class="inlineCode">Pipe</code></span></span> to process data, emitting all of the erroneous rows as <span class="obeylines-h"><span class="verb"><code class="inlineCode">Left</code></span></span> monads. This can lead to a helpful data validation application because it spots all of the problems with the data.</p>&#13;
<p>First, define a simple validation rule, like ”the values must be multiples of 3 or 5.” This means they must convert to integer values and the integer modulo 3 is zero or the integer modulo 5 is zero. Second, write the validation function that returns either a <span class="obeylines-h"><span class="verb"><code class="inlineCode">Right</code></span></span> or <span class="obeylines-h"><span class="verb"><code class="inlineCode">Left</code></span></span> object.</p>&#13;
<p>While a <span class="obeylines-h"><span class="verb"><code class="inlineCode">pymonad.io.IO</code></span></span> object can be used to parse a file, we’ll start with applying the validation function to a list and examining the results. Apply the validation function to a sequence of values, saving the resulting sequence of <span class="obeylines-h"><span class="verb"><code class="inlineCode">Either</code></span></span> objects.</p>&#13;
<p>An <span class="obeylines-h"><span class="verb"><code class="inlineCode">Either</code></span></span> object has an <span class="obeylines-h"><span class="verb"><code class="inlineCode">.either()</code></span></span> method which can process either <span class="obeylines-h"><span class="verb"><code class="inlineCode">Left</code></span></span> or <span class="obeylines-h"><span class="verb"><code class="inlineCode">Right</code></span></span> instances. For example, <span class="obeylines-h"><span class="verb"><code class="inlineCode">e.either(lambda</code><code class="inlineCode"> x:</code><code class="inlineCode"> True,</code><code class="inlineCode"> lambda</code><code class="inlineCode"> x:</code><code class="inlineCode"> False)</code></span></span> will return <span class="obeylines-h"><span class="verb"><code class="inlineCode">True</code></span></span> if the value of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">e</code></span></span> monad is a <span class="obeylines-h"><span class="verb"><code class="inlineCode">Left</code></span></span> instance. <span id="x1-280001r290"/></p>&#13;
</section>&#13;
<section id="multiple-models" class="level4 subsectionHead" data-number="0.17.8.4">&#13;
<h4 class="subsectionHead" data-number="0.17.8.4"><span class="titlemark">13.8.4 </span> <span id="x1-2810004"/>Multiple models</h4>&#13;
<p>A given process has several alternative models that compute an expected value from an observed sample value.</p>&#13;
<p>Each model computes an expected value, <span class="italic">e</span>, from the observed value in the sample, <span class="italic">s</span><sub><span class="cmmi-8">o</span></sub>:</p>&#13;
<ul>&#13;
<li><p><span class="italic">e </span>= 0<span class="italic">.</span>7412 <span class="cmsy-10x-x-109">× </span><span class="italic">s</span><sub><span class="cmmi-8">o</span></sub></p></li>&#13;
<li><p><span class="italic">e </span>= 0<span class="italic">.</span>9 <span class="cmsy-10x-x-109">× </span><span class="italic">s</span><sub><span class="cmmi-8">o</span></sub> <span class="cmsy-10x-x-109">− </span>90</p></li>&#13;
<li><p><span class="italic">e </span>= 0<span class="italic">.</span>7724 <span class="cmsy-10x-x-109">× </span><span class="italic">s</span><sub><span class="cmmi-8">o</span></sub><sup><span class="cmr-8">1</span><span class="cmmi-8">.</span><span class="cmr-8">0134</span></sup></p></li>&#13;
</ul>&#13;
<p>First, we need to implement each of these models as a curried function. This will let us compute predicted values using any of these models.</p>&#13;
<p>Given a model function, we then need to create a comparison function. We can use a general PyMonad <span class="obeylines-h"><span class="verb"><code class="inlineCode">Composition</code></span></span> or <span class="obeylines-h"><span class="verb"><code class="inlineCode">Pipe</code></span></span> to compute a predicted value using one of the models and compare the predicted value with an observed value.</p>&#13;
<p>The results of this comparison function can be used as part of a <span class="italic">χ</span><sup><span class="cmr-8">2</span></sup> (chi-squared) test to discern how well the model fits the observations. The actual chi-squared metric is the subject of <span class="cmti-10x-x-109">Chapter 16</span>, <span class="cmti-10x-x-109">A Chi-Squared Case Study</span>.</p>&#13;
<p>For now, create the curried model functions, and the <span class="obeylines-h"><span class="verb"><code class="inlineCode">Composition</code></span></span> or <span class="obeylines-h"><span class="verb"><code class="inlineCode">Pipe</code></span></span> to compare the model’s prediction with actual results.</p>&#13;
<p>For actual values and observed values, see the <a href="Chapter_12.xhtml#x1-2640004"><span class="cmti-10x-x-109">Logging</span></a> exercise in <a href="Chapter_12.xhtml#x1-25000012"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 12</span></a>, <a href="Chapter_12.xhtml#x1-25000012"><span class="cmti-10x-x-109">Decorator Design Techniques</span></a>.</p>&#13;
</section>&#13;
</section>&#13;
<section id="join-our-community-discord-space-11" class="level3 likesectionHead" data-number="0.17.9">&#13;
<h3 class="likesectionHead" data-number="0.17.9"><span id="x1-2820004"/>Join our community Discord space</h3>&#13;
<p>Join our Python Discord workspace to discuss and know more about the book: <a href="https://packt.link/dHrHU">https://packt.link/dHrHU</a></p>&#13;
<p><img src="../Images/file1.png" alt="PIC" width="85" height="85"/></p>&#13;
<p><span id="x1-282001r274"/></p>&#13;
</section>&#13;
</section>&#13;
</body></html>