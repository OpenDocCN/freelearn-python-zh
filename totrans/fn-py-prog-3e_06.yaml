- en: '6'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '6'
- en: Recursions and Reductions
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: é€’å½’å’Œå½’çº¦
- en: Many functional programming language compilers will optimize a recursive function
    to transform a recursive call in the tail of the function to an iteration. This
    tail-call optimization will dramatically improve performance. Python doesnâ€™t do
    this automatic tail-call optimization. One consequence is pure recursion suffers
    from limitations. Lacking an automated optimization, we need to do the tail-call
    optimization manually. This means rewriting recursion to use an explicit iteration.
    There are two common ways to do this, and weâ€™ll consider them both in this chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: è®¸å¤šå‡½æ•°å¼ç¼–ç¨‹è¯­è¨€ç¼–è¯‘å™¨ä¼šå°†é€’å½’å‡½æ•°ä¼˜åŒ–ï¼Œå°†å‡½æ•°å°¾éƒ¨çš„é€’å½’è°ƒç”¨è½¬æ¢ä¸ºè¿­ä»£ã€‚è¿™ç§å°¾è°ƒç”¨ä¼˜åŒ–å°†æ˜¾è‘—æé«˜æ€§èƒ½ã€‚Python ä¸è¿›è¡Œè¿™ç§è‡ªåŠ¨å°¾è°ƒç”¨ä¼˜åŒ–ã€‚ä¸€ä¸ªåæœæ˜¯çº¯é€’å½’å—åˆ°é™åˆ¶ã€‚ç¼ºä¹è‡ªåŠ¨ä¼˜åŒ–ï¼Œæˆ‘ä»¬éœ€è¦æ‰‹åŠ¨è¿›è¡Œå°¾è°ƒç”¨ä¼˜åŒ–ã€‚è¿™æ„å‘³ç€é‡å†™é€’å½’ä»¥ä½¿ç”¨æ˜¾å¼è¿­ä»£ã€‚æœ‰ä¸¤ç§å¸¸è§çš„æ–¹æ³•æ¥åšè¿™ä»¶äº‹ï¼Œæˆ‘ä»¬å°†åœ¨æœ¬ç« ä¸­è€ƒè™‘å®ƒä»¬ã€‚
- en: 'In previous chapters, weâ€™ve looked at several related kinds of processing design
    patterns; some of them are as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨å‰é¢çš„ç« èŠ‚ä¸­ï¼Œæˆ‘ä»¬æ¢è®¨äº†å¤šç§ç›¸å…³çš„å¤„ç†è®¾è®¡æ¨¡å¼ï¼›å…¶ä¸­ä¸€äº›å¦‚ä¸‹ï¼š
- en: Mapping and filtering, which create collections from collections
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æ˜ å°„å’Œè¿‡æ»¤ï¼Œå®ƒä»¬ä»é›†åˆåˆ›å»ºé›†åˆ
- en: Reductions that create a scalar value from a collection
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä»é›†åˆåˆ›å»ºæ ‡é‡å€¼çš„å½’çº¦
- en: The distinction is exemplified by functions such as `map()` and `filter()` that
    accomplish the first kind of collection processing. There are some more specialized
    reduction functions, which include `min()`, `max()`, `len()`, and `sum()`. Thereâ€™s
    a general-purpose reduction function as well, `functools.reduce()`.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ç§åŒºåˆ«å¯ä»¥é€šè¿‡åƒ `map()` å’Œ `filter()` è¿™æ ·çš„å‡½æ•°æ¥ä½“ç°ï¼Œè¿™äº›å‡½æ•°å®Œæˆäº†ç¬¬ä¸€ç§é›†åˆå¤„ç†ã€‚è¿˜æœ‰ä¸€äº›æ›´ä¸“ä¸šçš„å½’çº¦å‡½æ•°ï¼ŒåŒ…æ‹¬ `min()`ã€`max()`ã€`len()`
    å’Œ `sum()`ã€‚è¿˜æœ‰ä¸€ä¸ªé€šç”¨å½’çº¦å‡½æ•°ï¼Œ`functools.reduce()`ã€‚
- en: Weâ€™ll also consider creating a `collections.Counter()` object as a kind of reduction
    operator. It doesnâ€™t produce a single scalar value per se, but it does create
    a new organization of the data that eliminates some of the original structure.
    At heart, itâ€™s a kind of count-group-by operation that has more in common with
    a counting reduction than with a mapping.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬è¿˜å°†è€ƒè™‘åˆ›å»ºä¸€ä¸ª `collections.Counter()` å¯¹è±¡ä½œä¸ºå½’çº¦æ“ä½œç¬¦çš„ä¸€ç§ã€‚å®ƒæœ¬èº«å¹¶ä¸äº§ç”Ÿå•ä¸ªæ ‡é‡å€¼ï¼Œä½†å®ƒç¡®å®åˆ›å»ºäº†ä¸€ç§æ–°çš„æ•°æ®ç»„ç»‡æ–¹å¼ï¼Œæ¶ˆé™¤äº†åŸå§‹ç»“æ„çš„ä¸€äº›éƒ¨åˆ†ã€‚æœ¬è´¨ä¸Šï¼Œå®ƒæ˜¯ä¸€ç§è®¡æ•°åˆ†ç»„æ“ä½œï¼Œä¸è®¡æ•°å½’çº¦æ¯”ä¸æ˜ å°„æœ‰æ›´å¤šçš„å…±åŒç‚¹ã€‚
- en: In this chapter, weâ€™ll look at reduction functions in more detail. From a purely
    functional perspective, a reduction can be defined recursively. The tail-call
    optimization techniques available in Python apply elegantly to reductions.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æœ¬ç« ä¸­ï¼Œæˆ‘ä»¬å°†æ›´è¯¦ç»†åœ°æ¢è®¨å½’çº¦å‡½æ•°ã€‚ä»çº¯å‡½æ•°çš„è§’åº¦æ¥çœ‹ï¼Œå½’çº¦å¯ä»¥é€’å½’åœ°å®šä¹‰ã€‚Python ä¸­å¯ç”¨çš„å°¾è°ƒç”¨ä¼˜åŒ–æŠ€æœ¯éå¸¸é€‚åˆå½’çº¦ã€‚
- en: Weâ€™ll review a number of built-in reduction algorithms including `sum()`, `count()`,
    `max()`, and `min()`. Weâ€™ll look at the `collections.Counter()` creation and related
    `itertools.groupby()` reductions. Weâ€™ll also look at how parsing (and lexical
    scanning) are proper reductions since they transform sequences of tokens (or sequences
    of characters) into higher-order collections with more complex properties.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å°†å›é¡¾ä¸€äº›å†…ç½®çš„å½’çº¦ç®—æ³•ï¼ŒåŒ…æ‹¬ `sum()`ã€`count()`ã€`max()` å’Œ `min()`ã€‚æˆ‘ä»¬å°†æ¢è®¨ `collections.Counter()`
    çš„åˆ›å»ºå’Œç›¸å…³ `itertools.groupby()` å½’çº¦ã€‚æˆ‘ä»¬è¿˜å°†æ¢è®¨è§£æï¼ˆå’Œè¯æ³•æ‰«æï¼‰æ˜¯å¦‚ä½•ä½œä¸ºé€‚å½“çš„å½’çº¦çš„ï¼Œå› ä¸ºå®ƒä»¬å°†æ ‡è®°åºåˆ—ï¼ˆæˆ–å­—ç¬¦åºåˆ—ï¼‰è½¬æ¢ä¸ºå…·æœ‰æ›´å¤æ‚å±æ€§çš„æ›´é«˜é˜¶é›†åˆã€‚
- en: 6.1 Simple numerical recursions
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1 ç®€å•æ•°å€¼é€’å½’
- en: We can consider all numeric operations to be defined by recursions. For more
    details, read about the Peano axioms that define the essential features of numbers
    at [https://www.britannica.com/science/Peano-axioms](https://www.britannica.com/science/Peano-axioms).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯ä»¥å°†æ‰€æœ‰æ•°å€¼è¿ç®—éƒ½å®šä¹‰ä¸ºé€’å½’ã€‚æœ‰å…³æ›´å¤šè¯¦ç»†ä¿¡æ¯ï¼Œè¯·é˜…è¯»å®šä¹‰æ•°å­—åŸºæœ¬ç‰¹å¾çš„ä½©äºšè¯ºå…¬ç†ï¼Œè§[https://www.britannica.com/science/Peano-axioms](https://www.britannica.com/science/Peano-axioms)ã€‚
- en: From these axioms, we can see that addition is defined recursively using more
    primitive notions of the next number, or the successor of a number n, S(n).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: ä»è¿™äº›å…¬ç†ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°åŠ æ³•æ˜¯é€šè¿‡ä½¿ç”¨æ›´åŸå§‹çš„ä¸‹ä¸€ä¸ªæ•°çš„æ¦‚å¿µï¼Œå³æ•° n çš„åç»§ï¼ŒS(n) æ¥é€’å½’å®šä¹‰çš„ã€‚
- en: To simplify the presentation, weâ€™ll assume that we can define a predecessor
    function, P(n), such that n = S(P(n)) = P(S(n)), as long as nâ‰ 0\. This formalizes
    the idea that a number is the successor of the numberâ€™s predecessor.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºäº†ç®€åŒ–è¯´æ˜ï¼Œæˆ‘ä»¬å‡è®¾æˆ‘ä»¬å¯ä»¥å®šä¹‰ä¸€ä¸ªå‰é©±å‡½æ•°ï¼ŒP(n)ï¼Œä½¿å¾— n = S(P(n)) = P(S(n))ï¼Œåªè¦ nâ‰ 0ã€‚è¿™å½¢å¼åŒ–äº†è¿™æ ·ä¸€ä¸ªè§‚ç‚¹ï¼šä¸€ä¸ªæ•°æ˜¯å®ƒå‰é©±æ•°çš„åç»§ã€‚
- en: 'Addition between two natural numbers could be defined recursively as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸¤ä¸ªè‡ªç„¶æ•°ä¹‹é—´çš„åŠ æ³•å¯ä»¥é€’å½’åœ°å®šä¹‰ä¸ºå¦‚ä¸‹ï¼š
- en: '![ ( |{ add(a,b) = b if a = 0 |( add(P(a),S(b)) if a â„= 0 ](img/file48.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![ ( |{ add(a,b) = b if a = 0 |( add(P(a),S(b)) if a â„= 0 ](img/file48.jpg)'
- en: If we use the more typical notations of n + 1 and nâˆ’ 1 instead of S(n) and P(n),
    we can more easily see how the rule add(a,b) = add(a âˆ’ 1,b + 1) when aâ‰ 0 works.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘ä»¬ä½¿ç”¨æ›´å…¸å‹çš„n + 1å’Œnâˆ’ 1çš„è¡¨ç¤ºæ³•ï¼Œè€Œä¸æ˜¯S(n)å’ŒP(n)ï¼Œæˆ‘ä»¬å¯ä»¥æ›´å®¹æ˜“åœ°çœ‹åˆ°å½“aâ‰ 0æ—¶ï¼Œadd(a,b) = add(a âˆ’ 1,b
    + 1)çš„è§„åˆ™æ˜¯å¦‚ä½•å·¥ä½œçš„ã€‚
- en: 'This translates neatly into Python, as shown in the following function definition:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™åœ¨ä»¥ä¸‹å‡½æ•°å®šä¹‰ä¸­å¾—åˆ°äº†å¾ˆå¥½çš„ä½“ç°ï¼š
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Weâ€™ve rearranged the abstract mathematical notation into concrete Python.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å·²ç»å°†æŠ½è±¡çš„æ•°å­¦ç¬¦å·é‡æ–°æ’åˆ—æˆäº†å…·ä½“çš„Pythonä»£ç ã€‚
- en: Thereâ€™s no good reason to provide our own functions in Python to do simple addition.
    We rely on Pythonâ€™s underlying implementation to properly handle arithmetic of
    various kinds. Our point here is that fundamental scalar arithmetic can be defined
    recursively, and the definition translates to Python.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨Pythonä¸­æä¾›æˆ‘ä»¬è‡ªå·±çš„å‡½æ•°æ¥è¿›è¡Œç®€å•çš„åŠ æ³•æ²¡æœ‰å¾ˆå¥½çš„ç†ç”±ã€‚æˆ‘ä»¬ä¾èµ–äºPythonçš„åº•å±‚å®ç°æ¥æ­£ç¡®å¤„ç†å„ç§ç®—æœ¯è¿ç®—ã€‚æˆ‘ä»¬åœ¨è¿™é‡Œçš„è¦ç‚¹æ˜¯ï¼ŒåŸºæœ¬æ ‡é‡ç®—æœ¯å¯ä»¥é€’å½’å®šä¹‰ï¼Œå¹¶ä¸”å®šä¹‰å¯ä»¥ç¿»è¯‘æˆPythonã€‚
- en: This suggests that more complicated operations, defined recursively, can also
    be translated to Python. The translation can be manually optimized to create working
    code that matches the abstract definitions, reducing questions about possible
    bugs in the implementation.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™è¡¨æ˜æ›´å¤æ‚çš„é€’å½’å®šä¹‰çš„æ“ä½œä¹Ÿå¯ä»¥ç¿»è¯‘æˆPythonã€‚è¿™ç§ç¿»è¯‘å¯ä»¥é€šè¿‡æ‰‹åŠ¨ä¼˜åŒ–æ¥åˆ›å»ºä¸æŠ½è±¡å®šä¹‰ç›¸åŒ¹é…çš„è¿è¡Œä»£ç ï¼Œä»è€Œå‡å°‘å…³äºå®ç°ä¸­å¯èƒ½å‡ºç°çš„é”™è¯¯çš„é—®é¢˜ã€‚
- en: 'A recursive definition must include at least two cases: a non-recursive (or
    base) case where the value of the function is defined directly, and the recursive
    case where the value of the function is computed from a recursive evaluation of
    the function with different argument values.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: é€’å½’å®šä¹‰å¿…é¡»è‡³å°‘åŒ…æ‹¬ä¸¤ç§æƒ…å†µï¼šä¸€ä¸ªéé€’å½’ï¼ˆæˆ–åŸºæœ¬ï¼‰æƒ…å†µï¼Œå…¶ä¸­å‡½æ•°çš„å€¼ç›´æ¥å®šä¹‰ï¼Œä»¥åŠé€’å½’æƒ…å†µï¼Œå…¶ä¸­å‡½æ•°çš„å€¼æ˜¯é€šè¿‡é€’å½’è¯„ä¼°å…·æœ‰ä¸åŒå‚æ•°å€¼çš„å‡½æ•°æ¥è®¡ç®—çš„ã€‚
- en: In order to be sure the recursion will terminate, itâ€™s important to see how
    the recursive case computes values that approach the defined non-recursive base
    case. Pragmatically, there are often constraints on the argument values that weâ€™ve
    omitted from the functions here. For example, the `add()` function in the preceding
    command snippet could be expanded to include `assert``Â a>=0``Â and``Â b>=0` to establish
    two necessary constraints on the input values.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºäº†ç¡®ä¿é€’å½’èƒ½å¤Ÿç»ˆæ­¢ï¼Œé‡è¦çš„æ˜¯è¦çœ‹åˆ°é€’å½’æƒ…å†µæ˜¯å¦‚ä½•è®¡ç®—æ¥è¿‘å®šä¹‰çš„éé€’å½’åŸºæœ¬æƒ…å†µçš„å€¼çš„ã€‚ä»å®ç”¨è§’åº¦æ¥çœ‹ï¼Œæˆ‘ä»¬é€šå¸¸çœç•¥äº†å‡½æ•°ä¸­çš„å‚æ•°å€¼çº¦æŸã€‚ä¾‹å¦‚ï¼Œå‰é¢å‘½ä»¤ç‰‡æ®µä¸­çš„`add()`å‡½æ•°å¯ä»¥æ‰©å±•ä»¥åŒ…æ‹¬`assert
    a>=0 and b>=0`ï¼Œä»¥å»ºç«‹å¯¹è¾“å…¥å€¼çš„ä¸¤ä¸ªå¿…è¦çº¦æŸã€‚
- en: Without these constraints, starting with `a` equal to -1 wonâ€™t approach the
    non-recursive case of `a``Â ==``Â 0` as we keep subtracting 1 from `a`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: æ²¡æœ‰è¿™äº›é™åˆ¶ï¼Œä»`a`ç­‰äº-1å¼€å§‹ï¼Œå½“æˆ‘ä»¬ä¸æ–­ä»`a`ä¸­å‡å»1æ—¶ï¼Œä¸ä¼šæ¥è¿‘`a == 0`çš„éé€’å½’æƒ…å†µã€‚
- en: 6.1.1 Implementing manual tail-call optimization
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.1.1 å®ç°æ‰‹åŠ¨å°¾è°ƒç”¨ä¼˜åŒ–
- en: For some functions, the recursive definition is the most succinct and expressive.
    A common example is the `factorial()` function.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äºæŸäº›å‡½æ•°ï¼Œé€’å½’å®šä¹‰æ˜¯æœ€ç®€æ´å’Œè¡¨è¾¾æ€§æœ€å¼ºçš„ã€‚ä¸€ä¸ªå¸¸è§çš„ä¾‹å­æ˜¯`factorial()`å‡½æ•°ã€‚
- en: 'We can see how this is rewritten as a simple recursive function in Python from
    the following formula:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯ä»¥ä»ä»¥ä¸‹å…¬å¼ä¸­çœ‹åˆ°ï¼Œè¿™å¦‚ä½•è¢«é‡å†™ä¸ºPythonä¸­çš„ä¸€ä¸ªç®€å•é€’å½’å‡½æ•°ï¼š
- en: '![ ( | { 1 if n = 0 n! = |( n Ã— (nâˆ’ 1)! if n â„= 0 ](img/file49.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![ ( | { 1 if n = 0 n! = |( n Ã— (nâˆ’ 1)! if n â„= 0 ](img/file49.jpg)'
- en: 'The preceding formula can be implemented in Python by using the following function
    definition:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸Šè¿°å…¬å¼å¯ä»¥é€šè¿‡ä»¥ä¸‹å‡½æ•°å®šä¹‰åœ¨Pythonä¸­å®ç°ï¼š
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This implementation has the advantage of simplicity. The recursion limits in
    Python artificially constrain us; we canâ€™t do anything larger than about `fact(997)`.
    The value of 1000! has 2,568 digits and generally exceeds our floating-point capacity;
    on some systems the floating-point limit is near 10^(300). Pragmatically, itâ€™s
    common to switch to a log gamma function instead of working with immense numbers.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ç§å®ç°å…·æœ‰ç®€å•æ€§çš„ä¼˜åŠ¿ã€‚Pythonä¸­çš„é€’å½’é™åˆ¶äººä¸ºåœ°é™åˆ¶äº†æˆ‘ä»¬çš„èƒ½åŠ›ï¼›æˆ‘ä»¬æ— æ³•è¿›è¡Œå¤§äºçº¦`fact(997)`çš„æ“ä½œã€‚1000!çš„å€¼æœ‰2,568ä½æ•°å­—ï¼Œé€šå¸¸è¶…è¿‡äº†æˆ‘ä»¬çš„æµ®ç‚¹æ•°å®¹é‡ï¼›åœ¨æŸäº›ç³»ç»Ÿä¸­ï¼Œæµ®ç‚¹æ•°é™åˆ¶æ¥è¿‘10^(300)ã€‚ä»å®ç”¨è§’åº¦æ¥çœ‹ï¼Œé€šå¸¸åˆ‡æ¢åˆ°å¯¹æ•°ä¼½é©¬å‡½æ•°è€Œä¸æ˜¯å¤„ç†å·¨å¤§çš„æ•°å­—ã€‚
- en: See [https://functions.wolfram.com/GammaBetaErf/LogGamma/introductions/Gammas/ShowAll.html](https://functions.wolfram.com/GammaBetaErf/LogGamma/introductions/Gammas/ShowAll.html)
    for more on log gamma functions.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: æœ‰å…³å¯¹æ•°ä¼½é©¬å‡½æ•°çš„æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜…[https://functions.wolfram.com/GammaBetaErf/LogGamma/introductions/Gammas/ShowAll.html](https://functions.wolfram.com/GammaBetaErf/LogGamma/introductions/Gammas/ShowAll.html)ã€‚
- en: We can expand Pythonâ€™s call stack limit to stretch this to the limits of memory.
    Itâ€™s better, however, to manually optimize these kinds of functions to eliminate
    the recursion.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯ä»¥å°†Pythonçš„è°ƒç”¨æ ˆé™åˆ¶æ‰©å±•åˆ°å†…å­˜çš„æé™ã€‚ç„¶è€Œï¼Œæ‰‹åŠ¨ä¼˜åŒ–è¿™äº›å‡½æ•°ä»¥æ¶ˆé™¤é€’å½’æ˜¯æ›´å¥½çš„é€‰æ‹©ã€‚
- en: This function demonstrates a typical tail recursion. The last expression in
    the function is a call to the function with a new argument value. An optimizing
    compiler can replace the function call stack management with a loop that executes
    very quickly.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ªå‡½æ•°æ¼”ç¤ºäº†ä¸€ä¸ªå…¸å‹çš„å°¾é€’å½’ã€‚å‡½æ•°ä¸­çš„æœ€åä¸€ä¸ªè¡¨è¾¾å¼æ˜¯å¯¹å…·æœ‰æ–°å‚æ•°å€¼çš„å‡½æ•°çš„è°ƒç”¨ã€‚ä¼˜åŒ–ç¼–è¯‘å™¨å¯ä»¥ç”¨æ‰§è¡Œéå¸¸å¿«çš„å¾ªç¯æ¥æ›¿æ¢å‡½æ•°è°ƒç”¨æ ˆç®¡ç†ã€‚
- en: In this example, the function involves an incremental change from n to n âˆ’ 1\.
    This means that weâ€™re generating a sequence of numbers and then doing a reduction
    to compute their product.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œå‡½æ•°æ¶‰åŠä» n åˆ° n - 1 çš„å¢é‡å˜åŒ–ã€‚è¿™æ„å‘³ç€æˆ‘ä»¬åœ¨ç”Ÿæˆä¸€ç³»åˆ—æ•°å­—åï¼Œå†è¿›è¡Œå½’çº¦ä»¥è®¡ç®—å®ƒä»¬çš„ä¹˜ç§¯ã€‚
- en: 'Stepping outside purely functional processing, we can define an imperative
    `facti()` calculation as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: è¶…å‡ºçº¯ç²¹å‡½æ•°å¼å¤„ç†ï¼Œæˆ‘ä»¬å¯ä»¥å®šä¹‰ä¸€ä¸ªå‘½ä»¤å¼çš„ `facti()` è®¡ç®—å¦‚ä¸‹ï¼š
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This version of the factorial function will compute values beyond 1000! (2000!,
    for example, has 5,736 digits). This example isnâ€™t purely functional. Weâ€™ve optimized
    the tail recursion into a stateful `for` statement depending on the `i` variable
    to maintain the state of the computation.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ªé˜¶ä¹˜å‡½æ•°ç‰ˆæœ¬å°†è®¡ç®—è¶…è¿‡1000!ï¼ˆä¾‹å¦‚ï¼Œ2000!æœ‰5,736ä½ï¼‰ã€‚è¿™ä¸ªä¾‹å­å¹¶ä¸çº¯ç²¹æ˜¯å‡½æ•°å¼çš„ã€‚æˆ‘ä»¬å°†å°¾é€’å½’ä¼˜åŒ–ä¸ºä¸€ä¸ªä¾èµ–äº `i` å˜é‡çš„çŠ¶æ€ `for`
    è¯­å¥ï¼Œä»¥ä¿æŒè®¡ç®—çŠ¶æ€ã€‚
- en: In general, weâ€™re obliged to do this in Python because Python canâ€™t automatically
    do the tail-call optimization. There are situations, however, where this kind
    of optimization isnâ€™t actually helpful. Weâ€™ll look at a few of them.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: é€šå¸¸æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬ä¸å¾—ä¸åœ¨Pythonä¸­è¿™æ ·åšï¼Œå› ä¸ºPythonæ— æ³•è‡ªåŠ¨è¿›è¡Œå°¾è°ƒç”¨ä¼˜åŒ–ã€‚ç„¶è€Œï¼Œåœ¨æŸäº›æƒ…å†µä¸‹ï¼Œè¿™ç§ä¼˜åŒ–å®é™…ä¸Šå¹¶ä¸ helpfulã€‚æˆ‘ä»¬å°†æ¢è®¨å…¶ä¸­çš„ä¸€äº›æƒ…å†µã€‚
- en: 6.1.2 Leaving recursion in place
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.1.2 ä¿æŒé€’å½’ä¸å˜
- en: 'In some cases, the recursive definition is actually optimal. Some recursions
    involve a divide and conquer strategy that minimizes the work. One example of
    this is the algorithm for doing exponentiation by squaring. This works for computing
    values that have a positive integer exponent, like 2^(64). We can state it formally
    as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æŸäº›æƒ…å†µä¸‹ï¼Œé€’å½’å®šä¹‰å®é™…ä¸Šæ˜¯æœ€ä½³çš„ã€‚ä¸€äº›é€’å½’æ¶‰åŠåˆ†æ²»ç­–ç•¥ï¼Œè¿™å¯ä»¥æœ€å°åŒ–å·¥ä½œé‡ã€‚å…¶ä¸­ä¸€ä¸ªä¾‹å­æ˜¯å¹³æ–¹å¹‚çš„æŒ‡æ•°ç®—æ³•ã€‚è¿™é€‚ç”¨äºè®¡ç®—å…·æœ‰æ­£æ•´æ•°æŒ‡æ•°çš„å€¼ï¼Œå¦‚ 2^(64)ã€‚æˆ‘ä»¬å¯ä»¥å¦‚ä¸‹å½¢å¼åŒ–åœ°é™ˆè¿°å®ƒï¼š
- en: '![ (| ||| 1 if n = 0 n { (nâˆ’1) a = || a Ã— a if a is odd ||( n2 2 (a ) if a
    is even ](img/file50.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![ (| ||| 1 if n = 0 n { (nâˆ’1) a = || a Ã— a if a is odd ||( n2 2 (a ) if a
    is even ](img/file50.jpg)'
- en: 'Weâ€™ve broken the process into three cases, easily written in Python as a recursion.
    Look at the following function definition:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å°†è¿‡ç¨‹åˆ†è§£ä¸ºä¸‰ä¸ªæƒ…å†µï¼Œå¯ä»¥å¾ˆå®¹æ˜“åœ°ç”¨Pythonä½œä¸ºé€’å½’ç¼–å†™ã€‚çœ‹çœ‹ä»¥ä¸‹å‡½æ•°å®šä¹‰ï¼š
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: For odd numbers, the `fastexp()` method is defined recursively. The exponent
    `n` is reduced by 1\. A simple tail-recursion optimization would work for this
    case. It would not work for the even case, however.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äºå¥‡æ•°ï¼Œ`fastexp()` æ–¹æ³•å®šä¹‰ä¸ºé€’å½’ã€‚æŒ‡æ•° `n` å‡å°‘äº†1ã€‚å¯¹äºè¿™ç§æƒ…å†µï¼Œç®€å•çš„å°¾é€’å½’ä¼˜åŒ–æ˜¯å¯è¡Œçš„ã€‚ç„¶è€Œï¼Œå¯¹äºå¶æ•°æƒ…å†µï¼Œåˆ™ä¸å¯è¡Œã€‚
- en: For even numbers, the `fastexp()` recursion uses `n``Â //``Â 2`, chopping the
    problem into half of its original size. Since the problem size is reduced by a
    factor of 2, this case results in a significant speed-up of the processing.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äºå¶æ•°ï¼Œ`fastexp()` é€’å½’ä½¿ç”¨ `n // 2`ï¼Œå°†é—®é¢˜è§„æ¨¡å‡åŠã€‚ç”±äºé—®é¢˜è§„æ¨¡å‡å°‘äº†2å€ï¼Œè¿™ç§æƒ…å†µä¼šå¯¼è‡´å¤„ç†é€Ÿåº¦æ˜¾è‘—æå‡ã€‚
- en: We canâ€™t trivially reframe this kind of function into a tail-call optimization
    loop. Since itâ€™s already optimal, we donâ€™t really need to optimize it further.
    The recursion limit in Python would impose the constraint of n â‰¤ 2^(1000), a generous
    upper bound.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ä¸èƒ½ç®€å•åœ°é‡æ„è¿™ç§å‡½æ•°ä¸ºå°¾è°ƒç”¨ä¼˜åŒ–å¾ªç¯ã€‚ç”±äºå®ƒå·²ç»æ˜¯æœ€ä¼˜çš„ï¼Œæˆ‘ä»¬å®é™…ä¸Šä¸éœ€è¦è¿›ä¸€æ­¥ä¼˜åŒ–å®ƒã€‚Pythonä¸­çš„é€’å½’é™åˆ¶å°†å¯¼è‡´ n â‰¤ 2^(1000)ï¼Œè¿™æ˜¯ä¸€ä¸ªç›¸å½“å®½æ¾çš„ä¸Šé™ã€‚
- en: 6.1.3 Handling difficult tail-call optimization
  id: totrans-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.1.3 å¤„ç†å›°éš¾çš„å°¾è°ƒç”¨ä¼˜åŒ–
- en: 'We can look at the definition of Fibonacci numbers recursively. The following
    is one widely used definition for the n^(th) Fibonacci number, F[n]:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯ä»¥é€’å½’åœ°æŸ¥çœ‹æ–æ³¢é‚£å¥‘æ•°çš„å®šä¹‰ã€‚ä»¥ä¸‹æ˜¯å¯¹ç¬¬ n ä¸ªæ–æ³¢é‚£å¥‘æ•° F[n] çš„ä¸€ä¸ªå¹¿æ³›ä½¿ç”¨çš„å®šä¹‰ï¼š
- en: '![ (| ||| 0 if n = 0 { Fn = | 1 if n = 1 |||( Fnâˆ’ 1 + Fnâˆ’ 2 if n â‰¥ 2 ](img/file51.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![ (| ||| 0 if n = 0 { Fn = | 1 if n = 1 |||( Fnâˆ’ 1 + Fnâˆ’ 2 if n â‰¥ 2 ](img/file51.jpg)'
- en: 'A given Fibonacci number, F[n], is defined as the sum of the previous two numbers,
    F[nâˆ’1] + F[nâˆ’2]. This is an example of multiple recursion: it canâ€™t be trivially
    optimized as a simple tail recursion. However, if we donâ€™t optimize it to a tail
    recursion, weâ€™ll find it to be too slow to be useful.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€ä¸ªç»™å®šçš„æ–æ³¢é‚£å¥‘æ•°F[n]å®šä¹‰ä¸ºå‰ä¸¤ä¸ªæ•°çš„å’Œï¼Œå³F[nâˆ’1] + F[nâˆ’2]ã€‚è¿™æ˜¯ä¸€ä¸ªå¤šæ¬¡é€’å½’çš„ä¾‹å­ï¼šå®ƒä¸èƒ½ç®€å•åœ°ä½œä¸ºç®€å•çš„å°¾é€’å½’è¿›è¡Œä¼˜åŒ–ã€‚ç„¶è€Œï¼Œå¦‚æœæˆ‘ä»¬ä¸å°†å…¶ä¼˜åŒ–ä¸ºå°¾é€’å½’ï¼Œæˆ‘ä»¬ä¼šå‘ç°å®ƒå¤ªæ…¢è€Œæ— æ³•ä½¿ç”¨ã€‚
- en: 'The following is a naÃ¯ve implementation:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: ä»¥ä¸‹æ˜¯ä¸€ä¸ªç®€å•çš„å®ç°ï¼š
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This suffers from a terrible multiple recursion problem. When computing the
    `fib(n)` value, we must compute the `fib(n-1)` and `fib(n-2)` values. The computation
    of the `fib(n-1)` value involves a duplicate calculation of the `fib(n-2)` value.
    The two recursive uses of the `fib()` function will more than duplicate the amount
    of computation being done.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å­˜åœ¨ä¸€ä¸ªå¯æ€•çš„å¤šæ¬¡é€’å½’é—®é¢˜ã€‚åœ¨è®¡ç®—`fib(n)`å€¼æ—¶ï¼Œæˆ‘ä»¬å¿…é¡»è®¡ç®—`fib(n-1)`å’Œ`fib(n-2)`çš„å€¼ã€‚`fib(n-1)`å€¼çš„è®¡ç®—æ¶‰åŠåˆ°`fib(n-2)`å€¼çš„é‡å¤è®¡ç®—ã€‚`fib()`å‡½æ•°çš„ä¸¤æ¬¡é€’å½’ä½¿ç”¨å°†è¶…è¿‡é‡å¤è®¡ç®—çš„å·¥ä½œé‡ã€‚
- en: Because of the left-to-right Python evaluation rules, we can evaluate values
    up to about `fib(1000)`. However, we have to be patient. Very patient. (Trying
    to find the actual upper bound with the default stack size means waiting a long
    time before the `RecursionError` is raised.)
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: ç”±äºPythonä»å·¦åˆ°å³çš„è¯„ä¼°è§„åˆ™ï¼Œæˆ‘ä»¬å¯ä»¥è¯„ä¼°åˆ°å¤§çº¦`fib(1000)`çš„å€¼ã€‚ç„¶è€Œï¼Œæˆ‘ä»¬å¿…é¡»æœ‰è€å¿ƒã€‚éå¸¸è€å¿ƒã€‚ï¼ˆå°è¯•ä½¿ç”¨é»˜è®¤çš„æ ˆå¤§å°æ‰¾åˆ°å®é™…çš„ç•Œé™æ„å‘³ç€åœ¨`RecursionError`è¢«æŠ›å‡ºä¹‹å‰è¦ç­‰å¾…å¾ˆé•¿æ—¶é—´ã€‚ï¼‰
- en: 'The following is one alternative, which restates the entire algorithm to use
    stateful variables instead of a simple recursion:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: ä»¥ä¸‹æ˜¯ä¸€ä¸ªæ›¿ä»£æ–¹æ¡ˆï¼Œå®ƒé‡æ–°è¡¨è¿°äº†æ•´ä¸ªç®—æ³•ï¼Œä½¿ç”¨æœ‰çŠ¶æ€å˜é‡è€Œä¸æ˜¯ç®€å•çš„é€’å½’ï¼š
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Our stateful version of this function counts up from 0, unlike the recursion,
    which counts down from the initial value of `n`. This version is considerably
    faster than the recursive version.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬è¿™ä¸ªæœ‰çŠ¶æ€ç‰ˆæœ¬çš„å‡½æ•°ä»0å¼€å§‹è®¡æ•°ï¼Œä¸é€’å½’ä»åˆå§‹å€¼`n`å¼€å§‹è®¡æ•°ä¸åŒã€‚è¿™ä¸ªç‰ˆæœ¬æ¯”é€’å½’ç‰ˆæœ¬å¿«å¾—å¤šã€‚
- en: Whatâ€™s important here is that we couldnâ€™t trivially optimize the `fib()` function
    recursion with an obvious rewrite. In order to replace the recursion with an imperative
    version, we had to look closely at the algorithm to determine how many stateful
    intermediate variables were required.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œé‡è¦çš„æ˜¯ï¼Œæˆ‘ä»¬æ— æ³•ç®€å•åœ°é€šè¿‡æ˜æ˜¾çš„é‡å†™æ¥ä¼˜åŒ–`fib()`å‡½æ•°çš„é€’å½’ã€‚ä¸ºäº†ç”¨å‘½ä»¤å¼ç‰ˆæœ¬æ›¿æ¢é€’å½’ï¼Œæˆ‘ä»¬å¿…é¡»ä»”ç»†æŸ¥çœ‹ç®—æ³•ï¼Œä»¥ç¡®å®šéœ€è¦å¤šå°‘ä¸ªæœ‰çŠ¶æ€çš„ä¸­é—´å˜é‡ã€‚
- en: As an exercise for the reader, try using the `@cache` decorator from the `functools`
    module. What impact does this have?
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œä¸ºå¯¹è¯»è€…çš„ç»ƒä¹ ï¼Œå°è¯•ä½¿ç”¨`functools`æ¨¡å—ä¸­çš„`@cache`è£…é¥°å™¨ã€‚è¿™ä¼šäº§ç”Ÿä»€ä¹ˆå½±å“ï¼Ÿ
- en: 6.1.4 Processing collections through recursion
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.1.4 é€šè¿‡é€’å½’å¤„ç†é›†åˆ
- en: 'When working with a collection, we can also define the processing recursively.
    We can, for example, define the `map()` function recursively. The formalism could
    be stated as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: å½“å¤„ç†é›†åˆæ—¶ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥é€’å½’åœ°å®šä¹‰å¤„ç†ã€‚ä¾‹å¦‚ï¼Œæˆ‘ä»¬å¯ä»¥é€’å½’åœ°å®šä¹‰`map()`å‡½æ•°ã€‚å½¢å¼åŒ–å¯ä»¥è¡¨è¿°å¦‚ä¸‹ï¼š
- en: '![ ( |{ [] if len(C ) = 0 map (f,C ) = | ( map(f,C [:âˆ’1]) + [f (C âˆ’1)] if len(C
    ) > 0 ](img/file52.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![ ( |{ [] if len(C ) = 0 map (f,C ) = | ( map(f,C [:âˆ’1]) + [f (C âˆ’1)] if len(C
    ) > 0 ](img/file52.jpg)'
- en: Weâ€™ve defined the mapping of a function, f, to an empty collection as an empty
    sequence, `[]`. Weâ€™ve also specified that applying a function to a collection
    can be defined recursively with a three-step expression. First, recursively perform
    the mapping of the function to all of the collection except the last element,
    creating a sequence object. Then apply the function to the last element. Finally,
    append the last calculation to the previously built sequence.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å°†å‡½æ•°fæ˜ å°„åˆ°ç©ºé›†åˆå®šä¹‰ä¸ºç©ºåºåˆ—`[]`ã€‚æˆ‘ä»¬è¿˜æŒ‡å®šäº†å°†å‡½æ•°åº”ç”¨äºé›†åˆå¯ä»¥é€šè¿‡ä¸€ä¸ªä¸‰æ­¥è¡¨è¾¾å¼é€’å½’å®šä¹‰ã€‚é¦–å…ˆï¼Œé€’å½’åœ°å¯¹å‡½æ•°åº”ç”¨äºé™¤æœ€åä¸€ä¸ªå…ƒç´ ä¹‹å¤–çš„æ‰€æœ‰é›†åˆå…ƒç´ è¿›è¡Œæ˜ å°„ï¼Œåˆ›å»ºä¸€ä¸ªåºåˆ—å¯¹è±¡ã€‚ç„¶åå¯¹æœ€åä¸€ä¸ªå…ƒç´ åº”ç”¨å‡½æ•°ã€‚æœ€åï¼Œå°†æœ€åçš„è®¡ç®—ç»“æœè¿½åŠ åˆ°ä¹‹å‰æ„å»ºçš„åºåˆ—ä¸­ã€‚
- en: 'Following is a purely recursive function version of this `map()` function:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ä»¥ä¸‹æ˜¯è¿™ä¸ª`map()`å‡½æ•°çš„çº¯é€’å½’å‡½æ•°ç‰ˆæœ¬ï¼š
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The value of the `mapr(f,[])` method is defined to be an empty list object.
    The value of the `mapr()` function with a non-empty list will apply the function
    to the last element in the list and append this to the list built recursively
    from the `mapr()` function applied to the head of the list.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`mapr(f,[])`æ–¹æ³•å®šä¹‰çš„å€¼æ˜¯ä¸€ä¸ªç©ºåˆ—è¡¨å¯¹è±¡ã€‚å¯¹äºéç©ºåˆ—è¡¨çš„`mapr()`å‡½æ•°ï¼Œå°†åº”ç”¨å‡½æ•°åˆ°åˆ—è¡¨çš„æœ€åä¸€ä¸ªå…ƒç´ ï¼Œå¹¶å°†å…¶è¿½åŠ åˆ°ç”±åº”ç”¨äºåˆ—è¡¨å¤´çš„`mapr()`å‡½æ•°é€’å½’æ„å»ºçš„åˆ—è¡¨ä¸­ã€‚'
- en: We have to emphasize that this `mapr()` function actually creates a list object.
    The built-in `map()` function is an iterator; it doesnâ€™t create a list object.
    It yields the result values as they are computed. Also, the work is done in right-to-left
    order, which is not the way Python normally works. This is only observable when
    using a function that has side effects, something weâ€™d like to avoid doing.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¿…é¡»å¼ºè°ƒï¼Œè¿™ä¸ª`mapr()`å‡½æ•°å®é™…ä¸Šåˆ›å»ºäº†ä¸€ä¸ªåˆ—è¡¨å¯¹è±¡ã€‚å†…ç½®çš„`map()`å‡½æ•°æ˜¯ä¸€ä¸ªè¿­ä»£å™¨ï¼›å®ƒä¸ä¼šåˆ›å»ºåˆ—è¡¨å¯¹è±¡ã€‚å®ƒæŒ‰è®¡ç®—é¡ºåºäº§ç”Ÿç»“æœå€¼ã€‚æ­¤å¤–ï¼Œå·¥ä½œæ˜¯åœ¨ä»å³åˆ°å·¦çš„é¡ºåºä¸­å®Œæˆçš„ï¼Œè¿™ä¸æ˜¯Pythoné€šå¸¸çš„å·¥ä½œæ–¹å¼ã€‚è¿™åªæœ‰åœ¨ä½¿ç”¨å…·æœ‰å‰¯ä½œç”¨çš„åŠŸèƒ½æ—¶æ‰ä¼šè§‚å¯Ÿåˆ°ï¼Œè¿™æ˜¯æˆ‘ä»¬å¸Œæœ›é¿å…åšçš„äº‹æƒ…ã€‚
- en: While this is an elegant formalism, it still lacks the tail-call optimization
    required. An optimization will allow us to exceed the default recursion limit
    of 1,000 and also performs much more quickly than this naÃ¯ve recursion.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: è™½ç„¶è¿™æ˜¯ä¸€ä¸ªä¼˜é›…çš„å½¢å¼ä¸»ä¹‰ï¼Œä½†å®ƒä»ç„¶ç¼ºä¹æ‰€éœ€çš„å°¾è°ƒç”¨ä¼˜åŒ–ã€‚ä¼˜åŒ–å°†ä½¿æˆ‘ä»¬èƒ½å¤Ÿè¶…è¿‡é»˜è®¤çš„é€’å½’é™åˆ¶1,000ï¼Œå¹¶ä¸”æ¯”è¿™ç§åŸå§‹é€’å½’å¿«å¾—å¤šã€‚
- en: The use of `Callable[[Any],``Â Any]` is a weak type hint. To be more clear, it
    can help to define a domain type variable and a range type variable. Weâ€™ll include
    this detail in the optimized example.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨`Callable[[Any], Any]`æ˜¯ä¸€ç§å¼±ç±»å‹æç¤ºã€‚ä¸ºäº†æ›´æ¸…æ¥šï¼Œå¯ä»¥å®šä¹‰ä¸€ä¸ªåŸŸç±»å‹å˜é‡å’Œä¸€ä¸ªèŒƒå›´ç±»å‹å˜é‡ã€‚æˆ‘ä»¬å°†åœ¨ä¼˜åŒ–ç¤ºä¾‹ä¸­åŒ…å«è¿™ä¸ªç»†èŠ‚ã€‚
- en: 6.1.5 Tail-call optimization for collections
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.1.5 é›†åˆçš„å°¾è°ƒç”¨ä¼˜åŒ–
- en: 'We have two general ways to handle collections: we can use a higher-order function
    that returns a generator expression, or we can create a function that uses a `for`
    statement to process each item in a collection. These two patterns are very similar.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬æœ‰ä¸¤ç§å¤„ç†é›†åˆçš„ä¸€èˆ¬æ–¹æ³•ï¼šæˆ‘ä»¬å¯ä»¥ä½¿ç”¨è¿”å›ç”Ÿæˆå™¨è¡¨è¾¾å¼çš„é«˜é˜¶å‡½æ•°ï¼Œæˆ–è€…æˆ‘ä»¬å¯ä»¥åˆ›å»ºä¸€ä¸ªä½¿ç”¨`for`è¯­å¥å¤„ç†é›†åˆä¸­æ¯ä¸ªé¡¹çš„å‡½æ•°ã€‚è¿™ä¸¤ç§æ¨¡å¼éå¸¸ç›¸ä¼¼ã€‚
- en: 'Following is a higher-order function that behaves like the built-in `map()`
    function:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ä»¥ä¸‹æ˜¯ä¸€ä¸ªç±»ä¼¼äºå†…ç½®`map()`å‡½æ•°çš„é«˜é˜¶å‡½æ•°ï¼š
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Weâ€™ve returned a generator expression that produces the required mapping. This
    uses the explicit `for` in the generator expression as a kind of tail-call optimization.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬è¿”å›äº†ä¸€ä¸ªç”Ÿæˆå™¨è¡¨è¾¾å¼ï¼Œå®ƒäº§ç”Ÿäº†æ‰€éœ€çš„æ˜ å°„ã€‚è¿™ä½¿ç”¨äº†ç”Ÿæˆå™¨è¡¨è¾¾å¼ä¸­çš„æ˜¾å¼`for`ä½œä¸ºå°¾è°ƒç”¨ä¼˜åŒ–çš„ä¸€ç§å½¢å¼ã€‚
- en: The source of data, `C`, has a type hint of `Iterable[DomT]` to emphasize that
    some type, `DomT`, will form the domain for the mapping. The transformation function
    has a hint of `Callable[[DomT],``Â RngT]` to make it clear that it transforms from
    some domain type to a range type. The function `float()`, for example, can transform
    values from the string domain to the float range. The result has the hint of `Iterator[RngT]`
    to show that it iterates over the range type, `RngT`; the result type of the callable
    function.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: æ•°æ®æº`C`æœ‰ä¸€ä¸ªç±»å‹æç¤º`Iterable[DomT]`ï¼Œä»¥å¼ºè°ƒæŸäº›ç±»å‹`DomT`å°†å½¢æˆæ˜ å°„çš„åŸŸã€‚è½¬æ¢å‡½æ•°æœ‰ä¸€ä¸ªæç¤º`Callable[[DomT],
    RngT]`ï¼Œä»¥ä½¿å…¶æ˜ç¡®åœ°ä»æŸä¸ªåŸŸç±»å‹è½¬æ¢åˆ°èŒƒå›´ç±»å‹ã€‚ä¾‹å¦‚ï¼Œ`float()`å‡½æ•°å¯ä»¥å°†å€¼ä»å­—ç¬¦ä¸²åŸŸè½¬æ¢ä¸ºæµ®ç‚¹æ•°èŒƒå›´ã€‚ç»“æœæœ‰ä¸€ä¸ªæç¤º`Iterator[RngT]`ï¼Œä»¥è¡¨æ˜å®ƒéå†èŒƒå›´ç±»å‹`RngT`ï¼›å¯è°ƒç”¨å‡½æ•°çš„ç»“æœç±»å‹ã€‚
- en: 'The following is a generator function with the same signature and result:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: ä»¥ä¸‹æ˜¯ä¸€ä¸ªå…·æœ‰ç›¸åŒç­¾åå’Œç»“æœçš„ç”Ÿæˆå™¨å‡½æ•°ï¼š
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This uses a complete `for` statement for the tail-call optimization. The results
    are identical. This version is slightly slower because it involves multiple statements.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä½¿ç”¨äº†å®Œæ•´çš„`for`è¯­å¥è¿›è¡Œå°¾è°ƒç”¨ä¼˜åŒ–ã€‚ç»“æœç›¸åŒã€‚è¿™ä¸ªç‰ˆæœ¬ç¨å¾®æ…¢ä¸€äº›ï¼Œå› ä¸ºå®ƒæ¶‰åŠå¤šä¸ªè¯­å¥ã€‚
- en: 'In both cases, the result is an iterator over the results. We must do something
    else to materialize a sequence object from an iterable source. For example, here
    is the `list()` function being used to create a sequence from the iterator:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™ä¸¤ç§æƒ…å†µä¸‹ï¼Œç»“æœæ˜¯å¯¹ç»“æœçš„ä¸€ä¸ªè¿­ä»£å™¨ã€‚æˆ‘ä»¬å¿…é¡»åšäº›åˆ«çš„äº‹æƒ…ï¼Œæ‰èƒ½ä»ä¸€ä¸ªå¯è¿­ä»£æºä¸­åˆ›å»ºä¸€ä¸ªåºåˆ—å¯¹è±¡ã€‚ä¾‹å¦‚ï¼Œè¿™é‡Œä½¿ç”¨`list()`å‡½æ•°ä»è¿­ä»£å™¨åˆ›å»ºåºåˆ—ï¼š
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: For performance and scalability, this kind of tail-call optimization is required
    in Python programs. It makes the code less than purely functional. However, the
    benefit far outweighs the lack of purity. In order to reap the benefits of succinct
    and expressive functional design, it is helpful to treat these less-than-pure
    functions as if they were proper recursions.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºäº†æ€§èƒ½å’Œå¯æ‰©å±•æ€§ï¼ŒPythonç¨‹åºä¸­éœ€è¦è¿™ç§å°¾è°ƒç”¨ä¼˜åŒ–ã€‚è¿™ä½¿å¾—ä»£ç ä¸å¦‚çº¯å‡½æ•°ã€‚ç„¶è€Œï¼Œå¥½å¤„è¿œè¿œè¶…è¿‡äº†çº¯åº¦çš„ç¼ºä¹ã€‚ä¸ºäº†è·å¾—ç®€æ´å’Œè¡¨è¾¾æ€§å¼ºçš„å‡½æ•°å¼è®¾è®¡çš„ç›Šå¤„ï¼Œå°†è¿™äº›éçº¯å‡½æ•°è§†ä¸ºé€‚å½“çš„é€’å½’æ˜¯æœ‰å¸®åŠ©çš„ã€‚
- en: What this means, pragmatically, is that we must avoid cluttering up a collection
    processing function with additional stateful processing. The central tenets of
    functional programming are still valid even if some elements of our programs are
    less than purely functional.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™åœ¨å®ç”¨æ„ä¹‰ä¸Šæ„å‘³ç€æˆ‘ä»¬å¿…é¡»é¿å…åœ¨é›†åˆå¤„ç†å‡½æ•°ä¸­æ·»åŠ é¢å¤–çš„çŠ¶æ€åŒ–å¤„ç†ã€‚å³ä½¿æˆ‘ä»¬ç¨‹åºçš„ä¸€äº›å…ƒç´ ä¸æ˜¯å®Œå…¨å‡½æ•°å¼çš„ï¼Œå‡½æ•°å¼ç¼–ç¨‹çš„æ ¸å¿ƒåŸåˆ™ä»ç„¶æœ‰æ•ˆã€‚
- en: 6.1.6 Using the assignment (sometimes called the â€walrusâ€) operator in recursions
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.1.6 åœ¨é€’å½’ä¸­ä½¿ç”¨èµ‹å€¼ï¼ˆæœ‰æ—¶ç§°ä¸ºâ€œwalrusâ€ï¼‰è¿ç®—ç¬¦
- en: In some cases, recursions involve conditional processing that can be optimized
    using the â€walrusâ€ or assignment operator, `:=`. The use of assignment means that
    weâ€™re introducing stateful variables. If weâ€™re careful of the scope of those variables,
    the possibility of terribly complex algorithms is reduced.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æŸäº›æƒ…å†µä¸‹ï¼Œé€’å½’æ¶‰åŠå¯ä»¥ä½¿ç”¨â€œwalrusâ€æˆ–èµ‹å€¼è¿ç®—ç¬¦`:=`è¿›è¡Œä¼˜åŒ–çš„æ¡ä»¶å¤„ç†ã€‚ä½¿ç”¨èµ‹å€¼æ„å‘³ç€æˆ‘ä»¬æ­£åœ¨å¼•å…¥çŠ¶æ€å˜é‡ã€‚å¦‚æœæˆ‘ä»¬å°å¿ƒè¿™äº›å˜é‡çš„ä½œç”¨åŸŸï¼Œé‚£ä¹ˆäº§ç”Ÿæå…¶å¤æ‚ç®—æ³•çš„å¯èƒ½æ€§å°±ä¼šé™ä½ã€‚
- en: 'We reviewed the `fast_exp()` function shown below in the [Leaving recursion
    in place](#x1-1290002) section. This function used three separate cases to implement
    a divide and conquer strategy. In the case of raising a number, `a`, to an even
    power, we can use t = a^(![n 2](img/file53.jpg)) to compute t Ã— t = a^n:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬åœ¨[ä¿ç•™é€’å½’](#x1-1290002)éƒ¨åˆ†å›é¡¾äº†ä¸‹é¢çš„`fast_exp()`å‡½æ•°ã€‚è¿™ä¸ªå‡½æ•°ä½¿ç”¨äº†ä¸‰ä¸ªä¸åŒçš„æ¡ˆä¾‹æ¥å®ç°åˆ†è€Œæ²»ä¹‹çš„ç­–ç•¥ã€‚åœ¨å°†æ•°å­—`a`æå‡åˆ°å¶æ•°æ¬¡å¹‚çš„æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨`t
    = a^![n 2](img/file53.jpg)`æ¥è®¡ç®—`t Ã— t = a^n`ï¼š
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This uses the `:=` walrus operator to compute a partial answer, `fastexp_w(a,``Â q)`,
    and save it into a temporary variable, `t`. This is used later in the same statement
    to compute `t``Â *``Â t`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä½¿ç”¨`:=` walrusè¿ç®—ç¬¦æ¥è®¡ç®—éƒ¨åˆ†ç­”æ¡ˆ`fastexp_w(a, q)`å¹¶å°†å…¶ä¿å­˜åˆ°ä¸´æ—¶å˜é‡`t`ä¸­ã€‚è¿™å°†åœ¨åŒä¸€è¯­å¥çš„ç¨åéƒ¨åˆ†ç”¨äºè®¡ç®—`t *
    t`ã€‚
- en: For the most part, when we perform tail-call optimization on a recursion, the
    body of the `for` statement will have ordinary assignment statements. It isnâ€™t
    often necessary to exploit the walrus operator.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äºé€’å½’çš„å¤§éƒ¨åˆ†æƒ…å†µï¼Œå½“æˆ‘ä»¬å¯¹é€’å½’è¿›è¡Œå°¾è°ƒç”¨ä¼˜åŒ–æ—¶ï¼Œ`for`è¯­å¥çš„ä¸»ä½“å°†åŒ…å«æ™®é€šèµ‹å€¼è¯­å¥ã€‚é€šå¸¸æ²¡æœ‰å¿…è¦åˆ©ç”¨walrusè¿ç®—ç¬¦ã€‚
- en: The assignment operator is often used in situations like regular expression
    matching, where we want to save the match object as well as make a decision. Itâ€™s
    very common to see `if``Â (match``Â :=``Â pattern.match(text)):` as a way to both
    attempt a regular expression match, save the resulting match object, and confirm
    itâ€™s not a `None` object.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: èµ‹å€¼è¿ç®—ç¬¦å¸¸ç”¨äºæ­£åˆ™è¡¨è¾¾å¼åŒ¹é…ç­‰åœºæ™¯ï¼Œæˆ‘ä»¬å¸Œæœ›ä¿å­˜åŒ¹é…å¯¹è±¡å¹¶åšå‡ºå†³ç­–ã€‚`if(match := pattern.match(text)):`ä½œä¸ºå°è¯•æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…ã€ä¿å­˜ç»“æœåŒ¹é…å¯¹è±¡å¹¶ç¡®è®¤å®ƒä¸æ˜¯`None`å¯¹è±¡çš„ä¸€ç§å¸¸è§æ–¹å¼ã€‚
- en: 6.2 Reductions and folding a collection from many items to one
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2 ä»å¤šä¸ªé¡¹ç›®æŠ˜å é›†åˆåˆ°å•ä¸ªé¡¹ç›®
- en: 'We can consider the `sum()` function to have the following kind of definition.
    We could say that the sum of a collection is 0 for an empty collection. For a
    non-empty collection, the sum is the first element plus the sum of the remaining
    elements:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯ä»¥å°†`sum()`å‡½æ•°è€ƒè™‘ä¸ºä»¥ä¸‹ç±»å‹çš„å®šä¹‰ã€‚æˆ‘ä»¬å¯ä»¥è¯´ï¼Œå¯¹äºç©ºé›†åˆï¼Œé›†åˆçš„å’Œä¸º0ã€‚å¯¹äºéç©ºé›†åˆï¼Œå’Œæ˜¯ç¬¬ä¸€ä¸ªå…ƒç´ åŠ ä¸Šå‰©ä½™å…ƒç´ çš„å’Œï¼š
- en: '![ (| { 0 if n = 0 sum ([c0,c1,c2,...,cn]) = | ( c0 + sum ([c1,c2,...,cn])
    if n > 0 ](img/file54.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![ (| { 0 if n = 0 sum ([c0,c1,c2,...,cn]) = | ( c0 + sum ([c1,c2,...,cn])
    if n > 0 ](img/file54.jpg)'
- en: 'We can use a slightly simplified notation called the Bird-Meertens Formalism.
    This uses âŠ•âˆ•[c[0],c[1],...c[n]] to show how some arbitrary binary operator, âŠ•,
    can be applied to a sequence of values. Itâ€™s used as follows to summarize a recursive
    definition into something a little easier to work with:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¸€ç§ç¨å¾®ç®€åŒ–çš„ç¬¦å·ï¼Œç§°ä¸ºBird-Meertenså½¢å¼ä¸»ä¹‰ã€‚å®ƒä½¿ç”¨âŠ•âˆ•[c[0],c[1],...c[n]]æ¥æ˜¾ç¤ºæŸäº›ä»»æ„äºŒå…ƒè¿ç®—ç¬¦âŠ•å¦‚ä½•åº”ç”¨äºä¸€ç³»åˆ—å€¼ã€‚å®ƒå¦‚ä¸‹æ‰€ç¤ºï¼Œå°†é€’å½’å®šä¹‰æ€»ç»“ä¸ºæ›´å®¹æ˜“å¤„ç†çš„ä¸œè¥¿ï¼š
- en: '![sum ([c0,c1,c2,...,cn]) = + âˆ•[c0,c1,c2,...,cn] = 0+ c0 + c1 + ...+ cn ](img/file55.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![sum ([c0,c1,c2,...,cn]) = + âˆ•[c0,c1,c2,...,cn] = 0+ c0 + c1 + ...+ cn ](img/file55.jpg)'
- en: Weâ€™ve effectively folded the + operator between each item of the sequence. Implicitly,
    the processing will be done left to right. This could be called a â€fold leftâ€
    way of reducing a collection to a single value. We could also imagine grouping
    the operators from right to left, calling this a â€fold right.â€ While some compiled
    languages will perform this optimization, Python works strictly from left to right
    when given a sequence of similar precedence operators.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬æœ‰æ•ˆåœ°å°†åºåˆ—ä¸­æ¯ä¸ªé¡¹ç›®ä¹‹é—´çš„åŠ æ³•è¿ç®—ç¬¦æŠ˜å èµ·æ¥ã€‚éšå¼åœ°ï¼Œå¤„ç†å°†æŒ‰ä»å·¦åˆ°å³çš„é¡ºåºè¿›è¡Œã€‚è¿™å¯ä»¥ç§°ä¸ºå°†é›†åˆæŠ˜å ä¸ºå•ä¸ªå€¼çš„â€œfold leftâ€æ–¹å¼ã€‚æˆ‘ä»¬ä¹Ÿå¯ä»¥æƒ³è±¡ä»å³åˆ°å·¦åˆ†ç»„è¿ç®—ç¬¦ï¼Œç§°ä¹‹ä¸ºâ€œfold
    rightâ€ã€‚è™½ç„¶ä¸€äº›ç¼–è¯‘å‹è¯­è¨€ä¼šæ‰§è¡Œè¿™ç§ä¼˜åŒ–ï¼Œä½†Pythonåœ¨ç»™å®šä¸€ç³»åˆ—å…·æœ‰ç›¸åŒä¼˜å…ˆçº§çš„è¿ç®—ç¬¦æ—¶ï¼Œä¼šä¸¥æ ¼ä»å·¦åˆ°å³å·¥ä½œã€‚
- en: 'In Python, a product function can be defined recursively as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨Pythonä¸­ï¼Œä¹˜ç§¯å‡½æ•°å¯ä»¥é€’å½’åœ°å®šä¹‰ä¸ºä»¥ä¸‹å†…å®¹ï¼š
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This is a tiny rewrite from a mathematical notation to Python. However, it is
    less than optimal because all of the slices will create a large number of intermediate
    list objects. Itâ€™s also limited to only working with explicit collections; it
    canâ€™t work easily with iterable objects.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯å¯¹æ•°å­¦ç¬¦å·åˆ°Pythonçš„å¾®å°é‡å†™ã€‚ç„¶è€Œï¼Œå®ƒå¹¶ä¸ç†æƒ³ï¼Œå› ä¸ºæ‰€æœ‰çš„åˆ‡ç‰‡éƒ½ä¼šåˆ›å»ºå¤§é‡ä¸­é—´åˆ—è¡¨å¯¹è±¡ã€‚å®ƒä¹Ÿä»…é™äºä¸æ˜¾å¼é›†åˆä¸€èµ·å·¥ä½œï¼›å®ƒä¸èƒ½å®¹æ˜“åœ°ä¸å¯è¿­ä»£å¯¹è±¡ä¸€èµ·å·¥ä½œã€‚
- en: 'We can revise this slightly to work with an iterable, which avoids creating
    any intermediate collection objects. The following is a properly recursive product
    function that works with any iterator as a source of data:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯ä»¥ç¨ä½œä¿®æ”¹ä»¥é€‚åº”å¯è¿­ä»£å¯¹è±¡ï¼Œè¿™æ ·å¯ä»¥é¿å…åˆ›å»ºä»»ä½•ä¸­é—´é›†åˆå¯¹è±¡ã€‚ä»¥ä¸‹æ˜¯ä¸€ä¸ªæ­£ç¡®é€’å½’çš„ä¹˜ç§¯å‡½æ•°ï¼Œå®ƒå¯ä»¥ä¸ä»»ä½•è¿­ä»£å™¨ä½œä¸ºæ•°æ®æºä¸€èµ·å·¥ä½œï¼š
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This doesnâ€™t work with iterable collections. We canâ€™t interrogate an iterator
    with the `len()` function to see how many elements it has. All we can do is attempt
    to extract the head of the iterator. If there are no items in the iterator, then
    any attempt to get the head will raise the `StopIteration` exception. If there
    is an item, then we can multiply this item by the product of the remaining items
    in the sequence.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸é€‚ç”¨äºå¯è¿­ä»£é›†åˆã€‚æˆ‘ä»¬æ— æ³•ä½¿ç”¨`len()`å‡½æ•°æ¥æŸ¥è¯¢è¿­ä»£å™¨æœ‰å¤šå°‘å…ƒç´ ã€‚æˆ‘ä»¬æ‰€èƒ½åšçš„å°±æ˜¯å°è¯•æå–è¿­ä»£å™¨çš„å¤´éƒ¨ã€‚å¦‚æœæ²¡æœ‰å…ƒç´ åœ¨è¿­ä»£å™¨ä¸­ï¼Œé‚£ä¹ˆä»»ä½•è·å–å¤´éƒ¨å°è¯•éƒ½ä¼šå¼•å‘`StopIteration`å¼‚å¸¸ã€‚å¦‚æœæœ‰å…ƒç´ ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥å°†è¿™ä¸ªå…ƒç´ ä¹˜ä»¥åºåˆ—ä¸­å‰©ä½™å…ƒç´ çš„ä¹˜ç§¯ã€‚
- en: 'Note that we must explicitly create an iterator from a materialized sequence
    object, using the `iter()` function. In other contexts, we might have an iterable
    result that we can use. Following is an example:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œæˆ‘ä»¬å¿…é¡»æ˜¾å¼åœ°ä½¿ç”¨`iter()`å‡½æ•°ä»ä¸€ä¸ªå…·ä½“åŒ–çš„åºåˆ—å¯¹è±¡åˆ›å»ºä¸€ä¸ªè¿­ä»£å™¨ã€‚åœ¨å…¶ä»–ä¸Šä¸‹æ–‡ä¸­ï¼Œæˆ‘ä»¬å¯èƒ½æœ‰ä¸€ä¸ªå¯è¿­ä»£çš„è¾“å‡ºç»“æœå¯ä»¥ä½¿ç”¨ã€‚ä»¥ä¸‹æ˜¯ä¸€ä¸ªç¤ºä¾‹ï¼š
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This recursive definition does not rely on explicit state or other imperative
    features of Python. While itâ€™s more purely functional, it is still limited to
    working with collections of under 1,000 items. (While we can extend the stack
    size, itâ€™s far better to optimize this properly.) Pragmatically, we can use the
    following kind of imperative structure for reduction functions:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ªé€’å½’å®šä¹‰ä¸ä¾èµ–äºæ˜¾å¼çŠ¶æ€æˆ–Pythonçš„å…¶ä»–å‘½ä»¤å¼ç‰¹æ€§ã€‚è™½ç„¶å®ƒæ›´çº¯ç²¹æ˜¯å‡½æ•°å¼çš„ï¼Œä½†å®ƒä»ç„¶é™åˆ¶åœ¨å¤„ç†å°äº1,000ä¸ªé¡¹ç›®çš„é›†åˆã€‚ï¼ˆè™½ç„¶æˆ‘ä»¬å¯ä»¥æ‰©å±•æ ˆçš„å¤§å°ï¼Œä½†æ­£ç¡®ä¼˜åŒ–è¿™ä¸€ç‚¹è¦å¥½å¾—å¤šã€‚ï¼‰ä»å®ç”¨ä¸»ä¹‰çš„è§’åº¦æ¥çœ‹ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä»¥ä¸‹ç±»å‹çš„å‘½ä»¤å¼ç»“æ„æ¥å¤„ç†å½’çº¦å‡½æ•°ï¼š
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This avoids any recursion limits. It includes the required tail-call optimization.
    Furthermore, this will work equally well with any iterable. This means a `Sequence`
    object, or an iterator.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é¿å…äº†ä»»ä½•é€’å½’é™åˆ¶ã€‚å®ƒåŒ…æ‹¬æ‰€éœ€çš„å°¾è°ƒç”¨ä¼˜åŒ–ã€‚æ­¤å¤–ï¼Œè¿™å°†ä»¥ç›¸åŒçš„æ–¹å¼ä¸ä»»ä½•å¯è¿­ä»£å¯¹è±¡ä¸€èµ·å·¥ä½œã€‚è¿™æ„å‘³ç€ä¸€ä¸ª`Sequence`å¯¹è±¡ï¼Œæˆ–è€…ä¸€ä¸ªè¿­ä»£å™¨ã€‚
- en: 6.2.1 Tail-call optimization using deques
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.2.1 ä½¿ç”¨åŒç«¯é˜Ÿåˆ—è¿›è¡Œå°¾è°ƒç”¨ä¼˜åŒ–
- en: The heart of recursion is a stack of function calls. Evaluating `fact(5)`, for
    example, is `5*fact(4)`. The value of `fact(4)` is `5*fact(3)`. There is a stack
    of pending computations until `fact(0)` has a value of 1\. Then the stack of computations
    is completed, revealing the final result.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: é€’å½’çš„æ ¸å¿ƒæ˜¯å‡½æ•°è°ƒç”¨çš„æ ˆã€‚ä¾‹å¦‚ï¼Œè¯„ä¼°`fact(5)`æ˜¯`5*fact(4)`ã€‚`fact(4)`çš„å€¼æ˜¯`5*fact(3)`ã€‚ç›´åˆ°`fact(0)`çš„å€¼ä¸º1ï¼Œæ‰ä¼šæœ‰ä¸€ç³»åˆ—å¾…å¤„ç†çš„è®¡ç®—ã€‚ç„¶åè®¡ç®—æ ˆå®Œæˆï¼Œæ­ç¤ºæœ€ç»ˆç»“æœã€‚
- en: Python manages the stack of calls for us. It imposes an arbitrary default limit
    of 1,000 calls on the stack, to prevent a program with a bug in the recursion
    from running forever.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Pythonä¸ºæˆ‘ä»¬ç®¡ç†è°ƒç”¨æ ˆã€‚å®ƒå¯¹æ ˆå¼ºåŠ äº†ä¸€ä¸ªä»»æ„é»˜è®¤é™åˆ¶ï¼Œå³1,000æ¬¡è°ƒç”¨ï¼Œä»¥é˜²æ­¢å…·æœ‰é€’å½’é”™è¯¯çš„ç¨‹åºæ— é™æœŸåœ°è¿è¡Œã€‚
- en: We can manage the stack manually, also. This gives us another way to optimize
    recursions. We canâ€”explicitlyâ€”create a stack of pending work. We can then do a
    final summarization of the pending work, emptying the items from the stack.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ä¹Ÿå¯ä»¥æ‰‹åŠ¨ç®¡ç†æ ˆã€‚è¿™ä¸ºæˆ‘ä»¬æä¾›äº†ä¼˜åŒ–é€’å½’çš„å¦ä¸€ç§æ–¹æ³•ã€‚æˆ‘ä»¬å¯ä»¥â€”â€”æ˜ç¡®åœ°â€”â€”åˆ›å»ºä¸€ä¸ªå¾…å¤„ç†å·¥ä½œçš„æ ˆã€‚ç„¶åæˆ‘ä»¬å¯ä»¥å¯¹å¾…å¤„ç†å·¥ä½œè¿›è¡Œæœ€ç»ˆæ€»ç»“ï¼Œä»æ ˆä¸­æ¸…ç©ºé¡¹ç›®ã€‚
- en: For something as simple as computing a factorial value, the stacking and unstacking
    can seem like needless overhead. For more complex applications, like examining
    the hierarchical file system, it seems more appropriate to mix processing files
    with putting directories onto a stack for later consideration.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äºåƒè®¡ç®—é˜¶ä¹˜å€¼è¿™æ ·ç®€å•çš„äº‹æƒ…ï¼Œå †æ ˆçš„å‹å…¥å’Œå¼¹å‡ºå¯èƒ½çœ‹èµ·æ¥åƒæ˜¯æ— ç”¨çš„å¼€é”€ã€‚å¯¹äºæ›´å¤æ‚çš„åº”ç”¨ï¼Œå¦‚æ£€æŸ¥åˆ†å±‚æ–‡ä»¶ç³»ç»Ÿï¼Œå°†æ–‡ä»¶å¤„ç†ä¸å°†ç›®å½•æ”¾å…¥å †æ ˆä»¥ä¾›ä»¥åè€ƒè™‘æ··åˆèµ·æ¥ä¼¼ä¹æ›´åˆé€‚ã€‚
- en: We need a function to traverse a directory hierarchy without an explicit recursion.
    The core concept is that a directory is a collection of entries, and each entry
    is either a file, a sub-directory, or some other filesystem object we donâ€™t want
    to touch (e.g., a mount point, symbolic link, etc.).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬éœ€è¦ä¸€ä¸ªå‡½æ•°æ¥éå†ç›®å½•å±‚æ¬¡ç»“æ„è€Œä¸ä½¿ç”¨æ˜¾å¼é€’å½’ã€‚æ ¸å¿ƒæ¦‚å¿µæ˜¯ç›®å½•æ˜¯ä¸€ç³»åˆ—æ¡ç›®ï¼Œæ¯ä¸ªæ¡ç›®è¦ä¹ˆæ˜¯ä¸€ä¸ªæ–‡ä»¶ï¼Œè¦ä¹ˆæ˜¯ä¸€ä¸ªå­ç›®å½•ï¼Œæˆ–è€…æ˜¯æˆ‘ä»¬ä¸æƒ³æ¥è§¦çš„å…¶ä»–æ–‡ä»¶ç³»ç»Ÿå¯¹è±¡ï¼ˆä¾‹å¦‚ï¼ŒæŒ‚è½½ç‚¹ã€ç¬¦å·é“¾æ¥ç­‰ï¼‰ã€‚
- en: 'We can say a node in the directory tree is a collection of entries: N = e[0],e[1],e[2],...,e[n].
    Each entry is either another directory, e âˆˆğ”», or a file, e âˆˆğ”½.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯ä»¥è¯´ç›®å½•æ ‘ä¸­çš„ä¸€ä¸ªèŠ‚ç‚¹æ˜¯ä¸€ç³»åˆ—æ¡ç›®ï¼šN = e[0],e[1],e[2],...,e[n]ã€‚æ¯ä¸ªæ¡ç›®è¦ä¹ˆæ˜¯å¦ä¸€ä¸ªç›®å½•ï¼Œe âˆˆğ”»ï¼Œè¦ä¹ˆæ˜¯ä¸€ä¸ªæ–‡ä»¶ï¼Œe
    âˆˆğ”½ã€‚
- en: We can perform mappings on each file in the tree to process each fileâ€™s content.
    We might perform a filter operation to create an iterator over files with a specific
    property. We can also perform a reduction to count the number of files with a
    property. In this example, weâ€™ll count the occurrences of a specific substring
    throughout the contents of files in a directory tree.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯ä»¥åœ¨æ ‘ä¸­çš„æ¯ä¸ªæ–‡ä»¶ä¸Šæ‰§è¡Œæ˜ å°„ä»¥å¤„ç†æ¯ä¸ªæ–‡ä»¶çš„å†…å®¹ã€‚æˆ‘ä»¬å¯èƒ½æ‰§è¡Œä¸€ä¸ªè¿‡æ»¤æ“ä½œæ¥åˆ›å»ºå…·æœ‰ç‰¹å®šå±æ€§çš„æ–‡ä»¶è¿­ä»£å™¨ã€‚æˆ‘ä»¬è¿˜å¯ä»¥æ‰§è¡Œå½’çº¦æ“ä½œæ¥è®¡ç®—å…·æœ‰å±æ€§çš„æ–‡ä»¶æ•°é‡ã€‚åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œæˆ‘ä»¬å°†è®¡ç®—ç›®å½•æ ‘ä¸­æ–‡ä»¶å†…å®¹ä¸­ç‰¹å®šå­å­—ç¬¦ä¸²çš„å‡ºç°æ¬¡æ•°ã€‚
- en: 'Formally, we want a function p(f) that will provide the count of `"print"`
    in a node of the directory tree. It could be defined like this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: å½¢å¼ä¸Šï¼Œæˆ‘ä»¬å¸Œæœ›æœ‰ä¸€ä¸ªå‡½æ•°p(f)ï¼Œå®ƒå°†ä¸ºç›®å½•æ ‘èŠ‚ç‚¹ä¸­çš„â€œæ‰“å°â€æä¾›è®¡æ•°ã€‚å®ƒå¯ä»¥å®šä¹‰å¦‚ä¸‹ï¼š
- en: '![ ( |{|â€œprintâ€ âˆˆ N | if N âˆˆ ğ”½ p(N ) = âˆ‘ |( eâˆˆN p(e) if N âˆˆ ğ”» ](img/file56.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![ ( |{|â€œæ‰“å°â€ âˆˆ N | å¦‚æœ N âˆˆ ğ”½ p(N ) = âˆ‘ |( eâˆˆN p(e) if N âˆˆ ğ”» ](img/file56.jpg)'
- en: This shows how to apply the p(N) function to each element of a directory tree.
    When the element is a file, e âˆˆğ”½, we can count instances of â€printâ€. When the
    element is a directory, e âˆˆğ”», we need to apply the p(N) function recursively to
    each entry, e[x], in the directory. While directory trees canâ€™t be deep enough
    to break Pythonâ€™s stack size limit, this kind of algorithm reveals an alternative
    tail-call optimization. It is an opportunity to use an explicit stack.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¾ç¤ºäº†å¦‚ä½•å°†p(N)å‡½æ•°åº”ç”¨äºç›®å½•æ ‘ä¸­çš„æ¯ä¸ªå…ƒç´ ã€‚å½“å…ƒç´ æ˜¯æ–‡ä»¶ï¼Œe âˆˆğ”½ï¼Œæ—¶ï¼Œæˆ‘ä»¬å¯ä»¥è®¡ç®—â€œæ‰“å°â€çš„å®ä¾‹ã€‚å½“å…ƒç´ æ˜¯ç›®å½•ï¼Œe âˆˆğ”»ï¼Œæ—¶ï¼Œæˆ‘ä»¬éœ€è¦é€’å½’åœ°åº”ç”¨p(N)å‡½æ•°åˆ°ç›®å½•ä¸­çš„æ¯ä¸ªæ¡ç›®ï¼Œe[x]ã€‚è™½ç„¶ç›®å½•æ ‘å¯èƒ½ä¸å¤Ÿæ·±ä»¥æ‰“ç ´Pythonçš„æ ˆå¤§å°é™åˆ¶ï¼Œä½†è¿™ç§ç®—æ³•æ­ç¤ºäº†å°¾è°ƒç”¨ä¼˜åŒ–çš„æ›¿ä»£æ–¹æ¡ˆã€‚è¿™æ˜¯ä¸€ä¸ªä½¿ç”¨æ˜¾å¼æ ˆçš„æœºä¼šã€‚
- en: The `collections.deque` class is a marvelous way to build stacks and queues.
    The name comes from â€double-ended queue,â€ sometimes spelled dequeue. The data
    structure can be used as either a last-in-first-out (LIFO) stack or a first-in-first-out
    (FIFO). In this example, we use the `append()` and `pop()` methods, which enforce
    LIFO stack behavior. While this is much like a list, there are some optimizations
    in the `deque` implementation that can make it slightly faster than the generic
    list.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`collections.deque`ç±»æ˜¯æ„å»ºæ ˆå’Œé˜Ÿåˆ—çš„å¥‡å¦™æ–¹å¼ã€‚è¿™ä¸ªåå­—æ¥è‡ªâ€œåŒç«¯é˜Ÿåˆ—â€ï¼Œæœ‰æ—¶æ‹¼å†™ä¸ºdequeueã€‚è¿™ç§æ•°æ®ç»“æ„å¯ä»¥ç”¨ä½œåè¿›å…ˆå‡ºï¼ˆLIFOï¼‰æ ˆæˆ–å…ˆè¿›å…ˆå‡ºï¼ˆFIFOï¼‰ã€‚åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨`append()`å’Œ`pop()`æ–¹æ³•ï¼Œè¿™äº›æ–¹æ³•å¼ºåˆ¶æ‰§è¡ŒLIFOæ ˆè¡Œä¸ºã€‚è™½ç„¶è¿™å¾ˆåƒåˆ—è¡¨ï¼Œä½†åœ¨`deque`å®ç°ä¸­è¿˜æœ‰ä¸€äº›ä¼˜åŒ–ï¼Œå¯ä»¥ä½¿å…¶æ¯”é€šç”¨åˆ—è¡¨ç•¥å¿«ã€‚'
- en: 'Using a stack data structure lets us work with a hierarchy of indefinite size
    without running into Pythonâ€™s internal stack depth limitation and raising `RecursionError`
    exceptions. The following function will traverse a file hierarchy looking at Python
    source files (with a suffix of `.py`):'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨æ ˆæ•°æ®ç»“æ„è®©æˆ‘ä»¬èƒ½å¤Ÿåœ¨ä¸é‡åˆ°Pythonå†…éƒ¨æ ˆæ·±åº¦é™åˆ¶å¹¶å¼•å‘`RecursionError`å¼‚å¸¸çš„æƒ…å†µä¸‹å¤„ç†ä¸å®šå¤§å°çš„å±‚æ¬¡ç»“æ„ã€‚ä»¥ä¸‹å‡½æ•°å°†éå†æ–‡ä»¶å±‚æ¬¡ç»“æ„ï¼ŒæŸ¥çœ‹Pythonæºæ–‡ä»¶ï¼ˆåç¼€ä¸º`.py`ï¼‰ï¼š
- en: '[PRE15]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We seeded the stack of pending tasks with the initial directory. The essential
    algorithm is to unstack a directory and visit each entry in the directory. For
    entries that are files with the proper suffix, the processing is performed: counting
    the occurrences of â€printâ€. For entries that are directories, the directory is
    put into the stack as a pending task. Note that directories with a leading dot
    in their name need to be ignored. For the code in this book, those directories
    include caches used by tools like mypy, pytest, and tox. We want to skip over
    those cache directories.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ç”¨åˆå§‹ç›®å½•å¡«å……äº†å¾…å¤„ç†ä»»åŠ¡çš„æ ˆã€‚åŸºæœ¬ç®—æ³•æ˜¯ä»æ ˆä¸­å¼¹å‡ºç›®å½•å¹¶è®¿é—®ç›®å½•ä¸­çš„æ¯ä¸ªæ¡ç›®ã€‚å¯¹äºå…·æœ‰æ­£ç¡®åç¼€çš„æ–‡ä»¶æ¡ç›®ï¼Œæ‰§è¡Œå¤„ç†ï¼šè®¡ç®—â€œæ‰“å°â€çš„å‡ºç°æ¬¡æ•°ã€‚å¯¹äºç›®å½•æ¡ç›®ï¼Œå°†ç›®å½•ä½œä¸ºå¾…å¤„ç†ä»»åŠ¡æ”¾å…¥æ ˆä¸­ã€‚æ³¨æ„ï¼Œåç§°ä¸­å¸¦æœ‰ç‚¹çš„ç›®å½•éœ€è¦è¢«å¿½ç•¥ã€‚å¯¹äºæœ¬ä¹¦ä¸­çš„ä»£ç ï¼Œè¿™äº›ç›®å½•åŒ…æ‹¬mypyã€pytestå’Œtoxç­‰å·¥å…·ä½¿ç”¨çš„ç¼“å­˜ã€‚æˆ‘ä»¬å¸Œæœ›è·³è¿‡è¿™äº›ç¼“å­˜ç›®å½•ã€‚
- en: The processing performed on each file is part of the `all_print()` function.
    This can be refactored as a separate function thatâ€™s applied to each node as part
    of a reduction. Rewriting the `all_print()` function to be a proper higher-order
    function is left as an exercise for the reader.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹æ¯ä¸ªæ–‡ä»¶æ‰§è¡Œçš„å¤„ç†æ˜¯`all_print()`å‡½æ•°çš„ä¸€éƒ¨åˆ†ã€‚è¿™å¯ä»¥é‡æ„ä¸ºä¸€ä¸ªå•ç‹¬çš„å‡½æ•°ï¼Œä½œä¸ºå‡å°‘çš„ä¸€éƒ¨åˆ†åº”ç”¨äºæ¯ä¸ªèŠ‚ç‚¹ã€‚å°†`all_print()`å‡½æ•°é‡å†™ä¸ºé€‚å½“çš„æ›´é«˜é˜¶å‡½æ•°ä½œä¸ºç»ƒä¹ ç•™ç»™è¯»è€…ã€‚
- en: The idea here is we have two strategies for transforming a formal recursion
    into a usefully optimized function. We can reframe the recursion into an iteration,
    or we can introduce an explicit stack.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œçš„æƒ³æ³•æ˜¯æˆ‘ä»¬æœ‰ä¸¤ç§å°†å½¢å¼åŒ–é€’å½’è½¬æ¢ä¸ºæœ‰ç”¨ä¼˜åŒ–å‡½æ•°çš„ç­–ç•¥ã€‚æˆ‘ä»¬å¯ä»¥å°†é€’å½’é‡æ„æˆè¿­ä»£ï¼Œæˆ–è€…æˆ‘ä»¬å¯ä»¥å¼•å…¥ä¸€ä¸ªæ˜¾å¼çš„æ ˆã€‚
- en: In the next section, we will apply the idea of a reduction (and the associated
    tail-call optimizations) to creating groups of items and computing a reduction
    for the groups.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ä¸‹ä¸€èŠ‚ä¸­ï¼Œæˆ‘ä»¬å°†åº”ç”¨å‡å°‘ï¼ˆä»¥åŠç›¸å…³çš„å°¾è°ƒç”¨ä¼˜åŒ–ï¼‰çš„æ¦‚å¿µæ¥åˆ›å»ºé¡¹ç›®ç»„å¹¶è®¡ç®—ç»„çš„å‡å°‘ã€‚
- en: 6.3 Group-by reduction from many items to fewer
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3 ä»å¤šä¸ªé¡¹ç›®åˆ°è¾ƒå°‘é¡¹ç›®çš„åˆ†ç»„å‡å°‘
- en: The idea of a reduction can apply in many ways. Weâ€™ve looked at the essential
    recursive definition of a reduction that produces a single value from a collection
    of values. This leads us to optimizing the recursion so we have the ability to
    compute summaries without the overheads of a naive Pythonic implementation.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: å‡å°‘çš„æƒ³æ³•å¯ä»¥ä»¥å¤šç§æ–¹å¼åº”ç”¨ã€‚æˆ‘ä»¬å·²ç»çœ‹åˆ°äº†å‡å°‘çš„åŸºæœ¬é€’å½’å®šä¹‰ï¼Œå®ƒä»å€¼é›†åˆä¸­ç”Ÿæˆå•ä¸ªå€¼ã€‚è¿™å¯¼è‡´æˆ‘ä»¬ä¼˜åŒ–é€’å½’ï¼Œä»¥ä¾¿æˆ‘ä»¬èƒ½å¤Ÿåœ¨æ²¡æœ‰åŸå§‹Pythonå®ç°å¼€é”€çš„æƒ…å†µä¸‹è®¡ç®—æ‘˜è¦ã€‚
- en: Creating subgroups in Python isnâ€™t difficult, but it can help to understand
    the formalisms that support it. This understanding can help to avoid implementations
    that perform extremely poorly.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨Pythonä¸­åˆ›å»ºå­ç»„å¹¶ä¸å›°éš¾ï¼Œä½†äº†è§£æ”¯æŒå®ƒçš„å½¢å¼åŒ–æ–¹æ³•å¯èƒ½ä¼šæœ‰æ‰€å¸®åŠ©ã€‚è¿™ç§ç†è§£å¯ä»¥å¸®åŠ©é¿å…æ€§èƒ½æå·®çš„å®ç°ã€‚
- en: A very common operation is a reduction that groups values by some key or indicator.
    The raw data is grouped by some columnâ€™s value, and reductions (sometimes called
    aggregate functions) are applied to other columns.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€ä¸ªéå¸¸å¸¸è§çš„æ“ä½œæ˜¯æŒ‰æŸäº›é”®æˆ–æŒ‡æ ‡å¯¹å€¼è¿›è¡Œåˆ†ç»„ã€‚åŸå§‹æ•°æ®æŒ‰æŸäº›åˆ—çš„å€¼è¿›è¡Œåˆ†ç»„ï¼Œå¹¶å°†å‡å°‘ï¼ˆæœ‰æ—¶ç§°ä¸ºèšåˆå‡½æ•°ï¼‰åº”ç”¨äºå…¶ä»–åˆ—ã€‚
- en: In SQL, this is often called the `GROUP``Â BY` clause of the `SELECT` statement.
    The SQL aggregate functions include `SUM`, `COUNT`, `MAX`, and `MIN`, and often
    many more.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨SQLä¸­ï¼Œè¿™é€šå¸¸ç§°ä¸º`SELECT`è¯­å¥çš„`GROUP BY`å­å¥ã€‚SQLèšåˆå‡½æ•°åŒ…æ‹¬`SUM`ã€`COUNT`ã€`MAX`å’Œ`MIN`ï¼Œä»¥åŠè®¸å¤šå…¶ä»–å‡½æ•°ã€‚
- en: Python offers us several ways to group data before computing a reduction of
    the grouped values. Weâ€™ll start by looking at two ways to get simple counts of
    grouped data. Then weâ€™ll look at ways to compute different summaries of grouped
    data.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Pythonä¸ºæˆ‘ä»¬æä¾›äº†å¤šç§åœ¨è®¡ç®—åˆ†ç»„å€¼çš„å‡å°‘ä¹‹å‰å¯¹æ•°æ®è¿›è¡Œåˆ†ç»„çš„æ–¹æ³•ã€‚æˆ‘ä»¬å°†ä»æŸ¥çœ‹è·å–åˆ†ç»„æ•°æ®çš„ç®€å•è®¡æ•°æ–¹æ³•å¼€å§‹ã€‚ç„¶åæˆ‘ä»¬å°†æ¢è®¨è®¡ç®—åˆ†ç»„æ•°æ®ä¸åŒæ‘˜è¦çš„æ–¹æ³•ã€‚
- en: 'Weâ€™ll use the trip data that we computed in [ChapterÂ 4](Chapter_04.xhtml#x1-740004),
    [Working with Collections](Chapter_04.xhtml#x1-740004). This data started as a
    sequence of latitude-longitude waypoints. We restructured it to create legs represented
    by three-tuples of start, end, and distance for each leg. The data looks as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å°†ä½¿ç”¨æˆ‘ä»¬åœ¨[ç¬¬4ç« ](Chapter_04.xhtml#x1-740004)ï¼Œ[å¤„ç†é›†åˆ](Chapter_04.xhtml#x1-740004)ä¸­è®¡ç®—çš„ä¸‰æ¬¡æ•°æ®ã€‚è¿™äº›æ•°æ®æœ€åˆæ˜¯ä¸€ç³»åˆ—çº¬åº¦-ç»åº¦èˆªç‚¹ã€‚æˆ‘ä»¬å°†å…¶é‡æ„ä¸ºè¡¨ç¤ºæ¯æ¡è…¿çš„èµ·ç‚¹ã€ç»ˆç‚¹å’Œè·ç¦»çš„ä¸‰å…ƒç»„ã€‚æ•°æ®çœ‹èµ·æ¥å¦‚ä¸‹ï¼š
- en: '[PRE16]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Weâ€™d like to know the most common distance. Since the data is real-valued, and
    continuous, each distance is a unique value. We need to constrain these values
    from the continuous domain to a discrete set of distances. For example, quantizing
    each leg to the nearest multiple of five nautical miles. This creates bands of
    0 to 5 miles, over 5 to 10 miles, etc. Once weâ€™ve created discrete integer values,
    we can count the number of legs in each of these bands.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬æƒ³çŸ¥é“æœ€å¸¸è§çš„è·ç¦»ã€‚ç”±äºæ•°æ®æ˜¯å®å€¼ä¸”è¿ç»­çš„ï¼Œæ¯ä¸ªè·ç¦»éƒ½æ˜¯ä¸€ä¸ªç‹¬ç‰¹çš„å€¼ã€‚æˆ‘ä»¬éœ€è¦å°†è¿™äº›å€¼ä»è¿ç»­åŸŸçº¦æŸåˆ°ä¸€ç»„ç¦»æ•£çš„è·ç¦»ã€‚ä¾‹å¦‚ï¼Œå°†æ¯æ¡è…¿é‡åŒ–åˆ°æœ€æ¥è¿‘çš„äº”æµ·é‡Œå€æ•°ã€‚è¿™åˆ›å»ºäº†ä»0åˆ°5è‹±é‡Œï¼Œè¶…è¿‡5åˆ°10è‹±é‡Œç­‰çš„æ³¢æ®µã€‚ä¸€æ—¦æˆ‘ä»¬åˆ›å»ºäº†ç¦»æ•£çš„æ•´æ•°å€¼ï¼Œæˆ‘ä»¬å°±å¯ä»¥è®¡ç®—æ¯ä¸ªæ³¢æ®µä¸­çš„è…¿çš„æ•°é‡ã€‚
- en: 'These quantized distances can be produced with a generator expression:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™äº›é‡å­åŒ–çš„è·ç¦»å¯ä»¥é€šè¿‡ç”Ÿæˆå™¨è¡¨è¾¾å¼æ¥ç”Ÿæˆï¼š
- en: '[PRE17]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This will divide each distance by 5â€”discarding any fractionsâ€”then multiply the
    truncated result by 5 to compute a number that represents the distance rounded
    down to the nearest 5 nautical miles.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å°†æŠŠæ¯ä¸ªè·ç¦»é™¤ä»¥5â€”â€”ä¸¢å¼ƒä»»ä½•åˆ†æ•°â€”â€”ç„¶åå°†æˆªæ–­çš„ç»“æœä¹˜ä»¥5æ¥è®¡ç®—ä¸€ä¸ªè¡¨ç¤ºè·ç¦»å‘ä¸‹èˆå…¥åˆ°æœ€æ¥è¿‘5æµ·é‡Œçš„æ•°å­—ã€‚
- en: 'We donâ€™t use the values assigned to the `start` and `stop` variables. Itâ€™s
    common practice to assign these values to the `_` variable. This can lead to some
    confusion because this can obscure the structure of the triple. It would look
    like this:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬æ²¡æœ‰ä½¿ç”¨åˆ†é…ç»™ `start` å’Œ `stop` å˜é‡çš„å€¼ã€‚å°†å®ƒä»¬åˆ†é…ç»™ `_` å˜é‡æ˜¯ä¸€ç§å¸¸è§çš„åšæ³•ã€‚è¿™å¯èƒ½ä¼šå¯¼è‡´ä¸€äº›æ··æ·†ï¼Œå› ä¸ºè¿™å¯èƒ½ä¼šæ©ç›–ä¸‰å…ƒç»„çš„ç»“æ„ã€‚å®ƒçœ‹èµ·æ¥ä¼šæ˜¯è¿™æ ·ï¼š
- en: '[PRE18]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This approach can be helpful for removing some visual clutter.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ç§æ–¹æ³•å¯¹äºå»é™¤ä¸€äº›è§†è§‰æ‚ä¹±æ˜¯æœ‰å¸®åŠ©çš„ã€‚
- en: 6.3.1 Building a mapping with Counter
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.3.1 ä½¿ç”¨ Counter æ„å»ºæ˜ å°„
- en: 'A mapping like the `collections.Counter` class is a great optimization for
    doing reductions that create counts (or totals) grouped by some value in the collection.
    The following expression creates a mapping from distance to frequency:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ç±»ä¼¼äº `collections.Counter` ç±»çš„æ˜ å°„æ˜¯è¿›è¡ŒæŒ‰é›†åˆä¸­æŸäº›å€¼åˆ›å»ºè®¡æ•°çš„å½’çº¦çš„ä¼˜åŒ–ã€‚ä»¥ä¸‹è¡¨è¾¾å¼åˆ›å»ºäº†ä¸€ä¸ªä»è·ç¦»åˆ°é¢‘ç‡çš„æ˜ å°„ï¼š
- en: '[PRE19]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The resulting `summary` object is stateful; it can be updated. The expression
    to create the groups, `Counter()`, looks like a function, making it a good fit
    for a design based on functional programming ideas.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: ç”Ÿæˆçš„ `summary` å¯¹è±¡æ˜¯çŠ¶æ€çš„ï¼›å®ƒå¯ä»¥è¢«æ›´æ–°ã€‚åˆ›å»ºç»„çš„è¡¨è¾¾å¼ `Counter()` çœ‹èµ·æ¥åƒä¸€ä¸ªå‡½æ•°ï¼Œè¿™ä½¿å¾—å®ƒéå¸¸é€‚åˆåŸºäºå‡½æ•°ç¼–ç¨‹æ€æƒ³çš„æ¶æ„ã€‚
- en: 'If we print the `summary.most_common()` value, weâ€™ll see the following results:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘ä»¬æ‰“å° `summary.most_common()` çš„å€¼ï¼Œæˆ‘ä»¬å°†çœ‹åˆ°ä»¥ä¸‹ç»“æœï¼š
- en: '[PRE20]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The most common distance was about 30 nautical miles. We can also apply functions
    like `min()` and `max()` to find the shortest recorded and longest legs as well.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: æœ€å¸¸è§çš„è·ç¦»å¤§çº¦æ˜¯ 30 æµ·é‡Œã€‚æˆ‘ä»¬è¿˜å¯ä»¥åº”ç”¨ `min()` å’Œ `max()` ç­‰å‡½æ•°æ¥æ‰¾åˆ°è®°å½•çš„æœ€çŸ­å’Œæœ€é•¿çš„è…¿ã€‚
- en: 'Note that your output may vary slightly from whatâ€™s shown. The results of the
    `most_common()` function are in order of frequency; equal-frequency bins may be
    in any order. These five lengths may not always be in the order shown:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œä½ çš„è¾“å‡ºå¯èƒ½ä¸æ˜¾ç¤ºçš„ç•¥æœ‰ä¸åŒã€‚`most_common()` å‡½æ•°çš„ç»“æœæŒ‰é¢‘ç‡æ’åºï¼›é¢‘ç‡ç›¸ç­‰çš„æ¡¶å¯èƒ½ä»¥ä»»ä½•é¡ºåºæ’åˆ—ã€‚è¿™äº”ä¸ªé•¿åº¦ä¸ä¸€å®šæ€»æ˜¯æŒ‰æ˜¾ç¤ºçš„é¡ºåºæ’åˆ—ï¼š
- en: '[PRE21]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This slight variability makes testing with the doctest tool a little bit more
    complex. One helpful trick for testing with counters is to use a dictionary to
    validate the results in general; the comparison between actual and expected no
    longer relies on the vagaries of internal hash computations.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ç§è½»å¾®çš„å˜åŒ–ä½¿å¾—ä½¿ç”¨ doctest å·¥å…·è¿›è¡Œæµ‹è¯•ç¨å¾®å¤æ‚ä¸€äº›ã€‚å¯¹äºè®¡æ•°å™¨æµ‹è¯•çš„ä¸€ä¸ªæœ‰ç”¨æŠ€å·§æ˜¯ä½¿ç”¨å­—å…¸æ¥éªŒè¯ç»“æœï¼›å®é™…å€¼ä¸é¢„æœŸå€¼ä¹‹é—´çš„æ¯”è¾ƒä¸å†ä¾èµ–äºå†…éƒ¨å“ˆå¸Œè®¡ç®—çš„éšæ„æ€§ã€‚
- en: 6.3.2 Building a mapping by sorting
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.3.2 é€šè¿‡æ’åºæ„å»ºæ˜ å°„
- en: An alternative to `Counter` is to sort the original collection, and then use
    a recursive loop to identify when each group begins. This involves materializing
    the raw data, performing a sort that couldâ€”at worstâ€”do O(nlog n) operations, and
    then doing a reduction to get the sums or counts for each key.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`Counter` çš„ä¸€ä¸ªæ›¿ä»£æ–¹æ¡ˆæ˜¯å¯¹åŸå§‹é›†åˆè¿›è¡Œæ’åºï¼Œç„¶åä½¿ç”¨é€’å½’å¾ªç¯æ¥è¯†åˆ«æ¯ä¸ªç»„å¼€å§‹çš„ä½ç½®ã€‚è¿™æ¶‰åŠåˆ°å°†åŸå§‹æ•°æ®å®ä½“åŒ–ï¼Œæ‰§è¡Œä¸€ä¸ªå¯èƒ½æœ€åæƒ…å†µä¸‹è¿›è¡Œ
    O(nlog n) æ“ä½œçš„æ’åºï¼Œç„¶åè¿›è¡Œå½’çº¦ä»¥è·å–æ¯ä¸ªé”®çš„æ±‚å’Œæˆ–è®¡æ•°ã€‚'
- en: In order to work in a general way with Python objects that can be sorted, we
    need to define the protocol required for sorting. Weâ€™ll call the protocol `SupportsRichComparisonT`
    because we can sort any kinds of objects that implement the rich comparison operators,
    `<` and `>`. This isnâ€™t a particular class of objects; itâ€™s a protocol that any
    number of classes might implement. We formalize the idea of a protocol that classes
    must support using the `typing.Protocol` type definition. It could be also be
    called an interface that a class must implement. Pythonâ€™s flexibility stems from
    having a fairly large number of protocols that many different classes support.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºäº†ä»¥é€šç”¨æ–¹å¼ä¸å¯ä»¥æ’åºçš„ Python å¯¹è±¡ä¸€èµ·å·¥ä½œï¼Œæˆ‘ä»¬éœ€è¦å®šä¹‰æ’åºæ‰€éœ€çš„åè®®ã€‚æˆ‘ä»¬å°†æ­¤åè®®ç§°ä¸º `SupportsRichComparisonT`ï¼Œå› ä¸ºæˆ‘ä»¬å¯ä»¥æ’åºä»»ä½•å®ç°äº†ä¸°å¯Œæ¯”è¾ƒè¿ç®—ç¬¦
    `<` å’Œ `>` çš„å¯¹è±¡ã€‚è¿™ä¸æ˜¯ä¸€ä¸ªç‰¹å®šçš„å¯¹è±¡ç±»ï¼›è¿™æ˜¯ä¸€ä¸ªä»»ä½•æ•°é‡çš„ç±»éƒ½å¯èƒ½å®ç°çš„åè®®ã€‚æˆ‘ä»¬ä½¿ç”¨ `typing.Protocol` ç±»å‹å®šä¹‰æ­£å¼åŒ–ç±»å¿…é¡»æ”¯æŒçš„åè®®æ¦‚å¿µã€‚å®ƒä¹Ÿå¯ä»¥è¢«ç§°ä¸ºä¸€ä¸ªç±»å¿…é¡»å®ç°çš„æ¥å£ã€‚Python
    çš„çµæ´»æ€§æºäºæ‹¥æœ‰ç›¸å½“å¤šçš„åè®®ï¼Œè®¸å¤šä¸åŒçš„ç±»éƒ½æ”¯æŒè¿™äº›åè®®ã€‚
- en: 'The following is a common algorithm for creating groups from sorted data:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: ä»¥ä¸‹æ˜¯ä»æ’åºæ•°æ®åˆ›å»ºç»„çš„ä¸€ä¸ªå¸¸è§ç®—æ³•ï¼š
- en: '[PRE22]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The internal `group()` function steps through the sorted sequence of legs.
    If a given item key has already been seenâ€”it matches the value in `previous`â€”then
    the `counter` variable is incremented. If a given item does not match the previous
    value, then thereâ€™s been a change in value: emit the previous value and the count,
    and begin a new accumulation of counts for the new value.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: å†…éƒ¨ `group()` å‡½æ•°éå†è…¿çš„æ’åºåºåˆ—ã€‚å¦‚æœç»™å®šçš„é¡¹ç›®é”®å·²ç»å‡ºç°è¿‡â€”â€”å®ƒä¸ `previous` ä¸­çš„å€¼åŒ¹é…â€”â€”åˆ™ `counter` å˜é‡é€’å¢ã€‚å¦‚æœç»™å®šçš„é¡¹ç›®ä¸åŒ¹é…å‰ä¸€ä¸ªå€¼ï¼Œé‚£ä¹ˆå€¼å‘ç”Ÿäº†å˜åŒ–ï¼šè¾“å‡ºå‰ä¸€ä¸ªå€¼å’Œè®¡æ•°ï¼Œå¹¶å¼€å§‹ä¸ºæ–°å€¼ç§¯ç´¯è®¡æ•°ã€‚
- en: The definition of `group()` provides two important type hints. The source data
    is an iterable over some type, shown with the type variable `SupportsRichComparisonT`.
    In this specific case, itâ€™s pretty clear that the values in use will be of type
    `int`; however, the algorithm will work for any Python type. The resulting iterable
    from the `group()` function will preserve the type of the source data, and this
    is made explicit by using the same type variable, `SupportsRichComparisonT`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`group()` å‡½æ•°çš„å®šä¹‰æä¾›äº†ä¸¤ä¸ªé‡è¦çš„ç±»å‹æç¤ºã€‚æºæ•°æ®æ˜¯ä¸€äº›ç±»å‹çš„å¯è¿­ä»£å¯¹è±¡ï¼Œç”¨ç±»å‹å˜é‡ `SupportsRichComparisonT`
    è¡¨ç¤ºã€‚åœ¨è¿™ä¸ªç‰¹å®šçš„æƒ…å†µä¸‹ï¼Œå¾ˆæ˜æ˜¾ï¼Œä½¿ç”¨çš„å€¼å°†æ˜¯ `int` ç±»å‹ï¼›ç„¶è€Œï¼Œç®—æ³•å¯¹ä»»ä½• Python ç±»å‹éƒ½é€‚ç”¨ã€‚`group()` å‡½æ•°çš„ç»“æœå¯è¿­ä»£å¯¹è±¡å°†ä¿ç•™æºæ•°æ®çš„ç±»å‹ï¼Œå¹¶ä¸”é€šè¿‡ä½¿ç”¨ç›¸åŒçš„ç±»å‹å˜é‡
    `SupportsRichComparisonT` æ¥æ˜ç¡®è¿™ä¸€ç‚¹ã€‚'
- en: The final line of the `group_sort()` function creates a dictionary from the
    grouped items. This dictionary will be similar to a `Counter` dictionary. The
    primary difference is that a `Counter()` function will have a `most_common()`
    method function, which a default dictionary lacks.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`group_sort()` å‡½æ•°çš„æœ€åä¸€è¡Œä»åˆ†ç»„é¡¹åˆ›å»ºä¸€ä¸ªå­—å…¸ã€‚è¿™ä¸ªå­—å…¸å°†ä¸ `Counter` å­—å…¸ç±»ä¼¼ã€‚ä¸»è¦åŒºåˆ«æ˜¯ `Counter()` å‡½æ•°å°†æœ‰ä¸€ä¸ª
    `most_common()` æ–¹æ³•å‡½æ•°ï¼Œè€Œé»˜è®¤å­—å…¸æ²¡æœ‰ã€‚'
- en: We can also do this with `itertools.groupby()`. Weâ€™ll look at this function
    closely in [ChapterÂ 8](Chapter_08.xhtml#x1-1700008), [The Itertools Module](Chapter_08.xhtml#x1-1700008).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ä¹Ÿå¯ä»¥ä½¿ç”¨ `itertools.groupby()` æ¥åšè¿™ä»¶äº‹ã€‚æˆ‘ä»¬å°†åœ¨[ç¬¬8ç« ](Chapter_08.xhtml#x1-1700008)ï¼Œ[Itertools
    æ¨¡å—](Chapter_08.xhtml#x1-1700008)ä¸­è¯¦ç»†æ¢è®¨è¿™ä¸ªå‡½æ•°ã€‚
- en: 6.3.3 Grouping or partitioning data by key values
  id: totrans-160
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.3.3 æŒ‰é”®å€¼åˆ†ç»„æˆ–åˆ†åŒºæ•°æ®
- en: There are no limits to the kinds of reductions we might want to apply to grouped
    data. We might have data with a number of independent and dependent variables.
    We can consider partitioning the data by an independent variable and computing
    summaries such as the maximum, minimum, average, and standard deviation of the
    values in each partition.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯èƒ½æƒ³è¦åº”ç”¨äºåˆ†ç»„æ•°æ®çš„å½’çº¦ç±»å‹æ²¡æœ‰é™åˆ¶ã€‚æˆ‘ä»¬å¯èƒ½æœ‰å…·æœ‰å¤šä¸ªç‹¬ç«‹å’Œä¾èµ–å˜é‡çš„æ•°æ®ã€‚æˆ‘ä»¬å¯ä»¥è€ƒè™‘æŒ‰ç‹¬ç«‹å˜é‡åˆ†åŒºæ•°æ®ï¼Œå¹¶è®¡ç®—æ¯ä¸ªåˆ†åŒºä¸­å€¼çš„æœ€å¤§å€¼ã€æœ€å°å€¼ã€å¹³å‡å€¼å’Œæ ‡å‡†å·®ç­‰æ‘˜è¦ã€‚
- en: The essential trick to doing more sophisticated reductions is to collect all
    of the data values into each group. The `Counter()` function merely collects counts
    of identical items. For deeper analysis, we want to create sequences of the original
    members of the group.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: è¿›è¡Œæ›´å¤æ‚å½’çº¦çš„åŸºæœ¬æŠ€å·§æ˜¯å°†æ‰€æœ‰æ•°æ®å€¼æ”¶é›†åˆ°æ¯ä¸ªç»„ä¸­ã€‚`Counter()` å‡½æ•°ä»…æ”¶é›†ç›¸åŒé¡¹çš„è®¡æ•°ã€‚å¯¹äºæ›´æ·±å…¥çš„åˆ†æï¼Œæˆ‘ä»¬å¸Œæœ›åˆ›å»ºåŒ…å«ç»„åŸå§‹æˆå‘˜çš„åºåˆ—ã€‚
- en: Looking back at our trip data, each five-mile bin could contain the entire collection
    of legs of that distance, not merely a count of the legs. We can consider the
    partitioning as a recursion or as a stateful application of `defaultdict(list)`
    objects. Weâ€™ll look at the recursive definition of a `groupby()` function, since
    itâ€™s easy to design.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: å›é¡¾æˆ‘ä»¬çš„è¡Œç¨‹æ•°æ®ï¼Œæ¯ä¸ªäº”è‹±é‡ŒåŒºé—´å¯èƒ½åŒ…å«è¯¥è·ç¦»çš„æ‰€æœ‰è…¿çš„æ•´ä¸ªé›†åˆï¼Œè€Œä¸ä»…ä»…æ˜¯è…¿çš„æ•°é‡ã€‚æˆ‘ä»¬å¯ä»¥å°†åˆ†åŒºè§†ä¸ºé€’å½’æˆ–ä½œä¸º `defaultdict(list)`
    å¯¹è±¡çš„çŠ¶æ€åŒ–åº”ç”¨ã€‚æˆ‘ä»¬å°†æ¢è®¨ `groupby()` å‡½æ•°çš„é€’å½’å®šä¹‰ï¼Œå› ä¸ºå®ƒå¾ˆå®¹æ˜“è®¾è®¡ã€‚
- en: Clearly, the `groupby(C,``Â key)` computation for an empty collection, `[]`,
    is the empty dictionary, `dict()`. Or, more usefully, the empty `defaultdict(list)`
    object.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: æ˜¾ç„¶ï¼Œå¯¹äºç©ºé›†åˆ `[]` çš„ `groupby(C,` `key)` è®¡ç®—ç»“æœæ˜¯ç©ºå­—å…¸ `dict()`ã€‚æˆ–è€…æ›´æœ‰ç”¨ï¼Œç©º `defaultdict(list)`
    å¯¹è±¡ã€‚
- en: 'For a non-empty collection, we need to work with item `C[0]`, the head, and
    recursively process sequence `C[1:]`, the tail. We can use slice expressions,
    or we can use the `head,` `*tail``Â =``Â C` statement to do this parsing of the
    collection, as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äºéç©ºé›†åˆï¼Œæˆ‘ä»¬éœ€è¦å¤„ç†é¡¹ `C[0]`ï¼Œå³å¤´éƒ¨ï¼Œå¹¶é€’å½’åœ°å¤„ç†åºåˆ— `C[1:]`ï¼Œå³å°¾éƒ¨ã€‚æˆ‘ä»¬å¯ä»¥ä½¿ç”¨åˆ‡ç‰‡è¡¨è¾¾å¼ï¼Œæˆ–è€…æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ `head,`
    `*tail``Â =``Â C` è¯­å¥æ¥è§£æè¿™ä¸ªé›†åˆï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š
- en: '[PRE23]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If we have a `defaultdict` object named `groups`, we need to use the expression
    `groups[key(head)].append(head)` to include the head element in the `groups` dictionary.
    After this, we need to evaluate the `groupby(tail,``Â key)` expression to process
    the remaining elements.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘ä»¬æœ‰ä¸€ä¸ªåä¸º `groups` çš„ `defaultdict` å¯¹è±¡ï¼Œæˆ‘ä»¬éœ€è¦ä½¿ç”¨è¡¨è¾¾å¼ `groups[key(head)].append(head)`
    å°†å¤´éƒ¨å…ƒç´ åŒ…å«åœ¨ `groups` å­—å…¸ä¸­ã€‚ä¹‹åï¼Œæˆ‘ä»¬éœ€è¦è¯„ä¼° `groupby(tail, key)` è¡¨è¾¾å¼æ¥å¤„ç†å‰©ä½™çš„å…ƒç´ ã€‚
- en: 'We can create a function as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯ä»¥åˆ›å»ºä¸€ä¸ªå¦‚ä¸‹æ‰€ç¤ºçš„å‡½æ•°ï¼š
- en: '[PRE24]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The interior function `group_into()` handles the essential recursive definition.
    An empty value for `collection` returns the provided dictionary, `group_dict`.
    A non-empty collection is partitioned into a head and tail. The head is used to
    update the `group_dict` dictionary. The tail is then used, recursively, to update
    the dictionary with all remaining elements.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: å†…éƒ¨å‡½æ•° `group_into()` å¤„ç†åŸºæœ¬çš„é€’å½’å®šä¹‰ã€‚å¯¹äº `collection` çš„ç©ºå€¼è¿”å›æä¾›çš„å­—å…¸ `group_dict`ã€‚éç©ºé›†åˆè¢«åˆ†å‰²æˆå¤´éƒ¨å’Œå°¾éƒ¨ã€‚å¤´éƒ¨ç”¨äºæ›´æ–°
    `group_dict` å­—å…¸ã€‚ç„¶åé€’å½’åœ°ä½¿ç”¨å°¾éƒ¨æ›´æ–°å­—å…¸ä¸­çš„æ‰€æœ‰å‰©ä½™å…ƒç´ ã€‚
- en: The type hints make an explicit distinction between the type of the source objects
    `SeqItemT` and the type of the key `ItemKeyT`. The function provided as the `key`
    parameter must be a callable that returns a value of the key type `ItemKeyT`,
    given an object of the source type `SeqItemT`. In many of the examples, a function
    to extract the distance from a `Leg` object will be be shown. This is a `Callable[[SeqItemT],``Â ItemKeyT]`
    where the source type `SeqItemT` is the `Leg` object and the key type `ItemKeyT`
    is the float value.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: ç±»å‹æç¤ºåœ¨æºå¯¹è±¡ `SeqItemT` çš„ç±»å‹å’Œé”® `ItemKeyT` çš„ç±»å‹ä¹‹é—´åšå‡ºäº†æ˜ç¡®çš„åŒºåˆ†ã€‚ä½œä¸º `key` å‚æ•°æä¾›çš„å‡½æ•°å¿…é¡»æ˜¯ä¸€ä¸ªå¯è°ƒç”¨çš„å‡½æ•°ï¼Œå®ƒè¿”å›ä¸€ä¸ªé”®ç±»å‹
    `ItemKeyT` çš„å€¼ï¼Œç»™å®šä¸€ä¸ªæºç±»å‹ `SeqItemT` çš„å¯¹è±¡ã€‚åœ¨è®¸å¤šç¤ºä¾‹ä¸­ï¼Œå°†å±•ç¤ºä¸€ä¸ªä» `Leg` å¯¹è±¡ä¸­æå–è·ç¦»çš„å‡½æ•°ã€‚è¿™æ˜¯ä¸€ä¸ª `Callable[[SeqItemT],
    ItemKeyT]`ï¼Œå…¶ä¸­æºç±»å‹ `SeqItemT` æ˜¯ `Leg` å¯¹è±¡ï¼Œé”®ç±»å‹ `ItemKeyT` æ˜¯æµ®ç‚¹å€¼ã€‚
- en: '`bound=Hashable` is an additional constraint. This defines an â€upper boundâ€
    on the possible types, alerting mypy that any type that could be assigned to this
    type variable must implement the protocol for `Hashable`. The essential, immutable
    Python types of numbers, strings, and tuples all meet this bound. A mutable object
    like a dictionary, set, or list, will not meet the upper bound, leading to warnings
    from mypy.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`bound=Hashable` æ˜¯ä¸€ä¸ªé¢å¤–çš„çº¦æŸã€‚è¿™å®šä¹‰äº†å¯èƒ½ç±»å‹çš„â€œä¸Šé™â€ï¼Œå¹¶æé†’mypyä»»ä½•å¯ä»¥åˆ†é…ç»™æ­¤ç±»å‹å˜é‡çš„ç±»å‹éƒ½å¿…é¡»å®ç° `Hashable`
    åè®®ã€‚åŸºæœ¬ã€ä¸å¯å˜çš„Pythonç±»å‹ï¼Œå¦‚æ•°å­—ã€å­—ç¬¦ä¸²å’Œå…ƒç»„éƒ½æ»¡è¶³è¿™ä¸ªé™åˆ¶ã€‚åƒå­—å…¸ã€é›†åˆæˆ–åˆ—è¡¨è¿™æ ·çš„å¯å˜å¯¹è±¡å°†ä¸ä¼šæ»¡è¶³ä¸Šé™ï¼Œä»è€Œå¯¼è‡´mypyå‘å‡ºè­¦å‘Šã€‚'
- en: 'We canâ€™t easily use Pythonâ€™s default values to collapse this into a single
    function. We explicitly cannot use the following incorrect command snippet:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ä¸èƒ½è½»æ˜“ä½¿ç”¨Pythonçš„é»˜è®¤å€¼å°†æ­¤åˆå¹¶ä¸ºä¸€ä¸ªå•ä¸€å‡½æ•°ã€‚æˆ‘ä»¬æ˜ç¡®ä¸èƒ½ä½¿ç”¨ä»¥ä¸‹é”™è¯¯çš„å‘½ä»¤ç‰‡æ®µï¼š
- en: '[PRE25]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If we try this, all uses of the `group_by()` function share one common `defaultdict(list)`
    object. This does not work because Python builds the default value just once.
    Mutable objects as default values rarely do what we want. The common practice
    is to provide a `None` value, and use an explicit `if` statement to create each
    unique, empty instance of `defaultdict(list)` as needed. Weâ€™ve shown how to use
    a wrapper function definition to avoid the `if` statement.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘ä»¬å°è¯•è¿™æ ·åšï¼Œ`group_by()` å‡½æ•°çš„æ‰€æœ‰ä½¿ç”¨éƒ½å…±äº«ä¸€ä¸ªå…±åŒçš„ `defaultdict(list)` å¯¹è±¡ã€‚è¿™ä¸èµ·ä½œç”¨ï¼Œå› ä¸ºPythonåªæ„å»ºä¸€æ¬¡é»˜è®¤å€¼ã€‚ä½œä¸ºé»˜è®¤å€¼çš„å¯å˜å¯¹è±¡å¾ˆå°‘èƒ½åšæˆ‘ä»¬æƒ³è¦çš„äº‹æƒ…ã€‚å¸¸è§çš„åšæ³•æ˜¯æä¾›ä¸€ä¸ª
    `None` å€¼ï¼Œå¹¶ä½¿ç”¨æ˜¾å¼çš„ `if` è¯­å¥æ ¹æ®éœ€è¦åˆ›å»ºæ¯ä¸ªå”¯ä¸€çš„ç©º `defaultdict(list)` å®ä¾‹ã€‚æˆ‘ä»¬å·²ç»å±•ç¤ºäº†å¦‚ä½•ä½¿ç”¨åŒ…è£…å‡½æ•°å®šä¹‰æ¥é¿å…
    `if` è¯­å¥ã€‚
- en: 'We can group the data by distance as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯ä»¥å¦‚ä¸‹æŒ‰è·ç¦»å¯¹æ•°æ®è¿›è¡Œåˆ†ç»„ï¼š
- en: '[PRE26]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Weâ€™ve defined a reusable lambda that puts our distances into bins, each of which
    is 5 nautical miles in size. We then grouped the data using the provided lambda.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å®šä¹‰äº†ä¸€ä¸ªå¯é‡ç”¨çš„lambdaï¼Œå°†æˆ‘ä»¬çš„è·ç¦»æ”¾å…¥å¤§å°ä¸º5æµ·é‡Œä¸€ä¸ªçš„ç®±å­ä¸­ã€‚ç„¶åæˆ‘ä»¬ä½¿ç”¨æä¾›çš„lambdaå¯¹æ•°æ®è¿›è¡Œåˆ†ç»„ã€‚
- en: 'We can examine the binned data as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯ä»¥å¦‚ä¸‹æ£€æŸ¥åˆ†ç»„åçš„æ•°æ®ï¼š
- en: '[PRE27]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The following is what the output looks like:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: ä»¥ä¸‹å°±æ˜¯è¾“å‡ºçœ‹èµ·æ¥åƒä»€ä¹ˆï¼š
- en: '[PRE28]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Having looked at a recursive definition, we can turn to looking at making a
    tail-call optimization to build a group-by algorithm using iteration. This will
    work with larger collections of data, because it can exceed the internal stack
    size limitation.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æŸ¥çœ‹é€’å½’å®šä¹‰ä¹‹åï¼Œæˆ‘ä»¬å¯ä»¥è½¬å‘æŸ¥çœ‹å¦‚ä½•é€šè¿‡è¿­ä»£æ¥æ„å»ºä¸€ä¸ªåˆ†ç»„ç®—æ³•çš„å°¾è°ƒç”¨ä¼˜åŒ–ã€‚è¿™å°†é€‚ç”¨äºæ›´å¤§çš„æ•°æ®é›†ï¼Œå› ä¸ºå®ƒå¯ä»¥è¶…è¿‡å†…éƒ¨æ ˆå¤§å°é™åˆ¶ã€‚
- en: Weâ€™ll start with doing tail-call optimization on the `group_into()` function.
    Weâ€™ll rename this to `partition()` because partitioning is another way of looking
    at grouping.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å°†ä»å¯¹ `group_into()` å‡½æ•°è¿›è¡Œå°¾è°ƒç”¨ä¼˜åŒ–å¼€å§‹ã€‚æˆ‘ä»¬å°†å°†å…¶é‡å‘½åä¸º `partition()`ï¼Œå› ä¸ºåˆ†å‰²æ˜¯å¦ä¸€ç§çœ‹å¾…åˆ†ç»„çš„æ–¹å¼ã€‚
- en: 'The `partition()` function can be written as an iteration as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`partition()`å‡½æ•°å¯ä»¥å†™æˆå¦‚ä¸‹è¿­ä»£å½¢å¼ï¼š'
- en: '[PRE29]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: When doing the tail-call optimization, the essential line of the code in the
    imperative version will match the recursive definition. Weâ€™ve put a comment under
    the changed line to emphasize the rewrite is intended to have the same outcome.
    The rest of the structure represents the tail-call optimization weâ€™ve adopted
    as a common way to work around the Python limitations.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿›è¡Œå°¾è°ƒç”¨ä¼˜åŒ–æ—¶ï¼Œå‘½ä»¤å¼ç‰ˆæœ¬ä¸­çš„å…³é”®ä»£ç è¡Œå°†ä¸é€’å½’å®šä¹‰åŒ¹é…ã€‚æˆ‘ä»¬åœ¨æ›´æ”¹çš„è¡Œä¸‹é¢æ·»åŠ äº†æ³¨é‡Šï¼Œä»¥å¼ºè°ƒé‡å†™æ˜¯ä¸ºäº†è¾¾åˆ°ç›¸åŒçš„ç»“æœã€‚å…¶ä½™çš„ç»“æ„ä»£è¡¨äº†ä½œä¸ºç»•è¿‡Pythoné™åˆ¶çš„å¸¸ç”¨æ–¹æ³•æ‰€é‡‡ç”¨çš„å°¾è°ƒç”¨ä¼˜åŒ–ã€‚
- en: The type hints emphasize the distinction between the source type `SeqT` and
    the key type `KeyT`. The source data can be anything, but the keys are limited
    to types that have proper hash values.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: ç±»å‹æç¤ºå¼ºè°ƒäº†æºç±»å‹`SeqT`å’Œé”®ç±»å‹`KeyT`ä¹‹é—´çš„åŒºåˆ«ã€‚æºæ•°æ®å¯ä»¥æ˜¯ä»»ä½•ä¸œè¥¿ï¼Œä½†é”®é™äºå…·æœ‰é€‚å½“å“ˆå¸Œå€¼çš„ç±»å‹ã€‚
- en: 6.3.4 Writing more general group-by reductions
  id: totrans-189
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.3.4 ç¼–å†™æ›´é€šç”¨çš„æŒ‰ç»„å‡å°‘
- en: Once we have partitioned the raw data, we can compute various kinds of reductions
    on the data elements in each partition. We might, for example, want the northernmost
    point for the start of each leg in the distance bins.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€æ—¦æˆ‘ä»¬å¯¹åŸå§‹æ•°æ®è¿›è¡Œåˆ†åŒºï¼Œæˆ‘ä»¬å°±å¯ä»¥å¯¹æ¯ä¸ªåˆ†åŒºä¸­çš„æ•°æ®å…ƒç´ è¿›è¡Œå„ç§ç±»å‹çš„å‡å°‘è®¡ç®—ã€‚ä¾‹å¦‚ï¼Œæˆ‘ä»¬å¯èƒ½æƒ³è¦è·ç¦»binä¸­æ¯ä¸€æ®µçš„åŒ—éƒ¨æœ€è¿œç‚¹ã€‚
- en: 'Weâ€™ll introduce some helper functions to decompose the tuple as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å°†å¼•å…¥ä¸€äº›è¾…åŠ©å‡½æ•°æ¥åˆ†è§£å…ƒç»„ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š
- en: '[PRE30]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Each of these helper functions expects a tuple object to be provided using the
    `*` operator to map each element of the tuple to a separate parameter of the lambda.
    Once the tuple is expanded into the `s`, `e`, and `p` parameters, itâ€™s reasonably
    obvious to return the proper parameter by name. Itâ€™s much clearer than trying
    to interpret the `tuple_arg[2]` value.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™äº›è¾…åŠ©å‡½æ•°ä¸­çš„æ¯ä¸€ä¸ªéƒ½æœŸæœ›æä¾›ä¸€ä¸ªä½¿ç”¨`*`è¿ç®—ç¬¦æä¾›çš„å…ƒç»„å¯¹è±¡ï¼Œå°†å…ƒç»„çš„æ¯ä¸ªå…ƒç´ æ˜ å°„åˆ°lambdaçš„å•ç‹¬å‚æ•°ã€‚ä¸€æ—¦å…ƒç»„å±•å¼€ä¸º`s`ã€`e`å’Œ`p`å‚æ•°ï¼Œé€šè¿‡åç§°è¿”å›é€‚å½“çš„å‚æ•°å°±ç›¸å½“æ˜æ˜¾äº†ã€‚è¿™æ¯”å°è¯•è§£é‡Š`tuple_arg[2]`å€¼è¦æ¸…æ™°å¾—å¤šã€‚
- en: 'The following is how we use these helper functions:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: ä»¥ä¸‹æ˜¯æˆ‘ä»¬å¦‚ä½•ä½¿ç”¨è¿™äº›è¾…åŠ©å‡½æ•°ï¼š
- en: '[PRE31]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Our initial `point` object is a nested three tuple with (0)â€”a starting position,
    (1)â€”the ending position, and (2)â€”the distance. We extracted various fields using
    our helper functions.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬æœ€åˆçš„`point`å¯¹è±¡æ˜¯ä¸€ä¸ªåµŒå¥—çš„ä¸‰å…ƒç»„ï¼ŒåŒ…å«ï¼ˆ0ï¼‰èµ·å§‹ä½ç½®ï¼Œï¼ˆ1ï¼‰ç»“æŸä½ç½®ï¼Œå’Œï¼ˆ2ï¼‰è·ç¦»ã€‚æˆ‘ä»¬ä½¿ç”¨è¾…åŠ©å‡½æ•°æå–äº†å„ç§å­—æ®µã€‚
- en: 'Given these helpers, we can locate the northernmost starting position for the
    legs in each bin:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: ç»™å®šè¿™äº›è¾…åŠ©å‡½æ•°ï¼Œæˆ‘ä»¬å¯ä»¥å®šä½æ¯ä¸ªbinä¸­è·¯æ®µçš„åŒ—éƒ¨æœ€èµ·å§‹ä½ç½®ï¼š
- en: '[PRE32]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The data that we grouped by distance included each leg of the given distance.
    We supplied all of the legs in each bin to the `max()` function. The `key` function
    we provided to the `max()` function extracted just the latitude of the starting
    point of the leg.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬æŒ‰è·ç¦»åˆ†ç»„çš„æ•°æ®åŒ…æ‹¬ç»™å®šè·ç¦»çš„æ¯ä¸€æ®µã€‚æˆ‘ä»¬å°†æ¯ä¸ªbinä¸­çš„æ‰€æœ‰æ®µéƒ½æä¾›ç»™`max()`å‡½æ•°ã€‚æˆ‘ä»¬æä¾›ç»™`max()`å‡½æ•°çš„`key`å‡½æ•°ä»…æå–è·¯æ®µèµ·ç‚¹çš„çº¬åº¦ã€‚
- en: 'This gives us a short list of the northernmost legs of each distance, as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ºæˆ‘ä»¬æä¾›äº†ä¸€ä¸ªåŒ—éƒ¨æœ€è¿œè·¯æ®µçš„ç®€çŸ­åˆ—è¡¨ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š
- en: '[PRE33]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 6.3.5 Writing higher-order reductions
  id: totrans-202
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.3.5 ç¼–å†™é«˜é˜¶å‡å°‘
- en: Weâ€™ll look at an example of a higher-order reduction algorithm here. This will
    introduce a rather complex topic. The simplest kind of reduction develops a single
    value from a collection of values. Python has a number of built-in reductions,
    including `any()`, `all()`, `max()`, `min()`, `sum()`, and `len()`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å°†åœ¨è¿™é‡ŒæŸ¥çœ‹ä¸€ä¸ªé«˜é˜¶å‡å°‘ç®—æ³•çš„ç¤ºä¾‹ã€‚è¿™å°†å¼•å…¥ä¸€ä¸ªç›¸å½“å¤æ‚çš„è¯é¢˜ã€‚æœ€ç®€å•çš„å‡å°‘ç±»å‹æ˜¯ä»å€¼é›†åˆä¸­å‘å±•å‡ºä¸€ä¸ªå•ä¸€å€¼ã€‚Pythonæœ‰å‡ ä¸ªå†…ç½®çš„å‡å°‘ï¼ŒåŒ…æ‹¬`any()`ã€`all()`ã€`max()`ã€`min()`ã€`sum()`å’Œ`len()`ã€‚
- en: 'As we noted in [ChapterÂ 4](Chapter_04.xhtml#x1-740004), [Working with Collections](Chapter_04.xhtml#x1-740004),
    we can do a great deal of statistical calculation if we start with a few reductions
    such as the following:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æˆ‘ä»¬åœ¨[ç¬¬4ç« ](Chapter_04.xhtml#x1-740004)ä¸­æåˆ°çš„[ä½¿ç”¨é›†åˆ](Chapter_04.xhtml#x1-740004)ï¼Œå¦‚æœæˆ‘ä»¬ä»ä»¥ä¸‹å‡ ç§å‡å°‘å¼€å§‹ï¼Œæˆ‘ä»¬å¯ä»¥è¿›è¡Œå¤§é‡çš„ç»Ÿè®¡è®¡ç®—ï¼š
- en: '[PRE34]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This allows us to define mean, standard deviation, normalized values, correction,
    and even least-squares linear regression, building on these base reduction functions.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å…è®¸æˆ‘ä»¬å®šä¹‰å¹³å‡å€¼ã€æ ‡å‡†å·®ã€å½’ä¸€åŒ–å€¼ã€æ ¡æ­£ï¼Œç”šè‡³æœ€å°äºŒä¹˜çº¿æ€§å›å½’ï¼ŒåŸºäºè¿™äº›åŸºç¡€å‡å°‘å‡½æ•°ã€‚
- en: 'The last of our reductions, `sum_x2()`, shows how we can apply existing reductions
    to create higher-order functions. We might change our approach to be more like
    the following:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬æœ€åçš„å‡å°‘`sum_x2()`å±•ç¤ºäº†æˆ‘ä»¬å¦‚ä½•åº”ç”¨ç°æœ‰çš„å‡å°‘æ¥åˆ›å»ºé«˜é˜¶å‡½æ•°ã€‚æˆ‘ä»¬å¯èƒ½ä¼šæ”¹å˜æˆ‘ä»¬çš„æ–¹æ³•ï¼Œä½¿å…¶æ›´æ¥è¿‘ä»¥ä¸‹å†…å®¹ï¼š
- en: '[PRE35]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Weâ€™ve added a function, `function()`, as a parameter; the function can transform
    the data. This overall function, `sum_f()`, computes the sum of the transformed
    values.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬æ·»åŠ äº†ä¸€ä¸ªå‡½æ•°ï¼Œ`function()`ï¼Œä½œä¸ºå‚æ•°ï¼›è¯¥å‡½æ•°å¯ä»¥è½¬æ¢æ•°æ®ã€‚è¿™ä¸ªæ•´ä½“å‡½æ•°ï¼Œ`sum_f()`ï¼Œè®¡ç®—è½¬æ¢å€¼çš„æ€»å’Œã€‚
- en: 'Now we can apply this function in three different ways to compute the three
    essential sums as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œæˆ‘ä»¬å¯ä»¥ä»¥ä¸‰ç§ä¸åŒçš„æ–¹å¼åº”ç”¨æ­¤å‡½æ•°æ¥è®¡ç®—ä¸‰ä¸ªåŸºæœ¬æ±‚å’Œå¦‚ä¸‹ï¼š
- en: '[PRE36]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Weâ€™ve plugged in a small lambda to compute âˆ‘ [xâˆˆX]xâ° = âˆ‘ [xâˆˆX]1, which is the
    count, âˆ‘ [xâˆˆX]xÂ¹ = âˆ‘ [xâˆˆX]x, the sum, and âˆ‘ [xâˆˆX]xÂ², the sum of the squares, which
    we can use to compute standard deviation.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬æ’å…¥äº†ä¸€ä¸ªå°çš„lambdaæ¥è®¡ç®— âˆ‘ [xâˆˆX]xâ° = âˆ‘ [xâˆˆX]1ï¼Œè¿™æ˜¯è®¡æ•°ï¼Œâˆ‘ [xâˆˆX]xÂ¹ = âˆ‘ [xâˆˆX]xï¼Œæ±‚å’Œï¼Œä»¥åŠ âˆ‘ [xâˆˆX]xÂ²ï¼Œå¹³æ–¹å’Œï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨è¿™äº›æ¥è®¡ç®—æ ‡å‡†å·®ã€‚
- en: 'A common extension to this includes a filter to reject raw data that is unknown
    or unsuitable in some way. We might use the following function to reject bad data:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹æ­¤çš„ä¸€ä¸ªå¸¸è§æ‰©å±•åŒ…æ‹¬ä¸€ä¸ªè¿‡æ»¤å™¨æ¥æ‹’ç»æŸäº›æ–¹å¼æœªçŸ¥æˆ–ä¸åˆé€‚çš„åŸå§‹æ•°æ®ã€‚æˆ‘ä»¬å¯èƒ½ä½¿ç”¨ä»¥ä¸‹å‡½æ•°æ¥æ‹’ç»ä¸è‰¯æ•°æ®ï¼š
- en: '[PRE37]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The following function definition for computing a mean will reject `None` values
    in a simple way:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: ä»¥ä¸‹ç”¨äºè®¡ç®—å¹³å‡å€¼çš„å‡½æ•°å®šä¹‰å°†ä»¥ç®€å•çš„æ–¹å¼æ‹’ç»`None`å€¼ï¼š
- en: '[PRE38]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This shows how we can provide two distinct combinations of lambdas to our `sum_filter_f()`
    function. The filter argument is a lambda that rejects `None` values; weâ€™ve called
    it `valid` to emphasize its meaning. The function argument is a lambda that implements
    a count or a sum operation. We can easily add a lambda to compute a sum of squares.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¾ç¤ºäº†æˆ‘ä»¬å¯ä»¥å‘`sum_filter_f()`å‡½æ•°æä¾›ä¸¤ç§ä¸åŒçš„lambdaç»„åˆã€‚è¿‡æ»¤å™¨å‚æ•°æ˜¯ä¸€ä¸ªæ‹’ç»`None`å€¼çš„lambdaï¼›æˆ‘ä»¬å°†å…¶ç§°ä¸º`valid`ä»¥å¼ºè°ƒå…¶å«ä¹‰ã€‚å‡½æ•°å‚æ•°æ˜¯ä¸€ä¸ªå®ç°è®¡æ•°æˆ–æ±‚å’Œæ“ä½œçš„lambdaã€‚æˆ‘ä»¬å¯ä»¥è½»æ¾åœ°æ·»åŠ ä¸€ä¸ªlambdaæ¥è®¡ç®—å¹³æ–¹å’Œã€‚
- en: The reuse of a common `valid` rule assures that the various computations are
    all identical in applying any filters to the source data. This can be combined
    with a user-selected filter criteria to provide a tidy plug-in to compute a number
    of statistics related to a userâ€™s requested subset of the data.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: é‡å¤ä½¿ç”¨ä¸€ä¸ªå¸¸è§çš„`valid`è§„åˆ™ç¡®ä¿åœ¨åº”ç”¨ä»»ä½•è¿‡æ»¤å™¨åˆ°æºæ•°æ®æ—¶ï¼Œå„ç§è®¡ç®—éƒ½æ˜¯ç›¸åŒçš„ã€‚è¿™å¯ä»¥ä¸ç”¨æˆ·é€‰æ‹©çš„è¿‡æ»¤å™¨æ ‡å‡†ç›¸ç»“åˆï¼Œæä¾›ä¸€ä¸ªæ•´æ´çš„æ’ä»¶æ¥è®¡ç®—ä¸ç”¨æˆ·è¯·æ±‚çš„æ•°æ®å­é›†ç›¸å…³çš„å¤šä¸ªç»Ÿè®¡æ•°æ®ã€‚
- en: 6.3.6 Writing file parsers
  id: totrans-219
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.3.6 ç¼–å†™æ–‡ä»¶è§£æå™¨
- en: 'We can often consider a file parser to be a kind of reduction. Many languages
    have two levels of definition: the lower-level tokens in the language and the
    higher-level structures built from those tokens. When looking at an XML file,
    the tags, tag names, and attribute names form this lower-level syntax; the structures
    which are described by XML form a higher-level syntax.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬é€šå¸¸å¯ä»¥å°†æ–‡ä»¶è§£æå™¨è§†ä¸ºä¸€ç§è¿˜åŸã€‚è®¸å¤šè¯­è¨€æœ‰ä¸¤ä¸ªçº§åˆ«çš„å®šä¹‰ï¼šè¯­è¨€ä¸­çš„ä½çº§æ ‡è®°å’Œç”±è¿™äº›æ ‡è®°æ„å»ºçš„é«˜çº§ç»“æ„ã€‚å½“æˆ‘ä»¬æŸ¥çœ‹XMLæ–‡ä»¶æ—¶ï¼Œæ ‡ç­¾ã€æ ‡ç­¾åç§°å’Œå±æ€§åç§°å½¢æˆè¿™ç§ä½çº§è¯­æ³•ï¼›ç”±XMLæè¿°çš„ç»“æ„å½¢æˆä¸€ä¸ªé«˜çº§è¯­æ³•ã€‚
- en: 'The lower-level lexical scanning is a kind of reduction that takes individual
    characters and groups them into tokens. This fits well with Pythonâ€™s generator
    function design pattern. We can often write functions that look as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: ä½çº§è¯æ³•æ‰«ææ˜¯ä¸€ç§å°†å•ä¸ªå­—ç¬¦åˆ†ç»„ä¸ºæ ‡è®°çš„è¿˜åŸè¿‡ç¨‹ã€‚è¿™ä¸Pythonçš„ç”Ÿæˆå™¨å‡½æ•°è®¾è®¡æ¨¡å¼éå¸¸å¥‘åˆã€‚æˆ‘ä»¬ç»å¸¸å¯ä»¥ç¼–å†™å¦‚ä¸‹æ‰€ç¤ºçš„åŠŸèƒ½ï¼š
- en: '[PRE39]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: For well-known file formats, weâ€™ll use existing file parsers. For data in CSV,
    JSON, XML, or TOML format, we donâ€™t need to write file parsers. Most of these
    modules have a `load()` method that produces useful Python objects.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äºä¼—æ‰€å‘¨çŸ¥çš„æ–‡ä»¶æ ¼å¼ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨ç°æœ‰çš„æ–‡ä»¶è§£æå™¨ã€‚å¯¹äºCSVã€JSONã€XMLæˆ–TOMLæ ¼å¼çš„æ•°æ®ï¼Œæˆ‘ä»¬ä¸éœ€è¦ç¼–å†™æ–‡ä»¶è§£æå™¨ã€‚è¿™äº›æ¨¡å—ä¸­çš„å¤§å¤šæ•°éƒ½æœ‰ä¸€ä¸ª`load()`æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ç”Ÿæˆæœ‰ç”¨çš„Pythonå¯¹è±¡ã€‚
- en: In some cases, weâ€™ll need to combine the results of this parsing into higher-level
    objects, useful for our specific application. While the CSV parser provides individual
    rows, these might need to be used to create `NamedTuple` instances, or perhaps
    some other class of immutable Python objects. Our examples of trip data, starting
    in [ChapterÂ 4](Chapter_04.xhtml#x1-740004), [Working with Collections](Chapter_04.xhtml#x1-740004),
    are combined into higher-level objects, legs of a journey, by an algorithm that
    combines waypoints into pairs. When we introduce more complex decision-making,
    we make a transition from restructuring into parsing.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æŸäº›æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬éœ€è¦å°†æ­¤è§£æçš„ç»“æœç»„åˆæˆæ›´é«˜å±‚æ¬¡çš„å¯¹è±¡ï¼Œè¿™äº›å¯¹è±¡å¯¹æˆ‘ä»¬ç‰¹å®šçš„åº”ç”¨æ˜¯æœ‰ç”¨çš„ã€‚è™½ç„¶CSVè§£æå™¨æä¾›å•ä¸ªè¡Œï¼Œä½†è¿™äº›å¯èƒ½éœ€è¦ç”¨äºåˆ›å»º`NamedTuple`å®ä¾‹ï¼Œæˆ–è€…å¯èƒ½æ˜¯å…¶ä»–ä¸å¯å˜Pythonå¯¹è±¡ã€‚æˆ‘ä»¬çš„è¡Œç¨‹æ•°æ®ç¤ºä¾‹ï¼Œä»[ç¬¬4ç« ](Chapter_04.xhtml#x1-740004)
    [ä½¿ç”¨é›†åˆ](Chapter_04.xhtml#x1-740004)å¼€å§‹ï¼Œé€šè¿‡å°†èˆªç‚¹ç»„åˆæˆå¯¹çš„ä¸€ä¸ªç®—æ³•ç»„åˆæˆæ›´é«˜å±‚æ¬¡çš„å¯¹è±¡ï¼Œå³æ—…ç¨‹çš„æ®µè½ã€‚å½“æˆ‘ä»¬å¼•å…¥æ›´å¤æ‚çš„å†³ç­–æ—¶ï¼Œæˆ‘ä»¬å°±ä»é‡æ„è¿‡æ¸¡åˆ°è§£æã€‚
- en: 'In order to provide useful waypoints in the first place, we needed to parse
    a source file. In these examples, the input was a KML file; KML is an XML representation
    of geographic information. The essential features of the parser look similar to
    the following definition:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºäº†é¦–å…ˆæä¾›æœ‰ç”¨çš„èˆªç‚¹ï¼Œæˆ‘ä»¬éœ€è¦è§£ææºæ–‡ä»¶ã€‚åœ¨è¿™äº›ç¤ºä¾‹ä¸­ï¼Œè¾“å…¥æ˜¯ä¸€ä¸ª KML æ–‡ä»¶ï¼›KML æ˜¯åœ°ç†ä¿¡æ¯çš„ XML è¡¨ç¤ºã€‚è§£æå™¨çš„åŸºæœ¬åŠŸèƒ½çœ‹èµ·æ¥ç±»ä¼¼äºä»¥ä¸‹å®šä¹‰ï¼š
- en: '[PRE40]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The bulk of the `row_iter_kml()` function is the XML parsing that allows us
    to use the `doc.findall()` function to iterate through the `<ns0:coordinates>`
    tags in the document. Weâ€™ve used a function named `comma_split()` to parse the
    text of this tag into a three-tuple of values.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`row_iter_kml()` å‡½æ•°çš„ä¸»ä½“æ˜¯ XML è§£æï¼Œè¿™ä½¿å¾—æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ `doc.findall()` å‡½æ•°éå†æ–‡æ¡£ä¸­çš„ `<ns0:coordinates>`
    æ ‡ç­¾ã€‚æˆ‘ä»¬ä½¿ç”¨äº†ä¸€ä¸ªåä¸º `comma_split()` çš„å‡½æ•°æ¥è§£æè¿™ä¸ªæ ‡ç­¾çš„æ–‡æœ¬å†…å®¹ï¼Œå°†å…¶è§£æä¸ºåŒ…å«ä¸‰ä¸ªå€¼çš„å…ƒç»„ã€‚'
- en: The `cast()` function is only present to provide evidence to mypy that the value
    of `coordinates.text` is a `str` object. The default definition of the text attribute
    is `Union[str,` `bytes]`; in this application, the data will be `str` exclusively.
    The `cast()` function doesnâ€™t do any runtime processing.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`cast()` å‡½æ•°ä»…å­˜åœ¨ä»¥å‘ mypy æä¾›è¯æ®ï¼Œè¡¨æ˜ `coordinates.text` çš„å€¼æ˜¯ä¸€ä¸ª `str` å¯¹è±¡ã€‚æ–‡æœ¬å±æ€§çš„é»˜è®¤å®šä¹‰æ˜¯
    `Union[str, bytes]`ï¼›åœ¨æ­¤åº”ç”¨ä¸­ï¼Œæ•°æ®å°†æ˜¯ `str` ç‹¬æœ‰çš„ã€‚`cast()` å‡½æ•°ä¸æ‰§è¡Œä»»ä½•è¿è¡Œæ—¶å¤„ç†ã€‚'
- en: 'This function focused on working with the normalized XML structure. The document
    is close to the database designerâ€™s definitions of first normal form: each attribute
    is atomic (a single value), and each row in the XML data has the same columns
    with data of a consistent type. The data values arenâ€™t fully atomic, however:
    we have to split the points on the , to separate longitude, latitude, and altitude
    into atomic string values. However, the text value for these XML tags is internally
    consistent, making it a close fit with first normal form.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: æ­¤å‡½æ•°ä¸“æ³¨äºä¸è§„èŒƒåŒ–çš„ XML ç»“æ„ä¸€èµ·å·¥ä½œã€‚æ–‡æ¡£æ¥è¿‘æ•°æ®åº“è®¾è®¡è€…å¯¹ç¬¬ä¸€èŒƒå¼å®šä¹‰çš„æè¿°ï¼šæ¯ä¸ªå±æ€§éƒ½æ˜¯åŸå­çš„ï¼ˆå•ä¸ªå€¼ï¼‰ï¼ŒXML æ•°æ®ä¸­çš„æ¯ä¸€è¡Œéƒ½å…·æœ‰ç›¸åŒçš„åˆ—ï¼Œå¹¶ä¸”æ•°æ®ç±»å‹ä¸€è‡´ã€‚ç„¶è€Œï¼Œæ•°æ®å€¼å¹¶éå®Œå…¨åŸå­ï¼šæˆ‘ä»¬å¿…é¡»åœ¨é€—å·å¤„æ‹†åˆ†ç‚¹ï¼Œä»¥å°†ç»åº¦ã€çº¬åº¦å’Œæµ·æ‹”åˆ†ç¦»æˆåŸå­çš„å­—ç¬¦ä¸²å€¼ã€‚ç„¶è€Œï¼Œè¿™äº›
    XML æ ‡ç­¾çš„æ–‡æœ¬å€¼åœ¨å†…éƒ¨æ˜¯ä¸€è‡´çš„ï¼Œè¿™ä½¿å¾—å®ƒä¸ç¬¬ä¸€èŒƒå¼éå¸¸å¥‘åˆã€‚
- en: A large volume of dataâ€”XML tags, attributes, and other punctuationâ€”is reduced
    to a somewhat smaller volume, including just floating-point latitude and longitude
    values. For this reason, we can think of parsers as a kind of reduction.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: å¤§é‡çš„æ•°æ®â€”â€”XML æ ‡ç­¾ã€å±æ€§å’Œå…¶ä»–æ ‡ç‚¹ç¬¦å·â€”â€”è¢«å‡å°‘åˆ°ç›¸å¯¹è¾ƒå°çš„ä½“ç§¯ï¼ŒåŒ…æ‹¬ä»…åŒ…å«æµ®ç‚¹çº¬åº¦å’Œç»åº¦å€¼ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥å°†è§£æå™¨è§†ä¸ºä¸€ç§ç®€åŒ–ã€‚
- en: 'Weâ€™ll need a higher-level set of conversions to map the tuples of text into
    floating-point numbers. Also, weâ€™d like to discard altitude, and reorder longitude
    and latitude. This will produce the application-specific tuple we need. We can
    use functions as follows for this conversion:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬éœ€è¦ä¸€ç»„é«˜çº§è½¬æ¢æ¥å°†æ–‡æœ¬å…ƒç»„æ˜ å°„åˆ°æµ®ç‚¹æ•°ã€‚æ­¤å¤–ï¼Œæˆ‘ä»¬å¸Œæœ›ä¸¢å¼ƒæµ·æ‹”ï¼Œå¹¶é‡æ–°æ’åºç»åº¦å’Œçº¬åº¦ã€‚è¿™å°†ç”Ÿæˆæˆ‘ä»¬éœ€è¦çš„ç‰¹å®šäºåº”ç”¨çš„å…ƒç»„ã€‚æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä»¥ä¸‹å‡½æ•°è¿›è¡Œæ­¤è½¬æ¢ï¼š
- en: '[PRE41]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The essential tool is the `float_lat_lon()` function. This is a higher-order
    function that returns a generator expression. The generator uses the `map()` function
    to apply the `float()` function conversion to the results of the `pick_lat_lon()`
    function, and the `*row` argument to assign each member of the row tuple to a
    different parameter of the `pick_lat_lon()` function. This only works when each
    row is a three-tuple. The `pick_lat_lon()` function then returns a two-tuple of
    the selected items in the required order.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: é‡è¦çš„å·¥å…·æ˜¯ `float_lat_lon()` å‡½æ•°ã€‚è¿™æ˜¯ä¸€ä¸ªé«˜é˜¶å‡½æ•°ï¼Œå®ƒè¿”å›ä¸€ä¸ªç”Ÿæˆå™¨è¡¨è¾¾å¼ã€‚ç”Ÿæˆå™¨ä½¿ç”¨ `map()` å‡½æ•°å°† `float()`
    å‡½æ•°è½¬æ¢åº”ç”¨äº `pick_lat_lon()` å‡½æ•°çš„ç»“æœï¼Œå¹¶ä½¿ç”¨ `*row` å‚æ•°å°†è¡Œå…ƒç»„çš„æ¯ä¸ªæˆå‘˜åˆ†é…ç»™ `pick_lat_lon()` å‡½æ•°çš„ä¸åŒå‚æ•°ã€‚è¿™ä»…åœ¨æ¯ä¸€è¡Œæ˜¯ä¸‰ä¸ªå…ƒç»„æ—¶æ‰æœ‰æ•ˆã€‚ç„¶å
    `pick_lat_lon()` å‡½æ•°è¿”å›ä¸€ä¸ªæ‰€éœ€é¡ºåºçš„é€‰å®šé¡¹çš„ä¸¤å…ƒç»„ã€‚
- en: 'The source includes XML that looks like this:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: æºæ–‡ä»¶åŒ…å«å¦‚ä¸‹æ‰€ç¤ºçš„ XMLï¼š
- en: '[PRE42]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We can use this parser as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯ä»¥è¿™æ ·ä½¿ç”¨è¿™ä¸ªè§£æå™¨ï¼š
- en: '[PRE43]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This will build a tuple-of-tuples representation of each waypoint along the
    path in the original KML file. The result will be a flat sequence of pairs that
    looks like this:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å°†æ„å»ºåŸå§‹ KML æ–‡ä»¶ä¸­æ¯ä¸ªèˆªç‚¹çš„å…ƒç»„è¡¨ç¤ºã€‚ç»“æœå°†æ˜¯ä¸€ä¸ªçœ‹èµ·æ¥åƒè¿™æ ·çš„å¹³å¦åºåˆ—å¯¹ï¼š
- en: '[PRE44]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `float_lat_lon()` function uses a low-level XML parser to extract rows of
    text data from the original representation. It uses a higher-level parser to transform
    the text items into more useful tuples of floating-point values suitable for the
    target application.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`float_lat_lon()` å‡½æ•°ä½¿ç”¨ä½çº§ XML è§£æå™¨ä»åŸå§‹è¡¨ç¤ºä¸­æå–æ–‡æœ¬æ•°æ®è¡Œã€‚å®ƒä½¿ç”¨é«˜çº§è§£æå™¨å°†æ–‡æœ¬é¡¹è½¬æ¢ä¸ºæ›´æœ‰ç”¨çš„æµ®ç‚¹æ•°å€¼å…ƒç»„ï¼Œè¿™äº›å€¼é€‚ç”¨äºç›®æ ‡åº”ç”¨ã€‚'
- en: Parsing CSV files
  id: totrans-241
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: è§£æ CSV æ–‡ä»¶
- en: 'In [ChapterÂ 3](Chapter_03.xhtml#x1-510003), [Functions, Iterators, and Generators](Chapter_03.xhtml#x1-510003),
    we saw another example where we parsed a CSV file that was not in a normalized
    form: we had to discard header rows to make it useful. To do this, we used a function
    that extracted the header and returned an iterator over the remaining rows.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨[ç¬¬3ç« ](Chapter_03.xhtml#x1-510003)ï¼Œ[å‡½æ•°ã€è¿­ä»£å™¨å’Œç”Ÿæˆå™¨](Chapter_03.xhtml#x1-510003)ä¸­ï¼Œæˆ‘ä»¬çœ‹åˆ°äº†å¦ä¸€ä¸ªç¤ºä¾‹ï¼Œå…¶ä¸­æˆ‘ä»¬è§£æäº†ä¸€ä¸ªéè§„èŒƒåŒ–çš„CSVæ–‡ä»¶ï¼šæˆ‘ä»¬å¿…é¡»ä¸¢å¼ƒæ ‡é¢˜è¡Œä»¥ä½¿å…¶æœ‰ç”¨ã€‚ä¸ºæ­¤ï¼Œæˆ‘ä»¬ä½¿ç”¨äº†ä¸€ä¸ªæå–æ ‡é¢˜å¹¶è¿”å›å‰©ä½™è¡Œè¿­ä»£å™¨çš„å‡½æ•°ã€‚
- en: 'The data looks as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: æ•°æ®å¦‚ä¸‹æ‰€ç¤ºï¼š
- en: '[PRE45]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The columns are separated by tab characters. Plus, there are three rows of headers
    that we can discard.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ—ç”±åˆ¶è¡¨ç¬¦åˆ†éš”ã€‚æ­¤å¤–ï¼Œè¿˜æœ‰ä¸‰è¡Œæ ‡é¢˜ï¼Œæˆ‘ä»¬å¯ä»¥ä¸¢å¼ƒã€‚
- en: 'Hereâ€™s another version of that CSV-based parser. Weâ€™ve broken it into three
    functions. The first, `row_iter_csv()` function, returns the iterator over the
    rows in a tab-delimited file. The function looks as follows:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸‹é¢æ˜¯è¿™ä¸ªåŸºäºCSVçš„è§£æå™¨çš„å¦ä¸€ä¸ªç‰ˆæœ¬ã€‚æˆ‘ä»¬å°†å…¶åˆ†è§£ä¸ºä¸‰ä¸ªå‡½æ•°ã€‚ç¬¬ä¸€ä¸ªå‡½æ•°æ˜¯`row_iter_csv()`ï¼Œå®ƒè¿”å›ä¸€ä¸ªåˆ¶è¡¨ç¬¦åˆ†éš”çš„æ–‡ä»¶ä¸­è¡Œçš„è¿­ä»£å™¨ã€‚è¯¥å‡½æ•°å¦‚ä¸‹æ‰€ç¤ºï¼š
- en: '[PRE46]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This is a small wrapper around the CSV parsing process. When we look back at
    the previous parsers for XML and plain text, this was the kind of thing that was
    missing from those parsers. Producing an iterable over row tuples can be a common
    feature of parsers for normalized data.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯ä¸€ä¸ªå›´ç»•CSVè§£æè¿‡ç¨‹çš„å°å‹åŒ…è£…å™¨ã€‚å½“æˆ‘ä»¬å›é¡¾ä¹‹å‰çš„XMLå’Œçº¯æ–‡æœ¬è§£æå™¨æ—¶ï¼Œè¿™å°±æ˜¯é‚£äº›è§£æå™¨æ‰€ç¼ºå°‘çš„ä¸œè¥¿ã€‚ç”Ÿæˆè¡Œå…ƒç»„çš„å¯è¿­ä»£å¯¹è±¡å¯ä»¥æ˜¯è§„èŒƒåŒ–æ•°æ®è§£æå™¨çš„å¸¸è§åŠŸèƒ½ã€‚
- en: Once we have a row of tuples, we can pass rows that contain usable data and
    reject rows that contain other metadata, such as titles and column names. Weâ€™ll
    introduce a helper function that we can use to do some of the parsing, plus a
    `filter()` function to validate a row of data.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€æ—¦æˆ‘ä»¬æœ‰ä¸€è¡Œå…ƒç»„ï¼Œæˆ‘ä»¬å°±å¯ä»¥ä¼ é€’åŒ…å«å¯ç”¨æ•°æ®çš„è¡Œï¼Œå¹¶æ‹’ç»åŒ…å«å…¶ä»–å…ƒæ•°æ®ï¼ˆå¦‚æ ‡é¢˜å’Œåˆ—åï¼‰çš„è¡Œã€‚æˆ‘ä»¬å°†ä»‹ç»ä¸€ä¸ªè¾…åŠ©å‡½æ•°ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨å®ƒæ¥è¿›è¡Œä¸€äº›è§£æï¼Œä»¥åŠä¸€ä¸ª`filter()`å‡½æ•°æ¥éªŒè¯æ•°æ®è¡Œã€‚
- en: 'Following is the conversion:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸‹é¢æ˜¯è½¬æ¢ï¼š
- en: '[PRE47]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This function handles the conversion of a single string to float values, converting
    bad data to a `None` value. The type hint of `float``Â |``Â None` expresses the
    idea of having a value of the given type or having a value of the same type as
    `None`. This can also be stated as `Union[float,``Â None]` to show how the result
    is a union of different alternative types.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: æ­¤å‡½æ•°å¤„ç†å°†å•ä¸ªå­—ç¬¦ä¸²è½¬æ¢ä¸ºæµ®ç‚¹å€¼ï¼Œå°†ä¸è‰¯æ•°æ®è½¬æ¢ä¸º`None`å€¼ã€‚`float` | `None`çš„ç±»å‹æç¤ºè¡¨è¾¾äº†å…·æœ‰ç»™å®šç±»å‹å€¼æˆ–å…·æœ‰ä¸`None`ç›¸åŒç±»å‹çš„å€¼çš„æƒ³æ³•ã€‚è¿™ä¹Ÿå¯ä»¥è¡¨è¿°ä¸º`Union[float,
    None]`ï¼Œä»¥æ˜¾ç¤ºç»“æœæ˜¯å¦‚ä½•æˆä¸ºä¸åŒæ›¿ä»£ç±»å‹çš„è”åˆã€‚
- en: 'We can embed the `float_none()` function in a mapping so that we convert all
    columns of a row to a float or `None` value. A lambda for this looks as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯ä»¥å°†`float_none()`å‡½æ•°åµŒå…¥æ˜ å°„ä¸­ï¼Œä»¥ä¾¿å°†è¡Œçš„æ‰€æœ‰åˆ—è½¬æ¢ä¸ºæµ®ç‚¹æ•°æˆ–`None`å€¼ã€‚è¿™ä¸ªlambdaè¡¨è¾¾å¼å¦‚ä¸‹æ‰€ç¤ºï¼š
- en: '[PRE48]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Two type hints are used to make the definition of the `float_row()` function
    explicit. The `R_Float` hint defines the floating-point version of a row of data
    that may include `None` values.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨å®šä¹‰`float_row()`å‡½æ•°æ—¶ä½¿ç”¨äº†ä¸¤ä¸ªç±»å‹æç¤ºï¼Œä»¥ä½¿å…¶å®šä¹‰æ˜ç¡®ã€‚`R_Float`æç¤ºå®šä¹‰äº†å¯èƒ½åŒ…å«`None`å€¼çš„è¡Œçš„æµ®ç‚¹æ•°ç‰ˆæœ¬ã€‚
- en: 'Following is a row-level validator based on the use of the `all()` function
    to ensure that all values are `float` (or none of the values are `None`):'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸‹é¢æ˜¯ä¸€ä¸ªåŸºäº`all()`å‡½æ•°çš„è¡Œçº§éªŒè¯å™¨ï¼Œç”¨äºç¡®ä¿æ‰€æœ‰å€¼éƒ½æ˜¯`float`ï¼ˆæˆ–è€…æ²¡æœ‰å€¼æ˜¯`None`ï¼‰ï¼š
- en: '[PRE49]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This lambda is a kind of reduction, transforming a row of floating-point values
    to a Boolean value if all values are not â€falsyâ€ (that is, neither `None` nor
    zero) and there are exactly eight values.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ªlambdaè¡¨è¾¾å¼æ˜¯ä¸€ç§å½’çº¦ï¼Œå¦‚æœæ‰€æœ‰å€¼éƒ½ä¸æ˜¯â€œå‡å€¼â€ï¼ˆå³ï¼Œæ—¢ä¸æ˜¯`None`ä¹Ÿä¸æ˜¯é›¶ï¼‰å¹¶ä¸”æ°å¥½æœ‰å…«ä¸ªå€¼ï¼Œåˆ™å°†æµ®ç‚¹å€¼è¡Œè½¬æ¢ä¸ºå¸ƒå°”å€¼ã€‚
- en: The simplistic `all_numeric()` function conflates zero and `None`. A more sophisticated
    test would rely on something such as `not``Â any(item``Â is``Â None``Â for``Â item``Â in``Â row)`.
    The rewrite is left as an exercise for the reader.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: ç®€å•çš„`all_numeric()`å‡½æ•°å°†é›¶å’Œ`None`æ··æ·†ã€‚ä¸€ä¸ªæ›´å¤æ‚çš„æµ‹è¯•å°†ä¾èµ–äºç±»ä¼¼`not any(item is None for item
    in row)`çš„ä¸œè¥¿ã€‚é‡å†™ç•™ç»™è¯»è€…ä½œä¸ºç»ƒä¹ ã€‚
- en: The essential design is to create row-based elements that can be combined to
    create more complete algorithms for parsing an input file. The foundational functions
    iterate over tuples of text. These are combined to convert and validate the converted
    data. For the cases where files are either in first normal form (all rows are
    the same) or a simple validator can reject the extraneous rows, this design pattern
    works out nicely.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: åŸºæœ¬è®¾è®¡æ˜¯åˆ›å»ºåŸºäºè¡Œçš„å…ƒç´ ï¼Œå¯ä»¥ç»„åˆèµ·æ¥åˆ›å»ºè§£æè¾“å…¥æ–‡ä»¶çš„æ›´å®Œæ•´çš„ç®—æ³•ã€‚åŸºç¡€å‡½æ•°éå†æ–‡æœ¬å…ƒç»„ã€‚è¿™äº›è¢«ç»„åˆèµ·æ¥ä»¥è½¬æ¢å’ŒéªŒè¯è½¬æ¢åçš„æ•°æ®ã€‚å¯¹äºæ–‡ä»¶è¦ä¹ˆæ˜¯ç¬¬ä¸€èŒƒå¼ï¼ˆæ‰€æœ‰è¡Œéƒ½ç›¸åŒï¼‰æˆ–è€…ç®€å•éªŒè¯å™¨å¯ä»¥æ‹’ç»é¢å¤–è¡Œçš„æƒ…å†µï¼Œè¿™ç§è®¾è®¡æ¨¡å¼è¿ä½œå¾—å¾ˆå¥½ã€‚
- en: All parsing problems arenâ€™t quite this simple, however. Some files have important
    data in header or trailer rows that must be preserved, even though it doesnâ€™t
    match the format of the rest of the file. These non-normalized files will require
    a more sophisticated parser design.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶è€Œï¼Œå¹¶éæ‰€æœ‰è§£æé—®é¢˜éƒ½è¿™ä¹ˆç®€å•ã€‚ä¸€äº›æ–‡ä»¶åœ¨æ ‡é¢˜æˆ–å°¾éƒ¨è¡Œä¸­æœ‰é‡è¦æ•°æ®å¿…é¡»ä¿ç•™ï¼Œå³ä½¿å®ƒä¸åŒ¹é…æ–‡ä»¶å…¶ä½™éƒ¨åˆ†çš„æ ¼å¼ã€‚è¿™äº›éæ ‡å‡†åŒ–æ–‡ä»¶å°†éœ€è¦ä¸€ä¸ªæ›´å¤æ‚çš„è§£æå™¨è®¾è®¡ã€‚
- en: Parsing plain text files with headers
  id: totrans-262
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: è§£æå¸¦æœ‰æ ‡é¢˜çš„çº¯æ–‡æœ¬æ–‡ä»¶
- en: 'In [ChapterÂ 3](Chapter_03.xhtml#x1-510003), [Functions, Iterators, and Generators](Chapter_03.xhtml#x1-510003),
    the `Crayola.GPL` file was presented without showing the parser. This file looks
    as follows:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ [ç¬¬ 3 ç« ](Chapter_03.xhtml#x1-510003)ï¼Œ[å‡½æ•°ã€è¿­ä»£å™¨å’Œç”Ÿæˆå™¨](Chapter_03.xhtml#x1-510003)
    ä¸­ï¼Œ`Crayola.GPL` æ–‡ä»¶è¢«å±•ç¤ºå‡ºæ¥ï¼Œä½†æ²¡æœ‰æ˜¾ç¤ºè§£æå™¨ã€‚è¿™ä¸ªæ–‡ä»¶çœ‹èµ·æ¥å¦‚ä¸‹ï¼š
- en: '[PRE50]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We can parse a text file using regular expressions. We need to use a filter
    to read (and parse) header rows. We also want to return an iterable sequence of
    data rows. This rather complex two-part parsing is based entirely on the two-partâ€”head
    and tailâ€”file structure.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯ä»¥ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼è§£ææ–‡æœ¬æ–‡ä»¶ã€‚æˆ‘ä»¬éœ€è¦ä½¿ç”¨è¿‡æ»¤å™¨æ¥è¯»å–ï¼ˆå¹¶è§£æï¼‰æ ‡é¢˜è¡Œã€‚æˆ‘ä»¬è¿˜å¸Œæœ›è¿”å›ä¸€ä¸ªæ•°æ®è¡Œçš„å¯è¿­ä»£åºåˆ—ã€‚è¿™ä¸ªç›¸å½“å¤æ‚çš„ä¸¤æ­¥è§£æå®Œå…¨åŸºäºä¸¤æ­¥â€”â€”å¤´éƒ¨å’Œå°¾éƒ¨â€”â€”æ–‡ä»¶ç»“æ„ã€‚
- en: 'Following is a low-level parser that handles both the four lines of the header
    and the long tail:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸‹é¢æ˜¯ä¸€ä¸ªä½çº§è§£æå™¨ï¼Œå®ƒå¤„ç†æ ‡é¢˜çš„å››è¡Œå’Œé•¿å°¾ï¼š
- en: '[PRE51]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The `Head_Body` type definition summarizes the overall goal of the row iterator.
    The result is a two-tuple. The first item is a two-tuple with details from the
    file header. The second item is an iterator that provides the text items for a
    color definition. This `Head_Body` type hint is used in two places in this function
    definition.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`Head_Body` ç±»å‹å®šä¹‰æ€»ç»“äº†è¡Œè¿­ä»£å™¨çš„æ€»ä½“ç›®æ ‡ã€‚ç»“æœæ˜¯ä¸¤ä¸ªå…ƒç»„ã€‚ç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯ä¸€ä¸ªåŒ…å«æ–‡ä»¶æ ‡é¢˜è¯¦ç»†ä¿¡æ¯çš„ä¸¤ä¸ªå…ƒç»„ã€‚ç¬¬äºŒä¸ªå…ƒç´ æ˜¯ä¸€ä¸ªè¿­ä»£å™¨ï¼Œæä¾›é¢œè‰²å®šä¹‰çš„æ–‡æœ¬é¡¹ã€‚è¿™ä¸ª
    `Head_Body` ç±»å‹æç¤ºåœ¨è¿™ä¸ªå‡½æ•°å®šä¹‰ä¸­ä½¿ç”¨äº†ä¸¤ä¸ªåœ°æ–¹ã€‚'
- en: The `header_pat` regular expression parses all four lines of the header. There
    are instances of `()` in the expression to extract the name and column information
    from the header.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`header_pat` æ­£åˆ™è¡¨è¾¾å¼è§£ææ ‡é¢˜çš„æ‰€æœ‰å››è¡Œã€‚è¡¨è¾¾å¼ä¸­å­˜åœ¨ `()` çš„æƒ…å†µï¼Œç”¨äºä»æ ‡é¢˜ä¸­æå–åç§°å’Œåˆ—ä¿¡æ¯ã€‚'
- en: There are two internal functions for parsing different parts of the file. The
    `read_head()` function parses the header lines and returns interesting text and
    a `TextIO` object that can be used for the rest of the parsing. It does this by
    reading four lines and merging them into a single long string. This is then parsed
    with the `header_pat` regular expression.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: æ–‡ä»¶è§£ææœ‰ä¸¤ä¸ªå†…éƒ¨å‡½æ•°ç”¨äºè§£ææ–‡ä»¶çš„ä¸åŒéƒ¨åˆ†ã€‚`read_head()` å‡½æ•°è§£ææ ‡é¢˜è¡Œï¼Œå¹¶è¿”å›æœ‰è¶£çš„æ–‡æœ¬å’Œä¸€ä¸ªå¯ä»¥ç”¨äºå…¶ä½™è§£æçš„ `TextIO` å¯¹è±¡ã€‚å®ƒæ˜¯é€šè¿‡è¯»å–å››è¡Œå¹¶å°†å®ƒä»¬åˆå¹¶æˆä¸€ä¸ªé•¿å­—ç¬¦ä¸²æ¥åšåˆ°è¿™ä¸€ç‚¹çš„ã€‚ç„¶åä½¿ç”¨
    `header_pat` æ­£åˆ™è¡¨è¾¾å¼è¿›è¡Œè§£æã€‚
- en: The idea of returning the iterator from one function to be used in another function
    is a pattern for passing an explicitly stateful object from one function to another.
    It seems helpful to make sure all of the arguments for the `read_tail()` function
    are the results from the `read_head()` function.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: ä»ä¸€ä¸ªå‡½æ•°è¿”å›è¿­ä»£å™¨ä»¥åœ¨å¦ä¸€ä¸ªå‡½æ•°ä¸­ä½¿ç”¨æ˜¯ä¸€ç§å°†æ˜¾å¼çŠ¶æ€å¯¹è±¡ä»ä¸€ä¸ªå‡½æ•°ä¼ é€’åˆ°å¦ä¸€ä¸ªå‡½æ•°çš„æ¨¡å¼ã€‚ç¡®ä¿ `read_tail()` å‡½æ•°çš„æ‰€æœ‰å‚æ•°éƒ½æ˜¯ `read_head()`
    å‡½æ•°çš„ç»“æœä¼¼ä¹æ˜¯æœ‰å¸®åŠ©çš„ã€‚
- en: The `read_tail()` function parses the iterator over the remaining lines. These
    lines are merely split on spaces, since that fits the description of the GPL file
    format.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`read_tail()` å‡½æ•°è§£æå‰©ä½™è¡Œçš„è¿­ä»£å™¨ã€‚è¿™äº›è¡Œä»…æŒ‰ç©ºæ ¼åˆ†å‰²ï¼Œå› ä¸ºè¿™ä¸ GPL æ–‡ä»¶æ ¼å¼çš„æè¿°ç›¸ç¬¦ã€‚'
- en: 'For more information, visit the following link: [https://code.google.com/p/grafx2/issues/detail?id=518](https://code.google.com/p/grafx2/issues/detail?id=518).'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: æ›´å¤šä¿¡æ¯ï¼Œè¯·è®¿é—®ä»¥ä¸‹é“¾æ¥ï¼š[https://code.google.com/p/grafx2/issues/detail?id=518](https://code.google.com/p/grafx2/issues/detail?id=518)ã€‚
- en: Once weâ€™ve transformed each line of the file into a canonical tuple-of-strings
    format, we can apply the higher level of parsing to this data. This involves conversion
    and (if necessary) validation.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€æ—¦æˆ‘ä»¬å°†æ–‡ä»¶çš„æ¯ä¸€è¡Œè½¬æ¢æˆè§„èŒƒåŒ–çš„å­—ç¬¦ä¸²å…ƒç»„æ ¼å¼ï¼Œæˆ‘ä»¬å°±å¯ä»¥å¯¹è¿™ä»½æ•°æ®åº”ç”¨é«˜çº§è§£æã€‚è¿™æ¶‰åŠåˆ°è½¬æ¢ï¼ˆå¦‚æœéœ€è¦ï¼‰å’ŒéªŒè¯ã€‚
- en: 'The following is a higher-level parser command snippet:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: ä»¥ä¸‹æ˜¯ä¸€ä¸ªé«˜çº§è§£æå™¨å‘½ä»¤ç‰‡æ®µï¼š
- en: '[PRE52]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This function will work with the output of the lower-level `row_iter_gpl()`
    parser: it requires the headers and the iterator over individual rows. This function
    will use the multiple assignment feature of the `for` clause in the generator
    to separate the color numbers and the remaining words into four variables, `r`,
    `g`, `b`, and `name`. The use of the `*name` parameter ensures that all remaining
    values will be assigned to the `name` variable as a tuple. The `"``Â ".join(name)`
    expression then concatenates the words into a single space-separated string.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: æ­¤å‡½æ•°å°†ä¸ä½çº§`row_iter_gpl()`è§£æå™¨çš„è¾“å‡ºä¸€èµ·å·¥ä½œï¼šå®ƒéœ€è¦æ ‡é¢˜å’Œå•ä¸ªè¡Œçš„è¿­ä»£å™¨ã€‚æ­¤å‡½æ•°å°†ä½¿ç”¨ç”Ÿæˆå™¨ä¸­`for`å­å¥çš„å¤šä¸ªèµ‹å€¼åŠŸèƒ½ï¼Œå°†é¢œè‰²æ•°å­—å’Œå‰©ä½™çš„å•è¯åˆ†åˆ«åˆ†é…åˆ°å››ä¸ªå˜é‡`r`ã€`g`ã€`b`å’Œ`name`ä¸­ã€‚ä½¿ç”¨`*name`å‚æ•°ç¡®ä¿æ‰€æœ‰å‰©ä½™çš„å€¼éƒ½å°†ä½œä¸ºä¸€ä¸ªå…ƒç»„åˆ†é…ç»™`name`å˜é‡ã€‚ç„¶å`"``Â ".join(name)`è¡¨è¾¾å¼å°†å•è¯è¿æ¥æˆä¸€ä¸ªç©ºæ ¼åˆ†éš”çš„å­—ç¬¦ä¸²ã€‚
- en: 'The following is how we can use this two-tier parser:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: ä»¥ä¸‹æ˜¯å¦‚ä½•ä½¿ç”¨è¿™ä¸ªåŒå±‚è§£æå™¨çš„è¯´æ˜ï¼š
- en: '[PRE53]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Weâ€™ve applied the higher-level parser to the results of the lower-level parser.
    This will return the headers and a tuple built from the sequence of `Color` objects.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å·²ç»å°†é«˜çº§è§£æå™¨åº”ç”¨äºä½çº§è§£æå™¨çš„ç»“æœã€‚è¿™å°†è¿”å›æ ‡é¢˜å’Œä¸€ä¸ªç”±`Color`å¯¹è±¡åºåˆ—æ„å»ºçš„å…ƒç»„ã€‚
- en: 6.4 Summary
  id: totrans-281
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.4 æ‘˜è¦
- en: In this chapter, weâ€™ve looked at two significant functional programming topics.
    Weâ€™ve looked at recursions in some detail. Many functional programming language
    compilers will optimize a recursive function to transform a call in the tail of
    the function to a loop. This is sometimes called tail recursion elimination. More
    commonly, itâ€™s known as tail-call optimization. In Python, we must do the tail-call
    optimization manually by using an explicit `for` statement, replacing a purely
    functional recursion.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æœ¬ç« ä¸­ï¼Œæˆ‘ä»¬æ¢è®¨äº†ä¸¤ä¸ªé‡è¦çš„å‡½æ•°å¼ç¼–ç¨‹ä¸»é¢˜ã€‚æˆ‘ä»¬è¯¦ç»†ç ”ç©¶äº†é€’å½’ã€‚è®¸å¤šå‡½æ•°å¼ç¼–ç¨‹è¯­è¨€ç¼–è¯‘å™¨ä¼šä¼˜åŒ–é€’å½’å‡½æ•°ï¼Œå°†å‡½æ•°å°¾éƒ¨çš„è°ƒç”¨è½¬æ¢ä¸ºå¾ªç¯ã€‚è¿™æœ‰æ—¶è¢«ç§°ä¸ºå°¾é€’å½’æ¶ˆé™¤ã€‚æ›´å¸¸è§çš„æ˜¯ï¼Œå®ƒè¢«ç§°ä¸ºå°¾è°ƒç”¨ä¼˜åŒ–ã€‚åœ¨Pythonä¸­ï¼Œæˆ‘ä»¬å¿…é¡»é€šè¿‡ä½¿ç”¨æ˜¾å¼çš„`for`è¯­å¥æ‰‹åŠ¨è¿›è¡Œå°¾è°ƒç”¨ä¼˜åŒ–ï¼Œä»¥æ›¿æ¢çº¯å‡½æ•°å¼é€’å½’ã€‚
- en: Weâ€™ve also looked at reduction algorithms, including `sum()`, `count()`, `max()`,
    and `min()` functions. We looked at the `collections.Counter()` function and related
    `groupby()` reductions.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬è¿˜ç ”ç©¶äº†åŒ…æ‹¬`sum()`ã€`count()`ã€`max()`å’Œ`min()`å‡½æ•°åœ¨å†…çš„ç®€åŒ–ç®—æ³•ã€‚æˆ‘ä»¬ç ”ç©¶äº†`collections.Counter()`å‡½æ•°å’Œç›¸å…³`groupby()`ç®€åŒ–ã€‚
- en: Weâ€™ve also looked at how parsing (and lexical scanning) are similar to reductions
    since they transform sequences of tokens (or sequences of characters) into higher-order
    collections with more complex properties. Weâ€™ve examined a design pattern that
    decomposes parsing into a lower level and tries to produce tuples of raw strings,
    and a higher level that creates more useful application objects.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬è¿˜ç ”ç©¶äº†è§£æï¼ˆå’Œè¯æ³•æ‰«æï¼‰å¦‚ä½•ä¸ç®€åŒ–ç›¸ä¼¼ï¼Œå› ä¸ºå®ƒä»¬å°†æ ‡è®°åºåˆ—ï¼ˆæˆ–å­—ç¬¦åºåˆ—ï¼‰è½¬æ¢ä¸ºå…·æœ‰æ›´å¤æ‚å±æ€§çš„æ›´é«˜é˜¶é›†åˆã€‚æˆ‘ä»¬æ£€æŸ¥äº†ä¸€ä¸ªå°†è§£æåˆ†è§£ä¸ºä½çº§å¹¶å°è¯•ç”ŸæˆåŸå§‹å­—ç¬¦ä¸²å…ƒç»„çš„æ¨¡å¼ï¼Œä»¥åŠä¸€ä¸ªåˆ›å»ºæ›´æœ‰ç”¨åº”ç”¨å¯¹è±¡çš„æ›´é«˜çº§æ¨¡å¼ã€‚
- en: In the next chapter, weâ€™ll look at some techniques appropriate to working with
    named tuples and other immutable data structures. Weâ€™ll look at techniques that
    make stateful objects unnecessary. While stateful objects arenâ€™t purely functional,
    the idea of a class hierarchy can be used to package related method definitions.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ä¸‹ä¸€ç« ä¸­ï¼Œæˆ‘ä»¬å°†æ¢è®¨é€‚ç”¨äºå¤„ç†å‘½åå…ƒç»„å’Œå…¶å®ƒä¸å¯å˜æ•°æ®ç»“æ„çš„æŠ€å·§ã€‚æˆ‘ä»¬å°†æ¢è®¨ä½¿çŠ¶æ€å¯¹è±¡å˜å¾—ä¸å¿…è¦çš„æŠ€å·§ã€‚è™½ç„¶çŠ¶æ€å¯¹è±¡ä¸æ˜¯çº¯å‡½æ•°å¼çš„ï¼Œä½†ç±»å±‚æ¬¡ç»“æ„çš„æ¦‚å¿µå¯ä»¥ç”¨æ¥å°è£…ç›¸å…³çš„æ–¹æ³•å®šä¹‰ã€‚
- en: 6.5 Exercises
  id: totrans-286
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5 ç»ƒä¹ 
- en: This chapterâ€™s exercises are based on code available from Packt Publishing on
    GitHub. See [https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition](https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition).
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: æœ¬ç« çš„ç»ƒä¹ åŸºäºGitHubä¸ŠPackt Publishingæä¾›çš„ä»£ç ã€‚è¯·å‚é˜…[https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition](https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition)ã€‚
- en: In some cases, the reader will notice that the code provided on GitHub includes
    partial solutions to some of the exercises. These serve as hints, allowing the
    reader to explore alternative solutions.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æŸäº›æƒ…å†µä¸‹ï¼Œè¯»è€…ä¼šæ³¨æ„åˆ°GitHubä¸Šæä¾›çš„ä»£ç åŒ…å«äº†ä¸€äº›ç»ƒä¹ çš„éƒ¨åˆ†è§£å†³æ–¹æ¡ˆã€‚è¿™äº›è§£å†³æ–¹æ¡ˆä½œä¸ºæç¤ºï¼Œå…è®¸è¯»è€…æ¢ç´¢æ›¿ä»£æ–¹æ¡ˆã€‚
- en: In many cases, exercises will need unit test cases to confirm they actually
    solve the problem. These are often identical to the unit test cases already provided
    in the GitHub repository. The reader should replace the bookâ€™s example function
    name with their own solution to confirm that it works.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è®¸å¤šæƒ…å†µä¸‹ï¼Œç»ƒä¹ éœ€è¦å•å…ƒæµ‹è¯•ç”¨ä¾‹æ¥ç¡®è®¤å®ƒä»¬ç¡®å®è§£å†³äº†é—®é¢˜ã€‚è¿™äº›é€šå¸¸ä¸GitHubä»“åº“ä¸­å·²æä¾›çš„å•å…ƒæµ‹è¯•ç”¨ä¾‹ç›¸åŒã€‚è¯»è€…åº”å°†ä¹¦ç±ä¸­çš„ç¤ºä¾‹å‡½æ•°åç§°æ›¿æ¢ä¸ºè‡ªå·±çš„è§£å†³æ–¹æ¡ˆä»¥ç¡®è®¤å…¶å·¥ä½œã€‚
- en: 6.5.1 Multiple recursion and caching
  id: totrans-290
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.5.1 å¤šé‡é€’å½’å’Œç¼“å­˜
- en: In [Handling difficult tail-call optimization](#x1-1300003), we looked at a
    naive definition of a function to compute Fibonacci numbers, the `fib()` function.
    The `functools.cache` decorator can have a profound impact on the performance
    of this algorithm.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨[å¤„ç†å›°éš¾çš„å°¾è°ƒç”¨ä¼˜åŒ–](#x1-1300003)ä¸­ï¼Œæˆ‘ä»¬æŸ¥çœ‹äº†ä¸€ä¸ªè®¡ç®—æ–æ³¢é‚£å¥‘æ•°çš„å‡½æ•°çš„åŸå§‹å®šä¹‰ï¼Œå³`fib()`å‡½æ•°ã€‚`functools.cache`è£…é¥°å™¨å¯ä»¥å¯¹ç®—æ³•çš„æ€§èƒ½äº§ç”Ÿæ·±è¿œçš„å½±å“ã€‚
- en: Implement both versions and describe the impact of caching on the time required
    to compute large Fibonacci numbers.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: å®ç°ä¸¤ç§ç‰ˆæœ¬ï¼Œå¹¶æè¿°ç¼“å­˜å¯¹è®¡ç®—å¤§æ–æ³¢é‚£å¥‘æ•°æ‰€éœ€æ—¶é—´çš„å½±å“ã€‚
- en: 6.5.2 Refactor the all_print() function
  id: totrans-293
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.5.2 é‡æ„all_print()å‡½æ•°
- en: In [Tail-call optimization using deques](#x1-1350001), we showed a function
    that used a `collections.deque` to visit all nodes in a directory tree, summing
    the value for each node that is a proper file. This can be done with a list as
    well as a `deque`, with some minor code changes.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨[ä½¿ç”¨dequeè¿›è¡Œå°¾è°ƒç”¨ä¼˜åŒ–](#x1-1350001)ä¸­ï¼Œæˆ‘ä»¬å±•ç¤ºäº†ä¸€ä¸ªä½¿ç”¨`collections.deque`éå†ç›®å½•æ ‘ä¸­æ‰€æœ‰èŠ‚ç‚¹å¹¶è®¡ç®—æ¯ä¸ªæ­£ç¡®æ–‡ä»¶çš„å€¼çš„å‡½æ•°ã€‚è¿™ä¹Ÿå¯ä»¥ä½¿ç”¨åˆ—è¡¨ä»¥åŠ`deque`å®Œæˆï¼Œåªéœ€è¿›è¡Œä¸€äº›å°çš„ä»£ç æ›´æ”¹ã€‚
- en: 'This function embedded a specific computation. This computation (finding all
    occurrences of â€printâ€) really should have been a separate function. The body
    of the `all_print()` function should be refactored into two functions:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: æ­¤å‡½æ•°åµŒå…¥äº†ä¸€ä¸ªç‰¹å®šçš„è®¡ç®—ã€‚è¿™ä¸ªè®¡ç®—ï¼ˆæŸ¥æ‰¾æ‰€æœ‰â€œprintâ€çš„å®ä¾‹ï¼‰å®é™…ä¸Šåº”è¯¥æ˜¯ä¸€ä¸ªå•ç‹¬çš„å‡½æ•°ã€‚`all_print()`å‡½æ•°çš„ä¸»ä½“åº”è¯¥é‡æ„ä¸ºä¸¤ä¸ªå‡½æ•°ï¼š
- en: A generic directory traverse that applies a function to each text file with
    the expected suffix and sums the results.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä¸€ä¸ªé€šç”¨çš„ç›®å½•éå†ï¼Œå°†ä¸€ä¸ªå‡½æ•°åº”ç”¨äºå…·æœ‰é¢„æœŸåç¼€çš„æ¯ä¸ªæ–‡æœ¬æ–‡ä»¶å¹¶æ±‡æ€»ç»“æœã€‚
- en: A function that counts instances of â€printâ€ in a given Python file.
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä¸€ä¸ªç»Ÿè®¡ç»™å®šPythonæ–‡ä»¶ä¸­â€œprintâ€å®ä¾‹æ•°é‡çš„å‡½æ•°ã€‚
- en: 6.5.3 Parsing CSV files
  id: totrans-298
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.5.3 è§£æCSVæ–‡ä»¶
- en: See the [Parsing CSV files](#x1-1430006) section, earlier in this chapter. In
    that example, the simplistic `all_numeric()` function conflates zero and `None`.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: è¯·å‚é˜…æœ¬ç« å‰é¢çš„[è§£æCSVæ–‡ä»¶](#x1-1430006)éƒ¨åˆ†ã€‚åœ¨é‚£ä¸ªä¾‹å­ä¸­ï¼Œç®€å•çš„`all_numeric()`å‡½æ•°å°†é›¶å’Œ`None`æ··æ·†ã€‚
- en: Create a test case for this function that will show that it does not handle
    zero correctly, treating it as `None`. Once the test case is defined, rewrite
    the `all_numeric()` function to distinguish between zero and `None`.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºæ­¤å‡½æ•°åˆ›å»ºä¸€ä¸ªæµ‹è¯•ç”¨ä¾‹ï¼Œä»¥æ˜¾ç¤ºå®ƒæ²¡æœ‰æ­£ç¡®å¤„ç†é›¶ï¼Œå°†å…¶è§†ä¸º`None`ã€‚ä¸€æ—¦æµ‹è¯•ç”¨ä¾‹å®šä¹‰å¥½ï¼Œé‡æ–°ç¼–å†™`all_numeric()`å‡½æ•°ä»¥åŒºåˆ†é›¶å’Œ`None`ã€‚
- en: Note that itâ€™s common practice in Python to use the `is` operator when comparing
    with `None`. This specifically avoids some subtle problems that can arise when
    a class has an implementation of `__eq__()` that doesnâ€™t handle `None` as a properly
    distinct object.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œåœ¨Pythonä¸­ï¼Œä½¿ç”¨`is`è¿ç®—ç¬¦ä¸`None`è¿›è¡Œæ¯”è¾ƒæ˜¯ä¸€ç§å¸¸è§åšæ³•ã€‚è¿™ç‰¹åˆ«é¿å…äº†å½“ç±»æœ‰ä¸€ä¸ªä¸æ­£ç¡®å¤„ç†`None`ä½œä¸ºç‹¬ç«‹å¯¹è±¡çš„`__eq__()`å®ç°æ—¶å¯èƒ½å‡ºç°çš„å¾®å¦™é—®é¢˜ã€‚
- en: 6.5.4 Classification of state, Part III
  id: totrans-302
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.5.4 çŠ¶æ€åˆ†ç±»ï¼Œç¬¬ä¸‰éƒ¨åˆ†
- en: See [ChapterÂ 5](Chapter_05.xhtml#x1-1000005), [Higher-Order Functions](Chapter_05.xhtml#x1-1000005),
    the [Classification of state](Chapter_05.xhtml#x1-1220001) exercise.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: è¯·å‚é˜…[ç¬¬5ç« ](Chapter_05.xhtml#x1-1000005)ï¼Œ[é«˜é˜¶å‡½æ•°](Chapter_05.xhtml#x1-1000005)ï¼Œ[çŠ¶æ€åˆ†ç±»](Chapter_05.xhtml#x1-1220001)ç»ƒä¹ ã€‚
- en: Thereâ€™s a third way to consume status details and summarize them.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: æ¶ˆè´¹çŠ¶æ€è¯¦æƒ…å¹¶æ€»ç»“çš„ç¬¬ä¸‰ç§æ–¹æ³•ã€‚
- en: Write a reduce computation. This starts with an initial state of Running. As
    each serviceâ€™s three-tuple is folded into the result, there is a comparison between
    the state and the three-tuple. If the three-tuple has a non-responsive service,
    the state advances to Stopped. If the three-tuple has a slow or not working service,
    the state advances to Degraded. If no problems are found, the initial value becomes
    the final health of the overall system.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: ç¼–å†™ä¸€ä¸ªreduceè®¡ç®—ã€‚è¿™ä»è¿è¡ŒçŠ¶æ€å¼€å§‹ã€‚éšç€æ¯ä¸ªæœåŠ¡çš„ä¸‰å…ƒç»„æŠ˜å åˆ°ç»“æœä¸­ï¼ŒçŠ¶æ€ä¸ä¸‰å…ƒç»„ä¹‹é—´è¿›è¡Œæ¯”è¾ƒã€‚å¦‚æœä¸‰å…ƒç»„åŒ…å«ä¸€ä¸ªæ— å“åº”çš„æœåŠ¡ï¼ŒçŠ¶æ€å°†å‰è¿›åˆ°åœæ­¢ã€‚å¦‚æœä¸‰å…ƒç»„åŒ…å«ä¸€ä¸ªæ…¢æˆ–æ— æ³•å·¥ä½œçš„æœåŠ¡ï¼ŒçŠ¶æ€å°†å‰è¿›åˆ°é™çº§ã€‚å¦‚æœæ²¡æœ‰å‘ç°é—®é¢˜ï¼Œåˆå§‹å€¼å°†æˆä¸ºæ•´ä¸ªç³»ç»Ÿçš„æœ€ç»ˆå¥åº·çŠ¶æ€ã€‚
- en: The idea is to provide a `status_add(previous,``Â this_service)` function. This
    can be used in the context of `status``Â =``Â reduce(status_add,``Â service_status_sequence,``Â "Running")`
    to compute the current status of the sequence of services.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: ç­–ç•¥æ˜¯æä¾›ä¸€ä¸ª `status_add(previous, this_service)` å‡½æ•°ã€‚è¿™ä¸ªå‡½æ•°å¯ä»¥åœ¨ `status = reduce(status_add,
    service_status_sequence, "Running")` çš„ä¸Šä¸‹æ–‡ä¸­ä½¿ç”¨ï¼Œä»¥è®¡ç®—æœåŠ¡åºåˆ—çš„å½“å‰çŠ¶æ€ã€‚
- en: 6.5.5 Diesel engine data
  id: totrans-307
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.5.5 æŸ´æ²¹æœºæ•°æ®
- en: A diesel engine has had some repairs that raised doubts about the accuracy of
    the tachometer. After some heroic effort, the following table of data was collected
    showing the observed reading on the engineâ€™s tachometer, and the actual RPMs measured
    with an optical device on the engine.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€å°æŸ´æ²¹å‘åŠ¨æœºè¿›è¡Œäº†ä¸€äº›ç»´ä¿®ï¼Œè¿™å¼•èµ·äº†äººä»¬å¯¹è½¬é€Ÿè¡¨å‡†ç¡®æ€§çš„æ€€ç–‘ã€‚ç»è¿‡ä¸€äº›è‹±å‹‡çš„åŠªåŠ›ï¼Œæ”¶é›†åˆ°äº†ä»¥ä¸‹è¡¨æ ¼ä¸­çš„æ•°æ®ï¼Œæ˜¾ç¤ºäº†å‘åŠ¨æœºè½¬é€Ÿè¡¨ä¸Šçš„è§‚å¯Ÿè¯»æ•°ï¼Œä»¥åŠä½¿ç”¨å‘åŠ¨æœºä¸Šçš„å…‰å­¦è®¾å¤‡æµ‹é‡çš„å®é™…
    RPM å€¼ã€‚
- en: '| Sample | Tach | Engine |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| æ ·æœ¬ | è½¬é€Ÿ | å‘åŠ¨æœº |'
- en: '| 1 | 1000 | 883 |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1000 | 883 |'
- en: '| 2 | 1500 | 1242 |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 1500 | 1242 |'
- en: '| 3 | 1500 | 1217 |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 1500 | 1217 |'
- en: '| 4 | 1600 | 1306 |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 1600 | 1306 |'
- en: '| 5 | 1750 | 1534 |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 1750 | 1534 |'
- en: '| 6 | 2000 | 1805 |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 2000 | 1805 |'
- en: '| 7 | 2000 | 1720 |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 2000 | 1720 |'
- en: '|  |  |  |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '|  |  |  |'
- en: If needed, create a CSV file with the data. If you have access to the GitHub
    repository for this book, this is available in the `engine.csv` file.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœéœ€è¦ï¼Œåˆ›å»ºä¸€ä¸ªåŒ…å«æ•°æ®çš„ CSV æ–‡ä»¶ã€‚å¦‚æœæ‚¨æœ‰è®¿é—®æœ¬ä¹¦ GitHub ä»“åº“çš„æƒé™ï¼Œè¿™äº›æ•°æ®å¯ä»¥åœ¨ `engine.csv` æ–‡ä»¶ä¸­æ‰¾åˆ°ã€‚
- en: Create a `NamedTuple` for each sample and write some functions to acquire this
    data in a useful form. Once the data is available, see the [Using sums and counts
    for statistics](Chapter_04.xhtml#x1-850001) section of [ChapterÂ 4](Chapter_04.xhtml#x1-740004),
    [Working with Collections](Chapter_04.xhtml#x1-740004), for a definition of a
    correlation function.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºæ¯ä¸ªæ ·æœ¬åˆ›å»ºä¸€ä¸ª `NamedTuple`ï¼Œå¹¶ç¼–å†™ä¸€äº›å‡½æ•°ä»¥è·å–è¿™äº›æ•°æ®çš„æœ‰ç”¨å½¢å¼ã€‚ä¸€æ—¦æ•°æ®å¯ç”¨ï¼Œè¯·å‚é˜…[ç¬¬ 4 ç« ](Chapter_04.xhtml#x1-740004)ï¼Œ[ä½¿ç”¨é›†åˆ](Chapter_04.xhtml#x1-740004)ä¸­çš„[ä½¿ç”¨æ€»å’Œå’Œè®¡æ•°è¿›è¡Œç»Ÿè®¡](Chapter_04.xhtml#x1-850001)éƒ¨åˆ†ï¼Œäº†è§£ç›¸å…³å‡½æ•°çš„å®šä¹‰ã€‚
- en: The objective is to apply this correlation function to the engine and tach values
    to see if the values correlate. If they do, it suggests that the engineâ€™s instruments
    can be recalibrated. If they donâ€™t correlate, something else is wrong with the
    engine.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: ç›®æ ‡æ˜¯å°†æ­¤ç›¸å…³å‡½æ•°åº”ç”¨äºå‘åŠ¨æœºå’Œè½¬é€Ÿå€¼ï¼Œä»¥æŸ¥çœ‹å®ƒä»¬æ˜¯å¦ç›¸å…³ã€‚å¦‚æœå®ƒä»¬ç›¸å…³ï¼Œåˆ™è¡¨æ˜å‘åŠ¨æœºçš„ä»ªè¡¨å¯ä»¥é‡æ–°æ ¡å‡†ã€‚å¦‚æœä¸ç›¸å…³ï¼Œåˆ™è¡¨æ˜å‘åŠ¨æœºå­˜åœ¨å…¶ä»–é—®é¢˜ã€‚
- en: Note that the [ChapterÂ 4](Chapter_04.xhtml#x1-740004), [Working with Collections](Chapter_04.xhtml#x1-740004),
    correlation example may have assumptions about data types that donâ€™t necessarily
    apply to the `NamedTuple` defined earlier. If necessary, rewrite the type hints
    or your `NamedTuple` definition. Note that it can be difficult to write perfectly
    generic type hints, and it often takes a bit of work to resolve the differences.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œ[ç¬¬ 4 ç« ](Chapter_04.xhtml#x1-740004)ï¼Œ[ä½¿ç”¨é›†åˆ](Chapter_04.xhtml#x1-740004)çš„ç›¸å…³ç¤ºä¾‹å¯èƒ½å¯¹æ•°æ®ç±»å‹æœ‰ä¸€äº›å‡è®¾ï¼Œè¿™äº›å‡è®¾ä¸ä¸€å®šé€‚ç”¨äºä¹‹å‰å®šä¹‰çš„
    `NamedTuple`ã€‚å¦‚æœéœ€è¦ï¼Œè¯·é‡å†™ç±»å‹æç¤ºæˆ–æ‚¨çš„ `NamedTuple` å®šä¹‰ã€‚è¯·æ³¨æ„ï¼Œç¼–å†™å®Œå…¨é€šç”¨çš„ç±»å‹æç¤ºå¯èƒ½å¾ˆå›°éš¾ï¼Œé€šå¸¸éœ€è¦ä¸€äº›å·¥ä½œæ¥è§£å†³å·®å¼‚ã€‚
- en: Join our community Discord space
  id: totrans-322
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: åŠ å…¥æˆ‘ä»¬çš„ç¤¾åŒº Discord ç©ºé—´
- en: 'Join our Python Discord workspace to discuss and know more about the book:
    [https://packt.link/dHrHU](https://packt.link/dHrHU)'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: åŠ å…¥æˆ‘ä»¬çš„ Python Discord å·¥ä½œç©ºé—´ï¼Œè®¨è®ºå¹¶äº†è§£æ›´å¤šå…³äºæœ¬ä¹¦çš„ä¿¡æ¯ï¼š[https://packt.link/dHrHU](https://packt.link/dHrHU)
- en: '![PIC](img/file1.png)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file1.png)'
