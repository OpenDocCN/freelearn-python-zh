<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch04"/>Chapter 4.  Throttling, Filtering, Testing, and Deploying an API with Django </h1></div></div></div><p>In this chapter, we will use the additional features included in Django and Django REST Framework to improve our RESTful API. We will also write and execute unit tests and learn a few things related to deployment. We will cover the following topics in this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Understanding throttling classes</li><li class="listitem" style="list-style-type: disc">Configuring throttling policies</li><li class="listitem" style="list-style-type: disc">Testing throttle policies</li><li class="listitem" style="list-style-type: disc">Understanding filtering, searching and ordering classes</li><li class="listitem" style="list-style-type: disc">Configuring filtering, searching, and ordering for views</li><li class="listitem" style="list-style-type: disc">Testing filtering, searching and ordering features</li><li class="listitem" style="list-style-type: disc">Filter, search, and order in the browsable API</li><li class="listitem" style="list-style-type: disc">Writing a first round of unit tests</li><li class="listitem" style="list-style-type: disc">Running unit tests and checking testing coverage</li><li class="listitem" style="list-style-type: disc">Improving testing coverage</li><li class="listitem" style="list-style-type: disc">Understanding strategies for deployments and scalability</li></ul></div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec45"/>Understanding throttling classes</h1></div></div></div><p>So far, we haven't established any limits on the usage of our API, and therefore, both authenticated and unauthenticated users can compose and send as many requests as they want to. We only took advantage of the pagination features available in Django REST Framework to specify how we wanted large results sets to be split into individual pages of data. However, any user can compose and send thousands of requests to be processed without any kind of limitation.</p><p>We will use throttling to configure the following limitations of the usage of our API:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Unauthenticated users</strong>: A maximum of five requests per hour.</li><li class="listitem" style="list-style-type: disc"><strong>Authenticated users</strong>: A maximum of 20 requests per hour.</li></ul></div><p>In addition, we want to configure a maximum of 100 requests per hour to the game categories related views, no matter whether the user is authenticated or not.</p><p>Django REST Framework provides the following three throttling classes in the <code class="literal">rest_framework.throttling</code> module. All of them are subclasses of the <code class="literal">SimpleRateThrottle</code> class, which is a subclass of the <code class="literal">BaseThrottle</code> class. The classes allow us to set the maximum number of requests per period that are computed based on different mechanisms to determine the previous request information used to specify the scope. The previous request information for throttling is stored in the cache and the classes override the <code class="literal">get_cache_key</code> method that determines the scope.</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">AnonRateThrottle</code>: This class limits the rate of request that an anonymous user can make. The IP address of the request is the unique cache key, and therefore, all the requests coming from the same IP address will accumulate the total number of requests.</li><li class="listitem" style="list-style-type: disc"><code class="literal">UserRateThrottle</code>: This class limits the rate at which a specific user can make requests. For authenticated users, the authenticated user ID is the unique cache key. For anonymous users, the IP address of the request is the unique cache key.</li><li class="listitem" style="list-style-type: disc"><code class="literal">ScopedRateThrottle</code>: This class limits the rate of request for specific parts of the API identified with the value assigned to the <code class="literal">throttle_scope</code> property. The class is useful when we want to restrict access to specific parts of the API with different rates.</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec46"/>Configuring throttling policies</h1></div></div></div><p>We will use a combination of the three throttling classes, discussed earlier, to achieve our previously explained goals. Make sure you quit Django's development server. Remember that you just need to press <em>
<strong>Ctrl</strong>
</em> + <em>
<strong>C</strong>
</em> in the Terminal or Command Prompt window in which it is running.</p><p>Open the <code class="literal">gamesapi/settings.py</code> file and add the highlighted lines to the dictionary named <code class="literal">REST_FRAMEWORK</code> with two key-value pairs that configure the global default throttling classes and their rates. The code file for the sample is included in the <code class="literal">restful_python_chapter_04_01</code> folder:</p><pre class="programlisting">REST_FRAMEWORK = { 
    'DEFAULT_PAGINATION_CLASS': 
    'games.pagination.LimitOffsetPaginationWithMaxLimit', 
    'PAGE_SIZE': 5, 
    'DEFAULT_AUTHENTICATION_CLASSES': ( 
        'rest_framework.authentication.BasicAuthentication', 
        'rest_framework.authentication.SessionAuthentication', 
        ), 
    <strong>'DEFAULT_THROTTLE_CLASSES': ( 
        'rest_framework.throttling.AnonRateThrottle', 
        'rest_framework.throttling.UserRateThrottle', 
    ), 
    'DEFAULT_THROTTLE_RATES': { 
        'anon': '5/hour', 
        'user': '20/hour', 
        'game-categories': '30/hour', 
    } 
}</strong>
</pre><p>The value for the <code class="literal">DEFAULT_THROTTLE_CLASSES</code> settings key specifies a global setting with a tuple of string whose values indicate the default classes that we want to use for throttling-<code class="literal">AnonRateThrottle</code> and <code class="literal">UserRateThrottle</code>. The <code class="literal">DEFAULT_THROTTLE_RATES</code> settings key specifies a dictionary with default throttle rates. The value specified for the <code class="literal">'anon'</code> key indicates that we want a maximum of five requests per hour for anonymous users. The value specified for the <code class="literal">'user'</code> key indicates that we want a maximum of 20 requests per hour for authenticated users. The value specified for the <code class="literal">'game-categories'</code> key indicates that we want a maximum of <code class="literal">30</code> requests per hour for the scope with that name.</p><p>The maximum rate is a string that specifies the number of requests per period with the following format: <code class="literal">'number_of_requests/period'</code>, where period can be any of the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">s</code>: second</li><li class="listitem" style="list-style-type: disc"><code class="literal">sec</code>: second</li><li class="listitem" style="list-style-type: disc"><code class="literal">m</code>: minute</li><li class="listitem" style="list-style-type: disc"><code class="literal">min</code>: minute</li><li class="listitem" style="list-style-type: disc"><code class="literal">h</code>: hour</li><li class="listitem" style="list-style-type: disc"><code class="literal">hour</code>: hour</li><li class="listitem" style="list-style-type: disc"><code class="literal">d</code>: day</li><li class="listitem" style="list-style-type: disc"><code class="literal">day</code>: day</li></ul></div><p>Now, we will configure throttling policies for the class-based views related to game categories. We will override the value for the <code class="literal">throttle_scope</code> and <code class="literal">throttle_classes</code> class attributes for the <code class="literal">GameCategoryList</code> and <code class="literal">GameCategoryDetail</code> classes. First, we have to add the following <code class="literal">import</code> statement after the last import in the <code class="literal">views.py</code> file. The code file for the sample is included in the <code class="literal">restful_python_chapter_04_01</code> folder:</p><pre class="programlisting">from rest_framework.throttling import ScopedRateThrottle 
</pre><p>The following lines show the new code for the <code class="literal">GameCategoryList</code> class in the <code class="literal">views.py</code> file. The new lines are highlighted. The code file for the sample is included in the <code class="literal">restful_python_chapter_04_01</code> folder:</p><pre class="programlisting">class GameCategoryList(generics.ListCreateAPIView): 
    queryset = GameCategory.objects.all() 
    serializer_class = GameCategorySerializer 
    name = 'gamecategory-list' 
   <strong> throttle_scope = 'game-categories' 
    throttle_classes = (ScopedRateThrottle,)</strong>
</pre><p>The following lines show the new code for the <code class="literal">GameCategoryDetail</code> class in the <code class="literal">views.py</code> file. The new lines are highlighted in the following code. The code file for the sample is included in the <code class="literal">restful_python_chapter_04_01</code> folder:</p><pre class="programlisting">class GameCategoryDetail(generics.RetrieveUpdateDestroyAPIView): 
    queryset = GameCategory.objects.all() 
    serializer_class = GameCategorySerializer 
    name = 'gamecategory-detail' 
    <strong>throttle_scope = 'game-categories' 
    throttle_classes = (ScopedRateThrottle,)</strong>
</pre><p>We added the same lines in the two classes. We set <code class="literal">'game-categories'</code> as the value for the <code class="literal">throttle_scope</code> class attribute and we included <code class="literal">ScopedRateThrottle</code> in the tuple that defines the value for <code class="literal">throttle_classes</code>. This way, the two class-based views will use the settings specified for the <code class="literal">'game-categories'</code> scope and the <code class="literal">ScopeRateThrottle</code> class for throttling. These views will be able to serve 30 requests per hour and won't take into account the global settings that apply to the default classes that we use for throttling: <code class="literal">AnonRateThrottle</code> and <code class="literal">UserRateThrottle</code>.</p><p>Before Django runs the main body of a view, it performs the checks for each throttle class specified in the throttle classes. In the views related to the game categories, we wrote code that overrides the default settings. If a single throttle check fails, the code will raise a <code class="literal">Throttled</code> exception and Django won't execute the main body of the view. The cache is responsible of storing previous requests' information for throttling checking.</p></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec47"/>Testing throttling policies</h1></div></div></div><p>Now, we can launch Django's development server to compose and send HTTP requests. Execute any of the following two commands based on your needs to access the API in other devices or computers connected to your LAN. Remember that we analyzed the difference between them in <a class="link" href="ch01.html" title="Chapter 1. Developing RESTful APIs with Django">Chapter 1</a>
<em>, </em>
<em>Developing RESTful APIs with Django</em>.</p><pre class="programlisting">
<strong>python manage.py runserver</strong>
<strong>python manage.py runserver 0.0.0.0:8000</strong>
</pre><p>After we run any of the previous commands, the development server will start listening at port <code class="literal">8000</code>.</p><p>Now, we will compose and send an HTTP request to retrieve all the player's scores without authentication credentials six times:</p><pre class="programlisting">
<strong>http :8000/player-scores/</strong>
</pre><p>We can also use the features of the shell in macOS or Linux to run the previous command six times with just a single line. We can also run the command in a Cygwin terminal in Windows. We can execute the next line in a bash shell. However, we will see all the results one after the other and you will have to scroll to understand what happened with each execution:</p><pre class="programlisting">
<strong>for i in {1..6}; do http :8000/player-scores/; done;</strong>
</pre><p>The following is the equivalent curl command that we must execute six times:</p><pre class="programlisting">
<strong>curl -iX GET :8000/player-scores/</strong>
</pre><p>The following is the equivalent curl command that is executed six times with a single line in a bash shell in macOS or Linux, or a Cygwin terminal in Windows:</p><pre class="programlisting">
<strong>for i in {1..6}; do curl -iX GET :8000/player-scores/; done;</strong>
</pre><p>Django won't process the sixth request because <code class="literal">AnonRateThrottle</code> is configured as one of the default throttle classes and its throttle settings specify five requests per hour. Thus, we will receive a <code class="literal">429 Too many requests</code> status code in the response header and a message indicating that the request was throttled and the time in which the server will be able to process an additional request. The <code class="literal">Retry-After</code> key in the response header provides the number of seconds that it is necessary to wait until the next request: <code class="literal">3189</code>. The following lines show a sample response:</p><pre class="programlisting">
<strong>HTTP/1.0 429 Too Many Requests</strong>
<strong>Allow: GET, POST, HEAD, OPTIONS</strong>
<strong>Content-Type: application/json</strong>
<strong>Date: Tue, 05 Jul 2016 03:37:50 GMT</strong>
<strong>Retry-After: 3189</strong>
<strong>Server: WSGIServer/0.2 CPython/3.5.1</strong>
<strong>Vary: Accept, Cookie</strong>
<strong>X-Frame-Options: SAMEORIGIN</strong>
<strong>{</strong>
<strong>    "detail": "Request was throttled. Expected available in 3189 seconds."</strong>
<strong>}</strong>
</pre><p>Now, we will compose and send an HTTP request to retrieve the player's scores with authentication credentials, that is, with the <code class="literal">superuser</code> name and his password. We will execute the same request six times. Remember to replace <code class="literal">superuser</code> with the name you used for the <code class="literal">superuser</code> and <code class="literal">password</code> with the password you configured for this user in <a class="link" href="ch03.html" title="Chapter 3.  Improving and Adding Authentication to an API With Django">Chapter 3</a>
<em>, </em>
<em>Improving and Adding Authentication to an API with Django:</em>
</p><pre class="programlisting">
<strong>http -a superuser:'password' :8000/player-scores/</strong>
</pre><p>We can also run the previous command six times with just a single line:</p><pre class="programlisting">
<strong>for i in {1..6}; do http -a superuser:'password' :8000/player-scores/; done;</strong>
</pre><p>The following is the equivalent curl command that we must execute six times:</p><pre class="programlisting">
<strong>curl --user superuser:'password' -iX GET :8000/player-scores/</strong>
</pre><p>The following is the equivalent <code class="literal">curl</code> command that is executed six times with a single line:</p><pre class="programlisting">
<strong>for i in {1..6}; do curl --user superuser:'password' -iX GET :8000/player-scores/; done;</strong>
</pre><p>Django will process the sixth request because we have composed and sent six authenticated requests with the same user, <code class="literal">UserRateThrottle</code> is configured as one of the default throttle classes and its throttle settings specify 20 requests per hour.</p><p>If we run the previous commands 15 times more, we will accumulate 21 requests and we will will receive a <code class="literal">429 Too many requests</code> status code in the response header and a message indicating that the request was throttled and the time in which the server will be able to process an additional request after the last execution.</p><p>Now, we will compose and send an HTTP request to retrieve all the game categories thirty times without the authentication credentials:</p><pre class="programlisting">
<strong>http :8000/game-categories/</strong>
</pre><p>We can also run the previous command thirty times with just a single line:</p><pre class="programlisting">
<strong>for i in {1..30}; do http :8000/game-categories/; done;</strong>
</pre><p>The following is the equivalent <code class="literal">curl</code> command that we must execute thirty times:</p><pre class="programlisting">
<strong>curl -iX GET :8000/game-categories/</strong>
</pre><p>The following is the equivalent <code class="literal">curl</code> command that is executed thirty times with a single line:</p><pre class="programlisting">
<strong>for i in {1..30}; do curl -iX GET :8000/game-categories/; done;</strong>
</pre><p>Django will process the thirty requests because we have composed and sent 30 unauthenticated requests to a URL that is identified with the <code class="literal">'game-categories'</code> throttle scope and uses the <code class="literal">ScopedRateThrottle</code> class for throttle permission control. The throttle settings for the throttle scope identified with <code class="literal">'game-categories'</code> are configured with 30 requests per hour.</p><p>If we run the previous command once again, we will accumulate 31 requests and we will receive a <code class="literal">429 Too many requests</code> status code in the response header and a message indicating that the request was throttled and the time in which the server will be able to process an additional request after the last execution.</p></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec48"/>Understanding filtering, searching, and ordering classes</h1></div></div></div><p>We took advantage of the pagination features available in Django REST Framework to specify how we wanted large results sets to be split into individual pages of data. However, we have always been working with the entire queryset as the result set. Django REST Framework makes it easy to customize filtering, searching, and sorting capabilities to the views we have already coded.</p><p>First, we will install the <code class="literal">django-filter</code> package in our virtual environment. This way, we will be able to use field filtering features that we can easily customize in Django REST Framework. Make sure that you quit the Django's development server. Remember that you just need to press <em>
<strong>Ctrl</strong>
</em> + <em>
<strong>C</strong>
</em> in the terminal or Command Prompt window in which it is running. Then, we just need to run the following command to install the <code class="literal">django-filter</code> package:</p><pre class="programlisting">
<strong>pip install django-filter</strong>
</pre><p>The last lines for the output will indicate that the <code class="literal">django-filter</code> package has been successfully installed.</p><pre class="programlisting">
<strong>Collecting django-filter</strong>
<strong>  Downloading django_filter-0.13.0-py2.py3-none-any.whl</strong>
<strong>Installing collected packages: django-filter</strong>
<strong>Successfully installed django-filter-0.13.0</strong>
</pre><p>In addition, we will install the <code class="literal">django-cripsy-forms</code> package in our virtual environment. This package enhances how the browsable API renders the different filters. Run the following command to install the <code class="literal">django-cripsy-forms</code> package: We just need to run the following command to install this package:</p><pre class="programlisting">
<strong>pip install django-crispy-forms</strong>
</pre><p>The last lines for the output will indicate that the <code class="literal">django-crispy-forms</code> package has been successfully installed:</p><pre class="programlisting">
<strong>Collecting django-crispy-forms</strong>
<strong>Installing collected packages: django-crispy-forms</strong>
<strong>  Running setup.py install for django-crispy-forms</strong>
<strong>Successfully installed django-crispy-forms-1.6.0</strong>
</pre><p>Open the <code class="literal">gamesapi/settings.py</code> file and add the highlighted lines to the <code class="literal">REST_FRAMEWORK</code> dictionary. The code file for the sample is included in the <code class="literal">restful_python_chapter_04_02</code> folder:</p><pre class="programlisting">REST_FRAMEWORK = { 
    'DEFAULT_PAGINATION_CLASS': 
    'games.pagination.LimitOffsetPaginationWithMaxLimit', 
    'PAGE_SIZE': 5, 
    '<strong>DEFAULT_FILTER_BACKENDS': ( 
        'rest_framework.filters.DjangoFilterBackend', 
        'rest_framework.filters.SearchFilter', 
        'rest_framework.filters.OrderingFilter', 
        ),</strong> 
    'DEFAULT_AUTHENTICATION_CLASSES': ( 
        'rest_framework.authentication.BasicAuthentication', 
        'rest_framework.authentication.SessionAuthentication', 
        ), 
    'DEFAULT_THROTTLE_CLASSES': ( 
        'rest_framework.throttling.AnonRateThrottle', 
        'rest_framework.throttling.UserRateThrottle', 
    ), 
    'DEFAULT_THROTTLE_RATES': { 
        'anon': '5/hour', 
        'user': '20/hour', 
        'game-categories': '30/hour', 
    } 
} 
</pre><p>The value for the <code class="literal">'DEFAULT_FILTER_BACKENDS</code> settings key specifies a global setting with a tuple of string whose values indicate the default classes that we want to use for filter backends. We will use the following three classes:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">rest_framework.filters.DjangoFilterBackend</code>: This class provides field filtering capabilities. It uses the previously installed <code class="literal">django-filter</code> package. We can specify the set of fields we want to be able to filter against or create a <code class="literal">rest_framework.filters.FilterSet</code> class with more customized settings and associate it with the view.</li><li class="listitem" style="list-style-type: disc"><code class="literal">rest_framework.filters.SearchFilter</code>: This class provides single query parameter-based searching capabilities and it is based on Django admin's search function. We can specify the set of fields we want to include for the search and the client will be able to filter items by making queries that search these fields with a single query. It is useful when we want to make it possible for a request to search multiple fields with a single query.</li><li class="listitem" style="list-style-type: disc"><code class="literal">rest_framework.filters.OrderingFilter</code>: This class allows the client to control how the results are ordered with a single-query parameter. We can also specify the fields that can be ordered against.</li></ul></div><div><div><h3 class="title"><a id="tip31"/>Tip</h3><p>We can also configure the filter backends by including any of the previously enumerated classes in a tuple and assign it to the <code class="literal">filter_backends</code> class attribute for the generic view classes. However, in this case, we will use the default configuration for all our class-based views.</p></div></div><p>Add <code class="literal">'crispy_forms'</code> to the installed apps in the <code class="literal">settings.py</code> file, specifically, to the <code class="literal">INSTALLED_APPS</code> string list. The following code shows the lines we must add as the highlighted code. The code file for the sample is included in the <code class="literal">restful_python_chapter_04_02</code> folder:</p><pre class="programlisting">INSTALLED_APPS = [ 
    'django.contrib.admin', 
    'django.contrib.auth', 
    'django.contrib.contenttypes', 
    'django.contrib.sessions', 
    'django.contrib.messages', 
    'django.contrib.staticfiles', 
    # Django REST Framework 
    'rest_framework', 
    # Games application 
    'games.apps.GamesConfig', 
   <strong> # Crispy forms 
    'crispy_forms',</strong> 
] 
</pre><div><div><h3 class="title"><a id="tip32"/>Tip</h3><p>We have to be careful with the fields we configure to be available in the filtering, searching, and ordering features. The configuration will have an impact on the queries executed on the database, and therefore, we must ensure that we have the appropriate database optimizations considering the queries that will be executed.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec49"/>Configuring filtering, searching, and ordering for views</h1></div></div></div><p>Go to the <code class="literal">gamesapi/games</code> folder and open the <code class="literal">views.py</code> file. Add the following code after the last line that declares the imports but before the declaration of the <code class="literal">UserList</code> class. The code file for the sample is included in the <code class="literal">restful_python_chapter_04_02</code> folder:</p><pre class="programlisting">from rest_framework import filters 
from django_filters import NumberFilter, DateTimeFilter, AllValuesFilter 
</pre><p>Add the following highlighted lines to the <code class="literal">GameCategoryList</code> class declared in the <code class="literal">views.py</code> file. The code file for the sample is included in the <code class="literal">restful_python_chapter_04_02</code> folder:</p><pre class="programlisting">class GameCategoryList(generics.ListCreateAPIView): 
    queryset = GameCategory.objects.all() 
    serializer_class = GameCategorySerializer 
    name = 'gamecategory-list' 
    throttle_scope = 'game-categories' 
    throttle_classes = (ScopedRateThrottle,) 
    <strong>filter_fields = ('name',) 
    search_fields = ('^name',) 
    ordering_fields = ('name',) 
</strong>
</pre><p>The <code class="literal">filter_fields</code> attribute specifies a tuple of string whose values indicate the field names that we want to be able to filter against. Under the hoods, Django REST Framework will automatically create a <code class="literal">rest_framework.filters.FilterSet</code> class and associate it to the <code class="literal">GameCategoryList</code> view. This way, we will be able to filter against the <code class="literal">name</code> field.</p><p>The <code class="literal">search_fields</code> attribute specifies a tuple of string whose values indicate the text-type field names that we want to include in the search feature. In this case, we want to search only against the name field and perform a starts-with match. The <code class="literal">'^'</code> included as a prefix of the field name indicates that we want to restrict the search behavior to a starts-with match.</p><p>The <code class="literal">ordering_fields</code> attribute specifies a tuple of string whose values indicate the field names that the client can specify to sort the results. In case the client doesn't specify a field for ordering, the response will use the default ordering fields indicated in the model related to the view.</p><p>Add the following highlighted lines to the <code class="literal">GameList</code> class declared in the <code class="literal">views.py</code> file. The new lines specify the fields to be used in the filter, search, and ordering features. The code file for the sample is included in the <code class="literal">restful_python_chapter_04_02</code> folder:</p><pre class="programlisting">class GameList(generics.ListCreateAPIView): 
    queryset = Game.objects.all() 
    serializer_class = GameSerializer 
    name = 'game-list' 
    permission_classes = ( 
        permissions.IsAuthenticatedOrReadOnly, 
        IsOwnerOrReadOnly, 
        ) 
    <strong>filter_fields = ( 
        'name',  
        'game_category',  
        'release_date',  
        'played',  
        'owner', 
        ) 
    search_fields = ( 
        '^name', 
        ) 
    ordering_fields = ( 
        'name', 
        'release_date', 
        )</strong> 
 
    def perform_create(self, serializer): 
        serializer.save(owner=self.request.user) 
</pre><p>In this case, we specified many field names in the <code class="literal">filter_fields</code> attribute. We included <code class="literal">'game_category'</code> and <code class="literal">'owner'</code> in the string tuple, and therefore, the client will be able to include the id values for any of these two fields in the filter. We will take advantage of other options for related models, which will later allow us to filter the related models by field. This way, we will understand the different customizations available.</p><p>The <code class="literal">ordering_fields</code> attribute specifies two field names for the tuple of string, and therefore, the client will be able to order the results by either <code class="literal">name</code> or <code class="literal">release_date</code>.</p><p>Add the following highlighted lines to the <code class="literal">PlayerList</code> class declared in the <code class="literal">views.py</code> file. The new lines specify the fields to be used in the filter, search, and ordering features. The code file for the sample is included in the <code class="literal">restful_python_chapter_04_02</code> folder:</p><pre class="programlisting">class PlayerList(generics.ListCreateAPIView): 
    queryset = Player.objects.all() 
    serializer_class = PlayerSerializer 
    name = 'player-list' 
    <strong>filter_fields = ( 
        'name',  
        'gender',  
        )</strong>
<strong>search_fields = ( 
        '^name', 
        ) 
    ordering_fields = ( 
        'name', 
        )</strong>
</pre><p>Add the following lines to create the new <code class="literal">PlayerScoreFilter</code> class in the <code class="literal">views.py</code> file but before the declaration of the <code class="literal">PlayerScoreList</code> class. The code file for the sample is included in the <code class="literal">restful_python_chapter_04_02</code> folder:</p><pre class="programlisting">class PlayerScoreFilter(filters.FilterSet): 
    min_score = NumberFilter( 
        name='score', lookup_expr='gte') 
    max_score = NumberFilter( 
        name='score', lookup_expr='lte') 
    from_score_date = DateTimeFilter( 
        name='score_date', lookup_expr='gte') 
    to_score_date = DateTimeFilter( 
        name='score_date', lookup_expr='lte') 
    player_name = AllValuesFilter( 
        name='player__name') 
    game_name = AllValuesFilter( 
        name='game__name') 
 
    class Meta: 
        model = PlayerScore 
        fields = ( 
            'score', 
            'from_score_date', 
            'to_score_date', 
            'min_score', 
            'max_score', 
            #player__name will be accessed as player_name 
            'player_name', 
            #game__name will be accessed as game_name 
            'game_name', 
            ) 
</pre><p>The <code class="literal">PlayerScoreFilter</code> is a subclass of the <code class="literal">rest_framework.filters.FilterSet</code> class. We want to customize settings for the fields that we will use for filtering in the <code class="literal">PlayerScoreList</code> class-based view, and therefore, we created the new <code class="literal">PlayerScoreFilter</code> class. The class declares the following six class attributes:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">min_score</code>: It is a <code class="literal">django_filters.NumberFilter</code> instance that allows the client to filter the player scores whose <code class="literal">score</code> numeric value is greater than or equal to the specified number. The value for <code class="literal">name</code> indicates the field to which the numeric filter is applied, <code class="literal">'score'</code>, and the <code class="literal">lookup_expr</code> value indicates the lookup expression, <code class="literal">'gte'</code>, which means greater than or equal to.</li><li class="listitem" style="list-style-type: disc"><code class="literal">max_score</code>: It is a <code class="literal">django_filters.NumberFilter</code> instance that allows the client to filter the player scores whose <code class="literal">score</code> numeric value is less than or equal to the specified number. The value for <code class="literal">name</code> indicates the field to which the numeric filter is applied, <code class="literal">'score'</code>, and the <code class="literal">lookup_expr</code> value indicates the lookup expression, <code class="literal">'lte'</code>, which means less than or equal to.</li><li class="listitem" style="list-style-type: disc"><code class="literal">from_score_date</code>: It is a <code class="literal">django_filters.DateTimeFilter</code> instance that allows the client to filter the player scores whose <code class="literal">score_datedatetime</code> value is greater than or equal to the specified <code class="literal">datetime</code> value. The value for <code class="literal">name</code> indicates the field to which the datetime filter is applied, <code class="literal">'score_date'</code>, and the <code class="literal">lookup_expr</code> value indicates the lookup expression, <code class="literal">'gte'</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">to_score_date</code>: It is a <code class="literal">django_filters.DateTimeFilter</code> instance that allows the client to filter the player scores whose <code class="literal">score_datedatetime</code> value is less than or equal to the specified <code class="literal">datetime</code> value. The value for <code class="literal">name</code> indicates the field to which the <code class="literal">datetime</code> filter is applied, <code class="literal">'score_date'</code>,and the <code class="literal">lookup_expr</code> value indicates the lookup expression, <code class="literal">'lte'</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">player_name</code>: It is a <code class="literal">django_filters.AllValuesFilte</code>r: It is an instance that allows the client to filter the player scores whose player's name matches the specified string value. The value for <code class="literal">name</code> indicates the field to which the filter is applied, <code class="literal">'player__name'</code>. Note that the value has a double underscore (<code class="literal">__</code>) and you can read it as the <code class="literal">name</code> field for the <code class="literal">player</code> model or simply replace the double underscore with a dot and read <code class="literal">player.name</code>. The name uses Django's double underscore syntax. However, we don't want the client to use <code class="literal">player__name</code> to specify the filter for the player's name. Thus, the instance is stored in the class attribute named <code class="literal">player_name</code>, with just a single underscore between player and name. The browsable API will display a dropdown with all the possible values for the player's name to use as a filter. The dropdown will only include the players' names that have registered scores because we used the <code class="literal">AllValuesFilter</code> class.</li><li class="listitem" style="list-style-type: disc"><code class="literal">game_name</code>: This is a <code class="literal">django_filters.AllValuesFilter</code> instance that allows the client to filter the player scores whose game's name matches the specified string value. The value for <code class="literal">name</code> indicates the field on which the filter is applied, <code class="literal">'game__name'</code>. The name uses the previously explained Django's double underscore syntax. As happened with <code class="literal">player_name</code>, we don't want the client to use <code class="literal">game__name</code> to specify the filter for the game's name, and therefore, we stored the instance in the class attribute named <code class="literal">game_name</code>, with just a single underscore between game and name. The browsable API will display a dropdown with all the possible values for the game's name to use as a filter. The dropdown will only include the game's names that have registered scores because we used the <code class="literal">AllValuesFilter</code> class.</li></ul></div><p>In addition, the <code class="literal">PlayerScoreFilter</code> class declares a <code class="literal">Meta</code> inner class that declares two attributes: <code class="literal">model</code> and <code class="literal">fields</code>. The <code class="literal">model</code> attribute specifies the model related to the filter set, that is, the <code class="literal">PlayerScore</code> class. The <code class="literal">fields</code> attribute specifies a tuple of string whose values indicate the field names and filter names that we want to include in the filters for the related model. We included <code class="literal">'scores'</code> and the names for all the previously declared filters. The string <code class="literal">'scores'</code> refers to the <code class="literal">score</code> field name and we want to apply the default numeric filter that will be built under the hoods to allow the client to filter by an exact match on the <code class="literal">score</code> field.</p><p>Finally, add the following highlighted lines to the <code class="literal">PlayerScoreList</code> class declared in the <code class="literal">views.py</code> file. The code file for the sample is included in the <code class="literal">restful_python_chapter_04_02</code> folder:</p><pre class="programlisting">class PlayerScoreList(generics.ListCreateAPIView): 
    queryset = PlayerScore.objects.all() 
    serializer_class = PlayerScoreSerializer 
    name = 'playerscore-list' 
    filter_class = PlayerScoreFilter 
    ordering_fields = ( 
        'score', 
        'score_date', 
        ) 
</pre><p>The <code class="literal">filter_class</code> attribute specifies the <code class="literal">FilterSet</code> subclass that we want to use for this class-based view: <code class="literal">PlayerScoreFilter</code>. In addition, we specified the two field names that the client will be able to use for ordering in the <code class="literal">ordering_fields</code> tuple of string.</p></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec50"/>Testing filtering, searching, and ordering</h1></div></div></div><p>Now, we can launch Django's development server to compose and send HTTP requests. Execute any of the following two commands based on your needs to access the API in other devices or computers connected to your LAN. Remember that we analyzed the difference between them in <a class="link" href="ch01.html" title="Chapter 1. Developing RESTful APIs with Django">Chapter 1</a>, <em>Developing RESTful APIs with Django</em>.</p><pre class="programlisting">
<strong>python manage.py runserver</strong>
<strong>python manage.py runserver 0.0.0.0:8000</strong>
</pre><p>After we run any of the previous commands, the development server will start listening at port <code class="literal">8000</code>:</p><p>Now, we will compose and send an HTTP request to retrieve all the game categories whose name matches <code class="literal">3D RPG</code>:</p><pre class="programlisting">
<strong>http :8000/game-categories/?name=3D+RPG</strong>
</pre><p>The following is the equivalent <code class="literal">curl</code> command:</p><pre class="programlisting">
<strong>curl -iX GET :8000/game-categories/?name=3D+RPG</strong>
</pre><p>The following lines show a sample response with the single game category whose name matches the specified name in the filter. The following lines only show the JSON body without the headers:</p><pre class="programlisting">
<strong>{</strong>
<strong>    "count": 1, </strong>
<strong>    "next": null, </strong>
<strong>    "previous": null, </strong>
<strong>    "results": [</strong>
<strong>        {</strong>
<strong>            "games": [</strong>
<strong>                "http://localhost:8000/games/2/", </strong>
<strong>                "http://localhost:8000/games/15/", </strong>
<strong>                "http://localhost:8000/games/3/", </strong>
<strong>                "http://localhost:8000/games/16/"</strong>
<strong>            ], </strong>
<strong>            "name": "3D RPG", </strong>
<strong>            "pk": 3, </strong>
<strong>            "url": "http://localhost:8000/game-categories/3/"</strong>
<strong>        }</strong>
<strong>    ]</strong>
<strong>}</strong>
</pre><p>We will compose and send an HTTP request to retrieve all the games whose related category id is equal to <code class="literal">3</code> and the value for the played field is equal to <code class="literal">True</code>. We want to sort the results by <code class="literal">release_date</code> in descending order, and therefore, we specify <code class="literal">-release_date</code> in the value for <code class="literal">ordering</code>. The hyphen (<code class="literal">-</code>) before the field name specifies the ordering feature to use descending order instead of the default ascending order. Make sure you replace <code class="literal">3</code> with the pk value of the previously retrieved game category named <code class="literal">3D RPG</code>. The played field is a <code class="literal">bool</code> field, and therefore, we have to use Python-valid <code class="literal">bool</code> values (<code class="literal">True</code> and <code class="literal">False</code>) when specifying the desired values for the <code class="literal">bool</code> field in the filter:</p><pre class="programlisting">
<strong>http ':8000/games/?game_category=3&amp;played=True&amp;ordering=-release_date'</strong>
</pre><p>The following is the equivalent <code class="literal">curl</code> command:</p><pre class="programlisting">
<strong>curl -iX GET ':8000/games/?game_category=3&amp;played=True&amp;ordering=-release_date'</strong>
</pre><p>The following lines show a sample response with the two games that match the specified criteria in the filter. The following lines only show the JSON body without the headers:</p><pre class="programlisting">
<strong>{</strong>
<strong>    "count": 2, </strong>
<strong>    "next": null, </strong>
<strong>    "previous": null, </strong>
<strong>    "results": [</strong>
<strong>        {</strong>
<strong>            "game_category": "3D RPG", </strong>
<strong>            "name": "PvZ Garden Warfare 4", </strong>
<strong>            "owner": "superuser", </strong>
<strong>            "played": true, </strong>
<strong>            "release_date": "2016-06-21T03:02:00.776594Z", </strong>
<strong>            "url": "http://localhost:8000/games/2/"</strong>
<strong>        }, </strong>
<strong>        {</strong>
<strong>            "game_category": "3D RPG", </strong>
<strong>            "name": "Superman vs Aquaman", </strong>
<strong>            "owner": "superuser", </strong>
<strong>            "played": true, </strong>
<strong>            "release_date": "2016-06-21T03:02:00.776594Z", </strong>
<strong>            "url": "http://localhost:8000/games/3/"</strong>
<strong>        }</strong>
<strong>    ]</strong>
<strong>}</strong>
</pre><p>In the <code class="literal">GameList</code> class, we specified <code class="literal">'game_category'</code> as one of the strings in the <code class="literal">filter_fields</code> tuple of string. Thus, we had to use the game category id in the filter. Now, we will use a filter on the game's name related to a registered score. The <code class="literal">PlayerScoreFilter</code> class provides us a filter to the name of the related game in <code class="literal">game_name</code>. We will combine the filter with another filter on the player's name related to a registered score. The <code class="literal">PlayerScoreFilter</code> class provides us a filter to the name of the related player in <code class="literal">player_name</code>. Both conditions specified in the criteria must be met, and therefore, the filters are combined with the <code class="literal">AND</code> operator:</p><pre class="programlisting">
<strong>http ':8000/player-scores/?player_name=Kevin&amp;game_name=Superman+vs+Aquaman'</strong>
</pre><p>The following is the equivalent <code class="literal">curl</code> command:</p><pre class="programlisting">
<strong>curl -iX GET ':8000/player-scores/?player_name=Kevin&amp;game_name=Superman+vs+Aquaman'</strong>
</pre><p>The following lines show a sample response with the score that matches the specified criteria in the filters. The following lines only show the JSON body without the headers:</p><pre class="programlisting">{ 
    "count": 1,  
    "next": null,  
    "previous": null,  
    "results": [ 
        { 
            "game": "Superman vs Aquaman",  
            "pk": 5,  
            "player": "Kevin",  
            "score": 123200,  
            "score_date": "2016-06-22T03:02:00.776594Z",  
            "url": "http://localhost:8000/player-scores/5/" 
        } 
    ] 
} 
</pre><p>We will compose and send an HTTP request to retrieve all the scores that match the following criteria. The results will be ordered by <code class="literal">score_date</code> in descending order.</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">score</code> value is between 30,000 and 150,000</li><li class="listitem" style="list-style-type: disc">The <code class="literal">score_date</code> is between 2016-06-21 and 2016-06-22</li></ul></div><pre class="programlisting">
<strong>http ':8000/player-scores/?score=&amp;from_score_date=2016-06-01&amp;to_score_date=2016-06-28&amp;min_score=30000&amp;max_score=150000&amp;ordering=-score_date'</strong>
</pre><p>The following is the equivalent <code class="literal">curl</code> command:</p><pre class="programlisting">
<strong>curl -iX GET ':8000/player-scores/?score=&amp;from_score_date=2016-06-01&amp;to_score_date=2016-06-28&amp;min_score=30000&amp;max_score=150000&amp;ordering=-score_date'</strong>
</pre><p>The following lines show a sample response with the three games that match the specified criteria in the filters. We overrode the default ordering specified in the model with the specified ordering in the request. The following lines only show the JSON body without the headers:</p><pre class="programlisting">
<strong>{</strong>
<strong>    "count": 3, </strong>
<strong>    "next": null, </strong>
<strong>    "previous": null, </strong>
<strong>    "results": [</strong>
<strong>        {</strong>
<strong>            "game": "Superman vs Aquaman", </strong>
<strong>            "pk": 5, </strong>
<strong>            "player": "Kevin", </strong>
<strong>            "score": 123200, </strong>
<strong>            "score_date": "2016-06-22T03:02:00.776594Z", </strong>
<strong>            "url": "http://localhost:8000/player-scores/5/"</strong>
<strong>        }, </strong>
<strong>        {</strong>
<strong>            "game": "PvZ Garden Warfare 4", </strong>
<strong>            "pk": 4, </strong>
<strong>            "player": "Brandon", </strong>
<strong>            "score": 85125, </strong>
<strong>            "score_date": "2016-06-22T01:02:00.776594Z", </strong>
<strong>            "url": "http://localhost:8000/player-scores/4/"</strong>
<strong>        }, </strong>
<strong>        {</strong>
<strong>            "game": "PvZ Garden Warfare 4", </strong>
<strong>            "pk": 3, </strong>
<strong>            "player": "Brandon", </strong>
<strong>            "score": 35000, </strong>
<strong>            "score_date": "2016-06-21T03:02:00.776594Z", </strong>
<strong>            "url": "http://localhost:8000/player-scores/3/"</strong>
<strong>        }</strong>
<strong>    ]</strong>
<strong>}</strong>
</pre><div><div><h3 class="title"><a id="tip33"/>Tip</h3><p>In the preceding requests, all the responses didn't have more than one page. In case the response requires more than one page, the values for the <code class="literal">previous</code> and <code class="literal">next</code> keys will display the URLs that include the combination of the filters, search, ordering and pagination.</p></div></div><p>We will compose and send an HTTP request to retrieve all the games whose <code class="literal">name</code> starts with <code class="literal">'S'</code>. We will use the search feature that we configured to restrict the search behavior to a starts-with match on the <code class="literal">name</code> field:</p><pre class="programlisting">
<strong>http ':8000/games/?search=S'</strong>
</pre><p>The following is the equivalent <code class="literal">curl</code> command:</p><pre class="programlisting">
<strong>curl -iX GET ':8000/games/?search=S'</strong>
</pre><p>The following lines show a sample response with the two games that match the specified search criteria, that is, those games whose name starts with <code class="literal">'S'</code>. The following lines only show the JSON body without the headers:</p><pre class="programlisting">
<strong>{</strong>
<strong>    "count": 2, </strong>
<strong>    "next": null, </strong>
<strong>    "previous": null, </strong>
<strong>    "results": [</strong>
<strong>        {</strong>
<strong>            "game_category": "2D mobile arcade", </strong>
<strong>            "name": "Scribblenauts Unlimited", </strong>
<strong>            "owner": "superuser", </strong>
<strong>            "played": false, </strong>
<strong>            "release_date": "2016-06-21T03:02:00.776594Z", </strong>
<strong>            "url": "http://localhost:8000/games/7/"</strong>
<strong>        }, </strong>
<strong>        {</strong>
<strong>            "game_category": "3D RPG", </strong>
<strong>            "name": "Superman vs Aquaman", </strong>
<strong>            "owner": "superuser", </strong>
<strong>            "played": true, </strong>
<strong>            "release_date": "2016-06-21T03:02:00.776594Z", </strong>
<strong>            "url": "http://localhost:8000/games/3/"</strong>
<strong>        }</strong>
<strong>    ]</strong>
<strong>}</strong>
</pre><div><div><h3 class="title"><a id="tip34"/>Tip</h3><p>We can change the search and ordering parameter's default names: <code class="literal">'search'</code> and <code class="literal">'ordering'</code>. We just need to specify the desired names in the <code class="literal">SEARCH_PARAM</code> and the <code class="literal">ORDERING_PARAM</code> settings.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec51"/>Filtering, searching, and ordering in the Browsable API</h1></div></div></div><p>We can take advantage of the browsable API to easily test filter, search, and order features through a web browser. Open a web browser and enter <code class="literal">http://localhost:8000/player-scores/</code>. In case you use another computer or device to run the browser, replace <code class="literal">localhost</code> with the IP of the computer that is running the Django development server. The browsable API will compose and send a <code class="literal">GET</code> request to <code class="literal">/player-scores/</code> and will display the results of its execution, that is, the headers and the JSON player scores list. You will notice that there is a new <strong>Filters</strong> button located on the left-hand side of the <strong>OPTIONS</strong> button.</p><p>Click on <strong>Filters</strong> and the browsable API will display the <strong>Filters</strong> dialog box with the appropriate controls for each filter that you can apply below <strong>Field Filters</strong> and the different ordering options below <strong>Ordering</strong>. The following screenshot shows the <strong>Filters</strong> dialog box:</p><p>
</p><div><img src="img/image_04_001.jpg" alt="Filtering, searching, and ordering in the Browsable API"/></div><p>
</p><p>Both the <strong>Player name</strong> and <strong>Game name</strong> dropdowns will only include the related player's and game's names that have registered scores because we used the <code class="literal">AllValuesFilter</code> class for both filters. After we enter all the values for the filters, we can select the desired ordering option or click <strong>Submit</strong>. The browsable API will compose and send the appropriate HTTP request and will render a web page with the results of its execution. The results will include the HTTP request that was made to the Django server. The following screenshot shows an example of the result of executing the next request, that is, the request we built using the browsable API:</p><pre class="programlisting">
<strong>GET /player-scores/?score=&amp;from_score_date=&amp;to_score_date=&amp;min_score=30000&amp;max_score=40000&amp;player_name=Brandon&amp;game_name=PvZ+Garden+Warfare+4</strong>
</pre><p>
</p><div><img src="img/image_04_002.jpg" alt="Filtering, searching, and ordering in the Browsable API"/></div><p>
</p></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec52"/>Setting up unit tests</h1></div></div></div><p>First, we will install the <code class="literal">coverage</code> and <code class="literal">django-nose</code> packages in our virtual environment. We will make the necessary configurations to use the <code class="literal">django_nose.NoseTestRunner</code> class to run all the tests we code and we will use the necessary configurations to improve the accuracy of the test coverage measurements.</p><p>Make sure that you quit Django's development server. Remember that you just need to press <strong>Ctrl</strong> + <strong>C</strong> in the terminal or the Command Prompt window in which it is running. We just need to run the following command to install the <code class="literal">coverage</code> package:</p><pre class="programlisting">
<strong>pip install coverage</strong>
</pre><p>The last few lines of the output indicate that the <code class="literal">django-nose</code> package has been successfully installed:</p><pre class="programlisting">
<strong>Collecting coverage</strong>
<strong>  Downloading coverage-4.1.tar.gz</strong>
<strong>Installing collected packages: coverage</strong>
<strong>  Running setup.py install for coverage</strong>
<strong>Successfully installed coverage-4.1</strong>
</pre><p>We just need to run the following command to install the <code class="literal">django-nose</code> package:</p><pre class="programlisting">
<strong>pip install django-nose</strong>
</pre><p>The last few lines of the output indicate that the <code class="literal">django-nose</code> package has been successfully installed.</p><pre class="programlisting">
<strong>Collecting django-nose</strong>
<strong>  Downloading django_nose-1.4.4-py2.py3-none-any.whl</strong>
<strong>Collecting nose&gt;=1.2.1 (from django-nose)</strong>
<strong>  Downloading nose-1.3.7-py3-none-any.whl</strong>
<strong>Installing collected packages: nose, django-nose</strong>
<strong>Successfully installed django-nose-1.4.4 nose-1.3.7</strong>
</pre><p>Add <code class="literal">'django_nose'</code> to the installed apps in the <code class="literal">settings.py</code> file, specifically, to the <code class="literal">INSTALLED_APPS</code> string list. The following code shows the lines we need to add as highlighted code. The code file for the sample is included in the <code class="literal">restful_python_chapter_04_03</code> folder:</p><pre class="programlisting">INSTALLED_APPS = [ 
    'django.contrib.admin', 
    'django.contrib.auth', 
    'django.contrib.contenttypes', 
    'django.contrib.sessions', 
    'django.contrib.messages', 
    'django.contrib.staticfiles', 
    # Django REST Framework 
    'rest_framework', 
    # Games application 
    'games.apps.GamesConfig', 
    # Crispy forms 
    'crispy_forms', 
    # Django nose 
    'django_nose', 
] 
</pre><p>Open the <code class="literal">gamesapi/settings.py</code> file and add the following lines to configure the <code class="literal">django_nose.NoseTestRunner</code> class as our test runner and specify the default command-line options that we will use when we run our tests. The code file for the sample is included in the <code class="literal">restful_python_chapter_04_03</code> folder:</p><pre class="programlisting"># We want to use nose to run all the tests 
TEST_RUNNER = 'django_nose.NoseTestSuiteRunner' 
 
# We want nose to measure coverage on the games app 
NOSE_ARGS = [ 
    '--with-coverage', 
    '--cover-erase', 
    '--cover-inclusive', 
    '--cover-package=games', 
] 
</pre><p>The <code class="literal">NOSE_ARGS</code> settings specify the following command-line options for the nose test suite runner and for coverage:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">--with-coverage</code>: This option specifies that we always want to generate a test coverage report.</li><li class="listitem" style="list-style-type: disc"><code class="literal">--cover-erase</code>: This option makes sure the the test runner deletes the coverage test results from the previous run.</li><li class="listitem" style="list-style-type: disc"><code class="literal">--cover-inclusive</code>: This option includes all the Python files under the working directory in the coverage report. This way, we make sure that we discover holes in test coverage when we don't import all the files in our test suite. We will create a test suite that won't import all the files, and therefore, this option is very important to have an accurate test coverage report.</li><li class="listitem" style="list-style-type: disc"><code class="literal">--cover-package=games</code>: This option indicates the module that we want to cover: <code class="literal">games</code>.</li></ul></div><p>Finally, create a new text file named <code class="literal">.coveragerc</code> within the <code class="literal">gamesapi</code> root folder with the following content:</p><pre class="programlisting">[run] 
omit = *migrations* 
</pre><p>This way, the <code class="literal">coverage</code> utility won't take into account many things related to the generated migrations when providing us with the test coverage report. We will have a more accurate test coverage report with this settings file.</p></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec53"/>Writing a first round of unit tests</h1></div></div></div><p>Now, we will write the first round of unit tests. Specifically, we will write unit tests related to the game category class-based views: <code class="literal">GameCategoryList</code> and <code class="literal">GameCategoryDetail</code>. Open the existing <code class="literal">games/test.py</code> file and replace the existing code with the following lines that declare many <code class="literal">import</code> statements and the <code class="literal">GameCategoryTests</code> class. The code file for the sample is included in the <code class="literal">restful_python_chapter_04_04</code> folder, as shown:</p><pre class="programlisting">from django.test import TestCase 
from django.core.urlresolvers import reverse 
from django.utils.http import urlencode 
from rest_framework import status 
from rest_framework.test import APITestCase 
from games.models import GameCategory 
 
 
class GameCategoryTests(APITestCase): 
   <strong> def create_game_category(self, name):</strong> 
        url = reverse('gamecategory-list') 
        data = {'name': name} 
        response = self.client.post(url, data, format='json') 
        return response 
 
   <strong> def test_create_and_retrieve_game_category(self):</strong> 
        """ 
        Ensure we can create a new GameCategory and then retrieve it 
        """ 
        new_game_category_name = 'New Game Category' 
        response = self.create_game_category(new_game_category_name) 
        self.assertEqual(response.status_code, status.HTTP_201_CREATED) 
        self.assertEqual(GameCategory.objects.count(), 1) 
        self.assertEqual( 
            GameCategory.objects.get().name,  
            new_game_category_name) 
        print("PK {0}".format(GameCategory.objects.get().pk)) 
</pre><p>The <code class="literal">GameCategoryTests</code> class is a subclass of <code class="literal">rest_framework.test.APITestCase</code>. The class declares the <code class="literal">create_game_category</code> method that receives the desired <code class="literal">name</code> for the new game category as an argument. The method builds the URL and the data dictionary to compose and send an HTTP <code class="literal">POST</code> method to the view associated with the <code class="literal">gamecategory-list</code> view name and returns the response generated by this request. The code uses <code class="literal">self.client</code> to access the <code class="literal">APIClient</code> instance that allows us to easily compose and send HTTP requests for testing. In this case, the code calls the <code class="literal">post</code> method with the built <code class="literal">url</code>, the <code class="literal">data</code> dictionary, and the desired format for the data-<code class="literal">'json'</code>. Many test methods will call the <code class="literal">create_game_category</code> method to create a game category and then compose and send other HTTP requests to the API.</p><p>The <code class="literal">test_create_and_retrieve_game_category</code> method tests whether we can create a new <code class="literal">GameCategory</code> and then retrieve it. The method calls the <code class="literal">create_game_category</code> method explained earlier and then uses <code class="literal">assertEqual</code> to check for the following expected results:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">status_code</code> for the response is HTTP 201 Created (<code class="literal">status.HTTP_201_CREATED</code>)</li><li class="listitem" style="list-style-type: disc">The total number of <code class="literal">GameCategory</code> objects retrieved from the database is <code class="literal">1</code></li></ul></div><p>Add the following methods to the <code class="literal">GameCategoryTests</code> class we created in the <code class="literal">games/test.py</code> file. The code file for the sample is included in the <code class="literal">restful_python_chapter_04_04</code> folder:</p><pre class="programlisting">
<strong>    def test_create_duplicated_game_category(self):</strong> 
        """ 
        Ensure we can create a new GameCategory. 
        """ 
        url = reverse('gamecategory-list') 
        new_game_category_name = 'New Game Category' 
        data = {'name': new_game_category_name} 
        response1 = self.create_game_category(new_game_category_name) 
        self.assertEqual( 
            response1.status_code,  
            status.HTTP_201_CREATED) 
        response2 = self.create_game_category(new_game_category_name) 
        self.assertEqual( 
            response2.status_code,  
            status.HTTP_400_BAD_REQUEST) 
 
  <strong>  def test_retrieve_game_categories_list(self):</strong> 
        """ 
        Ensure we can retrieve a game cagory 
        """ 
        new_game_category_name = 'New Game Category' 
        self.create_game_category(new_game_category_name) 
        url = reverse('gamecategory-list') 
        response = self.client.get(url, format='json') 
        self.assertEqual( 
            response.status_code,  
            status.HTTP_200_OK) 
        self.assertEqual( 
            response.data['count'], 
            1) 
        self.assertEqual( 
            response.data['results'][0]['name'], 
            new_game_category_name) 
 
    <strong>def test_update_game_category(self):</strong> 
        """ 
        Ensure we can update a single field for a game category 
        """ 
        new_game_category_name = 'Initial Name' 
        response = self.create_game_category(new_game_category_name) 
        url = reverse( 
            'gamecategory-detail',  
            None,  
            {response.data['pk']}) 
        updated_game_category_name = 'Updated Game Category Name' 
        data = {'name': updated_game_category_name} 
        patch_response = self.client.patch(url, data, format='json') 
        self.assertEqual( 
            patch_response.status_code,  
            status.HTTP_200_OK) 
        self.assertEqual( 
            patch_response.data['name'], 
            updated_game_category_name) 
 
    <strong>def test_filter_game_category_by_name(self):</strong> 
        """ 
        Ensure we can filter a game category by name 
        """ 
        game_category_name1 = 'First game category name' 
        self.create_game_category(game_category_name1) 
        game_caregory_name2 = 'Second game category name' 
        self.create_game_category(game_caregory_name2) 
        filter_by_name = { 'name' : game_category_name1 } 
        url = '{0}?{1}'.format( 
            reverse('gamecategory-list'), 
            urlencode(filter_by_name)) 
        response = self.client.get(url, format='json') 
        self.assertEqual( 
            response.status_code,  
            status.HTTP_200_OK) 
        self.assertEqual( 
            response.data['count'], 
            1) 
        self.assertEqual( 
            response.data['results'][0]['name'], 
            game_category_name1) 
</pre><p>We added the following methods that start whose name start with the <code class="literal">test_</code> prefix:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">test_create_duplicated_game_category</code>: Tests whether the unique constraints don't make it possible for us to create two game categories with the same name. The second time we compose and send an HTTP POST request with a duplicate category name, we must receive an <code class="literal">HTTP 400 Bad Request</code> status code (<code class="literal">status.HTTP_400_BAD_REQUEST</code>)</li><li class="listitem" style="list-style-type: disc"><code class="literal">test_retrieve_game_categories_list</code>: Tests whether we can retrieve a specific game category by its primary key or id</li><li class="listitem" style="list-style-type: disc"><code class="literal">test_update_game_category</code>: Tests whether we can update a single field for a game category</li><li class="listitem" style="list-style-type: disc"><code class="literal">test_filter_game_category_by_name</code>: Tests whether we can filter a game category by name</li></ul></div><div><div><h3 class="title"><a id="tip35"/>Tip</h3><p>Note that each test that requires a specific condition in the database must execute all the necessary code for the database to be in this specific condition. For example, in order to update an existing game category, first we must create a new game category and then we can update it. Each test method will be executed without data from the previously executed test methods in the database, that is, each test will run with a database cleaned of data from previous tests.</p></div></div><p>The last three methods in the preceding list check the data included in the response JSON body by inspecting the <code class="literal">data</code> attribute for the response. For example, the first line checks whether the value for <code class="literal">count</code> is equal to <code class="literal">1</code> and the next lines check whether the <code class="literal">name</code> key for the first element in the <code class="literal">results</code> array is equal to the value hold in the <code class="literal">new_game_category_name</code> variable:</p><pre class="programlisting">self.assertEqual(response.data['count'], 1) 
self.assertEqual( 
    response.data['results'][0]['name'], 
    new_game_category_name) 
</pre><p>The <code class="literal">test_filter_game_category_by_name</code> method calls the <code class="literal">django.utils.http.urlencode</code> function to generate an encoded URL from the <code class="literal">filter_by_name</code> dictionary that specifies the field name and the value we want to use to filter the retrieved data. The following lines show the code that generates the URL and saves it in the <code class="literal">url</code> variable. If <code class="literal">game_cagory_name1</code> is <code class="literal">'First game category name'</code>, the result of the call to the <code class="literal">urlencode</code> function will be <code class="literal">'name=First+game+category+name'</code>.</p><pre class="programlisting">filter_by_name = { 'name' : game_category_name1 } 
url = '{0}?{1}'.format( 
    reverse('gamecategory-list'), 
    urlencode(filter_by_name)) 
</pre></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec54"/>Running unit tests and checking testing coverage</h1></div></div></div><p>Now, run the following command to create a test database, run all the migrations and use the Django nose test running to execute all the tests we created. The test runner will execute all the methods for our <code class="literal">GameCategoryTests</code> class that start with the <code class="literal">test_</code> prefix and will display the results.</p><div><div><h3 class="title"><a id="tip36"/>Tip</h3><p>The tests won't make changes to the database we have been using when working on the API.</p></div></div><p>Remember that we configured many default command-line options that will be used without the need to enter them in our command-line. Run the following command within the same virtual environment we have been using. We will use the <code class="literal">-v 2</code> option to use the verbosity level 2 because we want to check all the things that the test runner is doing:</p><pre class="programlisting">
<strong>python manage.py test -v 2</strong>
</pre><p>The following lines show the sample output:</p><pre class="programlisting">
<strong>nosetests --with-coverage --cover-package=games --cover-erase --cover-inclusive -v --verbosity=2</strong>
<strong>Creating test database for alias 'default' ('test_games')...</strong>
<strong>Operations to perform:</strong>
<strong>  Synchronize unmigrated apps: django_nose, staticfiles, crispy_forms, messages, rest_framework</strong>
<strong>  Apply all migrations: games, admin, auth, contenttypes, sessions</strong>
<strong>Synchronizing apps without migrations:</strong>
<strong>  Creating tables...</strong>
<strong>    Running deferred SQL...</strong>
<strong>Running migrations:</strong>
<strong>  Rendering model states... DONE</strong>
<strong>  Applying contenttypes.0001_initial... OK</strong>
<strong>  Applying auth.0001_initial... OK</strong>
<strong>  Applying admin.0001_initial... OK</strong>
<strong>  Applying admin.0002_logentry_remove_auto_add... OK</strong>
<strong>  Applying contenttypes.0002_remove_content_type_name... OK</strong>
<strong>  Applying auth.0002_alter_permission_name_max_length... OK</strong>
<strong>  Applying auth.0003_alter_user_email_max_length... OK</strong>
<strong>  Applying auth.0004_alter_user_username_opts... OK</strong>
<strong>  Applying auth.0005_alter_user_last_login_null... OK</strong>
<strong>  Applying auth.0006_require_contenttypes_0002... OK</strong>
<strong>  Applying auth.0007_alter_validators_add_error_messages... OK</strong>
<strong>  Applying games.0001_initial... OK</strong>
<strong>  Applying games.0002_auto_20160623_2131... OK</strong>
<strong>  Applying games.0003_game_owner... OK</strong>
<strong>  Applying sessions.0001_initial... OK</strong>
<strong>Ensure we can create a new GameCategory and then retrieve it ... ok</strong>
<strong>Ensure we can create a new GameCategory. ... ok</strong>
<strong>Ensure we can filter a game category by name ... ok</strong>
<strong>Ensure we can retrieve a game cagory ... ok</strong>
<strong>Ensure we can update a single field for a game category ... ok</strong>
<strong>Name                   Stmts   Miss  Cover</strong>
<strong>------------------------------------------</strong>
<strong>games.py                   0      0   100%</strong>
<strong>games/admin.py             1      1     0%</strong>
<strong>games/apps.py              3      3     0%</strong>
<strong>games/models.py           36     35     3%</strong>
<strong>games/pagination.py        3      0   100%</strong>
<strong>games/permissions.py       6      3    50%</strong>
<strong>games/serializers.py      45      0   100%</strong>
<strong>games/urls.py              3      0   100%</strong>
<strong>games/views.py            91      2    98%</strong>
<strong>------------------------------------------</strong>
<strong>TOTAL                    188     44    77%</strong>
<strong>------------------------------------------</strong>
<strong>Ran 5 tests in 0.143s</strong>
<strong>OK</strong>
<strong>Destroying test database for alias 'default' ('test_games')...</strong>
</pre><p>The output provides the details indicating that the test runner executed 5 tests and all of them passed. After the details about the migrations are executed, the output displays the comments we included for each method in the <code class="literal">GameCategoryTests</code> class that started with the <code class="literal">test_</code> prefix and represented a test to be executed. The following list shows the description included in the comments and the method that they represent:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Ensures we can create a new GameCategory and then retrieve it: <code class="literal">test_create_and_retrieve_game_category</code>.</li><li class="listitem" style="list-style-type: disc">Ensures we can create a new GameCategory: <code class="literal">test_create_duplicated_game_category</code>.</li><li class="listitem" style="list-style-type: disc">Ensures we can filter a game category by name: <code class="literal">test_retrieve_game_categories_list</code>.</li><li class="listitem" style="list-style-type: disc">Ensures we can retrieve a game cagory: <code class="literal">test_update_game_category</code>.</li><li class="listitem" style="list-style-type: disc">Ensures we can update a single field for a game category: <code class="literal">test_filter_game_category_by_name</code>.</li></ul></div><p>The test code coverage measurement report provided by the <code class="literal">coverage</code> package uses the code analysis tools and the tracing hooks included in the Python standard library to determine which lines of code are executable and which of these lines have been executed. The report provides a table with the following columns:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Name</code>: The Python module name.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Stmts</code>: The count of executable statements for the Python module.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Miss</code>: The number of executable statements missed, that is, the ones that weren't executed.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Cover</code>: The coverage of executable statements, expressed as a percentage.</li></ul></div><p>We definitely have a very low coverage for <code class="literal">models.py</code> based on the measurements shown in the report. In fact, we just wrote a few tests related to the <code class="literal">GameCategory</code> model, and therefore, it makes sense that the coverage is really low for the models:</p><p>We can run the <code class="literal">coverage</code> command with the <code class="literal">-m</code> command-line option to display the line numbers of the missing statements in a new <code class="literal">Missing</code> column.</p><pre class="programlisting">
<strong>coverage report -m</strong>
</pre><p>The command will use the information from the last execution and will display the missing statements. The next lines show a sample output that correspond to the previous execution of the unit tests:</p><pre class="programlisting">
<strong>Name                   Stmts   Miss  Cover   Missing</strong>
<strong>----------------------------------------------------</strong>
<strong>games/__init__.py          0      0   100%</strong>
<strong>games/admin.py             1      1     0%   1</strong>
<strong>games/apps.py              3      3     0%   1-5</strong>
<strong>games/models.py           36     35     3%   1-10, 14-70</strong>
<strong>games/pagination.py        3      0   100%</strong>
<strong>games/permissions.py       6      3    50%   6-9</strong>
<strong>games/serializers.py      45      0   100%</strong>
<strong>games/tests.py            55      0   100%</strong>
<strong>games/urls.py              3      0   100%</strong>
<strong>games/views.py            91      2    98%   83, 177</strong>
<strong>----------------------------------------------------</strong>
<strong>TOTAL                    243     44    82%</strong>
</pre><p>Now, run the following command to get annotated HTML listings detailing missed lines:</p><pre class="programlisting">
<strong>coverage html</strong>
</pre><p>Open the <code class="literal">index.html</code> HTML file generated in the <code class="literal">htmlcov</code> folder with your web browser. The following picture shows an example report that coverage generated in HTML format.</p><p>
</p><div><img src="img/image_04_003.jpg" alt="Running unit tests and checking testing coverage"/></div><p>
</p><p>Click or tap on <code class="literal">games/models.py</code> and the web browser will render a web page that displays the statements that were run, the missing ones and the excluded, with different colors. We can click or tap on the <strong>run</strong>, <strong>missing,</strong> and <strong>excluded</strong> buttons to show or hide the background color that represents the status for each line of code. By default, the missing lines of code will be displayed with a pink background. Thus, we must write unit tests that target these lines of code to improve our tests coverage:</p><p>
</p><div><img src="img/image_04_004.jpg" alt="Running unit tests and checking testing coverage"/></div><p>
</p></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec55"/>Improving testing coverage</h1></div></div></div><p>Now, we will write additional unit tests to improve the testing coverage. Specifically, we will write unit tests related to the player class based views: <code class="literal">PlayerList</code> and <code class="literal">PlayerDetail</code>. Open the existing <code class="literal">games/test.py</code> file and insert the following lines after the last line that declares imports. We need a new <code class="literal">import</code> statement and we will declare the new <code class="literal">PlayerTests</code> class. The code file for the sample is included in the <code class="literal">restful_python_chapter_04_05</code> folder:</p><pre class="programlisting">from games.models import Player 
 
class PlayerTests(APITestCase): 
    def create_player(self, name, gender): 
        url = reverse('player-list') 
        data = {'name': name, 'gender': gender} 
        response = self.client.post(url, data, format='json') 
        return response 
 
  <strong>  def test_create_and_retrieve_player(self):</strong> 
        """ 
        Ensure we can create a new Player and then retrieve it 
        """ 
        new_player_name = 'New Player' 
        new_player_gender = Player.MALE 
        response = self.create_player(new_player_name, new_player_gender) 
        self.assertEqual(response.status_code, status.HTTP_201_CREATED) 
        self.assertEqual(Player.objects.count(), 1) 
        self.assertEqual( 
            Player.objects.get().name,  
            new_player_name) 
 
   <strong> def test_create_duplicated_player(self):</strong> 
        """ 
        Ensure we can create a new Player and we cannot create a duplicate. 
        """ 
        url = reverse('player-list') 
        new_player_name = 'New Female Player' 
        new_player_gender = Player.FEMALE 
        response1 = self.create_player(new_player_name, new_player_gender) 
        self.assertEqual( 
            response1.status_code,  
            status.HTTP_201_CREATED) 
        response2 = self.create_player(new_player_name, new_player_gender) 
        self.assertEqual( 
            response2.status_code,  
            status.HTTP_400_BAD_REQUEST) 
 
   <strong> def test_retrieve_players_list(self):</strong> 
        """ 
        Ensure we can retrieve a player 
        """ 
        new_player_name = 'New Female Player' 
        new_player_gender = Player.FEMALE 
        self.create_player(new_player_name, new_player_gender) 
        url = reverse('player-list') 
        response = self.client.get(url, format='json') 
        self.assertEqual( 
            response.status_code,  
            status.HTTP_200_OK) 
        self.assertEqual( 
            response.data['count'], 
            1) 
        self.assertEqual( 
            response.data['results'][0]['name'], 
            new_player_name) 
        self.assertEqual( 
            response.data['results'][0]['gender'], 
            new_player_gender) 
</pre><p>The <code class="literal">PlayerTests</code> class is a subclass of <code class="literal">rest_framework.test.APITestCase</code>. The class declares the <code class="literal">create_player</code> method that receives the desired <code class="literal">name</code> and <code class="literal">gender</code> for the new player as arguments. The method builds the url and the data dictionary to compose and send an HTTP <code class="literal">POST</code> method to the view associated with the <code class="literal">player-list</code> view name and returns the response generated by this request. Many test methods will call the <code class="literal">create_player</code> method to create a player and then compose and send other HTTP requests to the API.</p><p>The class declares the following methods that start whose name start with the <code class="literal">test_</code> prefix:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">test_create_and_retrieve_player</code>: Tests whether we can create a new <code class="literal">Player</code> and then retrieve it.</li><li class="listitem" style="list-style-type: disc"><code class="literal">test_create_duplicated_player</code>: Tests whether the unique constraints don't make it possible for us to create two players with the same name. The second time we compose and send an HTTP POST request with a duplicate player name, we must receive an HTTP 400 Bad Request status code (<code class="literal">status.HTTP_400_BAD_REQUEST</code>).</li><li class="listitem" style="list-style-type: disc"><code class="literal">test_retrieve_player_list</code>: Tests whether we can retrieve a specific game category by its primary key or id.</li></ul></div><p>We just coded a few tests related to players to improve test coverage and notice the impact on the test coverage report.</p><p>Now, run the following command within the same virtual environment we have been using. We will use the <code class="literal">-v 2</code> option to use the verbosity level 2 because we want to check all the things that the test runner is doing:</p><pre class="programlisting">
<strong>python manage.py test -v 2</strong>
</pre><p>The following lines show the last lines of the sample output:</p><pre class="programlisting">
<strong>Ensure we can create a new GameCategory and then retrieve it ... ok</strong>
<strong>Ensure we can create a new GameCategory. ... ok</strong>
<strong>Ensure we can filter a game category by name ... ok</strong>
<strong>Ensure we can retrieve a game cagory ... ok</strong>
<strong>Ensure we can update a single field for a game category ... ok</strong>
<strong>Ensure we can create a new Player and then retrieve it ... ok</strong>
<strong>Ensure we can create a new Player and we cannot create a duplicate. ... ok</strong>
<strong>Ensure we can retrieve a player ... ok</strong>
<strong>Name                   Stmts   Miss  Cover</strong>
<strong>------------------------------------------</strong>
<strong>games.py                   0      0   100%</strong>
<strong>games/admin.py             1      1     0%</strong>
<strong>games/apps.py              3      3     0%</strong>
<strong>games/models.py           36     34     6%</strong>
<strong>games/pagination.py        3      0   100%</strong>
<strong>games/permissions.py       6      3    50%</strong>
<strong>games/serializers.py      45      0   100%</strong>
<strong>games/urls.py              3      0   100%</strong>
<strong>games/views.py            91      2    98%</strong>
<strong>------------------------------------------</strong>
<strong>TOTAL                    188     43    77%</strong>
<strong>----------------------------------------------------------------------</strong>
<strong>Ran 8 tests in 0.168s</strong>
<strong>OK</strong>
<strong>Destroying test database for alias 'default' ('test_games')...</strong>
</pre><p>The output provides details that indicate that the test runner executed 8 tests and all of them passed. The test code coverage measurement report provided by the <code class="literal">coverage</code> package increased the <code class="literal">Cover</code> percentage from 3% in the previous run to 6%. The additional tests we wrote execute code for the <code class="literal">Player</code> model, and therefore, there is an impact in the coverage report.</p><div><div><h3 class="title"><a id="tip37"/>Tip</h3><p>We just created a few unit tests to understand how we can code them. However, of course, it would be necessary to write more tests to provide an appropriate coverage of all the featured and execution scenarios included in the API.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec56"/>Understanding strategies for deployments and scalability</h1></div></div></div><p>One of the biggest drawbacks related to Django and Django REST Framework is that each HTTP request is blocking. Thus, whenever the Django server receives an HTTP request, it doesn't start working on any other HTTP requests in the incoming queue until the server sends the response for the first HTTP request it received.</p><p>However, one of the greatest advantages of RESTful Web Services is that they are stateless, that is, they shouldn't keep a client state on any server. Our API is a good example of a stateless RESTful Web Service. Thus, we can make the API run on as many servers as necessary to achieve our scalability goals. Obviously, we must take into account that we can easily transform the database server in our scalability bottleneck.</p><div><div><h3 class="title"><a id="tip38"/>Tip</h3><p>Nowadays, we have a huge number of cloud-based alternatives to deploy a RESTful web service that uses Django and Django REST Framework and make it extremely scalable. Just to mention a few examples, we have Heroku, PythonAnywhere, Google App Engine, OpenShift, AWS Elastic Beanstalk, and Windows Azure.</p></div></div><p>Each platform includes detailed instructions to deploy our application. All of them will require us to generate the <code class="literal">requirements.txt</code> file that lists the application dependencies together with their versions. This way, the platforms will be able to install all the necessary dependencies listed in the file.</p><p>Run the following <code class="literal">pip freeze</code>, to generate the <code class="literal">requirements.txt</code> file:</p><pre class="programlisting">
<strong>pip freeze &gt; requirements.txt</strong>
</pre><p>The following lines show the contents of a sample generated <code class="literal">requirements.txt</code> file. However, bear in mind that many packages increase their version number quickly and you might see different versions in your configuration:</p><pre class="programlisting">
<strong>coverage==4.1</strong>
<strong>Django==1.9.7</strong>
<strong>django-braces==1.9.0</strong>
<strong>django-crispy-forms==1.6.0</strong>
<strong>django-filter==0.13.0</strong>
<strong>django-nose==1.4.4</strong>
<strong>django-oauth-toolkit==0.10.0</strong>
<strong>djangorestframework==3.3.3</strong>
<strong>nose==1.3.7</strong>
<strong>oauthlib==1.0.3</strong>
<strong>psycopg2==2.6.2</strong>
<strong>six==1.10.0</strong>
</pre><p>We always have to make sure that we profile the API and the database before we deploy our first version of the RESTful Web Service. It is very important to make sure that the generated queries run properly on the underlying database and that the most popular queries do not end up in sequential scans. It is usually necessary to add the appropriate indexes to the tables in the database.</p><p>We have been using basic HTTP authentication. In case we decide to use this authentication or other mechanisms, we must make sure that the API runs under HTTPS in production environments. In addition, we must make sure that we change the following line in the <code class="literal">settings.py</code> file:</p><pre class="programlisting">DEBUG = True 
</pre><p>We must always turn off the debug mode in production, and therefore, we must replace the previous line with the following one:</p><pre class="programlisting">DEBUG = False 
</pre></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec57"/>Test your knowledge</h1></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">The <code class="literal">ScopedRateThrottle</code> class:<div><ol class="orderedlist arabic"><li class="listitem">Limits the rate of requests that a specific user can make.</li><li class="listitem">Limits the rate of requests for specific parts of the API identified with the value assigned to the <code class="literal">throttle_scope</code> property.</li><li class="listitem">Limits the rate of requests that an anonymous user can make.</li></ol></div><p>
</p></li><li class="listitem">The <code class="literal">UserRateThrottle</code> class:<div><ol class="orderedlist arabic"><li class="listitem">Limits the rate of requests that a specific user can make.</li><li class="listitem">Limits the rate of requests for specific parts of the API identified with the value assigned to the <code class="literal">throttle_scope</code> property.</li><li class="listitem">Limits the rate of requests that an anonymous user can make.</li></ol></div><p>
</p></li><li class="listitem">The <code class="literal">DjangoFilterBackend</code> class:<div><ol class="orderedlist arabic"><li class="listitem">Provides single query parameter based searching capabilities and it is based on the Django admin's search function.</li><li class="listitem">Allows the client to control how the results are ordered with a single query parameter.</li><li class="listitem">Provides field filtering capabilities.</li></ol></div><p>
</p></li><li class="listitem">The <code class="literal">SearchFilter</code> class:<div><ol class="orderedlist arabic"><li class="listitem">Provides single query parameter based searching capabilities and it is based on the Django admin's search function.</li><li class="listitem">Allows the client to control how the results are ordered with a single query parameter.</li><li class="listitem">Provides field filtering capabilities.</li></ol></div><p>
</p></li><li class="listitem">In a subclass of <code class="literal">APITestCase</code>, <code class="literal">self.client</code> is:<div><ol class="orderedlist arabic"><li class="listitem">The <code class="literal">APIClient</code> instance that allows us to easily compose and send HTTP requests for testing.</li><li class="listitem">The <code class="literal">APITestClient</code> instance that allows us to easily compose and send HTTP requests for testing.</li><li class="listitem">The <code class="literal">APITestCase</code> instance that allows us to easily compose and send HTTP requests for testing.</li></ol></div><p>
</p></li></ol></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec58"/>Summary</h1></div></div></div><p>In this chapter, we took advantage of the features included in Django REST Framework to define throttling policies. We used filtering, searching, and ordering classes to make it easy to configure filters, search queries, and desired order for the results in HTTP requests. We used the browsable API feature to test these new features included in our API.</p><p>We wrote the first round of unit tests, measured test coverage, and then we wrote additional unit tests to improve test coverage. Finally, we understood many considerations for deployment and scalability.</p><p>Now that we built a complex API with Django REST Framework and tested it, we will move to another popular Python web framework, Flask, which is what we are going to discuss in the next chapter.</p></div></body></html>