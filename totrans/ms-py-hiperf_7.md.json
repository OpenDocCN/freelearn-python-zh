["```py\nfrom numba import jit\nfrom numpy import arange\n\n# jit decorator tells Numba to compile this function.\n# The argument types will be inferred by Numba when function is called.\n@jit\ndef sum2d(arr):\n    M, N = arr.shape\n    result = 0.0\n    for i in range(M):\n        for j in range(N):\n            result += arr[i,j]\n    return result\n\na = arange(9).reshape(3,3)\nprint(sum2d(a))\n```", "```py\nfrom numba import jit\nfrom numpy import arange\n\n# jit decorator tells Numba to compile this function.\n# The argument types will be inferred by Numba when function is called.\n@jit\ndef sum2d(arr):\n    M, N = arr.shape\n    result = 0.0\n    for i in range(M):\n        for j in range(N):\n            result += arr[i,j]\n    return result\n\na = arange(9).reshape(3,3)\nprint(sum2d(a))\n```", "```py\n$ conda install numba\n\n```", "```py\n$ git clone git://github.com/numba/numba.git\n\n```", "```py\n$ python setup.py build_ext –inplace\n\n```", "```py\n>>> import numba\n>>> numba.__version__\n'0.18.2'\n```", "```py\nLazy compilation\n```", "```py\nfrom numba import jit\n\n@jit\ndef sum2(a,b):\n  return a + b\n```", "```py\nfrom numba import jit, int32\n\n@jit(int32(int32, int32))\ndef sum2(a,b):\n  return a + b\n```", "```py\n@jit(nopython=True)\ndef add2(a, b):\n  return a + b\n```", "```py\ndef sum(x, y):\n    array = np.arange(x * y).reshape(x, y)\n    sum = 0\n    for i in range(x):\n        for j in range(y):\n            sum += array[i, j]\n    return sum\n```", "```py\nsum_auto_jitting (int64, int64)\n--------------------------------------------------------------------------------\n# File: auto-jitting.py\n# --- LINE 6 --- \n\n@jit\n\n# --- LINE 7 --- \n\ndef sum_auto_jitting(x, y):\n\n    # --- LINE 8 --- \n    # label 0\n    #   x = arg(0, name=x)  :: pyobject\n    #   y = arg(1, name=y)  :: pyobject\n    #   $0.1 = global(np: <module 'numpy' from '/home/fernando/miniconda/lib/python2.7/site-packages/numpy/__init__.pyc'>)  :: pyobject\n    #   $0.2 = getattr(attr=arange, value=$0.1)  :: pyobject\n    #   del $0.1\n    #   $0.5 = x * y  :: pyobject\n    #   $0.6 = call $0.2($0.5, )  :: pyobject\n    #   del $0.5\n    #   del $0.2\n    #   $0.7 = getattr(attr=reshape, value=$0.6)  :: pyobject\n    #   del $0.6\n    #   $0.10 = call $0.7(x, y, )  :: pyobject\n    #   del $0.7\n    #   array = $0.10  :: pyobject\n    #   del $0.10\n\n    array = np.arange(x * y).reshape(x, y)\n\n    # --- LINE 9 --- \n    #   $const0.11 = const(int, 0)  :: pyobject\n    #   sum = $const0.11  :: pyobject\n    #   del $const0.11\n\n    sum = 0\n\n    # --- LINE 10 --- \n    #   jump 40.1\n    # label 40.1\n    #   $const40.1.1 = const(LiftedLoop, LiftedLoop(<function sum_auto_jitting at 0x7ff5f94756e0>))  :: XXX Lifted Loop XXX\n    #   $40.1.6 = call $const40.1.1(y, x, sum, array, )  :: XXX Lifted Loop XXX\n    #   del y\n...\n\n    #   jump 103\n    for i in range(x):\n        # --- LINE 11 --- \n        for j in range(y):\n            # --- LINE 12 --- \n            sum += array[i, j]\n    # --- LINE 13 --- \n    # label 103\n    #   $103.2 = cast(value=sum.1)  :: pyobject\n    #   del sum.1\n    #   return $103.2\n    return sum\n# The function contains lifted loops\n# Loop at line 10\n# Has 1 overloads\n# File: auto-jitting.py\n# --- LINE 6 --- \n\n@jit\n# --- LINE 7 --- \ndef sum_auto_jitting(x, y):\n    # --- LINE 8 --- \n    array = np.arange(x * y).reshape(x, y)\n    # --- LINE 9 --- \n    sum = 0\n    # --- LINE 10 --- \n    # label 37\n    #   y = arg(0, name=y)  :: int64\n    #   x = arg(1, name=x)  :: int64\n    #   sum = arg(2, name=sum)  :: int64\n    #   array = arg(3, name=array)  :: array(int64, 2d, C)\n    #   $37.1 = global(range: <built-in function range>)  :: range\n    #   $37.3 = call $37.1(x, )  :: (int64,) -> range_state64\n    #   del x\n    #   del $37.1\n    #   $37.4 = getiter(value=$37.3)  :: range_iter64\n    #   del $37.3\n    #   $phi50.1 = $37.4  :: range_iter64\n    #   del $37.4\n    #   jump 50\n    # label 50\n    #   $50.2 = iternext(value=$phi50.1)  :: pair<int64, bool>\n    #   $50.3 = pair_first(value=$50.2)  :: int64\n    #   $50.4 = pair_second(value=$50.2)  :: bool\n    #   del $50.2\n    #   $phi53.1 = $50.3  :: int64\n    #   del $50.3\n    #   branch $50.4, 53, 102\n    # label 53\n    #   i = $phi53.1  :: int64\n    #   del $phi53.1\n\n    for i in range(x):\n\n        # --- LINE 11 --- \n        #   jump 56\n        # label 56\n\n...\n        #   j = $phi72.1  :: int64\n        #   del $phi72.1\n\n        for j in range(y):\n\n            # --- LINE 12 --- \n            #   $72.6 = build_tuple(items=[Var(i, auto-jitting.py (10)), Var(j, auto-jitting.py (11))])  :: (int64 x 2)\n            #   del j\n            #   $72.7 = getitem(index=$72.6, value=array)  :: int64\n\n...\n            #   return $103.3\n\n            sum += array[i, j]\n\n    # --- LINE 13 --- \n\n    return sum\n```", "```py\n    $ conda create -n my_new_environment python \n\n    ```", "```py\n    $ source activate my_new_environment\n\n    ```", "```py\n    $ conda install  pandas\n\n    ```", "```py\n$ pip install pandas\n\n```", "```py\n$ sudo apt-get install python-pandas\n\n```", "```py\n$ sudo apt-get install python-pandas\n\n```", "```py\n$ zypper in python-pandas\n\n```", "```py\nimport pandas as pd \nimport time\nimport csv\nimport collections\n\nSOURCE_FILE = './311.csv'\n\ndef readCSV(fname):\n  with open(fname, 'rb') as csvfile:\n    reader = csv.DictReader(csvfile)\n    lines = [line for line in reader]\n    return lines\n\ndef process(fname):\n  content = readCSV(fname)\n  incidents_by_zipcode = collections.defaultdict(int)\n  for record in content:\n    incidents_by_zipcode[toFloat(record['Incident Zip'])] += 1\n  return sorted(incidents_by_zipcode.items(), reverse=True, key=lambda a: int(a[1]))[:10]\n\ndef toFloat(number):\n  try:\n    return int(float(number))\n  except:\n    return 0\n\ndef process_pandas(fname):\n  df = pd.read_csv(fname, dtype={'Incident Zip': str, 'Landmark': str, 'Vehicle Type': str, 'Ferry Direction': str})\n\n  df['Incident Zip'] = df['Incident Zip'].apply(toFloat)\n  column_names =  list(df.columns.values)\n  column_names.remove(\"Incident Zip\")\n  column_names.remove(\"Unique Key\")\n  return df.drop(column_names, axis=1).groupby(['Incident Zip'], sort=False).count().sort('Unique Key', ascending=False).head(10)\n\ninit = time.clock()\ntotal = process(SOURCE_FILE)\nendtime = time.clock() - init\nfor item in total:\n  print \"%s\\t%s\" % (item[0], item[1])\n\nprint \"(Pure Python) time: %s\" % (endtime)\n\ninit = time.clock()\ntotal = process_pandas(SOURCE_FILE)\nendtime = time.clock() - init\nprint total\nprint \"(Pandas) time: %s\" % (endtime)\n```", "```py\ndef process_pandas(fname):\n  df = pd.read_csv(fname, usecols=['Incident Zip', 'Unique Key'], converters={'Incident Zip': toFloat}, dtype={'Incident Zip': str})\n  return df.groupby(['Incident Zip'], sort=False).count().sort('Unique Key', ascending=False).head(10)\n```", "```py\n$ pip install parakeet\n\n```", "```py\n$ python setup.py install\n\n```", "```py\nfrom parakeet import jit\nimport random\nimport numpy as np\nimport time\n\n@jit \ndef allpairs_dist_prkt(X,Y):\n  def dist(x,y):\n    return np.sum( (x-y)**2 )\n  return np.array([[dist(x,y) for y in Y] for x in X])\n\ndef allpairs_dist_py(X,Y):\n  def dist(x,y):\n    return np.sum( (x-y)**2 )\n  return np.array([[dist(x,y) for y in Y] for x in X])\n\ninput_a =  [ random.random()  for x in range(0, 4000)] \ninput_b =  [ random.random()  for x in range(0, 4000)] \n\nprint \"----------------------------------------------\"\ninit = time.clock()\nallpairs_dist_py(input_a, input_b)\nend = time.clock()\nprint \"Total time pure python: %s\" % (end - init)\nprint \ninit = time.clock()\nallpairs_dist_prkt(input_a, input_b)\nend = time.clock()\nprint \"Total time parakeet: %s\" % (end – init)\nprint \"----------------------------------------------\"\n```"]