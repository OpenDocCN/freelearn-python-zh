<html><head></head><body>
		<div><h1 id="_idParaDest-75" class="chapter-number"><a id="_idTextAnchor076"/><st c="0">3</st></h1>
			<h1 id="_idParaDest-76"><a id="_idTextAnchor077"/><st c="2">Creating REST Web Services</st></h1>
			<p><st c="28">Although Flask is a popular lightweight web framework, it can also support RESTful web service implementations. </st><st c="141">It has its own JSON encoders and decoders, built-in JSON support mechanisms for response generation and error handling, easy-to-manage RESTful request dispatching, and a lean configuration approach. </st><st c="340">Unlike the other API frameworks, Flask uses more modules and packages because of the required project structure it needs to maintain. </st><st c="474">However, after setting up the directory structure accordingly, the succeeding steps will be seamless, lightweight, </st><st c="589">and straightforward.</st></p>
			<p><st c="609">This chapter will introduce the part of the Flask framework that deals with building API endpoints to provide data and services to sub-modules or other applications. </st><st c="776">The goal is to understand how Flask manages the incoming requests and outgoing responses for REST endpoints that will run on its environment. </st><st c="918">Also, this chapter will discuss the various components that will comprise the Flask’s API </st><st c="1008">endpoint implementation.</st></p>
			<p><st c="1032">Here are the topics that this chapter will cover to understand API development </st><st c="1112">with Flask:</st></p>
			<ul>
				<li><st c="1123">Setting up a </st><st c="1137">RESTful application</st></li>
				<li><st c="1156">Implementing </st><st c="1170">API endpoints</st></li>
				<li><st c="1183">Managing requests </st><st c="1202">and responses</st></li>
				<li><st c="1215">Utilizing response encoders </st><st c="1244">and decoders</st></li>
				<li><st c="1256">Filtering API requests </st><st c="1280">and responses</st></li>
				<li><st c="1293">Handling exceptions</st></li>
				<li><st c="1313">Consuming </st><st c="1324">API endpoints</st></li>
			</ul>
			<h1 id="_idParaDest-77"><a id="_idTextAnchor078"/><st c="1337">Technical requirements</st></h1>
			<p><st c="1360">This chapter utilizes a simple online pizza ordering system to showcase the capability of the Flask framework in developing REST web services. </st><st c="1504">The </st><code><st c="1508">ch03</st></code><st c="1512"> application has a login, product inventory, and ordering and payment modules with the business scope to identify the necessary Flask components and utilities for the development. </st><st c="1692">Moreover, a client application, </st><code><st c="1724">ch03-client</st></code><st c="1735">, is also included in the deliverables to showcase how to consume Flask API endpoints. </st><st c="1822">Both applications use PostgreSQL as their database management system, with SQLAlchemy as their ORM. </st><st c="1922">All these projects are uploaded </st><st c="1954">at </st><a href="https://github.com/PacktPublishing/Mastering-Flask-Web-Development/tree/main/ch03"><st c="1957">https://github.com/PacktPublishing/Mastering-Flask-Web-Development/tree/main/ch03</st></a><st c="2038">.</st></p>
			<h1 id="_idParaDest-78"><a id="_idTextAnchor079"/><st c="2039">Setting up a RESTful application</st></h1>
			<p><st c="2072">First, create </st><a id="_idIndexMarker156"/><st c="2087">the project’s virtual environment, which will serve as the local repository of the needed module extensions. </st><st c="2196">Next, open the VSCode editor to make the main project folder and install the </st><code><st c="2273">flask</st></code><st c="2278"> extension module using the </st><code><st c="2306">pip</st></code><st c="2309"> command through the VSCode’s command </st><st c="2347">line interpreter.</st></p>
			<p><st c="2364">Afterward, manage the directory structure, such as the arrangement made for </st><a href="B19383_02.xhtml#_idTextAnchor047"><em class="italic"><st c="2441">Chapter 2</st></em></a><st c="2450"> projects. </st><st c="2461">From the three approaches, namely the application factory design, </st><code><st c="2527">Blueprint</st></code><st c="2536">, and the hybrid between these two, our online pizza ordering application will use the application factory approach to place its custom exception classes, models, repository, services, utilities, APIs, and database configuration in one </st><code><st c="2772">app</st></code><st c="2775"> folder and register all these components using the </st><code><st c="2827">create_app()</st></code><st c="2839"> method. </st><em class="italic"><st c="2848">Figure 3</st></em><em class="italic"><st c="2856">.1</st></em><st c="2858"> shows the project directory structure of our </st><st c="2904">prototype application.</st></p>
			<div><div><img src="img/B19383_03_1.jpg" alt="Figure 3.1 – Project directory structure for the RESTful application"/><st c="2926"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="3055">Figure 3.1 – Project directory structure for the RESTful application</st></p>
			<p><st c="3123">The logging setup, the </st><a id="_idIndexMarker157"/><st c="3147">SQLAlchemy declarative configuration, and the sessions created in </st><a href="B19383_02.xhtml#_idTextAnchor047"><em class="italic"><st c="3213">Chapter 2</st></em></a><st c="3222"> are all retained and used in this application. </st><st c="3270">On the other hand, the </st><code><st c="3293">create_app()</st></code><st c="3305">, still placed in the </st><code><st c="3327">__init__.py</st></code><st c="3338"> of the </st><code><st c="3346">app</st></code><st c="3349"> package, is implemented </st><st c="3374">as follows:</st></p>
			<pre class="source-code"><st c="3385">
def create_app(config_file):
    app = Flask(__name__)
    app.config.from_file(config_file, toml.load)
    init_db()
    configure_logger('log_msg.txt')
    with app.app_context():
        from app.api import index
        … … … … … … …
        from app.api import orders
    return app</st></pre>			<p><st c="3625">The </st><code><st c="3630">main.py</st></code><st c="3637"> still has the error handlers and the </st><code><st c="3675">app.run()</st></code><st c="3684"> method for the server startup. </st><st c="3716">The same command, </st><code><st c="3734">python main.py</st></code><st c="3748">, will run the application. </st><st c="3776">However, the </st><code><st c="3789">ch03</st></code><st c="3793"> application </st><a id="_idIndexMarker158"/><st c="3806">will not be web-based </st><st c="3828">but API-based.</st></p>
			<p><st c="3842">Let us dissect our application and identify the Flask components used to build </st><st c="3922">REST services.</st></p>
			<h1 id="_idParaDest-79"><a id="_idTextAnchor080"/><st c="3936">Implementing API endpoints</st></h1>
			<p><st c="3963">The implementation of </st><a id="_idIndexMarker159"/><st c="3986">API endpoints uses the same bolts and knots applied in creating web-based components in </st><em class="italic"><st c="4074">Chapters 1</st></em><st c="4084"> and </st><em class="italic"><st c="4089">2</st></em><st c="4090">, such as declaring path variables, accessing the request through the </st><code><st c="4160">request</st></code><st c="4167"> proxy object, returning the same </st><code><st c="4201">Response</st></code><st c="4209"> object, and using the same </st><code><st c="4237">@route()</st></code><st c="4245"> decorator. </st><st c="4257">A GET API endpoint that returns a </st><em class="italic"><st c="4291">JSON</st></em><st c="4295"> response is </st><st c="4308">as follows:</st></p>
			<pre class="source-code">
<strong class="bold"><st c="4319">@current_app.route("/index", methods = ['GET'])</st></strong><st c="4367">
def index():
   response = </st><strong class="bold"><st c="4392">make_response</st></strong><st c="4405">(</st><strong class="bold"><st c="4407">jsonify</st></strong><st c="4414">(message='This is an Online Pizza Ordering System.', today=date.today()), 200)
   </st><code><st c="4515">index()</st></code><st c="4522"> function, found in the </st><code><st c="4546">app/api/index.py</st></code><st c="4562"> module, is exactly similar to the web-based view function, except that </st><code><st c="4634">make_response()</st></code><st c="4649"> requires the </st><code><st c="4663">jsonify()</st></code><st c="4672"> instead of the </st><code><st c="4688">render_template()</st></code><st c="4705"> method.</st></p>
			<p><st c="4713">The </st><code><st c="4718">jsonify()</st></code><st c="4727"> is a Flask utility method that serializes any data to produce an </st><code><st c="4793">application/json</st></code><st c="4809"> response. </st><st c="4820">It converts </st><em class="italic"><st c="4832">multiple values</st></em><st c="4847"> into an </st><em class="italic"><st c="4856">array of data</st></em><st c="4869"> and </st><em class="italic"><st c="4874">key-value pairs</st></em><st c="4889"> to a </st><em class="italic"><st c="4895">dictionary</st></em><st c="4905">. It can also accept a </st><em class="italic"><st c="4928">single-valued</st></em><st c="4941"> entry. </st><st c="4949">The </st><code><st c="4953">jsonify()</st></code><st c="4962"> in the given </st><code><st c="4976">index()</st></code><st c="4983"> function converts its arguments into a dictionary before calling Python’s </st><code><st c="5058">json.dumps()</st></code><st c="5070"> method. </st><st c="5079">After </st><code><st c="5085">json.dumps()</st></code><st c="5097">’s JSON serialization, </st><code><st c="5121">jsonify()</st></code><st c="5130"> will contain and render the result as part of </st><code><st c="5177">Response</st></code><st c="5185"> with a mime-type of </st><code><st c="5206">application/json</st></code><st c="5222"> instead of a plain JSON string. </st><st c="5255">Thus, running the given </st><code><st c="5279">/index</st></code><st c="5285"> endpoint with the </st><code><st c="5304">curl -i</st></code><st c="5311"> command will generate the following request </st><st c="5356">header result:</st></p>
			<div><div><img src="img/B19383_03_2.jpg" alt="Figure 3.2 – Running the /index endpoint using cURL"/><st c="5370"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="5653">Figure 3.2 – Running the /index endpoint using cURL</st></p>
			<p><st c="5704">The response body </st><a id="_idIndexMarker160"/><st c="5723">provided by running the curl command against </st><code><st c="5768">/index</st></code><st c="5774"> has a message body and response headers composed of </st><code><st c="5827">Server</st></code><st c="5833">, </st><code><st c="5835">Date</st></code><st c="5839">, </st><code><st c="5841">Content-Type</st></code><st c="5853">, </st><code><st c="5855">Content-Length</st></code><st c="5869">, and </st><code><st c="5875">Connection</st></code><st c="5885">. </st><code><st c="5887">Content-Type</st></code><st c="5899"> indicates the resource type the </st><code><st c="5932">/index</st></code><st c="5938"> API will return to the client. </st><st c="5970">Aside from strings, the </st><code><st c="5994">jsonify()</st></code><st c="6003"> method can also serialize and render an array of objects like in the following API function that returns an array of string data and some </st><st c="6142">single-valued objects:</st></p>
			<pre class="source-code">
<strong class="bold"><st c="6164">@current_app.route("/introduction", methods = ['GET'])</st></strong><st c="6219">
def introduction():
   response = make_response(</st><strong class="bold"><st c="6265">jsonify('This is an application that … … … order requests, and provides payment receipts.')</st></strong><st c="6357">, 200)
   return response
</st><strong class="bold"><st c="6380">@current_app.route("/company/trademarks", methods = ['GET'])</st></strong><st c="6440">
def list_goals():
   response = make_response(</st><strong class="bold"><st c="6484">jsonify(['Eat', 'Live', 'Happy'])</st></strong><st c="6518">, 200)
   return response</st></pre>			<p><st c="6540">When the response data is not serializable, </st><code><st c="6585">jsonify()</st></code><st c="6594"> can throw an exception, so it is advisable to enable error handlers. </st><st c="6664">Now, it is customary to exclude </st><code><st c="6696">make_response</st></code><st c="6709"> in returning the response data since </st><code><st c="6747">jsonify()</st></code><st c="6756"> can already manage the </st><code><st c="6780">Response</st></code><st c="6788"> generation alone for the endpoint function. </st><st c="6833">Thus, the following versions of the </st><code><st c="6869">index()</st></code><st c="6876">, </st><code><st c="6878">introduction()</st></code><st c="6892">, and </st><code><st c="6898">list_goals()</st></code><st c="6910"> endpoint functions </st><st c="6930">are acceptable:</st></p>
			<pre class="source-code">
<strong class="bold"><st c="6945">@current_app.route("/index", methods = ['GET'])</st></strong><st c="6993">
def index():
   response = </st><strong class="bold"><st c="7018">jsonify(message='This is an Online Pizza Ordering System.', today=date.today())</st></strong><st c="7097">, 200
   return response
</st><strong class="bold"><st c="7119">@current_app.route("/introduction", methods = ['GET'])</st></strong><st c="7173">
def introduction():
   response = </st><strong class="bold"><st c="7205">jsonify('This is an application that … … … order requests, and provides payment receipts.')</st></strong><st c="7296">, 200
   return response
</st><strong class="bold"><st c="7318">@current_app.route("/company/trademarks", methods = ['GET'])</st></strong><st c="7378">
def list_goals():
   response = </st><strong class="bold"><st c="7408">jsonify(['Eat', 'Live', 'Happy'])</st></strong><st c="7441">, 200
   return response</st></pre>			<p><st c="7462">Using the </st><code><st c="7473">@app.route()</st></code><st c="7485"> decorator</st><a id="_idIndexMarker161"/><st c="7495"> to bind the URL pattern to the function and define the HTTP request is always valid. </st><st c="7581">But Flask 3.x had released some decorator shortcuts that can assign one HTTP request per endpoint function, unlike the </st><code><st c="7700">@app.route()</st></code><st c="7712">, which can bind more than one HTTP request. </st><st c="7757">These shortcuts are </st><st c="7777">the following:</st></p>
			<ul>
				<li><code><st c="7791">get()</st></code><st c="7797">: This defines an endpoint function that will listen to incoming </st><em class="italic"><st c="7863">HTTP </st></em><st c="7868">GET requests, such as </st><a id="_idIndexMarker162"/><st c="7890">retrieving data from the </st><st c="7915">database servers.</st></li>
				<li><code><st c="7932">post()</st></code><st c="7939">: This </st><a id="_idIndexMarker163"/><st c="7947">defines an endpoint function to process an </st><em class="italic"><st c="7990">HTTP POST</st></em><st c="7999"> request, such as receiving a body of data for </st><st c="8046">internal processing.</st></li>
				<li><code><st c="8066">put()</st></code><st c="8072">: This defines an endpoint function to cater to </st><a id="_idIndexMarker164"/><st c="8121">any </st><em class="italic"><st c="8125">HTTP PUT</st></em><st c="8133"> requests, such as receiving a body of data containing updated details for the </st><st c="8212">database server.</st></li>
				<li><code><st c="8228">patch()</st></code><st c="8236">: This defines an endpoint to listen to an </st><em class="italic"><st c="8280">HTTP PATCH</st></em><st c="8290"> request</st><a id="_idIndexMarker165"/><st c="8298"> that aims to modify some </st><st c="8324">backend resources.</st></li>
				<li><code><st c="8342">delete()</st></code><st c="8351">: This defines an </st><em class="italic"><st c="8370">HTTP DELETE</st></em><st c="8381"> endpoint function</st><a id="_idIndexMarker166"/><st c="8399"> that will delete some </st><st c="8422">server resources.</st></li>
			</ul>
			<p><st c="8439">The following </st><a id="_idIndexMarker167"/><st c="8454">employee-related transactions of our </st><code><st c="8491">ch03</st></code><st c="8495"> application are all implemented using the shortcut </st><st c="8547">routing decorators:</st></p>
			<pre class="source-code">
<strong class="bold"><st c="8566">@current_app.post('/employee/add')</st></strong><st c="8601">
def add_employee():
    emp_json = request.get_json()
    repo = EmployeeRepository(db_session)
    employee = Employee(**emp_json)
    result = repo.insert(employee)
    if result:
        content = jsonify(emp_json)
        current_app.logger.info('insert employee record successful')
        return make_response(content, 201)
    else:
        raise DuplicateRecordException("insert employee record encountered a problem", status_code=500)</st></pre>			<p><st c="8989">The given </st><code><st c="9000">add_employee()</st></code><st c="9014"> endpoint</st><a id="_idIndexMarker168"/><st c="9023"> function performs a database INSERT transaction of a record of employee details received from the client. </st><st c="9130">The decorated </st><code><st c="9144">@current_app.post()</st></code><st c="9163"> makes the API function an HTTP POST request method. </st><st c="9216">On the other hand, the following is an API function that responds to an HTTP GET </st><st c="9297">client request:</st></p>
			<pre class="source-code">
<code><st c="9312">@current_app.get('/employee/list/all')</st></code><st c="9351">
def list_all_employee():
    repo = EmployeeRepository(db_session)
    records = repo.select_all()
    emp_rec = [rec.to_json() for rec in records]
    current_app.logger.info('retrieved a list of employees successfully')
    return jsonify(emp_rec)</st></pre>			<p><st c="9581">The </st><code><st c="9586">list_all_employee()</st></code><st c="9605">, defined by the </st><code><st c="9622">@current_app.get()</st></code><st c="9640"> decorator, processes the incoming HTTP GET requests for retrieving a list of employee records from the database server. </st><st c="9761">For an HTTP PUT transaction, here is an API that updates </st><st c="9818">employee details:</st></p>
			<pre class="source-code">
<strong class="bold"><st c="9835">@current_app.put('/employee/update')</st></strong><st c="9872">
def update_employee():
    emp_json = request.get_json()
    repo = EmployeeRepository(db_session)
    result = repo.update(emp_json['empid'], emp_json)
    if result:
        content = jsonify(emp_json)
        current_app.logger.info('update employee record successful')
        return make_response(content, 201)
    else:
        raise NoRecordException("update employee record encountered a problem", status_code=500)</st></pre>			<p><st c="10243">The given API endpoint requires an </st><code><st c="10279">empid</st></code><st c="10284"> path variable, which will serve as the key to search for the employee record that needs updating. </st><st c="10383">Since this is an HTTP PUT request, the transaction requires all the new employee details to be replaced by their new values. </st><st c="10508">But the following is another version of the update transaction that does not need a complete</st><a id="_idIndexMarker169"/><st c="10600"> employee </st><st c="10610">detail update:</st></p>
			<pre class="source-code">
<strong class="bold"><st c="10624">@current_app.patch('/employee/update/&lt;string:empid&gt;')</st></strong><st c="10678">
def update_employee_name(</st><strong class="bold"><st c="10704">empid:str</st></strong><st c="10714">):
    emp_json = request.get_json()
    repo = EmployeeRepository(db_session)
    result = repo.update(empid, emp_json)
    if result:
        content = jsonify(emp_json)
        current_app.logger.info('update employee firstname, middlename, and lastname successful')
        return make_response(content, 201)
    else:
        raise NoRecordException("update employee firstname, middlename, and lastname encountered a problem", status_code=500)</st></pre>			<p><code><st c="11111">update_employee()</st></code><st c="11129">, decorated by </st><code><st c="11144">@current_app.patch()</st></code><st c="11164">, only updates the first name, middle name, and last name of the employee identified by the given employee ID using its path variable </st><code><st c="11298">empid</st></code><st c="11303">. Now, the following API function deletes an employee record based on the </st><code><st c="11377">empid</st></code> <st c="11382">path variable:</st></p>
			<pre class="source-code">
<strong class="bold"><st c="11397">@current_app.delete('/employee/delete/&lt;string:empid&gt;')</st></strong><st c="11452">
def delete_employee(</st><strong class="bold"><st c="11473">empid:str</st></strong><st c="11483">):
    repo = EmployeeRepository(db_session)
    result = repo.delete(empid)
    if result:
        content = jsonify(message=f'employee {empid} deleted')
        current_app.logger.info('delete employee record successful')
        return make_response(content, 201)
    else:
        raise NoRecordException("delete employee record encountered a problem", status_code=500)</st></pre>			<p><code><st c="11809">delete_employee()</st></code><st c="11827">, decorated by </st><code><st c="11842">@current_app.delete()</st></code><st c="11863">, is an HTTP </st><code><st c="11876">DELETE</st></code><st c="11882"> request method </st><a id="_idIndexMarker170"/><st c="11898">with the path variable </st><code><st c="11921">empid</st></code><st c="11926">, used for searching employee records </st><st c="11964">for deletion.</st></p>
			<p><st c="11977">These shortcuts of binding HTTP requests to their respective request handler methods are appropriate for implementing REST services because of their definite, simple, and straightforward one-route approach to managing incoming requests and serializing the </st><st c="12234">required responses.</st></p>
			<p><st c="12253">Let us now explore how Flask API captures the incoming body of data for POST, PUT, and PATCH requests and, aside from </st><code><st c="12372">make_response()</st></code><st c="12387">, what other ways the API can generate </st><st c="12426">JSON responses.</st></p>
			<h1 id="_idParaDest-80"><a id="_idTextAnchor081"/><st c="12441">Managing requests and responses</st></h1>
			<p><st c="12473">Unlike in other frameworks, it is </st><a id="_idIndexMarker171"/><st c="12508">easy to capture the request body of the incoming POST, PUT, and</st><a id="_idIndexMarker172"/><st c="12571"> PATCH request in Flask, which is through the </st><code><st c="12617">get_json()</st></code><st c="12627"> method from the </st><code><st c="12644">request</st></code><st c="12651"> proxy object. </st><st c="12666">This utility method receives the incoming JSON data, parses the data using </st><code><st c="12741">json.loads()</st></code><st c="12753">, and returns the data in a Python dictionary format. </st><st c="12807">As seen in the following </st><code><st c="12832">add_customer()</st></code><st c="12846"> API, the value of </st><code><st c="12865">get_json()</st></code><st c="12875"> is converted into a </st><code><st c="12896">kwargs</st></code><st c="12902"> argument by Python’s </st><code><st c="12924">**</st></code><st c="12926"> operator before passing the request data to the model class’s constructor, an indication that the captured request data is a </st><code><st c="13052">dict</st></code><st c="13056"> convertible </st><st c="13069">into </st><code><st c="13074">kwargs</st></code><st c="13080">:</st></p>
			<pre class="source-code"><st c="13082">
@current_app.post('/customer/add')
def add_customer():
        </st><strong class="bold"><st c="13138">cust_json = request.get_json()</st></strong><st c="13168">
        repo = CustomerRepository(db_session)
        </st><strong class="bold"><st c="13207">customer = Customer(**cust_json)</st></strong><st c="13239">
        result = repo.insert(customer)
        if result:
            content = jsonify(cust_json)
            current_app.logger.info('insert customer record successful')
            return make_response(content, 201)
        else:
            content = jsonify(message="insert customer record encountered a problem")
            return make_response(content, 500)</st></pre>			<p><st c="13521">Another</st><a id="_idIndexMarker173"/><st c="13529"> common approach is to use the </st><code><st c="13560">request.json</st></code><st c="13572"> property to </st><a id="_idIndexMarker174"/><st c="13585">capture the incoming message body, which is raw and with the mime-type </st><code><st c="13656">application/json</st></code><st c="13672">. The following endpoint function captures the incoming request through </st><code><st c="13744">request.json</st></code><st c="13756"> and stores the data in the database as </st><code><st c="13796">category</st></code><st c="13804"> information:</st></p>
			<pre class="source-code"><st c="13817">
@current_app.post('/category/add')
def add_category():
    if </st><strong class="bold"><st c="13876">request.is_json</st></strong><st c="13891">:
        </st><strong class="bold"><st c="13894">cat_json = request.json</st></strong><st c="13917">
        cat = Category(</st><strong class="bold"><st c="13933">**cat_json</st></strong><st c="13944">)
        repo = CategoryRepository(db_session)
        result = repo.insert(cat)
        … … … … … …
    else:
        abort(500)</st></pre>			<p><st c="14039">Unlike </st><code><st c="14047">request.get_json()</st></code><st c="14065">, which uses serialization, validation, and other utilities to transform and return incoming data to JSON, the </st><code><st c="14176">request.json</st></code><st c="14188"> property has no validation support other than raising an </st><code><st c="14246">HTTP status 400</st></code><st c="14261"> or </st><code><st c="14265">Bad Data</st></code><st c="14273"> error if the data is not JSON serializable. </st><st c="14318">The </st><code><st c="14322">request.get_json()</st></code><st c="14340"> returns </st><code><st c="14349">None</st></code><st c="14353"> if the request data is not parsable. </st><st c="14391">That is why it is best to pair the </st><code><st c="14426">request.is_json</st></code><st c="14441"> Boolean property with </st><code><st c="14464">request.json</st></code><st c="14476"> to verify the incoming request and filter the non-JSON </st><a id="_idIndexMarker175"/><st c="14532">message body to avoid </st><code><st c="14554">HTTP Status Code 500</st></code><st c="14574">. Another </st><a id="_idIndexMarker176"/><st c="14584">option is to check if the </st><code><st c="14610">Content-Type</st></code><st c="14622"> request header of the incoming request is </st><code><st c="14665">application/json</st></code><st c="14681">, as showcased by the following </st><st c="14713">API function:</st></p>
			<pre class="source-code"><st c="14726">
@current_app.post('/nonpizza/add')
def add_nonpizza():
     </st><strong class="bold"><st c="14782">content_type = request.headers.get('Content-Type')</st></strong><strong class="bold"><st c="14832">if content_type == 'application/json'</st></strong><st c="14870">:
        </st><strong class="bold"><st c="14873">nonpizza_json = request.json</st></strong><st c="14901">
        nonpizza = NonPizza(**nonpizza_json)
        … … … … … …
     else:
        abort(500)</st></pre>			<p><st c="14967">This </st><code><st c="14973">add_nonpizza()</st></code><st c="14987"> function inserts a new record for the non-pizza menu options for the application, and it uses </st><code><st c="15082">request.json</st></code><st c="15094"> to access the JSON-formatted input from the client. </st><st c="15147">Both </st><code><st c="15152">request.json</st></code><st c="15164"> and </st><code><st c="15169">request.get_json()</st></code><st c="15187"> yield a dictionary object that makes the instantiation of model objects in the </st><code><st c="15267">add_category()</st></code><st c="15281"> and </st><code><st c="15286">add_non_pizza()</st></code><st c="15301"> API functions easier because </st><code><st c="15331">kwargs</st></code><st c="15337"> transformation from these JSON data </st><st c="15374">is straightforward.</st></p>
			<p><st c="15393">On the other hand, validation of incoming requests using </st><code><st c="15451">request.is_json</st></code><st c="15466"> and </st><code><st c="15471">Content-Type</st></code><st c="15483"> headers is also applicable to the POST, PUT, and DELETE message body retrieval through </st><code><st c="15571">request.get_json()</st></code><st c="15589">. Now, another approach to accessing the message body that requires </st><code><st c="15657">request.is_json</st></code><st c="15672"> validation is through </st><code><st c="15695">request.data</st></code><st c="15707">. This property captures POST, PUT, or PATCH message bodies regardless of any </st><code><st c="15785">Content-Type</st></code><st c="15797">, thus requiring a thorough validation mechanism. </st><st c="15847">The following API function captures user credentials through </st><code><st c="15908">request.data</st></code><st c="15920"> and inserts the</st><a id="_idIndexMarker177"/><st c="15936"> login details</st><a id="_idIndexMarker178"/><st c="15950"> in </st><st c="15954">the database:</st></p>
			<pre class="source-code"><st c="15967">
@current_app.route('/login/add', methods = ['POST'])
def add_login():
    </st><strong class="bold"><st c="16038">if request.is_json:</st></strong><strong class="bold"><st c="16057">login_json = loads(request.data)</st></strong><st c="16090">
        login = Login(**login_json)
        … … … … … …
    else:
        abort(500)</st></pre>			<p><st c="16147">It is always feasible to use </st><code><st c="16177">request.data</st></code><st c="16189"> for HTTP POST transactions, such as in the given </st><code><st c="16239">add_login()</st></code><st c="16250"> function, but the API needs to parse and serialize the </st><code><st c="16306">request.data</st></code><st c="16318"> using Flask’s built-in </st><code><st c="16342">loads()</st></code><st c="16349"> decoder from the </st><code><st c="16367">flask.json</st></code><st c="16377"> module extension because the request data is not yet JSON-formatted. </st><st c="16447">Additionally, the process needs tight data type validation for each JSON object in the captured request data before using it in </st><st c="16575">the transactions.</st></p>
			<p><st c="16592">Aside from these variations of managing the incoming requests, Flask also has approaches to dealing with outgoing JSON responses. </st><st c="16723">Instead of </st><code><st c="16734">jsonify()</st></code><st c="16743">, another way to render a JSON response is by instantiating and returning </st><code><st c="16817">Response</st></code><st c="16825"> to the client. </st><st c="16841">The following is a </st><code><st c="16860">list_login()</st></code><st c="16872"> endpoint function that retrieves a list of </st><code><st c="16916">Login</st></code><st c="16921"> records from the database using the </st><code><st c="16958">Response</st></code><st c="16966"> class:</st></p>
			<pre class="source-code"><st c="16973">
@current_app.route('/login/list/all', methods = ['GET'])
def list_all_login():
    repo = LoginRepository(db_session)
    records = repo.select_all()
    login_rec = [rec.to_json() for rec in records]
    current_app.logger.info('retrieved a list of login successfully')
    </st><strong class="bold"><st c="17229">resp = Response(response = dumps(login_rec),</st></strong> <strong class="bold"><st c="17273">status=200, mimetype="application/json" )</st></strong><st c="17315">
    return resp</st></pre>			<p><st c="17327">When </st><a id="_idIndexMarker179"/><st c="17333">using </st><code><st c="17339">Response</st></code><st c="17347">, an encoder such as </st><code><st c="17368">dumps()</st></code><st c="17375"> of the </st><code><st c="17383">flask.json</st></code><st c="17393"> module</st><a id="_idIndexMarker180"/><st c="17400"> can be used to create a JSONable object from an object, list, or dictionary. </st><st c="17478">And the </st><code><st c="17486">mime-type</st></code><st c="17495"> should always be </st><code><st c="17513">application/json</st></code><st c="17529"> to force the object to </st><st c="17553">become JSON.</st></p>
			<p><st c="17565">Let us focus now on Flask’s built-in support for JSON types and the serialization and de-serialization utilities it has to process </st><st c="17697">JSON objects.</st></p>
			<h1 id="_idParaDest-81"><a id="_idTextAnchor082"/><st c="17710">Utilizing response encoders and decoders</st></h1>
			<p><st c="17751">Flask framework </st><a id="_idIndexMarker181"/><st c="17768">supports the built Python </st><code><st c="17794">json</st></code><st c="17798"> module by default. </st><st c="17818">The built-in encoders, </st><code><st c="17841">dumps()</st></code><st c="17848">, and </st><code><st c="17854">loads()</st></code><st c="17861">, are found in the </st><code><st c="17880">flask.json</st></code><st c="17890"> module. </st><st c="17899">In the </st><em class="italic"><st c="17906">Managing the requests and responses</st></em><st c="17941"> section, the </st><code><st c="17955">add_login()</st></code><st c="17966"> endpoint function uses the </st><code><st c="17994">flask.json.loads()</st></code><st c="18012"> to de-serialize and transform the </st><code><st c="18047">request.data</st></code><st c="18059"> into a JSONable dictionary. </st><st c="18088">Meanwhile, the </st><code><st c="18103">flask.json.dumps()</st></code><st c="18121"> provided the </st><code><st c="18135">Response</st></code><st c="18143"> class with a JSONable object for some JSON response output, as previously highlighted in the </st><code><st c="18237">list_all_login()</st></code><st c="18253"> endpoint.</st></p>
			<p><st c="18263">But any application can override these default encoding and decoding processes to solve some custom requirements. </st><st c="18378">Customizing an appropriate JSON provider by sub-classing Flask’s </st><code><st c="18443">JSONProvider</st></code><st c="18455">, found in the </st><code><st c="18470">flask.json.provider</st></code><st c="18489">, can allow the overriding of these JSON processes. </st><st c="18541">The following is a custom implementation of a </st><code><st c="18587">JSONProvider</st></code><st c="18599"> with some modifications to the </st><code><st c="18631">dumps()</st></code><st c="18638"> and </st><code><st c="18643">loads()</st></code><st c="18650"> algorithms:</st></p>
			<pre class="source-code">
<strong class="bold"><st c="18662">from flask.json.provider import JSONProvider</st></strong>
<strong class="bold"><st c="18707">import json</st></strong><st c="18719">
class ImprovedJsonProvider(</st><strong class="bold"><st c="18747">JSONProvider</st></strong><st c="18760">):
    def __init__(self, *args, **kwargs):
        self.options = kwargs
        super().__init__(*args, **kwargs)
    </st><strong class="bold"><st c="18857">def default(self, o):</st></strong>
<strong class="bold"><st c="18878">        if isinstance(o, date):</st></strong>
<strong class="bold"><st c="18902">            return o.strftime("%m/%d/%Y")</st></strong>
<strong class="bold"><st c="18932">        elif isinstance(o, datetime):</st></strong>
<strong class="bold"><st c="18962">            return o.strftime("%m/%d/%Y, %H:%M:%S")</st></strong>
<strong class="bold"><st c="19002">        return super().default(self, o)</st></strong>
<strong class="bold"><st c="19034">    def dumps(self, obj, **kwargs):</st></strong>
<strong class="bold"><st c="19066">        kwargs.setdefault("default", self.default)</st></strong><strong class="bold"><st c="19109">kwargs.setdefault("ensure_ascii", True)</st></strong><strong class="bold"><st c="19149">kwargs.setdefault("sort_keys", True)</st></strong>
<strong class="bold"><st c="19186">        return json.dumps(obj, **kwargs)</st></strong><st c="19219">
    def loads(self, s: str | bytes, **kwargs):
        </st><strong class="bold"><st c="19263">s_dict:dict = json.loads(s.decode('utf-8'))</st></strong><strong class="bold"><st c="19306">s_sanitized = dict((k, v) for k, v in</st></strong> <strong class="bold"><st c="19344">s_dict.items() if v)</st></strong><strong class="bold"><st c="19365">s_str = json.dumps(s_sanitized)</st></strong><st c="19397">
        return json.loads(</st><code><st c="19497">main.py</st></code><st c="19504"> module and assign the </st><code><st c="19527">app</st></code><st c="19530">’s </st><code><st c="19534">json</st></code><st c="19538"> attribute with the instance of the custom provider with the </st><code><st c="19599">app</st></code><st c="19602"> object as its constructor parameter. </st><st c="19640">The following is the setup of our custom </st><code><st c="19681">ImprovedJsonprovider</st></code><st c="19701"> in the online pizza </st><st c="19722">ordering prototype:</st></p>
			<pre class="source-code"><st c="19741">
app = create_app('../config_dev.toml')
</st><code><st c="19835">JSONProvider</st></code><st c="19847"> requires overriding its </st><code><st c="19872">dump()</st></code><st c="19878"> and </st><code><st c="19883">loads()</st></code><st c="19890"> methods. </st><st c="19900">Additional custom features, such as formatting encoded dates, filtering empty JSON properties, and validating key and value types, can be helpful to custom implementation. </st><st c="20072">For the serializer and de-serializer, the preferred JSON utility in customizing the </st><code><st c="20156">JSONProvider</st></code><st c="20168"> is Python’s built-in </st><code><st c="20190">json</st></code><st c="20194"> module.</st></p>
			<p><st c="20202">The </st><code><st c="20207">ImprovedJsonprovider</st></code><st c="20227"> class includes a custom </st><code><st c="20252">default()</st></code><st c="20261"> method that validates the property value types during encoding. </st><st c="20326">It coerces the </st><code><st c="20341">date</st></code><st c="20345"> or </st><code><st c="20349">datetime</st></code><st c="20357"> objects to have a defined format. </st><st c="20392">For the application to utilize this method during encoding, the overridden </st><code><st c="20467">dumps()</st></code><st c="20474"> must pass this </st><code><st c="20490">default()</st></code><st c="20499"> to Python’s </st><code><st c="20512">json.dumps()</st></code><st c="20524"> as the </st><code><st c="20532">kwargs["default"]</st></code><st c="20549"> value. </st><st c="20557">In addition, there are also other keyword arguments that can smoothen the encoding process, such as </st><code><st c="20657">ensure_scii</st></code><st c="20668">, which enables the replacement of non-ASCII characters with whitespaces, and </st><code><st c="20746">sort_keys</st></code><st c="20755">, which sorts the keys of the resulting dictionary in </st><st c="20809">ascending order.</st></p>
			<p><st c="20825">On the other </st><a id="_idIndexMarker183"/><st c="20839">hand, </st><code><st c="20845">ImprovedJsonprovider</st></code><st c="20865"> ‘s overridden </st><code><st c="20880">loads()</st></code><st c="20887"> method initially converts the string request data into a dictionary using Python’s </st><code><st c="20971">json.loads()</st></code><st c="20983"> before removing all the key-value pairs with empty values. </st><st c="21043">Afterward, </st><code><st c="21054">json.dumps()</st></code><st c="21066"> serializes the sanitized dictionary back to its string type before submitting it for JSON de-serialization. </st><st c="21175">Thus, running the </st><code><st c="21193">add_category()</st></code><st c="21207"> endpoint with a message body that has an empty description value will lead to </st><em class="italic"><st c="21286">HTTP Status Code 500</st></em><st c="21306">, as shown in </st><em class="italic"><st c="21320">Figure 3</st></em><em class="italic"><st c="21328">.3</st></em><st c="21330">:</st></p>
			<div><div><img src="img/B19383_03_3.jpg" alt="Figure 3.3 – Applying the overridden flask.json.loads() decoder"/><st c="21332"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="21744">Figure 3.3 – Applying the overridden flask.json.loads() decoder</st></p>
			<p><st c="21807">The removal of the </st><code><st c="21827">description</st></code><st c="21838"> property by the custom </st><code><st c="21862">loads()</st></code><st c="21869"> caused the constructor error flagged in the </st><code><st c="21914">cURL</st></code><st c="21918"> command execution in </st><em class="italic"><st c="21940">Figure 3</st></em><em class="italic"><st c="21948">.3</st></em><st c="21950">.</st></p>
			<p><st c="21951">Now, the following are </st><a id="_idIndexMarker184"/><st c="21975">the deprecated features that will not work anymore in Flask 3.x </st><st c="22039">and onwards:</st></p>
			<ul>
				<li><code><st c="22051">JSONEncoder</st></code><st c="22063"> and </st><code><st c="22068">JSONDecoder</st></code><st c="22079"> APIs customize </st><code><st c="22095">flask.json.dumps()</st></code><st c="22113"> and </st><code><st c="22118">flask.json.loads()</st></code><st c="22136">, respectively.</st></li>
				<li><code><st c="22151">json_encoder</st></code><st c="22164"> and </st><code><st c="22169">json_decoder</st></code><st c="22181"> attributes set up </st><code><st c="22200">JSONEncoder</st></code><st c="22211"> and </st><code><st c="22216">JSONDecoder</st></code><st c="22227">, respectively.</st></li>
			</ul>
			<p><st c="22242">Also, the following setup applied in Python’s </st><code><st c="22289">json</st></code><st c="22293"> encoder and decoder during customization will not work here in the </st><st c="22361">Flask framework:</st></p>
			<ul>
				<li><st c="22377">Specifying the </st><code><st c="22393">flask.json.loads()</st></code><st c="22411"> encoder directly with </st><st c="22434">the custom.</st></li>
				<li><st c="22445">Specifying the </st><code><st c="22461">flask.json.dumps()</st></code><st c="22479"> decoder directly with the custom implementation class using the non-existent </st><code><st c="22557">cls</st></code><st c="22560"> kwarg.</st></li>
			</ul>
			<p><st c="22567">Since </st><code><st c="22574">JSONEcoder</st></code><st c="22584"> and </st><code><st c="22589">JSONDecoder</st></code><st c="22600"> will be obsolete soon, there will be no other means to customize these JSON utilities but through </st><st c="22699">the </st><code><st c="22703">JSONProvider</st></code><st c="22715">.</st></p>
			<p><st c="22716">However, there are instances where the incoming message body or the outgoing JSON responses are complex and huge, which cannot be handled optimally by the built-in JSON provider. </st><st c="22896">In this case, Flask allows replacing the existing provider with a fast, accurate, and flexible provider, such as </st><code><st c="23009">ujson</st></code><st c="23014"> and </st><code><st c="23019">orjson</st></code><st c="23025">. The following class is a sub-class of the </st><code><st c="23069">JSONProvider</st></code><st c="23081"> that uses the </st><code><st c="23096">orjson</st></code><st c="23102"> encoder </st><st c="23111">and decoder.</st></p>
			<pre class="source-code"><st c="23123">
from flask.json.provider import JSONProvider
</st><strong class="bold"><st c="23169">import orjson</st></strong><st c="23182">
class OrjsonJsonProvider(JSONProvider):
    def __init__(self, *args, **kwargs):
        self.options = kwargs
        super().__init__(*args, **kwargs)
    def dumps(self, obj, **kwargs):
        </st><strong class="bold"><st c="23348">return orjson.dumps(obj,</st></strong> <strong class="bold"><st c="23372">option=orjson.OPT_NON_STR_KEYS).decode('utf-8')</st></strong><st c="23420">
    def loads(self, s, **kwargs):
        </st><code><st c="23478">OrjsonJsonProvider</st></code><st c="23496"> implements a</st><a id="_idIndexMarker185"/><st c="23509"> custom JSON provider that uses </st><code><st c="23541">orjson</st></code><st c="23547">, one of the fastest JSON libraries that supports several </st><a id="_idIndexMarker186"/><st c="23605">types, such as </st><code><st c="23620">datetime</st></code><st c="23628">, </st><code><st c="23630">dataclass</st></code><st c="23639">, </st><code><st c="23641">numpy</st></code><st c="23646"> types, and </st><strong class="bold"><st c="23658">Universally Unique </st></strong><strong class="bold"><st c="23677">Identifiers</st></strong><st c="23688"> (</st><strong class="bold"><st c="23690">UUID</st></strong><st c="23694">).</st></p>
			<p><st c="23697">Another essential add-on that can further improve our RESTful application’s validation and handling of incoming body requests and outgoing responses is </st><em class="italic"><st c="23850">route filters</st></em><st c="23863">.</st></p>
			<h1 id="_idParaDest-82"><a id="_idTextAnchor083"/><st c="23864">Filtering API requests and responses</st></h1>
			<p><st c="23901">In </st><a href="B19383_01.xhtml#_idTextAnchor014"><em class="italic"><st c="23905">Chapter 1</st></em></a><st c="23914">, the CRUD </st><a id="_idIndexMarker187"/><st c="23925">operations of every view function became possible without an </st><a id="_idIndexMarker188"/><st c="23986">ORM because of a custom decorator, </st><code><st c="24021">@connect_db</st></code><st c="24032">. The decorator was responsible for database connectivity and closure for every execution of the view function. </st><st c="24144">Like in any Python decorator, the </st><code><st c="24178">@connect_db</st></code><st c="24189"> executes first before the view function starts receiving the requests from the client and executes after the view generates </st><st c="24314">the response.</st></p>
			<p><st c="24327">On the other hand, </st><a href="B19383_02.xhtml#_idTextAnchor047"><em class="italic"><st c="24347">Chapter 2</st></em></a><st c="24356"> introduced the use of </st><code><st c="24379">@before_request</st></code><st c="24394"> and </st><code><st c="24399">@after_request</st></code><st c="24413"> decorators in managing the application context of the view functions. </st><st c="24484">Our applications used them to access the session </st><code><st c="24533">db</st></code><st c="24535"> object for SQLAlchemy’s database connectivity, impose user authentication, and perform </st><st c="24623">software logging.</st></p>
			<p><st c="24640">Using decorators to manage the requests and responses for a view or API function is called route filtering. </st><st c="24749">The following are implementations of Flask’s </st><code><st c="24794">before_request</st></code><st c="24808"> and </st><code><st c="24813">after_request</st></code><st c="24826"> methods used by the </st><code><st c="24847">ch03</st></code><st c="24851"> application to filter the </st><st c="24878">request–response handshake:</st></p>
			<pre class="source-code">
<strong class="bold"><st c="24905">from flask import request, abort, Response</st></strong>
<strong class="bold"><st c="24948">@app.before_request</st></strong><st c="24968">
def before_request_func():
    api_method = request.method
    if api_method in ['POST', 'PUT', 'PATCH']:
        if request.json == '' or request.json == None:
            abort(500, description="request body is empty")
    api_endpoint_func = request.endpoint
    api_path = request.path
    app.logger.info(f'accessing URL endpoint: {api_path}, function name: {api_endpoint_func} ')
</st><strong class="bold"><st c="25315">@app.after_request</st></strong><st c="25333">
def after_request_func(response:Response):
    api_endpoint_func = request.endpoint
    api_path = request.path
    resp_allow_origin = response.access_control_allow_origin
    app.logger.info(f"access_control_allow_origin header: {resp_allow_origin}")
    app.logger.info(f'exiting URL endpoint: {api_path}, function name: {api_endpoint_func} ')
    return response</st></pre>			<p><st c="25676">In this </st><a id="_idIndexMarker189"/><st c="25685">application, </st><code><st c="25698">before_request</st></code><st c="25712"> checks if the incoming request body of </st><a id="_idIndexMarker190"/><st c="25752">HTTP POST, PUT, or PATCH transaction is not empty or </st><code><st c="25805">None</st></code><st c="25809">. Otherwise, it raises an </st><code><st c="25835">HTTP Status Code 500</st></code><st c="25855"> with the error message </st><code><st c="25879">request body is empty</st></code><st c="25900">. It also performs logging for audit purposes. </st><st c="25947">The </st><code><st c="25951">after_request</st></code><st c="25964"> method, on the other hand, logs the basic details of the API for tracing purposes and checks the </st><code><st c="26062">access_control_allow_origin</st></code><st c="26089"> response header. </st><st c="26107">The mandatory parameter response allows us to access the response headers for modification if given by the software requirement. </st><st c="26236">Also, this is the best spot to create cookies and execute the last database commits since this is the last moment of access to the response object before the </st><code><st c="26394">after_request</st></code><st c="26407"> method sends it to </st><st c="26427">the client.</st></p>
			<p><st c="26438">Like FastAPI, the Flask framework has its version of creating middleware-like components, which can act as a global route filter. </st><st c="26569">Our application has the following implementation, which serves as a middleware to the </st><st c="26655">API endpoints:</st></p>
			<pre class="source-code">
<strong class="bold"><st c="26669">import werkzeug.wrappers</st></strong>
<strong class="bold"><st c="26694">import werkzeug.wsgi</st></strong><st c="26715">
class AppMiddleware:
    def __init__(self, app):
        self.app = app
    def __call__(self, environ, start_response):
        request = </st><strong class="bold"><st c="26832">werkzeug.wrappers.Request</st></strong><st c="26857">(environ)
        api_path = request.url
        app.logger.info(f'accessing URL endpoint: {api_path} ')
        iterator:</st><strong class="bold"><st c="26956">werkzeug.wsgi.ClosingIterator</st></strong><st c="26986"> = self.app(environ, start_response)
        app.logger.info(f'exiting URL …: {api_path} ')
        </st><code><st c="27145">AppleMiddleware</st></code><st c="27160">, the </st><a id="_idIndexMarker192"/><st c="27166">involved </st><code><st c="27175">Request</st></code><st c="27182"> API class is from the </st><code><st c="27205">werkzeug</st></code><st c="27213"> module or the core platform itself since the implementation is server-level. </st><st c="27291">Instantiating the </st><code><st c="27309">werkzeug.wrappers.Request</st></code><st c="27334"> with the </st><code><st c="27344">environ</st></code><st c="27351"> parameter as its constructor argument will give us access to the details of the incoming request of the API endpoint. </st><st c="27470">Unfortunately, there is no direct way of accessing the response object within the filter class. </st><st c="27566">Some implementations require the creation of hook methods by registering custom decorators to Flask through the custom middleware, and others use external modules to implement a middleware that acts like a URL dispatcher. </st><st c="27788">Now, our custom middleware must be a callable class type, so all the implementations must be in its overridden </st><code><st c="27899">__call__()</st></code><st c="27909"> method.</st></p>
			<p><st c="27917">Moreover, we can </st><a id="_idIndexMarker193"/><st c="27935">also associate </st><code><st c="27950">Blueprint</st></code><st c="27959"> modules with their respective </st><a id="_idIndexMarker194"/><st c="27990">custom before and after filter methods, if required. </st><st c="28043">The following </st><code><st c="28057">app</st></code><st c="28060"> configuration assigns filter methods to the </st><code><st c="28105">order_cient_bp</st></code><st c="28119"> and </st><code><st c="28124">pizza_client_bp</st></code> <code><st c="28139">Blueprint</st></code><st c="28149">s of the </st><code><st c="28159">ch03-client</st></code><st c="28170"> application:</st></p>
			<pre class="source-code"><st c="28183">
app.</st><strong class="bold"><st c="28188">before_request_funcs</st></strong><st c="28209"> = {
    'orders_client_bp': [before_check_api_server],
    'pizza_client_bp': [before_log_pizza_bp]
}
app.</st><strong class="bold"><st c="28308">after_request_funcs</st></strong><st c="28328"> = {
    'orders_client_bp': [after_check_api_server],
    'pizza_client_bp': [after_log_pizza_bp]
}</st></pre>			<p><st c="28420">Both </st><code><st c="28426">before_request_funcs</st></code><st c="28446"> and </st><code><st c="28451">after_request_funcs</st></code><st c="28470"> contain the concerned </st><code><st c="28493">Blueprint</st></code><st c="28502"> names and their corresponding lists of implemented filter </st><st c="28561">method names.</st></p>
			<p><st c="28574">Can we also apply the same exception-handling directives used in the web-based applications of </st><em class="italic"><st c="28670">Chapters 1</st></em><st c="28680"> and </st><em class="italic"><st c="28685">2</st></em><st c="28686">? Let us find out in the </st><st c="28711">following discussion.</st></p>
			<h1 id="_idParaDest-83"><a id="_idTextAnchor084"/><st c="28732">Handling exceptions</st></h1>
			<p><st c="28752">In RESTful applications, Flask </st><a id="_idIndexMarker195"/><st c="28784">allows the endpoint function to trigger error handlers that return error messages in JSON format. </st><st c="28882">The following snippets are the error handlers of our </st><code><st c="28935">ch03</st></code><st c="28939"> application:</st></p>
			<pre class="source-code"><st c="28952">
@app.errorhandler(404)
def not_found(e):
    </st><strong class="bold"><st c="28994">return jsonify(error=str(e)), 404</st></strong><st c="29027">
@app.errorhandler(400)
def bad_request(e):
    </st><strong class="bold"><st c="29071">return jsonify(error=str(e)), 400</st></strong><st c="29104">
def server_error(e):
    print(e)
    </st><strong class="bold"><st c="29135">return jsonify(error=str(e)), 500</st></strong><st c="29168">
app.register_error_handler(500, server_error)</st></pre>			<p><st c="29214">Error handlers can also return the JSON response through the </st><code><st c="29276">jsonify()</st></code><st c="29285">, </st><code><st c="29287">make_response()</st></code><st c="29302">, or </st><code><st c="29307">Response</st></code><st c="29315"> class. </st><st c="29323">As shown in the given error handlers, the implementation is the same with the web-based error handlers except for the </st><code><st c="29441">jsonify()</st></code><st c="29450"> method, which serializes the captured error message to the JSON type instead of </st><st c="29531">using </st><code><st c="29537">render_template()</st></code><st c="29554">.</st></p>
			<p><st c="29555">Custom exception </st><a id="_idIndexMarker196"/><st c="29573">classes must include both the </st><em class="italic"><st c="29603">HTTP Status Code</st></em><st c="29619"> and error message in the JSON message. </st><st c="29659">The customization must include a </st><code><st c="29692">to_dict()</st></code><st c="29701"> method that will convert the payload and other external parameters to a dictionary object for the </st><code><st c="29800">jsonify()</st></code><st c="29809"> to serialize. </st><st c="29824">The following is a custom exception class raised by our </st><code><st c="29880">INSERT</st></code><st c="29886"> repository transactions and </st><st c="29915">endpoint functions:</st></p>
			<pre class="source-code"><st c="29934">
class DuplicateRecordException(HTTPException):
    status_code = 500
    def __init__(self, message, status_code=None, payload=None):
        super().__init__()
        self.message = message
        if status_code is not None:
            self.status_code = status_code
        self.payload = payload
    </st><code><st c="30292">DuplicateRecordException</st></code><st c="30316">, the following error handler will access its </st><code><st c="30362">to_dict()</st></code><st c="30371"> instance method and convert it to JSON through </st><code><st c="30419">jsonify()</st></code><st c="30428">. It will also access the </st><code><st c="30454">status_code</st></code><st c="30465"> for </st><st c="30470">the response:</st></p>
			<pre class="source-code"><st c="30483">
@app.errorhandler(</st><strong class="bold"><st c="30502">DuplicateRecordException</st></strong><st c="30527">)
def insert_record_exception(e):
    return </st><code><st c="30686">Database</st></code><strong class="source-inline"><st c="30694">
RecordException</st></strong><st c="30710">, triggering this </st><code><st c="30728">insert_record_exception()</st></code><st c="30753"> handler. </st><st c="30763">But for Python-related exceptions, the following error handler will also render the built-in exception messages in </st><st c="30878">JSON format:</st></p>
			<pre class="source-code"><st c="30890">
@app.errorhandler(Exception)
def handle_built_exception(e):
    if isinstance(e, HTTPException):
        return e
    </st><code><st c="31032">handle_built_exception()</st></code><st c="31056"> handler will always return a JSON-formatted error message and raise the Werkzeug-specific exceptions for other custom handlers to manage. </st><st c="31195">But for raised Python-specific exceptions, </st><code><st c="31238">handle_built_exception()</st></code><st c="31262"> will directly render the JSON</st><a id="_idIndexMarker198"/> <st c="31292">error message.</st></p>
			<p><st c="31307">After completing the needed components in building our RESTful application, it is time to consume these API endpoints using a </st><st c="31434">client application.</st></p>
			<h1 id="_idParaDest-84"><a id="_idTextAnchor085"/><st c="31453">Consuming API endpoints</st></h1>
			<p><st c="31477">Our </st><code><st c="31482">ch03-client</st></code><st c="31493"> project is </st><a id="_idIndexMarker199"/><st c="31505">a web-based Flask application that utilizes the API endpoints created in the </st><code><st c="31582">ch03</st></code><st c="31586"> application. </st><st c="31600">So far, the easiest way to consume a Flask API endpoint is to use the </st><code><st c="31670">requests</st></code><st c="31678"> extension module. </st><st c="31697">To install the </st><code><st c="31712">requests</st></code><st c="31720"> library, run the </st><st c="31738">following command:</st></p>
			<pre class="console"><st c="31756">
pip install requests</st></pre>			<p><st c="31777">This </st><code><st c="31783">requests</st></code><st c="31791"> module has a </st><code><st c="31805">get()</st></code><st c="31810"> helper method to send an HTTP GET request to a URL to retrieve some server resources. </st><st c="31897">The following view function from the </st><code><st c="31934">ch03-client</st></code><st c="31945"> project retrieves a list of customers and employees from the </st><code><st c="32007">ch03</st></code><st c="32011"> application and passes them as context data to the </st><code><st c="32063">add_order.html</st></code><st c="32077"> template:</st></p>
			<pre class="source-code"><st c="32087">
@current_app.route('/client/order/add', methods = ['GET', 'POST'])
def add_order():
    if request.method == 'POST':
        order_dict = request.form.to_dict(flat=True)
        </st><strong class="bold"><st c="32246">order_add_api = "http://localhost:5000/order/add"</st></strong><strong class="bold"><st c="32295">response: requests.Response =</st></strong> <strong class="bold"><st c="32325">requests.post(order_add_api, json=order_dict)</st></strong><strong class="bold"><st c="32371">customers_list_api =</st></strong> <strong class="bold"><st c="32392">"http://localhost:5000/customer/list/all"</st></strong><strong class="bold"><st c="32434">employees_list_api =</st></strong> <strong class="bold"><st c="32455">"http://localhost:5000/employee/list/all"</st></strong><strong class="bold"><st c="32497">resp_customers:requests.Response = requests.get(customers_list_api)</st></strong><strong class="bold"><st c="32565">resp_employees:requests.Response = requests.get(employees_list_api)</st></strong><st c="32633">
    return render_template('add_order.html', customers=</st><code><st c="32747">get()</st></code><st c="32752"> method returns a </st><code><st c="32770">requests.Response</st></code><st c="32787"> object that contains essential details, such as </st><code><st c="32836">content</st></code><st c="32843">, </st><code><st c="32845">url</st></code><st c="32848">, </st><code><st c="32850">status_code</st></code><st c="32861">, </st><code><st c="32863">json()</st></code><st c="32869">, </st><code><st c="32871">encoding</st></code><st c="32879">, and other headers from the API’s server. </st><st c="32922">Our </st><code><st c="32926">add_order()</st></code><st c="32937"> calls the </st><code><st c="32948">json()</st></code><st c="32954"> for each GET response to serialize the result in </st><st c="33004">JSON format.</st></p>
			<p><st c="33016">For the HTTP POST transaction, the </st><code><st c="33052">request</st></code><st c="33059"> module has a </st><code><st c="33073">post()</st></code><st c="33079"> method to send an HTTP POST request to </st><code><st c="33119">http://localhost:5000/order/add </st></code><st c="33151">API. </st><st c="33156">For a successful POST request handshake, the </st><code><st c="33201">post()</st></code><st c="33207"> requires the URL of the API service and the record or object as the request body in </st><st c="33292">dictionary format.</st></p>
			<p><st c="33310">Aside from the dictionary type, the </st><code><st c="33347">post()</st></code><st c="33353"> method can also allow the submission of a list of </st><em class="italic"><st c="33404">tuples</st></em><st c="33410">, </st><em class="italic"><st c="33412">bytes</st></em><st c="33417">, or </st><em class="italic"><st c="33422">file entity types</st></em><st c="33439">. It also has various parameter options such as </st><code><st c="33487">data</st></code><st c="33491">, </st><code><st c="33493">json</st></code><st c="33497">, or </st><code><st c="33502">files</st></code><st c="33507"> that can accept the appropriate</st><a id="_idIndexMarker200"/><st c="33539"> request </st><st c="33548">body types.</st></p>
			<p><st c="33559">Now, other than </st><code><st c="33576">get()</st></code><st c="33581"> and </st><code><st c="33586">post()</st></code><st c="33592"> methods, the </st><code><st c="33606">requests</st></code><st c="33614"> library has other helper methods that can also send other HTTP requests to the server, such as the </st><code><st c="33714">put()</st></code><st c="33719"> that calls the PUT API service, </st><code><st c="33752">delete()</st></code><st c="33760"> that calls DELETE API service, and </st><code><st c="33796">patch()</st></code><st c="33803"> for the PATCH </st><st c="33818">API service.</st></p>
			<h1 id="_idParaDest-85"><a id="_idTextAnchor086"/><st c="33830">Summary</st></h1>
			<p><st c="33838">This chapter has proven to us that some components apply to both API-based and web-based applications, but there are specific components that fit better in API transactions than in web-based ones. </st><st c="34036">It provided details on Flask’s JSON de-serialization applied to request bodies and serialization of outgoing objects to be part of the API responses. </st><st c="34186">The many options of capturing the request body through </st><code><st c="34241">request.json</st></code><st c="34253">, </st><code><st c="34255">request.data</st></code><st c="34267">, and </st><code><st c="34273">request.get_json()</st></code><st c="34291"> and generating responses through its </st><code><st c="34329">jsonify()</st></code><st c="34338"> or </st><code><st c="34342">make_response()</st></code><st c="34357"> and </st><code><st c="34362">Response</st></code><st c="34370"> class with </st><code><st c="34382">application/json</st></code><st c="34398"> as a mime-type show Flask’s flexibility as </st><st c="34442">a framework.</st></p>
			<p><st c="34454">The chapter also showcased Flask’s ability to adapt to different third-party JSON providers through sub-classing its </st><code><st c="34572">JSONProvider</st></code><st c="34584"> class. </st><st c="34592">Moreover, the many options for providing our API endpoints with route filtering mechanisms also show that the platform can manage the application’s incoming requests and outgoing responses like any good framework. </st><st c="34806">Regarding error handling mechanisms, the framework can provide error handlers for web-based applications that render templates and those that send JSON responses for </st><st c="34972">RESTful applications.</st></p>
			<p><st c="34993">When consuming the API endpoints, this chapter exhibited that Flask could support typical Python REST client modules, such as </st><code><st c="35120">requests</st></code><st c="35128">, without any </st><st c="35142">additional workaround.</st></p>
			<p><st c="35164">So, we have seen that Flask can support building web-based and API-based applications even though it is lightweight and </st><st c="35285">a microframework.</st></p>
			<p><st c="35302">The next chapter will discuss simplifying and organizing Flask implementations using popular third-party Flask </st><st c="35414">module extensions.</st></p>
		</div>
	<div></body></html>