- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Testing and Logging – Preparing for Bugs
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试和日志记录 – 为bug做准备
- en: When programming, most developers plan a bit and immediately start writing code.
    After all, we all expect to write bug-free code! Unfortunately, we don’t. At some
    point, an incorrect assumption, a misinterpretation, or just a silly mistake is
    bound to happen. Debugging (covered in *Chapter 11*, *Debugging – Solving the
    Bugs*) will always be required at some point, but there are several methods that
    you can use to prevent bugs or, at the very least, make it much easier to solve
    them when they do occur.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当编程时，大多数开发者会稍微规划一下，然后立即开始编写代码。毕竟，我们都期望编写无bug的代码！不幸的是，我们并不总是能做到。在某个时候，一个错误的假设、误解，或者仅仅是愚蠢的错误是不可避免的。调试（在第11章“调试
    - 解决bug”中介绍）在某个时候总是需要的，但你可以使用几种方法来防止bug，或者至少在它们发生时使解决它们变得容易得多。
- en: To prevent bugs from occurring in the first place, test-driven development or,
    at the very least, functional/regression/unit tests, are very useful. The standard
    Python installation alone offers several options such as the `doctest`, `unittest`,
    and `test` modules. The `doctest` module allows you to combine tests with example
    documentation. The `unittest` module allows you to easily write regression tests.
    The `test` module is meant for internal usage only, so unless you are planning
    to modify the Python core, you probably won’t need this one.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止bug从一开始就出现，测试驱动开发或至少功能/回归/单元测试非常有用。仅标准Python安装就提供了几个选项，如 `doctest`、`unittest`
    和 `test` 模块。`doctest` 模块允许你将测试与示例文档结合起来。`unittest` 模块允许你轻松编写回归测试。`test` 模块仅用于内部使用，所以除非你打算修改Python核心，否则你可能不需要这个模块。
- en: 'The test modules we will discuss in this chapter are:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将讨论的测试模块包括：
- en: '`doctest`'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`doctest`'
- en: '`py.test` (and why it’s more convenient than `unittest`)'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`py.test`（以及为什么它比 `unittest` 更方便）'
- en: '`unittest.mock`'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unittest.mock`'
- en: The `py.test` module has roughly the same purpose as the `unittest` module,
    but it’s much more convenient to use and has many more options and plugins available.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '`py.test` 模块与 `unittest` 模块大致具有相同的目的，但使用起来更方便，并且有更多的选项和插件可用。'
- en: After learning how to avoid the bugs, it’ll be time to take a look at logging
    so that we can inspect what is happening in our program and why. The `logging`
    module in Python is highly configurable and can be adjusted for just about any
    use case. If you’ve ever written Java code, you should feel right at home with
    the `logging` module, as its design is largely based on the `log4j` module and
    is very similar in both implementation and naming. The latter makes it a bit of
    an odd module in Python as well, as it is one of the few modules that does not
    follow the `pep8` naming standards.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习了如何避免bug之后，我们将来看看日志记录，这样我们就可以检查程序中发生了什么以及为什么。Python中的 `logging` 模块非常可配置，几乎可以调整到任何使用场景。如果你曾经编写过Java代码，你应该对
    `logging` 模块感到非常熟悉，因为其设计在很大程度上基于 `log4j` 模块，在实现和命名上都非常相似。后者使它成为Python中一个有点奇怪的模块，因为它是不遵循
    `pep8` 命名标准的少数模块之一。
- en: 'This chapter will explain the following topics:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将解释以下主题：
- en: Combining documentation with tests using `doctest`
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `doctest` 将文档与测试结合起来
- en: Regression and unit tests using `py.test` and `unittest`
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `py.test` 和 `unittest` 进行回归和单元测试
- en: Testing with fake objects using `unittest.mock`
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `unittest.mock` 进行模拟对象测试
- en: Testing multiple environments using `tox`
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `tox` 测试多个环境
- en: Using the `logging` module effectively
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有效使用 `logging` 模块
- en: Combining `logging` and `py.test`
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结合 `logging` 和 `py.test`
- en: Using documentation as tests with doctest
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 doctest 将文档作为测试
- en: The `doctest` module is one of the most useful modules within Python. It allows
    you to combine documenting your code with tests to make sure that it keeps working
    as it is supposed to.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`doctest` 模块是Python中最有用的模块之一。它允许你将代码文档与测试结合起来，以确保代码按预期工作。'
- en: By now the format should be very familiar to you; most of the code samples in
    this book use the `doctest` format, which offers the advantage that both the input
    and the output are shown intertwined. Especially in demonstrations, this is much
    more convenient than having a block of code followed by the output.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，格式应该对你来说非常熟悉；本书中的大多数代码示例都使用 `doctest` 格式，它提供了输入和输出交织显示的优势。特别是在演示中，这比代码块后面跟着输出要方便得多。
- en: A simple doctest example
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个简单的 doctest 示例
- en: 'Let’s start with a quick example: a function that squares the input. The following
    example is a fully functional command-line application, containing not only code
    but also functioning tests. The first few tests cover how the function is supposed
    to behave when executing normally, followed by a few tests to demonstrate the
    expected errors:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个小例子开始：一个平方输入的函数。以下示例是一个完全功能的命令行应用程序，不仅包含代码，还包含功能测试。前几个测试覆盖了函数在正常执行时的预期行为，然后是一些测试来演示预期的错误：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'It can be executed as any Python script, but the regular command won’t give
    any output as all tests are successful. The `doctest.testmod` function takes verbosity
    parameters, luckily:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以像任何Python脚本一样执行，但常规命令不会输出任何内容，因为所有测试都成功了。幸运的是，`doctest.testmod`函数有可变参数：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Additionally, since it uses the Google syntax (as discussed in *Chapter 9*,
    *Documentation – How to Use Sphinx and reStructuredText*, the documentation chapter),
    we can generate pretty documentation using Sphinx:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于它使用的是Google语法（如第9章所述，*文档 – 如何使用Sphinx和reStructuredText*，文档章节），我们可以使用Sphinx生成漂亮的文档：
- en: '![A simple doctest example](img/B15882_10_01.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![一个简单的doctests示例](img/B15882_10_01.png)'
- en: 'Figure 10.1: Documentation generated using Sphinx'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1：使用Sphinx生成的文档
- en: However, the code is not always correct, of course. What will happen if we modify
    the code so that the tests do not pass anymore?
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，代码并不总是正确的，当然。如果我们修改代码使得测试不再通过，会发生什么呢？
- en: 'This time, instead of `n * n`, we use `n ** 2`. Both square a number, so the
    results must be identical. Right? These are the types of assumptions that create
    bugs, and the types of assumptions that are trivial to catch using a few basic
    tests. Since most results are the same we will skip them in the example, but one
    test has different results now:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们使用的是`n ** 2`而不是`n * n`。两者都平方一个数，所以结果必须相同。对吧？这些就是那些导致错误的假设类型，也是使用一些基本测试很容易捕捉到的假设类型。由于大多数结果都是相同的，我们将在示例中跳过它们，但有一个测试现在有不同的结果：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The only modification we made to the code was replacing `n * n` with `n ** 2`,
    which translates to the power function. Since multiplication is not the same as
    taking the power of a number, the results are slightly different, but similar
    enough in practice that most programmers wouldn’t notice the difference.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对代码做的唯一修改是将`n * n`替换为`n ** 2`，这相当于幂函数。由于乘法不等于取一个数的幂，结果略有不同，但在实践中足够相似，以至于大多数程序员不会注意到差异。
- en: 'Because of that difference, however, the error changed from `can''t multiply
    sequence ...` to `unsupported operand type(s) for ** or pow(): ...`. It’s an innocent
    mistake, but a quick optimization by a programmer could have changed this unintentionally
    with possibly wrong results. If the `__pow__` method was overloaded with different
    behavior, for example, this could result in bigger problems.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '然而，由于这种差异，错误从`can''t multiply sequence ...`变成了`不支持的操作类型(s) for ** 或 pow():
    ...`。这是一个无辜的错误，但一个程序员的快速优化可能会无意中将其改变，并可能得到错误的结果。例如，如果`__pow__`方法被重载为不同的行为，这可能会导致更大的问题。'
- en: This example has shown us how useful these tests can be. When rewriting or optimizing
    code, an incorrect assumption is easily made, and that is where tests are very
    useful—knowing you are breaking code as soon as you break it instead of finding
    out months later.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子向我们展示了这些测试有多么有用。在重写或优化代码时，很容易做出错误的假设，而这就是测试非常有用的地方——当你破坏代码时立即知道，而不是几个月后才发现。
- en: Writing doctests
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写doctests
- en: 'Perhaps you have noticed from the preceding examples that the syntax is very
    similar to the regular Python console, and that is because it is. The `doctest`
    input is nothing more than the output of a regular Python shell session. This
    is what makes testing with this module so intuitive; simply write the code in
    the Python console and copy the output into a docstring to get tests. Here is
    an example:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你已经注意到，从前面的例子中，语法非常类似于常规Python控制台，这是因为它是。`doctest`输入不过是常规Python外壳会话的输出。这就是使用这个模块进行测试如此直观的原因；只需在Python控制台中编写代码，然后将输出复制到文档字符串中即可获得测试。以下是一个示例：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: That’s why this is probably the easiest way to test code. With almost no effort,
    you can check whether your code is working as you would expect it, add tests,
    and add documentation at the same time. Simply copy the output from the interpreter
    to your function or class documentation and you have functioning doctests.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么这可能是测试代码的最简单方式。几乎不需要任何努力，您就可以检查代码是否按预期工作，添加测试，并添加文档。只需将解释器的输出复制到您的函数或类文档中，您就有了一个功能性的
    doctests。
- en: Testing with documentation
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用文档进行测试
- en: The docstrings in functions, classes, and modules are usually the most obvious
    way to add doctests to your code, but they are not the only way. The Sphinx documentation,
    as we discussed in the previous chapter, also supports the `doctest` module.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 函数、类和模块中的文档字符串通常是向代码添加 doctests 的最明显方式，但它们并不是唯一的方式。正如我们在上一章中讨论的，Sphinx 文档也支持
    `doctest` 模块。
- en: To enable `doctest` support in Sphinx, you need to add the `sphinx.ext.doctest`
    extension in Sphinx, which tells Sphinx to run those tests as well. Since not
    all the examples in the code are useful, let’s see whether we can split them into
    the ones that are actually useful and the ones that are only relevant for documentation.
    Moreover, to see the results, we will add an error to the documentation.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Sphinx 中启用 `doctest` 支持，您需要在 Sphinx 中添加 `sphinx.ext.doctest` 扩展，这将告诉 Sphinx
    也要运行这些测试。由于代码中的并非所有示例都有用，让我们看看我们是否可以将它们分成真正有用的和仅与文档相关的部分。此外，为了查看结果，我们将在文档中添加一个错误。
- en: '`square.py`'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`square.py`'
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`square.rst`'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`square.rst`'
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, it’s time to execute the tests. In the case of Sphinx, there is a specific
    command for this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候执行测试了。在 Sphinx 的情况下，有一个特定的命令用于此操作：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As expected, we are getting an error for the incomplete `doctest`, but beyond
    that, all tests executed correctly. To make sure that the tests know what `square`
    is, we had to add the `testsetup` directive, and this still generates a pretty
    output:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期，我们得到了一个不完整的 `doctest` 错误，但除此之外，所有测试都执行正确。为了确保测试知道 `square` 是什么，我们不得不添加 `testsetup`
    指令，这仍然生成一个相当好的输出：
- en: '![](img/B15882_10_02.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15882_10_02.png)'
- en: 'Figure 10.2: Rendered Sphinx output'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.2：渲染的 Sphinx 输出
- en: Sphinx nicely renders both the documentation for the code and the highlighted
    code samples.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Sphinx 优雅地渲染了代码的文档和突出显示的代码示例。
- en: The doctest flags
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: doctest 标志
- en: 'The `doctest` module features several option flags that affect how `doctest`
    processes the tests. These option flags can be passed globally using your test
    suite, through command-line parameters while running the tests, and through inline
    commands. For this book, I have globally enabled the following option flags through
    a `pytest.ini` file (we will cover more about `py.test` later in this chapter):'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`doctest` 模块具有几个选项标志，这些标志会影响 `doctest` 处理测试的方式。这些选项标志可以通过测试套件全局传递，在运行测试时通过命令行参数传递，也可以通过内联命令传递。对于本书，我已经通过一个
    `pytest.ini` 文件全局启用了以下选项标志（我们将在本章后面更详细地介绍 `py.test`）：'
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Without these option flags, some of the examples in this book will not function
    properly. This is because they have to be reformatted to fit. The next few paragraphs
    will cover the following option flags:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 没有这些选项标志，本书中的一些示例可能无法正常工作。这是因为它们必须重新格式化以适应。接下来的几段将介绍以下选项标志：
- en: '`DONT_ACCEPT_TRUE_FOR_1`'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DONT_ACCEPT_TRUE_FOR_1`'
- en: '`NORMALIZE_WHITESPACE`'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NORMALIZE_WHITESPACE`'
- en: '`ELLIPSIS`'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ELLIPSIS`'
- en: 'There are several other option flags available with varying degrees of usefulness,
    but these are better left to the Python documentation: [https://docs.python.org/3/library/doctest.html#option-flags](https://docs.python.org/3/library/doctest.html#option-flags%20)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他一些选项标志可用，但它们的效果各有不同，但最好还是查阅 Python 文档：[https://docs.python.org/3/library/doctest.html#option-flags](https://docs.python.org/3/library/doctest.html#option-flags)
- en: True and False versus 1 and 0
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: True 和 False 与 1 和 0
- en: 'Having `True` evaluating to `1` and `False` evaluating to `0` is useful in
    most cases, but it can give unexpected results if you were actually expecting
    a `bool` instead of an `int`. To demonstrate the difference, we have these lines:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，将 `True` 评估为 `1` 和将 `False` 评估为 `0` 是有用的，但如果实际上你期望的是一个 `bool` 而不是一个
    `int`，则可能会得到意外的结果。为了展示这种差异，我们有以下这些行：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'When we run this, it will run the tests both without and with the `DONT_ACCEPT_TRUE_FOR_1`
    flag:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个命令时，它将运行带有和不带有 `DONT_ACCEPT_TRUE_FOR_1` 标志的测试：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can see, the `DONT_ACCEPT_TRUE_FOR_1` flag makes `doctest` reject `1`
    as a valid response for `True` as well as `0` for `False`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`DONT_ACCEPT_TRUE_FOR_1` 标志使 `doctest` 拒绝将 `1` 作为 `True` 的有效响应，以及将 `0`
    作为 `False` 的有效响应。
- en: Normalizing whitespace
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 正规化空白
- en: 'Since doctests are used for both documentation and test purposes, it is pretty
    much a requirement to keep them readable. Without normalizing whitespace, this
    can be tricky, however. Consider the following example:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 由于doctests既用于文档又用于测试目的，因此保持它们可读性几乎是一个基本要求。然而，如果没有空白字符规范化，这可能会很棘手。考虑以下示例：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'While not all that bad, this output isn’t the best for readability. With whitespace
    normalizing, here is what we can do instead:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不是特别糟糕，但这种输出对于可读性来说并不是最好的。通过空白字符规范化，我们可以这样做：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Formatting the output in this manner is both more readable and convenient for
    keeping your lines shorter.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式格式化输出既更易于阅读，又便于保持行较短。
- en: Ellipsis
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 省略号
- en: 'The `ELLIPSIS` flag is very useful but also a bit dangerous, as it can easily
    lead to incorrect matches. It makes `...` match any substring, which is very useful
    for exceptions but dangerous in other cases:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`ELLIPSIS`标志非常有用，但也有些危险，因为它很容易导致不正确的匹配。它使`...`匹配任何子字符串，这在异常处理中非常有用，但在其他情况下则很危险：'
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: These cases are not too useful in real scenarios, but they demonstrate how the
    `ELLIPSIS` option flag functions. They also indicate the danger. Both `[1, 2,
    3, 4]` and `[1, 0, ... , 4]` match the `[1, ..., 4]` test, which is probably unintentional,
    so be very careful while using `ELLIPSIS`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这些情况在现实场景中并不太有用，但它们展示了`ELLIPSIS`选项标志的功能。它们也指出了危险。`[1, 2, 3, 4]`和`[1, 0, ...
    , 4]`都与`[1, ..., 4]`测试匹配，这可能是无意为之，所以使用`ELLIPSIS`时要非常小心。
- en: 'A more useful case is when documenting class instances:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更有用的例子是在记录类实例时：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Without the `ELLIPSIS` flag, the memory address (the `0x...` part) would never
    be what you expect. Let’s demonstrate an actual run in a normal CPython instance:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 没有使用`ELLIPSIS`标志时，内存地址（即`0x...`部分）永远不会是你期望的那样。让我们在一个正常的CPython实例中演示一个实际的运行情况：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Doctest quirks
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Doctest怪异之处
- en: The three option flags discussed earlier take care of quite a few quirks found
    in doctests, but there are several more cases that require care. In these cases,
    you just need to be a bit careful and work around the limitations of the `doctest`
    module. The `doctest` module effectively uses the representation string, and those
    are not always consistent.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 之前讨论的三个选项标志处理了doctests中发现的许多怪异之处，但还有一些更多的情况需要小心处理。在这些情况下，你只需要稍微小心一些，并绕过`doctest`模块的限制。`doctest`模块实际上使用表示字符串，而这些字符串并不总是一致的。
- en: The representation string can be generated using `repr(object)` and uses the
    `__repr__` magic method internally. On regular classes without a specific `__repr__`
    method, this will look like `<module.className instance at 0x....>`, where the
    `0x...` is the memory address of the object, which changes with each run and each
    object.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 表示字符串可以使用`repr(object)`生成，并在内部使用`__repr__`魔法方法。对于没有特定`__repr__`方法的常规类，这看起来像`<module.className
    instance at 0x....>`，其中`0x...`是对象的内存地址，它会随着每次运行和每个对象而变化。
- en: 'The most important cases are floating-point inaccuracies, and random values,
    such as timers. With the following example, the floating-point example will return
    consistent results for your system, but on a different system it is likely to
    fail. The `time` example will almost certainly always fail:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的情况是浮点数的不精确性和随机值，例如计时器。以下示例中，浮点数示例将返回系统上的一致结果，但在不同的系统上可能会失败。`time`示例几乎肯定会总是失败：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: All the problems have several possible solutions, which differ mostly in style
    and your personal preference.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些问题都有几种可能的解决方案，这些解决方案主要在风格和你的个人偏好上有所不同。
- en: Testing dictionaries
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试字典
- en: Since the implementation of dictionaries has changed in recent Python versions,
    this exact issue is probably one you will not encounter anymore. However, there
    are still situations where similar solutions are useful.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Python最近版本中字典的实现已经改变，这个确切的问题你可能不会再遇到。然而，仍然有一些情况下类似的解决方案是有用的。
- en: The problem with dictionaries used to be that they had an effectively random
    representation order. Since the `doctest` system requires a representation string
    that is identical in meaning (save for certain `doctest` flags, of course) to
    the `docstring`, this does not work. Naturally, there are several workaround options
    available and all have some advantages and disadvantages.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以前字典的问题在于它们有一个实际上随机的表示顺序。由于`doctest`系统需要一个与`docstring`在意义上相同（当然，除了某些`doctest`标志之外）的表示字符串，这并不适用。自然地，有几种可行的解决方案，每种都有其优缺点。
- en: 'The first is using the `pprint` (pretty print) library to format the dictionary
    in a pretty and consistent way:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是使用`pprint`（美化打印）库以美观和一致的方式格式化字典：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Since the `pprint` library always sorts the items before outputting, this solves
    the problem with random representation orders. However, it does require an extra
    import and function call, which some people prefer to avoid.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`pprint`库在输出之前总是对项目进行排序，这解决了随机表示顺序的问题。然而，它确实需要额外的导入和函数调用，有些人可能希望避免。
- en: 'Another option is manual sorting of the items:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是手动对项目进行排序：
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The downside here is that it is not visible from the output that `data` is a
    dictionary, which makes the output less readable.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题是，输出中并没有显示`data`是一个字典，这使得输出不太易读。
- en: 'Lastly, comparing the `dict` with a different `dict` comprising the same elements
    works as well:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，比较两个包含相同元素的`dict`也是可行的：
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'A perfectly okay solution, of course! But `True` is not really the clearest
    output, especially if the comparison doesn’t work:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这是一个完全可行的解决方案！但`True`并不是最清晰的输出，尤其是如果比较没有成功的话：
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'On the other hand, the other options presented previously show both the expected
    value and the returned value correctly:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，之前提出的其他选项正确地显示了预期的值和返回的值：
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Personally, out of the solutions presented, I would recommend using `pprint`,
    as I find it the most readable solution, but all the solutions have some merits
    to them.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 个人而言，在所提出的解决方案中，我会推荐使用`pprint`，因为我发现它是可读性最高的解决方案，但所有解决方案都有其优点。
- en: Testing floating-point numbers
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 浮点数测试
- en: 'For the same reason a floating-point comparison can be problematic (that is,
    `1/3 == 0.333`), a representation string comparison is also problematic. The easiest
    solution is to round or clip the value, but the `ELLIPSIS` flag is also an option
    here. Here is a list of several solutions:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，由于浮点数比较可能存在问题（即`1/3 == 0.333`），表示字符串的比较也可能有问题。最简单的解决方案是四舍五入或截断值，但`ELLIPSIS`标志在这里也是一个选项。以下是一些解决方案的列表：
- en: '[PRE21]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Which solution you choose should depend on your own preference or consistency
    with the project you are working on. In general, my choice would be to enable
    the `ELLIPSIS` option flag globally and go for that solution, as it looks the
    cleanest to me.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你选择哪种解决方案应该取决于你自己的偏好或与你在工作的项目的一致性。一般来说，我的选择将是全局启用`ELLIPSIS`选项标志，并选择这个解决方案，因为它在我看来看起来最干净。
- en: Times and durations
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 时间和持续时间
- en: 'For timings, the problems that you will encounter are quite similar to the
    floating-point issues. When measuring the execution time of a code snippet, there
    will always be some variation present. That’s why limiting the precision is the
    easiest solution for time dependent tests. To achieve this we can check whether
    the delta (difference) between the two times is smaller than a certain number:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 对于计时，你将遇到的问题与浮点数问题相当相似。在测量代码片段的执行时间时，总会存在一些变化。这就是为什么限制精度是时间相关测试的最简单解决方案。为了实现这一点，我们可以检查两个时间之间的差值是否小于某个特定数值：
- en: '[PRE22]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'For the `timedelta` objects, however, it’s slightly more complicated. Yet,
    this is where the `ELLIPSIS` flag definitely comes in handy again:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于`timedelta`对象来说，情况稍微复杂一些。但在这里，`ELLIPSIS`标志确实非常有用：
- en: '[PRE23]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The alternative to the `ELLIPSIS` option flag would be comparing the days, hours,
    minutes, and microseconds in `timedelta` separately. Or you can use `timedelta.total_seconds()`
    to convert the `timedelta` into seconds and use a regular floating-point comparison.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`ELLIPSIS`选项标志的替代方案是分别比较`timedelta`中的天数、小时、分钟和微秒。或者，你可以使用`timedelta.total_seconds()`将`timedelta`转换为秒，然后进行常规的浮点数比较。'
- en: In a later paragraph, we will see a completely stable solution for problems
    like these using mock objects. For doctests, however, that is generally overkill.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在后面的段落中，我们将看到使用模拟对象解决这些问题的完全稳定的解决方案。然而，对于doctests来说，这通常过于冗余。
- en: Now that we are done with `doctest`, it is time to continue with more explicit
    tests using `py.test`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了`doctest`，是时候继续使用更明确的测试，即`py.test`。
- en: Testing with py.test
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用py.test进行测试
- en: The `py.test` tool makes it very easy to write tests and run them. There are
    a few other options such as `nose2` and the bundled `unittest` module available,
    but the `py.test` library offers a very good combination of usability and active
    development. In the past, I was an avid `nose` user but have since switched to
    `py.test` as it tends to be easier to use and has better community support, in
    my experience at least. Regardless, `nose2` is still a good choice, and if you’re
    already using either `nose` or `nose2`, there is little reason to switch and rewrite
    all of your tests. When writing tests for a new project, however, `py.test` can
    be much more convenient.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`py.test`工具使得编写和运行测试变得非常容易。还有一些其他选项，如`nose2`和捆绑的`unittest`模块，但`py.test`库提供了非常好的可用性和活跃开发相结合。在过去，我是一名狂热的`nose`用户，但后来转而使用`py.test`，因为在我的经验中，它更容易使用，并且有更好的社区支持。无论如何，`nose2`仍然是一个不错的选择，如果你已经在使用`nose`或`nose2`，那么几乎没有理由切换并重写你所有的测试。然而，在编写新项目的测试时，`py.test`可以更加方便。'
- en: Now, we will run the doctests from the previously discussed `square.py` file
    using `py.test`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用`py.test`运行之前讨论过的`square.py`文件中的doctests。
- en: 'First, start by installing `py.test`, of course:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，首先安装`py.test`：
- en: '[PRE24]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We also installed `pytest-flake8` here because the default `pytest.ini` for
    this project depends on it. We will discuss what it does and how it can be configured
    later in this chapter.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还安装了`pytest-flake8`，因为此项目的默认`pytest.ini`依赖于它。我们将在本章后面讨论它所做的工作以及如何配置它。
- en: 'Now you can do a test run, so let’s give the doctests we have in `square.py`
    a try:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以进行测试运行，让我们尝试一下`square.py`中的doctests：
- en: '[PRE25]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We can see that `py.test` was able to find two tests for the given file: the
    test in `square.square` itself, and a `flake8` test from the `pytest-flake8` plugin
    that we will see later in this chapter.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`py.test`能够为给定的文件找到两个测试：`square.square`中的测试本身，以及来自`pytest-flake8`插件的`flake8`测试，我们将在本章后面看到。
- en: The difference between the unittest and py.test output
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: unittest和py.test输出之间的差异
- en: We have the doctests in `square.py`. Let’s create a new class called `cube`
    and create a proper set of tests outside of the code.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`square.py`中有doctests。让我们创建一个新的类`cube`，并在代码外部创建一组适当的测试。
- en: 'First of all, we have the code of `cube.py`, similar to `square.py` but minus
    the doctests, since they mostly won’t work anyway:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们有`cube.py`的代码，与`square.py`类似，但减去了doctests，因为它们大多数情况下都不会工作：
- en: '[PRE26]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now let’s start with the `unittest` example, `T_09_test_cube.py`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们从`unittest`示例开始，`T_09_test_cube.py`：
- en: '[PRE27]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This can be executed by executing the file itself:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过执行文件本身来完成：
- en: '[PRE28]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Alternatively, it can be done through the `unittest` module:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，也可以通过`unittest`模块来完成：
- en: '[PRE29]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'But it also works with other tools such as `py.test`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 但它也可以与其他工具如`py.test`一起工作：
- en: '[PRE30]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'And other tools such as `nose` are also possible. First, we need to install
    it using pip:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 并且其他工具如`nose`也是可能的。首先，我们需要使用pip安装它：
- en: '[PRE31]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'After that, we can use the `nosetests` command to run:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们可以使用`nosetests`命令来运行：
- en: '[PRE32]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As long as all the results are successful, the differences between the output
    from `unittest` and `py.test` are slim. This time around, however, we are going
    to break the code to show the difference when it actually matters. Instead of
    the `cube` code, we will add the `square` code, returning `n ** 2` from `square`,
    instead of `n ** 3`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 只要所有结果都成功，`unittest`和`py.test`的输出之间的差异很小。然而，这一次，我们将故意破坏代码，以展示实际重要时的差异。我们将添加`square`代码，从`square`返回`n
    ** 2`，而不是`n ** 3`。
- en: To reduce the amount of output, we will not be running the verbose variants
    of the commands here.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少输出量，我们不会在这里运行命令的详细版本。
- en: 'First of all, we have the regular `unittest` output:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们有常规的`unittest`输出：
- en: '[PRE33]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Not all that bad, as each test returns a nice stack trace that includes the
    values and everything. Yet, we can observe a small difference here when compared
    with the `py.test` run:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 并不是那么糟糕，因为每次测试都会返回一个包含值和一切的漂亮堆栈跟踪。然而，当我们与`py.test`运行进行比较时，这里可以观察到一些细微的差异：
- en: '[PRE34]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In small cases such as these, the difference is not all that apparent, but when
    testing complicated code with large stack traces, it becomes even more useful.
    However, for me personally, seeing the surrounding test code is a big advantage.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些小案例中，差异并不那么明显，但当测试具有大型堆栈跟踪的复杂代码时，它变得更加有用。然而，对我个人来说，看到周围的测试代码是一个很大的优势。
- en: In the example that was just discussed, the `self.assertEqual(...)` line shows
    the entire test, but in many other cases, you will need more information. The
    difference between the regular `unittest` module and the `py.test` module is that
    with `py.test` you can see the entire function with all of the code and the output.
    Later in this chapter, we will see how powerful this can be when writing more
    advanced tests.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在刚才讨论的例子中，`self.assertEqual(...)` 行显示了整个测试，但在许多其他情况下，你需要更多信息。常规的 `unittest`
    模块和 `py.test` 模块之间的区别在于，使用 `py.test` 你可以看到整个函数以及所有的代码和输出。在本章的后面部分，我们将看到这在进行更高级的测试时是多么强大。
- en: To truly appreciate the `py.test` output, we need colors as well. Unfortunately,
    that is not possible within the constraints of this book, but I strongly encourage
    you to give `py.test` a try if you aren’t using it already.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要真正欣赏 `py.test` 的输出，我们需要颜色。不幸的是，在这个书的限制下这是不可能的，但我强烈建议如果你还没有使用 `py.test`，那么尝试一下。
- en: Perhaps you are wondering now, “Is that all? The only difference between `py.test`
    and `unittest` is a bit of color and a slightly different output?” Well, far from
    it; there are many other differences, but this alone is enough reason to give
    it a try.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你现在在想，“这就是全部吗？`py.test` 和 `unittest` 之间的唯一区别就是一点颜色和稍微不同的输出？” 嗯，远不止如此；还有很多其他的区别，但仅此一点就足以让我们尝试一下。
- en: The difference between unittest and py.test tests
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: unittest 和 py.test 测试之间的区别
- en: The improved output does help a bit, but the combination of improved output
    and a much easier way to write tests is what makes `py.test` so useful. There
    are quite a few methods for making the tests simpler and more legible, and in
    many cases, you can choose which you prefer. As always, readability counts, so
    choose wisely and try not to over-engineer the solutions.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 改进的输出确实有所帮助，但改进的输出和编写测试的更简单方式结合起来，使得 `py.test` 非常有用。有相当多的方法可以使测试更简单、更易读，在许多情况下，你可以选择你喜欢的。像往常一样，可读性很重要，所以明智地选择，并尽量避免过度设计解决方案。
- en: Simplifying assertions
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 简化断言
- en: Where the `unittest` library requires the usage of `self.assertEqual` to compare
    variables, `py.test` allows the use of a regular `assert` statement while still
    understanding the comparison between the variables.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `unittest` 库需要使用 `self.assertEqual` 来比较变量时，`py.test` 允许使用常规的 `assert` 语句，同时仍然理解变量之间的比较。
- en: 'The following test file contains three styles of tests, so they can be compared
    easily:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 以下测试文件包含三种测试风格，因此可以轻松比较：
- en: '[PRE35]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To convert to `py.test`, we simply replaced `self.assertEqual` with `assert
    ... == ...`. A minor improvement indeed, but the actual benefit is seen in the
    failure output. The first two use the `unittest` style and the latter two use
    the `py.test` style both inside a class and as separate functions:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要转换为 `py.test`，我们只需将 `self.assertEqual` 替换为 `assert ... == ...`。这确实是一个小的改进，但真正的益处体现在失败输出上。前两个使用的是
    `unittest` 风格，后两个使用的是 `py.test` 风格，无论是在类内部还是作为单独的函数：
- en: '[PRE36]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In addition to seeing the values that were compared, we can actually see the
    function that was called and which input parameters it received. With the regular
    `unittest` we have no way of knowing that `2` was entered as a parameter to the
    `cube()` function.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 除了可以看到比较的值之外，我们实际上还可以看到被调用的函数以及它接收到的输入参数。使用常规的 `unittest`，我们无法知道 `2` 是否被输入为
    `cube()` 函数的参数。
- en: The standard `py.test` behavior works for most test cases, but it may not be
    enough for some custom types. For example, let’s say that we have a `User` object
    with a `name` attribute that should be compared with the `name` attribute on another
    object. This part can easily be achieved by implementing the `__eq__` method on
    `User`, but it does not improve clarity. Since `name` is the attribute that we
    compare, it would be useful if the tests showed `name` when errors were displayed.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的 `py.test` 行为适用于大多数测试用例，但对于某些自定义类型可能不够。例如，假设我们有一个具有 `name` 属性的 `User` 对象，该属性应该与另一个对象的
    `name` 属性进行比较。这部分可以通过在 `User` 上实现 `__eq__` 方法轻松实现，但这并不提高清晰度。由于 `name` 是我们比较的属性，如果在错误显示时测试显示了
    `name`，那将是有用的。
- en: 'First is the class with two tests, one working and one broken to demonstrate
    the regular output:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 首先是包含两个测试的类，一个正常工作，一个损坏，以演示常规输出：
- en: '`T_11_representing_assertions.py`'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`T_11_representing_assertions.py`'
- en: '[PRE37]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'And here is the regular `py.test` output:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是常规的 `py.test` 输出：
- en: '[PRE38]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The default test output is still usable since the function is fairly straightforward,
    and the value for `name` is visible due to it being available in the constructor.
    However, it would have been more useful if we could explicitly see the value of
    `name`. By adding a `pytest_assertrepr_compare` function to the `conftest.py`
    file, we can modify the behavior of the `assert` statements.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 默认测试输出仍然可用，因为函数相当直接，并且由于它在构造函数中可用，`name`的值是可见的。然而，如果我们能够明确地看到`name`的值，那将更有用。通过向`conftest.py`文件添加`pytest_assertrepr_compare`函数，我们可以修改`assert`语句的行为。
- en: The `conftest.py` file is a special file for `py.test` that can be used to override
    or extend `py.test`. Note that this file will automatically be loaded by every
    test run in that directory, so we need to test the types of both the left-hand
    side and the right-hand side of the operator. In this case, it’s `a` and `b`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`conftest.py`文件是`py.test`的一个特殊文件，可以用来覆盖或扩展`py.test`。请注意，此文件将自动由该目录中的每个测试运行加载，因此我们需要测试操作符左右两边的类型。在这种情况下，是`a`和`b`。'
- en: '`conftest.py`'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`conftest.py`'
- en: '[PRE39]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The preceding function will be used as the output for our test. So when it
    fails, this time we get our own, slightly more useful, output:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 上述函数将被用作我们测试的输出。因此，当它失败时，这次我们得到了我们自己的、稍微更有用的输出：
- en: '[PRE40]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In this case, we could have easily changed the `__repr__` function of `User`
    as well, but there are many cases where modifying the `py.test` output can be
    useful – if you need more debug output, for example. Similar to this, there is
    specific support for many types, such as sets, dictionaries, and texts.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们也可以轻松地更改`User`的`__repr__`函数，但有许多情况下修改`py.test`的输出可能很有用——例如，如果你需要更多的调试输出。与此类似，对许多类型有特定的支持，例如集合、字典和文本。
- en: Parameterizing tests
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参数化测试
- en: So far, we have specified every test separately, but we can simplify tests a
    lot by parameterizing them. The square and cube tests are very similar; a certain
    input gave a certain output.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经分别指定了每个测试，但我们可以通过参数化来大大简化测试。平方和立方测试非常相似；一定的输入产生一定的输出。
- en: You could solve this by creating a loop in a test, but a loop in a test will
    be executed as a single test. This means that it will fail in its entirety if
    a single test iteration of the loop fails, which means you can’t easily see what
    exactly broke if you compare older and newer test output. In this example with
    the numbers, the result is obvious, but if you were to apply a list of filenames
    to a complicated processing test, it would be far less obvious what happened.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在测试中创建循环来解决此问题，但测试中的循环将被作为一个单独的测试执行。这意味着如果循环的某个测试迭代失败，整个测试将失败，这意味着如果你比较较旧和较新的测试输出，你无法轻易地看到到底出了什么问题。在这个用数字的例子中，结果是明显的，但如果你将文件名列表应用于复杂的处理测试，发生的事情将不那么明显。
- en: 'In these cases, parameterized tests can help a lot. After creating a list of
    parameters and the expected output data, you can make it run the test function
    for every parameter combination separately:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，参数化测试可以大有帮助。在创建参数列表和预期输出数据后，你可以为每个参数组合单独运行测试函数：
- en: '[PRE41]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This outputs the following, as you might have already expected:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能已经预料到的那样，它输出了以下内容：
- en: '[PRE42]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: With the parameterized tests, we can see the parameters clearly, which means
    we can see all inputs and outputs without any extra effort.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 使用参数化测试，我们可以清楚地看到参数，这意味着我们可以不费任何额外努力地看到所有输入和输出。
- en: Generating the list of tests dynamically at runtime is also possible with a
    global function. Similar to the `pytest_assertrepr_compare` function that we added
    to `conftest.py` earlier, we can add a `pytest_generate_tests` function, which
    generates tests.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时动态生成测试列表也是可能的，使用全局函数。类似于我们之前添加到`conftest.py`中的`pytest_assertrepr_compare`函数，我们可以添加一个`pytest_generate_tests`函数，该函数生成测试。
- en: Creating the `pytest_generate_tests` function can be useful only to test a subset
    of options depending on the configuration options. If possible, however, I recommend
    trying to configure selective tests using fixtures instead, as they are somewhat
    more explicit. We will cover this in the following section. The problem with functions
    such as `pytest_generate_tests` is that they are global and don’t discriminate
    between specific tests, resulting in strange behavior if you are not expecting
    that.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`pytest_generate_tests`函数可能只对测试配置选项的子集有用。然而，如果可能的话，我建议尝试使用固定装置来配置选择性测试，因为它们相对更明确。我们将在下一节中介绍这一点。`pytest_generate_tests`等函数的问题在于它们是全局的，并且不会区分特定的测试，如果你没有预料到这种情况，可能会导致奇怪的行为。
- en: Automatic arguments using fixtures
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用固定装置的自动参数
- en: 'The `py.test` fixture system is one of the most magical features of `py.test`.
    It magically executes a fixture function with the same **name** as your arguments.
    Let’s create a basic fixture to demonstrate this:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`py.test`固定装置系统是`py.test`最神奇的功能之一。它神奇地执行与你的参数具有相同**名称**的固定装置函数。让我们创建一个基本的固定装置来演示这一点：'
- en: '[PRE43]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: When the `test_something()` test is executed, the `name` argument will be filled
    with the output from the `name()` function automatically.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行`test_something()`测试时，`name`参数将自动填充`name()`函数的输出。
- en: 'Because arguments are automatically filled by fixtures, the naming of the arguments
    becomes very important, as fixtures can easily collide with other fixtures. To
    prevent collisions, the scope is set to `function` by default. However, `class`,
    `module`, and `session` are also valid options for the scope. There are several
    fixtures available by default, some of which you will use often, and others most
    likely never. A complete list can always be generated with the following command:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 由于参数是由固定装置自动填充的，因此参数的命名变得非常重要，因为固定装置很容易与其他固定装置冲突。为了防止冲突，默认情况下将作用域设置为`function`。然而，`class`、`module`和`session`也是有效的作用域选项。默认情况下有几个固定装置可用，其中一些你可能会经常使用，而其他的一些可能永远不会使用。可以通过以下命令生成完整的列表：
- en: '[PRE44]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The next few paragraphs demonstrate some fixture usage, and the `monkeypatch`
    fixture is covered later in the chapter.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几段将演示一些固定装置的使用，而`monkeypatch`固定装置将在本章后面介绍。
- en: cache
  id: totrans-187
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 缓存
- en: 'The `cache` fixture is as simple as it is useful; there is a `get` function
    and a `set` function, and the `cache` state remains between separate `py.test`
    runs. To illustrate how to get and set values from `cache`:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`cache`固定装置既简单又有用；有一个`get`函数和一个`set`函数，并且`cache`状态在单独的`py.test`运行之间保持不变。为了说明如何从`cache`获取和设置值，请看以下示例：'
- en: '[PRE45]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The default value (`0` in this case) is required for the `cache.get` function.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在此情况下，`cache.get`函数需要默认值（`0`）。
- en: The cache can be cleared through the `--cache-clear` command-line parameter,
    and all caches can be shown through `--cache-show`. Internally, the `cache` fixture
    uses the `json` module to encode/decode the values, so anything JSON encodable
    will work.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过`--cache-clear`命令行参数清除缓存，并且可以通过`--cache-show`显示所有缓存。内部，`cache`固定装置使用`json`模块来编码/解码值，因此任何可JSON编码的内容都可以工作。
- en: Custom fixtures
  id: totrans-192
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 自定义固定装置
- en: Bundled fixtures are quite useful, but within most projects, you will want to
    create your own fixtures to make things easier. Fixtures make it trivial to repeat
    code that is needed more often. You are most likely wondering how this is different
    from a regular function, context wrapper, or something else, but the special thing
    about fixtures is that they themselves can accept fixtures as well. So, if your
    function needs the `pytestconfig` variables, it can ask for them without needing
    to modify the calling functions.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 包含的固定装置非常有用，但在大多数项目中，你将想要创建自己的固定装置以使事情更简单。固定装置使得重复需要更频繁的代码变得非常简单。你很可能会想知道这与常规函数、上下文包装器或其他东西有什么不同，但固定装置的特殊之处在于它们自身也可以接受固定装置。所以，如果你的函数需要`pytestconfig`变量，它可以请求这些变量，而无需修改调用函数。
- en: 'You can create a fixture out of anything that would be useful to reuse. The
    basic premise is simple enough: a function with the `pytest.fixture` decorator,
    which returns a value that will be passed along as an argument. Also, the function
    can take parameters and fixtures just as any test can.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从任何有用的可重用内容创建固定装置。基本前提很简单：一个带有`pytest.fixture`装饰器的函数，它返回一个将作为参数传递的值。此外，该函数可以像任何测试一样接受参数和固定装置。
- en: 'The only notable variation is `pytest.yield_fixture`. This fixture variation
    has one small difference: the actual test will be executed at the `yield` (more
    than one `yield` results in errors) and the code before/after functions as setup/teardown
    code, which is useful for things like database connections and file handles. A
    basic example of a `fixture` and a `yield_fixture` looks like this:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一值得注意的变化是 `pytest.yield_fixture`。这种固定装置变化有一个小小的不同：实际的测试将在 `yield` 时执行（多个 `yield`
    会导致错误），而函数前后的代码作为设置/清理代码，这对于数据库连接和文件句柄等操作非常有用。一个 `fixture` 和 `yield_fixture` 的基本例子如下：
- en: '[PRE46]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'These fixtures take no parameters and simply pass a parameter to the `py.test`
    functions. A more useful example would be setting up a database connection and
    executing a query in a transaction:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这些固定装置不接受任何参数，只是简单地将一个参数传递给 `py.test` 函数。一个更有用的例子是设置数据库连接并在事务中执行查询：
- en: '[PRE47]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: First we have the `connection()` fixture, which uses the special parameter `params`.
    Instead of using the `:memory:` database in `sqlite3`, we can use a different
    database name or multiple names as well. That is why `params` is a `list`; the
    test will be executed for each value in `params`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 首先是 `connection()` 固定装置，它使用特殊的参数 `params`。我们不仅可以在 `sqlite3` 中使用 `:memory:` 数据库，还可以使用不同的数据库名称或多个名称。这就是为什么
    `params` 是一个列表；测试将为 `params` 中的每个值执行。
- en: The `transaction()` fixture uses the `connection()` to open the database connection,
    `yield` it to the user of that fixture, and take care of the cleanup after. This
    could easily have been omitted and done in `transation()` immediately, but it
    saves an indentation level and it allows you to further customize the connection
    at a single location if needed.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`transaction()` 固定装置使用 `connection()` 打开数据库连接，将其 `yield` 给该固定装置的用户，并在之后进行清理。这可以很容易地省略，并在
    `transation()` 中立即完成，但它节省了一个缩进级别，并在需要时允许你在单个位置进一步自定义连接。'
- en: Lastly, the `test_insert()` function uses the `transaction()` fixture to execute
    the queries on the database. It is important to note that if we had passed more
    values to `params`, this test would have been executed for each value.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`test_insert()` 函数使用 `transaction()` 固定装置在数据库上执行查询。需要注意的是，如果我们向 `params`
    传递了更多的值，这个测试将为每个值执行。
- en: Print statements and logging
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 打印语句和日志记录
- en: 'Even though print statements are generally not the most optimal way to debug
    code, I admit that it is still my default method of debugging. This means that
    when running and trying tests, I will include many print statements. However,
    let’s see what happens when we try this with `py.test`. Here is the testing code:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管打印语句通常不是调试代码的最佳方式，我承认这仍然是我的默认调试方法。这意味着当运行和尝试测试时，我会包含许多打印语句。然而，让我们看看当我们用 `py.test`
    尝试时会发生什么。以下是测试代码：
- en: '[PRE48]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The following is the actual output:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是实际输出：
- en: '[PRE49]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: So, all of our print statements and logging got trashed? Well, not really. In
    this case, `py.test` assumed that it wouldn’t be relevant to you, so it ignored
    the output. But what about the same run with an error?
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们所有的打印语句和日志记录都被丢弃了吗？实际上并不是这样。在这种情况下，`py.test` 假设这对您来说并不相关，因此它忽略了输出。但是，如果运行时出现错误呢？
- en: '[PRE50]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: As we see here, when it’s actually useful, we do get the `stdout` and `stderr`
    output. Additionally, logging with a level of `WARNING` or higher is visible now.
    `DEBUG` and `INFO` still won’t be visible, but we’ll see more about that later
    in this chapter, in the *Logging* section.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，当它真正有用时，我们确实会得到 `stdout` 和 `stderr` 输出。此外，现在可以看到 `WARNING` 级别或更高的日志记录。`DEBUG`
    和 `INFO` 仍然不可见，但关于这一点，我们将在本章后面的 *日志记录* 部分了解更多。
- en: 'There is one big caveat to using print statements for debugging, however: since
    they write to `stdout` they can break quickly break your doctests. Because `doctest`
    looks at all generated output, your print statements will be included as expected
    output.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用打印语句进行调试有一个很大的缺点：由于它们写入 `stdout`，它们可能会迅速破坏你的 doctests。因为 `doctest` 会查看所有生成的输出，所以你的打印语句将被包括为预期的输出。
- en: Plugins
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 插件
- en: One of the most powerful features of `py.test` is the plugin system. Within
    `py.test`, nearly everything can be modified using the available hooks; the result
    of this is that writing plugins is almost simple. Actually, if you’ve been typing
    along, you already wrote a few plugins in the previous paragraphs without realizing
    it. By packaging `conftest.py` in a different package or directory, it becomes
    a `py.test` plugin. We will explain more about packaging in *Chapter 18*, *Packaging
    – Creating Your Own Libraries or Applications*.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`py.test`最强大的功能之一是插件系统。在`py.test`中，几乎所有内容都可以使用可用的钩子进行修改；结果是编写插件几乎很简单。实际上，如果你一直在输入，你已经在之前的段落中编写了一些插件而没有意识到。通过将`conftest.py`打包在不同的包或目录中，它变成了一个`py.test`插件。我们将在*第18章*，*打包
    – 创建你自己的库或应用程序*中解释更多关于打包的内容。'
- en: 'Generally, it won’t be required to write your own plugin because the odds are
    that the plugins you seek are already available. A small list of plugins can be
    found on the `py.test` website at [https://pytest.org/latest/plugins.html](https://pytest.org/latest/plugins.html),
    an automatically generated list with plugins here: [https://docs.pytest.org/en/latest/reference/plugin_list.html](https://docs.pytest.org/en/latest/reference/plugin_list.html),
    and a longer completely uncurated list (currently over 8,000) can be found through
    the Python Package Index at [https://pypi.org/search/?q=pytest-](https://pypi.org/search/?q=pytest-).'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你不需要编写自己的插件，因为很可能你寻求的插件已经可用。可以在`py.test`网站上找到一小部分插件列表，网址为[https://pytest.org/latest/plugins.html](https://pytest.org/latest/plugins.html)，这里有自动生成的插件列表：[https://docs.pytest.org/en/latest/reference/plugin_list.html](https://docs.pytest.org/en/latest/reference/plugin_list.html)，以及一个更长且未经编辑的列表（目前超过8,000个），可以通过Python包索引在[https://pypi.org/search/?q=pytest-](https://pypi.org/search/?q=pytest-)找到。
- en: 'By default, `py.test` does cover quite a bit of the desirable features, so
    you can easily do without plugins, but within the packages that I write myself,
    I generally default to the following list:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`py.test`已经覆盖了许多期望的功能，所以你可以很容易地不使用插件，但在我自己编写的包中，我通常默认使用以下列表：
- en: '`pytest-cov`'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pytest-cov`'
- en: '`pytest-flake8`'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pytest-flake8`'
- en: '`pytest-mypy`'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pytest-mypy`'
- en: By using these plugins, it becomes much easier to maintain the code quality
    of your project. In order to understand why, we will take a closer look at these
    packages in the following paragraphs.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用这些插件，维护你项目的代码质量变得容易得多。为了理解为什么，我们将在接下来的段落中更详细地查看这些包。
- en: pytest-cov
  id: totrans-219
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: pytest-cov
- en: Using the `pytest-cov` package, you can see whether your code is properly covered
    by tests or not. Internally, it uses the `coverage` package to detect how much
    of the code is being tested.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`pytest-cov`包，你可以查看你的代码是否被测试覆盖得恰当。内部，它使用`coverage`包来检测代码被测试的部分。
- en: 'Make sure you have `pytest-cov` installed:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你已经安装了`pytest-cov`：
- en: '[PRE51]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: To demonstrate the principle, we will check the coverage of a `cube_root` function.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示原理，我们将检查`cube_root`函数的覆盖率。
- en: 'First of all, let’s create a `.coveragerc` file with some useful defaults:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个包含一些有用默认值的`.coveragerc`文件：
- en: '[PRE52]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Since Linux and Mac systems hide files starting with a `.` (such as `.coveragerc`),
    the filename in the GitHub repository is `_coveragerc`. To use the file, you can
    either choose to copy/rename it, or set the `COVERAGE_RCFILE` environment variable
    to override the filename.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Linux和Mac系统隐藏以`.`开头的文件（例如`.coveragerc`），GitHub仓库中的文件名为`_coveragerc`。要使用该文件，你可以选择复制/重命名它，或者设置`COVERAGE_RCFILE`环境变量以覆盖文件名。
- en: Which defaults are good for your project is of course a personal decision, but
    I find the defaults above quite useful. Be sure to read through these instead
    of blindly copying them, however; perhaps you want to make sure all of your `AssertionErrors`
    are tested instead of silently ignoring them from the coverage output.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 对于你的项目来说，哪些默认值是好的当然是一个个人决定，但我发现上面的默认值非常有用。但是，请务必仔细阅读这些内容，而不是盲目地复制；也许你想要确保所有的`AssertionErrors`都被测试，而不是在覆盖率输出中默默地忽略它们。
- en: 'Here is the `cube_root.py` code:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`cube_root.py`代码：
- en: '[PRE53]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'And the `T_16_test_cube_root.py` code:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 以及`T_16_test_cube_root.py`代码：
- en: '[PRE54]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now, let’s see what happens when we run this with coverage enabled:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看当我们启用覆盖率时会发生什么：
- en: '[PRE55]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'What happened here? It looks like we forgot to test some part of the code:
    line `14` and the branch that goes from line `11` to line `14`. This output isn’t
    all that readable, and that’s why we added `--cov-report=html` to get easily readable
    HTML output in the `htmlcov` directory as well:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了什么？看起来我们忘记测试代码的某些部分：第14行和从第11行到第14行的分支。这个输出并不那么易于阅读，这就是为什么我们添加了`--cov-report=html`，以便在`htmlcov`目录中获得易于阅读的HTML输出：
- en: '![](img/B15882_10_03.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B15882_10_03.png)'
- en: 'Figure 10.3: Coverage report generated by --cov-report=html'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3：由--cov-report=html生成的覆盖率报告
- en: Perfect! So now we know – we forgot to test for values smaller than `0`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 完美！所以现在我们知道——我们忘记测试小于`0`的值了。
- en: 'The yellow line (line 11) indicates that only one part of the branch was executed
    (`(n >= 0) == True`) and not the other (`(n >= 0) == False`). This occurs with
    `if` statements, loops, and other things where at least one of the branches is
    not covered. For example, if a loop over an empty array is an impossible scenario,
    then the test can be partially skipped using a comment:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 黄色线条（第11行）表明只有分支的一部分被执行了（`(n >= 0) == True`），而没有执行另一部分（`(n >= 0) == False`）。这种情况出现在`if`语句、循环和其他至少有一个分支未被覆盖的地方。例如，如果遍历空数组的循环是一个不可能的场景，那么可以通过注释来部分跳过测试：
- en: '[PRE56]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'But since we know the problem, that is, the missing test for `ValueError`,
    let’s add the test case:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 但既然我们知道问题所在，即缺少对`ValueError`的测试，让我们添加测试用例：
- en: '[PRE57]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Then we run the test again:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们再次运行测试：
- en: '[PRE58]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Perfect! Now we have 100% test coverage of our function. At least, in theory.
    I can think of several other test cases with different types of values that are
    not covered. So keep in mind that 100% test coverage is still no guarantee for
    bug-free code.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 完美！现在我们的函数已经达到了100%的测试覆盖率。至少，在理论上是这样。我可以想到几个其他类型的值，这些值没有被覆盖。所以请记住，100%的测试覆盖率并不能保证代码没有bug。
- en: But what if we have a branch that really doesn’t need testing because it is
    intentionally not implemented? If we raise a `NotImplementedError` instead of
    raising a `ValueError` for values below `0`, we also get 100% test coverage without
    adding that test.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们有一个实际上不需要测试的分支，因为它是有意不实现的呢？如果我们对小于`0`的值抛出`NotImplementedError`而不是`ValueError`，我们也可以在不添加该测试的情况下获得100%的测试覆盖率。
- en: This is because we added `raise NotImplementedError` to the ignore list in the
    `.coveragerc` file. Even if we were to test for the `NotImplementedError` in the
    test file, the coverage report would still ignore the line.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们在`.coveragerc`文件中将`raise NotImplementedError`添加到了忽略列表中。即使我们在测试文件中测试`NotImplementedError`，覆盖率报告仍然会忽略这一行。
- en: pytest-flake8
  id: totrans-247
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: pytest-flake8
- en: 'Code quality testing tools are very useful for making your code readable, consistent,
    and `pep8` compliant. The `pytest-flake8` plugin automatically executes these
    checks before running the actual tests. To install it, simply execute this line:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 代码质量测试工具对于使你的代码可读、一致和符合`pep8`规范非常有用。`pytest-flake8`插件在运行实际测试之前自动执行这些检查。要安装它，只需执行以下命令：
- en: '[PRE59]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: We already installed `pytest-flake8` earlier in this chapter because the default
    configuration for the code in this book depends on it.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章的早期部分已经安装了`pytest-flake8`，因为本书中代码的默认配置依赖于它。
- en: 'Now we’ll create some bad code:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将创建一些糟糕的代码：
- en: '[PRE60]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'After that, we can check the code using the `pytest-flake8` plugin by adding
    it to the `pytest.ini`, or by running `py.test` like this:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们可以通过将其添加到`pytest.ini`或通过以下方式运行`py.test`来使用`pytest-flake8`插件进行检查：
- en: '[PRE61]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The output of `pytest-flake8` is, as expected, very similar to the output from
    the `flake8` command that is called internally and combines the `pyflakes` and
    `pep8` commands to test code quality.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`pytest-flake8`的输出，正如预期的那样，与内部调用的`flake8`命令的输出非常相似，该命令结合了`pyflakes`和`pep8`命令来测试代码质量。'
- en: Depending on your situation, you might opt for having the code quality tests
    before you commit to the repository, or you could only run it on-demand if code
    quality isn’t that important to you. After all, while code quality considerations
    are important, it does not mean the code does not function without them, and a
    good editor will already notify you of code quality issues while typing.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '根据你的情况，你可能会选择在提交到仓库之前进行代码质量测试，或者如果你认为代码质量不是那么重要，你可以按需运行它。毕竟，虽然代码质量考虑因素很重要，但这并不意味着没有它们代码就不能工作，而且一个好的编辑器在输入时就会通知你代码质量问题。 '
- en: pytest-mypy
  id: totrans-257
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: pytest-mypy
- en: 'The `pytest-mypy` plugin runs the `mypy` static type checker, which uses the
    type hints to check if the input and output are as expected. First, we need to
    install it using `pip`:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`pytest-mypy`插件运行`mypy`静态类型检查器，它使用类型提示来检查输入和输出是否符合预期。首先，我们需要使用`pip`安装它：'
- en: '[PRE62]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'When we apply this to our `cube_root.py` file, we can already see a possible
    error:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将此应用于我们的`cube_root.py`文件时，我们就可以看到一个可能出现的错误：
- en: '[PRE63]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: As opposed to the `cube.py` file, which will return an `int` when given an `int`,
    the cube root of a number does not have to be an integer when an integer is passed.
    While the cube root of `8` is `2`, the cube root of `4` returns a floating-point
    number of approximately `1.587`.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 与返回`int`的`cube.py`文件相反，当传递一个整数时，一个数的立方根不必是整数。虽然`8`的立方根是`2`，但`4`的立方根返回一个大约为`1.587`的浮点数。
- en: This is an error that is easily overlooked without a tool such as `mypy`.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个在没有像`mypy`这样的工具的情况下容易被忽视的错误。
- en: Configuring plugins
  id: totrans-264
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 配置插件
- en: To make sure that all the plugins get executed and to configure them, simply
    add the settings to the `pytest.ini` file. The following example can be a reasonable
    default for development, but for production releases, you will probably want to
    take care of the `UnusedImport` warnings.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保所有插件都得到执行并对其进行配置，只需将设置添加到`pytest.ini`文件中。以下示例可以是开发的一个合理默认值，但对于生产版本，您可能需要处理`UnusedImport`警告。
- en: '`pytest.ini`'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`pytest.ini`'
- en: '[PRE64]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Using the `addopts` setting in the `pytest.ini`, you can add options to the
    `py.test` command as if you had added them to the command while running.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`pytest.ini`中的`addopts`设置，您可以将选项添加到`py.test`命令中，就像您在运行时将它们添加到命令中一样。
- en: When debugging to find out why a test is failing, it can be useful to simply
    look at the first test that fails. The `py.test` module offers both a `-x`/`--exitfirst`
    flag to stop after the first failure and `--maxfail=n` to stop after *n* failures.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 当调试以找出测试失败的原因时，查看第一个失败的测试可能很有用。`py.test`模块提供了`-x`/`--exitfirst`标志，在第一次失败后停止，以及`--maxfail=n`在*n*次失败后停止。
- en: Additionally, the `--ff`/`--failed-first` option is useful to run the previously
    failed tests first.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`--ff`/`--failed-first`选项在首先运行之前失败的测试时很有用。
- en: Or you can use the `--lf`/`--last-failed` option to only run previously failed
    tests.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用`--lf`/`--last-failed`选项来仅运行之前失败的测试。
- en: Now that we have a good understanding of the `py.test` possibilities, it is
    time to continue writing tests. Next up is the subject of faking objects using
    `mock`.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对`py.test`的可能性有了很好的理解，是时候继续编写测试了。接下来是使用`mock`来模拟对象的主题。
- en: Mock objects
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟对象
- en: When writing tests, you will often find that you are not only testing your own
    code, but also the interaction with external resources, such as hardware, databases,
    web hosts, servers, and others. Some of these can be run safely, but certain tests
    are too slow, too dangerous, or even impossible to run. In those cases, mock objects
    are your friends; they can be used to fake anything, so you can be certain that
    your code still returns the expected results without having any variation from
    external factors.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写测试时，您会发现您不仅正在测试自己的代码，而且还在测试与外部资源的交互，例如硬件、数据库、网络主机、服务器等。其中一些可以安全运行，但某些测试太慢、太危险，甚至无法运行。在这些情况下，模拟对象是您的朋友；它们可以用来模拟任何东西，这样您可以确信您的代码仍然返回预期的结果，而不会受到外部因素的影响。
- en: Using unittest.mock
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`unittest.mock`
- en: The `unittest.mock` library provides two base objects, `Mock` and `MagicMock`,
    to easily mock any external resources. The `Mock` object is just a general generic
    mock object and `MagicMock` is mostly the same, but it has all the Python magic
    methods such as `__contains__` and `__len__` defined. In addition to this, it
    can make your life even easier. This is because in addition to creating mock objects
    manually, it is possible to patch objects directly using the `patch` decorator/context
    manager.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`unittest.mock`库提供了两个基本对象，`Mock`和`MagicMock`，以便轻松模拟任何外部资源。`Mock`对象只是一个通用的模拟对象，而`MagicMock`基本上相同，但它定义了所有Python魔法方法，如`__contains__`和`__len__`。除此之外，它还可以使您的生活更加轻松。这是因为除了手动创建模拟对象之外，还可以直接使用`patch`装饰器/上下文管理器来修补对象。'
- en: 'The following function uses `random` to return `True` or `False` with probabilities
    governed by a certain probability distribution. Due to the random nature of a
    function like this, it is notoriously difficult to test, but not with `unittest.mock`.
    With the use of `unittest.mock`, it’s easy to get repeatable results:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数使用 `random` 返回 `True` 或 `False`，其概率受某种概率分布控制。由于这种函数的随机性，它很难测试，但使用 `unittest.mock`
    就容易多了。使用 `unittest.mock`，很容易得到可重复的结果：
- en: '[PRE65]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Wonderful, isn’t it? Without having to modify the original code, we can make
    sure that `random.random()` now returns `0.1` instead of some random number. If
    you have an `if` statement in your code so it only runs 10% of the time (`if random.random()
    < 0.1`), you can now test explicitly what happens in both cases of the `if`.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 真是太棒了，不是吗？在不修改原始代码的情况下，我们可以确保 `random.random()` 现在返回 `0.1` 而不是某个随机数。如果你的代码中有一个
    `if` 语句，它只运行 10% 的时间（`if random.random() < 0.1`），你现在可以明确测试两种情况会发生什么。
- en: 'The possibilities with mock objects are nearly endless. They vary from raising
    exceptions on access to faking entire APIs and returning different results on
    multiple calls. For example, let’s fake deleting a file:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟对象的可能性能近无限。它们从在访问时引发异常到模拟整个 API 并在多次调用时返回不同的结果。例如，让我们模拟删除一个文件：
- en: '[PRE66]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Quite a bit of magic in this example! The `side_effect` parameter tells `mock`
    to return those values in that sequence, making sure that the first call to `os.path.exists`
    returns `True` and the other two return `False`. The `mock.patch` call without
    specific arguments simply returns a callable that does nothing and accepts anything.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中有相当多的魔法！`side_effect` 参数告诉 `mock` 按照那个顺序返回那些值，确保第一次调用 `os.path.exists`
    返回 `True`，其他两次返回 `False`。没有特定参数的 `mock.patch` 调用简单地返回一个可调用的对象，它什么都不做，接受任何东西。
- en: Using py.test monkeypatch
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 py.test monkeypatch
- en: 'The `monkeypatch` object in `py.test` is a fixture that allows mocking as well.
    While it may seem useless after seeing the possibilities with `unittest.mock`,
    in summary, it’s not. Some of the functionality does overlap, but while `unittest.mock`
    focuses on controlling and recording the actions of an object, the `monkeypatch`
    fixture focuses on simple and temporary environmental changes. Some examples of
    these are given in the following list:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '`py.test` 中的 `monkeypatch` 对象是一个可以用于模拟的固定装置。虽然在看到 `unittest.mock` 的可能性之后，它可能看起来没有用，但总的来说，它是有用的。一些功能确实有重叠，但
    `unittest.mock` 专注于控制和记录对象的行为，而 `monkeypatch` 固定装置则专注于简单和临时的环境变化。以下是一些示例：'
- en: Setting and deleting attributes using `monkeypatch.setattr` and `monkeypatch.delattr`
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `monkeypatch.setattr` 和 `monkeypatch.delattr` 设置和删除属性
- en: Setting and deleting dictionary items using `monkeypatch.setitem` and `monkeypatch.delitem`
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `monkeypatch.setitem` 和 `monkeypatch.delitem` 设置和删除字典项
- en: Setting and deleting environment variables using `monkeypatch.setenv` and `monkeypatch.delenv`
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `monkeypatch.setenv` 和 `monkeypatch.delenv` 设置和删除环境变量
- en: Inserting an extra path to `sys.path` before all others using `monkeypatch.syspath_prepend`
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `monkeypatch.syspath_prepend` 在所有其他路径之前插入额外的路径
- en: Changing the directory using `monkeypatch.chdir`
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `monkeypatch.chdir` 更改目录
- en: To undo all modifications, simply use `monkeypatch.undo`. Naturally, at the
    end of your test function, `monkeypatch.undo()` will be called automatically.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 要撤销所有修改，只需使用 `monkeypatch.undo`。当然，在测试函数的末尾，`monkeypatch.undo()` 将会自动调用。
- en: 'For example, let’s say that for a certain test, we need to work from a different
    directory. With `mock`, your options would be to mock pretty much all file functions,
    including the `os.path` functions, and even in that case, you will probably forget
    about a few. So, it’s definitely not useful in this case. Another option would
    be to put the entire test into a `try...finally` block and just do an `os.chdir`
    before and after the testing code. This is quite a good and safe solution, but
    it’s a bit of extra work, so let’s compare the two methods:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设对于某个测试，我们需要从一个不同的目录中工作。使用 `mock`，你的选择是模拟几乎所有的文件函数，包括 `os.path` 函数，即使在那种情况下，你也可能忘记一些。所以，在这种情况下，它肯定不是很有用。另一个选择是将整个测试放入一个
    `try...finally` 块中，并在测试代码前后执行 `os.chdir`。这是一个相当好且安全的方法，但需要额外的工作，所以让我们比较这两种方法：
- en: '[PRE67]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: They effectively do the same, but one needs a single line of code to temporarily
    change directory whereas the other needs four, or five if you count the `os` import
    as well. All of these can easily be worked around with a few extra lines of code,
    of course, but the simpler the code is, the fewer mistakes you can make and the
    more readable it is.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 它们实际上做的是同一件事，但一个需要一行代码来临时更改目录，而另一个需要四行，如果将`os`导入也计算在内的话，则需要五行。当然，所有这些都可以通过几行额外的代码轻松解决，但代码越简单，你犯的错误就越少，代码的可读性也越高。
- en: Now that we know how to fake objects, let’s look at how we can run our tests
    on multiple platforms simultaneously using `tox`.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何伪造对象，让我们看看我们如何可以使用`tox`在多个平台上同时运行我们的测试。
- en: Testing multiple environments with tox
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用tox测试多个环境
- en: Now that we have written our tests and are able to run them for our own environment,
    it’s time to make sure that others can easily run the tests too. `tox` can create
    sandboxed environments for all specified Python versions (assuming they are installed)
    and runs them automatically and in parallel if needed. This is especially useful
    to test if your dependency specification is up to date. While you may have a lot
    of packages installed in your local environment, someone else might not have those
    packages.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经编写了测试，并且能够为我们自己的环境运行它们，现在是时候确保其他人也能轻松运行测试了。`tox`可以为所有指定的Python版本创建沙盒环境（假设它们已安装），并在需要时自动并行运行它们。这对于测试你的依赖规范是否是最新的特别有用。虽然你可能在本地环境中安装了大量的包，但其他人可能没有那些包。
- en: Getting started with tox
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始使用tox
- en: 'Before we can do anything, we need to install the `tox` command. A simple pip
    install will suffice:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够做任何事情之前，我们需要安装`tox`命令。简单的pip安装就足够了：
- en: '[PRE68]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'After the install, we can start by creating a `tox.ini` file to specify what
    we want to run. The easiest way is by using `tox-quickstart`, but if you already
    have a functioning `tox.ini` from a different project you can easily copy and
    modify that:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，我们可以通过创建一个`tox.ini`文件来指定我们想要运行的内容。最简单的方法是使用`tox-quickstart`，但如果你已经从一个不同的项目中有一个功能正常的`tox.ini`文件，你可以轻松地复制并修改它：
- en: '[PRE69]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Now we have our first `tox` configuration finished. The `tox-quickstart` command
    has made a `tox.ini` file with a few sane defaults.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了第一个`tox`配置。`tox-quickstart`命令已经创建了一个包含一些合理默认值的`tox.ini`文件。
- en: When looking at the output of `tox-quickstart`, you might be wondering why newer
    Python versions are not listed. The reason is that the Python versions are hardcoded
    in the `tox-quickstart` command at the time of writing. This issue is expected
    to be solved in the near future but should not be a big issue in either case,
    as the versions can be changed in the `tox.ini` file quite easily.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 当查看`tox-quickstart`的输出时，你可能会想知道为什么没有列出较新的Python版本。原因是，在写作时，Python版本被硬编码在`tox-quickstart`命令中。这个问题预计将在不久的将来得到解决，但在任何情况下都不应该是一个大问题，因为版本可以在`tox.ini`文件中相当容易地更改。
- en: The tox.ini config file
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: tox.ini配置文件
- en: 'The `tox.ini` file is very basic by default:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`tox.ini`文件非常基础：
- en: '[PRE70]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The `tox.ini` file usually consists of two main types of sections, the `tox`
    and `testenv` sections.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '`tox.ini`文件通常由两种主要类型的部分组成，即`tox`和`testenv`部分。'
- en: 'The `tox` section configures the `tox` command itself and specifies options
    such as:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '`tox`部分配置了`tox`命令本身并指定了如下的选项：'
- en: '`envlist`: Specifies the default list of environments to run, can be overridden
    by running `tox -e <env>`.'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`envlist`：指定要运行的默认环境列表，可以通过运行`tox -e <env>`来覆盖。'
- en: '`requires`: Specifies which packages (and specific versions) are required alongside
    `tox`. This can be useful for specifying a specific `setuptools` version so your
    package can be installed correctly.'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`requires`：指定与`tox`一起所需的包（和特定版本）。这可以用来指定特定的`setuptools`版本，以便你的包可以正确安装。'
- en: '`skip_missing_interpreters`: A very useful feature that allows you to test
    all available environments on your system but skip the ones that are not installed.'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`skip_missing_interpreters`：一个非常实用的功能，允许你测试系统上所有可用的环境，但跳过那些未安装的环境。'
- en: 'The `testenv` section configures your actual environment. Some of the most
    useful options are:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '`testenv`部分配置了你的实际环境。其中一些最有用的选项包括：'
- en: '`basepython`: The Python executable to run, useful if your Python binary has
    a non-standard name but more commonly useful when using custom environment names.'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`basepython`：要运行的Python可执行文件，如果你的Python二进制文件有一个非标准名称，这很有用；更常见的是，当使用自定义环境名称时更有用。'
- en: '`commands`: Commands to run when testing, in our case `pytest`.'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`commands`：测试时运行的命令，在我们的例子中是`pytest`。'
- en: '`install_command`: Command to run to install the package, defaults to `python
    -m pip install {opts} {packages}(ARGV)`.'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`install_command`：运行以安装包的命令，默认为`python -m pip install {opts} {packages}(ARGV)`。'
- en: '`allowlist_externals`: Which external commands such as `make`, `rm`, `ls`,
    and `cd` to allow so they can be run from the package or the scripts.'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`allowlist_externals`：允许哪些外部命令，如`make`、`rm`、`ls`和`cd`，以便它们可以从包或脚本中运行。'
- en: '`changedir`: Switch to a specific directory before running tests; to the directory
    containing the tests, for example.'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`changedir`：在运行测试之前切换到特定目录；例如，切换到包含测试的目录。'
- en: '`deps`: Which Python packages to install, uses the `pip` command syntax. A
    `requirements.txt` file can be specified through `-rrequirements.txt`.'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`deps`：要安装的Python包，使用`pip`命令语法。可以通过`-rrequirements.txt`指定`requirements.txt`文件。'
- en: '`platform`: Restrict the environment to a specific value of `sys.platform`.'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`platform`：将环境限制为`sys.platform`的特定值。'
- en: '`setenv`: Set environment variables, very useful to let tests know that they
    are being run from `tox`, for example.'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setenv`：设置环境变量，非常有用，可以让测试知道它们是从`tox`中运行的，例如。'
- en: '`skipsdist`: With this flag enabled, you can test a regular directory instead
    of only installable Python packages.'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`skipsdist`：启用此标志后，你可以测试普通目录，而不仅仅是可安装的Python包。'
- en: The most interesting part of the configuration is the `testenv` section prefix.
    While the `testenv` options above can be configured globally for all environments,
    you can use a section such as `[testenv:my_custom_env]` to only apply to your
    custom environment. In those cases, you will need to specify the `basepython`
    option so `tox` knows what to execute.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 配置中最有趣的部分是`testenv`部分前缀。虽然上面的`testenv`选项可以全局配置所有环境，但你也可以使用如`[testenv:my_custom_env]`这样的部分，仅适用于你的自定义环境。在这些情况下，你需要指定`basepython`选项，这样`tox`就知道要执行什么。
- en: Additionally to a single environment, you can also expand the pattern to configure
    multiple environments simultaneously with a pattern such as `[testenv:py{27,38}]`
    to specify both the `py27` and `py38` environments.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 除了单个环境之外，你还可以使用如`[testenv:py{27,38}]`这样的模式同时配置多个环境，以指定`py27`和`py38`环境。
- en: 'Expansions such as `py{27,38}` are also possible for all other options, so
    to specify a whole list of Python environments, you could do:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有其他选项，也可以使用如`py{27,38}`这样的扩展，因此要指定整个Python环境列表，你可以这样做：
- en: '[PRE71]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Furthermore, all options in the `tox.ini` also allow for variable interpolation
    based on a whole range of available variables, such as `{envname}`, but also based
    on options from other environments. The next example shows how to copy the `basepython`
    variable from the `py39` environment:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`tox.ini`中的所有选项都允许基于一系列可用变量进行变量插值，例如`{envname}`，也可以基于其他环境中的选项。下一个示例显示了如何从`py39`环境复制`basepython`变量：
- en: '[PRE72]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Naturally, interpolating from environment variables is also possible:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，也可以从环境变量中进行插值：
- en: '[PRE73]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'With an optional default:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 可选默认值：
- en: '[PRE74]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Running tox
  id: totrans-332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行tox
- en: Now that we know some of the basic config options for `tox`, let’s run a simple
    test to illustrate how convenient it can be.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了`tox`的一些基本配置选项，让我们运行一个简单的测试来展示它有多方便。
- en: 'First we need to create a `tox.ini` file to configure `tox`:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一个`tox.ini`文件来配置`tox`：
- en: '[PRE75]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Next, we will create a `test.py` file containing the Python 3.9 `dict` merge
    operator:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个包含Python 3.9 `dict`合并操作符的`test.py`文件：
- en: '[PRE76]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Now when running `tox`, it will show us that this syntax failed on Python 3.8
    and works on Python 3.9 as expected:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当运行`tox`时，它将显示这个语法在Python 3.8上失败，在Python 3.9上按预期工作：
- en: '[PRE77]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: That all looks good – an error for Python 3.8 and a fully working Python 3.9
    run. This is where `tox` is really useful; you can easily test multiple Python
    versions and multiple environments simultaneously, even in parallel if you use
    the `tox -p<processes>` parameter. And best of all, since it creates a completely
    blank Python environment, you are testing your requirements specification as well.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都看起来很好——Python 3.8的一个错误和一个完全工作的Python 3.9运行。这就是`tox`真正有用的地方；你可以轻松地同时测试多个Python版本和多个环境，如果你使用`tox
    -p<processes>`参数，甚至可以并行测试。而且最好的是，因为它创建了一个完全空的Python环境，你还可以测试你的需求规范。
- en: Now that we know how to run our tests on multiple Python environments simultaneously,
    it is time to continue with `logging`, the last section of this chapter. While
    a simple print statement can be very useful in debugging, when working on larger
    or distributed systems it is often not the most convenient option anymore. This
    is where the `logging` module can help you greatly to debug your issues.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了如何在多个Python环境中同时运行我们的测试，现在是时候继续本章的最后一个部分——`logging`了。虽然简单的打印语句在调试时非常有用，但在处理更大的或分布式系统时，它可能不再是最佳选择。这就是`logging`模块可以帮助你极大地调试问题的地方。
- en: Logging
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志记录
- en: The Python `logging` module is one of those modules that are extremely useful,
    but it tends to be very difficult to use correctly. The result is often that people
    just disable logging completely and use `print` statements instead. While it is
    somewhat understandable, this is a waste of the very extensive logging system
    in Python.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: Python的`logging`模块是那些极其有用但往往很难正确使用的模块之一。结果是人们通常会完全禁用日志记录，并使用`print`语句代替。虽然这可以理解，但这浪费了Python中非常广泛的日志系统。
- en: The Python `logging` module is largely based on the Java `log4j` library so
    it might be familiar to you if you’ve written Java before. That is also one of
    the biggest problems with the `logging` module in my opinion; Python is not Java
    and the `logging` module feels pretty un-Pythonic because of it. That does not
    make it a bad library, but it takes a little effort to get used to its design.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: Python的`logging`模块在很大程度上基于Java的`log4j`库，如果你之前写过Java，可能会很熟悉。这也是我认为`logging`模块最大的问题之一；Python不是Java，由于这个原因，`logging`模块感觉非常不符合Python风格。这并不意味着它是一个糟糕的库，但适应其设计需要一点努力。
- en: 'The most important objects of the `logging` module are the following:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '`logging`模块最重要的对象如下：'
- en: '**Logger**: The actual logging interface'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**记录器**：实际的日志接口'
- en: '**Handler**: This processes the log statements and outputs them'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理器**：处理日志语句并将它们输出'
- en: '**Formatter**: This formats the input data into a string'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**格式化器**：将输入数据格式化为字符串'
- en: '**Filter**: This allows filtering of certain messages'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过滤器**：允许过滤某些消息'
- en: 'Within these objects, you can set the logging levels to one of the default
    levels:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些对象中，你可以将日志级别设置为以下默认级别之一：
- en: '`CRITICAL: 50`'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CRITICAL: 50`'
- en: '`ERROR: 40`'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ERROR: 40`'
- en: '`WARNING: 30`'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WARNING: 30`'
- en: '`INFO: 20`'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INFO: 20`'
- en: '`DEBUG: 10`'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DEBUG: 10`'
- en: '`NOTSET: 0`'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NOTSET: 0`'
- en: The numbers are the numeric values of these log levels. While you can generally
    ignore them, the order is obviously important while setting the minimum level.
    Also, when defining custom levels, you will have to overwrite existing levels
    if they have the same numeric value.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 这些日志级别的数字值。虽然你可以一般忽略它们，但在设置最小级别时，顺序显然很重要。另外，当定义自定义级别时，如果它们具有相同的数字值，你必须覆盖现有级别。
- en: Configuration
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置
- en: There are several ways to configure the logging system, ranging from pure code
    to JSON files or even remote configuration. The examples will use parts of the
    `logging` module discussed later in this chapter, but the usage of the config
    system is all that matters here. If you are not interested in the internal workings
    of the `logging` module, you should be able to get by with just this paragraph
    of the *Logging* section.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 配置日志系统有几种方法，从纯代码到JSON文件，甚至远程配置。示例将使用本章后面讨论的`logging`模块的部分，但这里重要的是配置系统的使用。如果你对`logging`模块的内部工作不感兴趣，你应该能够仅通过本节中的这一段来理解。
- en: Basic logging configuration
  id: totrans-360
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基本日志配置
- en: 'The most basic logging configuration is, of course, no configuration, but that
    will not get you much useful output:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 最基本的日志配置当然是不配置，但这不会给你带来多少有用的输出：
- en: '[PRE78]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'With the default log level, you will only see a `WARNING` and up:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 使用默认的日志级别，你将只会看到`WARNING`及以上：
- en: '[PRE79]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: A quick and easy start for a configuration is `logging.basicConfig()`. I recommend
    using this if you just need some quick logging for a script you’re writing, but
    not for a full-blown application. While you can configure pretty much anything
    you wish, once you get a more complicated setup, there are usually more convenient
    options. We will talk more about that in later paragraphs, but first, we have
    `logging.basicConfig()`, which creates a `logging.StreamHandler` that is added
    to the root logger and configured to write all output to `sys.stderr` (standard
    error). Note that if the root logger already has handlers, the `logging.basicConfig()`
    function does nothing (unless `force=True`).
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 配置的一个快速简单的方法是 `logging.basicConfig()`。如果你只是需要为编写的脚本进行一些快速日志记录，而不需要用于完整的应用程序，我建议使用这个方法。虽然你可以配置几乎任何你希望的东西，但一旦你有一个更复杂的设置，通常有更多方便的选项。我们将在后面的段落中更多地讨论这一点，但首先，我们有
    `logging.basicConfig()`，它创建一个 `logging.StreamHandler`，并将其添加到根记录器中，配置为将所有输出写入 `sys.stderr`（标准错误）。请注意，如果根记录器已经有处理程序，则
    `logging.basicConfig()` 函数不会做任何事情（除非 `force=True`）。
- en: If no log handlers are configured for the root logger, the logging functions
    (`debug()`, `info()`, `warning()`, `error()`, and `critical()`) will automatically
    call `logging.basicConfig()` to set up a logger for you. This means that if you
    have a log statement before your `logging.basicConfig()` call, it will be ignored.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 如果根记录器没有配置日志处理程序，则日志函数（`debug()`、`info()`、`warning()`、`error()` 和 `critical()`）将自动调用
    `logging.basicConfig()` 为你设置记录器。这意味着，如果你的日志语句在 `logging.basicConfig()` 调用之前，它将被忽略。
- en: 'To illustrate the usage of `basicConfig()` with a few customizations:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明如何使用带有一些自定义设置的 `basicConfig()`：
- en: '[PRE80]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Now we can test the code:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以测试代码：
- en: '[PRE81]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'This will give us the following output on our screen:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在我们的屏幕上给出以下输出：
- en: '[PRE82]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'And here is the output in the `debug.log` file:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 `debug.log` 文件中的输出：
- en: '[PRE83]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: This configuration shows how log outputs can be configured with separate configurations,
    log levels, and, if you choose so, formatting. It tends to become unreadable though,
    which is why it’s usually a better idea to use `basicConfig` only for simple configurations
    that don’t involve multiple handlers.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置显示了如何使用单独的配置、日志级别以及（如果你选择的话）格式来配置日志输出。然而，它往往变得难以阅读，这就是为什么通常更好的想法是只为不涉及多个处理程序的基本配置使用
    `basicConfig`。
- en: Dictionary configuration
  id: totrans-376
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字典配置
- en: '`dictConfig` makes it possible to name all parts so that they can be reused
    easily, for example, a single formatter for multiple loggers and handlers. Let’s
    rewrite our previous configuration using `dictConfig`:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '`dictConfig` 使得命名所有部分成为可能，以便它们可以轻松重用，例如，为多个记录器和处理程序使用单个格式化程序。让我们使用 `dictConfig`
    重写我们之前的配置：'
- en: '[PRE84]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: You can probably see the similarities with the `logging.basicConfig()` call
    we used earlier. It is merely a different syntax for a `logging` configuration.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到了与我们之前使用的 `logging.basicConfig()` 调用的相似之处。它只是 `logging` 配置的不同语法。
- en: The nice thing about the dictionary configuration is that it’s very easy to
    extend and/or overwrite the logging configuration. For example, if you want to
    change the formatter for all of your logging, you can simply change the `standard`
    formatter or even loop through `handlers`.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 字典配置的好处在于它非常容易扩展和/或覆盖日志配置。例如，如果你想更改所有日志的格式化程序，你可以简单地更改 `standard` 格式化程序，甚至遍历
    `handlers`。
- en: JSON configuration
  id: totrans-381
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JSON 配置
- en: Since `dictConfig` takes any type of dictionary, it is actually quite simple
    to implement a different type of reader employing JSON or YAML files. This is
    especially useful as they tend to be a bit friendlier toward non-Python programmers.
    As opposed to Python files, they are easily readable and writable from outside
    of Python.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `dictConfig` 可以接受任何类型的字典，因此实现使用 JSON 或 YAML 文件的不同类型的读取器实际上非常简单。这对于它们对非 Python
    程序员来说更加友好。与 Python 文件相比，它们可以从 Python 之外轻松地读取和写入。
- en: 'Let’s assume that we have a `T_26_logging_json_config.json` file such as the
    following:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个 `T_26_logging_json_config.json` 文件，如下所示：
- en: '[PRE85]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'We can simply use this code to read the config:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以简单地使用以下代码来读取配置：
- en: '[PRE86]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Naturally, you could use any source that can generate a `dict`, but be mindful
    of the source. Since the `logging` module will import the specified class, it
    can be a potential security risk.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 自然，你可以使用任何可以生成 `dict` 的来源，但请注意来源。由于 `logging` 模块将导入指定的类，因此可能存在潜在的安全风险。
- en: ini file configuration
  id: totrans-388
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ini 文件配置
- en: 'The file configuration is probably the most readable format for non-programmers.
    It uses the `ini-style` configuration format and uses the `configparser` module
    internally. The downside is that it is perhaps a little verbose, but it is clear
    enough and makes it easy to combine several configuration files without us having
    to worry too much about overwriting other configurations. Having said that, if
    `dictConfig` is an option, then it is most likely a better option. This is because
    `fileConfig` is slightly limited and awkward at times. Just look at the handlers
    as an example:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 文件配置可能是非程序员最易读的格式。它使用 `ini-style` 配置格式，并在内部使用 `configparser` 模块。缺点是它可能有点冗长，但足够清晰，并且使得在不担心覆盖其他配置的情况下合并多个配置文件变得容易。话虽如此，如果
    `dictConfig` 是一个选项，那么它可能是一个更好的选择。这是因为 `fileConfig` 在某些时候略显有限且有些笨拙。以处理器为例：
- en: '[PRE87]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Reading the files is extremely easy though:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 读取文件却非常简单：
- en: '[PRE88]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: One thing to make note of, however, is that if you look carefully, you will
    see that this config is slightly different from the other configs. With `fileConfig`
    you can’t just use keyword arguments alone. The args is required for both `FileHandler`
    and `StreamHandler`.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一点需要注意，如果您仔细观察，您会看到这个配置与其他配置略有不同。使用 `fileConfig`，您不能仅使用关键字参数。对于 `FileHandler`
    和 `StreamHandler`，都需要 `args` 参数。
- en: The network configuration
  id: totrans-394
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 网络配置
- en: The network configuration is a rarely used but very convenient way to configure
    your loggers across multiple processes. This type of configuration is quite esoteric
    and if you have no use for such a setup, feel free to skip to the *Logger* section.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 网络配置是一种很少使用但非常方便的方式，可以在多个进程中配置您的日志记录器。这种配置相当晦涩，如果您不需要这种设置，请随意跳转到 *日志记录器* 部分。
- en: The major caveat of the network configuration is that it can be dangerous because
    it allows you to configure your logger on the fly while your application/script
    is still running. The dangerous part is that the config is (partially) read by
    using the `eval` function, which allows people to potentially execute code within
    your application remotely. Even though `logging.config.listen` only listens to
    local connections, it can still be dangerous if you execute the code on a shared/unsafe
    host where others can run code as well.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 网络配置的主要缺点是它可能很危险，因为它允许在您的应用程序/脚本仍在运行时动态配置您的日志记录器。危险的部分在于配置是通过使用 `eval` 函数（部分）读取的，这允许人们远程在您的应用程序中执行代码。尽管
    `logging.config.listen` 只监听本地连接，但如果您在共享/不安全的主机上执行代码，其他人也可以运行代码，这仍然可能很危险。
- en: 'If your system is unsafe, you can pass `verify` as a callable argument to `listen()`,
    which could implement signature verification or encryption of the configurations
    before they are evaluated. By default, the `verify` function is analogous to `lambda
    config: config`. As the most simple verification method, you could use something
    along these lines:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '如果您的系统不安全，您可以将 `verify` 作为可调用参数传递给 `listen()`，这可以实现在配置评估之前对配置进行签名验证或加密。默认情况下，`verify`
    函数类似于 `lambda config: config`。作为最简单的验证方法，您可以使用类似以下的内容：'
- en: '[PRE89]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'To show the workings of the network configuration, we need two scripts. One
    script will continuously print a few messages to the loggers and the other will
    change the logging configuration. We will start with the same test code that we
    had before, but keep it running in an endless loop with a `sleep` in between:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示网络配置的工作原理，我们需要两个脚本。一个脚本将不断向日志记录器打印几条消息，另一个将更改日志配置。我们将从之前相同的测试代码开始，但将其保持在一个带有
    `sleep` 的无限循环中运行：
- en: '[PRE90]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Now we need to run both of the scripts at the same time. First, we start the
    `receive` script, which will start outputting data:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要同时运行这两个脚本。首先，我们启动 `receive` 脚本，它将开始输出数据：
- en: '[PRE91]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'In the meantime, we run the `send` command:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，我们运行 `send` 命令：
- en: '[PRE92]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: As you can see, the logging configuration was updated while the code was still
    running. This can be very useful for long-running scripts that you need to debug
    but don’t want to restart.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，在代码仍在运行时，日志配置已被更新。这对于需要调试但不想重新启动的长运行脚本非常有用。
- en: 'In addition to the output on the screen, the extra output was sent to the `debug.log`
    file, which looks something like this now:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 除了屏幕上的输出外，额外的输出被发送到 `debug.log` 文件，现在看起来像这样：
- en: '[PRE93]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: This allows you to redirect mostly useless debug output to a separate log file
    while still keeping the most important messages on the screen.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许您将大部分无用的调试输出重定向到单独的日志文件，同时仍然在屏幕上保留最重要的消息。
- en: Logger
  id: totrans-409
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main object that you will be using all the time with the `logging` module
    is the `Logger` object. This object contains all the APIs that you will need to
    do the actual logging. Most are simple enough but some require attention.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: First of all, loggers inherit the parent settings by default. As we have seen
    previously, with the `propagate` setting, by default, all settings will propagate
    from the parent. This is really useful when incorporating loggers within your
    files.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming your modules are using sane names and import paths, I recommend the
    following style of naming your loggers:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'By using this style, your loggers will get names such as `main_module.sub_module.ClassName`.
    Not only does this make your logs easier to read, but also it is easily possible
    to enable or disable logging per module with the propagation of log settings.
    To create a new log file that logs everything from `main_module.sub_module`, we
    can simply do this:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Alternatively, you can configure it using your chosen configuration option,
    of course. The relevant point is that with sub-loggers, you have very fine-grained
    control over your loggers.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: 'This includes increasing the log level:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Usage
  id: totrans-419
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The usage of the `Logger` object is mostly identical to that of the bare `logging`
    module, but `Logger` actually supports a bit more. This is because the bare `logging`
    module just calls the functions on the root logger. The `Logger` object has a
    few very useful properties, although most of these are undocumented in the library:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: '`propagate`: Whether to pass events to this logger or to the handlers of the
    parent loggers. Without this, a log message to `main_module.sub_module` won’t
    be logged by `main_module`.'
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `handle` method will keep looking for parent handlers as long as those loggers
    have `propagate` set to `true`, which is the default.
  id: totrans-422
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`filters`: These are the filters attached to the logger. They can be set through
    `addFilter` and `removeFilter`. To see whether a message will be filtered, the
    `filter` method can be used.'
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`disabled`: By setting this property, it’s possible to disable a certain logger.
    The regular API only allows the disabling of all loggers below a certain level.
    This offers some fine-grained control.'
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`handlers`: These are the handlers attached to the logger. They can be added
    through `addHandler` and `removeHandler`. The existence of any (inherited) handlers
    can be checked through the `hasHandlers` function.'
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`level`: This is really an internal one as it simply has a numeric value and
    not a name. But beyond that, it doesn’t take inheritance into account, so it’s
    better to avoid the property and use the `getEffectiveLevel` function instead.
    To check whether the setting is enabled for a `DEBUG`, for example, you can simply
    do `logger.isEnabledFor(logging.DEBUG)`. Setting the property is possible through
    the `setLevel` function, of course.'
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name`: As this property’s name suggests, it is very useful for your own reference,
    of course.'
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that you know about the properties, it is time to discuss the logging functions
    themselves. The functions you will use most often are the `log`, `debug`, `info`,
    `warning`, `error`, and `critical` log functions. They can be used quite simply,
    but they support string formatting as well, which is very useful:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Formatting
  id: totrans-430
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When seeing the previous examples, you might wonder why we use `logger.error(''error:
    %r'', error)` instead of regular string formatting with f-strings, `%`, or `string.format`
    instead. The reason is that when parameters are used instead of preformatted strings,
    the handler gets them as parameters. The result is that you can group log messages
    by the original string, which is what tools such as Sentry ([https://github.com/getsentry/sentry](https://github.com/getsentry/sentry))
    use.'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: 'There is more to it, however. In terms of parameters, `*args` are only for
    string formatting, but it’s possible to add extra parameters to a log object using
    the `extra` keyword parameter:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'These `extra` parameters can be used in the logging formatter to display extra
    information just like the standard formatting options:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'This results in the following:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'However, one of the most useful features is the support for exceptions:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'This results in a stack trace for the exception, but it will not kill the code:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Modern formatting using f-strings and str.format
  id: totrans-442
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Python `logging` module is still largely based on the “old” formatting syntax
    and doesn’t have much support for `str.format`. For the `Formatter` itself, you
    can easily use the new style formatting, but that’s ultimately mostly useless
    since you rarely modify the `Formatter` and mainly need formatting when logging
    messages instead.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: 'Regardless, the syntax is simple enough to enable:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Which results in:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'For actual messages requiring formatting, we need to implement something ourselves,
    however. A logging adapter is the easiest solution:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'When executing the code, this results in the following output:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: The solution still doesn’t look that pretty in my opinion, but it works. Because
    the formatting of log messages cannot be overridden easily in the `logging` module,
    we have created a separate `FormattingMessage` that formats itself whenever `str(message)`
    is called. This way we can override the formatting using a simple `logging.LoggerAdapter`
    without having to replace large portions of the `logging` library.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: Please note that if you want to send the value of `kwargs` to a logger such
    as Sentry, you will need to make sure the order of operations is correct, since
    this method cannot pass the `kwargs` along or the standard log formatter would
    complain.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, you might be wondering why we used the `FormattingMessage` instead
    of running `msg.format(**kwargs)` in the `process()` method. The reason is that
    we want to avoid string formatting for as long as possible.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: If the logger doesn’t have an active handler or the handler ignores messages
    of this level, it means we would have done useless work. Depending on the implementation,
    string formatting can be a very heavy operation and the `logging` system is meant
    to be as light as possible until enabled.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: Logging pitfalls
  id: totrans-456
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The logging propagation is one of the most useful features and also the biggest
    problem with the `logging` module. We have already seen how logging settings are
    inherited from parent loggers, but what if you override them? Well, let’s find
    out:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'When we run this code, we get this output:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: In this case it’s obvious that the `a.setLevel(...)` caused the issue, but if
    that happens in some external code that you didn’t know about, you could be searching
    for a long time.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: 'And the reverse can also happen; an explicit level on a logger will ignore
    your parent level:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'When we execute this, we notice that setting the level is completely ignored:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: Once again, not a problem in this case, but if that happens in some external
    library without your knowledge it can certainly cause a headache.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: Debugging loggers
  id: totrans-467
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most important rule about loggers is that they inherit the settings from
    the parent loggers unless you override them. If your logging isn’t working as
    you expect it, most of the time it’s caused by some inheritance issue and that
    can be difficult to debug.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: 'The logging flow according to the Python manual looks like this:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: '![../_images/logging_flow.png](img/B15882_10_04.png)'
  id: totrans-470
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.4: Logging flow. Copyright © 2001-2021 Python Software Foundation;
    All Rights Reserved'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we know how the logging flow is supposed to go, we can start creating
    a method to show our current logger structure and the settings:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: The `get_handlers()` function recursively walks through a logger and all of
    its parents to collect all propagated handlers. The `debug_loggers()` function
    walks through the internal config of the `logging` module to list all configured
    loggers and fetch the matching handlers through `get_handlers()`.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: 'This is just a basic debugging function of course, but it can really help you
    when you’re wondering why your logging is not working as expected. The output
    looks something like this:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: Now we can see that the `a` logger has level `INFO` but only has a handler at
    a `WARNING` level. So, none of our `INFO` messages will show. Similarly, the `a.b`
    logger has a `DEBUG` level but a handler at level `INFO` so it will only show
    `INFO` and higher levels.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-478
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have seen several testing and logging options, it’s time to try
    it yourself.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: 'A few challenges:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: Create a function that tests the doctests of a given function/class.
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a greater challenge, create a function that recursively tests all doctests
    of every function and class in a given module.
  id: totrans-482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create a `py.test` plugin that checks if all tested files have file-level documentation.
    Hint: use `pytest_collect_file`.'
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a custom `tox` environment to run `flake8` or `mypy` on your project.
  id: totrans-484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a `LoggerAdapter` that combines multiple messages into a single message
    based on some task ID. This can be useful when debugging long-running tasks.
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Example answers for these exercises can be found on GitHub: [https://github.com/mastering-python/exercises](Chapter_10.xhtml).
    You are encouraged to submit your own solutions and learn about alternative solutions
    from others.'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-487
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter showed us how to write doctests, make use of the shortcuts provided
    by `py.test`, and use the `logging` module. With testing, there is never a one-size-fits-all
    solution. While the `doctest` system is very useful in many cases for providing
    both documentation and tests at the same time, in many functions there are edge
    cases that simply don’t matter for documentation but still need to be tested.
    This is where regular unit tests come in and where `py.test` helps a lot.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: We have also seen how we can use `tox` to run tests in multiple sandboxed environments.
    If you ever have a project that also has to run on different computers or even
    on different Python versions, I would highly encourage you to use it.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: The `logging` module is extremely useful when configured correctly and if your
    project becomes somewhat larger, it quickly becomes useful to do so. The usage
    of the logging system should be clear enough for most of the common use cases
    now, and as long as you keep the `propagate` parameter in check, you should be
    fine when implementing a logging system.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: Next up is debugging, where testing helps prevent bugs. We will see how to solve
    them effectively. In addition, the logging that we added in this chapter will
    help a lot in that area.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: Join our community on Discord
  id: totrans-492
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers: [https://discord.gg/QMzJenHuJf](https://discord.gg/QMzJenHuJf)'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code156081100001293319171.png)'
  id: totrans-494
  prefs: []
  type: TYPE_IMG
