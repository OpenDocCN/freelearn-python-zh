- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing and Logging – Preparing for Bugs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When programming, most developers plan a bit and immediately start writing code.
    After all, we all expect to write bug-free code! Unfortunately, we don’t. At some
    point, an incorrect assumption, a misinterpretation, or just a silly mistake is
    bound to happen. Debugging (covered in *Chapter 11*, *Debugging – Solving the
    Bugs*) will always be required at some point, but there are several methods that
    you can use to prevent bugs or, at the very least, make it much easier to solve
    them when they do occur.
  prefs: []
  type: TYPE_NORMAL
- en: To prevent bugs from occurring in the first place, test-driven development or,
    at the very least, functional/regression/unit tests, are very useful. The standard
    Python installation alone offers several options such as the `doctest`, `unittest`,
    and `test` modules. The `doctest` module allows you to combine tests with example
    documentation. The `unittest` module allows you to easily write regression tests.
    The `test` module is meant for internal usage only, so unless you are planning
    to modify the Python core, you probably won’t need this one.
  prefs: []
  type: TYPE_NORMAL
- en: 'The test modules we will discuss in this chapter are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`doctest`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`py.test` (and why it’s more convenient than `unittest`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unittest.mock`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `py.test` module has roughly the same purpose as the `unittest` module,
    but it’s much more convenient to use and has many more options and plugins available.
  prefs: []
  type: TYPE_NORMAL
- en: After learning how to avoid the bugs, it’ll be time to take a look at logging
    so that we can inspect what is happening in our program and why. The `logging`
    module in Python is highly configurable and can be adjusted for just about any
    use case. If you’ve ever written Java code, you should feel right at home with
    the `logging` module, as its design is largely based on the `log4j` module and
    is very similar in both implementation and naming. The latter makes it a bit of
    an odd module in Python as well, as it is one of the few modules that does not
    follow the `pep8` naming standards.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will explain the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Combining documentation with tests using `doctest`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regression and unit tests using `py.test` and `unittest`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing with fake objects using `unittest.mock`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing multiple environments using `tox`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `logging` module effectively
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combining `logging` and `py.test`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using documentation as tests with doctest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `doctest` module is one of the most useful modules within Python. It allows
    you to combine documenting your code with tests to make sure that it keeps working
    as it is supposed to.
  prefs: []
  type: TYPE_NORMAL
- en: By now the format should be very familiar to you; most of the code samples in
    this book use the `doctest` format, which offers the advantage that both the input
    and the output are shown intertwined. Especially in demonstrations, this is much
    more convenient than having a block of code followed by the output.
  prefs: []
  type: TYPE_NORMAL
- en: A simple doctest example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s start with a quick example: a function that squares the input. The following
    example is a fully functional command-line application, containing not only code
    but also functioning tests. The first few tests cover how the function is supposed
    to behave when executing normally, followed by a few tests to demonstrate the
    expected errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'It can be executed as any Python script, but the regular command won’t give
    any output as all tests are successful. The `doctest.testmod` function takes verbosity
    parameters, luckily:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, since it uses the Google syntax (as discussed in *Chapter 9*,
    *Documentation – How to Use Sphinx and reStructuredText*, the documentation chapter),
    we can generate pretty documentation using Sphinx:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A simple doctest example](img/B15882_10_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.1: Documentation generated using Sphinx'
  prefs: []
  type: TYPE_NORMAL
- en: However, the code is not always correct, of course. What will happen if we modify
    the code so that the tests do not pass anymore?
  prefs: []
  type: TYPE_NORMAL
- en: 'This time, instead of `n * n`, we use `n ** 2`. Both square a number, so the
    results must be identical. Right? These are the types of assumptions that create
    bugs, and the types of assumptions that are trivial to catch using a few basic
    tests. Since most results are the same we will skip them in the example, but one
    test has different results now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The only modification we made to the code was replacing `n * n` with `n ** 2`,
    which translates to the power function. Since multiplication is not the same as
    taking the power of a number, the results are slightly different, but similar
    enough in practice that most programmers wouldn’t notice the difference.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because of that difference, however, the error changed from `can''t multiply
    sequence ...` to `unsupported operand type(s) for ** or pow(): ...`. It’s an innocent
    mistake, but a quick optimization by a programmer could have changed this unintentionally
    with possibly wrong results. If the `__pow__` method was overloaded with different
    behavior, for example, this could result in bigger problems.'
  prefs: []
  type: TYPE_NORMAL
- en: This example has shown us how useful these tests can be. When rewriting or optimizing
    code, an incorrect assumption is easily made, and that is where tests are very
    useful—knowing you are breaking code as soon as you break it instead of finding
    out months later.
  prefs: []
  type: TYPE_NORMAL
- en: Writing doctests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perhaps you have noticed from the preceding examples that the syntax is very
    similar to the regular Python console, and that is because it is. The `doctest`
    input is nothing more than the output of a regular Python shell session. This
    is what makes testing with this module so intuitive; simply write the code in
    the Python console and copy the output into a docstring to get tests. Here is
    an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: That’s why this is probably the easiest way to test code. With almost no effort,
    you can check whether your code is working as you would expect it, add tests,
    and add documentation at the same time. Simply copy the output from the interpreter
    to your function or class documentation and you have functioning doctests.
  prefs: []
  type: TYPE_NORMAL
- en: Testing with documentation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The docstrings in functions, classes, and modules are usually the most obvious
    way to add doctests to your code, but they are not the only way. The Sphinx documentation,
    as we discussed in the previous chapter, also supports the `doctest` module.
  prefs: []
  type: TYPE_NORMAL
- en: To enable `doctest` support in Sphinx, you need to add the `sphinx.ext.doctest`
    extension in Sphinx, which tells Sphinx to run those tests as well. Since not
    all the examples in the code are useful, let’s see whether we can split them into
    the ones that are actually useful and the ones that are only relevant for documentation.
    Moreover, to see the results, we will add an error to the documentation.
  prefs: []
  type: TYPE_NORMAL
- en: '`square.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`square.rst`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it’s time to execute the tests. In the case of Sphinx, there is a specific
    command for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, we are getting an error for the incomplete `doctest`, but beyond
    that, all tests executed correctly. To make sure that the tests know what `square`
    is, we had to add the `testsetup` directive, and this still generates a pretty
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15882_10_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.2: Rendered Sphinx output'
  prefs: []
  type: TYPE_NORMAL
- en: Sphinx nicely renders both the documentation for the code and the highlighted
    code samples.
  prefs: []
  type: TYPE_NORMAL
- en: The doctest flags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `doctest` module features several option flags that affect how `doctest`
    processes the tests. These option flags can be passed globally using your test
    suite, through command-line parameters while running the tests, and through inline
    commands. For this book, I have globally enabled the following option flags through
    a `pytest.ini` file (we will cover more about `py.test` later in this chapter):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Without these option flags, some of the examples in this book will not function
    properly. This is because they have to be reformatted to fit. The next few paragraphs
    will cover the following option flags:'
  prefs: []
  type: TYPE_NORMAL
- en: '`DONT_ACCEPT_TRUE_FOR_1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NORMALIZE_WHITESPACE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ELLIPSIS`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are several other option flags available with varying degrees of usefulness,
    but these are better left to the Python documentation: [https://docs.python.org/3/library/doctest.html#option-flags](https://docs.python.org/3/library/doctest.html#option-flags%20)'
  prefs: []
  type: TYPE_NORMAL
- en: True and False versus 1 and 0
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Having `True` evaluating to `1` and `False` evaluating to `0` is useful in
    most cases, but it can give unexpected results if you were actually expecting
    a `bool` instead of an `int`. To demonstrate the difference, we have these lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run this, it will run the tests both without and with the `DONT_ACCEPT_TRUE_FOR_1`
    flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `DONT_ACCEPT_TRUE_FOR_1` flag makes `doctest` reject `1`
    as a valid response for `True` as well as `0` for `False`.
  prefs: []
  type: TYPE_NORMAL
- en: Normalizing whitespace
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Since doctests are used for both documentation and test purposes, it is pretty
    much a requirement to keep them readable. Without normalizing whitespace, this
    can be tricky, however. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'While not all that bad, this output isn’t the best for readability. With whitespace
    normalizing, here is what we can do instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Formatting the output in this manner is both more readable and convenient for
    keeping your lines shorter.
  prefs: []
  type: TYPE_NORMAL
- en: Ellipsis
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `ELLIPSIS` flag is very useful but also a bit dangerous, as it can easily
    lead to incorrect matches. It makes `...` match any substring, which is very useful
    for exceptions but dangerous in other cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: These cases are not too useful in real scenarios, but they demonstrate how the
    `ELLIPSIS` option flag functions. They also indicate the danger. Both `[1, 2,
    3, 4]` and `[1, 0, ... , 4]` match the `[1, ..., 4]` test, which is probably unintentional,
    so be very careful while using `ELLIPSIS`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A more useful case is when documenting class instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Without the `ELLIPSIS` flag, the memory address (the `0x...` part) would never
    be what you expect. Let’s demonstrate an actual run in a normal CPython instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Doctest quirks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The three option flags discussed earlier take care of quite a few quirks found
    in doctests, but there are several more cases that require care. In these cases,
    you just need to be a bit careful and work around the limitations of the `doctest`
    module. The `doctest` module effectively uses the representation string, and those
    are not always consistent.
  prefs: []
  type: TYPE_NORMAL
- en: The representation string can be generated using `repr(object)` and uses the
    `__repr__` magic method internally. On regular classes without a specific `__repr__`
    method, this will look like `<module.className instance at 0x....>`, where the
    `0x...` is the memory address of the object, which changes with each run and each
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most important cases are floating-point inaccuracies, and random values,
    such as timers. With the following example, the floating-point example will return
    consistent results for your system, but on a different system it is likely to
    fail. The `time` example will almost certainly always fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: All the problems have several possible solutions, which differ mostly in style
    and your personal preference.
  prefs: []
  type: TYPE_NORMAL
- en: Testing dictionaries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since the implementation of dictionaries has changed in recent Python versions,
    this exact issue is probably one you will not encounter anymore. However, there
    are still situations where similar solutions are useful.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with dictionaries used to be that they had an effectively random
    representation order. Since the `doctest` system requires a representation string
    that is identical in meaning (save for certain `doctest` flags, of course) to
    the `docstring`, this does not work. Naturally, there are several workaround options
    available and all have some advantages and disadvantages.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first is using the `pprint` (pretty print) library to format the dictionary
    in a pretty and consistent way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Since the `pprint` library always sorts the items before outputting, this solves
    the problem with random representation orders. However, it does require an extra
    import and function call, which some people prefer to avoid.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another option is manual sorting of the items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The downside here is that it is not visible from the output that `data` is a
    dictionary, which makes the output less readable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, comparing the `dict` with a different `dict` comprising the same elements
    works as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'A perfectly okay solution, of course! But `True` is not really the clearest
    output, especially if the comparison doesn’t work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, the other options presented previously show both the expected
    value and the returned value correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Personally, out of the solutions presented, I would recommend using `pprint`,
    as I find it the most readable solution, but all the solutions have some merits
    to them.
  prefs: []
  type: TYPE_NORMAL
- en: Testing floating-point numbers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For the same reason a floating-point comparison can be problematic (that is,
    `1/3 == 0.333`), a representation string comparison is also problematic. The easiest
    solution is to round or clip the value, but the `ELLIPSIS` flag is also an option
    here. Here is a list of several solutions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Which solution you choose should depend on your own preference or consistency
    with the project you are working on. In general, my choice would be to enable
    the `ELLIPSIS` option flag globally and go for that solution, as it looks the
    cleanest to me.
  prefs: []
  type: TYPE_NORMAL
- en: Times and durations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For timings, the problems that you will encounter are quite similar to the
    floating-point issues. When measuring the execution time of a code snippet, there
    will always be some variation present. That’s why limiting the precision is the
    easiest solution for time dependent tests. To achieve this we can check whether
    the delta (difference) between the two times is smaller than a certain number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'For the `timedelta` objects, however, it’s slightly more complicated. Yet,
    this is where the `ELLIPSIS` flag definitely comes in handy again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The alternative to the `ELLIPSIS` option flag would be comparing the days, hours,
    minutes, and microseconds in `timedelta` separately. Or you can use `timedelta.total_seconds()`
    to convert the `timedelta` into seconds and use a regular floating-point comparison.
  prefs: []
  type: TYPE_NORMAL
- en: In a later paragraph, we will see a completely stable solution for problems
    like these using mock objects. For doctests, however, that is generally overkill.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are done with `doctest`, it is time to continue with more explicit
    tests using `py.test`.
  prefs: []
  type: TYPE_NORMAL
- en: Testing with py.test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `py.test` tool makes it very easy to write tests and run them. There are
    a few other options such as `nose2` and the bundled `unittest` module available,
    but the `py.test` library offers a very good combination of usability and active
    development. In the past, I was an avid `nose` user but have since switched to
    `py.test` as it tends to be easier to use and has better community support, in
    my experience at least. Regardless, `nose2` is still a good choice, and if you’re
    already using either `nose` or `nose2`, there is little reason to switch and rewrite
    all of your tests. When writing tests for a new project, however, `py.test` can
    be much more convenient.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will run the doctests from the previously discussed `square.py` file
    using `py.test`.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, start by installing `py.test`, of course:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We also installed `pytest-flake8` here because the default `pytest.ini` for
    this project depends on it. We will discuss what it does and how it can be configured
    later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you can do a test run, so let’s give the doctests we have in `square.py`
    a try:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that `py.test` was able to find two tests for the given file: the
    test in `square.square` itself, and a `flake8` test from the `pytest-flake8` plugin
    that we will see later in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: The difference between the unittest and py.test output
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have the doctests in `square.py`. Let’s create a new class called `cube`
    and create a proper set of tests outside of the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we have the code of `cube.py`, similar to `square.py` but minus
    the doctests, since they mostly won’t work anyway:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s start with the `unittest` example, `T_09_test_cube.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This can be executed by executing the file itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, it can be done through the `unittest` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'But it also works with other tools such as `py.test`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'And other tools such as `nose` are also possible. First, we need to install
    it using pip:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we can use the `nosetests` command to run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: As long as all the results are successful, the differences between the output
    from `unittest` and `py.test` are slim. This time around, however, we are going
    to break the code to show the difference when it actually matters. Instead of
    the `cube` code, we will add the `square` code, returning `n ** 2` from `square`,
    instead of `n ** 3`.
  prefs: []
  type: TYPE_NORMAL
- en: To reduce the amount of output, we will not be running the verbose variants
    of the commands here.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we have the regular `unittest` output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Not all that bad, as each test returns a nice stack trace that includes the
    values and everything. Yet, we can observe a small difference here when compared
    with the `py.test` run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In small cases such as these, the difference is not all that apparent, but when
    testing complicated code with large stack traces, it becomes even more useful.
    However, for me personally, seeing the surrounding test code is a big advantage.
  prefs: []
  type: TYPE_NORMAL
- en: In the example that was just discussed, the `self.assertEqual(...)` line shows
    the entire test, but in many other cases, you will need more information. The
    difference between the regular `unittest` module and the `py.test` module is that
    with `py.test` you can see the entire function with all of the code and the output.
    Later in this chapter, we will see how powerful this can be when writing more
    advanced tests.
  prefs: []
  type: TYPE_NORMAL
- en: To truly appreciate the `py.test` output, we need colors as well. Unfortunately,
    that is not possible within the constraints of this book, but I strongly encourage
    you to give `py.test` a try if you aren’t using it already.
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps you are wondering now, “Is that all? The only difference between `py.test`
    and `unittest` is a bit of color and a slightly different output?” Well, far from
    it; there are many other differences, but this alone is enough reason to give
    it a try.
  prefs: []
  type: TYPE_NORMAL
- en: The difference between unittest and py.test tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The improved output does help a bit, but the combination of improved output
    and a much easier way to write tests is what makes `py.test` so useful. There
    are quite a few methods for making the tests simpler and more legible, and in
    many cases, you can choose which you prefer. As always, readability counts, so
    choose wisely and try not to over-engineer the solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Simplifying assertions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Where the `unittest` library requires the usage of `self.assertEqual` to compare
    variables, `py.test` allows the use of a regular `assert` statement while still
    understanding the comparison between the variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following test file contains three styles of tests, so they can be compared
    easily:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'To convert to `py.test`, we simply replaced `self.assertEqual` with `assert
    ... == ...`. A minor improvement indeed, but the actual benefit is seen in the
    failure output. The first two use the `unittest` style and the latter two use
    the `py.test` style both inside a class and as separate functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In addition to seeing the values that were compared, we can actually see the
    function that was called and which input parameters it received. With the regular
    `unittest` we have no way of knowing that `2` was entered as a parameter to the
    `cube()` function.
  prefs: []
  type: TYPE_NORMAL
- en: The standard `py.test` behavior works for most test cases, but it may not be
    enough for some custom types. For example, let’s say that we have a `User` object
    with a `name` attribute that should be compared with the `name` attribute on another
    object. This part can easily be achieved by implementing the `__eq__` method on
    `User`, but it does not improve clarity. Since `name` is the attribute that we
    compare, it would be useful if the tests showed `name` when errors were displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'First is the class with two tests, one working and one broken to demonstrate
    the regular output:'
  prefs: []
  type: TYPE_NORMAL
- en: '`T_11_representing_assertions.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is the regular `py.test` output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The default test output is still usable since the function is fairly straightforward,
    and the value for `name` is visible due to it being available in the constructor.
    However, it would have been more useful if we could explicitly see the value of
    `name`. By adding a `pytest_assertrepr_compare` function to the `conftest.py`
    file, we can modify the behavior of the `assert` statements.
  prefs: []
  type: TYPE_NORMAL
- en: The `conftest.py` file is a special file for `py.test` that can be used to override
    or extend `py.test`. Note that this file will automatically be loaded by every
    test run in that directory, so we need to test the types of both the left-hand
    side and the right-hand side of the operator. In this case, it’s `a` and `b`.
  prefs: []
  type: TYPE_NORMAL
- en: '`conftest.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding function will be used as the output for our test. So when it
    fails, this time we get our own, slightly more useful, output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we could have easily changed the `__repr__` function of `User`
    as well, but there are many cases where modifying the `py.test` output can be
    useful – if you need more debug output, for example. Similar to this, there is
    specific support for many types, such as sets, dictionaries, and texts.
  prefs: []
  type: TYPE_NORMAL
- en: Parameterizing tests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So far, we have specified every test separately, but we can simplify tests a
    lot by parameterizing them. The square and cube tests are very similar; a certain
    input gave a certain output.
  prefs: []
  type: TYPE_NORMAL
- en: You could solve this by creating a loop in a test, but a loop in a test will
    be executed as a single test. This means that it will fail in its entirety if
    a single test iteration of the loop fails, which means you can’t easily see what
    exactly broke if you compare older and newer test output. In this example with
    the numbers, the result is obvious, but if you were to apply a list of filenames
    to a complicated processing test, it would be far less obvious what happened.
  prefs: []
  type: TYPE_NORMAL
- en: 'In these cases, parameterized tests can help a lot. After creating a list of
    parameters and the expected output data, you can make it run the test function
    for every parameter combination separately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'This outputs the following, as you might have already expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: With the parameterized tests, we can see the parameters clearly, which means
    we can see all inputs and outputs without any extra effort.
  prefs: []
  type: TYPE_NORMAL
- en: Generating the list of tests dynamically at runtime is also possible with a
    global function. Similar to the `pytest_assertrepr_compare` function that we added
    to `conftest.py` earlier, we can add a `pytest_generate_tests` function, which
    generates tests.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the `pytest_generate_tests` function can be useful only to test a subset
    of options depending on the configuration options. If possible, however, I recommend
    trying to configure selective tests using fixtures instead, as they are somewhat
    more explicit. We will cover this in the following section. The problem with functions
    such as `pytest_generate_tests` is that they are global and don’t discriminate
    between specific tests, resulting in strange behavior if you are not expecting
    that.
  prefs: []
  type: TYPE_NORMAL
- en: Automatic arguments using fixtures
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `py.test` fixture system is one of the most magical features of `py.test`.
    It magically executes a fixture function with the same **name** as your arguments.
    Let’s create a basic fixture to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: When the `test_something()` test is executed, the `name` argument will be filled
    with the output from the `name()` function automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because arguments are automatically filled by fixtures, the naming of the arguments
    becomes very important, as fixtures can easily collide with other fixtures. To
    prevent collisions, the scope is set to `function` by default. However, `class`,
    `module`, and `session` are also valid options for the scope. There are several
    fixtures available by default, some of which you will use often, and others most
    likely never. A complete list can always be generated with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The next few paragraphs demonstrate some fixture usage, and the `monkeypatch`
    fixture is covered later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: cache
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `cache` fixture is as simple as it is useful; there is a `get` function
    and a `set` function, and the `cache` state remains between separate `py.test`
    runs. To illustrate how to get and set values from `cache`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The default value (`0` in this case) is required for the `cache.get` function.
  prefs: []
  type: TYPE_NORMAL
- en: The cache can be cleared through the `--cache-clear` command-line parameter,
    and all caches can be shown through `--cache-show`. Internally, the `cache` fixture
    uses the `json` module to encode/decode the values, so anything JSON encodable
    will work.
  prefs: []
  type: TYPE_NORMAL
- en: Custom fixtures
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Bundled fixtures are quite useful, but within most projects, you will want to
    create your own fixtures to make things easier. Fixtures make it trivial to repeat
    code that is needed more often. You are most likely wondering how this is different
    from a regular function, context wrapper, or something else, but the special thing
    about fixtures is that they themselves can accept fixtures as well. So, if your
    function needs the `pytestconfig` variables, it can ask for them without needing
    to modify the calling functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create a fixture out of anything that would be useful to reuse. The
    basic premise is simple enough: a function with the `pytest.fixture` decorator,
    which returns a value that will be passed along as an argument. Also, the function
    can take parameters and fixtures just as any test can.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The only notable variation is `pytest.yield_fixture`. This fixture variation
    has one small difference: the actual test will be executed at the `yield` (more
    than one `yield` results in errors) and the code before/after functions as setup/teardown
    code, which is useful for things like database connections and file handles. A
    basic example of a `fixture` and a `yield_fixture` looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'These fixtures take no parameters and simply pass a parameter to the `py.test`
    functions. A more useful example would be setting up a database connection and
    executing a query in a transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: First we have the `connection()` fixture, which uses the special parameter `params`.
    Instead of using the `:memory:` database in `sqlite3`, we can use a different
    database name or multiple names as well. That is why `params` is a `list`; the
    test will be executed for each value in `params`.
  prefs: []
  type: TYPE_NORMAL
- en: The `transaction()` fixture uses the `connection()` to open the database connection,
    `yield` it to the user of that fixture, and take care of the cleanup after. This
    could easily have been omitted and done in `transation()` immediately, but it
    saves an indentation level and it allows you to further customize the connection
    at a single location if needed.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, the `test_insert()` function uses the `transaction()` fixture to execute
    the queries on the database. It is important to note that if we had passed more
    values to `params`, this test would have been executed for each value.
  prefs: []
  type: TYPE_NORMAL
- en: Print statements and logging
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Even though print statements are generally not the most optimal way to debug
    code, I admit that it is still my default method of debugging. This means that
    when running and trying tests, I will include many print statements. However,
    let’s see what happens when we try this with `py.test`. Here is the testing code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the actual output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: So, all of our print statements and logging got trashed? Well, not really. In
    this case, `py.test` assumed that it wouldn’t be relevant to you, so it ignored
    the output. But what about the same run with an error?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: As we see here, when it’s actually useful, we do get the `stdout` and `stderr`
    output. Additionally, logging with a level of `WARNING` or higher is visible now.
    `DEBUG` and `INFO` still won’t be visible, but we’ll see more about that later
    in this chapter, in the *Logging* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one big caveat to using print statements for debugging, however: since
    they write to `stdout` they can break quickly break your doctests. Because `doctest`
    looks at all generated output, your print statements will be included as expected
    output.'
  prefs: []
  type: TYPE_NORMAL
- en: Plugins
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the most powerful features of `py.test` is the plugin system. Within
    `py.test`, nearly everything can be modified using the available hooks; the result
    of this is that writing plugins is almost simple. Actually, if you’ve been typing
    along, you already wrote a few plugins in the previous paragraphs without realizing
    it. By packaging `conftest.py` in a different package or directory, it becomes
    a `py.test` plugin. We will explain more about packaging in *Chapter 18*, *Packaging
    – Creating Your Own Libraries or Applications*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Generally, it won’t be required to write your own plugin because the odds are
    that the plugins you seek are already available. A small list of plugins can be
    found on the `py.test` website at [https://pytest.org/latest/plugins.html](https://pytest.org/latest/plugins.html),
    an automatically generated list with plugins here: [https://docs.pytest.org/en/latest/reference/plugin_list.html](https://docs.pytest.org/en/latest/reference/plugin_list.html),
    and a longer completely uncurated list (currently over 8,000) can be found through
    the Python Package Index at [https://pypi.org/search/?q=pytest-](https://pypi.org/search/?q=pytest-).'
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, `py.test` does cover quite a bit of the desirable features, so
    you can easily do without plugins, but within the packages that I write myself,
    I generally default to the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pytest-cov`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pytest-flake8`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pytest-mypy`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By using these plugins, it becomes much easier to maintain the code quality
    of your project. In order to understand why, we will take a closer look at these
    packages in the following paragraphs.
  prefs: []
  type: TYPE_NORMAL
- en: pytest-cov
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Using the `pytest-cov` package, you can see whether your code is properly covered
    by tests or not. Internally, it uses the `coverage` package to detect how much
    of the code is being tested.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure you have `pytest-cov` installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: To demonstrate the principle, we will check the coverage of a `cube_root` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, let’s create a `.coveragerc` file with some useful defaults:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Since Linux and Mac systems hide files starting with a `.` (such as `.coveragerc`),
    the filename in the GitHub repository is `_coveragerc`. To use the file, you can
    either choose to copy/rename it, or set the `COVERAGE_RCFILE` environment variable
    to override the filename.
  prefs: []
  type: TYPE_NORMAL
- en: Which defaults are good for your project is of course a personal decision, but
    I find the defaults above quite useful. Be sure to read through these instead
    of blindly copying them, however; perhaps you want to make sure all of your `AssertionErrors`
    are tested instead of silently ignoring them from the coverage output.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the `cube_root.py` code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'And the `T_16_test_cube_root.py` code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s see what happens when we run this with coverage enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'What happened here? It looks like we forgot to test some part of the code:
    line `14` and the branch that goes from line `11` to line `14`. This output isn’t
    all that readable, and that’s why we added `--cov-report=html` to get easily readable
    HTML output in the `htmlcov` directory as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15882_10_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.3: Coverage report generated by --cov-report=html'
  prefs: []
  type: TYPE_NORMAL
- en: Perfect! So now we know – we forgot to test for values smaller than `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The yellow line (line 11) indicates that only one part of the branch was executed
    (`(n >= 0) == True`) and not the other (`(n >= 0) == False`). This occurs with
    `if` statements, loops, and other things where at least one of the branches is
    not covered. For example, if a loop over an empty array is an impossible scenario,
    then the test can be partially skipped using a comment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'But since we know the problem, that is, the missing test for `ValueError`,
    let’s add the test case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we run the test again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Perfect! Now we have 100% test coverage of our function. At least, in theory.
    I can think of several other test cases with different types of values that are
    not covered. So keep in mind that 100% test coverage is still no guarantee for
    bug-free code.
  prefs: []
  type: TYPE_NORMAL
- en: But what if we have a branch that really doesn’t need testing because it is
    intentionally not implemented? If we raise a `NotImplementedError` instead of
    raising a `ValueError` for values below `0`, we also get 100% test coverage without
    adding that test.
  prefs: []
  type: TYPE_NORMAL
- en: This is because we added `raise NotImplementedError` to the ignore list in the
    `.coveragerc` file. Even if we were to test for the `NotImplementedError` in the
    test file, the coverage report would still ignore the line.
  prefs: []
  type: TYPE_NORMAL
- en: pytest-flake8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Code quality testing tools are very useful for making your code readable, consistent,
    and `pep8` compliant. The `pytest-flake8` plugin automatically executes these
    checks before running the actual tests. To install it, simply execute this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: We already installed `pytest-flake8` earlier in this chapter because the default
    configuration for the code in this book depends on it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’ll create some bad code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we can check the code using the `pytest-flake8` plugin by adding
    it to the `pytest.ini`, or by running `py.test` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The output of `pytest-flake8` is, as expected, very similar to the output from
    the `flake8` command that is called internally and combines the `pyflakes` and
    `pep8` commands to test code quality.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on your situation, you might opt for having the code quality tests
    before you commit to the repository, or you could only run it on-demand if code
    quality isn’t that important to you. After all, while code quality considerations
    are important, it does not mean the code does not function without them, and a
    good editor will already notify you of code quality issues while typing.
  prefs: []
  type: TYPE_NORMAL
- en: pytest-mypy
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `pytest-mypy` plugin runs the `mypy` static type checker, which uses the
    type hints to check if the input and output are as expected. First, we need to
    install it using `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'When we apply this to our `cube_root.py` file, we can already see a possible
    error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: As opposed to the `cube.py` file, which will return an `int` when given an `int`,
    the cube root of a number does not have to be an integer when an integer is passed.
    While the cube root of `8` is `2`, the cube root of `4` returns a floating-point
    number of approximately `1.587`.
  prefs: []
  type: TYPE_NORMAL
- en: This is an error that is easily overlooked without a tool such as `mypy`.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring plugins
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To make sure that all the plugins get executed and to configure them, simply
    add the settings to the `pytest.ini` file. The following example can be a reasonable
    default for development, but for production releases, you will probably want to
    take care of the `UnusedImport` warnings.
  prefs: []
  type: TYPE_NORMAL
- en: '`pytest.ini`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Using the `addopts` setting in the `pytest.ini`, you can add options to the
    `py.test` command as if you had added them to the command while running.
  prefs: []
  type: TYPE_NORMAL
- en: When debugging to find out why a test is failing, it can be useful to simply
    look at the first test that fails. The `py.test` module offers both a `-x`/`--exitfirst`
    flag to stop after the first failure and `--maxfail=n` to stop after *n* failures.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the `--ff`/`--failed-first` option is useful to run the previously
    failed tests first.
  prefs: []
  type: TYPE_NORMAL
- en: Or you can use the `--lf`/`--last-failed` option to only run previously failed
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a good understanding of the `py.test` possibilities, it is
    time to continue writing tests. Next up is the subject of faking objects using
    `mock`.
  prefs: []
  type: TYPE_NORMAL
- en: Mock objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When writing tests, you will often find that you are not only testing your own
    code, but also the interaction with external resources, such as hardware, databases,
    web hosts, servers, and others. Some of these can be run safely, but certain tests
    are too slow, too dangerous, or even impossible to run. In those cases, mock objects
    are your friends; they can be used to fake anything, so you can be certain that
    your code still returns the expected results without having any variation from
    external factors.
  prefs: []
  type: TYPE_NORMAL
- en: Using unittest.mock
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `unittest.mock` library provides two base objects, `Mock` and `MagicMock`,
    to easily mock any external resources. The `Mock` object is just a general generic
    mock object and `MagicMock` is mostly the same, but it has all the Python magic
    methods such as `__contains__` and `__len__` defined. In addition to this, it
    can make your life even easier. This is because in addition to creating mock objects
    manually, it is possible to patch objects directly using the `patch` decorator/context
    manager.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following function uses `random` to return `True` or `False` with probabilities
    governed by a certain probability distribution. Due to the random nature of a
    function like this, it is notoriously difficult to test, but not with `unittest.mock`.
    With the use of `unittest.mock`, it’s easy to get repeatable results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Wonderful, isn’t it? Without having to modify the original code, we can make
    sure that `random.random()` now returns `0.1` instead of some random number. If
    you have an `if` statement in your code so it only runs 10% of the time (`if random.random()
    < 0.1`), you can now test explicitly what happens in both cases of the `if`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The possibilities with mock objects are nearly endless. They vary from raising
    exceptions on access to faking entire APIs and returning different results on
    multiple calls. For example, let’s fake deleting a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Quite a bit of magic in this example! The `side_effect` parameter tells `mock`
    to return those values in that sequence, making sure that the first call to `os.path.exists`
    returns `True` and the other two return `False`. The `mock.patch` call without
    specific arguments simply returns a callable that does nothing and accepts anything.
  prefs: []
  type: TYPE_NORMAL
- en: Using py.test monkeypatch
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `monkeypatch` object in `py.test` is a fixture that allows mocking as well.
    While it may seem useless after seeing the possibilities with `unittest.mock`,
    in summary, it’s not. Some of the functionality does overlap, but while `unittest.mock`
    focuses on controlling and recording the actions of an object, the `monkeypatch`
    fixture focuses on simple and temporary environmental changes. Some examples of
    these are given in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting and deleting attributes using `monkeypatch.setattr` and `monkeypatch.delattr`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting and deleting dictionary items using `monkeypatch.setitem` and `monkeypatch.delitem`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting and deleting environment variables using `monkeypatch.setenv` and `monkeypatch.delenv`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inserting an extra path to `sys.path` before all others using `monkeypatch.syspath_prepend`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the directory using `monkeypatch.chdir`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To undo all modifications, simply use `monkeypatch.undo`. Naturally, at the
    end of your test function, `monkeypatch.undo()` will be called automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let’s say that for a certain test, we need to work from a different
    directory. With `mock`, your options would be to mock pretty much all file functions,
    including the `os.path` functions, and even in that case, you will probably forget
    about a few. So, it’s definitely not useful in this case. Another option would
    be to put the entire test into a `try...finally` block and just do an `os.chdir`
    before and after the testing code. This is quite a good and safe solution, but
    it’s a bit of extra work, so let’s compare the two methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: They effectively do the same, but one needs a single line of code to temporarily
    change directory whereas the other needs four, or five if you count the `os` import
    as well. All of these can easily be worked around with a few extra lines of code,
    of course, but the simpler the code is, the fewer mistakes you can make and the
    more readable it is.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to fake objects, let’s look at how we can run our tests
    on multiple platforms simultaneously using `tox`.
  prefs: []
  type: TYPE_NORMAL
- en: Testing multiple environments with tox
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have written our tests and are able to run them for our own environment,
    it’s time to make sure that others can easily run the tests too. `tox` can create
    sandboxed environments for all specified Python versions (assuming they are installed)
    and runs them automatically and in parallel if needed. This is especially useful
    to test if your dependency specification is up to date. While you may have a lot
    of packages installed in your local environment, someone else might not have those
    packages.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with tox
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we can do anything, we need to install the `tox` command. A simple pip
    install will suffice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'After the install, we can start by creating a `tox.ini` file to specify what
    we want to run. The easiest way is by using `tox-quickstart`, but if you already
    have a functioning `tox.ini` from a different project you can easily copy and
    modify that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Now we have our first `tox` configuration finished. The `tox-quickstart` command
    has made a `tox.ini` file with a few sane defaults.
  prefs: []
  type: TYPE_NORMAL
- en: When looking at the output of `tox-quickstart`, you might be wondering why newer
    Python versions are not listed. The reason is that the Python versions are hardcoded
    in the `tox-quickstart` command at the time of writing. This issue is expected
    to be solved in the near future but should not be a big issue in either case,
    as the versions can be changed in the `tox.ini` file quite easily.
  prefs: []
  type: TYPE_NORMAL
- en: The tox.ini config file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `tox.ini` file is very basic by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The `tox.ini` file usually consists of two main types of sections, the `tox`
    and `testenv` sections.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `tox` section configures the `tox` command itself and specifies options
    such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '`envlist`: Specifies the default list of environments to run, can be overridden
    by running `tox -e <env>`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`requires`: Specifies which packages (and specific versions) are required alongside
    `tox`. This can be useful for specifying a specific `setuptools` version so your
    package can be installed correctly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`skip_missing_interpreters`: A very useful feature that allows you to test
    all available environments on your system but skip the ones that are not installed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `testenv` section configures your actual environment. Some of the most
    useful options are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`basepython`: The Python executable to run, useful if your Python binary has
    a non-standard name but more commonly useful when using custom environment names.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`commands`: Commands to run when testing, in our case `pytest`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`install_command`: Command to run to install the package, defaults to `python
    -m pip install {opts} {packages}(ARGV)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`allowlist_externals`: Which external commands such as `make`, `rm`, `ls`,
    and `cd` to allow so they can be run from the package or the scripts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`changedir`: Switch to a specific directory before running tests; to the directory
    containing the tests, for example.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`deps`: Which Python packages to install, uses the `pip` command syntax. A
    `requirements.txt` file can be specified through `-rrequirements.txt`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`platform`: Restrict the environment to a specific value of `sys.platform`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setenv`: Set environment variables, very useful to let tests know that they
    are being run from `tox`, for example.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`skipsdist`: With this flag enabled, you can test a regular directory instead
    of only installable Python packages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The most interesting part of the configuration is the `testenv` section prefix.
    While the `testenv` options above can be configured globally for all environments,
    you can use a section such as `[testenv:my_custom_env]` to only apply to your
    custom environment. In those cases, you will need to specify the `basepython`
    option so `tox` knows what to execute.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally to a single environment, you can also expand the pattern to configure
    multiple environments simultaneously with a pattern such as `[testenv:py{27,38}]`
    to specify both the `py27` and `py38` environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Expansions such as `py{27,38}` are also possible for all other options, so
    to specify a whole list of Python environments, you could do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Furthermore, all options in the `tox.ini` also allow for variable interpolation
    based on a whole range of available variables, such as `{envname}`, but also based
    on options from other environments. The next example shows how to copy the `basepython`
    variable from the `py39` environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Naturally, interpolating from environment variables is also possible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'With an optional default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Running tox
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we know some of the basic config options for `tox`, let’s run a simple
    test to illustrate how convenient it can be.
  prefs: []
  type: TYPE_NORMAL
- en: 'First we need to create a `tox.ini` file to configure `tox`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will create a `test.py` file containing the Python 3.9 `dict` merge
    operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when running `tox`, it will show us that this syntax failed on Python 3.8
    and works on Python 3.9 as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: That all looks good – an error for Python 3.8 and a fully working Python 3.9
    run. This is where `tox` is really useful; you can easily test multiple Python
    versions and multiple environments simultaneously, even in parallel if you use
    the `tox -p<processes>` parameter. And best of all, since it creates a completely
    blank Python environment, you are testing your requirements specification as well.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to run our tests on multiple Python environments simultaneously,
    it is time to continue with `logging`, the last section of this chapter. While
    a simple print statement can be very useful in debugging, when working on larger
    or distributed systems it is often not the most convenient option anymore. This
    is where the `logging` module can help you greatly to debug your issues.
  prefs: []
  type: TYPE_NORMAL
- en: Logging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Python `logging` module is one of those modules that are extremely useful,
    but it tends to be very difficult to use correctly. The result is often that people
    just disable logging completely and use `print` statements instead. While it is
    somewhat understandable, this is a waste of the very extensive logging system
    in Python.
  prefs: []
  type: TYPE_NORMAL
- en: The Python `logging` module is largely based on the Java `log4j` library so
    it might be familiar to you if you’ve written Java before. That is also one of
    the biggest problems with the `logging` module in my opinion; Python is not Java
    and the `logging` module feels pretty un-Pythonic because of it. That does not
    make it a bad library, but it takes a little effort to get used to its design.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most important objects of the `logging` module are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Logger**: The actual logging interface'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Handler**: This processes the log statements and outputs them'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Formatter**: This formats the input data into a string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Filter**: This allows filtering of certain messages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Within these objects, you can set the logging levels to one of the default
    levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CRITICAL: 50`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ERROR: 40`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WARNING: 30`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`INFO: 20`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DEBUG: 10`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NOTSET: 0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The numbers are the numeric values of these log levels. While you can generally
    ignore them, the order is obviously important while setting the minimum level.
    Also, when defining custom levels, you will have to overwrite existing levels
    if they have the same numeric value.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are several ways to configure the logging system, ranging from pure code
    to JSON files or even remote configuration. The examples will use parts of the
    `logging` module discussed later in this chapter, but the usage of the config
    system is all that matters here. If you are not interested in the internal workings
    of the `logging` module, you should be able to get by with just this paragraph
    of the *Logging* section.
  prefs: []
  type: TYPE_NORMAL
- en: Basic logging configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The most basic logging configuration is, of course, no configuration, but that
    will not get you much useful output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'With the default log level, you will only see a `WARNING` and up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: A quick and easy start for a configuration is `logging.basicConfig()`. I recommend
    using this if you just need some quick logging for a script you’re writing, but
    not for a full-blown application. While you can configure pretty much anything
    you wish, once you get a more complicated setup, there are usually more convenient
    options. We will talk more about that in later paragraphs, but first, we have
    `logging.basicConfig()`, which creates a `logging.StreamHandler` that is added
    to the root logger and configured to write all output to `sys.stderr` (standard
    error). Note that if the root logger already has handlers, the `logging.basicConfig()`
    function does nothing (unless `force=True`).
  prefs: []
  type: TYPE_NORMAL
- en: If no log handlers are configured for the root logger, the logging functions
    (`debug()`, `info()`, `warning()`, `error()`, and `critical()`) will automatically
    call `logging.basicConfig()` to set up a logger for you. This means that if you
    have a log statement before your `logging.basicConfig()` call, it will be ignored.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate the usage of `basicConfig()` with a few customizations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can test the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'This will give us the following output on our screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is the output in the `debug.log` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: This configuration shows how log outputs can be configured with separate configurations,
    log levels, and, if you choose so, formatting. It tends to become unreadable though,
    which is why it’s usually a better idea to use `basicConfig` only for simple configurations
    that don’t involve multiple handlers.
  prefs: []
  type: TYPE_NORMAL
- en: Dictionary configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`dictConfig` makes it possible to name all parts so that they can be reused
    easily, for example, a single formatter for multiple loggers and handlers. Let’s
    rewrite our previous configuration using `dictConfig`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: You can probably see the similarities with the `logging.basicConfig()` call
    we used earlier. It is merely a different syntax for a `logging` configuration.
  prefs: []
  type: TYPE_NORMAL
- en: The nice thing about the dictionary configuration is that it’s very easy to
    extend and/or overwrite the logging configuration. For example, if you want to
    change the formatter for all of your logging, you can simply change the `standard`
    formatter or even loop through `handlers`.
  prefs: []
  type: TYPE_NORMAL
- en: JSON configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since `dictConfig` takes any type of dictionary, it is actually quite simple
    to implement a different type of reader employing JSON or YAML files. This is
    especially useful as they tend to be a bit friendlier toward non-Python programmers.
    As opposed to Python files, they are easily readable and writable from outside
    of Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s assume that we have a `T_26_logging_json_config.json` file such as the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'We can simply use this code to read the config:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Naturally, you could use any source that can generate a `dict`, but be mindful
    of the source. Since the `logging` module will import the specified class, it
    can be a potential security risk.
  prefs: []
  type: TYPE_NORMAL
- en: ini file configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The file configuration is probably the most readable format for non-programmers.
    It uses the `ini-style` configuration format and uses the `configparser` module
    internally. The downside is that it is perhaps a little verbose, but it is clear
    enough and makes it easy to combine several configuration files without us having
    to worry too much about overwriting other configurations. Having said that, if
    `dictConfig` is an option, then it is most likely a better option. This is because
    `fileConfig` is slightly limited and awkward at times. Just look at the handlers
    as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Reading the files is extremely easy though:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: One thing to make note of, however, is that if you look carefully, you will
    see that this config is slightly different from the other configs. With `fileConfig`
    you can’t just use keyword arguments alone. The args is required for both `FileHandler`
    and `StreamHandler`.
  prefs: []
  type: TYPE_NORMAL
- en: The network configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The network configuration is a rarely used but very convenient way to configure
    your loggers across multiple processes. This type of configuration is quite esoteric
    and if you have no use for such a setup, feel free to skip to the *Logger* section.
  prefs: []
  type: TYPE_NORMAL
- en: The major caveat of the network configuration is that it can be dangerous because
    it allows you to configure your logger on the fly while your application/script
    is still running. The dangerous part is that the config is (partially) read by
    using the `eval` function, which allows people to potentially execute code within
    your application remotely. Even though `logging.config.listen` only listens to
    local connections, it can still be dangerous if you execute the code on a shared/unsafe
    host where others can run code as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your system is unsafe, you can pass `verify` as a callable argument to `listen()`,
    which could implement signature verification or encryption of the configurations
    before they are evaluated. By default, the `verify` function is analogous to `lambda
    config: config`. As the most simple verification method, you could use something
    along these lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'To show the workings of the network configuration, we need two scripts. One
    script will continuously print a few messages to the loggers and the other will
    change the logging configuration. We will start with the same test code that we
    had before, but keep it running in an endless loop with a `sleep` in between:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to run both of the scripts at the same time. First, we start the
    `receive` script, which will start outputting data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'In the meantime, we run the `send` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the logging configuration was updated while the code was still
    running. This can be very useful for long-running scripts that you need to debug
    but don’t want to restart.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the output on the screen, the extra output was sent to the `debug.log`
    file, which looks something like this now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: This allows you to redirect mostly useless debug output to a separate log file
    while still keeping the most important messages on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Logger
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main object that you will be using all the time with the `logging` module
    is the `Logger` object. This object contains all the APIs that you will need to
    do the actual logging. Most are simple enough but some require attention.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, loggers inherit the parent settings by default. As we have seen
    previously, with the `propagate` setting, by default, all settings will propagate
    from the parent. This is really useful when incorporating loggers within your
    files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming your modules are using sane names and import paths, I recommend the
    following style of naming your loggers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'By using this style, your loggers will get names such as `main_module.sub_module.ClassName`.
    Not only does this make your logs easier to read, but also it is easily possible
    to enable or disable logging per module with the propagation of log settings.
    To create a new log file that logs everything from `main_module.sub_module`, we
    can simply do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Alternatively, you can configure it using your chosen configuration option,
    of course. The relevant point is that with sub-loggers, you have very fine-grained
    control over your loggers.
  prefs: []
  type: TYPE_NORMAL
- en: 'This includes increasing the log level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Usage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The usage of the `Logger` object is mostly identical to that of the bare `logging`
    module, but `Logger` actually supports a bit more. This is because the bare `logging`
    module just calls the functions on the root logger. The `Logger` object has a
    few very useful properties, although most of these are undocumented in the library:'
  prefs: []
  type: TYPE_NORMAL
- en: '`propagate`: Whether to pass events to this logger or to the handlers of the
    parent loggers. Without this, a log message to `main_module.sub_module` won’t
    be logged by `main_module`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `handle` method will keep looking for parent handlers as long as those loggers
    have `propagate` set to `true`, which is the default.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`filters`: These are the filters attached to the logger. They can be set through
    `addFilter` and `removeFilter`. To see whether a message will be filtered, the
    `filter` method can be used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`disabled`: By setting this property, it’s possible to disable a certain logger.
    The regular API only allows the disabling of all loggers below a certain level.
    This offers some fine-grained control.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`handlers`: These are the handlers attached to the logger. They can be added
    through `addHandler` and `removeHandler`. The existence of any (inherited) handlers
    can be checked through the `hasHandlers` function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`level`: This is really an internal one as it simply has a numeric value and
    not a name. But beyond that, it doesn’t take inheritance into account, so it’s
    better to avoid the property and use the `getEffectiveLevel` function instead.
    To check whether the setting is enabled for a `DEBUG`, for example, you can simply
    do `logger.isEnabledFor(logging.DEBUG)`. Setting the property is possible through
    the `setLevel` function, of course.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name`: As this property’s name suggests, it is very useful for your own reference,
    of course.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that you know about the properties, it is time to discuss the logging functions
    themselves. The functions you will use most often are the `log`, `debug`, `info`,
    `warning`, `error`, and `critical` log functions. They can be used quite simply,
    but they support string formatting as well, which is very useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: Formatting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When seeing the previous examples, you might wonder why we use `logger.error(''error:
    %r'', error)` instead of regular string formatting with f-strings, `%`, or `string.format`
    instead. The reason is that when parameters are used instead of preformatted strings,
    the handler gets them as parameters. The result is that you can group log messages
    by the original string, which is what tools such as Sentry ([https://github.com/getsentry/sentry](https://github.com/getsentry/sentry))
    use.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is more to it, however. In terms of parameters, `*args` are only for
    string formatting, but it’s possible to add extra parameters to a log object using
    the `extra` keyword parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'These `extra` parameters can be used in the logging formatter to display extra
    information just like the standard formatting options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'However, one of the most useful features is the support for exceptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in a stack trace for the exception, but it will not kill the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Modern formatting using f-strings and str.format
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Python `logging` module is still largely based on the “old” formatting syntax
    and doesn’t have much support for `str.format`. For the `Formatter` itself, you
    can easily use the new style formatting, but that’s ultimately mostly useless
    since you rarely modify the `Formatter` and mainly need formatting when logging
    messages instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Regardless, the syntax is simple enough to enable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'Which results in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'For actual messages requiring formatting, we need to implement something ourselves,
    however. A logging adapter is the easiest solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'When executing the code, this results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: The solution still doesn’t look that pretty in my opinion, but it works. Because
    the formatting of log messages cannot be overridden easily in the `logging` module,
    we have created a separate `FormattingMessage` that formats itself whenever `str(message)`
    is called. This way we can override the formatting using a simple `logging.LoggerAdapter`
    without having to replace large portions of the `logging` library.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that if you want to send the value of `kwargs` to a logger such
    as Sentry, you will need to make sure the order of operations is correct, since
    this method cannot pass the `kwargs` along or the standard log formatter would
    complain.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, you might be wondering why we used the `FormattingMessage` instead
    of running `msg.format(**kwargs)` in the `process()` method. The reason is that
    we want to avoid string formatting for as long as possible.
  prefs: []
  type: TYPE_NORMAL
- en: If the logger doesn’t have an active handler or the handler ignores messages
    of this level, it means we would have done useless work. Depending on the implementation,
    string formatting can be a very heavy operation and the `logging` system is meant
    to be as light as possible until enabled.
  prefs: []
  type: TYPE_NORMAL
- en: Logging pitfalls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The logging propagation is one of the most useful features and also the biggest
    problem with the `logging` module. We have already seen how logging settings are
    inherited from parent loggers, but what if you override them? Well, let’s find
    out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run this code, we get this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: In this case it’s obvious that the `a.setLevel(...)` caused the issue, but if
    that happens in some external code that you didn’t know about, you could be searching
    for a long time.
  prefs: []
  type: TYPE_NORMAL
- en: 'And the reverse can also happen; an explicit level on a logger will ignore
    your parent level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'When we execute this, we notice that setting the level is completely ignored:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: Once again, not a problem in this case, but if that happens in some external
    library without your knowledge it can certainly cause a headache.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging loggers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most important rule about loggers is that they inherit the settings from
    the parent loggers unless you override them. If your logging isn’t working as
    you expect it, most of the time it’s caused by some inheritance issue and that
    can be difficult to debug.
  prefs: []
  type: TYPE_NORMAL
- en: 'The logging flow according to the Python manual looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![../_images/logging_flow.png](img/B15882_10_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.4: Logging flow. Copyright © 2001-2021 Python Software Foundation;
    All Rights Reserved'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we know how the logging flow is supposed to go, we can start creating
    a method to show our current logger structure and the settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: The `get_handlers()` function recursively walks through a logger and all of
    its parents to collect all propagated handlers. The `debug_loggers()` function
    walks through the internal config of the `logging` module to list all configured
    loggers and fetch the matching handlers through `get_handlers()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is just a basic debugging function of course, but it can really help you
    when you’re wondering why your logging is not working as expected. The output
    looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: Now we can see that the `a` logger has level `INFO` but only has a handler at
    a `WARNING` level. So, none of our `INFO` messages will show. Similarly, the `a.b`
    logger has a `DEBUG` level but a handler at level `INFO` so it will only show
    `INFO` and higher levels.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have seen several testing and logging options, it’s time to try
    it yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 'A few challenges:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a function that tests the doctests of a given function/class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a greater challenge, create a function that recursively tests all doctests
    of every function and class in a given module.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create a `py.test` plugin that checks if all tested files have file-level documentation.
    Hint: use `pytest_collect_file`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a custom `tox` environment to run `flake8` or `mypy` on your project.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a `LoggerAdapter` that combines multiple messages into a single message
    based on some task ID. This can be useful when debugging long-running tasks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Example answers for these exercises can be found on GitHub: [https://github.com/mastering-python/exercises](Chapter_10.xhtml).
    You are encouraged to submit your own solutions and learn about alternative solutions
    from others.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter showed us how to write doctests, make use of the shortcuts provided
    by `py.test`, and use the `logging` module. With testing, there is never a one-size-fits-all
    solution. While the `doctest` system is very useful in many cases for providing
    both documentation and tests at the same time, in many functions there are edge
    cases that simply don’t matter for documentation but still need to be tested.
    This is where regular unit tests come in and where `py.test` helps a lot.
  prefs: []
  type: TYPE_NORMAL
- en: We have also seen how we can use `tox` to run tests in multiple sandboxed environments.
    If you ever have a project that also has to run on different computers or even
    on different Python versions, I would highly encourage you to use it.
  prefs: []
  type: TYPE_NORMAL
- en: The `logging` module is extremely useful when configured correctly and if your
    project becomes somewhat larger, it quickly becomes useful to do so. The usage
    of the logging system should be clear enough for most of the common use cases
    now, and as long as you keep the `propagate` parameter in check, you should be
    fine when implementing a logging system.
  prefs: []
  type: TYPE_NORMAL
- en: Next up is debugging, where testing helps prevent bugs. We will see how to solve
    them effectively. In addition, the logging that we added in this chapter will
    help a lot in that area.
  prefs: []
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers: [https://discord.gg/QMzJenHuJf](https://discord.gg/QMzJenHuJf)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code156081100001293319171.png)'
  prefs: []
  type: TYPE_IMG
