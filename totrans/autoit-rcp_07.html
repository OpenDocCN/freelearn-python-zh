<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Power of APIs</h1></div></div></div><p>This chapter takes you on a journey to the interesting world of APIs. APIs are a critical part of the business world today. Tasks like querying data, exchanging information across services amongst others rely on web APIs and Webhooks.</p><p>In this chapter, we will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Designing your own REST APIs</li><li class="listitem" style="list-style-type: disc">Automating social media marketing with Twitter APIs</li><li class="listitem" style="list-style-type: disc">An introduction to Webhooks</li><li class="listitem" style="list-style-type: disc">Implementing Webhooks</li><li class="listitem" style="list-style-type: disc">Automating lead management with Webhooks</li></ul></div><div><div><div><div><h1 class="title"><a id="ch07lvl1sec61"/>Introduction</h1></div></div></div><p>APIs have become absolutely indispensable in the world driven by the Internet. Every web application that you must have interacted with uses an API on the backend to implement its core functionality--Amazon, Google, Twitter, you name it! What's more, you see all these applications thrive on APIs. Amazon uses it to drive its payment transactions and Google for showing you all the fancy maps. APIs are so essential to business that you hear the word API right from CEOs to managers, all the way to software developers. In general, using an API is a fundamental way of enabling different software to talk to each other. Operating system operations are also performed with APIs. They have been absolutely critical from the very beginning of computing.</p><p>But what are APIs and how are they useful? How to develop APIs of our own? How do they find their way into business process automation? We'll find answers to all these questions in this chapter.</p><p>We start with a more familiar and older web term: web service. Web services are essentially the key points of integration between different applications hosted across platforms and built on different languages using independent systems. Web services communicate with each other via WWW and typically involve two parties: one that exposes a set of APIs, also known as the server, and another that calls or consumes the server APIs, also known as consumers or clients. Web services are independent of the client implementation and thus work well with browsers, mobile phones, or just any software that can make an API call.</p><p>They use different protocols for communication, with different messaging and URI contracts. The most common implementations of web services are:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">HTTP-based <strong>REST</strong> (<strong>Representation State Transfer</strong>) web service</li><li class="listitem" style="list-style-type: disc">SOAP-based (<strong>Simple Object Access Protocol</strong>) web service</li><li class="listitem" style="list-style-type: disc">XML <strong>RPC</strong> (<strong>Remote Procedure Call</strong>)</li></ul></div><p>Messaging formats that have been commonly used for these services are:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>JSON</strong> (<strong>JavaScript Object Notation</strong>)</li><li class="listitem" style="list-style-type: disc"><strong>XML</strong> (<strong>eXtensible Markup Language</strong>)</li></ul></div><p>Web services are at the very core of web applications today and hence need to provide good performance; they need to be scalable and reliable.</p><p>Right, so in this chapter, we'll cover HTTP-based REST APIs. You'll understand how to develop RESTful web services with Python in detail. You'll also learn how clients automate their business processes using RESTful web services.</p><div><div><h3 class="title"><a id="note20"/>Note</h3><p>Note that there are different terminologies available for referring to APIs, for example, the HTTP API, Web API, and so on. I suggest you read about them for better clarity. However, essentially, at their core APIs are integration points between two services in an application or between multiple servers/services across applications.</p></div></div><p>In this chapter, we'll look at multiple Python modules, mentioned in the following list:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">flask</code> (<a class="ulink" href="http://flask.pocoo.org/">http://flask.pocoo.org/</a>)</li><li class="listitem" style="list-style-type: disc"><code class="literal">twython</code> (<a class="ulink" href="https://twython.readthedocs.io/en/latest/">https://twython.readthedocs.io/en/latest/</a>)</li><li class="listitem" style="list-style-type: disc"><code class="literal">pytz</code> (<a class="ulink" href="https://pypi.python.org/pypi/pytz">https://pypi.python.org/pypi/pytz</a>)</li><li class="listitem" style="list-style-type: disc"><code class="literal">django</code> (<a class="ulink" href="https://www.djangoproject.com/">https://www.djangoproject.com/</a>)</li><li class="listitem" style="list-style-type: disc"><code class="literal">django-rest-hooks</code> (<a class="ulink" href="https://github.com/zapier/django-rest-hooks">https://github.com/zapier/django-rest-hooks</a>)</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec62"/>Designing your own REST APIs</h1></div></div></div><p>
<strong>Representational State Transfer</strong> (<strong>REST</strong>) has gained lot of preference and popularity in the community and is virtually the default architectural style for designing and implementing RESTful web services.</p><div><div><h3 class="title"><a id="note21"/>Note</h3><p>Note that there are other possible implementations of web services for which you can follow the SOAP and XML-RPC way, these are not within the scope of this chapter.</p></div></div><p>In this recipe, we'll learn how to implement a simple RESTful web service using the Python flask micro framework. We'll implement a user service for user management, which is an imperative aspect of any web application.</p><p>The REST architecture is designed to fit with the HTTP protocol and has the notion of resources, that is, <strong>Uniform Resource Identifiers</strong> (<strong>URIs</strong>). Clients send requests to these URIs with different HTTP request methods and get back the state of the affected resources as a response.</p><p>So what are we waiting for? Let's design and implement the user web service.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec178"/>How to do it...</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Let's begin by defining our model--<strong>user</strong>. Our user resource would be typically identified by these attributes:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">id</code>: A unique ID to identify the user</li><li class="listitem" style="list-style-type: disc"><code class="literal">username</code>: The name of the user used in the application</li><li class="listitem" style="list-style-type: disc"><code class="literal">email</code>: The e-mail address of the user for e-mail notifications</li><li class="listitem" style="list-style-type: disc"><code class="literal">status</code>: To check whether the user is active or verified</li></ul></div></li><li class="listitem">Designing REST APIs involves identifying resources (URIs) and verbs (HTTP methods) that take action on the user model. We need to perform actions such as creating a new user, updating certain attributes of the user, getting a user or list of users, or if needed deleting a user. We also need to relate our actions to HTTP verbs and have to define CRUD operations for our service. <strong>CRUD</strong> means performing the <strong>Create, Read, Update, and Delete</strong> operations on a user model. The following table shows exactly what we need:<div><table border="1"><colgroup><col/><col/><col/></colgroup><tbody><tr><td>
<p>
<strong>URI</strong>
</p>
</td><td>
<p>
<strong>Method</strong>
</p>
</td><td>
<p>
<strong>Action</strong>
</p>
</td></tr><tr><td>
<p>
<code class="literal">http://v1/users/</code>
</p>
</td><td>
<p>
<code class="literal">GET</code>
</p>
</td><td>
<p>To get a list of available users</p>
</td></tr><tr><td>
<p>
<code class="literal">http://v1/users/</code>
</p>
</td><td>
<p>
<code class="literal">POST</code>
</p>
</td><td>
<p>To create a new user</p>
</td></tr><tr><td>
<p>
<code class="literal">http://v1/users/1/</code>
</p>
</td><td>
<p>
<code class="literal">GET</code>
</p>
</td><td>
<p>To get details of an existing user with ID equal to 1</p>
</td></tr><tr><td>
<p>
<code class="literal">http:///v1/users/1/</code>
</p>
</td><td>
<p>
<code class="literal">PUT</code>/<code class="literal">DELETE</code>
</p>
</td><td>
<p>To update or remove the user with ID equal to 1</p>
</td></tr></tbody></table></div></li><li class="listitem">Now let's write the code to implement the RESTful user service. We start by creating a virtual environment. I hope we all know about <code class="literal">virtualenv</code>, but for beginners virtual environment is a tool that isolates Python modules. This helps in resolving issues related to permissions; it also helps to avoid polluting the global Python installation and to manage versions of the same module used across applications. If you don't have <code class="literal">virtualenv</code> on your system, you can install it using Python <code class="literal">pip</code> or download it from <a class="ulink" href="https://pypi.python.org/pypi/virtualenv">https://pypi.python.org/pypi/virtualenv</a>.<pre class="programlisting">
<strong>        chetans-MacBookPro:ch07 Chetan$ pip install virtualenv &#13;
 &#13;
        chetans-MacBookPro:ch07 Chetan$ virtualenv user &#13;
        New python executable in user/bin/python2.7 &#13;
        Also creating executable in user/bin/python &#13;
        Installing setuptools, pip, wheel...done. &#13;
</strong>
</pre></li><li class="listitem">Once we have <code class="literal">virtualenv</code> installed, we need to activate it using a simple command. As you can see in the second line in the following, the <code class="literal">virtualenv</code> user has been activated:<pre class="programlisting">
<strong>        chetans-MacBookPro:ch07 Chetan$ source user/bin/activate &#13;
         (user)chetans-MacBookPro:ch07 Chetan$ &#13;
</strong>
</pre></li><li class="listitem">Let's go ahead and install <code class="literal">flask</code> in our virtual environment. We do this with the help of Python <code class="literal">pip</code> using the <code class="literal">pip install flask</code> command:<pre class="programlisting">
<strong>        (user)chetans-MacBookPro:ch07 Chetan$ pip install flask &#13;
        Collecting flask &#13;
          Using cached Flask-0.11.1-py2.py3-none-any.whl &#13;
        Collecting click&gt;=2.0 (from flask) &#13;
          Using cached click-6.6.tar.gz &#13;
        Collecting its dangerous&gt;=0.21 (from flask) &#13;
        Collecting Werkzeug&gt;=0.7 (from flask) &#13;
          Using cached Werkzeug-0.11.10-py2.py3-none-any.whl &#13;
        Collecting Jinja2&gt;=2.4 (from flask) &#13;
          Using cached Jinja2-2.8-py2.py3-none-any.whl &#13;
        Collecting MarkupSafe (from Jinja2&gt;=2.4-&gt;flask) &#13;
        Building wheels for collected packages: click &#13;
          Running setup.py bdist_wheel for click &#13;
          Stored in directory: /Users/chetan/Library/ &#13;
          Caches/pip/wheels/b0/6d/8c/ &#13;
          cf5ca1146e48bc7914748bfb1dbf3a40a440b8b4f4f0d952dd &#13;
        Successfully built click &#13;
        Installing collected packages: click, itsdangerous,  &#13;
          Werkzeug, MarkupSafe, Jinja2, flask &#13;
        Successfully installed Jinja2-2.8 MarkupSafe-0.23  &#13;
          Werkzeug-0.11.10 click-6.6 flask-0.11.1  &#13;
          itsdangerous-0.24 &#13;
</strong>
</pre></li><li class="listitem">If you look at the installation logs, we seem to have installed <code class="literal">flask</code> along with the template engines <code class="literal">Jinja2</code> and <code class="literal">Werkzeug</code>, a WSGI utility that supports multiple operations, such as cookie handling, file uploads, and request/response objects.</li><li class="listitem">Okay good! We have <code class="literal">flask</code> installed and the environment is nicely set up. Let's write a minimalistic web application and name it <code class="literal">app.py</code>. The code for our web service looks like this:<pre class="programlisting">        from flask import Flask &#13;
        app = Flask(__name__) &#13;
 &#13;
        @app.route('/') &#13;
  &#13;
        def index(): &#13;
            return "Hello, Python!" &#13;
 &#13;
        if __name__ == '__main__': &#13;
            app.run(debug=True) &#13;
</pre></li><li class="listitem">If you run the app, you will see the Flask server running on port 5000:<pre class="programlisting">        (user)chetans-MacBookPro:ch07 Chetan$ python app.py  &#13;
         * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit) &#13;
         * Restarting with stat &#13;
         * Debugger is active! &#13;
         * Debugger pin code: 272-029-183 &#13;
</pre></li><li class="listitem">If you try to access the server on port 5000, you will see what we intended:<p>
</p><div><img alt="How to do it..." src="img/image_08_001.jpg"/></div><p>
</p></li><li class="listitem">Great! Now let's improve on this to implement the user REST APIs. We first implement HTTP's <code class="literal">GET</code> on the <code class="literal">/v1/users/</code> resource. In the following code, we implement a <code class="literal">flask</code> route with the <code class="literal">get_users()</code> API to return all the users in JSON format:<pre class="programlisting">        from flask import Flask, jsonify &#13;
        app = Flask(__name__) &#13;
 &#13;
        users = [ &#13;
            { &#13;
                'id': 1, &#13;
                'username': u'cjgiridhar', &#13;
                'email': u'abc@xyz.com', &#13;
                'active': True &#13;
            }, &#13;
            { &#13;
                'id': 2, &#13;
                'username': u'python', &#13;
                'email': u'py@py.org', &#13;
                'active': False &#13;
            } &#13;
        ] &#13;
 &#13;
        @app.route('/v1/users/', methods=['GET']) &#13;
        def get_users(): &#13;
            return jsonify({'users': users}) &#13;
 &#13;
        if __name__ == '__main__': &#13;
            app.run(debug=True) &#13;
</pre></li><li class="listitem">If we rerun the app (if you're using an editor such as PyCharm, it will itself reload the app for you every time you save your code), our <code class="literal">flask</code> route gets loaded; we can now make an HTTP <code class="literal">GET</code> request on the <code class="literal">/v1/users/</code> API. The output of the request will yield the response, as seen in the next screenshot. Hey, cool! We wrote our first resource for the RESTful user service.</li><li class="listitem">Notice the header section of the response:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Content-Type</code> is application/JSON (we'll talk about message formats later in the chapter)</li><li class="listitem" style="list-style-type: disc">Server is Werkzeug on which Flask is based</li><li class="listitem" style="list-style-type: disc">Date refers to when the server responded to the request</li><li class="listitem" style="list-style-type: disc">The response body has the following:</li><li class="listitem" style="list-style-type: disc">An output with the users key containing information for all the users</li><li class="listitem" style="list-style-type: disc">Information about a user consists of desired attributes such as ID, username, e-mail, and account status</li></ul></div><p>The response format is JSON, as indicated in the headers</p><div><div><h3 class="title"><a id="note22"/>Note</h3><p>Note that we use the RESTED plugin of Firefox to make these requests.</p></div></div><p>
</p><div><img alt="How to do it..." src="img/image_08_002.jpg"/></div><p>
</p></li><li class="listitem">Nice! We have the first URI implemented as part of user service. Now let's quickly go ahead and implement the next resource. Here, we need to get the user based on the ID. The following <code class="literal">flask</code> route will do the job for us:<pre class="programlisting">        @app.errorhandler(404) &#13;
        def not_found(error): &#13;
            return make_response(jsonify({'error': 'Not found'}), 404) &#13;
 &#13;
        @app.route('/v1/users/&lt;int:id&gt;/', methods=['GET']) &#13;
        def get_user(id): &#13;
            for user in users: &#13;
                if user.get("id") == id: &#13;
                    return jsonify({'users': user}) &#13;
            abort(404) &#13;
</pre></li><li class="listitem">In the preceding code, we defined a <code class="literal">flask</code> route with the API <code class="literal">get_user(id)</code>, which takes the user ID as an argument. When we make an HTTP <code class="literal">GET</code> request on this URI, the <code class="literal">get_user()</code> API gets invoked; it internally looks up all the available users to locate the user with the desired ID. If the user is found, the user record is returned in JSON format; if not, the server sends an HTTP 404 response. Here's a screenshot illustrating this:<p>
</p><div><img alt="How to do it..." src="img/image_08_003.jpg"/></div><p>
</p></li><li class="listitem">You want users to sign up on your web application, right? So let's write a <code class="literal">flask</code> route that will help create a new user. The following code performs this operation:<pre class="programlisting">        @app.route('/v1/users/', methods=['POST']) &#13;
        def create_user(): &#13;
            if not request.json or not 'email' in request.json: &#13;
                abort(404) &#13;
            user_id = users[-1].get("id") + 1 &#13;
            username = request.json.get('username') &#13;
            email = request.json.get('email') &#13;
            status = False &#13;
            user = {"id": user_id, "email": email, &#13;
                    "username": username, "active": status} &#13;
            users.append(user) &#13;
            return jsonify({'user':user}), 201 &#13;
</pre></li><li class="listitem">Now if you make an HTTP <code class="literal">POST</code> request on the <code class="literal">/v1/users/</code> resource and pass user information to the body, you'll be able to create a new user. By default, the status of the user will be inactive (<code class="literal">'active': False</code>); you can make it <code class="literal">'active': False</code> when the user verifies her/his e-mail address:<p>
</p><div><img alt="How to do it..." src="img/B05370_08_56.jpg"/></div><p>
</p></li><li class="listitem">OK! Now let's quickly look at the REST APIs that will edit the user details and delete the user if needed. The following flask route will edit the user details:<pre class="programlisting">        @app.route('/v1/users/&lt;int:id&gt;/', methods=['PUT']) &#13;
        def update_user(id): &#13;
            user = [user for user in users if user['id'] == id] &#13;
            user[0]['username'] = request.json.get( &#13;
                    'username', user[0]['username']) &#13;
            user[0]['email'] = request.json.get( &#13;
        'email', user[0]['email']) &#13;
            user[0]['active'] = request.json.get( &#13;
        'active', user[0]['active']) &#13;
            return jsonify({'users': user[0]}) &#13;
</pre></li><li class="listitem">Now if we perform the HTTP <code class="literal">PUT</code> operation on the <code class="literal">/v1/users/:id/</code> resource with the changed data, we should be able to update the user information. In the following screenshot, the request body contains the new e-mail address that needs to be updated for user ID equal to <code class="literal">1</code>. When we make an HTTP <code class="literal">PUT</code> request, the information gets updated and we have the new e-mail address for the user:<p>
</p><div><img alt="How to do it..." src="img/B05370_08_78.jpg"/></div><p>
</p></li><li class="listitem">The only operation pending now is to implement the <code class="literal">DELETE</code> operation. We can use this operation to delete a user. But you might ask, "Why would I delete the user?" So you can have your own implementation of <code class="literal">DELETE</code>; possibly, you can make the user inactive (by setting the <code class="literal">active</code> attribute to <code class="literal">False</code>). But for the sake of this discussion, let's delete the user for the heck of it.</li><li class="listitem">The following code deletes the user based on the user ID:<pre class="programlisting">        @app.route('/v1/users/&lt;int:id&gt;/', methods=['DELETE']) &#13;
        def delete_user(id): &#13;
            user = [user for user in users if user['id'] == id] &#13;
            users.remove(user[0]) &#13;
            return jsonify({}), 204 &#13;
</pre></li><li class="listitem">The <code class="literal">DELETE</code> operation typically returns the status code <strong>204 NO CONTENT</strong>, which is shown in the following screenshot:<p>
</p><div><img alt="How to do it..." src="img/image_08_008.jpg"/></div><p>
</p></li><li class="listitem">Cool! So we have our RESTful user service completely implemented and up-and-running. Great!</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec179"/>How it works...</h2></div></div></div><p>REST is an architectural style of the WWW. It consists of a coordinated set of components where the focus is on component roles and interactions between data elements rather than the implementation. Its purpose is to make the Web more scalable, portable, and reliable, and improve performance.</p><p>The REST architecture works according to the following constraints:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Client-server</strong>: A <strong>Uniform Resource Locator</strong> (<strong>URL</strong>) separates the REST API from the client. Servers are not concerned about the user interface or the state; as a result, REST APIs are more scalable.</li><li class="listitem" style="list-style-type: disc"><strong>Stateless</strong>: This means every request is independent and has no connection to the previous request or client. The client must contain all the necessary information to complete the request, and the session state remains with the client and hence is not stored on the server.</li><li class="listitem" style="list-style-type: disc"><strong>Cacheable</strong>: RESTful web service can cache or not cache responses. Services must let the clients know whether the response is cached. This helps improve the performance of the system as some requests may no longer be needed based on the cache expiry time.</li><li class="listitem" style="list-style-type: disc"><strong>Layered system</strong>: A client may or may not directly interact with the server; they can always have intermediary servers such as caches or load balancers.</li><li class="listitem" style="list-style-type: disc"><strong>Uniform resource</strong>: Each REST resource should be independent; this allows you to have a separation of concerns, and it decouples the architecture.</li><li class="listitem" style="list-style-type: disc"><strong>Code on demand</strong>: The server can provide code for clients to execute in their context. This is an optional requirement though.</li></ul></div><p>The <code class="literal">GET</code> and <code class="literal">HEAD</code> methods are examples of safe methods as they don't change the state of the resource. The <code class="literal">PUT</code>/<code class="literal">DELETE</code> methods are idempotent. This means clients can make multiple similar calls to the resource and the resource will behave in the exact same way; of course, the response itself will have been changed as well.</p><p>Cool! So now we're in a position to create our own RESTful APIs. We can now host these on the Internet for our customers to use or implement functionalities in our web applications. Nice work!</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec180"/>There's more...</h2></div></div></div><p>We looked at the fundamentals of the REST architecture and learned how to design a RESTful web service. We were helped by the Flask micro framework and learned how to write our own REST APIs.</p><p>In the next recipe, we'll see how the clients, due to their needs, consume REST APIs. We will also learn about using REST APIs to automate business processes.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec63"/>Automating social media marketing with Twitter APIs</h1></div></div></div><p>Joy is a marketing manager of a world-known consumer brand. She handles the content marketing portfolio of the company and heavily relies on blogs and social media to showcase the company's product line and create a buzz in the market.</p><p>Without doubt, she has a few problems! Some of the products that she markets have been designed differently for different markets, so she has to work across time zones to make sure her content gets published at the right time. She also feels the need to repeat her posts just to make sure she reaches the majority of her customers; this would also help in improving brand recognition.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec181"/>Getting ready</h2></div></div></div><p>If you carefully analyze her situation, Joy has two issues. One, she has to ensure her social media content is posted at the right time, based on her customer market. So if her product is being sold in Australia, she needs to make sure that her tweets are posted as per the Australian time when her customers are most likely to view them. Second, to get more traction for her product announcements, such as a weekend offer, she may want to repeat a few tweets at a later point in time.</p><p>OK! Now that we understand her problem, let's try to devise a solution. Looks like we need to take care of the following points:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We should provide her with the capability of posting tweets in an automated fashion</li><li class="listitem" style="list-style-type: disc">Her tweets should go at a desired time, even if Joy is asleep</li><li class="listitem" style="list-style-type: disc">We should also provide the capability of scheduling repeat tweets</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec182"/>How to do it...</h2></div></div></div><p>REST APIs to the rescue! Twitter has a fabulous set of REST APIs that can be used by the users for playing with Twitter data, user information, and of course posting tweets. You can also perform multiple operations such as uploading images, querying timelines, and sending direct messages. Wow! That's cool! But lets not get distracted and instead move on to the problem at hand:</p><div><ol class="orderedlist arabic"><li class="listitem">First, let's see how we can post tweets using Python even without logging in to Twitter. To post tweets, we will use a Python library called <code class="literal">twython</code>. So let's install <code class="literal">twython</code> using our friend, the Python <code class="literal">pip</code>:<pre class="programlisting">
<strong>        (user)chetans-MacBookPro:ch07 Chetan$ pip install twython &#13;
        Collecting twython &#13;
          Downloading twython-3.4.0.tar.gz &#13;
        Collecting requests&gt;=2.1.0 (from twython) &#13;
          Downloading requests-2.11.1-py2.py3-none-any.whl (514kB) &#13;
            100% |████████████████████████████████| 516kB 495kB/s  &#13;
        Collecting requests-oauthlib&gt;=0.4.0 (from twython) &#13;
          Downloading requests_oauthlib-0.6.2-py2.py3-none-any.whl &#13;
        Collecting oauthlib&gt;=0.6.2 (from requests-oauthlib&gt;=0.4.0-&#13;
        &gt;twython) &#13;
          Downloading oauthlib-1.1.2.tar.gz (111kB) &#13;
            100% |████████████████████████████████| 114kB 80kB/s  &#13;
        Building wheels for collected packages: twython, oauthlib &#13;
          Running setup.py bdist_wheel for twython &#13;
          Stored in directory: /Users/chetan/Library/Caches/pip/ &#13;
          wheels/48/e9/f5/a4c968725948c73f71df51a3c6 &#13;
          759425358c1eda2dcf2031f4 &#13;
          Running setup.py bdist_wheel for oauthlib &#13;
          Stored in directory: /Users/chetan/Library/Caches/pip/ &#13;
          wheels/e6/be/43/e4a2ca8cb9c78fbd9b5b14b9 &#13;
          6cb7a5cc43f36bc11af5dfac5b &#13;
        Successfully built twython oauthlib &#13;
        Installing collected packages: requests, oauthlib,  &#13;
                               requests-oauthlib, twython &#13;
        Successfully installed oauthlib-1.1.2  &#13;
          requests-2.11.1 requests-oauthlib-0.6.2 twython-3.4.0 &#13;
         (user)chetans-MacBookPro:ch07 Chetan$  &#13;
</strong>
</pre></li><li class="listitem">But before we can start playing with our Twitter account, we'd need to register an app with Twitter. This makes sure that Twitter is aware of our API calls and considers them legitimate. We can register an app by navigating to <a class="ulink" href="https://apps.twitter.com/">https://apps.twitter.com/</a> and clicking on <strong>Create New App</strong>. You can fill in the details as shown in the following screenshot and create your app.<p>Please note a few things about the details you need to fill in:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The application name is unique across all the users on Twitter, so try to make it really unique to you, but at the same time keep it simple</li><li class="listitem" style="list-style-type: disc">Make a description that exactly defines your use case so you remember it later</li><li class="listitem" style="list-style-type: disc">Fill in your website name; keep it short</li><li class="listitem" style="list-style-type: disc">A callback URL is only needed if you want Twitter to send data to you about your authentication, which is not needed for this exercise</li></ul></div><p>
</p><div><img alt="How to do it..." src="img/image_08_009.jpg"/></div><p>
</p></li><li class="listitem">You also need to get your App Key and App Secret, and for that you need OAuth Token and OAuth Token Secret. These are needed essentially to authenticate your API calls with Twitter, or else Twitter will reject your REST API calls as malicious. You will get these details by clicking on your newly created app and browsing to the <strong>Keys and Access Tokens</strong> tab at the top of your page. You can also navigate to <code class="literal">https://apps.twitter.com/app/&lt;app_id&gt;/keys/</code> to get these details:<p>
</p><div><img alt="How to do it..." src="img/image_08_010.jpg"/></div><p>
</p></li><li class="listitem">OK! Let's write some of the code and check whether we're good to work with Twitter's REST APIs. The following code makes a call to the Twitter timeline REST API and pulls the details of the topmost tweet on your timeline. Here we perform an HTTP <code class="literal">GET</code> operation on the <a class="ulink" href="https://dev.twitter.com/rest/reference/get/statuses/home_timeline">https://dev.twitter.com/rest/reference/get/statuses/home_timeline </a>REST API:<pre class="programlisting">        from twython import Twython &#13;
 &#13;
        APP_KEY = '' &#13;
        APP_SECRET = '' &#13;
        OAUTH_TOKEN ='' &#13;
        OAUTH_TOKEN_SECRET = '' &#13;
        twitter = Twython(APP_KEY, APP_SECRET, &#13;
                          OAUTH_TOKEN, OAUTH_TOKEN_SECRET) &#13;
 &#13;
        tweet = twitter.get_home_timeline()[1] &#13;
        print "Tweet text: ", tweet["text"] &#13;
        print "Tweet created at: ", tweet["created_at"] &#13;
        print "Tweeted by: ",  &#13;
        tweet["entities"]["user_mentions"][0]["name"] &#13;
        print "Re Tweeted?: ", tweet["retweet_count"] &#13;
</pre><p>The output of the preceding code snippet is as follows:</p><p>
</p><div><img alt="How to do it..." src="img/image_08_011.jpg"/></div><p>
</p><p>That's cool! We get all the essential details from the post on our timeline. Looks like we're all set then with respect to the Twitter App and Keys.</p></li><li class="listitem">Now let's try to tweet with the status's REST API by posting data to it. The REST API used here is <a class="ulink" href="https://dev.twitter.com/rest/reference/post/statuses/update">https://dev.twitter.com/rest/reference/post/statuses/update</a>. The following Python code will make a <code class="literal">POST</code> request on this REST resource and create a tweet on behalf of my account on Twitter:<pre class="programlisting">        from twython import Twython &#13;
 &#13;
        APP_KEY = '' &#13;
        APP_SECRET = '' &#13;
        OAUTH_TOKEN ='' &#13;
        OAUTH_TOKEN_SECRET = '' &#13;
        twitter = Twython(APP_KEY, APP_SECRET, &#13;
                          OAUTH_TOKEN, OAUTH_TOKEN_SECRET) &#13;
        twitter.update_status(status='Python import antigravity&#13;
        https://xkcd.com/353/') &#13;
</pre><p>After running the preceding code, I looked at Twitter, and voilà! I had a tweet under my name in an automated manner. Here's a screenshot of the tweet:</p><p>
</p><div><img alt="How to do it..." src="img/image_08_012.jpg"/></div><p>
</p><p>So we have solved the first problem for Joy. The tweet can be posted on her behalf even when she is unavailable or can't log in to the Internet, and this can be done using the preceding Python code snippet. But she can't schedule her tweet as per the Australian time zone yet. Hmm, let's look at resolving the scheduling problem now.</p></li><li class="listitem">Before we look at how to schedule tweets, we will install a module that will be very useful for the next recipe. We will install <code class="literal">pytz</code>. It helps us work with time zones and will be helpful in solving Joy's problem:<pre class="programlisting">
<strong>        (user)chetans-MacBookPro:ch07 Chetan$ pip install pytz &#13;
        Collecting pytz &#13;
          Using cached pytz-2016.6.1-py2.py3-none-any.whl &#13;
        Installing collected packages: pytz &#13;
        Successfully installed pytz-2016.6.1 &#13;
</strong>
</pre></li><li class="listitem">To solve the scheduling problem, we need two things. First, we need a configuration that can be used to decide the content, time, and time zone of the tweet. Second, we need a runner program that will use this configuration to post a tweet on Twitter. Now let's look at the following code, which does exactly what we need:<pre class="programlisting">        scheduled_tweets.py &#13;
 &#13;
        from twython import Twython &#13;
 &#13;
        APP_KEY = '' &#13;
        APP_SECRET = '' &#13;
        OAUTH_TOKEN ='' &#13;
        OAUTH_TOKEN_SECRET = '' &#13;
        twitter = Twython(APP_KEY, APP_SECRET, &#13;
                  OAUTH_TOKEN, OAUTH_TOKEN_SECRET) &#13;
 &#13;
        from datetime import datetime &#13;
        import pytz, time &#13;
        from pytz import timezone &#13;
        import tweet_config as config &#13;
 &#13;
        while True: &#13;
 &#13;
            for msg in config.scheduled_messages: &#13;
                print msg["timezone"] &#13;
                tz = timezone(msg["timezone"]) &#13;
                utc = pytz.utc &#13;
                utc_dt = datetime.utcnow().replace(tzinfo=utc) &#13;
                au_dt = utc_dt.astimezone(tz) &#13;
                sday = au_dt.strftime('%Y-%m-%d') &#13;
                stime = au_dt.strftime('%H:%M') &#13;
                print "Current Day:Time", sday, stime &#13;
 &#13;
                if sday == msg["day"]: &#13;
                    if stime == msg["time"]: &#13;
                        print "Time", stime &#13;
                        print "Content", msg["content"] &#13;
                        twitter.update_status(status='%s' %&#13;
                        msg["content"] ) &#13;
 &#13;
 &#13;
            print "Running.. Will try in another min" &#13;
            time.sleep(60) &#13;
            tweet_config.py&#13;
        offers_sydney = { &#13;
            "content":"Weekend Offers, avail 30% discount today!", &#13;
            "day":"2016-08-27", &#13;
            "time":"13:25", &#13;
            "timezone":"Australia/Sydney" &#13;
        } &#13;
 &#13;
        post_newyork = { &#13;
            "content":"Introducing sun glasses at your favorite stores &#13;
            in NY!", &#13;
            "day":"2016-08-27", &#13;
            "time":"12:41", &#13;
            "timezone":"America/New_York" &#13;
        } &#13;
 &#13;
        scheduled_messages = [offers_sydney, post_newyork] &#13;
</pre><p>The output of the preceding code is as follows. Here's the first iteration:</p><p>
</p><div><img alt="How to do it..." src="img/image_08_013.jpg"/></div><p>
</p><p>Here's the second iteration:</p><p>
</p><div><img alt="How to do it..." src="img/image_08_014.jpg"/></div><p>
</p><p>Here's the actual tweet:</p><p>
</p><div><img alt="How to do it..." src="img/image_08_015.jpg"/></div><p>
</p></li><li class="listitem">Cool! So we have what Joy needs. An automated tweet with the right content at the right time for the right audiences across the globe. Woohoo!</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec183"/>How it works...</h2></div></div></div><p>In the preceding code snippets, we have two files. We have <code class="literal">tweet_config.py</code>, and it contains a configuration dictionary that is used to specify the content and schedule of the tweets. It also mentions the time zone in which the tweets need to be posted.</p><p>The second file <code class="literal">scheduled_tweets.py</code> is a runner program. It looks at the configuration every minute and checks whether there is any tweet scheduled for the given minute of the day.</p><p>When the runner program, <code class="literal">scheduled_tweets.py</code>, runs, it checks whether there are any messages scheduled. In iteration 1, the runner program doesn't find anything that it needs to work on; it just returns the current day and time of the time zone.</p><p>In iteration 2, it does find that there is a tweet scheduled in the Australian time zone, Sydney to be precise, at 13:25 hours on August 27;<sup>,</sup> since the time matched, it posted a tweet. Of course, the example taken here is a very crude one. We might want to schedule Cron jobs instead of an endless while loop. But hey, this was an example to bring home the point about automatically scheduled tweets.</p><p>In this section, we automated the marketing process for Joy. Now she can not only tweet when she is is asleep, but also schedule tweets for different time zones and with different content. Now that's the power of automation.</p><p>"But hey, this is just one social media platform; what about Facebook?" you might ask. Yes, we have a trick up our sleeves. Twitter provides apps for connecting you to multiple services, including Facebook. So configure an app for your account so that every tweet that you post also gets posted on Facebook. This is how the configuration looks. It posts your original tweets and retweets them on your Facebook profile:</p><p>
</p><div><img alt="How it works..." src="img/image_08_016.jpg"/></div><p>
</p><p>Remember the first message that we posted about Python antigravity? Yes, it actually got posted on the Facebook wall as well. Look at the source next to the date and time of the tweet; yes it's Twitter! Perhaps, Twitter uses Facebook APIs to automate this:</p><p>
</p><div><img alt="How it works..." src="img/image_08_017.jpg"/></div><p>
</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec64"/>An introduction to Webhooks</h1></div></div></div><p>In the last section, we understood how to design and develop REST APIs and how to leverage REST APIs to our benefit by taking an example of Twitter/Facebook automation. Let's look at another amazing piece: Webhooks. A Webhook is an HTTP callback--an HTTP <code class="literal">POST</code> request to a user-defined URL (implemented as an HTTP API) when a favorable event occurs. Webhooks are often referred to as reverse APIs and are used for real-time communication or integration across services. But before we go deeper, let's understand a bit about polling.</p><p>You might have seen applications polling for long hours to check whether an event has occurred so that they can perform some follow-up action for the event. Take a real-world example. You go to a self-service restaurant and order your favorite pizza for lunch. The guy at the counter gives you an order number and tells you to watch the token machine for your order number so that you can collect your pizza. While everybody around is busy eating, you are hungry and tend to watch this token machine every 5 seconds hoping to see your order number flash on it. Now this is polling. You are polling the token machine. In the API world, the client would be polling the pizza place API to check the status of the order.</p><p>Wouldn't it be simple enough for the guy at the service counter to shout the order number when its ready? So after placing your order, you could get busy checking your official e-mails. When the service guy calls out your order number, you can collect your pizza from the delivery counter. This makes sure that your time is better utilized. Now this is a Webhook. When a favorable event occurs (your order is ready), you get a callback (the service guy shouts your order number) on your URL (in this case, your ears) that is literally listening and responding to callbacks. In the API world, you'd register your URL (the HTTP API) that gets called by the pizza place when your order is ready.</p><p>Webhooks can be used for three main purposes:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Receiving data in real time</li><li class="listitem" style="list-style-type: disc">Receiving data and pushing it on to another service</li><li class="listitem" style="list-style-type: disc">Receiving the data and then processing and returning it</li></ul></div><p>You can think of many different ways of using Webhooks in the preceding three scenarios.</p><p>If you think of polling and Webhooks, they both use APIs for integration needs. While polling is a client-driven integration technique, Webhooks are server-driven. Polling is very inefficient in the sense that the client keeps making server API calls to check the state of the resource (in our example, an order resource) with the help of a time stamp. Polling can happen every <em>x</em> minutes, <em>x</em> hours, or even <em>x</em> seconds to become more real time, but I think you get the inefficiencies associated with polling. On the other hand, Webhooks post data back to the callback URIs in the case of a favorable event. This is much more efficient than constant polling, but the flip side is you end up developing APIs on the client side, so your client tends to behave like a server itself.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec65"/>Implementing Webhooks</h1></div></div></div><p>With this knowledge, let's get started and implement Webhooks in this recipe.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec184"/>Getting ready</h2></div></div></div><p>For this recipe, we will use a famous Python web framework called <strong>Django</strong>. It allows you to use multiple plugins that get simply plugged in. Here, we will use the <code class="literal">django-rest-hooks</code> plugin developed by Zapier for implementing Webhooks.</p><p>So let's gets started and install the required packages. We install <code class="literal">Django==1.10</code> and <code class="literal">django-rest-hooks==1.3.1</code> using our favorite tool, Python <code class="literal">pip</code>:</p><pre class="programlisting">
<strong>        (user)chetans-MacBookPro:ch07 Chetan$ pip install Django==1.10 &#13;
        Collecting Django==1.10 &#13;
          Downloading Django-1.10-py2.py3-none-any.whl (6.8MB) &#13;
            100% |████████████████████████████████| 6.8MB 71kB/s  &#13;
        Installing collected packages: Django &#13;
        Successfully installed Django-1.10 &#13;
 &#13;
         (user)chetans-MacBookPro:ch07 Chetan$ pip install django-rest-hooks &#13;
        Collecting django-rest-hooks &#13;
          Downloading django-rest-hooks-1.3.1.tar.gz &#13;
        Requirement already satisfied (use --upgrade to upgrade): Django&gt;=1.4 in ./user/lib/python2.7/site-packages (from django-rest-hooks) &#13;
        Requirement already satisfied (use --upgrade to upgrade): requests in ./user/lib/python2.7/site-packages (from django-rest-hooks) &#13;
        Building wheels for collected packages: django-rest-hooks &#13;
          Running setup.py bdist_wheel for django-rest-hooks &#13;
          Stored in directory: /Users/chetan/Library/Caches/pip/wheels/96/93/12/3ec10693ee2b394a7d8594e8939f7506d7231fab69c8e69550 &#13;
        Successfully built django-rest-hooks &#13;
        Installing collected packages: django-rest-hooks &#13;
        Successfully installed django-rest-hooks-1.3.1 &#13;
</strong>
</pre></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec185"/>How to do it...</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">OK, let's create a Django app. We do this with the following commands:<pre class="programlisting">
<strong>           python manage.py startproject bookstore &#13;
           cd bookstore &#13;
           python manage.py startapp book &#13;
</strong>
</pre></li><li class="listitem">Next, let's configure Django to use the <code class="literal">rest_hooks</code> module in the app. We do this by adding <code class="literal">rest_hooks</code> to <code class="literal">bookstore/settings.py</code> under <code class="literal">INSTALLED_APPS</code>. We also add our app book to this list. Add an event, namely <code class="literal">user.signup</code>, to <code class="literal">settings.py</code> by using the constant <code class="literal">HOOK_EVENTS</code>. We haven't tied the event <code class="literal">user.signup</code> to any action here, so it's none. This is how <code class="literal">settings.py</code> should look like:<p>
</p><div><img alt="How to do it..." src="img/image_08_018.jpg"/></div><p>
</p></li><li class="listitem">Now, let's register this event to a callback URL. But before we go there, navigate to the root of your project and run this command to initialize your Django models:<pre class="programlisting">
<strong>        (user)chetans-MacBookPro:bookstore Chetan$ python manage.py&#13;
        migrate &#13;
        Operations to perform: &#13;
          Apply all migrations: admin, contenttypes, rest_hooks, auth,&#13;
          sessions &#13;
        Running migrations: &#13;
          Rendering model states... DONE &#13;
          Applying contenttypes.0001_initial... OK &#13;
          Applying auth.0001_initial... OK &#13;
          Applying admin.0001_initial... OK &#13;
          Applying admin.0002_logentry_remove_auto_add... OK &#13;
          Applying contenttypes.0002_remove_content_type_name... OK &#13;
          Applying auth.0002_alter_permission_name_max_length... OK &#13;
          Applying auth.0003_alter_user_email_max_length... OK &#13;
          Applying auth.0004_alter_user_username_opts... OK &#13;
          Applying auth.0005_alter_user_last_login_null... OK &#13;
          Applying auth.0006_require_contenttypes_0002... OK &#13;
          Applying auth.0007_alter_validators_add_error_messages... OK &#13;
          Applying rest_hooks.0001_initial... OK &#13;
          Applying sessions.0001_initial... OK &#13;
</strong>
</pre></li><li class="listitem">Once the models are initialized, go to the database shell and run the following Python code snippets. They will create a user in the Django user table and register a Webhook for this user:<pre class="programlisting">
<strong>        &gt;&gt;&gt; from django.contrib.auth.models import User &#13;
        &gt;&gt;&gt; from rest_hooks.models import Hook &#13;
        &gt;&gt;&gt; usr=User.objects.create(username='chetan') &#13;
        &gt;&gt;&gt; hook = Hook(user=usr, event='user.signup',&#13;
        target='http://localhost:8000/hook/') &#13;
        &gt;&gt;&gt; hook.save() &#13;
        &gt;&gt;&gt; hook &#13;
        &lt;Hook: user.signup =&gt; http://localhost:8000/hook/&gt; &#13;
</strong>
</pre></li><li class="listitem">Now add a file called <code class="literal">urls.py</code> to the Book app and add this code:<pre class="programlisting">        from django.conf.urls import url &#13;
        from . import views &#13;
        urlpatterns = [ &#13;
            url(r'event/$', views.event), &#13;
            url(r'hook/$', views.webhook),] &#13;
</pre></li><li class="listitem">Add the following methods to <code class="literal">book/views.py</code> to create Django views:<pre class="programlisting">        from django.shortcuts import render&#13;
        from django.views.decorators.csrf import csrf_exempt &#13;
        from rest_hooks.signals import raw_hook_event &#13;
        from django.contrib.auth.models import User &#13;
        import datetime &#13;
        from django.http.response import HttpResponse &#13;
        # Create your views here. &#13;
 &#13;
        @csrf_exempt &#13;
        def webhook(request): &#13;
            print request.body &#13;
            return HttpResponse() &#13;
 &#13;
        def event(request): &#13;
            user = User.objects.get(username='chetan') &#13;
            raw_hook_event.send( &#13;
                sender=None, &#13;
                event_name='user.signup', &#13;
                payload={ &#13;
                    'username': user.username, &#13;
                    'email': user.email, &#13;
                    'when': datetime.datetime.now().isoformat() &#13;
                }, &#13;
                user=user # required: used to filter Hooks &#13;
            ) &#13;
            return HttpResponse() &#13;
</pre></li><li class="listitem">Also, include these URLs in the project under <code class="literal">bookstore.urls.py</code> like this:<pre class="programlisting">        from django.conf.urls import url, include &#13;
        from django.contrib import admin &#13;
 &#13;
 &#13;
        urlpatterns = [ &#13;
            url(r'^admin/', admin.site.urls), &#13;
            url(r'^', include('book.urls')) &#13;
        ] &#13;
</pre></li><li class="listitem">Now run the Django server as follows:<pre class="programlisting">
<strong>        (user)chetans-MacBookPro:bookstore Chetan$ python manage.py &#13;
        runserver &#13;
        Performing system checks... &#13;
 &#13;
        System check identified no issues (0 silenced). &#13;
        August 27, 2016 - 11:14:52 &#13;
        Django version 1.9, using settings 'bookstore.settings' &#13;
        Starting development server at http://127.0.0.1:8000/ &#13;
        Quit the server with CONTROL-C. &#13;
</strong>
</pre></li><li class="listitem">From your browser, go to <code class="literal">http://localhost:8000/event/</code> and look at your server logs. You will see that the registered Webhook got invoked, which means an HTTP <code class="literal">POST</code> request was sent to the target URL <code class="literal">http://localhost:8000/hook/</code> along with the payload, which contains all of the information we configured in the view. The server logs look like this:<pre class="programlisting">        [27/Aug/2016 10:53:29] "GET /event/ HTTP/1.1" 200 0 &#13;
 &#13;
        {"hook": {"target": "http://localhost:8000/hook/", "id": 1,&#13;
        "event": "user.signup"}, "data": {"username": "chetan", "when": &#13;
        "2016-08-27T10:53:29.301317", "email": ""}} &#13;
 &#13;
         [27/Aug/2016 10:53:29] "POST /hook/ HTTP/1.1" 200 0 &#13;
</pre></li></ol></div><p>Cool! Did you look at it? We invoked the /event URL, which in turn posted the required information to the target URL, which was registered for the event <code class="literal">user.signup</code> in our Webhook.</p><p>Similar to custom Webhooks, one could also develop RESTful Webhooks. RESTful Webhooks support subscription, notification, and publication actions through a RESTful interface. RESTful Webhooks must support four event types, namely <code class="literal">ACCESSED</code>, <code class="literal">CREATED</code>, <code class="literal">UPDATED</code>, and <code class="literal">DELETED</code>, which correspond to four HTTP verbs; notifications should be sent for the actions that get applied to the resource. For instance, when a resource gets created, an event gets generated; with this, the Webhook must be triggered and the target URL should be posted. In our example, we can define two more hook events, namely <code class="literal">book.added</code> and <code class="literal">book.deleted</code>, along with actions such as <code class="literal">book.Book.added</code> or <code class="literal">book.Book.deleted</code>. When we do a <code class="literal">book.save()</code> action on the model, the <code class="literal">book.added</code> event gets triggered, and if we have a hook defined for this event for the user, the HTTP <code class="literal">POST</code> request will be called on the target URL.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec186"/>How it works...</h2></div></div></div><p>In the preceding code snippets, we first defined an event in the <code class="literal">settings.py</code> file. The event was named <code class="literal">user.signup</code>. Since it was a custom event, it had no action defined.</p><p>We then created a new user <code class="literal">chetan</code> in the <code class="literal">auth_user</code> table using the default Django user model.</p><p>Later, we defined a Webhook for the the user <code class="literal">chetan</code>. This Webhook was configured for the event <code class="literal">user.signup</code>, and the target URL was set to <code class="literal">http://localhost:8000/hook/</code>.</p><p>We also defined two views in our Django app. The first view event was responsible for firing the Webhook for the corresponding user and event and for sending the payload information. The second view Webhook was defined for the target URL.</p><p>We then ran the Django development server and navigated to <code class="literal">http://localhost:8000/event/</code>, which posted the payload information to the target URL, namely <code class="literal">http://localhost:8000/hook/</code>. The target URL received all of the payload data, such as the username, e-mail, and the time when the signup happened.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec187"/>There's more...</h2></div></div></div><p>In this section, we looked at polling and Webhooks, which are other forms of integration on the Web that use APIs. We learned inefficiencies with polling and how Webhooks were much more useful. In the preceding recipe, we covered a custom event useful for user signup as I wanted it to explain the concept in a generic way. The coverage was brief, so I would like you to study more about RESTful Webhooks as they present a powerful use case for automation. With this understanding, let's see what problems Oliver has and how we can help him.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec66"/>Automating lead management with Webhooks</h1></div></div></div><p>Oliver is Joy's colleague and works in the marketing department. He is responsible for the user onboarding process. His primary responsibility includes:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Sending a welcome e-mail to users who sign up on your website</li><li class="listitem" style="list-style-type: disc">Adding a lead record for the new signee into the CRM</li></ul></div><p>Previously, it was easy for him to perform these two tasks manually since the signups on the site were minimal. But with the growing popularity of the website, he has begun to see an upsurge in the number of signups on a daily basis. Without doubt, he sees this as a highly time-consuming activity that can be easily automated. Can you help Oliver?</p><p>If we carefully analyze the problem, Oliver's main issue is integration across services. The two services that he needs to integrate the signup are e-mail and CRM. He needs to track a signup event and take an action on this event. Webhooks are a perfect solution for this use case. Let's see how we can help Oliver automate his task.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec188"/>How to do it...</h2></div></div></div><p>We will use the same Django project to solve this problem. We will also use an external service, Zapier, and see how it helps make things so much easier. Let's get started:</p><div><ol class="orderedlist arabic"><li class="listitem">From the Terminal, go to the Django project's root directory and run the Python <code class="literal">manage.py</code> shell command to log in to the DB shell. Here, update our user <code class="literal">chetan</code> with the e-mail address. This can be achieved with the following set of commands:<pre class="programlisting">
<strong>        &gt;&gt;&gt; from django.contrib.auth.models import User &#13;
        &gt;&gt;&gt; from rest_hooks.models import Hook &#13;
        &gt;&gt;&gt; usr = User.objects.get(username='chetan') &#13;
        &gt;&gt;&gt; usr.email='chetan@email.io' &#13;
        &gt;&gt;&gt; usr.save() &#13;
</strong>
</pre></li><li class="listitem">Now create an account with the Zapier app by navigating to <a class="ulink" href="https://zapier.com/">https://zapier.com/</a>. Once you have the account created, click on <strong>MAKE A ZAP!</strong> to reach <strong>Choose App</strong> and click on <strong>Webhooks</strong> under the <strong>BUILT-IN APPS</strong> section:<p>
</p><div><img alt="How to do it..." src="img/image_08_019.jpg"/></div><p>
</p></li><li class="listitem">Once you select a Webhook, you will get a screen to create a <strong>TRIGGER</strong> and <strong>ACTION</strong> on the left-hand pane. On the right-hand side, select the <strong>Catch Hook</strong> option. Click on <strong>Save + Continue</strong>. Refer to the following screenshot:<p>
</p><div><img alt="How to do it..." src="img/image_08_020.jpg"/></div><p>
</p></li><li class="listitem">Next, you will get the page to provide a JSON key that you want to select from the payload. This is an optional step and can be ignored. Click on <strong>Continue</strong> to reach the next step. Here, you'll get a custom Webhook URL. Copy this URL; it will act as a target URL.</li><li class="listitem">Now go back to your Django project and navigate to the DB shell. Create a new hook with the same event <code class="literal">user.signup</code> and target the URL that you received from Zapier in the earlier step. The commands will look as follows:<pre class="programlisting">
<strong>        &gt;&gt;&gt; hook = Hook(user=usr, event='user.signup', &#13;
        target=&#13;
        'https://hooks.zapier.com/hooks/catch/&lt;Id&gt;/&lt;Webhook_Id&gt;/') &#13;
        &gt;&gt;&gt; hook.save() &#13;
        &gt;&gt;&gt; hook &#13;
        &lt;Hook: user.signup =&gt; &#13;
        https://hooks.zapier.com/hooks/catch/&lt;Id&gt;/&lt;Webhook_Id&gt;/&gt; &#13;
</strong>
</pre></li><li class="listitem">Run the Django development server with the <code class="literal">runserver</code> command of Python <code class="literal">manage.py</code>. Once the server is running, go to <code class="literal">http://localhost:8000/event/</code>; this will make a callback request to the target URL obtained from Zapier. You can verify this by going to Zapier again and looking at <strong>Test this Step</strong> on the left pane, under the <strong>Catch Hook</strong> section:<p>
</p><div><img alt="How to do it..." src="img/image_08_021.jpg"/></div><p>
</p></li><li class="listitem">Cool! We now have the trigger set up. Let's set up the action. For this, go to your left-hand pane and click on <strong>Set up this step</strong> under <strong>ACTION</strong>. Choose Gmail from the list of apps that will show up on the right-hand side of the screen:<p>
</p><div><img alt="How to do it..." src="img/image_08_022.jpg"/></div><p>
</p></li><li class="listitem">Once you click on <strong>Gmail</strong>, you get the next option to select an action, such as <strong>Create Draft</strong> or <strong>Send Email</strong>. Click on <strong>Send Email</strong> and activate your e-mail account by allowing Zapier to access it. The following screenshots will show you how to perform these steps:<p>
</p><div><img alt="How to do it..." src="img/image_08_023.jpg"/></div><p>
</p><p>In the next screenshot, we allow Zapier to access the Gmail app:</p><p>
</p><div><img alt="How to do it..." src="img/image_08_024.jpg"/></div><p>
</p></li><li class="listitem">OK! Now the only thing pending is to create the e-mail template. Our template contains the <strong>To</strong> e-mail address, subject, and body. Zapier gives you a nice option to configure your template. If you have already tested your trigger by posting data to the target URL, you will see a set of options on the extreme right of every field in the e-mail template. In the next two screenshots, I have <strong>Data Email</strong> in the <strong>To</strong> field, <strong>Welcome Data Username!</strong> in the <strong>Subject</strong> field, and <strong>Your Signup made our day!</strong> as the e-mail body.</li><li class="listitem">The following screenshot shows a dropdown of all the available options from the payload that the target URL received in the <strong>Test this Step</strong> section of the trigger. I have just shown the username. Look how the field name <strong>To</strong> of the template can chose <strong>Data Username</strong> from the payload:<p>
</p><div><img alt="How to do it..." src="img/image_08_025.jpg"/></div><p>
</p><p>The e-mail template with all the necessary fields configured can be seen in the following screenshot. We have configured the <strong>To</strong>, subject, and body parts of the e-mail in Zapier:</p><p>
</p><div><img alt="How to do it..." src="img/image_08_026.jpg"/></div><p>
</p></li><li class="listitem">That's it! Click on <strong>Continue</strong> at the bottom of this screen; Zapier will test your action and you're done. The following screenshot shows the confirmation of success!<p>
</p><div><img alt="How to do it..." src="img/image_08_027.jpg"/></div><p>
</p></li><li class="listitem">Now if you check your e-mail, you should have received a test e-mail from Zapier, which was used for testing the Zapier action. The contents of the e-mail are the way we wanted them to be. Pretty cool! So now when anyone signs up on Oliver's product website, the view will <code class="literal">POST</code> the signee's information as the payload to Zapier's Webhook (the target URL), and Zapier will automate the e-mail part.<p>
</p><div><img alt="How to do it..." src="img/image_08_028.jpg"/></div><p>
</p></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec189"/>How it works...</h2></div></div></div><p>Zapier provides us with a feature to create custom Webhooks. It has integration with almost all the apps under the sun, such as Gmail, Trello, Slack, and so on. We just created a Webhook as a trigger and followed it up with an action from Gmail.</p><p>Whenever a user signs up (new user creation), the Django app will <code class="literal">POST</code> the user's data as the payload to the Zapier target URL, which we got when we created a trigger in Zapier.</p><p>Once Zapier receives the payload data to the target URL, it checks the action and finds that it has to send an e-mail to a Gmail account. Zapier is also intelligent enough to get the data from the payload and send the e-mail to the user's e-mail address; it also allows configuration of the e-mail's subject and body.</p><p>Fantastic! Oliver is happy! And what about step 2? Well, it's another Zapier trigger with either the Salesforce or Pipedrive CRM to create a lead record in the CRM. A walk in the park!</p><p>In this section, we looked at automating user onboarding with a user signup event. We took an example of Zapier as it's the best possible way to automate apps. If we had not done this, we would have ended up understanding the APIs provided by all these apps and writing code for all of them ourselves, an activity which may not be the core of your product or service.</p><p>Well that's it, folks! Hope you enjoyed this piece of automation and I'm sure you will definitely implement this in your organization.</p></div></div></body></html>