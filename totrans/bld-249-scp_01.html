<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Extending Blender with Python</h1></div></div></div><p>Before we start crafting scripts in Blender we must check whether or not we have all the necessary tools available. After that we will have to familiarize ourselves with these tools so that we can use them with confidence. In this chapter, we will look at:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">What can and cannot be accomplished with Python in Blender</li><li class="listitem" style="list-style-type: disc">How to install a full Python distribution</li><li class="listitem" style="list-style-type: disc">How to use the built-in editor</li><li class="listitem" style="list-style-type: disc">How to run a Python script</li><li class="listitem" style="list-style-type: disc">How to explore built-in modules</li><li class="listitem" style="list-style-type: disc">How to write a simple script that adds an object to a Blender scene</li><li class="listitem" style="list-style-type: disc">How to register a script in the Blender scripts menu</li><li class="listitem" style="list-style-type: disc">How to document your script in a user-friendly way</li><li class="listitem" style="list-style-type: disc">How to distribute a script</li></ul></div><p>With so many things possible there is an awful lot to learn, but fortunately the learning curve is not as steep as it might seem. Let's just type in a quick few lines of Python to put a simple object into our Blender scene, just to prove we can, before we head into deeper waters.</p><div><ol class="orderedlist arabic"><li class="listitem">Start Blender with an empty scene.<div><img alt="Extending Blender with Python" src="img/0400_01_01.jpg"/></div></li><li class="listitem"><a class="indexterm" id="id0"/>Open the interactive Python console (refer to the preceding screenshot to see where to find it).</li><li class="listitem">Type in the following lines (end each one with a <em>Enter</em>/<em>Return</em>).<div><pre class="programlisting">mesh = Mesh.Primitives.Monkey()
Scene.GetCurrent().objects.new(mesh,'Suzanne')
Window.RedrawAll()</pre></div></li></ol></div><p>Voila! That's all that is needed to add Suzanne, Blender's famous mascot, to the scene.</p><div><img alt="Extending Blender with Python" src="img/0400_01_02.jpg"/></div><div><div><div><div><h1 class="title"><a id="ch01lvl1sec07"/>The Blender API</h1></div></div></div><a class="indexterm" id="id1"/><p>Almost anything in Blender is accessible from Python scripts but there are some exceptions and limitations. In this section, we illustrate what this means exactly and which notable features are not accessible to Python (for example, fluid dynamics).</p><p>The Blender API consists of three major areas of interest:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Access to Blender objects and their properties, for example a <code class="literal">Camera</code> object and its <code class="literal">angle</code> property or a <code class="literal">Scene</code> object and its <code class="literal">objects</code> property</li><li class="listitem" style="list-style-type: disc">Access to operations to perform, for example adding a new <code class="literal">Camera</code> or rendering an image</li><li class="listitem" style="list-style-type: disc">Access to the graphical user interface, either by using simple building blocks or by interacting with the Blender event system</li></ul></div><a class="indexterm" id="id2"/><p>There are also some utilities that do not fit well in any of these categories as they concern themselves with abstractions that have no direct relation to Blender objects as seen by the end user, for example functions to manipulate vectors and matrices.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec04"/>A lot of power</h2></div></div></div><a class="indexterm" id="id3"/><p>Taken together this means we can achieve a lot of things from Python scripts. We can:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Create a new Blender object of any type, including cameras, lamps, meshes, and even scenes</li><li class="listitem" style="list-style-type: disc">Interact with the user with a graphical user interface</li><li class="listitem" style="list-style-type: disc">Automate common tasks within Blender such as rendering</li><li class="listitem" style="list-style-type: disc">Automate maintenance tasks outside of Blender such as cleaning up directories</li><li class="listitem" style="list-style-type: disc">Manipulate any property of a Blender object that is exposed by the API</li></ul></div><p>That last statement shows one of the current weaknesses of the Blender API: any object property that the developers add in the Blender C source must be provided separately in the Python API. There is no automatic conversion from internal structures to the interface available in Python and this means that efforts must be duplicated and may lead to omitted functionality. For instance, in Blender 2.49 it is not possible at all to set up a fluid simulation from a script. Although it is possible to set up a particle system, there is no way to set the behavioral characteristics of a boids particle system.</p><p>Another problem of the 2.49 Python API is that many of the actions a user may choose to perform on an object have no equivalent in the API. Setting simple parameters such as the camera angle or performing a rotation of any object is easy and even associating for example, a subsurface modifier to a mesh is just a few lines of code but common actions, especially on mesh objects, such as subdividing selected edges or extruding faces are missing from the API and must be implemented by the script developer.</p><p>These problems led the Blender developers to completely redesign the Blender Python API for the 2.5 version, focusing on feature parity (that is, everything possible in Blender should be possible using the Python API). This means that in many situations it will be far easier to get the same results in Blender 2.5.</p><p>Finally, Python is used in more places than just standalone scripts: <strong>PyDrivers</strong> and <strong>PyConstraints</strong> enable us to control the way Blender objects behave and we will encounter them in later chapters. Python also allows us to write custom textures and shaders as part of the nodes system as we will see in <a class="link" href="ch07.html" title="Chapter 7. Creating Custom Shaders and Textures with Pynodes">Chapter 7</a>, <em> Creating Custom Shaders and Textures.</em>
</p><a class="indexterm" id="id4"/><p>Also, it is important to keep in mind that Python offers us far more than just the (already impressive) tools to automate all sorts of tasks in Blender. Python is a general programming language with an extensive library of tools included, so we do not have to resort to external tools for common system tasks such as copying files or archiving (zipping) directories. Even networking tasks can be implemented quite easily as a number of render farm solutions prove.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec05"/>Some batteries included</h2></div></div></div><p>When we install Blender, a Python interpreter is already part of the application. This means that it is not necessary to install Python as a separate application. But there is more to Python than just the interpreter. Python comes with a huge collection of modules that provide a wealth of functionality. Anything from file manipulation to XML processing and more is available, and the best bit is that these modules are a standard part of the language. They are just as well maintained as the Python interpreter itself and (with very few exceptions) available on any platform that Python runs on.</p><p>The downside is, of course, that this collection of modules is fairly large (40MB or so), so the Blender developers chose to distribute only the bare minimum, primarily the math module. This makes sense if you want to keep the size of the Blender downloads manageable. Many Python developers have come to depend on the standard distribution because not having to reinvent the wheel saves huge amounts of time, not to mention it's not an easy task to develop and test a full-fledged XML library say, just because you want to be able to read a simple XML file. That is why it is now more or less a consensus that it is a good thing to install the full Python distribution. Fortunately, the installation is just as easy as the installation of Blender itself, even for end users, as binary installers are provided for many platforms, such as Windows and Mac, also in 64-bit versions. (Distributions for Linux are provided as source code with instructions on how to compile them, but many Linux distributions either already provide Python automatically or make it very easy to install it afterwards from a package repository).</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec06"/>Check for a full Python distribution</h2></div></div></div><a class="indexterm" id="id5"/><a class="indexterm" id="id6"/><p>Chances are that you already have a full Python distribution on your system. You can verify this by starting Blender and checking the console window (the term <strong>console</strong> <strong>window</strong> refers to either the DOSBox that starts in parallel on Windows or the X terminal window where you start Blender from on other systems) to see if it displays the following text:</p><div><pre class="programlisting">
<strong>Compiled with Python version 2.6.2.</strong>
<strong>Checking for installed Python... got it!</strong>
</pre></div><a class="indexterm" id="id7"/><p>If it does, then there is nothing you have to do and you can skip to <em>The</em> <em>interactive</em> <em>Python</em> <em>console</em> section. If it shows the following message then you do have to take some action:</p><div><pre class="programlisting">
<strong>Compiled with Python version 2.6.2.</strong>
<strong>Checking for installed Python... No installed Python found.</strong>
 <strong>     Only built-in modules are available.  Some scripts may not run.</strong>
 <strong>     Continuing happily.</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec07"/>Installing a full Python distribution</h2></div></div></div><a class="indexterm" id="id8"/><a class="indexterm" id="id9"/><a class="indexterm" id="id10"/><p>The steps toward a full Python installation for Windows or Mac are as follows:</p><div><ol class="orderedlist arabic"><li class="listitem">Download a suitable installer from <a class="ulink" href="http://www.python.org/download/">http://www.python.org/download/</a>. At the moment of writing, the latest stable 2.6 version is 2.6.2 (used in Blender 2.49). It is generally a good thing to install the latest stable version as it will contain the latest bug fixes. Make sure, however, to use the same major version as Blender is compiled with. It is fine to use version 2.6.3 when it is released even as Blender is compiled with version 2.6.2. But if you use an older version of Blender that is compiled with Python 2.5.4 you have to install the latest Python 2.5.x release (or upgrade to Blender 2.49, if that is an option).</li><li class="listitem">Run the installer: On Windows the installer offers you to choose where to install Python. You can choose anything you like here, but if you choose the default, Blender will almost certainly find the modules installed here without the need to set the <code class="literal">PYTHONPATH</code> variable. (see below)</li><li class="listitem">(Re) start Blender. The Blender console should show the text:<div><pre class="programlisting">Compiled with Python version 2.6.2.
Checking for installed Python... got it!</pre></div><p>If it doesn't, it might be necessary to set the <code class="literal">PYTHONPATH</code> variable. Refer to the Blender wiki for detailed information: <a class="ulink" href="http://wiki.blender.org/index.php/Doc:Manual/Extensions/Python">http://wiki.blender.org/index.php/Doc:Manual/Extensions/Python</a>
</p></li></ol></div><p>On Ubuntu Linux, the first step is not needed and installing can be done by using the built-in package manager:</p><div><pre class="programlisting">
<strong>sudo apt-get update</strong>
<strong>sudo apt-get install python2.6</strong>
</pre></div><p>Other distributions might use a different package management system so you might have to check the documentation for that. Under Windows it might be necessary to set the <code class="literal">PYTHONPATH</code> environment variable, although this is unlikely when using the provided packages.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec08"/>The interactive Python console</h2></div></div></div><a class="indexterm" id="id11"/><a class="indexterm" id="id12"/><p>To see where Blender actually looks for modules you may look at Python's <code class="literal">sys.path</code> variable. To do this you have to start up Blender's interactive Python console. Note that you use a different and possibly confusing notion of console here—the DOSBox or the terminal window that is started alongside Blender's main application window and where various informational messages are displayed is referred to as <strong>console</strong> as well! The Python interactive console that we want to use now is started from the <strong>script window</strong>:</p><div><img alt="The interactive Python console" src="img/0400_01_03.jpg"/></div><p>Once the interactive Python console is started, type the following commands:</p><div><pre class="programlisting">
<strong>import sys</strong>
<strong>print sys.path</strong>
</pre></div><a class="indexterm" id="id13"/><a class="indexterm" id="id14"/><p>Note that the interactive Python console does not show any prompt (unless when expecting indentation, for example within a <code class="literal">for</code> loop) but anything you type will be in a different color (white on black by default) from what is returned (that will be blue or black). The two preceding commands will give us access to Python's <code class="literal">sys</code> module that contains various variables with system information. The <code class="literal">sys.path</code> variable that we print here will hold all of the directories that will be searched when we try to import a module. (Note that importing <code class="literal">sys</code> will always work because <code class="literal">sys</code> is a built-in module.) The output will be something similar to:</p><div><pre class="programlisting">
<strong>['C:\\Program Files\\Blender Foundation\\Blender', 'C:\\Program Files\\Blender Foundation\\Blender\\python26.zip', 'C:\\Python26\\Lib', 'C:\\Python26\\DLLs', 'C:\\Python26\\Lib\\lib-tk', 'C:\\Program Files\\Blender Foundation\\Blender', 'C:\\Python26', 'C:\\Python26\\lib\\site-packages','C:\\Python26\\lib\\site-packages\\PIL', 'C:\\PROGRA~1\\BLENDE~1\\Blender', 'C:\\Documents and Settings\\Michel\\Application Data\\Blender Foundation\\Blender\\.blender\\scripts', 'C:\\Documents and Settings\\Michel\\Application Data\\Blender </strong>
<strong>Foundation\\Blender\\.blender\\scripts\\bpymodules']</strong>
</pre></div><p>If your Python installation directory is not in this list then you should set the <code class="literal">PYTHONPATH</code> variable before starting Blender.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec08"/>Exploring built-in modules, the help() function</h1></div></div></div><a class="indexterm" id="id15"/><a class="indexterm" id="id16"/><p>The interactive Python console is a good platform to explore built-in modules as well. Because Python comes equipped with two very useful functions, <code class="literal">help()</code> and <code class="literal">dir()</code>, you have instant access to a lot of information contained in Blender's (and Python's) modules as a lot of documentation is provided as part of the code.</p><p>For people not familiar with these functions, here are two short examples, both run from the interactive Python console. To get information on a specific object or function, type:</p><div><pre class="programlisting">help(Blender.Lamp.Get)</pre></div><p>The information will be printed in the same console:</p><div><pre class="programlisting">
<strong>Help on built-in function Get in module Blender.Lamp:</strong>

<strong>Lamp.Get (name = None):</strong>
 <strong>       </strong>
<strong>Return the Lamp Data with the given name, None if not found, or</strong>
 <strong>       Return a list with all Lamp Data objects in the current scene,</strong>
 <strong>       if no argument was given.</strong>
</pre></div><a class="indexterm" id="id17"/><p>The <code class="literal">help()</code> function will show the associated docstring of functions, classes, or modules. In the previous example, that is the information provided with the <code class="literal">Get()</code> method (function) of the <code class="literal">Lamp</code> class<a class="indexterm" id="id18"/>. A <strong>docstring</strong><a class="indexterm" id="id19"/> is the first string defined in a function, class, or module. When defining your own functions, it is a good thing to do this as well. This might look like this:</p><div><pre class="programlisting">def square(x):
   """
   calculate the square of x.
   """
   return x*x</pre></div><p>We can now apply the <code class="literal">help</code> function to our newly-defined function like we did before:</p><div><pre class="programlisting">help(square)</pre></div><p>The output then shows:</p><div><pre class="programlisting">
<strong>Help on function square in module __main__:</strong>
<strong>square(x)</strong>
 <strong>   calculate the square of x.</strong>
</pre></div><p>In the programs that we will be developing, we will use this method of documenting where appropriate.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec09"/>Exploring built-in functions, the dir() function</h2></div></div></div><a class="indexterm" id="id20"/><a class="indexterm" id="id21"/><p>The <code class="literal">dir()</code> function lists all members of an object. That object can be an instance, but also a class or module. For example, we might apply it to the <code class="literal">Blender.Lamp</code> module:</p><div><pre class="programlisting">dir(Blender.Lamp)</pre></div><p>The output will be a list of all members of the <code class="literal">Blender.Lamp</code> module<a class="indexterm" id="id22"/>. You can spot the <code class="literal">Get()</code> function <a class="indexterm" id="id23"/>that we encountered earlier:</p><div><pre class="programlisting">['ENERGY', 'Falloffs', 'Get', 'Modes', 'New', 'OFFSET', 'RGB','SIZE', 'SPOTSIZE', 'Types', '__doc__', '__name__', '__package__','get']</pre></div><p>Once you know which members a class or module has, you can then check for any additional help information for these members by applying the <code class="literal">help()</code> function.</p><p>Of course both <code class="literal">dir()</code> and <code class="literal">help()</code> are most useful when you already have some clue where to look for information. But if so, they can be very convenient tools indeed.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec09"/>Getting familiar with the built-in editor</h1></div></div></div><a class="indexterm" id="id24"/><p>It is possible to use any editor (that you like) to write Python scripts and then import the scripts as text files but Blender's built-in text editor will probably be adequate for all programming needs. It features conveniences such as syntax highlighting, line numbering, and automatic indentation, and gives you the possibility to run a script directly from the editor. The ability to run a script directly from the editor is a definite boon when debugging because of the direct feedback that you get when encountering an error. You will not only get an informative message but the offending line will also be highlighted in the editor.</p><p>What is more, the editor comes with many plug-ins of which the automatic suggestion of members and the documentation viewer are very convenient for programmers. And of course, it is possible to write additional plug-ins yourself.</p><p>You can select the built-in editor by choosing <strong>Text Editor</strong> from the Windows menu:</p><div><img alt="Getting familiar with the built-in editor" src="img/0400_01_04.jpg"/></div><a class="indexterm" id="id25"/><p>When you start up you are presented with an almost empty area except for a strip of buttons at the bottom:</p><div><img alt="Getting familiar with the built-in editor" src="img/0400_01_05.jpg"/></div><p>We can select the default empty text buffer <code class="literal">TX:Text</code> or create a new empty text by selecting <strong>ADD NEW</strong> from the drop-down menu available when we click on the <strong>Menu</strong> button.</p><a class="indexterm" id="id26"/><p>The default name for this new text will be <code class="literal">TX:Text.001,</code> but you may change it to something more meaningful by clicking on the name and changing it. Note that if you would like to save this text to an external file (with <strong>Text</strong> <strong>|</strong> <strong>Save</strong> <strong>As...</strong>) the name of the text is distinct from the filename (although in general it is a good idea to keep these the same to avoid confusion). It is not mandatory to save texts as external files; texts are Blender objects that are saved together with all other information when you save your <code class="literal">.blend</code> file.</p><p>External files may be opened as texts by selecting <strong>OPEN NEW</strong> from the <strong>Menu</strong> button drop-down instead of <strong>ADD NEW</strong>. If for some reason an external file and an associated text are out of sync when Blender is started, an out of sync button is displayed. When clicked, it displays a number of options to resolve the issue.</p><p>Once a new or existing text is selected, the menu bar at the bottom of the screen is updated with some additional menu options:</p><div><img alt="Getting familiar with the built-in editor" src="img/0400_01_06.jpg"/></div><p>The <strong>Text</strong> <strong>file</strong> <strong>menu</strong> gives access to options to open or save a file or to run the script in the editor. It also presents a number of template scripts that may be used as a basis for your own scripts. If you select one of these templates a new text buffer is created with a copy of the selected template.</p><p>The <strong>Edit</strong> <strong>menu</strong> contains <strong>cut-and-paste</strong> functionality as well as options to search and replace text or jump to a chosen line number.</p><p>The <strong>Format</strong> menu has options to indent and unindent selected text as well as options to convert whitespace. The latter option can be very helpful when the Python interpreter complains about unexpected indentation levels although there seems nothing amiss with your file. If that happens you possibly have mixed tabs and spaces in way that confuse Python (as they are different as far as the interpreter is concerned) and a possible way out is to convert selected text to spaces first and then back to tabs. This way mixed spaces and tabs will be used in a uniform way again.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec10"/>An editor example</h2></div></div></div><a class="indexterm" id="id27"/><p>To get used to the editor, create a new text buffer by choosing <strong>Text | New</strong> and type in the following example lines:</p><div><pre class="programlisting">import sys
print sys.path</pre></div><p>Most keys on the keyboard will behave in a familiar way, including <em>Delete</em>, <em>Backspace</em>, and <em>Enter</em>. The shortcut keys for cutting, pasting, and copying are listed in the <strong>Edit</strong> menu as <em>Alt + X</em>, <em>Alt + V</em>, and <em>Alt + C</em> respectively but the <em>Ctrl</em> key equivalents <em>Ctrl + X</em>, <em>Ctrl + V</em>, and <em>Ctrl + C</em> (familiar to Windows users) work just as well. A full keyboard map can be consulted on the Blender wiki, <a class="ulink" href="http://wiki.blender.org/index.php/Doc:Manual/Extensions/Python/Text_editor">http://wiki.blender.org/index.php/Doc:Manual/Extensions/Python/Text_editor</a>
</p><p>Selecting portions of the text can be achieved by clicking and dragging the mouse, but you can also select text by moving the text cursor around while pressing the <em>Shift</em> key.</p><p>Text will be uncolored by default, but reading scripts can be made a lot easier on the eye by enabling syntax highlighting. Clicking on the little <strong>AB</strong> button will toggle this (it will be black and white when syntax highlighting is off and colored when on.) Like many aspects of Blender, text colors can be customized in the <strong>themes</strong> section of the <strong>User Preferences </strong>window.</p><p>Another feature that is very convenient to enable, especially when debugging scripts, is line numbering. (You might write a faultless code in one go, but unfortunately yours truly is less of a genius.) Every Python error message that will be shown will have a filename and a line number, and the offending line will be highlighted. But the lines of the calling function(s), if any, will not be highlighted although their line numbers will be shown in the error message, so having line numbers enabled will enable you to quickly locate the calling context of the trouble spot. Line numbering is enabled by clicking on the <strong>lines</strong> button.</p><p>Running a script is done by pressing <em>Alt + P</em>. Nothing is displayed in the editor when there are no errors encountered, but the output will be shown on the console (that is, the DOSBox or X terminal Blender started from, <em>not</em> the Python interactive console that we encountered earlier).</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec10"/>First steps: Hello world</h1></div></div></div><a class="indexterm" id="id28"/><p>Tradition demands every book about programming to have a "hello world" example and why would we offend people? We will implement, and run, a simple object instantiating script and show how to integrate this in Blender's script menu. We will also show how to document it and make an entry in the help system. Finally, we will spend some words on the pros and cons of distributing scripts as <code class="literal">.blend</code> files or as scripts to install in the <code class="literal">scriptdir</code> by the user.</p><p>Let's write some code! You can type in the following lines directly into the interactive Python console, or you can open a new text in Blender's text editor and then press <em>Alt + P</em> to run the script. It is a short script but we'll go through it in some detail as it features many of the key aspects of the Blender Python API.</p><div><pre class="programlisting">#!BPY

<strong>import Blender</strong>
from Blender import Scene, Text3d, Window

hello = Text3d.New("HelloWorld")
hello.setText("Hello World!")

scn = Scene.GetCurrent()
ob = scn.objects.new(hello)

Window.RedrawAll()</pre></div><p>The first line identifies this script as a Blender script. This is not necessary to run the script, but if we want to be able to make this script a part of Blender's menu structure we need it, so we better get used to it right away.</p><p>You will find the second line (which is highlighted) in virtually any Blender script because it gives us access to the classes and functions of the Blender Python API. Likewise, the third line gives us access to the specific submodules of the Blender module that we will need in this script. We could access them as members of the <code class="literal">Blender</code> module of course (for example, <code class="literal">Blender.Scene</code>), but importing them explicitly saves some typing and enhances readability.</p><p>The next two lines first create a <code class="literal">Text3d</code> object and assign that to the variable <code class="literal">hello</code>. The <code class="literal">Text3d</code> object will have the name <code class="literal">HelloWorld</code> in Blender so users can refer to this object by this name. Also this is the name that will be visible in the Outliner window and in the lower-left corner if the object is selected. If there already exists an object of the same type with this name, Blender adds a numerical suffix to the name to make it unique. <code class="literal"/>For example, <code class="literal">HelloWorld</code> might become <code class="literal">HelloWord.001</code> if we run the scripts twice.</p><p>By default, a newly created <code class="literal">Text3d</code> object will contain the text <strong>Text</strong> so we change that to <strong>Hello</strong> <strong>World!</strong> with <code class="literal">setText()</code> method.</p><p>A newly created Blender object is not visible by default, we have to associate that with a <a class="indexterm" id="id29"/>
<code class="literal">Scene</code> so the next few lines retrieve a reference to the current scene and add the <code class="literal">Text3d</code> object to it. The <code class="literal">Text3d</code> object is not added directly to the scene but the <code class="literal">scene.objects.new()</code> method embeds the <code class="literal">Text3d</code> object in a generic Blender object and returns a reference to the latter. The generic Blender object holds information common to all objects, such as position, whereas the <code class="literal">Text3d</code> object holds specific information, such as the text font.</p><p>Finally, we tell the window manager to refresh any window that needs a refresh due to the addition of a new object.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec11"/>Integrating a script in Blender's menus</h2></div></div></div><a class="indexterm" id="id30"/><a class="indexterm" id="id31"/><p>Your own script doesn't have to be a second class citizen. It can be made part of Blender on par with any of the bundled scripts that come with Blender. It can be added to the <strong>Add</strong> menu present in the header at the top of the View3D window. </p><div><div><h3 class="title"><a id="note02"/>Note</h3><p>Actually, the <strong>Add</strong> menu is present in the header at the bottom of the user preferences window but as this window is situated above the View3D window, and is by default minimized to just the header, it looks as if it's a header at the top of the View3D window. Many users are so accustomed to it that they see it as part of the View3D window. </p></div></div><p>It may supply information to Blender's help system just like any other script. The following few lines of code make that possible:</p><div><pre class="programlisting">"""
Name: 'HelloWorld'
Blender: 249
Group: 'AddMesh'
Tip: 'Create a Hello World text object'
"""</pre></div><p>We start the script with a standalone string containing several lines.</p><div><div><h3 class="title"><a id="note03"/>Note</h3><p>Each line starts with a label followed by a colon and a value. The colon should follow the label immediately. There should not be any intervening space, otherwise our script will <em>not</em> show up in any menu.</p></div></div><p>The labels at the beginning of each line serve the following purpose:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Name</code> (a string) defines the name of the scripts as it appears in the menu</li><li class="listitem" style="list-style-type: disc"><code class="literal">Blender</code> (a number) defines the minimum version of Blender needed to use the script</li><li class="listitem" style="list-style-type: disc"><code class="literal">Group</code> (a string) is the submenu of the scripts menu under which this script should be grouped<a class="indexterm" id="id32"/><a class="indexterm" id="id33"/><p>If our scripts are to appear under the <strong>Add | Mesh</strong> menu in the View3D window (also accessible by pressing <em>Space</em>) this should read <code class="literal">AddMesh</code>. If it should be under a different submenu of the script's menu, it could read, for example, <code class="literal">Wizards</code> or <code class="literal">Object</code>. Besides the necessary labels the following optional labels might be added:</p></li></ul></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Version</code> (a string) is the version of the script in any format you like.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Tip</code> (a string) is the information shown in the tooltip when hovering over the menu item in the <strong>Scripts</strong> menu. If the script belongs to the group <code class="literal">AddMesh</code>, no tooltip will be shown even if we define one here.</li></ul></div><div><img alt="Integrating a script in Blender's menus" src="img/0400_01_07.jpg"/></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec12"/>Integrating a script in Blender's help system</h2></div></div></div><a class="indexterm" id="id34"/><a class="indexterm" id="id35"/><p>Blender has an integrated help system that is accessible from the <strong>Help</strong> menu at the top of the screen. It gives access to online resources and to information on registered scripts via the <strong>Scripts</strong> <strong>Help</strong> <strong>Browser</strong> entry. Once selected, it shows a collection of drop-down menus, one for each group, where you can select a script and view its help information.</p><p>If we want to enter our script in the integrated help system we need to define some additional global variables:</p><div><pre class="programlisting">__author__    = "Michel Anders (varkenvarken)"
__version__   = "1.00 2009/08/01"
__copyright__ = "(c) 2009"
__url__       = ["author's site, http://www.swineworld.org"]
__doc__       = """
A simple script to add a Blender Text object to a scene.
It takes no parameters and initializes the object to contain the
text 'Hello World'
"""</pre></div><a class="indexterm" id="id36"/><p>These variables should be self-explanatory except for the <code class="literal">__url__</code> variable—this one will take a list of strings where each string consists of a short description, a comma, and a URL. The resulting help screen will look like this:</p><div><img alt="Integrating a script in Blender's help system" src="img/0400_01_08.jpg"/></div><p>Now all that we have left to do is to test it and then place this script in an appropriate location. We can test the script by pressing <em>Alt + P</em>. If no errors are encountered, this will result in our <code class="literal">Hello</code> <code class="literal">World</code> <code class="literal">Text3d</code> object being added to the scene but the script will <em>not</em> be appended to the <strong>Add</strong> menu yet.</p><a class="indexterm" id="id37"/><p>If a script is to be added to the <strong>Add</strong> menu it has to reside in Blender's script directory. To do this, first save the script in the text buffer to a file with a meaningful name. Next, make sure that this file is located in Blender's script directory. This directory is called <code class="literal">scripts</code> and is a subdirectory of <code class="literal">.blender</code>, Blender's configuration directory. It is either located in Blender's installation directory or (on Windows) in the <code class="literal">Application</code> <code class="literal">Data</code> directory. The easiest way to find ours is to simply look at the <code class="literal">sys.path</code> variable again to see which listed directory ends in <code class="literal">.blender\scripts</code>.</p><a class="indexterm" id="id38"/><p>Scripts located in Blender's <code class="literal">scripts</code> directory will be automatically executed on startup, so our hello world script will be available anytime we start up Blender. If we want Blender to reexamine the script directory (so that we don't have to restart Blender to see our new addition) we can choose <strong>Scripts | Update menus</strong> in the interactive console.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec11"/>Don't get confused, stay objective</h1></div></div></div><a class="indexterm" id="id39"/><a class="indexterm" id="id40"/><p>As you may have noticed the word <strong>object</strong> is used in two different (possibly confusing) ways. In Blender almost anything is referred to as an Object. A <code class="literal">Lamp</code> for instance is an Object, but so is a <code class="literal">Cube</code> or a <code class="literal">Camera</code>. <strong>Objects</strong> are things that can be manipulated by the user and have for example a position and a rotation.</p><p>In fact, things are a little bit more structured (or complicated, as some people say): any <code class="literal">Blender</code> object contains a reference to a more specific object called the <strong>data</strong> <strong>block</strong><a class="indexterm" id="id41"/>. When you add a <code class="literal">Cube</code> object to an empty scene you will have a generic object at some location. That object will be called <code class="literal">Cube</code> and will contain a reference to another object, a <code class="literal">Mesh</code>. This <code class="literal">Mesh</code> object is called <code class="literal">Cube</code> by default as well but this is fine as the namespaces of different kind of objects are separate.</p><p>This separation of properties common to all objects (such as position) and properties specific to a single type of object (such as the energy of a <code class="literal">Lamp</code> or the vertices of a <code class="literal">Mesh</code>) is a logical way to order sets of properties. It also allows for the instantiation of many copies of an object without consuming a lot of memory; we can have more than one object that points to the same <code class="literal">Mesh</code> object for example. (The way to achieve that is to create a <strong>linked</strong> <strong>duplicate</strong>, using <em>Alt + D</em>.) The following diagram might help to grasp the concept:</p><div><img alt="Don't get confused, stay objective" src="img/0400_01_09.jpg"/></div><p>Another way the word <strong>object</strong> is used is in the Python sense. Here we mean an instance of a class. The Blender API is object-oriented and almost every conceivable piece of structured data is represented by an object instanced from a class. Even fairly abstract concepts such as an <strong>Action</strong> or an <strong>IPO</strong> (abstract in the sense that they do not have a position somewhere in your scene) are defined as classes.</p><p>How we refer to the Blender or to the Python sense of the word object in this book will mostly be obvious from the context if you keep in mind this distinction. But if not, we tend to write the Blender sense as <em>Object</em> and the Python sense as <em>object</em> or <em>object instance</em>.</p></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec12"/>Adding different types of object from a script</h1></div></div></div><a class="indexterm" id="id42"/><p>Adding other types of objects is, in many cases, just as straightforward as adding our text object. If we want our scene to be populated in a way that enabled us to render it, we would have to add a camera and a lamp to make things visible. Adding a camera to the same scene could be done like this (assuming we still have a reference to our active scene in the <code class="literal">scn</code> variable):</p><div><pre class="programlisting">from Blender import Camera
cam = Camera.New()         # creates new camera data
ob = scn.objects.new(cam)  # adds a new camera object
scn.setCurrentCamera(ob)    # makes this camera active</pre></div><p>Note that the <code class="literal">Camera</code> object<a class="indexterm" id="id43"/> is again different from the actual camera data. A <code class="literal">Camera</code> object holds camera-specific data, such as viewing angle, and a Blender object holds data common to all objects, notably its position and rotation. We will encounter cameras again later and see how we can point them and set the view angle.</p><p>Lamps follow pretty much the same pattern:</p><div><pre class="programlisting">from Blender import Lamp
lamp = Lamp.New()            # create a new lamp
ob = scn.objects.new(lamp)</pre></div><p>Again, the <code class="literal">Lamp</code> object<a class="indexterm" id="id44"/> holds lamp-specific data such as its type (for example, spot or area ) or its energy while the Blender object that encapsulates it defines its position and rotation.</p><p>This pattern is similar for a <code class="literal">Mesh</code> object but the situation is subtly different here because a mesh is a conglomerate of vertices, edges, and faces among other properties.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec13"/>Adding a mesh object</h2></div></div></div><a class="indexterm" id="id45"/><p>Like a <code class="literal">Lamp</code> or a <code class="literal">Camera</code>, a <code class="literal">Mesh</code> is a Blender object that encapsulates another object in this case, a <code class="literal">Blender.Mesh</code> object<a class="indexterm" id="id46"/>. But unlike <code class="literal">Blender.Lamp</code> or <code class="literal">Blender.Camera</code> objects it does not stop there. A <code class="literal">Blender.Mesh</code> object itself may contain many other objects. These objects are vertices, edges, and faces. Each of these may have a number of associated properties. They may be selected or hidden and may have a surface normal or an associated UV-texture.</p><p>Beside's any associated properties, a single vertex is basically a point in 3D space. In a <code class="literal">Blender.Mesh</code> object any number of vertices are organized in a list of <code class="literal">Blender.Mesh.MVert</code> objects<a class="indexterm" id="id47"/>. Given a <code class="literal">Mesh</code> object <code class="literal">me</code>, this list may be accessed as <code class="literal">me.verts</code>. An <strong>edge</strong><a class="indexterm" id="id48"/> is a line connecting two vertices in Blender represented by a <code class="literal">Blender.Mesh.MEdge</code> object<a class="indexterm" id="id49"/>. Its main properties are <code class="literal">v1</code> and <code class="literal">v2</code>, which are references to <code class="literal">MVert</code> objects. The list of edges in a <code class="literal">Mesh</code> object can be accessed as <code class="literal">me.edges</code>.</p><p>A <code class="literal">MFace</code> object<a class="indexterm" id="id50"/> is a like an edge, basically a list of references to the vertices that define it. If we have a <code class="literal">MFace</code> object <code class="literal">face</code>, this list may be accessed as <code class="literal">face.verts.</code>
</p><div><img alt="Adding a mesh object" src="img/0400_01_10.jpg"/></div><p>This jumble of objects containing other objects may be confusing, so keep the previous diagram in mind and let's look at some example code to clarify things. We will define a cube. A cube consists of eight vertices connected by twelve edges. The eight vertices also define the six sides (or faces) of the cube.</p><div><pre class="programlisting">from Blender import Mesh,Scene

corners=[ (-1,-1,-1), (1,-1,-1), (1,1,-1), (-1,1,-1),(-1,-1, 1), (1,-1, 1), (1,1, 1), (-1,1, 1) ]
sides= [ (0,1,2,3), (4,5,6,7), (0,1,5,4), (1,2,6,5), (2,3,7,6), (3,0,4,7) ]

<strong>me = Mesh.New('Cube')</strong>
me.verts.extend(corners)
me.faces.extend(sides)
scn = Scene.GetCurrent()
ob = scn.objects.new(me, 'Cube')
Window.RedrawAll()</pre></div><a class="indexterm" id="id51"/><p>We start by defining a list of corners. Each of the eight corners is represented by a tuple of three numbers, its x, y, and z coordinates. Next we define a list of tuples defining the faces of the cube. The sides of a cube are squares so each tuple holds four integers—each integer is an index to the list of corners. It is important to get the order of these indices right: if we would list the first side as (0,1,3,2) we would get a twisted or a bow-tie face.</p><p>Now we can define a <code class="literal">Mesh</code> object and name it <code class="literal">Cube</code> (the highlighted part in the preceding code). As noted earlier, the vertices of a <code class="literal">Mesh</code> object are accessible as a list named <code class="literal">verts</code>. It has an <code class="literal">extend()</code> method that may take a list of tuples representing vertex positions to define additional <code class="literal">MVert</code> objects in our <code class="literal">Mesh</code>.</p><p>Likewise, we can add extra faces to the list of faces of a <code class="literal">Mesh</code> object by calling the <code class="literal">extend()</code> method<a class="indexterm" id="id52"/> of <code class="literal">faces</code> with a list of tuples. Because all edges of a cube are edges of the faces there is no need to add any edges separately. This is done automatically when we <code class="literal">extend()</code> the list of faces.</p><p>The <code class="literal">Mesh</code> object that we have defined so far can now be embedded in a Blender object that can be added to the active scene. Note that it is perfectly acceptable to have a <code class="literal">Mesh</code> object and a Blender Object with the same name (<code class="literal">Cube</code> in this case) because different kind of objects in Blender have separate namespaces. In the Blender GUI, names are always prefixed with a two letter prefix to distinguish them. (for example, LA for a lamp, ME for a mesh, or OB for a Blender object)</p><p>When creating <code class="literal">Mesh</code> objects a great deal of attention is needed to get all the vertices, edges, and faces added and correctly numbered. This is just the tip of the iceberg when creating meshes. In <a class="link" href="ch02.html" title="Chapter 2. Creating and Editing Objects">Chapter 2</a>, 
<em>Creating and Editing Objects</em>, we will see what hides underwater.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec14"/>Distributing scripts</h2></div></div></div><a class="indexterm" id="id53"/><p>In the previous sections, we saw that in order to integrate our script in Blender's menu system and help system we had to place the script in the <code class="literal">.blender\scripts</code> directory. A fully integrated script can be a big advantage, but this method has a clear drawback: the person who wants to use this script has to put it in the correct directory. This might be a problem if this person does not know how to locate this directory or does not have the permission to place scripts in that directory. That last problem may be overcome by setting an alternative script directory in the <code class="literal">User Preferences</code>, but not everybody might be that tech oriented.</p><p>A viable alternative is distributing a script as a text within a .<code class="literal">blend</code> file. A .<code class="literal">blend</code> file can be saved with the script clearly visible in the main window and one of the first comment lines of the script might read <code class="literal">Press</code> <code class="literal">ALT-P</code> <code class="literal">to</code> <code class="literal">start</code> <code class="literal">this</code> <code class="literal">script</code>. This way, the script can be used by anybody who knows how to open a .<code class="literal">blend</code> file.</p><p>An additional advantage is that it is easy to bundle extra resources in the same <code class="literal">.blend</code> file. For example, a script might use certain materials or textures or you might want to include sample output from your script. The only thing that is very difficult to do is distribute Python modules this way. You can use the <code class="literal">import</code> statement to access other text files but this may pose problems (see <a class="link" href="apb.html" title="Appendix B. Common Pitfalls">Appendix B</a>). If you have a lot of code and it is organized in modules, you and your users are probably still better off if you distribute it as a ZIP file with clear instructions on where to unpack this ZIP file.</p><p>For Pynodes (or dynamic nodes, see <a class="link" href="ch07.html" title="Chapter 7. Creating Custom Shaders and Textures with Pynodes">Chapter 7</a>) you don't have a choice. <strong>Pynodes</strong> can refer to only the Python code contained in text files within a <code class="literal">.blend</code> file. This is not really a limitation though as these Pynodes are an integral part of a material, and Blender materials can be distributed only within a <code class="literal">.blend</code> file. When these materials are linked to or appended their associated nodes and any texts associated with Pynodes are linked to or appended as well, completely hiding from the end user the way a material is actually implemented.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec15"/>The Blender API</h2></div></div></div><a class="indexterm" id="id54"/><p>When developing Python programs in Blender it is important to understand what functionality is provided by the API and even more so, what not. The API basically exposes all data and provides functions for manipulating that data. Additionally, the API provides the developer with functions to draw on the screen and to interact with the user interface and windowing system. What the Blender API does not provide is object-specific functionality besides setting simple properties, especially lacking any functions to manipulate meshes on the level of vertices, edges, or faces other than adding or removing them.</p><a class="indexterm" id="id55"/><p>This means that very high-level or complex tasks such as adding a subsurface modifier to a <code class="literal">Mesh</code> object or displaying a file selector dialog are as simple as writing a single line of code, while functions as essential and seemingly simple as subdividing an edge or selecting an edge loop are not available. That doesn't mean these tasks cannot be accomplished, but we will have to code them ourselves. So many examples in this book will refer to a module called <code class="literal">Tools</code> that we will develop in the next chapters and that will contain useful tools from extruding faces to bridging face loops. Where appropriate and interesting we will highlight the code in this module as well but mainly it is a device to squirrel away any code that might detract us from our goals.</p><p>The following sections give a short and very high-level overview of what is available in the Blender API. Many modules and utilities will feature prominently in the next chapters as we will develop practical examples. This overview is meant as a way to help you get started if you want to find out about some functionality and do not know where to look first. It is nowhere near a full documentation of the Blender API. For that, check the most recent version of the API documentation online. You can find the link in the <a class="link" href="apa.html" title="Appendix A. Links and Resources">Appendix A </a>
<em>Links and Resources</em>.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec16"/>The Blender module</h2></div></div></div><a class="indexterm" id="id56"/><p>The Blender module serves as a container for most other modules and provides functionality to access system information and perform general tasks.</p><p>For example, information such as the Blender version that you are using can be retrieved with the <code class="literal">Get()</code> function:</p><div><pre class="programlisting">import Blender
version = Blender.Get('version')</pre></div><p>Incorporating all externally referred files in a <code class="literal">.blend</code> file (called <strong>packing</strong> in Blender) or saving your current Blender session to a <code class="literal">.blend</code> file are other examples of functionality implemented in the top-level Blender module:</p><div><pre class="programlisting">import Blender
Blender.PackAll()
Blender.Save('myfile.blend')</pre></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec17"/>Blender objects</h2></div></div></div><a class="indexterm" id="id57"/><p>Each Blender object type (<code class="literal">Object</code>, <code class="literal">Mesh</code>, <code class="literal">Armature</code>, <code class="literal">Lamp</code>, <code class="literal">Scene</code>, and so on) has an associated module which is a submodule of the top-level <code class="literal">Blender</code> module. Each module supplies functions to create new objects and find objects of a given type by name. Each module also defines a class with the same name that implements the functionality associated with the Blender object.</p><p>Note that in Blender, not only the things directly visible in your scene, such as meshes, lamps, or cameras are objects, but also materials, textures, particle systems, and even IPOs, actions, worlds, and scenes.</p><p>Many other data items in Blender are not Objects in the Blender sense (you cannot append them from another <code class="literal">.blend</code> file or move them about in your scene) but are objects in the Python sense. For example, vertices, edges, and faces within a mesh are implemented as classes: <code class="literal">Blender.Mesh.MVert</code>, <code class="literal">Blender.Mesh.MEdge</code>, and <code class="literal">Blender.Mesh.MFace</code> respectively.</p><p>Many modules also have submodules of their own; for example the <code class="literal">Blender.Scene</code><a class="indexterm" id="id58"/> module provides access to the rendering context by way of the <code class="literal">Blender.Scene.Render</code> module<a class="indexterm" id="id59"/>. Among other things, this module defines a <code class="literal">RenderData</code> class<a class="indexterm" id="id60"/> that allows you to render a still image or animation.</p><p>So with what we know now it is possible to draw two slightly different family trees of Blender objects. </p><p>The first one illustrates what kind of Blender objects may be contained within or referred to by another Blender object where we limit ourselves to the less abstract objects:</p><div><img alt="Blender objects" src="img/0400_01_tree1.jpg"/></div><a class="indexterm" id="id61"/><p>Of course, the diagram above is greatly simplified as we left out some less relevant objects and as it only illustrates a single kind of relationship. There are of course many more types of relationship in a scene, such as parent-child relationships or constraints.</p><p>We may contrast the previous diagram with the one that shows in which module a type of object (a class) is defined:</p><div><img alt="Blender objects" src="img/0400_01_tree2.jpg"/></div><a class="indexterm" id="id62"/><p>The differences are quite noticeable and are important to keep in mind, especially when looking for specific information in the Blender API documentation. Don't expect to find information on a <code class="literal">Curve</code> object in the documentation for the <code class="literal">Blender.Object</code> module<a class="indexterm" id="id63"/> because a Blender Curve is a specific Blender Object; the <code class="literal">Curve</code> class<a class="indexterm" id="id64"/> is defined and documented in the <code class="literal">Blender.Curve</code> module. In general you can expect the documentation of a class to be in the module of same name.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec18"/>The bpy module</h2></div></div></div><a class="indexterm" id="id65"/><p>Besides the Blender module, there is another top-level module called <code class="literal">bpy</code> that provides a unified way to access data. It is considered experimental, but it is stable and might be used as a more intuitive way of accessing objects. For example, if we want to access an object called <code class="literal">MyObject</code> we normally would do something like this:</p><div><pre class="programlisting">import Blender
ob = Blender.Object.Get(name='MyObject')</pre></div><p>With the <code class="literal">bpy</code> module we might rephrase this:</p><div><pre class="programlisting">import bpy
ob = bpy.data.objects['MyObject']</pre></div><p>Likewise, to get access to the active <code class="literal">scene</code> object we might write this:</p><div><pre class="programlisting">import Blender
scene = Blender.Scene.GetCurrent()</pre></div><p>Which can be written in an alternative way:</p><div><pre class="programlisting">import bpy
scene = bpy.data.scenes.active</pre></div><a class="indexterm" id="id66"/><p>Which one to prefer is a matter of taste. The <code class="literal">bpy</code> module will be the only way to access data in the upcoming Blender 2.5 but the changes in Blender 2.5 go deeper than just this data access so don't be fooled by the superficial similarity of the module name!</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec19"/>Drawing on the screen</h2></div></div></div><p>Access to Blender's windowing system is provided by the <code class="literal">Blender.Draw</code> module<a class="indexterm" id="id67"/>. Here you will find classes and functions to define buttons and pop-up menus and ways to interact with the user. The types of graphical elements that you can display using the <code class="literal">Draw</code> module are limited to the commonly used ones and customization is not an option.</p><p>More advanced functions are provided in the <code class="literal">Blender.BGL</code> module<a class="indexterm" id="id68"/> that gives you access to virtually all OpenGL functions and constants, allowing you to draw almost anything on screen and to let the user interact in many different ways.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec20"/>Utilities</h2></div></div></div><p>Finally, there are a number of modules that encapsulate various functionality that do not fit in any of the previous categories:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Blender.Library</code>: <a class="indexterm" id="id69"/>Blender allows you to append (that is, import) or link (refer to) objects in another <code class="literal">.blend</code> file. Another way to look at this is that a <code class="literal">.blend</code> file can act as a library where you can store your assets. And because almost anything is an object in Blender, almost any asset can be stored in such a library, be it models, lamps, textures, or even complete scenes. The <code class="literal">Blender.Library</code> module provides script authors the means to access those libraries.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Blender.Mathutils</code> and <code class="literal">Blender.Geometry</code>: <a class="indexterm" id="id70"/><a class="indexterm" id="id71"/>These modules contain among other things, the <code class="literal">Vector</code> and <code class="literal">Matrix</code> classes with associated functions to apply all sorts of vector algebra to Blender objects. With the functions provided in these modules you will be able to rotate or shear your object's co-ordinates or calculate the angle between two vectors. Many more convenience functions are provided and these will make many surprise appearances in the examples in this book. Don't worry, we will provide explanations where necessary for people not so at home with vector math.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Blender.Noise</code>: <a class="indexterm" id="id72"/>Noise is used in generating all the (apparently) random patterns that form the basis of many of the procedural textures in Blender. This module gives access to the same routines that provide the noise for those textures. This might not only be useful in generating your own textures but might for instance be used in the random placement of objects or implementing a slightly shaky camera path to add realism to your animation.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Blender.Registry</code>: <a class="indexterm" id="id73"/>The data inside scripts, whether local or global, is not stored once a script exits. This can be very inconvenient, for example if you want to save the user preferences for your custom script. The <code class="literal">Blender.Registry</code> module provides ways to store and retrieve persistent data. It does not, however, provide any means to store this data on disk, so the persistence is only for the duration of a Blender session.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Blender.Sys</code>: <a class="indexterm" id="id74"/>To quote this module's documentation:<p><em>This module provides a minimal set of helper functions and data. Its purpose is to avoid the need for the standard Python module <code class="literal">os</code> in special <code class="literal">os.path</code>, though it is only meant for the simplest cases.</em></p><p>As we argued earlier, it is generally advisable to install a full Python distribution which among other things includes the <code class="literal">os</code> and <code class="literal">os.path</code> modules that give you access to a far wider range of functionality. Therefore, we will not use the <code class="literal">Blender.sys</code> module in this book.</p></li><li class="listitem" style="list-style-type: disc"><code class="literal">Blender.Types</code>: <a class="indexterm" id="id75"/>This module provides constants that can be used for the type checking of objects. Python's built-in function <code class="literal">type()</code> returns the type of its argument. This makes it quite easy to check whether an object has a given type when compared to one of the constants in this module.<p>If we would want to make sure an Object is a <code class="literal">Curve</code> object we could, for example, do it like this:</p><div><pre class="programlisting">…
if type(someobject) == Blender.Types.CurveType :
… do things only allowed for Curve objects ...</pre></div></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec13"/>Summary</h1></div></div></div><p>In this chapter, we have seen how to extend Blender with a full Python distribution and familiarized ourselves with the built-in editor. This enabled us to write scripts that, although simple, were fully integrated in Blenders scripting menu and help system. We covered many subjects in detail including:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">What can and cannot be accomplished with Python in Blender</li><li class="listitem" style="list-style-type: disc">How to install a full Python distribution</li><li class="listitem" style="list-style-type: disc">How to use to the built-in editor</li><li class="listitem" style="list-style-type: disc">How to run a Python script</li><li class="listitem" style="list-style-type: disc">How to explore built-in modules</li><li class="listitem" style="list-style-type: disc">How to write a simple script that adds an object to a Blender scene</li><li class="listitem" style="list-style-type: disc">How to register a script in the Blender scripts menu</li><li class="listitem" style="list-style-type: disc">How to document your script in a user-friendly way</li><li class="listitem" style="list-style-type: disc">How to distribute a script</li></ul></div><p>In the next chapter, we take this knowledge a step further to create and edit complex objects and we will see how to define a graphical user interface.</p></div></body></html>