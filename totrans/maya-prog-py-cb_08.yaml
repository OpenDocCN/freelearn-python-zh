- en: Chapter 8. Working with File Input/Output
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll be looking at ways to get custom data in and out of
    Maya via scripting:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the fileDialog2 command to navigate the file system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading text files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing text files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing binary data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading binary data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading multiple types of files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although Maya is an incredibly powerful tool, it's almost always just one step
    in a larger toolchain. Whether you're using Maya to create prerendered animation
    for film and video or creating assets for use in real-time applications, you'll
    generally always need to interface Maya or the content you create within it, with
    other applications. Very often, this takes the form of either reading or writing
    data of a specific format.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll be looking at how to work with custom data formats, both
    text-based and binary, and to both read and write data.
  prefs: []
  type: TYPE_NORMAL
- en: Using the fileDialog2 command to navigate the file system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Loading and saving files will almost always require prompting the user for a
    file location. In this example, we'll look at how to do that. We'll also see how
    to work with directories, including creating new ones.
  prefs: []
  type: TYPE_NORMAL
- en: We'll create a script that will allow the user to browse the files in a `customData`
    folder within the current project directory. If that folder doesn't exist, it
    will be created the first time the script is run.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new file and add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You'll be presented with a file browser dialog. And, while the dialog won't
    actually do anything just yet, if you check your project directory, you'll find
    that it now contains a folder named `customData`.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first thing to note about this script is that we add an additional import
    statement to the start of the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The os library (short for "operating system") offers a variety of functionality
    related to the operating system of the host machine, including the ability to
    work with directories. We'll be using both to check to see whether a directory
    exists and to create it if it doesn't exist. More on this will be explained later.
  prefs: []
  type: TYPE_NORMAL
- en: For this script, we'll want to start by finding out what the current project
    directory is. For that, we can use the `internalVar` command. The `internalVar`
    command can be used to get access to various directories related to the current
    user's environment. It cannot be used to set any of those directories, only to
    query them. However, note that we don't actually use it in the query mode (Maya's
    commands aren't always the most consistent). Instead, we set the value of the
    flag we want the value of to true.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we''re asking for the `userWorkspaceDir`, which will provide
    us with the current project directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we want to test to see if there''s the `customData` folder within the
    current workspace. To do this, we''ll start by creating the full path to that
    directory (if it exists) by adding "customData" to the value that `internalVar`
    returned. We *could* do it with string manipulation, but that gets a bit tricky,
    since different platforms can use different characters to indicate separations
    between directories. Linux-based platforms (including Macintosh) use "/", whereas
    Windows machines use "\". A safer (and therefore better) way to go about it is
    to use Python''s `os.path.join` method, which is guaranteed to be safe, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have the full path to the `customData` folder, but it might not actually
    exist. We can use another function from `os.path`, `os.path.exists`, to check
    that, and to create it if it doesn''t:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If we find that the path, in fact, does not exist, we use `os.makedirs` to
    create it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we can finally invoke the `fileDialog2` command to present the
    user with a file browser dialog. In order to make sure that it starts out in the
    `customData` directory, we set the `startingDirectory` flag to our `newDir` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note that we use `fileDialog2`, which might look a bit odd. There is also a
    `fileDialog` command, but it's deprecated (along with the `fileBrowserDialog`
    command). As a result, we're left needing to use the somewhat awkwardly named
    `fileDialog2`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `fileDialog2` command has a number of other options that we'll see in later
    examples. The `internalVar` command also has a number of additional locations
    that it can provide. One that is often useful is the `userScriptDir` option, which
    will provide the user's script directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you wanted to get a list of all of the scripts currently in the user''s
    script directory, for example, you could use the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `os.listdir` command will provide an array of all the files in a given directory.
    In this case, we might want to create GUI with a button for each script, providing
    an easy way for users to select and run scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Reading text files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we'll be reading a text file and using the contents to create
    some geometry in our scene.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to do any kind of file input/output, the first thing you''ll need
    to do is to understand the file format that you''re wanting to read (or create).
    In both this example and the one involving writing to text files, we''ll be using
    an example file format—the "foo" file. "Foo" files are text-based files, and each
    line represents a geometric primitive of a given type, at a given location. The
    type of geometric primitive is represented by a three-letter string, with "spr"
    meaning a sphere and "cub" meaning a cube. The type string is then followed by
    three numbers representing the X, Y, and Z position of the item. So, an example
    `.foo` file might look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Although this is certainly not a particularly useful format, it shares similarities
    with many common text-based formats. The OBJ format, for example, is a common
    standard for 3D models that uses a similar approach—each line consists of an identifier
    for the type of information it holds, followed by details on that entry. For example,
    a line indicating that there is a vertex located at 2, 3, and 4 would look like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: So, our "foo" files, while intentionally very simple, will be read and processed
    in much the same way as many *real* file formats.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you run the script for this example, make sure that you''ve created
    a `.foo` file. To do that, create a new text file and add some number of lines
    that:'
  prefs: []
  type: TYPE_NORMAL
- en: Begin with either "spr" (for sphere) or "cub" (for cube)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are followed with three numbers (for X, Y, and Z positions), each separated
    by a space
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be sure to save the file as a `.foo` file, rather than `.txt`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new file and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Run the file, and you will be presented with a file dialog that will let you
    find a `.foo` file. Once you specify a file with valid FOO file data, you should
    see some number of spheres and cubes created.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/4657_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first thing we do in the script is to invoke the `fileDialog2` command
    in order to let the user specify a file. We set the `fileMode` flag to 1 to indicate
    that we want to read (rather than write) a file. We also make use of the `fileFilter`
    flag in order to point the user at our custom file format. This is totally optional,
    but it can be a nice way to prevent the user from giving you the wrong kind of
    data. To do that, we''ll want to provide Maya with two things:'
  prefs: []
  type: TYPE_NORMAL
- en: A short description of the file type to show the user, and
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One or more file extensions, with a wildcard character ("*")
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So in this case, we''ll want to limit the user to "FOO files", and we''ll identify
    those as anything that ends in either `.foo` or `.fo`. The final value of the
    string to pass in looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we could also allow the user to open other kinds of files as well,
    by separating the strings for each with a double semicolon. Let''s say that we
    wanted to allow the user to open text (`.txt`) files as well. For that, our call
    to `fileDialog2` would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If you allow the user to open files of more than one type, each type will be
    available in the dropdown in the bottom of the file dialog. By selecting an option
    from the dropdown, the user can change which types of files the dialog will accept.
    Now that we've covered specifying the file type, let's go back to our regularly
    scheduled example.
  prefs: []
  type: TYPE_NORMAL
- en: 'We store the output of the `fileDialog` to a variable. We also check to make
    sure that the variable is not None before proceeding. This way, we''ll ensure
    that we don''t proceed with the script if the user has clicked on the "cancel"
    button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we''re ready to actually open the file. To do it, we use Python''s `open`
    command, with the first argument being the full path to the file we want to open,
    and the second argument indicating the mode to open the file in, with `"r"` meaning
    "read":'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note that `filePath` is an array, so we'll need to feed in the first element
    into the open command. The return value of open, which we store in our `fileRef`
    variable, is a reference to the file that we can use to read in data.
  prefs: []
  type: TYPE_NORMAL
- en: 'For most types of text-based files (with FOO files being no exception), we''ll
    want to read the file in line by line. We''ll start by reading a single line from
    our file reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we''ve done that, we want to:'
  prefs: []
  type: TYPE_NORMAL
- en: Process the information in the line we just read
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Read the next line from the file
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Continue until we've read the entire file
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'That''s easily done with a while loop. The processing will be handled by a
    separate function, which we''ll get to next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we get to the end of the file, our line variable will be empty, and the
    while loop will terminate. The last thing we do is a bit of housekeeping, that
    is, we close the reference to the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s take a closer look at how we process the data, in our `processFooLine`
    function. We start off by breaking the line up into parts, using Python''s `split`
    function. That will take the input string and break it up into an array of strings,
    separated (by default) based on whitespaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Because our FOO file specification states that each line should be a short
    string, followed by three numbers, we throw an error if our parts array has fewer
    than four entries. If it does have at least four, we convert the second, third,
    and fourth entries to floats and store them into variables for the *x*, *y*, and
    *z* position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we create the object, either a sphere or a cube based on the first entry
    in the parts array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we move the object we just created to the position indicated in our
    `x`, `y`, and `z` variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although the FOO format specification is intentionally simplistic, we could
    easily extend it to store more information or possibly optional information. For
    example, we might also have an optional fifth entry to indicate the size of the
    object to be created (for example, face width for cubes and radius for spheres).
    If you would like to see what a format that is superficially similar to FOO files,
    but more useful, looks like, I encourage you to take a look at the OBJ file format.
    Not only is it widely used in 3D, but it's also a relatively simple format to
    understand and as such is a great introduction to file parsing.
  prefs: []
  type: TYPE_NORMAL
- en: Writing text files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous example, we looked at how to read a custom data file format
    and use it to create geometry in a scene. In this example, we'll do the inverse,
    in that we'll examine our scene for polygonal cubes and NURBS spheres, and write
    the position of each one we find out to a new FOO file. In the process, we'll
    see how to write data to custom text-based formats.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before running this example, make sure that you have a scene with some number
    of (NURBS) spheres and polygonal cubes in it. Make sure that you create the cubes
    and spheres with construction history enabled, otherwise our script won't be able
    to correctly identify the geometry.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new file and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We start off by prompting the user to specify a file. As in the file reading
    example, we set the `fileFilter` flag so that the dialog is limited to .foo files.
    This time, though, we set the `fileMode` flag to 0 to indicate that we want to
    write a file (instead of a value of 1, indicating reading):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'If the result of the `fileDialog2` command is empty (indicating that the user
    canceled), we stop. Otherwise, we continue with the script and open the specified
    file for writing. Again, note that the `fileDialog2` command returned an array,
    meaning that we need to pass in its first entry to the open command. We also set
    the second argument to `"w"`, indicating that we want to write to the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Next, we need to find all of the cubes and spheres in our scene. To do that,
    we start off by getting all of the transform nodes in the scene.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: For each object, we want to find out if it's a sphere or a cube. One way to
    do it is to examine the construction history of the object and see if there's
    a `makeNurbSphere` or `polyCube` node. To keep things nice and neat, we'll wrap
    that in a separate function, `checkHistory`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the history for a given object, we can use the `listHistory` command,
    which will give us the construction history as an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we''ve done that, we''re ready to run through the history and see if we
    can find the geometry that we''re looking for. But first, we set up a variable
    to hold the geometry type and initialize it to an empty string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: If the object in question *is* one of the types we're looking for, it will have
    either the `makeNurbSphere` or `polyCube` node in its history. However, in either
    case, the node will have a number at the end of its name. So, we'll need to use
    Python's `startswith` command to perform the check, instead of just testing for
    direct equality.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we find either of the geometry creation nodes we''re looking for, we''ll
    set our `geoType` string to the appropriate abbreviation (based on the FOO file
    format specification):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we return the `geoType` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The upshot of all that is that we'll have either "spr" or "cub" for the objects
    that we want to export, and an empty string for everything else. With this, we
    can turn our attention back to our main function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Armed with out `checkHistory` function, we''re now ready to loop through all
    of the objects in the scene, testing each one to see if it''s the geometry we''re
    interested in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: If the value returned from `checkHistory` is *not* an empty string, we know
    that we have something that we want to write out to our file. We already know
    the geometry type, but we still need to get the world-space position. For that,
    we use the `xform` command, in query mode.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we''re finally ready to write our data out to our file. We''ll want to
    build up a string with the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll start by creating a string from the position we received from `xform`.
    The position starts out as an array of floating-point numbers, which we''ll want
    to convert into a single string. This means that we need to do two things:'
  prefs: []
  type: TYPE_NORMAL
- en: Convert the numbers to strings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Join the strings together into a single string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If we have an array of strings, we can join them together using Python''s `join`
    command. The syntax for that is a bit odd, but it''s easy enough to use; we start
    with a string that holds whatever it is that we would like to use as a separator.
    In this case (as in most cases), we''ll want to use a space. We then call join
    on that string, passing in the list of elements that we want to join. So, if the
    position array contained strings, we could do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'However, it''s not quite that easy because the position array contains floating-point
    values. So, before we can run join, we need to first convert the numerical values
    to strings. If that''s all we want to do, we could do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we use Python's `map` function to apply the first argument
    (the `str` or string function) to each element of the second (the position array).
    That translates the position array into an array of strings, which can then be
    passed to the join function.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we may want more control over the formatting of our floats, which
    brings us to the line that we''re actually using, namely:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This is a bit similar to the map-based example, in that we apply a function
    to the position array before passing the contents into the join function. However,
    in this case, we use the `format` function, which allows us more control over
    the specifics of how floats are formatted. In this case, we're limiting the precision
    of the values to three decimal places.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we have the full position of the object at hand as a string.
    To finish it off, we need to add the geometry type identifier (as specified in
    our FOO file format spec). We'll also want to add a newline (`\n`) character at
    the end, to ensure that each piece of geometry has a separate line for its data.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that if you open the created file in notepad on a Windows machine, you'll
    see that all of your data appear as a single line. That's because unix-like systems
    (including Mac) use `\n` as the newline character, whereas Windows uses `\r\n`.
    The `\r` is the carriage return character, whereas `\n` is the newline character.
    Using both is a byproduct of the old days when typewriters would perform two actions
    to move to the next line—move the paper all the way to the right (`\r`) and move
    it up (`\n`). If you're working on Windows, you might want to add `\r\n` instead
    of just `\n`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This gives us the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we''re finally ready to write the data to our file. That''s easily done
    with a call to `write()` on our file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we''ve finished our loop through all the objects and saved out all our
    data, we finish off by closing the file reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The example presented in this section may seem a bit artificial, but exporting
    positional data is a fairly common need. Very often, it can be easier for your
    art team to use Maya to position objects that are later used in some programmatic
    way, such as (in the case of games) spawn points or item pickup locations.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we identified the objects to export by examining their construction
    history. This can work, but it's easily broken if construction history is ever
    deleted. Because deleting history is a common thing to do, it's good to have alternative
    means to identify nodes for export.
  prefs: []
  type: TYPE_NORMAL
- en: One very reliable way to go about it is to add a custom attribute to nodes that
    should be exported and to use that when looping through objects. For example,
    we might be using polygonal cubes to indicate where certain types of item pickups
    are in a game level. To better prepare for exporting the data, we could add a
    `pickupType` attribute to each cube.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could easily wrap that in a nice function to add the attribute and set its
    value, as in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code would add a keyable `pickupType` attribute to a given object
    and set its value. Note that we check to see whether the `pickupType` attribute
    exists on the node before adding it because adding an attribute that already exists
    will generate an error. To check for the attribute, we first get a list of all
    the user-defined attributes, then test to see if `pickupType` exists in that array.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we''re ready to export our data, we can use the same trick to identify
    the objects for which we want to export data. If we wanted to write out data for
    every object that possesses the `pickupType` attribute, we could do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: We start by creating a new list to hold our pickups, then grabbing all of the
    transform nodes in the scene. For each transform, we grab all of the custom attributes
    added to it and check to see whether any of them are named `pickupType`. If that's
    the case, we add the object to our list. Once we've finished with the loop, we
    return the list, for use elsewhere (perhaps to write out their locations).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For a quick overview of the FOO file format, be sure to take a look at the previous
    example regarding reading text-based data.
  prefs: []
  type: TYPE_NORMAL
- en: Writing binary data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far in this chapter, we've looked at reading and writing text-based data
    formats. This will allow you to work with many types of data (and to easily create
    your own formats), but it's only half of the picture. In this example, we'll look
    at the other half-binary formats.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we'll be writing out a binary version of our FOO file. We'll
    call such files FOB (foo, binary). As was the case with FOO files, FOB files are
    a scaled-down example of the types of things that are often encountered in real
    formats. FOB files will contain the same data we saw in FOO files, namely a list
    of object types and positions, but stored in a way common to binary formats.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most binary files consist of two main parts:'
  prefs: []
  type: TYPE_NORMAL
- en: A header, which is a fixed-size chunk that describes the nature of the rest
    of the document.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Entries that are read according to the data layout specified in the header.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the case of our FOB files, our header will contain the following:'
  prefs: []
  type: TYPE_NORMAL
- en: An integer (1 byte) that specifies how many characters are used for the geometry
    type specification per entry (our "spr" or "cub").
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An integer (1 byte) that specifies the maximum number of attributes per object
    (X, Y, and Z position at a minimum, possibly more data).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An integer (1 byte) that specifies the number of bytes per attribute.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, a specific FOB file might say that we''re using three bytes for the geometry
    type, with a maximum number of four data values (X, Y, Z position and size), each
    of which uses four bytes. This would give us a header like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: After the header, there would be some number of entries, each of which would
    consist of 19 bytes (3 for the geometry type, plus 4 * 4, or 16 bytes for the
    data).
  prefs: []
  type: TYPE_NORMAL
- en: Before you run the example, make sure that you have one or more NURBS spheres
    and/or polygonal cubes in your scene and that they were created with construction
    history enabled (the default option).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new file and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first thing to note is that we have an additional import statement at the
    start of the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The `struct` library provides functions that we'll be using to properly format
    data to write to binary. More on that in a bit. Onto the script itself...
  prefs: []
  type: TYPE_NORMAL
- en: 'First off, we ask the user to specify a file, just as we''ve done in the previous
    examples. The only difference is that we change the `fileFilter` argument a bit
    to specify files of type "FOO Binary", with a `.fob` extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We check to make sure that our `filePath` variable has an actual value (that
    the user didn''t cancel out) and stop the script if it doesn''t. We then open
    the file for writing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Note that we're using `"wb"` instead of `"w"` as an argument to the open command;
    this tells Python that we want to open the file for writing (`"w"`) in binary
    mode (`"b"`).
  prefs: []
  type: TYPE_NORMAL
- en: Now we're ready to start writing to our file. Before we can write any data though,
    we'll need to write the header. In the case of FOB files, all that is three integers—one
    to hold the number of characters for the geometry identifier, one to hold the
    number of data points per object, and one to hold the number of bytes per data
    points.
  prefs: []
  type: TYPE_NORMAL
- en: 'To actually write the data, we''ll use the pack function of the `struct` library.
    The pack function will create a sequence of bytes containing data of a given format,
    as specified in a format string. The format string is a sequence of characters,
    with each one representing the type of data that is to be written. The characters
    can be any of the following as well as many others:'
  prefs: []
  type: TYPE_NORMAL
- en: '| i | integer |'
  prefs: []
  type: TYPE_TB
- en: '| f | float |'
  prefs: []
  type: TYPE_TB
- en: '| c | char |'
  prefs: []
  type: TYPE_TB
- en: For a full list, refer to Python's documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we''ll want to store three integers, so our format string will
    need to consist of three Is, as in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We pass the format string into the `struct.pack` function, followed by the
    values we want to encode (in this case, three integers). In this case, we''ll
    want three characters for our geometry identifier length (to accommodate "spr"
    and "cub"), three points of data (the X, Y, and Z positions), and four bytes for
    each piece of data. Putting that all together gives us the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have the data packed up, we write it to our file with `write`. We wrap
    all of that in a nice function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Now that we've written our header to the file, we're ready to write the data
    for our objects. We run through the scene and find all of the spheres and cubes
    in exactly the same way that we did in the example on saving text data. For each
    object we find, we write the data to our file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Our `writeObjData` function takes the object itself, the object type string
    (as determined by our `checkHistory` function from the text output example and
    a reference to the file we're writing to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the `writeObjData` function, we start out by grabbing the position of
    the object in world space using the `xform` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: We then write the geometry type identifier (either "spr" or "cub") to the file.
    Writing text to binary files is easy—we just write the values directly. This will
    result in a single byte for each character being written to the file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we write the position data to the file, once again using the struct.pack
    function. This time, however, we want to write floating-point values, so we use
    three fs as the format string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Finally, and back in our main function, we close our file, which now contains
    both the header and all of our data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We could easily write out more than just position data for each object. If
    we wanted to write out a radius value for each sphere, we would need to do a few
    things, namely:'
  prefs: []
  type: TYPE_NORMAL
- en: Change our header to specify four values per object, instead of just three.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the format string passed in to pack to have four fs instead of three.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that even though a radius value doesn't make sense in the case of a cube,
    we would still need to write *something* in that place in order to ensure that
    each entry occupies the same number of bytes. Since binary files are generally
    processed by reading in a set number of bytes at a time, having a byte width that
    changes from entry to entry would interfere with that.
  prefs: []
  type: TYPE_NORMAL
- en: If you think that it's a limitation, you're right. Binary formats tend to be
    much stricter than text-based formats, and they are generally only worth it if
    you really need to create very compact files. In general, if you're considering
    creating a custom format, text is almost always going to be a better choice. Reserve
    binary output for situations where you find yourself having to output data to
    an existing format that happens to be binary.
  prefs: []
  type: TYPE_NORMAL
- en: Reading binary data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we'll look at how to read in binary data. We'll use our same
    example format, the "FOO binary" format, which consists of a header with three
    integers, followed by one or more entries, each of which has a string identifying
    a type of object and three or more numbers indicating its position (and possibly
    additional data).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to run this example, you'll need to have a `.fob` file at the ready.
    Creating binary files manually is a bit of a hassle, so I recommend using the
    example explained earlier to generate one for you.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new file and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Run the script, point it at a valid .fob file, and you should see some number
    of spheres and/or cubes in your scene.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this example, we''ll also be using the struct library (to unpack our data),
    so we need to make sure that we import it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'We start out by using the `fileDialog2` command to prompt the user to specify
    a .fob file and exiting the script if nothing was given:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'If we have a file to open, we open it using the `open` command, passing in
    `"rb"` for the mode (`"r"` for reading and `"b"` for binary):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have the file open, we grab all of the data at once, using the `read`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'This will result in data holding an array of all of the bytes in the file.
    Once we''ve done that, we''re ready to start parsing our content. For each bit
    of data we read, we''ll be doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Reading some number of bytes from our data variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Passing the bytes into `struct.unpack`, along with a format string indicating
    what type of data it should be interpreted as.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The first thing we''ll need to do is to read the file''s header. In the case
    of .fob files, that''s guaranteed to always be exactly 12 bytes—3 integers, at
    4 bytes each. So, we start by reading the first 12 bytes in the data array and
    passing that to `struct.unpack`. The format string we use will be "iii", indicating
    that the bytes should be interpreted as three integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the `unpack` function is an array containing the data. In this
    case, we have the number of bytes per geometric identifier, the number of data
    points per entry, and the number of bytes per data point. To make things easier
    on ourselves (and the code more readable), we store each element in its own, named
    variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we''ve done that, we do one more thing for the sake of clarity in what
    comes next—we calculate the total number of bytes per entry as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have that, we can determine the total number of entries in the file
    by dividing the total number of bytes (minus those consumed by the header) by
    the number of bytes per entry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s one more detail to take care of before we read the data; we''ll want
    to create a format string for use with `struct.unpack`. In the case of `.fob`
    files, everything after the geometric identifier string will be a float, but we
    want to make sure that we take into account the number of entries, as specified
    in the header. So, if we have three entries per object, we''ll want "fff", but
    if we have four, we would want "ffff". Python makes creating a string from a given
    number of repeated characters as easy as multiplying, which gives us the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'And with that, we''re done with the prep work and we''re ready to move on to
    actually reading our data. We start with a loop that runs for the number of entries
    that we found earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The math to calculate the indices we'll need to read isn't particularly complicated,
    but it would get confusing, so we use a couple of variables to break it out onto
    separate lines.
  prefs: []
  type: TYPE_NORMAL
- en: 'The starting byte for each entry is simply the number of entries we''ve read
    so far multiplied by the total length per entry and offset by the length of the
    header. The end index is the start plus the length of the header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Reading the geometric identifier is easy, since it''s just text, with each
    byte corresponding to a single letter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Now we set out start and end variables to new values to read the position (and
    possibly other) data. We set the start to the previous value of end. This works,
    because when reading a range of indices from a Python array, the values read start
    at the first number and read up to (but not including) the second.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ending index for the data is the start plus the total number of bytes for
    the data (`numData * bytesPerData`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'And with this, we can finally read our object''s data. We index into our data
    array and pass the result to `struct.unpack`, along with our previously created
    format string (`dataStr`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have both the geometry type (`geoType`) and the position (`pos`), we
    pass both into a function to actually create the geometry we want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The `makeObject` function is pretty straightforward—we use the `geoType` argument
    to create one of two possible objects and, if that worked, we move the created
    object to the position given in the `pos` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Till now, we''ve only read (or written) binary data of a single type, such
    as integers (for our header) and floats (for the data). The `struct.pack` and
    `struct.unpack` functions can also be used with mixed types, as long as you use
    the proper format string. For example, if we knew that our header contained three
    floats and one integer, we could use the following to read it in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Note that the preceding code uses 0 and 16 as the start and end indices, which
    might seem like we're grabbing 17 bytes. However, Python interprets ranges as
    from the start up to (but not including) the second. So, what we're really saying
    is to use indices from 0 to (16-1), or 15.
  prefs: []
  type: TYPE_NORMAL
- en: Reading multiple types of files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, you might want to have a single script that is capable of reading
    in multiple file types. For example, if you were building a complex system to
    build character rigs, you might want to have one custom format that holds information
    about default bone layouts and another type that stores information about animation
    settings, allowing the user to mix and match any two files.
  prefs: []
  type: TYPE_NORMAL
- en: In such cases, you might want your script to handle files with multiple extensions—one
    for each type of data. In this example, we'll look at how to do that by creating
    a script that can be used to read either FOO (our example text-based format) or
    FOB (our example binary format).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make sure that you have at least one file of each type. For FOO files, you can
    just create them directly in a text editor. For FOB files, it's best to use the
    script in the writing binary files example.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new file and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Note that the preceding code makes use of two functions that we haven't defined,
    namely `readFOOFile` and `readFOBFile`. I've left those out for the sake of brevity,
    but they both use the same code as we discussed in the previous examples on reading
    text and binary files, respectfully.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the script, you'll be able to select FOO files or, by selecting "FOO
    binary files" from the drop-down list of file types, FOB files. Either way, you
    should see the corresponding collection of spheres and cubes added to the scene.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first thing that we have to do in order to read multiple files is to add
    two or more types to the `fileFilter` argument, separating them with a double
    semicolon, as in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Other than this, the `fileDialog2` command is used as we've used it in the past.
    Once we have the result from the command, we store the first entry (the path the
    used selected) into a `filePath` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we''ve done that, we want to examine the file extension of the file chosen
    by the user. We could do that with string functions, but it''s a bit safer to
    rely on Python''s `os.path.splitext` function, which is specifically designed
    to separate extensions from paths, with the return being an array consisting of
    first the path (including filename) and then the extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have the extension, we test it against all of the types we want to
    process, calling the appropriate function for each:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: For each file type, we invoke a function to handle the actual processing, passing
    in the path to the file. We finish off by throwing an error, in the event that
    the user somehow managed to choose a file of a type that we don't handle.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can certainly extend this approach to handle a wide range of file types
    in a single script, though if you have a large number of types, selecting the
    proper one from the dropdown might prove tiring for the user.
  prefs: []
  type: TYPE_NORMAL
- en: In such cases, you might want to just leave out the `fileFilter` altogether,
    and just allow the script to accept all file types, relying on the extension-filtering
    logic to filter out any types that you didn't want to process.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, however, if you're really dealing with a large number of different
    file types, it's likely that your script is trying to do too many things. Consider
    breaking it up into smaller components, with each one focused on a specific subset
    of the process you're building them for.
  prefs: []
  type: TYPE_NORMAL
