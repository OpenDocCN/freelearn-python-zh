- en: '*Chapter 4:* Software Projects and How We Organize Our Code'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第四章*：软件项目和我们的代码组织方式'
- en: When we write software and our program grows, we will need to organize our code
    so that it is easy to read when we need to maintain it. An application can be
    hundreds of thousands or millions of lines of code long, so having it all in a
    single file is impossible. We will need to divide the code into multiple files,
    but how will we do this? And even if we put the code into separate files, then
    we'll have lots of files, so we will need to organize them into folders. How can
    we do this so that the compiler or interpreter can find them? How will we know
    where to look when we need to edit a part of the application? In this chapter,
    we will discuss this and learn about some patterns that we can use.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写软件并且我们的程序增长时，我们需要组织我们的代码，以便在需要维护时易于阅读。一个应用程序可能有数万行或数百万行代码，所以将所有内容放在一个文件中是不可能的。我们需要将代码分成多个文件，但我们如何做到这一点？即使我们将代码放入单独的文件中，我们也会有大量的文件，所以我们需要将它们组织成文件夹。我们如何做到这一点，以便编译器或解释器能够找到它们？当我们需要编辑应用程序的一部分时，我们将知道在哪里寻找？在这一章中，我们将讨论这个问题，并了解我们可以使用的某些模式。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Understanding code modules
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解代码模块
- en: The concept of a code project
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码项目的概念
- en: Working with package managers to share code
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用包管理器共享代码
- en: Delving into a namespace
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入了解命名空间
- en: Using namespaces to avoid naming conflicts
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用命名空间来避免命名冲突
- en: Code modules
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码模块
- en: If programs are used, they are also updated, and if you are the developer of
    a program, this means that you will need to edit the source code in order to add
    features and fix errors. If your code is not well organized, it will be hard to
    read and maintain because you will need much more time to find where to insert
    your new code or where that nasty error might be.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果程序被使用，它们也会更新，如果你是程序的开发者，这意味着你需要编辑源代码来添加功能和修复错误。如果你的代码组织得不好，它将很难阅读和维护，因为你需要更多的时间来找到插入新代码的地方或者那个讨厌的错误可能在哪个地方。
- en: One measure to make your code easier to handle is to distribute it into several
    logical blocks. But how do we decide what will go into such a block? There are
    no fixed rules for how this is done, but the language you use might give you some
    hints, depending on how it wants you to structure the code. In the end, it is
    up to you to make the final decision.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使你的代码更容易处理，一个措施是将它分成几个逻辑块。但我们如何决定什么会进入这样的块呢？没有固定的规则来决定如何做这件事，但你所使用的语言可能会给你一些提示，这取决于它希望你怎么结构化代码。最后，最终的决定权在你。
- en: The code we write is logically connected, so to be able to do something, we
    often need to do a couple of other things first. It is as if you wake up in the
    morning and, while still in bed, you remember that there is nothing at home to
    make breakfast with, so first, you need to go shopping. But before you can do
    that, you need to do several other things, such as get out of bed and get dressed.
    These tasks are done to enable you to go shopping. In a way, you can say that
    these things are related and, by that logic, belong together. You could also see
    this differently and say that you want breakfast, but to be able to get it, you
    need to get out of bed, get dressed, go shopping, and finally prepare the breakfast.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写的代码在逻辑上是相互关联的，所以要做某件事，我们通常需要先做几件其他的事情。这就像你早上醒来，还在床上的时候，突然想起家里没有东西可以做早餐，所以首先你需要去购物。但在你能够去购物之前，你需要做几件其他的事情，比如起床和穿衣服。这些任务都是为了让你能够去购物。从某种意义上说，你可以认为这些事情是相关的，并且按照这种逻辑，它们属于一起。你也可以有不同的看法，比如说你想要早餐，但为了能够得到它，你需要起床，穿衣服，去购物，最后准备早餐。
- en: In the same way, you will have sections of your code that logically belong together,
    where some things are done to enable you to do other things. We need to keep this
    in mind when deciding on how to split the code into some logical blocks.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，你的代码中也会有逻辑上属于一起的部分，其中一些事情是为了让你能够做其他事情。在决定如何将代码分成一些逻辑块时，我们需要记住这一点。
- en: There can be other reasons, other than readability, for having code separated
    from other parts of the program. You might have developed this smart thing that
    you want to reuse in other programs or even distribute it to others so they can
    also use it. To be able to do that, the code that defines this smart thing must
    be separate from the rest of the program. This means that it cannot be tightly
    entangled with other parts of the code. If it is, it will be hard to reuse this
    section of your program.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 除了可读性之外，还有其他原因可以将代码与其他程序部分分开。你可能已经开发了一个你想要在其他程序中重用，甚至分发给别人以便他们也能使用的智能功能。为了能够做到这一点，定义这个智能功能的代码必须与程序的其他部分分开。这意味着它不能与其他代码部分紧密纠缠。如果是这样，那么重用这个程序部分将会很困难。
- en: Let's look at an example. Imagine you are writing an application that goes online
    and gathers data from several different websites and then analyzes this data.
    This could be stock market values or temperature readings from several weather
    services. If we were to create this program, we would need to define the websites
    that our program will visit, go to each of them, download and store each page,
    and go through all the stored pages to extract the data we need.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子。想象你正在编写一个应用程序，该应用程序会上线并从几个不同的网站收集数据，然后分析这些数据。这可能是股市价值或来自几个气象服务的温度读数。如果我们创建这个程序，我们需要定义我们的程序将要访问的网站，访问每个网站，下载并存储每个页面，然后遍历所有存储的页面以提取我们需要的资料。
- en: Overall, we know what we need to do, and in what order we need to do things.
    We also know that the result will be that we have gathered the data we need so
    that we can start to analyze it. This is good, as we can think of these things
    as separate tasks that should be as independent of each other as possible. Why
    is it so important that they are independent? Let's explore the development process
    of this application further to understand this.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 总体来说，我们知道我们需要做什么，以及我们需要按什么顺序做事。我们还知道结果将是我们收集了所需的数据，这样我们就可以开始分析它了。这是好事，因为我们可以将这些事情视为独立的任务，它们应该尽可能独立于彼此。为什么它们独立如此重要？让我们进一步探讨这个应用程序的开发过程，以了解这一点。
- en: If we start with the first task, how do we define what websites to visit? Shall
    we ask the user of the application to provide us with the addresses by asking
    them to write them down in the user interface, or should we have them in a file
    that we can read from? Both work, but what we don't want to do is store the addresses
    in the actual code, even if it would be possible to do so. The reason for this
    is that we want to enable the users of our application to define what sites they
    visit. We can't ask them to change the code of the program, as we can't assume
    that all our users are programmers. However, we can give them a text file that
    they can edit and save, and we can then read this file to get their input. Another
    reason is that we want to be flexible. Today, reading the addresses might be the
    best option, but in the future, we might discover another way to get the addresses
    into our application. We don't want to hardwire a solution into our program, but
    instead make the program as independent as possible from the source that provides
    us with this data.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从第一个任务开始，我们应该如何定义要访问的网站呢？我们是要求应用程序的用户通过在用户界面中写下它们来提供给我们地址，还是我们应该有一个文件，我们可以从中读取它们？这两种方法都可行，但我们不想做的是在代码中存储地址，即使这样做是可能的。这样做的原因是我们希望让我们的应用程序的用户能够定义他们要访问的网站。我们不能要求他们更改程序的代码，因为我们不能假设所有我们的用户都是程序员。然而，我们可以给他们一个可以编辑和保存的文本文件，然后我们可以读取这个文件来获取他们的输入。另一个原因是我们要保持灵活性。今天，读取地址可能是最佳选择，但将来，我们可能会发现另一种将地址输入到我们的应用程序的方法。我们不想将解决方案硬编码到我们的程序中，而是使程序尽可能独立于提供我们这些数据的数据源。
- en: The next thing we will need to do is go to each of the sites that we defined
    in the previous step and download that page. Now, let's assume that we have written
    the code that can do this. We want to keep it independent of the previous step;
    that is, this part of the program should not care about how the addresses to the
    sites came into the application. It should be given an address that downloads
    that page and returns that page data. That is all. It does not know how the address
    to this page came and knows nothing about what happens to the page data when it
    completes its task. In that way, a part of the code can be reused in other projects,
    which might receive its addresses in other ways and do something completely different
    from the downloaded page.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步我们需要做的是前往之前步骤中定义的每个网站并下载该页面。现在，假设我们已经编写了能够完成这一任务的代码。我们希望保持它与之前步骤的独立性；也就是说，程序的这一部分不应该关心网站地址是如何进入应用程序的。它应该被赋予一个下载该页面并返回页面数据的地址。仅此而已。它不知道这个页面的地址是如何来的，也不知道当它完成任务时页面数据发生了什么。这样，代码的一部分就可以在其他项目中重用，这些项目可能以其他方式接收其地址，并执行与下载页面完全不同的操作。
- en: 'For the remaining tasks, that is, storing the downloaded pages and processing
    the data within each page, we strive to do the same thing: construct them as independent
    parts of the code. The following diagram shows this concept:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对于剩余的任务，即存储下载的页面和处理每个页面内的数据，我们努力做到同样的事情：将它们构建为代码的独立部分。以下图表展示了这个概念：
- en: '![Figure 4.1 – An application that uses several independent blocks of code
    to fulfill its task](img/B15554_04_01.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图4.1 – 一个使用多个独立代码块来完成任务的应用程序](img/B15554_04_01.jpg)'
- en: Figure 4.1 – An application that uses several independent blocks of code to
    fulfill its task
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 – 一个使用多个独立代码块来完成任务的应用程序
- en: We can now say that we have independent code modules. The term *module* will
    have a slightly different meaning, depending on what language we are using. However,
    all of them will agree that it is a section of code that is independent, though
    how it is handled will differ. Some languages say that each module will go into
    a separate file, or multiple files if it is a large and more complex module. Others
    will have ways to define several modules within one single file. In some circumstances,
    the term module will hardly ever be used, even if the concept of independent sections
    of code exist.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以说我们已经有了独立的代码模块。术语*模块*的含义将根据我们使用的语言略有不同。然而，它们都会同意，它是一个独立的代码部分，尽管处理方式可能不同。一些语言表示每个模块将进入一个单独的文件，或者如果是一个大而复杂的模块，则进入多个文件。其他语言将提供在单个文件中定义多个模块的方法。在某些情况下，术语模块几乎不会被使用，即使独立代码部分的概念存在。
- en: One benefit of treating code as independent modules is, as we already stated,
    to be able to reuse the module in other applications. Another reason to do this
    is that it will be easier for us to change or replace a module. If our code sections
    are intertwined and depend heavily on each other, changing parts of the code will
    be harder as we need to make these changes at multiple locations throughout the
    code, and we need to make sure that we have found all occurrences where we need
    to make changes.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码视为独立模块的一个好处，正如我们之前所述，是能够在其他应用程序中重用模块。另一个原因是这将使我们更容易更改或替换模块。如果我们的代码部分相互交织并且高度依赖，那么更改代码部分将会更困难，因为我们需要在代码的多个位置进行这些更改，并且我们需要确保我们已经找到了所有需要更改的实例。
- en: When we have broken up our code into these smaller modules, we need to put everything
    together into what will be our final application. To do this, we will need to
    store the modules in a project.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将代码分解成这些较小的模块时，我们需要将所有这些内容组合成我们最终的应用程序。为此，我们需要将模块存储在项目中。
- en: Working with software projects
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与软件项目合作
- en: 'The term *project* can be used in two different ways when talking about software
    development:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到软件开发时，术语*项目*可以有两种不同的用法：
- en: A collaborative enterprise used to develop the actual program – in other words,
    as a group of people working together. For that, we need a project plan, a project
    leader, and so on.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于开发实际程序的协作企业——换句话说，就是一群人共同工作。为此，我们需要一个项目计划、项目负责人等等。
- en: A container for all the files that make up the program we develop.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们开发程序所组成的所有文件的容器。
- en: It is the latter meaning – a container for all the files that make up a program
    – that we will discuss here as the former is about project management and not
    software development.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里讨论后一种含义——一个包含构成程序的文件容器——因为前一种含义是关于项目管理而不是软件开发。
- en: When our code is broken up into well-defined modules – most likely in the form
    of several files – we need a way to let the compiler or interpreter find all the
    files so that they can be assembled into the executable machine code.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的代码被分解成定义良好的模块——很可能是几个文件的形式——我们需要一种方法让编译器或解释器找到所有文件，以便它们可以被组装成可执行的机器代码。
- en: Creating the correct structure for the project is usually done by tools that
    programmers use to develop software. These tools come in many categories, but
    the most advanced form is called an **Integrated Development Environment** (**IDE**).
    The central part of an IDE is the editor that's used to write the code. It will
    also assist us with creating software projects. A programming language defines
    how a project shall be organized. This can, for example, be in a form where the
    different files shall be in relation to each other. Some languages will do this
    with the help of things called packages.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 创建正确的项目结构通常是通过程序员用来开发软件的工具来完成的。这些工具分为许多类别，但最先进的形式被称为**集成开发环境**（**IDE**）。IDE的核心部分是用于编写代码的编辑器。它还将帮助我们创建软件项目。编程语言定义了项目应该如何组织。这可以是以不同文件相互关联的形式，例如，一些语言会通过称为软件包的东西来实现。
- en: Working with packages to share code
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用软件包共享代码
- en: In software developer culture, sharing code for free is very natural. This makes
    the industry unique as programmers share and use each other's code all the time.
    Using someone else's solutions to a problem is as natural as sharing my good ideas
    and code. It is usually wise to reuse the work of others as the code is often
    well developed, well tested, and well maintained. In software development, the
    term *open source* is well known. It means that someone has an idea for an application,
    writes the code for it, and then shares it online. Others are then encouraged
    to help with the development of this project. Several programmers will join in,
    and together they keep the project going. Everyone interested can then use this
    code free of charge.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发者的文化中，免费共享代码是非常自然的。这使得该行业独一无二，因为程序员经常共享和使用彼此的代码。使用他人的解决方案来解决问题就像分享我的好想法和代码一样自然。通常，重用他人的工作是明智的，因为代码通常是经过良好开发、良好测试和良好维护的。在软件开发中，术语*开源*是众所周知的。这意味着有人有一个应用程序的想法，为它编写代码，然后在线分享它。其他人随后被鼓励帮助这个项目的开发。几个程序员会加入进来，他们一起保持项目的进行。任何感兴趣的人都可以免费使用这段代码。
- en: The code that's developed in such a project is often in the form of one or several
    modules. If you want to use such a module, you must find it, and then you need
    to download it. The question is, how we can find it, download it, and make sure
    it is put in a location so that our application can find it?
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这样的项目中开发的代码通常以一个或多个模块的形式存在。如果你想使用这样的模块，你必须找到它，然后你需要下载它。问题是，我们如何找到它，下载它，并确保它被放置在一个位置，以便我们的应用程序可以找到它？
- en: 'Luckily, there is a solution to this: package managers.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这个问题有一个解决方案：软件包管理器。
- en: Package managers
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 软件包管理器
- en: A package manager is a piece of software that will help us find, download, and
    install code. Most languages will have at least one package manager that can help
    us with this. It works by storing the code modules, now referred to as packages,
    in a central location. This central storage is called a repository, or just repo.
    This means that when you write a program, you can visit the package manager's
    website to search for any packages that might be useful in your project.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 软件包管理器是一种软件工具，它将帮助我们查找、下载和安装代码。大多数语言至少会有一个可以帮助我们完成这项任务的软件包管理器。它通过将代码模块，现在称为软件包，存储在中央位置来实现。这个中央存储被称为仓库，或简称repo。这意味着当你编写一个程序时，你可以访问软件包管理器的网站来搜索可能对你的项目有用的任何软件包。
- en: 'Here is a list of package managers for some popular languages:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些流行语言的软件包管理器列表：
- en: '![Table 4.1](img/B15554_Table_4.1.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![表 4.1](img/B15554_Table_4.1.jpg)'
- en: Table 4.1
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.1
- en: Let's look at the project example where we downloaded web pages. You decide
    that the coding part of downloading a page feels a bit too hard to write yourself,
    so instead, you search the package manager site for your language, find a package
    that does what you want, and then download a web page, when given an address.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们下载网页的项目示例。您决定下载页面的编码部分感觉有点难以自己编写，所以您搜索您语言对应的包管理器网站，找到一个做您想要的事情的包，然后当给定一个地址时下载网页。
- en: You can now use the package manager application to download and install this
    package and then call the functionality in that package from your code.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以使用包管理器应用程序下载并安装此包，然后从您的代码中调用该包的功能。
- en: Let's say we are using Python. Even if we know that we could go to the PyPI
    website, we might not be sure what to search for. Instead, we could do a Google
    search for something such as `Python download web page`, and we will find several
    suggestions for how to do it. We are likely to stumble upon several suggestions
    to use something called **requests**.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们使用 Python。即使我们知道我们可以去 PyPI 网站，我们可能也不确定要搜索什么。相反，我们可以通过 Google 搜索像“Python
    下载网页”这样的内容，我们会找到几种如何做到这一点的建议。我们可能会偶然发现几个建议使用名为 **requests** 的东西。
- en: 'If we decide that we want to try the `requests` package and see if it is useful
    for us, we can go to the `pypi.org` website and search for requests. We will then
    see a page like this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们决定想要尝试 `requests` 包并看看它对我们是否有用，我们可以访问 `pypi.org` 网站，并搜索 requests。然后我们会看到一个像这样的页面：
- en: '![Figure 4.2 – The project page for requests at pypi.org](img/B15554_04_02.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.2 – pypi.org 上的 requests 项目页面](img/B15554_04_02.jpg)'
- en: Figure 4.2 – The project page for requests at pypi.org
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 – pypi.org 上的 requests 项目页面
- en: If we scroll down on this page, we will find installation instructions and even
    an example of how it can be used. There is also a link to the project website
    for this project where we can find documentation and more examples.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在这个页面上滚动，我们会找到安装说明，甚至还有如何使用的示例。还有一个链接到这个项目的网站，在那里我们可以找到文档和更多示例。
- en: 'The installation instructions might look something like this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 安装说明可能看起来像这样：
- en: '[PRE0]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, `pip` is the package manager. When installing the Python programming language,
    the package manager, `pip`, will also be installed. We can open a Command Prompt
    (if we are using Windows) or a Terminal window (if we are using Mac or Linux)
    and run this command.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`pip` 是包管理器。当安装 Python 编程语言时，包管理器 `pip` 也会被安装。我们可以打开命令提示符（如果我们使用的是 Windows）或终端窗口（如果我们使用的是
    Mac 或 Linux）并运行此命令。
- en: The package manager will then go to its central repository online and download
    the package that was asked for, which is `requests` in our case. If this package
    is using other packages, we don't need to download them ourselves. The package
    manager will take care of this, and everything we need to be able to use this
    package will be downloaded and installed.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 包管理器将随后访问其在线中央仓库，下载请求的包，在我们的例子中是 `requests`。如果这个包正在使用其他包，我们不需要自己下载它们。包管理器会处理这个问题，并且我们需要的一切以便能够使用此包都将被下载和安装。
- en: Now that we can download the package, we will soon be dealing with another problem.
    We must make sure that, when naming things in our code, all the names are unique.
    If not, the program will not run. This can be tricky, especially when using packages
    that others have written. How do we know that the names we're using are not already
    being used? The solution is in namespaces.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们可以下载这个包，我们很快就会遇到另一个问题。我们必须确保，在代码中命名事物时，所有名称都是唯一的。如果不是，程序将无法运行。这可能会很棘手，尤其是在使用他人编写的包时。我们如何知道我们使用的名称尚未被使用？解决方案在命名空间中。
- en: Avoiding conflicts using namespaces
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用命名空间避免冲突
- en: When writing code, you will constantly name things. The problem is, what if
    you give something a name that is already being used? We now know that the code
    for an application can consist of thousands of lines of code divided into hundreds
    of files. How can you make sure that the names you give something are not already
    taken? We also learned that we can install packages with code that others have
    written. How can we make sure that they have not given their packages names that
    we have already used? Or how can we make sure that a package we install is not
    using names that another package we already installed is using?
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, handling names can be tricky. Let's look at an example. In [*Chapter
    8*](B15554_08_Final_NM_ePub.xhtml#_idTextAnchor116), *Understanding Functions*,
    we will discuss what a function is and how it works. For this example, all we
    need to know about functions is that they have a name and consist of several lines
    of code. We use the function name to call it, which will make the code inside
    it run.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we are constructing a calculator app. First, let''s have a
    look at what the application might look like:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – Our calculator application](img/B15554_04_03.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – Our calculator application
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: 'When the user clicks on the square root button, (![](img/Formula_04_001.png))
    , we have to calculate the square root of the number currently in the display.
    This means that we need to connect some code with the event that occurs when this
    button is clicked. This code needs to perform the following steps:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: It needs to get the value currently in the display.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, it needs to calculate the square root of that value.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, it needs to put the result in the display of the calculator.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These instructions will be carried out when the square root button is pressed,
    and we stick them in a function. Now, this function needs a name. The name *squareroot*
    is rather long, so you might decide to shorten it to *sqrt*.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: When you reach the point where you want to calculate the square root, you will
    most likely use a built-in function that will help us with this. Most languages
    will have such a function, and often, its name will be `sqrt`. This is a problem,
    as we gave our function the same name as a function that comes shipped with the
    language. We could, of course, rename our function to something else. Don't despair
    – namespaces will solve this problem for us.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Delving into namespaces
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand what a namespace is, we can think of files and folders on our
    computer. Assume that you are going to have two parties soon: one summer party
    and a birthday party. You write two invitations to the parties and try to store
    them in a folder on your computer.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: 'You have named both files `Party Invitation`, but you can''t have two files
    with the same name in the same folder:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 – Two files in the same folder can''t have the same name](img/B15554_04_04.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
- en: Figure 4.4 – Two files in the same folder can't have the same name
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of renaming one file, you can create two folders and store the files
    in one folder each. This way, the files can still have the name `Party Invitation`,
    and there is no longer a conflict between the names as they are in separate folders,
    as shown in the following diagram:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是重命名一个文件，你可以创建两个文件夹，并将文件分别存储在每个文件夹中。这样，文件仍然可以命名为`Party Invitation`，并且由于它们位于不同的文件夹中，名称冲突不再存在，如下面的图示所示：
- en: '![Figure 4.5 – Storing files in separate folders to avoid naming conflicts](img/B15554_04_05.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图4.5 – 通过将文件存储在不同的文件夹中来避免命名冲突](img/B15554_04_05.jpg)'
- en: Figure 4.5 – Storing files in separate folders to avoid naming conflicts
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5 – 通过将文件存储在不同的文件夹中来避免命名冲突
- en: To summarize this, on a computer, we can have multiple files with the same name,
    but within a folder, the filenames must be unique.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，在计算机上，我们可以有多个同名文件，但文件夹内的文件名必须是唯一的。
- en: Many programming languages use a similar technique, called namespaces. Namespaces
    let us reuse the same name multiple times within an application, but in a namespace,
    all the names must be unique. The namespace acts like the folders on the computer,
    and the things we are naming are like the files.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 许多编程语言使用类似的技巧，称为命名空间。命名空间允许我们在应用程序中多次重用相同的名称，但在命名空间中，所有名称都必须是唯一的。命名空间就像计算机上的文件夹，而我们命名的对象就像文件。
- en: How namespaces are implemented will differ between languages. Let's examine
    how some of the more popular languages have implemented them.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间是如何实现的，这将在不同的语言之间有所不同。让我们来看看一些更流行的语言是如何实现它们的。
- en: Namespaces in JavaScript
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JavaScript中的命名空间
- en: In JavaScript, when we define things such as functions, we can create a namespace
    by surrounding the part we want to belong to the namespace with curly brackets,
    `{}`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，当我们定义诸如函数之类的对象时，我们可以通过将我们想要属于命名空间的部分用花括号`{}`包围来创建一个命名空间。
- en: 'If we represent our `sqrt` function in a namespace called `myCalc`, it will
    look something like this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在名为`myCalc`的命名空间中代表我们的`sqrt`函数，它看起来可能像这样：
- en: '[PRE1]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: On the first line, we define a namespace called `myCalc`. We use an open bracket
    to indicate the beginning of the namespace; the closing bracket on the last line
    marks the end of the namespace.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，我们定义了一个名为`myCalc`的命名空间。我们使用一个开括号来表示命名空间的开始；最后一行的闭括号标志着命名空间的结束。
- en: Within the brackets, we find a function named `sqrt`. The function also uses
    open and close brackets to indicate where it starts and ends. In this example,
    the function is empty, so there is nothing there.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在括号内，我们找到一个名为`sqrt`的函数。该函数也使用开闭括号来表示其开始和结束的位置。在这个例子中，该函数是空的，所以里面没有内容。
- en: 'We can now access both our own function and the built-in function, even if
    both are named `sqrt`. It could look something like this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以访问我们自己的函数和内置函数，即使它们都命名为`sqrt`。它可能看起来像这样：
- en: '[PRE2]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The first line calls the `sqrt` function within the `myCalc` namespace. The
    second line calls the built-in `sqrt` function. It is in a namespace called `Math`.
    That function will accept a value (the value we want to take the square root of),
    and here, we pass the value `9`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行在`myCalc`命名空间中调用了`sqrt`函数。第二行调用了内置的`sqrt`函数。它位于名为`Math`的命名空间中。该函数将接受一个值（我们想要开平方的值），在这里，我们传递了值`9`。
- en: Namespaces in Python
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python中的命名空间
- en: In Python, namespaces are defined by individual modules. A module in Python
    is a file, so everything in a file (that is, a Python module) is in the same namespace.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，命名空间是由单个模块定义的。Python中的模块是一个文件，所以文件中的所有内容（即Python模块）都在同一个命名空间中。
- en: 'We can now create a file called `myCalc.py`. The`.py` extension indicates that
    this file contains Python code. It is in this file where we add our `sqrt` function:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以创建一个名为`myCalc.py`的文件。`.py`扩展名表示该文件包含Python代码。正是在这个文件中我们添加了我们的`sqrt`函数：
- en: '![Figure 4.6 – Project structure in Python](img/B15554_04_06.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图4.6 – Python中的项目结构](img/B15554_04_06.jpg)'
- en: Figure 4.6 – Project structure in Python
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6 – Python中的项目结构
- en: Look at the preceding diagram. The `main_application.py` file is our main program
    that uses the code inside `myCalc.py`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 看看前面的图示。`main_application.py`文件是我们使用`myCalc.py`内部代码的主程序。
- en: 'Inside the `main_application.py` file, we can now access both the built-in
    `sqrt` function and the `sqrt` function we created, as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main_application.py`文件内部，我们现在可以访问内置的`sqrt`函数和我们创建的`sqrt`函数，如下所示：
- en: '[PRE3]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'From the preceding code, we can see the following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中，我们可以看到以下内容：
- en: In the first line, we say that we want to be able to use things from the `math`
    module. Remember that Python uses the concept that a module is a namespace, so
    `math` is both a module and a namespace.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一行，我们表示我们想要能够使用`math`模块中的内容。记住，Python使用模块是命名空间的概念，所以`math`既是模块也是命名空间。
- en: The second line does the same for our `myCalc` module, which contains our `sqrt`
    function.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二行对我们包含`sqrt`函数的`myCalc`模块做了同样的事情。
- en: On line three, we call the `sqrt` function in the `myCalc` module.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第三行，我们调用`myCalc`模块中的`sqrt`函数。
- en: On the last line, we call the `sqrt` function in the `math` module and pass
    `9` to it.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在最后一行，我们在`math`模块中调用`sqrt`函数，并将`9`传递给它。
- en: Namespaces in C++
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C++中的命名空间
- en: 'In C++, we have a keyword. A *keyword* is a word that is reserved by the language
    and has a special meaning. Refer to [*Chapter 2*](B15554_02_Final_NM_ePub.xhtml#_idTextAnchor029),
    *Introduction to Programming Languages*, for a more thorough explanation of keywords.
    Here, we have a keyword called `namespace` that we can use to define a namespace.
    It could look something like this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，我们有一个关键字。一个*关键字*是语言保留的单词，具有特殊含义。请参阅[*第2章*](B15554_02_Final_NM_ePub.xhtml#_idTextAnchor029)，*编程语言简介*，以获取对关键字的更详细解释。在这里，我们有一个名为`namespace`的关键字，我们可以用它来定义一个命名空间。它可能看起来像这样：
- en: '[PRE4]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, we first create a namespace called `myCalc`, containing a function called
    `sqrt`. Note that just as in the JavaScript example, the function has an opening
    and a closing bracket, indicating the start and the end of the function, and just
    as in that example, the function is empty.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先创建一个名为`myCalc`的命名空间，其中包含一个名为`sqrt`的函数。请注意，就像在JavaScript示例中一样，函数有一个开括号和一个闭括号，表示函数的开始和结束，就像那个例子一样，函数是空的。
- en: 'C++ then uses a special syntax to access something within a namespace. First,
    we state what namespace we want to use, followed by two colons, `::`, and then
    what it is within this namespace we want to use. This can look like this:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: C++使用特殊语法来访问命名空间内的内容。首先，我们声明我们想要使用的命名空间，然后是两个冒号`::`，然后是我们想要使用该命名空间内的内容。这可以看起来像这样：
- en: '[PRE5]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The first line calls the `sqrt` function in the namespace we defined previously.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行调用我们之前定义的命名空间中的`sqrt`函数。
- en: The second line calls the `sqrt` function in the standard namespace, called
    `std` in C++, passing the value `c` to it.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行调用标准命名空间中的`sqrt`函数，在C++中称为`std`，并将值`c`传递给它。
- en: Namespaces in other languages
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他语言中的命名空间
- en: These were just a few examples of how namespaces are used in some languages.
    Other languages have their own variants of this. For example, in Java, namespaces
    are closely connected to how packages are used. In C#, namespaces are implemented
    almost in the same way as they are in C++, but not accessed with a double colon.
    Instead, they are accessed with a dot, `.`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是某些语言中命名空间使用的一些例子。其他语言有自己的变体。例如，在Java中，命名空间与包的使用紧密相关。在C#中，命名空间几乎以与C++相同的方式实现，但不是使用双冒号访问。相反，它们使用点`.`访问。
- en: Now that we know a little bit about namespaces, let's return to our calculator
    application.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对命名空间有了一些了解，让我们回到我们的计算器应用程序。
- en: Using namespaces in our calculator application
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在我们的计算器应用程序中使用命名空间
- en: We are at the point where we want to name a `sqrt` function, and we have realized
    that the language we use also has a function called `sqrt`. This built-in `sqrt`
    function will calculate the square root for any number we pass to it. We don't
    want to rename our function; instead, we want to solve the naming conflict with
    the use of namespaces.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在处于想要命名一个`sqrt`函数的阶段，我们已经意识到我们使用的语言也有一个名为`sqrt`的函数。这个内置的`sqrt`函数将计算我们传递给它的任何数字的平方根。我们不想重命名我们的函数；相反，我们想要通过使用命名空间来解决命名冲突。
- en: The first thing we need to do is understand how namespaces are used in the current
    language. As we saw previously, the way we define and use namespaces will differ
    between languages.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要做的是了解当前语言中命名空间的使用方式。正如我们之前看到的，定义和使用命名空间的方式将在不同语言之间有所不同。
- en: By adding our `sqrt` function inside its namespace, we don't need to worry about
    a naming conflict with the built-in `sqrt` function or any other function that
    we might get when importing packages using a package manager. Everything is defined
    within different namespaces and we will need to state in what namespace the function
    we want is located.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在我们的命名空间内添加`sqrt`函数，我们不需要担心与内置的`sqrt`函数或其他可能通过包管理器导入包时获得的函数的命名冲突。所有内容都在不同的命名空间中定义，并且我们需要声明我们想要的函数位于哪个命名空间中。
- en: 'We already know what our `sqrt` function needs to do: get the value from the
    display, calculate the square root of that value, and then put the resulting value
    back into the display.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: We will add our `sqrt` function to a namespace to avoid a naming conflict with
    the built-in version. We also want to use the built-in `sqrt` function from within
    our function. We can do that by specifying what namespace the built-in `sqrt`
    resides in.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, the focus has been on organizing our code and how to name things
    so that we can avoid naming conflicts.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: A book is divided into chapters to make it easier to read and navigate. In the
    same way, we want our code to be easy to read and understand. We don't have the
    concept of chapters in programming, but we do have modules. A module is a part
    of our application where the code is logically related; that is, one way or the
    other, it works with the code. A module is often defined as a separate code file.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: In larger projects, we can end up with a large number of modules. Due to this,
    we need a way to organize them so that the compiler or interpreter can locate
    the correct file when all the pieces needs to be put together. We do this with
    the help of a project. We can see the project as a form of container for all our
    modules, but also for other resources that our application might use, such as
    images, configuration files, and so on.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Writing programs is about being efficient and focusing our time and attention
    on what is important to make the program do what it is intended to do. We will
    often face situations where we need to solve a problem that we know others have
    solved before us. It is therefore not considered a bad thing to reuse the work
    of others in our application. The software programming community/industry is very
    open and helpful, and programmers share and reuse code from others all the time.
    By doing this, we can focus our efforts on what makes our application unique and
    not spend time reinventing the wheel again and again.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: One way we can make use of code that others have written is by using tools that
    often come shipped with the language, called package managers. These tools will
    store code that we can reuse in a central location online. They will also help
    us find what we need and download install, and configure it for us.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: However, as our applications grow and we use code that's been written by others,
    we will need a way to avoid naming conflicts. If I use a name for something that
    has already been used elsewhere in my application, the language must have a way
    to distinguish between the two. This is done with something called namespaces.
    A name that we give something must only be unique within a namespace. If we divide
    our applications into several namespaces, we will reduce the risk of name clashes
    dramatically.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Now, we are finally ready to dig into the process of writing programs. In the
    next chapter, we will look at the most fundamental building blocks of any program
    in terms of sequences.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们终于准备好深入探究编写程序的过程了。在下一章中，我们将探讨任何程序在序列方面的最基本构建模块。
