- en: '*Chapter 4:* Software Projects and How We Organize Our Code'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we write software and our program grows, we will need to organize our code
    so that it is easy to read when we need to maintain it. An application can be
    hundreds of thousands or millions of lines of code long, so having it all in a
    single file is impossible. We will need to divide the code into multiple files,
    but how will we do this? And even if we put the code into separate files, then
    we'll have lots of files, so we will need to organize them into folders. How can
    we do this so that the compiler or interpreter can find them? How will we know
    where to look when we need to edit a part of the application? In this chapter,
    we will discuss this and learn about some patterns that we can use.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding code modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The concept of a code project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with package managers to share code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delving into a namespace
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using namespaces to avoid naming conflicts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If programs are used, they are also updated, and if you are the developer of
    a program, this means that you will need to edit the source code in order to add
    features and fix errors. If your code is not well organized, it will be hard to
    read and maintain because you will need much more time to find where to insert
    your new code or where that nasty error might be.
  prefs: []
  type: TYPE_NORMAL
- en: One measure to make your code easier to handle is to distribute it into several
    logical blocks. But how do we decide what will go into such a block? There are
    no fixed rules for how this is done, but the language you use might give you some
    hints, depending on how it wants you to structure the code. In the end, it is
    up to you to make the final decision.
  prefs: []
  type: TYPE_NORMAL
- en: The code we write is logically connected, so to be able to do something, we
    often need to do a couple of other things first. It is as if you wake up in the
    morning and, while still in bed, you remember that there is nothing at home to
    make breakfast with, so first, you need to go shopping. But before you can do
    that, you need to do several other things, such as get out of bed and get dressed.
    These tasks are done to enable you to go shopping. In a way, you can say that
    these things are related and, by that logic, belong together. You could also see
    this differently and say that you want breakfast, but to be able to get it, you
    need to get out of bed, get dressed, go shopping, and finally prepare the breakfast.
  prefs: []
  type: TYPE_NORMAL
- en: In the same way, you will have sections of your code that logically belong together,
    where some things are done to enable you to do other things. We need to keep this
    in mind when deciding on how to split the code into some logical blocks.
  prefs: []
  type: TYPE_NORMAL
- en: There can be other reasons, other than readability, for having code separated
    from other parts of the program. You might have developed this smart thing that
    you want to reuse in other programs or even distribute it to others so they can
    also use it. To be able to do that, the code that defines this smart thing must
    be separate from the rest of the program. This means that it cannot be tightly
    entangled with other parts of the code. If it is, it will be hard to reuse this
    section of your program.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at an example. Imagine you are writing an application that goes online
    and gathers data from several different websites and then analyzes this data.
    This could be stock market values or temperature readings from several weather
    services. If we were to create this program, we would need to define the websites
    that our program will visit, go to each of them, download and store each page,
    and go through all the stored pages to extract the data we need.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, we know what we need to do, and in what order we need to do things.
    We also know that the result will be that we have gathered the data we need so
    that we can start to analyze it. This is good, as we can think of these things
    as separate tasks that should be as independent of each other as possible. Why
    is it so important that they are independent? Let's explore the development process
    of this application further to understand this.
  prefs: []
  type: TYPE_NORMAL
- en: If we start with the first task, how do we define what websites to visit? Shall
    we ask the user of the application to provide us with the addresses by asking
    them to write them down in the user interface, or should we have them in a file
    that we can read from? Both work, but what we don't want to do is store the addresses
    in the actual code, even if it would be possible to do so. The reason for this
    is that we want to enable the users of our application to define what sites they
    visit. We can't ask them to change the code of the program, as we can't assume
    that all our users are programmers. However, we can give them a text file that
    they can edit and save, and we can then read this file to get their input. Another
    reason is that we want to be flexible. Today, reading the addresses might be the
    best option, but in the future, we might discover another way to get the addresses
    into our application. We don't want to hardwire a solution into our program, but
    instead make the program as independent as possible from the source that provides
    us with this data.
  prefs: []
  type: TYPE_NORMAL
- en: The next thing we will need to do is go to each of the sites that we defined
    in the previous step and download that page. Now, let's assume that we have written
    the code that can do this. We want to keep it independent of the previous step;
    that is, this part of the program should not care about how the addresses to the
    sites came into the application. It should be given an address that downloads
    that page and returns that page data. That is all. It does not know how the address
    to this page came and knows nothing about what happens to the page data when it
    completes its task. In that way, a part of the code can be reused in other projects,
    which might receive its addresses in other ways and do something completely different
    from the downloaded page.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the remaining tasks, that is, storing the downloaded pages and processing
    the data within each page, we strive to do the same thing: construct them as independent
    parts of the code. The following diagram shows this concept:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – An application that uses several independent blocks of code
    to fulfill its task](img/B15554_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – An application that uses several independent blocks of code to
    fulfill its task
  prefs: []
  type: TYPE_NORMAL
- en: We can now say that we have independent code modules. The term *module* will
    have a slightly different meaning, depending on what language we are using. However,
    all of them will agree that it is a section of code that is independent, though
    how it is handled will differ. Some languages say that each module will go into
    a separate file, or multiple files if it is a large and more complex module. Others
    will have ways to define several modules within one single file. In some circumstances,
    the term module will hardly ever be used, even if the concept of independent sections
    of code exist.
  prefs: []
  type: TYPE_NORMAL
- en: One benefit of treating code as independent modules is, as we already stated,
    to be able to reuse the module in other applications. Another reason to do this
    is that it will be easier for us to change or replace a module. If our code sections
    are intertwined and depend heavily on each other, changing parts of the code will
    be harder as we need to make these changes at multiple locations throughout the
    code, and we need to make sure that we have found all occurrences where we need
    to make changes.
  prefs: []
  type: TYPE_NORMAL
- en: When we have broken up our code into these smaller modules, we need to put everything
    together into what will be our final application. To do this, we will need to
    store the modules in a project.
  prefs: []
  type: TYPE_NORMAL
- en: Working with software projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The term *project* can be used in two different ways when talking about software
    development:'
  prefs: []
  type: TYPE_NORMAL
- en: A collaborative enterprise used to develop the actual program – in other words,
    as a group of people working together. For that, we need a project plan, a project
    leader, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A container for all the files that make up the program we develop.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is the latter meaning – a container for all the files that make up a program
    – that we will discuss here as the former is about project management and not
    software development.
  prefs: []
  type: TYPE_NORMAL
- en: When our code is broken up into well-defined modules – most likely in the form
    of several files – we need a way to let the compiler or interpreter find all the
    files so that they can be assembled into the executable machine code.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the correct structure for the project is usually done by tools that
    programmers use to develop software. These tools come in many categories, but
    the most advanced form is called an **Integrated Development Environment** (**IDE**).
    The central part of an IDE is the editor that's used to write the code. It will
    also assist us with creating software projects. A programming language defines
    how a project shall be organized. This can, for example, be in a form where the
    different files shall be in relation to each other. Some languages will do this
    with the help of things called packages.
  prefs: []
  type: TYPE_NORMAL
- en: Working with packages to share code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In software developer culture, sharing code for free is very natural. This makes
    the industry unique as programmers share and use each other's code all the time.
    Using someone else's solutions to a problem is as natural as sharing my good ideas
    and code. It is usually wise to reuse the work of others as the code is often
    well developed, well tested, and well maintained. In software development, the
    term *open source* is well known. It means that someone has an idea for an application,
    writes the code for it, and then shares it online. Others are then encouraged
    to help with the development of this project. Several programmers will join in,
    and together they keep the project going. Everyone interested can then use this
    code free of charge.
  prefs: []
  type: TYPE_NORMAL
- en: The code that's developed in such a project is often in the form of one or several
    modules. If you want to use such a module, you must find it, and then you need
    to download it. The question is, how we can find it, download it, and make sure
    it is put in a location so that our application can find it?
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily, there is a solution to this: package managers.'
  prefs: []
  type: TYPE_NORMAL
- en: Package managers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A package manager is a piece of software that will help us find, download, and
    install code. Most languages will have at least one package manager that can help
    us with this. It works by storing the code modules, now referred to as packages,
    in a central location. This central storage is called a repository, or just repo.
    This means that when you write a program, you can visit the package manager's
    website to search for any packages that might be useful in your project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a list of package managers for some popular languages:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 4.1](img/B15554_Table_4.1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Table 4.1
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at the project example where we downloaded web pages. You decide
    that the coding part of downloading a page feels a bit too hard to write yourself,
    so instead, you search the package manager site for your language, find a package
    that does what you want, and then download a web page, when given an address.
  prefs: []
  type: TYPE_NORMAL
- en: You can now use the package manager application to download and install this
    package and then call the functionality in that package from your code.
  prefs: []
  type: TYPE_NORMAL
- en: Let's say we are using Python. Even if we know that we could go to the PyPI
    website, we might not be sure what to search for. Instead, we could do a Google
    search for something such as `Python download web page`, and we will find several
    suggestions for how to do it. We are likely to stumble upon several suggestions
    to use something called **requests**.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we decide that we want to try the `requests` package and see if it is useful
    for us, we can go to the `pypi.org` website and search for requests. We will then
    see a page like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – The project page for requests at pypi.org](img/B15554_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – The project page for requests at pypi.org
  prefs: []
  type: TYPE_NORMAL
- en: If we scroll down on this page, we will find installation instructions and even
    an example of how it can be used. There is also a link to the project website
    for this project where we can find documentation and more examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'The installation instructions might look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here, `pip` is the package manager. When installing the Python programming language,
    the package manager, `pip`, will also be installed. We can open a Command Prompt
    (if we are using Windows) or a Terminal window (if we are using Mac or Linux)
    and run this command.
  prefs: []
  type: TYPE_NORMAL
- en: The package manager will then go to its central repository online and download
    the package that was asked for, which is `requests` in our case. If this package
    is using other packages, we don't need to download them ourselves. The package
    manager will take care of this, and everything we need to be able to use this
    package will be downloaded and installed.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we can download the package, we will soon be dealing with another problem.
    We must make sure that, when naming things in our code, all the names are unique.
    If not, the program will not run. This can be tricky, especially when using packages
    that others have written. How do we know that the names we're using are not already
    being used? The solution is in namespaces.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding conflicts using namespaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When writing code, you will constantly name things. The problem is, what if
    you give something a name that is already being used? We now know that the code
    for an application can consist of thousands of lines of code divided into hundreds
    of files. How can you make sure that the names you give something are not already
    taken? We also learned that we can install packages with code that others have
    written. How can we make sure that they have not given their packages names that
    we have already used? Or how can we make sure that a package we install is not
    using names that another package we already installed is using?
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, handling names can be tricky. Let's look at an example. In [*Chapter
    8*](B15554_08_Final_NM_ePub.xhtml#_idTextAnchor116), *Understanding Functions*,
    we will discuss what a function is and how it works. For this example, all we
    need to know about functions is that they have a name and consist of several lines
    of code. We use the function name to call it, which will make the code inside
    it run.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we are constructing a calculator app. First, let''s have a
    look at what the application might look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – Our calculator application](img/B15554_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – Our calculator application
  prefs: []
  type: TYPE_NORMAL
- en: 'When the user clicks on the square root button, (![](img/Formula_04_001.png))
    , we have to calculate the square root of the number currently in the display.
    This means that we need to connect some code with the event that occurs when this
    button is clicked. This code needs to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: It needs to get the value currently in the display.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, it needs to calculate the square root of that value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, it needs to put the result in the display of the calculator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These instructions will be carried out when the square root button is pressed,
    and we stick them in a function. Now, this function needs a name. The name *squareroot*
    is rather long, so you might decide to shorten it to *sqrt*.
  prefs: []
  type: TYPE_NORMAL
- en: When you reach the point where you want to calculate the square root, you will
    most likely use a built-in function that will help us with this. Most languages
    will have such a function, and often, its name will be `sqrt`. This is a problem,
    as we gave our function the same name as a function that comes shipped with the
    language. We could, of course, rename our function to something else. Don't despair
    – namespaces will solve this problem for us.
  prefs: []
  type: TYPE_NORMAL
- en: Delving into namespaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand what a namespace is, we can think of files and folders on our
    computer. Assume that you are going to have two parties soon: one summer party
    and a birthday party. You write two invitations to the parties and try to store
    them in a folder on your computer.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You have named both files `Party Invitation`, but you can''t have two files
    with the same name in the same folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 – Two files in the same folder can''t have the same name](img/B15554_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.4 – Two files in the same folder can't have the same name
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of renaming one file, you can create two folders and store the files
    in one folder each. This way, the files can still have the name `Party Invitation`,
    and there is no longer a conflict between the names as they are in separate folders,
    as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5 – Storing files in separate folders to avoid naming conflicts](img/B15554_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.5 – Storing files in separate folders to avoid naming conflicts
  prefs: []
  type: TYPE_NORMAL
- en: To summarize this, on a computer, we can have multiple files with the same name,
    but within a folder, the filenames must be unique.
  prefs: []
  type: TYPE_NORMAL
- en: Many programming languages use a similar technique, called namespaces. Namespaces
    let us reuse the same name multiple times within an application, but in a namespace,
    all the names must be unique. The namespace acts like the folders on the computer,
    and the things we are naming are like the files.
  prefs: []
  type: TYPE_NORMAL
- en: How namespaces are implemented will differ between languages. Let's examine
    how some of the more popular languages have implemented them.
  prefs: []
  type: TYPE_NORMAL
- en: Namespaces in JavaScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In JavaScript, when we define things such as functions, we can create a namespace
    by surrounding the part we want to belong to the namespace with curly brackets,
    `{}`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we represent our `sqrt` function in a namespace called `myCalc`, it will
    look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: On the first line, we define a namespace called `myCalc`. We use an open bracket
    to indicate the beginning of the namespace; the closing bracket on the last line
    marks the end of the namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Within the brackets, we find a function named `sqrt`. The function also uses
    open and close brackets to indicate where it starts and ends. In this example,
    the function is empty, so there is nothing there.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now access both our own function and the built-in function, even if
    both are named `sqrt`. It could look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The first line calls the `sqrt` function within the `myCalc` namespace. The
    second line calls the built-in `sqrt` function. It is in a namespace called `Math`.
    That function will accept a value (the value we want to take the square root of),
    and here, we pass the value `9`.
  prefs: []
  type: TYPE_NORMAL
- en: Namespaces in Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Python, namespaces are defined by individual modules. A module in Python
    is a file, so everything in a file (that is, a Python module) is in the same namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now create a file called `myCalc.py`. The`.py` extension indicates that
    this file contains Python code. It is in this file where we add our `sqrt` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6 – Project structure in Python](img/B15554_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.6 – Project structure in Python
  prefs: []
  type: TYPE_NORMAL
- en: Look at the preceding diagram. The `main_application.py` file is our main program
    that uses the code inside `myCalc.py`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `main_application.py` file, we can now access both the built-in
    `sqrt` function and the `sqrt` function we created, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'From the preceding code, we can see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: In the first line, we say that we want to be able to use things from the `math`
    module. Remember that Python uses the concept that a module is a namespace, so
    `math` is both a module and a namespace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second line does the same for our `myCalc` module, which contains our `sqrt`
    function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On line three, we call the `sqrt` function in the `myCalc` module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the last line, we call the `sqrt` function in the `math` module and pass
    `9` to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Namespaces in C++
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In C++, we have a keyword. A *keyword* is a word that is reserved by the language
    and has a special meaning. Refer to [*Chapter 2*](B15554_02_Final_NM_ePub.xhtml#_idTextAnchor029),
    *Introduction to Programming Languages*, for a more thorough explanation of keywords.
    Here, we have a keyword called `namespace` that we can use to define a namespace.
    It could look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, we first create a namespace called `myCalc`, containing a function called
    `sqrt`. Note that just as in the JavaScript example, the function has an opening
    and a closing bracket, indicating the start and the end of the function, and just
    as in that example, the function is empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'C++ then uses a special syntax to access something within a namespace. First,
    we state what namespace we want to use, followed by two colons, `::`, and then
    what it is within this namespace we want to use. This can look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The first line calls the `sqrt` function in the namespace we defined previously.
  prefs: []
  type: TYPE_NORMAL
- en: The second line calls the `sqrt` function in the standard namespace, called
    `std` in C++, passing the value `c` to it.
  prefs: []
  type: TYPE_NORMAL
- en: Namespaces in other languages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These were just a few examples of how namespaces are used in some languages.
    Other languages have their own variants of this. For example, in Java, namespaces
    are closely connected to how packages are used. In C#, namespaces are implemented
    almost in the same way as they are in C++, but not accessed with a double colon.
    Instead, they are accessed with a dot, `.`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know a little bit about namespaces, let's return to our calculator
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Using namespaces in our calculator application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are at the point where we want to name a `sqrt` function, and we have realized
    that the language we use also has a function called `sqrt`. This built-in `sqrt`
    function will calculate the square root for any number we pass to it. We don't
    want to rename our function; instead, we want to solve the naming conflict with
    the use of namespaces.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we need to do is understand how namespaces are used in the current
    language. As we saw previously, the way we define and use namespaces will differ
    between languages.
  prefs: []
  type: TYPE_NORMAL
- en: By adding our `sqrt` function inside its namespace, we don't need to worry about
    a naming conflict with the built-in `sqrt` function or any other function that
    we might get when importing packages using a package manager. Everything is defined
    within different namespaces and we will need to state in what namespace the function
    we want is located.
  prefs: []
  type: TYPE_NORMAL
- en: 'We already know what our `sqrt` function needs to do: get the value from the
    display, calculate the square root of that value, and then put the resulting value
    back into the display.'
  prefs: []
  type: TYPE_NORMAL
- en: We will add our `sqrt` function to a namespace to avoid a naming conflict with
    the built-in version. We also want to use the built-in `sqrt` function from within
    our function. We can do that by specifying what namespace the built-in `sqrt`
    resides in.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, the focus has been on organizing our code and how to name things
    so that we can avoid naming conflicts.
  prefs: []
  type: TYPE_NORMAL
- en: A book is divided into chapters to make it easier to read and navigate. In the
    same way, we want our code to be easy to read and understand. We don't have the
    concept of chapters in programming, but we do have modules. A module is a part
    of our application where the code is logically related; that is, one way or the
    other, it works with the code. A module is often defined as a separate code file.
  prefs: []
  type: TYPE_NORMAL
- en: In larger projects, we can end up with a large number of modules. Due to this,
    we need a way to organize them so that the compiler or interpreter can locate
    the correct file when all the pieces needs to be put together. We do this with
    the help of a project. We can see the project as a form of container for all our
    modules, but also for other resources that our application might use, such as
    images, configuration files, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Writing programs is about being efficient and focusing our time and attention
    on what is important to make the program do what it is intended to do. We will
    often face situations where we need to solve a problem that we know others have
    solved before us. It is therefore not considered a bad thing to reuse the work
    of others in our application. The software programming community/industry is very
    open and helpful, and programmers share and reuse code from others all the time.
    By doing this, we can focus our efforts on what makes our application unique and
    not spend time reinventing the wheel again and again.
  prefs: []
  type: TYPE_NORMAL
- en: One way we can make use of code that others have written is by using tools that
    often come shipped with the language, called package managers. These tools will
    store code that we can reuse in a central location online. They will also help
    us find what we need and download install, and configure it for us.
  prefs: []
  type: TYPE_NORMAL
- en: However, as our applications grow and we use code that's been written by others,
    we will need a way to avoid naming conflicts. If I use a name for something that
    has already been used elsewhere in my application, the language must have a way
    to distinguish between the two. This is done with something called namespaces.
    A name that we give something must only be unique within a namespace. If we divide
    our applications into several namespaces, we will reduce the risk of name clashes
    dramatically.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we are finally ready to dig into the process of writing programs. In the
    next chapter, we will look at the most fundamental building blocks of any program
    in terms of sequences.
  prefs: []
  type: TYPE_NORMAL
