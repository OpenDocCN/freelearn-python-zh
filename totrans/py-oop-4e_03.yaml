- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: When Objects Are Alike
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 当物体相似时
- en: In the programming world, duplicate code is considered evil. We should not have
    multiple copies of the same, or similar, code in different places. When we fix
    a bug in one copy and fail to fix the same bug in another copy, we've caused no
    end of problems for ourselves.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程领域，重复代码被视为邪恶。我们不应该在不同地方有相同或相似的代码的多个副本。当我们修复了一个副本中的错误，却未能修复另一个副本中的相同错误时，我们给自己带来了无穷无尽的麻烦。
- en: 'There are many ways to merge pieces of code or objects that have a similar
    functionality. In this chapter, we''ll be covering the most famous object-oriented
    principle: inheritance. As discussed in *Chapter 1*, *Object-Oriented Design*,
    inheritance allows us to create "is-a" relationships between two or more classes,
    abstracting common logic into superclasses and extending the superclass with specific
    details in each subclass. In particular, we''ll be covering the Python syntax
    and principles for the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 合并具有相似功能的代码或对象有许多方法。在本章中，我们将介绍最著名的面向对象原则：继承。正如在*第一章*，*面向对象设计*中讨论的那样，继承使我们能够在两个或更多类之间创建“是”的关系，将共同逻辑抽象到超类中，并在每个子类中用特定细节扩展超类。特别是，我们将介绍以下Python语法和原则：
- en: Basic inheritance
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本继承
- en: Inheriting from built-in types
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从内置类型继承
- en: Multiple inheritance
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多重继承
- en: Polymorphism and duck typing
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多态和鸭子类型
- en: This chapter's case study will expand on the previous chapter. We'll leverage
    the concepts of inheritance and abstraction to look for ways to manage common
    code in parts of the *k*-nearest neighbors computation.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的案例研究将扩展上一章的内容。我们将利用继承和抽象的概念来寻找管理*k*最近邻计算中公共代码的方法。
- en: We'll start by taking a close look at how inheritance works to factor out common
    features so we can avoid copy-and-paste programming.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先详细探讨继承的工作原理，以便提取共同特性，从而避免复制粘贴编程。
- en: Basic inheritance
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本继承
- en: Technically, every class we create uses inheritance. All Python classes are
    subclasses of the special built-in class named `object`. This class provides a
    little bit of metadata and a few built-in behaviors so Python can treat all objects
    consistently.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 技术上讲，我们创建的每个类都使用了继承。所有 Python 类都是名为 `object` 的特殊内置类的子类。这个类提供了一点点元数据和一些内置行为，以便
    Python 可以一致地处理所有对象。
- en: 'If we don''t explicitly inherit from a different class, our classes will automatically
    inherit from `object`. However, we can redundantly state that our class derives
    from `object` using the following syntax:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有显式地从不同的类继承，我们的类将自动继承自`object`。然而，我们可以使用以下语法冗余地声明我们的类继承自`object`：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is inheritance! This example is, technically, no different from our very
    first example in *Chapter 2*, *Objects in Python*. In Python 3, all classes automatically
    inherit from `object` if we don't explicitly provide a different **superclass**.
    The superclasses, or *parent* classes, in the relationship are the classes that
    are being inherited from, `object` in this example. A subclass – `MySubClass`,
    in this example – inherits from a superclass. A subclass is also said to be *derived
    from* its parent class, or the subclass *extends* the parent class.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是继承！从技术上讲，这个例子与我们*第二章*中非常第一个例子没有区别，即*Python中的对象*。在Python 3中，如果我们没有明确提供不同的**超类**，所有类都会自动从`object`继承。在这个例子中，超类或*父类*是继承的类，即`object`。一个子类——在这个例子中是`MySubClass`——从超类继承。子类也被说成是*从其父类派生*，或者子类*扩展*了父类。
- en: As you've probably figured out from the example, inheritance requires a minimal
    amount of extra syntax over a basic class definition. Simply include the name
    of the parent class inside parentheses between the class name and the colon that
    follows. This is all we have to do to tell Python that the new class should be
    derived from the given superclass.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从示例中可能已经推断出来，继承相对于基本类定义只需要额外的少量语法。只需在类名和冒号之间用括号包含父类的名称即可。这就是我们要做的全部，以告诉Python新类应该从给定的超类派生。
- en: 'How do we apply inheritance in practice? The simplest and most obvious use
    of inheritance is to add functionality to an existing class. Let''s start with
    a contact manager that tracks the names and email addresses of several people.
    The `Contact` class is responsible for maintaining a global list of all contacts
    ever seen in a class variable, and for initializing the name and address for an
    individual contact:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何在实践中应用继承？继承最简单和最明显的用途是为现有类添加功能。让我们从一个联系人管理器开始，它跟踪几个人的姓名和电子邮件地址。`Contact`类负责维护一个全局列表，其中包含一个类变量中曾经见过的所有联系人，并为单个联系人初始化姓名和地址：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This example introduces us to **class variables**. The `all_contacts` list,
    because it is part of the class definition, is shared by all instances of this
    class. This means that there is only one `Contact.all_contacts` list. We can also
    access it as `self.all_contacts` from within any method on an instance of the `Contact` class.
    If a field can't be found on the object (via `self`), then it will be found on
    the class and will thus refer to the same single list.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子向我们介绍了**类变量**。`all_contacts`列表，因为它属于类定义的一部分，被这个类的所有实例共享。这意味着只有一个`Contact.all_contacts`列表。我们也可以从`Contact`类的任何实例的方法中通过`self.all_contacts`来访问它。如果一个字段在对象上（通过`self`）找不到，那么它将在类上找到，因此将引用同一个单个列表。
- en: Be careful with the `self`-based reference. It can only provide access to an
    existing class-based variable. If you ever attempt to **set** the variable using `self.all_contacts`,
    you will actually be creating a **new** instance variable associated just with
    that object. The class variable will still be unchanged and accessible as `Contact.all_contacts`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 小心使用基于`self`的引用。它只能提供访问现有基于类的变量的权限。如果你试图使用`self.all_contacts`来**设置**变量，实际上你将会创建一个仅与该对象关联的**新**实例变量。类变量将保持不变，并且可以通过`Contact.all_contacts`进行访问。
- en: 'We can see how the class tracks data with the following example:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下示例了解该类如何跟踪数据：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We created two instances of the `Contact` class and assigned them to variables
    `c_1` and `c_2`. When we looked at the `Contact.all_contacts` class variable,
    we saw that the list has been updated to track the two objects.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了两个`Contact`类的实例，并将它们分别赋值给变量`c_1`和`c_2`。当我们查看`Contact.all_contacts`类变量时，我们发现列表已经更新，以跟踪这两个对象。
- en: 'This is a simple class that allows us to track a couple of pieces of data about
    each contact. But what if some of our contacts are also suppliers that we need
    to order supplies from? We could add an `order` method to the `Contact` class,
    but that would allow people to accidentally order things from contacts who are
    customers or family friends. Instead, let''s create a new `Supplier` class that
    acts like our `Contact` class, but has an additional `order` method that accepts
    a yet-to-be-defined `Order` object:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的类，它允许我们跟踪每个联系人的几项数据。但如果我们的一些联系人也是我们需要从他们那里订购物资的供应商怎么办呢？我们可以在`Contact`类中添加一个`order`方法，但这样可能会让人们在无意中从客户或家人朋友那里订购东西。相反，让我们创建一个新的`Supplier`类，它类似于我们的`Contact`类，但有一个额外的`order`方法，该方法接受一个尚未定义的`Order`对象：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, if we test this class in our trusty interpreter, we see that all contacts,
    including suppliers, accept a name and email address in their `__init__()` method,
    but that only `Supplier` instances have an `order()` method:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们在我们可靠的解释器中测试这个类，我们会看到所有联系，包括供应商，都在它们的`__init__()`方法中接受一个名称和电子邮件地址，但只有`Supplier`实例才有`order()`方法：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Our `Supplier` class can do everything a contact can do (including adding itself
    to the list of `Contact.all_contacts`) and all the special things it needs to
    handle as a supplier. This is the beauty of inheritance.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Supplier`类可以做到一个联系人所能做的一切（包括将自己添加到`Contact.all_contacts`的列表中），以及作为供应商需要处理的特殊事务。这就是继承的美丽之处。
- en: Also, note that `Contact.all_contacts` has collected every instance of the `Contact`
    class as well as the subclass, `Supplier`. If we used `self.all_contacts`, then
    this would **not** collect all objects into the `Contact` class, but would put
    `Supplier` instances into `Supplier.all_contacts`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意`Contact.all_contacts`已经收集了`Contact`类及其子类`Supplier`的每一个实例。如果我们使用`self.all_contacts`，那么这**不会**将所有对象收集到`Contact`类中，而是将`Supplier`实例放入`Supplier.all_contacts`中。
- en: Extending built-ins
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展内置功能
- en: One interesting use of this kind of inheritance is adding functionality to built-in
    classes. In the `Contact` class seen earlier, we are adding contacts to a list
    of all contacts. What if we also wanted to search that list by name? Well, we
    could add a method on the `Contact` class to search it, but it feels like this
    method actually belongs to the list itself.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这种继承的一个有趣用途是向内置类添加功能。在前面看到的`Contact`类中，我们正在将联系人添加到所有联系人的列表中。如果我们还想按名称搜索这个列表怎么办？嗯，我们可以在`Contact`类上添加一个方法来搜索它，但感觉这个方法实际上属于列表本身。
- en: 'The following example shows how we can do this using inheritance from a built-in
    type. In this case, we''re using the `list` type. We''re going to inform **mypy**
    that our list is only of instances of the `Contact` class by using `list["Contact"]`.
    For this syntax to work in Python 3.9, we need to also import the `annotations`
    module from the `__future__` package. The definitions look like this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了我们如何通过从内置类型继承来实现这一点。在这种情况下，我们使用的是`list`类型。我们将通过使用`list["Contact"]`来通知**mypy**我们的列表只包含`Contact`类的实例。为了使此语法在Python
    3.9中工作，我们还需要从`__future__`包中导入`annotations`模块。定义看起来是这样的：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Instead of instantiating a generic list as our class variable, we create a
    new `ContactList` class that extends the built-in `list` data type. Then, we instantiate
    this subclass as our `all_contacts` list. We can test the new search functionality
    as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是将一个通用列表作为我们的类变量，而是创建一个新的`ContactList`类，该类扩展了内置的`list`数据类型。然后，我们将这个子类实例化为我们自己的`all_contacts`列表。我们可以如下测试新的搜索功能：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We have two ways to create generic list objects. With type hints, we have another
    way of talking about lists, separate from creating actual list instances.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两种创建通用列表对象的方法。使用类型提示，我们有了另一种谈论列表的方式，这不同于创建实际的列表实例。
- en: 'First, creating a list with `[]` is actually a shortcut for creating a list
    using `list()`; the two syntaxes behave identically:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用`[]`创建列表实际上是一个使用`list()`创建列表的快捷方式；这两种语法的行为相同：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `[]` is short and sweet. We can call it **syntactic sugar**; it is a call
    to the `list()` constructor, written with two characters instead of six. The `list` name
    refers to a data type: it is a class that we can extend.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`[]` 简短而甜美。我们可以称它为**语法糖**；它是对 `list()` 构造函数的调用，用两个字符代替了六个字符。`list` 名称指的是一种数据类型：它是一个我们可以扩展的类。'
- en: Tools like **mypy** can check the body of the `ContactList.search()` method
    to be sure it really will create a `list` instance populated with `Contact` objects.
    Be sure you've installed a version that's 0.812 or newer; older versions of **mypy**
    don't handle these annotations based on generic types completely.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 工具如 **mypy** 可以检查 `ContactList.search()` 方法的主体，以确保它确实会创建一个填充有 `Contact` 对象的
    `list` 实例。请确保您已安装了 0.812 或更高版本的版本；**mypy** 的旧版本无法完全处理基于泛型的这些注解。
- en: Because we provided the `Contact` class definition after the definition of the
    `ContactList` class, we had to provide the reference to a not-yet-defined class
    as a string, `list["Contact"]`. It's often more common to provide the individual
    item class definition first, and the collection can then refer to the defined
    class by name without using a string.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在`ContactList`类的定义之后提供了`Contact`类的定义，我们不得不将一个尚未定义的类的引用作为字符串提供，即`list["Contact"]`。通常情况下，先提供单个项目类的定义更为常见，然后集合可以无使用字符串通过名称引用已定义的类。
- en: 'As a second example, we can extend the `dict` class, which is a collection
    of keys and their associated values. We can create instances of dictionaries using
    the `{}` syntax sugar. Here''s an extended dictionary that tracks the longest
    key it has seen:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第二个例子，我们可以扩展`dict`类，它是一个键及其相关值的集合。我们可以使用`{}`语法糖来创建字典的实例。以下是一个扩展的字典，它跟踪它所看到的最大键长：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The hint for the class narrowed the generic `dict` to a more specific `dict[str,
    int]`; the keys are of type `str` and the values are of type `int`. This helps
    **mypy** reason about the `longest_key()` method. Since the keys are supposed
    to be `str`-type objects, the statement `for key in self:` will iterate over `str`
    objects. The result will be a `str`, or possibly `None`. That's why the result
    is described as `Optional[str]`. (Is `None` appropriate? Perhaps not. Perhaps
    a `ValueError` exception is a better idea; that will have to wait until *Chapter
    4*, *Expecting the Unexpected*.)
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 课程提示将通用的 `dict` 窄化为更具体的 `dict[str, int]`；键的类型为 `str`，值的类型为 `int`。这有助于 **mypy**
    推理 `longest_key()` 方法。由于键应该是 `str` 类型的对象，因此 `for key in self:` 语句将遍历 `str` 对象。结果将是
    `str` 类型，或者可能是 `None`。这就是为什么结果被描述为 `Optional[str]` 的原因。（`None` 是否合适？或许并不合适。或许抛出一个
    `ValueError` 异常会更好；这将在 *第4章，意料之外* 中讨论。）
- en: 'We''re going to be working with strings and integer values. Perhaps the strings
    are usernames, and the integer values are the number of articles they''ve read
    on a website. In addition to the core username and reading history, we also need
    to know the longest name so we can format a table of scores with the right size
    display box. This is easy to test in the interactive interpreter:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将处理字符串和整数值。也许这些字符串是用户名，而整数值是他们在一个网站上阅读的文章数量。除了核心的用户名和阅读历史之外，我们还需要知道最长的名字，以便我们可以格式化一个具有正确尺寸显示框的分数表。这可以在交互式解释器中轻松测试：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: What if we wanted a more generic dictionary? Say with either strings **or**
    integers as the values? We'd need a slightly more expansive type hint. We might
    use `dict[str, Union[str, int]]` to describe a dictionary mapping strings to a
    union of either strings or integers.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要一个更通用的字典？比如说，其值可以是字符串**或**整数？我们就需要一个稍微更广泛的类型提示。我们可能会使用`dict[str, Union[str,
    int]]`来描述一个将字符串映射到字符串或整数的并集的字典。
- en: 'Most built-in types can be similarly extended. These built-in types fall into
    several interesting families, with separate kinds of type hints:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数内置类型都可以类似地扩展。这些内置类型分为几个有趣的家族，具有各自类型的提示：
- en: 'Generic collections: `set`, `list`, `dict`. These use type hints like `set[something]`,
    `list[something]`, and `dict[key, value]` to narrow the hint from purely generic
    to something more specific that the application will actually use. To use the
    generic types as annotations, a `from __future__ import annotations` is required
    as the first line of code.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通用集合：`set`、`list`、`dict`。这些使用类型提示如`set[something]`、`list[something]`和`dict[key,
    value]`来将提示从纯泛型缩小到应用实际使用的更具体类型。要使用通用类型作为注解，需要在代码的第一行使用`from __future__ import
    annotations`。
- en: The `typing.NamedTuple` definition lets us define new kinds of immutable tuples
    and provide useful names for the members. This will be covered in *Chapter 7*,
    *Python Data Structures*, and *Chapter 8*, *The Intersection of Object-Oriented
    and Functional Programming*.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`typing.NamedTuple` 定义允许我们定义新的不可变元组类型，并为成员提供有用的名称。这将在 *第7章*，*Python数据结构*，以及
    *第8章*，*面向对象与函数式编程的交汇处* 中进行介绍。'
- en: Python has type hints for file-related I/O objects. A new kind of file can use
    a type hint of `typing.TextIO` or `typing.BinaryIO` to describe built-in file
    operations.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 为文件相关的 I/O 对象提供了类型提示。一种新的文件可以使用 `typing.TextIO` 或 `typing.BinaryIO` 类型提示来描述内置的文件操作。
- en: It's possible to create new types of strings by extending `typing.Text`. For
    the most part, the built-in `str` class does everything we need.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过扩展 `typing.Text`，可以创建新的字符串类型。在大多数情况下，内置的 `str` 类就能满足我们的需求。
- en: New numeric types often start with the `numbers` module as a source for built-in
    numeric functionality.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的数值类型通常以`numbers`模块作为内置数值功能的来源。
- en: We'll use the generic collections heavily throughout the book. As noted, we'll
    look at named tuples in later chapters. The other extensions to built-in types
    are too advanced for this book. In the next section, we'll look more deeply at
    the benefits of inheritance and how we can selectively leverage features of the
    superclass in our subclass.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在整本书中大量使用通用集合。正如所注，我们将在后面的章节中探讨命名元组。对于内置类型的其他扩展，本书内容过于高级。在下一节中，我们将更深入地探讨继承的好处以及我们如何在子类中选择性利用超类特性。
- en: Overriding and super
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 覆盖和超类
- en: So, inheritance is great for *adding* new behavior to existing classes, but
    what about *changing* behavior? Our `Contact` class allows only a name and an
    email address. This may be sufficient for most contacts, but what if we want to
    add a phone number for our close friends?
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，继承非常适合于向现有类中*添加*新的行为，但关于*改变*行为又如何呢？我们的`Contact`类只允许添加姓名和电子邮件地址。这可能对大多数联系人来说已经足够了，但如果我们想为我们的亲密朋友添加电话号码怎么办呢？
- en: 'As we saw in *Chapter 2*, *Objects in Python*, we can do this easily by setting
    a `phone` attribute on the contact after it is constructed. But if we want to
    make this third variable available on initialization, we have to override the `__init__()`
    method. Overriding means altering or replacing a method of the superclass with
    a new method (with the same name) in the subclass. No special syntax is needed
    to do this; the subclass''s newly created method is automatically called instead
    of the superclass''s method, as shown in the following code:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如同我们在*第二章*，*Python中的对象*中看到的，我们可以在对象构建后通过设置一个`phone`属性来轻松实现这一点。但如果我们想在初始化时使这个第三个变量可用，我们必须重写`__init__()`方法。重写意味着用子类中具有相同名称的新方法（或替换）来更改或替换超类的方法。为此不需要特殊的语法；子类新创建的方法会自动被调用，而不是调用超类的方法，如下面的代码所示：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Any method can be overridden, not just `__init__()`. Before we go on, however,
    we need to address some problems in this example. Our `Contact` and `Friend` classes
    have duplicate code to set up the `name` and `email` properties; this can make
    code maintenance complicated, as we have to update the code in two or more places.
    More alarmingly, our `Friend` class is neglecting to add itself to the `all_contacts` list
    we have created on the `Contact` class. Finally, looking forward, if we add a
    feature to the `Contact` class, we'd like it to also be part of the `Friend` class.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 任何方法都可以被覆盖，不仅仅是`__init__()`。然而，在我们继续之前，我们需要解决这个例子中的一些问题。我们的`Contact`和`Friend`类在设置`name`和`email`属性方面有重复的代码；这可能会使代码维护变得复杂，因为我们不得不在两个或更多的地方更新代码。更令人担忧的是，我们的`Friend`类正在忽视将自身添加到我们在`Contact`类上创建的`all_contacts`列表中。最后，展望未来，如果我们向`Contact`类添加一个功能，我们希望它也成为`Friend`类的一部分。
- en: 'What we really need is a way to execute the original `__init__()` method on
    the `Contact` class from inside our new class. This is what the `super()` function
    does; it returns the object as if it was actually an instance of the parent class,
    allowing us to call the parent method directly:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们真正需要的是一种方法，在新的类内部执行`Contact`类的原始`__init__()`方法。这正是`super()`函数的作用；它返回一个对象，仿佛它实际上是父类的一个实例，这样我们就可以直接调用父类的方法：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This example first binds the instance to the parent class using `super()` and
    calls `__init__()` on that object, passing in the expected arguments. It then
    does its own initialization, namely, setting the `phone` attribute, which is unique
    to the `Friend` class.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例首先使用`super()`将实例绑定到父类，并在该对象上调用`__init__()`方法，传入预期的参数。然后它执行自己的初始化，即设置`phone`属性，这是`Friend`类独有的。
- en: 'The `Contact` class provided a definition for the `__repr__()` method to produce
    a string representation. Our class did not override the `__repr__()` method inherited
    from the superclass. Here''s the consequence of that:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`Contact` 类提供了一个定义，用于生成字符串表示形式的 `__repr__()` 方法。我们的类没有覆盖从超类继承来的 `__repr__()`
    方法。以下是这种做法的后果：'
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The details shown for a `Friend` instance don't include the new attribute. It's
    easy to overlook the special method definitions when thinking about class design.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Friend`实例显示的详细信息不包括新属性。在考虑类设计时，很容易忽略特殊方法定义。
- en: A `super()` call can be made inside any method. Therefore, all methods can be
    modified via overriding and calls to `super()`. The call to `super()` can also
    be made at any point in the method; we don't have to make the call as the first
    line. For example, we may need to manipulate or validate incoming parameters before
    forwarding them to the superclass.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何方法内部都可以调用`super()`。因此，所有方法都可以通过重写和调用`super()`来修改。`super()`的调用也可以在任何方法点进行；我们不必将调用作为第一行执行。例如，我们可能需要在将参数转发给超类之前对其进行操作或验证。
- en: Multiple inheritance
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多重继承
- en: 'Multiple inheritance is a touchy subject. In principle, it''s simple: a subclass
    that inherits from more than one parent class can access functionality from both
    of them. In practice, it requires some care to be sure any method overrides are
    fully understood.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 多重继承是一个敏感的话题。在原则上，它是简单的：一个从多个父类继承的子类可以访问它们的功能。在实践中，它需要一些小心，以确保任何方法覆盖都被完全理解。
- en: As a humorous rule of thumb, if you think you need multiple inheritance, you're
    probably wrong, but if you know you need it, you might be right.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一条幽默的经验法则，如果你认为你需要多重继承，你可能错了，但如果你确实需要它，你可能是对的。
- en: The simplest and most useful form of multiple inheritance follows a design pattern
    called the **mixin**. A mixin class definition is not intended to exist on its
    own, but is meant to be inherited by some other class to provide extra functionality.
    For example, let's say we wanted to add functionality to our `Contact` class that
    allows sending an email to `self.email`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单且最有用的多重继承形式遵循一种名为**混入（mixin）**的设计模式。混入类定义并不是为了独立存在，而是意味着它将被其他类继承以提供额外的功能。例如，假设我们想要为我们的`Contact`类添加功能，使其能够向`self.email`发送电子邮件。
- en: 'Sending email is a common task that we might want to use on many other classes.
    So, we can write a simple mixin class to do the emailing for us:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 发送电子邮件是一项常见的任务，我们可能在许多其他课程中也会用到。因此，我们可以编写一个简单的混合类来帮我们完成电子邮件发送：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `MailSender` class doesn''t do anything special (in fact, it can barely
    function as a standalone class, since it assumes an attribute it doesn''t set).
    We have two classes because we''re describing two things: aspects of the host
    class for a mixin, and new aspects the mixin provides to the host. We needed to
    create a hint, `Emailable`, to describe the kinds of classes our `MailSender`
    mixin expects to work with.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`MailSender` 类没有做任何特别的事情（实际上，它几乎不能作为一个独立的类使用，因为它假设了一个它没有设置的属性）。我们有两个类，因为我们描述了两件事情：混合类的主类方面以及混合类提供给主类的新方面。我们需要创建一个提示，`Emailable`，来描述我们的
    `MailSender` 混合类期望与之一起工作的类类型。'
- en: This kind of type hint is called a **protocol**; protocols generally have methods,
    and can also have class-level attribute names with type hints, but not full assignment
    statements. A protocol definition is a kind of incomplete class; think of it like
    a contract for features of a class. A protocol tells **mypy** that any class (or
    subclass) of `Emailable` objects must support an `email` attribute, and it must
    be a string.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型提示被称为**协议**；协议通常有方法，也可以有带有类型提示的类级别属性名，但不能有完整的赋值语句。协议定义是一种不完整的类；可以将其想象为类特征的合同。协议告诉
    **mypy** 任何 `Emailable` 对象的类（或子类）必须支持一个 `email` 属性，并且它必须是一个字符串。
- en: Note that we're relying on Python's name resolution rules. The name `self.email`
    can be resolved as either an instance variable, or a class-level variable, `Emailable.email`,
    or a property. The **mypy** tool will check all the classes mixed in with `MailSender`
    for instance- or class-level definitions. We only need to provide the name of
    the attribute at the class level, with a type hint to make it clear to **mypy**
    that the mixin does not define the attribute – the class into which it's mixed
    will provide the `email` attribute.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们依赖于 Python 的名称解析规则。名称 `self.email` 可以解析为实例变量，或者类级别变量 `Emailable.email`，或者属性。**mypy**
    工具将检查与 `MailSender` 混合的所有类中的实例或类级别定义。我们只需要在类级别提供属性的名称，并附上类型提示，以便向 **mypy** 表明混合类没有定义该属性——混合到其中的类将提供
    `email` 属性。
- en: Because of Python's duck typing rules, we can use the `MailSender` mixin with
    any class that has an `email` attribute defined. A class with which `MailSender`
    is mixed doesn't have to be a formal subclass of `Emailable`; it only has to provide
    the required attribute.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Python的鸭子类型规则，我们可以将`MailSender`混入任何定义了`email`属性的类。与`MailSender`混入的类不必是`Emailable`的正式子类；它只需提供所需的属性即可。
- en: For brevity, we didn't include the actual email logic here; if you're interested
    in studying how it's done, see the `smtplib` module in the Python standard library.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁，我们没有在这里包含实际的电子邮件逻辑；如果您想了解它是如何实现的，请参阅Python标准库中的`smtplib`模块。
- en: 'The `MailSender` class does allow us to define a new class that describes both
    a `Contact` and a `MailSender`, using multiple inheritance:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`MailSender` 类确实允许我们定义一个新的类，该类描述了`Contact`和`MailSender`，通过多重继承实现：'
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The syntax for multiple inheritance looks like a parameter list in the class
    definition. Instead of including one base class inside the parentheses, we include
    two (or more), separated by a comma. When it's done well, it's common for the
    resulting class to have no unique features of its own. It's a combination of mixins,
    and the body of the class definition is often nothing more than the `pass` placeholder.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 多重继承的语法看起来像类定义中的参数列表。我们不是在括号内包含一个基类，而是包含两个（或更多），用逗号分隔。当做得好的时候，结果类通常没有自己独特的特性。它是混入（mixins）的组合，类定义的主体通常只是`pass`占位符。
- en: 'We can test this new hybrid to see the mixin at work:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以测试这个新的混合体，看看混合效果如何：
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `Contact` initializer is still adding the new contact to the `all_contacts` list,
    and the mixin is able to send mail to `self.email`, so we know that everything
    is working.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`Contact` 初始化器仍在将新的联系人添加到 `all_contacts` 列表中，并且混入（mixin）能够向 `self.email` 发送邮件，因此我们知道一切都在正常工作。'
- en: 'This wasn''t so hard, and you''re probably wondering what our dire warnings
    about multiple inheritance were for. We''ll get into the complexities in a minute,
    but let''s consider some other options we had for this example, rather than using
    a mixin:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不那么困难，你可能想知道我们关于多重继承的严重警告是为了什么。我们稍后会深入探讨复杂性，但让我们考虑一下这个例子中我们有的其他选项，而不是使用混入（mixin）：
- en: We could have used single inheritance and added the `send_mail` function to
    a subclass of `Contact`. The disadvantage here is that the email functionality
    then has to be duplicated for any unrelated classes that need an email. For example,
    if we had email information in the payments part of our application, unrelated
    to these contacts, and we wanted a `send_mail()` method, we'd have to duplicate
    the code.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们本可以使用单继承，并将`send_mail`函数添加到`Contact`的子类中。这里的缺点是，电子邮件功能必须为任何需要电子邮件功能但与之无关的类重复实现。例如，如果我们应用中的支付部分包含电子邮件信息，这些信息与这些联系人无关，而我们想要一个`send_mail()`方法，我们就必须重复代码。
- en: We can create a standalone Python function for sending an email, and just call
    that function with the correct email address supplied as a parameter when the
    email needs to be sent (this is a very common choice). Because the function is
    not part of a class, it's harder to be sure that proper encapsulation is being
    used.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以创建一个独立的 Python 函数用于发送电子邮件，并在需要发送电子邮件时，只需调用该函数并传入正确的电子邮件地址作为参数（这是一个非常常见的做法）。因为这个函数不是类的一部分，所以更难确保使用了适当的封装。
- en: We could explore a few ways of using composition instead of inheritance. For
    example, `EmailableContact` could have a `MailSender` object as a property instead
    of inheriting from it. This leads to a more complex `MailSender` class because
    it now has to stand alone. It also leads to a more complex `EmailableContact`
    class because it has to associate a `MailSender` instance with each `Contact`.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以探索一些使用组合而非继承的方法。例如，`EmailableContact` 可以将 `MailSender` 对象作为属性，而不是从它继承。这导致
    `MailSender` 类变得更加复杂，因为它现在必须独立存在。这也导致 `EmailableContact` 类变得更加复杂，因为它必须将每个 `Contact`
    实例与一个 `MailSender` 实例关联起来。
- en: We could try to monkey patch (we'll briefly cover monkey patching in *Chapter
    13*, *Testing Object-Oriented Programs*) the `Contact` class to have a `send_mail` method
    after the class has been created. This is done by defining a function that accepts
    the `self` argument, and setting it as an attribute on an existing class. This
    is fine for creating a unit test fixture, but terrible for the application itself.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以尝试对`Contact`类进行猴子补丁（我们将在*第13章*，*面向对象程序的测试*中简要介绍猴子补丁），在类创建后添加一个`send_mail`方法。这是通过定义一个接受`self`参数的函数，并将其设置为现有类的属性来实现的。这对于创建单元测试用例是可行的，但对于应用程序本身来说却非常糟糕。
- en: Multiple inheritance works alright when we're mixing methods from different
    classes, but it can be messy when we have to call methods on the superclass. When
    there are multiple superclasses, how do we know which one's methods to call? What is
    the rule for selecting the appropriate superclass method?
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 多重继承在我们混合不同类的方法时工作得很好，但当我们需要在超类上调用方法时可能会变得混乱。当存在多个超类时，我们如何知道应该调用哪个类的的方法？选择合适的超类方法的规则是什么？
- en: 'Let''s explore these questions by adding a home address to our `Friend` class.
    There are a few approaches we might take:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过向我们的`Friend`类添加家庭地址来探讨这些问题。我们可以采取几种方法：
- en: An address is a collection of strings representing the street, city, country,
    and other related details of the contact. We could pass each of these strings
    as a parameter into the `Friend` class's `__init__()` method. We could also store
    these strings in a generic tuple or dictionary. These options work well when the
    address information doesn't need new methods.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地址是一组表示联系人的街道、城市、国家和其他相关细节的字符串集合。我们可以将这些字符串中的每一个作为参数传递给`Friend`类的`__init__()`方法。我们还可以将这些字符串存储在一个通用的元组或字典中。当地址信息不需要新方法时，这些选项工作得很好。
- en: Another option would be to create our own `Address` class to hold those strings
    together, and then pass an instance of this class into the `__init__()` method
    in our `Friend` class. The advantage of this solution is that we can add behavior
    (say, a method to give directions or to print a map) to the data instead of just
    storing it statically. This is an example of composition, as we discussed in *Chapter
    1*, *Object-Oriented Design*. The "has-a" relationship of composition is a perfectly
    viable solution to this problem and allows us to reuse `Address` classes in other
    entities, such as buildings, businesses, or organizations. (This is an opportunity
    to use a dataclass. We'll discuss dataclasses in *Chapter 7*, *Python Data Structures*.)
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个选择是创建我们自己的`Address`类来将这些字符串组合在一起，然后将其实例传递到我们的`Friend`类的`__init__()`方法中。这种解决方案的优势在于，我们可以在数据上添加行为（比如，提供方向或打印地图的方法），而不仅仅是静态地存储它。这是我们之前在*第一章*，*面向对象设计*中讨论的组合的一个例子。组合的“拥有”关系是解决这个问题的完美可行方案，并允许我们在其他实体（如建筑物、企业或组织）中重用`Address`类。（这是一个使用数据类的机会。我们将在*第七章*，*Python
    数据结构*中讨论数据类。）
- en: A third course of action is a cooperative multiple inheritance design. While
    this can be made to work, it doesn't pass muster with **mypy**. The reason, we'll see,
    is some potential ambiguity that's difficult to describe with the available type
    hints.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三种行动方案是合作式多重继承设计。虽然这可以使其工作，但在**mypy**看来并不符合规范。原因，我们将看到，是一些难以用现有类型提示描述的潜在歧义。
- en: The objective here is to add a new class to hold an address. We'll call this
    new class `AddressHolder` instead of `Address` because inheritance defines an
    "is-a" relationship. It is not correct to say a `Friend` class is an `Address` class,
    but since a friend can have an `Address` class, we can argue that a `Friend` class
    is an `AddressHolder` class. Later, we could create other entities (companies,
    buildings) that also hold addresses. (Convoluted naming and nuanced questions
    about "is-a" serve as decent indications we should be sticking with composition,
    rather than inheritance.)
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 此处的目标是添加一个新的类来存储地址。我们将把这个新类命名为`AddressHolder`而不是`Address`，因为继承定义了一个“是”的关系。说一个`Friend`类是一个`Address`类是不正确的，但是既然一个朋友可以有一个`Address`类，我们可以争论说一个`Friend`类是一个`AddressHolder`类。稍后，我们还可以创建其他也持有地址的实体（公司、建筑）。（复杂的命名和关于“是”的微妙问题可以作为我们应坚持组合而不是继承的合理指示。）
- en: 'Here''s a naïve `AddressHolder` class. We''re calling it naïve because it doesn''t
    account for multiple inheritance well:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个简单的`AddressHolder`类。我们称之为简单，因为它在处理多重继承方面做得不好：
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We take all the data and toss the argument values into instance variables upon
    initialization. We'll look at the consequences of this, and then show a better
    design.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在初始化时将所有数据以及参数值抛入实例变量中。我们将探讨这种做法的后果，然后展示一个更好的设计。
- en: The diamond problem
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 钻石问题
- en: 'We can use multiple inheritance to add this new class as a parent of our existing
    `Friend` class. The tricky part is that we now have two parent `__init__()` methods,
    both of which need to be called. And they need to be called with different arguments.
    How do we do this? Well, we could start with a naïve approach for the `Friend`
    class, also:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用多重继承来将这个新类作为我们现有`Friend`类的父类。棘手的部分在于我们现在有两个父类`__init__()`方法，它们都需要被调用。而且它们需要用不同的参数来调用。我们该如何做呢？好吧，我们也可以从对`Friend`类的天真方法开始：
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this example, we directly call the `__init__()` function on each of the superclasses
    and explicitly pass the `self` argument. This example technically works; we can
    access the different variables directly on the class. But there are a few problems.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们直接在每个超类上调用`__init__()`函数，并显式传递`self`参数。这个例子在技术上是可以工作的；我们可以直接在类上访问不同的变量。但存在一些问题。
- en: First, it is possible for a superclass to remain uninitialized if we neglect
    to explicitly call the initializer. That wouldn't break this example, but it could
    cause hard-to-debug program crashes in common scenarios. We would get a lot of
    strange-looking `AttributeError` exceptions in classes where there's clearly an
    `__init__()` method. It's rarely obvious the `__init__()` method wasn't actually
    used.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果忘记显式调用初始化器，一个超类可能保持未初始化状态。这不会破坏这个示例，但在常见场景中可能会导致难以调试的程序崩溃。我们会在那些显然有`__init__()`方法的类中遇到许多看起来奇怪的`AttributeError`异常。实际上并未使用`__init__()`方法这一点通常并不明显。
- en: 'A more insidious possibility is a superclass being called multiple times because
    of the organization of the class hierarchy. Look at this inheritance diagram:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 更为隐蔽的可能性是由于类层次结构的组织，一个超类被多次调用。看看这个继承图：
- en: '![Diagram  Description automatically generated](img/B17070_03_01.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图表描述自动生成](img/B17070_03_01.png)'
- en: 'Figure 3.1: Inheritance diagram for our multiple inheritance implementation'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1：我们多重继承实现的继承图
- en: The `__init__()` method from the `Friend` class first calls `__init__()` on the
    `Contact` class, which implicitly initializes the `object` superclass (remember,
    all classes derive from `object`). The `Friend` class then calls `__init__()` on `AddressHolder`,
    which implicitly initializes the `object` superclass *again*. This means the parent
    class has been set up twice. With the `object` class, that's relatively harmless,
    but in some situations, it could spell disaster. Imagine trying to connect to
    a database twice for every request!
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`Friend` 类的 `__init__()` 方法首先调用 `Contact` 类的 `__init__()`，这隐式地初始化了 `object`
    超类（记住，所有类都从 `object` 继承）。然后 `Friend` 类再次调用 `AddressHolder` 的 `__init__()`，这又隐式地初始化了
    `object` 超类。这意味着父类被设置了两次。使用 `object` 类，这相对无害，但在某些情况下，可能会造成灾难。想象一下，每次请求都要尝试连接数据库两次！'
- en: The base class should only be called once. Once, yes, but when? Do we call `Friend`,
    then `Contact`, then `Object`, and then `AddressHolder`? Or `Friend`, then `Contact`,
    then `AddressHolder`, and then `Object`?
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 基类应该只被调用一次。一次，是的，但何时调用呢？我们是先调用`Friend`，然后是`Contact`，接着是`Object`，最后是`AddressHolder`吗？还是先调用`Friend`，然后是`Contact`，接着是`AddressHolder`，最后是`Object`？
- en: Let's contrive an example to illustrate this problem more clearly. Here, we
    have a base class, `BaseClass`, that has a method named `call_me()`. Two subclasses,
    `LeftSubclass` and `RightSubclass`, extend the `BaseClass` class, and each overrides
    the `call_me()` method with different implementations.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构造一个例子来更清晰地说明这个问题。在这里，我们有一个基类`BaseClass`，它有一个名为`call_me()`的方法。两个子类`LeftSubclass`和`RightSubclass`扩展了`BaseClass`类，并且每个子类都使用不同的实现覆盖了`call_me()`方法。
- en: 'Then, *another* subclass extends both of these using multiple inheritance with
    a fourth, distinct implementation of the `call_me()` method. This is called **diamond
    inheritance** because of the diamond shape of the class diagram:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，*另一个*子类通过多重继承同时扩展了这两个类，并使用第四个，独特的`call_me()`方法实现。这被称为**菱形继承**，因为类图呈现出菱形形状：
- en: '![Diagram  Description automatically generated](img/B17070_03_02.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图表描述自动生成](img/B17070_03_02.png)'
- en: 'Figure 3.2: Diamond inheritance'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2：钻石继承
- en: 'Let''s convert this diagram into code. This example shows when the methods
    are called:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这个图表转换为代码。这个示例展示了方法被调用的时机：
- en: '[PRE18]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This example ensures that each overridden `call_me()` method directly calls
    the parent method with the same name. It lets us know each time a method is called
    by printing the information to the screen. It also creates a distinct instance
    variable to show how many times it has been called.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例确保每个重写的`call_me()`方法都直接调用同名父方法。它通过将信息打印到屏幕上，让我们每次调用方法时都能得知。它还创建了一个独特的实例变量，以显示该方法被调用的次数。
- en: The `self.num_base_calls += 1` line requires a little sidebar explanation.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`self.num_base_calls += 1` 这一行需要一点侧边栏的解释。'
- en: This is effectively `self.num_base_calls = self.num_base_calls + 1`. When Python
    resolves `self.num_base_calls` on the right side of the `=`, it will first look
    for an instance variable, then look for the class variable; we've provided a class
    variable with a default value of zero. After the `+1` computation, the assignment
    statement will create a new instance variable; it will not update the class-level
    variable.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上等同于 `self.num_base_calls = self.num_base_calls + 1`。当Python在等号右侧解析 `self.num_base_calls`
    时，它首先会查找实例变量，然后查找类变量；我们提供了一个默认值为零的类变量。在执行 `+1` 计算之后，赋值语句将创建一个新的实例变量；它不会更新类级别的变量。
- en: Each time after the first call, the instance variable will be found. It's pretty
    cool for the class to provide default values for instance variables.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 每次在第一次调用之后，实例变量将被找到。对于类来说，为实例变量提供默认值是非常酷的。
- en: 'If we instantiate one `Subclass` object and call the `call_me()` method on
    it once, we get the following output:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们实例化一个`Subclass`对象，并对其调用一次`call_me()`方法，我们将得到以下输出：
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Thus, we can see the base class's `call_me()` method being called twice. This
    could lead to some pernicious bugs if that method is doing actual work, such as
    depositing into a bank account, twice.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以看到基类的`call_me()`方法被调用了两次。如果该方法正在执行实际工作，例如向银行账户存钱，这可能会导致一些有害的bug。
- en: Python's **Method Resolution Order** (**MRO**) algorithm transforms the diamond
    into a flat, linear tuple. We can see the results of this in the `__mro__` attribute
    of a class. The linear version of this diamond is the sequence `Subclass`, `LeftSubclass`,
    `RightSubClass`, `BaseClass`, `object`. What's important here is that `Subclass`
    lists `LeftSubclass` before `RightSubClass`, imposing an ordering on the classes
    in the diamond.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Python的**方法解析顺序**（**MRO**）算法将菱形转换为平面的线性元组。我们可以在类的`__mro__`属性中看到这个结果。这个菱形的线性版本是序列`Subclass`，`LeftSubclass`，`RightSubClass`，`BaseClass`，`object`。这里重要的是`Subclass`在`LeftSubclass`之前列出`RightSubClass`，对菱形中的类施加了一个顺序。
- en: The thing to keep in mind with multiple inheritance is that we often want to
    call the next method in the MRO sequence, not necessarily a method of the parent
    class. The `super()` function locates the name in the MRO sequence. Indeed, `super()` was
    originally developed to make complicated forms of multiple inheritance possible.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在多重继承中需要注意的事情是，我们通常想要调用MRO（Method Resolution Order，方法解析顺序）序列中的下一个方法，而不一定是父类的方法。`super()`函数在MRO序列中定位名称。实际上，`super()`函数最初是为了使复杂的多重继承形式成为可能而开发的。
- en: 'Here is the same code written using `super()`. We''ve renamed some of the classes,
    adding an `_S` to make it clear this is the version using `super()`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用 `super()` 编写的相同代码。我们重命名了一些类，添加了 `_S` 以使其明确这是使用 `super()` 的版本：
- en: '[PRE20]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The change is pretty minor; we only replaced the naive direct calls with calls
    to `super()`. The `Subclass_S` class, at the bottom of the diamond, only calls `super()`
    once rather than having to make the calls for both the left and right. The change
    is easy enough, but look at the difference when we execute it:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 变化相当微小；我们只是将原始的直接调用替换为对 `super()` 的调用。位于菱形底部的 `Subclass_S` 类只需调用一次 `super()`，而不是必须对左边的和右边的都进行调用。这个变化足够简单，但看看当我们执行它时的差异：
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This output looks good: our base method is only being called once. We can see
    how this works by looking at the `__mro__` attribute of the class:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出看起来不错：我们的基础方法只被调用了一次。我们可以通过查看类的`__mro__`属性来了解它是如何工作的：
- en: '[PRE22]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The order of the classes shows what order `super()` will use. The last class
    in the tuple is generally the built-in `object` class. As noted earlier in this
    chapter, it's the implicit superclass of all classes.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 类的顺序显示了`super()`将使用什么顺序。元组中的最后一个类通常是内置的`object`类。正如本章前面所提到的，它是所有类的隐式超类。
- en: 'This shows what `super()` is actually doing. Since the `print` statements are
    executed after the `super` calls, the printed output is in the order each method
    is actually executed. Let''s look at the output from back to front to see who
    is calling what:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了`super()`实际上在做什么。由于`print`语句是在`super`调用之后执行的，所以打印的输出顺序是每个方法实际执行的顺序。让我们从后往前查看输出，看看谁在调用什么：
- en: We start with the `Subclass_S.call_me()` method. This evaluates `super().call_me()`.
    The MRO shows `LeftSubclass_S` as next.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从`Subclass_S.call_me()`方法开始。这会评估`super().call_me()`。MRO（方法解析顺序）显示下一个是`LeftSubclass_S`。
- en: We begin evaluation of the `LeftSubclass_S.call_me()` method. This evaluates
    `super().call_me()`. The MRO puts `RightSubclass_S` as next. This is not a superclass;
    it's adjacent in the class diamond.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们开始评估 `LeftSubclass_S.call_me()` 方法。这会评估 `super().call_me()`。MRO（方法解析顺序）将 `RightSubclass_S`
    作为下一个。这并不是一个超类；它在类菱形中是相邻的。
- en: The evaluation of the `RightSubclass_S.call_me()` method, `super().call_me()`.
    This leads to `BaseClass`.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对`RightSubclass_S.call_me()`方法和`super().call_me()`方法的评估，这会导致`BaseClass`。
- en: 'The `BaseClass.call_me()` method finishes its processing: printing a message and
    setting an instance variable, `self.num_base_calls`, to `BaseClass.num_base_calls
    + 1`.'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`BaseClass.call_me()` 方法完成了其处理过程：打印一条消息并将实例变量 `self.num_base_calls` 设置为 `BaseClass.num_base_calls
    + 1`。'
- en: Then, the `RightSubclass_S.call_me()` method can finish, printing a message
    and setting an instance variable, `self.num_right_calls`.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，`RightSubclass_S.call_me()` 方法可以完成，打印一条消息并设置一个实例变量，`self.num_right_calls`。
- en: Then, the `LeftSubclass_S.call_me()` method will finish by printing a message
    and setting an instance variable, `self.num_left_calls`.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，`LeftSubclass_S.call_me()` 方法将通过打印一条消息并设置一个实例变量，`self.num_left_calls` 来结束。
- en: This serves to set the stage for `Subclass_S` to finish its `call_me()` method
    processing. It writes a message, sets an instance variable, and rests, happy and
    successful.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是为了为`Subclass_S`完成其`call_me()`方法处理做好准备。它写了一条消息，设置了一个实例变量，然后休息，感到快乐且成功。
- en: '**Pay particular attention to this**: The `super` call is *not* calling the
    method on the superclass of `LeftSubclass_S` (which is `BaseClass`). Rather, it
    is calling `RightSubclass_S`, even though it is not a direct parent of `LeftSubclass_S`!
    This is the *next* class in the MRO, not the parent method. `RightSubclass_S` then
    calls `BaseClass` and the `super()` calls have ensured each method in the class
    hierarchy is executed once.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**特别留意这一点**：`super`调用并不是在`LeftSubclass_S`（其父类是`BaseClass`）的父类上调用方法。相反，它是在`RightSubclass_S`上调用，即使它不是`LeftSubclass_S`的直接父类！这是MRO（方法解析顺序）中的下一个类，而不是父类方法。然后`RightSubclass_S`调用`BaseClass`，而`super()`调用确保了类层次结构中的每个方法只执行一次。'
- en: Different sets of arguments
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不同的参数集
- en: 'This is going to make things complicated as we return to our `Friend` cooperative
    multiple inheritance example. In the `__init__()` method for the `Friend` class,
    we were originally delegating initialization to the `__init__()` methods of both
    parent classes, *with different sets of arguments*:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使得事情变得复杂，因为我们回到了我们的`Friend`合作式多重继承示例。在`Friend`类的`__init__()`方法中，我们最初是将初始化委托给两个父类的`__init__()`方法，*使用不同的参数集*：
- en: '[PRE23]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: How can we manage different sets of arguments when using `super()`? We only
    really have access to the next class in the MRO sequence. Because of this, we
    need a way to pass the **extra** arguments through the constructors so that subsequent
    calls to super(), from other mixin classes, receive the right arguments.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`super()`时，我们如何管理不同的参数集？我们实际上只能访问MRO（方法解析顺序）序列中的下一个类。正因为如此，我们需要一种方法，通过构造函数传递**额外的**参数，以便后续从其他混入类中对`super()`的调用能够接收到正确的参数。
- en: It works like this. The first call to `super()` provides arguments to the first
    class of the MRO, passing the `name` and `email` arguments to `Contact.__init__()`.
    Then, when `Contact.__init__()` calls `super()`, it needs to be able to pass the
    address-related arguments to the method of the next class in the MRO, which is `AddressHolder.__init__()`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 它的工作原理是这样的。第一次调用`super()`时，将`name`和`email`参数传递给MRO（方法解析顺序）中的第一个类，即传递给`Contact.__init__()`。然后，当`Contact.__init__()`调用`super()`时，它需要能够将地址相关的参数传递给MRO中下一个类的`__init__()`方法，即`AddressHolder.__init__()`。
- en: This problem often manifests itself anytime we want to call superclass methods
    with the same name, but with different sets of arguments. Collisions often arise
    around the special method names. Of these, the most common example is having a
    different set of arguments to various `__init__()` methods, as we're doing here.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题通常在我们想要调用具有相同名称但参数集不同的超类方法时出现。在特殊方法名称周围经常发生冲突。在这些例子中，最常见的情况是具有不同参数集的各种`__init__()`方法，正如我们在这里所做的那样。
- en: There's no magical Python feature to handle cooperation among classes with divergent
    `__init__()` parameters. Consequently, this requires some care to design our class
    parameter lists. The cooperative multiple inheritance approach is to accept keyword
    arguments for any parameters that are not required by every subclass implementation.
    A method must pass the unexpected arguments on to its `super()` call, in case
    they are necessary to later methods in the MRO sequence of classes.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Python 没有魔法般的功能来处理具有不同 `__init__()` 参数的类之间的协作。因此，这需要我们在设计类参数列表时格外小心。协作的多继承方法是为任何不是每个子类实现所必需的参数接受关键字参数。一个方法必须将其意外的参数传递给其
    `super()` 调用，以防它们对于类 MRO（方法解析顺序）序列中后续方法来说是必要的。
- en: While this works and works well, it's difficult to describe with type hints.
    Instead, we have to silence **mypy** in a few key places.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这方法效果很好，但用类型提示来描述它却很困难。相反，我们不得不在几个关键位置关闭**mypy**。
- en: 'Python''s function parameter syntax provides a tool we can use to do this,
    but it makes the overall code look cumbersome. Have a look at a version of the `Friend` multiple
    inheritance code:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的函数参数语法提供了一个我们可以用来做这件事的工具，但它使得整体代码看起来有些笨拙。看看 `Friend` 多重继承代码的一个版本：
- en: '[PRE24]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We've added the `**kwargs` parameter, which collects all additional keyword
    argument values into a dictionary. When called with `Contact(name="this", email="that",
    street="something")`, the `street` argument is put into the `kwargs` dictionary;
    these extra parameters are passed up to the next class with the `super()` call.
    The special parameter `/` separates parameters that could be provided by position
    in the call from parameters that require a keyword to associate them with an argument
    value. We've given all string parameters an empty string as a default value, also.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了`**kwargs`参数，该参数将所有额外的关键字参数值收集到一个字典中。当使用`Contact(name="this", email="that",
    street="something")`调用时，`street`参数被放入`kwargs`字典中；这些额外的参数通过`super()`调用传递到下一个类。特殊参数`/`将可以通过位置在调用中提供的参数与需要通过关键字与参数值关联的参数分开。我们还为所有字符串参数提供了一个空字符串作为默认值。
- en: If you aren't familiar with the `**kwargs` syntax, it basically collects any
    keyword arguments passed into the method that were not explicitly listed in the
    parameter list. These arguments are stored in a dictionary named `kwargs` (we
    can call the variable whatever we like, but convention suggests `kw` or `kwargs`).
    When we call a method, for example, `super().__init__()`, with `**kwargs` as an
    argument value, it unpacks the dictionary and passes the results to the method
    as keyword arguments. We'll look at this in more depth in *Chapter 8*, *The Intersection
    of Object-Oriented and Functional Programming*.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不太熟悉 `**kwargs` 语法，它基本上收集了传递给方法的所有关键字参数，这些参数在参数列表中并未明确列出。这些参数存储在一个名为 `kwargs`
    的字典中（我们可以将变量命名为任何我们喜欢的名字，但惯例建议使用 `kw` 或 `kwargs`）。当我们调用一个方法时，例如，`super().__init__()`，并将
    `**kwargs` 作为参数值，它会展开字典并将结果作为关键字参数传递给方法。我们将在 *第8章*，*面向对象与函数式编程的交汇处* 中更深入地探讨这一点。
- en: 'We''ve introduced two comments that are addressed to **mypy** (and any person
    scrutinizing the code). The `# type: ignore` comments provide a specific error
    code, `call-arg`, on a specific line to be ignored. In this case, we need to ignore
    the `super().__init__(**kwargs)` calls because it isn''t obvious to **mypy** what
    the MRO really will be at runtime. As someone reading the code, we can look at
    the `Friend` class and see the order: `Contact` and `AddressHolder`. This order
    means that inside the `Contact` class, the `super()` function will locate the
    next class, `AddressHolder`.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '我们引入了两个针对 **mypy**（以及任何审查代码的人）的注释。`# type: ignore` 注释在特定行提供了一个特定的错误代码 `call-arg`，以忽略该行。在这种情况下，我们需要忽略
    `super().__init__(**kwargs)` 调用，因为对 **mypy** 来说，运行时实际的 MRO（方法解析顺序）并不明显。作为阅读代码的人，我们可以查看
    `Friend` 类并看到顺序：`Contact` 和 `AddressHolder`。这个顺序意味着在 `Contact` 类内部，`super()` 函数将定位到下一个类，即
    `AddressHolder`。'
- en: The **mypy** tool, however, doesn't look this deeply; it goes by the explicit
    list of parent classes in the `class` statement. Since there's no parent class
    named, **mypy** is convinced the `object` class will be located by `super()`.
    Since `object.__init__()` cannot take any arguments, the `super().__init__(**kwargs)`
    in both `Contact` and `AddressHolder` appears incorrect to **mypy**. Practically,
    the chain of classes in the MRO will consume all of the various parameters and
    there will be nothing left over for the `AddressHolder` class's `__init__()` method.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，**mypy** 工具并不会这样深入地检查；它依据 `class` 语句中显式列出的父类列表。由于没有指定父类名称，**mypy** 相信 `object`
    类将通过 `super()` 方法找到。由于 `object.__init__()` 无法接受任何参数，因此 `Contact` 和 `AddressHolder`
    中的 `super().__init__(**kwargs)` 在 **mypy** 看来是错误的。实际上，MRO（方法解析顺序）中的类链将消耗所有各种参数，并且将没有剩余参数留给
    `AddressHolder` 类的 `__init__()` 方法。
- en: For more information on type hint annotations for cooperative multiple inheritance,
    see [https://github.com/python/mypy/issues/8769](https://github.com/python/mypy/issues/8769).
    The longevity of this issue suggests how hard the solution can be.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 关于合作多继承的类型提示注解的更多信息，请参阅[https://github.com/python/mypy/issues/8769](https://github.com/python/mypy/issues/8769)。该问题持续存在的时间表明解决方案可能有多么困难。
- en: The previous example does what it is supposed to do. But it's supremely difficult
    to answer the question: *What arguments do we need to pass into* `Friend.__init__()`?
    This is the foremost question for anyone planning to use the class, so a docstring
    should be added to the method to explain the entire list of parameters from all
    the parent classes.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子做了它应该做的事情。但是回答以下问题非常困难：*我们需要传递哪些参数给* `Friend.__init__()`？这是任何计划使用该类的人首要的问题，因此应该在方法中添加一个文档字符串来解释所有父类中的参数列表。
- en: 'The error message in the event of a misspelled or extraneous parameter can
    be confusing, also. The message `TypeError: object.__init__() takes exactly one
    argument (the instance to initialize)` isn''t too informative on how an extra
    parameter came to be provided to `object.__init__()`.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '在参数拼写错误或多余的参数情况下出现的错误信息也可能令人困惑。信息`TypeError: object.__init__() takes exactly
    one argument (the instance to initialize)`并没有提供太多关于如何将多余的参数提供给`object.__init__()`的信息。'
- en: We have covered many of the caveats involved with cooperative multiple inheritance
    in Python. When we need to account for all possible situations, we have to plan
    for them, and our code can get messy.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了在Python中涉及合作多继承的许多注意事项。当我们需要考虑所有可能的情况时，我们必须为此做出规划，我们的代码可能会变得混乱。
- en: Multiple inheritance following the mixin pattern often works out very nicely.
    The idea is to have additional methods defined in mixin classes, but to keep all
    of the attributes centralized in a host class hierarchy. This can avoid the complexity
    of cooperative initialization.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 按照mixin模式实现的多个继承通常效果非常好。其思路是在mixin类中定义额外的方法，但将所有属性集中在一个宿主类层次结构中。这样可以避免合作初始化的复杂性。
- en: Design using composition also often works better than complex multiple inheritance.
    Many of the design patterns we'll be covering in *Chapter 11*, *Common Design
    Patterns,* and *Chapter 12*, *Advanced Design Patterns*, are examples of composition-based
    design.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 使用组合进行设计通常也比复杂的多重继承效果更好。我们在第11章“常见设计模式”和第12章“高级设计模式”中将要讨论的许多设计模式都是基于组合的设计示例。
- en: The inheritance paradigm depends on a clear "is-a" relationship between classes.
    Multiple inheritance folds in other relationships that aren't as clear. We can
    say that an "Email is a kind of Contact," for example. But it doesn't seem as
    clear that we can say "A Customer is an Email." We might say "A Customer has an
    Email address" or "A Customer is contacted via Email," using "has an" or "is contacted
    by" instead of a direct "is-a" relationship.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 继承范式依赖于类之间清晰的“是一种”关系。多重继承会折叠其他不那么清晰的关系。例如，我们可以说“电子邮件是一种联系”，但似乎并不那么清晰地说“客户是电子邮件”。我们可能会说“客户有一个电子邮件地址”或“客户通过电子邮件被联系”，使用“有一个”或“被联系”来代替直接的“是一种”关系。
- en: Polymorphism
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多态性
- en: 'We were introduced to polymorphism in *Chapter 1*, *Object-Oriented Design*.
    It is a showy name describing a simple concept: different behaviors happen depending
    on which subclass is being used, without having to explicitly know what the subclass
    actually is. It is also sometimes called the Liskov Substitution Principle, honoring
    Barbara Liskov''s contributions to object-oriented programming. We should be able
    to substitute any subclass for its superclass.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在*第一章*，*面向对象设计*中接触到了多态性。这是一个描述简单概念的华丽名称：根据使用的是哪个子类，会发生不同的行为，而无需明确知道子类实际上是什么。它有时也被称为Liskov替换原则，以纪念芭芭拉·利斯科夫对面向对象编程的贡献。我们应该能够用任何子类替换其超类。
- en: 'As an example, imagine a program that plays audio files. A media player might
    need to load an `AudioFile` object and then play it. We can put a `play()` method
    on the object, which is responsible for decompressing or extracting the audio
    and routing it to the sound card and speakers. The act of playing an `AudioFile` could
    feasibly be as simple as:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，想象一个播放音频文件的程序。一个媒体播放器可能需要加载一个`AudioFile`对象然后播放它。我们可以在对象上放置一个`play()`方法，该方法负责解压缩或提取音频并将其路由到声卡和扬声器。播放一个`AudioFile`的行为可能实际上非常简单，就像这样：
- en: '[PRE25]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: However, the process of decompressing and extracting an audio file is very different
    for different types of files. While `.wav` files are stored uncompressed, `.mp3`, `.wma`,
    and `.ogg` files all utilize totally different compression algorithms.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，解压缩和提取音频文件的过程因文件类型的不同而大相径庭。当`.wav`文件以未压缩的形式存储时，`.mp3`、`.wma`和`.ogg`文件则全部采用了完全不同的压缩算法。
- en: 'We can use inheritance with polymorphism to simplify the design. Each type
    of file can be represented by a different subclass of `AudioFile`, for example, `WavFile` and `MP3File`.
    Each of these would have a `play()` method that would be implemented differently
    for each file to ensure that the correct extraction procedure is followed. The
    media player object would never need to know which subclass of `AudioFile` it
    is referring to; it just calls `play()` and polymorphically lets the object take
    care of the actual details of playing. Let''s look at a quick skeleton showing
    how this might work:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过继承和多态来简化设计。每种类型的文件都可以由`AudioFile`的不同子类来表示，例如`WavFile`和`MP3File`。这些子类中的每一个都会有一个`play()`方法，该方法会针对每个文件以不同的方式实现，以确保遵循正确的提取程序。媒体播放器对象永远不需要知道它引用的是`AudioFile`的哪个子类；它只需调用`play()`，并通过多态让对象处理播放的实际细节。让我们快速看一下一个示例框架，展示这可能是如何工作的：
- en: '[PRE26]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: All audio files check to ensure that a valid extension was given upon initialization.
    If the filename doesn't end with the correct name, it raises an exception (exceptions
    will be covered in detail in *Chapter 4*, *Expecting the Unexpected*).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 所有音频文件在初始化时都会检查是否给出了有效的扩展名。如果文件名不以正确的名称结尾，则会引发异常（异常将在*第4章*，*意料之外*中详细说明）。
- en: But did you notice how the `__init__()` method in the parent class is able to
    access the `ext` class variable from different subclasses? That's polymorphism
    at work. The `AudioFile` parent class merely has a type hint explaining to **mypy**
    that there will be an attribute named `ext`. It doesn't actually store a reference
    to the `ext` attribute. When the inherited method is used by a subclass, then
    the subclass' definition of the `ext` attribute is used. The type hint can help
    **mypy** spot a class missing the attribute assignment.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 但你是否注意到父类中的 `__init__()` 方法是如何能够从不同的子类中访问 `ext` 类变量的？这就是多态性的体现。`AudioFile` 父类仅仅有一个类型提示，向
    **mypy** 解释将会有一个名为 `ext` 的属性。它实际上并没有存储对 `ext` 属性的引用。当子类使用继承的方法时，就会使用子类对 `ext`
    属性的定义。类型提示可以帮助 **mypy** 发现缺少属性赋值的类。
- en: 'In addition, each subclass of `AudioFile` implements `play()` in a different
    way (this example doesn''t actually play the music; audio compression algorithms
    really deserve a separate book!). This is also polymorphism in action. The media
    player can use the exact same code to play a file, no matter what type it is;
    it doesn''t care what subclass of `AudioFile` it is looking at. The details of
    decompressing the audio file are *encapsulated*. If we test this example, it works
    as we would hope:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`AudioFile`的每个子类都以不同的方式实现`play()`方法（这个示例实际上并没有播放音乐；音频压缩算法真的值得有一本单独的书来介绍！）。这同样是多态性的体现。媒体播放器可以使用完全相同的代码来播放文件，无论其类型如何；它不关心它正在查看的`AudioFile`的子类是什么。音频文件的解压缩细节被*封装*起来。如果我们测试这个示例，它将如我们所期望的那样工作：
- en: '[PRE27]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: See how `AudioFile.__init__()` can check the file type without actually knowing
    which subclass it is referring to?
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 看看`AudioFile.__init__()`是如何在不实际知道它引用的是哪个子类的情况下检查文件类型的？
- en: 'Polymorphism is actually one of the coolest things about object-oriented programming,
    and it makes some programming designs obvious that weren''t possible in earlier
    paradigms. However, Python makes polymorphism seem less awesome because of duck
    typing. Duck typing in Python allows us to use *any* object that provides the
    required behavior without forcing it to be a subclass. The dynamic nature of Python
    makes this trivial. The following example does not extend `AudioFile`, but it
    can be interacted with in Python using the exact same interface:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 多态性实际上是面向对象编程中最酷的事情之一，它使得一些在早期范式下不可能的编程设计变得明显。然而，由于鸭子类型，Python 使得多态性看起来不那么酷。Python
    中的鸭子类型允许我们使用任何提供所需行为的对象，而不必强制它成为子类。Python 的动态特性使得这一点变得微不足道。以下示例没有扩展 `AudioFile`，但在
    Python 中可以使用完全相同的接口与之交互：
- en: '[PRE28]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Our media player can play objects of the `FlacFile` class just as easily as
    objects of classes that extend `AudioFile`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的媒体播放器可以像播放扩展自`AudioFile`类的对象一样轻松地播放`FlacFile`类的对象。
- en: Polymorphism is one of the most important reasons to use inheritance in many
    object-oriented contexts. Because any objects that supply the correct interface
    can be used interchangeably in Python, it reduces the need for polymorphic common
    superclasses. Inheritance can still be useful for sharing code, but if all that
    is being shared is the public interface, duck typing is all that is required.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 多态性是许多面向对象场景中使用继承最重要的原因之一。因为任何提供正确接口的对象都可以在Python中互换使用，这减少了需要多态公共超类的情况。继承仍然可以用于共享代码，但如果共享的仅仅是公共接口，那么鸭子类型就足够了。
- en: This reduced need for inheritance also reduces the need for multiple inheritance;
    often, when multiple inheritance appears to be a valid solution, we can just use
    duck typing to mimic one of the multiple superclasses.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这种减少对继承的需求也减少了多重继承的需求；通常，当多重继承看起来是一个有效的解决方案时，我们只需使用鸭子类型来模拟其中一个多重超类。
- en: 'In some cases, we can formalize this kind of duck typing using a `typing.Protocol`
    hint. To make **mypy** aware of the expectations, we''ll often define a number
    of functions or attributes (or a mixture) as a formal `Protocol` type. This can
    help clarify how classes are related. We might, for example, have this kind of
    definition to define the common features between the `FlacFile` class and the
    `AudioFile` class hierarchy:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们可以使用`typing.Protocol`提示来形式化这种鸭子类型。为了使**mypy**了解期望，我们通常会定义多个函数或属性（或它们的组合）作为一个正式的`Protocol`类型。这有助于阐明类之间的关系。例如，我们可能会有以下这种定义来定义`FlacFile`类和`AudioFile`类层次结构之间的共同特征：
- en: '[PRE29]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Of course, just because an object satisfies a particular protocol (by providing
    required methods or attributes) does not mean it will simply work in all situations.
    It has to fulfill that interface in a way that makes sense in the overall system.
    Just because an object provides a `play()` method does not mean it will automatically
    work with a media player. The methods must also have the same meaning, or semantics,
    in addition to having the same syntax.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，仅仅因为一个对象满足特定的协议（通过提供所需的方法或属性）并不意味着它在所有情况下都能简单地工作。它必须以一种在整体系统中有意义的方式实现该接口。仅仅因为一个对象提供了一个`play()`方法并不意味着它将自动与媒体播放器协同工作。这些方法除了具有相同的语法外，还必须具有相同的意义或语义。
- en: Another useful feature of duck typing is that the duck-typed object only needs
    to provide those methods and attributes that are actually being accessed. For
    example, if we needed to create a fake file object to read data from, we can create
    a new object that has a `read()` method; we don't have to override the `write()` method
    if the code that is going to interact with the fake object will not be calling
    it. More succinctly, duck typing doesn't need to provide the entire interface
    of an object that is available; it only needs to fulfill the protocol that is
    actually used.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 鸭式类型的一个有用特性是，鸭式类型的对象只需提供那些实际被访问的方法和属性。例如，如果我们需要创建一个模拟文件对象来读取数据，我们可以创建一个新的对象，该对象具有`read()`方法；如果将要与模拟对象交互的代码不会调用它，我们就不必重写`write()`方法。更简洁地说，鸭式类型不需要提供对象可用的整个接口；它只需满足实际使用的协议。
- en: Case study
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 案例研究
- en: This section expands on the object-oriented design of our example, iris classification.
    We've been building on this in the previous chapters, and we'll continue building
    on it in later chapters. In this chapter, we'll review the diagrams created using
    the **Unified Modeling Language** (**UML**) to help depict and summarize the software
    we're going to build. We'll move on from the previous chapter to add features
    for the various ways of computing "nearest" for the *k*-nearest neighbors algorithm.
    There are a number of variations for this, and it demonstrates how class hierarchies
    work.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 本节扩展了我们示例中的面向对象设计，即鸢尾花分类。我们已经在之前的章节中构建了这一部分，并在后续章节中将继续构建。在本章中，我们将回顾使用**统一建模语言**（**UML**）创建的图表，以帮助描述和总结我们将要构建的软件。我们将从上一章继续前进，为计算*k*最近邻算法中“最近”的多种方式添加功能。对此有几种变体，这展示了类层次结构是如何工作的。
- en: 'There are several design principles that we''ll be exploring as this design
    becomes more and more complete. One popular set of principles is the **SOLID** principles,
    which are:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 随着设计的不断完善，我们将探讨几个设计原则。其中一套流行的原则是**SOLID**原则，具体如下：
- en: '**S**. Single Responsibility Principle. A class should have one responsibility.
    This can mean one reason to change when the application''s requirements change.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**S**. 单一职责原则。一个类应该只有一个职责。这可以意味着当应用程序的需求发生变化时，只有一个理由去修改。'
- en: '**O**. Open/Closed. A class should be open to extension but closed to modification.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**O**. 开放/封闭原则。一个类应该对扩展开放，但对修改封闭。'
- en: '**L**. Liskov Substitution. (Named after Barbara Liskov, who created one of
    the first object-oriented programming languages, CLU.) Any subclass can be substituted
    for its superclass. This tends to focus a class hierarchy on classes that have
    very similar interfaces, leading to *polymorphism* among the objects. This the
    essence of inheritance.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**L**. Liskov 替换原则。（以 Barbara Liskov 命名，她是第一个面向对象编程语言 CLU 的创造者之一。）任何子类都可以替换其超类。这往往使类层次结构集中在具有非常相似接口的类上，导致对象之间的 *多态性*。这是继承的本质。'
- en: '**I**. Interface Segregation. A class should have the smallest interface possible.
    This is, perhaps, the most important of these principles. Classes should be relatively
    small and isolated.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**I**. 接口隔离。一个类应该拥有尽可能小的接口。这可能是这些原则中最重要的一个。类应该相对较小且独立。'
- en: '**D**. Dependency Inversion. This has a peculiar name. We need to know what
    a bad dependency relationship is so we know how to invert it to have a good relationship.
    Pragmatically, we''d like classes to be independent, so a Liskov Substitution
    doesn''t involve a lot of code changes. In Python, this often means referring
    to superclasses in type hints to be sure we have the flexibility to make changes.
    In some cases, it also means providing parameters so that we can make global class
    changes without revising any of the code.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**D**. 依赖倒置。这个名字听起来很特别。我们需要了解什么是糟糕的依赖关系，这样我们才知道如何将其反转以形成良好的关系。从实用主义的角度来看，我们希望类是独立的，这样Liskov替换就不会涉及到大量的代码更改。在Python中，这通常意味着在类型提示中引用超类，以确保我们有灵活性来做出更改。在某些情况下，这也意味着提供参数，这样我们就可以在不修改任何代码的情况下进行全局类更改。'
- en: We won't look at all of these principles in this chapter. Because we're looking
    at inheritance, our design will tend to follow the Liskov Substitution design
    principle. Other chapters will touch on other design principles.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中不会探讨所有这些原则。因为我们关注的是继承，我们的设计将倾向于遵循Liskov替换设计原则。其他章节将涉及其他设计原则。
- en: Logical view
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逻辑视图
- en: 'Here''s the overview of some of the classes shown in the previous chapter''s
    case study. An important omission from those definitions was the `classify` algorithm
    of the `Hyperparameter` class:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是上一章案例研究中展示的一些类别的概述。那些定义中的一个重要遗漏是`Hyperparameter`类的`classify`算法：
- en: '![Diagram  Description automatically generated](img/B17070_03_03.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![图表描述自动生成](img/B17070_03_03.png)'
- en: 'Figure 3.3: Class overview'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3：类概述
- en: In the previous chapter, we avoided delving into the classification algorithm.
    This reflects a common design strategy, sometimes called "*Hard Part, Do Later*,"
    also called "*Do The Easy Part First*." This strategy encourages following common
    design patterns where possible to isolate the hard part. In effect, the easy parts
    define a number of fences that enclose and constrain the novel and unknown parts.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们避免了深入探讨分类算法。这反映了一种常见的策略，有时被称为“*先难后易*”，也称为“*先做简单部分*”。这种策略鼓励尽可能遵循常见的模式设计，以隔离困难的部分。实际上，简单部分定义了一系列围栏，这些围栏包围并限制了新颖和未知的部分。
- en: The classification we're doing is based on the *k*-nearest neighbors algorithm,
    *k*-NN. Given a set of known samples, and an unknown sample, we want to find neighbors
    near the unknown sample; the majority of the neighbors tells us how to classify
    the newcomer. This means *k* is usually an odd number, so the majority is easy
    to compute. We've been avoiding the question, "What do we mean by nearest?"
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所进行的分类是基于**k**-最近邻算法，**k**-NN。给定一组已知样本和一个未知样本，我们希望找到靠近未知样本的邻居；大多数邻居告诉我们如何对新人进行分类。这意味着**k**通常是一个奇数，因此计算多数是容易的。我们一直在避免这个问题，“我们所说的‘最近’是什么意思？”
- en: 'In a conventional, two-dimensional geometric sense, we can use the "Euclidean"
    distance between samples. Given an Unknown sample located at ![](img/B17070_03_001.png)
    and a Training sample at ![](img/B17070_03_002.png), the Euclidean distance between
    these samples, ![](img/B17070_03_003.png), is:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的二维几何意义上，我们可以使用样本之间的“欧几里得”距离。给定一个位于 ![](img/B17070_03_001.png) 的未知样本和一个位于 ![](img/B17070_03_002.png)
    的训练样本，这两个样本之间的欧几里得距离， ![](img/B17070_03_003.png)，是：
- en: '![](img/B17070_03_004.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17070_03_004.png)'
- en: 'We can visualize it like this:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将其可视化如下：
- en: '![Chart  Description automatically generated](img/B17070_03_04.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![图表描述自动生成](img/B17070_03_04.png)'
- en: 'Figure 3.4: Euclidean distance'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4：欧几里得距离
- en: 'We''ve called this ED2 because it''s only two-dimensional. In our case study
    data, we actually have four dimensions: sepal length, sepal width, petal length,
    and petal width. This is really difficult to visualize, but the math isn''t too
    complex. Even when it''s hard to imagine, we can still write it out fully, like
    so:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将其称为ED2，因为它只有二维。在我们的案例研究数据中，我们实际上有四个维度：花瓣长度、花瓣宽度、萼片长度和萼片宽度。这确实很难可视化，但数学并不太复杂。即使很难想象，我们仍然可以完整地写出来，如下所示：
- en: '![](img/B17070_03_005.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17070_03_005.png)'
- en: All of the two-dimensional examples expand to four dimensions, in spite of how
    hard it is to imagine. We'll stick with the easier to visualize *x-y* distance
    for the diagrams in this section. But we really mean the full four-dimensional
    computation that includes all of the available measurements.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 所有二维示例都扩展到四维，尽管想象起来很困难。在本节的图中，我们将坚持使用更容易可视化的*x-y*距离。但我们的真正意思是包括所有可用测量的完整四维计算。
- en: 'We can capture this computation as a class definition. An instance of this
    `ED` class is usable by the `Hyperparameter` class:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个计算过程表示为一个类定义。`ED` 类的一个实例可以被 `Hyperparameter` 类使用：
- en: '[PRE30]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We've leveraged the `math.hypot()` function to do the square and square root
    parts of the distance computation. We've used a superclass, `Distance`, that we
    haven't defined yet. We're pretty sure it's going to be needed, but we'll hold
    off a bit on defining it.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经利用了 `math.hypot()` 函数来完成距离计算的平方和开方部分。我们使用了一个尚未定义的超类 `Distance`。我们相当确信它将会被需要，但我们暂时先不定义它。
- en: 'The Euclidean distance is one of many alternative definitions of distance between
    a known and unknown sample. There are two relatively simple ways to compute a
    distance that are similar, and they often produce consistently good results without
    the complexity of a square root:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 欧几里得距离是已知样本和未知样本之间许多替代距离定义之一。有两种相对简单的方法来计算距离，它们相似，并且通常能产生一致的良好结果，而不需要平方根的复杂性：
- en: '**Manhattan distance**: This is the distance you would walk in a city with
    square blocks (somewhat like parts of the city of Manhattan.)'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**曼哈顿距离**：这是你在具有方块状街区（类似于曼哈顿市的部分地区）的城市中行走的距离。'
- en: '**Chebyshev distance**: This counts a diagonal step as 1\. A Manhattan computation
    would rank this as 2\. The Euclidean distance would be ![](img/B17070_03_006.png),
    as depicted in *Figure 3.4*.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**切比雪夫距离**：这种距离计算将对角线步长计为1。曼哈顿计算会将这个距离计为2。欧几里得距离将如*图3.4*所示，为 ![](img/B17070_03_006.png)。'
- en: 'With a number of alternatives, we''re going to need to create distinct subclasses.
    That means we''ll need a base class to define the general idea of distances. Looking
    over the definitions at hand, it seems like the base class can be the following:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在有多种选择的情况下，我们需要创建不同的子类。这意味着我们需要一个基类来定义距离的一般概念。查看现有的定义，似乎基类可以是以下这样：
- en: '[PRE31]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This seems to capture the essence of the distance computations we've seen. Let's
    implement a few more subclasses of this to be sure the abstraction really works.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这似乎捕捉到了我们所看到的距离计算的精髓。让我们再实现几个这个类的子类，以确保抽象确实有效。
- en: 'The Manhattan distance is the total number of steps along the *x*-axis, plus
    the total number of steps along the *y*-axis. The formula uses the absolute values
    of the distances, written as ![](img/B17070_03_007.png), and looks like this:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 曼哈顿距离是沿着*x*轴的总步数，加上沿着*y*轴的总步数。该公式使用距离的绝对值，表示为![](img/B17070_03_007.png)，其形式如下：
- en: '![](img/B17070_03_008.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17070_03_008.png)'
- en: This can be as much as 41% larger than the direct Euclidean distance. However,
    it will still parallel the direct distance in a way that can yield a good *k*-NN
    result, but with a faster computation because it avoids squaring numbers and computing
    a square root.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能比直接欧几里得距离大41%。然而，它仍然以一种可以产生良好的*k*-NN结果的方式与直接距离平行，但计算速度更快，因为它避免了平方数字和计算平方根。
- en: 'Here''s a view of the Manhattan distance:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是曼哈顿距离的视图：
- en: '![A picture containing chart  Description automatically generated](img/B17070_03_05.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![包含图表的图片 自动生成描述](img/B17070_03_05.png)'
- en: 'Figure 3.5: Manhattan distance'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5：曼哈顿距离
- en: 'Here''s a subclass of `Distance` that computes this variation:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个计算这种变化的`Distance`子类的示例：
- en: '[PRE32]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The Chebyshev distance is the largest of the absolute *x* or *y* distances.
    This tends to minimize the effects of multiple dimensions:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 切比雪夫距离是绝对 *x* 或 *y* 距离中最大的。这倾向于最小化多个维度的影响：
- en: '![](img/B17070_03_009.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17070_03_009.png)'
- en: 'Here''s a view of the Chebyshev distance; it tends to emphasize neighbors that
    are closer to each other:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是切比雪夫距离的视图；它倾向于强调彼此更近的邻居：
- en: '![Chart  Description automatically generated](img/B17070_03_06.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![图表描述自动生成](img/B17070_03_06.png)'
- en: 'Figure 3.6: Chebyshev distance'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6：切比雪夫距离
- en: 'Here''s a subclass of `Distance` that performs this variant on the distance
    computation:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个`Distance`子类的示例，它实现了距离计算的这种变体：
- en: '[PRE33]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: See *Effects of Distance Measure Choice on KNN Classifier Performance - A Review*
    ([https://arxiv.org/pdf/1708.04321.pdf](https://arxiv.org/pdf/1708.04321.pdf)).
    This paper contains 54 distinct metrics computations. The examples we're looking
    at are collectively identified as "Minkowski" measures because they're similar
    and measure each axis equally. Each alternative distance strategy yields different
    results in the model's ability to classify unknown samples given a set of training
    data.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 查阅 *距离度量选择对KNN分类器性能的影响 - 一篇综述* ([https://arxiv.org/pdf/1708.04321.pdf](https://arxiv.org/pdf/1708.04321.pdf))。该论文包含了54种不同的度量计算。我们所研究的例子被统称为“闵可夫斯基”度量，因为它们相似且对每个轴的度量相等。每种替代距离策略在给定一组训练数据的情况下，对模型分类未知样本的能力都会产生不同的结果。
- en: 'This changes the idea behind the `Hyperparameter` class: we now have two distinct
    hyperparameters. The value of *k*, to decide how many neighbors to examine, and
    the distance computation, which tells us how to compute "nearest." These are both
    changeable parts of the algorithm, and we''ll need to test various combinations
    to see which works best for our data.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这改变了`超参数`类的理念：我们现在有两个不同的超参数。一个是决定要检查多少个邻居的*k*值，另一个是距离计算，它告诉我们如何计算“最近”。这些都是算法的可变部分，我们需要测试各种组合，看看哪种最适合我们的数据。
- en: How can we have all of these different distance computations available? The
    short answer is we'll need a lot of subclass definitions of a common distance
    class. The review paper cited above lets us pare down the domain to a few of the
    more useful distance computations. To be sure we've got a good design, let's look
    at one more distance.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何能够拥有所有这些不同的距离计算方法呢？简短的回答是我们需要为公共距离类定义大量的子类。上述综述论文让我们将领域缩小到几个更有用的距离计算方法。为了确保我们有一个良好的设计，让我们再看看一种更多的距离计算方法。
- en: Another distance
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另一种距离
- en: 'Just to make it clear how easy it is to add subclasses, we''ll define a somewhat
    more complex distance metric. This is the Sorensen distance, also known as Bray-Curtis.
    If our distance class can handle these kinds of more complex formulas, we can
    be confident it''s capable of handling others:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 只为了让你们更清楚地了解添加子类有多简单，我们将定义一个稍微复杂一些的距离度量。这就是Sorensen距离，也称为Bray-Curtis。如果我们距离类能够处理这类更复杂的公式，我们就可以有信心它能够处理其他情况：
- en: '![](img/B17070_03_010.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17070_03_010.png)'
- en: We've effectively standardized each component of the Manhattan distance by dividing
    by the possible range of values.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过除以可能值的范围，有效地标准化了曼哈顿距离的每个组成部分。
- en: 'Here''s a diagram to illustrate how the Sorensen distance works:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个图表来展示索伦森距离是如何工作的：
- en: '![Chart  Description automatically generated with medium confidence](img/B17070_03_07.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![图表描述自动生成，置信度中等](img/B17070_03_07.png)'
- en: 'Figure 3.7: Manhattan versus Sorensen distance'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.7：曼哈顿距离与索伦森距离
- en: The simple Manhattan distance applies no matter how far from the origin we are.
    The Sorensen distance reduces the importance of measures that are further from
    the origin so they don't dominate the *k*-NN by virtue of being large-valued outliers.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的曼哈顿距离无论我们离原点有多远都适用。Sorensen距离降低了远离原点的度量值的重要性，这样它们就不会因为是大数值的异常值而主导*k*-NN。
- en: 'We can introduce this into our design by adding a new subclass of `Distance`.
    While this is similar, in some ways, to the Manhattan distance, it''s often classified
    separately:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过添加一个新的`Distance`子类来将此概念引入我们的设计中。虽然这在某些方面与曼哈顿距离相似，但它通常被单独分类：
- en: '[PRE34]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This design approach lets us leverage object-oriented inheritance to build a
    polymorphic family of distance computation functions. We can build on the first
    few functions to create a wide family of functions and use these as part of hyperparameter
    tuning to locate the best way to measure distances and perform the required classification.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计方法使我们能够利用面向对象的继承来构建一个多态的距离计算函数族。我们可以在前几个函数的基础上创建一个广泛的函数族，并将这些函数用作超参数调整的一部分，以找到测量距离和执行所需分类的最佳方式。
- en: We'll need to integrate a `Distance` object into the `Hyperparameter` class.
    This means providing an instance of one of these subclasses. Because they're all
    implementing the same `distance()` method, we can replace different alternative
    distance computations to find which performs best with our unique collection of
    data and attributes.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将一个`Distance`对象集成到`Hyperparameter`类中。这意味着提供这些子类中的一个实例。因为它们都在实现相同的`distance()`方法，我们可以替换不同的替代距离计算方法，以找到在我们独特的数据和属性集合中表现最佳的方法。
- en: For now, we can reference a specific distance subclass in our `Hyperparameter`
    class definition. In *Chapter 11*, *Common Design Patterns*, we'll look at how
    we can flexibly plug in any possible distance computation from the hierarchy of
    `Distance` class definitions.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们可以在我们的`Hyperparameter`类定义中参考一个特定的距离子类。在*第11章*，*常见设计模式*中，我们将探讨如何从`Distance`类定义的层次结构中灵活地插入任何可能的距离计算方法。
- en: Recall
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回忆
- en: 'Some key points in this chapter:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的一些关键点：
- en: 'A central object-oriented design principle is inheritance: a subclass can inherit
    aspects of a superclass, saving copy-and-paste programming. A subclass can extend
    the superclass to add features or specialize the superclass in other ways.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向对象设计的一个核心原则是继承：子类可以继承超类的一些特性，从而节省复制粘贴编程。子类可以扩展超类以添加功能或以其他方式对超类进行专门化。
- en: Multiple inheritance is a feature of Python. The most common form is a host
    class with mixin class definitions. We can combine multiple classes leveraging
    the method resolution order to handle common features like initialization.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多继承是Python的一个特性。最常见的形式是主类与混合类定义的组合。我们可以利用方法解析顺序来组合多个类，以处理初始化等常见功能。
- en: Polymorphism lets us create multiple classes that provide alternative implementations
    for fulfilling a contract. Because of Python's duck typing rules, any classes
    that have the right methods can substitute for each other.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多态性允许我们创建多个类，这些类提供满足合同的不同实现。由于Python的鸭子类型规则，任何具有正确方法的类都可以相互替代。
- en: Exercises
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Look around you at some of the physical objects in your workspace and see if
    you can describe them in an inheritance hierarchy. Humans have been dividing the
    world into taxonomies like this for centuries, so it shouldn't be difficult. Are
    there any non-obvious inheritance relationships between classes of objects? If
    you were to model these objects in a computer application, what properties and
    methods would they share? Which ones would have to be polymorphically overridden?
    What properties would be completely different between them?
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 环顾你的工作空间，看看你能否用继承层次结构来描述一些物理对象。人类已经用这种分类法来划分世界数百年了，所以这不应该很难。物体类别之间是否存在任何非显而易见的继承关系？如果你要在计算机应用程序中模拟这些对象，它们会共享哪些属性和方法？哪些需要被多态地覆盖？它们之间会有哪些完全不同的属性？
- en: Now write some code. No, not for the physical hierarchy; that's boring. Physical
    items have more properties than methods. Just think about a pet programming project
    you've wanted to tackle in the past year, but never gotten around to. For whatever
    problem you want to solve, try to think of some basic inheritance relationships
    and then implement them. Make sure that you also pay attention to the sorts of
    relationships that you actually don't need to use inheritance for. Are there any
    places where you might want to use multiple inheritance? Are you sure? Can you
    see any place where you would want to use a mixin? Try to knock together a quick
    prototype. It doesn't have to be useful or even partially working. You've seen how
    you can test code using `python -i` already; just write some code and test it in
    the interactive interpreter. If it works, write some more. If it doesn't, fix
    it!
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在写一些代码。不，不是指物理层次结构；那很无聊。物理实体比方法有更多的属性。想想看，在过去一年里，你有没有想要尝试解决的项目，但一直没找到时间去实现。对于你想要解决的问题，试着想一些基本的继承关系，然后实现它们。确保你也注意到了那些实际上不需要使用继承的关系类型。有没有可能需要使用多重继承的地方？你确定吗？你能看到任何可能想要使用混入（mixin）的地方吗？试着快速搭建一个原型。它不必有用，甚至不必部分工作。你已经看到了如何使用`python
    -i`来测试代码；只需编写一些代码，并在交互式解释器中测试它。如果它工作正常，就继续写更多。如果它不工作，就修复它！
- en: Now, take a look at the various distance computations in the case study. We
    need to be able to work with testing data as well as unknown samples provided
    by a user. What do these two kinds of samples have in common? Can you create a
    common superclass and use inheritance for these two classes with similar behavior?
    (We haven't looked closely at the *k*-NN classification yet, but you can provide
    a "mock" classifier that will provide fake answers.)
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看案例研究中的各种距离计算。我们需要能够处理测试数据以及用户提供的未知样本。这两种类型的样本有什么共同点？你能创建一个公共超类，并使用继承来处理这两个具有相似行为的类吗？（我们还没有仔细研究*k*-NN分类，但你可以提供一个“模拟”分类器，它将提供虚假答案。）
- en: When we look at the distance computation, we can see how a `Hyperparameter`
    is a composition that includes a distance algorithm plug-in as one of the parameters.
    Is this a good candidate for a mixin? Why or why not? What limitations does a
    mixin have that a plug-in does not have?
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们观察距离计算时，可以看到一个`超参数`是如何作为一个包含距离算法插件作为参数之一的组合。这是否是一个好的mixin候选者？为什么或为什么不？mixin有哪些限制是插件所不具备的？
- en: Summary
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We've gone from simple inheritance, one of the most useful tools in the object-oriented
    programmer's toolbox, all the way through to multiple inheritance – one of the
    most complicated. Inheritance can be used to add functionality to existing classes
    and built-in generics. Abstracting similar code into a parent class can help increase
    maintainability. Methods on parent classes can be called using `super`, and argument
    lists must be formatted safely for these calls to work when using multiple inheritance.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经从简单的继承，这是面向对象程序员工具箱中最有用的工具之一，一路发展到多重继承——这是最复杂的一种。继承可以用来向现有类和内置泛型添加功能。将相似代码抽象到父类中可以帮助提高可维护性。父类上的方法可以使用`super`来调用，并且在使用多重继承时，参数列表必须格式化得安全，以确保这些调用能够正常工作。
- en: In the next chapter, we'll cover the subtle art of handling exceptional circumstances.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将探讨处理特殊情况的微妙艺术。
