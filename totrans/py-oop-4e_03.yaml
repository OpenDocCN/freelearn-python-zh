- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: When Objects Are Alike
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 当物体相似时
- en: In the programming world, duplicate code is considered evil. We should not have
    multiple copies of the same, or similar, code in different places. When we fix
    a bug in one copy and fail to fix the same bug in another copy, we've caused no
    end of problems for ourselves.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程领域，重复代码被视为邪恶。我们不应该在不同地方有相同或相似的代码的多个副本。当我们修复了一个副本中的错误，却未能修复另一个副本中的相同错误时，我们给自己带来了无穷无尽的麻烦。
- en: 'There are many ways to merge pieces of code or objects that have a similar
    functionality. In this chapter, we''ll be covering the most famous object-oriented
    principle: inheritance. As discussed in *Chapter 1*, *Object-Oriented Design*,
    inheritance allows us to create "is-a" relationships between two or more classes,
    abstracting common logic into superclasses and extending the superclass with specific
    details in each subclass. In particular, we''ll be covering the Python syntax
    and principles for the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 合并具有相似功能的代码或对象有许多方法。在本章中，我们将介绍最著名的面向对象原则：继承。正如在*第一章*，*面向对象设计*中讨论的那样，继承使我们能够在两个或更多类之间创建“是”的关系，将共同逻辑抽象到超类中，并在每个子类中用特定细节扩展超类。特别是，我们将介绍以下Python语法和原则：
- en: Basic inheritance
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本继承
- en: Inheriting from built-in types
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从内置类型继承
- en: Multiple inheritance
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多重继承
- en: Polymorphism and duck typing
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多态和鸭子类型
- en: This chapter's case study will expand on the previous chapter. We'll leverage
    the concepts of inheritance and abstraction to look for ways to manage common
    code in parts of the *k*-nearest neighbors computation.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: We'll start by taking a close look at how inheritance works to factor out common
    features so we can avoid copy-and-paste programming.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先详细探讨继承的工作原理，以便提取共同特性，从而避免复制粘贴编程。
- en: Basic inheritance
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本继承
- en: Technically, every class we create uses inheritance. All Python classes are
    subclasses of the special built-in class named `object`. This class provides a
    little bit of metadata and a few built-in behaviors so Python can treat all objects
    consistently.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 技术上讲，我们创建的每个类都使用了继承。所有 Python 类都是名为 `object` 的特殊内置类的子类。这个类提供了一点点元数据和一些内置行为，以便
    Python 可以一致地处理所有对象。
- en: 'If we don''t explicitly inherit from a different class, our classes will automatically
    inherit from `object`. However, we can redundantly state that our class derives
    from `object` using the following syntax:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有显式地从不同的类继承，我们的类将自动继承自`object`。然而，我们可以使用以下语法冗余地声明我们的类继承自`object`：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is inheritance! This example is, technically, no different from our very
    first example in *Chapter 2*, *Objects in Python*. In Python 3, all classes automatically
    inherit from `object` if we don't explicitly provide a different **superclass**.
    The superclasses, or *parent* classes, in the relationship are the classes that
    are being inherited from, `object` in this example. A subclass – `MySubClass`,
    in this example – inherits from a superclass. A subclass is also said to be *derived
    from* its parent class, or the subclass *extends* the parent class.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: As you've probably figured out from the example, inheritance requires a minimal
    amount of extra syntax over a basic class definition. Simply include the name
    of the parent class inside parentheses between the class name and the colon that
    follows. This is all we have to do to tell Python that the new class should be
    derived from the given superclass.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'How do we apply inheritance in practice? The simplest and most obvious use
    of inheritance is to add functionality to an existing class. Let''s start with
    a contact manager that tracks the names and email addresses of several people.
    The `Contact` class is responsible for maintaining a global list of all contacts
    ever seen in a class variable, and for initializing the name and address for an
    individual contact:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This example introduces us to **class variables**. The `all_contacts` list,
    because it is part of the class definition, is shared by all instances of this
    class. This means that there is only one `Contact.all_contacts` list. We can also
    access it as `self.all_contacts` from within any method on an instance of the `Contact` class.
    If a field can't be found on the object (via `self`), then it will be found on
    the class and will thus refer to the same single list.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Be careful with the `self`-based reference. It can only provide access to an
    existing class-based variable. If you ever attempt to **set** the variable using `self.all_contacts`,
    you will actually be creating a **new** instance variable associated just with
    that object. The class variable will still be unchanged and accessible as `Contact.all_contacts`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see how the class tracks data with the following example:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We created two instances of the `Contact` class and assigned them to variables
    `c_1` and `c_2`. When we looked at the `Contact.all_contacts` class variable,
    we saw that the list has been updated to track the two objects.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a simple class that allows us to track a couple of pieces of data about
    each contact. But what if some of our contacts are also suppliers that we need
    to order supplies from? We could add an `order` method to the `Contact` class,
    but that would allow people to accidentally order things from contacts who are
    customers or family friends. Instead, let''s create a new `Supplier` class that
    acts like our `Contact` class, but has an additional `order` method that accepts
    a yet-to-be-defined `Order` object:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, if we test this class in our trusty interpreter, we see that all contacts,
    including suppliers, accept a name and email address in their `__init__()` method,
    but that only `Supplier` instances have an `order()` method:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Our `Supplier` class can do everything a contact can do (including adding itself
    to the list of `Contact.all_contacts`) and all the special things it needs to
    handle as a supplier. This is the beauty of inheritance.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Also, note that `Contact.all_contacts` has collected every instance of the `Contact`
    class as well as the subclass, `Supplier`. If we used `self.all_contacts`, then
    this would **not** collect all objects into the `Contact` class, but would put
    `Supplier` instances into `Supplier.all_contacts`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Extending built-ins
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One interesting use of this kind of inheritance is adding functionality to built-in
    classes. In the `Contact` class seen earlier, we are adding contacts to a list
    of all contacts. What if we also wanted to search that list by name? Well, we
    could add a method on the `Contact` class to search it, but it feels like this
    method actually belongs to the list itself.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows how we can do this using inheritance from a built-in
    type. In this case, we''re using the `list` type. We''re going to inform **mypy**
    that our list is only of instances of the `Contact` class by using `list["Contact"]`.
    For this syntax to work in Python 3.9, we need to also import the `annotations`
    module from the `__future__` package. The definitions look like this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Instead of instantiating a generic list as our class variable, we create a
    new `ContactList` class that extends the built-in `list` data type. Then, we instantiate
    this subclass as our `all_contacts` list. We can test the new search functionality
    as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We have two ways to create generic list objects. With type hints, we have another
    way of talking about lists, separate from creating actual list instances.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 'First, creating a list with `[]` is actually a shortcut for creating a list
    using `list()`; the two syntaxes behave identically:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `[]` is short and sweet. We can call it **syntactic sugar**; it is a call
    to the `list()` constructor, written with two characters instead of six. The `list` name
    refers to a data type: it is a class that we can extend.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Tools like **mypy** can check the body of the `ContactList.search()` method
    to be sure it really will create a `list` instance populated with `Contact` objects.
    Be sure you've installed a version that's 0.812 or newer; older versions of **mypy**
    don't handle these annotations based on generic types completely.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Because we provided the `Contact` class definition after the definition of the
    `ContactList` class, we had to provide the reference to a not-yet-defined class
    as a string, `list["Contact"]`. It's often more common to provide the individual
    item class definition first, and the collection can then refer to the defined
    class by name without using a string.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'As a second example, we can extend the `dict` class, which is a collection
    of keys and their associated values. We can create instances of dictionaries using
    the `{}` syntax sugar. Here''s an extended dictionary that tracks the longest
    key it has seen:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The hint for the class narrowed the generic `dict` to a more specific `dict[str,
    int]`; the keys are of type `str` and the values are of type `int`. This helps
    **mypy** reason about the `longest_key()` method. Since the keys are supposed
    to be `str`-type objects, the statement `for key in self:` will iterate over `str`
    objects. The result will be a `str`, or possibly `None`. That's why the result
    is described as `Optional[str]`. (Is `None` appropriate? Perhaps not. Perhaps
    a `ValueError` exception is a better idea; that will have to wait until *Chapter
    4*, *Expecting the Unexpected*.)
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re going to be working with strings and integer values. Perhaps the strings
    are usernames, and the integer values are the number of articles they''ve read
    on a website. In addition to the core username and reading history, we also need
    to know the longest name so we can format a table of scores with the right size
    display box. This is easy to test in the interactive interpreter:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: What if we wanted a more generic dictionary? Say with either strings **or**
    integers as the values? We'd need a slightly more expansive type hint. We might
    use `dict[str, Union[str, int]]` to describe a dictionary mapping strings to a
    union of either strings or integers.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: 'Most built-in types can be similarly extended. These built-in types fall into
    several interesting families, with separate kinds of type hints:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'Generic collections: `set`, `list`, `dict`. These use type hints like `set[something]`,
    `list[something]`, and `dict[key, value]` to narrow the hint from purely generic
    to something more specific that the application will actually use. To use the
    generic types as annotations, a `from __future__ import annotations` is required
    as the first line of code.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `typing.NamedTuple` definition lets us define new kinds of immutable tuples
    and provide useful names for the members. This will be covered in *Chapter 7*,
    *Python Data Structures*, and *Chapter 8*, *The Intersection of Object-Oriented
    and Functional Programming*.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python has type hints for file-related I/O objects. A new kind of file can use
    a type hint of `typing.TextIO` or `typing.BinaryIO` to describe built-in file
    operations.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's possible to create new types of strings by extending `typing.Text`. For
    the most part, the built-in `str` class does everything we need.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New numeric types often start with the `numbers` module as a source for built-in
    numeric functionality.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll use the generic collections heavily throughout the book. As noted, we'll
    look at named tuples in later chapters. The other extensions to built-in types
    are too advanced for this book. In the next section, we'll look more deeply at
    the benefits of inheritance and how we can selectively leverage features of the
    superclass in our subclass.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Overriding and super
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So, inheritance is great for *adding* new behavior to existing classes, but
    what about *changing* behavior? Our `Contact` class allows only a name and an
    email address. This may be sufficient for most contacts, but what if we want to
    add a phone number for our close friends?
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: 'As we saw in *Chapter 2*, *Objects in Python*, we can do this easily by setting
    a `phone` attribute on the contact after it is constructed. But if we want to
    make this third variable available on initialization, we have to override the `__init__()`
    method. Overriding means altering or replacing a method of the superclass with
    a new method (with the same name) in the subclass. No special syntax is needed
    to do this; the subclass''s newly created method is automatically called instead
    of the superclass''s method, as shown in the following code:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Any method can be overridden, not just `__init__()`. Before we go on, however,
    we need to address some problems in this example. Our `Contact` and `Friend` classes
    have duplicate code to set up the `name` and `email` properties; this can make
    code maintenance complicated, as we have to update the code in two or more places.
    More alarmingly, our `Friend` class is neglecting to add itself to the `all_contacts` list
    we have created on the `Contact` class. Finally, looking forward, if we add a
    feature to the `Contact` class, we'd like it to also be part of the `Friend` class.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: 'What we really need is a way to execute the original `__init__()` method on
    the `Contact` class from inside our new class. This is what the `super()` function
    does; it returns the object as if it was actually an instance of the parent class,
    allowing us to call the parent method directly:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This example first binds the instance to the parent class using `super()` and
    calls `__init__()` on that object, passing in the expected arguments. It then
    does its own initialization, namely, setting the `phone` attribute, which is unique
    to the `Friend` class.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Contact` class provided a definition for the `__repr__()` method to produce
    a string representation. Our class did not override the `__repr__()` method inherited
    from the superclass. Here''s the consequence of that:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The details shown for a `Friend` instance don't include the new attribute. It's
    easy to overlook the special method definitions when thinking about class design.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: A `super()` call can be made inside any method. Therefore, all methods can be
    modified via overriding and calls to `super()`. The call to `super()` can also
    be made at any point in the method; we don't have to make the call as the first
    line. For example, we may need to manipulate or validate incoming parameters before
    forwarding them to the superclass.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Multiple inheritance
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Multiple inheritance is a touchy subject. In principle, it''s simple: a subclass
    that inherits from more than one parent class can access functionality from both
    of them. In practice, it requires some care to be sure any method overrides are
    fully understood.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: As a humorous rule of thumb, if you think you need multiple inheritance, you're
    probably wrong, but if you know you need it, you might be right.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: The simplest and most useful form of multiple inheritance follows a design pattern
    called the **mixin**. A mixin class definition is not intended to exist on its
    own, but is meant to be inherited by some other class to provide extra functionality.
    For example, let's say we wanted to add functionality to our `Contact` class that
    allows sending an email to `self.email`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: 'Sending email is a common task that we might want to use on many other classes.
    So, we can write a simple mixin class to do the emailing for us:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `MailSender` class doesn''t do anything special (in fact, it can barely
    function as a standalone class, since it assumes an attribute it doesn''t set).
    We have two classes because we''re describing two things: aspects of the host
    class for a mixin, and new aspects the mixin provides to the host. We needed to
    create a hint, `Emailable`, to describe the kinds of classes our `MailSender`
    mixin expects to work with.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: This kind of type hint is called a **protocol**; protocols generally have methods,
    and can also have class-level attribute names with type hints, but not full assignment
    statements. A protocol definition is a kind of incomplete class; think of it like
    a contract for features of a class. A protocol tells **mypy** that any class (or
    subclass) of `Emailable` objects must support an `email` attribute, and it must
    be a string.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Note that we're relying on Python's name resolution rules. The name `self.email`
    can be resolved as either an instance variable, or a class-level variable, `Emailable.email`,
    or a property. The **mypy** tool will check all the classes mixed in with `MailSender`
    for instance- or class-level definitions. We only need to provide the name of
    the attribute at the class level, with a type hint to make it clear to **mypy**
    that the mixin does not define the attribute – the class into which it's mixed
    will provide the `email` attribute.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Because of Python's duck typing rules, we can use the `MailSender` mixin with
    any class that has an `email` attribute defined. A class with which `MailSender`
    is mixed doesn't have to be a formal subclass of `Emailable`; it only has to provide
    the required attribute.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: For brevity, we didn't include the actual email logic here; if you're interested
    in studying how it's done, see the `smtplib` module in the Python standard library.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: 'The `MailSender` class does allow us to define a new class that describes both
    a `Contact` and a `MailSender`, using multiple inheritance:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The syntax for multiple inheritance looks like a parameter list in the class
    definition. Instead of including one base class inside the parentheses, we include
    two (or more), separated by a comma. When it's done well, it's common for the
    resulting class to have no unique features of its own. It's a combination of mixins,
    and the body of the class definition is often nothing more than the `pass` placeholder.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: 'We can test this new hybrid to see the mixin at work:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `Contact` initializer is still adding the new contact to the `all_contacts` list,
    and the mixin is able to send mail to `self.email`, so we know that everything
    is working.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: 'This wasn''t so hard, and you''re probably wondering what our dire warnings
    about multiple inheritance were for. We''ll get into the complexities in a minute,
    but let''s consider some other options we had for this example, rather than using
    a mixin:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: We could have used single inheritance and added the `send_mail` function to
    a subclass of `Contact`. The disadvantage here is that the email functionality
    then has to be duplicated for any unrelated classes that need an email. For example,
    if we had email information in the payments part of our application, unrelated
    to these contacts, and we wanted a `send_mail()` method, we'd have to duplicate
    the code.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can create a standalone Python function for sending an email, and just call
    that function with the correct email address supplied as a parameter when the
    email needs to be sent (this is a very common choice). Because the function is
    not part of a class, it's harder to be sure that proper encapsulation is being
    used.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We could explore a few ways of using composition instead of inheritance. For
    example, `EmailableContact` could have a `MailSender` object as a property instead
    of inheriting from it. This leads to a more complex `MailSender` class because
    it now has to stand alone. It also leads to a more complex `EmailableContact`
    class because it has to associate a `MailSender` instance with each `Contact`.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We could try to monkey patch (we'll briefly cover monkey patching in *Chapter
    13*, *Testing Object-Oriented Programs*) the `Contact` class to have a `send_mail` method
    after the class has been created. This is done by defining a function that accepts
    the `self` argument, and setting it as an attribute on an existing class. This
    is fine for creating a unit test fixture, but terrible for the application itself.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple inheritance works alright when we're mixing methods from different
    classes, but it can be messy when we have to call methods on the superclass. When
    there are multiple superclasses, how do we know which one's methods to call? What is
    the rule for selecting the appropriate superclass method?
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explore these questions by adding a home address to our `Friend` class.
    There are a few approaches we might take:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: An address is a collection of strings representing the street, city, country,
    and other related details of the contact. We could pass each of these strings
    as a parameter into the `Friend` class's `__init__()` method. We could also store
    these strings in a generic tuple or dictionary. These options work well when the
    address information doesn't need new methods.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another option would be to create our own `Address` class to hold those strings
    together, and then pass an instance of this class into the `__init__()` method
    in our `Friend` class. The advantage of this solution is that we can add behavior
    (say, a method to give directions or to print a map) to the data instead of just
    storing it statically. This is an example of composition, as we discussed in *Chapter
    1*, *Object-Oriented Design*. The "has-a" relationship of composition is a perfectly
    viable solution to this problem and allows us to reuse `Address` classes in other
    entities, such as buildings, businesses, or organizations. (This is an opportunity
    to use a dataclass. We'll discuss dataclasses in *Chapter 7*, *Python Data Structures*.)
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A third course of action is a cooperative multiple inheritance design. While
    this can be made to work, it doesn't pass muster with **mypy**. The reason, we'll see,
    is some potential ambiguity that's difficult to describe with the available type
    hints.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The objective here is to add a new class to hold an address. We'll call this
    new class `AddressHolder` instead of `Address` because inheritance defines an
    "is-a" relationship. It is not correct to say a `Friend` class is an `Address` class,
    but since a friend can have an `Address` class, we can argue that a `Friend` class
    is an `AddressHolder` class. Later, we could create other entities (companies,
    buildings) that also hold addresses. (Convoluted naming and nuanced questions
    about "is-a" serve as decent indications we should be sticking with composition,
    rather than inheritance.)
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a naïve `AddressHolder` class. We''re calling it naïve because it doesn''t
    account for multiple inheritance well:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We take all the data and toss the argument values into instance variables upon
    initialization. We'll look at the consequences of this, and then show a better
    design.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: The diamond problem
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can use multiple inheritance to add this new class as a parent of our existing
    `Friend` class. The tricky part is that we now have two parent `__init__()` methods,
    both of which need to be called. And they need to be called with different arguments.
    How do we do this? Well, we could start with a naïve approach for the `Friend`
    class, also:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this example, we directly call the `__init__()` function on each of the superclasses
    and explicitly pass the `self` argument. This example technically works; we can
    access the different variables directly on the class. But there are a few problems.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: First, it is possible for a superclass to remain uninitialized if we neglect
    to explicitly call the initializer. That wouldn't break this example, but it could
    cause hard-to-debug program crashes in common scenarios. We would get a lot of
    strange-looking `AttributeError` exceptions in classes where there's clearly an
    `__init__()` method. It's rarely obvious the `__init__()` method wasn't actually
    used.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: 'A more insidious possibility is a superclass being called multiple times because
    of the organization of the class hierarchy. Look at this inheritance diagram:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram  Description automatically generated](img/B17070_03_01.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.1: Inheritance diagram for our multiple inheritance implementation'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: The `__init__()` method from the `Friend` class first calls `__init__()` on the
    `Contact` class, which implicitly initializes the `object` superclass (remember,
    all classes derive from `object`). The `Friend` class then calls `__init__()` on `AddressHolder`,
    which implicitly initializes the `object` superclass *again*. This means the parent
    class has been set up twice. With the `object` class, that's relatively harmless,
    but in some situations, it could spell disaster. Imagine trying to connect to
    a database twice for every request!
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: The base class should only be called once. Once, yes, but when? Do we call `Friend`,
    then `Contact`, then `Object`, and then `AddressHolder`? Or `Friend`, then `Contact`,
    then `AddressHolder`, and then `Object`?
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Let's contrive an example to illustrate this problem more clearly. Here, we
    have a base class, `BaseClass`, that has a method named `call_me()`. Two subclasses,
    `LeftSubclass` and `RightSubclass`, extend the `BaseClass` class, and each overrides
    the `call_me()` method with different implementations.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, *another* subclass extends both of these using multiple inheritance with
    a fourth, distinct implementation of the `call_me()` method. This is called **diamond
    inheritance** because of the diamond shape of the class diagram:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram  Description automatically generated](img/B17070_03_02.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.2: Diamond inheritance'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s convert this diagram into code. This example shows when the methods
    are called:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This example ensures that each overridden `call_me()` method directly calls
    the parent method with the same name. It lets us know each time a method is called
    by printing the information to the screen. It also creates a distinct instance
    variable to show how many times it has been called.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: The `self.num_base_calls += 1` line requires a little sidebar explanation.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: This is effectively `self.num_base_calls = self.num_base_calls + 1`. When Python
    resolves `self.num_base_calls` on the right side of the `=`, it will first look
    for an instance variable, then look for the class variable; we've provided a class
    variable with a default value of zero. After the `+1` computation, the assignment
    statement will create a new instance variable; it will not update the class-level
    variable.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Each time after the first call, the instance variable will be found. It's pretty
    cool for the class to provide default values for instance variables.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'If we instantiate one `Subclass` object and call the `call_me()` method on
    it once, we get the following output:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Thus, we can see the base class's `call_me()` method being called twice. This
    could lead to some pernicious bugs if that method is doing actual work, such as
    depositing into a bank account, twice.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Python's **Method Resolution Order** (**MRO**) algorithm transforms the diamond
    into a flat, linear tuple. We can see the results of this in the `__mro__` attribute
    of a class. The linear version of this diamond is the sequence `Subclass`, `LeftSubclass`,
    `RightSubClass`, `BaseClass`, `object`. What's important here is that `Subclass`
    lists `LeftSubclass` before `RightSubClass`, imposing an ordering on the classes
    in the diamond.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: The thing to keep in mind with multiple inheritance is that we often want to
    call the next method in the MRO sequence, not necessarily a method of the parent
    class. The `super()` function locates the name in the MRO sequence. Indeed, `super()` was
    originally developed to make complicated forms of multiple inheritance possible.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the same code written using `super()`. We''ve renamed some of the classes,
    adding an `_S` to make it clear this is the version using `super()`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The change is pretty minor; we only replaced the naive direct calls with calls
    to `super()`. The `Subclass_S` class, at the bottom of the diamond, only calls `super()`
    once rather than having to make the calls for both the left and right. The change
    is easy enough, but look at the difference when we execute it:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This output looks good: our base method is only being called once. We can see
    how this works by looking at the `__mro__` attribute of the class:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The order of the classes shows what order `super()` will use. The last class
    in the tuple is generally the built-in `object` class. As noted earlier in this
    chapter, it's the implicit superclass of all classes.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'This shows what `super()` is actually doing. Since the `print` statements are
    executed after the `super` calls, the printed output is in the order each method
    is actually executed. Let''s look at the output from back to front to see who
    is calling what:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: We start with the `Subclass_S.call_me()` method. This evaluates `super().call_me()`.
    The MRO shows `LeftSubclass_S` as next.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We begin evaluation of the `LeftSubclass_S.call_me()` method. This evaluates
    `super().call_me()`. The MRO puts `RightSubclass_S` as next. This is not a superclass;
    it's adjacent in the class diamond.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The evaluation of the `RightSubclass_S.call_me()` method, `super().call_me()`.
    This leads to `BaseClass`.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `BaseClass.call_me()` method finishes its processing: printing a message and
    setting an instance variable, `self.num_base_calls`, to `BaseClass.num_base_calls
    + 1`.'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, the `RightSubclass_S.call_me()` method can finish, printing a message
    and setting an instance variable, `self.num_right_calls`.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, the `LeftSubclass_S.call_me()` method will finish by printing a message
    and setting an instance variable, `self.num_left_calls`.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This serves to set the stage for `Subclass_S` to finish its `call_me()` method
    processing. It writes a message, sets an instance variable, and rests, happy and
    successful.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Pay particular attention to this**: The `super` call is *not* calling the
    method on the superclass of `LeftSubclass_S` (which is `BaseClass`). Rather, it
    is calling `RightSubclass_S`, even though it is not a direct parent of `LeftSubclass_S`!
    This is the *next* class in the MRO, not the parent method. `RightSubclass_S` then
    calls `BaseClass` and the `super()` calls have ensured each method in the class
    hierarchy is executed once.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Different sets of arguments
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is going to make things complicated as we return to our `Friend` cooperative
    multiple inheritance example. In the `__init__()` method for the `Friend` class,
    we were originally delegating initialization to the `__init__()` methods of both
    parent classes, *with different sets of arguments*:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: How can we manage different sets of arguments when using `super()`? We only
    really have access to the next class in the MRO sequence. Because of this, we
    need a way to pass the **extra** arguments through the constructors so that subsequent
    calls to super(), from other mixin classes, receive the right arguments.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: It works like this. The first call to `super()` provides arguments to the first
    class of the MRO, passing the `name` and `email` arguments to `Contact.__init__()`.
    Then, when `Contact.__init__()` calls `super()`, it needs to be able to pass the
    address-related arguments to the method of the next class in the MRO, which is `AddressHolder.__init__()`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: This problem often manifests itself anytime we want to call superclass methods
    with the same name, but with different sets of arguments. Collisions often arise
    around the special method names. Of these, the most common example is having a
    different set of arguments to various `__init__()` methods, as we're doing here.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: There's no magical Python feature to handle cooperation among classes with divergent
    `__init__()` parameters. Consequently, this requires some care to design our class
    parameter lists. The cooperative multiple inheritance approach is to accept keyword
    arguments for any parameters that are not required by every subclass implementation.
    A method must pass the unexpected arguments on to its `super()` call, in case
    they are necessary to later methods in the MRO sequence of classes.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: While this works and works well, it's difficult to describe with type hints.
    Instead, we have to silence **mypy** in a few key places.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: 'Python''s function parameter syntax provides a tool we can use to do this,
    but it makes the overall code look cumbersome. Have a look at a version of the `Friend` multiple
    inheritance code:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We've added the `**kwargs` parameter, which collects all additional keyword
    argument values into a dictionary. When called with `Contact(name="this", email="that",
    street="something")`, the `street` argument is put into the `kwargs` dictionary;
    these extra parameters are passed up to the next class with the `super()` call.
    The special parameter `/` separates parameters that could be provided by position
    in the call from parameters that require a keyword to associate them with an argument
    value. We've given all string parameters an empty string as a default value, also.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: If you aren't familiar with the `**kwargs` syntax, it basically collects any
    keyword arguments passed into the method that were not explicitly listed in the
    parameter list. These arguments are stored in a dictionary named `kwargs` (we
    can call the variable whatever we like, but convention suggests `kw` or `kwargs`).
    When we call a method, for example, `super().__init__()`, with `**kwargs` as an
    argument value, it unpacks the dictionary and passes the results to the method
    as keyword arguments. We'll look at this in more depth in *Chapter 8*, *The Intersection
    of Object-Oriented and Functional Programming*.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve introduced two comments that are addressed to **mypy** (and any person
    scrutinizing the code). The `# type: ignore` comments provide a specific error
    code, `call-arg`, on a specific line to be ignored. In this case, we need to ignore
    the `super().__init__(**kwargs)` calls because it isn''t obvious to **mypy** what
    the MRO really will be at runtime. As someone reading the code, we can look at
    the `Friend` class and see the order: `Contact` and `AddressHolder`. This order
    means that inside the `Contact` class, the `super()` function will locate the
    next class, `AddressHolder`.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: The **mypy** tool, however, doesn't look this deeply; it goes by the explicit
    list of parent classes in the `class` statement. Since there's no parent class
    named, **mypy** is convinced the `object` class will be located by `super()`.
    Since `object.__init__()` cannot take any arguments, the `super().__init__(**kwargs)`
    in both `Contact` and `AddressHolder` appears incorrect to **mypy**. Practically,
    the chain of classes in the MRO will consume all of the various parameters and
    there will be nothing left over for the `AddressHolder` class's `__init__()` method.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: For more information on type hint annotations for cooperative multiple inheritance,
    see [https://github.com/python/mypy/issues/8769](https://github.com/python/mypy/issues/8769).
    The longevity of this issue suggests how hard the solution can be.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: The previous example does what it is supposed to do. But it's supremely difficult
    to answer the question: *What arguments do we need to pass into* `Friend.__init__()`?
    This is the foremost question for anyone planning to use the class, so a docstring
    should be added to the method to explain the entire list of parameters from all
    the parent classes.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'The error message in the event of a misspelled or extraneous parameter can
    be confusing, also. The message `TypeError: object.__init__() takes exactly one
    argument (the instance to initialize)` isn''t too informative on how an extra
    parameter came to be provided to `object.__init__()`.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: We have covered many of the caveats involved with cooperative multiple inheritance
    in Python. When we need to account for all possible situations, we have to plan
    for them, and our code can get messy.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Multiple inheritance following the mixin pattern often works out very nicely.
    The idea is to have additional methods defined in mixin classes, but to keep all
    of the attributes centralized in a host class hierarchy. This can avoid the complexity
    of cooperative initialization.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Design using composition also often works better than complex multiple inheritance.
    Many of the design patterns we'll be covering in *Chapter 11*, *Common Design
    Patterns,* and *Chapter 12*, *Advanced Design Patterns*, are examples of composition-based
    design.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: The inheritance paradigm depends on a clear "is-a" relationship between classes.
    Multiple inheritance folds in other relationships that aren't as clear. We can
    say that an "Email is a kind of Contact," for example. But it doesn't seem as
    clear that we can say "A Customer is an Email." We might say "A Customer has an
    Email address" or "A Customer is contacted via Email," using "has an" or "is contacted
    by" instead of a direct "is-a" relationship.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We were introduced to polymorphism in *Chapter 1*, *Object-Oriented Design*.
    It is a showy name describing a simple concept: different behaviors happen depending
    on which subclass is being used, without having to explicitly know what the subclass
    actually is. It is also sometimes called the Liskov Substitution Principle, honoring
    Barbara Liskov''s contributions to object-oriented programming. We should be able
    to substitute any subclass for its superclass.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, imagine a program that plays audio files. A media player might
    need to load an `AudioFile` object and then play it. We can put a `play()` method
    on the object, which is responsible for decompressing or extracting the audio
    and routing it to the sound card and speakers. The act of playing an `AudioFile` could
    feasibly be as simple as:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: However, the process of decompressing and extracting an audio file is very different
    for different types of files. While `.wav` files are stored uncompressed, `.mp3`, `.wma`,
    and `.ogg` files all utilize totally different compression algorithms.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use inheritance with polymorphism to simplify the design. Each type
    of file can be represented by a different subclass of `AudioFile`, for example, `WavFile` and `MP3File`.
    Each of these would have a `play()` method that would be implemented differently
    for each file to ensure that the correct extraction procedure is followed. The
    media player object would never need to know which subclass of `AudioFile` it
    is referring to; it just calls `play()` and polymorphically lets the object take
    care of the actual details of playing. Let''s look at a quick skeleton showing
    how this might work:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: All audio files check to ensure that a valid extension was given upon initialization.
    If the filename doesn't end with the correct name, it raises an exception (exceptions
    will be covered in detail in *Chapter 4*, *Expecting the Unexpected*).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: But did you notice how the `__init__()` method in the parent class is able to
    access the `ext` class variable from different subclasses? That's polymorphism
    at work. The `AudioFile` parent class merely has a type hint explaining to **mypy**
    that there will be an attribute named `ext`. It doesn't actually store a reference
    to the `ext` attribute. When the inherited method is used by a subclass, then
    the subclass' definition of the `ext` attribute is used. The type hint can help
    **mypy** spot a class missing the attribute assignment.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, each subclass of `AudioFile` implements `play()` in a different
    way (this example doesn''t actually play the music; audio compression algorithms
    really deserve a separate book!). This is also polymorphism in action. The media
    player can use the exact same code to play a file, no matter what type it is;
    it doesn''t care what subclass of `AudioFile` it is looking at. The details of
    decompressing the audio file are *encapsulated*. If we test this example, it works
    as we would hope:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: See how `AudioFile.__init__()` can check the file type without actually knowing
    which subclass it is referring to?
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: 'Polymorphism is actually one of the coolest things about object-oriented programming,
    and it makes some programming designs obvious that weren''t possible in earlier
    paradigms. However, Python makes polymorphism seem less awesome because of duck
    typing. Duck typing in Python allows us to use *any* object that provides the
    required behavior without forcing it to be a subclass. The dynamic nature of Python
    makes this trivial. The following example does not extend `AudioFile`, but it
    can be interacted with in Python using the exact same interface:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Our media player can play objects of the `FlacFile` class just as easily as
    objects of classes that extend `AudioFile`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism is one of the most important reasons to use inheritance in many
    object-oriented contexts. Because any objects that supply the correct interface
    can be used interchangeably in Python, it reduces the need for polymorphic common
    superclasses. Inheritance can still be useful for sharing code, but if all that
    is being shared is the public interface, duck typing is all that is required.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: This reduced need for inheritance also reduces the need for multiple inheritance;
    often, when multiple inheritance appears to be a valid solution, we can just use
    duck typing to mimic one of the multiple superclasses.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'In some cases, we can formalize this kind of duck typing using a `typing.Protocol`
    hint. To make **mypy** aware of the expectations, we''ll often define a number
    of functions or attributes (or a mixture) as a formal `Protocol` type. This can
    help clarify how classes are related. We might, for example, have this kind of
    definition to define the common features between the `FlacFile` class and the
    `AudioFile` class hierarchy:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Of course, just because an object satisfies a particular protocol (by providing
    required methods or attributes) does not mean it will simply work in all situations.
    It has to fulfill that interface in a way that makes sense in the overall system.
    Just because an object provides a `play()` method does not mean it will automatically
    work with a media player. The methods must also have the same meaning, or semantics,
    in addition to having the same syntax.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Another useful feature of duck typing is that the duck-typed object only needs
    to provide those methods and attributes that are actually being accessed. For
    example, if we needed to create a fake file object to read data from, we can create
    a new object that has a `read()` method; we don't have to override the `write()` method
    if the code that is going to interact with the fake object will not be calling
    it. More succinctly, duck typing doesn't need to provide the entire interface
    of an object that is available; it only needs to fulfill the protocol that is
    actually used.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Case study
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section expands on the object-oriented design of our example, iris classification.
    We've been building on this in the previous chapters, and we'll continue building
    on it in later chapters. In this chapter, we'll review the diagrams created using
    the **Unified Modeling Language** (**UML**) to help depict and summarize the software
    we're going to build. We'll move on from the previous chapter to add features
    for the various ways of computing "nearest" for the *k*-nearest neighbors algorithm.
    There are a number of variations for this, and it demonstrates how class hierarchies
    work.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several design principles that we''ll be exploring as this design
    becomes more and more complete. One popular set of principles is the **SOLID** principles,
    which are:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '**S**. Single Responsibility Principle. A class should have one responsibility.
    This can mean one reason to change when the application''s requirements change.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**O**. Open/Closed. A class should be open to extension but closed to modification.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**L**. Liskov Substitution. (Named after Barbara Liskov, who created one of
    the first object-oriented programming languages, CLU.) Any subclass can be substituted
    for its superclass. This tends to focus a class hierarchy on classes that have
    very similar interfaces, leading to *polymorphism* among the objects. This the
    essence of inheritance.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**I**. Interface Segregation. A class should have the smallest interface possible.
    This is, perhaps, the most important of these principles. Classes should be relatively
    small and isolated.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**D**. Dependency Inversion. This has a peculiar name. We need to know what
    a bad dependency relationship is so we know how to invert it to have a good relationship.
    Pragmatically, we''d like classes to be independent, so a Liskov Substitution
    doesn''t involve a lot of code changes. In Python, this often means referring
    to superclasses in type hints to be sure we have the flexibility to make changes.
    In some cases, it also means providing parameters so that we can make global class
    changes without revising any of the code.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We won't look at all of these principles in this chapter. Because we're looking
    at inheritance, our design will tend to follow the Liskov Substitution design
    principle. Other chapters will touch on other design principles.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Logical view
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here''s the overview of some of the classes shown in the previous chapter''s
    case study. An important omission from those definitions was the `classify` algorithm
    of the `Hyperparameter` class:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram  Description automatically generated](img/B17070_03_03.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.3: Class overview'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, we avoided delving into the classification algorithm.
    This reflects a common design strategy, sometimes called "*Hard Part, Do Later*,"
    also called "*Do The Easy Part First*." This strategy encourages following common
    design patterns where possible to isolate the hard part. In effect, the easy parts
    define a number of fences that enclose and constrain the novel and unknown parts.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: The classification we're doing is based on the *k*-nearest neighbors algorithm,
    *k*-NN. Given a set of known samples, and an unknown sample, we want to find neighbors
    near the unknown sample; the majority of the neighbors tells us how to classify
    the newcomer. This means *k* is usually an odd number, so the majority is easy
    to compute. We've been avoiding the question, "What do we mean by nearest?"
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: 'In a conventional, two-dimensional geometric sense, we can use the "Euclidean"
    distance between samples. Given an Unknown sample located at ![](img/B17070_03_001.png)
    and a Training sample at ![](img/B17070_03_002.png), the Euclidean distance between
    these samples, ![](img/B17070_03_003.png), is:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17070_03_004.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
- en: 'We can visualize it like this:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '![Chart  Description automatically generated](img/B17070_03_04.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.4: Euclidean distance'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve called this ED2 because it''s only two-dimensional. In our case study
    data, we actually have four dimensions: sepal length, sepal width, petal length,
    and petal width. This is really difficult to visualize, but the math isn''t too
    complex. Even when it''s hard to imagine, we can still write it out fully, like
    so:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17070_03_005.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
- en: All of the two-dimensional examples expand to four dimensions, in spite of how
    hard it is to imagine. We'll stick with the easier to visualize *x-y* distance
    for the diagrams in this section. But we really mean the full four-dimensional
    computation that includes all of the available measurements.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: 'We can capture this computation as a class definition. An instance of this
    `ED` class is usable by the `Hyperparameter` class:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We've leveraged the `math.hypot()` function to do the square and square root
    parts of the distance computation. We've used a superclass, `Distance`, that we
    haven't defined yet. We're pretty sure it's going to be needed, but we'll hold
    off a bit on defining it.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: 'The Euclidean distance is one of many alternative definitions of distance between
    a known and unknown sample. There are two relatively simple ways to compute a
    distance that are similar, and they often produce consistently good results without
    the complexity of a square root:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '**Manhattan distance**: This is the distance you would walk in a city with
    square blocks (somewhat like parts of the city of Manhattan.)'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Chebyshev distance**: This counts a diagonal step as 1\. A Manhattan computation
    would rank this as 2\. The Euclidean distance would be ![](img/B17070_03_006.png),
    as depicted in *Figure 3.4*.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With a number of alternatives, we''re going to need to create distinct subclasses.
    That means we''ll need a base class to define the general idea of distances. Looking
    over the definitions at hand, it seems like the base class can be the following:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This seems to capture the essence of the distance computations we've seen. Let's
    implement a few more subclasses of this to be sure the abstraction really works.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'The Manhattan distance is the total number of steps along the *x*-axis, plus
    the total number of steps along the *y*-axis. The formula uses the absolute values
    of the distances, written as ![](img/B17070_03_007.png), and looks like this:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17070_03_008.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
- en: This can be as much as 41% larger than the direct Euclidean distance. However,
    it will still parallel the direct distance in a way that can yield a good *k*-NN
    result, but with a faster computation because it avoids squaring numbers and computing
    a square root.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a view of the Manhattan distance:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '![A picture containing chart  Description automatically generated](img/B17070_03_05.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.5: Manhattan distance'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a subclass of `Distance` that computes this variation:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The Chebyshev distance is the largest of the absolute *x* or *y* distances.
    This tends to minimize the effects of multiple dimensions:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17070_03_009.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
- en: 'Here''s a view of the Chebyshev distance; it tends to emphasize neighbors that
    are closer to each other:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '![Chart  Description automatically generated](img/B17070_03_06.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.6: Chebyshev distance'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a subclass of `Distance` that performs this variant on the distance
    computation:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: See *Effects of Distance Measure Choice on KNN Classifier Performance - A Review*
    ([https://arxiv.org/pdf/1708.04321.pdf](https://arxiv.org/pdf/1708.04321.pdf)).
    This paper contains 54 distinct metrics computations. The examples we're looking
    at are collectively identified as "Minkowski" measures because they're similar
    and measure each axis equally. Each alternative distance strategy yields different
    results in the model's ability to classify unknown samples given a set of training
    data.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: 'This changes the idea behind the `Hyperparameter` class: we now have two distinct
    hyperparameters. The value of *k*, to decide how many neighbors to examine, and
    the distance computation, which tells us how to compute "nearest." These are both
    changeable parts of the algorithm, and we''ll need to test various combinations
    to see which works best for our data.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: How can we have all of these different distance computations available? The
    short answer is we'll need a lot of subclass definitions of a common distance
    class. The review paper cited above lets us pare down the domain to a few of the
    more useful distance computations. To be sure we've got a good design, let's look
    at one more distance.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Another distance
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Just to make it clear how easy it is to add subclasses, we''ll define a somewhat
    more complex distance metric. This is the Sorensen distance, also known as Bray-Curtis.
    If our distance class can handle these kinds of more complex formulas, we can
    be confident it''s capable of handling others:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17070_03_010.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
- en: We've effectively standardized each component of the Manhattan distance by dividing
    by the possible range of values.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a diagram to illustrate how the Sorensen distance works:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '![Chart  Description automatically generated with medium confidence](img/B17070_03_07.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.7: Manhattan versus Sorensen distance'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: The simple Manhattan distance applies no matter how far from the origin we are.
    The Sorensen distance reduces the importance of measures that are further from
    the origin so they don't dominate the *k*-NN by virtue of being large-valued outliers.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: 'We can introduce this into our design by adding a new subclass of `Distance`.
    While this is similar, in some ways, to the Manhattan distance, it''s often classified
    separately:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This design approach lets us leverage object-oriented inheritance to build a
    polymorphic family of distance computation functions. We can build on the first
    few functions to create a wide family of functions and use these as part of hyperparameter
    tuning to locate the best way to measure distances and perform the required classification.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: We'll need to integrate a `Distance` object into the `Hyperparameter` class.
    This means providing an instance of one of these subclasses. Because they're all
    implementing the same `distance()` method, we can replace different alternative
    distance computations to find which performs best with our unique collection of
    data and attributes.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: For now, we can reference a specific distance subclass in our `Hyperparameter`
    class definition. In *Chapter 11*, *Common Design Patterns*, we'll look at how
    we can flexibly plug in any possible distance computation from the hierarchy of
    `Distance` class definitions.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: Recall
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some key points in this chapter:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: 'A central object-oriented design principle is inheritance: a subclass can inherit
    aspects of a superclass, saving copy-and-paste programming. A subclass can extend
    the superclass to add features or specialize the superclass in other ways.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple inheritance is a feature of Python. The most common form is a host
    class with mixin class definitions. We can combine multiple classes leveraging
    the method resolution order to handle common features like initialization.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Polymorphism lets us create multiple classes that provide alternative implementations
    for fulfilling a contract. Because of Python's duck typing rules, any classes
    that have the right methods can substitute for each other.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Look around you at some of the physical objects in your workspace and see if
    you can describe them in an inheritance hierarchy. Humans have been dividing the
    world into taxonomies like this for centuries, so it shouldn't be difficult. Are
    there any non-obvious inheritance relationships between classes of objects? If
    you were to model these objects in a computer application, what properties and
    methods would they share? Which ones would have to be polymorphically overridden?
    What properties would be completely different between them?
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Now write some code. No, not for the physical hierarchy; that's boring. Physical
    items have more properties than methods. Just think about a pet programming project
    you've wanted to tackle in the past year, but never gotten around to. For whatever
    problem you want to solve, try to think of some basic inheritance relationships
    and then implement them. Make sure that you also pay attention to the sorts of
    relationships that you actually don't need to use inheritance for. Are there any
    places where you might want to use multiple inheritance? Are you sure? Can you
    see any place where you would want to use a mixin? Try to knock together a quick
    prototype. It doesn't have to be useful or even partially working. You've seen how
    you can test code using `python -i` already; just write some code and test it in
    the interactive interpreter. If it works, write some more. If it doesn't, fix
    it!
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: Now, take a look at the various distance computations in the case study. We
    need to be able to work with testing data as well as unknown samples provided
    by a user. What do these two kinds of samples have in common? Can you create a
    common superclass and use inheritance for these two classes with similar behavior?
    (We haven't looked closely at the *k*-NN classification yet, but you can provide
    a "mock" classifier that will provide fake answers.)
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: When we look at the distance computation, we can see how a `Hyperparameter`
    is a composition that includes a distance algorithm plug-in as one of the parameters.
    Is this a good candidate for a mixin? Why or why not? What limitations does a
    mixin have that a plug-in does not have?
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've gone from simple inheritance, one of the most useful tools in the object-oriented
    programmer's toolbox, all the way through to multiple inheritance – one of the
    most complicated. Inheritance can be used to add functionality to existing classes
    and built-in generics. Abstracting similar code into a parent class can help increase
    maintainability. Methods on parent classes can be called using `super`, and argument
    lists must be formatted safely for these calls to work when using multiple inheritance.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll cover the subtle art of handling exceptional circumstances.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
