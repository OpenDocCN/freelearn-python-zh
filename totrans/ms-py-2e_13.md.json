["```py\nimport asyncio\n\n@asyncio.coroutine\ndef main():\n    print('Hello from main')\n    yield from asyncio.sleep(1)\n\nloop = asyncio.new_event_loop()\nloop.run_until_complete(main())\nloop.close() \n```", "```py\nimport asyncio\n\nasync def main():\n    print('Hello from main')\n    await asyncio.sleep(1)\n\nloop = asyncio.new_event_loop()\nloop.run_until_complete(main())\nloop.close() \n```", "```py\nimport asyncio\n\nasync def main():\n    print('Hello from main')\n    await asyncio.sleep(1)\n\nasyncio.run(main()) \n```", "```py\nimport asyncio\n\nasync def main():\n    print('Hello from main')\n    await asyncio.sleep(1)\n\nloop = asyncio.new_event_loop()\nasyncio.set_event_loop(loop)\ntry:\n    loop.run_until_complete(main())\nfinally:\n    # Run the loop again to finish pending tasks\n    loop.run_until_complete(asyncio.sleep(0))\n\n    asyncio.set_event_loop(None)\n    loop.close() \n```", "```py\nimport asyncio\n\nasync def main():\n    print('Hello from main')\n    await asyncio.sleep(1)\n\nloop = asyncio.get_event_loop()\nloop.run_until_complete(main()) \n```", "```py\n>>> import time\n>>> import asyncio\n\n>>> def normal_sleep():\n...     print('before sleep')\n...     time.sleep(1)\n...     print('after sleep')\n\n>>> def normal_sleeps(n):\n...     for _ in range(n):\n...         normal_sleep()\n\n# Normal execution\n>>> start = time.time()\n>>> normal_sleeps(2)\nbefore sleep\nafter sleep\nbefore sleep\nafter sleep\n>>> print(f'duration: {time.time() - start:.0f}')\nduration: 2 \n```", "```py\n>>> async def asyncio_sleep():\n...     print('before sleep')\n...     await asyncio.sleep(1)\n...     print('after sleep')\n\n>>> async def asyncio_sleeps(n):\n...     coroutines = []\n...     for _ in range(n):\n...         coroutines.append(asyncio_sleep())\n...\n...     await asyncio.gather(*coroutines)\n\n>>> start = time.time()\n>>> asyncio.run(asyncio_sleeps(2))\nbefore sleep\nbefore sleep\nafter sleep\nafter sleep\n>>> print(f'duration: {time.time() - start:.0f}')\nduration: 1 \n```", "```py\n>>> import asyncio\n>>> import selectors\n\n>>> selector = selectors.SelectSelector()\n>>> loop = asyncio.SelectorEventLoop(selector)\n>>> asyncio.set_event_loop(loop) \n```", "```py\nimport asyncio\n\nclass UvLoopPolicy(asyncio.DefaultEventLoopPolicy):\n    def new_event_loop(self):\n        try:\n            from uvloop import Loop\n            return Loop()\n        except ImportError:\n            return super().new_event_loop()\n\nasyncio.set_event_loop_policy(UvLoopPolicy()) \n```", "```py\n>>> import time\n>>> import asyncio\n\n>>> def printer(name):\n...     print(f'Started {name} at {loop.time() - offset:.1f}')\n...     time.sleep(0.2)\n...     print(f'Finished {name} at {loop.time() - offset:.1f}')\n\n>>> loop = asyncio.new_event_loop()\n>>> _ = loop.call_at(loop.time() + .2, printer, 'call_at')\n>>> _ = loop.call_later(.1, printer, 'call_later')\n>>> _ = loop.call_soon(printer, 'call_soon')\n>>> _ = loop.call_soon_threadsafe(printer, 'call_soon_threadsafe')\n\n>>> # Make sure we stop after a second\n>>> _ = loop.call_later(1, loop.stop)\n\n# Store the offset because the loop requires time to start\n>>> offset = loop.time()\n\n>>> loop.run_forever()\nStarted call_soon at 0.0\nFinished call_soon at 0.2\nStarted call_soon_threadsafe at 0.2\nFinished call_soon_threadsafe at 0.4\nStarted call_later at 0.4\nFinished call_later at 0.6\nStarted call_at at 0.6\nFinished call_at at 0.8 \n```", "```py\n>>> import time\n>>> import asyncio\n\n>>> def executor_sleep():\n...     print('before sleep')\n...     time.sleep(1)\n...     print('after sleep')\n\n>>> async def executor_sleeps(n):\n...     loop = asyncio.get_running_loop()\n...     futures = []\n...     for _ in range(n):\n...         future = loop.run_in_executor(None, executor_sleep)\n...         futures.append(future)\n...\n...     await asyncio.gather(*futures)\n\n>>> start = time.time()\n>>> asyncio.run(executor_sleeps(2))\nbefore sleep\nbefore sleep\nafter sleep\nafter sleep\n>>> print(f'duration: {time.time() - start:.0f}')\nduration: 1 \n```", "```py\nimport time\nimport asyncio\nimport concurrent.futures\n\ndef executor_sleep():\n    print('before sleep')\n    time.sleep(1)\n    print('after sleep')\n\nasync def executor_sleeps(n):\n    loop = asyncio.get_running_loop()\n    futures = []\n    with concurrent.futures.ProcessPoolExecutor() as pool:\n        for _ in range(n):\n            future = loop.run_in_executor(pool, executor_sleep)\n            futures.append(future)\n\n        await asyncio.gather(*futures)\n\nif __name__ == '__main__':\n    start = time.time()\n    asyncio.run(executor_sleeps(2))\n    print(f'duration: {time.time() - start:.0f}') \n```", "```py\n>>> import time\n>>> import subprocess\n\n>>> def subprocess_sleep():\n...     print(f'Started sleep at: {time.time() - start:.1f}')\n...     process = subprocess.Popen(['sleep', '0.1'])\n...     process.wait()\n...     print(f'Finished sleep at: {time.time() - start:.1f}')\n\n>>> start = time.time() \n```", "```py\n>>> for _ in range(2):\n...     subprocess_sleep()\nStarted sleep at: 0.0\nFinished sleep at: 0.1\nStarted sleep at: 0.1\nFinished sleep at: 0.2 \n```", "```py\n>>> import time\n>>> import subprocess\n\n>>> def subprocess_sleep():\n...     print(f'Started sleep at: {time.time() - start:.1f}')\n...     return subprocess.Popen(['sleep', '0.1'])\n\n>>> start = time.time() \n```", "```py\n>>> processes = []\n>>> for _ in range(2):\n...     processes.append(subprocess_sleep())\nStarted sleep at: 0.0\nStarted sleep at: 0.0 \n```", "```py\n>>> for process in processes:\n...     returncode = process.wait()\n...     print(f'Finished sleep at: {time.time() - start:.1f}')\nFinished sleep at: 0.1\nFinished sleep at: 0.1 \n```", "```py\n>>> import time\n>>> import asyncio\n\n>>> async def async_process_sleep():\n...     print(f'Started sleep at: {time.time() - start:.1f}')\n...     process = await asyncio.create_subprocess_exec('sleep', '0.1')\n...     await process.wait()\n...     print(f'Finished sleep at: {time.time() - start:.1f}')\n\n>>> async def main():\n...     coroutines = []\n...     for _ in range(2):\n...         coroutines.append(async_process_sleep())\n...     await asyncio.gather(*coroutines)\n\n>>> start = time.time()\n>>> asyncio.run(main())\nStarted sleep at: 0.0\nStarted sleep at: 0.0\nFinished sleep at: 0.1\nFinished sleep at: 0.1 \n```", "```py\n>>> import time\n>>> import asyncio\n\n>>> async def run_python_script(script):\n...     print(f'Executing: {script!r}')\n...     process = await asyncio.create_subprocess_exec(\n...         'python3',\n...         stdout=asyncio.subprocess.PIPE,\n...         stdin=asyncio.subprocess.PIPE,\n...     )\n...     stdout, stderr = await process.communicate(script)\n...     print(f'stdout: {stdout!r}')\n\n>>> asyncio.run(run_python_script(b'print(2 ** 20)'))\nExecuting: b'print(2 ** 20)'\nstdout: b'1048576\\n' \n```", "```py\n>>> import asyncio\n\n>>> async def run_script():\n...     process = await asyncio.create_subprocess_exec(\n...         'python3',\n...         stdout=asyncio.subprocess.PIPE,\n...         stdin=asyncio.subprocess.PIPE,\n...     )\n... \n...     # Write a simple Python script to the interpreter\n...     process.stdin.write(b'print(\"Hi~\")')\n... \n...     # Make sure the stdin is flushed asynchronously\n...     await process.stdin.drain()\n...     # And send the end of file so the Python interpreter will\n...     # start processing the input. Without this the process will\n...     # stall forever.\n...     process.stdin.write_eof()\n... \n...     # Fetch the lines from the stdout asynchronously\n...     async for line in process.stdout:\n...         # Decode the output from bytes and strip the whitespace\n...         # (newline) at the right\n...         print('stdout:', line.rstrip())\n... \n...     # Wait for the process to exit\n...     await process.wait()\n\n>>> asyncio.run(run_script())\nstdout: b'Hi~' \n```", "```py\n>>> import asyncio\n\n>>> HOST = '127.0.0.1'\n>>> PORT = 1234\n\n>>> async def echo_client(message):\n...     # Open the connection to the server\n...     reader, writer = await asyncio.open_connection(HOST, PORT)\n... \n...     print(f'Client sending {message!r}')\n...     writer.write(message)\n... \n...     # We need to drain and write the EOF to stop sending\n...     writer.write_eof()\n...     await writer.drain()\n... \n...     async for line in reader:\n...         print(f'Client received: {line!r}')\n... \n...     writer.close()\n\n>>> async def echo(reader, writer):\n...     # Read all lines from the reader and send them back\n...     async for line in reader:\n...         print(f'Server received: {line!r}')\n...         writer.write(line)\n...         await writer.drain()\n... \n...     writer.close()\n\n>>> async def echo_server():\n...     # Create a TCP server that listens on 'HOST'/'PORT' and\n...     # calls 'echo' when a client connects.\n...     server = await asyncio.start_server(echo, HOST, PORT)\n... \n...     # Start listening\n...     async with server:\n...         await server.serve_forever()\n\n>>> async def main():\n...     # Create and run the echo server\n...     server_task = asyncio.create_task(echo_server())\n... \n...     # Wait a little for the server to start\n...     await asyncio.sleep(0.01)\n... \n...     # Create a client and send the message\n...     await echo_client(b'test message')\n... \n...     # Kill the server\n...     server_task.cancel()\n\n>>> asyncio.run(main())\nClient sending b'test message'\nServer received: b'test message'\nClient received: b'test message' \n```", "```py\n$ pip3 install aiofiles \n```", "```py\n>>> import asyncio\n>>> import aiofiles\n\n>>> async def main():\n...     async with aiofiles.open('aiofiles.txt', 'w') as fh:\n...         await fh.write('Writing to file')\n...\n...     async with aiofiles.open('aiofiles.txt', 'r') as fh:\n...         async for line in fh:\n...             print(line) \n\n>>> asyncio.run(main())\nWriting to file \n```", "```py\n>>> import asyncio\n\n>>> class AsyncGenerator:\n...     def __init__(self, iterable):\n...         self.iterable = iterable\n...\n...     async def __aiter__(self):\n...         for item in self.iterable:\n...             yield item\n\n>>> async def main():\n...     async_generator = AsyncGenerator([4, 2])\n...\n...     async for item in async_generator:\n...         print(f'Got item: {item}')\n\n>>> asyncio.run(main())\nGot item: 4\nGot item: 2 \n```", "```py\n>>> import asyncio\n\n>>> class AsyncContextManager:\n...     async def __aenter__(self):\n...         print('Hi :)')\n...\n...     async def __aexit__(self, exc_type, exc_value, traceback):\n...         print('Bye :(')\n\n>>> async def main():\n...     async_context_manager = AsyncContextManager()\n...\n...     print('Before with')\n...     async with async_context_manager:\n...         print('During with')\n...     print('After with')\n\n>>> asyncio.run(main())\nBefore with\nHi :)\nDuring with\nBye :(\nAfter with \n```", "```py\n>>> import asyncio\n\n>>> class SomeClass:\n...     def __init__(self, *args, **kwargs):\n...         print('Sync init')\n...\n...     async def init(self, *args, **kwargs):\n...         print('Async init')\n...\n...     @classmethod\n...     async def create(cls, *args, **kwargs):\n...         # Create an instance of 'SomeClass' which calls the\n...         # sync init: 'SomeClass.__init__(*args, **kwargs)'\n...         self = cls(*args, **kwargs)\n...         # Now we can call the async init:\n...         await self.init(*args, **kwargs)\n...         return self\n...\n...     async def close(self):\n...         print('Async destructor')\n...\n...     def __del__(self):\n...         print('Sync destructor')\n\n>>> async def main():\n...     # Note that we use 'SomeClass.create()' instead of\n...     # 'SomeClass()' so we also run 'SomeClass().init()'\n...     some_class = await SomeClass.create()\n...     print('Using the class here')\n...     await some_class.close()\n...     del some_class\n\n>>> asyncio.run(main())\nSync init\nAsync init\nUsing the class here\nAsync destructor\nSync destructor \n```", "```py\n$ pip3 install asyncpg \n```", "```py\nimport typing\nimport asyncio\nimport asyncpg\n\nclass AsyncPg:\n    _connection: typing.Optional[asyncpg.Connection]\n\n    async def init(self):\n        self._connection = asyncpg.connect(...)\n\n    async def close(self):\n        await self._connection.close()\n\n    def __del__(self):\n        if self._connection:\n            loop = asyncio.get_event_loop()\n            if loop.is_running():\n                loop.create_task(self.close())\n            else:\n                loop.run_until_complete(self.close())\n\n            self._connection = None \n```", "```py\nSOME_ENVIRONMENT_VARIABLE=value python3 script.py \n```", "```py\nexport SOME_ENVIRONMENT_VARIABLE=value \n```", "```py\necho $SOME_ENVIRONMENT_VARIABLE \n```", "```py\nset SOME_ENVIRONMENT_VARIABLE=value \n```", "```py\nset SOME_ENVIRONMENT_VARIABLE \n```", "```py\nasync def printer():\n    print('This is a coroutine')\n\nprinter() \n```", "```py\n$ PYTHONASYNCIODEBUG=1 python3 T_13_forgot_await.py\nT_13_forgot_await.py:5: RuntimeWarning: coroutine 'printer' was never awaited\n  printer()\nRuntimeWarning: Enable tracemalloc to get the object allocation traceback \n```", "```py\nimport time\nimport asyncio\n\nasync def main():\n    # Oh no... a synchronous sleep from asyncio code\n    time.sleep(0.2)\n\nasyncio.run(main(), debug=True) \n```", "```py\n$ PYTHONASYNCIODEBUG=1 python3 T_14_slow_blocking_code.py\nExecuting <Task finished ...> took 0.204 seconds \n```", "```py\nimport asyncio\n\nasync def throw_exception():\n    raise RuntimeError()\n\nasync def main():\n    # Ignoring an exception from an async def\n    asyncio.create_task(throw_exception())\n\nasyncio.run(main()) \n```", "```py\n$ python3 T_15_forgotten_exception.py\nTask exception was never retrieved\nfuture: <Task finished ... at T_15_forgotten_exception.py:4> exception=RuntimeError()>\nTraceback (most recent call last):\n  File \"T_15_forgotten_exception.py\", line 5, in throw_exception\n    raise RuntimeError()\nRuntimeError \n```", "```py\n$ PYTHONASYNCIODEBUG=1 python3 T_15_forgotten_exception.py\nTask exception was never retrieved\nfuture: <Task finished ... at T_15_forgotten_exception.py:4> exception=RuntimeError() created at asyncio/tasks.py:361>\nsource_traceback: Object created at (most recent call last):\n  File \"T_15_forgotten_exception.py\", line 13, in <module>\n    asyncio.run(main())\n  File \"asyncio/runners.py\", line 44, in run\n    return loop.run_until_complete(main)\n  File \"asyncio/base_events.py\", line 629, in run_until_complete\n    self.run_forever()\n  File \"asyncio/base_events.py\", line 596, in run_forever\n    self._run_once()\n  File \"asyncio/base_events.py\", line 1882, in _run_once\n    handle._run()\n  File \"asyncio/events.py\", line 80, in _run\n    self._context.run(self._callback, *self._args)\n  File \"T_15_forgotten_exception.py\", line 10, in main\n    asyncio.create_task(throw_exception())\n  File \"asyncio/tasks.py\", line 361, in create_task\n    task = loop.create_task(coro)\nTraceback (most recent call last):\n  File \"T_15_forgotten_exception.py\", line 5, in throw_exception\n    raise RuntimeError()\nRuntimeError \n```", "```py\nimport asyncio\n\nasync def sub_printer():\n    print('Hi from the sub-printer')\n\nasync def printer():\n    print('Before creating the sub-printer task')\n    asyncio.create_task(sub_printer())\n    print('After creating the sub-printer task')\n\nasync def main():\n    asyncio.create_task(printer())\n\nasyncio.run(main()) \n```", "```py\n$ PYTHONASYNCIODEBUG=1 python3 T_16_early_exit.py\nBefore creating the sub-printer task\nAfter creating the sub-printer task \n```", "```py\nimport asyncio\n\nasync def sub_printer():\n    print('Hi from the sub-printer')\n\nasync def printer():\n    print('Before creating the sub-printer task')\n    asyncio.create_task(sub_printer())\n    print('After creating the sub-printer task')\n\nasync def main():\n    asyncio.create_task(printer())\n    await asyncio.sleep(0.1)\n\nasyncio.run(main()) \n```", "```py\n$ python3 T_17_wait_for_exit.py\nBefore creating the sub-printer task\nAfter creating the sub-printer task\nHi from the sub-printer \n```", "```py\nimport asyncio\n\nasync def sub_printer():\n    print('Hi from the sub-printer')\n\nasync def printer():\n    print('Before creating the sub-printer task')\n    asyncio.create_task(sub_printer())\n    print('After creating the sub-printer task')\n\nasync def main():\n    asyncio.create_task(printer())\n    await shutdown()\n\nasync def shutdown(timeout=5):\n    tasks = []\n    # Collect all tasks from 'asyncio'\n    for task in asyncio.all_tasks():\n        # Make sure we skip our current task so we don't loop\n        if task is not asyncio.current_task():\n            tasks.append(task)\n\n    for future in asyncio.as_completed(tasks, timeout=timeout):\n        await future\n\nasyncio.run(main()) \n```"]