<html><head></head><body>
		<div><h1 id="_idParaDest-51" class="chapter-number"><a id="_idTextAnchor054"/>3</h1>
			<h1 id="_idParaDest-52"><a id="_idTextAnchor055"/>Social Media Post Management</h1>
			<p>In the previous chapter, we introduced models, serializers, viewsets, and routes to create our first endpoints. In this chapter, we will be working with the same concepts for creating posts for our social media project. This will be done by dividing the project into concepts such as database relations, filtering, and permissions. By the end of this chapter, you’ll be able to work with database relations with Django models, write custom filters and permissions, and delete and update objects.</p>
			<p>We will be covering the following topics in this chapter:</p>
			<ul>
				<li>Creating the Post model</li>
				<li>Writing the Post model</li>
				<li>Writing the Post serializer</li>
				<li>Writing Post viewsets</li>
				<li>Adding permissions</li>
				<li>Deleting and updating posts</li>
				<li>Adding the Like feature</li>
			</ul>
			<h1 id="_idParaDest-53"><a id="_idTextAnchor056"/>Technical requirements</h1>
			<p>For this chapter, you need to have Insomnia installed on your machine to make HTTP requests.</p>
			<p>You can find the code for this chapter here: <a href="https://github.com/PacktPublishing/Full-stack-Django-and-React/tree/chap3">https://github.com/PacktPublishing/Full-stack-Django-and-React/tree/chap3</a>.</p>
			<h1 id="_idParaDest-54"><a id="_idTextAnchor057"/>Creating the Post model</h1>
			<p>A post in this project is a long or short piece of text that can be viewed by anyone, irrespective of whether a<a id="_idIndexMarker145"/> user is linked or associated to that post. Here are the requirements for the post feature:</p>
			<ul>
				<li>Authenticated users should be able to create a post</li>
				<li>Authenticated users should be able to like the post</li>
				<li>All users should be able to read the post, even if they aren’t authenticated</li>
				<li>The author of the post should be able to modify the post</li>
				<li>The author of the post should be able to delete the post</li>
			</ul>
			<p>Looking at these requirements from a backend perspective, we can understand that we’ll be dealing with a database, a model, and permissions. First, let’s start by writing the structure of the <code>Post</code> model in the database.</p>
			<h2 id="_idParaDest-55"><a id="_idTextAnchor058"/>Designing the Post model</h2>
			<p>A post consists of content <a id="_idIndexMarker146"/>made up of characters written by an author (here, a user). How does that schematize itself into our database?</p>
			<p>Before creating the <code>Post</code> model, let’s draw a quick figure of the structure of the model in the database:</p>
			<div><div><img src="img/Figure_3.1_B18221.jpg" alt="Figure 3.1 – Post table"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1 – Post table</p>
			<p>As you can see in <em class="italic">Figure 3</em><em class="italic">.1</em>, there is an <code>author</code> field, which is a <code>User</code> table. Each time a post is created, a foreign<a id="_idIndexMarker148"/> key will need to be passed.</p>
			<p>The foreign key is one of the characteristics of the <strong class="bold">one-to-many</strong> (or <strong class="bold">many-to-one</strong>) relationship. In this relationship, a row in table A can have many matching rows in table B (<em class="italic">one-to-many</em>) but a row in table B can only have one matching row in table A.</p>
			<p>In our case, a user (from the <code>User</code> table) can have many posts (in the <code>Post</code> table) but a post can only have one user (<em class="italic">Figure 3</em><em class="italic">.2</em>):</p>
			<div><div><img src="img/Figure_3.2_B18221.jpg" alt="Figure 3.2 – User and Post relationship"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.2 – User and Post relationship</p>
			<p>There are also two other types of database relationships:</p>
			<ul>
				<li>One-to-one: In this type of relationship, a row in table A can only have one matching row in table B, and vice versa. An example of this can be worker C having one and only one desk D. And this desk D can <a id="_idIndexMarker149"/>only be used by this worker C (<em class="italic">Figure 3</em><em class="italic">.3</em>):</li>
			</ul>
			<div><div><img src="img/Figure_3.3_B18221.jpg" alt="Figure 3.3 – One-to-one relationship between a worker and a desk"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.3 – One-to-one relationship between a worker and a desk</p>
			<ul>
				<li>Many-to-many: In this type of database relationship, a row in table A can have many matching rows in table B, and vice versa. For example, in an e-commerce application, an order can have many items, and an item can also appear in many different orders (<em class="italic">Figure 3</em><em class="italic">.4</em>):</li>
			</ul>
			<div><div><img src="img/Figure_3.4_B18221.jpg" alt="Figure 3.4 – Many-to-many relationship between an order and an item"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.4 – Many-to-many relationship between an order and an item</p>
			<p>The <em class="italic">many-to-many</em> relationship will be used when writing the <em class="italic">like</em> feature for the posts.</p>
			<p>Great, now that we have a better idea of database relationships, we can begin to write the post feature, starting from the <code>Post</code> model. But before that, let’s quickly refactor the code to make development easier.</p>
			<h2 id="_idParaDest-56"><a id="_idTextAnchor059"/>Abstraction</h2>
			<p>The next models that we’ll create will also have the <code>public_id</code>, <code>created</code>, and <code>updated</code> fields. For the <a id="_idIndexMarker150"/>sake of the <strong class="bold">don’t repeat yourself</strong> (<strong class="bold">DRY</strong>) principle, we will <a id="_idIndexMarker151"/>use abstract model classes.</p>
			<p>An <strong class="bold">abstract class</strong> can be considered a <a id="_idIndexMarker152"/>blueprint for other classes. It usually contains a set of methods or attributes that must be created within any child classes built from the abstract class.</p>
			<p>Inside the <code>core</code> directory, create a new Python package called <code>abstract</code>. Once it’s done, create a <code>models.py</code> file. In this file, we will write two classes: <code>AbstractModel</code> and <code>AbstractManager</code>.</p>
			<p>The <code>AbstractModel</code> class will contain fields such as <code>public_id</code>, <code>created</code>, and <code>updated</code>. On the other side, the <code>AbstractManager</code> class will contain the function used to retrieve an object by its <code>public_id</code> field:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/abstract/models.py</p>
			<pre class="source-code">
from django.db import models
import uuid
from django.core.exceptions import ObjectDoesNotExist
from django.http import Http404
class AbstractManager(models.Manager):
   def get_object_by_public_id(self, public_id):
       try:
           instance = self.get(public_id=public_id)
           return instance
       except (ObjectDoesNotExist, ValueError, TypeError):
           return Http404
class AbstractModel(models.Model):
   public_id = models.UUIDField(db_index=True, unique=True,
     default=uuid.uuid4, editable=False)
   created = models.DateTimeField(auto_now_add=True)
   updated = models.DateTimeField(auto_now=True)
   objects = AbstractManager()
   class Meta:
       abstract = True</pre>
			<p>As you can see in the <code>Meta</code> class for <code>AbstractModel</code>, the <code>abstract</code> attribute is set to <code>True</code>. Django will ignore this class model and won’t generate migrations<a id="_idIndexMarker153"/> for this.</p>
			<p>Now that we have this class, let’s make a quick refactor on the <code>User</code> model:</p>
			<p>First, let’s remove the <code>get_object_by_public_id</code> method to retrieve an object via <code>public_id</code>, and let’s subclass <code>UserManager</code>:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/user/models.py</p>
			<pre class="source-code">
…
from core.abstract.models import AbstractModel, AbstractManager
class UserManager(BaseUserManager, AbstractManager):
…
class User(AbstractModel, AbstractBaseUser, PermissionsMixin):
…</pre>
			<p>On the <code>User</code> model, remove the <code>public_id</code>, <code>updated</code>, and <code>created</code> fields, and also, subclass the <code>User</code> model with the <code>AbstractModel</code> class. This will normally cause no changes to the <a id="_idIndexMarker154"/>database, hence, there is no need to run <code>makemigrations</code> again unless you’ve changed an attribute of a field.</p>
			<p>Let’s also add <code>AbstractSerializer</code>, which will be used by all the serializers we’ll be creating on this project.</p>
			<h2 id="_idParaDest-57"><a id="_idTextAnchor060"/>Writing the AbstractSerializer</h2>
			<p>All the objects sent back as <a id="_idIndexMarker155"/>a response in our API will contain the <code>id</code>, <code>created</code>, and <code>updated</code> fields. It’ll be repetitive to write these fields all over again on every <code>ModelSerializer</code>, so let’s just create an <code>AbstractSerializer</code> class. In the <code>abstract</code> directory, create a file called <code>serializers.py</code> and add the<a id="_idIndexMarker156"/> following content:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/abstract/serializers.py</p>
			<pre class="source-code">
from rest_framework import serializers
class AbstractSerializer(serializers.ModelSerializer):
   id = serializers.UUIDField(source='public_id',
                              read_only=True, format='hex')
   created = serializers.DateTimeField(read_only=True)
   updated = serializers.DateTimeField(read_only=True)</pre>
			<p>Once it’s done, you can go and subclass the <code>UserSerializer</code> class with the <code>AbstractSerializer</code> class:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/user/serializers.py</p>
			<pre class="source-code">
from core.abstract.serializers import AbstractSerializer
from core.user.models import User
class UserSerializer(AbstractSerializer):
…</pre>
			<p>Once it’s done, remove<a id="_idIndexMarker157"/> the field declaration of <code>id</code>, <code>created</code>, and <code>updated</code>.</p>
			<p>Let’s perform one last <a id="_idIndexMarker158"/>abstraction for <code>ViewSets</code>.</p>
			<h2 id="_idParaDest-58"><a id="_idTextAnchor061"/>Writing the AbstractViewSet</h2>
			<p>But why write an abstract <code>ViewSet</code>? Well, there <a id="_idIndexMarker159"/>will be repeated declarations as to the ordering and the filtering. Let’s create a class that will contain the default values.</p>
			<p>In the <code>abstract</code> directory, create a file called <code>viewsets.py</code> and add the following content:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/abstract/viewsets.py</p>
			<pre class="source-code">
from rest_framework import viewsets
from rest_framework import filters
class AbstractViewSet(viewsets.ModelViewSet):
   filter_backends = [filters.OrderingFilter]
   ordering_fields = ['updated', 'created']
   ordering = ['-updated']</pre>
			<p>As you can see, we have the following attributes:</p>
			<ul>
				<li><code>filter_backends</code>: This sets the default filter backend.</li>
				<li><code>ordering_fields</code>: This list contains the fields that can be used as ordering parameters when making a request.</li>
				<li><code>ordering</code>: This will tell Django REST in which order to send many objects as a response. In this case, all the responses will be ordered by the most recently updated.</li>
			</ul>
			<p>The next step is to add the <code>AbstractViewSet</code> class to the code where <code>ModelViewSets</code> is actually<a id="_idIndexMarker160"/> called. Go to <code>core/user/viewsets.py</code> and <a id="_idIndexMarker161"/>subclass <code>UserViewSet</code> with the <code>AbstractViewSet</code> class:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/user/viewsets.py</p>
			<pre class="source-code">
…
from core.abstract.viewsets import AbstractViewSet
from core.user.serializers import UserSerializer
from core.user.models import User
class UserViewSet(AbstractViewSet):
…</pre>
			<p>Great, now we have all the things needed to write better and less code; let’s write the <code>Post</code> model.</p>
			<h1 id="_idParaDest-59"><a id="_idTextAnchor062"/>Writing the Post model</h1>
			<p>We have already <a id="_idIndexMarker162"/>established the structure of the <code>Post</code> model. Let’s write the code and the features:</p>
			<ol>
				<li>Create a new application called <code>post</code>:<pre class="source-code">
django-admin startapp post</pre></li>
				<li>Rewrite <code>apps.py</code> of the new create package so it can be called easily in the project:</li>
			</ol>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/post/apps.py</p>
			<pre class="source-code">
from django.apps import AppConfig
class PostConfig(AppConfig):
   default_auto_field =
     'django.db.models.BigAutoField'
   name = 'core.post'
   label = "core_label"</pre>
			<ol>
				<li value="3">Once it’s done, we <a id="_idIndexMarker163"/>can now write the <code>Post</code> model. Open the <code>models.py</code> file and enter the following content:</li>
			</ol>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/post/models.py</p>
			<pre class="source-code">
from django.db import models
from core.abstract.models import AbstractModel, AbstractManager
class PostManager(AbstractManager):
   pass
class Post(AbstractModel):
   author = models.ForeignKey(to="core_user.User",
     on_delete=models.CASCADE)
   body = models.TextField()
   edited = models.BooleanField(default=False)
   objects = PostManager()
   def __str__(self):
       return f"{self.author.name}"
   class Meta:
       db_table = "'core.post'"</pre>
			<p>You can see here how we created the <code>ForeignKey</code> relationship. Django models actually provide tools to handle this kind of relationship, and it’s also symmetrical, meaning that not only can we use the <code>Post.author</code> syntax to access the user object but <a id="_idIndexMarker164"/>we can also access posts created by a user using the <code>User.post_set</code> syntax. The latter syntax will return a <code>queryset</code> object containing the posts created by the user because we are in a <code>ForeignKey</code> relationship, which is also a one-to-many relationship. You will also notice the <code>on_delete</code> attribute with the <code>models.CASCADE</code> value. Using <code>CASCADE</code>, if a user is deleted from the database, Django will also delete all records of posts in relation to this user.</p>
			<p>Apart from <code>CASCADE</code> as a value for the <code>on_delete</code> attribute on a <code>ForeignKey</code> relationship, you can also have the following:</p>
			<ul>
				<li><code>SET_NULL</code>: This will set the child object foreign key to null on delete. For example, if a user is deleted from the database, the value of the <code>author</code> field of the posts in relation to this user is set to <strong class="bold">None</strong>.</li>
				<li><code>SET_DEFAULT</code>: This will set the child object to the default value given while writing the model. It works if you are sure that the default value won’t be deleted.</li>
				<li><code>RESTRICT</code>: This raises <code>RestrictedError</code> under certain conditions.</li>
				<li><code>PROTECT</code>: This prevents the foreign key object from being deleted as long as there are objects linked to the foreign key object.</li>
			</ul>
			<p>Let’s test the newly added model by<a id="_idIndexMarker165"/> creating an object and saving it in the database:</p>
			<ol>
				<li value="4">Add the newly created application to the <code>INSTALLED_APPS</code> list:</li>
			</ol>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">CoreRoot/settings.py</p>
			<pre class="source-code">
…
'core.post'
…</pre>
			<ol>
				<li value="5">Let’s create the migrations for the newly added application:<pre class="source-code">
<strong class="bold">python manage makemigrations &amp;&amp; python manage.py migrate</strong></pre></li>
				<li>Then, let’s play <a id="_idIndexMarker166"/>with the <code>python manage.py </code><code>shell</code> command:<pre class="source-code">
<strong class="bold">(venv) koladev@koladev123xxx:~/PycharmProjects/Full-stack-Django-and-React$ python manage.py shell</strong></pre><pre class="source-code">
<strong class="bold">Python 3.10.2 (main, Jan 15 2022, 18:02:07) [GCC 9.3.0] on linux</strong></pre><pre class="source-code">
<strong class="bold">Type "help", "copyright", "credits" or "license" for more information.</strong></pre><pre class="source-code">
<strong class="bold">(InteractiveConsole)</strong></pre><pre class="source-code">
<strong class="bold">&gt;&gt;&gt;</strong></pre></li>
			</ol>
			<p class="callout-heading">Important note</p>
			<p class="callout">You can use the <strong class="bold">django_shell_plus</strong> package<a id="_idIndexMarker167"/> to speed up work with Django shell. You won’t need to type all imports yourself as all your models will be imported by default. You can find more information on how to install it from the following website: <a href="https://django-extensions.readthedocs.io/en/latest/shell_plus.html">https://django-extensions.readthedocs.io/en/latest/shell_plus.html</a>.</p>
			<ol>
				<li value="7">Let’s import a user. This <a id="_idIndexMarker168"/>will be the author of the post we’ll be creating:<pre class="source-code">
&gt;&gt;&gt; from core.post.models import Post</pre><pre class="source-code">
&gt;&gt;&gt; from core.user.models import User</pre><pre class="source-code">
&gt;&gt;&gt; user = User.objects.first()</pre><pre class="source-code">
&gt;&gt;&gt; user</pre></li>
				<li>Next, let’s create a dictionary that will contain all the fields needed to create a post:<pre class="source-code">
&gt;&gt;&gt; data = {"author": user, "body":"A simple test"}</pre></li>
				<li>And now, let’s create a post:<pre class="source-code">
&gt;&gt;&gt; post = Post.objects.create(**data)</pre><pre class="source-code">
&gt;&gt;&gt; post</pre><pre class="source-code">
&lt;Post: John Hey&gt;</pre><pre class="source-code">
&gt;&gt;&gt;</pre><pre class="source-code">
Let's access the author field of this object.</pre><pre class="source-code">
&gt;&gt;&gt; post.author</pre><pre class="source-code">
&lt;User: testuser@yopmail.com&gt;</pre></li>
			</ol>
			<p>As you can see, the author is in fact the user we’ve retrieved from the database.</p>
			<p>Let’s also try the inverse relationship:</p>
			<pre class="source-code">
&gt;&gt;&gt; user.post_set.all()
&lt;QuerySet [&lt;Post: John Hey&gt;]&gt;</pre>
			<p>As you can see, the <code>post_set</code> attribute contains all the instructions needed to interact with all the posts linked to this user.</p>
			<p>Now that you have a better understanding of how database relationships work in Django, we can move on to writing<a id="_idIndexMarker169"/> the serializer of the <code>Post</code> object.</p>
			<h1 id="_idParaDest-60"><a id="_idTextAnchor063"/>Writing the Post serializer</h1>
			<p>The <code>Post</code> serializer will contain the<a id="_idIndexMarker170"/> fields needed to create a post when making a request on the endpoint. Let’s add the feature for the post creation first.</p>
			<p>In the <code>post</code> directory, create a file called <code>serializers.py</code>. Inside this file, add the following content:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/post/serializers.py</p>
			<pre class="source-code">
from rest_framework import serializers
from rest_framework.exceptions import ValidationError
from core.abstract.serializers import AbstractSerializer
from core.post.models import Post
from core.user.models import User
class PostSerializer(AbstractSerializer):
   author = serializers.SlugRelatedField(
     queryset=User.objects.all(), slug_field='public_id')
   def validate_author(self, value):
       if self.context["request"].user != value:
           raise ValidationError("You can't create a post
                                  for another user.")
       return value
   class Meta:
       model = Post
       # List of all the fields that can be included in a
       # request or a response
       fields = ['id', 'author', 'body', 'edited',
                 'created', 'updated']
       read_only_fields = ["edited"]</pre>
			<p>We’ve added a new serializer field type, <code>SlugRelatedField</code>. As we are working with the <code>ModelSerializer</code> class, Django automatically handles the fields and relationship generation for us. Defining<a id="_idIndexMarker171"/> the type of relationship field we want to use can also be crucial to tell Django exactly what to do.</p>
			<p>And that’s where <code>SlugRelatedField</code> comes in. It is used to represent the target of the relationship using a field on the target. Thus, when creating a post, <code>public_id</code> of the author will be passed in the body of the request so that the user can be identified and linked to the post.</p>
			<p>The <code>validate_author</code> method checks validation for the <code>author</code> field. Here, we want to make sure that the user creating the post is the same user as in the <code>author</code> field. A context dictionary is available in every serializer. It usually contains the request object that we can use to make some checks.</p>
			<p>There is no hard limitation here so we can easily move to the next part of this feature: writing the <code>Post</code> viewsets.</p>
			<h1 id="_idParaDest-61"><a id="_idTextAnchor064"/>Writing Post viewsets</h1>
			<p>For the following endpoint, we’ll only<a id="_idIndexMarker172"/> be allowing the <code>POST</code> and <code>GET</code> methods. This will help us have the basic features working first.</p>
			<p>The code should follow these rules:</p>
			<ul>
				<li>Only authenticated users can create posts</li>
				<li>Only authenticated users can read posts</li>
				<li>Only <code>GET</code> and <code>POST</code> methods are allowed</li>
			</ul>
			<p>Inside the <code>post</code> directory, create <a id="_idIndexMarker173"/>a file called <code>viewsets.py</code>. Into the file, add the following content:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/post/viewsets.py</p>
			<pre class="source-code">
from rest_framework.permissions import IsAuthenticated
from core.abstract.viewsets import AbstractViewSet
from core.post.models import Post
from core.post.serializers import PostSerializer
class PostViewSet(AbstractViewSet):
   http_method_names = ('post', 'get')
   permission_classes = (IsAuthenticated,)
   serializer_class = PostSerializer
   def get_queryset(self):
       return Post.objects.all()
   def get_object(self):
       obj = Post.objects.get_object_by_public_id(
         self.kwargs['pk'])
       self.check_object_permissions(self.request, obj)
       return obj
   def create(self, request, *args, **kwargs):
       serializer = self.get_serializer(data=request.data)
       serializer.is_valid(raise_exception=True)
       self.perform_create(serializer)
       return Response(serializer.data,
                       status=status.HTTP_201_CREATED)</pre>
			<p>In the preceding code, we<a id="_idIndexMarker174"/> defined three interesting methods:</p>
			<ul>
				<li>The <code>get_queryset</code> method returns all the posts. We don’t actually have particular requirements for fetching posts, so we can return all posts in the database.</li>
				<li>The <code>get_object</code> method returns a <code>post</code> object using <code>public_id</code> that will be present in the URL. We retrieve this parameter from the <code>self.kwargs</code> directory.</li>
				<li>The <code>create</code> method, which is the <code>ViewSet</code> action executed on <code>POST</code> requests on the endpoint linked to <code>ViewSet</code>. We simply pass the data to the serializer declared on <code>ViewSet</code>, validate the data, and then call the <code>perform_create</code> method to create a <code>post</code> object. This method will automatically handle the creation of a <code>post</code> object by calling the <code>Serializer.create</code> method, which will trigger the creation of a <code>post</code> object in the database. Finally, we return a response with the newly created post.</li>
			</ul>
			<p>And right here, you have the code for <code>ViewSet</code>. The next step is to add an endpoint and start testing the API.</p>
			<h2 id="_idParaDest-62"><a id="_idTextAnchor065"/>Adding the Post route</h2>
			<p>In the <code>routers.py</code> file, add the<a id="_idIndexMarker175"/> following content:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/routers.py</p>
			<pre class="source-code">
…
from core.post.viewsets import PostViewSet
# ##################################################################### #
# ################### POST                       ###################### #
# ##################################################################### #
router.register(r'post', PostViewSet, basename='post')
…</pre>
			<p>Once it’s done, you’ll have a new endpoint available on <code>/post/</code>. Let’s play with Insomnia to test the API.</p>
			<p>First of all, try to make a request directly to the <code>/post/</code> endpoint. You’ll receive a <code>/auth/login/</code> endpoint with a registered user and copy the token.</p>
			<p>In the <strong class="bold">Bearer</strong> tab in Insomnia, select <strong class="bold">Bearer Token</strong>:</p>
			<div><div><img src="img/Figure_3.5_B18221.jpg" alt="Figure 3.5 – Adding Bearer Token to Insomnia request"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.5 – Adding Bearer Token to Insomnia request</p>
			<p>Now, fire the <a id="_idIndexMarker177"/>endpoint again with a <code>GET</code> request. You’ll see no results, great! Let’s create the first post in the database.</p>
			<p>Change the type of request to <code>POST</code> and the following to the JSON body:</p>
			<pre class="source-code">
{
    "author": "19a2316e94e64c43850255e9b62f2056",
    "body": "A simple posted"
}</pre>
			<p>Please note that we will have a different <code>public_id</code> so make sure to use <code>public_id</code> of the user you’ve just logged in as and send the request again:</p>
			<div><div><img src="img/Figure_3.6_B18221.jpg" alt="Figure 3.6 – Creating a post"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.6 – Creating a post</p>
			<p>Great, the post is <a id="_idIndexMarker178"/>created! Let’s see whether it’s available when making a <code>GET</code> request:</p>
			<div><div><img src="img/Figure_3.7_B18221.jpg" alt="Figure 3.7 – Getting all posts"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.7 – Getting all posts</p>
			<p>The DRF provides a way to paginate responses and a default pagination limit size globally in the <code>settings.py</code> file. With time, a lot of objects will be shown and the size of the payload will vary.</p>
			<p>To prevent this, let’s add a default size and a class to paginate our results.</p>
			<p>Inside the <code>settings.py</code> file of <a id="_idIndexMarker179"/>the project, add new settings to the <code>REST_FRAMEWORK</code> dictionary:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">CoreRoot/settings.py</p>
			<pre class="source-code">
REST_FRAMEWORK = {
…
   'DEFAULT_PAGINATION_CLASS':
     'rest_framework.pagination.LimitOffsetPagination',
   'PAGE_SIZE': 15,
}
…</pre>
			<p>Basically here, all results are limited to 15 per page but we can also increase this size with the <code>limit</code> parameter when making a request and also use the <code>offset</code> parameter to precisely where we want the result to start from:</p>
			<pre class="source-code">
GET https://api.example.org/accounts/?limit=100&amp;offset=400</pre>
			<p>Great, now make a <code>GET</code> request again and you’ll see that the results are better structured.</p>
			<p>Also, it’ll be more practical to have the name of the author in the response as well. Let’s rewrite a serializer method that can help modify the response object.</p>
			<h2 id="_idParaDest-63"><a id="_idTextAnchor066"/>Rewriting the Post serialized object</h2>
			<p>Actually, the <code>author</code> field <a id="_idIndexMarker180"/>accepts <code>public_id</code> and returns <code>public_id</code>. While it does the work, it can be a little bit difficult to identify the user. This will cause it to make a request again with <code>public_id</code> of the user to get the pieces of information about the user.</p>
			<p>The <code>to_representation()</code> method takes the object instance that requires serialization and returns a primitive representation. This usually means returning a structure of built-in Python data types. The exact types that can be handled depend on the render classes you configure<a id="_idIndexMarker181"/> for your API.</p>
			<p>Inside <code>post/serializers.py</code>, add a new method called <code>to_represenation()</code>:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/post/serializers.py</p>
			<pre class="source-code">
class PostSerializer(AbstractSerializer):
   …
   def to_representation(self, instance):
       rep = super().to_representation(instance)
       author = User.objects.get_object_by_public_id(
         rep["author"])
       rep["author"] = UserSerializer(author).data
       return rep
…</pre>
			<p>As you can see, we are using the <code>public_id</code> field to retrieve the user and then serialize the <code>User</code> object with <code>UserSerializer</code>.</p>
			<p>Let’s get all the posts again and you’ll see all the users:</p>
			<div><div><img src="img/Figure_3.8_B18221.jpg" alt="Figure 3.8 – Getting all posts"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.8 – Getting all posts</p>
			<p>We have a working <code>Post</code> feature but it also has some issues. Let’s explore this further when writing permissions for <a id="_idIndexMarker182"/>our feature.</p>
			<h1 id="_idParaDest-64"><a id="_idTextAnchor067"/>Adding permissions</h1>
			<p>If authentication is the action of<a id="_idIndexMarker183"/> verifying the identity of a user, authorization is simply the action of checking whether the user has the rights or privileges to perform an action.</p>
			<p>In our project, we have three types of users:</p>
			<ul>
				<li><strong class="bold">The anonymous user</strong>: This user <a id="_idIndexMarker184"/>has no account on the API and can’t really be identified</li>
				<li><strong class="bold">The registered and active user</strong>: This user<a id="_idIndexMarker185"/> has an account on the API and can easily perform some actions</li>
				<li><strong class="bold">The admin user</strong>: This user has<a id="_idIndexMarker186"/> all rights and privileges</li>
			</ul>
			<p>We want anonymous users to be able to read the posts on the API without necessarily being authenticated. While it’s true that there is the <code>AllowAny</code> permission, it’ll surely conflict with the <code>IsAuthenticated</code> permission.</p>
			<p>Thus, we need to write a custom <a id="_idIndexMarker187"/>permission.</p>
			<p>Inside the <code>authentication</code> directory, create a file called <code>permissions</code>, and add the following content:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/post/viewsets.py</p>
			<pre class="source-code">
from rest_framework.permissions import BasePermission, SAFE_METHODS
class UserPermission(BasePermission):
   def has_object_permission(self, request, view, obj):
       if request.user.is_anonymous:
           return request.method in SAFE_METHODS
       if view.basename in ["post"]:
           return bool(request.user and
                       request.user.is_authenticated)
    return False
   def has_permission(self, request, view):
       if view.basename in ["post"]:
           if request.user.is_anonymous:
               return request.method in SAFE_METHODS
           return bool(request.user and
                       request.user.is_authenticated)
       return False</pre>
			<p>Django permissions usually work on two levels: on the overall endpoint (<code>has_permission</code>) and on an object level (<code>has_object_permission</code>).</p>
			<p>A great way to write permissions is to always deny by default; that is why we always return <code>False</code> at the end of each permission method. And then you can start adding the conditions. Here, in all the methods, we are checking that anonymous users can only make the <code>SAFE_METHODS</code> requests — <code>GET</code>, <code>OPTIONS</code>, and <code>HEAD</code>.</p>
			<p>And for other users, we are making<a id="_idIndexMarker188"/> sure that they are always authenticated before continuing. Another important feature is to allow users to delete or update posts. Let’s see how we can add this with Django.</p>
			<h1 id="_idParaDest-65"><a id="_idTextAnchor068"/>Deleting and updating posts</h1>
			<p>Deleting and updating articles are<a id="_idIndexMarker189"/> also part of the features of posts. To add these functionalities, we don’t need to write a serializer or a viewset, as the methods for deletion (<code>destroy()</code>), and <a id="_idIndexMarker190"/>updating (<code>update()</code>) are already available by default in the <code>ViewSet</code> class. We will just rewrite the <code>update</code> method on <code>PostSerializer</code> to ensure that the <code>edited</code> field is set to <code>True</code> when modifying a post.</p>
			<p>Let’s add the <code>PUT</code> and <code>DELETE</code> methods to <code>http_methods</code> of <code>PostViewSet</code>:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/post/viewsets.py</p>
			<pre class="source-code">
…
class PostViewSet(AbstractViewSet):
   http_method_names = ('post', 'get', 'put', 'delete')
…</pre>
			<p>Before going in, let’s rewrite the <code>update</code> method in <code>PostSerializer</code>. We actually have a field called <code>edited</code> in the <code>Post</code> model. This field will tell us whether the post has been edited:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/post/serializers.py</p>
			<pre class="source-code">
…
class PostSerializer(AbstractSerializer):
…
   def update(self, instance, validated_data):
       if not instance.edited:
           validated_data['edited'] = True
       instance = super().update(instance, validated_data)
       return instance
…</pre>
			<p>And let’s try the <code>PUT</code> and <code>DELETE</code> requests in Insomnia. Here’s an example of the body for the <code>PUT</code> request:</p>
			<pre class="source-code">
{
    "author": "61c5a1ecb9f5439b810224d2af148a23",
    "body": "A simple post edited"
}</pre>
			<div><div><img src="img/Figure_3.9_B18221.jpg" alt="Figure 3.9 – Modifying a post"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.9 – Modifying a post</p>
			<p>As you can see, the <code>edited</code> field in the<a id="_idIndexMarker191"/> response is set to <code>true</code>.</p>
			<p>Let’s try to delete the post <a id="_idIndexMarker192"/>and see whether it works:</p>
			<div><div><img src="img/Figure_3.10_B18221.jpg" alt="Figure 3.10 – Deleting a post"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.10 – Deleting a post</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">There is a way to delete records without necessarily deleting them from the database. It’s usually called a soft delete. The record just won’t be accessible to the user, but it will always be present in the database. You can learn more about this at <a href="https://dev.to/bikramjeetsingh/soft-deletes-in-django-a9j">https://dev.to/bikramjeetsingh/soft-deletes-in-django-a9j</a>.</p>
			<h1 id="_idParaDest-66"><a id="_idTextAnchor069"/>Adding the Like feature</h1>
			<p>A nice feature to have<a id="_idIndexMarker193"/> in a social media application is favoriting. Like Facebook, Instagram, or Twitter, we’ll allow users here to like a post.</p>
			<p>Plus, we’ll also add data to count the number of likes a post has received and check whether a current user making the request has liked a post.</p>
			<p>We’ll do this in four steps:</p>
			<ol>
				<li value="10">Add a new <code>posts_liked</code> field to the <code>User</code> model.</li>
				<li>Write methods on the <code>User</code> model to like and remove a like from a post. We’ll also add a method to check whether the user has liked a post.</li>
				<li>Add <code>likes_count</code> and <code>has_liked</code> to <code>PostSerializer</code>.</li>
				<li>Add endpoints to like and dislike a post.</li>
			</ol>
			<p>Great! Let’s start by adding the new fields to the <code>User</code> model.</p>
			<h2 id="_idParaDest-67"><a id="_idTextAnchor070"/>Adding the posts_liked field to the User model</h2>
			<p>The <code>posts_liked</code> field will contain all the posts liked by a user. The relationship between the <code>User</code> model and the <code>Post</code> model concerning the Like feature can be described as follows:</p>
			<ul>
				<li>A user can like many posts</li>
				<li>A post can be liked by many users</li>
			</ul>
			<p>This kind of relationship sounds familiar? It is a <em class="italic">many-to-many</em> relationship.</p>
			<p>Following this change, here’s the updated structure of the table – we are also anticipating the methods <a id="_idIndexMarker194"/>we’ll add to the model:</p>
			<div><div><img src="img/Figure_3.11_B18221.jpg" alt="Figure 3.11 – New User table structure"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.11 – New User table structure</p>
			<p>Great! Let’s add the <code>posts_liked</code> field to the <code>User</code> model. Open the <code>/core/user/models.py</code> file and add a new field to the <code>User</code> model:</p>
			<pre class="source-code">
class User(AbstractModel, AbstractBaseUser, PermissionsMixin):
...
   posts_liked = models.ManyToManyField(
       "core_post.Post",
       related_name="liked_by"
   )
...</pre>
			<p>After that, run the following commands to create a new migrations file and apply this migration to the <a id="_idIndexMarker195"/>database:</p>
			<pre class="console">
python manage.py makemigrations
python manage.py migrate</pre>
			<p>The next step is to add the new methods shown in <em class="italic">Figure 3</em><em class="italic">.11</em> to the <code>User</code> model.</p>
			<h2 id="_idParaDest-68"><a id="_idTextAnchor071"/>Adding the like, remove_like, and has_liked methods</h2>
			<p>Before writing these methods, let’s describe the purpose of each new method:</p>
			<ul>
				<li>The <code>like()</code> method: This is used for liking a post if it hasn’t been done yet. For this, we’ll use the <code>add()</code> method from the models. We’ll use <code>ManyToManyField</code> to link a post to a user.</li>
				<li>The <code>remove_like()</code> method: This is <a id="_idIndexMarker196"/>used for removing a like from a post. For this, we’ll use the <code>remove</code> method from the models. We’ll use <code>ManyToManyField</code> to unlink a post from a user.</li>
				<li>The <code>has_liked()</code> method: This is used for<a id="_idIndexMarker197"/> returning <code>True</code> if the user has liked a post, else <code>False</code>.</li>
			</ul>
			<p>Let’s move on to the coding:</p>
			<pre class="source-code">
class User(AbstractModel, AbstractBaseUser, PermissionsMixin):
   ...
   def like(self, post):
       """Like `post` if it hasn't been done yet"""
       return self.posts_liked.add(post)
   def remove_like(self, post):
       """Remove a like from a `post`"""
       return self.posts_liked.remove(post)
   def has_liked(self, post):
       """Return True if the user has liked a `post`; else
          False"""
       return self.posts_liked.filter(pk=post.pk).exists()</pre>
			<p>Great! Next, let’s <a id="_idIndexMarker198"/>add the <code>likes_count</code> and <code>has_liked</code> fields <a id="_idIndexMarker199"/>to <code>PostSerializer</code>.</p>
			<h2 id="_idParaDest-69"><a id="_idTextAnchor072"/>Adding the likes_count and has_liked fields to PostSerializer</h2>
			<p>Instead of adding<a id="_idIndexMarker200"/> fields such as <code>likes_count</code> in the <code>Post</code> model and generating more fields in the database, we can directly manage it on <code>PostSerializer</code>. The <code>Serializer</code> class in Django <a id="_idIndexMarker201"/>provides ways to create the <code>write_only</code> values that <a id="_idIndexMarker202"/>will be sent<a id="_idIndexMarker203"/> on the response.</p>
			<p>Inside the <code>core/post/serializers.py</code> file, add new fields to <code>PostSerializer</code>:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Core/post/serializers.py</p>
			<pre class="source-code">
...
class PostSerializer(AbstractSerializer):
   ...
   liked = serializers.SerializerMethodField()
   likes_count = serializers.SerializerMethodField()
   def get_liked(self, instance):
       request = self.context.get('request', None)
       if request is None or request.user.is_anonymous:
           return False
       return request.user.has_liked(instance)
   def get_likes_count(self, instance):
       return instance.liked_by.count()
   class Meta:
       model = Post
       # List of all the fields that can be included in a
       # request or a response
       fields = ['id', 'author', 'body', 'edited', 'liked',
                 'likes_count', 'created', 'updated']
       read_only_fields = ["edited"]</pre>
			<p>In the <a id="_idIndexMarker204"/>preceding code, we <a id="_idIndexMarker205"/>are using the <code>serializers.SerializerMethodField()</code> field, which allows us to write a custom function that will return a value we want to attribute to this field. The syntax of the method will be <code>get_field</code>, where <code>field</code> is the name of the field declared on the serializer.</p>
			<p>That is why for <code>liked</code>, we have<a id="_idIndexMarker206"/> the <code>get_liked</code> method, and for <code>likes_count</code>, we have the <code>get_likes_count</code> method.</p>
			<p>With the new fields on <code>PostSerializer</code>, we can now add the endpoints needed to <code>PostViewSet</code> to like or <a id="_idIndexMarker207"/>dislike an article.</p>
			<h2 id="_idParaDest-70"><a id="_idTextAnchor073"/>Adding like and dislike actions to PostViewSet</h2>
			<p>DRF provides a decorator called <code>action</code>. This decorator helps make methods on a <code>ViewSet</code> class routable. The <code>action</code> decorator<a id="_idIndexMarker208"/> takes two arguments:</p>
			<ul>
				<li><code>detail</code>: If this argument is set to <code>True</code>, the route to this action will require a resource lookup field; in most cases, this will be the ID of the resource</li>
				<li><code>methods</code>: This is a list of the methods accepted by the action</li>
			</ul>
			<p>Let’s write the actions on <code>PostViewSets</code>:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/post/viewsets.py</p>
			<pre class="source-code">
 ...
class PostViewSet(AbstractViewSet):
   ...
   @action(methods=['post'], detail=True)
   def like(self, request, *args, **kwargs):
       post = self.get_object()
       user = self.request.user
       user.like(post)
       serializer = self.serializer_class(post)
       return Response(serializer.data,
                       status=status.HTTP_200_OK)
   @action(methods=['post'], detail=True)
   def remove_like(self, request, *args, **kwargs):
       post = self.get_object()
       user = self.request.user
       user.remove_like(post)
       serializer = self.serializer_class(post)
       return Response(serializer.data,
                       status=status.HTTP_200_OK)</pre>
			<p>For each action added, we<a id="_idIndexMarker209"/> are writing the logic following these steps:</p>
			<ol>
				<li value="1">First, we retrieve the concerned post on which we want to call the like or remove the like action. The <code>self.get_object()</code> method will automatically return the concerned post using the ID passed to the URL request, thanks to the <code>detail</code> attribute being set to <code>True</code>.</li>
				<li>Second, we also retrieve the user making the request from the <code>self.request</code> object. This is done so that we can call the <code>remove_like</code> or <code>like</code> method added to the <code>User</code> model.</li>
				<li>And finally, we serialize the post using the <code>Serializer</code> class defined on <code>self.serializer_class</code> and we return a response.</li>
			</ol>
			<p>With this added to <code>PostViewSets</code>, the Django Rest Framework routers will automatically create new routes for this resource, and then, you can do the following:</p>
			<ol>
				<li value="1">Like a post with the<a id="_idIndexMarker210"/> following endpoint: <code>api/post/post_pk/like/</code>.</li>
				<li>Remove the like from a post with the following endpoint: <code>api/post/post_pk/remove_like/</code>.</li>
			</ol>
			<p>Great, the feature is working like a charm. In the next chapter, we’ll be adding the <em class="italic">comments</em> feature to the project.</p>
			<h1 id="_idParaDest-71"><a id="_idTextAnchor074"/>Summary</h1>
			<p>In this chapter, we’ve learned how to use database relationships and write permissions. We also learned how to surcharge updates and create methods on viewsets and serializers.</p>
			<p>We performed quick refactoring on our code by creating an <code>Abstract</code> class to follow the <em class="italic">DRY</em> rule. In the next chapter, we’ll be adding the Comments feature on the posts. Users will be able to create comments under posts as well as delete and update them.</p>
			<h1 id="_idParaDest-72"><a id="_idTextAnchor075"/>Questions</h1>
			<ol>
				<li value="1">What are some database relationships?</li>
				<li>What are Django permissions?</li>
				<li>How do you paginate the results of an API response?</li>
				<li>How do you use Django shell?</li>
			</ol>
		</div>
		<div><div></div>
		</div>
	</body></html>