<html><head></head><body>
		<div id="_idContainer035">
			<h1 id="_idParaDest-51" class="chapter-number"><a id="_idTextAnchor054"/>3</h1>
			<h1 id="_idParaDest-52"><a id="_idTextAnchor055"/>Social Media Post Management</h1>
			<p>In the previous chapter, we introduced models, serializers, viewsets, and routes to create our first endpoints. In this chapter, we will be working with the same concepts for creating posts for our social media project. This will be done by dividing the project into concepts such as database relations, filtering, and permissions. By the end of this chapter, you’ll be able to work with database relations with Django models, write custom filters and permissions, and delete and <span class="No-Break">update objects.</span></p>
			<p>We will be covering the following topics in <span class="No-Break">this chapter:</span></p>
			<ul>
				<li>Creating the <span class="No-Break">Post model</span></li>
				<li>Writing the <span class="No-Break">Post model</span></li>
				<li>Writing the <span class="No-Break">Post serializer</span></li>
				<li>Writing <span class="No-Break">Post viewsets</span></li>
				<li><span class="No-Break">Adding permissions</span></li>
				<li>Deleting and <span class="No-Break">updating posts</span></li>
				<li>Adding the <span class="No-Break">Like feature</span></li>
			</ul>
			<h1 id="_idParaDest-53"><a id="_idTextAnchor056"/>Technical requirements</h1>
			<p>For this chapter, you need to have Insomnia installed on your machine to make <span class="No-Break">HTTP requests.</span></p>
			<p>You can find the code for this chapter <span class="No-Break">here: </span><a href="https://github.com/PacktPublishing/Full-stack-Django-and-React/tree/chap3"><span class="No-Break">https://github.com/PacktPublishing/Full-stack-Django-and-React/tree/chap3</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-54"><a id="_idTextAnchor057"/>Creating the Post model</h1>
			<p>A post in this project is a long or short piece of text that can be viewed by anyone, irrespective of whether a<a id="_idIndexMarker145"/> user is linked or associated to that post. Here are the requirements for the <span class="No-Break">post feature:</span></p>
			<ul>
				<li>Authenticated users should be able to create <span class="No-Break">a post</span></li>
				<li>Authenticated users should be able to like <span class="No-Break">the post</span></li>
				<li>All users should be able to read the post, even if they <span class="No-Break">aren’t authenticated</span></li>
				<li>The author of the post should be able to modify <span class="No-Break">the post</span></li>
				<li>The author of the post should be able to delete <span class="No-Break">the post</span></li>
			</ul>
			<p>Looking at these requirements from a backend perspective, we can understand that we’ll be dealing with a database, a model, and permissions. First, let’s start by writing the structure of the <strong class="source-inline">Post</strong> model in <span class="No-Break">the database.</span></p>
			<h2 id="_idParaDest-55"><a id="_idTextAnchor058"/>Designing the Post model</h2>
			<p>A post consists of content <a id="_idIndexMarker146"/>made up of characters written by an author (here, a user). How does that schematize itself into <span class="No-Break">our database?</span></p>
			<p>Before creating the <strong class="source-inline">Post</strong> model, let’s draw a quick figure of the structure of the model in <span class="No-Break">the database:</span></p>
			<div>
				<div id="_idContainer024" class="IMG---Figure">
					<img src="image/Figure_3.1_B18221.jpg" alt="Figure 3.1 – Post table"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1 – Post table</p>
			<p>As you can see in <span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.1</em>, there is an <strong class="source-inline">author</strong> field, which is a <strong class="bold">foreign key</strong>. A foreign key is a set of attributes in a table that<a id="_idIndexMarker147"/> refers to the primary key of another table. In our case, the foreign key will refer to the primary key of the <strong class="source-inline">User</strong> table. Each time a post is created, a foreign<a id="_idIndexMarker148"/> key will need to <span class="No-Break">be passed.</span></p>
			<p>The foreign key is one of the characteristics of the <strong class="bold">one-to-many</strong> (or <strong class="bold">many-to-one</strong>) relationship. In this relationship, a row in table A can have many matching rows in table B (<em class="italic">one-to-many</em>) but a row in table B can only have one matching row in <span class="No-Break">table A.</span></p>
			<p>In our case, a user (from the <strong class="source-inline">User</strong> table) can have many posts (in the <strong class="source-inline">Post</strong> table) but a post can only have one user (<span class="No-Break"><em class="italic">Figure 3</em></span><span class="No-Break"><em class="italic">.2</em></span><span class="No-Break">):</span></p>
			<div>
				<div id="_idContainer025" class="IMG---Figure">
					<img src="image/Figure_3.2_B18221.jpg" alt="Figure 3.2 – User and Post relationship"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.2 – User and Post relationship</p>
			<p>There are also two other types of <span class="No-Break">database relationships:</span></p>
			<ul>
				<li>One-to-one: In this type of relationship, a row in table A can only have one matching row in table B, and vice versa. An example of this can be worker C having one and only one desk D. And this desk D can <a id="_idIndexMarker149"/>only be used by this worker C (<span class="No-Break"><em class="italic">Figure 3</em></span><span class="No-Break"><em class="italic">.3</em></span><span class="No-Break">):</span></li>
			</ul>
			<div>
				<div id="_idContainer026" class="IMG---Figure">
					<img src="image/Figure_3.3_B18221.jpg" alt="Figure 3.3 – One-to-one relationship between a worker and a desk"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.3 – One-to-one relationship between a worker and a desk</p>
			<ul>
				<li>Many-to-many: In this type of database relationship, a row in table A can have many matching rows in table B, and vice versa. For example, in an e-commerce application, an order can have many items, and an item can also appear in many different orders (<span class="No-Break"><em class="italic">Figure 3</em></span><span class="No-Break"><em class="italic">.4</em></span><span class="No-Break">):</span></li>
			</ul>
			<div>
				<div id="_idContainer027" class="IMG---Figure">
					<img src="image/Figure_3.4_B18221.jpg" alt="Figure 3.4 – Many-to-many relationship between an order and an item"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.4 – Many-to-many relationship between an order and an item</p>
			<p>The <em class="italic">many-to-many</em> relationship will be used when writing the <em class="italic">like</em> feature for <span class="No-Break">the posts.</span></p>
			<p>Great, now that we have a better idea of database relationships, we can begin to write the post feature, starting from the <strong class="source-inline">Post</strong> model. But before that, let’s quickly refactor the code to make <span class="No-Break">development easier.</span></p>
			<h2 id="_idParaDest-56"><a id="_idTextAnchor059"/>Abstraction</h2>
			<p>The next models that we’ll create will also have the <strong class="source-inline">public_id</strong>, <strong class="source-inline">created</strong>, and <strong class="source-inline">updated</strong> fields. For the <a id="_idIndexMarker150"/>sake of the <strong class="bold">don’t repeat yourself</strong> (<strong class="bold">DRY</strong>) principle, we will <a id="_idIndexMarker151"/>use abstract <span class="No-Break">model classes.</span></p>
			<p>An <strong class="bold">abstract class</strong> can be considered a <a id="_idIndexMarker152"/>blueprint for other classes. It usually contains a set of methods or attributes that must be created within any child classes built from the <span class="No-Break">abstract class.</span></p>
			<p>Inside the <strong class="source-inline">core</strong> directory, create a new Python package called <strong class="source-inline">abstract</strong>. Once it’s done, create a <strong class="source-inline">models.py</strong> file. In this file, we will write two classes: <strong class="source-inline">AbstractModel</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">AbstractManager</strong></span><span class="No-Break">.</span></p>
			<p>The <strong class="source-inline">AbstractModel</strong> class will contain fields such as <strong class="source-inline">public_id</strong>, <strong class="source-inline">created</strong>, and <strong class="source-inline">updated</strong>. On the other side, the <strong class="source-inline">AbstractManager</strong> class will contain the function used to retrieve an object by its <span class="No-Break"><strong class="source-inline">public_id</strong></span><span class="No-Break"> field:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/abstract/models.py</p>
			<pre class="source-code">
from django.db import models
import uuid
from django.core.exceptions import ObjectDoesNotExist
from django.http import Http404
class AbstractManager(models.Manager):
   def get_object_by_public_id(self, public_id):
       try:
           instance = self.get(public_id=public_id)
           return instance
       except (ObjectDoesNotExist, ValueError, TypeError):
           return Http404
class AbstractModel(models.Model):
   public_id = models.UUIDField(db_index=True, unique=True,
     default=uuid.uuid4, editable=False)
   created = models.DateTimeField(auto_now_add=True)
   updated = models.DateTimeField(auto_now=True)
   objects = AbstractManager()
   class Meta:
       abstract = True</pre>
			<p>As you can see in the <strong class="source-inline">Meta</strong> class for <strong class="source-inline">AbstractModel</strong>, the <strong class="source-inline">abstract</strong> attribute is set to <strong class="source-inline">True</strong>. Django will ignore this class model and won’t generate migrations<a id="_idIndexMarker153"/> <span class="No-Break">for this.</span></p>
			<p>Now that we have this class, let’s make a quick refactor on the <span class="No-Break"><strong class="source-inline">User</strong></span><span class="No-Break"> model:</span></p>
			<p>First, let’s remove the <strong class="source-inline">get_object_by_public_id</strong> method to retrieve an object via <strong class="source-inline">public_id</strong>, and let’s <span class="No-Break">subclass </span><span class="No-Break"><strong class="source-inline">UserManager</strong></span><span class="No-Break">:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/user/models.py</p>
			<pre class="source-code">
…
from core.abstract.models import AbstractModel, AbstractManager
class UserManager(BaseUserManager, AbstractManager):
…
class User(AbstractModel, AbstractBaseUser, PermissionsMixin):
…</pre>
			<p>On the <strong class="source-inline">User</strong> model, remove the <strong class="source-inline">public_id</strong>, <strong class="source-inline">updated</strong>, and <strong class="source-inline">created</strong> fields, and also, subclass the <strong class="source-inline">User</strong> model with the <strong class="source-inline">AbstractModel</strong> class. This will normally cause no changes to the <a id="_idIndexMarker154"/>database, hence, there is no need to run <strong class="source-inline">makemigrations</strong> again unless you’ve changed an attribute of <span class="No-Break">a field.</span></p>
			<p>Let’s also add <strong class="source-inline">AbstractSerializer</strong>, which will be used by all the serializers we’ll be creating on <span class="No-Break">this project.</span></p>
			<h2 id="_idParaDest-57"><a id="_idTextAnchor060"/>Writing the AbstractSerializer</h2>
			<p>All the objects sent back as <a id="_idIndexMarker155"/>a response in our API will contain the <strong class="source-inline">id</strong>, <strong class="source-inline">created</strong>, and <strong class="source-inline">updated</strong> fields. It’ll be repetitive to write these fields all over again on every <strong class="source-inline">ModelSerializer</strong>, so let’s just create an <strong class="source-inline">AbstractSerializer</strong> class. In the <strong class="source-inline">abstract</strong> directory, create a file called <strong class="source-inline">serializers.py</strong> and add the<a id="_idIndexMarker156"/> <span class="No-Break">following content:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/abstract/serializers.py</p>
			<pre class="source-code">
from rest_framework import serializers
class AbstractSerializer(serializers.ModelSerializer):
   id = serializers.UUIDField(source='public_id',
                              read_only=True, format='hex')
   created = serializers.DateTimeField(read_only=True)
   updated = serializers.DateTimeField(read_only=True)</pre>
			<p>Once it’s done, you can go and subclass the <strong class="source-inline">UserSerializer</strong> class with the <span class="No-Break"><strong class="source-inline">AbstractSerializer</strong></span><span class="No-Break"> class:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/user/serializers.py</p>
			<pre class="source-code">
from core.abstract.serializers import AbstractSerializer
from core.user.models import User
class UserSerializer(AbstractSerializer):
…</pre>
			<p>Once it’s done, remove<a id="_idIndexMarker157"/> the field declaration of <strong class="source-inline">id</strong>, <strong class="source-inline">created</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">updated</strong></span><span class="No-Break">.</span></p>
			<p>Let’s perform one last <a id="_idIndexMarker158"/>abstraction <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">ViewSets</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-58"><a id="_idTextAnchor061"/>Writing the AbstractViewSet</h2>
			<p>But why write an abstract <strong class="source-inline">ViewSet</strong>? Well, there <a id="_idIndexMarker159"/>will be repeated declarations as to the ordering and the filtering. Let’s create a class that will contain the <span class="No-Break">default values.</span></p>
			<p>In the <strong class="source-inline">abstract</strong> directory, create a file called <strong class="source-inline">viewsets.py</strong> and add the <span class="No-Break">following content:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/abstract/viewsets.py</p>
			<pre class="source-code">
from rest_framework import viewsets
from rest_framework import filters
class AbstractViewSet(viewsets.ModelViewSet):
   filter_backends = [filters.OrderingFilter]
   ordering_fields = ['updated', 'created']
   ordering = ['-updated']</pre>
			<p>As you can see, we have the <span class="No-Break">following attributes:</span></p>
			<ul>
				<li><strong class="source-inline">filter_backends</strong>: This sets the default <span class="No-Break">filter backend.</span></li>
				<li><strong class="source-inline">ordering_fields</strong>: This list contains the fields that can be used as ordering parameters when making <span class="No-Break">a request.</span></li>
				<li><strong class="source-inline">ordering</strong>: This will tell Django REST in which order to send many objects as a response. In this case, all the responses will be ordered by the most <span class="No-Break">recently updated.</span></li>
			</ul>
			<p>The next step is to add the <strong class="source-inline">AbstractViewSet</strong> class to the code where <strong class="source-inline">ModelViewSets</strong> is actually<a id="_idIndexMarker160"/> called. Go to <strong class="source-inline">core/user/viewsets.py</strong> and <a id="_idIndexMarker161"/>subclass <strong class="source-inline">UserViewSet</strong> with the <span class="No-Break"><strong class="source-inline">AbstractViewSet</strong></span><span class="No-Break"> class:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/user/viewsets.py</p>
			<pre class="source-code">
…
from core.abstract.viewsets import AbstractViewSet
from core.user.serializers import UserSerializer
from core.user.models import User
class UserViewSet(AbstractViewSet):
…</pre>
			<p>Great, now we have all the things needed to write better and less code; let’s write the <span class="No-Break"><strong class="source-inline">Post</strong></span><span class="No-Break"> model.</span></p>
			<h1 id="_idParaDest-59"><a id="_idTextAnchor062"/>Writing the Post model</h1>
			<p>We have already <a id="_idIndexMarker162"/>established the structure of the <strong class="source-inline">Post</strong> model. Let’s write the code and <span class="No-Break">the features:</span></p>
			<ol>
				<li>Create a new application <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">post</strong></span><span class="No-Break">:</span><pre class="source-code">
django-admin startapp post</pre></li>
				<li>Rewrite <strong class="source-inline">apps.py</strong> of the new create package so it can be called easily in <span class="No-Break">the project:</span></li>
			</ol>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/post/apps.py</p>
			<pre class="source-code">
from django.apps import AppConfig
class PostConfig(AppConfig):
   default_auto_field =
     'django.db.models.BigAutoField'
   name = 'core.post'
   label = "core_label"</pre>
			<ol>
				<li value="3">Once it’s done, we <a id="_idIndexMarker163"/>can now write the <strong class="source-inline">Post</strong> model. Open the <strong class="source-inline">models.py</strong> file and enter the <span class="No-Break">following content:</span></li>
			</ol>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/post/models.py</p>
			<pre class="source-code">
from django.db import models
from core.abstract.models import AbstractModel, AbstractManager
class PostManager(AbstractManager):
   pass
class Post(AbstractModel):
   author = models.ForeignKey(to="core_user.User",
     on_delete=models.CASCADE)
   body = models.TextField()
   edited = models.BooleanField(default=False)
   objects = PostManager()
   def __str__(self):
       return f"{self.author.name}"
   class Meta:
       db_table = "'core.post'"</pre>
			<p>You can see here how we created the <strong class="source-inline">ForeignKey</strong> relationship. Django models actually provide tools to handle this kind of relationship, and it’s also symmetrical, meaning that not only can we use the <strong class="source-inline">Post.author</strong> syntax to access the user object but <a id="_idIndexMarker164"/>we can also access posts created by a user using the <strong class="source-inline">User.post_set</strong> syntax. The latter syntax will return a <strong class="source-inline">queryset</strong> object containing the posts created by the user because we are in a <strong class="source-inline">ForeignKey</strong> relationship, which is also a one-to-many relationship. You will also notice the <strong class="source-inline">on_delete</strong> attribute with the <strong class="source-inline">models.CASCADE</strong> value. Using <strong class="source-inline">CASCADE</strong>, if a user is deleted from the database, Django will also delete all records of posts in relation to <span class="No-Break">this user.</span></p>
			<p>Apart from <strong class="source-inline">CASCADE</strong> as a value for the <strong class="source-inline">on_delete</strong> attribute on a <strong class="source-inline">ForeignKey</strong> relationship, you can also have <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="source-inline">SET_NULL</strong>: This will set the child object foreign key to null on delete. For example, if a user is deleted from the database, the value of the <strong class="source-inline">author</strong> field of the posts in relation to this user is set <span class="No-Break">to </span><span class="No-Break"><strong class="bold">None</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">SET_DEFAULT</strong>: This will set the child object to the default value given while writing the model. It works if you are sure that the default value won’t <span class="No-Break">be deleted.</span></li>
				<li><strong class="source-inline">RESTRICT</strong>: This raises <strong class="source-inline">RestrictedError</strong> under <span class="No-Break">certain conditions.</span></li>
				<li><strong class="source-inline">PROTECT</strong>: This prevents the foreign key object from being deleted as long as there are objects linked to the foreign <span class="No-Break">key object.</span></li>
			</ul>
			<p>Let’s test the newly added model by<a id="_idIndexMarker165"/> creating an object and saving it in <span class="No-Break">the database:</span></p>
			<ol>
				<li value="4">Add the newly created application to the <span class="No-Break"><strong class="source-inline">INSTALLED_APPS</strong></span><span class="No-Break"> list:</span></li>
			</ol>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">CoreRoot/settings.py</p>
			<pre class="source-code">
…
'core.post'
…</pre>
			<ol>
				<li value="5">Let’s create the migrations for the newly <span class="No-Break">added application:</span><pre class="source-code">
<strong class="bold">python manage makemigrations &amp;&amp; python manage.py migrate</strong></pre></li>
				<li>Then, let’s play <a id="_idIndexMarker166"/>with the <strong class="bold">Django shell</strong> by starting it with the <strong class="source-inline">python manage.py </strong><span class="No-Break"><strong class="source-inline">shell</strong></span><span class="No-Break"> command:</span><pre class="source-code">
<strong class="bold">(venv) koladev@koladev123xxx:~/PycharmProjects/Full-stack-Django-and-React$ python manage.py shell</strong></pre><pre class="source-code">
<strong class="bold">Python 3.10.2 (main, Jan 15 2022, 18:02:07) [GCC 9.3.0] on linux</strong></pre><pre class="source-code">
<strong class="bold">Type "help", "copyright", "credits" or "license" for more information.</strong></pre><pre class="source-code">
<strong class="bold">(InteractiveConsole)</strong></pre><pre class="source-code">
<strong class="bold">&gt;&gt;&gt;</strong></pre></li>
			</ol>
			<p class="callout-heading">Important note</p>
			<p class="callout">You can use the <strong class="bold">django_shell_plus</strong> package<a id="_idIndexMarker167"/> to speed up work with Django shell. You won’t need to type all imports yourself as all your models will be imported by default. You can find more information on how to install it from the following <span class="No-Break">website: </span><a href="https://django-extensions.readthedocs.io/en/latest/shell_plus.html"><span class="No-Break">https://django-extensions.readthedocs.io/en/latest/shell_plus.html</span></a><span class="No-Break">.</span></p>
			<ol>
				<li value="7">Let’s import a user. This <a id="_idIndexMarker168"/>will be the author of the post we’ll <span class="No-Break">be creating:</span><pre class="source-code">
&gt;&gt;&gt; from core.post.models import Post</pre><pre class="source-code">
&gt;&gt;&gt; from core.user.models import User</pre><pre class="source-code">
&gt;&gt;&gt; user = User.objects.first()</pre><pre class="source-code">
&gt;&gt;&gt; user</pre></li>
				<li>Next, let’s create a dictionary that will contain all the fields needed to create <span class="No-Break">a post:</span><pre class="source-code">
&gt;&gt;&gt; data = {"author": user, "body":"A simple test"}</pre></li>
				<li>And now, let’s create <span class="No-Break">a post:</span><pre class="source-code">
&gt;&gt;&gt; post = Post.objects.create(**data)</pre><pre class="source-code">
&gt;&gt;&gt; post</pre><pre class="source-code">
&lt;Post: John Hey&gt;</pre><pre class="source-code">
&gt;&gt;&gt;</pre><pre class="source-code">
Let's access the author field of this object.</pre><pre class="source-code">
&gt;&gt;&gt; post.author</pre><pre class="source-code">
&lt;User: testuser@yopmail.com&gt;</pre></li>
			</ol>
			<p>As you can see, the author is in fact the user we’ve retrieved from <span class="No-Break">the database.</span></p>
			<p>Let’s also try the <span class="No-Break">inverse relationship:</span></p>
			<pre class="source-code">
&gt;&gt;&gt; user.post_set.all()
&lt;QuerySet [&lt;Post: John Hey&gt;]&gt;</pre>
			<p>As you can see, the <strong class="source-inline">post_set</strong> attribute contains all the instructions needed to interact with all the posts linked to <span class="No-Break">this user.</span></p>
			<p>Now that you have a better understanding of how database relationships work in Django, we can move on to writing<a id="_idIndexMarker169"/> the serializer of the <span class="No-Break"><strong class="source-inline">Post</strong></span><span class="No-Break"> object.</span></p>
			<h1 id="_idParaDest-60"><a id="_idTextAnchor063"/>Writing the Post serializer</h1>
			<p>The <strong class="source-inline">Post</strong> serializer will contain the<a id="_idIndexMarker170"/> fields needed to create a post when making a request on the endpoint. Let’s add the feature for the post <span class="No-Break">creation first.</span></p>
			<p>In the <strong class="source-inline">post</strong> directory, create a file called <strong class="source-inline">serializers.py</strong>. Inside this file, add the <span class="No-Break">following content:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/post/serializers.py</p>
			<pre class="source-code">
from rest_framework import serializers
from rest_framework.exceptions import ValidationError
from core.abstract.serializers import AbstractSerializer
from core.post.models import Post
from core.user.models import User
class PostSerializer(AbstractSerializer):
   author = serializers.SlugRelatedField(
     queryset=User.objects.all(), slug_field='public_id')
   def validate_author(self, value):
       if self.context["request"].user != value:
           raise ValidationError("You can't create a post
                                  for another user.")
       return value
   class Meta:
       model = Post
       # List of all the fields that can be included in a
       # request or a response
       fields = ['id', 'author', 'body', 'edited',
                 'created', 'updated']
       read_only_fields = ["edited"]</pre>
			<p>We’ve added a new serializer field type, <strong class="source-inline">SlugRelatedField</strong>. As we are working with the <strong class="source-inline">ModelSerializer</strong> class, Django automatically handles the fields and relationship generation for us. Defining<a id="_idIndexMarker171"/> the type of relationship field we want to use can also be crucial to tell Django exactly what <span class="No-Break">to do.</span></p>
			<p>And that’s where <strong class="source-inline">SlugRelatedField</strong> comes in. It is used to represent the target of the relationship using a field on the target. Thus, when creating a post, <strong class="source-inline">public_id</strong> of the author will be passed in the body of the request so that the user can be identified and linked to <span class="No-Break">the post.</span></p>
			<p>The <strong class="source-inline">validate_author</strong> method checks validation for the <strong class="source-inline">author</strong> field. Here, we want to make sure that the user creating the post is the same user as in the <strong class="source-inline">author</strong> field. A context dictionary is available in every serializer. It usually contains the request object that we can use to make <span class="No-Break">some checks.</span></p>
			<p>There is no hard limitation here so we can easily move to the next part of this feature: writing the <span class="No-Break"><strong class="source-inline">Post</strong></span><span class="No-Break"> viewsets.</span></p>
			<h1 id="_idParaDest-61"><a id="_idTextAnchor064"/>Writing Post viewsets</h1>
			<p>For the following endpoint, we’ll only<a id="_idIndexMarker172"/> be allowing the <strong class="source-inline">POST</strong> and <strong class="source-inline">GET</strong> methods. This will help us have the basic features <span class="No-Break">working first.</span></p>
			<p>The code should follow <span class="No-Break">these rules:</span></p>
			<ul>
				<li>Only authenticated users can <span class="No-Break">create posts</span></li>
				<li>Only authenticated users can <span class="No-Break">read posts</span></li>
				<li>Only <strong class="source-inline">GET</strong> and <strong class="source-inline">POST</strong> methods <span class="No-Break">are allowed</span></li>
			</ul>
			<p>Inside the <strong class="source-inline">post</strong> directory, create <a id="_idIndexMarker173"/>a file called <strong class="source-inline">viewsets.py</strong>. Into the file, add the <span class="No-Break">following content:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/post/viewsets.py</p>
			<pre class="source-code">
from rest_framework.permissions import IsAuthenticated
from core.abstract.viewsets import AbstractViewSet
from core.post.models import Post
from core.post.serializers import PostSerializer
class PostViewSet(AbstractViewSet):
   http_method_names = ('post', 'get')
   permission_classes = (IsAuthenticated,)
   serializer_class = PostSerializer
   def get_queryset(self):
       return Post.objects.all()
   def get_object(self):
       obj = Post.objects.get_object_by_public_id(
         self.kwargs['pk'])
       self.check_object_permissions(self.request, obj)
       return obj
   def create(self, request, *args, **kwargs):
       serializer = self.get_serializer(data=request.data)
       serializer.is_valid(raise_exception=True)
       self.perform_create(serializer)
       return Response(serializer.data,
                       status=status.HTTP_201_CREATED)</pre>
			<p>In the preceding code, we<a id="_idIndexMarker174"/> defined three <span class="No-Break">interesting methods:</span></p>
			<ul>
				<li>The <strong class="source-inline">get_queryset</strong> method returns all the posts. We don’t actually have particular requirements for fetching posts, so we can return all posts in <span class="No-Break">the database.</span></li>
				<li>The <strong class="source-inline">get_object</strong> method returns a <strong class="source-inline">post</strong> object using <strong class="source-inline">public_id</strong> that will be present in the URL. We retrieve this parameter from the <span class="No-Break"><strong class="source-inline">self.kwargs</strong></span><span class="No-Break"> directory.</span></li>
				<li>The <strong class="source-inline">create</strong> method, which is the <strong class="source-inline">ViewSet</strong> action executed on <strong class="source-inline">POST</strong> requests on the endpoint linked to <strong class="source-inline">ViewSet</strong>. We simply pass the data to the serializer declared on <strong class="source-inline">ViewSet</strong>, validate the data, and then call the <strong class="source-inline">perform_create</strong> method to create a <strong class="source-inline">post</strong> object. This method will automatically handle the creation of a <strong class="source-inline">post</strong> object by calling the <strong class="source-inline">Serializer.create</strong> method, which will trigger the creation of a <strong class="source-inline">post</strong> object in the database. Finally, we return a response with the newly <span class="No-Break">created post.</span></li>
			</ul>
			<p>And right here, you have the code for <strong class="source-inline">ViewSet</strong>. The next step is to add an endpoint and start testing <span class="No-Break">the API.</span></p>
			<h2 id="_idParaDest-62"><a id="_idTextAnchor065"/>Adding the Post route</h2>
			<p>In the <strong class="source-inline">routers.py</strong> file, add the<a id="_idIndexMarker175"/> <span class="No-Break">following content:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/routers.py</p>
			<pre class="source-code">
…
from core.post.viewsets import PostViewSet
# ##################################################################### #
# ################### POST                       ###################### #
# ##################################################################### #
router.register(r'post', PostViewSet, basename='post')
…</pre>
			<p>Once it’s done, you’ll have a new endpoint available on <strong class="source-inline">/post/</strong>. Let’s play with Insomnia to test <span class="No-Break">the API.</span></p>
			<p>First of all, try to make a request directly to the <strong class="source-inline">/post/</strong> endpoint. You’ll receive a <strong class="bold">401 error</strong>, meaning that you <a id="_idIndexMarker176"/>must provide an access token. No problem, log in on the <strong class="source-inline">/auth/login/</strong> endpoint with a registered user and copy <span class="No-Break">the token.</span></p>
			<p>In the <strong class="bold">Bearer</strong> tab in Insomnia, select <span class="No-Break"><strong class="bold">Bearer Token</strong></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer028" class="IMG---Figure">
					<img src="image/Figure_3.5_B18221.jpg" alt="Figure 3.5 – Adding Bearer Token to Insomnia request"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.5 – Adding Bearer Token to Insomnia request</p>
			<p>Now, fire the <a id="_idIndexMarker177"/>endpoint again with a <strong class="source-inline">GET</strong> request. You’ll see no results, great! Let’s create the first post in <span class="No-Break">the database.</span></p>
			<p>Change the type of request to <strong class="source-inline">POST</strong> and the following to the <span class="No-Break">JSON body:</span></p>
			<pre class="source-code">
{
    "author": "19a2316e94e64c43850255e9b62f2056",
    "body": "A simple posted"
}</pre>
			<p>Please note that we will have a different <strong class="source-inline">public_id</strong> so make sure to use <strong class="source-inline">public_id</strong> of the user you’ve just logged in as and send the <span class="No-Break">request again:</span></p>
			<div>
				<div id="_idContainer029" class="IMG---Figure">
					<img src="image/Figure_3.6_B18221.jpg" alt="Figure 3.6 – Creating a post"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.6 – Creating a post</p>
			<p>Great, the post is <a id="_idIndexMarker178"/>created! Let’s see whether it’s available when making a <span class="No-Break"><strong class="source-inline">GET</strong></span><span class="No-Break"> request:</span></p>
			<div>
				<div id="_idContainer030" class="IMG---Figure">
					<img src="image/Figure_3.7_B18221.jpg" alt="Figure 3.7 – Getting all posts"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.7 – Getting all posts</p>
			<p>The DRF provides a way to paginate responses and a default pagination limit size globally in the <strong class="source-inline">settings.py</strong> file. With time, a lot of objects will be shown and the size of the payload <span class="No-Break">will vary.</span></p>
			<p>To prevent this, let’s add a default size and a class to paginate <span class="No-Break">our results.</span></p>
			<p>Inside the <strong class="source-inline">settings.py</strong> file of <a id="_idIndexMarker179"/>the project, add new settings to the <span class="No-Break"><strong class="source-inline">REST_FRAMEWORK</strong></span><span class="No-Break"> dictionary:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">CoreRoot/settings.py</p>
			<pre class="source-code">
REST_FRAMEWORK = {
…
   'DEFAULT_PAGINATION_CLASS':
     'rest_framework.pagination.LimitOffsetPagination',
   'PAGE_SIZE': 15,
}
…</pre>
			<p>Basically here, all results are limited to 15 per page but we can also increase this size with the <strong class="source-inline">limit</strong> parameter when making a request and also use the <strong class="source-inline">offset</strong> parameter to precisely where we want the result to <span class="No-Break">start from:</span></p>
			<pre class="source-code">
GET https://api.example.org/accounts/?limit=100&amp;offset=400</pre>
			<p>Great, now make a <strong class="source-inline">GET</strong> request again and you’ll see that the results are <span class="No-Break">better structured.</span></p>
			<p>Also, it’ll be more practical to have the name of the author in the response as well. Let’s rewrite a serializer method that can help modify the <span class="No-Break">response object.</span></p>
			<h2 id="_idParaDest-63"><a id="_idTextAnchor066"/>Rewriting the Post serialized object</h2>
			<p>Actually, the <strong class="source-inline">author</strong> field <a id="_idIndexMarker180"/>accepts <strong class="source-inline">public_id</strong> and returns <strong class="source-inline">public_id</strong>. While it does the work, it can be a little bit difficult to identify the user. This will cause it to make a request again with <strong class="source-inline">public_id</strong> of the user to get the pieces of information about <span class="No-Break">the user.</span></p>
			<p>The <strong class="source-inline">to_representation()</strong> method takes the object instance that requires serialization and returns a primitive representation. This usually means returning a structure of built-in Python data types. The exact types that can be handled depend on the render classes you configure<a id="_idIndexMarker181"/> for <span class="No-Break">your API.</span></p>
			<p>Inside <strong class="source-inline">post/serializers.py</strong>, add a new method <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">to_represenation()</strong></span><span class="No-Break">:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/post/serializers.py</p>
			<pre class="source-code">
class PostSerializer(AbstractSerializer):
   …
   def to_representation(self, instance):
       rep = super().to_representation(instance)
       author = User.objects.get_object_by_public_id(
         rep["author"])
       rep["author"] = UserSerializer(author).data
       return rep
…</pre>
			<p>As you can see, we are using the <strong class="source-inline">public_id</strong> field to retrieve the user and then serialize the <strong class="source-inline">User</strong> object <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">UserSerializer</strong></span><span class="No-Break">.</span></p>
			<p>Let’s get all the posts again and you’ll see all <span class="No-Break">the users:</span></p>
			<div>
				<div id="_idContainer031" class="IMG---Figure">
					<img src="image/Figure_3.8_B18221.jpg" alt="Figure 3.8 – Getting all posts"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.8 – Getting all posts</p>
			<p>We have a working <strong class="source-inline">Post</strong> feature but it also has some issues. Let’s explore this further when writing permissions for <a id="_idIndexMarker182"/><span class="No-Break">our feature.</span></p>
			<h1 id="_idParaDest-64"><a id="_idTextAnchor067"/>Adding permissions</h1>
			<p>If authentication is the action of<a id="_idIndexMarker183"/> verifying the identity of a user, authorization is simply the action of checking whether the user has the rights or privileges to perform <span class="No-Break">an action.</span></p>
			<p>In our project, we have three types <span class="No-Break">of users:</span></p>
			<ul>
				<li><strong class="bold">The anonymous user</strong>: This user <a id="_idIndexMarker184"/>has no account on the API and can’t really <span class="No-Break">be identified</span></li>
				<li><strong class="bold">The registered and active user</strong>: This user<a id="_idIndexMarker185"/> has an account on the API and can easily perform <span class="No-Break">some actions</span></li>
				<li><strong class="bold">The admin user</strong>: This user has<a id="_idIndexMarker186"/> all rights <span class="No-Break">and privileges</span></li>
			</ul>
			<p>We want anonymous users to be able to read the posts on the API without necessarily being authenticated. While it’s true that there is the <strong class="source-inline">AllowAny</strong> permission, it’ll surely conflict with the <span class="No-Break"><strong class="source-inline">IsAuthenticated</strong></span><span class="No-Break"> permission.</span></p>
			<p>Thus, we need to write a <span class="No-Break">custom </span><span class="No-Break"><a id="_idIndexMarker187"/></span><span class="No-Break">permission.</span></p>
			<p>Inside the <strong class="source-inline">authentication</strong> directory, create a file called <strong class="source-inline">permissions</strong>, and add the <span class="No-Break">following content:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/post/viewsets.py</p>
			<pre class="source-code">
from rest_framework.permissions import BasePermission, SAFE_METHODS
class UserPermission(BasePermission):
   def has_object_permission(self, request, view, obj):
       if request.user.is_anonymous:
           return request.method in SAFE_METHODS
       if view.basename in ["post"]:
           return bool(request.user and
                       request.user.is_authenticated)
    return False
   def has_permission(self, request, view):
       if view.basename in ["post"]:
           if request.user.is_anonymous:
               return request.method in SAFE_METHODS
           return bool(request.user and
                       request.user.is_authenticated)
       return False</pre>
			<p>Django permissions usually work on two levels: on the overall endpoint (<strong class="source-inline">has_permission</strong>) and on an object <span class="No-Break">level (</span><span class="No-Break"><strong class="source-inline">has_object_permission</strong></span><span class="No-Break">).</span></p>
			<p>A great way to write permissions is to always deny by default; that is why we always return <strong class="source-inline">False</strong> at the end of each permission method. And then you can start adding the conditions. Here, in all the methods, we are checking that anonymous users can only make the <strong class="source-inline">SAFE_METHODS</strong> requests — <strong class="source-inline">GET</strong>, <strong class="source-inline">OPTIONS</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">HEAD</strong></span><span class="No-Break">.</span></p>
			<p>And for other users, we are making<a id="_idIndexMarker188"/> sure that they are always authenticated before continuing. Another important feature is to allow users to delete or update posts. Let’s see how we can add this <span class="No-Break">with Django.</span></p>
			<h1 id="_idParaDest-65"><a id="_idTextAnchor068"/>Deleting and updating posts</h1>
			<p>Deleting and updating articles are<a id="_idIndexMarker189"/> also part of the features of posts. To add these functionalities, we don’t need to write a serializer or a viewset, as the methods for deletion (<strong class="source-inline">destroy()</strong>), and <a id="_idIndexMarker190"/>updating (<strong class="source-inline">update()</strong>) are already available by default in the <strong class="source-inline">ViewSet</strong> class. We will just rewrite the <strong class="source-inline">update</strong> method on <strong class="source-inline">PostSerializer</strong> to ensure that the <strong class="source-inline">edited</strong> field is set to <strong class="source-inline">True</strong> when modifying <span class="No-Break">a post.</span></p>
			<p>Let’s add the <strong class="source-inline">PUT</strong> and <strong class="source-inline">DELETE</strong> methods to <strong class="source-inline">http_methods</strong> <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">PostViewSet</strong></span><span class="No-Break">:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/post/viewsets.py</p>
			<pre class="source-code">
…
class PostViewSet(AbstractViewSet):
   http_method_names = ('post', 'get', 'put', 'delete')
…</pre>
			<p>Before going in, let’s rewrite the <strong class="source-inline">update</strong> method in <strong class="source-inline">PostSerializer</strong>. We actually have a field called <strong class="source-inline">edited</strong> in the <strong class="source-inline">Post</strong> model. This field will tell us whether the post has <span class="No-Break">been edited:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/post/serializers.py</p>
			<pre class="source-code">
…
class PostSerializer(AbstractSerializer):
…
   def update(self, instance, validated_data):
       if not instance.edited:
           validated_data['edited'] = True
       instance = super().update(instance, validated_data)
       return instance
…</pre>
			<p>And let’s try the <strong class="source-inline">PUT</strong> and <strong class="source-inline">DELETE</strong> requests in Insomnia. Here’s an example of the body for the <span class="No-Break"><strong class="source-inline">PUT</strong></span><span class="No-Break"> request:</span></p>
			<pre class="source-code">
{
    "author": "61c5a1ecb9f5439b810224d2af148a23",
    "body": "A simple post edited"
}</pre>
			<div>
				<div id="_idContainer032" class="IMG---Figure">
					<img src="image/Figure_3.9_B18221.jpg" alt="Figure 3.9 – Modifying a post"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.9 – Modifying a post</p>
			<p>As you can see, the <strong class="source-inline">edited</strong> field in the<a id="_idIndexMarker191"/> response is set <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">true</strong></span><span class="No-Break">.</span></p>
			<p>Let’s try to delete the post <a id="_idIndexMarker192"/>and see whether <span class="No-Break">it works:</span></p>
			<div>
				<div id="_idContainer033" class="IMG---Figure">
					<img src="image/Figure_3.10_B18221.jpg" alt="Figure 3.10 – Deleting a post"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.10 – Deleting a post</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">There is a way to delete records without necessarily deleting them from the database. It’s usually called a soft delete. The record just won’t be accessible to the user, but it will always be present in the database. You can learn more about this <span class="No-Break">at </span><a href="https://dev.to/bikramjeetsingh/soft-deletes-in-django-a9j"><span class="No-Break">https://dev.to/bikramjeetsingh/soft-deletes-in-django-a9j</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-66"><a id="_idTextAnchor069"/>Adding the Like feature</h1>
			<p>A nice feature to have<a id="_idIndexMarker193"/> in a social media application is favoriting. Like Facebook, Instagram, or Twitter, we’ll allow users here to like <span class="No-Break">a post.</span></p>
			<p>Plus, we’ll also add data to count the number of likes a post has received and check whether a current user making the request has liked <span class="No-Break">a post.</span></p>
			<p>We’ll do this in <span class="No-Break">four steps:</span></p>
			<ol>
				<li value="10">Add a new <strong class="source-inline">posts_liked</strong> field to the <span class="No-Break"><strong class="source-inline">User</strong></span><span class="No-Break"> model.</span></li>
				<li>Write methods on the <strong class="source-inline">User</strong> model to like and remove a like from a post. We’ll also add a method to check whether the user has liked <span class="No-Break">a post.</span></li>
				<li>Add <strong class="source-inline">likes_count</strong> and <strong class="source-inline">has_liked</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">PostSerializer</strong></span><span class="No-Break">.</span></li>
				<li>Add endpoints to like and dislike <span class="No-Break">a post.</span></li>
			</ol>
			<p>Great! Let’s start by adding the new fields to the <span class="No-Break"><strong class="source-inline">User</strong></span><span class="No-Break"> model.</span></p>
			<h2 id="_idParaDest-67"><a id="_idTextAnchor070"/>Adding the posts_liked field to the User model</h2>
			<p>The <strong class="source-inline">posts_liked</strong> field will contain all the posts liked by a user. The relationship between the <strong class="source-inline">User</strong> model and the <strong class="source-inline">Post</strong> model concerning the Like feature can be described <span class="No-Break">as follows:</span></p>
			<ul>
				<li>A user can like <span class="No-Break">many posts</span></li>
				<li>A post can be liked by <span class="No-Break">many users</span></li>
			</ul>
			<p>This kind of relationship sounds familiar? It is a <span class="No-Break"><em class="italic">many-to-many</em></span><span class="No-Break"> relationship.</span></p>
			<p>Following this change, here’s the updated structure of the table – we are also anticipating the methods <a id="_idIndexMarker194"/>we’ll add to <span class="No-Break">the model:</span></p>
			<div>
				<div id="_idContainer034" class="IMG---Figure">
					<img src="image/Figure_3.11_B18221.jpg" alt="Figure 3.11 – New User table structure"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.11 – New User table structure</p>
			<p>Great! Let’s add the <strong class="source-inline">posts_liked</strong> field to the <strong class="source-inline">User</strong> model. Open the <strong class="source-inline">/core/user/models.py</strong> file and add a new field to the <span class="No-Break"><strong class="source-inline">User</strong></span><span class="No-Break"> model:</span></p>
			<pre class="source-code">
class User(AbstractModel, AbstractBaseUser, PermissionsMixin):
...
   posts_liked = models.ManyToManyField(
       "core_post.Post",
       related_name="liked_by"
   )
...</pre>
			<p>After that, run the following commands to create a new migrations file and apply this migration to <span class="No-Break">the </span><span class="No-Break"><a id="_idIndexMarker195"/></span><span class="No-Break">database:</span></p>
			<pre class="console">
python manage.py makemigrations
python manage.py migrate</pre>
			<p>The next step is to add the new methods shown in <span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.11</em> to the <span class="No-Break"><strong class="source-inline">User</strong></span><span class="No-Break"> model.</span></p>
			<h2 id="_idParaDest-68"><a id="_idTextAnchor071"/>Adding the like, remove_like, and has_liked methods</h2>
			<p>Before writing these methods, let’s describe the purpose of each <span class="No-Break">new method:</span></p>
			<ul>
				<li>The <strong class="source-inline">like()</strong> method: This is used for liking a post if it hasn’t been done yet. For this, we’ll use the <strong class="source-inline">add()</strong> method from the models. We’ll use <strong class="source-inline">ManyToManyField</strong> to link a post to <span class="No-Break">a user.</span></li>
				<li>The <strong class="source-inline">remove_like()</strong> method: This is <a id="_idIndexMarker196"/>used for removing a like from a post. For this, we’ll use the <strong class="source-inline">remove</strong> method from the models. We’ll use <strong class="source-inline">ManyToManyField</strong> to unlink a post from <span class="No-Break">a user.</span></li>
				<li>The <strong class="source-inline">has_liked()</strong> method: This is used for<a id="_idIndexMarker197"/> returning <strong class="source-inline">True</strong> if the user has liked a post, <span class="No-Break">else </span><span class="No-Break"><strong class="source-inline">False</strong></span><span class="No-Break">.</span></li>
			</ul>
			<p>Let’s move on to <span class="No-Break">the coding:</span></p>
			<pre class="source-code">
class User(AbstractModel, AbstractBaseUser, PermissionsMixin):
   ...
   def like(self, post):
       """Like `post` if it hasn't been done yet"""
       return self.posts_liked.add(post)
   def remove_like(self, post):
       """Remove a like from a `post`"""
       return self.posts_liked.remove(post)
   def has_liked(self, post):
       """Return True if the user has liked a `post`; else
          False"""
       return self.posts_liked.filter(pk=post.pk).exists()</pre>
			<p>Great! Next, let’s <a id="_idIndexMarker198"/>add the <strong class="source-inline">likes_count</strong> and <strong class="source-inline">has_liked</strong> fields <a id="_idIndexMarker199"/><span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">PostSerializer</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-69"><a id="_idTextAnchor072"/>Adding the likes_count and has_liked fields to PostSerializer</h2>
			<p>Instead of adding<a id="_idIndexMarker200"/> fields such as <strong class="source-inline">likes_count</strong> in the <strong class="source-inline">Post</strong> model and generating more fields in the database, we can directly manage it on <strong class="source-inline">PostSerializer</strong>. The <strong class="source-inline">Serializer</strong> class in Django <a id="_idIndexMarker201"/>provides ways to create the <strong class="source-inline">write_only</strong> values that <a id="_idIndexMarker202"/>will be sent<a id="_idIndexMarker203"/> on <span class="No-Break">the response.</span></p>
			<p>Inside the <strong class="source-inline">core/post/serializers.py</strong> file, add new fields <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">PostSerializer</strong></span><span class="No-Break">:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Core/post/serializers.py</p>
			<pre class="source-code">
...
class PostSerializer(AbstractSerializer):
   ...
   liked = serializers.SerializerMethodField()
   likes_count = serializers.SerializerMethodField()
   def get_liked(self, instance):
       request = self.context.get('request', None)
       if request is None or request.user.is_anonymous:
           return False
       return request.user.has_liked(instance)
   def get_likes_count(self, instance):
       return instance.liked_by.count()
   class Meta:
       model = Post
       # List of all the fields that can be included in a
       # request or a response
       fields = ['id', 'author', 'body', 'edited', 'liked',
                 'likes_count', 'created', 'updated']
       read_only_fields = ["edited"]</pre>
			<p>In the <a id="_idIndexMarker204"/>preceding code, we <a id="_idIndexMarker205"/>are using the <strong class="source-inline">serializers.SerializerMethodField()</strong> field, which allows us to write a custom function that will return a value we want to attribute to this field. The syntax of the method will be <strong class="source-inline">get_field</strong>, where <strong class="source-inline">field</strong> is the name of the field declared on <span class="No-Break">the serializer.</span></p>
			<p>That is why for <strong class="source-inline">liked</strong>, we have<a id="_idIndexMarker206"/> the <strong class="source-inline">get_liked</strong> method, and for <strong class="source-inline">likes_count</strong>, we have the <span class="No-Break"><strong class="source-inline">get_likes_count</strong></span><span class="No-Break"> method.</span></p>
			<p>With the new fields on <strong class="source-inline">PostSerializer</strong>, we can now add the endpoints needed to <strong class="source-inline">PostViewSet</strong> to like or <a id="_idIndexMarker207"/>dislike <span class="No-Break">an article.</span></p>
			<h2 id="_idParaDest-70"><a id="_idTextAnchor073"/>Adding like and dislike actions to PostViewSet</h2>
			<p>DRF provides a decorator called <strong class="source-inline">action</strong>. This decorator helps make methods on a <strong class="source-inline">ViewSet</strong> class routable. The <strong class="source-inline">action</strong> decorator<a id="_idIndexMarker208"/> takes <span class="No-Break">two arguments:</span></p>
			<ul>
				<li><strong class="source-inline">detail</strong>: If this argument is set to <strong class="source-inline">True</strong>, the route to this action will require a resource lookup field; in most cases, this will be the ID of <span class="No-Break">the resource</span></li>
				<li><strong class="source-inline">methods</strong>: This is a list of the methods accepted by <span class="No-Break">the action</span></li>
			</ul>
			<p>Let’s write the actions <span class="No-Break">on </span><span class="No-Break"><strong class="source-inline">PostViewSets</strong></span><span class="No-Break">:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/post/viewsets.py</p>
			<pre class="source-code">
 ...
class PostViewSet(AbstractViewSet):
   ...
   @action(methods=['post'], detail=True)
   def like(self, request, *args, **kwargs):
       post = self.get_object()
       user = self.request.user
       user.like(post)
       serializer = self.serializer_class(post)
       return Response(serializer.data,
                       status=status.HTTP_200_OK)
   @action(methods=['post'], detail=True)
   def remove_like(self, request, *args, **kwargs):
       post = self.get_object()
       user = self.request.user
       user.remove_like(post)
       serializer = self.serializer_class(post)
       return Response(serializer.data,
                       status=status.HTTP_200_OK)</pre>
			<p>For each action added, we<a id="_idIndexMarker209"/> are writing the logic following <span class="No-Break">these steps:</span></p>
			<ol>
				<li value="1">First, we retrieve the concerned post on which we want to call the like or remove the like action. The <strong class="source-inline">self.get_object()</strong> method will automatically return the concerned post using the ID passed to the URL request, thanks to the <strong class="source-inline">detail</strong> attribute being set <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">True</strong></span><span class="No-Break">.</span></li>
				<li>Second, we also retrieve the user making the request from the <strong class="source-inline">self.request</strong> object. This is done so that we can call the <strong class="source-inline">remove_like</strong> or <strong class="source-inline">like</strong> method added to the <span class="No-Break"><strong class="source-inline">User</strong></span><span class="No-Break"> model.</span></li>
				<li>And finally, we serialize the post using the <strong class="source-inline">Serializer</strong> class defined on <strong class="source-inline">self.serializer_class</strong> and we return <span class="No-Break">a response.</span></li>
			</ol>
			<p>With this added to <strong class="source-inline">PostViewSets</strong>, the Django Rest Framework routers will automatically create new routes for this resource, and then, you can do <span class="No-Break">the following:</span></p>
			<ol>
				<li value="1">Like a post with the<a id="_idIndexMarker210"/> following <span class="No-Break">endpoint: </span><span class="No-Break"><strong class="source-inline">api/post/post_pk/like/</strong></span><span class="No-Break">.</span></li>
				<li>Remove the like from a post with the following <span class="No-Break">endpoint: </span><span class="No-Break"><strong class="source-inline">api/post/post_pk/remove_like/</strong></span><span class="No-Break">.</span></li>
			</ol>
			<p>Great, the feature is working like a charm. In the next chapter, we’ll be adding the <em class="italic">comments</em> feature to <span class="No-Break">the project.</span></p>
			<h1 id="_idParaDest-71"><a id="_idTextAnchor074"/>Summary</h1>
			<p>In this chapter, we’ve learned how to use database relationships and write permissions. We also learned how to surcharge updates and create methods on viewsets <span class="No-Break">and serializers.</span></p>
			<p>We performed quick refactoring on our code by creating an <strong class="source-inline">Abstract</strong> class to follow the <em class="italic">DRY</em> rule. In the next chapter, we’ll be adding the Comments feature on the posts. Users will be able to create comments under posts as well as delete and <span class="No-Break">update them.</span></p>
			<h1 id="_idParaDest-72"><a id="_idTextAnchor075"/>Questions</h1>
			<ol>
				<li value="1">What are some <span class="No-Break">database relationships?</span></li>
				<li>What are <span class="No-Break">Django permissions?</span></li>
				<li>How do you paginate the results of an <span class="No-Break">API response?</span></li>
				<li>How do you use <span class="No-Break">Django shell?</span></li>
			</ol>
		</div>
		<div>
			<div id="_idContainer036" class="IMG---Figure">
			</div>
		</div>
	</body></html>