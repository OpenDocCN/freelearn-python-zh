- en: Automating Tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will add some automated testing to our RESTful Web Services
    and we will execute the tests within a test database. We won''t cover all the
    tests that we should write for our complex RESTful Web Service. However, we will
    follow the first steps and we will gain an understanding of:'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready for unit testing with pytest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing unit tests for a RESTful Web Service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discovering and running unit tests with pytest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing new unit tests to improve tests' code coverage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running new unit tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting ready for unit testing with pytest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have been writing code to add features to our RESTful Web Service
    and configuring many settings for the Django REST framework. We used command-line
    and GUI tools to understand how all the pieces worked together and to check the
    results of diverse HTTP requests. Now, we will write unit tests that will allow
    us to make sure that our RESTful Web Service will work as expected. Before we
    can start writing unit tests, it is necessary to install many additional packages
    in our virtual environment. Make sure you quit Django's development server. Remember
    that you just need to press *Ctrl* + *C* in the terminal or go to the Command
    Prompt window in which it is running. First, we will make some changes to work
    with a single version of our RESTful Web Service.
  prefs: []
  type: TYPE_NORMAL
- en: 'This way, it will be easier to focus on tests for a single version in our examples.
    Replace the code in the `urls.py` file in the `restful01/restful01` folder, specifically,
    the `restful01/restful01/urls.py` file. The file defines the root URL configurations,
    and therefore, we want to include only the URL patterns for the first version
    of our web service. The code file for the sample is included in the `hillar_django_restful_10_01`
    folder, in the `restful01/restful01/urls.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We will install the following Python packages in our virtual environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pytest`: This is a very popular Python unit test framework that makes testing
    easy and reduces boilerplate code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pytest-django`: This `pytest` plugin allows us to easily use and configure
    the features provided by `pytest` in our Django tests'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notice that we won't be working with Django's `manage.pytest` command. We will
    work with `pytest` instead. However, in case you don't want to work with `pytest`,
    most of the things you will learn can be easily adapted to any other test framework.
    In fact, the code is compatible with `nose` in case you decide to use the most
    common, yet a bit outdated, configuration for testing with the Django REST framework.
    Nowadays, `pytest` is the preferred unit test framework for Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to install the `pytest` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The last lines for the output will indicate that the `pytest` package and its
    required packages have been successfully installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We just need to run the following command to install the `pytest-django` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The last lines for the output will indicate that the `pytest-django` package
    has been successfully installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, go to the `restful01` folder that contains the `manage.py` file and create
    a new file named `pytest.ini`. Write the following code in this new file. The
    following lines show the code for this file that specifies the Django settings
    module (`restful01.settings`) and the pattern that `pytest` will use to locate
    the Python files, the declare tests. The code file for the sample is included
    in the `hillar_django_restful_10_01` folder in the `restful01/pytest.ini` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Whenever we execute pytest to run tests, the test runner will check the following
    to find test definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: Python files named `tests.py`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python files whose name starts with the `test_` prefix
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python files whose name ends with the `_tests` suffix
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In [Chapter 9](dj-rst-websvc_ch17.html), *Applying Throttling Rules and Versioning
    Management*, we configured throttling rules for our RESTful Web Service. We want
    to run our tests considering the throttling rules. In fact, we should write tests
    to make sure that the throttling rules are working OK. We will be running requests
    many times, and therefore, the low values we used for the throttling rules might
    complicate running all the requests required by our tests. Hence, we will increase
    the values for the throttling rules to simplify our testing samples. Open the
    `restful01/restful01/settings.py` file that declares module-level variables that
    define the configuration of Django for the `restful01` project. We will make some
    changes to this Django settings file. Replace the code for the highlighted lines
    included in the `REST_FRAMEWORK` dictionary. The following lines show the new
    declaration of the `REST_FRAMEWORK` dictionary. The code file for the sample is
    included in the `hillar_django_restful_10_01` folder in the `restful01/restful01/settings.py`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We increased the number of requests per hour that we can execute in each of
    the throttling rates configurations. This way, we will be able to run our tests
    without issues.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we are using the same settings file for our tests in order to
    avoid running additional steps and repeating test settings. However, in most cases,
    we would create a specific Django configuration file for testing.
  prefs: []
  type: TYPE_NORMAL
- en: Writing unit tests for a RESTful Web Service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we will write our first round of unit tests related to the drone category
    class based views: `DroneCategoryList` and `DroneCategoryDetail`. Open the existing
    `restful01/drones/tests.py` file and replace the existing code with the following
    lines that declare many `import` statements and the `DroneCategoryTests` class.
    The code file for the sample is included in the `hillar_django_restful_10_01`
    folder in the `restful01/drones/tests.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `DroneCategoryTests` class is a subclass of the `rest_framework.test.APITestCase`
    superclass and declares the `post_drone_category` method that receives the desired
    `name` for the new drone category as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: This method builds the URL and the data dictionary to compose and send an HTTP
    `POST` request to the view associated with the `views.DroneCategoryList.name`
    name (`dronecategory-list`) and returns the response generated by this request.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code uses the `self.client` attribute to access the `APIClient` instance
    that allows us to easily compose and send HTTP requests for testing our RESTful
    Web Service that uses the Django REST framework. For this test, the code calls
    the `post` method with the built `url`, the `data` dictionary, and the desired
    format for the data: `''json''`.'
  prefs: []
  type: TYPE_NORMAL
- en: Many test methods will call the `post_drone_category` method to create a new
    drone category and then compose and send other HTTP requests to the RESTful Web
    Service. For example, we will need a drone category to post a new drone.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `test_post_and_get_drone_category` method tests whether we can create a
    new `DroneCategory` and then retrieve it. The method calls the `post_drone_category`
    method and then calls `assert` many times to check for the following expected
    results:'
  prefs: []
  type: TYPE_NORMAL
- en: The `status_code` attribute for the response is equal to HTTP 201 Created (`status.HTTP_201_CREATED`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The total number of `DroneCategory` objects retrieved from the database is `1`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The value of the `name` attribute for the retrieved `DroneCategory` object is
    equal to the `new_drone_category_name` variable passed as a parameter to the `post_drone_category`
    method
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The previously coded tests make sure that we can create a new drone category
    with the RESTful Web Service, it is persisted in the database, and the serializer
    does its job as expected. The drone category is a very simple entity because it
    just has a primary key and a name. Now, we will add more test methods that will
    allow us to cover more scenarios related to drone categories.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `test_post_existing_drone_category_name` method to the recently created
    `DroneCategoryTests` class in the `restful01/drones/tests.py` file. The code file
    for the sample is included in the `hillar_django_restful_10_01` folder in the
    `restful01/drones/tests.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The new method tests whether the unique constraint for the drone category name
    works as expected and doesn't make it possible for us to create two drone categories
    with the same name. The second time we compose and send an HTTP `POST` request
    with a duplicate drone name, we must receive an HTTP `400 Bad Request` status
    code (`status.HTTP_400_BAD_REQUEST`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `test_filter_drone_category_by_name` method to the `DroneCategoryTests`
    class in the `restful01/drones/tests.py` file. The code file for the sample is
    included in the `hillar_django_restful_10_01` folder in the `restful01/drones/tests.py`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The new method tests whether we can filter a drone category by name, and therefore,
    checks the usage of the filter field we have configured for the `DroneCategoryList`
    class-based view. The code creates two drone categories and then calls the `django.utils.http.urlencode`
    function to build an encoded URL from the `filter_by_name` dictionary. This dictionary
    includes the field name as a key and the desired string for the field as a value.
    In this case, `drone_category_name1` is equal to `'Hexacopter'`, and therefore,
    the encoded URL saved in the `url` variable will be `'name=Hexacopter'`.
  prefs: []
  type: TYPE_NORMAL
- en: After the call to `self.client.get` with the built URL to retrieve the filtered
    list of drone categories, the method verifies the data included in the response
    JSON body by inspecting the `data` attribute for the response. The second line
    that calls `assert` checks whether the value for `count` is equal to `1` and the
    next lines verify whether the `name` key for the first element in the `results`
    array is equal to the value hold in the `drone_category_name1` variable. The code
    is easy to read and understand.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `test_get_drone_categories_collection` method to the `DroneCategoryTests`
    class in the `restful01/drones/tests.py` file. The code file for the sample is
    included in the `hillar_django_restful_10_01` folder in the `restful01/drones/tests.py`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The method tests whether we can retrieve the drone categories collection. First,
    the code creates a new drone category and then makes an HTTP `GET` request to
    retrieve the drones collection. The lines that call `assert` check that the results
    include the only created and persisted drone and that its name is equal to the
    name used for the call to the `POST` method to create the new drone category.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `test_update_drone_category` method to the `DroneCategoryTests` class
    in the `restful01/drones/tests.py` file. The code file for the sample is included
    in the `hillar_django_restful_10_01` folder in the `restful01/drones/tests.py`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The new method tests whether we can update a single field for a drone category.
    First, the code creates a new drone category and then makes an HTTP `PATCH` request
    to update the name field for the previously persisted drone category. The lines
    that call `assert` check that the returned status code is `HTTP 200 OK` and that
    the value of the `name` key in the response body is equal to the new name that
    we specified in the HTTP `PATCH` request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `test_get_drone_category` method to the `DroneCategoryTests` class
    in the `restful01/drones/tests.py` file. The code file for the sample is included
    in the `hillar_django_restful_10_01` folder in the `restful01/drones/tests.py`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The new method tests whether we can retrieve a single category with an HTTP
    `GET` request. First, the code creates a new drone category and then makes an
    HTTP `GET` request to retrieve the previously persisted drone category. The lines
    that call `assert` check that the returned status code is `HTTP 200 OK` and that
    the value of the `name` key in the response body is equal to the name that we
    specified in the HTTP `POST` request that created the drone category.
  prefs: []
  type: TYPE_NORMAL
- en: Each test method that requires a specific condition in the database must execute
    all the necessary code to generate the required data. For example, in order to
    update the name for an existing drone category, it was necessary to create a new
    drone category before making the HTTP `PATCH` request to update it. Pytest and
    the Django REST framework will execute each test method without data from the
    previously executed test methods in the database, that is, each test will run
    with a database cleansed of data from the previous tests.
  prefs: []
  type: TYPE_NORMAL
- en: Discovering and running unit tests with pytest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, go to the `restful01` folder that contains the `manage.py` file, with
    the virtual environment activated, and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `pytest` command and the Django REST framework will perform the following
    actions:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a clean test database name `test_drones`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run all the migrations required for the database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Discover the tests that have to be executed based on the settings specified
    in the `pytest.ini` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run all the methods whose name starts with the `test_` prefix in the `DroneCategoryTests`
    class and display the results. We declared this class in the `tests.py` file and
    it matches the pattern specified for the `python_files` setting in the `pytest.ini`
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drop the test database named `test_drones`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is very important to know that the tests won't make changes to the database
    we have been using when working with our RESTful Web Service. Notice that the
    test database name is `test_drones` and the database name that we have been using
    with Django's development server is `drones`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows a sample output generated by the `pytest` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6cc2cb23-d8d3-44a7-856e-86f7d770a77f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The output indicated that the test runner collected and executed six tests
    and all of them passed. However, the output didn''t show the names of the tests
    that passed. Hence, we will run `pytest` again with the `-v` option to increase
    verbosity. Run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows a sample output generated by the `pytest` command
    with the increased verbosity:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/158cd88e-eaef-4ad7-b999-28c4563d5bed.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We enabled verbose mode, and therefore, the new output displayed the full test
    names. Pytest displays the following information for each discovered and executed
    test: the Python file that defines it, the class name, and the method, such as
    the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The line indicates that the `test_filter_drone_category_by_name` test method
    declared in the `DroneCategoryTests` class, within the `drones/tests.py` module
    has been executed, passed, and its execution represents 16% of the discovered
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: The verbose mode makes it possible to know the specific tests that have been
    executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the test methods include calls to the `print` function. By default,
    pytest captures both the `stdout` and `stderr` and only shows the captured content
    for the tests that fail. Sometimes, it is useful for us to see the results of
    calls to the `print` function while `pytest` runs the tests. We will run `pytest`
    again with `-s` option combined with the `-v` option to disable capturing and
    increase verbosity. Notice that the `-s` option is a shortcut that is equivalent
    to the `-capture=no` option. Run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows a sample output for the previous command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/32a2544d-1693-4676-8db5-6e8b6bba9390.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The new output displayed the results of each call to the `print` function.
    In addition, we will notice that there are two messages displayed that are printed
    by Django, one line before the first test runs and another line after the last
    test finishes its execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: These messages indicate that Django created the test database before running
    the first test and drops the database after all the tests have been executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `test_filter_drone_category_by_name` test method declared in the `DroneCategoryTests`
    class has the following two calls to the `print` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous output shows the results of the two calls to the `print` function.
    First, the tests output display the value of the `url` variable with the composed
    URL and then the output shows the response of the call to `self.client.get` as
    a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the output is clear. However, as you might notice in the previous
    screenshot, the output generated by the other print statements is shown at the
    right-hand side of the test method name that was executed and it is not so clear.
    Hence, whenever we want to provide helpful output for tests, it is always a good
    idea to make sure we start with a new line (`'n'`) and provide some context for
    the output we are displaying.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will replace the line that calls the `print` function in the `test_post_and_get_drone_category`
    method for the `DroneCategoryTests` class in the `restful01/drones/tests.py` file.
    The code file for the sample is included in the `hillar_django_restful_10_02`
    folder in the `restful01/drones/tests.py` file. The replaced line is highlighted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following command to execute pytest again with the `-s` and `-v` options
    combined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows a sample output for the previous command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1260c896-8211-407c-8ba3-3bbe651a3f2d.png)'
  prefs: []
  type: TYPE_IMG
- en: The edits made in the call to the print statement that added a new line before
    and after the output made it easier to read the output. The generated output is
    highlighted in the previous screenshot. It is very important to take this formatting
    into account when working with `pytest`.
  prefs: []
  type: TYPE_NORMAL
- en: Writing new unit tests to improve the tests' code coverage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our first round of unit tests was related to the drone category class-based
    views: `DroneCategoryList` and `DroneCategoryDetail`. Now, we will write a second
    round of unit tests related to the pilot class-based views: `PilotList` and `PilotDetail`.
    The new tests will be a bit more complex because we will have to work with authenticated
    requests.'
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 8*](dj-rst-websvc_ch17.html), *Securing the API with Authentication
    and Permissions*, we configured authentication and permission policies for the
    class-based views that work with the `Pilot` model. We overrode the values for
    the `authentication_classes` and `permission_classes` class attributes for the
    `PilotDetail` and `PilotList` classes. In order to create, read, update, or delete
    pilots, we have to provide an authentication token. Hence, we will write tests
    to make sure that an unauthenticated request cannot perform operations related
    to pilots. In addition, we want to make sure that an authenticated request with
    a token can create a new pilot and then retrieve it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `restful01/drones/tests.py` file and add the following lines after
    the last line that declares the imports, before the declaration of the `DroneCategoryTests`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code to the existing `restful01/drones/tests.py` file to
    create the new `PilotTests` class. The code file for the sample is included in
    the `hillar_django_restful_10_02` folder in the `restful01/drones/tests.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `PilotTests` class is a subclass of the `rest_framework.test.APITestCase`
    superclass and declares the `post_pilot` method that receives the desired `name`
    and `gender` for the new pilot as arguments.
  prefs: []
  type: TYPE_NORMAL
- en: This method builds the URL and the data dictionary to compose and send an HTTP
    `POST` request to the view associated with the `views.PilotList.name` name (`pilot-list`)
    and returns the response generated by this request.
  prefs: []
  type: TYPE_NORMAL
- en: Many test methods will call the `post_pilot` method to create a new pilot and
    then compose and send other HTTP requests to the RESTful Web Service. Notice that
    the `post_pilot` method doesn't configure authentication credentials, and therefore,
    we will be able to call this method for unauthenticated or authenticated users.
    We already know that unauthenticated users shouldn't be able to post a pilot,
    and a test will call this method without a token and make sure no pilot is persisted
    in the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `create_user_and_set_token_credentials` method executes the following actions:'
  prefs: []
  type: TYPE_NORMAL
- en: Creates a Django user with a call to the `User.objects.create_user` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creates a token for the previously created Django user with a call to the `Token.objects.create`
    method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Includes the token generated for the Django user as the value for the `Authorization`
    HTTP header key with the `'Token '` string as a prefix for the token. The last
    line calls the `self.client.credentials` method to set the generated HTTP header
    as the value for the `HTTP_AUTHORIZATION` named argument.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember that the `self.client` attribute allows us to access the `APIClient`
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever a test wants to perform an HTTP request with a token, the code will
    call the `create_user_and_set_token_credentials` method. In order to clean up
    the credentials configured for the `APIClient` instance saved in `self.client`,
    it is necessary to call the `self.client.credentials()` method without arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `test_post_and_get_pilot` method tests the following path:'
  prefs: []
  type: TYPE_NORMAL
- en: We can create a new `Pilot` with an HTTP `POST` request that has an appropriate
    authentication token
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can retrieve the recently created `Pilot` with an HTTP `GET` request that
    has an appropriate authentication token
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We cannot retrieve the recently created `Pilot` with an unauthenticated HTTP
    `GET` request
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The code calls the `create_user_and_set_token_credentials` method and then
    calls the `post_pilot` method. Then, the code calls `assert` many times to check
    for the following expected results:'
  prefs: []
  type: TYPE_NORMAL
- en: The `status_code` attribute for the response is equal to HTTP 201 Created (`status.HTTP_201_CREATED`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The total number of `Pilot` objects retrieved from the database is `1`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The value of the `name`, `gender`, and `races_count` attributes for the retrieved
    `Pilot` object is equal to the values passed as parameters to the `post_pilot`
    method
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, the code calls the `self.client.get` with the built URL to retrieve the
    previously persisted pilot. This request will use the same credentials applied
    to the HTTP `POST` request, and therefore, the new request is authenticated by
    a valid token. The method verifies the data included in the response JSON body
    by inspecting the `data` attribute for the response. The code calls `assert` twice
    to check for the following expected results:'
  prefs: []
  type: TYPE_NORMAL
- en: The `status_code` attribute for the response is equal to HTTP 201 Created (`status.HTTP_201_CREATED`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The value of the `name` key in the response body is equal to the `name` that
    we specified in the HTTP `POST` request
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, the code calls the `self.client.credentials` method without arguments
    to clean up the credentials and calls the `self.client.get` method again with
    the same built URL, this time, without a token. Finally, the code calls assert
    to check that the status_code attribute for the response is equal to HTTP 401
    Unauthorized (`status.HTTP_401_UNAUTHORIZED`).
  prefs: []
  type: TYPE_NORMAL
- en: The previously coded test makes sure that we can create a new pilot with the
    RESTful Web Service and the appropriate authentication requirement we configured,
    the pilot is persisted in the database, and the serializer does its job as expected.
    In addition, unauthenticated users aren't able to access a pilot.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `test_try_to_post_pilot_without_token` method to the recently created
    `DroneCategoryTests` class in the `restful01/drones/tests.py` file. The code file
    for the sample is included in the `hillar_django_restful_10_02` folder in the
    `restful01/drones/tests.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The new method tests that the combination of permission and authentication
    classes configured for the `PilotList` class doesn''t make it possible for an
    unauthenticated HTTP `POST` request to create a pilot. The code calls the `post_pilot`
    method without configuring any credentials, and therefore the request runs without
    authentication. Then, the code calls `assert` twice to check for the following
    expected results:'
  prefs: []
  type: TYPE_NORMAL
- en: The `status_code` attribute for the response is equal to HTTP 401 Unauthorized
    (`status.HTTP_401_UNAUTHORIZED`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The total number of `Pilot` objects retrieved from the database is `0` because
    the received data to create a new pilot wasn't processed
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have increased the scenarios covered by our tests. We should write more tests
    related to pilots. However, with all the examples provided, you will have the
    necessary information to write all the tests required to make sure that each new
    version of a RESTful Web Service developed with Django and the Django REST framework
    works as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Running unit tests again with pytest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, go to the `restful01` folder that contains the `manage.py` file, with
    the virtual environment activated, and run the following command to execute `pytest`
    again with the `-v` option to increase verbosity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In this case, pytest will run all the methods whose name starts with the `test_`
    prefix in both the `DroneCategoryTests` and `PilotTests` classes and display the
    results.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows a sample output generated for the new execution
    of the `pytest` command with the increased verbosity:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e539bf0a-53d0-45f4-8402-5f08dc821699.png)'
  prefs: []
  type: TYPE_IMG
- en: We enabled verbose mode again, and therefore, the output displayed the full
    test names that the `test_post_and_get_pilot` and `test_try_to_post_pilot_without_token
    test methods` passed.
  prefs: []
  type: TYPE_NORMAL
- en: We should continue writing tests related to pilots, drone categories, drones, and
    competitions. It is extremely important that we cover all the scenarios for our
    RESTful Web Service. Automated tests will make it possible for us to make sure
    that each new version of our RESTful Web Service will work as expected after it
    is deployed to production.
  prefs: []
  type: TYPE_NORMAL
- en: We built RESTful Web Services with Django, the Django REST framework, and Python
    3.6\. We learned to design a RESTful Web Service from scratch, starting with the
    requirements, and to run some of the necessary tests to make sure our web service
    runs as expected. We learned to work with different command-line and GUI tools
    to make our development tests easy. We understood many features included in the
    Django REST framework and how to configure them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we are ready to create RESTful Web Services with Django and the Django
    REST framework. We will definitely need to dive deep into additional features,
    packages, and configurations. We definitely have a great baseline to develop our
    next RESTful Web Service with the most versatile programming language: Python.'
  prefs: []
  type: TYPE_NORMAL
- en: Test your knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's see whether you can answer the following questions correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a subclass of `APITestCase`, `self.client` is:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `APITestCase` instance that allows us to easily compose and send HTTP requests
    for testing
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The `APITestClient` instance that allows us to easily compose and send HTTP
    requests for testing
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The `APIClient` instance that allows us to easily compose and send HTTP requests
    for testing
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following lines clean up the credentials of a method within a subclass
    of `APITestCase`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`self.client.credentials()`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`self.client.clean_credentials()`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`self.client.credentials = {}`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following methods for `self.client` in a method within a subclass
    of `APITestCase` allows us to make an HTTP POST request?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`http_post`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`make_http_post_request`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`post`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following methods for self.client in a method within a subclass
    of `APITestCase` allows us to make an HTTP GET request?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`http_get`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`make_http_get_request`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`get`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following methods for `self.client` in a method within a subclass
    of `APITestCase` allows us to make an HTTP PATCH request?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`http_patch`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`make_http_patch_request`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`patch`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The rights answers are included in the [Appendix](https://cdp.packtpub.com/django_restful_web_services__/wp-admin/post.php?post=44&action=edit#post_454), *Solutions*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned to write unit tests for our RESTful Web Service.
    We installed the necessary packages and made the appropriate configurations to
    work with the modern and popular pytest unit test framework. Then, we wrote our
    first round of unit tests for the RESTful Web Service related to different scenarios
    with drone categories.
  prefs: []
  type: TYPE_NORMAL
- en: We worked with the different options for the pytest command to discover and
    run unit tests in the default mode, the increase verbosity mode, and the disable
    capture mode. We understood how to combine pytest with the testing classed provided
    by the Django REST framework.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we wrote additional unit tests for the RESTful Web Service related
    to different scenarios with pilots and the token authentication requirements for
    specific requests. We are able to continue adding tests for our RESTful Web Service
    with all the things we have learned.
  prefs: []
  type: TYPE_NORMAL
- en: Now, it is your turn. You can start developing RESTful Web Services with Django, 
    Django REST framework, and Python 3.6.
  prefs: []
  type: TYPE_NORMAL
