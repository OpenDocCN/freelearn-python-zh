- en: '3'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Function Definitions
  prefs: []
  type: TYPE_NORMAL
- en: Function definitions are a way to decompose a large problem into smaller problems.
    Mathematicians have been doing this for centuries. It’s a way to package our Python
    programming into intellectually manageable chunks.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll look at a number of function definition techniques in these recipes. This
    will include ways to handle flexible parameters and ways to organize the parameters
    based on some higher-level design principles.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also look at the typing module and how we can create more formal type
    hints for our functions. Using type hints will prepare our code so we can use
    tools like mypy to confirm the data types are used properly throughout a program.
    Type hints aren’t required, but they often identify potential inconsistencies,
    allowing us to write code that prevents problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll look at the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Function parameters and type hints](ch007_split_000.xhtml#x1-1620001)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Designing functions with optional parameters](ch007_split_000.xhtml#x1-1680002)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Using super flexible keyword parameters](ch007_split_000.xhtml#x1-1760003)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Forcing keyword-only arguments with the * separator](ch007_split_000.xhtml#x1-1820004)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Defining position-only parameters with the / separator](ch007_split_000.xhtml#x1-1880005)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Picking an order for parameters based on partial functions](ch007_split_001.xhtml#x1-1940006)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Writing clear documentation strings with RST markup](ch007_split_001.xhtml#x1-2030007)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Designing recursive functions around Python’s stack limits](ch007_split_001.xhtml#x1-2090008)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Writing testable scripts with the script-library switch](ch007_split_001.xhtml#x1-2150009)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 3.1 Function parameters and type hints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Through a number of Python Enhancement Proposals, type hints have grown in sophistication.
    The mypy tool is one way to validate these type hints to be sure the hints and
    the code agree. All the examples shown in this book have been checked with the
    mypy tool.
  prefs: []
  type: TYPE_NORMAL
- en: This extra syntax for the hints is optional. It has limited use at runtime and
    has no performance costs.
  prefs: []
  type: TYPE_NORMAL
- en: 3.1.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ll need to download and install the mypy tool. Generally, this is done with
    the following terminal command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Using the python -m pip command ensures the pip command will be associated with
    the currently active virtual environment. In this example, the prompt shows a
    virtual environment named cookbook3.
  prefs: []
  type: TYPE_NORMAL
- en: We can also use the pyright tool to examine type hints.
  prefs: []
  type: TYPE_NORMAL
- en: 'For an example of type hints, we’ll look at some color computations. The first
    of these is extracting the Red, Green, and Blue values from the color codes commonly
    used in the style sheets for HTML pages. There are a variety of ways of encoding
    the values, including strings, integers, and tuples. Here are some of the varieties
    of data types:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A string of six hexadecimal characters with a leading # , for example, "#C62D42"'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A string of six hexadecimal characters, for example, "C62D42"
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Python numeric value, for example, 0xC62D42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A three-tuple of R, G, and B integers, for example, (198, 45, 66)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For strings and numbers, we use the type name directly, str or int. For tuples,
    we use a more complicated-looking tuple[int, int, int].
  prefs: []
  type: TYPE_NORMAL
- en: 'The target is three integer values. A conversion from string or integer to
    three values involves two separate steps:'
  prefs: []
  type: TYPE_NORMAL
- en: If the value is a string, convert to a single integer using the int() function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For single integer values, split the integer into three separate values using
    the >> and & operators. This is the core computation for converting a single integer
    value, hx_int, into three separate r, g, b values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: A single RGB integer has three separate values that are combined via bit shifting.
    The red value was shifted left 16 bits. To extract this component, the value is
    shifted right 16 bits using the >> operator. The & operator applies 0xff as a
    ”mask” to save only 8 bits of a potentially larger number. To extract the green
    component, shift right 8 bits. The blue value occupies the least-significant 8
    bits.
  prefs: []
  type: TYPE_NORMAL
- en: 3.1.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For some functions, it can be easiest to start with a working implementation
    and add hints. Here’s how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the function without any hints:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add the result hint. It’s based on the return statement. In this example, the
    return is a tuple of three integers, tuple[int, int, int].
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the parameter hints. In this case, we’ve got two alternative types for
    the parameter: it can be a string or an integer. In the formal language of the
    type hints, this is a union of two types. The parameter can be described as Union[str, int]
    or str | int. If Union is used, the definition must be imported from the typing
    module.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Combining the hints into a function leads to the following definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 3.1.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These type hints have no impact when the Python code is executed. The hints
    are designed for people to read and for external tools, like mypy, to verify.
    A tool can confirm that the hx_int variable is always used as either an integer
    or a string.
  prefs: []
  type: TYPE_NORMAL
- en: In the r, g, b = assignment statement, the value for hx_int is expected to be
    an integer. The mypy tool can confirm the operators are appropriate for integer
    values, and the return type matches the computed types.
  prefs: []
  type: TYPE_NORMAL
- en: We can observe the mypy tool’s analysis of a type by inserting the reveal_type(hx_int)
    function into our code. This statement has function-like syntax; it’s only used
    when running the mypy tool. We will only see output from this when we run mypy,
    and we have to remove this extra line of code before we try to do anything else
    with the module.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output looks like this when we run mypy at the shell prompt on the recipe_01_reveal.py
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The output from the reveal_type(hx_int) line tells us mypy is certain the variable
    will have an integer value after the first if statement is complete. Once we’ve
    seen the revealed type information, we need to delete the reveal_type(hx_int)
    line from the file.
  prefs: []
  type: TYPE_NORMAL
- en: 3.1.4 There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s look at a related computation. This converts RGB numbers into Hue-Saturation-Lightness
    (HSL) values. These HSL values can be used to compute complementary colors. An
    additional algorithm required to convert from HSL back into RGB values can help
    encode colors for a web page:'
  prefs: []
  type: TYPE_NORMAL
- en: 'RGB to HSL: We’ll look at this closely because it has complex type hints.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'HSL to complement: There are a number of theories on what the ”best” complement
    might be. We’ll gloss over the details.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'HSL to RGB: This will be the final step, but we’ll ignore the details of this
    computation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We won’t look closely at two of the implementations. They are not horribly complicated,
    but these computation details can be a distraction from understanding the types
    and type hints. See [https://www.easyrgb.com/en/math.php](https://www.easyrgb.com/en/math.php).
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by roughing out a definition of the function with a stub definition,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This can help us visualize a number of related functions to be sure they all
    have consistent types. The other two functions have stubs like these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'After writing down this initial list of stub definitions, we can see some type
    hints are repeated in slightly different contexts. This suggests we need to create
    a separate named type to avoid repetition of the details. We’ll provide a name
    for the repeated type detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This overview of the various functions can be helpful for assuring that each
    function uses data in a way that’s consistent with other functions.
  prefs: []
  type: TYPE_NORMAL
- en: The names RGB_a and HSL_a include a suffix of _a to help distinguish these type
    aliases from other examples in this recipe. In a practical application, the suffix
    strings like _a to show the name is an alias are going to become visual clutter
    and should be avoided.
  prefs: []
  type: TYPE_NORMAL
- en: 'As noted in the [Using NamedTuples to simplify item access in tuples](ch005_split_001.xhtml#x1-7500010)
    in Chapter [1](ch005_split_000.xhtml#x1-170001), we can provide a more descriptive
    set of names for these tuple types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We’ve defined a unique, new NamedTuple subclass, called RGB. Using names can
    help clarify the intent behind the code.
  prefs: []
  type: TYPE_NORMAL
- en: 3.1.5 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The mypy project contains a wealth of information. See [https://mypy.readthedocs.io](https://mypy.readthedocs.io)
    for more information on the way type hints work.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The pyright project is another helpful type hint tool. See [https://microsoft.github.io/pyright](https://microsoft.github.io/pyright)
    for more information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 3.2 Designing functions with optional parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we define a function, we often have a need for optional parameters. This
    allows us to write functions that are more flexible and easier to read.
  prefs: []
  type: TYPE_NORMAL
- en: We can also think of this as a way to create a family of closely related functions.
    Each function has a slightly different collection of parameters – called the signature
    – but all sharing the same simple name. This is sometimes called an ”overloaded”
    function. Within the typing module, an @overload decorator can help create type
    hints in the more complicated cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of an optional parameter is the built-in int() function. This function
    has two signatures:'
  prefs: []
  type: TYPE_NORMAL
- en: int(str) -> int. For example, the value of int(’355’) has a value of 355\. An
    optional base parameter defaults to a value of 10.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: int(str, base) -> int. For example, the value of int(’163’, 16) is 355\. In
    this case, the base parameter value is 16.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 3.2.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A great many games rely on collections of dice. The casino game of Craps uses
    two dice. A game like Zonk (or Greed or Ten Thousand) uses six dice. It’s handy
    to have a dice-rolling function that can handle all of these variations.
  prefs: []
  type: TYPE_NORMAL
- en: 3.2.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have two approaches to designing a function with optional parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: 'General to particular: Start by designing the most general solution and provide
    defaults for the most common case.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Particular to general: Start by designing several related functions. We then
    merge them into one general function that covers all of the cases, singling out
    one of the original functions to be the default behavior.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ll look at the particular to general approach first, because it’s often easier
    to start with a number of concrete examples.
  prefs: []
  type: TYPE_NORMAL
- en: Particular to general design
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Throughout this example, we’ll use slightly different names as the function
    evolves. This simplifies unit testing the different versions and comparing them.
    Here’s how we’ll proceed:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write one game function. We’ll start with the Craps game because it seems to
    be the simplest:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We defined a function, die(), to encapsulate a basic fact about standard dice.
    Five platonic solids are often used, yielding four-sided, six-sided, eight-sided,
    twelve-sided, and twenty-sided dice. The randint() expression assumes a six-sided
    cube.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Write the next game function. We’ll move on to the Zonk game:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We’ve used a generator expression to create a tuple object with a collection
    of six dice. We’ll look at generator expressions in depth in Chapter [9](ch013_split_000.xhtml#x1-5020009).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The generator expression in the body of the zonk() function has a variable,
    x, which is required syntax, but the value is ignored. It’s also common to see
    this written as tuple(die() for _ in range(6)). The variable _ is a valid Python
    variable name, often used when a variable name is required, but is never used.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Locate the common features in the craps() and zonk() functions. In this case,
    we can refactor the design of the craps() function to follow the pattern set by
    the zonk() function. Rather than building exactly two evaluations of the die()
    function, we can introduce a generator expression based on range(2) that will
    evaluate the die() function twice:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Merge the two functions. This will often involve exposing a variable that had
    previously been a literal value:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This provides a general function that covers the needs of both the Craps and
    Zonk games.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Identify the most common use case and make this the default value for any parameters
    that were introduced. If our most common simulation was Craps, we might do this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, we can use dice_v3() for the Craps game. We’ll need to use the expression
    dice_v3(6) for the first roll of a Zonk game.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Check the type hints to be sure they describe the parameters and the return
    values. In this case, we have one parameter with an integer value, and the return
    is a tuple of integers, described by tuple[int, ...].
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Throughout this example, the name evolved from dice() to dice_v2() and then
    to dice_v3(). This can make it easier to see the differences here in the recipe.
    Once a final version is written, it makes sense to delete the others and rename
    the final versions of these functions to dice(), craps(), and zonk(). The story
    of their evolution may become a blog post, but it doesn’t need to be preserved
    in the code.
  prefs: []
  type: TYPE_NORMAL
- en: General to particular design
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When following the general to particular strategy, we’ll identify all of the
    needs first. It can be difficult to foresee all the alternatives, making this
    more challenging. We’ll often do this by introducing variables to the requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Summarize the requirements for dice-rolling. We might start with a list like
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Craps: Two dice'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'First roll in Zonk: Six dice'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Subsequent rolls in Zonk: One to six dice'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Rewrite the requirements with an explicit parameter in place of any literal
    value. We’ll replace all of our numbers with a parameter, n. This will take on
    values of 2, 6, or a value in the range 1 ≤ n ≤ 6\. We want to be sure we’ve properly
    parameterized each of the various functions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write the function that fits the general pattern:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the third case – subsequent rolls in Zonk – we identified a constraint of
    1 ≤ n ≤ 6, imposed by the application program to play Zonk.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Provide a default value for the most common use case. If our most common simulation
    was Craps, we might do this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add type hints. These will describe the parameters and the return values. In
    this case, we have one parameter with an integer value, and the return is a tuple
    of integers, described by tuple[int, ...]:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, we can use this dice() function for Craps. We’ll need to use dice(6) for
    the first roll in Zonk.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, the name didn’t need to evolve through multiple versions. The
    name evolution is only useful in a book for unit testing each example.
  prefs: []
  type: TYPE_NORMAL
- en: This version looks precisely like dice_v2() from the previous recipe. This isn’t
    an accident – the two design strategies often converge on a common solution.
  prefs: []
  type: TYPE_NORMAL
- en: 3.2.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python’s rules for providing parameter values enable several ways to ensure
    that each parameter is given an argument value. We can think of the process like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: Where there are default values, set those parameters. Default values make these
    optional.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For arguments without names – for example, dice(2) – the argument values are
    assigned to the parameters by position.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For arguments with names – for example, dice(n=2) – the argument values are
    assigned to parameters by name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If any parameter still lacks a value, raise a TypeError exception.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The rules also allow us to mix positional values with named values. This make
    some parameters optional by providing a default value.
  prefs: []
  type: TYPE_NORMAL
- en: 3.2.4 There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It helps to write functions that are specialized versions of our more generalized
    function. These functions can simplify an application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Our application features – craps_v3() and zonk_v3() – depend on a general function,
    dice().
  prefs: []
  type: TYPE_NORMAL
- en: These form layers of dependencies, saving us from having to understand too many
    details. This idea of layered abstractions is sometimes called chunking, a way
    of managing complexity by isolating the details.
  prefs: []
  type: TYPE_NORMAL
- en: 3.2.5 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll extend on some of these ideas in the [Picking an order for parameters
    based on partial functions](ch007_split_001.xhtml#x1-1940006) recipe, later in
    this chapter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ve made use of optional parameters that involve immutable objects. In this
    recipe, we focused on numbers. In Chapter [4](ch008_split_000.xhtml#x1-2240004),
    we’ll look at mutable objects, which have an internal state that can be changed.
    In the [Avoiding mutable default values for function parameters](ch009.xhtml#x1-3210006)
    recipe, we’ll look at some additional considerations for optional values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 3.3 Using super flexible keyword parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some design problems involve solving a simple equation for one unknown when
    given enough known values. For example, rate, time, and distance have a simple
    linear relationship. We can solve for any one when given the other two.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three related solutions to r × t = d:'
  prefs: []
  type: TYPE_NORMAL
- en: '![d = r × t ](img/file14.png)'
  prefs:
  - PREF_UL
  type: TYPE_IMG
- en: '![r = dt ](img/file15.png)'
  prefs:
  - PREF_UL
  type: TYPE_IMG
- en: '![ d t = r ](img/file16.png)'
  prefs:
  - PREF_UL
  type: TYPE_IMG
- en: When designing electrical circuits, for example, a similar set of equations
    is used based on Ohm’s law. In that case, the equations tie together resistance,
    current, and voltage.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, we want an implementation that can perform any of the three different
    calculations based on what’s known and what’s unknown.
  prefs: []
  type: TYPE_NORMAL
- en: 3.3.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll build a single function that can solve a Rate-Time-Distance (RTD) calculation
    by embodying all three solutions, given any two known values. With minor variable
    name changes, this applies to a surprising number of real-world problems.
  prefs: []
  type: TYPE_NORMAL
- en: We don’t necessarily want a single value as an answer. We can slightly generalize
    this by creating a small Python dictionary with the three values in it; two are
    given, one is computed. We’ll look at dictionaries in more detail in Chapter [5](ch009.xhtml#x1-2890005).
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll use the warnings module instead of raising an exception when there’s
    a problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Sometimes, it is more helpful to produce a result that is doubtful than to stop
    processing.
  prefs: []
  type: TYPE_NORMAL
- en: 3.3.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Solve the equation for each of the unknowns. There are three separate expressions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: distance = rate * time
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: rate = distance / time
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: time = distance / rate
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Wrap each expression in an if statement based on one of the values being None
    when it’s unknown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Refer to the [Designing complex if...elif chains](ch006_split_000.xhtml#x1-1170005)
    recipe from Chapter [2](ch006_split_000.xhtml#x1-840002), for guidance on designing
    these complex if...elif chains. Include a variation of the Else-Raise option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Build the resulting dictionary object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Wrap all of this as a function using keyword parameters with default values
    of None. This leads to parameter types of Optional[float], often stated as float | None.
    The return type is a dictionary with string keys, summarized as dict[str, float | None].
    It looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The type hints tend to make the function definition so long it has to be spread
    across five physical lines of code. The presence of so many optional values is
    difficult to summarize!
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the resulting function like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This shows us that going 31.2 nautical miles at a rate of 6 knots will take
    5.2 hours.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a nicely formatted output, we might do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: To break up the long string, we used our knowledge from the [Designing complex
    if...elif chains](ch006_split_000.xhtml#x1-1170005) recipe in Chapter [2](ch006_split_000.xhtml#x1-840002).
  prefs: []
  type: TYPE_NORMAL
- en: To make the warning more visible, the warnings module can be used to set a filter
    that elevates the warning to an error. Use the expression warnings.simplefilter(’error’)
    to transform warnings into visible exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: 3.3.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Because we’ve provided default values for all of the parameters, we can provide
    argument values for any two of the three parameters, and the function can then
    solve for the third parameter. This saves us from having to write three separate
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: Returning a dictionary as the final result isn’t essential to this. It’s a handy
    way to show inputs and outputs. It allows the function to return a uniform result,
    no matter which parameter values were provided.
  prefs: []
  type: TYPE_NORMAL
- en: 3.3.4 There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have an alternative formulation for this, one that involves more flexibility.
    Python functions have an all other keywords parameter, prefixed with **.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can leverage the flexible keywords parameter and insist that all arguments
    be provided as keywords:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The keywords type hint states that all of the values for these parameters will
    be float objects. In some rare case, not all of the keyword parameters are the
    same type; in this case, some redesign may be helpful to make the types clearer.
  prefs: []
  type: TYPE_NORMAL
- en: This version uses the dictionary get() method to find a given key in the dictionary.
    If the key is not present, a default value of None is provided.
  prefs: []
  type: TYPE_NORMAL
- en: The dictionary’s get() method permits a second parameter, the default, which
    can be provided instead of None if the key is not present.
  prefs: []
  type: TYPE_NORMAL
- en: This kind of open-ended design has the potential advantage of being much more
    flexible. One potential disadvantage is that the actual parameter names are hard
    to discern, since they’re not part of the function definition, but instead part
    of the function’s body. We can follow the [Writing better docstrings with RST
    markup](ch006_split_000.xhtml#x1-1090004) recipe and provide a good docstring.
    It seems much better, though, to provide the parameter names explicitly as part
    of the Python code rather than implicitly through documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'This has another, and more profound, disadvantage. The problem is revealed
    in the following bad example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This isn’t the behavior we want. The misspelling of ”distance” is not reported
    as a TypeError exception. The misspelled parameter name is not reported anywhere.
    To uncover these errors, we’d need to add some programming to pop items from the
    keywords dictionary and report errors on names that remain after the expected
    names were removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This design will spot spelling errors. The extra processing suggests explicit
    parameter names might be better than the flexibility of an unbounded collection
    of names.
  prefs: []
  type: TYPE_NORMAL
- en: 3.3.5 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We look at the documentation of functions in the [Writing better docstrings
    with RST markup](ch006_split_000.xhtml#x1-1090004) recipe in Chapter [2](ch006_split_000.xhtml#x1-840002).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 3.4 Forcing keyword-only arguments with the * separator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are some situations where we have a large number of positional parameters
    for a function. Pragmatically, a function with more than about three parameters
    can be confusing. A great deal of conventional mathematics seems to focus on one-
    and two-parameter functions. There don’t seem to be too many common mathematical
    operators that involve three or more operands.
  prefs: []
  type: TYPE_NORMAL
- en: When it gets difficult to remember the required order for the parameters, this
    suggests there are too many parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 3.4.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll look at a function to prepare a wind-chill table and write the data to
    a CSV format output file. We need to provide a range of temperatures, a range
    of wind speeds, and information on the file we’d like to create. This is a lot
    of parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'One formula for the apparent temperature, the wind chill, T[wc], is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Twc(Ta,V ) = 13.2 + 0.6215Ta − 11.37V 0.16 + 0.3965TaV 0.16 ](img/file17.png)'
  prefs: []
  type: TYPE_IMG
- en: The wind chill temperature, ![Twc ](img/file18.png), is based on the air temperature,
    ![Ta ](img/file19.png), in degrees C, and the wind speed, ![V ](img/file20.png),
    in KPH.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Americans, this requires some conversions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Convert the temperature, ![Ta ](img/file21.png), from Farenheit, ![∘F ](img/file22.png),
    into Celsius, ![∘C ](img/file23.png): ![T = 5(F−-32)- a 9 ](img/file24.png).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Convert windspeed, ![V ](img/file25.png), from MPH, ![Vmph ](img/file26.png),
    into KPH: ![V = 1.609344Vmph ](img/file27.png).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The result, ![Twc ](img/file28.png), needs to be converted from ![∘C ](img/file29.png)
    back to ![∘F ](img/file30.png): ![ 9Twc- F = 32+ 5 ](img/file31.png).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We won’t fold these American conversions into the solution. We’ll leave this
    as an exercise for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function to compute the wind-chill temperature, T_wc() looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This function has an unusual name, T_wc(). We’ve matched the formal definition
    of T[wc], rather than enforcing the PEP-8 rule of beginning function names with
    a lowercase letter. In this case, it seems better to stick with names used in
    the literature, rather than imposing a name based on language conventions.
  prefs: []
  type: TYPE_NORMAL
- en: 'One approach to creating a wind-chill table is to create something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Before we get to the design problem, let’s look at the essential processing.
    We expect the function using this will have opened an output file using the with
    context. This follows the [Managing a context using the with statement](ch006_split_001.xhtml#x1-15200011)
    recipe in Chapter [2](ch006_split_000.xhtml#x1-840002). Within this context, we’ve
    created a write for the CSV output file. We look at this in more depth in Chapter [11](ch015_split_000.xhtml#x1-61500011).
  prefs: []
  type: TYPE_NORMAL
- en: The value for the heading variable includes a list literal and a comprehension
    that builds a list. We look at lists in Chapter [4](ch008_split_000.xhtml#x1-2240004).
    We look at comprehensions and generator expressions in Chapter [9](ch013_split_000.xhtml#x1-5020009).
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, each row of the table is built by an expression that combines a single
    float value with a list comprehension. The list consists of values computed by
    the wind-chill function, T_wc(). We provide the wind velocity, V, based on the
    row in the table. We also provide a temperature, T, based on the column in the
    table.
  prefs: []
  type: TYPE_NORMAL
- en: 'The wind_chill() function’s overall definition presents a problem: the wind_chill()
    function has seven distinct positional parameters. When we try to use this function,
    we wind up with code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: What are all those numbers? Is there something we can do to help explain the
    purposes behind all those numbers?
  prefs: []
  type: TYPE_NORMAL
- en: 3.4.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we have a large number of parameters, it helps to require the use of keyword
    arguments instead of positional arguments. We can use the * as a separator between
    two groups of parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our example, the resulting function definition has the following stub definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s see how it works in practice with different kinds of parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: 'When we try to use the confusing positional parameters, we’ll see this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We must use the function with explicit parameter names, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This use of mandatory keyword parameters forces us to write a longer, but clearer,
    statement each time we use this complicated-seeming function.
  prefs: []
  type: TYPE_NORMAL
- en: 3.4.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The * character, when used as a parameter definition, separates two collections
    of parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: Before *, we list the argument values that can be either positional or named
    by keyword. In this example, we don’t have any of these parameters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After *, we list the argument values that must be given with a keyword. For
    our example, this is all of the parameters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The print() function exemplifies this. It has three keyword-only parameters
    for the output file, the field separator string, and the line end string.
  prefs: []
  type: TYPE_NORMAL
- en: 3.4.4 There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can, of course, combine this technique with default values for the various
    parameters. We might, for example, make a change to this, thus introducing a single
    default value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now use this function in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a way to print the table on the console, using the default target:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here’s a way to write to a file using an explicit target:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can be more confident in these changes because the parameters must be provided
    by name. We don’t have to check carefully to be sure about the order of the parameters.
  prefs: []
  type: TYPE_NORMAL
- en: As a general pattern, we suggest doing this when there are more than three parameters
    for a function. It’s easy to remember one or two. Most mathematical operators
    are unary or binary. While a third parameter may still be easy to remember, the
    fourth (and subsequent) parameter will become very difficult to recall.
  prefs: []
  type: TYPE_NORMAL
- en: 3.4.5 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See the [Picking an order for parameters based on partial functions](ch007_split_001.xhtml#x1-1940006)
    recipe for another application of this technique.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 3.5 Defining position-only parameters with the / separator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can use the / character in the parameter list to separate the parameters
    into two groups. Before /, all argument values work positionally. After the /
    parameter, argument values may be given positionally, or names may be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'This should be used for functions where the following conditions are all true:'
  prefs: []
  type: TYPE_NORMAL
- en: A few positional parameters are used (no more than three).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And they are all required.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And the order is so obvious that any change might be confusing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This has always been a feature of the standard library. As an example, the
    math.sin() function can only use positional parameters. The formal definition
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Even though there’s an x parameter name, we can’t use this name. If we try
    to, we’ll see the following exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The x parameter can only be provided positionally. The output from the help()
    function provides a suggestion of how the / separator can be used to make this
    happen.
  prefs: []
  type: TYPE_NORMAL
- en: 3.5.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Position-only parameters are used by some of the internal built-ins; the design
    pattern can also be helpful, though, in our functions. To be useful, there must
    be very few position-only parameters. Since most mathematical operators have one
    or two operands, this suggests one or two position-only parameters can be useful.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll consider two functions for conversion of units from the Fahrenheit system
    used in the US and the Centigrade system used almost everywhere else in the world:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Convert from ![∘ F ](img/file32.png) into ![∘ C ](img/file33.png): ![ 5(F−32)
    C = ---9--- ](img/file34.png)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Convert from ![∘C ](img/file35.png) into ![∘F ](img/file36.png): ![F = 32 +
    9C- 5 ](img/file37.png)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of these functions has a single argument, making it a reasonable example
    for a position-only parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 3.5.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Define the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the / parameter separator after the position-only parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For these examples, we put a _1 and _2 suffixes on the function names to make
    it clear which definition goes with each step of the recipe. These are two versions
    of the same function, and they should have the same name. They’re separated to
    show the history of writing the functions; this is not a practical naming convention
    except when writing a book where some partially complete functions have their
    own unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: 3.5.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The / separator divides the parameter names into two groups. In front of /
    are parameters where the argument values must be provided positionally: named
    argument values cannot be used. After the / are parameters where names are permitted.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at a slightly more complex version of our temperature conversions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'This function has a position-only parameter named f. It also has the truncate
    parameter, which can be provided by name. This leads to three separate ways to
    use this function, as shown in the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The first example shows the position-only parameter and the output without any
    rounding. This is an awkwardly complex-looking value.
  prefs: []
  type: TYPE_NORMAL
- en: The second example uses the named parameter style to set the non-positional
    parameter, truncate, to True. The third example provides both argument values
    positionally.
  prefs: []
  type: TYPE_NORMAL
- en: 3.5.4 There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This can be combined with the * separator to create very sophisticated function
    signatures. The parameters can be decomposed into three groups:'
  prefs: []
  type: TYPE_NORMAL
- en: Parameters before the / separator must be given by position. These must be first.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parameters after the / separator can be given by position or name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parameters after the * separator must be given by name only. These names are
    provided last, since they can never be matched by position.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 3.5.5 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See the [Forcing keyword-only arguments with the * separator](ch007_split_000.xhtml#x1-1820004)
    recipe for details on the * separator.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 3.6 Picking an order for parameters based on partial functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The term partial function is widely used to describe the partial application
    of a function. Some of the argument values are fixed, while others vary. We might
    have a function, ![f (a,b,c) ](img/file38.png), where there are fixed values for
    ![a ](img/file39.png) and ![b ](img/file40.png). With fixed values, we have a
    new version of the function, ![fp(c) ](img/file41.png).
  prefs: []
  type: TYPE_NORMAL
- en: When we look at complex functions, we’ll sometimes see a pattern in the ways
    we use the function. We might, for example, evaluate a function many times with
    some argument values that are fixed by context, and other argument values that
    are changing with the details of the processing. Having some fixed argument values
    suggests a partial function.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a partial function can simplify our programming by avoiding code to
    repeat the argument values that are fixed by a specific context.
  prefs: []
  type: TYPE_NORMAL
- en: 3.6.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ll look at a version of the haversine formula. This computes distances between
    two points, p[1] = (lon[1],lat[1]) and p[2] = (lon[2],lat[2]), on the surface
    of the Earth:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ ∘ ------------------------------------------------- a = sin2(lat2 −-lat1)+
    cos(lat1)cos(lat2) sin2(lat2 −-lat1) 2 2 ](img/file42.png)![c = 2arcsin a ](img/file43.png)'
  prefs: []
  type: TYPE_IMG
- en: The essential calculation yields the central angle, c, between two points. The
    angle is measured in radians. We must convert this angle into distance by multiplying
    by the Earth’s mean radius in some given units. If we multiply the angle c by
    a radius of 3,959 miles, we’ll convert the angle into miles.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an implementation of this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The doctest example uses an Earth radius with an extra decimal point that’s
    not used elsewhere. This example’s output will match other examples found online.
  prefs: []
  type: TYPE_NORMAL
- en: The problem we often have is the value for R rarely changes for a specific context.
    One context may use kilometers throughout the application, while another uses
    nautical miles. We’d like to impose a context-specific default value like R = NM
    to get nautical miles in a given context without having to edit the module.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll look at several common approaches to providing a consistent value for
    an argument.
  prefs: []
  type: TYPE_NORMAL
- en: 3.6.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In some cases, an overall context will establish a single value for a parameter.
    The value will rarely change. The following are three common approaches to providing
    a consistent value for an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: Wrap the function in a new function that provides the default value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create a partial function with the default value. This has two further refinements:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can provide defaults as a keyword parameters.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We can provide defaults as positional parameters.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ll look at each of these in separate variations in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping a function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here’s how we can revise the function, slightly, and create a wrapper:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Make some parameters positional and some parameters keywords. We want the contextual
    features – the ones that rarely change – to be keywords. The parameters that change
    more frequently should be left as positional:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can follow the [Forcing keyword-only arguments with the * separator](ch007_split_000.xhtml#x1-1820004)
    recipe.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can then write a wrapper function that will apply all of the positional
    arguments, unmodified. It will supply the additional keyword argument as part
    of the long-running context:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have the *args construct in the function declaration to accept all positional
    argument values in a single tuple, args. We use a similar-looking *args when evaluating
    the haversine() function to expand the tuple into all of the positional argument
    values to this function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this case, all the types are float. We can use *args: float to provide a
    suitable hint. This doesn’t always work out, and this style of handling arguments
    – while simple-looking – can hide problems.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a partial function with keyword parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One approach to defining functions that work well as partial function is to
    use keyword parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can follow the [Forcing keyword-only arguments with the * separator](ch007_split_000.xhtml#x1-1820004)
    recipe to do this. We might change the basic haversine function so that it looks
    like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a partial function using the keyword parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The partial() function builds a new function from an existing function and a
    concrete set of argument values. The nm_haversine_3() function has a specific
    value for R provided when the partial was built.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use this like we’d use any other function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: We get an answer in nautical miles, allowing us to do boating-related calculations.
    Having a fixed value for R=NM leaves the code slightly simpler-looking, and much
    more trust-worthy. The possibility of one computation having an incorrect value
    for R is eliminated.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a partial function with positional parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If we try to use partial() with positional arguments, we’re constrained to
    providing the leftmost parameter values in the partial definition. This leads
    us to think of the first few arguments to a function as candidates for being hidden
    by a partial function or a wrapper:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to change the basic haversine function to put the R parameter first.
    This makes it slightly easier to define a partial function. Here’s the changed
    definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a partial function using the positional parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The partial() function builds a new function from an existing function and a
    concrete set of argument values. The nm_haversine_4() function has a specific
    value for the first parameter, R, that’s provided when the partial was built.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can use this like we’d use any other function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: We get an answer in nautical miles, allowing us to do boating-related calculations
    easily, The code can use a version of the the haversine() function without the
    annoying detail of repeating the R=NM argument value.
  prefs: []
  type: TYPE_NORMAL
- en: 3.6.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A partial function is, essentially, identical to a wrapper function. We can
    build partials freely in the middle of other, more complex, pieces of a program.
    Note that creating partial functions leads to a few additional considerations
    when looking at the order for positional parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: If we try to use *args in the wrapper, these must be defined last. All of these
    parameters become anonymous. This anonymity means tools like mypy may have problems
    confirming the parameters are being used correctly. The documentation will not
    show the necessary details, either.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The leftmost positional parameters are easiest to provide a value for when creating
    a partial function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any keyword-only parameters, defined after the * separator, are also a good
    choice to provide as part of a partial definition.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These considerations can lead us to look at the leftmost argument as being
    a kind of context: these parameters are expected to change rarely and can be provided
    more easily by partial function definitions.'
  prefs: []
  type: TYPE_NORMAL
- en: 3.6.4 There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There’s yet another way to wrap a function – we can also build a lambda object.
    The following example will also work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: This relies on the haversine_k() function definition, where the R parameter
    is marked as keyword-only. Without this clear separation between positional and
    keyword argument values, this lambda definition will result in a warning from
    mypy. If we use the original haversine() function, the warning tells us that it’s
    possible for R to get multiple values.
  prefs: []
  type: TYPE_NORMAL
- en: 'A lambda object is a function that’s been stripped of its name and body. The
    function definition is reduced to just two essentials:'
  prefs: []
  type: TYPE_NORMAL
- en: The parameter list, *args, in this example.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A single expression, which is the result, haversine_k(*args, R=NM). A lambda
    cannot have any statements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The lambda approach makes it difficult to create type hints. This limits its
    utility. Further, the [PEP-8](https://peps.python.org/pep-0008/) recommendations
    suggest assigning a lambda to a variable should never be done.
  prefs: []
  type: TYPE_NORMAL
- en: 3.6.5 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll also look at extending this design further in the [Writing testable scripts
    with the script-library switch](ch007_split_001.xhtml#x1-2150009) recipe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For more functional programming techniques, see Functional Python Programming:
    [https://www.packtpub.com/product/functional-python-programming-3rd-edition-third-edition/9781803232577](https://www.packtpub.com/product/functional-python-programming-3rd-edition-third-edition/9781803232577).
    This has numerous examples of using lambdas and partial functions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 3.7 Writing clear documentation strings with RST markup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How can we clearly document what a function does? Can we provide examples? Of
    course we can, and we really should. In the [Including descriptions and documentation](ch006_split_000.xhtml#x1-1010003)
    recipe in Chapter [2](ch006_split_000.xhtml#x1-840002), and in the [Writing better
    docstrings with RST markup](ch006_split_000.xhtml#x1-1090004) recipe, we looked
    at some essential documentation techniques. Those recipes introduced ReStructuredText
    (RST) for module docstrings.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll extend those techniques to write RST for function docstrings. When we
    use a tool such as Sphinx, the docstrings from our function will become elegant-looking
    documentation that describes what our function does.
  prefs: []
  type: TYPE_NORMAL
- en: 3.7.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the [Forcing keyword-only arguments with the * separator](ch007_split_000.xhtml#x1-1820004)
    recipe, we looked at a function to compute wind-chill, given the temperature and
    wind-speed.
  prefs: []
  type: TYPE_NORMAL
- en: In the recipe, we’ll show several versions of the function with trailing _0
    in the name. Pragmatically, this name change is not a good idea. For the purposes
    of making the evolution of this function clear in this book, however, it seems
    helpful to give each new variant a distinct name.
  prefs: []
  type: TYPE_NORMAL
- en: We need to annotate this function with some more complete documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 3.7.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ll generally write the following things for a function description:'
  prefs: []
  type: TYPE_NORMAL
- en: Synopsis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exceptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test cases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anything else that seems meaningful
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here’s how we’ll create documentation for a function. We can apply a similar
    method to a method of a class, or even a module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the synopsis. A proper subject isn’t required. Don’t write This function
    computes...; we can start with Computes.... There’s no reason to overstate the
    context:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To help clarify the evolution of this function’s docstring in this book, we’ve
    appended a suffix of _1 to the name.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Write the description and provide details:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this case, we used a little block of typeset math in our description. The
    :math: interpreted text role uses LaTeXmath typesetting. Tools like Sphinx can
    use MathJax or jsMath to do handle math typesetting.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Describe the parameters. For positional parameters, it’s common to use :param name:
    description. Sphinx will tolerate a number of variations, but this is common.
    For parameters that must be keywords, it’s common to use :key name: as the prefix
    to the description.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Describe the return value using :returns::'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Identify the important exceptions that might be raised. Use the :raises exception:
    markup to define the reasons for the exception. There are several possible variations,
    but :raises exception: seems to be popular:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Include a doctest test case, if possible:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Write any additional notes and helpful information. We could add the following
    to the docstring:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We’ve included a reference to a Wikipedia page that summarizes wind-chill calculations
    and has links to more detailed information.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We’ve also included a ..  math:: directive with the LaTeX formula that’s used
    in the function. This will often typeset nicely, providing a very readable version
    of the code.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 3.7.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For more information on docstrings, see the [Including descriptions and documentation](ch006_split_000.xhtml#x1-1010003)
    recipe in Chapter [2](ch006_split_000.xhtml#x1-840002). While Sphinx is popular,
    it isn’t the only tool that can create documentation from the docstring comments.
    The pydoc utility that’s part of the Python Standard Library can also produce
    good-looking documentation from the docstring comments.
  prefs: []
  type: TYPE_NORMAL
- en: The Sphinx tool relies on the core features of RST processing in the Docutils
    package. See [https://pypi.python.org/pypi/docutils](https://pypi.python.org/pypi/docutils)
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: 'The RST rules are relatively simple. Most of the additional features in this
    recipe leverage the interpreted text roles of RST. Each of our :param T:, :returns:,
    and :raises ValueError: constructs is a text role. The RST processor can use this
    information to decide on a style and structure for the content. The style usually
    includes a distinctive font. The context might be an HTML definition list format.'
  prefs: []
  type: TYPE_NORMAL
- en: 3.7.4 There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In many cases, we’ll also need to include cross-references among functions and
    classes. For example, we might have a function that prepares a wind-chill table.
    This function might have documentation that includes a reference to the T_wc()
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sphinx will generate these cross-references using a special :func: text role:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: We’ve used :func:‘Twc‘ to create a reference from one function in the RST documentation
    to another function. Sphinx will turn these into proper hyperlinks.
  prefs: []
  type: TYPE_NORMAL
- en: 3.7.5 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See the [Including descriptions and documentation](ch006_split_000.xhtml#x1-1010003)
    and [Writing better docstrings with RST markup](ch006_split_000.xhtml#x1-1090004)
    recipes in Chapter [2](ch006_split_000.xhtml#x1-840002), for other recipes that
    show how RST works.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 3.8 Designing recursive functions around Python’s stack limits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some functions can be defined clearly and succinctly using a recursive formula.
    There are two common examples of this.
  prefs: []
  type: TYPE_NORMAL
- en: 'The factorial function has the following recursive definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ ( |{ n! = 1 if n = 0, |( n × (n− 1)! if n > 0\. ](img/file44.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The recursive rule for computing a Fibonacci number, F[n], has the following
    definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ ( |{ F = 1 if n = 0∨ n = 1, n |( Fn −1 + Fn −2 if n > 1\. ](img/file45.png)'
  prefs: []
  type: TYPE_IMG
- en: Each of these involves a case that has a simple defined value and a case that
    involves computing the function’s value, based on other values of the same function.
  prefs: []
  type: TYPE_NORMAL
- en: The problem we have is that Python imposes an upper limit for these kinds of
    recursive function evaluations. While Python’s integers can easily compute the
    value of 1000!, the stack limit prevents us from computing this casually.
  prefs: []
  type: TYPE_NORMAL
- en: Pragmatically, the filesystem is an example of a recursive data structure. Each
    directory contains subdirectories. Recursive function definitions can be used
    on directory trees. The cases with defined values come from processing the non-directory
    files.
  prefs: []
  type: TYPE_NORMAL
- en: We can often refactor a recursive design to eliminate the recursion and replace
    it with iteration. While doing recursion elimination, we’d like to preserve as
    much of the original mathematical clarity as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 3.8.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Many recursive function definitions follow the pattern set by the factorial
    function. This is sometimes called tail recursion because the recursive case can
    be written at the tail of the function body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The last expression in the function refers to the same function, but uses a
    different argument value.
  prefs: []
  type: TYPE_NORMAL
- en: We can restate this, avoiding the recursion limits in Python.
  prefs: []
  type: TYPE_NORMAL
- en: 3.8.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A tail recursion can also be described as a reduction. We’re going to start
    with a collection of values, and then reduce them to a single value:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Expand the rule to show all of the details: n! = n×(n−1)×(n−2)× (n − 3) ×![⋅⋅⋅](img/file46.png)×
    1\. This helps ensure we understand the recursive rule.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write a loop or generator to create all the values: N = {n,n − 1,n − 2,n −
    3,…,1}. In Python, this can be as simple as range(1, n+1). In some cases, though,
    we might have to apply some transformation function to the base values: N = {f(i)∣1
    ≤ i < n + 1}. This is a list comprehension; see [Building lists – literals, appending,
    and comprehensions](ch008_split_000.xhtml#x1-2310002) in Chapter [4](ch008_split_000.xhtml#x1-2240004).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Incorporate the reduction function. In this case, we’re computing a large product,
    using multiplication. We can summarize this as ∏ [1≤x<n+1]x.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here’s an implementation in Python:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: An equivalent function is available in the math module. Rather than write it
    out as shown above, we can use from math import prod.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The prod_i() function can be used as follows to compute a factorial value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: This works nicely. We’ve optimized the prod_i() function into an iterative function.
    This revision avoids the potential stack overflow problems the recursive version
    suffers from.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the range object is lazy; it doesn’t create a big list object, avoiding
    the allocation of a great deal of memory. A range object returns individual values
    as they are consumed by the prod_i() function.
  prefs: []
  type: TYPE_NORMAL
- en: 3.8.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A tail recursion definition is handy because it’s short and easy to remember.
    Mathematicians like this because it can help clarify what a function means.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many static, compiled languages create optimized code in a manner similar to
    the technique we’ve shown here. This works by injecting a special instruction
    into the virtual machine’s byte code – or the actual machine code – to re-evaluate
    the function without creating a new stack frame. Python doesn’t have this feature.
    In effect, this optimization transforms a recursion into a kind of while statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: The injection of the special byte code instruction will lead to code that runs
    quickly, without revealing the intermediate revisions. The resulting instructions
    will not be a perfect match for the source text, however, leading to potential
    difficulties in locating bugs.
  prefs: []
  type: TYPE_NORMAL
- en: 3.8.4 There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Computing the F[n] Fibonacci number involves an additional problem. If we’re
    not careful, we’ll compute a lot of values more than once:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To compute F[5] = F[4] + F[3], for example, we’ll evaluate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![F5 = (F3 + F2 )+ (F2 + F1) ](img/file47.png)'
  prefs: []
  type: TYPE_IMG
- en: Expanding the definition of F[3] and F[2] shows a number of redundant computations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Fibonacci problem involves two recursions. If we write it naively, it might
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s difficult to do a simple mechanical transformation to turn something like
    this example into a tail recursion. We have two ways to reduce the computation
    complexity of this:'
  prefs: []
  type: TYPE_NORMAL
- en: Use memoization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Restate the problem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The memoization technique is easy to apply in Python. We can use the @functools.cache
    as a decorator. It looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Adding this decorator will optimize a more complex recursion.
  prefs: []
  type: TYPE_NORMAL
- en: Restating the problem means looking at it from a new perspective. In this case,
    we can think of computing all Fibonacci numbers up to and including the desired
    F[n]. We only want the last value in this sequence. Computing a number of intermediate
    values can be reasonably efficient.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a generator function that does this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: This function is an infinite iteration of Fibonacci numbers. It uses Python’s
    yield so that it emits values in a lazy fashion. When a client function uses this
    iterator, the next number in the sequence is computed as each number is consumed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a function that consumes the values and also imposes an upper limit
    on the otherwise infinite iterator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: This function consumes a sequence of values from the fibo_iter() iterator. When
    the desired number has been reached, the break statement ends the for statement.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve optimized the recursive solution and turned it into an iteration that
    avoids the potential for stack overflow.
  prefs: []
  type: TYPE_NORMAL
- en: 3.8.5 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See the [Avoiding a potential problem with break statements](ch006_split_001.xhtml#x1-1290007)
    recipe in Chapter [2](ch006_split_000.xhtml#x1-840002).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 3.9 Writing testable scripts with the script-library switch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It’s often very easy to create a Python script file. When we provide a script
    file to Python, it runs immediately. In some cases, there are no function or class
    definitions; the script file is the sequence of Python statements.
  prefs: []
  type: TYPE_NORMAL
- en: These script files are very difficult to test. Additionally, they’re also difficult
    to reuse. When we want to build larger and more sophisticated applications from
    a collection of script files, we’re often forced to re-engineer a script into
    one or more functions.
  prefs: []
  type: TYPE_NORMAL
- en: 3.9.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s say that we have a handy implementation of the haversine distance function
    called haversine(), and it’s in a file named recipe_11.py.
  prefs: []
  type: TYPE_NORMAL
- en: 'The file contains the functions and definitions shown in the [Picking an order
    for parameters based on partial functions](ch007_split_001.xhtml#x1-1940006) in
    this chapter. This includes a partial function, nm_haversine(), to compute distances
    in nautical miles. The script also contains the following top-level code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: This Python script opens a file, data/wapypoints.csv, and does some processing
    on that file. While this is handy to use, we can’t easily test it.
  prefs: []
  type: TYPE_NORMAL
- en: If we try to import the haversine() function for a unit test, we’ll execute
    the other parts of the script. How can we refactor this module so we can import
    the useful functions without it printing a display of distances between waypoints
    in the wapypoints.csv file?
  prefs: []
  type: TYPE_NORMAL
- en: 3.9.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Writing a Python script can be called an attractive nuisance; it’s attractively
    simple, but it’s difficult to test effectively. Here’s how we can transform a
    script into a testable and reusable library:'
  prefs: []
  type: TYPE_NORMAL
- en: Identify the statements that do the work of the script. This means distinguishing
    between definitions and actions. Statements such as import, def, and class are
    definitional – they create objects but don’t take a direct action to compute or
    produce the output. Almost all other statements take some action. Because some
    assignment statements might be part of type hint definition, or might create useful
    constants, the distinction is entirely one of intent.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In our example, we have some assignment statements that are more definition
    than action. These assignments are analogous to def statements; they only set
    variables that are used later. Here are the generally definitional statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The rest of the statements in the module are designed to take an action toward
    producing the printed results.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Wrap the actions into a function. Try to pick a descriptive name. If there’s
    no better name, use main(). In this example the action computes distances, so
    we’ll call the function distances().
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the above example, we named the function distances_draft() to assure that
    it’s clearly distinct from a more final version. Practically, using distinct names
    like this as code evolves toward completion isn’t necessary, unless writing a
    book where it’s essential to unit test intermediate steps.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Where possible, extract literals and turn them into parameters. This is often
    a simple movement of the literal to a parameter with a default value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This makes the script reusable because the path is now a parameter instead of
    an assumption.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Include the following if statement as the only high-level action statements
    in the script file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We’ve packaged the action of the script as a function. The top-level action
    script is now wrapped in an if statement so that it isn’t executed during import
    but is executed when the script is run directly.
  prefs: []
  type: TYPE_NORMAL
- en: 3.9.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An important rule for Python is that an import of a module is essentially the
    same as running the module as a script. The statements in the file are executed,
    in order, from top to bottom.
  prefs: []
  type: TYPE_NORMAL
- en: When we import a file, we’re generally interested in executing the def and class
    statements. We might be interested in some assignment statements that define useful
    globals. Sometimes, we’re not interested in executing the main program.
  prefs: []
  type: TYPE_NORMAL
- en: 'When Python runs a script, it sets a number of built-in special variables.
    One of these is __name__. This variable has two different values, depending on
    the context in which the file is being executed:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The top-level script, executed from the command line: In this case, the value
    of the built-in special name of __name__ is set to "__main__".'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A file being executed because of an import statement: In this case, the value
    of __name__ is the name of the module being created from reading the file and
    executing the Python statements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The standard name of "__main__" may seem a little odd at first. Why not use
    the filename in all cases? This special name is assigned because a Python script
    can be read from one of many sources. It can be a file. Python can also be read
    from the stdin pipeline, or it can be provided on the Python command line using
    the -c option.
  prefs: []
  type: TYPE_NORMAL
- en: 3.9.4 There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can now build useful work around a reusable library. We might make an application
    script file that look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'The goal is to decompose a practical solution into two collections of features:'
  prefs: []
  type: TYPE_NORMAL
- en: The definition of classes and functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A very small action-oriented script that uses the definitions to do useful work
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We often start with a script that conflates both sets of features. This kind
    of script can be viewed as a spike solution. Our spike solution can evolve toward
    a more refined solution as soon as we’re sure that it works. A spike or piton
    is a piece of removable mountain-climbing gear that enables us to climb safely.
  prefs: []
  type: TYPE_NORMAL
- en: After starting with a spike, we can elevate our design and refactor the code
    into definitions and actions. Tests can then import the module to test the various
    definitions without taking actions that might overwrite important files.
  prefs: []
  type: TYPE_NORMAL
- en: 3.9.5 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Chapter [7](ch011_split_000.xhtml#x1-3760007), we look at class definitions.
    These are another kind of widely used definitional statement, in addition to function
    definitions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [Reading delimited files with the CSV module](ch015_split_000.xhtml#x1-6320003)
    recipe that we look at in Chapter [11](ch015_split_000.xhtml#x1-61500011) also
    addresses CSV file reading.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Join our community Discord space
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our Python Discord workspace to discuss and find out more about the book:
    [https://packt.link/dHrHU](https://packt.link/dHrHU)'
  prefs: []
  type: TYPE_NORMAL
- en: '![PIC](img/file1.png)'
  prefs: []
  type: TYPE_IMG
