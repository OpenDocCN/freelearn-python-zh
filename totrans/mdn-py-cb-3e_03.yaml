- en: '3'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '3'
- en: Function Definitions
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 函数定义
- en: Function definitions are a way to decompose a large problem into smaller problems.
    Mathematicians have been doing this for centuries. It’s a way to package our Python
    programming into intellectually manageable chunks.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 函数定义是将一个大问题分解成更小问题的方法。数学家们已经这样做了几百年。这是一种将我们的Python编程打包成智力上可管理的块的方法。
- en: We’ll look at a number of function definition techniques in these recipes. This
    will include ways to handle flexible parameters and ways to organize the parameters
    based on some higher-level design principles.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这些食谱中查看多种函数定义技术。这包括处理灵活参数的方法以及根据某些高级设计原则组织参数的方法。
- en: We’ll also look at the typing module and how we can create more formal type
    hints for our functions. Using type hints will prepare our code so we can use
    tools like mypy to confirm the data types are used properly throughout a program.
    Type hints aren’t required, but they often identify potential inconsistencies,
    allowing us to write code that prevents problems.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将查看typing模块以及我们如何为我们的函数创建更正式的类型提示。使用类型提示将使我们的代码准备就绪，以便我们可以使用像mypy这样的工具来确认在整个程序中正确地使用了数据类型。类型提示不是必需的，但它们通常可以识别潜在的不一致性，使我们能够编写防止问题的代码。
- en: 'In this chapter, we’ll look at the following recipes:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将查看以下食谱：
- en: '[Function parameters and type hints](ch007_split_000.xhtml#x1-1620001)'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[函数参数和类型提示](ch007_split_000.xhtml#x1-1620001)'
- en: '[Designing functions with optional parameters](ch007_split_000.xhtml#x1-1680002)'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[设计具有可选参数的函数](ch007_split_000.xhtml#x1-1680002)'
- en: '[Using super flexible keyword parameters](ch007_split_000.xhtml#x1-1760003)'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用超级灵活的关键字参数](ch007_split_000.xhtml#x1-1760003)'
- en: '[Forcing keyword-only arguments with the * separator](ch007_split_000.xhtml#x1-1820004)'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用*分隔符强制关键字参数](ch007_split_000.xhtml#x1-1820004)'
- en: '[Defining position-only parameters with the / separator](ch007_split_000.xhtml#x1-1880005)'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用/分隔符定义位置参数](ch007_split_000.xhtml#x1-1880005)'
- en: '[Picking an order for parameters based on partial functions](ch007_split_001.xhtml#x1-1940006)'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[根据部分函数选择参数顺序](ch007_split_001.xhtml#x1-1940006)'
- en: '[Writing clear documentation strings with RST markup](ch007_split_001.xhtml#x1-2030007)'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用RST标记编写清晰的文档字符串](ch007_split_001.xhtml#x1-2030007)'
- en: '[Designing recursive functions around Python’s stack limits](ch007_split_001.xhtml#x1-2090008)'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[围绕Python的堆限制设计递归函数](ch007_split_001.xhtml#x1-2090008)'
- en: '[Writing testable scripts with the script-library switch](ch007_split_001.xhtml#x1-2150009)'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用script-library开关编写可测试的脚本](ch007_split_001.xhtml#x1-2150009)'
- en: 3.1 Function parameters and type hints
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.1 函数参数和类型提示
- en: Through a number of Python Enhancement Proposals, type hints have grown in sophistication.
    The mypy tool is one way to validate these type hints to be sure the hints and
    the code agree. All the examples shown in this book have been checked with the
    mypy tool.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 通过多个Python增强提案，类型提示变得更加复杂。mypy工具是验证这些类型提示的一种方式，以确保提示和代码一致。本书中展示的所有示例都已通过mypy工具检查。
- en: This extra syntax for the hints is optional. It has limited use at runtime and
    has no performance costs.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这种额外的语法对于提示是可选的。它在运行时用途有限，并且没有性能开销。
- en: 3.1.1 Getting ready
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1.1 准备工作
- en: 'We’ll need to download and install the mypy tool. Generally, this is done with
    the following terminal command:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要下载并安装mypy工具。通常，这是通过以下终端命令完成的：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Using the python -m pip command ensures the pip command will be associated with
    the currently active virtual environment. In this example, the prompt shows a
    virtual environment named cookbook3.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 使用python -m pip命令确保pip命令将与当前活动的虚拟环境相关联。在这个例子中，提示显示了名为cookbook3的虚拟环境。
- en: We can also use the pyright tool to examine type hints.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用pyright工具来检查类型提示。
- en: 'For an example of type hints, we’ll look at some color computations. The first
    of these is extracting the Red, Green, and Blue values from the color codes commonly
    used in the style sheets for HTML pages. There are a variety of ways of encoding
    the values, including strings, integers, and tuples. Here are some of the varieties
    of data types:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，为了说明类型提示，我们将查看一些颜色计算。这些计算中的第一个是从在HTML页面样式表中常用颜色代码中提取红色、绿色和蓝色值。值的编码方式有很多种，包括字符串、整数和元组。以下是数据类型的一些变体：
- en: 'A string of six hexadecimal characters with a leading # , for example, "#C62D42"'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，一个以#开头的前导六位十六进制字符的字符串，如"#C62D42"
- en: A string of six hexadecimal characters, for example, "C62D42"
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个六位十六进制字符的字符串，例如，"C62D42"
- en: A Python numeric value, for example, 0xC62D42
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，一个Python数值，比如0xC62D42
- en: A three-tuple of R, G, and B integers, for example, (198, 45, 66)
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，一个包含 R, G 和 B 整数的三个元组，(198, 45, 66)
- en: For strings and numbers, we use the type name directly, str or int. For tuples,
    we use a more complicated-looking tuple[int, int, int].
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 对于字符串和数字，我们直接使用类型名称，str 或 int。对于元组，我们使用更复杂的看起来像 tuple[int, int, int]。
- en: 'The target is three integer values. A conversion from string or integer to
    three values involves two separate steps:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是三个整数值。从字符串或整数到三个值的转换涉及两个单独的步骤：
- en: If the value is a string, convert to a single integer using the int() function.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果值是字符串，则使用 int() 函数将其转换为单个整数。
- en: 'For single integer values, split the integer into three separate values using
    the >> and & operators. This is the core computation for converting a single integer
    value, hx_int, into three separate r, g, b values:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于单个整数值，使用 >> 和 & 运算符将整数拆分为三个单独的值。这是将单个整数值 hx_int 转换为三个单独的 r, g, b 值的核心计算：
- en: '[PRE1]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: A single RGB integer has three separate values that are combined via bit shifting.
    The red value was shifted left 16 bits. To extract this component, the value is
    shifted right 16 bits using the >> operator. The & operator applies 0xff as a
    ”mask” to save only 8 bits of a potentially larger number. To extract the green
    component, shift right 8 bits. The blue value occupies the least-significant 8
    bits.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一个单独的 RGB 整数有三个单独的值，这些值通过位移操作组合在一起。红色值左移了 16 位。为了提取这个组件，使用 >> 运算符将值右移 16 位。&
    运算符应用 0xff 作为“掩码”，仅保存可能更大的数字的 8 位。为了提取绿色组件，右移 8 位。蓝色值占据最低的有效 8 位。
- en: 3.1.2 How to do it...
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1.2 如何实现...
- en: 'For some functions, it can be easiest to start with a working implementation
    and add hints. Here’s how it works:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些函数，从工作实现开始并添加提示可能最简单。以下是它是如何工作的：
- en: 'Write the function without any hints:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不添加任何提示编写函数：
- en: '[PRE2]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Add the result hint. It’s based on the return statement. In this example, the
    return is a tuple of three integers, tuple[int, int, int].
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加结果提示。它基于返回语句。在这个例子中，返回是一个包含三个整数的元组，tuple[int, int, int]。
- en: 'Add the parameter hints. In this case, we’ve got two alternative types for
    the parameter: it can be a string or an integer. In the formal language of the
    type hints, this is a union of two types. The parameter can be described as Union[str, int]
    or str | int. If Union is used, the definition must be imported from the typing
    module.'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加参数提示。在这种情况下，我们有两个参数的替代类型：它可以是字符串或整数。在类型提示的正式语言中，这是两种类型的联合。参数可以描述为 Union[str,
    int] 或 str | int。如果使用 Union，则必须从 typing 模块导入定义。
- en: 'Combining the hints into a function leads to the following definition:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 将提示合并到一个函数中，得到以下定义：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 3.1.3 How it works...
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1.3 它是如何工作的...
- en: These type hints have no impact when the Python code is executed. The hints
    are designed for people to read and for external tools, like mypy, to verify.
    A tool can confirm that the hx_int variable is always used as either an integer
    or a string.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型提示在 Python 代码执行时没有影响。提示是为了让人阅读和供外部工具，如 mypy，验证。工具可以确认 hx_int 变量始终用作整数或字符串。
- en: In the r, g, b = assignment statement, the value for hx_int is expected to be
    an integer. The mypy tool can confirm the operators are appropriate for integer
    values, and the return type matches the computed types.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在 r, g, b = 赋值语句中，预期 hx_int 的值是一个整数。mypy 工具可以确认运算符适用于整数值，并且返回类型与计算类型匹配。
- en: We can observe the mypy tool’s analysis of a type by inserting the reveal_type(hx_int)
    function into our code. This statement has function-like syntax; it’s only used
    when running the mypy tool. We will only see output from this when we run mypy,
    and we have to remove this extra line of code before we try to do anything else
    with the module.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在代码中插入 reveal_type(hx_int) 函数来观察 mypy 工具对类型的分析。这个语句具有函数语法；它仅在运行 mypy 工具时使用。我们只有在运行
    mypy 时才会看到这个输出，我们必须在尝试对模块进行任何其他操作之前删除这额外的代码行。
- en: 'The output looks like this when we run mypy at the shell prompt on the recipe_01_reveal.py
    file:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在 recipe_01_reveal.py 文件上在 shell 提示符运行 mypy 时，输出看起来是这样的：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The output from the reveal_type(hx_int) line tells us mypy is certain the variable
    will have an integer value after the first if statement is complete. Once we’ve
    seen the revealed type information, we need to delete the reveal_type(hx_int)
    line from the file.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 从 reveal_type(hx_int) 行输出的结果告诉我们，mypy 确定在第一个 if 语句完成后，变量将具有整数值。一旦我们看到了揭示的类型信息，我们需要从文件中删除
    reveal_type(hx_int) 行。
- en: 3.1.4 There’s more...
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1.4 更多内容...
- en: 'Let’s look at a related computation. This converts RGB numbers into Hue-Saturation-Lightness
    (HSL) values. These HSL values can be used to compute complementary colors. An
    additional algorithm required to convert from HSL back into RGB values can help
    encode colors for a web page:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个相关的计算。这个计算将 RGB 数值转换为色调-饱和度-亮度 (HSL) 值。这些 HSL 值可以用来计算补色。一个额外的算法，将 HSL
    转换回 RGB 值，可以帮助为网页编码颜色：
- en: 'RGB to HSL: We’ll look at this closely because it has complex type hints.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RGB 到 HSL：我们将仔细研究这个，因为它有复杂的类型提示。
- en: 'HSL to complement: There are a number of theories on what the ”best” complement
    might be. We’ll gloss over the details.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HSL 补色：关于“最佳”补色可能存在多种理论。我们将略过这些细节。
- en: 'HSL to RGB: This will be the final step, but we’ll ignore the details of this
    computation.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HSL 到 RGB：这将是最后一步，但我们将忽略这个计算的细节。
- en: We won’t look closely at two of the implementations. They are not horribly complicated,
    but these computation details can be a distraction from understanding the types
    and type hints. See [https://www.easyrgb.com/en/math.php](https://www.easyrgb.com/en/math.php).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会仔细研究两个实现。它们并不特别复杂，但这些计算细节可能会分散对类型和类型提示的理解。请参阅 [https://www.easyrgb.com/en/math.php](https://www.easyrgb.com/en/math.php)。
- en: 'We start by roughing out a definition of the function with a stub definition,
    like this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过一个类似这样的存根定义来草拟函数的定义：`def function_name() -> return_type:`。
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This can help us visualize a number of related functions to be sure they all
    have consistent types. The other two functions have stubs like these:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以帮助我们可视化多个相关函数，以确保它们都具有一致的类型。其他两个函数有类似的存根：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'After writing down this initial list of stub definitions, we can see some type
    hints are repeated in slightly different contexts. This suggests we need to create
    a separate named type to avoid repetition of the details. We’ll provide a name
    for the repeated type detail:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在写下这个初始的存根定义列表之后，我们可以看到一些类型提示在略有不同的上下文中被重复。这表明我们需要创建一个单独的命名类型来避免重复细节。我们将为重复的类型细节提供一个名称：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This overview of the various functions can be helpful for assuring that each
    function uses data in a way that’s consistent with other functions.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 本概述中各种函数的介绍可以帮助确保每个函数使用数据的方式与其他函数保持一致。
- en: The names RGB_a and HSL_a include a suffix of _a to help distinguish these type
    aliases from other examples in this recipe. In a practical application, the suffix
    strings like _a to show the name is an alias are going to become visual clutter
    and should be avoided.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: RGB_a 和 HSL_a 名称包含一个后缀 _a 以帮助区分这些类型别名与这个食谱中的其他示例。在实际应用中，像 _a 这样的后缀字符串来显示名称是别名将会造成视觉上的杂乱，应该避免。
- en: 'As noted in the [Using NamedTuples to simplify item access in tuples](ch005_split_001.xhtml#x1-7500010)
    in Chapter [1](ch005_split_000.xhtml#x1-170001), we can provide a more descriptive
    set of names for these tuple types:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如第 [1](ch005_split_000.xhtml#x1-170001) 章中提到的 [使用 NamedTuples 简化元组中的项目访问](ch005_split_001.xhtml#x1-7500010)，我们可以为这些元组类型提供一组更具描述性的名称：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We’ve defined a unique, new NamedTuple subclass, called RGB. Using names can
    help clarify the intent behind the code.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个独特的新 NamedTuple 子类，称为 RGB。使用名称可以帮助阐明代码背后的意图。
- en: 3.1.5 See also
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1.5 参见
- en: The mypy project contains a wealth of information. See [https://mypy.readthedocs.io](https://mypy.readthedocs.io)
    for more information on the way type hints work.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: mypy 项目包含大量信息。有关类型提示如何工作的更多信息，请参阅 [https://mypy.readthedocs.io](https://mypy.readthedocs.io)。
- en: The pyright project is another helpful type hint tool. See [https://microsoft.github.io/pyright](https://microsoft.github.io/pyright)
    for more information.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: pyright 项目是另一个有用的类型提示工具。有关更多信息，请参阅 [https://microsoft.github.io/pyright](https://microsoft.github.io/pyright)。
- en: 3.2 Designing functions with optional parameters
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.2 设计具有可选参数的函数
- en: When we define a function, we often have a need for optional parameters. This
    allows us to write functions that are more flexible and easier to read.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们定义一个函数时，我们通常需要可选参数。这使我们能够编写更加灵活且易于阅读的函数。
- en: We can also think of this as a way to create a family of closely related functions.
    Each function has a slightly different collection of parameters – called the signature
    – but all sharing the same simple name. This is sometimes called an ”overloaded”
    function. Within the typing module, an @overload decorator can help create type
    hints in the more complicated cases.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以将其视为创建一组密切相关函数的方法。每个函数都有略微不同的参数集合——称为签名——但所有函数都共享相同的简单名称。这有时被称为“重载”函数。在类型模块中，@overload
    装饰器可以帮助在更复杂的情况下创建类型提示。
- en: 'An example of an optional parameter is the built-in int() function. This function
    has two signatures:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 可选参数的一个例子是内置的 `int()` 函数。此函数有两个签名：
- en: int(str) -> int. For example, the value of int(’355’) has a value of 355\. An
    optional base parameter defaults to a value of 10.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int(str)` -> `int`。例如，`int(''355'')` 的值为 355。可选的基数参数默认值为 10。'
- en: int(str, base) -> int. For example, the value of int(’163’, 16) is 355\. In
    this case, the base parameter value is 16.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int(str, base)` -> `int`。例如，`int(''163'', 16)` 的值为 355。在这种情况下，基数参数的值是 16。'
- en: 3.2.1 Getting ready
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2.1 准备工作
- en: A great many games rely on collections of dice. The casino game of Craps uses
    two dice. A game like Zonk (or Greed or Ten Thousand) uses six dice. It’s handy
    to have a dice-rolling function that can handle all of these variations.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 许多游戏依赖于骰子集合。赌场游戏 Craps 使用两个骰子。像 Zonk（或贪婪或一万）这样的游戏使用六个骰子。有一个可以处理所有这些变化的掷骰子函数是很有用的。
- en: 3.2.2 How to do it...
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2.2 如何操作...
- en: 'We have two approaches to designing a function with optional parameters:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两种设计具有可选参数的函数的方法：
- en: 'General to particular: Start by designing the most general solution and provide
    defaults for the most common case.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从一般到特殊：首先设计最通用的解决方案，并为最常见的情况提供默认值。
- en: 'Particular to general: Start by designing several related functions. We then
    merge them into one general function that covers all of the cases, singling out
    one of the original functions to be the default behavior.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特殊到一般：首先设计几个相关的函数。然后我们将它们合并成一个通用的函数，该函数涵盖所有情况，并特别指定一个原始函数作为默认行为。
- en: We’ll look at the particular to general approach first, because it’s often easier
    to start with a number of concrete examples.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先探讨从特殊到一般的方法，因为这通常更容易从一个具体例子开始。
- en: Particular to general design
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 特殊到一般设计
- en: 'Throughout this example, we’ll use slightly different names as the function
    evolves. This simplifies unit testing the different versions and comparing them.
    Here’s how we’ll proceed:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个示例中，我们将使用略有不同的名称，因为函数在演变过程中。这简化了不同版本的单元测试和比较。我们将这样进行：
- en: 'Write one game function. We’ll start with the Craps game because it seems to
    be the simplest:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个游戏函数。我们将从 Craps 游戏开始，因为它似乎是最简单的：
- en: '[PRE13]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We defined a function, die(), to encapsulate a basic fact about standard dice.
    Five platonic solids are often used, yielding four-sided, six-sided, eight-sided,
    twelve-sided, and twenty-sided dice. The randint() expression assumes a six-sided
    cube.
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们定义了一个函数，`die()`，来封装有关标准骰子的一个基本事实。通常使用五个柏拉图立体，产生四面体、六面体、八面体、十二面体和二十面体骰子。`randint()`
    表达式假设是一个六面的立方体。
- en: 'Write the next game function. We’ll move on to the Zonk game:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写下一个游戏函数。我们将继续到 Zonk 游戏：
- en: '[PRE14]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We’ve used a generator expression to create a tuple object with a collection
    of six dice. We’ll look at generator expressions in depth in Chapter [9](ch013_split_000.xhtml#x1-5020009).
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用生成器表达式创建了一个包含六个骰子的元组对象。我们将在第 [9](ch013_split_000.xhtml#x1-5020009) 章节中深入探讨生成器表达式。
- en: The generator expression in the body of the zonk() function has a variable,
    x, which is required syntax, but the value is ignored. It’s also common to see
    this written as tuple(die() for _ in range(6)). The variable _ is a valid Python
    variable name, often used when a variable name is required, but is never used.
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: zonk() 函数体内的生成器表达式有一个变量 x，这是必需的语法，但该值被忽略。这也常见于写作 `tuple(die() for _ in range(6))`。变量
    _ 是一个有效的 Python 变量名，通常在需要变量名但从未使用时使用。
- en: 'Locate the common features in the craps() and zonk() functions. In this case,
    we can refactor the design of the craps() function to follow the pattern set by
    the zonk() function. Rather than building exactly two evaluations of the die()
    function, we can introduce a generator expression based on range(2) that will
    evaluate the die() function twice:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定位 craps() 和 zonk() 函数中的共同特征。在这种情况下，我们可以重构 craps() 函数的设计，使其遵循 zonk() 函数的模式。而不是构建
    exactly two evaluations of the die() 函数，我们可以引入一个基于 range(2) 的生成器表达式，该表达式将评估 die()
    函数两次：
- en: '[PRE15]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Merge the two functions. This will often involve exposing a variable that had
    previously been a literal value:'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 合并两个函数。这通常涉及暴露之前是字面值的变量：
- en: '[PRE16]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This provides a general function that covers the needs of both the Craps and
    Zonk games.
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这提供了一个通用的函数，涵盖了 Craps 和 Zonk 游戏的需求。
- en: 'Identify the most common use case and make this the default value for any parameters
    that were introduced. If our most common simulation was Craps, we might do this:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 识别最常见的使用情况，并将此作为任何引入的参数的默认值。如果我们最常见的模拟是 Craps，我们可能会这样做：
- en: '[PRE17]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now, we can use dice_v3() for the Craps game. We’ll need to use the expression
    dice_v3(6) for the first roll of a Zonk game.
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们可以使用 dice_v3() 来玩 Craps 游戏。在 Zonk 游戏的第一轮中，我们需要使用表达式 dice_v3(6)。
- en: Check the type hints to be sure they describe the parameters and the return
    values. In this case, we have one parameter with an integer value, and the return
    is a tuple of integers, described by tuple[int, ...].
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查类型提示以确保它们描述了参数和返回值。在这种情况下，我们有一个整数值的参数，返回值是一个整数元组，描述为 tuple[int, ...]。
- en: Throughout this example, the name evolved from dice() to dice_v2() and then
    to dice_v3(). This can make it easier to see the differences here in the recipe.
    Once a final version is written, it makes sense to delete the others and rename
    the final versions of these functions to dice(), craps(), and zonk(). The story
    of their evolution may become a blog post, but it doesn’t need to be preserved
    in the code.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个示例中，名称从 dice() 发展到 dice_v2()，然后到 dice_v3()。这可以使得在菜谱中更容易看到差异。一旦编写了最终版本，删除其他版本并将这些函数的最终版本重命名为
    dice()、craps() 和 zonk() 是有意义的。它们演变的历程可能成为一篇博客文章，但不需要保留在代码中。
- en: General to particular design
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从一般到特殊的设计
- en: 'When following the general to particular strategy, we’ll identify all of the
    needs first. It can be difficult to foresee all the alternatives, making this
    more challenging. We’ll often do this by introducing variables to the requirements:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在遵循从一般到特殊策略时，我们首先确定所有需求。预见所有替代方案可能很困难，这使得这个任务更具挑战性。我们通常会通过向需求中引入变量来完成这项工作：
- en: 'Summarize the requirements for dice-rolling. We might start with a list like
    this:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 总结掷骰子需求。我们可能从如下列表开始：
- en: 'Craps: Two dice'
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Craps：两个骰子
- en: 'First roll in Zonk: Six dice'
  id: totrans-109
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Zonk 的第一轮：六个骰子
- en: 'Subsequent rolls in Zonk: One to six dice'
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Zonk 的后续轮次：一到六个骰子
- en: Rewrite the requirements with an explicit parameter in place of any literal
    value. We’ll replace all of our numbers with a parameter, n. This will take on
    values of 2, 6, or a value in the range 1 ≤ n ≤ 6\. We want to be sure we’ve properly
    parameterized each of the various functions.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用显式参数替换任何字面值重写需求。我们将用参数 n 替换我们所有的数字。这个参数将取值为 2、6 或 1 ≤ n ≤ 6 范围内的值。我们想确保我们已经正确地参数化了每个不同的函数。
- en: 'Write the function that fits the general pattern:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写符合一般模式的函数：
- en: '[PRE18]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the third case – subsequent rolls in Zonk – we identified a constraint of
    1 ≤ n ≤ 6, imposed by the application program to play Zonk.
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第三种情况——Zonk 的后续轮次——中，我们确定了一个由应用程序在玩 Zonk 时施加的约束 1 ≤ n ≤ 6。
- en: 'Provide a default value for the most common use case. If our most common simulation
    was Craps, we might do this:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为最常见的用例提供一个默认值。如果我们最常见的模拟是骰子游戏 Craps，我们可能会这样做：
- en: '[PRE19]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Add type hints. These will describe the parameters and the return values. In
    this case, we have one parameter with an integer value, and the return is a tuple
    of integers, described by tuple[int, ...]:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加类型提示。这些将描述参数和返回值。在这种情况下，我们有一个整数值的参数，返回值是一个整数元组，描述为 tuple[int, ...]：
- en: '[PRE20]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now, we can use this dice() function for Craps. We’ll need to use dice(6) for
    the first roll in Zonk.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用这个 dice() 函数来玩 Craps。在 Zonk 的第一轮中，我们需要使用 dice(6)。
- en: In this recipe, the name didn’t need to evolve through multiple versions. The
    name evolution is only useful in a book for unit testing each example.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，名称不需要通过多个版本演变。名称演变只在书中对单元测试每个示例有用。
- en: This version looks precisely like dice_v2() from the previous recipe. This isn’t
    an accident – the two design strategies often converge on a common solution.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本看起来与之前菜谱中的 dice_v2() 函数完全一样。这不是偶然的——两种设计策略通常会在一个共同解决方案上汇聚。
- en: 3.2.3 How it works...
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2.3 它是如何工作的...
- en: 'Python’s rules for providing parameter values enable several ways to ensure
    that each parameter is given an argument value. We can think of the process like
    this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Python 提供参数值的规则允许确保每个参数都给出了一个参数值。我们可以将这个过程想象成这样：
- en: Where there are default values, set those parameters. Default values make these
    optional.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在存在默认值的地方，设置这些参数。默认值使这些参数成为可选的。
- en: For arguments without names – for example, dice(2) – the argument values are
    assigned to the parameters by position.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于没有名称的参数——例如，dice(2)——参数值按位置分配给参数。
- en: For arguments with names – for example, dice(n=2) – the argument values are
    assigned to parameters by name.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于具有名称的参数——例如，dice(n=2)——参数值按名称分配给参数。
- en: If any parameter still lacks a value, raise a TypeError exception.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果任何参数仍然缺少值，则引发 TypeError 异常。
- en: The rules also allow us to mix positional values with named values. This make
    some parameters optional by providing a default value.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 规则还允许我们将位置值与命名值混合。这通过提供默认值使一些参数成为可选的。
- en: 3.2.4 There’s more...
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2.4 更多...
- en: 'It helps to write functions that are specialized versions of our more generalized
    function. These functions can simplify an application:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 写出我们更通用函数的专用版本有助于编写函数。这些函数可以简化应用程序：
- en: '[PRE21]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Our application features – craps_v3() and zonk_v3() – depend on a general function,
    dice().
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序功能 - craps_v3() 和 zonk_v3() - 依赖于一个通用函数，dice()。
- en: These form layers of dependencies, saving us from having to understand too many
    details. This idea of layered abstractions is sometimes called chunking, a way
    of managing complexity by isolating the details.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这些形成了依赖层，使我们不必了解太多细节。这种分层抽象的想法有时被称为分块，是一种通过隔离细节来管理复杂性的方法。
- en: 3.2.5 See also
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2.5 参考以下内容
- en: We’ll extend on some of these ideas in the [Picking an order for parameters
    based on partial functions](ch007_split_001.xhtml#x1-1940006) recipe, later in
    this chapter.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将在本章后面的[基于部分函数选择参数顺序](ch007_split_001.xhtml#x1-1940006)食谱中扩展这些想法。
- en: We’ve made use of optional parameters that involve immutable objects. In this
    recipe, we focused on numbers. In Chapter [4](ch008_split_000.xhtml#x1-2240004),
    we’ll look at mutable objects, which have an internal state that can be changed.
    In the [Avoiding mutable default values for function parameters](ch009.xhtml#x1-3210006)
    recipe, we’ll look at some additional considerations for optional values.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经使用了涉及不可变对象的可选参数。在本食谱中，我们专注于数字。在第[4](ch008_split_000.xhtml#x1-2240004)章中，我们将探讨可变对象，它们具有可以更改的内部状态。在[避免为函数参数使用可变默认值](ch009.xhtml#x1-3210006)食谱中，我们将探讨可选值的额外考虑。
- en: 3.3 Using super flexible keyword parameters
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.3 使用超级灵活的关键字参数
- en: Some design problems involve solving a simple equation for one unknown when
    given enough known values. For example, rate, time, and distance have a simple
    linear relationship. We can solve for any one when given the other two.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一些设计问题涉及在给出足够已知值时求解一个未知数的简单方程。例如，速率、时间和距离有一个简单的线性关系。我们可以求解任何一个，当给出其他两个时。
- en: 'There are three related solutions to r × t = d:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个与 r × t = d 相关的解：
- en: '![d = r × t ](img/file14.png)'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_IMG
  zh: '![d = r × t ](img/file14.png)'
- en: '![r = dt ](img/file15.png)'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_IMG
  zh: '![r = dt ](img/file15.png)'
- en: '![ d t = r ](img/file16.png)'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_IMG
  zh: '![ d t = r ](img/file16.png)'
- en: When designing electrical circuits, for example, a similar set of equations
    is used based on Ohm’s law. In that case, the equations tie together resistance,
    current, and voltage.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在设计电路时，基于欧姆定律使用一组类似的方程。在这种情况下，方程将电阻、电流和电压联系起来。
- en: In some cases, we want an implementation that can perform any of the three different
    calculations based on what’s known and what’s unknown.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们希望有一个可以根据已知和未知的内容执行三种不同计算的实施方案。
- en: 3.3.1 Getting ready
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3.1 准备工作
- en: We’ll build a single function that can solve a Rate-Time-Distance (RTD) calculation
    by embodying all three solutions, given any two known values. With minor variable
    name changes, this applies to a surprising number of real-world problems.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个单一的功能，通过体现所有三种解决方案，可以解决任何两个已知值的速率-时间-距离（RTD）计算。通过微小的变量名更改，这适用于许多现实世界的问题。
- en: We don’t necessarily want a single value as an answer. We can slightly generalize
    this by creating a small Python dictionary with the three values in it; two are
    given, one is computed. We’ll look at dictionaries in more detail in Chapter [5](ch009.xhtml#x1-2890005).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不一定需要一个单一的值作为答案。我们可以通过创建一个包含三个值的Python小字典来稍微泛化这一点；其中两个是已给出的，一个是计算得出的。我们将在第[5](ch009.xhtml#x1-2890005)章中更详细地探讨字典。
- en: 'We’ll use the warnings module instead of raising an exception when there’s
    a problem:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当有问题时，我们将使用警告模块而不是引发异常：
- en: '[PRE22]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Sometimes, it is more helpful to produce a result that is doubtful than to stop
    processing.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，产生一个可疑的结果比停止处理更有帮助。
- en: 3.3.2 How to do it...
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3.2 如何实现...
- en: 'Solve the equation for each of the unknowns. There are three separate expressions:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为每个未知数求解方程。有三个单独的表达式：
- en: distance = rate * time
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: distance = rate * time
- en: rate = distance / time
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: rate = distance / time
- en: time = distance / rate
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: time = distance / rate
- en: 'Wrap each expression in an if statement based on one of the values being None
    when it’s unknown:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据其中一个值在未知时为None的条件，将每个表达式包裹在一个if语句中：
- en: '[PRE23]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Refer to the [Designing complex if...elif chains](ch006_split_000.xhtml#x1-1170005)
    recipe from Chapter [2](ch006_split_000.xhtml#x1-840002), for guidance on designing
    these complex if...elif chains. Include a variation of the Else-Raise option:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请参考第[2](ch006_split_000.xhtml#x1-840002)章的[设计复杂的if...elif链](ch006_split_000.xhtml#x1-1170005)配方，以获取设计这些复杂if...elif链的指导。包括Else-Raise选项的变体：
- en: '[PRE24]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Build the resulting dictionary object:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建最终的字典对象：
- en: '[PRE25]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Wrap all of this as a function using keyword parameters with default values
    of None. This leads to parameter types of Optional[float], often stated as float | None.
    The return type is a dictionary with string keys, summarized as dict[str, float | None].
    It looks like this:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用具有默认值None的关键字参数将所有这些封装成一个函数。这导致参数类型为Optional[float]，通常表示为float | None。返回类型是一个具有字符串键的字典，总结为dict[str,
    float | None]。它看起来像这样：
- en: '[PRE26]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The type hints tend to make the function definition so long it has to be spread
    across five physical lines of code. The presence of so many optional values is
    difficult to summarize!
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 类型提示往往会使函数定义变得非常长，以至于不得不跨越五行代码。这么多可选值的呈现很难总结！
- en: 'We can use the resulting function like this:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样使用生成的函数：
- en: '[PRE27]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This shows us that going 31.2 nautical miles at a rate of 6 knots will take
    5.2 hours.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明以6节的速度航行31.2海里需要5.2小时。
- en: 'For a nicely formatted output, we might do this:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 为了得到格式良好的输出，我们可能这样做：
- en: '[PRE28]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: To break up the long string, we used our knowledge from the [Designing complex
    if...elif chains](ch006_split_000.xhtml#x1-1170005) recipe in Chapter [2](ch006_split_000.xhtml#x1-840002).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 为了打断长字符串，我们使用了第[2](ch006_split_000.xhtml#x1-840002)章的[设计复杂的if...elif链](ch006_split_000.xhtml#x1-1170005)配方中的知识。
- en: To make the warning more visible, the warnings module can be used to set a filter
    that elevates the warning to an error. Use the expression warnings.simplefilter(’error’)
    to transform warnings into visible exceptions.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使警告更加明显，可以使用警告模块设置一个过滤器，将警告提升为错误。使用表达式 `warnings.simplefilter('error')` 将警告转换为可见的异常。
- en: 3.3.3 How it works...
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3.3 它是如何工作的...
- en: Because we’ve provided default values for all of the parameters, we can provide
    argument values for any two of the three parameters, and the function can then
    solve for the third parameter. This saves us from having to write three separate
    functions.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经为所有参数提供了默认值，因此我们可以为三个参数中的任意两个提供参数值，然后函数可以求解第三个参数。这使我们不必编写三个单独的函数。
- en: Returning a dictionary as the final result isn’t essential to this. It’s a handy
    way to show inputs and outputs. It allows the function to return a uniform result,
    no matter which parameter values were provided.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 返回字典作为最终结果并不是这个问题的关键。这是一个方便的方式来展示输入和输出。它允许函数返回统一的结果，无论提供了哪些参数值。
- en: 3.3.4 There’s more...
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3.4 更多...
- en: We have an alternative formulation for this, one that involves more flexibility.
    Python functions have an all other keywords parameter, prefixed with **.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有这个问题的另一种公式，它涉及更多的灵活性。Python函数有一个所有其他关键字参数，前缀为**。
- en: 'We can leverage the flexible keywords parameter and insist that all arguments
    be provided as keywords:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用灵活的关键字参数并坚持要求所有参数都作为关键字提供：
- en: '[PRE29]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The keywords type hint states that all of the values for these parameters will
    be float objects. In some rare case, not all of the keyword parameters are the
    same type; in this case, some redesign may be helpful to make the types clearer.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字类型提示表明，这些参数的所有值都将为float对象。在极少数情况下，不是所有关键字参数的类型都相同；在这种情况下，一些重新设计可能有助于使类型更清晰。
- en: This version uses the dictionary get() method to find a given key in the dictionary.
    If the key is not present, a default value of None is provided.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本使用字典的get()方法在字典中查找给定的键。如果键不存在，则提供一个默认值None。
- en: The dictionary’s get() method permits a second parameter, the default, which
    can be provided instead of None if the key is not present.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 字典的get()方法允许第二个参数，即默认值，如果键不存在，则可以提供而不是None。
- en: This kind of open-ended design has the potential advantage of being much more
    flexible. One potential disadvantage is that the actual parameter names are hard
    to discern, since they’re not part of the function definition, but instead part
    of the function’s body. We can follow the [Writing better docstrings with RST
    markup](ch006_split_000.xhtml#x1-1090004) recipe and provide a good docstring.
    It seems much better, though, to provide the parameter names explicitly as part
    of the Python code rather than implicitly through documentation.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这种开放式设计具有更大的灵活性，这是一个潜在的优势。一个潜在的缺点是，实际的参数名称难以辨认，因为它们不是函数定义的一部分，而是函数体的一部分。我们可以遵循[Writing
    better docstrings with RST markup](ch006_split_000.xhtml#x1-1090004)配方并提供一个好的文档字符串。然而，似乎更好的做法是将参数名称明确地作为Python代码的一部分提供，而不是通过文档隐式地提供。
- en: 'This has another, and more profound, disadvantage. The problem is revealed
    in the following bad example:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这还有另一个，并且更加深远的缺点。问题在以下不良示例中暴露出来：
- en: '[PRE30]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This isn’t the behavior we want. The misspelling of ”distance” is not reported
    as a TypeError exception. The misspelled parameter name is not reported anywhere.
    To uncover these errors, we’d need to add some programming to pop items from the
    keywords dictionary and report errors on names that remain after the expected
    names were removed:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是我们想要的行为。拼写错误的“distance”没有被报告为TypeError异常。拼写错误的参数名称在任何地方都没有被报告。为了揭示这些错误，我们需要添加一些编程来从关键字字典中弹出项目，并在移除预期名称后报告剩余名称的错误：
- en: '[PRE31]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This design will spot spelling errors. The extra processing suggests explicit
    parameter names might be better than the flexibility of an unbounded collection
    of names.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计将检测拼写错误。额外的处理表明，显式参数名称可能比无限制名称集合的灵活性更好。
- en: 3.3.5 See also
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3.5 参考信息
- en: We look at the documentation of functions in the [Writing better docstrings
    with RST markup](ch006_split_000.xhtml#x1-1090004) recipe in Chapter [2](ch006_split_000.xhtml#x1-840002).
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们查看第[2](ch006_split_000.xhtml#x1-840002)章中[Writing better docstrings with RST
    markup](ch006_split_000.xhtml#x1-1090004)配方中函数的文档。
- en: 3.4 Forcing keyword-only arguments with the * separator
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.4 使用*分隔符强制关键字参数
- en: There are some situations where we have a large number of positional parameters
    for a function. Pragmatically, a function with more than about three parameters
    can be confusing. A great deal of conventional mathematics seems to focus on one-
    and two-parameter functions. There don’t seem to be too many common mathematical
    operators that involve three or more operands.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些情况下，一个函数会有大量的位置参数。从实用主义的角度来看，具有三个以上参数的函数可能会让人困惑。大量的传统数学似乎都集中在单参数和双参数函数上。似乎没有太多常见的数学运算符涉及三个或更多操作数。
- en: When it gets difficult to remember the required order for the parameters, this
    suggests there are too many parameters.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当难以记住参数的所需顺序时，这表明参数太多。
- en: 3.4.1 Getting ready
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.4.1 准备工作
- en: We’ll look at a function to prepare a wind-chill table and write the data to
    a CSV format output file. We need to provide a range of temperatures, a range
    of wind speeds, and information on the file we’d like to create. This is a lot
    of parameters.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将查看一个用于准备风寒表并写入CSV格式输出文件的函数。我们需要提供一系列温度、一系列风速以及我们想要创建的文件信息。这有很多参数。
- en: 'One formula for the apparent temperature, the wind chill, T[wc], is this:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 显然温度，即风寒温度，T[wc]，的一个公式是：
- en: '![Twc(Ta,V ) = 13.2 + 0.6215Ta − 11.37V 0.16 + 0.3965TaV 0.16 ](img/file17.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![Twc(Ta,V ) = 13.2 + 0.6215Ta − 11.37V 0.16 + 0.3965TaV 0.16 ](img/file17.png)'
- en: The wind chill temperature, ![Twc ](img/file18.png), is based on the air temperature,
    ![Ta ](img/file19.png), in degrees C, and the wind speed, ![V ](img/file20.png),
    in KPH.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 风寒温度，![Twc ](img/file18.png)，基于空气温度，![Ta ](img/file19.png)，以摄氏度为单位，以及风速，![V
    ](img/file20.png)，以公里每小时为单位。
- en: 'For Americans, this requires some conversions:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 对于美国人来说，这需要一些转换：
- en: 'Convert the temperature, ![Ta ](img/file21.png), from Farenheit, ![∘F ](img/file22.png),
    into Celsius, ![∘C ](img/file23.png): ![T = 5(F−-32)- a 9 ](img/file24.png).'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将温度，![Ta ](img/file21.png)，从华氏度，![∘F ](img/file22.png)，转换为摄氏度，![∘C ](img/file23.png)：![T
    = 5(F−-32)- a 9 ](img/file24.png)。
- en: 'Convert windspeed, ![V ](img/file25.png), from MPH, ![Vmph ](img/file26.png),
    into KPH: ![V = 1.609344Vmph ](img/file27.png).'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将风速，![V ](img/file25.png)，从英里每小时，![Vmph ](img/file26.png)，转换为公里每小时：![V = 1.609344Vmph
    ](img/file27.png)。
- en: 'The result, ![Twc ](img/file28.png), needs to be converted from ![∘C ](img/file29.png)
    back to ![∘F ](img/file30.png): ![ 9Twc- F = 32+ 5 ](img/file31.png).'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结果，![Twc ](img/file28.png)，需要从![∘C ](img/file29.png)转换回![∘F ](img/file30.png)：![
    9Twc- F = 32+ 5 ](img/file31.png)。
- en: We won’t fold these American conversions into the solution. We’ll leave this
    as an exercise for you.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会将这些美国转换折叠到解决方案中。我们将把这留给你作为练习。
- en: 'The function to compute the wind-chill temperature, T_wc() looks like this:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 计算风寒温度的函数，T_wc()，看起来像这样：
- en: '[PRE32]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This function has an unusual name, T_wc(). We’ve matched the formal definition
    of T[wc], rather than enforcing the PEP-8 rule of beginning function names with
    a lowercase letter. In this case, it seems better to stick with names used in
    the literature, rather than imposing a name based on language conventions.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数有一个不寻常的名字，T_wc()。我们匹配了 T[wc] 的正式定义，而不是强制执行 PEP-8 规则，即函数名以小写字母开头。在这种情况下，似乎坚持使用文献中使用的名称，而不是基于语言习惯强加名称会更好。
- en: 'One approach to creating a wind-chill table is to create something like this:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 创建风寒表的 一种方法 是创建如下所示的东西：
- en: '[PRE33]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Before we get to the design problem, let’s look at the essential processing.
    We expect the function using this will have opened an output file using the with
    context. This follows the [Managing a context using the with statement](ch006_split_001.xhtml#x1-15200011)
    recipe in Chapter [2](ch006_split_000.xhtml#x1-840002). Within this context, we’ve
    created a write for the CSV output file. We look at this in more depth in Chapter [11](ch015_split_000.xhtml#x1-61500011).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们到达设计问题之前，让我们看看基本处理。我们期望使用此函数的人已经使用 with 上下文打开了一个输出文件。这遵循了第 [2](ch006_split_000.xhtml#x1-840002)
    章中 [Managing a context using the with statement](ch006_split_001.xhtml#x1-15200011)
    的配方。在这个上下文中，我们为 CSV 输出文件创建了一个写入。我们将在第 [11](ch015_split_000.xhtml#x1-61500011)
    章中更深入地探讨这一点。
- en: The value for the heading variable includes a list literal and a comprehension
    that builds a list. We look at lists in Chapter [4](ch008_split_000.xhtml#x1-2240004).
    We look at comprehensions and generator expressions in Chapter [9](ch013_split_000.xhtml#x1-5020009).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 标题变量的值包括一个列表字面量和构建列表的推导式。我们将在第 [4](ch008_split_000.xhtml#x1-2240004) 章中探讨列表。我们将在第
    [9](ch013_split_000.xhtml#x1-5020009) 章中探讨推导式和生成器表达式。
- en: Similarly, each row of the table is built by an expression that combines a single
    float value with a list comprehension. The list consists of values computed by
    the wind-chill function, T_wc(). We provide the wind velocity, V, based on the
    row in the table. We also provide a temperature, T, based on the column in the
    table.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，表格的每一行都是由一个表达式构建的，该表达式将单个浮点值与列表推导式相结合。列表由通过 wind-chill 函数，T_wc() 计算的值组成。我们根据表格中的行提供风速，V。我们还根据表格中的列提供温度，T。
- en: 'The wind_chill() function’s overall definition presents a problem: the wind_chill()
    function has seven distinct positional parameters. When we try to use this function,
    we wind up with code like the following:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: wind_chill() 函数的整体定义提出了一个问题：wind_chill() 函数有七个不同的位置参数。当我们尝试使用这个函数时，我们最终得到如下代码：
- en: '[PRE34]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: What are all those numbers? Is there something we can do to help explain the
    purposes behind all those numbers?
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些数字是什么？我们能做些什么来帮助解释所有这些数字背后的目的？
- en: 3.4.2 How to do it...
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.4.2 如何做到...
- en: When we have a large number of parameters, it helps to require the use of keyword
    arguments instead of positional arguments. We can use the * as a separator between
    two groups of parameters.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们拥有大量参数时，要求使用关键字参数而不是位置参数是有帮助的。我们可以在两组参数之间使用 * 作为分隔符。
- en: 'For our example, the resulting function definition has the following stub definition:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，结果函数定义具有以下存根定义：
- en: '[PRE35]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Let’s see how it works in practice with different kinds of parameters:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它在实践中如何使用不同类型的参数：
- en: 'When we try to use the confusing positional parameters, we’ll see this:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们尝试使用令人困惑的位置参数时，我们会看到如下情况：
- en: '[PRE36]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We must use the function with explicit parameter names, as follows:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须使用具有显式参数名称的函数，如下所示：
- en: '[PRE37]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This use of mandatory keyword parameters forces us to write a longer, but clearer,
    statement each time we use this complicated-seeming function.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这种强制使用关键字参数的使用迫使我们每次使用这个看似复杂的函数时都要写一个更长但更清晰的语句。
- en: 3.4.3 How it works...
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.4.3 它是如何工作的...
- en: 'The * character, when used as a parameter definition, separates two collections
    of parameters:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 当 * 字符用作参数定义时，它将两个参数集合分开：
- en: Before *, we list the argument values that can be either positional or named
    by keyword. In this example, we don’t have any of these parameters.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 * 之前，我们列出可以按位置或按关键字命名的参数值。在这个例子中，我们没有这些参数。
- en: After *, we list the argument values that must be given with a keyword. For
    our example, this is all of the parameters.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 * 之后，我们列出必须用关键字给出的参数值。在我们的例子中，这是所有参数。
- en: The print() function exemplifies this. It has three keyword-only parameters
    for the output file, the field separator string, and the line end string.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: 3.4.4 There’s more...
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can, of course, combine this technique with default values for the various
    parameters. We might, for example, make a change to this, thus introducing a single
    default value:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We can now use this function in two ways:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a way to print the table on the console, using the default target:'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Here’s a way to write to a file using an explicit target:'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We can be more confident in these changes because the parameters must be provided
    by name. We don’t have to check carefully to be sure about the order of the parameters.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: As a general pattern, we suggest doing this when there are more than three parameters
    for a function. It’s easy to remember one or two. Most mathematical operators
    are unary or binary. While a third parameter may still be easy to remember, the
    fourth (and subsequent) parameter will become very difficult to recall.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: 3.4.5 See also
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See the [Picking an order for parameters based on partial functions](ch007_split_001.xhtml#x1-1940006)
    recipe for another application of this technique.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 3.5 Defining position-only parameters with the / separator
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can use the / character in the parameter list to separate the parameters
    into two groups. Before /, all argument values work positionally. After the /
    parameter, argument values may be given positionally, or names may be used.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 'This should be used for functions where the following conditions are all true:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: A few positional parameters are used (no more than three).
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And they are all required.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And the order is so obvious that any change might be confusing.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This has always been a feature of the standard library. As an example, the
    math.sin() function can only use positional parameters. The formal definition
    is as follows:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Even though there’s an x parameter name, we can’t use this name. If we try
    to, we’ll see the following exception:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The x parameter can only be provided positionally. The output from the help()
    function provides a suggestion of how the / separator can be used to make this
    happen.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: 3.5.1 Getting ready
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Position-only parameters are used by some of the internal built-ins; the design
    pattern can also be helpful, though, in our functions. To be useful, there must
    be very few position-only parameters. Since most mathematical operators have one
    or two operands, this suggests one or two position-only parameters can be useful.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll consider two functions for conversion of units from the Fahrenheit system
    used in the US and the Centigrade system used almost everywhere else in the world:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: 'Convert from ![∘ F ](img/file32.png) into ![∘ C ](img/file33.png): ![ 5(F−32)
    C = ---9--- ](img/file34.png)'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Convert from ![∘C ](img/file35.png) into ![∘F ](img/file36.png): ![F = 32 +
    9C- 5 ](img/file37.png)'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of these functions has a single argument, making it a reasonable example
    for a position-only parameter.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: 3.5.2 How to do it...
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Define the function:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义函数：
- en: '[PRE43]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Add the / parameter separator after the position-only parameters:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在仅位置参数之后添加/参数分隔符：
- en: '[PRE44]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: For these examples, we put a _1 and _2 suffixes on the function names to make
    it clear which definition goes with each step of the recipe. These are two versions
    of the same function, and they should have the same name. They’re separated to
    show the history of writing the functions; this is not a practical naming convention
    except when writing a book where some partially complete functions have their
    own unit tests.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些例子中，我们在函数名称后加上_1和_2后缀，以便清楚地说明每个步骤对应的定义。这是同一函数的两个版本，它们应该有相同的名称。它们被分开以展示函数编写的历史；这并不是一个实用的命名约定，除非在写书时，一些部分完成的函数有自己的单元测试。
- en: 3.5.3 How it works...
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.5.3 它是如何工作的...
- en: 'The / separator divides the parameter names into two groups. In front of /
    are parameters where the argument values must be provided positionally: named
    argument values cannot be used. After the / are parameters where names are permitted.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: /分隔符将参数名称分为两组。在/之前是必须按位置提供参数值的参数：不能使用命名参数值。在/之后是允许使用名称的参数。
- en: 'Let’s look at a slightly more complex version of our temperature conversions:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看温度转换的一个稍微复杂一点的版本：
- en: '[PRE45]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This function has a position-only parameter named f. It also has the truncate
    parameter, which can be provided by name. This leads to three separate ways to
    use this function, as shown in the following examples:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数有一个名为f的仅位置参数。它还有一个截断参数，可以通过名称提供。这导致有三种使用此函数的不同方式，如下面的例子所示：
- en: '[PRE46]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The first example shows the position-only parameter and the output without any
    rounding. This is an awkwardly complex-looking value.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个例子显示了仅位置参数和没有四舍五入的输出。这是一个看起来复杂的价值。
- en: The second example uses the named parameter style to set the non-positional
    parameter, truncate, to True. The third example provides both argument values
    positionally.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个例子使用命名参数样式将非位置参数截断设置为True。第三个例子提供了两种参数值的位置。
- en: 3.5.4 There’s more...
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.5.4 更多内容...
- en: 'This can be combined with the * separator to create very sophisticated function
    signatures. The parameters can be decomposed into three groups:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以与*分隔符结合，创建非常复杂的函数签名。参数可以分解为三组：
- en: Parameters before the / separator must be given by position. These must be first.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: /分隔符之前的参数必须按位置提供。这些必须是第一个。
- en: Parameters after the / separator can be given by position or name.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: /分隔符之后的参数可以通过位置或名称提供。
- en: Parameters after the * separator must be given by name only. These names are
    provided last, since they can never be matched by position.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*分隔符之后的参数必须只按名称提供。这些名称是最后提供的，因为它们永远不会按位置匹配。'
- en: 3.5.5 See also
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.5.5 参考内容
- en: See the [Forcing keyword-only arguments with the * separator](ch007_split_000.xhtml#x1-1820004)
    recipe for details on the * separator.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关*分隔符的详细信息，请参阅[使用*分隔符强制关键字参数](ch007_split_000.xhtml#x1-1820004)的配方。
- en: 3.6 Picking an order for parameters based on partial functions
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.6 基于部分函数选择参数顺序
- en: The term partial function is widely used to describe the partial application
    of a function. Some of the argument values are fixed, while others vary. We might
    have a function, ![f (a,b,c) ](img/file38.png), where there are fixed values for
    ![a ](img/file39.png) and ![b ](img/file40.png). With fixed values, we have a
    new version of the function, ![fp(c) ](img/file41.png).
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: “部分函数”这个术语被广泛用来描述函数的部分应用。一些参数值是固定的，而另一些则变化。我们可能有一个函数，![f (a,b,c) ](img/file38.png)，其中![a
    ](img/file39.png)和![b ](img/file40.png)有固定的值。有了这些固定值，我们就有了一个函数的新版本，![fp(c) ](img/file41.png)。
- en: When we look at complex functions, we’ll sometimes see a pattern in the ways
    we use the function. We might, for example, evaluate a function many times with
    some argument values that are fixed by context, and other argument values that
    are changing with the details of the processing. Having some fixed argument values
    suggests a partial function.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看复杂函数时，我们有时会看到我们使用函数的方式中存在一种模式。例如，我们可能会多次评估一个函数，其中一些参数值由上下文固定，而其他参数值则随着处理细节的变化而变化。有一些固定的参数值暗示了一个部分函数。
- en: Creating a partial function can simplify our programming by avoiding code to
    repeat the argument values that are fixed by a specific context.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 创建部分函数可以通过避免重复特定上下文中固定的参数值来简化我们的编程。
- en: 3.6.1 Getting ready
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.6.1 准备工作
- en: 'We’ll look at a version of the haversine formula. This computes distances between
    two points, p[1] = (lon[1],lat[1]) and p[2] = (lon[2],lat[2]), on the surface
    of the Earth:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将查看 haversine 公式的版本。这个公式计算地球表面上两点，p[1] = (lon[1],lat[1]) 和 p[2] = (lon[2],lat[2])
    之间的距离：
- en: '![ ∘ ------------------------------------------------- a = sin2(lat2 −-lat1)+
    cos(lat1)cos(lat2) sin2(lat2 −-lat1) 2 2 ](img/file42.png)![c = 2arcsin a ](img/file43.png)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![ ∘ ------------------------------------------------- a = sin2(lat2 −-lat1)+
    cos(lat1)cos(lat2) sin2(lat2 −-lat1) 2 2 ](img/file42.png)![c = 2arcsin a ](img/file43.png)'
- en: The essential calculation yields the central angle, c, between two points. The
    angle is measured in radians. We must convert this angle into distance by multiplying
    by the Earth’s mean radius in some given units. If we multiply the angle c by
    a radius of 3,959 miles, we’ll convert the angle into miles.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的计算得到两点之间的中心角，c。角度以弧度为单位。我们必须通过乘以地球的平均半径以某些给定的单位来将这个角度转换为距离。如果我们把角度 c 乘以 3,959
    英里的半径，我们将把角度转换为英里。
- en: 'Here’s an implementation of this function:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是这个函数的实现：
- en: '[PRE47]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The doctest example uses an Earth radius with an extra decimal point that’s
    not used elsewhere. This example’s output will match other examples found online.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: doctest 示例使用了一个地球半径，多了一个未在其他地方使用的额外小数点。这个示例的输出将与网上找到的其他示例相匹配。
- en: The problem we often have is the value for R rarely changes for a specific context.
    One context may use kilometers throughout the application, while another uses
    nautical miles. We’d like to impose a context-specific default value like R = NM
    to get nautical miles in a given context without having to edit the module.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常遇到的问题是 R 的值在特定上下文中很少改变。一个上下文可能在整个应用程序中使用公里，而另一个上下文使用海里。我们希望为特定上下文强制一个默认值
    R = NM，在给定上下文中得到海里，而无需编辑模块。
- en: We’ll look at several common approaches to providing a consistent value for
    an argument.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将查看几种提供一致参数值的方法。
- en: 3.6.2 How to do it...
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.6.2 如何实现...
- en: 'In some cases, an overall context will establish a single value for a parameter.
    The value will rarely change. The following are three common approaches to providing
    a consistent value for an argument:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，整体上下文将确定一个参数的单个值。这个值很少改变。以下是为参数提供一致值的三种常见方法：
- en: Wrap the function in a new function that provides the default value.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将函数包装在一个新函数中，该函数提供默认值。
- en: 'Create a partial function with the default value. This has two further refinements:'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个带有默认值的偏函数。这有两个进一步的改进：
- en: We can provide defaults as a keyword parameters.
  id: totrans-296
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以将默认值作为关键字参数提供。
- en: We can provide defaults as positional parameters.
  id: totrans-297
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以将默认值作为位置参数提供。
- en: We’ll look at each of these in separate variations in this recipe.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本食谱中分别查看这些不同的变体。
- en: Wrapping a function
  id: totrans-299
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 包装一个函数
- en: 'Here’s how we can revise the function, slightly, and create a wrapper:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们如何稍微修改函数并创建一个包装器的示例：
- en: 'Make some parameters positional and some parameters keywords. We want the contextual
    features – the ones that rarely change – to be keywords. The parameters that change
    more frequently should be left as positional:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一些参数设置为位置参数，将一些参数设置为关键字参数。我们希望上下文特征——那些很少改变的——是关键字参数。更频繁改变的参数应保留为位置参数：
- en: '[PRE48]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We can follow the [Forcing keyword-only arguments with the * separator](ch007_split_000.xhtml#x1-1820004)
    recipe.
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以遵循[使用 * 分隔符强制关键字参数](ch007_split_000.xhtml#x1-1820004)食谱。
- en: 'We can then write a wrapper function that will apply all of the positional
    arguments, unmodified. It will supply the additional keyword argument as part
    of the long-running context:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以编写一个包装函数，该函数将应用所有位置参数，不进行修改。它将作为长期上下文的一部分提供额外的关键字参数：
- en: '[PRE49]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We have the *args construct in the function declaration to accept all positional
    argument values in a single tuple, args. We use a similar-looking *args when evaluating
    the haversine() function to expand the tuple into all of the positional argument
    values to this function.
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们在函数声明中有 *args 构造来接受所有位置参数值作为一个单一的元组，args。我们在评估 haversine() 函数时使用类似外观的 *args
    来将元组展开为该函数的所有位置参数值。
- en: In this case, all the types are float. We can use *args: float to provide a
    suitable hint. This doesn’t always work out, and this style of handling arguments
    – while simple-looking – can hide problems.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '在这种情况下，所有类型都是 float。我们可以使用 *args: float 提供合适的提示。这并不总是有效，并且这种处理参数的方式——虽然看起来简单——可能会隐藏问题。'
- en: Creating a partial function with keyword parameters
  id: totrans-308
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用关键字参数创建部分函数
- en: 'One approach to defining functions that work well as partial function is to
    use keyword parameters:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 定义作为部分函数工作良好的函数的一种方法是通过使用关键字参数：
- en: 'We can follow the [Forcing keyword-only arguments with the * separator](ch007_split_000.xhtml#x1-1820004)
    recipe to do this. We might change the basic haversine function so that it looks
    like this:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以遵循[使用 * 分隔符强制关键字参数](ch007_split_000.xhtml#x1-1820004)的配方来做这件事。我们可能会改变基本的海里函数，使其看起来像这样：
- en: '[PRE50]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Create a partial function using the keyword parameter:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用关键字参数创建部分函数：
- en: '[PRE51]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The partial() function builds a new function from an existing function and a
    concrete set of argument values. The nm_haversine_3() function has a specific
    value for R provided when the partial was built.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '`partial()` 函数从一个现有函数和一个具体的参数值集合中构建一个新的函数。`nm_haversine_3()` 函数在构建部分函数时为 R
    提供了一个特定的值。'
- en: 'We can use this like we’d use any other function:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像使用任何其他函数一样使用它：
- en: '[PRE52]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We get an answer in nautical miles, allowing us to do boating-related calculations.
    Having a fixed value for R=NM leaves the code slightly simpler-looking, and much
    more trust-worthy. The possibility of one computation having an incorrect value
    for R is eliminated.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到海里单位的答案，这使得我们能够轻松地进行与航海相关的计算。将 R=NM 设置为固定值使代码看起来稍微简单一些，并且更加可信。消除了一个计算中 R
    值可能不正确的情况。
- en: Creating a partial function with positional parameters
  id: totrans-318
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用位置参数创建部分函数
- en: 'If we try to use partial() with positional arguments, we’re constrained to
    providing the leftmost parameter values in the partial definition. This leads
    us to think of the first few arguments to a function as candidates for being hidden
    by a partial function or a wrapper:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试使用 `partial()` 与位置参数一起，我们被限制在部分定义中提供最左边的参数值。这让我们想到函数的前几个参数可能是被部分函数或包装器隐藏的候选者：
- en: 'We need to change the basic haversine function to put the R parameter first.
    This makes it slightly easier to define a partial function. Here’s the changed
    definition:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要更改基本的海里函数，将 R 参数放在第一位。这使得定义部分函数稍微容易一些。以下是更改后的定义：
- en: '[PRE53]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Create a partial function using the positional parameter:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用位置参数创建部分函数
- en: '[PRE54]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The partial() function builds a new function from an existing function and a
    concrete set of argument values. The nm_haversine_4() function has a specific
    value for the first parameter, R, that’s provided when the partial was built.
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`partial()` 函数从一个现有函数和一个具体的参数值集合中构建一个新的函数。`nm_haversine_4()` 函数在构建部分函数时为第一个参数
    R 提供了一个特定的值。'
- en: 'We can use this like we’d use any other function:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像使用任何其他函数一样使用它：
- en: '[PRE55]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: We get an answer in nautical miles, allowing us to do boating-related calculations
    easily, The code can use a version of the the haversine() function without the
    annoying detail of repeating the R=NM argument value.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到海里单位的答案，这使得我们能够轻松地进行与航海相关的计算，代码可以使用没有重复 R=NM 参数值的烦恼细节的海里函数版本。
- en: 3.6.3 How it works...
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.6.3 它是如何工作的...
- en: 'A partial function is, essentially, identical to a wrapper function. We can
    build partials freely in the middle of other, more complex, pieces of a program.
    Note that creating partial functions leads to a few additional considerations
    when looking at the order for positional parameters:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 部分函数本质上与包装函数相同。我们可以在程序的其他更复杂的部分中自由构建部分函数。请注意，创建部分函数时，在考虑位置参数的顺序时会导致一些额外的考虑：
- en: If we try to use *args in the wrapper, these must be defined last. All of these
    parameters become anonymous. This anonymity means tools like mypy may have problems
    confirming the parameters are being used correctly. The documentation will not
    show the necessary details, either.
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们尝试在包装器中使用 `*args`，这些必须定义在最后。所有这些参数都变成了匿名参数。这种匿名性意味着像 mypy 这样的工具可能难以确认参数是否被正确使用。文档也不会显示必要的细节。
- en: The leftmost positional parameters are easiest to provide a value for when creating
    a partial function.
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在创建部分函数时，最左边的位置参数最容易提供值。
- en: Any keyword-only parameters, defined after the * separator, are also a good
    choice to provide as part of a partial definition.
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何在 * 分隔符之后定义的关键字参数也是作为部分定义的一部分提供的好选择。
- en: 'These considerations can lead us to look at the leftmost argument as being
    a kind of context: these parameters are expected to change rarely and can be provided
    more easily by partial function definitions.'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 这些考虑可以让我们将最左边的参数视为一种上下文：这些参数预计很少改变，并且可以通过部分函数定义更容易地提供。
- en: 3.6.4 There’s more...
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.6.4 更多...
- en: 'There’s yet another way to wrap a function – we can also build a lambda object.
    The following example will also work:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This relies on the haversine_k() function definition, where the R parameter
    is marked as keyword-only. Without this clear separation between positional and
    keyword argument values, this lambda definition will result in a warning from
    mypy. If we use the original haversine() function, the warning tells us that it’s
    possible for R to get multiple values.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: 'A lambda object is a function that’s been stripped of its name and body. The
    function definition is reduced to just two essentials:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: The parameter list, *args, in this example.
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A single expression, which is the result, haversine_k(*args, R=NM). A lambda
    cannot have any statements.
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The lambda approach makes it difficult to create type hints. This limits its
    utility. Further, the [PEP-8](https://peps.python.org/pep-0008/) recommendations
    suggest assigning a lambda to a variable should never be done.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: 3.6.5 See also
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll also look at extending this design further in the [Writing testable scripts
    with the script-library switch](ch007_split_001.xhtml#x1-2150009) recipe.
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For more functional programming techniques, see Functional Python Programming:
    [https://www.packtpub.com/product/functional-python-programming-3rd-edition-third-edition/9781803232577](https://www.packtpub.com/product/functional-python-programming-3rd-edition-third-edition/9781803232577).
    This has numerous examples of using lambdas and partial functions.'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 3.7 Writing clear documentation strings with RST markup
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How can we clearly document what a function does? Can we provide examples? Of
    course we can, and we really should. In the [Including descriptions and documentation](ch006_split_000.xhtml#x1-1010003)
    recipe in Chapter [2](ch006_split_000.xhtml#x1-840002), and in the [Writing better
    docstrings with RST markup](ch006_split_000.xhtml#x1-1090004) recipe, we looked
    at some essential documentation techniques. Those recipes introduced ReStructuredText
    (RST) for module docstrings.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: We’ll extend those techniques to write RST for function docstrings. When we
    use a tool such as Sphinx, the docstrings from our function will become elegant-looking
    documentation that describes what our function does.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: 3.7.1 Getting ready
  id: totrans-348
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the [Forcing keyword-only arguments with the * separator](ch007_split_000.xhtml#x1-1820004)
    recipe, we looked at a function to compute wind-chill, given the temperature and
    wind-speed.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: In the recipe, we’ll show several versions of the function with trailing _0
    in the name. Pragmatically, this name change is not a good idea. For the purposes
    of making the evolution of this function clear in this book, however, it seems
    helpful to give each new variant a distinct name.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: We need to annotate this function with some more complete documentation.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: 3.7.2 How to do it...
  id: totrans-352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ll generally write the following things for a function description:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: Synopsis
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Description
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parameters
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exceptions
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test cases
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anything else that seems meaningful
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何其他似乎有意义的内容
- en: Here’s how we’ll create documentation for a function. We can apply a similar
    method to a method of a class, or even a module.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将如何为函数创建文档。我们可以将类似的方法应用于类的成员函数，甚至是一个模块。
- en: 'Write the synopsis. A proper subject isn’t required. Don’t write This function
    computes...; we can start with Computes.... There’s no reason to overstate the
    context:'
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写概要。不需要适当的主题。不要写 This function computes...；我们可以从 Computes.... 开始。没有必要过度强调上下文：
- en: '[PRE57]'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: To help clarify the evolution of this function’s docstring in this book, we’ve
    appended a suffix of _1 to the name.
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了帮助阐明本书中此函数 docstring 的演变，我们在名称后附加了后缀 _1。
- en: 'Write the description and provide details:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写描述并提供详细信息：
- en: '[PRE58]'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'In this case, we used a little block of typeset math in our description. The
    :math: interpreted text role uses LaTeXmath typesetting. Tools like Sphinx can
    use MathJax or jsMath to do handle math typesetting.'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '在这种情况下，我们在描述中使用了小块排版数学。:math: 解释文本角色使用 LaTeXmath 排版。像 Sphinx 这样的工具可以使用 MathJax
    或 jsMath 来处理数学排版。'
- en: 'Describe the parameters. For positional parameters, it’s common to use :param name:
    description. Sphinx will tolerate a number of variations, but this is common.
    For parameters that must be keywords, it’s common to use :key name: as the prefix
    to the description.'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '描述参数。对于位置参数，通常使用 :param name: description. Sphinx 可以容忍多种变体，但这是常见的。对于必须使用关键字参数的情况，通常使用
    :key name: 作为描述的前缀。'
- en: '[PRE59]'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Describe the return value using :returns::'
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '使用 :returns:: 描述返回值'
- en: '[PRE60]'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Identify the important exceptions that might be raised. Use the :raises exception:
    markup to define the reasons for the exception. There are several possible variations,
    but :raises exception: seems to be popular:'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '识别可能引发的重要异常。使用 :raises exception: 标记来定义异常的原因。有几种可能的变体，但 :raises exception:
    似乎很受欢迎：'
- en: '[PRE61]'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Include a doctest test case, if possible:'
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果可能，包括一个 doctest 测试用例：
- en: '[PRE62]'
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Write any additional notes and helpful information. We could add the following
    to the docstring:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写任何附加的注释和有用的信息。我们可以在 docstring 中添加以下内容：
- en: '[PRE63]'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: We’ve included a reference to a Wikipedia page that summarizes wind-chill calculations
    and has links to more detailed information.
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还包含了一个指向总结风冷计算并链接到更多详细信息页面的维基百科页面。
- en: 'We’ve also included a ..  math:: directive with the LaTeX formula that’s used
    in the function. This will often typeset nicely, providing a very readable version
    of the code.'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '我们还包含了一个 ..  math:: 指令，其中包含函数中使用的 LaTeX 公式。这通常会很好地排版，提供代码的可读版本。'
- en: 3.7.3 How it works...
  id: totrans-380
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.7.3 它是如何工作的...
- en: For more information on docstrings, see the [Including descriptions and documentation](ch006_split_000.xhtml#x1-1010003)
    recipe in Chapter [2](ch006_split_000.xhtml#x1-840002). While Sphinx is popular,
    it isn’t the only tool that can create documentation from the docstring comments.
    The pydoc utility that’s part of the Python Standard Library can also produce
    good-looking documentation from the docstring comments.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 docstrings 的更多信息，请参阅第 [2](ch006_split_000.xhtml#x1-840002) 章的 [包括描述和文档](ch006_split_000.xhtml#x1-1010003)
    菜单。虽然 Sphinx 很受欢迎，但它不是唯一可以从 docstring 注释创建文档的工具。Python 标准库中的 pydoc 工具也可以从 docstring
    注释生成外观良好的文档。
- en: The Sphinx tool relies on the core features of RST processing in the Docutils
    package. See [https://pypi.python.org/pypi/docutils](https://pypi.python.org/pypi/docutils)
    for more information.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: Sphinx 工具依赖于 Docutils 包的核心 RST 处理功能。有关更多信息，请参阅 [https://pypi.python.org/pypi/docutils](https://pypi.python.org/pypi/docutils)。
- en: 'The RST rules are relatively simple. Most of the additional features in this
    recipe leverage the interpreted text roles of RST. Each of our :param T:, :returns:,
    and :raises ValueError: constructs is a text role. The RST processor can use this
    information to decide on a style and structure for the content. The style usually
    includes a distinctive font. The context might be an HTML definition list format.'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 'RST 规则相对简单。这个菜谱中的大多数附加功能都利用了 RST 的解释文本角色。我们每个 :param T:, :returns:, 和 :raises ValueError:
    构造都是一个文本角色。RST 处理器可以使用这些信息来决定内容的样式和结构。样式通常包括一个独特的字体。上下文可能是 HTML 定义列表格式。'
- en: 3.7.4 There’s more...
  id: totrans-384
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.7.4 还有更多...
- en: In many cases, we’ll also need to include cross-references among functions and
    classes. For example, we might have a function that prepares a wind-chill table.
    This function might have documentation that includes a reference to the T_wc()
    function.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，我们还需要在函数和类之间包含交叉引用。例如，我们可能有一个准备风冷表的函数。这个函数的文档可能包括对 T_wc() 函数的引用。
- en: 'Sphinx will generate these cross-references using a special :func: text role:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: We’ve used :func:‘Twc‘ to create a reference from one function in the RST documentation
    to another function. Sphinx will turn these into proper hyperlinks.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: 3.7.5 See also
  id: totrans-389
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See the [Including descriptions and documentation](ch006_split_000.xhtml#x1-1010003)
    and [Writing better docstrings with RST markup](ch006_split_000.xhtml#x1-1090004)
    recipes in Chapter [2](ch006_split_000.xhtml#x1-840002), for other recipes that
    show how RST works.
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 3.8 Designing recursive functions around Python’s stack limits
  id: totrans-391
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some functions can be defined clearly and succinctly using a recursive formula.
    There are two common examples of this.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: 'The factorial function has the following recursive definition:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: '![ ( |{ n! = 1 if n = 0, |( n × (n− 1)! if n > 0\. ](img/file44.png)'
  id: totrans-394
  prefs: []
  type: TYPE_IMG
- en: 'The recursive rule for computing a Fibonacci number, F[n], has the following
    definition:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: '![ ( |{ F = 1 if n = 0∨ n = 1, n |( Fn −1 + Fn −2 if n > 1\. ](img/file45.png)'
  id: totrans-396
  prefs: []
  type: TYPE_IMG
- en: Each of these involves a case that has a simple defined value and a case that
    involves computing the function’s value, based on other values of the same function.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: The problem we have is that Python imposes an upper limit for these kinds of
    recursive function evaluations. While Python’s integers can easily compute the
    value of 1000!, the stack limit prevents us from computing this casually.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: Pragmatically, the filesystem is an example of a recursive data structure. Each
    directory contains subdirectories. Recursive function definitions can be used
    on directory trees. The cases with defined values come from processing the non-directory
    files.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: We can often refactor a recursive design to eliminate the recursion and replace
    it with iteration. While doing recursion elimination, we’d like to preserve as
    much of the original mathematical clarity as possible.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: 3.8.1 Getting ready
  id: totrans-401
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Many recursive function definitions follow the pattern set by the factorial
    function. This is sometimes called tail recursion because the recursive case can
    be written at the tail of the function body:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The last expression in the function refers to the same function, but uses a
    different argument value.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: We can restate this, avoiding the recursion limits in Python.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: 3.8.2 How to do it...
  id: totrans-406
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A tail recursion can also be described as a reduction. We’re going to start
    with a collection of values, and then reduce them to a single value:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: 'Expand the rule to show all of the details: n! = n×(n−1)×(n−2)× (n − 3) ×![⋅⋅⋅](img/file46.png)×
    1\. This helps ensure we understand the recursive rule.'
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write a loop or generator to create all the values: N = {n,n − 1,n − 2,n −
    3,…,1}. In Python, this can be as simple as range(1, n+1). In some cases, though,
    we might have to apply some transformation function to the base values: N = {f(i)∣1
    ≤ i < n + 1}. This is a list comprehension; see [Building lists – literals, appending,
    and comprehensions](ch008_split_000.xhtml#x1-2310002) in Chapter [4](ch008_split_000.xhtml#x1-2240004).'
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Incorporate the reduction function. In this case, we’re computing a large product,
    using multiplication. We can summarize this as ∏ [1≤x<n+1]x.
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here’s an implementation in Python:'
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: An equivalent function is available in the math module. Rather than write it
    out as shown above, we can use from math import prod.
  id: totrans-413
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The prod_i() function can be used as follows to compute a factorial value:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This works nicely. We’ve optimized the prod_i() function into an iterative function.
    This revision avoids the potential stack overflow problems the recursive version
    suffers from.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: Note that the range object is lazy; it doesn’t create a big list object, avoiding
    the allocation of a great deal of memory. A range object returns individual values
    as they are consumed by the prod_i() function.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: 3.8.3 How it works...
  id: totrans-418
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A tail recursion definition is handy because it’s short and easy to remember.
    Mathematicians like this because it can help clarify what a function means.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: 'Many static, compiled languages create optimized code in a manner similar to
    the technique we’ve shown here. This works by injecting a special instruction
    into the virtual machine’s byte code – or the actual machine code – to re-evaluate
    the function without creating a new stack frame. Python doesn’t have this feature.
    In effect, this optimization transforms a recursion into a kind of while statement:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The injection of the special byte code instruction will lead to code that runs
    quickly, without revealing the intermediate revisions. The resulting instructions
    will not be a perfect match for the source text, however, leading to potential
    difficulties in locating bugs.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: 3.8.4 There’s more...
  id: totrans-423
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Computing the F[n] Fibonacci number involves an additional problem. If we’re
    not careful, we’ll compute a lot of values more than once:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: 'To compute F[5] = F[4] + F[3], for example, we’ll evaluate this:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: '![F5 = (F3 + F2 )+ (F2 + F1) ](img/file47.png)'
  id: totrans-426
  prefs: []
  type: TYPE_IMG
- en: Expanding the definition of F[3] and F[2] shows a number of redundant computations.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: 'The Fibonacci problem involves two recursions. If we write it naively, it might
    look like this:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'It’s difficult to do a simple mechanical transformation to turn something like
    this example into a tail recursion. We have two ways to reduce the computation
    complexity of this:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: Use memoization
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Restate the problem
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The memoization technique is easy to apply in Python. We can use the @functools.cache
    as a decorator. It looks like this:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Adding this decorator will optimize a more complex recursion.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: Restating the problem means looking at it from a new perspective. In this case,
    we can think of computing all Fibonacci numbers up to and including the desired
    F[n]. We only want the last value in this sequence. Computing a number of intermediate
    values can be reasonably efficient.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a generator function that does this:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: This function is an infinite iteration of Fibonacci numbers. It uses Python’s
    yield so that it emits values in a lazy fashion. When a client function uses this
    iterator, the next number in the sequence is computed as each number is consumed.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a function that consumes the values and also imposes an upper limit
    on the otherwise infinite iterator:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: This function consumes a sequence of values from the fibo_iter() iterator. When
    the desired number has been reached, the break statement ends the for statement.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: We’ve optimized the recursive solution and turned it into an iteration that
    avoids the potential for stack overflow.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: 3.8.5 See also
  id: totrans-444
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See the [Avoiding a potential problem with break statements](ch006_split_001.xhtml#x1-1290007)
    recipe in Chapter [2](ch006_split_000.xhtml#x1-840002).
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 3.9 Writing testable scripts with the script-library switch
  id: totrans-446
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It’s often very easy to create a Python script file. When we provide a script
    file to Python, it runs immediately. In some cases, there are no function or class
    definitions; the script file is the sequence of Python statements.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: These script files are very difficult to test. Additionally, they’re also difficult
    to reuse. When we want to build larger and more sophisticated applications from
    a collection of script files, we’re often forced to re-engineer a script into
    one or more functions.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: 3.9.1 Getting ready
  id: totrans-449
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s say that we have a handy implementation of the haversine distance function
    called haversine(), and it’s in a file named recipe_11.py.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: 'The file contains the functions and definitions shown in the [Picking an order
    for parameters based on partial functions](ch007_split_001.xhtml#x1-1940006) in
    this chapter. This includes a partial function, nm_haversine(), to compute distances
    in nautical miles. The script also contains the following top-level code:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: This Python script opens a file, data/wapypoints.csv, and does some processing
    on that file. While this is handy to use, we can’t easily test it.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: If we try to import the haversine() function for a unit test, we’ll execute
    the other parts of the script. How can we refactor this module so we can import
    the useful functions without it printing a display of distances between waypoints
    in the wapypoints.csv file?
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: 3.9.2 How to do it...
  id: totrans-455
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Writing a Python script can be called an attractive nuisance; it’s attractively
    simple, but it’s difficult to test effectively. Here’s how we can transform a
    script into a testable and reusable library:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: Identify the statements that do the work of the script. This means distinguishing
    between definitions and actions. Statements such as import, def, and class are
    definitional – they create objects but don’t take a direct action to compute or
    produce the output. Almost all other statements take some action. Because some
    assignment statements might be part of type hint definition, or might create useful
    constants, the distinction is entirely one of intent.
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In our example, we have some assignment statements that are more definition
    than action. These assignments are analogous to def statements; they only set
    variables that are used later. Here are the generally definitional statements:'
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-459
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-460
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The rest of the statements in the module are designed to take an action toward
    producing the printed results.
  id: totrans-461
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Wrap the actions into a function. Try to pick a descriptive name. If there’s
    no better name, use main(). In this example the action computes distances, so
    we’ll call the function distances().
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-463
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: In the above example, we named the function distances_draft() to assure that
    it’s clearly distinct from a more final version. Practically, using distinct names
    like this as code evolves toward completion isn’t necessary, unless writing a
    book where it’s essential to unit test intermediate steps.
  id: totrans-464
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Where possible, extract literals and turn them into parameters. This is often
    a simple movement of the literal to a parameter with a default value.
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-466
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: This makes the script reusable because the path is now a parameter instead of
    an assumption.
  id: totrans-467
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Include the following if statement as the only high-level action statements
    in the script file:'
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-469
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: We’ve packaged the action of the script as a function. The top-level action
    script is now wrapped in an if statement so that it isn’t executed during import
    but is executed when the script is run directly.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: 3.9.3 How it works...
  id: totrans-471
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An important rule for Python is that an import of a module is essentially the
    same as running the module as a script. The statements in the file are executed,
    in order, from top to bottom.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: When we import a file, we’re generally interested in executing the def and class
    statements. We might be interested in some assignment statements that define useful
    globals. Sometimes, we’re not interested in executing the main program.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: 'When Python runs a script, it sets a number of built-in special variables.
    One of these is __name__. This variable has two different values, depending on
    the context in which the file is being executed:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: 'The top-level script, executed from the command line: In this case, the value
    of the built-in special name of __name__ is set to "__main__".'
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A file being executed because of an import statement: In this case, the value
    of __name__ is the name of the module being created from reading the file and
    executing the Python statements.'
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The standard name of "__main__" may seem a little odd at first. Why not use
    the filename in all cases? This special name is assigned because a Python script
    can be read from one of many sources. It can be a file. Python can also be read
    from the stdin pipeline, or it can be provided on the Python command line using
    the -c option.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: 3.9.4 There’s more...
  id: totrans-478
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can now build useful work around a reusable library. We might make an application
    script file that look like this:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The goal is to decompose a practical solution into two collections of features:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: The definition of classes and functions
  id: totrans-482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A very small action-oriented script that uses the definitions to do useful work
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个非常小的以动作为导向的脚本，使用定义来完成有用的工作
- en: We often start with a script that conflates both sets of features. This kind
    of script can be viewed as a spike solution. Our spike solution can evolve toward
    a more refined solution as soon as we’re sure that it works. A spike or piton
    is a piece of removable mountain-climbing gear that enables us to climb safely.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常从一个将这两组功能合并在一起的脚本开始。这种脚本可以被视为一个峰值解决方案。一旦我们确定它可行，我们的峰值解决方案就可以向更精细的解决方案进化。峰值或锤子是登山装备的一部分，使我们能够安全地攀登。
- en: After starting with a spike, we can elevate our design and refactor the code
    into definitions and actions. Tests can then import the module to test the various
    definitions without taking actions that might overwrite important files.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始使用峰值（spike）之后，我们可以提升我们的设计，并将代码重构为定义和动作。然后测试可以导入模块来测试各种定义，而不执行可能会覆盖重要文件的行动。
- en: 3.9.5 See also
  id: totrans-486
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.9.5 参见
- en: In Chapter [7](ch011_split_000.xhtml#x1-3760007), we look at class definitions.
    These are another kind of widely used definitional statement, in addition to function
    definitions.
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第 [7](ch011_split_000.xhtml#x1-3760007) 章中，我们探讨了类定义。这些是除了函数定义之外，另一种广泛使用的定义性语句。
- en: The [Reading delimited files with the CSV module](ch015_split_000.xhtml#x1-6320003)
    recipe that we look at in Chapter [11](ch015_split_000.xhtml#x1-61500011) also
    addresses CSV file reading.
  id: totrans-488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在第 [11](ch015_split_000.xhtml#x1-61500011) 章中讨论的 [使用 CSV 模块读取定界文件](ch015_split_000.xhtml#x1-6320003)
    的配方也解决了 CSV 文件读取的问题。
- en: Join our community Discord space
  id: totrans-489
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的社区 Discord 空间
- en: 'Join our Python Discord workspace to discuss and find out more about the book:
    [https://packt.link/dHrHU](https://packt.link/dHrHU)'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的 Python Discord 工作空间，讨论并了解更多关于这本书的信息：[https://packt.link/dHrHU](https://packt.link/dHrHU)
- en: '![PIC](img/file1.png)'
  id: totrans-491
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file1.png)'
