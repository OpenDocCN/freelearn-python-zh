- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ARM Addressing Modes
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Addressing modes are a fundamental part of computer architecture and are concerned
    with how you express the location of an operand. We introduced addressing modes
    in earlier chapters. Now, we will examine the ARM’s rather sophisticated set of
    addressing modes.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics to be discussed are as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Literal addressing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scaled literals
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Register indirect addressing
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The use of two-pointer registers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Auto-incrementing pointers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Literal addressing
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The easiest addressing mode is *literal addressing*. Instead of saying where
    an operand is in memory, you provide the operand in an instruction (i.e., this
    is literally the value). Other addressing modes require you to specify where an
    operand is in memory. Consider the following Python expression, which has two
    literals, 30 and 12:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '`if A > 30: B =` `12`'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: 'We can express this fragment of Python in ARM assembly language as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can simplify this code by using conditional execution, as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Scaled literals
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The ARM implements 12-bit literals in an unusual way, using a technique borrowed
    from the world of floating-point arithmetic. Four of the 12 bits of a literal
    are used to scale an 8-bit constant. That is, the 8-bit constant is rotated right
    by twice the number in the 4-bit scaling field. The four most-significant bits
    of the literal field specify the literal’s alignment within a 32-bit word. If
    the 8-bit immediate value is `N` and the 4-bit alignment is `n`, then the value
    of the literal is given by `N` rotated *right* by *2n* places. For example, if
    the 8-bit literal is `0xAB` and `n` is `4`, the resulting 32-bit literal is `0xAB000000`
    because of the eight-position right rotation (2 x 4). Remember that an eight rotate
    right position is equivalent to a 32 - 8 = 24 bit shift left. *Figure 11**.1*
    demonstrates some 32-bit literals and the 12-bit literal codes that generate them.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1 – ARM’s literal operand encoding](img/Figure_11.01_B19624.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
- en: Figure 11.1 – ARM’s literal operand encoding
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: You might find this rather strange. Why didn’t ARM use the 12-bit literal field
    to provide a number in the range 0 to 4,095, rather than a number in the range
    0 to 255 scaled by the power of 2? The answer is that ARM’s designers determined
    that the scaled literals were more useful in real-world applications than unscaled
    numbers. For example, suppose you wanted to clear all bits of a 32-bit word, except
    bits 8 to 15\. You would need to `AND` it with the literal `0b00000000000000001111111100000000`
    or `0x0000FF00` in hexadecimal. Using the scaling mechanism, we can take 8 bits
    `0x11111111` and shift them left by 8 bits (i.e., right by 24 bits) to get the
    required constant. However, the scaling factor `n` needs twice the number of rotation
    rights to achieve this. That is (32 – 8)/2, which is 12\. Consequently, the literal
    stored in the 12-bit instruction field is 12,255, or CFF in hexadecimal.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, calculating the scaling factor is something the programmer does
    not always have to worry about. ARM compilers take a constant and automatically
    generate the best instruction(s) necessary to generate it.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Register indirect addressing
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already encountered this addressing mode where the location of an operand
    is held in a register. It is called register *indirect addressing* because the
    instruction specifies the register where a pointer to the actual operand can be
    found. In ARM literature, this addressing mode is called *indexed addressing*.
    Some people call this *base addressing*.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 'Register indirect addressing mode requires three read operations to access
    an operand:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Read the instruction to find the pointer register
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read the pointer register to find the operand address
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read memory at the operand address to find the operand
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Register indirect addressing is important because the contents of the register
    containing the pointer to the actual operand can be modified at runtime, and therefore,
    the address is a variable. Consequently, we can step through data structures such
    as tables by changing the pointer.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2 – Register indirect addressing – executing ldr r1,[r0]](img/Figure_11.02_B19624.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
- en: Figure 11.2 – Register indirect addressing – executing ldr r1,[r0]
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 11**.2* illustrates the effect of `ldr` r1,`[r0]`, where `r0` is the
    pointer and contains the value `n`.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '`ldr` r1`,[r0]` loads the contents of the memory location pointed at by register
    `r0` into register `r1`.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Executing `add` r0`,r0,#4` increments the contents of the pointer register `r0`
    by 4 to point at the next word location (remember that consecutive word addresses
    differ by 4).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The first instruction loads `r1` with the 32-bit word pointed at by `r0`. The
    second instruction increments `r0` by 4 to point at the next byte in memory. Repeating
    this pair of instructions will allow you to step through a table of values, element
    by element. We will soon see that the ARM includes a mechanism to automatically
    increment or decrement the pointer.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: 'The next fragment of code demonstrates how you would add together the elements
    of a table. Suppose that you have a table of daily expenditures you have made
    over four weeks. Each item is stored consecutively in a table with 4 x 7 = 28
    entries:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this simple example, we set up a loop and step through elements from the
    first to the last. On each cycle, we read an element and add it to the total.
    The shaded lines are where the action takes place – getting an element and pointing
    to the next one.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'The next example demonstrates both pointer-based indirect addressing and byte
    operations (i.e., operations on an 8-bit value rather than a full word). Suppose
    we want to find a given character within a string. The following code uses a *byte
    load instruction*, `ldrb`, which loads 8 bits into the destination register. We
    increment the pointer by 1 as we step through the string, not 4, because the values
    are on one-byte boundaries:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Pointer-based addressing with an offset
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Suppose someone asks you, *“Where’s the pharmacy?”* You might reply, *“It’s
    two blocks to the left of the bank.”* That’s pointer-based offset addressing in
    everyday life. We point to the bank by giving its location in relation to something
    else.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: The ARM allows you to specify an address using a pointer register, plus a 12-bit
    literal that supplies the offset. Note that this is a true 12-bit literal rather
    than the 8-bit scaled value used as a literal operand. The literal can be positive
    or negative (indicating that it’s to be added to or subtracted from the base pointer).
    Consider `ldr` r5`,[r2,#160]`, where the address of the operand loaded into `r5`
    is the contents of `r1` plus 160.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose you wanted to move a block of 24 words to a location that is 128 bytes
    further on in memory. Assume that the address of the block to move is at `0x400`.
    We can write the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Unfortunately, you cannot run this directly on an ARM-based Raspberry Pi as
    we described because you are not allowed to modify memory in a code segment. That
    is an operating system limitation. To avoid this problem, you have to use pointers,
    as we demonstrated in [*Chapter 9*](B19624_09.xhtml#_idTextAnchor159). We will
    return to this point.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Two pointers are better than one
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The register-indirect addressing mode lets you access elements in a linear data
    structure, such as a one-column table. Sometimes, you will have a more complex
    two-dimensional data structure, such as a matrix with rows and columns. In that
    case, two pointers can simplify programming – one pointer for the row and one
    for the column.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: 'ARM provides a pointer-based addressing mode that allows you to specify an
    address that is the sum of two pointer registers, such as the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You can apply a shift to the second operand, such as the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this case, register `r1` is scaled by 8\. The scaling factor must be a power
    of 2 (i.e., 2, 4, 8, 16…).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 11**.3* illustrates pointer-based addressing with two index registers.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.3 – Indexed addressing with a register offset – ldr r0,[r1,r2]](img/Figure_11.03_B19624.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
- en: Figure 11.3 – Indexed addressing with a register offset – ldr r0,[r1,r2]
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: This is conceptual because we’ve shown one register pointing at memory (`r1`)
    and one register providing an offset from `r1` (i.e., `r2`). However, since the
    final address is `r1` plus `r2`, we could have drawn it the other way around.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Automatic indexing of pointer registers
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When pointer registers are used, they are frequently used to step through data
    structures and are often incremented or decremented after every memory access.
    It would, therefore, make sense to include this action as part of the instruction.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Indeed, CISC processors invariably include automatic indexing. When RISC processors
    arrived with their *one instruction per clock cycle goal*, automatic indexing
    was dropped from the instruction set. However, this mechanism has been incorporated
    into ARM architecture.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'ARM’s automatic indexing has four variations. You can do it before using a
    pointer or after using a pointer. You can index up toward higher addresses or
    down toward lower addresses. Consider the following operations involving an index
    register, `r0`, and an increment of 4 (for one word on a byte-addressed machine).
    Each option is composed of a memory access and a pointer adjust action; in the
    first two cases, the pointer is adjusted first (pre-indexing), and in the other
    two cases, memory is accessed first (post-indexing). Memory accesses are given
    in bold:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '| **Indexing type** | **First action** | **Second action** |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
- en: '| Pre-indexed up | `[r1]` `←` `[r1] + 4` | [r0] ← [[r1]] |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
- en: '| Pre-indexed down | `[r1]` `←` `[r1] - 4` | [r0] ← [[r1]] |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
- en: '| Post-indexed up | [r0] ← [[r1]] | `[r1]` `←` `[r1] + 4` |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
- en: '| Post-indexed down | [r0] ← [[r1]] | `[r1]` `←` `[r1] – 4` |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
- en: 'ARM indicates pre-indexing by including the offset within square brackets and
    appending an exclamation mark, such as the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The value of the pointer `r0` changes *BEFORE* it is used as an offset. Let’s
    suppose we wish to use post-indexing and increment the pointer *AFTER* it is used.
    In this case, the format is as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, the value of the pointer `r0` changes *AFTER* it is used as an offset.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '*Figures 11.4* to *11.6* illustrate ARM’s variations on indexed addressing.
    In each case, the base register is `r1`, the offset is `12`, and the destination
    register is `r0`. These figures are summarized here:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '| **Figure** | **Type** | **Format** | **Base** **reg before** | **Base** **reg
    after** | **Operand address** |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
- en: '| 11.4 | Reg indirect | ldr r0,[r1,#12] | [r1] | [r1] | [r1] + 12 |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
- en: '| 11.5 | Pre-indexed | ldr r0,[r1,#12]! | [r1] | [r1] + 12 | [r1] + 12 |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
- en: '| 11.6 | Post-indexing | ldr r0,[r1],#12 | [r1] | [r1] + 12 | [r1] |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
- en: '![Figure 11.4 – Register indirect addressing with an offset](img/Figure_11.04_B19624.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
- en: Figure 11.4 – Register indirect addressing with an offset
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.5 – Register indirect addressing with pre-indexing](img/Figure_11.05_B19624.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
- en: Figure 11.5 – Register indirect addressing with pre-indexing
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.6 – Register indirect addressing with post-indexing](img/Figure_11.06_B19624.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
- en: Figure 11.6 – Register indirect addressing with post-indexing
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example where we use post-indexing to move a block of
    data from one memory region to another. In this case, we use post-indexing by
    four because we move 4-byte words:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The two key lines of this program are the load and store instructions (shaded),
    where data is read from the source and copied to the destination. As we have stated,
    you can’t run this code *directly* on Raspberry Pi without modification because
    of the way in which the memory space is allocated to variables. The following
    code demonstrates a runnable version for Raspberry Pi.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: 'This is, essentially, the same code. As well as dealing with the memory problem,
    we’ve added assembly directives and dummy data (complete with markers that allow
    you to observe data in memory more easily). There’s also a `nop` instruction.
    Note that some versions of ARM have a true `nop` and some use a pseudo-instruction.
    I added this as a dummy instruction to *“land on”* while testing. Remember that
    the address of the actual data is stored in the program area, and then a pointer
    is loaded with that address:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.7 – The use of pointers when accessing read/write memory](img/Figure_11.07_B19624.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
- en: Figure 11.7 – The use of pointers when accessing read/write memory
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: We ran the preceding program using `gbd` as a debugging tool, as the following
    output demonstrates. In order to condense the text, we’ve removed unnecessary
    data from the display – for example, registers that are not accessed or modified.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.8 – Using gdb to trace the program of Figure 11.7](img/Figure_11.08_B19624.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
- en: Figure 11.8 – Using gdb to trace the program of Figure 11.7
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Example of string-copying
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next example, *Figure 11**.9*, uses post-indexing to copy a string from
    one place to another in reverse order by moving one pointer down and the other
    up. The destination pointer is incremented by `len-1` to point to the end of the
    string, initially. The following code includes assembly language directives, enabling
    it to run on the RPi:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '![Figure 11.9 – Reversing a string](img/Figure_11.09_B19624.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
- en: Figure 11.9 – Reversing a string
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: The next section looks at a variation of pointer-based addressing where the
    pointer is the program counter itself. Consequently, all data and programs are
    referenced to the location of the current program.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Program counter-relative addressing
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ARM is an unusual processor in so many ways. You can use any register (i.e.,
    `r0` to `r15`) as a pointer register. However, `r15` is the ARM’s program counter.
    If you use `r15` as a pointer register with an index, you are saying, *“The operand
    is at this distance from where I am.”* Here the *“where I am”* refers to the instruction
    itself. *Figure 11**.10* illustrates program counter-relative addressing.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Think about it. You give the address of data with respect to the program that’s
    using it and not an absolute address in memory. If you move the program in memory,
    the data is still the same distance from the instructions that access it, using
    program counter-relative addressing. The introduction of program counter relative
    addressing was one of the major advances in computer architecture. By the way,
    most branch instructions use program counter relative addressing because the destination
    of a branch is specified with respect to the current instruction.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: The ARM uses program counter relative addressing to load 32-bit constants. Recall
    that you can load only 12-bit constants with the `ldr` instruction. However, the
    assembler can pre-load a 32-bit constant in memory and then use program counter
    relative addressing to access it. In other words, you dump a 32-value in memory
    near (or within) the program and then access it using program counter relative
    addressing. This is the reason for pseudo-instructions. Without pseudo-instructions,
    you’d have to calculate the relative address between the current `pc` and the
    desired operand. Pseudo-instructions do that and make the address invisible to
    the programmer.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Executing `ldr` r0`,[r15,#0x100]` loads a 32-bit operand that is `0x100` bytes
    (0x40 or 64 words) from the contents of register `r15`, the program counter. The
    operand loaded into `r0` is `0x108` bytes from the pc. Why `0x108` and not `0x100`,
    as specified in the instruction? The additional 8 bytes are there because the
    program counter is incremented by 8 bytes after each instruction and, therefore,
    runs 8 bytes ahead of the current address.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: What about program counter relative store instructions? These cannot be used.
    Store operations using the program counter addressing mode are not supported in
    the ARM. This restriction is probably because (a) a lot of code is in read-only
    memory and can’t be changed, and (b) it would allow the modification of runtime
    programs.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.10 – Program counter relative addressing](img/Figure_11.10_B19624.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
- en: Figure 11.10 – Program counter relative addressing
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Demonstration of program counter relative addressing
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider the following text where we use two types of pseudo-instruction, both
    of which are designed to load a 32-bit value into a register. One is `adr` (load
    an address) and the other `ldr` (load a 32-bit literal):'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: There are three `ldr` instructions. Two load addresses into registers and the
    third, `ldr`, loads a 32-bit literal `0x11111111`. There is an `adr` instruction
    that loads a 32-bit address into register `r2`. What happens when these codes
    are executed?
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s look at the source code when viewed in `gdb`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note that these differ from the source code. That’s because the source code
    uses pseudo-instructions that are translated. For example, `ldr r0,=pqr` is translated
    into `ldr r0,[pc,#32]`. The source code cannot specify a 32-bit instruction. However,
    the translated version used a conventional load to specify the location of the
    actual operand 32 bits for the current value of the program counter.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '`add r2,pc,#20` is treated differently. Here, the 32-bit literal is generated
    by adding 20 to the value of the current pc, because the address to be located
    is 20 bytes from the current PC value.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the registers when the code is executed up to `nop` using `gdb`.
    We will examine both the contents of the registers at the end of the program and
    then look at the memory locations. You can see the data stored in memory and the
    constants accessed by program counter relative addressing:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the next chapter, we will continue the theme of addressing, looking at how
    the ARM implements subroutines and how you can use the stack to keep track of
    subroutine return addresses.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Addressing modes comprise all the ways to express the location of an item in
    memory. Addressing modes are simultaneously the easiest and most difficult topic
    in assembly language programming. The concept is simple, but indirect addressing
    modes that use pointers may take some effort to visualize.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we learned about literal or immediate addressing where an operand
    is an actual value (it’s the thing itself and not the location). Literal values
    are used to specify constants – for example, in x + 5, the number 5 is a literal.
    This is the simplest of addressing modes, and no memory location is accessed because
    the data is part of the instruction.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: We also looked at the ARM’s rather unusual way of specifying literals, by providing
    a value in the range of 0 to 255 and a multiplier that can multiply it by an even
    power of 2\. You can specify 5 and store 5, 20, 80, and so on.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Much of this chapter was taken up by register indirect addressing, which has
    a lot of other names (indexed and pointer-based). In this case, the address is
    given by the contents of a register. The instruction specifies not the actual
    address of an operand but the register that points to it. Because you can manipulate
    data in a register, you can manipulate addresses and access data structures such
    as arrays and tables.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: The ARM provides RISC-style auto-incrementing and decrementing. That means you
    can use a pointer and increment it or decrement it beforehand (or after it is
    used).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: We also looked at a special form of register indirect addressing, relative addressing,
    where the pointer is the program counter itself – that is, the address of an operand
    is specified with respect to the instruction that accesses it. This means that
    code using program counter relative addressing can be moved around in memory without
    any addresses being recalculated.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at a topic that is fundamental to programming
    – the subroutine and the stack. This topic is also heavily related to addressing
    modes.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨编程基础中的一个主题——子程序和栈。这个主题也与寻址模式密切相关。
