<html><head></head><body>
		<div><h1 id="_idParaDest-117" class="chapter-number"><a id="_idTextAnchor118"/>4</h1>
			<h1 id="_idParaDest-118"><a id="_idTextAnchor119"/>Application Models</h1>
			<p>This chapter will guide you through some small enhancements to an existing add-on module. You already registered your add-on module in the Odoo instance in <a href="B20997_03.xhtml#_idTextAnchor083"><em class="italic">Chapter 3</em></a>,<em class="italic"> Creating Odoo Add-On Modules</em>. Now, you will explore the database aspects of the module in more depth. You will learn how to create a new model (database table), add new fields, and apply constraints. You will also discover how to use inheritance in Odoo to modify existing models. In this chapter, you will use the same module that you created in the previous chapter.</p>
			<p>This chapter covers the following topics:</p>
			<ul>
				<li>Defining the model representation and order</li>
				<li>Adding data fields to a model</li>
				<li>Adding a float field with configurable precision</li>
				<li>Adding a monetary field to a model</li>
				<li>Adding relational fields to a model</li>
				<li>Adding a hierarchy to a model</li>
				<li>Adding constraint validations to a model</li>
				<li>Adding computed fields to a model</li>
				<li>Exposing related fields stored in other models</li>
				<li>Adding dynamic relations using reference fields</li>
				<li>Adding features to a model using inheritance</li>
				<li>Using abstract models for reusable model features</li>
				<li>Copying the model definition using inheritance</li>
			</ul>
			<h1 id="_idParaDest-119"><a id="_idTextAnchor120"/>Technical requirements</h1>
			<p>Before proceeding with the examples in this chapter, make sure you have the module that we developed in <a href="B20997_03.xhtml#_idTextAnchor083"><em class="italic">Chapter 3</em></a>, <em class="italic">Creating Odoo Add-On Modules</em>, and that it is properly installed and configured.</p>
			<h1 id="_idParaDest-120"><a id="_idTextAnchor121"/>Defining the model representation and order</h1>
			<p>A model <a id="_idIndexMarker180"/>refers to a representation of a database table. A model defines the structure and behavior of a database table, including fields, relationships, and various methods. Models are defined in Python code using Odoo’s <strong class="bold">object-relational mapping</strong> (<strong class="bold">ORM</strong>) system. ORM allows developers to interact with <a id="_idIndexMarker181"/>the database using Python classes and methods, rather than writing raw SQL queries.</p>
			<p>Model attributes are the features of a model that will be defined when we create a new model; otherwise, we use the attributes of the model that already exists. Models use structural attributes with an underscore prefix to define their behavior.</p>
			<h2 id="_idParaDest-121"><a id="_idTextAnchor122"/>Getting ready</h2>
			<p>The <code>my_hostel</code> instance should already contain a Python file called <code>models/hostel.py</code>, which defines a basic model. We will edit it to add new class-level attributes.</p>
			<h2 id="_idParaDest-122"><a id="_idTextAnchor123"/>How to do it...</h2>
			<p>By utilizing these attributes effectively, developers can create well-organized, reusable, and maintainable code in Odoo, leading to a more efficient and robust application. The following are the attributes that can be used on a model:</p>
			<ol>
				<li><code>_name </code>: The <code>name</code> attribute is the most important one, as it determines the internal global identifier and the database table name. The model name is expressed in dot notation within the module namespace. For instance, <code>name="hostel.hostel"</code> will create the <code>hostel_hostel</code> table in the database:<pre class="source-code">
_name = 'hostel.hostel'</pre></li>				<li><code>_table</code>: We can define the SQL table name utilized by the model if  ‘<code>_auto</code>’ is enabled:<pre class="source-code">
_name = 'project.task.stage.personal'
_table = 'project_task_user_rel'</pre></li>				<li><code>_description</code>:  To assign a descriptive title to the model that reflects its purpose <a id="_idIndexMarker182"/>and functionality, insert the following code snippet:<pre class="source-code">
_description = 'Information about hostel'</pre></li>			</ol>
			<p class="callout-heading">Note</p>
			<p class="callout">If you don’t use <code>_description</code> for your model, Odoo will show a warning in the logs.</p>
			<ol>
				<li value="4"><code>_order</code>: The default field for ordering the search results is ‘<code>id</code>’. However, this can be changed so that we can use the fields of our choice, by providing an <code>_order</code> attribute with a string containing a comma-separated list of field names. A field name can be followed by the <code>desc</code> keyword to sort it in descending order. To order the records by <code>id</code> in descending order, followed by names in ascending order, use the following code syntax:<pre class="source-code">
_order = "id desc, name"</pre></li>			</ol>
			<p class="callout-heading">Note</p>
			<p class="callout">Only fields stored in the database can be used. Non-stored computed fields can’t be used to sort records. The syntax for the <code>_order</code> string is similar to the <code>SQL ORDER BY</code> clauses, although it’s stripped down. For instance, special clauses, such as <code>NULLS FIRST</code>, are not allowed.</p>
			<ol>
				<li value="5"><code>_rec_name</code>: This is used to set the field that’s used as a representation or title for the records. The default field for <code>rec_name</code> is the name field. <code>_rec_name</code> is the <a id="_idIndexMarker183"/>display name of the record used by Odoo’s <code>rec_name</code> and set <code>hostel_code</code> as a representative of the model, use the following code syntax:<pre class="source-code">
_rec_name = 'hostel_code'
hostel_code = fields.Char(string="Code", required=True)</pre></li>			</ol>
			<p class="callout-heading">Note</p>
			<p class="callout">If your model doesn’t have a name field and you haven’t specified <code>_rec_name</code> either, your display name will be a combination of the model name and record ID, like this – <code>(</code><code>hostel.hostel, 1)</code>.</p>
			<ol>
				<li value="6"><code>_rec_names_search</code>: This is used to search specific records by mentioned field values. It is similar to using the <code>name_search</code> function. You can directly use this <a id="_idIndexMarker184"/>attribute instead of using the <code>name_search</code> method. To do so, use the following code syntax:<pre class="source-code">
_rec_names_search = ['name', 'co<a id="_idTextAnchor124"/>de']</pre></li>			</ol>
			<h2 id="_idParaDest-123"><a id="_idTextAnchor125"/>There’s more…</h2>
			<p>All models <a id="_idIndexMarker185"/>have a <code>display_name</code> field that shows the record representation in a human-readable format, which has been automatically added to all models since version 8.0. The default <code>_compute_display_name()</code> method uses the <code>_rec_name</code> attribute to determine which field contains the data for the display name. To customize the display name, you can override the <code>_compute_display_name()</code> method and provide your logic. The method should return a list of tuples, each containing the record ID and the Unicode string representation.</p>
			<p>For example, to have the hostel name and hostel code in the representation, such as <code>Youth Hostel (YHG015)</code>, we can define the following:</p>
			<p>Take a look at the following example. This will add a release date to the record’s name:</p>
			<pre class="source-code">
@api.depends('hostel_code')
    def _compute_display_name(self):
        for record in self:
            name = record.name
            if record.hostel_code:
                name = f'{name} ({record.hostel_code})'
            record.display_name = name</pre>			<p>After adding <a id="_idIndexMarker186"/>the preceding code, your <code>display_name</code> record will be updated. Suppose you have a record with the name <code>Bell House Hostel</code> and its code is <code>BHH101</code>; then, the preceding <code>_compute_display_name()</code> method will generate a name such as <code>Bell House </code><code>Hostel (BHH101)</code>.</p>
			<p>When we’re done, our <code>hostel.py</code> file should appear as follows:</p>
			<pre class="source-code">
from odoo import fields, models
class Hostel(models.Model):
_name = 'hostel.hostel'
_description = "Information about hostel"
_order = "id desc, name"
_rec_name = 'hostel_code'
name = fields.Char(string="hostel Name", required=True)
hostel_code = fields.Char(string="Code", required=True)
street = fields.Char('Street')
street2 = fields.Char('Street2')
zip = fields.Char('Zip', change_default=True)
city = fields.Char('City')
state_id = fields.Many2one("res.country.state", string='State')
country_id = fields.Many2one('res.country', string='Country')
phone = fields.Char('Phone',required=True)
mobile = fields.Char('Mobile',required=True)
email = fields.Char('Email')
@api.depends('hostel_code')
    def _compute_display_name(self):
        for record in self:
            name = record.name
            if record.hostel_code:
                name = f'{name} ({record.hostel_code})'
            record.display_name = name</pre>			<p>Your <code>&lt;form&gt;</code> view <a id="_idIndexMarker187"/>in the <code>hostel.xml</code> file will look as follows:</p>
			<pre class="source-code">
&lt;form string="Hostel"&gt;
  &lt;sheet&gt;
    &lt;div class="oe_title"&gt;
      &lt;h3&gt;
        &lt;table&gt;
          &lt;tr&gt;
            &lt;td style="padding-right:10px;"&gt;
            &lt;field name="name" required="1" 
            placeholder="Name" /&gt;&lt;/td&gt;
            &lt;td style="padding-right:10px;"&gt;
            &lt;field name="hostel_code" placeholder="Code" 
            /&gt;&lt;/td&gt;
          &lt;/tr&gt;
        &lt;/table&gt;
      &lt;/h3&gt;
    &lt;/div&gt;
    &lt;group&gt;
      &lt;group&gt;
        &lt;label for="street" string="Address"/&gt;
          &lt;div class="o_address_format"&gt;
            &lt;field name="street" placeholder="Street..." 
            class="o_address_street"/&gt;
            &lt;field name="street2" placeholder="Street 2..." 
            class="o_address_street"/&gt;
            &lt;field name="city" placeholder="City" 
            class="o_address_city"/&gt;
            &lt;field name="state_id" class="o_address_state" 
            placeholder="State" options='{"no_open": 
            True}'/&gt;
            &lt;field name="zip" placeholder="ZIP" 
            class="o_address_zip"/&gt;
            &lt;field name="country_id" placeholder="Country"
            class="o_address_country" options='{"no_open": 
            True, "no_create": True}'/&gt;
          &lt;/div&gt;
      &lt;/group&gt;
      &lt;group&gt;
        &lt;field name="phone" widget="phone"/&gt;
          &lt;field name="mobile" widget="phone"/&gt;
            &lt;field name="email" widget="email" 
            context="{'gravatar_image': True}"/&gt;
      &lt;/group&gt;
    &lt;/group&gt;
  &lt;/sheet&gt;
&lt;/form&gt;</pre>			<p>We should <a id="_idIndexMarker188"/>then upgrade the module to activate these changes in Odoo.</p>
			<p>To update the module, execute the following:</p>
			<pre class="source-code">
Activate developer mode -&gt;Apps -&gt; Update App List</pre>			<p>Then, search for the <code>my_hostel</code> module and upgrade it via the dropdown, as shown in the following screenshot:</p>
			<div><div><img src="img/B20997_04_1.jpg" alt="Figure 4.1 – The option to update the module"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1 – The option to update the module</p>
			<p>Alternatively, you can <a id="_idIndexMarker189"/>also use the <code>-u my_hostel</code> command in the comma<a id="_idTextAnchor126"/>nd line.</p>
			<h1 id="_idParaDest-124"><a id="_idTextAnchor127"/>Adding data fields to a model</h1>
			<p>A field represents a column in a database table and defines the structure of the data that can be <a id="_idIndexMarker190"/>stored in that column. Fields in Odoo models are used to specify the attributes and characteristics of the data that the model will store. Each field has a data type (e.g., <code>Char</code>, <code>Integer</code>, <code>Float</code>, or <code>Date</code>) and various attributes that determine how the field behaves.</p>
			<p>In this section, you will explore the various data types that fields can support and how to add them to<a id="_idTextAnchor128"/> a model.</p>
			<h2 id="_idParaDest-125"><a id="_idTextAnchor129"/>Getting ready</h2>
			<p>This recipe assumes that you have an instance ready with the <code>my_hostel</code> add-on module available, as described in <a href="B20997_03.xhtml#_idTextAnchor083"><em class="italic">Chapter 3</em></a>, <em class="italic">Creating Odoo </em><em class="italic">Add-On<a id="_idTextAnchor130"/> Modules</em>.</p>
			<h2 id="_idParaDest-126"><a id="_idTextAnchor131"/>How to do it...</h2>
			<p>The <code>my_hostel</code> add-on module should already have <code>models/hostel.py</code>, defining a basic model. We will edit it to add new fields:</p>
			<ol>
				<li>Use the <a id="_idIndexMarker191"/>minimal syntax to add fields to the <code>Hostel</code> model:<pre class="source-code">
from odoo import models, fields
class Hostel(models.Model):
    # …
    email = fields.Char('Email')
    hostel_floors = fields.Integer(string="Total Floors")
    image = fields.Binary('Hostel Image')
    active = fields.Boolean("Active", default=True,
    help="Activate/Deactivate hostel record")
    type = fields.Selection([("male", "Boys"), ("female", "Girls"),
    ("common", "Common")], "Type", help="Type of Hostel",
    required=True, default="common")
    other_info = fields.Text("Other Information",
    help="Enter more information")
    description = fields.Html('Description')
    hostel_rating = fields.Float('Hostel Average Rating', digits=(14, 4))</pre><p class="list-inset">We have added new fields to the model. We still need to add these fields to the form view <a id="_idIndexMarker192"/>in order to reflect these changes in the user interface. Refer to the following code to add fields to the form view:</p><pre class="source-code">&lt;field name="image" widget="image" class="oe_avatar"/&gt;
  &lt;group&gt;
    &lt;group&gt;
    &lt;label for="street" string="Address"/&gt;
    &lt;div class="o_address_format"&gt;
      &lt;field name="street" placeholder="Street..." class="o_address_street"/&gt;
      &lt;field name="street2" placeholder="Street 2..." class="o_address_street"/&gt;
      &lt;field name="city" placeholder="City" class="o_address_city"/&gt;
      &lt;field name="state_id" class="o_address_state" 
      placeholder="State" options='{"no_open": True}'/&gt;
      &lt;field name="zip" placeholder="ZIP" class="o_address_zip"/&gt;
      &lt;field name="country_id" placeholder="Country"
      class="o_address_country" options='{"no_open": True,
       "no_create": True}'/&gt;
    &lt;/div&gt;
    &lt;field name="phone" widget="phone"/&gt;
    &lt;field name="mobile" widget="phone"/&gt;
    &lt;field name="email" widget="email" context="{'gravatar_image': True}"/&gt;
    &lt;/group&gt;
    &lt;group&gt;
      &lt;field name="hostel_floors"/&gt;
      &lt;field name="active"/&gt;
      &lt;field name="type"/&gt;
      &lt;field name="hostel_rating"/&gt;
      &lt;field name="other_info"/&gt;
    &lt;/group&gt;
  &lt;/group&gt;
  &lt;group&gt;
    &lt;field name="description"/&gt;
  &lt;/group&gt;</pre></li>			</ol>
			<p>Upgrading the <a id="_idIndexMarker193"/>module will make these changes effective in the Odoo m<a id="_idTextAnchor132"/>odel.</p>
			<h2 id="_idParaDest-127"><a id="_idTextAnchor133"/>How it works...</h2>
			<p>To add fields <a id="_idIndexMarker194"/>to models, you need to define an attribute of the corresponding type in their Python classes. The available types of non-relational fields <a id="_idIndexMarker195"/>are as follows:</p>
			<ul>
				<li><strong class="bold">Char</strong>: Stores string values.</li>
				<li><strong class="bold">Text</strong>: Stores multiline string values.</li>
				<li><strong class="bold">Selection</strong>: Stores one value from a list of predefined values and descriptions. This has a list of values and description pairs. The value that is selected is what gets stored in the database, and it can be a string or an integer. The description is automatically translatable.</li>
			</ul>
			<p class="callout-heading">Note</p>
			<p class="callout">Odoo does not display the description if the value is zero for integer keys. The <code>Selection</code> field also accepts a function reference as its <code>selection</code> attribute instead of a list. This allows you to dynamically generate lists of options. You can find an example relating to this in the <em class="italic">Adding dynamic relations using reference fields</em> recipe in this chapter, where a <code>selection</code> attribute is also used.</p>
			<ul>
				<li><strong class="bold">Html</strong>: Stores rich text in the HTML format.</li>
				<li><strong class="bold">Binary</strong>: Stores binary files, such as images or documents.</li>
				<li><code>True</code>/<code>False</code> values.</li>
				<li><code>fields.Date.today()</code> to set the default value to the current date.</li>
				<li><code>datetime</code> values as Python datetime objects in UTC time. Use <code>fields.Date.now()</code> to set the default value to the current time.</li>
				<li><strong class="bold">Integer</strong>: Stores integer values.</li>
				<li><strong class="bold">Float</strong>: Stores numeric values with optional precision (total digits and decimal digits).</li>
				<li><strong class="bold">Monetary</strong>: Stores an amount in a specific currency. This will be explained further in the <em class="italic">Adding a monetary field to a model</em> recipe in this chapter.</li>
			</ul>
			<p><em class="italic">Step 1</em> of this recipe shows the minimal syntax to add to each field type. The field definitions can be <a id="_idIndexMarker196"/>expanded to add other optional attributes, as <a id="_idTextAnchor134"/>shown in <em class="italic">step 2</em>. Here’s an explanation of the field attributes that were used:</p>
			<ul>
				<li><code>string</code> is the field’s title and is used in UI view labels. It is optional. If not set, a label will be derived from the field name by adding a title case and replacing the underscores with spaces.</li>
				<li><code>translate</code>, when set to <code>True</code>, makes the field translatable. It can hold a different value, depending on the user interface language.</li>
				<li><code>default</code> is the default value. It can also be a function that is used to calculate the default value – for example, <code>default=_compute_default</code>, where <code>_compute_default</code> is a method that was defined on the model before the field definition.</li>
				<li><code>help</code> is an explanation text that’s displayed in the UI tooltips.</li>
				<li><code>groups</code> makes the field available only to some security groups. It is a string containing a comma-separated list of XML IDs for security groups. This is addressed in more detail in <a href="B20997_10.xhtml#_idTextAnchor549"><em class="italic">Chapter 10</em></a>, <em class="italic">Security Access</em>.</li>
				<li><code>copy</code> flags whether the field value is copied when the record is duplicated. By default, it is <code>True</code> for non-relational and <code>Many2one</code> fields, and <code>False</code> for <code>One2many</code> and computed fields.</li>
				<li><code>index</code>, when set to <code>True</code>, creates a database index for the field, which sometimes allows for faster searches. It replaces the deprecated <code>select=1</code> attribute.</li>
				<li>The <code>readonly</code> flag makes the field read-only by default in the user interface.</li>
				<li>The <code>required</code> flag makes the field mandatory by default in the user interface.</li>
				<li>The various whitelists that are mentioned here are defined in <code>odoo/fields.py</code>.</li>
				<li>The <code>company_dependent</code> flag makes the field store different values for each company. It replaces the deprecated <code>Property</code> field type.</li>
				<li>The value isn’t stored on the model table. It is registered as `<code>ir.property</code>`. When the value of the <code>company_dependent</code> field is needed, an `<code>ir.property</code>` is searched and linked to the current company (and the current record if one property exists). If the value is changed on the record, it either modifies the existing property for the current record (if one exists) or creates a new <a id="_idIndexMarker197"/>one for the current company and <code>res_id</code>. If the value is changed on the company side, it will impact all records on which the value hasn’t been changed.</li>
				<li><code>group_operator</code> is an aggregate function used to display results in the group by mode.<p class="list-inset">Possible values for this attribute include <code>count</code>, <code>count_distinct</code>, <code>array_agg</code>, <code>bool_and</code>, <code>bool_or</code>, <code>max</code>, <code>min</code>, <code>avg</code>, and <code>sum</code>. Integer, float, and monetary field types have the default <code>sum</code> value for this attribute. This field is used by the <code>:meth:~odoo.models.Model.read_group</code> method to group rows based on this field.</p><p class="list-inset">The supported aggregate functions are as follows:</p><ul><li><code>array_agg</code>: Concatenates all values, including nulls, into an array</li><li><code>count</code>: Counts the number of rows</li><li><code>count_distinct</code>: Counts the number of distinct rows</li><li><code>bool_and</code>: Returns <code>true</code> if all values are <code>true</code>, and <code>false</code> otherwise</li><li><code>bool_or</code>: Returns <code>true</code> if at least one value is <code>true</code>, and <code>false</code> otherwise</li><li><code>max</code>: Returns the maximum value of all values</li><li><code>min</code>: Returns the minimum value of all values</li><li><code>avg</code>: Returns the average (arithmetic mean) of all values</li><li><code>sum</code>: Returns the sum of all values</li></ul></li>
				<li><code>Store</code>: This is for whether the field is stored in the database (the default is <code>True</code>, and <code>False</code> for computed fields).</li>
				<li><code>group_expand</code>: This function <a id="_idIndexMarker198"/>is used to expand <code>read_group</code> results when grouping on the current field:<pre class="source-code">
   .. code-block:: python
        @api.model
        def _read_group_selection_field(self, values, domain, order):
            return ['choice1', 'choice2', ...] # available selection choices.
         @api.model
        def _read_group_many2one_field(self, records, domain, order):
            return records + self.search([custom_domain])</pre></li>				<li>The <code>sanitize</code> flag is employed within HTML fields to systematically remove potentially insecure tags from their content. Activation of this flag results in a comprehensive cleansing of the input. For users seeking more nuanced control over HTML sanitization, there are additional attributes available. It is important to note that these attributes are effective only when the sanitize flag is enabled.</li>
			</ul>
			<p>If you need <a id="_idIndexMarker199"/>finer control in HTML sanitization, there are a few more attributes that you can use, which only work if <code>sanitize</code> is enabled:</p>
			<ul>
				<li><code>sanitize_tags=True</code>, to remove tags that are not part of a whitelist (this is the default)</li>
				<li><code>sanitize_attributes=True</code>, to remove attributes of the tags that are not part of a whitelist</li>
				<li><code>sanitize_style=True</code>, to remove style properties that are not part of a whitelist</li>
				<li><code>strip_style=True</code>, to remove all style elements</li>
				<li><code>strip_class=True</code>, to remove the class attributes</li>
			</ul>
			<p>Finally, we updated the form view according to the newly added fields in the model. We placed all fields in form view, but you can place them anywhere you want. Form views are explained in more detail in <a href="B20997_09.xhtml#_idTextAnchor446"><em class="italic">Chapter 9</em></a>, <em class="italic">Backend Views</em>.</p>
			<h2 id="_idParaDest-128"><a id="_idTextAnchor135"/>There’s more...</h2>
			<p>The <code>Date</code> and <code>Datetime</code> field objects expose a few utility methods that can be convenient for Date and Datetime:</p>
			<p>For <code>Date</code>, we have <a id="_idIndexMarker200"/>the following:</p>
			<ul>
				<li><code>fields.Date.to_date(string_value)</code> parses the string into a date object.</li>
				<li><code>fields.Date.to_string(date_value)</code> converts the Python Date object to a string.</li>
				<li><code>fields.Date.today()</code> returns the current day in a string format. This is appropriate for use with default values.</li>
				<li><code>fields.Date.context_today(record, timestamp)</code> returns the day of the timestamp (or the current day, if the timestamp is omitted) in a string format, according to the time zone of the record’s (or record set’s) context.</li>
			</ul>
			<p>For <code>Datetime</code>, we have <a id="_idIndexMarker201"/>the following:</p>
			<ul>
				<li><code>fields.Datetime.to_datetime(string_value)</code> parses the string into a datetime object.</li>
				<li><code>fields.Datetime.to_string(datetime_value)</code> converts the datetime object to a string.</li>
				<li><code>fields.Datetime.now()</code> returns the current day and time in a string format. This is appropriate to use for default values.</li>
				<li><code>fields.Datetime.context_timestamp(record, timestamp) </code>converts a timestamp-naive datetime object into a time zone-aware datetime object. using the time zone in the context of a record. This is not suitable for default values but can be used for instances when you’re sending data to an external system.</li>
			</ul>
			<p>In addition <a id="_idIndexMarker202"/>to the <a id="_idIndexMarker203"/>basic fields, there are also few <a id="_idIndexMarker204"/>relational fields such as <code>Many2one</code>, <code>One2many</code>, and <code>Many2many</code>. These are covered in the <em class="italic">Adding relational fields to a model</em> recipe in this chapter.</p>
			<p>You can also create fields with values that are computed automatically by using the <code>compute</code> field attribute to define the computation function. This is covered in the <em class="italic">Adding computed fields to a model</em> recipe of this chapter.</p>
			<p>Some fields are added by default in Odoo models, so you should avoid using these names for your fields. These are as follows:</p>
			<ul>
				<li><code>id</code> (the record’s automatically generated identifier)</li>
				<li><code>create_date</code> (the record creation timestamp)</li>
				<li><code>create_uid</code> (the user who created the record)</li>
				<li><code>write_date</code> (the last recorded timestamp edit)</li>
				<li><code>write_uid</code> (the user who last edited the record)</li>
			</ul>
			<p>The automatic creation of these log fields can be disabled by setting the <code>_log_access=False</code> model attribute.</p>
			<p>Another special column that can be added to a model is <code>active</code>. It must be a <code>Boolean</code> field, allowing users <a id="_idIndexMarker205"/>to mark records as inactive. It is used to enable the <code>archive</code>/<code>unarchive</code> feature on the records. Its definition is as follows:</p>
			<pre class="source-code">
active = fields.Boolean('Active', default=True)</pre>			<p>By default, only records with <code>active</code> set to <code>True</code> are visible. To retrieve them, we need to use a domain filter with <code>[('active', '=', False)]</code>. Alternatively, if the <code>'active_test': False</code> value is added to the environment’s context, ORM will not filter out inactive records.</p>
			<p>In some cases, you may not be able to modify the context to get both the active and the inactive records. If so, you can use the <code>['|', ('active', '=', True), ('active', '=', </code><code>False)]</code> domain.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout"><code>[('active', 'in' (True, False))]</code> does not work as you might expect. Odoo explicitly looks for an <code>('active', '=', False)</code> clause in the domain. It will default to restricting the search<a id="_idTextAnchor136"/> to active records only.</p>
			<h1 id="_idParaDest-129"><a id="_idTextAnchor137"/>Adding a float field with configurable precision</h1>
			<p>When <a id="_idIndexMarker206"/>using <code>float</code> fields, we may want to <a id="_idIndexMarker207"/>let the end user configure the decimal precision that will be used. In this recipe, we will add a <code>hostel_rating</code> field to the <code>hostel</code> model, with user-confi<a id="_idTextAnchor138"/>gurable decimal precision.</p>
			<h2 id="_idParaDest-130"><a id="_idTextAnchor139"/>Getting ready</h2>
			<p>We will continue using the <code>my_hostel</code> add-on module<a id="_idTextAnchor140"/> from the previous recipe.</p>
			<h2 id="_idParaDest-131"><a id="_idTextAnchor141"/>How to do it...</h2>
			<p>Perform the following steps to apply dynamic decimal precision to the model’s <code>hostel_rating</code> field:</p>
			<ol>
				<li>Create a <a id="_idIndexMarker208"/>data folder and add a <code>data.xml</code> file. Inside this file, add the following record for the decimal precision <a id="_idIndexMarker209"/>model. This will add a new configuration.<pre class="source-code">
&lt;record forcecreate="True" id="decimal_point" model="decimal.precision"&gt;
&lt;field name="name"&gt;Rating Value&lt;/field&gt;
&lt;field name="digits"&gt;3&lt;/field&gt;
&lt;/record&gt;</pre></li>				<li>Activate <strong class="bold">Developer Mode</strong> from the link in the <strong class="bold">Settings</strong> menu (refer to the <em class="italic">Activating the Odoo developer tools</em> recipe in <a href="B20997_01.xhtml#_idTextAnchor020"><em class="italic">Chapter 1</em></a>, <em class="italic">Installing the Odoo Development Environment</em>). This will enable the <strong class="bold">Settings</strong> | <strong class="bold">Technical</strong> menu.</li>
				<li>Access the decimal precision configurations. To do this, open the <strong class="bold">Settings</strong> top menu and select <strong class="bold">Technical</strong> | <strong class="bold">Database Structure</strong> | <strong class="bold">Decimal Accuracy</strong>. We should see a list of the currently defined settings.</li>
			</ol>
			<div><div><img src="img/B20997_04_2.jpg" alt="Figure 4.2 – Creating new decimal precision"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2 – Creating new decimal precision</p>
			<ol>
				<li value="4">To add <a id="_idIndexMarker210"/>the <code>model</code> field using <a id="_idIndexMarker211"/>this decimal precision setting, edit the <code>models/hostel.py</code> file by adding the following code:<pre class="source-code">
class Hostel(models.Model):
    hostel_rating = fields.Float('Hostel Average Rating',
    # digits=(14, 4) # Method 1: Optional precision (total, decimals),
    digits='Rating Value' # Method 2
)</pre></li>			</ol>
			<h2 id="_idParaDest-132"><a id="_idTextAnchor142"/>How it works...</h2>
			<p>When you add a string value to the <code>digits</code> attribute of the field, Odoo looks up that string in the decimal accuracy model’s <code>Usage</code> field and returns a tuple, with 16-digit precision and the number of decimals that were defined in the configuration. Using the field definition, instead of having it hardcoded, we allow the end user to configure<a id="_idTextAnchor143"/> it according to their needs.</p>
			<h1 id="_idParaDest-133"><a id="_idTextAnchor144"/>Adding a monetary field to a model</h1>
			<p>To work <a id="_idIndexMarker212"/>with monetary values and currencies in a model, we can use Odoo to provide special support for working with monetary values and currencies in its models, through the use of specific field types and features. Odoo’s special support for monetary values and currencies simplifies the handling of financial data, ensuring accuracy, consistency, and compliance with <a id="_idTextAnchor145"/>currency-related requirements.</p>
			<h2 id="_idParaDest-134"><a id="_idTextAnchor146"/>Getting ready</h2>
			<p>We will use the same <code>my_hostel</code> add-on module from the previous recipe.</p>
			<h2 id="_idParaDest-135"><a id="_idTextAnchor147"/>How to do it…</h2>
			<p>We need to add a currency field along with a monetary field to store the currency for the amounts.</p>
			<p>We will add <code>models/hostel_room.py</code>, to add the necessary fields:</p>
			<ol>
				<li>Create the field to store the currency for the amounts:<pre class="source-code">
class HostelRoom(models.Model):
    _name = "hostel.room"
    …#
    currency_id = fields.Many2one('res.currency', string='Currency')</pre></li>				<li>Add the monetary field to store the amount:<pre class="source-code">
class HostelRoom(models.Model):
    _name = "hostel.room"
    …#
    rent_amount = fields.Monetary('Rent Amount', help="Enter rent amount per month") # optional attribute: currency_field='currency_id' incase currency field have another name then 'currency_id'</pre><p class="list-inset">Create a security file for the new model and a form view to show it in the UI. Upgrade <a id="_idIndexMarker213"/>the add-on module to apply the changes. The monetary field will appear like this:</p></li>			</ol>
			<div><div><img src="img/B20997_04_3.jpg" alt="Figure 4.3 – The currenc﻿y symbol in the monetary field"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.3 – The currenc<a id="_idTextAnchor148"/>y symbol in the monetary field</p>
			<h2 id="_idParaDest-136"><a id="_idTextAnchor149"/>How it works…</h2>
			<p>Odoo can display <code>monetary</code> fields correctly in the user interface because they have a second field that indicates their currency. This field is similar to a float field.</p>
			<p>The currency field is usually named <code>currency_id</code>, but we can use any other name as long as we specify it with the optional <code>currency_field</code> parameter.</p>
			<p>If your currency information is stored in a field named <code>currency_id</code>, you don’t need to specify the <code>currency_field</code> attribute for the monetary field.</p>
			<p>This is helpful when you have to store amounts in different currencies in the same record. For example, if you want to have the currency of the sale order and the company, you can <a id="_idIndexMarker214"/>create two fields as <code>fields.Many2one(res.currency)</code> and use one for each amount.</p>
			<p>The currency definition (the <code>decimal_precision</code> field of the <code>res.currency model</code>) determines the de<a id="_idTextAnchor150"/>cimal precision for the amount.</p>
			<h1 id="_idParaDest-137"><a id="_idTextAnchor151"/>Adding relational fields to a model</h1>
			<p>Relational <a id="_idIndexMarker215"/>fields are used to represent relations between Odoo models. There are three types of relations:</p>
			<ul>
				<li><code>many-to-one</code>, or <code>m2o</code> for</li>
				<li><code>one-to-many</code>, or <code>o2m</code> for short</li>
				<li><code>many-to-many</code>, or <code>m2m</code> for short</li>
			</ul>
			<p>To illustrate this, let’s consider the hostel room model. A room belongs to a single hostel, so the relation between the hostel and the room is <code>m2o</code>. However, a hostel can have multiple rooms, so the opposite relationship is <code>o2m</code>.</p>
			<p>We can also have a <code>m2m</code> relationship. For instance, a room can offer various amenities and amenities can be available in different rooms. This is a<a id="_idTextAnchor152"/> bidirectional <code>m2m</code> relationship.</p>
			<h2 id="_idParaDest-138"><a id="_idTextAnchor153"/>Getting ready</h2>
			<p>We will continue using the <code>my_hostel</code> add-on <a id="_idTextAnchor154"/>module from the previous recipe.</p>
			<h2 id="_idParaDest-139"><a id="_idTextAnchor155"/>How to do it...</h2>
			<p>We will edit the <code>models/hostel_room.py</code> file to add these fields:</p>
			<ol>
				<li>Add the <code>m2o</code> field for the hostel in <code>Hostel Room</code>:<pre class="source-code">
class HostelRoom(models.Model):
    
# ...
    hostel_id = fields.Many2one("hostel.hostel", "hostel", help="Name of hostel")</pre></li>				<li>We want to create a <code>o2m</code> field for a student that links to a room.</li>
				<li>First, we need a new model for hostel students. We will make a<code> hostel_student.py</code> file and add some basic fields to the hostel student model. Then, we will add a <code>room_id</code> <code>m2o</code> field to connect the student and room models.</li>
				<li>Finally, we will <a id="_idIndexMarker216"/>add an <code>o2m</code> field, <code>student_ids</code>, of the <code>hostel.student</code> model to the <code>hostel.room</code> model:<pre class="source-code">
class HostelStudent(models.Model):
    _name = "hostel.student"
    name = fields.Char("Student Name")
    gender = fields.Selection([("male", "Male"),
    ("female", "Female"), ("other", "Other")],
    string="Gender", help="Student gender")
    active = fields.Boolean("Active", default=True,
    help="Activate/Deactivate hostel record")
    <strong class="bold">room_id = fields.Many2one("hostel.room", "Room",</strong>
<strong class="bold">    </strong><strong class="bold">help="Select hostel room")</strong>
class HostelRoom(models.Model):
    _name = "hostel.room"
    # ...
    student_ids = fields.One2many("hostel.student", "<strong class="bold">room_id</strong>",
    string="Students", help="Enter students")</pre></li>				<li>We will <a id="_idIndexMarker217"/>create a new file, <code>hostel_amenities.py</code>. Add the following code to the file:<pre class="source-code">
class HostelAmenities(models.Model):
    _name = "hostel.amenities"
    _description = "Hostel Amenities"
    name = fields.Char("Name", help="Provided Hostel Amenity")
    active = fields.Boolean("Active",
    help="Activate/Deactivate whether the amenity should be given or not")</pre><p class="list-inset">Now, we will <a id="_idIndexMarker218"/>add an <code>m2m</code> field of amenities to the <code>hostel.room</code> model. Add the following code to <code>hostel_room.py</code>:</p><pre class="source-code">class HostelRoom(models.Model):
    _name = "hostel.room"
    # ...
    hostel_amenities_ids = fields.Many2many("hostel.amenities",
    "hostel_room_amenities_rel", "room_id", "amenitiy_id",
    string="Amenities", domain="[('active', '=', True)]",
    help="Select hostel room amenities")</pre></li>			</ol>
			<p>Now, upgrade the add-on module, and the new fields should be available in the model. They won’t be visible in the views until they are added to them. We will add new fields to the <code>hostel_room.xml</code> file.</p>
			<p>We can confirm their addition by inspecting the <code>model</code> fields in <strong class="bold">Settings</strong> | <strong class="bold">Technical</strong> | <strong class="bold">Database St<a id="_idTextAnchor156"/>ructure</strong> | <strong class="bold">Models</strong> in <strong class="bold">Developer</strong> mode.</p>
			<h2 id="_idParaDest-140"><a id="_idTextAnchor157"/>How it works…</h2>
			<p>An <code>m2o</code> field stores the database ID of another record in a column of the model’s table. This creates a foreign key constraint in the database, which ensures that the stored ID is a valid reference <a id="_idIndexMarker219"/>to a record in another table. By default, these relationship fields do not have a database index, but you can add one by setting the <code>index=True</code> attribute.</p>
			<p>You can also specify what happens when the record that is referenced by an <code>m2o</code> field is deleted. The <code>ondelete</code> attribute controls this behavior. For instance, what should happen to students when their room record is deleted? The default option is <code>'set null'</code>, which means the field will have an empty value. Another option is <code>'restrict'</code>, which means the related record cannot be deleted. A third option is <code>'cascade'</code>, which means the linked record will be deleted as well.</p>
			<p>You can also use <code>context</code> and <code>domain</code> for other relational fields. These attributes are mainly useful on the client side, and they provide default values for the views of the related records that are accessed through a field:</p>
			<ul>
				<li><code>context</code> sets some <a id="_idIndexMarker220"/>variables in the client context when you click on a field to see the related record’s view. For example, you can use it to set default values for new records that are created in that view.</li>
				<li><code>domain</code> is a filter <a id="_idIndexMarker221"/>that limits the list of related records that you can choose from.</li>
			</ul>
			<p>You can learn more about <code>context</code> and <code>domain</code> in <a href="B20997_09.xhtml#_idTextAnchor446"><em class="italic">Chapter 9</em></a>, <em class="italic">Backend Views</em>.</p>
			<p>An <code>o2m</code> field is the opposite of an <code>m2o</code> field, and it lets you access a list of related records from a model. Unlike other fields, it does not have a column in the database table. It is just a convenient way to display these related records in views. To use an <code>o2m</code> field, you need to have a corresponding <code>m2o field</code> in the other model. In our example, we added an <code>o2m</code> field to the room model. The  <code>student_ids</code> <code>o2m</code> field has a reference to the <code>room_id</code> field of the <code>hostel.room</code> model.</p>
			<p>A <code>m2m</code> field does not have a column in the model’s table. Instead, it uses another table in the database to store the relationship between two models. This table has two columns for the IDs of the related records. When you link a room and its amenity with an <code>m2m</code> field, a new record is created in this table with the room’s ID and the amenity’s ID.</p>
			<p>Odoo creates the relationship table for you. By default, the name of the relationship table is made from the names of the two models, sorted alphabetically, with a <code>_rel</code> suffix. You can change this name with the <code>relation</code> attribute.</p>
			<p>You should use the <code>relation</code> attribute when the names of the two models are too long for the default name. PostgreSQL has a limit of 63 characters for database identifiers. So, if the <a id="_idIndexMarker222"/>names of the two models are more than 23 characters each, you should set a shorter name with the <code>relation</code> attribute. We will<a id="_idTextAnchor158"/> explain this more in the next section.</p>
			<h2 id="_idParaDest-141"><a id="_idTextAnchor159"/>There’s more...</h2>
			<p>You can also use the <code>auto_join</code> attribute for <code>m2o</code> fields. This attribute lets ORM use SQL joins <a id="_idIndexMarker223"/>on this field. This means that ORM does not check the user access control and record access rules for this field. This can help with performance issues in some cases, but it is better to avoid it.</p>
			<p>We have seen the simplest way to define the relational fields. Now, let’s look at the attributes that are specific to these fields.</p>
			<p>These are <a id="_idIndexMarker224"/>the attributes for the <code>o2m</code> field:</p>
			<ul>
				<li> <code>comodel_name</code>: This is the name of the model that the field relates to. You need this attribute for all relational fields. You can write it without the keyword, as the first argument.</li>
				<li><code>inverse_name</code>: This is only for the <code>o2m</code> fields. It is the name of the <code>m2o</code> field in the other model that links back to this model.</li>
				<li><code>limit</code>: This is for the <code>o2m</code> and <code>m2m</code> fields. It sets a maximum number of records to read and display in the user interface.</li>
			</ul>
			<p>These are <a id="_idIndexMarker225"/>the attributes for the <code>m2m</code> field:</p>
			<ul>
				<li><code>comodel_name</code>: This is the name of the model that the field relates to. It is the same as for the <code>o2m</code> field.</li>
				<li><code>relation</code>: This is the name of the table in the database that stores the relationship. You can use this attribute to change the default name.</li>
				<li><code>column1</code>: This is the name of column 1 in the relation table that links to this model.</li>
				<li><code>column2</code>: This is the <a id="_idIndexMarker226"/>name of column 2 in the relation table that links to the other model.</li>
			</ul>
			<p>Odoo typically handles the creation and management of these attributes automatically. It can identify and utilize an existing relation table for an inverse <code>m2m</code> field. However, there are specific scenarios where manual intervention is required.</p>
			<p>When dealing with multiple <code>m2m</code> fields between the same two models, it becomes necessary to assign distinct relation table names for each field.</p>
			<p>In cases where <a id="_idIndexMarker227"/>the names of the two models exceed PostgreSQL’s limit of 63 characters for database object names, you must set these attributes yourself. The default relation table name is typically <code>&lt;model1&gt;_&lt;model2&gt;rel</code>. However, this table includes a primary key index with a longer name (<code>&lt;model1&gt;&lt;model2&gt;rel&lt;model1&gt;id&lt;model2&gt;_id_key</code>), which also needs to adhere to the 63-character limit. Therefore, if the combined names of the two models surpass this limit, you<a id="_idTextAnchor160"/> must opt for a shorter relation table name.</p>
			<h1 id="_idParaDest-142"><a id="_idTextAnchor161"/>Adding a hierarchy to a model</h1>
			<p>You can use an <code>m2o</code> field to represent hierarchies, where each record has a parent record and <a id="_idIndexMarker228"/>many child records in the same model. However, Odoo also provides improved support for this type of field by using the <code>nested set model</code> (<a href="https://en.wikipedia.org/wiki/Nested_set_model">https://en.wikipedia.org/wiki/Nested_set_model</a>). When activated, queries using the <code>child_of</code> operator in their domain filters will run significantly faster.</p>
			<p>Staying with the <code>Hostel</code> example, we will build a hierarchical category<a id="_idTextAnchor162"/> tree that can be used to categorize hostels.</p>
			<h2 id="_idParaDest-143"><a id="_idTextAnchor163"/>Getting ready</h2>
			<p>We will continue using the <code>my_h<a id="_idTextAnchor164"/>ostel</code> add-on module from the previous recipe.</p>
			<h2 id="_idParaDest-144"><a id="_idTextAnchor165"/>How to do it...</h2>
			<p>We will add a new Python file, <code>models/hostel_categ.py</code>, for the category tree, as follows:</p>
			<ol>
				<li>To load the new Python code file, add the following line to <code>models/__init__.py</code>:<pre class="source-code">
from . import <code>Hostel Category</code> model with the parent and child relationships, create the <code>models/hostel_categ.py</code> file with the following code:<pre class="source-code">
from odoo import models, fields, api
class HostelCategory(models.Model):
    _name = "hostel.category"
    name = fields.Char('Category')
    parent_id = fields.Many2one(
        'hostel.category',
        string='Parent Category',
        ondelete='restrict',
        index=True)
    parent_path = fields.Char(index=True)
    child_ids = fields.One2many(
        'hostel.category', 'parent_id',
        string='Child Categories')</pre></li>				<li>To enable the <a id="_idIndexMarker230"/>special hierarchy support, also add the following code:<pre class="source-code">
_parent_store = True
_parent_name = "parent_id" # optional if field is 'parent_id'
parent_path = fields.Char(index=True, unaccent=False)</pre></li>				<li>To add a check to prevent looping relations, add the following line to the model:<pre class="source-code">
from odoo.exceptions import ValidationError
...
@api.constrains('parent_id')
def _check_hierarchy(self):
    if not self._check_recursion():
        raise models.ValidationError(
            'Error! You cannot create recursive categories.')</pre></li>				<li>Now, we need to assign a category to a hostel. To do this, we will add a new <code>m2o</code> field to the <code>hostel.hostel</code> model:<pre class="source-code">
category_id = fields.Many2one('hostel.category')</pre></li>			</ol>
			<p>Finally, a module upgrade will make these changes effective.</p>
			<p>To display the <code>hostel.category</code> model in the user interface, you will need to add menus, views, and security rules. For more details, refer to <a href="B20997_03.xhtml#_idTextAnchor083"><em class="italic">Chapter 3</em></a>, <em class="italic">Creating Odoo Add-On Modules</em>. Alternatively, you can access all code at <a href="https://github.com/PacktPublishing/Odoo-17-Development-Cookbook-Fifth-Edition/tree/main/Chapter04">https://github.com/PacktPublishing/Odoo-17-Development-Cookbook-Fifth-Edition/tree/main/Chapter04</a>.</p>
			<h2 id="_idParaDest-145"><a id="_idTextAnchor166"/>How it works…</h2>
			<p>We want to create a new model with hierarchical relations. This means that each record can have a <a id="_idIndexMarker231"/>parent record and many child records in the same model. Here are the steps to do this:</p>
			<ol>
				<li>We create an <code>m2o</code> field to reference the parent record. We use <code>index=True</code> to make this field indexed in the database for faster queries. We also use <code>ondelete='cascade'</code> or <code>ondelete='restrict'</code> to control what happens when the parent record is deleted.</li>
				<li>We create a <code>o2m</code> field to access all the child records of a record. This field does not add anything to the database, but it is a convenient way to get the child records. We add a special support for hierarchies by using <code>parent_store=True</code> in the model attribute. This makes the queries using the <code>child_of</code> operator faster, but it also makes the write operations slower. We also add a helper field called <code>parent_path</code> to store data for hierarchical searches. If we use a different name from <code>parent_id</code> for the parent field, we need to specify it with <code>parent_name</code> in the model attribute.</li>
				<li>We prevent cyclic dependencies in the hierarchy by using the <code>_check_recursion</code> method from <code>models.Model</code>. This avoids us having a record that is both an ancestor and a descendant of another record, which can cause infinite loops.</li>
				<li>We add a <code>category_id</code> field with <code>Many2one</code> type to the hostel.hostel model, so that we can assign a category to ea<a id="_idTextAnchor167"/>ch hostel. This is just to complete our example.</li>
			</ol>
			<h2 id="_idParaDest-146"><a id="_idTextAnchor168"/>There’s more…</h2>
			<p>You should use this technique for hierarchies that do not change much but are read and queried a lot. This is because the nested set model in the database needs to update the <code>parent_path</code> column (and the related database indexes) for all records when a category is added, deleted, or moved. This can be slow and costly, especially when there are many concurrent transactions.</p>
			<p>If you have a hierarchy that changes a lot, you might get better performance by using the standard <code>parent_id</code> and <code>child_ids</code> relations<a id="_idTextAnchor169"/>hips. This way, you can avoid table-level locks.</p>
			<h1 id="_idParaDest-147"><a id="_idTextAnchor170"/>Adding constraints validations to a model</h1>
			<p>We want <a id="_idIndexMarker232"/>to make sure that our models do not have invalid or inconsistent data. Odoo has two kinds of constraints to do this:</p>
			<ul>
				<li><code>Database-level constraints</code>: These are the constraints that PostgreSQL <a id="_idIndexMarker233"/>supports. The most common ones are the <code>UNIQUE</code> constraints, which prevent duplicate values. We can also use <code>CHECK</code> and <code>EXCLUDE</code> constraints for other conditions. These constraints are fast and reliable, but they are limited by what PostgreSQL can do.</li>
				<li><code>Server-level constraints</code>: These are the constraints that we write in Python <a id="_idIndexMarker234"/>code. We can use these constraints when the database-level ones are not enough for our needs. These constraints are more flexible and powerful, but they are slower and more complex.</li>
			</ul>
			<h2 id="_idParaDest-148"><a id="_idTextAnchor171"/>Getting ready</h2>
			<p>We will continue using the <code>my_hostel</code> add-on module from the previous recipe. We will use the hostel room model and add some constraints to it. We will use the hostel room model from <a href="B20997_03.xhtml#_idTextAnchor083"><em class="italic">Chapter </em><em class="italic">3</em></a>, <em class="italic">Creating Odoo Add-On Modules</em>, and add some constraints to it.</p>
			<p>We will use a <code>UNIQUE</code> constraint to ensure that room numbers are not repeated. We will also add a Python model co<a id="_idTextAnchor172"/>nstraint to check that the rent amount is positive.</p>
			<h2 id="_idParaDest-149"><a id="_idTextAnchor173"/>How to do it...</h2>
			<ol>
				<li>SQL constraints are defined through the <code>_sql_constraints</code> model attribute. This attribute is assigned a list of triples containing strings <code>(name</code>, <code>sql_definition</code>, <code>message)</code>, where <code>name</code> is a valid SQL constraint name, <code>sql_definition</code> is a <code>table_constraint</code> expression, and <code>message</code> is the error <a id="_idIndexMarker235"/>message. We can add the following code to the <code>hostel.room</code> model:<pre class="source-code">
_sql_constraints = [
   ("room_no_unique", "unique(room_no)", "Room number must be unique!")]</pre></li>				<li>A Python constraint is a method that checks a condition on a set of records. We use the <code>constrains()</code> decorator to mark the method as a constraint and to indicate which fields are involved in the condition. The constraint is automatically checked when any of these fields are changed. The method should raise an exception if the condition is not met:<pre class="source-code">
from odoo.exceptions import ValidationError
...
 @api.constrains("rent_amount")
     def _check_rent_amount(self):
        """Constraint on negative rent amount"""
        if self.rent_amount &lt; 0:
        raise ValidationError(_("Rent Amount Per Month should not be a negative value!"))</pre><p class="list-inset">You need <a id="_idIndexMarker236"/>to upgrade the add-on module and restart the server after you make these changes to the code file.</p></li>			</ol>
			<p class="callout-heading">Note</p>
			<p class="callout">If you add SQL constraints to the existing model through model inheritance, make sure you don’t have rows that violate the constraints. If you have such rows, then SQL constraints will not be added, and an error will be generated in the log.</p>
			<p class="callout">For more <a id="_idIndexMarker237"/>information on PostgreSQL constraints in general and table constraints in particular, take a look at <a href="http://www.postgresql.org/docs/current/static/ddl-constraints.html">http://www.postgresql.org/docs/current/static/ddl-constraints.html</a>.</p>
			<h2 id="_idParaDest-150"><a id="_idTextAnchor174"/>How it works…</h2>
			<p>We can use Python code to validate our models and prevent invalid data. To do this, we use two things:</p>
			<p>A method that checks a condition on a set of records. We use the <code>constrains()</code> decorator to mark the method as a constraint and to indicate which fields are involved in the condition. The constraint is automatically checked when any of these fields are changed.</p>
			<p>A <code>ValidationError</code> exception that we raise when the condition is not met. This exception shows<a id="_idTextAnchor175"/> an error message to the user and stops the operation.</p>
			<h1 id="_idParaDest-151"><a id="_idTextAnchor176"/>Adding computed fields to a model</h1>
			<p>We may <a id="_idIndexMarker238"/>want to create a field that depends on the values of other fields in the same record or in related records. For instance, we can calculate the total amount by multiplying a unit price by a quantity. In Odoo models, we can use computed fields to do this.</p>
			<p>To demonstrate how computed fields work, we will add one to the Hostel Room model that computes the availability of rooms based on student occupancy.</p>
			<p>We can also make computed fields editable and searchable. <a id="_idTextAnchor177"/>We will show you how to do this in our example as well.</p>
			<h2 id="_idParaDest-152"><a id="_idTextAnchor178"/>Getting ready</h2>
			<p>We will continue usin<a id="_idTextAnchor179"/>g the <code>my_hostel</code> add-on module from the previous recipe.</p>
			<h2 id="_idParaDest-153"><a id="_idTextAnchor180"/>How to do it...</h2>
			<p>We will <a id="_idIndexMarker239"/>modify the <code>models/hostel_room.py</code> code file to include a new field and the methods that implement its logic:</p>
			<ol>
				<li>A computed field’s value usually relies on the values of other fields in the same record. ORM requires the developer to declare those dependencies on the <code>compute</code> method using the <code>depends()</code> decorator. ORM uses the given dependencies to recompute the field whenever any of its dependencies change. Start by adding the new fields to the <code>Hostel </code><code>Rooms</code> model:<pre class="source-code">
student_per_room = fields.Integer("Student Per Room", required=True,help="Students allocated per room")'
availability = fields.Float(compute="_compute_check_availability",string="Availability", help="Room availability in hostel")
@api.depends("student_per_room", "student_ids")
def _compute_check_availability(self):
    """Method to check room availability"""
    for rec in self:
rec.availability = rec.student_per_room - len(rec.student_ids.ids)</pre></li>				<li>By default, computed fields are read-only because the user should not enter a value.<p class="list-inset">However, in some cases, it might be helpful to allow the user to set a value directly. For example, in our hostel student scenario, we will add an admission date, discharge date, and duration. We would like the user to be able to enter either the <a id="_idIndexMarker240"/>duration or the discharge date and have the other value updated accordingly:</p><pre class="source-code">
admission_date = fields.Date("Admission Date",
    help="Date of admission in hostel",
    default=fields.Datetime.today)
discharge_date = fields.Date("Discharge Date",
    help="Date on which student discharge")
duration = fields.Integer("Duration",  compute="_compute_check_duration", inverse="_inverse_duration", help="Enter duration of living")
@api.depends("admission_date", "discharge_date")
def _compute_check_duration(self):
    """Method to check duration"""
    for rec in self:
        if rec.discharge_date and rec.admission_date:
            rec.duration = (rec.discharge_date - rec.admission_date).days
def _inverse_duration(self):
    for stu in self:
        if stu.discharge_date and stu.admission_date:
            duration = (stu.discharge_date - stu.admission_date).days
            if duration != stu.duration:
                stu.discharge_date = (stu.admission_date + timedelta(days=stu.duration)).strftime('%Y-%m-%d')</pre><p class="list-inset">A compute <a id="_idIndexMarker241"/>method assigns a value to the field, while an inverse method assigns values to the field’s dependencies.</p><p class="list-inset">Note that the inverse method is invoked when the record is saved, while the compute method is invoked whenever any of its dependencies change.</p></li>				<li>Computed fields are not stored in the database by default. One solution is to store the field with the <code>store=True</code> attribute:<pre class="source-code">
availability = fields.Float(compute="_compute_check_availability", store=True, string="Availability", help="Room availability in hostel")</pre><p class="list-inset">As computed fields are not stored in the database by default, it is not possible to search on a computed field unle<a id="_idTextAnchor181"/>ss we use the <code>store=True</code> attribute or add a <code>search</code> method.</p></li>			</ol>
			<h2 id="_idParaDest-154"><a id="_idTextAnchor182"/>How it works...</h2>
			<p>A computed <a id="_idIndexMarker242"/>field looks like a regular field, except that it has a <code>compute</code> attribute that specifies the name of the method that computes its value.</p>
			<p>However, computed fields are not the same as regular fields internally. Computed fields are calculated on the fly at runtime, and because of that, they are not stored in the database, so you cannot search or write on them by default. You need to do some extra work to enable writing and search support for them. Let’s see how to do it.</p>
			<p>The computation method is calculated on the fly at runtime, but ORM uses caching to avoid recalculating it unnecessarily every time its value is accessed. So, it needs to know what other fields it relies on. It uses the <code>@depends</code> decorator to determine when its cached values should be invalidated and recalculated.</p>
			<p>Make sure that the compute method always assigns a value to the computed field. Otherwise, an error will occur. This can happen when you have conditions in your code that sometimes fail to assign a value to the computed field. This can be hard to debug.</p>
			<p>Write support can be added by implementing the <code>inverse</code> method. This uses the value assigned to the computed field to update the source fields. Of course, this only works for simple calculations. However, there are still cases where it can be helpful. In our example, we make it possible to set the discharge date by editing the duration days, since <code>Duration</code> is a computed field.</p>
			<p>The <code>inverse</code> attribute is optional; if you don’t want to make the computed field editable, you can skip it.</p>
			<p>It is also possible to make a non-stored computed field searchable by setting the <code>search</code> attribute to the method name (similar to <code>compute</code> and <code>inverse</code>). Like <code>inverse</code>, <code>search</code> is also optional; if you don’t want to make the computed field searchable, you can skip it.</p>
			<p>However, this method is not supposed to perform the actual search. Instead, it receives the operator <a id="_idIndexMarker243"/>and value used to search on the field as parameters and is supposed to return a domain, with the alternative search conditions to use.</p>
			<p>The optional <code>store=True</code> flag stores the field in the database. In this case, after being computed, the field values are stored in the database, and from then on, they are retrieved in the same way as regular fields, instead of being recomputed at runtime. Thanks to the <code>@api.depends</code> decorator, ORM will know when these stored values need to be recomputed and updated. You can think of it as a persistent cache. It also has the benefit of making the field usable for search conditions, including sorting and grouping by operations. If you use <code>store=True</code> in your compute field, you no longer need to implement the <code>search</code> method because the field is stored in a database, and you can search/sort based on it.</p>
			<p>The <code>compute_sudo=True</code> flag is for cases where the computations need to be done with higher privileges. This might be needed when the computation needs to use data that may not be accessible to the end user.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The default value of <code>compute_sudo</code> changed in Odoo v13. Before Odoo v13, the value of <code>compute_sudo</code> was <code>False</code>, but in v13, the default value of <code>compute_sudo</code> depends on the store attribute. If the <code>store</code> attribute is <code>True</code>, then <code>compute_sudo</code> is <code>True</code>; otherwise, it is <code>False</code>. However, you can always override it <a id="_idTextAnchor183"/>by explicitly setting <code>compute_sudo</code> in your field definition.</p>
			<h2 id="_idParaDest-155"><a id="_idTextAnchor184"/>There’s more...</h2>
			<p>Odoo v13 introduced <a id="_idIndexMarker244"/>a new caching mechanism for ORM. Previously, the cache was based on the environment, but now, in Odoo v13, there is one global cache. So, if you have a computed field that relies on context values, then you may get the wrong values sometimes. To solve this problem, you need to use the <code>@api.depends_context</code> decorator. Refer to the following example:</p>
			<pre class="source-code">
    @api.depends('price')
    @api.depends_context('company_id')
    def _compute_value(self):
        company_id = self.env.context.get('company_id')
       ...
       # other computation</pre>			<p>You can see in <a id="_idIndexMarker245"/>the preceding example that our computation uses <code>company_id</code> from the context. By using <code>company_id</code> in the <code>depends_context</code> decorator, we ensure that the field value will <a id="_idTextAnchor185"/>be recomputed based on the value of <code>company_id</code> in the context.</p>
			<h1 id="_idParaDest-156"><a id="_idTextAnchor186"/>Exposing related fields stored in other models</h1>
			<p>Odoo clients <a id="_idIndexMarker246"/>can only read data from the server for the fields that belong to the model they are querying. They cannot access data from related tables using dot notation as server-side code can.</p>
			<p>However, we can make the data from related tables available to the clients by adding it as related fields. This is what<a id="_idTextAnchor187"/> we will do to get the hostel of the room in the student model.</p>
			<h2 id="_idParaDest-157"><a id="_idTextAnchor188"/>Getting ready</h2>
			<p>We will conti<a id="_idTextAnchor189"/>nue using the <code>my_hostel</code> add-on module from the previous recipe.</p>
			<h2 id="_idParaDest-158"><a id="_idTextAnchor190"/>How to do it...</h2>
			<p>Edit the <code>models/hostel_student.py</code> file to add the new <code>related</code> field.</p>
			<p>Ensure that we have a field for the hostel room, and then, we add a new relation field to link the student with their hostel:</p>
			<pre class="source-code">
class HostelStudent(models.Model):
    _name = "hostel.student"
    # ...
    hostel_id = fields.Many2one("hostel.hostel", related='room_id.hostel_id')</pre>			<p>Finally, we need to upgrade the<a id="_idTextAnchor191"/> add-on module for the new field to be available in the model.</p>
			<h2 id="_idParaDest-159"><a id="_idTextAnchor192"/>How it works...</h2>
			<p>A related field is a special type of field that references another field from a different record. To create <a id="_idIndexMarker247"/>a related field, we need to specify the <code>related</code> attribute and give it a string that shows the path of fields to follow. For example, we can create a related field that shows the hostel o<a id="_idTextAnchor193"/>f the room of a student by following the <code>room_id.hostel_id</code> path.</p>
			<h2 id="_idParaDest-160"><a id="_idTextAnchor194"/>There’s more...</h2>
			<p>Related fields are, in fact, computed fields. They just provide a convenient shortcut syntax to read field values from related models. As they are computed fields, this means that the <code>store</code> attribute is also available. As a shortcut, they also have all the attributes from the referenced field, such as <code>name</code> and <code>translatable</code>, as required.</p>
			<p>Additionally, they support a <code>related_sudo</code> flag, similar to <code>compute_sudo</code>; when set to <code>True</code>, the field chain is traversed without checking the user access rights.</p>
			<p>Using related fields in a <code>create()</code> method can affect performance, as the computation of these fields is delayed until the end of their creation. So, if you have an <code>o2m</code> relationship, such as in the <code>sale.order</code> and <code>sale.order.line</code> models, and you have a related field on the line model referring to a field on the order model, you should explicitly read the field on the order model during record creation, instead of using the<a id="_idTextAnchor195"/> related field shortcut, especially if there are a lot of lines.</p>
			<h1 id="_idParaDest-161"><a id="_idTextAnchor196"/>Adding dynamic relations using reference fields</h1>
			<p>With relational fields, we need to decide the relation’s target model (or co-model) beforehand. However, sometimes, we may need to leave that decision to the user and first choose <a id="_idIndexMarker248"/>the model we want and <a id="_idIndexMarker249"/>then the record we want to l<a id="_idTextAnchor197"/>ink it to.</p>
			<p>With Odoo, this can be achieved using reference fields.</p>
			<h2 id="_idParaDest-162"><a id="_idTextAnchor198"/>Getting ready</h2>
			<p>We will co<a id="_idTextAnchor199"/>ntinue using the <code>my_hostel</code> add-on module from the previous recipe.</p>
			<h2 id="_idParaDest-163"><a id="_idTextAnchor200"/>How to do it...</h2>
			<p>Edit the <code>models/hostel.py</code> file to add the new related field:</p>
			<ol>
				<li>First, we need to add a helper method to dynamically build a list of selectable target models:<pre class="source-code">
from odoo import models, fields, api
class Hostel(models.Model):
_name = 'hostel.hostel'
    # ...
    @api.model
    def _referencable_models(self):
        models = self.env['ir.model'].search([
            ('field_id.name', '=', 'message_ids')])
        return [(x.model, x.name) for x in models]</pre></li>				<li>Then, we need to add the reference field and use the previous function to provide a list of selectable models:<pre class="source-code">
    ref_doc_id = fields.Reference(
        selection='_referencable_models',
        string='Reference Document')</pre></li>			</ol>
			<p>Since we are changing the model’<a id="_idTextAnchor201"/>s structure, a module upgrade is needed to activate these changes.</p>
			<h2 id="_idParaDest-164"><a id="_idTextAnchor202"/>How it works...</h2>
			<p>Reference fields are similar to <code>m2o</code> fields, except that they allow the user to select the model to link to.</p>
			<p>The target <a id="_idIndexMarker250"/>model is selectable from a <a id="_idIndexMarker251"/>list that’s provided by the <code>selection</code> attribute. The <code>selection</code> attribute <a id="_idIndexMarker252"/>must be a list of two-element tuples, where the first is the model’s internal identifier and the second is a text description for it.</p>
			<p>Here’s an example:</p>
			<pre class="source-code">
[('res.users', 'User'), ('res.partner', 'Partner')]</pre>			<p>However, rather than providing a fixed list, we can use the most common models. For simplicity, we used all the models that have the messaging feature. Using the <code>_referencable_models</code> method, we provided a model list dynamically.</p>
			<p>Our recipe started by providing a function to browse all the model records that can be referenced, to dynamically build a list that will be provided to the <code>selection</code> attribute. Although both forms are allowed, we declared the function name inside quotes, instead of directly referencing the function without quotes. This is more flexible, and it allows for the referenced function to be defined only later in code, for example, which is something that is not possible when using a direct reference.</p>
			<p>The function needs the <code>@api.model</code> decorator because it operates on the model level, not on the record set level.</p>
			<p>While this feature looks nice, it comes with a significant execution overhead. Displaying the reference fields for a large number of records (for instance, in a list view) can create heavy database loads, as each value has to be looked up in a separate query. It is also unable to take advantage of database referential integrity, unlike regular relation fields.</p>
			<h1 id="_idParaDest-165"><a id="_idTextAnchor203"/>Adding features to a model using inheritance</h1>
			<p>Odoo boasts a robust feature that significantly enhances its flexibility and functionality, which is <a id="_idIndexMarker253"/>particularly beneficial for businesses seeking tailored solutions. This feature enables the integration of module add-ons, allowing them to augment the capabilities of existing modules without the need to <a id="_idIndexMarker254"/>alter their underlying codebase. This is achieved through the addition or modification of fields and methods, as well as the extension of current methods with supplementary logic. This modular approach not only facilitates a customizable and scalable system but also ensures that upgrades and maintenance remain streamlined, preventing the complexities typically associated with custom modifications.</p>
			<p>The official documentation describes three kinds of inheritance in Odoo:</p>
			<ul>
				<li>Class inheritance (extension)</li>
				<li>Prototype inheritance</li>
				<li>Delegation inheritance</li>
			</ul>
			<p>We will see each one of these in a separate recipe. In this recipe, we will see class inheritance (extension). This is used to add new fields or methods to existing models.</p>
			<p>We’ll expand the existing partner model, <code>res.partner</code>, to include it in a computed field that calculates how many hostel rooms are assigned to each user. This will help dete<a id="_idTextAnchor204"/>rmine which section each room is assigned to and which user occupies it.</p>
			<h2 id="_idParaDest-166"><a id="_idTextAnchor205"/>Getting ready</h2>
			<p>We wi<a id="_idTextAnchor206"/>ll continue using the <code>my_hostel</code> add-on module from the previous recipe.</p>
			<h2 id="_idParaDest-167"><a id="_idTextAnchor207"/>How to do it...</h2>
			<p>We will extend the built-in partner model. If you remember, we already inherited the <code>res.parnter</code> model in the <em class="italic">Adding relational fields to a model</em> recipe in this chapter. To keep the explanation as simple as possible, we will reuse the <code>res.partner</code> model in the <code>models/hostel_book.py</code> code file:</p>
			<ol>
				<li>First, we will ensure that the <code>authored_book_ids</code> inverse relation is in the partner model and add the computed field:<pre class="source-code">
class ResPartner(models.Model):
   _inherit = "res.partner"
   is_hostel_rector = fields.Boolean("Hostel Rector", help="Activate if the following person is hostel rector")
   assign_room_ids = fields.Many2many('library.book',string='Authored Books')
   count_assign_room = fields.Integer( 'Number of Authored Books', compute="_compute_count_room")</pre></li>				<li>Next, add the <a id="_idIndexMarker255"/>method that’s needed to <a id="_idIndexMarker256"/>compute the book count:<pre class="source-code">
@api.depends('assign_room_ids')
   def _compute_count_room(self):
       for partner in self:
           partner.count_assign_room = len(partner.assign_room_ids)</pre></li>				<li>Finally, w<a id="_idTextAnchor208"/>e need to upgrade the add-on module for the modifications to take effect.</li>
			</ol>
			<h2 id="_idParaDest-168"><a id="_idTextAnchor209"/>How it works...</h2>
			<p>When a model class is defined with the <code>_inherit</code> attribute, it adds modifications to the inherited model, rather than replacing it.</p>
			<p>This means that fields defined in the inheriting class are added or changed on the parent model. At the database layer, ORM adds fields to the same database table.</p>
			<p>Fields are also incrementally modified. This means that if the field already exists in the superclass, only the attributes declared in the inherited class are modified; the other ones are kept as they are in the parent class.</p>
			<p>Methods defined in the inheriting class replace methods in the parent class. If you don’t invoke the <a id="_idIndexMarker257"/>parent method with the <code>super</code> call, the parent’s version of the method will not be executed, and we will lose the features. So, whenever you add a new logic by inheriting existing methods, you should include <a id="_idIndexMarker258"/>a statement with <code>super</code> to call its version in the parent class. This is discussed in more detail in <a href="B20997_05.xhtml#_idTextAnchor238"><em class="italic">Chapter 5</em></a>, <em class="italic">Basic </em><em class="italic">Server-Side Development</em>.</p>
			<p>This recipe will add new fields to the existing model. If you also want to add these new fields to existing views (the user interface), refer to the <em class="italic">Changing existing views –</em> <em class="italic">view inheritance</em> recipe in <a href="B20997_09.xhtml#_idTextAnchor446"><em class="italic">Chapter 9</em></a>, <em class="italic">Backend Views</em>.</p>
			<h1 id="_idParaDest-169"><a id="_idTextAnchor210"/>Copying the model definition using inheritance</h1>
			<p>We saw <a id="_idIndexMarker259"/>class inheritance (extension) in the <a id="_idIndexMarker260"/>previous recipe. Now, we will see <code>hostel.room</code> model.</p>
			<h2 id="_idParaDest-170">Getting read<a id="_idTextAnchor212"/>y</h2>
			<p>We will continue using the <code>my_hostel</code> add-on module from the previous recipe.</p>
			<h2 id="_idParaDest-171"><a id="_idTextAnchor213"/>How to do it...</h2>
			<p>Prototype inheritance is executed by using the <code>_name</code> and <code>_inherit</code> class attributes at the same time. Perform the following steps to generate a copy of the <code>hotel.room</code> model:</p>
			<ol>
				<li>Add a new file called <code>hostel_room_copy.py</code> to the <code>/</code><code>my_hostel/models/</code> directory.</li>
				<li>Add the following content to the <code>hostel_room_copy.py</code> file:<pre class="source-code">
from odoo import fields, models, api, _
class HostelRoomCopy(models.Model):
   _name = "hostel.room.copy"
   _inherit="hostel.room"
   _description = "Hostel Room Information Copy"</pre></li>				<li>Import a new file reference into the <code>/my_library/models/__init__.py</code> file. Following the changes, your<code> __init__.py</code> file will look like this:<pre class="source-code">
from . import hostel_room
from . import hostel_room_copy</pre></li>				<li>Finally, we need <a id="_idIndexMarker262"/>to upgrade the add-on <a id="_idIndexMarker263"/>module for the modifications to take effect.</li>
				<li>To check the new model’s definition, go to the <code>hostel.room.copy</code> model here.</li>
			</ol>
			<p class="callout-heading"> Tip</p>
			<p class="callout">In order to see menus and views for the new model, you need to add the XML definition of views and menus. To learn more about views and menus, refer to th<a id="_idTextAnchor214"/>e <em class="italic">Adding menu items and views recipe</em> in <a href="B20997_03.xhtml#_idTextAnchor083"><em class="italic">Chapter 3</em></a>, <em class="italic">Creating Odoo </em><em class="italic">Add-On Modules</em>.</p>
			<h2 id="_idParaDest-172"><a id="_idTextAnchor215"/>How it works...</h2>
			<p>By using <code>_name</code> with the <code>_inherit</code> class attribute at the same time, you can copy the definition of the model. When you use both attributes in the model, Odoo will copy the model definition of <code>_inherit</code> and create a new model with the <code>_name</code> attribute.</p>
			<p>In our example, Odoo will copy the definition of the <code>Hostel.room</code> model and create a new model, <code>hostel.room.copy</code>. The new <code>hostel.room.copy</code> model has its own database table with its own data that is totally independent from the <code>hostel.room</code> parent model. Since it still inherits from the partner model, any subsequent modifications to it will also affect the new model.</p>
			<p>Prototype inheritance copies all the properties of the parent class. It copies fields, attributes, and methods. If you want to modify them in the child class, you can simply do so by adding <a id="_idIndexMarker264"/>a new definition to the child <a id="_idIndexMarker265"/>class. For example, the <code>hostel.room </code>model has the <code>_name_get</code> method. If you want to use a different version of <code>_name_get</code> in the child, you need to redefine the method in the <code>hostel.room.copy</code> model.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Prototype inheritance <a id="_idIndexMarker266"/>does not work if you use the same model name in the <code>_inherit</code> and <code>_name</code> attributes. If you do use the same model name in the <code>_inh<a id="_idTextAnchor216"/>erit</code> and <code>_name</code> attributes, it will just behave like a normal extension inheritance.</p>
			<h2 id="_idParaDest-173"><a id="_idTextAnchor217"/>There’s more…</h2>
			<p>In the official documentation, this is called prototype inheritance, but in practice, it is rarely used. The reason for this is that delegation inheritance usually answers to that need in a <a id="_idIndexMarker267"/>more efficient way, without the need to <strong class="bold">duplicate data structures</strong>. For more information on this, you can refer<a id="_idTextAnchor218"/> to the next recipe, Using delegation inheritance to copy features to another model.</p>
			<h1 id="_idParaDest-174"><a id="_idTextAnchor219"/>Using delegation inheritance to copy features to another model</h1>
			<p>The third type of inheritance is Delegation inheritance. Instead of <code>_inherit</code>, it uses the <code>_inherits</code> class attribute. There are cases where, rather than modifying an existing model, we want to create a new model based on an existing one to use the features it already has. We can copy a model’s definitions with prototype inheritance, but this will generate duplicate data structures. If you want to copy a model’s definitions without duplicating data structures, then the answer lies in Odoo’s delegation inheritance, which uses the <code>_inherits</code> model attribute (note the additional <code>s</code>).</p>
			<p>Traditional inheritance is quite different from the similarly named concept in object-oriented programming. Delegation inheritance, in turn, is similar, in that a new model can be created to include the features from a parent model. It also supports polymorphic inheritance, where we inherit from two or more other models.</p>
			<p>We operate a hostel that accommodates both rooms and students. To better manage our accommodations, it’s essential to integrate student-related information into our system. Specifically, for each student, we require comprehensive identification and address details, similar to those captured in the partner model. Additionally, it’s crucial to maintain records related to room allocation, including the start and end dates of each student’s stay and their card number.</p>
			<p>Directly adding <a id="_idIndexMarker268"/>these fields to the existing partner <a id="_idIndexMarker269"/>model isn’t an ideal approach, as it would unnecessarily clutter the model with student-specific data that is irrelevant for non-student partners. A more effective solution would be to enhance the partner model by creating a new model that inherits from it and introduces the additional fields required to manage student information. This approach ensures a cleaner, mo<a id="_idTextAnchor220"/>re organized, and functionally efficient system to cater to our hostel’s unique needs.</p>
			<h2 id="_idParaDest-175">Gett<a id="_idTextAnchor221"/>ing ready</h2>
			<p>We will continue using the <code>my_hostel</code> add-on module from the previous recipe.</p>
			<h2 id="_idParaDest-176"><a id="_idTextAnchor222"/>How to do it...</h2>
			<p>The new library member model should be in its own Python code file, but to keep the explanation as simple as possible, we will reuse the <code>models/hostel_student.py</code> file:</p>
			<ol>
				<li>Add the new model, inheriting from <code>res.partner</code>:<pre class="source-code">
class HostelStudent(models.Model):
   _name = "hostel.student"
   _inherits = {'res.partner': 'partner_id'}
   _description = "Hostel Student Information"
   ………
   partner_id = fields.Many2one('res.partner', ondelete='cascade')</pre></li>				<li>Next, we will add the fields that are specific to each student:<pre class="source-code">
gender = fields.Selection([("male", "Male"),
       ("female", "Female"), ("other", "Other")],
       string="Gender", help="Student gender")
   room_id = fields.Many2one("hostel.room", "Room",
       help=<a id="_idTextAnchor223"/>"Select hostel room")</pre></li>			</ol>
			<p>Now, we should upgrade the add-on module to activate the changes.</p>
			<h2 id="_idParaDest-177"><a id="_idTextAnchor224"/>How it works...</h2>
			<p>The <code>_inherits</code> model attribute sets the parent models that we want to inherit from. In this case, we just have one – <code>res.partner</code>. Its value is a key-value dictionary, where the <a id="_idIndexMarker270"/>keys are the inherited models and the <a id="_idIndexMarker271"/>values are the field names that were used to link to them. These are <code>m2o</code> fields that we must also define in the model. In our example, <code>partner_id</code> is the field that will be used to link with the <code>Partner</code> parent model.</p>
			<p>To better understand how this works, let’s look at what happens at a database level when we create a new member:</p>
			<ul>
				<li>A new record is created in the <code>res_partner</code> table.</li>
				<li>A new record is created in the <code>hostel_student</code> table.</li>
				<li>The <code>partner_id</code> field of the <code>hostel_student</code> table is set to the ID of the <code>res_partner</code> record that is created for it</li>
			</ul>
			<p>The member record is automatically linked to a new partner record. It’s just an <code>m2o</code> relationship, but the delegation mechanism adds some magic so that the partner’s fields are seen as if they belong to the member record, and a new partner record is also automatically created with the new member.</p>
			<p>You may be interested to know that this automatically created partner record has nothing special about it. It’s a regular partner, and if you browse the partner model, you will be able to find that record (without the additional member data, of course). All members are partners, but only some partners are also members. So, what happens if you delete a partner record that is also a member? You decide by choosing the <code>ondelete</code> value for the relation field. For <code>partner_id</code>, we used <code>cascade</code>. This means that deleting the partner will also delete the corresponding member. We could have used the <a id="_idIndexMarker272"/>more conservative setting, <code>restrict</code>, to prohibit deleting the partner while it has a linked member. In this case, only deleting the member will work.</p>
			<p>It’s important <a id="_idIndexMarker273"/>to note that delegation inheritance only works for fields, not for methods. So, if the partne<a id="_idTextAnchor225"/>r model has a <code>do_something()</code> method, the members model will not automatically inherit it.</p>
			<h2 id="_idParaDest-178"><a id="_idTextAnchor226"/>There’s more...</h2>
			<p>There is a shortcut for this inheritance delegation. Instead of creating an <code>_inherits</code> dictionary, you can use the <code>delegate=True</code> attribute in the <code>m2o</code> field definition. This will work exactly like the <code>_inherits</code> option. The main advantage is that this is simpler. In the given example, we performed the same inheritance delegation as in the previous one, but in this case, instead of creating an <code>_inherits</code> dictionary, we used the <code>delegate=True</code> option in the <code>partner_id</code> field:</p>
			<pre class="source-code">
class HostelStudent(models.Model):
   _name = "hostel.student"
   _description = "Hostel Student Information"
   partner_id = fields.Many2one('res.partner', ondelete='cascade', delegate=True)</pre>			<p>A noteworthy case of delegation inheritance is the users model, <code>res.users</code>. It inherits from partners (<code>res.partner</code>). This means that some of the fields that you can see on the user are actually stored in the partner model (notably, the <code>name</code> field). When a new user is created, we also get a new, automatically created partner.</p>
			<p>We should also mention that traditional inheritance with <code>_inherit</code> can also copy features into a new model, although in a less eff<a id="_idTextAnchor227"/>icient way. This was discussed in the <em class="italic">Adding features to a model using </em><em class="italic">inheritance</em> recipe.</p>
			<h1 id="_idParaDest-179"><a id="_idTextAnchor228"/>Using abstract models for reusable model features</h1>
			<p>Sometimes, there is a particular feature that we want to be able to add to several different <a id="_idIndexMarker274"/>models. Repeating the same code in different files is a bad programming practice; it would be better to implement it once and reuse it.</p>
			<p>Abstract <a id="_idIndexMarker275"/>models allow us to create a generic model that implements some features that can then be inherited by regular models, in order to make that feature available.</p>
			<p>As an example, we will implement a simple archive feature. This adds the <code>active</code> field to the model (if it doesn’t exist already) and makes an archive method available to toggle the <code>active</code> flag. This works because <code>active</code> is a magic field. If it is present in a model by default, the records with <code>active<a id="_idTextAnchor229"/>=False</code> will be filtered out from the queries. We will then add it to the <code>hostel </code><code>room</code> model.<a id="_idTextAnchor230"/></p>
			<h2 id="_idParaDest-180"><a id="_idTextAnchor231"/>Getting ready</h2>
			<p>We will continue using the <code>my_hostel</code> add-on module from the previous recipe.</p>
			<h2 id="_idParaDest-181"><a id="_idTextAnchor232"/>How to do it...</h2>
			<p>The archive feature certainly deserves its own add-on module, or at least its own Python code file. However, to keep the explanation as simple as possible, we will cram it into the <code>models/hostel_room.py</code> file:</p>
			<ol>
				<li>Add the abstract model for the archive feature. It must be defined in the library book model, where it will be used:<pre class="source-code">
class BaseArchive(models.AbstractModel):
   _name = 'base.archive'
   active = fields.Boolean(default=True)
   def do_archive(self):
       for record in self:
           record.active = not record.active</pre></li>				<li>Now, we will edit the Hostel Room model to inherit the archive model:<pre class="source-code">
class HostelRoom(models.Model):
   _name = "hostel.room"
   _inherit = ['base.arch<a id="_idTextAnchor233"/>ive']</pre></li>			</ol>
			<p>An upgrade of the add-on module is required in order for the changes to be activated.</p>
			<h2 id="_idParaDest-182"><a id="_idTextAnchor234"/>How it works...</h2>
			<p>An abstract <a id="_idIndexMarker276"/>model is created by a class based on <code>models.AbstractModel</code>, instead of the usual <code>models.Model</code>. It has all the attributes and capabilities of regular models; the difference <a id="_idIndexMarker277"/>is that ORM will not create an actual representation for it in the database. This means that it can’t have any data stored in it. It only serves as a template for a reusable feature that will be added to regular models.</p>
			<p>Our archive abstract model is quite simple. It just adds the <code>active</code> field and a method to toggle the value of the <code>active</code> flag, which we expect to be used later, via a button on the user interface. When a model class is defined with the <code>_inherit</code> attribute, it inherits the attribute methods of those classes, and the attribute methods that are defined in the current class add modifications to those inherited features.</p>
			<p>The mechanism at play here is the same as that of a regular model extension (as per the <em class="italic">Adding features to a model using inheritance</em> recipe). You may have noticed that <code>_inherit</code> uses a list of model identifiers instead of a string with one model identifier. In fact, <code>_inherit</code> can have both forms. Using the list form allows us to inherit from multiple (usually <code>Abstract</code>) classes. In this case, we inheri<a id="_idTextAnchor235"/>t<a id="_idTextAnchor236"/> just one, so a text string would be fine. A list was used instead, for illustration purposes.</p>
			<h2 id="_idParaDest-183"><a id="_idTextAnchor237"/>There’s more...</h2>
			<p>A noteworthy <a id="_idIndexMarker278"/>built-in abstract <a id="_idIndexMarker279"/>model is <code>mail.thread</code>, which is provided by the <code>mail (Discuss)</code> add-on module. On models, it enables the discussion features that power the message wall that’s seen at the bottom of many forms.</p>
			<p>Other than <code>AbstractModel</code>, a third model type is available – <code>models.TransientModel</code>. This has a database representation like <code>models.Model</code>, but the records that are created there are supposed to be temporary and regularly purged by a server-scheduled job. Other than that, transient models work just like regular models.</p>
			<p><code>models.TransientModel</code> is useful for more complex user interactions, known as <strong class="bold">wizards</strong>. A wizard is <a id="_idIndexMarker280"/>used to request inputs from the user. In <a href="B20997_08.xhtml#_idTextAnchor388"><em class="italic">Chapter 8</em></a>, <em class="italic">Advanced Server-Side Development Techniques</em>, we will explore how to use these for advanced user interaction.</p>
		</div>
	</body></html>