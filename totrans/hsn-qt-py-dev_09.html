<html><head></head><body>
        

                            
                    <h1 class="header-title">Using Comboboxes and List Views</h1>
                
            
            
                
<p class="mce-root">The components of the GUI that will be discussed in this chapter are somewhat mixed in nature. They are text fields and can be used to control elements in the application. In other words, the user can input text in these fields and then make a choice via a drop-down menu that is provided with additional functionality. Using these components helps make the GUI application more compact and informative.</p>
<p class="mce-root">The components within this chapter represent the model-view paradigm of the Qt framework. In short, the line edit field can also be implemented using the list view.</p>
<p class="mce-root">In this chapter, the following topics will be covered:</p>
<ul>
<li>Model-view architecture</li>
<li>Combobox</li>
<li>Simple list view</li>
<li>Table</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Model-view architecture</h1>
                
            
            
                
<p>The Qt framework has a set of classes that utilize a model-view paradigm to regulate the relationship between the data and the representation of the data known as the <strong>Model-View-Controller</strong> (<strong>MVC</strong>) paradigm. MVC is a design pattern that's often used while establishing user interfaces. MVC has three kinds of objects:</p>
<ul>
<li>The model (application object)</li>
<li>The view (screen presentation)</li>
<li>The controller (defines the action on the user interface on user input) </li>
</ul>
<p>The following diagram depicts the interactions among the model, view, and controller: </p>
<p class="CDPAlignCenter CDPAlign"><img src="img/331fcf00-26d2-4857-bb54-effe5c8b3299.png" style="width:16.17em;height:12.25em;"/></p>
<p>In the Qt framework, when the view and controller are combined, this creates the model-view architecture. To create the model with Qt, the framework uses the classes of the <kbd>QtCore</kbd> module, such as <kbd>QAbstractItemModel</kbd>, the base class, and the classes that inherit this class, such as <kbd>QAbstractListModel</kbd> and <kbd>QAbstractTableModel</kbd>. The classes that represent the views use the views from the <kbd>QtWidgets</kbd> module, such as <kbd>QListView</kbd>, <kbd>QTableView</kbd>, and <kbd>QTreeView</kbd>, and they inherit the base class, <kbd>QAbstractItemView</kbd>. Here, we will describe just a few of them, including the basics for implementing the model-view architecture with the application. Refer to the documentations (<a href="https://doc.qt.io/qt-5/model-view-programming.html">https://doc.qt.io/qt-5/model-view-programming.html</a>) for a more in-depth understanding.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">QAbstractItemModel</h1>
                
            
            
                
<p>This class realizes the abstract interface for model classes. The full list of functions to manipulate the model part of the model-view architecture is available in the documentation. The construction syntax of this class is as follows:</p>
<pre>class Model(QtCore.QAbstractItemModel):<br/><br/>    def __init__(self, parent=None):<br/>        super(Model, self).__init__(parent)<br/><br/>    def rowCount(self, parent):<br/>        return ... <br/><br/>    def columnCount(self, parent):<br/>        return ...<br/><br/>    def index(self, row, column, parent):<br/>        return ...<br/>     <br/><br/>    def data(self, index, role):<br/>        return ...</pre>
<p>The functions that need to be overridden are as follows:</p>
<p><kbd>columnCount(QtCore.QModelIndex)</kbd>: This returns the number of columns under the parent specified in the parameter.</p>
<p><kbd>data(QtCore.QModelIndex, int)</kbd>: This returns the data stored under the role (the second parameter) for the item specified as the first parameter.</p>
<p><kbd>index(int, int, QtCore.QModelIndex)</kbd>: This returns the item's index in the model specified by the row (the first parameter), column (the second parameter), and parent (the third parameter).</p>
<p><kbd>rowCount(QtCore.QModelIndex)</kbd>: This returns the number of rows under the parent specified in the parameter.</p>
<p>The most useful functions are as follows:</p>
<p><kbd>insertColumn(int, QtCore.QModelIndex)</kbd>: This inserts the column before the column specified as the first parameter in the child items of the parent (the second parameter).</p>
<p><kbd>insertColumns(int, int, QtCore.QModelIndex)</kbd>: This inserts the number of new columns (the second parameter) before the column (the first parameter) related to the item represented by the parent model index (the third parameter).</p>
<p><kbd>insertRow(int, QtCore.QModelIndex)</kbd>: This inserts the row before the row specified as the first parameter in the child items of the parent (the second parameter).</p>
<p><kbd>insertRows(int, int, QtCore.QModelIndex)</kbd>: This inserts the number of new rows (the second parameter) before the row (the first parameter) related to the item represented by the parent model index (the third parameter).</p>
<p><kbd>moveColumn(QtCore.QModelIndex, int, QtCore.QModelIndex, int)</kbd>: This moves the source column (the second parameter) from the source parent (the first parameter) to the destination child (the fourth parameter) under the destination parent (the third parameter).</p>
<p><kbd>moveColumns(QtCore.QModelIndex, int, int, QtCore.QModelIndex, int)</kbd>: This moves the number of columns specified as the third parameter, starting with the source column (the second parameter), from the source parent (the first parameter) to the destination child (the fifth parameter) under the destination parent (the fourth parameter).</p>
<p><kbd>moveRow(QtCore.QModelIndex, int, QtCore.QModelIndex, int)</kbd>: This moves the source row (the second parameter) from the source parent (the first parameter) to the destination child (the fourth parameter) under the destination parent (the third parameter).</p>
<p><kbd>moveRows(QtCore.QModelIndex, int, int, QtCore.QModelIndex, int)</kbd>: This moves the number of rows specified as the third parameter, starting with the source row (the second parameter), from the source parent (the first parameter) to the destination child (the fifth parameter) under the destination parent (the fourth parameter).</p>
<p><kbd>removeColumn(int, QtCore.QModelIndex)</kbd>: This removes the column (the first parameter) of the parent (the second parameter).</p>
<p><kbd>removeColumns(int, int, QtCore.QModelIndex)</kbd>: This removes the number of columns specified as the second parameter, starting with the column (the first parameter) of the parent (the third parameter).</p>
<p><kbd>removeRow(int, QtCore.QModelIndex)</kbd>: This removes the row (the first parameter) of the parent (the second parameter).</p>
<p><kbd>removeRows(int, int, QtCore.QModelIndex)</kbd>: This removes the number of rows specified as the second parameter, starting with the row (the first parameter) of the parent (the third parameter).</p>
<p><kbd>sort(int, QtCore.Qt.SortOrder)</kbd>: This sorts the model by columns (the first parameter) according to the order specified as the second parameter.</p>
<p><kbd>setData(QtCore.QModelIndex, object, int)</kbd>: This sets the data for the item with a specified role (the third parameter) and index (the first parameter) to a specified value (the second parameter).</p>
<p><kbd>setHeaderData(int, QtCore.Qt.Orientation, object, int)</kbd>: This sets the header data with a specified role (the fourth parameter), section (the first parameter), and orientation (the second parameter) to a specified value (the third parameter).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">QAbstractTableModel</h1>
                
            
            
                
<p>This class provides a standard interface that represents the data as a two-dimensional array in the model. The <kbd>QAbstractTableModel</kbd> class inherits from the <kbd>QAbstractItemModel</kbd> class. The construction syntax of this class is as follows:</p>
<pre>class Model(QtCore.QAbstractTableModel):<br/><br/>    def __init__(self, parent=None):<br/>        super(Model, self).__init__(parent)<br/> <br/>    def rowCount(self, parent):<br/>        return ...<br/> <br/>    def columnCount(self, parent):<br/>        return ...<br/><br/>    def data(self, row, column):<br/>        return ...</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">QAbstractItemView</h1>
                
            
            
                
<p>This is a base abstract class that provides the basic functionality for view classes in the Qt framework. Usually, this class is reimplemented with the <kbd>QListView</kbd>, <kbd>QTreeView</kbd>, and <kbd>QTableView</kbd> classes in the GUI application construction. The inheritance scheme for this class is as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/daf5fded-0f44-4173-aea4-d4d6c25c4822.png" style="width:64.75em;height:5.17em;"/></p>
<p>Functions that are commonly used with the GUI application include the following (the full list is available in the documentation):</p>
<p><kbd>setDragEnabled(bool)</kbd>: If the parameter is <kbd>True</kbd>, the view will support the dragging of items.</p>
<p><kbd>setDragDropMode(QtWidgets.QAbstractItemView.DragDropMode)</kbd>: This sets the drag and drop mode; by default, dragging or dropping is not supported in the view. The available modes are as follows:</p>
<ul>
<li><kbd>QtWidgets.QAbstractItemView.NoDragDrop</kbd>—<kbd>0</kbd>: This view doesn't support dragging and dropping.</li>
<li><kbd>QtWidgets.QAbstractItemView.DragOnly</kbd>—<kbd>1</kbd>: This view supports dragging.</li>
<li><kbd>QtWidgets.QAbstractItemView.DropOnly</kbd>—<kbd>2</kbd>: This view supports dropping.</li>
<li><kbd>QtWidgets.QAbstractItemView.DragDrop</kbd>—<kbd>3</kbd>: This view supports dragging and dropping.</li>
<li><kbd>QtWidgets.QAbstractItemView.InternalMove</kbd>—<kbd>4</kbd>: This view will accept moving operations, excluding copying.</li>
</ul>
<p><kbd>setDropIndicatorShown(bool)</kbd>: If the parameter is <kbd>True</kbd>, this sets the drop indicator, as demonstrated when used with the dragging and dropping of items.</p>
<p><kbd>setModel(QtCore.QAbstractItemModel)</kbd>: This sets the model that will be represented with the view.</p>
<p><kbd>setRootIndex(QtCore.QModelIndex)</kbd>: This sets the root item to the item according to the index specified in the parameter.</p>
<p><kbd>setSelectionBehavior(QtWidgets.QAbstractItemView.SelectionBehavior)</kbd>: This sets the selection behavior that will be used by the view. The available behaviors are as follows:</p>
<ul>
<li><kbd>QtWidgets.QAbstractItemView.SelectItems</kbd>—<kbd>0</kbd>: Single items.</li>
<li><kbd>QtWidgets.QAbstractItemView.SelectRows</kbd>—<kbd>1</kbd>: Only rows.</li>
<li><kbd>QtWidgets.QAbstractItemView.SelectColumns</kbd>—<kbd>2</kbd>: Only columns.</li>
</ul>
<p><kbd>setSelectionMode(QtWidgets.QAbstractItemView.SelectionMode)</kbd>: This sets how the view will respond to selections. The selection modes that are available are as follows:</p>
<ul>
<li><kbd>QtWidgets.QAbstractItemView.NoSelection</kbd>—<kbd>0</kbd>: The items are not selected.</li>
<li><kbd>QtWidgets.QAbstractItemView.SingleSelection</kbd>—<kbd>1</kbd>: An item that has already been selected will be deselected.</li>
</ul>
<ul>
<li><kbd>QtWidgets.QAbstractItemView.MultiSelection</kbd>—<kbd>2</kbd>: The selected item is toggled, and the other items are left alone. Multiple items can be toggled by dragging the mouse over them.</li>
<li><kbd>QtWidgets.QAbstractItemView.ExtendedSelection</kbd>—<kbd>3</kbd>: An item that has already been selected will be selected and deselected using the <em>Shift</em> key, or using the <em>Ctrl</em> key, the clicked item gets toggled and all other items are left untouched.</li>
<li><kbd>QtWidgets.QAbstractItemView.ContiguousSelection</kbd>—<kbd>4</kbd>: An item that has already been selected will be deselected, and not deselected using the <em>Shift</em> key.</li>
</ul>
<p><kbd>setSelectionModel(QtCore.QItemSelectionModel)</kbd>: Sets the selection model specified in the parameter.</p>
<p><kbd>setState(QtWidgets.QAbstractItemView.State)</kbd>: Sets the item views state specified in the parameter. The states are as follows:</p>
<ul>
<li><kbd>QtWidgets.QAbstractItemView.NoState</kbd>—<kbd>0</kbd>: Default.</li>
<li><kbd>QtWidgets.QAbstractItemView.DraggingState</kbd>—<kbd>1</kbd>: The items are dragged by the user.</li>
<li><kbd>QtWidgets.QAbstractItemView.DragSelectingState</kbd>—<kbd>2</kbd>: The items are selected by the user.</li>
<li><kbd>QtWidgets.QAbstractItemView.EditingState</kbd>—<kbd>3</kbd>: The items are edited by the user.</li>
<li><kbd>QtWidgets.QAbstractItemView.ExpandingState</kbd>—<kbd>4</kbd>: The items are opened in a branch by the user.</li>
<li><kbd>QtWidgets.QAbstractItemView.CollapsingState</kbd>—<kbd>5</kbd>: The branch of items is closed by the user.</li>
<li><kbd>QtWidgets.QAbstractItemView.AnimatingState</kbd>—<kbd>6</kbd>: This is the view performing the animation.</li>
</ul>
<p><kbd>edit(QtCore.QModelIndex)</kbd>: This begins editing the item according to the index specified in the parameter.</p>
<p><kbd>model()</kbd>: This returns the model of the <kbd>QtCore.QAbstractItemModel</kbd> type that's represented in the view.</p>
<p><kbd>selectAll()</kbd>: This selects all the items represented in the view.</p>
<p><kbd>startDrag(QtCore.Qt.DropActions)</kbd>: This starts a drag process by calling drag with <kbd>exec()</kbd>, which is related to the drop actions specified in the parameter.</p>
<p><kbd>update(QtCore.QModelIndex)</kbd>: This updates the area occupied by the index specified in the parameter.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">QComboBox</h1>
                
            
            
                
<p>The combobox widget, which is constructed with the <kbd>QComboBox</kbd> class, provides the combined button and pop-up list. This widget contains the field where current text is displayed (or can be edited), a pop-up list containing some values, and the option to make a choice and select a number of control elements. This can be used in the GUIs, where there is a need to represent numerous values with options in order to choose something from the popup, and that may imply another functionality. Developers create the comboboxes where places inside the graphical window are limited and many values need to be displayed. The <kbd>QComboBox</kbd> class has a declaration syntax in the application that looks like this:</p>
<pre><strong>combo_box</strong> = QtWidgets.QComboBox()</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">QComboBox functions</h1>
                
            
            
                
<p><kbd>QComboBox</kbd> inherits the <kbd>QWidget</kbd> class and improves functionality with the following functions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">add</h1>
                
            
            
                
<p>These are functions related to the addition of the elements or actions to the combobox:</p>
<p><kbd>combo_box.addItem("item", object)</kbd>: This adds the item (the first parameter) of the Unicode string type and optional user data with a second parameter (the default is <kbd>None</kbd>) to the end of this combobox pop-up list.</p>
<p><kbd>combo_box.addItem(QtGui.QIcon, "item", object)</kbd>: This adds the item (the second parameter) of the Unicode string type and optional user data with a third parameter (the default is <kbd>None</kbd>) to the end of this combobox pop-up list. The item's text will be displayed with the icon (the first parameter).</p>
<p><kbd>combo_box.addItems(["item"])</kbd>: This adds several items with the text of the Unicode string type to the end of this combobox pop-up list. Each item of the list, specified in the parameter, will be appended as the new line of the pop-up list.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">set</h1>
                
            
            
                
<p>These are functions related to the setting of the parameters/properties in relation to the combobox, including the setting of text, alignment, or functionality:</p>
<p><kbd>combo_box.setCompleter(QtWidgets.QCompleter)</kbd>: This sets the completer that will be used with the combobox.</p>
<p><kbd>combo_box.setCurrentIndex(int)</kbd>: This sets the current index specified in the parameter of the item in the combobox. The item with this index will be marked as current and visible.</p>
<p><kbd>combo_box.setCurrentText("Item")</kbd>: This sets the current text specified in the parameter of the item in the combobox. The item with this text will be marked as current and visible.</p>
<p><kbd>combo_box.setDuplicatesEnabled(bool)</kbd>: If the parameter is <kbd>True</kbd>, sets are allowed to enter duplicate items into the combobox.</p>
<p><kbd>combo_box.setEditable(bool)</kbd>: If the parameter is <kbd>True</kbd>, this sets the combobox as being available to edit with the line edit field.</p>
<p><kbd>combo_box.setEditText("Text")</kbd>: This sets the text in the line edit field of the combobox.</p>
<p><kbd>combo_box.setFrame(bool)</kbd>: If the parameter is <kbd>True</kbd>, this sets the frame around the combobox.</p>
<p><kbd>combo_box.setIconSize(QtCore.QSize)</kbd>: This sets the size of the icons that will be displayed in the combobox.</p>
<p><kbd>combo_box.setInsertPolicy(QtWidgets.QComboBox.InsertPolicy)</kbd>: This sets the insert policy for this combobox. The policies that are available are as follows:</p>
<ul>
<li><kbd>QtWidgets.QComboBox.NoInsert</kbd>—<kbd>0</kbd>: The items will not be inserted.</li>
<li><kbd>QtWidgets.QComboBox.InsertAtTop</kbd>—<kbd>1</kbd>: The current item will be inserted as the first item.</li>
</ul>
<ul>
<li><kbd>QtWidgets.QComboBox.InsertAtCurrent</kbd>—<kbd>2</kbd>: The current item in the combobox will be replaced by the new item.</li>
<li><kbd>QtWidgets.QComboBox.InsertAtBottom</kbd>—<kbd>3</kbd>: The current item will be inserted after the last item.</li>
<li><kbd>QtWidgets.QComboBox.InsertAfterCurrent</kbd>—<kbd>4</kbd>: This item will be inserted after the current item.</li>
<li><kbd>QtWidgets.QComboBox.InsertBeforeCurrent</kbd>—<kbd>5</kbd>: This item will be inserted before the current item.</li>
<li><kbd>QtWidgets.QComboBox.InsertAlphabetically</kbd>—<kbd>6</kbd>: This item will be inserted in alphabetical order.</li>
</ul>
<p><kbd>combo_box.setItemData(int, object, int)</kbd>: This sets the data role (the third parameter) for the item with an index (the first parameter) to the value specified as the second parameter.</p>
<p><kbd>combo_box.setItemDelegate(QtWidgets.QAbstractItemDelegate)</kbd>: This sets the pop-up list view item delegate.</p>
<p><kbd>combo_box.setItemIcon(int, QtGui.QIcon)</kbd>: This sets the icon (the second parameter) for the item specified by the index (the first parameter).</p>
<p><kbd>combo_box.setItemText(int, "Item")</kbd>: This sets the text (the second parameter) for the item specified by the index (the first parameter).</p>
<p><kbd>combo_box.setLineEdit(QtWidgets.QLineEdit)</kbd>: This sets the line edit field that will be used with this combobox.</p>
<p><kbd>combo_box.setMaxCount(int)</kbd>: This sets the maximum number of items that will be used in this combobox.</p>
<p><kbd>combo_box.setMaxVisibleItems(int)</kbd>: This sets the maximum number of items that will be visible in the combobox screen without scrolling.</p>
<p><kbd>combo_box.setMinimumContentsLength(int)</kbd>: This sets the minimum number of characters for the item that will be represented with the combobox screen.</p>
<p><kbd>combo_box.setModel(QtCore.QAbstractItemModel)</kbd>: This sets the model for this combobox.</p>
<p><kbd>combo_box.setModelColumn(int)</kbd>: This sets the visible column in the combobox model.</p>
<p><kbd>combo_box.setRootModelIndex(QtCore.QModelIndex)</kbd>: This sets the root model item as an index in the parameter for the combobox items.</p>
<p><kbd>combo_box.setSizeAdjustPolicy(QtWidgets.QComboBox.SizeAdjustPolicy)</kbd>: This sets the size adjust policy for this combobox. The policies that are available are as follows:</p>
<ul>
<li><kbd>QtWidgets.QComboBox.AdjustToContents</kbd>—<kbd>0</kbd>: Will always adjust to the content.</li>
<li><kbd>QtWidgets.QComboBox.AdjustToContentsOnFirstShow</kbd>—<kbd>1</kbd>: Will adjust to the content the first time it is shown.</li>
<li><kbd>QtWidgets.QComboBox.AdjustToMinimumContentsLength</kbd>—<kbd>2</kbd>: Will adjust to the minimum content length.</li>
<li><kbd>QtWidgets.QComboBox.AdjustToMinimumContentsLengthWithIcon</kbd>—<kbd>3</kbd>: Will adjust to the minimum content length, plus space for the icon.</li>
</ul>
<p><kbd>combo_box.setValidator(QtGui.QValidator)</kbd>: This sets the validator that will be used with this combobox.</p>
<p><kbd>combo_box.setView(QtWidgets.QAbstractItemView)</kbd>: This sets the view that will be used in the combobox pop-up list.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">edit</h1>
                
            
            
                
<p>These are functions that make some changes to the current content of the combobox, including clear, undo, and redo:</p>
<p><kbd>combo_box.clear()</kbd>: This clears the pop-up list items from the combobox.</p>
<p><kbd>combo_box.clearEditText()</kbd>: This clears the text of the edited field of the combobox. The line edit text of the combobox will be cleared.</p>
<p><kbd>combo_box.hidePopup()</kbd>: This hides the combobox pop-up list; the list will be reset.</p>
<p><kbd>combo_box.showPopup()</kbd>: This shows the combobox pop-up list.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">is/has</h1>
                
            
            
                
<p>These are functions that return a Boolean value (<kbd>bool</kbd>) related to the combobox states, for example, to check for availability:</p>
<p><kbd>combo_box.hasFrame()</kbd>: This returns <kbd>True</kbd> if the combobox has a surrounding frame.</p>
<p><kbd>combo_box.isEditable()</kbd>: This returns <kbd>True</kbd> if the line field of this combobox can be edited.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">functional</h1>
                
            
            
                
<p>The following are functions related to the current values of the combobox being returned, changes in functionality, and so on:</p>
<p><kbd>combo_box.completer()</kbd>: This returns the completer for autocompletion of the text input for this combobox.</p>
<p><kbd>combo_box.count()</kbd>: This counts the items of the pop-up list and returns the integer value.</p>
<p><kbd>combo_box.currentData(int)</kbd>: This returns the object that describes the current data of the pop-up list item, with a <kbd>QtCore.Qt.UserRole</kbd> parameter type.</p>
<p><kbd>combo_box.currentIndex()</kbd>:<strong> </strong>This returns the current index of the item (integer value) from the pop-up list that may have been chosen by the user.</p>
<p><kbd>combo_box.currentText()</kbd>: This returns the current text of the item (<kbd>string</kbd>) from the pop-up list that may have been chosen by the user.</p>
<p><kbd>combo_box.duplicatesEnabled()</kbd>: This returns <kbd>True</kbd> if it is possible to enter duplicate items in the combobox.</p>
<p><kbd>combo_box.findData(object, int, QtCore.Qt.MatchFlags)</kbd>: This returns the index of the item that contains the specified data (the first parameter), role (the second parameter), and flags (the third parameter). Otherwise, it returns a value of <kbd>-1</kbd>.</p>
<p><kbd>combo_box.findText("Text to find", QtCore.Qt.MatchFlags)</kbd>: This returns the index of the item that contains the text (the first parameter) with flags (the second parameter), such as <kbd>QtCore.Qt.MatchCaseSensitive</kbd>. Otherwise, it returns a value of <kbd>-1</kbd>.</p>
<p><kbd>combo_box.iconSize()</kbd>: This returns the icon size of the <kbd>QtCore.QSize</kbd> type.</p>
<p><kbd>combo_box.initStyleOption(QtWidgets.QStyleOptionFrame)</kbd>: This initializes style options with the values from the parameter.</p>
<p><kbd>combo_box.inputMethodQuery(QtCore.Qt.InputMethodQuery, object)</kbd>: This is used to query a set of properties of the combobox to enable support for complex input method operations, such as support for surrounding text and reconversions.</p>
<p><kbd>combo_box.insertItem(int, "Item text", object)</kbd>: This inserts the item in the position (the first parameter) of the pop-up list with text (the second parameter) and user data (the third parameter).</p>
<p><kbd>combo_box.insertItem(int, QtGui.QIcon, "Item text", object)</kbd>: This inserts the item in the position (the first parameter) of the pop-up list with text (the third parameter) that will be displayed with the icon (the second parameter) and user data (the fourth parameter).</p>
<p><kbd>combo_box.insertItems(int, ["Item text"])</kbd>: This inserts several items with Unicode string type text in the position (the first parameter) of the combobox pop-up list. Each item from the iterable (the second parameter) will be inserted as the new line of the pop-up list and will begin from the given position index.</p>
<p><kbd>combo_box.insertPolicy()</kbd>: This returns the policy of the <kbd>QtWidgets.QComboBox.InsertPolicy</kbd> type that was used when inserting the policy into the combobox.</p>
<p><kbd>combo_box.insertSeparator(int)</kbd>: This inserts the separator for these combobox items in the position specified in the parameter.</p>
<p><kbd>combo_box.itemData(int, int)</kbd>: This returns the item's data according to the index (the first parameter) for the given role (the second parameter) in the combobox.</p>
<p><kbd>combo_box.itemDelegate()</kbd>: This returns the delegate of the item of the <kbd>QtWidgets.QAbstractItemDelegate</kbd> type that's used by the pop-up list view.</p>
<p><kbd>combo_box.itemIcon(int)</kbd>: This returns the icon of the <kbd>QtGui.QIcon</kbd> type for the item with the index specified in the parameter, inside the combobox.</p>
<p><kbd>combo_box.itemText(int)</kbd>: This returns the text of the item with the index in the combobox specified in the parameter.</p>
<p><kbd>combo_box.lineEdit()</kbd>: This returns the line edit field used to edit items in the combobox, if the combobox is editable.</p>
<p><kbd>combo_box.maxCount()</kbd>: This returns the maximum number of items that can be used with the combobox.</p>
<p><kbd>combo_box.maxVisibleItems()</kbd>: This returns the maximum number of items that can be displayed as a combobox pop-up list. If there are more elements than this, they will be visible if you scroll through the combobox screen.</p>
<p><kbd>combo_box.minimumContentsLength()</kbd>: This returns the minimum number of characters that will be represented with the combobox screen (default <kbd>0</kbd>).</p>
<p><kbd>combo_box.model()</kbd>: This returns the model for the combobox.</p>
<p><kbd>combo_box.modelColumn()</kbd>: This returns the visible column in the combobox model.</p>
<p><kbd>combo_box.removeItem(int)</kbd>: This removes the item from the combobox with the index specified in the parameter.</p>
<p><kbd>combo_box.rootModelIndex()</kbd>: This returns the root model item index for the combobox item.</p>
<p><kbd>combo_box.sizeAdjustPolicy()</kbd>: This returns the adjusted size of the <kbd>QtWidgets.QComboBox.SizeAdjustPolicy</kbd> type that's used with the combobox.</p>
<p><kbd>combo_box.validator()</kbd>: This returns the validator for the text input of the combobox.</p>
<p><kbd>combo_box.view()</kbd>: This returns the pop-up list view that's used for the combobox.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">events</h1>
                
            
            
                
<p>These are functions that are related to the events, such as event handlers:</p>
<p><kbd>combo_box.changeEvent(QtCore.QEvent)</kbd>: This handles state changes within the combobox.</p>
<p><kbd>combo_box.contextMenuEvent(QtGui.QContextMenuEvent)</kbd>: This event handler is designed to receive combobox context menu events.</p>
<p><kbd>combo_box.event(QtCore.QEvent)</kbd>: This receives events for the object and should return <kbd>True</kbd> if the event is recognized and processed.</p>
<p><kbd>combo_box.focusOutEvent(QtGui.QFocusEvent)</kbd>: This event handler is designed to receive the combobox keyboard focus events that are passed with event parameters when the focus is lost.</p>
<p><kbd>combo_box.focusInEvent(QtGui.QFocusEvent)</kbd>: This event handler is designed to receive the comb box keyboard focus events that are passed with event parameters when the focus is received.</p>
<p><kbd>combo_box.inputMethodEvent(QtGui.QInputMethodEvent)</kbd>: This event handler is designed to receive input method composition events that are passed with event parameters.</p>
<p><kbd>combo_box.keyPressEvent(QtGui.QKeyEvent)</kbd>: This event handler is designed to receive key press events for the combobox that is passed with event parameters.</p>
<p><kbd>combo_box.keyReleaseEvent(QtGui.QKeyEvent)</kbd>: This event handler is designed to receive key release events for the combobox that is passed with event parameters.</p>
<p><kbd>combo_box.mousePressEvent(QtGui.QMouseEvent)</kbd>: This event handler is designed to receive mouse press events for the combobox that is passed with event parameters.</p>
<p><kbd>combo_box.mouseReleaseEvent(QtGui.QMouseEvent)</kbd>: This event handler is designed to receive mouse release events for the combobox that this passed with event parameters.</p>
<p><kbd>combo_box.paintEvent(QtGui.QPaintEvent)</kbd>: This event handler is designed to receive paint events for the combobox that is passed with event parameters.</p>
<p><kbd>combo_box.resizeEvent(QtGui.QResizeEvent)</kbd>: This event handler is designed to receive and resize events for the combobox that is passed with event parameters.</p>
<p><kbd>combo_box.showEvent(QtGui.QShowEvent)</kbd>: This event handler is designed to receive show events for the combobox that is passed with event parameters.</p>
<p><kbd>combo_box.wheelEvent(QtGui.QWheelEvent)</kbd>: This event handler is designed to receive mouse wheel events for the combobox that is passed with event parameters.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">signals</h1>
                
            
            
                
<p>The available signals for the <kbd>QComboBox</kbd> class are as follows:</p>
<p><kbd>combo_box.activated(int)</kbd>: This signal is emitted when the item is chosen in the combobox with the index of the item passed in the parameter.</p>
<p><kbd>combo_box.activated(str)</kbd>: This signal is emitted when the item is chosen in the combobox with the text of the item passed in the parameter.</p>
<p><kbd>combo_box.currentIndexChanged(int)</kbd>: This signal is emitted when the item is chosen in the combobox and the current index of the item is changed, with the index that was passed in the parameter.</p>
<p><kbd>combo_box.currentIndexChanged(str)</kbd>: This signal is emitted when the item is chosen in the combobox and the current index of the item is changed, with the item's text that is passed in the parameter.</p>
<p><kbd>combo_box.currentTextChanged(str)</kbd>: This signal is emitted when the item is chosen in the combobox and the current text of the item is changed, with the item's text that is passed in the parameter.</p>
<p><kbd>combo_box.editTextChanged(str)</kbd>: This signal is emitted when the text of the editable line field is changed, with text that is passed in the parameter.</p>
<p><kbd>combo_box.highlighted(int)</kbd>: This signal is emitted when the item is highlighted by the user, with the item's index that is passed in the parameter.</p>
<p><kbd>combo_box.highlighted(str)</kbd>: This signal is emitted when the item is highlighted by the user, with the item's text that is passed in the parameter.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">QFontComboBox</h1>
                
            
            
                
<p>PyQt5 and PySide2 provide the completed combobox so that you can choose the font family in regard to text in the text field (for example). We can use this combobox in the application by typing the following line:</p>
<pre><strong>combo_boxf</strong> = QtWidgets.QFontComboBox()</pre>
<p><kbd>QFontComboBox</kbd> inherits <kbd>QComboBox</kbd> with the following functions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">set</h1>
                
            
            
                
<p>These are functions that are related to setting the parameters/properties in relation to the font combobox, such as setting text, alignment, and so on:</p>
<p><kbd>combo_boxf.setCurrentFont(QtGui.QFont)</kbd>: This sets the current font family for this combobox. The name of the font family, such as Helvetica or Times New Roman, which is passed to the parameter, can be used.</p>
<p><kbd>combo_boxf.setFontFilters(QtWidgets.QFontComboBox.FontFilters)</kbd>: This sets the filters that will be used with this combobox. The available filters are as follows:</p>
<ul>
<li><kbd>QtWidgets.QFontComboBox.AllFonts</kbd>: Shows all fonts.</li>
<li><kbd>QtWidgets.QFontComboBox.ScalableFonts</kbd>: Shows scalable fonts.</li>
<li><kbd>QtWidgets.QFontComboBox.NonScalableFonts</kbd>: Non-scalable fonts in the combobox.</li>
<li><kbd>QtWidgets.QFontComboBox.MonospacedFonts</kbd>: Monospaced fonts in the combobox.</li>
<li><kbd>QtWidgets.QFontComboBox.ProportionalFonts</kbd>: Proportional fonts in the combobox.</li>
</ul>
<p><kbd>combo_boxf.setWritingSystem(QtGui.QFontDatabase.WritingSystem)</kbd>: This sets the writing system that serves as a filter for this combobox.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">functional</h1>
                
            
            
                
<p>These are functions that return the current values of the font combobox, changes in functionality, and so on:</p>
<p><kbd>combo_boxf.currentFont()</kbd>: This returns the current font family of the <kbd>QtGui.QFont</kbd> type that is displayed/selected with the font combobox.</p>
<p><kbd>combo_boxf.fontFilters()</kbd>: This returns the filters of the <kbd>QtWidgets.QFontComboBox.FontFilters</kbd> type for the combobox.</p>
<p><kbd>combo_boxf.writingSystem()</kbd>: This returns the writing system for the combobox.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">events</h1>
                
            
            
                
<p>This function is related to the events, such as event handler:</p>
<p><kbd>combo_boxf.event(QtCore.QEvent)</kbd>: This receives events for the object and should return <kbd>True</kbd> if the event is recognized and processed.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">signals</h1>
                
            
            
                
<p>The following is the available signal for the <kbd>QFontComboBox</kbd> class:</p>
<p><kbd>combo_boxf.currentFontChanged(QtGui.QFont)</kbd>: This signal is emitted when the current font family of the combobox changes, and occurs when a new font is passed in the parameter.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">QComboBox example</h1>
                
            
            
                
<p>Let's implement the comboboxes we described previously in the application. We are creating the combobox so that we can choose between different fields that will be visualized—text field and table. Add the <kbd>QComboBox</kbd> class to the <kbd>u_style.py</kbd> files:</p>
<ol>
<li>Add the <kbd>UComBox</kbd> class using the following lines:</li>
</ol>
<pre style="padding-left: 60px">...<br/>class UComBox(QtWidgets.QComboBox):<br/><br/>    def __init__(self, parent=None, icon=None, pad=10,<br/>                            bdr=5, bdw=1, bdc=color[3]):<br/>        super(UComBox, self).__init__(parent)<br/>        self.icon, self.pad = icon, pad<br/>        self.bdr, self.bdw, self.bdc = bdr, bdw, bdc<br/>        font = UFonts(size=14, weight=59)<br/>        self.setFont(font.font1)<br/>        self.setStyleSheet(<br/>          """QComboBox {padding: %spx; background-color: %s;<br/>              color: %s; border-style: solid; border-radius: %spx;<br/>              border-width: %spx; border-color: %s;}<br/>             QComboBox:drop-down:down-arrow { image: url(%s);<br/>              width: 14px; height: 14px;}<br/>             QComboBox:drop-down:button { margin: %spx;<br/>              background-color: %s; border-style: solid;<br/>              border-radius: %spx; border-width: %spx;<br/>              border-color: %s;}""" <br/>             % (self.pad, color[0], color[3], self.bdr, self.bdw,<br/>               self.bdc, self.icon, self.pad, color[0], self.bdr,<br/>               self.bdw, self.bdc))<br/>  ...</pre>
<p style="padding-left: 60px">This combobox has styling properties that can be reimplemented. Now, we need to add this class to the <kbd>u_app.py</kbd> files so that we can use them in the application.</p>
<ol start="2">
<li>Add the following to the import section of the <kbd>u_app.py</kbd> files:</li>
</ol>
<pre style="padding-left: 60px">...<br/>from u_style import UComBox<br/>...</pre>
<ol start="3">
<li>Then, add the following lines to the <kbd>__init__()</kbd>  function of the <kbd>u_app.py</kbd> files:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    def __init__(self, parent=None):<br/>        ...<br/>        self.combox1 = UComBox(self.frame2)<br/>        self.combox1.addItems(["Texts", "Table"])<br/>        ...<br/>        self.layfr2.addWidget(self.combox1, 0, 0, 1, 1)<br/>        self.layfr2.addWidget(self.label1, 1, 0, 1, 1)<br/>        self.layfr2.addWidget(self.line_ed3, 4, 0, 1, 1)<br/>        ... <br/>...</pre>
<p style="padding-left: 60px">This is the combobox instance with the list of items that will be displayed.</p>
<ol start="4">
<li>To change the arrow of the combobox button to an icon, we can change the following line, as follows:</li>
</ol>
<pre style="padding-left: 60px">...<br/>self.combox1 = UComBox(self.frame2, icon="Path/to/Icon")<br/>...</pre>
<p style="padding-left: 60px">This will add the icon with a specified path and will change the default arrow icon.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">QListView</h1>
                
            
            
                
<p>This class provides a list or icon view that's implemented on the model. <kbd>QListView</kbd> is used to display the items as a simple non-hierarchical list. With the help of the list view, the combobox pop-up list can be represented in another way. The inheritance scheme of <kbd>QListView</kbd> is as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/daec193a-99b6-4c24-84cf-73f62fe3da1a.png"/></p>
<p>The following is the declaration statement of this class in the application:</p>
<pre><strong>list_view</strong> = QtWidgets.QListView()</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Functions of the QListView class</h1>
                
            
            
                
<p>The <kbd>QListView</kbd> class improves functionality by means of the following functions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">set</h1>
                
            
            
                
<p>These are functions related to setting parameters/properties in relation to the list view:</p>
<p><kbd>list_view.setBatchSize(int)</kbd>: This sets the number of items of each batch if the layout mode is set to <kbd>Batched</kbd>.</p>
<p><kbd>list_view.setFlow(QtWidgets.QListView.Flow)</kbd>: This sets the flow of the content that's used with the list view. The flows that are available are as follows:</p>
<ul>
<li><kbd>QtWidgets.QListView.LeftToRight</kbd>—<kbd>0</kbd>: The items will be laid out from left to right.</li>
<li><kbd>QtWidgets.QListView.TopToBottom</kbd>—<kbd>1</kbd>: The items will be laid out from top to bottom.</li>
</ul>
<p><kbd>list_view.setGridSize(QtCore.QSize)</kbd>: This sets the size of the layout grid.</p>
<p><kbd>list_view.setLayoutMode(QtWidgets.QListView.LayoutMode)</kbd>: This sets the mode of the layout for this list view. The modes that are available are as follows:</p>
<ul>
<li><kbd>QtWidgets.QListView.SinglePass</kbd>—<kbd>0</kbd>: All items are laid out simultaneously.</li>
<li><kbd>QtWidgets.QListView.Batched</kbd>—<kbd>1</kbd>: Items are laid out in batches.</li>
</ul>
<p><kbd>list_view.setModelColumn(int)</kbd>: This sets the column in the model specified in the parameter that will be visible.</p>
<p><kbd>list_view.setMovement(QtWidgets.QListView.Movement)</kbd>: This sets the movement for items in this list view. The movements that are available are as follows:</p>
<ul>
<li><kbd>QtWidgets.QListView.Static</kbd>—<kbd>0</kbd>: Items cannot be moved.</li>
<li><kbd>QtWidgets.QListView.Free</kbd>—<kbd>1</kbd>: Items can be moved.</li>
<li><kbd>QtWidgets.QListView.Snap</kbd>—<kbd>2</kbd>: Items will be moved when they're snapped to the specified grid.</li>
</ul>
<p><kbd>list_view.setPositionForIndex(QtCore.QPoint, QtCore.QModelIndex)</kbd>: This sets the content position of the item at the index (the second parameter) in the model in relation to the position specified as the first parameter.</p>
<p><kbd>list_view.setResizeMode(QtWidgets.QListView.ResizeMode)</kbd>: This sets the resize mode for the model of the list view. The resizing that's available is as follows:</p>
<ul>
<li><kbd>QtWidgets.QListView.Fixed</kbd>—<kbd>0</kbd>: The items will be laid out for the first time when the list view is shown.</li>
</ul>
<ul>
<li><kbd>QtWidgets.QListView.Adjust</kbd>—<kbd>1</kbd>: The items will be laid out every time the list view is resized.</li>
</ul>
<p><kbd>list_view.setRowHidden(int, bool)</kbd>: This sets the row (the first parameter) to hidden if the second parameter is set to <kbd>True</kbd>.</p>
<p><kbd>list_view.setSelectionRectVisible(bool)</kbd>: If the parameter is <kbd>True</kbd>, this sets the selection rectangle as visible.</p>
<p><kbd>list_view.setSpacing(int)</kbd>: This sets the space around all the sides of the items represented in the layout.</p>
<p><kbd>list_view.setUniformItemSizes(bool)</kbd>: If the parameter is <kbd>True</kbd>, all items are supposed to be the same size in the list view.</p>
<p><kbd>list_view.setViewMode(QtWidgets.QListView.ViewMode)</kbd>: This sets the view mode for this list view. The view modes that are available are as follows:</p>
<ul>
<li><kbd>QtWidgets.QListView.ListMode</kbd>—<kbd>0</kbd>: Items will be laid out using static movement, a <kbd>TopToBottom</kbd> flow, with a small size.</li>
<li><kbd>QtWidgets.QListView.IconMode</kbd>—<kbd>1</kbd>: Items will be laid out using free movement, a <kbd>LeftToRight</kbd> flow, with a large size.</li>
</ul>
<p><kbd>list_view.setWordWrap(bool)</kbd>: If the parameter is <kbd>True</kbd>, the item text will be wrapped at word breaks.</p>
<p><kbd>list_view.setWrapping(bool)</kbd>: If the parameter is <kbd>True</kbd>, the item layout will wrap when the space in the visible area is insufficient.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">is/has</h1>
                
            
            
                
<p>These are functions that return a Boolean value (<kbd>bool</kbd>) related to the list view states, for example, to check visibility:</p>
<ul>
<li><kbd>list_view.isRowHidden(int)</kbd>: This returns <kbd>True</kbd> if the row, specified in the parameter, is hidden in the list view; otherwise, it returns <kbd>False</kbd>.</li>
<li><kbd>list_view.isSelectionRectVisible()</kbd>: This returns <kbd>True</kbd> if the selection rectangle is visible; otherwise, the selection rectangle is hidden.</li>
<li><kbd>list_view.isWrapping()</kbd>: This returns <kbd>True</kbd> if the layout will wrap when the space in the visible area is insufficient.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">functional</h1>
                
            
            
                
<p>These are functions that are related to the returns of the current list view:</p>
<p><kbd>list_view.batchSize()</kbd>: This returns the number of items of each batch if the layout mode is set to <kbd>Batched</kbd>.</p>
<p><kbd>list_view.clearPropertyFlags()</kbd>: This clears the property flags from the list view.</p>
<p><kbd>list_view.flow()</kbd>: This returns the flow of the content that's used with a list view of the <kbd>QtWidgets.QListView.Flow</kbd> type.</p>
<p><kbd>list_view.gridSize()</kbd>: This returns the size of the layout grid that's used with a list view of the <kbd>QtCore.QSize</kbd> type.</p>
<p><kbd>list_view.layoutMode()</kbd>: This returns the layout mode of the <kbd>QtWidgets.QListView.LayoutMode</kbd> type.</p>
<p><kbd>list_view.modelColumn()</kbd>: This returns the number of columns that are visible in the model.</p>
<p><kbd>list_view.movement()</kbd>: This returns the movement of the <kbd>QtWidgets.QListView.Movement</kbd> type, describing whether the items can be moved, snapped to a grid, or cannot be moved.</p>
<p><kbd>list_view.rectForIndex(QtCore.QModelIndex)</kbd>: This returns the rectangle of the <kbd>QtCore.QRect</kbd> type for the item at the position index in the model, as specified in the parameter.</p>
<p><kbd>list_view.resizeMode()</kbd>: This returns the resize mode of the <kbd>QtWidgets.QListView.ResizeMode</kbd> type or how the items are laid out when the list view is resized.</p>
<p><kbd>list_view.spacing()</kbd>: This returns the space around all the sides of the items in the layout.</p>
<p><kbd>list_view.uniformItemSizes()</kbd>: This returns <kbd>True</kbd> if all the items have the same size in this list view.</p>
<p><kbd>list_view.viewMode()</kbd>: This returns the view mode of the <kbd>QtWidgets.QListView.ViewMode</kbd> type for this list view.</p>
<p><kbd>list_view.wordWrap()</kbd>: This returns <kbd>True</kbd> if the item text is wrapped at word breaks.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">events</h1>
                
            
            
                
<p>These are functions that are related to events, such as event handlers:</p>
<p><kbd>list_view.dragLeaveEvent(QtGui.QDragLeaveEvent)</kbd>: This event handler is called with the event parameter when the mouse leaves the list view and a drag operation is in progress.</p>
<p><kbd>list_view.dragMoveEvent(QtGui.QDragMoveEvent)</kbd>: This event handler is called with the event parameter when conditions occur, such as the cursor entering or moving within the view, the modifier key is clicked on the keyboard while the list view has focus, or if a drag operation is in progress.</p>
<p><kbd>list_view.dropEvent(QtGui.QDropEvent)</kbd>: This event handler is called with the event parameter when the drag is dropped on the list view.</p>
<p><kbd>list_view.event(QtCore.QEvent)</kbd>: This receives events to the object and should return <kbd>True</kbd> if the event is recognized and processed.</p>
<p><kbd>list_view.mouseMoveEvent(QtGui.QMouseEvent)</kbd>: This event handler receives mouse move events for the list view, along with the mouse event that's passed in the parameter.</p>
<p><kbd>list_view.mouseReleaseEvent(QtGui.QMouseEvent)</kbd>: This event handler receives mouse release events for the list view, along with the mouse event that's passed in the parameter.</p>
<p><kbd>list_view.paintEvent(QtGui.QPaintEvent)</kbd>: This event handler receives paint events for the list view, along with the paint event that's passed in the parameter.</p>
<p><kbd>list_view.resizeEvent(QtGui.QResizeEvent)</kbd>: This event handler receives resize events for the list view, along with the resize event that's passed in the parameter.</p>
<p><kbd>list_view.timerEvent(QtCore.QTimerEvent)</kbd>: This event handler receives timer events for the list view, along with the timer event that's passed in the parameter.</p>
<p><kbd>list_view.wheelEvent(QtGui.QWheelEvent)</kbd>: This event handler receives mouse wheel events for the list view, along with the wheel event that's passed in the parameter.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">signals</h1>
                
            
            
                
<p>The available signal for the <kbd>QListView</kbd> class is as follows:</p>
<p><kbd>list_view.indexesMoved(QtCore.QModelIndexList)</kbd>: This signal is emitted when the indexes specified in the parameter are moved in the view.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">QListView example</h1>
                
            
            
                
<p>Now, we will create the <kbd>UListV</kbd> class in the <kbd>u_style.py</kbd> files of the PySide2 and PyQt5 apps. This class will demonstrate utilization of the list view with the combobox that we created previously:</p>
<ol>
<li>Add the <kbd>UListV</kbd> class to the <kbd>u_style.py</kbd> files:</li>
</ol>
<pre style="padding-left: 60px">...<br/>class UListV(QtWidgets.QListView):<br/><br/>    def __init__(self, parent=None, mg=5, pad=10,<br/>                       bdr=5, bdw=1, bdc=color[3]):<br/>        super(UListV, self).__init__(parent)<br/>        self.setWordWrap(True)<br/>        self.mg, self.pad = mg, pad<br/>        self.bdr, self.bdw, self.bdc = bdr, bdw, bdc<br/>        font = UFonts(size=14, weight=59)<br/>        self.setFont(font.font1)<br/>        self.setStyleSheet(<br/>          """margin: %spx; padding: %spx; background-color: %s;<br/>             color: %s; border-style: solid; border-radius: %spx;<br/>             border-width: %spx; border-color: %s;"""<br/>          % (self.mg, self.pad, color[0], color[3],<br/>                      self.bdr, self.bdw, self.bdc))<br/>...</pre>
<p style="padding-left: 60px">This list view will be used in the combobox to display the popup. To implement this list view with a combobox in the application, we need to add some lines in the <kbd>u_app.py</kbd> files.</p>
<ol start="2">
<li>Add the <kbd>UListV</kbd> class to the import section of the <kbd>u_app.py</kbd> files, in keeping with the <kbd>UCombo</kbd> class:</li>
</ol>
<pre style="padding-left: 60px">...<br/>from u_style import UComBox, UListV<br/>...</pre>
<ol start="3">
<li>In addition, change the lines of the combobox, as follows:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    def __init__(self, parent=None):<br/>        ...<br/>        self.combox1.addItems(["Texts", "Table"])<br/>        self.combox1.setView(UListV())<br/>        ...<br/>...</pre>
<p style="padding-left: 60px">This sets the list view for the combobox element. By doing this, we can style and add functionality to the combobox pop-up list.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">QTableView</h1>
                
            
            
                
<p>Let's describe table implementation in the GUI application. The <kbd>QTableView</kbd> class provides the representation of the data in table form. In accordance with the paradigm of the Qt framework, this class (including the list view) provides a default model-view implementation of the table view. To fill the table with some data, you need to use models such as the <kbd>QAbstractTableModel</kbd> class of the <kbd>QtCore</kbd> module. The <kbd>QTableView</kbd> class has the following inheritance scheme:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/e485f97c-0a08-4fbc-be61-167e48d8a5bc.png" style="width:65.83em;height:5.25em;"/></p>
<p class="mce-root"/>
<p>The declaration statement of this class in the application is as follows:</p>
<pre><strong>table_view</strong> = QtWidgets.QTableView()</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">QTableView functions</h1>
                
            
            
                
<p>The <kbd>QTableView</kbd> class improves functionality with the following functions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">set</h1>
                
            
            
                
<p>These are functions that are related to setting parameters/properties in relation to the table view:</p>
<p><kbd>table_view.setColumnHidden(int, bool)</kbd>: If the second parameter is <kbd>True</kbd>, this sets the column specified in the parameter as hidden.</p>
<p><kbd>table_view.setColumnWidth(int, int)</kbd>: This sets the width (the second parameter) of the column that's specified as the first parameter.</p>
<p><kbd>table_view.setCornerButtonEnabled(bool)</kbd>: If the parameter is <kbd>True</kbd>, this sets the button in the top-left corner of this table to select all of the table.</p>
<p><kbd>table_view.setGridStyle(QtCore.Qt.PenStyle)</kbd>: This sets the pen style that will be used to draw the grid for this table. The styles that are available are as follows:</p>
<ul>
<li><kbd>QtCore.Qt.NoPen</kbd>—<kbd>0</kbd>: No pen.</li>
<li><kbd>QtCore.Qt.SolidLine</kbd>—<kbd>1</kbd>: Plain line.</li>
<li><kbd>QtCore.Qt.DashLine</kbd>—<kbd>2</kbd>: Dashed line.</li>
<li><kbd>QtCore.Qt.DotLine</kbd>—<kbd>3</kbd>: Dotted line.</li>
<li><kbd>QtCore.Qt.DashDotLine</kbd>—<kbd>4</kbd>: Dashed-dotted line.</li>
<li><kbd>QtCore.Qt.DashDotDotLine</kbd>—<kbd>5</kbd>: Dashed and double-dotted line.</li>
<li><kbd>QtCore.Qt.CustomDashLine</kbd>—<kbd>6</kbd>: Customized dashed line, which is defined by using the <kbd>QtGui.QPainterPathStroker</kbd> custom pattern.</li>
</ul>
<p><kbd>table_view.setHorizontalHeader(QtWidgets.QHeaderView)</kbd>: This sets the header specified in the parameter that will be used as a horizontal header.</p>
<p><kbd>table_view.setModel(QtCore.QAbstractItemModel)</kbd>: This sets the model with data that will be used for the table view.</p>
<p><kbd>table_view.setRowHeight(int, int)</kbd>: This sets the height (the second parameter) of the row specified as the first parameter.</p>
<p><kbd>table_view.setRowHidden(int, bool)</kbd>: If the second parameter is <kbd>True</kbd>, this sets the row (the first parameter) as hidden.</p>
<p><kbd>table_view.setShowGrid(bool)</kbd>: If the parameter is <kbd>True</kbd>, the grid will be shown with this table.</p>
<p><kbd>table_view.setSortingEnabled(bool)</kbd>: If the parameter is <kbd>True</kbd>, this sets the sorting for the table as enabled.</p>
<p><kbd>table_view.setSpan(int, int, int, int)</kbd>: This sets the span for the element in the row (the first parameter) and column (the second parameter) to the number of rows (the third parameter) and columns (the fourth parameter).</p>
<p><kbd>table_view.setVerticalHeader(QtWidgets.QHeaderView)</kbd>: This sets the header that's specified in the parameter and will be used as a vertical header.</p>
<p><kbd>table_view.setWordWrap(bool)</kbd>: If the parameter is <kbd>True</kbd>, this sets the word wrapping policy for the item's text.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">is</h1>
                
            
            
                
<p>These are functions that return a Boolean value (<kbd>bool</kbd>) related to the table view states, for example, to check visibility:</p>
<p><kbd>table_view.isColumnHidden(int)</kbd>: This returns <kbd>True</kbd> if the column specified in the parameter is hidden.</p>
<p><kbd>table_view.isCornerButtonEnabled()</kbd>: This returns <kbd>True</kbd> if the button displayed in the top-left corner of the table view is enabled.</p>
<p><kbd>table_view.isRowHidden(int)</kbd>: This returns <kbd>True</kbd> if the row specified in the parameter is hidden.</p>
<p><kbd>table_view.isSortingEnabled()</kbd>: This returns <kbd>True</kbd> if sorting is enabled for this table.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">functional</h1>
                
            
            
                
<p>These are functions that return the current table view values, changes in functionality, and so on:</p>
<p><kbd>table_view.clearSpans()</kbd>: This removes all row/column spans in the table view.</p>
<p><kbd>table_view.columnAt(int)</kbd>: This returns the column that is located by the <em>y</em> coordinate that's specified in the parameter in the content coordinates.</p>
<p><kbd>table_view.columnCountChanged(int, int)</kbd>: This is the slot that's called when columns are added or deleted. The previous number of columns is specified as the first parameter, while the new number of columns is specified as the second parameter.</p>
<p><kbd>table_view.columnMoved(int, int, int)</kbd>: This is the slot that's called to change the index of the column that's specified as the first parameter. The previous index is specified as the second parameter, while the new index is specified as the third parameter.</p>
<p><kbd>table_view.columnResized(int, int, int)</kbd>: This is the slot that's called to change the width of the column that's specified as the first parameter. The previous width is specified as the second parameter, while the new width is specified as the third parameter.</p>
<p><kbd>table_view.columnSpan(int, int)</kbd>: This returns the column span of the element in the table in the specified row (the first parameter) and column (the second parameter).</p>
<p><kbd>table_view.columnViewportPosition(int)</kbd>: This returns the <em>x</em> coordinate of the column specified in the parameter in the content coordinates.</p>
<p><kbd>table_view.columnWidth(int)</kbd>: This returns the width of the column specified in the parameter.</p>
<p><kbd>table_view.gridStyle()</kbd>: This returns the style of the <kbd>QtCore.Qt.PenStyle</kbd> type for the table grid.</p>
<p><kbd>table_view.hideColumn(int)</kbd>: This hides the column of the table specified in the parameter.</p>
<p><kbd>table_view.hideRow(int)</kbd>: This hides the row specified in the parameter.</p>
<p><kbd>table_view.horizontalHeader()</kbd>: This returns the horizontal header of the <kbd>QtWidgets.QHeaderView</kbd> type for the table view.</p>
<p><kbd>table_view.resizeColumnsToContents()</kbd>: This resizes all columns to the size based on the size hints of the delegate that's used for each item in the columns.</p>
<p><kbd>table_view.resizeColumnToContents(int)</kbd>: This resizes the column that's specified in the parameter to the size based on the size hint of the delegate that's used for each item in the column.</p>
<p><kbd>table_view.resizeRowsToContents()</kbd>: This resizes all rows to the size based on the size hints of the delegate that's used for each item in the rows.</p>
<p><kbd>table_view.resizeRowToContents(int)</kbd>: This resizes the row that's specified in the parameter to the size based on the size hint of the delegate that's used for each item in the row.</p>
<p><kbd>table_view.rowAt(int)</kbd>: This returns the row that is located by the <em>y</em> coordinate that's specified in the parameter in the content coordinates.</p>
<p><kbd>table_view.rowCountChanged(int, int)</kbd>: This is the slot that's called when columns are added or deleted, that is, the previous number of rows (the first parameter) and the new number of rows (the second parameter).</p>
<p><kbd>table_view.rowHeight(int)</kbd>: This returns the height of the row specified in the parameter.</p>
<p><kbd>table_view.rowMoved(int, int, int)</kbd>: This is the slot that's called to change the index of the row that's specified as the first parameter. The previous index is specified as the second parameter, while the new index is specified as the third parameter.</p>
<p><kbd>table_view.rowResized(int, int, int)</kbd>: This is the slot that's called to change the width of the row that's specified as the first parameter. The previous width is specified as the second parameter, while the new width is specified as the third parameter.</p>
<p><kbd>table_view.rowSpan(int, int)</kbd>: This returns the row span of the element in the table that is in the specified row (the first parameter) and column (the second parameter).</p>
<p><kbd>table_view.rowViewportPosition(int)</kbd>: This returns the <em>y</em> coordinate of the row that's specified in the parameter in the content coordinates.</p>
<p><kbd>table_view.selectColumn(int)</kbd>: This selects the column that's specified in the parameter of this table view.</p>
<p><kbd>table_view.selectRow(int)</kbd>: This selects the row that's specified in the parameter of this table view.</p>
<p><kbd>table_view.showColumn(int)</kbd>: This shows the column that's specified in the parameter.</p>
<p><kbd>table_view.showGrid()</kbd>: This returns <kbd>True</kbd> if the table is displayed in grid mode.</p>
<p><kbd>table_view.showRow(int)</kbd>: This shows the row that's specified in the parameter.</p>
<p><kbd>table_view.sortByColumn(int, QtCore.Qt.SortOrder)</kbd>: This sorts the model by the column specified as the first parameter in the order (the second parameter).</p>
<p><kbd>table_view.verticalHeader()</kbd>: This returns the vertical header of the <kbd>QtWidgets.QHeaderView</kbd> type that's used for this table view.</p>
<p><kbd>table_view.wordWrap()</kbd>: This returns <kbd>True</kbd> if the word wrapping policy is enabled for the item's text.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">events</h1>
                
            
            
                
<p>This is function that is related to events such as event handler, and so on:</p>
<p><kbd>table_view.paintEvent(QtGui.QPaintEvent)</kbd>: This event handler receives paint events for this table view with events passed in the parameter.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">QTableView example</h1>
                
            
            
                
<p>To demonstrate the table in the application, we need to create the table data model and view for the table. First, let's create the model with the <kbd>QAbstractTableModel</kbd> class from the <kbd>QtCore</kbd> module. Create files named <kbd>u_table.py</kbd> in both the <kbd>App/App_PyQt5/</kbd> and <kbd>App/App_PySide2/</kbd> directories and include the following lines inside them:</p>
<ol>
<li>In the case of PyQt5, add the following to the import section of the <kbd>u_table.py</kbd> file:</li>
</ol>
<pre style="padding-left: 60px">...<br/>from PyQt5 import QtCore<br/>import random<br/>...</pre>
<ol start="2">
<li>In the case of PySide2, add the following to the import section of the <kbd>u_table.py</kbd> file:</li>
</ol>
<pre style="padding-left: 60px">...<br/>from PySide2 import QtCore<br/>import random<br/>...</pre>
<ol start="3">
<li>Then, add the <kbd>UTModel</kbd> class to the <kbd>u_table.py</kbd> files:</li>
</ol>
<pre style="padding-left: 60px">...<br/>class UTModel(QtCore.QAbstractTableModel):<br/><br/>    def __init__(self, parent=None):<br/>        super(UTModel, self).__init__(parent)<br/><br/>    def rowCount(self, parent):<br/>        return 27<br/><br/>    def columnCount(self, parent):<br/>        return 14<br/><br/>    def data(self, row, column):<br/>        randn = random.randint(1, 100)<br/>        return randn<br/>...</pre>
<p style="padding-left: 60px">These methods are required in the abstract class. They describe the total number of rows and columns in the table, as well as the data for each cell. Now, we need to add some style for this table using the <kbd>u_style.py</kbd> files.</p>
<ol start="4">
<li>Create a class called <kbd>UTabView</kbd> in the <kbd>u_style.py</kbd> files:</li>
</ol>
<pre style="padding-left: 60px">...<br/>class UTabView(QtWidgets.QTableView):<br/><br/>    def __init__(self, parent=None, tvpad=7, tvbgcolor=color[1],<br/>                 tvtxc=color[3], bdr=5, bdw=1, bdc=color[3]):<br/>        super(UTabView, self).__init__(parent)<br/>        self.tvpad = tvpad<br/>        self.tvbgcolor, self.tvtxc = tvbgcolor, tvtxc<br/>        self.bdr, self.bdw, self.bdc = bdr, bdw, bdc<br/>        font = UFonts(size=14, weight=59)<br/>        self.setFont(font.font1)<br/>        self.setStyleSheet( <br/>          """QTableView {padding: %spx; background-color: %s;<br/>              color: %s; border-style: solid;<br/>              border-radius: %spx; border-width: %spx;<br/>              border-color: %s; gridline-color: %s;}"""<br/>          % (self.tvpad, self.tvbgcolor, self.tvtxc,<br/>             self.bdr, self.bdw, self.bdc, color[3]))<br/>  ...</pre>
<p style="padding-left: 60px">This table view will be used to style the table with custom properties and will allow us to reimplement them if needed.</p>
<p>Now, add some lines to the <kbd>u_app.py</kbd> files:</p>
<ol start="1">
<li>In the import section of the <kbd>u_app.py</kbd> file, add the <kbd>UTabView</kbd> class, as follows:</li>
</ol>
<pre style="padding-left: 60px">...<br/>from u_style import UComBox, UListV, <strong>UTabView</strong><br/>from u_table import <strong>UTModel</strong><br/>...</pre>
<ol start="2">
<li>Then, inside the <kbd>__init__()</kbd> function of the <kbd>UApp</kbd> class, add the table and set the model. Finally, add the signal of the combobox with the function that will be called:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    def __init__(self, parent=None):<br/>        ...<br/>        self.table = UTabView(self.frame1)<br/>        self.table.setVisible(False)<br/>        model = UTModel()<br/>        self.table.setModel(model)<br/>        self.layfr1 = QtWidgets.QGridLayout()<br/>        self.layfr1.addWidget(self.table, 0, 0, 1, 1)<br/>        self.layfr1.addWidget(self.text_edit, 0, 0, 1, 1)<br/>        ...<br/>        self.combox1.activated.connect(self.txt_table)<br/><br/>    def txt_table(self):<br/>        if self.combox1.currentText() == "Texts":<br/>            self.text_edit.setVisible(True)<br/>            self.table.setVisible(False)<br/>        if self.combox1.currentText() == "Table":<br/>            self.text_edit.setVisible(False)<br/>            self.table.setVisible(True)<br/>...</pre>
<p style="padding-left: 60px">We're using the table view to represent the table in the application and using the model to represent the data in the table (following the model-view paradigm). As a result, if the table in the combobox is selected, the table will appear as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/8939828d-9409-4163-8c82-a4af8b178155.png"/></p>
<p>Each cell of this table uses the random number as a value.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we described the basic paradigms of the Qt framework known as the model-view. In a broad sense, the MVC architecture provides us with an opportunity to use data and represent this data in a flexible form; in other words, to split the model with the data and views of the data model. In this way, almost any type of data can be implemented with a GUI application. In regard to the development process, some features, such as tree views and list views, were not shown, but these can be used in conjunction with documentation in a broad area of software development. In the chapters that follow, models with data will be modernized and demonstrated in greater detail.</p>
<p>The next chapter will describe the basic construction of the different kinds of buttons that are used with Python bindings to create GUI apps.</p>


            

            
        
    </body></html>