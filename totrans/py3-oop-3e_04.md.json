["```py\n>>> print \"hello world\"\n File \"<stdin>\", line 1\n print \"hello world\"\n ^\nSyntaxError: invalid syntax  \n```", "```py\n>>> x = 5 / 0\nTraceback (most recent call last):\n File \"<stdin>\", line 1, in <module>\nZeroDivisionError: int division or modulo by zero\n\n>>> lst = [1,2,3]\n>>> print(lst[3])\nTraceback (most recent call last):\n File \"<stdin>\", line 1, in <module>\nIndexError: list index out of range\n\n>>> lst + 2\nTraceback (most recent call last):\n File \"<stdin>\", line 1, in <module>\nTypeError: can only concatenate list (not \"int\") to list\n\n>>> lst.add\nTraceback (most recent call last):\n File \"<stdin>\", line 1, in <module>\nAttributeError: 'list' object has no attribute 'add'\n\n>>> d = {'a': 'hello'}\n>>> d['b']\nTraceback (most recent call last):\n File \"<stdin>\", line 1, in <module>\nKeyError: 'b'\n\n>>> print(this_is_not_a_var)\nTraceback (most recent call last):\n File \"<stdin>\", line 1, in <module>\nNameError: name 'this_is_not_a_var' is not defined  \n```", "```py\nclass EvenOnly(list): \n    def append(self, integer): \n        if not isinstance(integer, int): \n raise TypeError(\"Only integers can be added\") \n        if integer % 2: \n raise ValueError(\"Only even numbers can be added\") \n        super().append(integer) \n```", "```py\n>>> e = EvenOnly()\n>>> e.append(\"a string\")\nTraceback (most recent call last):\n File \"<stdin>\", line 1, in <module>\n File \"even_integers.py\", line 7, in add\n raise TypeError(\"Only integers can be added\")\nTypeError: Only integers can be added\n\n>>> e.append(3)\nTraceback (most recent call last):\n File \"<stdin>\", line 1, in <module>\n File \"even_integers.py\", line 9, in add\n raise ValueError(\"Only even numbers can be added\")\nValueError: Only even numbers can be added\n>>> e.append(2)\n```", "```py\ndef no_return(): \n    print(\"I am about to raise an exception\") \n    raise Exception(\"This is always raised\") \n    print(\"This line will never execute\") \n    return \"I won't be returned\" \n```", "```py\n>>> no_return()\nI am about to raise an exception\nTraceback (most recent call last):\n File \"<stdin>\", line 1, in <module>\n File \"exception_quits.py\", line 3, in no_return\n raise Exception(\"This is always raised\")\nException: This is always raised  \n```", "```py\ndef call_exceptor(): \n    print(\"call_exceptor starts here...\") \n    no_return() \n    print(\"an exception was raised...\") \n    print(\"...so these lines don't run\") \n```", "```py\n>>> call_exceptor()\ncall_exceptor starts here...\nI am about to raise an exception\nTraceback (most recent call last):\n File \"<stdin>\", line 1, in <module>\n File \"method_calls_excepting.py\", line 9, in call_exceptor\n no_return()\n File \"method_calls_excepting.py\", line 3, in no_return\n raise Exception(\"This is always raised\")\nException: This is always raised  \n```", "```py\ntry: \n    no_return() \nexcept: \n    print(\"I caught an exception\") \nprint(\"executed after the exception\") \n```", "```py\nI am about to raise an exception \nI caught an exception \nexecuted after the exception \n```", "```py\ndef funny_division(divider):\n    try:\n        return 100 / divider\n except ZeroDivisionError:\n        return \"Zero is not a good idea!\"\n\nprint(funny_division(0))\nprint(funny_division(50.0))\nprint(funny_division(\"hello\"))\n```", "```py\nZero is not a good idea!\n2.0\nTraceback (most recent call last):\n File \"catch_specific_exception.py\", line 9, in <module>\n print(funny_division(\"hello\"))\n File \"catch_specific_exception.py\", line 3, in funny_division\n return 100 / divider\nTypeError: unsupported operand type(s) for /: 'int' and 'str'.  \n```", "```py\ndef funny_division2(divider):\n    try:\n        if divider == 13:\n            raise ValueError(\"13 is an unlucky number\")\n        return 100 / divider\n except (ZeroDivisionError, TypeError):\n        return \"Enter a number other than zero\"\n\nfor val in (0, \"hello\", 50.0, 13):\n\n    print(\"Testing {}:\".format(val), end=\" \")\n    print(funny_division2(val))\n```", "```py\nTesting 0: Enter a number other than zero\nTesting hello: Enter a number other than zero\nTesting 50.0: 2.0\nTesting 13: Traceback (most recent call last):\n File \"catch_multiple_exceptions.py\", line 11, in <module>\n print(funny_division2(val))\n File \"catch_multiple_exceptions.py\", line 4, in funny_division2\n raise ValueError(\"13 is an unlucky number\")\nValueError: 13 is an unlucky number  \n```", "```py\ndef funny_division3(divider):\n    try:\n        if divider == 13:\n            raise ValueError(\"13 is an unlucky number\")\n        return 100 / divider\n except ZeroDivisionError:\n        return \"Enter a number other than zero\"\n except TypeError:\n        return \"Enter a numerical value\"\n except ValueError:\n        print(\"No, No, not 13!\")\n        raise\n```", "```py\ntry: \n    raise ValueError(\"This is an argument\") \nexcept ValueError as e: \n    print(\"The exception arguments were\", e.args) \n```", "```py\nimport random \nsome_exceptions = [ValueError, TypeError, IndexError, None] \n\ntry: \n    choice = random.choice(some_exceptions) \n    print(\"raising {}\".format(choice)) \n    if choice: \n        raise choice(\"An error\") \nexcept ValueError: \n    print(\"Caught a ValueError\") \nexcept TypeError: \n    print(\"Caught a TypeError\") \nexcept Exception as e: \n    print(\"Caught some other error: %s\" % \n        ( e.__class__.__name__)) \nelse: \n    print(\"This code called if there is no exception\") \nfinally: \n    print(\"This cleanup code is always called\") \n```", "```py\n$ python finally_and_else.py\nraising None\nThis code called if there is no exception\nThis cleanup code is always called\n\n$ python finally_and_else.py\nraising <class 'TypeError'>\nCaught a TypeError\nThis cleanup code is always called\n\n$ python finally_and_else.py\nraising <class 'IndexError'>\nCaught some other error: IndexError\nThis cleanup code is always called\n\n$ python finally_and_else.py\nraising <class 'ValueError'>\nCaught a ValueError\nThis cleanup code is always called  \n```", "```py\nclass InvalidWithdrawal(Exception): \n    pass \n\nraise InvalidWithdrawal(\"You don't have $50 in your account\") \n```", "```py\nclass InvalidWithdrawal(Exception): \n    def __init__(self, balance, amount): \n        super().__init__(f\"account doesn't have ${amount}\") \n        self.amount = amount \n        self.balance = balance \n\n    def overage(self): \n        return self.amount - self.balance \n\nraise InvalidWithdrawal(25, 50) \n```", "```py\ntry: \n    raise InvalidWithdrawal(25, 50) \nexcept InvalidWithdrawal as e: \n    print(\"I'm sorry, but your withdrawal is \" \n            \"more than your balance by \" \n            f\"${e.overage()}\") \n```", "```py\ndef divide_with_exception(number, divisor): \n    try: \n        print(f\"{number} / {divisor} = {number / divisor}\") \n    except ZeroDivisionError: \n        print(\"You can't divide by zero\") \n\ndef divide_with_if(number, divisor): \n    if divisor == 0: \n        print(\"You can't divide by zero\") \n    else: \n        print(f\"{number} / {divisor} = {number / divisor}\") \n```", "```py\nclass Inventory:\n    def lock(self, item_type):\n        \"\"\"Select the type of item that is going to\n        be manipulated. This method will lock the\n        item so nobody else can manipulate the\n        inventory until it's returned. This prevents\n        selling the same item to two different\n        customers.\"\"\"\n        pass\n\n    def unlock(self, item_type):\n        \"\"\"Release the given type so that other\n        customers can access it.\"\"\"\n        pass\n\n    def purchase(self, item_type):\n        \"\"\"If the item is not locked, raise an\n        exception. If the item_type does not exist,\n        raise an exception. If the item is currently\n        out of stock, raise an exception. If the item\n        is available, subtract one item and return\n        the number of items left.\"\"\"\n        pass\n```", "```py\nitem_type = \"widget\"\ninv = Inventory()\ninv.lock(item_type)\ntry:\n    num_left = inv.purchase(item_type)\nexcept InvalidItemType:\n    print(\"Sorry, we don't sell {}\".format(item_type))\nexcept OutOfStock:\n    print(\"Sorry, that item is out of stock.\")\nelse:\n    print(\"Purchase complete. There are {num_left} {item_type}s left\")\nfinally:\n    inv.unlock(item_type)\n```", "```py\nimport hashlib\n\nclass User:\n    def __init__(self, username, password):\n        \"\"\"Create a new user object. The password\n        will be encrypted before storing.\"\"\"\n        self.username = username\n        self.password = self._encrypt_pw(password)\n        self.is_logged_in = False\n\n    def _encrypt_pw(self, password):\n        \"\"\"Encrypt the password with the username and return\n        the sha digest.\"\"\"\n        hash_string = self.username + password\n        hash_string = hash_string.encode(\"utf8\")\n        return hashlib.sha256(hash_string).hexdigest()\n\n    def check_password(self, password):\n        \"\"\"Return True if the password is valid for this\n        user, false otherwise.\"\"\"\n        encrypted = self._encrypt_pw(password)\n        return encrypted == self.password\n```", "```py\nclass AuthException(Exception): \n    def __init__(self, username, user=None): \n        super().__init__(username, user) \n        self.username = username \n        self.user = user \n\nclass UsernameAlreadyExists(AuthException): \n    pass \n\nclass PasswordTooShort(AuthException): \n    pass \n```", "```py\nclass Authenticator:\n    def __init__(self):\n        \"\"\"Construct an authenticator to manage\n        users logging in and out.\"\"\"\n        self.users = {}\n\n    def add_user(self, username, password):\n        if username in self.users:\n            raise UsernameAlreadyExists(username)\n        if len(password) < 6:\n            raise PasswordTooShort(username)\n        self.users[username] = User(username, password)\n```", "```py\nclass InvalidUsername(AuthException): \n    pass \n\nclass InvalidPassword(AuthException): \n    pass \n```", "```py\n    def login(self, username, password): \n        try: \n            user = self.users[username] \n        except KeyError: \n            raise InvalidUsername(username) \n\n        if not user.check_password(password): \n            raise InvalidPassword(username, user) \n\n        user.is_logged_in = True \n        return True \n```", "```py\n    def is_logged_in(self, username): \n        if username in self.users: \n            return self.users[username].is_logged_in \n        return False \n```", "```py\nauthenticator = Authenticator() \n```", "```py\nclass Authorizor: \n    def __init__(self, authenticator): \n        self.authenticator = authenticator \n        self.permissions = {} \n```", "```py\n    def add_permission(self, perm_name): \n        '''Create a new permission that users \n        can be added to''' \n        try: \n            perm_set = self.permissions[perm_name] \n        except KeyError: \n            self.permissions[perm_name] = set() \n        else: \n            raise PermissionError(\"Permission Exists\") \n\n    def permit_user(self, perm_name, username): \n        '''Grant the given permission to the user''' \n        try: \n            perm_set = self.permissions[perm_name] \n        except KeyError: \n            raise PermissionError(\"Permission does not exist\") \n        else: \n            if username not in self.authenticator.users: \n                raise InvalidUsername(username) \n            perm_set.add(username) \n```", "```py\nclass PermissionError(Exception): \n    pass \n```", "```py\n    def check_permission(self, perm_name, username): \n        if not self.authenticator.is_logged_in(username): \n            raise NotLoggedInError(username) \n        try: \n            perm_set = self.permissions[perm_name] \n        except KeyError: \n            raise PermissionError(\"Permission does not exist\") \n        else: \n            if username not in perm_set: \n                raise NotPermittedError(username) \n            else: \n                return True \n```", "```py\nclass NotLoggedInError(AuthException): \n    pass \n\nclass NotPermittedError(AuthException): \n    pass \n```", "```py\nauthorizor = Authorizor(authenticator) \n```", "```py\n>>> import auth\n>>> auth.authenticator.add_user(\"joe\", \"joepassword\")\n>>> auth.authorizor.add_permission(\"paint\")\n>>> auth.authorizor.check_permission(\"paint\", \"joe\")\nTraceback (most recent call last):\n File \"<stdin>\", line 1, in <module>\n File \"auth.py\", line 109, in check_permission\n raise NotLoggedInError(username)\nauth.NotLoggedInError: joe\n>>> auth.authenticator.is_logged_in(\"joe\")\nFalse\n>>> auth.authenticator.login(\"joe\", \"joepassword\")\nTrue\n>>> auth.authorizor.check_permission(\"paint\", \"joe\")\nTraceback (most recent call last):\n File \"<stdin>\", line 1, in <module>\n File \"auth.py\", line 116, in check_permission\n    raise NotPermittedError(username)\nauth.NotPermittedError: joe\n>>> auth.authorizor.check_permission(\"mix\", \"joe\")\nTraceback (most recent call last):\n File \"auth.py\", line 111, in check_permission\n perm_set = self.permissions[perm_name]\nKeyError: 'mix'\n\nDuring handling of the above exception, another exception occurred:\nTraceback (most recent call last):\n File \"<stdin>\", line 1, in <module>\n File \"auth.py\", line 113, in check_permission\n raise PermissionError(\"Permission does not exist\")\nauth.PermissionError: Permission does not exist\n>>> auth.authorizor.permit_user(\"mix\", \"joe\")\nTraceback (most recent call last):\n File \"auth.py\", line 99, in permit_user\n perm_set = self.permissions[perm_name]\nKeyError: 'mix'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n File \"<stdin>\", line 1, in <module>\n File \"auth.py\", line 101, in permit_user\n raise PermissionError(\"Permission does not exist\")\nauth.PermissionError: Permission does not exist\n>>> auth.authorizor.permit_user(\"paint\", \"joe\")\n>>> auth.authorizor.check_permission(\"paint\", \"joe\")\nTrue  \n```", "```py\nimport auth\n\n# Set up a test user and permission\nauth.authenticator.add_user(\"joe\", \"joepassword\")\nauth.authorizor.add_permission(\"test program\")\nauth.authorizor.add_permission(\"change program\")\nauth.authorizor.permit_user(\"test program\", \"joe\")\n\nclass Editor:\n    def __init__(self):\n        self.username = None\n        self.menu_map = {\n            \"login\": self.login,\n            \"test\": self.test,\n            \"change\": self.change,\n            \"quit\": self.quit,\n        }\n\n    def login(self):\n        logged_in = False\n        while not logged_in:\n            username = input(\"username: \")\n            password = input(\"password: \")\n            try:\n                logged_in = auth.authenticator.login(username, password)\n            except auth.InvalidUsername:\n                print(\"Sorry, that username does not exist\")\n            except auth.InvalidPassword:\n                print(\"Sorry, incorrect password\")\n            else:\n                self.username = username\n\n    def is_permitted(self, permission):\n        try:\n            auth.authorizor.check_permission(permission, self.username)\n        except auth.NotLoggedInError as e:\n            print(\"{} is not logged in\".format(e.username))\n            return False\n        except auth.NotPermittedError as e:\n            print(\"{} cannot {}\".format(e.username, permission))\n            return False\n        else:\n            return True\n\n    def test(self):\n        if self.is_permitted(\"test program\"):\n            print(\"Testing program now...\")\n\n    def change(self):\n        if self.is_permitted(\"change program\"):\n            print(\"Changing program now...\")\n\n    def quit(self):\n        raise SystemExit()\n\n    def menu(self):\n        try:\n            answer = \"\"\n            while True:\n                print(\n                    \"\"\"\nPlease enter a command:\n\\tlogin\\tLogin\n\\ttest\\tTest the program\n\\tchange\\tChange the program\n\\tquit\\tQuit\n\"\"\"\n                )\n                answer = input(\"enter a command: \").lower()\n                try:\n                    func = self.menu_map[answer]\n                except KeyError:\n                    print(\"{} is not a valid option\".format(answer))\n                else:\n                    func()\n        finally:\n            print(\"Thank you for testing the auth module\")\n\nEditor().menu()\n```"]