- en: Chapter 4. The Façade Pattern – Being Adaptive with Façade
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you learned about the Factory design pattern. We discussed
    about three variations—Simple Factory, Factory method, and Abstract Factory pattern.
    You also learned how each of them is used in the real world and looked at Python
    implementations. We also compared the Factory method with Abstract Factory patterns
    and listed the pros and cons. As we are now aware, both the Factory design pattern
    and Singleton design pattern ([Chapter 2](part0022_split_000.html#KVCC1-5ae934a69a004514b92177e2702ed0a9
    "Chapter 2. The Singleton Design Pattern"), *The Singleton Design Pattern*) are
    classified as Creational design patterns.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will move ahead and learn about another type of design pattern,
    the Structural design pattern. We will get introduced to the Façade design pattern
    and how it is used in software application development. We will work with a sample
    use case and implement it in Python v3.5.
  prefs: []
  type: TYPE_NORMAL
- en: 'In brief, we will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to Structural design patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An understanding of the Façade design pattern with a UML diagram
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A real-world use case with the Python v3.5 code implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Façade pattern and principle of least knowledge
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Structural design patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following points will help us understand more about Structural patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: Structural patterns describe how objects and classes can be combined to form
    larger structures.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structural patterns can be thought of as design patterns that ease the design
    by identifying simpler ways to realize or demonstrate relationships between entities.
    Entities mean objects or classes in the object-oriented world.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While the Class patterns describe abstraction with the help of inheritance and
    provide a more useful program interface, Object patterns describe how objects
    can be associated and composed to form larger objects. Structural patterns are
    a combination of Class and Object patterns.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following are a few examples of different Structural design patterns. You'd
    notice how each of these involve interaction between objects or classes to achieve
    high-level design or architectural goals.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the examples of Structural design patterns are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Adapter pattern**: Adapting an interface to another one so that it meets
    the client''s expectations. It tries to match interfaces of different classes
    based on the client''s needs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bridge pattern**: This decouples an object''s interface from its implementation
    so that both can work independently.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Decorator pattern**: This defines additional responsibilities for an object
    at runtime or dynamically. We add certain attributes to objects with an interface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are a few more Structural patterns that you will learn in this book. So,
    let's start by first taking up the Façade design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Façade design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The façade is generally referred to as the face of the building, especially
    an attractive one. It can be also referred to as a behavior or appearance that
    gives a false idea of someone's true feelings or situation. When people walk past
    a façade, they can appreciate the exterior face but aren't aware of the complexities
    of the structure within. This is how a façade pattern is used. Façade hides the
    complexities of the internal system and provides an interface to the client that
    can access the system in a very simplified way.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the example of a storekeeper. Now, when you, as a customer, visit a
    store to buy certain items, you're not aware of the layout of the store. You typically
    approach the storekeeper, who is well aware of the store system. Based on your
    requirements, the storekeeper picks up items and hands them over to you. Isn't
    this easy? The customer need not know how the store looks and s/he gets the stuff
    done through a simple interface, the storekeeper.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Façade design pattern essentially does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It provides a unified interface to a set of interfaces in a subsystem and defines
    a high-level interface that helps the client use the subsystem in an easy way.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Façade discusses representing a complex subsystem with a single interface object.
    It doesn't **encapsulate** the subsystem but actually combines the underlying
    subsystems.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It promotes the decoupling of the implementation with multiple clients.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A UML class diagram
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will now discuss the Façade pattern with the help of the following UML diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A UML class diagram](img/00015.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'As we observe the UML diagram, you''ll realize that there are three main participants
    in this pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Façade**: The main responsibility of a façade is to wrap up a complex group
    of subsystems so that it can provide a pleasing look to the outside world.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**System**: This represents a set of varied subsystems that make the whole
    system compound and difficult to view or work with.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Client**: The client interacts with the Façade so that it can easily communicate
    with the subsystem and get the work completed. It doesn''t have to bother about
    the complex nature of the system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will now learn a little more about the three main participants from the
    data structure's perspective.
  prefs: []
  type: TYPE_NORMAL
- en: Façade
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following points will give us a better idea of Façade:'
  prefs: []
  type: TYPE_NORMAL
- en: It is an interface that knows which subsystems are responsible for a request
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It delegates the client's requests to the appropriate subsystem objects using
    composition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, if the client is looking for some work to be accomplished, it need
    not have to go to individual subsystems but can simply contact the interface (Façade)
    that gets the work done.
  prefs: []
  type: TYPE_NORMAL
- en: System
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the Façade world, System is an entity that performs the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It implements subsystem functionality and is represented by a class. Ideally,
    a System is represented by a group of classes that are responsible for different
    operations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It handles the work assigned by the Façade object but has no knowledge of the
    façade and keeps no reference to it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For instance, when the client requests the Façade for a certain service, Façade
    chooses the right subsystem that delivers the service based on the type of service.
  prefs: []
  type: TYPE_NORMAL
- en: Client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here''s how we can describe the client:'
  prefs: []
  type: TYPE_NORMAL
- en: The client is a class that instantiates the Façade
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It makes requests to the Façade to get the work done from the subsystems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the Façade pattern in the real world
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To demonstrate the applications of the Façade pattern, let's take an example
    that we'd have experienced in our lifetime.
  prefs: []
  type: TYPE_NORMAL
- en: Consider that you have a marriage in your family and you are in charge of all
    the arrangements. Whoa! That's a tough job on your hands. You have to book a hotel
    or place for marriage, talk to a caterer for food arrangements, organize a florist
    for all the decorations, and finally handle the musical arrangements expected
    for the event.
  prefs: []
  type: TYPE_NORMAL
- en: In yesteryears, you'd have done all this by yourself, for example by talking
    to the relevant folks, coordinating with them, negotiating on the pricing, but
    now life is simpler. You go and talk to an event manager who handles this for
    you. S/he will make sure that they talk to the individual service providers and
    get the best deal for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Putting it in the Façade pattern perspective:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Client**: It''s you who need all the marriage preparations to be completed
    in time before the wedding. They should be top class and guests should love the
    celebrations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Façade**: The event manager who''s responsible for talking to all the folks
    that need to work on specific arrangements such as food, and flower decorations,
    among others'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Subsystems**: They represent the systems that provide services such as catering,
    hotel management, and flower decorations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's develop an application in Python v3.5 and implement this use case. We
    start with the client first. It's you! Remember, you're the one who has been given
    the responsibility to make sure that the marriage preparations are done and the
    event goes fine!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now move ahead and talk about the Façade class. As discussed earlier,
    the Façade class simplifies the interface for the client. In this case, `EventManager`
    acts as a façade and simplifies the work for `You`. Façade talks to the subsystems
    and does all the booking and preparations for the marriage on your behalf. Here
    is the Python code for the `EventManager` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we''re done with the Façade and client, let''s dive into the subsystems.
    We have developed the following classes for this scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Hotelier` is for the hotel bookings. It has a method to check whether the
    hotel is free on that day (`__isAvailable`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Florist` class is responsible for flower decorations. Florist has the `setFlowerRequirements()`
    method to be used to set the expectations on the kind of flowers needed for the
    marriage decoration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Caterer` class is used to deal with the caterer and is responsible for
    the food arrangements. Caterer exposes the `setCuisine()` method to accept the
    type of cuisine to be served at the marriage.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Musician` class is designed for musical arrangements at the marriage. It
    uses the `setMusicType()` method to understand the music requirements for the
    event.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let us now look at the `Hotelier` object, followed by `Florist` object and
    their methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: However, you're being clever here and passing on the responsibility to the event
    manager, aren't you? Let's now look at the `You` class. In this example, you create
    an object of the `EventManager` class so that the manager can work with the relevant
    folks on marriage preparations while you relax.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is given here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing the Façade pattern in the real world](img/00016.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can relate to the Facade pattern with the real world scenario, in the following
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: The `EventManager` class is the Façade that simplifies the interface for `You`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EventManager` uses composition to create objects of the subsystems such as
    `Hotelier`, `Caterer`, and others'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The principle of least knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you have learned in the initial parts of the chapter, the Façade provides
    a unified system that makes subsystems easy to use. It also decouples the client
    from the subsystem of components. The design principle that is employed behind
    the Façade pattern is the **principle of least knowledge**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The principle of least knowledge guides us to reduce the interactions between
    objects to just a few *friends* that are close enough to you. In real terms, it
    means the following:'
  prefs: []
  type: TYPE_NORMAL
- en: When designing a system, for every object created, one should look at the number
    of classes that it interacts with and the way in which the interaction happens.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Following the principle, make sure that we avoid situations where there are
    many classes created that are tightly coupled to each other.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there are a lot of dependencies between classes, the system becomes hard
    to maintain. Any changes in one part of the system can lead to unintentional changes
    to other parts of the system, which means that the system is exposed to regressions
    and this should be avoided.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Frequently asked questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Q1\. What is the Law of Demeter and how is it related to the Factory pattern?
  prefs: []
  type: TYPE_NORMAL
- en: 'A: The Law of Demeter is a design guideline that talks about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Each unit should have only limited knowledge of other units in the system
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A unit should talk to its friends only
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A unit should not know about the internal details of the object that it manipulates
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The principle of least knowledge and Law of Demeter are the same and both point
    to the philosophy of *loose coupling*. The principle of least knowledge fits the
    use case of the Façade pattern as the name is intuitive and the word principle
    acts as a guideline, not being strict, and being useful only when needed.
  prefs: []
  type: TYPE_NORMAL
- en: Q2\. Can there be multiple Façades for a subsystem?
  prefs: []
  type: TYPE_NORMAL
- en: 'A: Yes, one could implement more than one façade for a group of subsystem components.'
  prefs: []
  type: TYPE_NORMAL
- en: Q3\. What are the disadvantages of the principle of least knowledge?
  prefs: []
  type: TYPE_NORMAL
- en: 'A: A Façade provides a simplified interface for the clients to interact with
    subsystems. In the spirit of providing a simplified interface, an application
    can have multiple unnecessary interfaces that add to the complexity of the system
    and reduce runtime performance.'
  prefs: []
  type: TYPE_NORMAL
- en: Q4\. Can the client access the subsystems independently?
  prefs: []
  type: TYPE_NORMAL
- en: 'A: Yes, in fact, the Façade pattern provides simplified interfaces so that
    the client need not be bothered about the complexity of the subsystems.'
  prefs: []
  type: TYPE_NORMAL
- en: Q5\. Does the Façade add any functionality of its own?
  prefs: []
  type: TYPE_NORMAL
- en: 'A: A Façade can add its "thinking" to the subsystems, such as making sure that
    the order of innovation for subsystems can be decided by the Façade.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We began the chapter by first understanding the Structural design patterns.
    You then learned about the Façade design pattern and the context in which it's
    used. We understood the basis of Façade and how it is effectively used in software
    architecture. We looked at how Façade design patterns create a simplified interface
    for clients to use. They simplify the complexity of subsystems so that the client
    benefits.
  prefs: []
  type: TYPE_NORMAL
- en: The Façade doesn't encapsulate the subsystem, and the client is free to access
    the subsystems even without going through the Façade. You also learned the pattern
    with a UML diagram and sample code implementation in Python v3.5\. We understood
    the principle of least knowledge and how its philosophy governs the Façade design
    patterns.
  prefs: []
  type: TYPE_NORMAL
- en: We also covered a section on FAQs that would help you get more ideas on the
    pattern and its possible disadvantages. We're now geared up to learn more Structural
    patterns in the chapters to come.
  prefs: []
  type: TYPE_NORMAL
