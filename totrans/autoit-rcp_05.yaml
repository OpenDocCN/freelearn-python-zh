- en: Chapter 5. Fun with E-mails
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: E-mail communication has become a primary mode of information exchange over
    last couple of decades. You work with e-mails on a daily basis and for multiple
     reasons. But did it ever strike that you could manipulate your inbox with Python?
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Sending e-mail messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: E-mail encryption
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Beautifying e-mail messages with MIME messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: E-mail messages with attachments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting to your inbox
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fetching and reading e-mail messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Marking e-mail messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clearing up e-mail messages from your inbox
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automating customer support flows with e-mail responses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hello, folks! Hope you're having a great day. In this chapter, we will talk
    about e-mails and the numerous operations we can achieve with e-mails using Python.
    We will also understand ways of automating business processes with e-mails with
    the help of real world business use case.
  prefs: []
  type: TYPE_NORMAL
- en: So, what are we waiting for? Let's get started and understand a bit about the
    history of e-mails and its technical implementation.
  prefs: []
  type: TYPE_NORMAL
- en: E-mails don't need any introduction actually; of course, they're a method of
    exchanging digital messages between computer users. E-mails operate on computer
    networks available over Internet for information exchange. You can log in to your
    favorite e-mail client and start working on your messages stored in the e-mail
    servers. The most widely used web client is Gmail.
  prefs: []
  type: TYPE_NORMAL
- en: E-mails have a very interesting history. In the past, e-mails needed the sender
    and the recipient to be online for the communication to succeed. That didn't make
    much sense, right? Gradually with time, e-mail servers became intelligent and
    started to work on a store-and-forward philosophy. Today, e-mail messages are
    stored asynchronously on the servers so that recipients can view them later at
    their convenience. E-mail servers are thus able to provide facilities such as
    accepting, forwarding, and marking messages.
  prefs: []
  type: TYPE_NORMAL
- en: E-mail messages started with ASCII-only characters, which were later extended
    by **Multipurpose Internet Mail Extensions** (**MIME**) for rich text and attachments.
    From a protocols standpoint, e-mails initially worked with the **File Transfer
    Protocol** (**FTP**) to send messages across computers, but as you might be aware,
    **Simple Mail Transfer Protocol** (**SMTP**) is the most widely used protocol
    for working with e-mails.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Please note that setting up of e-mail servers is not covered in this book. If
    you look on the Internet, you'll find many more resources that can help you get
    started. The scope of this chapter is to make you aware of things you can do with
    e-mail using Python programs. We take examples that apply to the Gmail web client
    so that you can try out code examples quickly and get to appreciate the power
    of using Python to automate e-mail tasks without having to set up your own e-mail
    server. While we use Gmail as an example, these snippets will work with any other
    e-mail servers that support SMTP for sending e-mails and IMAP for retrieving e-mails.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll learn how to work with e-mails using Python. We''ll
    also use multiple Python modules, listed below, to perform various operations
    on e-mail messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '`smtplib` ([https://docs.python.org/2/library/smtplib.html](https://docs.python.org/2/library/smtplib.html))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`email` ([https://docs.python.org/2/library/email.html](https://docs.python.org/2/library/email.html))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`imaplib` ([https://docs.python.org/2/library/imaplib.html](https://docs.python.org/2/library/imaplib.html))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gmail` ([https://github.com/charlierguo/gmail](https://github.com/charlierguo/gmail))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When it comes to working with e-mails using Python , what you need is a module
    that helps you construct messages, a module that can send e-mails, and a module
    that helps retrieve and update messages.
  prefs: []
  type: TYPE_NORMAL
- en: Sending e-mail messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first and foremost thing that you may want to achieve with an e-mail client
    is to send a message to your friend's or colleague's e-mail address. Let's go
    ahead and see how we can achieve this in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to send e-mail messages, we will need to have Python''s `smtplib`
    module. This library, as the name suggests, uses the SMTP protocol to send e-mail
    messages. We can install `smtplib` with our favorite `pip` tool with the following
    command. But Python''s default installation should also have this module already:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'On your computer, open your favorite editor and add the following code snippet.
    Let this be known as `config.py`. The configuration file has login details, such
    as e-mail address, password, and the e-mail address to which the e-mail needs
    to be sent:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let''s write the code to send an e-mail using this configuration file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Store the preceding code as `basic_email.py`, and run the code using the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you run the preceding code, you'll see exceptions with `SMTPAuthenticationError`,
    and your program will fail with exit code  `1`. This is how your exception will
    look like:![How to do it...](img/image_06_001.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Okay, that's bad, but on the contrary, it's good as well! Exception suggests
    that the login to the server was fine, but Gmail blocked you from sending the
    message. Now, if you log in to Gmail, you should see an e-mail suggesting there
    was a signup detected from a less secure app. Really?! Yes, that's because we
    tried to access the Gmail account from our Python program. This is why we get
    an e-mail from Google suggesting a possible security breach in case there was
    a malicious activity on our account. The e-mail message from Google can be viewed
    in the following screenshot:![How to do it...](img/image_06_002.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: But obviously, this was a legitimate attempt to use the Gmail account, so let's
    confirm that to Google. Open the e-mail message from Google and click on **ALLOW
    ACCESS.** You'll be taken to the **Less secure apps** page where you can turn
    this setting on, as shown in the following screenshot:![How to do it...](img/image_06_003.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, log out of the Gmail web client and log in again to let the settings take
    effect on your account. If this went through fine, you will receive an e-mail
    from Google that the **Access for less secure apps is turned on.** The confirmation
    e-mail from Google will look similar to this screenshot:![How to do it...](img/image_06_004.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, if you run the Python program again, it should run successfully and you
    will receive an e-mail in your inbox:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_06_005.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Cool! Notice, the message contents are the same as we added in our code snippet.
    Also, since the *from* and *to* addresses were the same, the e-mail came from
    you, but it doesn't have any subject, which is not great. We will do something
    about this in the next recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As stated earlier, SMTP is used to send e-mail messages. We use Python module,
    `smtplib`, for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: If you look at the preceding code snippet, we use the constructor, `smtplib.SMTP()`
    to configure Gmail's SMTP settings and get access to the e-mail server. Gmail's
    SMTP server runs on `smtp.gmail.com` and on port 587.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have the server object, `server`, we use this to log in to Gmail with
    our username and password. Note that we have another line in the preceding code:
    `server.starttls()`; we will come to this later in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: We have created a test message and stored it in the variable `msg`, which is
    then sent using the `sendmail` method `('fromaddr', 'toddr', msg)`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we close the connection to the e-mail server with `server.quit()`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We looked at how to sign in to Gmail and send a basic e-mail using the SMTP
    protocol and Python's `smptlib` library. While this recipe gets us started, there
    are more details that we'll delve into in the next recipe. Let's look at them.
  prefs: []
  type: TYPE_NORMAL
- en: E-mail encryption
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: E-mail is prone to disclosure of information. Most e-mails are currently transmitted
    in clear text format. E-mail encryption involves encrypting or disguising content
    of the e-mail so that the content is read by the intended recipients. Always remember
    that security is of prime importance when dealing with e-mails. Let's see how
    we can encrypt e-mails with Python.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We looked at sending a basic e-mail in the previous recipe, but what's the `starttls()`
    method? How does e-mail encryption work? We will get answers to these questions
    in this section.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start by opening our favorite editor and typing in the following code
    snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, let's run the Python code and see what it prints. We have outputs in three
    different segments. The first one is when we send an `ehlo()` message to our e-mail
    server:![How to do it...](img/image_06_006.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second one is when we call `starttls()` method on the server object. Check
    out the following screenshot:![How to do it...](img/image_06_007.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The third one is when we connect to the e-mail server with `ehlo()` again:![How
    to do it...](img/image_06_008.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's start with the basics. E-mail encryption means protecting e-mail messages
    from being read by someone other than the intended parties. E-mails are typically
    sent in clear text and can be sniffed by third parties. To avoid this, we encrypt
    e-mails at the protocol layer; this may include authentication as well.
  prefs: []
  type: TYPE_NORMAL
- en: SMTP servers typically send e-mails on port 25 using SSL/TLS protocols. However,
    with the advent of STARTTLS (layer on top of SMTP) and the usage of port 587 for
    message submissions, e-mail clients like Gmail use STARTTLS and port 587 for sending
    e-mails. Gmail also has authentication implemented; remember that we used `server.login
    (username, password)` to login to the Gmail server.
  prefs: []
  type: TYPE_NORMAL
- en: For STARTTLS to be used across the server and client, the client needs to first
    know if the server supports this protocol. When we issue `server.ehlo()`, the
    program sends an `EHLO` message to the SMTP server to establish communication.
    The server responds with the message and allowed extensions, as observed in the
    first screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: Now, from the code, we check whether the server supports the `STARTTLS` extension
    with `server.has_extn('STARTTLS')`. As we saw in the first screenshot, the SMTP
    server responded with the `STARTTLS` extension; this confirms that gmail supports
    the `STARTTLS` protocol layer, which is awesome.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we communicate with the server using `server.starttls()`. The server responds
    to this by sending a message, `Ready to start TLS`. This way, we have encrypted
    our session. If you now look at the third screenshot, when we send `server.ehlo()`,
    we re-identify ourselves with the server over the TLS session. It also suggests
    that the server implements an authentication extension.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we quit our SMTP session using `server.quit()` and the server responds
    with `closing connection`, as shown in the third screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Well, that was pretty detailed. Take a few moments to understand it. It's actually
    interesting what goes on behind the sending of a simple e-mail message. But don't
    worry about it too much; let's start the fun and get into many more examples.
  prefs: []
  type: TYPE_NORMAL
- en: Beautifying e-mail messages with MIME
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the first few recipes, we sent e-mail messages in a simple plain old text
    format. The MIME Internet standard helps us construct messages with non-ASCII
    characters, multipart messages and images. It also helps with attachments and
    many other tasks. This way, we can construct enriched e-mail messages. Let's look
    at how the MIME format is used in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we will use the same module, `smtplib`, to send e-mail messages.
    We will also introduce another module `email`, which will help us construct better
    e-mail messages with the MIME format. The `email` module comes in with Python
    installation; hence, we don't need any new modules or installations to be carried
    out. In this section, we will look at how to use the MIME attributes to send better
    looking e-mails.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start by importing all of the modules we need:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let''s construct our e-mail message using the MIME module. The following
    code creates the message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'So, now we have the details of whom to send the e-mail message to. We have
    also constructed the e-mail message in the MIME format. What are we waiting for?
    Let''s send it using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The received e-mail looks as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/B05370_07_09.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Awesome! That's great, but hey... how did it work?
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the preceding example, we imported the configuration file from where we got
    `fromaddress` and `password` to log in to the SMTP server and `toaddress` to whom
    the e-mail message will be sent.
  prefs: []
  type: TYPE_NORMAL
- en: Now, before sending the message, we construct a new MIME message object. We
    do that with `MIMEMultipart()` class from the `email.mime.multipart` module of
    Python. For those who are not aware, a MIME multipart message means both HTML
    and text content in a single e-mail. So, in this code, we create a new multipart
    MIME message and then add the text content to it.
  prefs: []
  type: TYPE_NORMAL
- en: The text content, which is the body of the e-mail, is created with the `MIMEText()`
    constructor from the `email.mime.text` module and is then attached to the multipart
    message with the `attach()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The constructed MIME message is seen in the following screenshot, where the
    content-type is multipart and the MIME Version is 1.0, the **Subject**, **To**,
    and **From** details are as expected, and the e-mail body contains the expected
    text:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/B05370_07_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Once we have the message and the recipient details, we send the e-mail as usual,
    using the `SMTP.sendmail()` method.
  prefs: []
  type: TYPE_NORMAL
- en: E-mail messages with attachments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most used and simple use cases with e-mail is the ability to add attachments
    to your e-mail messages. In this section, we will learn how to add attachments
    to our e-mails in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We use the same `smtplib` and `email` modules for this example. So, don't bother
    about the modules to be installed. Let's get on with the recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's begin by quickly creating a small text file. We will call it `attach.txt`,
    and its contents are shown in the following screenshot:![How to do it...](img/image_06_011.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s look at the code that will help add an attachment to our e-mail:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When you run the preceding code, you will receive the e-mail in your inbox,
    which will look similar to the following screenshot:![How to do it...](img/image_06_012.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We're already familiar with creating MIME message objects. So, in this code,
    we create a multipart message object, `msg`. We then add a text message to it
    with `msg.attach()`. The text body says `Click to open the attachment`.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we use another new class, `MIMEBase` from the `email` module
    that will be used to attach the text file. Remember, we already have the `attach.txt`
    file created, we open the file using Python's `open()` method and get the file
    handle `attachment`. We then create a `MIMEBase` object, `part`, and assign the
    contents of the file as payload to this object. The contents of the file are obtained
    with `attachment.read()` and the payload is set with the `set_payload()` method.
  prefs: []
  type: TYPE_NORMAL
- en: To attach the file, the `MIMEBase` object has to be encoded to base64 and the
    `Content-Disposition` header needs to be added to the `part` object. Now that
    we have the `part` object, it can be attached to the multipart object, `msg`,
    with the `attach()` method, as we did for the body text.
  prefs: []
  type: TYPE_NORMAL
- en: Cool, so we have the complete MIME message and the details of whom to send the
    message to. So, we go ahead and send the e-mail with the attachment. Just what
    we intended to achieve.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to your inbox
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout the chapter, we have been talking about sending e-mails with Python.
    However, at some point, you might also want to scan through your inbox and read
    the incoming messages. So, how do you do that? Let's understand and learn it in
    this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we use a new Python module that will help us retrieve messages
    from the inbox. We use the Python module, `imaplib`, which is available in the
    default Python installation. Cool, so let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We start by using the configuration file, which we have already created to
    store our e-mail and password, to log in to the server. We then add our code to
    create a handle or an object to work with our inbox. This is how the code looks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you run the preceding piece of code, you will get the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_06_013.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'By default, when we login to Gmail, default inbox gets selected, but if we
    have created other inboxes as well, we can get the list by adding a small line
    of code. Now, from all the labels, if we specifically want to select `Inbox`,
    even that can be achieved. Look at the following code example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output of the preceding code snippet is shown in the following screenshot.
    Though I have many labels created, I have taken a screenshot with fewer labels:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_06_014.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As discussed in the beginning of this chapter, we have three main protocols
    to work with e-mails. We used SMTP heavily for sending e-mails, but while reading
    e-mails, we can use either POP or IMAP to retrieve messages from the e-mail server.
    We will go through the code step by step.
  prefs: []
  type: TYPE_NORMAL
- en: Python's `imaplib` library helps us connect to our mailbox using the **Internet
    Message Access Protocol** (**IMAP**). The Gmail server is configured to IMAP,
    with the server running on `imap.gmail.com` and on port '993'.
  prefs: []
  type: TYPE_NORMAL
- en: In our code example, we create an object of type `imaplib` with the constructor
    `IMAP4_SSL("imap.gmail.com", 993)`; we call this object `M`.
  prefs: []
  type: TYPE_NORMAL
- en: Regarding the encryption, we use `IMAP4_SSL` for connecting to the server because
    it uses encrypted communications over SSL sockets. We avoid the usage of `IMAP4`
    class, which internally uses clear text sockets.
  prefs: []
  type: TYPE_NORMAL
- en: Now, with object `M`, we can log in to Gmail with our username and password
    and get connected to our inbox.
  prefs: []
  type: TYPE_NORMAL
- en: When we call the `list()` method on object `M`, it returns all the labels you
    have already created. Now, in my case, I have created the `ACM` label (for my
    work with ACM), and hence it shows up in my list of labels.
  prefs: []
  type: TYPE_NORMAL
- en: If you look at the code example, we can explicitly connect to the `INBOX` using
    the `select()` method. Once connected to the inbox, we can start fetching the
    e-mail messages from the inbox.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we close our connection with the inbox using the `M.logout()` method.
    Cool! That was nice and easy.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So, we learnt how to connect to our inbox in this recipe, but we may also want
    to read the messages, mark them, and perform interesting actions on them. Let's
    look at how to perform operations on the messages in the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching and reading e-mail messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Retrieving e-mail messages with `imaplib` is also easy to achieve. In this recipe,
    we will learn how to do that with Python code. In this recipe, we will search
    for e-mails with a particular subject line and fetch the latest message from the
    inbox that matches a predefined criteria.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We continue to use the `imaplib` module for reading e-mail messages, so no new
    installations are required for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We utilize the configuration file and import `fromaddress`, `password`, and
    `toaddress` to log in to the server. Once we''re logged in, we select the default
    inbox, fetch e-mail messages, and read them. Let''s look at the complete code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Store the preceding file as `inbox_search.py` and run the code using the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The output of the preceding code snippet is shown in the following screenshot:![How
    to do it...](img/image_06_015.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the preceding code snippet, we first create an object of `IMAP_SSL4()` with
    the appropriate IMAP settings. We then log in to the client using the credentials
    from the configuration file with the help of the IMAP object. We then select our
    `INBOX` so that we can perform search operations on it.
  prefs: []
  type: TYPE_NORMAL
- en: The `M.search()` method called on the IMAP object helps us search for e-mails
    with the subject *Email with an attachment*. The `search()` method returns an
    array of messages that match the criteria we searched for.
  prefs: []
  type: TYPE_NORMAL
- en: Now, if we have to get to a particular message, and since we have to read the
    latest e-mail message that matched our criteria, we use the `M.fetch()` method.
    The `fetch()` method requires a given message object and the part of the message
    that you want to fetch. So, in this code example, we pass the latest e-mail object
    that matches the criteria and pass `RFC822`, which suggests that we want the e-mail
    body in the RFC 822 format.
  prefs: []
  type: TYPE_NORMAL
- en: When we print the message obtained from `fetch()`, we get the contents of the
    e-mail body for the latest e-mail that matched the search.
  prefs: []
  type: TYPE_NORMAL
- en: Now, do you remember seeing the contents of the e-mail? Well, it's the same
    e-mail message we had sent in one of our earlier recipes, which was used for demonstrating
    the e-mail attachment.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Good! So, now we can search for a message and fetch it too. There are many more
    granular operations such as marking messages that we'd like to perform on our
    inbox. Let's look at them in the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Marking e-mail messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we looked at fetching and reading messages. Wasn't it
    too complicated? Do we have to take care of so many details while doing a simple
    operation like search or read? In this section, let's look at another library
    that can help us not only to search or read better, but also to perform various
    operations on our e-mails.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this section, we will install the `gmail` module. You can install this
    module through your Terminal using the `pip` command, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at how to search for e-mails and read them using `gmail` APIs.
    This will get us started with the `gmail` module. The following code snippet searches
    for e-mails that were received after July 22, 2016\. We then take the latest message
    and fetch it. Once we have the message fetched, we just go ahead and read the
    body of the e-mail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The output of the preceding code is shown in the following screenshot. Looks
    like I may have received an e-mail digest from Quora!
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/image_06_016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here''s a screenshot from my inbox:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/Chapter5-Page-21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Wasn't that too easy? Incidentally, the `gmail` module is written on top of
    `imaplib` but has better APIs, so let's take advantage of this module and do some
    fantastic operations.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s open the inbox and look for an unread message that matches a certain
    criteria and mark the message as read. The following code easily does this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Before running this program, I had one e-mail in my inbox from [https://glassdoor.com](https://glassdoor.com) that
    I hadn''t read. It looked like this in my inbox:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_06_017.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'After running the code snippet, it identified this e-mail as matching my criteria
    of unread messages from `noreply@glassdoor.com` and marked my message as read.
    So, now it looks like this in my inbox. Gmail un-bolds the read messages and that''s
    what happened in my inbox:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_06_018.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Nice!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Let's look at another example. I have been receiving so many promotional e-mails
    from Amazon Now from Jan 2016\. This is how my mailbox looks:![How to do it...](img/image_06_019.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, I want to mark them all as `read` and assign them under one label, `AMAZON`.
    How can I do it? The following code does this operation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After running this code, a new label will appear in your inbox with the name, `AMAZON`.
    Now, if you search your inbox for all e-mails with the label `AMAZON`, you'll
    see that all these e-mail messages have been marked as read. Look at the following
    screenshot where I search for e-mails with the label `AMAZON`:![How to do it...](img/image_06_020.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the first step, we created an object, `g` by logging into the Gmail server.
    Note that we didn't pass any parameters like IMAP settings or port to create the
    object. The `gmail` module internally handles this.
  prefs: []
  type: TYPE_NORMAL
- en: Now, using this object, we start searching our inbox for e-mails that are *unread*
    and sent by `noreply@glassdoor.in`', and all the mail objects matching this criteria
    are stored in *mails*.
  prefs: []
  type: TYPE_NORMAL
- en: Later, we fetch the latest record with the `fetch()` method and mark this mail
    as read with the `read()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, in the second recipe, we iterate through all the e-mail messages
    that are *unread*, sent by `store-news@amazon.in`, and that were sent to me this
    year.
  prefs: []
  type: TYPE_NORMAL
- en: Each mail is then marked as read with the `read()` method and added to the label,
    `AMAZON`. Works like a breeze, awesome!
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We looked at some of the operations that we can perform on our e-mail messages.
    There are many more. With the `gmail` module, you can mark messages as unread
    or even make them important with a star. Let's look at an example with which we
    can clear up our inbox.
  prefs: []
  type: TYPE_NORMAL
- en: Clearing up e-mail messages from your inbox
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Last but not least, this recipe will take you through the steps with which you
    can delete e-mail messages from your inbox. As you'd expect, it's pretty straightforward
    to delete your e-mails programmatically.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Even if you delete the messages from your e-mail client, the e-mail server can
    still choose to store them. So, when you delete your messages, you're merely marking
    them to be hidden from your inbox while they can continue to stay on your e-mail
    server, based on the server implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We continue to use the `imaplib` module for deleting e-mail messages, so no
    new installations are required for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's utilize the configuration file and import the `fromaddress`, `password`,
    and `toaddress` to log in to the server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This is how the complete code looks like:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Store the preceding file as `inbox_delete.py` and run the code using the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Similar to what we saw in the previous examples, we first log in to Gmail with
    our login credentials from the configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: We then connect to our inbox and search for e-mails coming from `junk@xyz.com`.
    If we find any e-mails that match this criteria, we want to delete them.
  prefs: []
  type: TYPE_NORMAL
- en: So, we loop over the mail objects and perform the `delete()` operation on them,
    and that's it! Our inbox is now free from all messages that we deem as junk. :)
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Excellent! So, now we know how to send e-mail messages, add attachments, and
    fetch and read them. We also learnt how to mark our message as read, add appropriate
    labels, and delete these messages if needed. Armed with this knowledge, can we
    do something for Kelly who has a few problems?
  prefs: []
  type: TYPE_NORMAL
- en: Automating customer support flows with with e-mail responses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kelly, Director of Customer Support, has a problem at hand. Most of her support
    engineers end up responding to Level 1 support requests where customers are looking
    for information that is already available on the website. Customers just end up
    sending e-mails to support without trying to search for themselves.
  prefs: []
  type: TYPE_NORMAL
- en: This sequence of events is non-productive for the customer and support engineers.
    Customers simply wait for information instead of getting it on the website directly,
    and support engineers manually send a pointer to the **Frequently Asked Questions**
    (**FAQ**) section from the website to the customers. Kelly sees it as an opportunity
    to improve and wants to reduce the time spent on support by automating this flow. Can
    we do something to help her?
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Of course, this is a bigger problem to solve but at the very least, we can do
    something that will help automate the flow. Whenever the support team receives
    a new ticket via e-mail, we can auto respond to the ticket acknowledging the receipt
    of the ticket and also send the link to the FAQ section from the company's website.
    This way, the customers can browse and look up the information they need from
    the FAQ section. It also reduces the load on support engineers as the auto-response
    e-mail would have already resolved the customer query and that too in a quick
    time.
  prefs: []
  type: TYPE_NORMAL
- en: So now, what do we actually need? We need to monitor our support inbox, look
    at any new customer queries, and then auto-respond with our template e-mail.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s directly jump to our solution. Create a Python file and copy the following code
    snippet into it. It does exactly what we need to automate the support flow:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the preceding code with Python, and you will observe that the program is
    still running. It is actually waiting for new e-mails, in this context, the customer
    requests for the support engineers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you now send an e-mail to customer support, you will receive an auto reply
    from our Python program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: In this case the support inbox is my e-mail address, but you can easily set
    up an e-mail account for your company so that the customer requests are directed
    to this account.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This is how the auto response e-mail looks:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_06_021.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We start with a `while` loop that runs every one min (60 seconds). Every iteration
    reads the support inbox and searches for unread e-mails.
  prefs: []
  type: TYPE_NORMAL
- en: If the `while` loop finds any unread e-mail, it will fetch the e-mail and get
    the `fr` attribute. The `fr` attribute gets you the `from` field of the e-mail
    message. The `from` field is the e-mail address of the customer asking for information
    from the support engineer.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have the customer's e-mail address, we send an automated response to
    the customer from our inbox. The preceding screenshot shows exactly what the auto
    response looks like. Cool, so now when the customers asks a question to the customer
    support engineer by sending an e-mail, they will get an automated e-mail response
    with the link to the Frequently Asked Questions section.
  prefs: []
  type: TYPE_NORMAL
- en: This way, the customer gets the required information quickly from the FAQ link.
    Also, the load on the support engineers is reduced, as they don't have to respond
    to the mundane support requests manually.
  prefs: []
  type: TYPE_NORMAL
- en: I'm sure Kelly feels happy about this improvement. She understands that the
    customer support flow is automated to a certain extent and hopes to see productivity
    gains soon!
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Awesome! There are many other things that you can do with e-mails. Tried downloading
    e-mail attachments? Want to give it a shot? We'll let you try that for yourself.
    See you in the next chapter!
  prefs: []
  type: TYPE_NORMAL
