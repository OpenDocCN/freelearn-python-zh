- en: Chapter 6. Using Python to Drive Hardware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Controlling an LED
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Responding to a button
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A controlled shutdown button
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The GPIO keypad input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiplexed color LEDs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing messages using Persistence of Vision
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the key features of a Raspberry Pi computer that sets it apart from most
    other home/office computers is that it has the ability to directly interface with
    other hardware. The hardware **General Purpose Input/Output** (**GPIO**) pins
    on the Raspberry Pi can control a wide range of low-level electronics, from **Light
    Emitting Diodes** (**LEDs**) to switches, sensors, motors, servos, and even extra
    displays.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will focus on connecting the Raspberry Pi with some simple circuits
    and getting to grips with using Python to control and respond to the connected
    components.
  prefs: []
  type: TYPE_NORMAL
- en: The Raspberry Pi hardware interface consists of 40 pins located along one side
    of the board.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The GPIO pins and their layout will vary slightly according to the particular
    model you have.
  prefs: []
  type: TYPE_NORMAL
- en: The Raspberry Pi 2 and the Raspberry Pi 1 Model A Plus and B Plus all have the
    same 40-pin layout.
  prefs: []
  type: TYPE_NORMAL
- en: The older Raspberry Pi 1 models (non-plus types) have a 26-pin header, which
    is the same as the 1-26 pins of the newer models.
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction](img/6623OT_06_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Raspberry Pi 2 and Raspberry Pi Model Plus GPIO header pins (pin functions)
  prefs: []
  type: TYPE_NORMAL
- en: The layout of the connector is shown in the previous diagram; the pin numbers
    are shown as seen from pin 1 of the GPIO header.
  prefs: []
  type: TYPE_NORMAL
- en: '**Pin 1** is at the end that is nearest to the SD card, as shown in the following
    image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction](img/6623OT_06_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Raspberry Pi GPIO header location
  prefs: []
  type: TYPE_NORMAL
- en: Care should be taken when using the GPIO header, since it also includes power
    pins (3V3 and 5V) as well as ground pins (GND). All of the GPIO pins can be used
    as standard GPIO, but several also have special functions; these are labeled and
    highlighted with different colors.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is common for engineers to use a 3V3 notation to specify values in schematics
    to avoid using decimal places that could easily be missed (using 33V rather than
    3.3V would cause severe damage). The same can applied to other values such as
    resistors, so for example, 1.2k ohms can be written as 1k2 ohms.
  prefs: []
  type: TYPE_NORMAL
- en: There are **TX** and **RX** pins that are used for serial RS232 communications,
    and with the aid of a voltage level convertor, information can be transferred
    via a serial cable to another computer or device.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have **SDA** and **SCL** pins that are able to support a two-wire bus communication
    protocol called **I²C** (on Model Plus and Raspberry Pi 2 boards there are two
    I²C channels: **channel 1 ARM** is for general use while **channel 0 VC** is typically
    used for identifying Hardware Attached on Top (HAT) modules). There are also the
    **SPI MOSI**, **SPI MISO**, **SPI SCLK**, **SPI CE0**, and **SPI CE1** pins, which
    support another type of bus protocol called **SPI** for high-speed data. Finally,
    we have **PWM0/1**, which allows a **pulse width modulation** signal to be generated,
    which is useful for servos and generating analog signals.'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we will focus on using just the standard GPIO functions in this chapter.
    The GPIO pin layout is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction](img/6623OT_06_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Raspberry Pi GPIO header pins (GPIO.BOARD and GPIO.BCM)
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Raspberry Pi Rev 2 (pre-July 2014) has the following differences to the
    Raspberry Pi 2 GPIO layout:'
  prefs: []
  type: TYPE_NORMAL
- en: 26 GPIO pins header (matching the first 26 pins)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An additional secondary set of eight holes (P5) located next to the pin header.
    The details are as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Introduction](img/6623OT_06_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Raspberry Pi Rev 2 P5 GPIO header pins
  prefs: []
  type: TYPE_NORMAL
- en: 'The original Raspberry Pi Rev 1 (pre-Oct 2012) has only 26 GPIO pins in total
    (matching the first 26 pins of the current Raspberry Pi, except for the following
    details):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction](img/6623OT_06_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Raspberry Pi Rev 1 GPIO header differencesThe **RPi.GPIO** library can reference
    the pins on the Raspberry Pi using one of two systems. The numbers shown in the
    center are the physical position of the pins and are also the numbers referenced
    by RPi.GPIO when in the **GPIO.BOARD** mode. The numbers on the outside (**GPIO.BCM**)
    are the actual references for the physical ports of the processor to which the
    pins are wired (which is why they are not in any specific order). They are used
    when the mode is set to **GPIO.BCM** and allow control of the GPIO header pins
    and also any peripherals connected to other GPIO lines. This includes the LED
    on the add-on camera on BCM GPIO 4 and the status LED on the board. However, this
    can also include the GPIO lines used for reading/writing to the SD card, which
    would cause serious errors if interfered with.
  prefs: []
  type: TYPE_NORMAL
- en: If you use other programming languages to access the GPIO pins, the numbering
    scheme may be different, so it will be helpful if you are aware of the BCM GPIO
    references, which refer to the physical GPIO port of the processor.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Be sure to check out the [Appendix](apa.html "Appendix A. Hardware and Software
    List"), *Hardware and Software List*, which lists all the items used in this chapter
    and the places you can obtain them from.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling an LED
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The hardware equivalent of `hello world` is an LED flash, which is a great test
    to ensure that everything is working and that you have wired it correctly. To
    make it a little more interesting, I've suggested using an RGB LED (it has red,
    green, and blue LEDs combined into a single unit), but feel free to use separate
    LEDs if that is all you have available.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You will need the following equipment:'
  prefs: []
  type: TYPE_NORMAL
- en: 4 x DuPont female to male patch wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mini breadboard (170 tie points) or a larger one
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RGB LED (common cathode)/3 standard LEDs (ideally red/green/blue)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Breadboarding wire (solid core)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 3 x 470 ohm resistors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of the previous components should only cost a few dollars and can be reused
    for other projects afterwards. The breadboard is a particularly useful item that
    allows you to try out your own circuits without needing to solder them.
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/6623OT_06_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The diagrams of an RGB LED, standard LED, and RGB circuit
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the breadboard circuitry:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/6623OT_06_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The wiring of an RGB LED/standard LEDs connected to the GPIO header
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are several variations of RGB LEDs available, so check the datasheet of
    your component to confirm the pin order and type you have. Some are Red, Blue,
    and Green (RBG), so ensure that you wire accordingly or adjust the `RGB_` pin
    settings in the code. You can also get common anode variants, which will require
    the anode to be connected to 3V3 (GPIO-Pin1) for it to light up (and require `RGB_ENABLE`
    and `RGB_DISABLE` to be set to `0` and `1`).
  prefs: []
  type: TYPE_NORMAL
- en: The breadboard and component diagrams of this book have been created using a
    free tool called **Fritzing** ([www.fritzing.org](http://www.fritzing.org)); it
    is great for planning your own Raspberry Pi projects.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create the `ledtest.py` script as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `RPi.GPIO` library will require `sudo` permissions to access the GPIO pin
    hardware, so you will need to run the script using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: When you run the script, you should see the red, green, and blue parts of the
    LED (or each LED, if using separate ones) light up in turn. If not, double-check
    your wiring or confirm the LED is working by temporarily connecting the red, green,
    or blue wire to the 3V3 pin (pin 1 of the GPIO header).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `sudo` command is required for most hardware-related scripts because it
    isn't normal for users to directly control hardware at such a low level. For example,
    setting or clearing a control pin that is part of the SD card controller could
    corrupt data being written to it. Therefore, for security purposes, super user
    permissions are required to stop programs from using hardware by accident (or
    with malicious intent).
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To access the GPIO pins using Python, we import `RPi.GPIO`, which allows direct
    control of the pins through the module functions. We also require the `time` module
    to pause the program for a set number of seconds.
  prefs: []
  type: TYPE_NORMAL
- en: We define values for the LED wiring and active states (see *Controlling the
    GPIO current* in the *There's more…* section of this recipe).
  prefs: []
  type: TYPE_NORMAL
- en: Before the GPIO pins are used by the program, we need to set them up by specifying
    the numbering method (`GPIO.BOARD`) and the direction—`GPIO.OUT` or `GPIO.IN`
    (in this case, we set all the RGB pins to outputs). If a pin is configured as
    an output, we will be able to set the pin state; similarly, if it is configured
    as an input, we will be able to read the pin state.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we control the pins using `GPIO.ouput()` by stating the number of the
    GPIO pin and the state we want it to be in (`1` = high/on and `0` = low/off).
    We switch each LED on, wait 5 seconds, and then switch it back off.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we use `GPIO.cleanup()` to return the GPIO pins back to their original
    default state and release control of the pins for use by other programs.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using the GPIO pins on the Raspberry Pi must be done with care since these pins
    are directly connected to the main processor of the Raspberry Pi without any additional
    protection. Caution must be used, as any incorrect wiring will probably damage
    the Raspberry Pi processor and cause it to stop functioning altogether.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, you could use one of the many modules available that plug directly
    into the GPIO header pins (reducing the chance of wiring mistakes).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For example, the Pi-Stop is a simple pre-built LED board that simulates a set
    of traffic lights, designed to be a stepping stone for those interested in controlling
    hardware but want to avoid the risk of damaging their Raspberry Pi. After the
    basics have been mastered, it also makes an excellent indicator to aid debugging.
  prefs: []
  type: TYPE_NORMAL
- en: Just ensure you update the `LED CONFIG` pin references in the `ledtest.py` script
    to reference the pin layout and location used for the hardware you are using.
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more…](img/6623OT_06_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: See the [Appendix](apa.html "Appendix A. Hardware and Software List"), *Hardware
    and Software List*, for a list of Raspberry Pi hardware retailers.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the GPIO current
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Each GPIO pin is only able to handle a certain current before it will burn out
    (not greater than 16 mA from a single pin or 30 mA in total), and similarly, the
    RGB LED should be limited to no more than 100 mA. By adding a resistor before
    or after an LED, we will be able to limit the current that will be passed through
    it and also control how bright it is (more current will equal a brighter LED).
  prefs: []
  type: TYPE_NORMAL
- en: Since we may wish to drive more than one LED at a time, we typically aim to
    set the current as low as we can get away with while still providing enough power
    to light up the LED.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use Ohm''s law to tell us how much resistance to use to provide a particular
    current. The law is as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Controlling the GPIO current](img/6623OT_06_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Ohm's law describes the relationship between the current, resistance, and voltage
    in electrical circuits
  prefs: []
  type: TYPE_NORMAL
- en: We will aim for a minimum current (3 mA) and maximum current (16 mA), while
    still producing a reasonably bright light from each of the LEDs. To get a balanced
    output for the RGB LEDs, I tested different resistors until they provided a near
    white light (when viewed through a card). A 470 ohm resistor was selected for
    each one (your LEDs may differ slightly).
  prefs: []
  type: TYPE_NORMAL
- en: '![Controlling the GPIO current](img/6623OT_06_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Resistors are needed to limit the current that passes through the LEDs
  prefs: []
  type: TYPE_NORMAL
- en: 'The voltage across the resistor is equal to the GPIO voltage (Vgpio = 3.3V)
    minus the voltage drop on the particular LED (`Vfwd`); we can then use this resistance
    to calculate the current used by each of the LEDs, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Controlling the GPIO current](img/6623OT_06_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can calculate the current drawn by each of the LEDs
  prefs: []
  type: TYPE_NORMAL
- en: Responding to a button
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many applications using the Raspberry Pi require that actions are activated
    without a keyboard and screen attached to it. The GPIO pins provide an excellent
    way for the Raspberry Pi to be controlled by your own buttons and switches without
    a mouse/keyboard and screen.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You will need the following equipment:'
  prefs: []
  type: TYPE_NORMAL
- en: 2 x DuPont female to male patch wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mini breadboard (170 tie points) or a larger one
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Push button switch (momentary close) or a wire connection to make/break the
    circuit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Breadboarding wire (solid core)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1k ohm resistor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The switches are as seen in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/6623OT_06_012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The push button switch and other types of switch
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The switches used in the following examples are **single pole single throw**
    (**SPST**) momentary close push button switches. **Single pole** (**SP**) means
    that there is one set of contacts that makes a connection. In the case of the
    push switch used here, the legs on each side are connected together with a single
    pole switch in the middle. A **double pole** (**DP**) switch acts just like a
    single pole switch, except that the two sides are separated electrically, allowing
    you to switch two separate components on/off at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: '**Single throw** (**ST**) means the switch will make a connection with just
    one position; the other side will be left open. **Double throw** (**DT**) means
    both positions of the switch will connect to different parts.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Momentary close** means that the button will close the switch when pressed
    and automatically open it when released. A **latched** push button switch will
    remain closed until it is pressed again.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/6623OT_06_013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The layout of the button circuit
  prefs: []
  type: TYPE_NORMAL
- en: We will use sound in this example, so you will also need speakers or headphones
    attached to the audio socket of the Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will need to install a program called `flite` using the following command,
    which will let us make the Raspberry Pi talk:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'After it has been installed, you can test it with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If it is a little too quiet (or too loud), you can adjust the volume (0-100
    percent) using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create the `btntest.py` script as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As in the previous recipe, we set up the GPIO pin as required, but this time
    as an input, and we also enable the internal pull-up resistor (see *Pull-up and
    pull-down resistor circuits* in the *There''s more…* section of this recipe for
    more information) using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: After the GPIO pin is set up, we create a loop that will continuously check
    the state of `BTN` using `GPIO.input()`. If the value returned is `false`, the
    pin has been connected to 0V (ground) through the switch, and we will use `flite`
    to count out loud for us each time the button is pressed.
  prefs: []
  type: TYPE_NORMAL
- en: Since we have called the main function from within a `try`/`finally` condition,
    it will still call `GPIO.cleanup()` even if we close the program using *Ctrl*
    + *Z*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We use a short delay in the loop; this ensures that any noise from the contacts
    on the switch is ignored. This is because when we press the button, there isn't
    always perfect contact as we press or release it, and it may produce several triggers
    if we press it again too quickly. This is known as **software debouncing**; we
    ignore the bounce in the signal here.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Raspberry Pi GPIO pins must be used with care; voltages used for inputs
    should be within specific ranges, and any current drawn from them should be minimized
    using protective resistors.
  prefs: []
  type: TYPE_NORMAL
- en: Safe voltages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We must ensure that we only connect inputs that are between 0 (Ground) and 3.3V.
    Some processors use voltages between 0 and 5V, so extra components are required
    to interface safely with them. Never connect an input or component that uses 5V
    unless you are certain it is safe, or you will damage the GPIO ports of the Raspberry
    Pi.
  prefs: []
  type: TYPE_NORMAL
- en: Pull-up and pull-down resistor circuits
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The previous code sets the GPIO pins to use an internal pull-up resistor. Without
    a pull-up resistor (or pull-down resistor) on the GPIO pin, the voltage is free
    to float somewhere between 3.3V and 0V, and the actual logical state remains undetermined
    (sometimes 1 and sometimes 0).
  prefs: []
  type: TYPE_NORMAL
- en: Raspberry Pi's internal pull-up resistors are 50k ohm-65k ohm and the pull-down
    resistors are 50k ohm-65k ohm. External pull-up/pull-down resistors are often
    used in GPIO circuits (as shown in the following diagram), typically using 10k
    ohm or larger for similar reasons (giving a very small current draw when not active).
  prefs: []
  type: TYPE_NORMAL
- en: 'A pull-up resistor allows a small amount of current to flow through the GPIO
    pin and will provide a high voltage when the switch isn''t pressed. When the switch
    is pressed, the small current is replaced by the larger one flowing to 0V, so
    we get a low voltage on the GPIO pin instead. The switch is active low and logic
    0 when pressed. It works as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Pull-up and pull-down resistor circuits](img/6623OT_06_014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A pull-up resistor circuit
  prefs: []
  type: TYPE_NORMAL
- en: 'Pull-down resistors work in the same way, except the switch is active high
    (the GPIO pin is logic 1 when pressed). It works as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Pull-up and pull-down resistor circuits](img/6623OT_06_015.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A pull-down resistor circuit
  prefs: []
  type: TYPE_NORMAL
- en: Protection resistors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In addition to the switch, the circuit includes a resistor in series with the
    switch to protect the GPIO pin, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Protection resistors](img/6623OT_06_016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A GPIO protective current-limiting resistor
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of the protection resistor is to protect the GPIO pin if it is accidentally
    set as an output rather than an input. Imagine, for instance, that we have our
    switch connected between the GPIO and ground. Now the GPIO pin is set as an output
    and switched on (driving it to 3.3V) as soon as we press the switch; without a
    resistor present, the GPIO pin will directly be connected to 0V. The GPIO will
    still try to drive it to 3.3V; this would cause the GPIO pin to burn out (since
    it would use too much current to drive the pin to the high state). If we use a
    1k ohm resistor here, the pin is able to be driven high using an acceptable amount
    of current (I = V/R = 3.3/1k = 3.3mA).
  prefs: []
  type: TYPE_NORMAL
- en: A controlled shutdown button
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Raspberry Pi should always be shut down correctly to avoid the SD card being
    corrupted (by losing power while performing a write operation to the card). This
    can pose a problem if you don't have a keyboard or screen connected (if you are
    running an automated program or controlling it remotely over a network and forget
    to turn it off) as you can't type the command or see what you are doing. By adding
    our own buttons and LED indicator, we can easily command a shutdown, reset, and
    startup again to indicate when the system is active.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You will need the following equipment:'
  prefs: []
  type: TYPE_NORMAL
- en: 3 x Dupont female to male patch wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mini breadboard (170 tie points) or a larger one
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Push button switch (momentary close)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: General purpose LED
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2 x 470-ohm resistors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Breadboarding wire (solid core)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The entire layout of the shutdown circuit will look as shown in the following
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/6623OT_06_017.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The controlled shutdown circuit layout
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create the `shtdwn.py` script as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'To get this script to run automatically (once we have tested it), we can place
    the script in `~/bin` (we can use `cp` instead of `mv` if we just want to copy
    it) and add it to `crontab` with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'At the end of the file, we add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This time, when we set up the GPIO pin, we define the pin connected to the shutdown
    button as an input and the pin connected to the LED as an output. We turn the
    LED on to indicate that the system is running.
  prefs: []
  type: TYPE_NORMAL
- en: By setting the `DEBUG` flag to `True`, we can test the functionality of our
    script without causing an actual shutdown (by reading the terminal messages);
    we just need to ensure to set `DEBUG` to `False` when using the script for real.
  prefs: []
  type: TYPE_NORMAL
- en: We enter a `while` loop and check every second to see whether the GPIO pin is
    set to `LOW` (the switch has been pressed); if so, we enter the `doShutdown()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: The program will wait for 3 seconds and then test again to see whether the button
    is still being pressed. If the button is no longer being pressed, we return to
    the previous `while` loop. However, if it is still being pressed after 3 seconds,
    the program will flash the LED and trigger the shutdown (also providing an audio
    warning using `flite`).
  prefs: []
  type: TYPE_NORMAL
- en: When we are happy with how the script is operating, we can disable the `DEBUG`
    flag (by setting it to `False`) and add the script to `crontab`. Crontab is a
    special program that runs in the background and allows us to schedule (at specific
    times, dates, or periodically) programs and actions when the system is started
    (`@reboot`). This allows the script to be started automatically every time the
    Raspberry Pi is powered up. When we press and hold the shutdown button for more
    than 3 seconds, it safely shuts down the system and enters a low power state (the
    LED switches off just before this, indicating it is safe to remove the power shortly
    after). To restart the Raspberry Pi, we briefly remove the power; this will restart
    the system, and the LED will light up when the Raspberry Pi has loaded.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can extend this example further using the reset header by adding extra functionality
    and making use of additional GPIO connections (if available).
  prefs: []
  type: TYPE_NORMAL
- en: Resetting and rebooting Raspberry Pi
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Raspberry Pi has holes for mounting a reset header (marked **RUN** on the
    Raspberry Pi 2 / 3 and **P6** on the Raspberry Pi 1 Model B Rev 2 and Model As).
    The reset pin allows the device to be reset using a button rather than removing
    the micro USB connector each time to cycle the power:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Resetting and rebooting Raspberry Pi](img/6623OT_06_018.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Raspberry Pi reset headers – on the left, Raspberry Pi Model A/B (Rev2), and
    on the right, Raspberry Pi 2
  prefs: []
  type: TYPE_NORMAL
- en: 'To make use of it, you will need to solder a wire or pin header to the Raspberry
    Pi and connect a button to it (or briefly touch a wire between the two holes each
    time). Alternatively, we can extend our previous circuit, as shown in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Resetting and rebooting Raspberry Pi](img/6623OT_06_019.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The controlled shutdown circuit layout and reset button
  prefs: []
  type: TYPE_NORMAL
- en: We can add this extra button to our circuit, which can be connected to the reset
    header (this is the hole nearest the middle on the Raspberry Pi 2 or closest to
    the edge on other models). This pin, when temporarily pulled low by connecting
    to ground (such as the hole next to it or by another ground point such as pin
    6 of the GPIO header), will reset the Raspberry Pi and allow it to boot up again
    following a shutdown.
  prefs: []
  type: TYPE_NORMAL
- en: Adding extra functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since we now have the script monitoring the shutdown button all the time, we
    can add extra buttons/switches/jumpers to be monitored at the same time. This
    will allow us to trigger specific programs or set up particular states just by
    changing the inputs. The following example allows us to easily switch between
    automatic DHCP networking (the default networking setup) and using a direct IP
    address, as used in the *Networking directly to a laptop or computer* recipe of
    [Chapter 1](ch01.html "Chapter 1. Getting Started with a Raspberry Pi Computer"),
    *Getting Started with a Raspberry Pi Computer*, for direct LAN connections.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following components to the previous circuit:'
  prefs: []
  type: TYPE_NORMAL
- en: A 470-ohm resistor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two pin headers with a jumper connector (or optionally a switch)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Breadboarding wire (solid core)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After adding the previous components, our controlled shutdown circuit now looks
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding extra functions](img/6623OT_06_020.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The controlled shutdown circuit layout, reset button, and jumper pins
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous script, we add an additional input to detect the status of
    the `LAN_SWA` pin (the jumper pins we added to the circuit) using the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Ensure that it is set up as an input (with a pull-up resistor) in the `gpio_setup()`
    function using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a new function to switch between the LAN modes, and read out the new IP
    address. The `doChangeLAN()` function checks if the status of the `LAN_SWA` pin
    has changed since the last call, and if so, it sets the network adaptor to DHCP
    or sets the direct LAN settings accordingly (and uses `flite` to speak the new
    IP setting if available). Finally, the LAN being set for direct connection causes
    the LED to flash slowly while that mode is active. Use the following code to do
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Add another function, `flashled()`, which will just toggle the state of the
    LED each time it is called. The code for this function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we adjust the main loop to also call `doChangeLAN()` and use the result
    to decide whether we call `flashled()` using `ledon` to keep track of the LED''s
    previous state each time. The `main()` function should now be updated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The GPIO keypad input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen how we can monitor inputs on the GPIO to launch applications and
    control the Raspberry Pi; however, sometimes we need to control third-party programs.
    Using the `uInput` library, we can emulate key presses from a keyboard (or even
    mouse movement) to control any program, using our own custom hardware.
  prefs: []
  type: TYPE_NORMAL
- en: For more information about using `uInput`, visit [http://tjjr.fi/sw/python-uinput/](http://tjjr.fi/sw/python-uinput/).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to install `uInput`:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to download `uInput`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will need to download the `uInput` Python library from Github (~50 KB)
    using the following commands:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The library will unzip to a directory called `python-uinput-master`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once completed, you can remove the ZIP file using the following command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Install the required packages (if you have installed them already, the `apt-get`
    command will ignore them) using the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Compile and install `uInput` using the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we load the new `uinput` kernel module using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To ensure it is loaded on startup, we can add `uinput` to the `modules` file
    using the following command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Put `uinput` on a new line in the file and save it (*Ctrl* + *X*,*Y*).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create the following circuit using the following equipment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Breadboard (half-sized or larger)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 7 x Dupont female to male patch wires
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Six push buttons
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 6 x 470-ohm resistors
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Breadboarding wire (solid core)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Getting ready](img/6623OT_06_021.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: GPIO keypad circuit layout
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The keypad circuit can also be built into a permanent circuit by soldering
    the components into a Vero prototype board (also known as a stripboard), as shown
    in the following image:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Getting ready](img/6623OT_06_022.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: GPIO keypad Pi hardware module
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: This circuit is available as a solder-yourself kit from [PiHardware.com](http://PiHardware.com).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Connect the circuit to the Raspberry Pi GPIO pins as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '|   | Button | GPIO pin |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| GND |   | 6 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| v | B_DOWN | 22 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| < | B_LEFT | 18 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ^ | B_UP | 15 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| > | B_RIGHT | 13 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 1 | B_1 | 11 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 2 | B_2 | 7 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a `gpiokeys.py` script as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, we import `uinput` and define the wiring of the keypad buttons. For each
    of the buttons in `BTN`, we enable them as inputs with internal pull-ups enabled.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we set up `uinput`, defining the keys we want to emulate and adding them
    to the `uinput.Device()` function. We wait a few seconds to allow `uinput` to
    initialize, set the initial button and key states, and start our `main` loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `main` loop is split into two sections: the first part checks through the
    buttons and records the states in `btn_state`, and the second part compares the
    `btn_state` with the current `key_state` array. This way, we can detect a change
    in `btn_state` and call `device.emit()` to toggle the state of the key.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To allow us to run this script in the background, we can run it with `&` as
    shown in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `&` character allows the command to run in the background, so we can continue
    with the command line to run other programs. You can use `fg` to bring it back
    to the foreground, or `%1`, `%2`, and so on if you have several commands running.
    Use `jobs` to get a list.
  prefs: []
  type: TYPE_NORMAL
- en: You can even put a process/program on hold to get to the command prompt by pressing
    *Ctrl* + *Z* and then resume it with `bg` (which will let it run in the background).
  prefs: []
  type: TYPE_NORMAL
- en: You can test the keys using the game created in the *Creating an overhead scrolling
    game* recipe in [Chapter 4](ch04.html "Chapter 4. Creating Games and Graphics"),
    *Creating Games and Graphics*, which you can now control using your GPIO directional
    pad. Don't forget that if you are connecting to the Raspberry Pi remotely, any
    key presses will only be active on the locally connected screen.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can do more using `uinput` to provide hardware control for other programs,
    including those that require mouse input.
  prefs: []
  type: TYPE_NORMAL
- en: Generating other key combinations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can create several different key mappings in your file to support different
    programs. For instance, the `events_z80` key mapping would be useful for a Spectrum
    Emulator such as **fuze** (browse to [http://raspi.tv/2012/how-to-install-fuse-zx-spectrum-emulator-on-raspberry-pi](http://raspi.tv/2012/how-to-install-fuse-zx-spectrum-emulator-on-raspberry-pi)
    for details). The `events_omx` key mappings are suitable for controlling video
    played through the OMX Player using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: You can get a list of keys supported by `omxplayer` by using the `-k` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace the line that defines the `events` list with a new key mapping, and
    select different ones by assigning them to events using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'You can find all the `KEY` definitions in the `input.h` file; you can view
    it using the `less` command (press *Q* to exit) as shown in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Emulating mouse events
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `uinput` library can emulate mouse and joystick events as well as keyboard
    presses. To use the buttons to simulate a mouse, we can adjust the script to use
    mouse events (as well as defining `mousemove` to set the step size of the movement)
    using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to modify the button handling to provide continuous movement,
    as we don''t need to keep track of the state of the keys for the mouse. To do
    so, use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Multiplexed color LEDs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next example in this chapter demonstrates that some seemingly simple hardware
    can produce some impressive results if controlled with software. We return to
    using some RGB LEDs that are wired so that we only need to use eight GPIO pins
    to control the red, green, and blue elements of five RGB LEDs using a method called
    **hardware multiplexing** (see the *Hardware multiplexing* subsection in the *There's
    more…* section of this recipe).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You will need the RGB LED module shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/6623OT_06_023.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The RGB LED module from PiHardware.com
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the preceding image, the RGB LED module from [PiHardware.com](http://PiHardware.com)
    comes with GPIO pins and a Dupont female to female cable for connecting it. Although
    there are two sets of pins labelled 1 to 5, only one side needs to be connected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, you can recreate your own with the following circuit using five
    common cathode RGB LEDs, 3 x 470-ohm resistors, and a Vero prototype board (or
    large breadboard). The circuit will look as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/6623OT_06_024.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Circuit diagram for the RGB LED module
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Strictly speaking, we should use 15 resistors in this circuit (one for each
    RGB LED element), which will avoid interference from LEDs sharing the same resistor
    and would also prolong the life of the LEDs themselves if switched on together.
    However, there is only a slight advantage, particularly since we intend to drive
    each RGB LED independently of the other four to achieve multicolor effects.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will need to connect the circuit to the Raspberry Pi GPIO header as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| RGB LED |   |   |   |   |   | 1 |   | 2 | 3 |   | 4 |   |   |   |   |   |
      |   |   |   |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | ---
    | --- | --- | --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **Rpi GPIO Pin** | 2 | 4 | 6 | 8 | 10 | 12 | 14 | 16 | 18 | 20 | 22 | 24
    | 26 | 28 | 30 | 32 | 34 | 36 | 38 | 40 |'
  prefs: []
  type: TYPE_TB
- en: '| **Rpi GPIO Pin** | 1 | 3 | 5 | 7 | 9 | 11 | 13 | 15 | 17 | 19 | 21 | 23 |
    25 | 27 | 29 | 31 | 33 | 35 | 37 | 39 |'
  prefs: []
  type: TYPE_TB
- en: '| **RGB LED** |   |   |   | 5 |   | R | G | B |   |   |   |   |   |   |   |
      |   |   |   |   |'
  prefs: []
  type: TYPE_TB
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create the `rgbled.py` script and perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import all the required modules and define values to be used with the help
    of the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define functions to set up the GPIO pins using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define our utility functions to help control the LEDs using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a test function to demonstrate the functionality of the module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To start with, we define the hardware setup by defining the states required
    to **Enable** and **Disable** the LED depending on the type of RGB LED (common
    cathode) used. If you are using a common anode device, just reverse the **Enable**/**Disable**
    states.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we define the GPIO mapping to the pins to match the wiring we did previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also define some basic color combinations by combining red, green, and/or
    blue together, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/6623OT_06_025.jpg)'
  prefs: []
  type: TYPE_IMG
- en: LED color combinations
  prefs: []
  type: TYPE_NORMAL
- en: We define a series of useful functions, the first being `led_setup()`, which
    will set the GPIO numbering to `GPIO.BOARD` and define all the pins used to be
    outputs. We also call a function named `led_clear()`, which will set the pins
    to the default state with all the pins disabled.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This means the LED pins, 1-5 (the common cathode on each LED), are set to `HIGH`,
    while the RGB pins (the separate anodes for each color) are set to `LOW`.
  prefs: []
  type: TYPE_NORMAL
- en: We create a function called `led_gpiocontrol()` that will allow us to set the
    state of one or more pins. The `isinstance()` function allows us to test a value
    to see whether it matches a particular type (in this case, a single integer);
    then we can either set the state of that single pin or iterate through the list
    of pins and set each one.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we define two functions, `led_activate()` and `led_deactivate()`, which
    will enable and disable the specified LED and color. Finally, we define `led_time()`,
    which will allow us to specify an LED, color, and time to switch it on for.
  prefs: []
  type: TYPE_NORMAL
- en: We also create `led_cleanup()` to reset the pins (and LEDs) to the default values
    and call `GPIO.cleanup()` to release the GPIO pins in use.
  prefs: []
  type: TYPE_NORMAL
- en: 'This script is intended to become a library file, so we will use the `if __name__==''__main__''`
    check to only run our test code when running the file directly:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By checking the value of `__name__`, we can determine whether the file was run
    directly (it will equal `__main__`) or whether it was imported by another Python
    script.
  prefs: []
  type: TYPE_NORMAL
- en: This allows us to define special test code that is only executed when we directly
    load and run the file. If we include this file as a module in another script,
    then this code will not be executed.
  prefs: []
  type: TYPE_NORMAL
- en: We have used this technique previously in the *There's more…* section in the
    *Working with text and strings* recipe of [Chapter 2](ch02.html "Chapter 2. Starting
    with Python Strings, Files, and Menus"), *Starting with Python Strings, Files,
    and Menus*.
  prefs: []
  type: TYPE_NORMAL
- en: As before, we will use `try`/`finally` to allow us to always perform cleanup
    actions, even if we exit early.
  prefs: []
  type: TYPE_NORMAL
- en: To test the script, we will set the LEDs to light up in various colors one after
    another.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can create a few different colors by switching on one or more parts of the
    RGB LED at a time. However, with some clever programming, we can create a whole
    spectrum of colors. Also, we can display different colors on each LED, seemingly
    at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Hardware multiplexing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An LED requires a high voltage on the anode side and a lower voltage on the
    cathode side to light up. The RGB LEDs used in the circuit are common cathode,
    so we must apply a high voltage (3.3V) on the RGB pins and a low voltage (0V)
    on the cathode pin (wired to pins 1 to 5 for each of the LEDs).
  prefs: []
  type: TYPE_NORMAL
- en: 'The cathode and RGB pin states are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Hardware multiplexing](img/6623OT_06_026.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Cathode and RGB pin states
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, we can enable one or more of the RGB pins but still control which
    of the LEDs are lit. We enable the pins of the LEDs we want to light up and disable
    the ones we don't. This allows us to use far fewer pins than we would need to
    control each of the 15 RGB lines separately.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying random patterns
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can add new functions to our library to produce different effects, such
    as generating random colors. The following function uses `randint()` to get a
    value between 1 and the number of colors. We ignore any values that are over the
    number of the available colors so that we can control how often the LEDs may be
    switched off. Perform the following steps to add the required functions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `randint()` function from the `random` module to the `rgbled.py` script
    using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now add `led_rgbrandom()` using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the following commands in the `main()` function to create a series of flashing
    LEDs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Mixing multiple colors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Until now, we have only displayed a single color at a time on one or more of
    the LEDs. If you consider how the circuit is wired up, you might wonder how can
    we get one LED to display one color and another a different one at the same time?
    The simple answer is that we don't need to—we just do it quickly!
  prefs: []
  type: TYPE_NORMAL
- en: 'All we need to do is display one color at a time but change it very quickly
    back and forth, so fast the color looks like a mix of the two (or even a combination
    of the three red/green/blue LEDs). Fortunately, this is something that computers
    such as the Raspberry Pi can do very easily, even allowing us to combine the RGB
    elements to make multiple shades of colors across all five LEDs. Perform the following
    steps to mix the colors:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add combo color definitions to the top of the `rgbled.py` script, after the
    definition of the mixed colors, using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code will provide the combination of colors to create our shades,
    with `RGB_COLORS` providing a smooth progression through the shades.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we need to create a function called `led_combo()` to handle single or
    multiple colors. The code for the function will be as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we can create a new script, `rgbledrainbow.py`, to make use of the new
    functions in our `rgbled.py` module. The `rgbledrainbow.py` script will be as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `main()` function will first cycle through the LEDs, setting each color
    from the `RGB_COLORS` array on all the LEDs. Then, it will cycle through the colors,
    creating a rainbow effect over the LEDs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Mixing multiple colors](img/6623OT_06_027.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Cycle through multiple colors on the five RGB LEDs
  prefs: []
  type: TYPE_NORMAL
- en: Writing messages using Persistence of Vision
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Persistence of Vision (POV)** displays can produce an almost magical effect,
    displaying images in the air by moving a line of LEDs back and forth very quickly
    or around in circles. The effect works because your eyes are unable to adjust
    fast enough to separate out the individual flashes of light, and so you observe
    a merged image (the message or picture being displayed).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing messages using Persistence of Vision](img/6623OT_06_028.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Persistence of vision using RGB LEDs
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This recipe also uses the RGB LED kit used in the previous recipe; you will
    also need the following additional items:'
  prefs: []
  type: TYPE_NORMAL
- en: Breadboard (half-sized or larger)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2 x Dupont female to male patch wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tilt switch (ball-bearing type is suitable)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 x 470 ohm resistor (R_Protect)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Breadboarding wire (solid core)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The tilt switch should be added to the RGB LED (as described in the *Getting
    ready* section of the *Multiplexed color LEDs* recipe). The tilt switch is wired
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/6623OT_06_029.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tilt switch is connected to GPIO Input (GPIO pin 24) and Gnd (GPIO pin 6)
  prefs: []
  type: TYPE_NORMAL
- en: 'To reproduce the POV image, you will need to be able to quickly move the LEDs
    and tilt switch back and forth. Note how the tilt switch is mounted angled to
    the side, so the switch will open when moved to the left. It is recommended that
    the hardware is mounted onto a length of wood or similar. You can even use a portable
    USB battery pack along with a Wi-Fi dongle to power and control the Raspberry
    Pi through a remote connection (see [Chapter 1](ch01.html "Chapter 1. Getting
    Started with a Raspberry Pi Computer"), *Getting Started with a Raspberry Pi –
    Connecting Remotely to the Raspberry Pi over the Network using SSH (and X11 Forwarding)*,
    for details):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/6623OT_06_030.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Persistence of Vision hardware setup
  prefs: []
  type: TYPE_NORMAL
- en: You will also need the completed `rgbled.py` file, which we will extend further
    in the *How to do it*… section.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a script called `tilt.py` to report the state of the tilt switch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'You can test the script by running it directly with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following `rgbled_pov()` function to the `rgbled.py` script we created
    previously; this will allow us to display a single line of our image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now create the following file, called `rgbledmessage.py`, to perform
    the required actions to display our message. First we will import the modules
    used, the updated `rgbled` module, the new `tilt` module, and the python `os`
    module. Initially, we set `DEBUG` to `True` so the Python terminal will display
    additional information while the script is running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a `readMessageFile()` function to read the content of the `letters.txt`
    file and then add `processFileContent()` to generate a **Python dictionary** of
    the LED patterns for each letter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a `createBuffer()` function, which will convert a message into a series
    of LED patterns for each letter (assuming the letter is defined by the `letters.txt`
    file):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we define `displayBuffer()` to display the LED patterns using the `rgbled_pov()`
    function in the `rgbled` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we create a `main()` function to perform each of the required steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Set up the hardware components (RGB LEDs and the tilt switch).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Read the `letters.txt` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define the dictionary of LED letter patterns.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generate a buffer to represent the required message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Display the buffer using the `rgbled` module and control it with the `tilt`
    module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the following file, called `letters.txt`, to define the LED patterns
    needed to display the example `''_COOKBOOK_''` message. Note, this file only needs
    to define a pattern for each unique letter or symbol in the message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first function, `readMessageFile()`, will open and read the contents of
    a given file (as we did previously in [Chapter 2](ch02.html "Chapter 2. Starting
    with Python Strings, Files, and Menus"), *Starting with Python Strings, Files,
    and Menus*; see the *Using files and handling errors* recipe for more details).
    This will then use `processFileContent()` to return a Python **dictionary** containing
    corresponding patterns for the letters defined in the file provided. Each line
    in the file is processed, ignoring any line with a `#` character in and checking
    for `"` characters to indicate the name for the LED pattern that follows after.
    After the file has been processed, we end up with a Python dictionary that contains
    LED patterns for the `''_''`, `''C''`, `''B''`, `''K''` and `''O''` characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have a selection of letters to choose from, we can create a sequence
    of LED patterns using the `createBuffer()` function. As the name suggests, the
    function will build up a buffer of LED patterns by looking up each letter in the
    message and adding the related pattern row by row. If a letter isn't found in
    the dictionary, then a space will be used instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we now have a list of LED patterns ready to display. To control when
    we start the sequence, we will use the TILT module and check the status of the
    tilt switch:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/6623OT_06_031.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The tilt switch position when not moving (left) and moving (right)
  prefs: []
  type: TYPE_NORMAL
- en: 'The tilt switch consists of a small ball bearing enclosed in a hollow insulated
    cylinder; the connection between the two pins is closed when the ball is resting
    at the bottom of the cylinder. The tilt switch is open when the ball is moved
    to the other end of the cylinder, out of contact of the pins:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/6623OT_06_032.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The tilt switch circuit, switch closed and switch open
  prefs: []
  type: TYPE_NORMAL
- en: The tilt switch circuit shown previously will allow GPIO pin 24 to be connected
    to the ground when the switch is closed, then if we read the pin it will return
    `False` when it is at rest. By setting the GPIO pin as an input and enabling the
    internal pull-up resistor, when the tilt switch is open it will report `True`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the tilt switch is open (reporting `True`) then we will assume the unit
    is being moved and begin displaying the LED sequences, incrementing the current
    position each time we display a row of the LED pattern. Just to make the pattern
    a little more colorful (just because we can!) we repeat each row in another color.
    As soon as the `TILT.tilt_moving()` function reports we have stopped moving or
    we are moving in the opposite direction, we will reset the current position, ready
    to start the whole pattern over again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/6623OT_06_033.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The message is displayed by the RGB LEDs – here using Green and Blue together
  prefs: []
  type: TYPE_NORMAL
- en: When the RGB LED module and tilt switch are moved back and forth, we should
    see the message displayed in the air!
  prefs: []
  type: TYPE_NORMAL
- en: Try experimenting with different color combinations, speeds, and arm waviness
    to see what effects you can produce. You could even create a similar setup mounted
    on a wheel to produce a continuous POV effect.
  prefs: []
  type: TYPE_NORMAL
