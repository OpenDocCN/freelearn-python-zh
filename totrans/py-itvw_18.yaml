- en: Chapter 18. Nick Coghlan
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第18章。尼克·科根兰
- en: '![Nick Coghlan](img/B08180_11_01.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![尼克·科根兰](img/B08180_11_01.jpg)'
- en: Nick Coghlan is an Australian software developer and systems architect. His
    past roles include software engineer at Boeing Australia and senior software engineer
    at Red Hat Asia Pacific, a provider of open source solutions. Nick is a CPython
    core developer and BDFL-delegate for Python packaging interoperability standards.
    He is a founding member of the Python Software Foundation (PSF)'s Python Packaging
    Working Group, and the founder of the PyCon Australia Education Seminar. Over
    the past 20 years, Nick has contributed to a range of open source systems and
    software projects.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 尼克·科根兰是一位澳大利亚软件开发者和系统架构师。他过去的工作经历包括在波音澳大利亚的软件工程师和红帽亚太地区的资深软件工程师，红帽是一家开源解决方案提供商。尼克是CPython核心开发者，Python打包互操作性标准的BDFL代表。他是Python软件基金会（PSF）的Python打包工作组创始人，也是PyCon澳大利亚教育研讨会的创始人。在过去20年里，尼克为一系列开源系统和软件项目做出了贡献。
- en: '**Photo credits of Nick Coghlan**: © Kushal Das'
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**尼克·科根兰的照片版权**：©库沙尔·达斯'
- en: ''
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**Discussion themes: core developers, PEPs, learning Python.**'
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**讨论主题：核心开发者、PEP、学习Python。**'
- en: ''
  id: totrans-6
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**Catch up with Nick Coghlan here: @ncoghlan_de**'
  id: totrans-7
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**在这里了解尼克·科根兰：@ncoghlan_de**'
- en: '**Mike Driscoll**: What made you decide to become a computer programmer?'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**迈克·德里斯科尔**：是什么让你决定成为一名计算机程序员？'
- en: '**Nick Coghlan**: Originally, I just did programming as a plaything as a kid.
    We had the good old BASIC programming book for the Apple IIe.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**尼克·科根兰**：起初，我只是把编程当作孩子时的玩具。我们有一本关于Apple IIe的老式BASIC编程书籍。'
- en: It wasn't until I did IT in my first year of high school that I discovered that
    computers were actually a thing you could play with as a job. The school that
    I went to was one of the first in the state to actually have an IT class. So that
    was pretty much why I then went into computer systems engineering at university.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 直到我在高中一年级学习信息技术时，我才意识到计算机实际上是一种可以用来工作的玩具。我去的学校是该州最早开设信息技术课程的学校之一。所以这就是我后来在大学选择计算机系统工程的原因。
- en: My initial full-time job out of university was embedded systems programming
    in C, for a Texas Instruments DSP. From there, I ended up doing a lot more systems
    control and automation stuff, which looks a lot more like programming than it
    does embedded software development. So it was just the case that I enjoyed programming,
    I was good at it, and you can make money from it.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我大学毕业后最初的全职工作是使用C语言为德州仪器的DSP进行嵌入式系统编程。从那里，我做了很多系统控制和自动化工作，这看起来更像编程，而不是嵌入式软件开发。所以，我只是喜欢编程，我擅长它，而且你可以从中赚钱。
- en: '**Driscoll**: So why did you move into Python?'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**德里斯科尔**：那你为什么转向Python？'
- en: '**Coghlan**: So the way that I came to Python is actually kind of interesting,
    because I was originally a C/C++ developer.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**科根兰**：我转向Python的方式实际上很有趣，因为我最初是一名C/C++开发者。'
- en: '**Nick Coghlan: ''I was the guy who then replied, "Can we use a different language
    instead? I already know Java, and I''d like to use Java."''**'
  id: totrans-14
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**尼克·科根兰：“我就是那个回答说‘我们能用不同的语言吗？我已经知道Java了，我想用Java’的人。’**'
- en: My only exposure to Python at university was from a networking lecturer who
    said, "I'm going to make you all do the assignments in Python, because I'm confident
    that none of you will know it". I was the guy who then replied, "Can we use a
    different language instead? I already know Java, and I'd like to use Java".
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我在大学里对Python的唯一接触是从一位网络讲师那里，他说：“我将让你们所有人用Python完成作业，因为我相信你们中没有人会知道它”。我就是那个回答说：“我们能用不同的语言吗？我已经知道Java了，我想用Java”的人。
- en: My lecturer said, "Well, if you really want to use Java then use it, but try
    Python first". So I tried Python 1.5.2 and it was fun.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我的讲师说：“好吧，如果你真的想用Java，那就用吧，但先试试Python”。所以我试了Python 1.5.2，感觉很有趣。
- en: Professionally, I was working for a large-scale system integrator here in Australia.
    For the DSP program I was working on, my test suite was a really rudimentary C
    program, which was a success if it got to the end without crashing.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在专业领域，我在澳大利亚的一家大型系统集成公司工作。对于我正在工作的DSP项目，我的测试套件是一个非常基础的C程序，如果它运行到结束而没有崩溃，那就算成功了。
- en: We were just having lots of problems with the DSP code not working properly
    when we got to the next level of integration testing. So we had a huge amount
    of behavioral bugs getting through. We decided that we needed to write a better
    test suite to feed the audio in. It was important to check that we were getting
    the answers we were expecting from the actual data analysis, not simply that we
    could talk to the DSP and ask it to do things remotely.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们到达下一级集成测试时，我们遇到了很多DSP代码不正常工作的问题。所以我们有大量的行为错误通过。我们决定我们需要编写一个更好的测试套件来输入音频。检查我们是否从实际数据分析中获得预期的答案是重要的，而不仅仅是我们可以与DSP通信并远程请求它做事情。
- en: '**Nick Coghlan: ''It was important to check that we were getting the answers
    we were expecting from the actual data analysis.''**'
  id: totrans-19
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**尼克·科格兰：''检查我们是否从实际数据分析中获得预期的答案是很重要的。''**'
- en: We wanted to check the actual signal processing itself. We also really didn't
    want to write that in C and C++. Another part of the system had already had Python
    approved as a language for system control components. So Python wasn't being used
    for critical path stuff, but just orchestrating all the different bits of the
    system, and starting them when they were supposed to be started.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想检查实际的信号处理。我们也不想用C和C++来编写它。系统的另一部分已经批准Python作为系统控制组件的语言。所以Python并没有用于关键路径的东西，只是协调系统的不同部分，并在它们应该启动时启动它们。
- en: There were two main options that we were looking at for doing the automated
    testing. One option was using Python's `unittest` module, with SWIG, to generate
    the bindings to the C++ drivers that actually talked to the DSP. The alternative
    was the in-house C/C++ test framework that we used for everything else. We selected
    Python.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在自动化测试方面有两个主要的选择。一个选项是使用Python的`unittest`模块和SWIG生成绑定到与DSP通信的C++驱动程序的绑定。另一个选择是我们用于其他所有事情的内部C/C++测试框架。我们选择了Python。
- en: '**Driscoll**: Why did you choose Python?'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**德里斯科尔**: 为什么选择Python？'
- en: '**Coghlan**: The thing was that Python had the `unittest` module to actually
    organize the testing. Python had SWIG to tie to the C++ driver. We controlled
    the API of that driver, so making it play nicely with SWIG was straightforward.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**科格兰**: 问题是Python有一个`unittest`模块来实际组织测试。Python有SWIG来连接到C++驱动程序。我们控制了那个驱动程序的API，所以让它与SWIG很好地配合是直接的。'
- en: Then the last key piece was that Python, in its standard library, had the wave
    module, to play WAV files out of the PC. So that established a trend for that
    whole project, which was Australia's High Frequency Modernization Project. Python
    just ended up kind of proliferating through that project for all of the bits that
    were testing, mocking and simulating system interfaces for testing purposes.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 然后最后一个关键部分是Python在其标准库中有一个wave模块，可以从PC播放WAV文件。因此，这为整个项目确立了一个趋势，即澳大利亚高频现代化项目。Python最终在这个项目中广泛传播，用于所有测试、模拟系统接口的测试目的。
- en: '**Driscoll**: So I know that another Australian helped to create pywin32\.
    Did you have any involvement in that project?'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**德里斯科尔**: 所以我知道另一个澳大利亚人帮助创建了pywin32。你在那个项目中有什么参与吗？'
- en: '**Coghlan**: No, I''ve only ever been a pywin32 user. There are actually lots
    of Australians who have historically contributed to the Python community. But
    because they haven''t really been active in PyCon Australia, or anything like
    that, I''ve never actually met them!'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**科格兰**: 不，我过去一直只是个pywin32用户。实际上，历史上有很多澳大利亚人为Python社区做出了贡献。但是因为他们并没有真正活跃在PyCon
    Australia或类似的活动上，所以我实际上从未见过他们！'
- en: '**Driscoll**: Well, let''s move on. How did you become a core developer for
    the Python language?'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**德里斯科尔**: 好吧，让我们继续。你是如何成为Python语言的核心开发者的？'
- en: '**Coghlan**: So my short answer to this question is that I became a core developer
    by arguing with Guido van Rossum!'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**科格兰**: 所以我对这个问题的简短回答是，我是通过与Guido van Rossum争论而成为核心开发者的！'
- en: '**Nick Coghlan: ''I became a core developer by arguing with Guido van Rossum!''**'
  id: totrans-29
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**尼克·科格兰：''我是通过与Guido van Rossum争论而成为核心开发者的！''**'
- en: What actually happened was that I'd been on Usenet since the late 1990s, and
    so I was very familiar with that whole online discussion format. After I started
    using Python, I ended up joining the original Python mailing list, and participating
    in discussions there.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上发生的事情是，我从20世纪90年代末就开始使用Usenet，所以我非常熟悉那个整个在线讨论格式。在我开始使用Python后，我最终加入了原始的Python邮件列表，并参与了那里的讨论。
- en: I discovered that Python-Dev was a thing and started lurking on that, originally
    with the intention just to listen to what people were talking about. I actually
    started participating actively in discussions and posting as well. The first contribution
    that I can remember actually making was in discussions on the Python list.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现Python-Dev是一个东西，并开始在那里潜伏，最初只是想听听人们都在谈论什么。我实际上开始积极参与讨论并发表帖子。我记得我第一次真正做出的贡献是在Python列表上的讨论。
- en: It was very common to use the `timeit` module to time snippets of code and say,
    "Oh this is faster than that." At that point, if you wanted to time the snippets
    between two different versions, you had to find where the `timeit` module was
    in a particular version of the standard library.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`timeit`模块来计时代码片段并说“哦，这个比那个快。”是很常见的。在那个阶段，如果你想比较两个不同版本之间的代码片段，你必须找到标准库中特定版本的`timeit`模块所在的位置。
- en: We said, "Hang on! Python already knows where the `timeit` module is. Why are
    we having to tell Python where to find it?" So that ended up becoming a patch
    to add the initial version of the -m switch in Python 2.4\. I think Raymond Hettinger
    reviewed that. This initial version of Python could only do top-level modules
    and couldn't do packages or submodules. Then finally by the time we reached Python
    2.7, the -m switch actually worked properly and did all the things you would expect
    of it.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们说，“等等！Python已经知道`timeit`模块在哪里了。我们为什么还要告诉Python在哪里找到它？”所以这最终成为了一个补丁，用于在Python
    2.4中添加初始版本的-m开关。我认为雷蒙德·赫廷格审查了那个。这个Python初始版本只能处理顶层模块，不能处理包或子模块。最终到了Python 2.7，-m开关实际上正常工作，并做了你期望的所有事情。
- en: '**Nick Coghlan: ''Finally by the time we reached Python 2.7, the -m switch
    actually worked properly.''**'
  id: totrans-34
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**尼克·科根：''终于到了Python 2.7版本，-m开关才真正正常工作。''**'
- en: Something else interesting happened in late 2004\. After a major crunch period
    at work, I took a leave of absence of three months. I ended up helping out Raymond
    and Facundo Batista with the initial performance enhancements on the Python decimal
    module. We were looking at what we could do to make the module faster.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在2004年底发生了一件有趣的事情。在工作中的一个大压力期之后，我请了三个月的假。我最终帮助雷蒙德和法昆多·巴蒂斯塔对Python十进制模块进行了初始的性能提升。我们正在研究我们能做什么来使该模块更快。
- en: '**Driscoll**: Did you find a way to speed things up?'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**德里斯科尔**：你找到加快速度的方法了吗？'
- en: '**Coghlan**: There was actually an eventual solution several years later, but
    in those early days, there was lots of benchmarking to say, "How fast can we make
    this just as a pure Python thing?"'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**科根**：实际上，几年后找到了一个解决方案，但在那些早期日子里，有很多基准测试来说明，“我们能把这个东西做得有多快，仅仅作为一个纯Python的东西？”'
- en: '**Nick Coghlan: ''There was lots of benchmarking to say, "How fast can we make
    this just as a pure Python thing?"''**'
  id: totrans-38
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**尼克·科根：''有很多基准测试来说明，''我们能把这个东西做得有多快，仅仅作为一个纯Python的东西？''**'
- en: There was a glorious hack that I remember from those days. We made the discovery
    that in pure Python, if you have a tuple of digits that you would like to turn
    into a decimal number, then the fastest conversion mechanism that CPython itself
    offers is to convert all the digits to strings, concatenate the strings, and then
    use `int` to convert the concatenated string back to a number.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我记得那些日子里有一个辉煌的技巧。我们发现，在纯Python中，如果你有一个你想转换成十进制数的数字元组，那么CPython本身提供的最快转换机制是将所有数字转换为字符串，连接这些字符串，然后使用`int`将连接后的字符串转换回数字。
- en: This is because the string `int` conversions have been optimized to a point
    where doing that is faster than doing all the multiplication and addition operations
    as Python code. In C, of course, you do the arithmetic. Our findings really annoyed
    the PyPy developers. From their point of view, doing the arithmetic was a lot
    better, because the JIT worked. So this meant that their `decimal` module was
    slower than they liked.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为字符串到`int`的转换已经被优化到了一个程度，这样做比用Python代码进行所有乘法和加法运算要快。当然，在C语言中，你会进行算术运算。我们的发现真的让PyPy开发者感到烦恼。从他们的角度来看，进行算术运算要好得多，因为JIT（即时编译）工作。这意味着他们的`decimal`模块比他们希望的运行得慢。
- en: I think that I began getting involved in discussions just after Python 2.3 came
    out. One of the popular pastimes was making fun of the extended slice syntax.
    You had the reverse smiley of open bracket, colon, colon, -1, and close bracket,
    to reverse a sequence. This was long before `reversed` or anything like that.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为我是在Python 2.3发布后不久开始参与讨论的。当时的一种流行消遣是嘲笑扩展切片语法。你有反向笑脸的开放括号，冒号，冒号，-1，和闭合括号，来反转一个序列。这还是在`reversed`或类似功能出现之前。
- en: '`reversed` became a thing because it turned out that getting the arithmetic
    right for reversing a slice was actually quite tricky. It was just really prone
    to off-by-one errors if you did it manually. So adding in reversed made things
    easier to read.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`reversed`之所以成为可能，是因为发现正确处理切片反转的算术实际上相当棘手。如果你手动做，很容易出现偏移量错误。所以添加`reversed`使得代码更容易阅读。'
- en: '**Driscoll**: What do you think about the long life of Python 2.7? Should people
    move over to the latest version?'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**德里斯科尔**: 你对Python 2.7的长期存在有何看法？人们应该迁移到最新版本吗？'
- en: '**Coghlan**: We deliberately set the support period of Python 2.7 such that
    existing users could make their own decision about when they considered the Python
    3 ecosystem to be sufficiently mature for them to switch over.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**科格兰**: 我们故意将Python 2.7的支持期设定得足够长，以便现有用户可以自己决定何时认为Python 3生态系统足够成熟，可以切换过来。'
- en: '**Nick Coghlan: ''We deliberately set the support period of Python 2.7 such
    that existing users could make their own decision.''**'
  id: totrans-45
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**尼克·科格兰：“我们故意将Python 2.7的支持期设定得足够长，以便现有用户可以自己做出决定。”**'
- en: Folks that had personally felt the pain of Python 2.7's limitations migrated
    early, so we're now at the point where most of the folks that are still to migrate
    are either looking for better tools to help them with that process, or are simply
    planning to sunset affected projects and products along with Python 2.7.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 感受过Python 2.7限制之苦的人们早早地迁移了，所以我们现在处于这样一个阶段，即大多数尚未迁移的人要么正在寻找更好的工具来帮助他们完成这个过程，要么只是简单地计划在Python
    2.7停止支持的同时结束受影响的项目和产品。
- en: On the tooling front, one of the important use cases for Python 3's type hinting
    machinery is to allow folks to statically check for Python 3 type correctness
    errors, even if their automated test coverage is low. This greatly expands the
    scope of code which can be reliably migrated.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在工具方面，Python 3的类型提示机制的一个重要用例是允许人们静态检查Python 3的类型正确性错误，即使他们的自动化测试覆盖率很低。这大大扩大了可以可靠迁移的代码范围。
- en: '**Driscoll**: What changes would you like to see in future Python releases?'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**德里斯科尔**: 你希望在未来的Python版本中看到哪些变化？'
- en: '**Coghlan**: I''d like to see better tools for working with partially structured
    hierarchical data, but in a way that preserves Python''s reputation as executable
    pseudo code. I''d also like to continue reducing the discrepancies between what
    can be done with extension modules, and what specifically requires a Python source
    module.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**科格兰**: 我希望看到更好的工具来处理部分结构化的分层数据，但方式要保留Python作为可执行伪代码的声誉。我还希望继续减少使用扩展模块可以做到的事情和具体需要Python源模块的事情之间的差异。'
- en: Finally, I'd like to see better support for protected memory management models,
    where rather than aiming to serve as a security boundary, we're instead providing
    memory separation as a way to assist with maintaining the correctness of concurrent
    code. CPython's subinterpreter feature already provides this to some degree, but
    that capability currently has a lot of usability challenges, which Eric Snow is
    looking to address.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我希望看到对受保护内存管理模型的支持得到改善，而不是旨在作为安全边界，而是提供内存分离作为辅助维护并发代码正确性的方式。CPython的子解释器功能已经在某种程度上提供了这种支持，但该功能目前存在许多可用性挑战，埃里克·斯诺正在努力解决这些问题。
- en: '**Driscoll**: Well good! So let''s pretend that I want to become a core developer
    like you. What would I need to do to actually become one?'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**德里斯科尔**: 好啊！那么让我们假设我想成为像你一样的核心开发者。我实际上需要做什么才能成为核心开发者？'
- en: '**Coghlan**: So one of the most important things is to figure out why you want
    to become a core developer. You need the answer to that question because there
    are going to be inevitable frustrations where you ask yourself: "Why the hell
    am I doing this?!"'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**科格兰**: 其中最重要的一件事是要弄清楚你为什么想成为核心开发者。你需要回答这个问题，因为在不可避免的不满中，你会问自己：“我究竟为什么要做这件事？！”'
- en: If you don't know what your motivations are, then that's going to be a problem!
    Nobody else can answer the question for you. Having got past that point, the main
    thing about becoming a core developer is that a lot of it's actually about trust
    and earning trust.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不知道自己的动机是什么，那么这将会成为一个问题！没有人能为你回答这个问题。过了这个阶段，成为核心开发者最主要的是，这实际上很多都是关于信任和赢得信任。
- en: '**Nick Coghlan: ''The main thing about becoming a core developer is that a
    lot of it''s actually about trust and earning trust.''**'
  id: totrans-54
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**尼克·科根：**“成为核心开发者最主要的是，这实际上很多都是关于信任和赢得信任。”'
- en: It's a case of contributing, so as core reviewers we're basically there saying,
    "Do we want to accept this change and maintain it into the future? Can we give
    a good answer about why we have accepted the change, if later asked?"
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个贡献的问题，所以作为核心审查员，我们基本上在那里说，“我们是否想接受这个变化并将其维护到未来？如果我们后来被问及，我们能否给出一个关于我们为什么接受这个变化的良好答案？”
- en: What we're looking for when nominating new core developers and core reviewers
    is someone whose ability we trust to make good judgements. We want them to say,
    "Yes, this is a suitable change that will, on balance, make life better for future
    Python users."
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们提名新的核心开发者时，我们寻找的是我们信任其能够做出良好判断的人。我们希望他们能说，“是的，这是一个合适的变更，从整体上讲，将使未来的Python用户的生活变得更好。”
- en: Programming language design is a game of trade-offs. If you try to optimize
    for everything at once, then you end up optimizing for nothing. So there are a
    lot of things that have emerged over time as the trade-offs that make something
    Pythonic. It becomes a matter of understanding whether you can decide something
    on your own, or whether you need to take a problem to Python-Dev for discussion.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 编程语言设计是一场权衡的游戏。如果你试图一次性优化所有事情，那么你最终什么都没有优化。所以随着时间的推移，出现了很多权衡，使某些事情变得像Python一样。这变成了一个问题，即你是否可以自己做出决定，或者你是否需要将问题带到Python-Dev进行讨论。
- en: '**Nick Coghlan: ''Programming language design is a game of trade-offs. If you
    try to optimize for everything at once, then you end up optimizing for nothing.''**'
  id: totrans-58
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**尼克·科根：**“编程语言设计是一场权衡的游戏。如果你试图一次性优化所有事情，那么你最终什么都没有优化。”'
- en: Then there is a final level of escalation, when we say, "This proposal is tricky
    enough and there are enough subtleties here. There is enough potential controversy
    here that we should escalate this problem to become a full Python Enhancement
    Proposal and thrash out the details, before doing anything else." It's ultimately
    a core developer that makes the decision about where in that spectrum a particular
    change lies.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然后有一个最终的升级级别，当我们说，“这个提案很棘手，这里有很多微妙之处。这里有足够的潜在争议，我们应该将这个问题升级为一个完整的Python增强提案，并详细讨论细节，然后再做其他任何事情。”最终是核心开发者决定一个特定的变化位于那个光谱的哪个位置。
- en: '**Nick Coghlan: ''It''s ultimately a core developer that makes the decision
    about where in that spectrum a particular change lies.''**'
  id: totrans-60
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**尼克·科根：**“最终是核心开发者决定一个特定的变化位于那个光谱的哪个位置。”'
- en: '**Driscoll**: How does a core developer go about making that decision?'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**德里斯科尔：**核心开发者是如何做出那个决定的？'
- en: '**Coghlan**: Well, bug fixes are usually pretty straightforward because we
    know something is wrong. Even with a bug fix though, it''s sometimes confusing.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**科根：**嗯，错误修复通常相当直接，因为我们知道有些东西是错误的。即使是在错误修复的情况下，有时也会让人困惑。'
- en: We have three sources of truth, because we have what the reference interpreter
    does, what the test suite says it does, and what the documentation says it does.
    When all three of those are in agreement, then you know that there is consistency
    with what you are doing.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有三个真理来源，因为我们有参考解释器所做的工作，测试套件所说的，以及文档所说的。当这三个都达成一致时，你就知道你所做的是一致的。
- en: Where things start becoming more of a matter of design judgment is when the
    interpreter does something, and the test suite and the docs are silent on it.
    That case just isn't tested, and isn't documented as doing anything in particular.
    Then the other case is when the documentation says one thing, but the tests and
    the implementation say something different. In those cases, you have to say, "Well,
    is the documentation right and it's a bug, or are the docs just wrong?"
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当解释器做了某事，而测试套件和文档对此保持沉默时，事情开始更多地成为设计判断的问题。那种情况根本就没有被测试，也没有记录为做了任何特别的事情。然后另一种情况是，文档说了一件事，但测试和实现说的是另一件事。在这些情况下，你必须说，“嗯，是文档正确并且是一个错误，还是文档只是错了？”
- en: Those are the kinds of things that you get to do as a core developer. Whereas
    when you're contributor, you just want to get your ideas in. That's still a question
    of trust management, but what you're trying to do is persuade reviewers that your
    change is worth making. So yeah, it's certainly interesting!
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 那些是你作为一个核心开发者能够做的事情。而当你是一个贡献者时，你只是希望把自己的想法提出来。这仍然是一个信任管理的问题，但你试图做的是说服审阅者你的改动是值得进行的。所以，是的，这确实很有趣！
- en: You need to understand what becoming a core developer entails, and why it's
    something you want. In terms of the practical mechanics of the role, there's the
    Dev Guide that Brett Cannon originally wrote with BSF funding. The Dev Guide has
    been maintained and enhanced over time and it explains the difference between
    being a core developer and being a contributor to CPython.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要理解成为核心开发者意味着什么，以及为什么这是你想要的。从角色的实际操作机制来看，有由布赖特·卡农最初用BSF资金编写的开发者指南。开发者指南随着时间的推移得到了维护和增强，它解释了成为核心开发者与成为CPython贡献者之间的区别。
- en: '**Nick Coghlan: ''There are extra responsibilities that come with being a core
    developer.''**'
  id: totrans-67
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**尼克·科根：''作为一个核心开发者，你会有额外的责任。''**'
- en: There are extra responsibilities that come with being a core developer. The
    role includes working with issues, working with the reviewer, understanding the
    review process, discussing things on the mailing lists and making design decisions.
    You end up dealing with the inevitable frustrations of actually working on such
    a big project. The core mentorship mailing list can also be useful, depending
    on the kind of person you are.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个核心开发者，你会有额外的责任。这个角色包括处理问题、与审阅者合作、理解审阅流程、在邮件列表上讨论事情以及做出设计决策。你最终会处理在这样一个大项目上工作的不可避免的不满。根据你是什么样的人，核心导师邮件列表也可能很有用。
- en: '**Driscoll**: So I''ve always been interested in Python Enhancement Proposals.
    Could you describe the process of how they get created and accepted?'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**德里斯科尔：所以我一直对Python增强提案很感兴趣。你能描述一下它们是如何被创建和接受的流程吗？**'
- en: '**Coghlan**: Yes, so there are two different flows that the Python Enhancement
    Proposals (PEPs) can go through.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**科根：是的，所以Python增强提案（PEPs）可以通过两种不同的流程进行。**'
- en: '**Nick Coghlan: ''One flow is when a core developer proposes a change that
    we know we want to make, but we also know that this change will be big and complex.''**'
  id: totrans-71
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**尼克·科根：''有一种情况是一个核心开发者提出一个我们知道我们想要进行的改动，但我们也知道这个改动将会很大且复杂。我们知道不需要任何人告诉我们，这个改动需要成为一个PEP。所以在这种情况下，我们通常会先写一个PEP，并将PEP提交到PEPs仓库。''**'
- en: One flow is when a core developer proposes a change that we know we want to
    make, but we also know that this change will be big and complex. We know without
    anybody telling us that this change needs to be a PEP. So in those cases, we'll
    often just start by writing the PEP and committing the PEP to the PEPs repo.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 一种情况是一个核心开发者提出一个我们知道我们想要进行的改动，但我们也知道这个改动将会很大且复杂。我们知道不需要任何人告诉我们，这个改动需要成为一个PEP。所以在这种情况下，我们通常会先写一个PEP，并将PEP提交到PEPs仓库。
- en: We will then start the discussion on Python-ideas by saying, "Hey, I've written
    a new PEP proposing this, and here is why." Discussions basically just start at
    that level. Core developers manage the PEP process, because we've been through
    it a few times and we know when a change is big enough to qualify.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在Python-ideas上开始讨论，说：“嘿，我写了一个新的PEP，提出了这个，这是原因。”讨论基本上就是从那个层面开始的。核心开发者管理PEP流程，因为我们已经经历了几次，我们知道什么时候一个改动足够大，可以成为PEP。
- en: For other PEPs, the usual point of genesis is when somebody comes to Python-ideas
    with a suggestion. This suggestion will have been kicked around as a Python-ideas
    thread for a bit. People will then have said, "You know what, this actually sounds
    like it could potentially be a good idea!" The decision is then made to turn the
    idea into a full PEP and propose the idea that way, rather than just submitting
    it as an issue on the issue tracker.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他PEP（Python增强提案），通常的起点是有人带着一个建议来到Python-ideas。这个建议已经作为一个Python-ideas线程讨论了一段时间。然后人们会说：“你知道什么，这实际上听起来可能是一个好主意！”然后决定将这个想法变成一个完整的PEP，并通过这种方式提出这个想法，而不是仅仅在问题跟踪器上提交为一个问题。
- en: That does actually remind me of the third way that PEPs happen. They can come
    out of discussions on the issue tracker when we definitely know we want to make
    a change, but there are lots of niggly details. We write a PEP, thrash out the
    details, and then use that to drive how we implement the idea.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上让我想起了PEP发生的第三种方式。它们可以从问题跟踪器上的讨论中产生，当我们确实知道我们想要进行改动，但有很多小细节。我们写一个PEP，讨论细节，然后使用它来推动我们如何实现这个想法。
- en: '**Nick Coghlan: ''We write a PEP, thrash out the details, and then use that
    to drive how we implement the idea.''**'
  id: totrans-76
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**尼克·科格兰**：“我们编写一个PEP，讨论细节，然后使用它来推动我们的想法的实施。”'
- en: '**Driscoll**: So are these changes just discussed until they eventually get
    ironed out, and then accepted or rejected?'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**德里斯科尔**：那么这些变化只是讨论，直到它们最终被解决，然后被接受或拒绝吗？'
- en: '**Coghlan**: It depends on the proposal. With some proposals, the change itself
    is not controversial, but the details just need thrashing out.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**科格兰**：这取决于提议。有些提议本身并不具有争议性，但细节需要进一步讨论。'
- en: Those proposals will usually go through some discussion on Python-ideas and
    Python-Dev. The decision will then be made to stop thrashing out the idea and
    start implementing it. The proposal becomes an accepted PEP and eventually goes
    through to final.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这些提议通常会经过Python-ideas和Python-Dev的一些讨论。然后，将做出决定停止讨论这个想法，并开始实施它。这个提议成为了一个被接受的PEP，并最终进入最终阶段。
- en: Some proposals are more borderline and we put a question to Python-Dev about
    whether they are in fact a good idea. We do actually have a proposal open at the
    moment around the null coalescing operator. We genuinely don't know if we want
    to proceed. This PEP would make the language more complex, because it's a cryptic
    syntax that people would have to learn and understand. So that's the main argument
    against the idea. But on the argument in favor, you're saying, "Well, this is
    a pattern that comes up fairly often in data manipulation pipelines."
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 有些提议更接近边缘，我们向Python-Dev提出了一个问题，即它们是否真的是一个好主意。我们目前确实有一个关于空合并运算符的提议。我们真的不知道我们是否想继续下去。这个PEP会使语言更加复杂，因为它是一种需要学习和理解的晦涩语法。所以这是反对这个想法的主要论据。但在支持这个论据时，你说：“嗯，这是一个在数据处理管道中相当常见的模式。”
- en: So that PEP is still in discussion, until it does get to the point of finally
    being put to Python-Dev as a yes or no question. Then the decision will be made
    that yes we definitely want to proceed, or no we don't, unless something changes.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这个PEP仍在讨论中，直到它最终被提交给Python-Dev作为一个是或否的问题。然后，将做出决定，要么我们确实想继续下去，要么我们不，除非有变化。
- en: '**Nick Coghlan: ''Very occasionally, you do get PEPs that are written specifically
    to be rejected.''**'
  id: totrans-82
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**尼克·科格兰**：“非常偶尔，你会得到一些专门写成被拒绝的PEP。”'
- en: Very occasionally, you do get PEPs that are written specifically to be rejected.
    In those cases, an idea keeps coming up, but the arguments against it have never
    been clearly documented anywhere. So someone is just taking the time to write
    down the idea and write down all the reasons that we rejected the PEP, before
    saying, "Right! I'm posting this as a rejected PEP, to say this is why we don't
    do this". That makes me think of some of the new stuff that I've seen in Python
    3.5 and 3.6, that was only partially accepted and classed as provisional.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 非常偶尔，你会得到一些专门写成被拒绝的PEP。在这些情况下，一个想法会不断出现，但反对它的论据从未在任何地方被清楚地记录下来。所以有人只是花时间写下这个想法，并写下我们拒绝这个PEP的所有原因，然后说：“好吧！我正在发布这个被拒绝的PEP，来说明我们为什么不做这件事。”这让我想到了我在Python
    3.5和3.6中看到的一些新东西，这些只被部分接受，并被归类为临时。
- en: '**Driscoll**: So is that slightly different? Does that mean that people have
    agreed enough that they want to add something, but they may not keep it?'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**德里斯科尔**：那么这略有不同吗？这意味着人们已经足够同意，他们想添加一些内容，但他们可能不会保留它吗？'
- en: '**Coghlan**: Yes, so we got caught a couple of times when we accepted a change,
    and the new API, and immediately put it under our standard backwards compatibility
    guarantee.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**科格兰**：是的，所以我们接受了一些变更，并立即将其纳入我们的标准向后兼容性保证中，结果我们遇到了几次麻烦。'
- en: What we ended up doing was painting ourselves into a corner. We were stuck supporting
    an API that actually wasn't very good for the problem it was aiming to solve.
    We were getting these suggestions and potential module additions that were clearly
    beneficial and clearly helpful for users. The problem was that we were not sure
    we had the API design details right.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终陷入的困境是把自己逼入了一个角落。我们陷入了支持一个实际上对它试图解决的问题并不好的API。我们收到了这些建议和潜在的模块添加，这些显然对用户是有益的，并且显然是有帮助的。问题是，我们不确定我们是否正确地设计了API的细节。
- en: '**Nick Coghlan: ''We were stuck supporting an API that actually wasn''t very
    good for the problem it was aiming to solve.''**'
  id: totrans-87
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**尼克·科格兰**：“我们陷入了支持一个实际上对它试图解决的问题并不好的API。”'
- en: We didn't want to put anything under our full standard library backwards compatibility
    guarantee, so we decided not to include the additions. This approach ended up
    being bad for everyone, because it kept things out of the standard library that
    really should have been in there.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不想将任何内容置于我们完整的标准库向后兼容性保证之下，所以我们决定不包含这些新增内容。这种方法最终对每个人都不利，因为它将本应包含在标准库中的内容排除在外。
- en: We also couldn't use that type of module to help us to improve other parts of
    the standard library. Honestly, one of the main ways that new building blocks
    get into the standard library is because we want to use them in other parts of
    the standard library. So there's a standard library `enum` type now, because we
    wanted `enum` types in things like the socket module.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也无法使用这种类型的模块来帮助我们改进标准库的其他部分。坦白说，新构建块进入标准库的主要方式之一是我们想在标准库的其他部分使用它们。所以现在有一个标准库的`enum`类型，因为我们想在像socket模块这样的东西中使用`enum`类型。
- en: The provisional PEP, which I think ended up being PEP 411, went through a few
    iterations. Basically PEP 411 was designed to give us that ability to accept modules
    that we're pretty confident we're going to keep, but we're not sure we have the
    API design details right yet.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为最终成为PEP 411的临时PEP经历了几次迭代。基本上，PEP 411是为了让我们能够接受我们相当有信心会保留的模块，但我们还不确定API设计细节是否正确。
- en: We leave a PEP as provisional for a couple of releases, to give ourselves the
    right to make breaking changes to the API if we mess something up. I think async
    I/O only just went non-provisional in Python 3.6.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将PEP作为临时提案保留几轮发布，以便在出现错误时，我们有权利对API进行破坏性更改。我认为异步I/O仅在Python 3.6中刚刚变为非临时。
- en: '**Nick Coghlan: ''We leave a PEP as provisional for a couple of releases, to
    give ourselves the right to make breaking changes to the API if we mess something
    up.''**'
  id: totrans-92
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**尼克·科根：**“我们将PEP作为临时提案保留几轮发布，以便在出现错误时，我们有权利对API进行破坏性更改。”'
- en: '**Driscoll**: So does leaving a PEP as provisional work well?'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**德里斯科尔**：那么将PEP作为临时提案是否有效？'
- en: '**Coghlan**: Yes, we''re actually really happy with how that''s worked out.
    It lets us give people that clear warning that a PEP is still a bit in flux. This
    lets users know that we''re still figuring out the details and if this bothers
    them, then they shouldn''t use that PEP yet.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**科根**：是的，我们实际上对它的运作效果非常满意。它让我们能够清楚地警告人们PEP仍然有些变动。这使用户知道我们仍在确定细节，如果这让他们感到困扰，那么他们就不应该使用这个PEP。'
- en: There was actually an interesting example recently for Python 3.6 with `pathlib`.
    So `pathlib` had been included as a provisional API and it had lots of interoperability
    problems with other standard library APIs that were expecting strings.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 最近有一个有趣的例子是Python 3.6中的`pathlib`。`pathlib`被作为一个临时API包含在内，它与期望字符串的其他标准库API存在许多互操作性问题。
- en: '**Nick Coghlan: ''For Python 3.6, pathlib had hit a crossroads.''**'
  id: totrans-96
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**尼克·科根：**“对于Python 3.6，`pathlib`遇到了十字路口。”**'
- en: For Python 3.6, `pathlib` had hit a crossroads and was either going to get taken
    out of the standard library again and pushed back to purely being a PyPI module,
    or the interoperability issues had to be fixed. That was the either/or decision
    that was before the core development team for Python 3.6.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Python 3.6，`pathlib`遇到了十字路口，要么再次从标准库中移除并推回纯PyPI模块，要么必须修复互操作性问题。这是Python 3.6核心开发团队面前的一个非此即彼的决定。
- en: This decision became the `os.path` protocol, or the `os.fspath` protocol and
    the path-like objects support, which is basically fixing the interoperability
    problem for `pathlib`. So this means that there are a lot of standard library
    APIs now that automatically accept path-like objects.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这个决定成为了`os.path`协议，或`os.fspath`协议以及路径对象支持，这基本上是修复了`pathlib`的互操作性问题。这意味着现在有很多标准库API会自动接受路径对象。
- en: '**Driscoll**: Alright, so what is the Python Packaging Authority?'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**德里斯科尔**：好的，那么Python打包权威机构是什么？'
- en: '**Coghlan**: So the Python Packaging Authority''s name actually started as
    a joke by the pip and virtualenv developers. They wanted a name for the development
    team that covered both projects. So they said, "Let''s call ourselves the Python
    Packaging Authority, because nobody expects the Python Packaging Authority!"'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**科根**：所以Python打包权威机构的名字实际上最初是pip和virtualenv开发者开的玩笑。他们想要一个涵盖这两个项目的开发团队的名称。所以他们说：“让我们称自己为Python打包权威机构，因为没有人会期待Python打包权威机构！”'
- en: Then, back in 2013, we were starting to actively try to bring more of the tools,
    like `setuptools` and `distutils`, into that space. The Python Packaging User
    Guide started bringing all that information together, to offer a more coherent
    and officially recommended way of doing things. We needed a name for that umbrella
    group too. We decided that the Python Packaging Authority was kind of cool as
    a name, so we could start bringing in more projects under that umbrella.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，回到2013年，我们开始积极尝试将更多工具，如`setuptools`和`distutils`，引入这个领域。Python打包用户指南开始将这些信息整合起来，以提供一种更连贯且官方推荐的做法。我们也需要一个名字来称呼这个范畴组。我们决定Python打包权威机构这个名字听起来挺酷的，所以我们可以开始将更多项目纳入这个范畴。
- en: '**Nick Coghlan: ''We decided that the Python Packaging Authority was kind of
    cool as a name, so we could start bringing in more projects under that umbrella.''**'
  id: totrans-102
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**尼克·科根：**“我们决定Python打包权威机构这个名字听起来挺酷的，所以我们可以开始将更多项目纳入这个范畴。”**'
- en: Basically, the Python Packaging Authority occupies a role around packaging tools
    and interoperability standards, that's similar to the role that core developers
    play in relation to Python as a whole. While there's some overlap between people
    who are interested in programming language design and people who are interested
    in software distribution design, there are a lot of people who fall on one side
    or the other. Those people aren't the least bit interested in the other aspects.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，Python打包权威机构在打包工具和互操作性标准方面扮演着一种角色，这与核心开发者与Python整体的关系类似。虽然对编程语言设计和软件分发设计感兴趣的人之间有一些重叠，但很多人更倾向于其中的一边。这些人对于另一方面的内容并不感兴趣。
- en: Separating the two types of people means that anyone who cares about both types
    of design can participate in both subcommunities. But we're not constantly trying
    to explain the complexities of software distribution to language designers and
    vice versa. I think this split has made people a lot happier in general. It's
    nice to be in a group that you understand. I like packaging, but I like Python
    too. So I'm kind of torn on which one I'd probably fall under. I'd probably want
    to work on Python and the Python Packaging Authority too.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 将这两种类型的人分开意味着任何关心这两种设计类型的人都可以参与这两个子社区。但我们并不是一直在试图向语言设计师解释软件分发的复杂性，反之亦然。我认为这种划分使人们普遍感到更快乐。能在一个你理解的群体中是很不错的。我喜欢打包，但也喜欢Python。所以我有点犹豫自己可能属于哪一类。我可能还想在Python和Python打包权威机构上工作。
- en: '**Nick Coghlan: ''I like packaging, but I like Python too. So I''m kind of
    torn on which one I''d probably fall under.''**'
  id: totrans-105
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**尼克·科根：**“我喜欢打包，但也喜欢Python。所以我有点犹豫自己可能属于哪一类。”**'
- en: '**Driscoll**: Python is one of the major languages being used in AI and machine
    learning. Why do you think this is?'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**德里科：**Python是AI和机器学习中使用的几种主要语言之一。你认为为什么Python会是这样？'
- en: '**Coghlan**: AI and machine learning are an interesting mix of exploratory
    interactive data analysis and heavy-duty number-crunching. CPython''s rich C API
    has led to Python serving as a ''glue'' language for interconnecting high performance
    components written in languages like C, C++, and Fortran.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**科根：**AI和机器学习是探索性交互数据分析与重型数值计算的有趣结合。CPython丰富的C API导致Python成为连接用C、C++和Fortran等语言编写的性能组件的“胶水”语言。'
- en: The scientific research community has been using Python that way for more than
    20 years (the first version of Numeric was released in 1995). This means that
    Python offers a unique hybrid of a flexible, yet easy-to-learn and general-purpose
    computing language, combined with a set of scientific computing libraries, developed
    for use in high-performance computing environments.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 科学研究界已经这样使用Python超过20年了（Numeric的第一个版本于1995年发布）。这意味着Python提供了一种独特的混合体，既灵活又易于学习，是一种通用计算语言，结合了一套为高性能计算环境开发使用的科学计算库。
- en: '**Driscoll**: What could be done to make Python a better language for AI and
    machine learning?'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**德里科：**“为了使Python成为更好的AI和机器学习语言，我们可以做些什么？”**'
- en: '**Coghlan**: On the ease of use side, there are still a lot of opportunities
    to make components more readily available to users, either through preconfigured
    freemium web services (like Google Colabatory or Microsoft Azure Notebooks), or
    locally through the Python and Conda packaging toolchains.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**科根：**在易用性方面，还有很多机会让组件更容易地提供给用户，无论是通过预配置的免费增值网络服务（如Google Colabatory或Microsoft
    Azure Notebooks），还是通过本地的Python和Conda打包工具链。'
- en: On the performance side, there are also a lot of unexplored opportunities to
    better optimize the CPython interpreter and the Cython static compiler (for example,
    Cython doesn't currently ship a shared dynamic runtime, so there's likely a lot
    of duplicated boilerplate code in generated modules, that not only makes them
    larger and slower to compile, but also slower to import at runtime).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在性能方面，还有许多未探索的机会来更好地优化 CPython 解释器和 Cython 静态编译器（例如，Cython 目前不提供共享动态运行时，因此生成的模块中可能存在大量的重复样板代码，这不仅使它们更大、编译速度更慢，而且在运行时导入也更快）。
- en: '**Driscoll**: So I noticed that you are a fellow blogger. How long have you
    been writing about Python and what made you decide to become a blogger?'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**德里斯科尔**: 所以我注意到你也是一个博主。你写了多久关于 Python 的内容？是什么让你决定成为一名博主的？'
- en: '**Coghlan**: It was probably around Python 3.3 that I started talking about
    programming stuff on my blog. Mostly, I find writing is a very useful aid to thinking.
    You''re forced to get an idea coherent enough to be readable. So that''s mainly
    the way that I still use the blog now. If there''s something in particular about
    Python that I want to reference later, then I write down my current thoughts.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**科格兰**: 大概是在 Python 3.3 的时候，我开始在我的博客上谈论编程相关的内容。大多数情况下，我发现写作是一种非常有用的思考辅助工具。你被迫使你的想法足够连贯以便于阅读。所以现在我还是主要用这种方式来使用博客。如果我对
    Python 的某个特定方面想要稍后引用，那么我会写下我的当前想法。'
- en: '**Driscoll**: In your opinion, is Python a good language to actually start
    learning programming with?'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**德里斯科尔**: 在你看来，Python 是一个适合实际开始学习编程的语言吗？'
- en: '**Coghlan**: I do recommend Python as a first text-based language. For a lot
    of people, starting with one of the plug-and-play languages is a good alternative
    if they want to get the basic concepts down.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**科格兰**: 我确实推荐 Python 作为一种基于文本的第一语言。对于很多人来说，如果他们想要掌握基本概念，从一种即插即用的语言开始是一个不错的选择。'
- en: '**Nick Coghlan: ''Once you want to get into full combinatorial programming,
    then Python''s a very good language.''**'
  id: totrans-116
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**尼克·科格兰：“一旦你想进入完整的组合编程，那么 Python 就是一个非常优秀的语言。”**'
- en: Once you want to get into full combinatorial programming, then Python's a very
    good language. The deliberate language design restrictions are not very bright.
    You cannot get them to parse very complicated action at a distance things. If
    you study linguistics, then you realize that the human brain also struggles to
    parse complicated at a distance things.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你想进入完整的组合编程，Python 就是一个非常优秀的语言。故意的语言设计限制并不十分明智。你不能让它们解析非常复杂的远程操作。如果你学习语言学，你就会意识到人类大脑也难以解析复杂的远程操作。
- en: So the advantage of Python is that you only need one token look ahead to understand
    the context of the thing you're currently looking at. You don't need to keep much
    in your head to understand what the code is trying to tell you. We try to keep
    things visible as to where different names are coming from. I think that makes
    a surprising amount of difference to how easy it is for people to fit ideas into
    their brain.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 所以 Python 的优势在于，你只需要向前看一个标记就能理解你当前正在查看的内容的上下文。你不需要在脑海中保留太多信息来理解代码试图告诉你的内容。我们试图使不同名称的来源可见。我认为这会对人们将想法融入大脑的难易程度产生很大的影响。
- en: I made a post several years ago about scripting languages and suitable complexity.
    If you look at a cookbook, or a work instruction guide, then you will find procedural
    instructions. The outer layer of a cookbook is very much procedural and sequential.
    Then the subfunctions and the objects are all kind of embedded within that framework.
    I think Python works well for people because it reflects how we interact with
    the world.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 几年前，我发表了一篇关于脚本语言和适宜复杂度的帖子。如果你查看一本菜谱或工作指导手册，你将找到程序性指令。菜谱的外层非常程序化和顺序化。然后子函数和对象都嵌入在这个框架中。我认为
    Python 对人们来说效果很好，因为它反映了我们与世界互动的方式。
- en: '**Nick Coghlan: ''I think Python works well for people because it reflects
    how we interact with the world.''**'
  id: totrans-120
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**尼克·科格兰：“我认为 Python 对人们来说效果很好，因为它反映了我们与世界互动的方式。”**'
- en: '**Driscoll**: Could you explain a little more about why Python works so well?'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**德里斯科尔**: 你能更详细地解释一下为什么 Python 工作得如此好吗？'
- en: '**Coghlan**: Sure, we do things in sequence. Starting procedurally as your
    foundation, and then layering all of your other things on top, as you need them,
    makes a lot of sense.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**科格兰**: 当然，我们按顺序做事。从程序性开始作为你的基础，然后根据需要，将其他所有东西层层叠加，这样做是非常有意义的。'
- en: Object-oriented programming, functional programming and event-based programming
    are all techniques that we have come up with to manage complexity. Whichever one
    of them you choose, as your fundamental organizing principle for your language,
    then sets the minimum level of complexity for what you do.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程、函数式编程和基于事件的编程都是我们为了管理复杂性而提出的技术。无论你选择哪一种，作为你语言的基本组织原则，都将设定你所做事情的最小复杂度。
- en: It's really interesting to talk to people that teach with robotics and the embodied
    computing type environment. When you teach that way, starting with objects is
    a good way to go. Embodied computing people have that natural ability to say,
    "That robot sitting on my desk corresponds to the class 'Robot' in my program."
    They can do that visual correlation.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 与那些使用机器人技术和具身计算类型环境进行教学的人交谈非常有趣。当你这样教学时，从对象开始是一个不错的选择。具身计算的人有那种自然的能力，可以说：“我桌子上坐着的机器人对应于我程序中的‘Robot’类。”他们可以进行这种视觉关联。
- en: I think it's the case that procedural by default really does match the way cookbooks
    and instructions are written. That is good for lowering barriers to entry but,
    at the same time, Python is a language that can grow with you. Python has all
    the tools to do mathematical programming, object-oriented programming and functional
    programming.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为默认情况下，过程式编程确实与烹饪书和说明书的编写方式相匹配。这有助于降低入门门槛，但与此同时，Python 是一种可以与你一起成长的编程语言。Python
    拥有进行数学编程、面向对象编程和函数式编程的所有工具。
- en: '**Nick Coghlan: ''Python is a language that can grow with you.''**'
  id: totrans-126
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**尼克·科格兰**：“Python 是一种可以与你一起成长的编程语言。”'
- en: You can use Python based on the kinds of problems that you have. When you start
    learning more about particular aspects of Python, then you can use that as a launching
    point to get into languages that specialize in a particular area. So you can use
    Python to launch into Haskell (functional programming), Java or C#.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以根据你遇到的问题使用 Python。当你开始更深入地了解 Python 的特定方面时，你可以利用这一点作为跳板，进入专注于特定领域的语言。因此，你可以使用
    Python 来进入 Haskell（函数式编程）、Java 或 C#。
- en: '**Driscoll**: So let''s pretend that I know all the basics of Python and now
    I want to enhance my understanding of the language. What should I do?'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**德里斯科尔**：所以，让我们假设我已经了解了 Python 的所有基础知识，现在我想增强我对这种语言的理解。我应该怎么做？'
- en: '**Coghlan**: The important question to ask yourself at this point is how you
    learn. So for example, for myself, I figured out that I''m very much about needs-based
    learning.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**科格兰**：在这个阶段，你需要问自己的重要问题是你是如何学习的。例如，对我来说，我发现我非常注重基于需求的学习。'
- en: '**Nick Coghlan: ''I learned new programming techniques and new libraries in
    order to solve a problem.''**'
  id: totrans-130
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**尼克·科格兰**：“我学习新的编程技术和新的库是为了解决问题。”'
- en: I don't do well learning things just for the sake of learning them. I learn
    new programming techniques and new libraries in order to solve a problem. In my
    case, I find the problem I'm interested in solving and then learn whatever I need
    to do to solve that.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我并不擅长为了学习而学习。我学习新的编程技术和新的库是为了解决问题。在我的情况下，我会找到我感兴趣解决的问题，然后学习我需要做的任何事情来解决它。
- en: In terms of learning more, Allison Kaptur has written some quite good stuff.
    We've started adding a section to the Dev Guide about diving into internals. One
    useful trick can be to look at something you use every day, particularly an open
    source library, and just start digging into the code.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习更多方面，艾莉森·卡普图已经写了一些相当不错的内容。我们已经开始在开发指南中添加一个关于深入了解内部结构的章节。一个有用的技巧是看看你每天都会用到的东西，尤其是开源库，然后开始深入研究代码。
- en: '**Nick Coghlan: ''Look at something you use every day, particularly an open
    source library, and just start digging into the code.''**'
  id: totrans-133
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**尼克·科格兰**：“看看你每天都会用到的东西，尤其是开源库，然后开始深入研究代码。”'
- en: So in the standard library, there will actually be links to the source code
    from the standard library module documentation. Actually just going and reading
    that, and trying to figure out why certain things are done, can be useful.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在标准库中，实际上会有从标准库模块文档到源代码的链接。实际上，只是去阅读它，并试图弄清楚为什么某些事情被这样做，可能会有所帮助。
- en: That reminds me of another interesting project called Python Tutor (pythontutor.com).
    Python Tutor is a code visualizer or a behavioral visualizer. As you work through
    the code, Python Tutor has a little system model that it updates progressively,
    explaining what's going on.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这让我想起了另一个有趣的项目，叫做 Python Tutor（pythontutor.com）。Python Tutor 是一个代码可视化器或行为可视化器。当你通过代码工作时，Python
    Tutor 有一个逐步更新的小系统模型，解释正在发生的事情。
- en: One strategy, that I know some people have certainly found useful, is trying
    to change things, not because they actually want to make a change, but just to
    learn the mechanics of what's involved.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 一种策略，我知道有些人肯定觉得很有用，就是试图改变事物，不是因为它们实际上想要做出改变，而是为了学习涉及其中的机制。
- en: '**Driscoll**: What are you most excited about in Python today?'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**德里斯科尔**：你对今天的 Python 最兴奋的是什么？'
- en: '**Coghlan**: I''ll give a split answer here, as my professional and personal
    perspectives on the question are slightly different.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**科格兰**：我会给出一个分裂的回答，因为我对这个问题的专业和个人观点略有不同。'
- en: 'In a lot of ways, Python has done to the Linux ecosystem what the Linux ecosystem
    did to enterprise organizations in general: become ubiquitous without anyone really
    bothering to tell executive management about it. This means that everything we''ve
    achieved so far has been done primarily through the efforts of the volunteer community
    contributors, with only occasional and intermittent investments from large commercial
    and institutional users.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在很多方面，Python 对 Linux 生态系统所做的一切，就像 Linux 生态系统对一般企业组织所做的那样：无处不在，却没有人真正费心去告诉管理层。这意味着我们迄今为止所取得的一切成就，主要是通过志愿者社区贡献者的努力实现的，只有大型商业和机构用户偶尔和间歇性的投资。
- en: '**Nick Coghlan: ''Everything we''ve achieved so far has been done primarily
    through the efforts of the volunteer community contributors.''**'
  id: totrans-140
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**尼克·科格兰**：“我们迄今为止所取得的一切成就，主要是通过志愿者社区贡献者的努力实现的。”'
- en: So professionally, the thing that most excites me is the fact that the increase
    in the use of AI and machine learning techniques in business software development
    is prompting a lot of organizations to realize that there's more to the world
    of software development than the current enterprise incumbents of C, C++, Java,
    and C#.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，从职业角度来看，最让我兴奋的是，AI 和机器学习技术在商业软件开发中的使用增加，促使许多组织意识到，软件开发的世界远不止当前的 C、C++、Java
    和 C# 的企业巨头。
- en: This has been most clearly visible in recent years through IEEE Spectrum's annual
    multi-data-source language ranking, where Python started out, in 2014, at the
    edge of the top five (with C#), but has steadily climbed through those rankings,
    reaching first place in the 2017 edition of the survey.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这在近年来通过 IEEE Spectrum 的年度多数据源语言排名中表现得最为明显，Python 在 2014 年开始时位于前五名边缘（与 C# 一起），但稳步攀升，在
    2017 年的调查中达到了第一名。
- en: Personally, the thing that most excites me is the way we're getting teachers
    and other educators directly involved in the open source Python community. Prompted
    by an excellent keynote from James Curran at PyCon Australia 2014, and the Education
    Track at PyCon UK, I founded the PyCon Australia Education Seminar in 2015, and
    we've been running that every year since.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 个人而言，最让我兴奋的是我们正在让教师和其他教育者直接参与到开源 Python 社区中来。受到 2014 年 PyCon 澳大利亚上詹姆斯·柯兰的精彩主题演讲以及
    PyCon 英国教育轨道的启发，我在 2015 年成立了 PyCon 澳大利亚教育研讨会，并且从那以后每年都在举办。
- en: A lot of Python user groups also have a specific focus on adult education and
    offer workshops for folks either looking to improve their computing skills in
    their current profession, or contemplating a career change into software development.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 Python 用户组也专注于成人教育，并为那些希望提高他们在当前职业中的计算技能，或者考虑转向软件开发职业的人提供研讨会。
- en: '**Driscoll**: Thank you, Nick Coghlan.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**德里斯科尔**：谢谢你，尼克·科格兰。'
