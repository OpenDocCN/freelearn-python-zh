- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Deploying and Monitoring Your Application
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署和监控您的应用程序
- en: In the previous chapter, we built the frontend of our app, thereby completing
    it as a useable tool. However, while we are able to use it locally, no other users
    would be able to. Therefore, in this chapter, we’ll deploy our application and
    make it available via a public domain name, [tozo.dev](http://tozo.dev). We’ll
    also ensure that we are monitoring the app so that we can quickly fix any issues.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们构建了应用程序的前端，从而使其成为一个可用的工具。然而，尽管我们可以在本地使用它，但其他用户将无法使用。因此，在本章中，我们将部署我们的应用程序，并通过一个公开的域名[tozo.dev](http://tozo.dev)使其可用。我们还将确保我们正在监控应用程序，以便我们可以快速修复任何问题。
- en: So, in this chapter, you’ll learn how to build the infrastructure in AWS for
    any Docker containerized app that needs a database; this infrastructure will be
    able to scale to very high loads without major changes. You’ll also learn how
    to set up a **domain name system** (**DNS**) and HTTPS for your domain, both of
    which are applicable to any website or application. Finally, you’ll learn the
    importance of monitoring and how to do so easily.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章中，你将学习如何为任何需要数据库的Docker容器化应用程序在AWS中构建基础设施；该基础设施将能够扩展到非常高的负载而无需进行重大更改。你还将学习如何为你的域名设置**域名系统**（**DNS**）和HTTPS，这两者都适用于任何网站或应用程序。最后，你将了解监控的重要性以及如何轻松地进行监控。
- en: For our app to be accessible via a public domain name, it will need to be running
    on a system that is always accessible via the internet. This could be any system,
    including our local computer. However, the system needs to be continuously running
    and accessible via a stable IP address. For this reason, it is much better to
    pay for a dedicated system managed by AWS.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的应用程序可以通过公开域名访问，它需要在始终可以通过互联网访问的系统上运行。这可能可以是任何系统，包括我们的本地计算机。然而，该系统需要持续运行并通过稳定的IP地址访问。因此，支付由AWS管理的专用系统费用会更好。
- en: AWS costs
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: AWS费用
- en: The AWS infrastructure built in this chapter will cost approximately $20 per
    month to run without the free tier. It will be cheaper (but not free) if you are
    able to use the free tier. Alternatively, AWS has a number of startup credit programs
    you may be eligible for.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章构建的AWS基础设施在无免费层的情况下运行成本约为每月20美元。如果你能够使用免费层，这将更便宜（但不是免费的）。另外，AWS有几个创业信用计划，你可能符合资格。
- en: If you want to stop paying, you will need to remove the infrastructure, which
    can be done by deleting the `resource` definitions and running `terraform apply`.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想停止付费，你需要移除基础设施，这可以通过删除`resource`定义并运行`terraform apply`来完成。
- en: Once we have paid for a remote system, we could configure it to run our app
    directly, as we have our local system. However, we will use a containerized infrastructure
    as it is easier to configure the container to run our app than to configure the
    remote system.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们为远程系统付费，我们可以将其配置为直接运行我们的应用程序，就像我们的本地系统一样。然而，我们将使用容器化基础设施，因为配置容器以运行我们的应用程序比配置远程系统更容易。
- en: 'So, in this chapter, we will cover the following topics:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章中，我们将涵盖以下主题：
- en: Making the app production-ready
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使应用程序准备就绪以投入生产
- en: Deploying to AWS
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署到AWS
- en: Serving on a domain
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在域名上提供服务
- en: Sending production emails
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送生产电子邮件
- en: Monitoring production
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控生产
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To follow the development in this chapter using the companion repository, [https://github.com/pgjones/tozo](https://github.com/pgjones/tozo),
    see the commits between the `r1-ch6-start` and `r1-ch6-end` tags.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用配套仓库跟踪本章的发展，请访问[https://github.com/pgjones/tozo](https://github.com/pgjones/tozo)，查看`r1-ch6-start`和`r1-ch6-end`标签之间的提交。
- en: Making the app production-ready
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使应用程序准备就绪以投入生产
- en: As our production infrastructure will run containers, we need to containerize
    our app. To do so, we’ll need to decide how to serve the frontend and backend,
    and how to build the container image.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的生产基础设施将运行容器，我们需要将我们的应用程序容器化。为此，我们需要决定如何提供前端和后端服务，以及如何构建容器镜像。
- en: Serving the frontend
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 前端服务
- en: So far in development, we’ve used `npm run start` to run a server that serves
    the frontend code. This is called **server-side rendering** (**SSR**), and we
    could continue to do this in production. However, it is much easier to utilize
    **client-side rendering** (**CSR**), as this does not require a dedicated frontend
    server. CSR works by building a bundle of frontend files that can be served by
    any server (rather than a dedicated frontend server), and we’ll use the backend
    server.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在开发过程中，我们使用 `npm run start` 来运行一个提供前端代码的服务器。这被称为 **服务器端渲染**（**SSR**），我们可以在生产环境中继续这样做。然而，利用
    **客户端渲染**（**CSR**）要容易得多，因为它不需要一个专门的前端服务器。CSR 通过构建一个可以由任何服务器（而不是专门的前端服务器）提供的文件包来实现，我们将使用后端服务器。
- en: 'To build the frontend bundle, we can use the `npm run build` command. This
    command creates a single HTML file (*frontend/build/index.xhtml*) and multiple
    static files (`css`, `js`, and `media`) in the following structure:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建前端包，我们可以使用 `npm run build` 命令。此命令创建一个单独的 HTML 文件 (*frontend/build/index.xhtml*)
    和多个静态文件（`css`、`js` 和 `media`）在以下结构中：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The static files, consisting of the files within the *frontend/build/static*
    folder, can be served by moving the files and structure to the *backend/src/backend/static*
    folder. Our backend will then serve these files automatically with paths matching
    the folder structure.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 静态文件，包括 *frontend/build/static* 文件夹内的文件，可以通过将文件和结构移动到 *backend/src/backend/static*
    文件夹来提供服务。然后，我们的后端将自动使用与文件夹结构匹配的路径提供这些文件。
- en: 'The remaining part of the bundle (i.e., the HTML file) will need to be served
    for any request that matches a page in the app. To do this, we first need a serving
    blueprint, which is created by adding the following to *backend/src/backend/blueprints/serving.py*:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 包的剩余部分（即 HTML 文件）需要为任何匹配应用中页面的请求提供服务。为此，我们首先需要一个服务蓝图，通过在 *backend/src/backend/blueprints/serving.py*
    中添加以下内容来创建它：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The blueprint then needs to be registered with the app, by adding the following
    to *backend/src/backend/run.py*:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 随后需要将蓝图注册到应用中，通过在 *backend/src/backend/run.py* 中添加以下内容：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As the backend has no knowledge regarding which paths match the pages on the
    frontend, it will have to serve the frontend for any paths that do not match backend
    API paths. This is done in Quart by using a `<path:path>` URL variable; so, add
    the following into *backend/src/backend/blueprints/serving.py*:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 由于后端没有关于哪些路径匹配前端页面的知识，它将为任何不匹配后端 API 路径的路径提供前端服务。这是通过 Quart 使用 `<path:path>`
    URL 变量完成的；因此，将以下内容添加到 *backend/src/backend/blueprints/serving.py* 中：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Finally, *frontend/build/index.xhtml* will need to be copied to *backend/src/backend/templates/index.xhtml*
    for the production app, as we will do when containerizing the app.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，需要将 *frontend/build/index.xhtml* 复制到 *backend/src/backend/templates/index.xhtml*
    以用于生产应用，就像我们在容器化应用时做的那样。
- en: As it is now possible to serve the frontend from the backend server, we can
    now focus on using a production-ready backend server.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 由于现在可以从后端服务器提供前端服务，我们现在可以专注于使用一个生产就绪的后端服务器。
- en: Serving the backend
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 后端服务
- en: So far in development, we’ve used `pdm run start` to run and serve the backend.
    This, however, is unsuitable for production as it starts a Hypercorn server configured
    for development (for example, it configures the server to output debugging information).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在开发过程中，我们使用 `pdm run start` 来运行和提供后端服务。然而，这不适合生产环境，因为它启动了一个为开发配置的 Hypercorn
    服务器（例如，它配置服务器输出调试信息）。
- en: Hypercorn
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Hypercorn
- en: Quart is a framework that requires a server to work. So far in development,
    we’ve been using Hypercorn as configured for development. Hypercorn is a Python
    server that supports HTTP/1, HTTP/2, and HTTP/3 in a performant manner and is
    recommended by Quart.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Quart 是一个需要服务器才能工作的框架。到目前为止，在开发过程中，我们一直使用为开发配置的 Hypercorn。Hypercorn 是一个支持 HTTP/1、HTTP/2
    和 HTTP/3 的 Python 服务器，以高效的方式运行，并由 Quart 推荐使用。
- en: 'We will configure Hypercorn for production usage using the following placed
    in *hypercorn.toml*:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下配置来为生产环境配置 Hypercorn，放置在 *hypercorn.toml* 中：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `accesslog` and `errorlog` configuration ensure that Hypercorn logs every
    request and error while it runs, which will help us understand what the server
    is doing. The `bind` configures Hypercorn to listen on the `8080` port, which
    we’ll direct network traffic to when we set up the production infrastructure in
    the next section.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`accesslog` 和 `errorlog` 配置确保 Hypercorn 在运行时记录每个请求和错误，这将帮助我们了解服务器正在做什么。`bind`
    配置 Hypercorn 监听 `8080` 端口，当我们设置下一节的生产基础设施时，我们将网络流量导向此端口。'
- en: 'The server can then be started in production via the following command:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，可以通过以下命令在生产环境中启动服务器：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now we know how to serve the backend in a production environment, we need to
    focus on how we install everything we need to do so.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何在生产环境中提供后端，我们需要关注如何安装我们为此所需的一切。
- en: Containerizing the app
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器化应用程序
- en: To run the app in production, we need all the app’s dependencies and the app’s
    code installed in the container. We will achieve this by building a container
    image with the dependencies installed and the code included.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要在生产环境中运行应用程序，我们需要在容器中安装应用程序的所有依赖项和代码。我们将通过构建一个包含已安装依赖项和包含代码的容器镜像来实现这一点。
- en: To build the image, we’ll use a Dockerfile as it is the clearest way to build
    an image. Specifically, we will use a multistage Dockerfile, with the first stage
    building the frontend, and the final stage installing and running the backend
    server.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建镜像，我们将使用Dockerfile，因为这是构建镜像最清晰的方式。具体来说，我们将使用多阶段Dockerfile，第一阶段构建前端，最终阶段安装和运行后端服务器。
- en: Docker terms
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Docker术语
- en: A **Dockerfile** is used with Docker to build a container image. The Dockerfile
    is an ordered list of commands, with each command producing a layer of the final
    image, and with each layer building upon the previous. The final image will need
    to include everything required to run the code contained within it. A running
    instance of the image is known as a **container**.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**Dockerfile** 与Docker一起用于构建容器镜像。Dockerfile是一个有序的命令列表，每个命令生成最终镜像的一层，每一层都是基于前一层构建的。最终的镜像需要包含运行其中代码所需的一切。运行实例的镜像被称为**容器**。'
- en: Building the frontend stage
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建前端阶段
- en: 'To build the frontend, we will need a system with NodeJS installed. As this
    is a common requirement, there are NodeJS base images we can use. Therefore, we
    can start by adding the following to *Dockerfile* to create a NodeJS-based stage
    called `frontend`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建前端，我们需要一个已安装NodeJS的系统。由于这是一个常见的要求，我们可以使用NodeJS基础镜像。因此，我们可以在**Dockerfile**中添加以下内容，以创建一个名为`frontend`的基于NodeJS的阶段：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, we need to create a working directory and install the frontend dependencies
    within it:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一个工作目录并在其中安装前端依赖项：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is best done before the code is copied into the image as the dependencies
    change less often than the code.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这最好在将代码复制到镜像之前完成，因为依赖项的变化频率低于代码。
- en: Dockerfile caching
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile缓存
- en: The Dockerfile is a sequence of commands with each command forming a layer in
    the final image. These layers are built in the order given in the Dockerfile and
    a change to any layer requires all the subsequent layers to be rebuilt with earlier
    layers being cached. Hence, it is best to put layers that rarely change before
    those that change often.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile是一系列命令，每个命令在最终镜像中形成一个层。这些层按照Dockerfile中给出的顺序构建，对任何层的更改都需要重建所有后续层，并且早期层将被缓存。因此，最好将很少改变的层放在经常改变的层之前。
- en: 'Finally, we can copy the frontend code we’ve written for our app into the image
    and build it with the following code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以将为我们应用程序编写的客户端代码复制到镜像中，并使用以下代码构建它：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We now have a complete frontend stage containing the built frontend. We’ll make
    use of this in the production image.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个包含构建好的前端的完整前端阶段。我们将在生产镜像中使用它。
- en: Building the production image
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建生产镜像
- en: 'The production image will be built as the second stage of the *Dockerfile*.
    This stage can also start from an existing base image, as systems with Python
    installed are also a common requirement. To do so the following should be added
    to the *Dockerfile*:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 生产镜像将在**Dockerfile**的第二个阶段构建。此阶段也可以从一个现有的基础镜像开始，因为安装了Python的系统也是一个常见的要求。为此，以下内容应添加到**Dockerfile**中：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, we need to add an `init` system to ensure that signals are correctly
    sent to our backend server as it runs in the Docker container. `dumb-init` is
    a popular solution and one I’ve used many times before. `dumb-init` is installed
    and configured with the following additions:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要添加一个`init`系统，以确保在Docker容器中运行时，正确地向我们的后端服务器发送信号。`dumb-init`是一个流行的解决方案，我之前多次使用过。`dumb-init`通过以下添加进行安装和配置：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can then configure Hypercorn to start when the image is run:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以配置Hypercorn在镜像运行时启动：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, we need to install the backend dependencies, which first requires that
    we install `pdm` and configure Python to work with it:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要安装后端依赖项，这首先需要我们安装`pdm`并配置Python以与之协同工作：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This allows us to install the backend dependencies using `pdm`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们使用`pdm`安装后端依赖项：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, we can include the built frontend from the frontend stage:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以从前端阶段包含构建好的前端：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Finally, we can copy the backend code into the image:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以将后端代码复制到镜像中：
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This gives us a complete image ready to use in production.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们提供了一个完整的镜像，可用于生产环境。
- en: 'To make the image more secure, we can alter the user that will run the server.
    By default, this is the `root` user that comes with admin privileges and access,
    whereas changing to `nobody` removes these privileges. We can do this by adding
    the following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使镜像更安全，我们可以更改将运行服务器的用户。默认情况下，这是带有管理权限和访问权限的`root`用户，而将用户更改为`nobody`则移除了这些权限。我们可以通过添加以下内容来完成此操作：
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As we’ve defined how to build a Docker image, we can now focus on building and
    deploying it.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经定义了如何构建Docker镜像，我们现在可以专注于构建和部署它。
- en: Deploying to AWS
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署到AWS
- en: To deploy our app, we need to build an infrastructure that runs containers and
    a database. The containers must be reachable from the public internet, and the
    database from the containers. This infrastructure is easily buildable with **AWS**,
    which we’ll use. However, in this book, we’ll use AWS services that have equivalents
    on other cloud providers if you wish to use a different provider.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 要部署我们的应用程序，我们需要构建一个运行容器和数据库的基础设施。容器必须可以从公共互联网访问，数据库必须可以从容器访问。这个基础设施很容易用**AWS**构建，我们将使用它。然而，在这本书中，我们将使用AWS服务，这些服务在其他云提供商上也有等效服务，如果您希望使用不同的提供商。
- en: 'To start, we need to create an AWS account (through this link: [aws.amazon.com](http://aws.amazon.com))
    using an email, password, and your card details. This account will be the root
    or superuser account; therefore, we will create an additional **identity and access
    management** (**IAM**) subaccount for Terraform to use. The IAM user is created
    via the **Add users** button on the IAM **Users** dashboard shown in *Figure 6.1*:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要使用电子邮件、密码和您的卡详情创建一个AWS账户（通过此链接：[aws.amazon.com](http://aws.amazon.com)）。这个账户将是根账户或超级用户账户；因此，我们将为Terraform创建一个额外的**身份和访问管理**（**IAM**）子账户。IAM用户是通过IAM
    **用户**仪表板上的**添加用户**按钮创建的，如图6.1所示：
- en: '![Figure 6.1: The IAM dashboard (with the Add users button) ](img/B18727_06_01.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图6.1：IAM仪表板（带有添加用户按钮）](img/B18727_06_01.jpg)'
- en: 'Figure 6.1: The IAM dashboard (with the Add users button)'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1：IAM仪表板（带有添加用户按钮）
- en: 'I will name the user `terraform` to indicate what it is used for. It should
    have programmatic access only and have the `AdministratorAccess` policy attached.
    Once created, an access key ID and secret access key will be shown; both need
    to be added as follows to *infrastructure/secrets.auto.tfvars*:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我将把这个用户命名为`terraform`，以表明它的用途。它应该只有程序性访问权限，并附加`AdministratorAccess`策略。一旦创建，将显示访问密钥ID和秘密访问密钥；两者都需要按照以下方式添加到`*infrastructure/secrets.auto.tfvars*`中：
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: I am using `abcd` as examples, which you need to replace with your own values.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我正在使用`abcd`作为示例，您需要将其替换为您自己的值。
- en: 'With your credentials in place, we can start configuring Terraform to work
    with AWS. Firstly, add the AWS provider to Terraform by adding the following to
    the existing Terraform `required_providers` section in *infrastructure/main.tf*:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好凭证后，我们可以开始配置Terraform以与AWS协同工作。首先，通过在`*infrastructure/main.tf*`中现有的Terraform
    `required_providers`部分添加以下内容，将AWS提供者添加到Terraform中：
- en: '[PRE18]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: After making this change, `terraform init` will need to be run for the change
    to take effect.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 进行此更改后，需要运行`terraform init`以使更改生效。
- en: 'We can then configure the provider, which requires choosing a region to use.
    As I’m based in London, UK, I’ll be using `eu-west-2`, however, I recommend that
    you use whichever region is closest to your customers. This is done by adding
    the following to *infrastructure/aws.tf*:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以配置提供者，这需要选择一个要使用的区域。由于我位于英国伦敦，我将使用`eu-west-2`，然而，我建议您使用离您的客户最近的区域。这可以通过在`*infrastructure/aws.tf*`中添加以下内容来完成：
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We can now use Terraform to manage the AWS infrastructure, which means we can
    focus on what we want that infrastructure to be.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用Terraform来管理AWS基础设施，这意味着我们可以专注于我们希望该基础设施成为什么样子。
- en: Designing the production system
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计生产系统
- en: 'In [*Chapter 2*](B18727_02.xhtml#_idTextAnchor053), *Creating a Reusable Backend
    with Quart*, we decided to build a three-tier architecture where there is a backend
    API that communicates with the frontend and with a database. This means that in
    AWS, we need to be running the database, the backend in a container, and a load
    balancer to listen to incoming requests from the frontend. To do so, we can use
    the services and setup shown in *Figure 6.2*:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2: The intended AWS architecture ](img/Figure_6.2_NEW.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.2: The intended AWS architecture'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 'This architecture uses the following AWS services:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '**Relational Database Service** (**RDS**) to run a PostgreSQ database'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Elastic Container Service** (**ECS**) to run the app container'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Application Load Balancer** (**ALB**) to accept connections from the internet
    (frontend)'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition, we’ll use the **Fargate** variant of ECS as this means that we
    won’t need to manage the systems running the containers.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: By using these managed services, we can pay AWS to do most of the work of managing
    the servers, allowing us to focus on our app instead. We can now set up the networking
    to support this architecture.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the networking
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To build our architecture, we have to start at the foundation, which is the
    network. We need to define how the systems can communicate with one another. In
    *Figure 6.3*, you can see that we are aiming for a single **virtual private cloud**
    (**VPC**) with public and private subnets.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3: The intended network setup ](img/B18727_06_03.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.3: The intended network setup'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Crucially, the private subnets can only communicate with the public subnets,
    but not the internet directly. This means that we can place the database in the
    private subnets, and the app and ALB in the public subnets, thereby adding an
    additional layer of security that prevents unauthorized database access.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: VPC
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: A VPC is a virtual network containing resources. We’ll use a single VPC for
    all our resources.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: 'To build the network, we first need to create an AWS VPC for our systems by
    adding the following to *infrastructure/aws_network.tf*:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: CIDR notation
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'AWS uses `/`). IPv4 addresses consist of 4 bytes (each byte is 8 bits) with
    each byte written as a number separated by dots (`.`). The netmask number indicates
    how many leading bits of the trial address must match the given address to be
    considered part of the given range. The following examples show CIDR ranges:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '- `10.0.0.0/16` indicates that the first 16 bits (or the first two bytes) must
    match within this range (i.e., any address starting with `10.0` is in the range)'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '- `10.0.0.64/26` indicates that the first 26 bits or the first 3 bytes and
    then the first 2 bits of the final byte must match (i.e., any address between
    `10.0.0.64` and `10.0.0.128` (excluding `10.0.0.128`)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '- `0.0.0.0/0` means that any IP address matches'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: With this VPC setup, all the IP addresses we will use will be in the `10.0.0.0/16`
    CIDR block and hence will begin with `10.0`. This block is a conventional choice
    for AWS VPCs.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种 VPC 设置，我们将使用的所有 IP 地址都将位于 `10.0.0.0/16` CIDR 块中，因此将以 `10.0` 开头。这个块是 AWS
    VPC 的传统选择。
- en: We can now divide the VPC into subnets or subnetworks, as this allows us to
    restrict which subnets can communicate with each other and the public internet.
    Firstly, we’ll divide the VPC into public subnets in the CIDR block `10.0.0.0/24`
    and private subnets in `10.0.1.0/24`. I’ve chosen these as blocks as it makes
    the distinction very clear that any IP that starts with `10.0.0` will be public,
    and `10.0.1` will be private.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以将 VPC 划分为子网或子网络，因为这允许我们限制哪些子网可以相互通信以及与公共互联网通信。首先，我们将 VPC 划分为 CIDR 块 `10.0.0.0/24`
    中的公共子网和 `10.0.1.0/24` 中的私有子网。我选择这些块，因为它们非常清楚地表明以 `10.0.0` 开头的任何 IP 地址将是公共的，而 `10.0.1`
    将是私有的。
- en: 'As an AWS region is split into availability zones, we’ll create a public and
    a private subnet for each zone, with up to a total of four subnets. Four is the
    best number as it is represented by 2 bits and hence makes the CIDR ranges easier
    to express. The netmask for these subnets is therefore 26, as it is 24 plus the
    2 bits required. This is done by adding the following to *infrastructure/aws_network.tf*:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 AWS 区域被划分为可用区，我们将为每个区域创建一个公共子网和一个私有子网，总共可达四个子网。四个是最佳选择，因为它由 2 位表示，因此使得 CIDR
    范围更容易表达。因此，这些子网的子网掩码为 26，因为它等于 24 加上所需的 2 位。这是通过在 *infrastructure/aws_network.tf*
    中添加以下内容来完成的：
- en: '[PRE21]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Availability zones
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 可用区
- en: AWS Regions are split into multiple (usually three) **availability zones** (often
    called **AZs**). Each zone is a physical data center separated from the others
    such that if there was a failure of one zone (e.g., a fire), it would not affect
    the others. Placing our systems in multiple zones, therefore, gives more robustness
    against failures.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: AWS 区域被划分为多个（通常为三个）**可用区**（通常称为 **AZs**）。每个区域都是一个与其他区域物理隔离的数据中心，这样如果某个区域发生故障（例如，火灾），就不会影响到其他区域。因此，将我们的系统放置在多个区域中，可以提供更强的容错能力。
- en: 'As the *public* name suggests, we want systems in the public subnets to be
    able to communicate with the internet. This means that we need to add an internet
    gateway to the VPC and allow network traffic to route between it and the public
    subnets. This is done by adding the following to *infrastructure/aws_network.tf*:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如其 **公共** 名称所暗示的，我们希望公共子网中的系统能够与互联网进行通信。这意味着我们需要向 VPC 添加一个互联网网关，并允许网络流量在它和公共子网之间路由。这通过在
    *infrastructure/aws_network.tf* 中添加以下内容来完成：
- en: '[PRE22]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Finally, in terms of networking, we need a load balancer to accept connections
    from the internet and route them to the app containers. To begin, let’s add a
    security group for the load balancer that allows inbound (ingress) connections
    on ports `80` and `443` and any outbound (egress) connection; we do this in *infrastructure/aws_network.tf*:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在网络的方面，我们需要一个负载均衡器来接受来自互联网的连接并将它们路由到应用容器。首先，让我们为负载均衡器添加一个安全组，允许在端口 `80` 和
    `443` 上进行入站（入站）连接以及任何出站（出站）连接；我们在 *infrastructure/aws_network.tf* 中这样做：
- en: '[PRE23]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Protocols and ports
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 协议和端口
- en: By default, websites serve requests using TCP (the protocol) on port `80` for
    HTTP and port `443` for HTTPS. The ports can be changed, but this isn’t recommended
    as most users won’t understand how to do the matching change in their browser.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，网站使用 TCP（协议）在端口 `80` 上为 HTTP 请求提供服务，在端口 `443` 上为 HTTPS 请求提供服务。端口可以更改，但这样做并不推荐，因为大多数用户不会理解如何在他们的浏览器中进行匹配更改。
- en: The next version of HTTP, HTTP/3, will use QUIC over UDP as the protocol, with
    potentially any port the server defines. This technology is in its infancy at
    the moment though, and hence won’t be used in this book.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 的下一个版本，HTTP/3，将使用 UDP 作为协议，服务器定义的任何端口都可能被使用。然而，这项技术目前还处于起步阶段，因此不会在这本书中使用。
- en: 'The load balancer itself can now be added by adding the following to *infrastructure/aws_network.tf*:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以通过在 *infrastructure/aws_network.tf* 中添加以下内容来添加负载均衡器本身：
- en: '[PRE24]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Load balancing
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 负载均衡
- en: A load balancer will distribute requests across the target group in an attempt
    to balance the load experienced by each target in the target group. Therefore,
    it is possible to use multiple machines to serve the requests behind a single
    load balancer.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 负载均衡器将尝试在目标组中分配请求，以平衡目标组中每个目标所承受的负载。因此，可以使用多台机器来服务单个负载均衡器后面的请求。
- en: With the load balancer in place and ready, we can now start adding systems to
    the network, starting with the database.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在负载均衡器就位并准备就绪后，我们现在可以开始向网络中添加系统，从数据库开始。
- en: Adding a database
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加数据库
- en: 'We can now add a PostgreSQL database to the private subnets, and then via a
    security group, we can ensure that the database can only communicate with systems
    in the public subnets. This makes it harder for an attacker to gain access to
    the database as they are unable to access it directly. So, to do this, the following
    should be added to *infrastructure/aws_network.tf*:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将 PostgreSQL 数据库添加到私有子网中，然后通过安全组，我们可以确保数据库只能与公共子网中的系统通信。这使得攻击者更难直接访问数据库。因此，为了做到这一点，以下内容应添加到
    *infrastructure/aws_network.tf*：
- en: '[PRE25]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The database itself is created using the `aws_db_instance` Terraform resource,
    which requires quite a lot of configuration variables to be defined. What is given
    in the following code is a safe set of variables to run a database that counts
    in the AWS free tier. The following should be added to *infrastructure/aws.tf*:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库本身是通过 `aws_db_instance` Terraform 资源创建的，这需要定义相当多的配置变量。以下代码给出的是一组安全的变量，用于在
    AWS 免费层上运行数据库。以下内容应添加到 *infrastructure/aws.tf*：
- en: '[PRE26]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `db_password` should be added to *infrastructure/secrets.auto.tfvars* with
    a value ideally created by a password generator on a very strong setting (this
    password will never need to be memorized or typed).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`db_password` 应该添加到 *infrastructure/secrets.auto.tfvars* 中，其值最好由密码生成器在非常强的设置下创建（这个密码永远不需要记住或输入）。'
- en: As your app usage grows, I recommend that you change the value of `instance_class`
    to a larger machine, enable `multi_az` to ensure robustness in the case of an
    availability zone failure, and enable `storage_encrypted`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你的应用程序使用量的增长，我建议你将 `instance_class` 的值更改为更大的机器，启用 `multi_az` 以确保在可用区故障情况下的鲁棒性，并启用
    `storage_encrypted`。
- en: AWS web interface
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: AWS 网络界面
- en: In this book, we are intentionally defining all the infrastructure as code and
    ignoring the AWS web interface. This is best as it ensures that we can always
    restore the infrastructure to a known working state (by running `terraform apply`)
    and as it means we have an auditable history of changes. However, it is still
    very useful to use the web interface to inspect the infrastructure and check everything
    is as expected.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们故意将所有基础设施定义为代码，并忽略 AWS 网络界面。这样做最好，因为它确保我们可以始终通过运行 `terraform apply`
    来恢复基础设施到已知的工作状态，并且这意味着我们有一个可审计的变更历史。然而，使用网络界面检查基础设施并检查一切是否如预期仍然非常有用。
- en: After running `terraform apply`, you should see a database running in RDS, which
    means we can create a cluster to run the app in.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行 `terraform apply` 之后，你应该看到 RDS 中正在运行数据库，这意味着我们可以创建一个集群来运行应用程序。
- en: Running the cluster
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行集群
- en: We will use an ECS cluster to run our Docker images in, and furthermore, we
    will run the ECS cluster with Fargate as this means we won’t have to manage the
    servers or the cluster itself. While Fargate is not part of the AWS free tier
    and will sadly cost more, it is worth it to avoid having to manage things ourselves.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 ECS 集群来运行我们的 Docker 镜像，并且我们还将使用 Fargate 运行 ECS 集群，这意味着我们不需要管理服务器或集群本身。虽然
    Fargate 不属于 AWS 免费层并且会花费更多，但避免自己管理这些事情是值得的。
- en: 'Before we can set ECS up though, we first need a repository to place the Docker
    images in and where ECS will pull and run the images from. We can use the **elastic
    container register** (**ECR**) for this by adding the following to *infrastructure/aws_cluster.tf*:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以设置 ECS 之前，我们首先需要一个存储 Docker 镜像的仓库，以及 ECS 从中拉取和运行镜像的地方。我们可以通过在 *infrastructure/aws_cluster.tf*
    中添加以下内容来使用 **弹性容器注册**（**ECR**）：
- en: '[PRE27]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Alongside creating the repository itself, this ensures that old images are deleted,
    which is crucial to reducing storage costs over time. Images tagged with `prod`
    are kept, as these are applied to the image that should be running (`latest` is
    added by Docker to the most recently built image).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 除了创建仓库本身，这还确保了旧镜像被删除，这对于随着时间的推移降低存储成本至关重要。标记为 `prod` 的镜像被保留，因为这些镜像应用于应该运行的镜像（Docker
    会将 `latest` 添加到最近构建的镜像）。
- en: Docker image tagging
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 镜像标记
- en: When a Docker image is built, it can be given tags to identify it. By default,
    it will be tagged as `latest` until a newer image is built and takes the tag.
    It is therefore best to tag images in a useful way to know what they represent.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建 Docker 镜像时，可以给它添加标签以识别它。默认情况下，它将被标记为 `latest`，直到构建了新的镜像并取走该标签。因此，最好以有用的方式标记镜像，以便知道它们代表什么。
- en: 'We can now create the ECS cluster, which requires a task definition and then
    a service to run the task in the cluster. Starting with the task, we need an IAM
    role to execute, which we’ll call `ecs_task_execution`, and an IAM role for the
    task to exist, which we’ll call `ecs_task`. These are created by adding the following
    to *infrastructure/aws_cluster.tf*:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以创建 ECS 集群，这需要一个任务定义，然后是一个在集群中运行任务的服务。从任务开始，我们需要一个 IAM 角色来执行，我们将称之为 `ecs_task_execution`，以及一个
    IAM 角色让任务存在，我们将称之为 `ecs_task`。这些是通过在 *infrastructure/aws_cluster.tf* 中添加以下内容来创建的：
- en: '[PRE28]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The policy attachment is used to attach an existing execution policy to the
    IAM role.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 策略附加用于将现有的执行策略附加到 IAM 角色上。
- en: 'With the roles created, we can now define the ECS task itself. This needs to
    include all of the environment variables required for the code to run correctly
    in production. Therefore, an `app_secret_key` variable should be created in the
    same way as for `db_password` and added to the *infrastructure/secrets.auto.tfvars*
    file first. Then, the following can be added to *infrastructure/aws_cluster.tf*:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建了角色之后，我们现在可以定义 ECS 任务本身。这需要包括所有在生产环境中正确运行代码所需的环境变量。因此，应该以与 `db_password`
    相同的方式创建一个 `app_secret_key` 变量，并将其首先添加到 *infrastructure/secrets.auto.tfvars* 文件中。然后，以下内容可以添加到
    *infrastructure/aws_cluster.tf*：
- en: '[PRE29]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Like with the database, as you gain customers and the app scales up, the `cpu`
    and `memory` values can be increased to meet the demand.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 就像数据库一样，随着客户数量的增加和应用的扩展，`cpu` 和 `memory` 的值可以增加以满足需求。
- en: 'We have now created the task the service will run; however, before we can create
    the service, we need to allow connections between the load balancer and the running
    containers (which are exposing port `8080`), by adding the following to *infrastructure/aws_network.tf*:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经创建了服务将运行的任务；然而，在我们可以创建服务之前，我们需要通过在 *infrastructure/aws_network.tf* 中添加以下内容来允许负载均衡器和运行中的容器（这些容器正在暴露端口
    `8080`）之间的连接：
- en: '[PRE30]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This finally allows the service and cluster to be defined by using the following
    code in *infrastructure/aws_cluster.tf*:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这最终允许通过在 *infrastructure/aws_cluster.tf* 中使用以下代码来定义服务和集群：
- en: '[PRE31]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `desired_count` refers to the number of running containers and should be
    increased as your app handles more requests; a minimum of three should mean that
    there are containers running in different availability zones and hence is more
    robust.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`desired_count` 指的是运行中的容器数量，应该随着你的应用处理更多请求而增加；至少三个意味着有容器在不同的可用区运行，因此更健壮。'
- en: Autoscaling
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 自动扩展
- en: As the traffic to your app grows, you can scale the infrastructure by allocating
    larger machines and by increasing `desired_count`. You should be able to scale
    to very heavy traffic this way (and many congratulations to you when you do).
    However, if your traffic is periodic (for example, you have more traffic during
    the day than the night), then using autoscaling can save costs. Autoscaling is
    where more resources are allocated automatically as the traffic increases.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你的应用流量增长，你可以通过分配更大的机器和增加 `desired_count` 来扩展基础设施。你应该能够通过这种方式扩展到非常高的流量（并且当你这样做的时候，恭喜你）。然而，如果你的流量是周期性的（例如，白天比晚上有更多的流量），那么使用自动扩展可以节省成本。自动扩展是指随着流量的增加自动分配更多资源。
- en: We now have the cluster ready to go; all we need now is for the Docker images
    to be built and placed into the repository.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了准备就绪的集群；我们现在需要的只是将 Docker 镜像构建并放置到仓库中。
- en: Adding continuous deployment
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加持续部署
- en: With everything ready to run, we can now deploy changes by building the container
    image, uploading it to the ECR registry, and informing ECS to deploy the new image.
    This is something that is best done whenever a change is made to the main branch
    of the GitHub repository. We can do this using a GitHub action, much like in the
    *Adopting a collaborative development process using GitHub* section in [*Chapter
    1*](B18727_01.xhtml#_idTextAnchor015)*, Setting Up Our System for Development*.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 一切准备就绪后，我们现在可以通过构建容器镜像，将其上传到 ECR 仓库，并通知 ECS 部署新镜像来部署更改。这是在 GitHub 仓库的主要分支发生更改时最好执行的操作。我们可以使用
    GitHub action 来完成这项工作，就像在 [*第一章*](B18727_01.xhtml#_idTextAnchor015) 的 *使用 GitHub
    采纳协作开发流程* 部分中一样，设置我们的开发系统。
- en: 'To start, we need to create an IAM user that has permission to push Docker
    images to the ECR registry and to inform ECS to deploy a new image. This user
    will also need an access key, as we’ll use this to authenticate the `push` and
    `deploy` commands. The following code creates this user and should be placed in
    *infrastructure/aws.tf*:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'As the continuous deployment will run as a GitHub action, we need to make this
    access key and the repository URL available as a `github_actions_secret`; this
    is done by adding the following to *infrastructure/github.tf*:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'These secrets can now be used in the continuous deployment action. This action
    consists of two jobs:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: The first job builds the Docker image and pushes it to the ECR registry
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second instructs ECS to deploy it (by replacing the currently running image)
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Starting with the first job, the following should be added to *.github/workflows/cd.yml*:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: To save on build time, the last built image, tagged as `latest`, is pulled and
    used as a cache. The built image is then identified by being tagged with the commit
    hash.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now add a `deploy` job that should instruct ECS to deploy the image
    built for this commit. This is done by adding a `prod` tag to the image already
    tagged with the commit hash and then informing ECS to run it. This is done by
    adding the following to *.github/workflows/cd.yml*:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This job is idempotent and rerunning it will deploy the specific commit it is
    associated with. This means it can be rerun to **roll back** a deployment as needed.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Deployment issues and rollbacks
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Not every deployment will go well, and the failure could be during the deployment
    or after deployment. If the deployment itself fails, ECS will automatically keep
    the previous deployment running. If the failure is after deployment, you can roll
    back to a safe previous version by rerunning an old `deploy` job.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Now, on every change to the main branch, you should see that change automatically
    goes live in the production environment. In addition, you can rerun an old `deploy`
    job if there is a bug or issue with the running job. This is a very productive
    way of developing an app.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: While we can visit the app via the ALB URL, our users will expect to use a nice
    domain name, which is what we’ll focus on next.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Serving on a domain
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We’ll want a memorable domain name for users to find and identify our app,
    which means we’ll need to buy one from a domain name registrar. I like to use
    Gandi ([gandi.net](http://gandi.net)) or AWS as they are trustworthy, however,
    I like to separate the domain name from the hosting provider in case something
    goes wrong; for that reason, I’ll be using Gandi in this book and have used it
    to register [tozo.dev](http://tozo.dev) for the next few years, as shown in *Figure
    6.4*:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4: The Gandi home page for registering a domain ](img/B18727_06_04.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.4: The Gandi home page for registering a domain'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: 'The domain name registrar will allow for the relevant DNS records for a domain
    name to be specified; to do so with Gandi, we need to add the `gandi` provider
    to `terraform` by adding the following highlighted code to the existing `terraform`
    section in *infrastructure/main.tf*:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: DNS
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: While the domain name is memorable for humans, the browser will need a corresponding
    IP address in order to make the request. This is the purpose of DNS, which will
    resolve a domain name into the correct IP address. This is done automatically
    by the browser, but if you’d like to try it manually, you can use the `dig` tool
    (e.g., `dig tozo.dev`).A single domain will have multiple DNS records. So far,
    we’ve discussed the `A` record, which contains the IPv4 address for the domain.
    There is also an `AAA` record for an IPv6 address, an `ALIAS` record that points
    to another domain’s `A` or `AAA` record, an `MX` record for mail server information
    (which we’ll use in the *Sending production emails* section of this chapter),
    a `CNAME` record to alias a subdomain to another domain name, and various others.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 'Once initialized via `terraform init`, we can start to use `terraform apply`
    to make these changes. First, we need to retrieve a production API key from Gandi,
    which is found in the **Security** section as shown in *Figure 6.5*:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.5: The Gandi Security section; note the Production API key section
    ](img/B18727_06_05.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.5: The Gandi Security section; note the Production API key section'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'The API key needs to be added as follows to *infrastructure/secrets.auto.tfvars*
    (your key will differ from my `abcd` example):'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Then, the key is used to configure the `gandi` provider by adding the following
    to *infrastructure/dns.tf*:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `gandi` provider is now set up and can be used to set DNS records. We need
    two records: an `ALIAS` record for the domain, and a `CNAME` record for the [www.tozo.dev](http://www.tozo.dev)
    subdomain. The following should be added to *infrastructure/dns.tf*:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: With the DNS records in place, we can now focus on adding HTTPS (SSL).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Securing the connection
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is best practice to ensure that communication between the user and the app
    is encrypted; however, this becomes essential when the communication consists
    of sensitive information, such as the user’s password. As such, we’ll only use
    encrypted communication for our app.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: 'To secure this connection, we can utilize HTTPS using SSL (or TLS), which is
    widely supported and easy to use. To do so, we need to be issued an encryption
    certificate that browsers will recognize. Fortunately, Let’s Encrypt will issue
    us a certificate for free. Let’s Encrypt is usable with Terraform via the `acme`
    provider, which is activated by adding the following highlighted code to the existing
    `terraform` section in *infrastructure/main.tf* and then running `terraform init`:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Certificate authorities
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: To enable HTTPS, we could create our own self-signed certificate; this would
    work, but browsers will display a warning. This warning will state that the browser
    does not trust that the given certificate belongs to the domain. To avoid this
    warning, we need a recognized certificate authority to sign our certificate. To
    do so, the certificate authority must confirm that the owner of the domain is
    the one asking for the certificate. There are many other certificate authorities
    that charge for this service, but Let’s Encrypt does it for free!
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'To acquire a certificate for a domain name, we’ll need to prove to Let’s Encrypt
    that we control the domain name. We can do this via the `acme` provider by adding
    the following to *infrastructure/certs.tf*:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Remember to change the email address, so that reminders and updates from Let’s
    Encrypt go to you rather than to my email!
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: 'The certificates we’ve just created can now be added to the ALB, as doing so
    will enable users to connect to the ALB, and hence our app, via HTTPS. To ensure
    only HTTPS is used, let’s redirect any visitors that connect via HTTP (port `80`)
    to do so via HTTPS (port `443`) by adding the following to *infrastructure/aws_network.tf*:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We can then accept HTTPS connections and forward them to the target group containing
    our running app by adding the following code to *infrastruture/aws_network.tf*:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'With these changes, you can run the following:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This should create all the infrastructure. You will then need to push your local
    code to the GitHub repository for the CD job to run and deploy the app. Once that
    completes, you should be able to visit [tozo.dev](http://tozo.dev) (or whatever
    your domain is) and see the running app. We can now focus on how we can send emails,
    such as a welcome email, to the app’s users.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Sending production emails
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the *Sending emails* section of [*Chapter 2*](B18727_02.xhtml#_idTextAnchor053)*,
    Creating a Reusable Backend with Quart,* we configured our app to send emails
    via Postmark if a `POSTMARK_TOKEN` configuration value was present. We can now
    set up production so that there is a `POSTMARK_TOKEN` in the app’s configuration.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: To do so, we first need approval from Postmark; this is done to ensure that
    we don’t intend to misuse their service. As we are using Postmark for transactional
    emails (e.g., password reset tokens), we should get permission. This is gained
    via the request approval button or by talking directly to their support.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: 'With permission granted, we can add the relevant DNS records to prove to Postmark
    that we control the [tozo.dev](http://tozo.dev) domain. These are available from
    your Postmark account and should be added as follows to *infrastructure/dns.tf*:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Note the highlighted `abcd` DKIM value is a placeholder and should be replaced
    with your own value.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: 'The Postmark token we need is also available in your account and should be
    added to *infrastructure/secrets.auto.tfvars* (your key will differ from my `abcd`
    example):'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'To make this token available to our app, we need it to be an environment variable
    in the running container. This is achieved by adding the following to the existing
    `aws_ecs_task_definition` section in *infrastructure/aws_cluster.tf*:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The highlighted lines should be added to the file. Note that the environment
    variable name is `TOZO_POSTMARK_TOKEN` as only environment variables prefixed
    with `TOZO_` are loaded into the app’s configuration. See the *Creating a basic
    Quart app* section in [*Chapter 2*](B18727_02.xhtml#_idTextAnchor053)*, Creating
    a Reusable Backend with Quart*.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Our app should now send the welcome, reset password, and other emails using
    Postmark. We can monitor this by logging into Postmark and checking the activity.
    Next, we can focus on monitoring the app itself.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring production
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that our app is running in production, we need to keep it working. This
    means we need to monitor for issues, notably errors and slow performance, as both
    lead to a poor user experience. To do so, I find it easiest to use Sentry ([sentry.io](http://sentry.io)),
    which can monitor errors and performance in the frontend and backend code.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring the backend
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To monitor the backend, we should create a new project in Sentry and call it
    `backend`. This is where we’ll see any errors and can monitor the performance.
    The project will have its own **data source name** (**DSN**) value, which we’ll
    need to provide to the app in production. The DSN is found on the project’s configuration
    page on [sentry.io](http://sentry.io).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the DSN available to our app, we need it to be an environment variable
    in the running container. This is achieved by adding the following to the existing
    `aws_ecs_task_definition` section in *infrastructure/aws_cluster.tf*:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The highlighted value will be different for your setup, as the value used here
    is Sentry’s example DSN.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: 'We next need to install `sentry-sdk` by running the following in the *backend*
    folder:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This allows us to activate the Sentry monitoring for Quart using Sentry’s `QuartIntegration`;
    we can do this by adding the following to *backend/src/backend/run.py*:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: It is important that `sentry_sdk.init` is before `app = Quart(__name__)`, as
    highlighted in the previous code.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: Expected performance
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: As a rule of thumb, if an action takes more than 100 milliseconds to return
    a response, the user will notice the slowdown and have a bad experience. Therefore,
    I aim to have routes completed within 40 milliseconds, as this gives time for
    the network transmission and any UI updates to take place within the 100 millisecond
    target. There is an exception though, which is that any route that hashes the
    password should take in excess of 100 milliseconds – otherwise, the hash is too
    weak and liable to be broken.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: This is all we need to monitor the backend, so now we can do the same for the
    frontend.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring the frontend
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To monitor the frontend, we first need to create a `frontend` project in Sentry.
    Next, we need to install the Sentry SDK by running the following in the *frontend*
    folder:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This allows us to activate the Sentry monitoring using Sentry’s browser integration
    by adding the following to *frontend/src/index.tsx*:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The highlighted DSN value provided is an example, and yours is available in
    the project settings on [sentry.io](http://sentry.io). As this value isn’t sensitive,
    it is safe for us to place it directly in the frontend code.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: 'To work correctly, it is important that `Sentry.init` is before the following:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: And that is all we need to monitor the frontend. Next, we can show the user
    a friendly error page when an error occurs.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: Displaying an error page
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is likely, despite our best efforts, that users will encounter bugs and
    errors as they use the app. When this happens, we should show the user a helpful
    error page that acknowledges the issue and encourages the user to try again, as
    shown in *Figure 6.6*:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.6: The Error page ](img/B18727_06_06.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.6: The Error page'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: 'This page is implemented by adding the following code to *frontend/src/pages/Error.tsx*:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Error tolerance
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: In my experience, users are very tolerant of bugs that are acknowledged and
    fixed quickly, with the inconvenience being quickly forgotten. However, bugs that
    are not acknowledged or affect the user multiple times are not forgiven and result
    in the user using a different app. This is why it is vital to monitor the app
    for errors and fix them first, before adding any new features.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: 'To display this error page when an error occurs, we can use Sentry’s `ErrorBoundary`
    by making the following changes to *frontend/src/index.tsx*:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'To check that everything is set up and works correctly, we can create a route
    that errors when visited by adding the following to *frontend/src/Router.tsx*:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: In the code block, `...` represents code that has been omitted for brevity.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: Now, any visit to `/test-error/` will result in an error and the error page
    being displayed.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: With a friendly error page and Sentry installed, we are able to monitor for
    errors and performance issues.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we’ve deployed our app to the cloud and served it on our own
    memorable domain name, thereby allowing any user to use our app. We also learned
    how to monitor it for any issues, and so are ready to fix bugs as quickly as possible.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: The infrastructure we’ve built in this chapter can be used for any containerized
    app that needs a database and will scale to very high loads.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll add some advanced features to our app and turn it
    into a progressive web app.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
