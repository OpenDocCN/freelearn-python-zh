- en: Chapter 10. Files, Databases, Networks, and Contexts
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章：文件、数据库、网络和上下文
- en: Files and the filesystem are central to the way modern OSs work. Many OS resources
    are visible as part of the filesystem. For example, the Linux `/dev/mem` is a
    view into the processor's memory, implemented as a device visible in the filesystem.
    Python provides file objects that map to these OS features.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 文件和文件系统是现代操作系统工作方式的核心。许多操作系统资源都作为文件系统的一部分可见。例如，Linux的`/dev/mem`是处理器内存的视图，作为文件系统中可见的设备实现。Python提供了映射到这些操作系统特性的文件对象。
- en: At a fundamental level, OS files are simply collections of bytes. In practice,
    we often work with files that are collections of Unicode characters. Python offers
    both views of files. With some file formats, we need to process the bytes. With
    text files, we expect Python to properly decode Unicode characters from the bytes.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在基本层面上，操作系统文件仅仅是字节集合。在实践中，我们经常处理的是由Unicode字符组成的文件集合。Python提供了这两种文件视图。对于某些文件格式，我们需要处理字节。对于文本文件，我们期望Python能够正确地将Unicode字符从字节中解码出来。
- en: A Python file object will generally be entangled with an OS resource. In order
    to be sure that an application doesn't leak OS resources, we often use a context
    manager. This allows us to be sure that OS resources are released when Python
    files are closed. The `with` statement provides a tidy way to work with a context
    manager to allocate and de-allocate resources.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Python文件对象通常与操作系统资源纠缠在一起。为了确保应用程序不会泄露操作系统资源，我们经常使用上下文管理器。这允许我们确保在Python文件关闭时释放操作系统资源。`with`语句提供了一种整洁的方式来使用上下文管理器分配和释放资源。
- en: In addition to ordinary files, we'll look at TCP/IP sockets. The `urllib` module
    allows us to open a socket to a remote host. The socket is used like a file to
    read the data from the remote host.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 除了普通文件外，我们还将探讨TCP/IP套接字。`urllib`模块允许我们打开一个远程主机的套接字。套接字被用作文件来从远程主机读取数据。
- en: A file has a physical format; all but the simplest formats require a `library`
    module to read and write the content properly. Additionally, within the constraints
    of a physical format, there may be variations in the logical layout of the data.
    A **comma-separated values** (**CSV**) file, for example, may use field names
    in the first line of the file to describe the logical layout of the columns.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 文件有一个物理格式；除了最简单的格式外，所有格式都需要一个`library`模块来正确地读写内容。此外，在物理格式的约束下，数据逻辑布局可能会有所不同。例如，**逗号分隔值**（**CSV**）文件可能使用文件的第一行中的字段名来描述列的逻辑布局。
- en: A SQLite database or a `shelve` database relies on one (or more) file to make
    the data persistent. We'll look briefly at higher-level constructs which rely
    on files.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite数据库或`shelve`数据库依赖于一个（或多个）文件来使数据持久化。我们将简要地探讨依赖于文件的高级结构。
- en: The essential file concept
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件的基本概念
- en: Modern OSs rely on files and device drivers for a variety of services and features.
    Bytes on a disk drive are only one type of file.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 现代操作系统依赖于文件和设备驱动程序来提供各种服务和功能。磁盘驱动器上的字节只是文件的一种类型。
- en: Note
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Since many storage devices use or include **Solid State Drives** (**SSD**) the
    term "disk" is technically a misnomer; we'll use the outdated term.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 由于许多存储设备使用或包含**固态硬盘**（**SSD**），从技术上来说，“磁盘”这个术语是一个误称；我们将使用过时的术语。
- en: A network adapter is another kind of file; one in which bytes are available
    continuously, instead of appearing at rest. In addition to disk and network files,
    the Linux filesystem includes the `/dev` directory, which describes all of the
    devices on a given computer. These devices include serial ports, references to
    memory, and even a device which accumulates an entropy pool to provide random
    bytes.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 网络适配器是另一种类型的文件；在这种文件中，字节是连续可用的，而不是静止出现。除了磁盘和网络文件外，Linux文件系统还包括`/dev`目录，它描述了给定计算机上的所有设备。这些设备包括串行端口、内存引用，甚至一个累积熵池以提供随机字节的设备。
- en: 'The Python file object wraps an OS file. The `open()` function binds a Python
    file object to an OS file. In addition to a name, the function expects a mode
    string for access. The mode string combines two features:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Python文件对象封装了一个操作系统文件。`open()`函数将Python文件对象绑定到操作系统文件。除了名称外，该函数还期望一个用于访问的模式字符串。模式字符串结合了两个功能：
- en: '**Characters versus bytes**: By default, a file is opened in text mode; we
    can make this explicit by using `t`. When reading, the OS bytes are decoded to
    create Unicode characters. When writing, the Unicode characters are encoded into
    bytes. To use bytes instead of text, we include `b` in the mode; no encoding or
    decoding will be done.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**字符与字节**：默认情况下，文件以文本模式打开；我们可以通过使用`t`来明确这一点。在读取时，操作系统字节被解码以创建Unicode字符。在写入时，Unicode字符被编码成字节。要使用字节而不是文本，我们在模式中包含`b`；不会进行编码或解码。'
- en: '**Allowed operations**: By default, a file is opened in `r` mode which allows
    reading only. We can open a file in `w` mode which will remove any previous content
    and allow writing only. We can open a file in `a` mode which will search to the
    end of the previous content so that new content can be appended. The `+` modifier
    allows both reading and writing; this means that `w+` removes any previous content
    and allows reading and writing; `r+` leaves the previous content in place and
    allows reading and writing.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**允许的操作**：默认情况下，文件以`r`模式打开，仅允许读取。我们可以以`w`模式打开文件，这将删除任何先前内容并仅允许写入。我们可以以`a`模式打开文件，这将搜索到先前内容的末尾，以便可以附加新内容。`+`修饰符允许读写；这意味着`w+`将删除任何先前内容并允许读写；`r+`将保留先前内容并允许读写。'
- en: When we open a text file, we provide explicit encoding. In some cases, explicit
    encoding is required because the encoding expected by the OS isn't in the file.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们打开一个文本文件时，我们提供明确的编码。在某些情况下，需要明确编码，因为操作系统期望的编码不在文件中。
- en: 'In some cases, we may also need to specify how newline characters should be
    handled. On input, we rarely need to specify line endings: Python handles them
    gracefully by translating Windows `\r\n` to `\n`. On output, however, we might
    need to explicitly provide the line ending. If we set `newline=""`, then no translation
    is performed; we''ll need this so that we can create CSV files with `\r\n` line
    endings. If we set `newline=None` when opening a file, then `\n` from our program''s
    output translates the platform-specific value in the `os.linesep` variable. This
    is the default behavior. Any other values for `newline` replace the `\n` characters
    in our output.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们可能还需要指定如何处理换行符。在输入时，我们很少需要指定行结束符：Python通过将Windows `\r\n`转换为`\n`来优雅地处理它们。然而，在输出时，我们可能需要明确提供行结束符。如果我们设置`newline=""`，则不会执行转换；我们需要这样做，以便可以创建具有`\r\n`行结束符的CSV文件。如果我们打开文件时设置`newline=None`，那么程序输出的`\n`将转换为`os.linesep`变量中的平台特定值。这是默认行为。`newline`的任何其他值都将替换输出中的`\n`字符。
- en: We can specify buffering. We can also specify how Unicode decoding errors are
    handled. There are seven choices for Unicode errors, including `strict`, `ignore`,
    `replace`, `xmlcharrefreplace`, `backslashreplace`, and `surrogateescape`. The
    `strict` error handling raises an exception. The `ignore` error handling quietly
    drops the illegal character. The other choices offer different kinds of replacement
    strategies.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以指定缓冲区。我们还可以指定如何处理Unicode解码错误。有七个选项用于Unicode错误，包括`strict`、`ignore`、`replace`、`xmlcharrefreplace`、`backslashreplace`和`surrogateescape`。`strict`错误处理会引发异常。`ignore`错误处理会静默地丢弃非法字符。其他选项提供不同的替换策略。
- en: Opening text files
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 打开文本文件
- en: 'For processing text files, here''s how to create the file object using the
    `open()` function:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于处理文本文件，以下是使用`open()`函数创建文件对象的方法：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We've opened a file using all of the default settings. The mode will be read-only.
    The file must use the system's default encoding (Mac-Roman, for example). We'll
    rely on the default buffering and the default Unicode error handling, which is
    `strict`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用所有默认设置打开了文件。模式将是只读。文件必须使用系统的默认编码（例如Mac-Roman）。我们将依赖默认的缓冲区和默认的Unicode错误处理，即`strict`。
- en: In this example, we read the entire file into a giant string and then split
    that single string into a sequence of individual lines. We assigned the list of
    strings to the `text` variable. We only displayed the first five items from this
    list. By default, the string `split()` method does not preserve the split character.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将整个文件读入一个巨大的字符串，然后将该单个字符串拆分为一系列单独的行。我们将字符串列表分配给`text`变量。我们只显示了列表中的前五项。默认情况下，`split()`字符串方法不保留拆分字符。
- en: Filtering text lines
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过滤文本行
- en: 'We''ll look at two key concepts in the following examples. We''ll start by
    opening a file that''s encoded using `"utf-8"`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在以下示例中查看两个关键概念。我们将首先打开一个使用`"utf-8"`编码的文件：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We've opened a file with the mode `"rt",` which means read-only and text. This
    is the default, so it could have been omitted. We've explicitly provided `"utf-8"`
    encoding, which is not the OS default.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以 `"rt"` 模式打开了一个文件，这意味着只读和文本模式。这是默认设置，所以可以省略。我们明确提供了 `"utf-8"` 编码，这并非操作系统默认编码。
- en: 'We used the `list()` function to convert the file object into a sequence of
    lines. When we use a file object as if it is an iterable, we''ll see that the
    file iterates over lines. If we don''t change the newline setting for the file,
    then the "universal newlines" rules are used: `\n`, `\r`, or `\r\n` will end a
    line; they''re normalized to `\n`. When we process a file as lines, the line ending
    characters are preserved.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `list()` 函数将文件对象转换为行序列。当我们将文件对象用作可迭代对象时，我们会看到文件按行迭代。如果我们不更改文件的换行设置，则使用“通用换行”规则：`\n`、`\r`
    或 `\r\n` 结束一行；它们被规范化为 `\n`。当我们按行处理文件时，行结束字符被保留。
- en: We often want to remove newline characters from the end of each line. This is
    a kind of mapping from raw lines to lines with trailing whitespace stripped. We
    can use a generator expression or the `map()` function and the `str.rstrip()`
    method.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常希望从每行的末尾删除换行符。这是一种从原始行到去除尾随空白的行的映射。我们可以使用生成器表达式或 `map()` 函数以及 `str.rstrip()`
    方法来实现。
- en: 'In some cases, an empty line has no meaning and can be removed. This, too,
    can be done with a generator expression that has an `if` clause to reject empty
    lines. We can also do it with a `filter()` function. It''s easier if we write
    these map and filter operations in two lines, like this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，空行没有意义，可以删除。这也可以通过具有 `if` 子句以拒绝空行的生成器表达式来完成。我们还可以使用 `filter()` 函数来完成。如果我们将这些映射和过滤操作写成两行，会更简单，如下所示：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We've broken down the input cleanup into two generator expressions. The first
    generator expression, `txt_stripped`, maps raw lines to lines with trailing whitespace
    stripped. The second generator expression, `txt_non_empty`, is a filter which
    rejects lines that are empty. We could easily add other filter conditions to the
    `if` clause. Since generator expressions are lazy, nothing is really done until
    the final `list()` function consumes all of the lines from the generators.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将输入清理分解为两个生成器表达式。第一个生成器表达式 `txt_stripped` 将原始行映射到去除尾随空白的行。第二个生成器表达式 `txt_non_empty`
    是一个过滤器，它会拒绝空行。我们很容易在 `if` 子句中添加其他过滤条件。由于生成器表达式是惰性的，直到最终的 `list()` 函数消耗了所有生成器中的行，实际上并没有做什么。
- en: In this way, we can design fairly sophisticated file parsing as a collection
    of generator expressions. We can apply a number of mapping and filtering operations
    so that the main suite of statements has only clean data.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，我们可以设计相当复杂的文件解析，作为生成器表达式集合。我们可以应用一系列映射和过滤操作，使得主语句块中只有干净的数据。
- en: Working with raw bytes
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理原始字节
- en: 'Here''s how we open a file and see the raw bytes:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们打开文件并查看原始字节的方法：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We've opened this file in binary mode. The input we get will be `bytes` instead
    of `str`. Since a `bytes` object has many similar features to a `str` object,
    we can do a great deal of string-like processing on these bytes. We've dumped
    the first 22 bytes from the file. Bytes are shown as a mixture of hex values and
    ASCII characters.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以二进制模式打开了此文件。我们得到的输入将是 `bytes` 而不是 `str`。由于 `bytes` 对象具有许多与 `str` 对象相似的功能，我们可以对这些字节进行大量的字符串处理。我们已经从文件中导出了前
    22 个字节。字节以十六进制值和 ASCII 字符的混合形式显示。
- en: We'll need to look at the description of the ICO file format to see what the
    bytes mean. Here's some background at [http://en.wikipedia.org/wiki/ICO_(file_format)](http://en.wikipedia.org/wiki/ICO_(file_format)).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要查看 ICO 文件格式的描述，以了解字节的意义。有关背景信息，请参阅[http://en.wikipedia.org/wiki/ICO_(file_format)](http://en.wikipedia.org/wiki/ICO_(file_format))。
- en: The easiest way to decode this block of bytes is by using the `struct` module.
    We can do the following to pick apart the header on the file and the header on
    the first image of the file.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 解码此字节块的最简单方法是使用 `struct` 模块。我们可以执行以下操作来解析文件头和文件第一个图像的头。
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `unpack()` function requires a format that specifies different kinds of
    conversions to perform on the stream of bytes. In this case, the format contains
    three codes for groups of bytes: `h` means two-byte half worlds, `b` means single
    bytes, and `i` means four-byte integers. The bytes are assembled into numeric
    values and the resulting structure is a tuple of proper Python `int` values. The
    leading `<` in the format specifies that the conversion to integers uses **little-endian**
    byte ordering.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`unpack()` 函数需要一个格式，该格式指定了对字节流执行的不同类型的转换。在这种情况下，格式包含三个用于字节组的代码：`h` 表示双字节半字，`b`
    表示单字节，而 `i` 表示四字节整数。字节被组装成数值，结果结构是一个包含适当 Python `int` 值的元组。格式中的前导 `<` 指定整数转换使用
    **小端字节序**。'
- en: Using file-like objects
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用文件类似对象
- en: Because of the way objects work in Python, any object that offers an interface
    similar to the `file` class can be used in place of a file. This leads to the
    term "file-like object". We can use a file object, or any other object which is
    designed to behave like a file. For example, the `io` module has the `StringIO`
    class, which allows us to work with a string as if it were the contents of a file.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Python 中对象的工作方式，任何提供类似 `file` 类接口的对象都可以用来代替文件。这导致了“文件类似对象”这个术语。我们可以使用文件对象，或者任何其他设计为像文件一样工作的对象。例如，`io`
    模块有 `StringIO` 类，它允许我们像处理文件内容一样处理字符串。
- en: We often use this for creating test data. Note that an `io.StringIO` object
    is a lot like an open file. When we think about designing for testability—the
    subject of [Chapter 14](ch14.html "Chapter 14. Fit and Finish – Unit Testing,
    Packaging, and Documentation"), *Fit and Finish – Unit Testing, Packaging, and
    Documentation*—we need to design functions to work with file objects, not filenames.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常使用它来创建测试数据。请注意，`io.StringIO` 对象与一个打开的文件非常相似。当我们考虑为可测试性进行设计——即 [第 14 章](ch14.html
    "第 14 章。完善——单元测试、打包和文档") 的主题，“完善——单元测试、打包和文档”——我们需要设计函数以与文件对象一起工作，而不是与文件名一起工作。
- en: Here's a function that applies simple pattern matching to lines of a file to
    yield numeric values extracted from complex lines of text. For more information
    on regular expressions, see [Chapter 3](ch03.html "Chapter 3. Expressions and
    Output"), *Expressions and Output*.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个将简单模式匹配应用于文件行以产生从复杂文本行中提取的数值的函数。有关正则表达式的更多信息，请参阅 [第 3 章](ch03.html "第 3
    章。表达式和输出")，“表达式和输出”。
- en: 'This function uses a pattern to filter the lines of a file or file-like object:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数使用一个模式来过滤文件或文件类似对象的行：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We''ve defined a generator function, which will reduce a log file to the few
    lines that match the given pattern. We''ve used the `re` module to define a pattern,
    `data_pat`, that looks for a string of words (`[\w ]+`), a `:` character, and
    a number that could be an integer or floating-point (`\d+\.?\d*`). The `data_pat.findall(line)`
    expression will locate all of these *words: number* pairs in a given line. A resulting
    list of match results is produced for each matching line.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个生成器函数，该函数将日志文件减少到与给定模式匹配的几行。我们使用了 `re` 模块来定义一个模式 `data_pat`，该模式查找一个单词字符串
    (`[\w ]+`)，一个冒号字符，以及一个可能是整数或浮点数的数字 (`\d+\.?\d*`)。`data_pat.findall(line)` 表达式将在给定行中定位所有这些
    *单词：数字* 对。对于每行匹配项，将生成一个匹配结果列表。
- en: The matches are strings. We'll need to apply additional functions to the results
    to convert the numeric group from a string to a proper number.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配结果是字符串。我们需要应用额外的函数来将结果中的数字组从字符串转换为正确的数字。
- en: 'It is important when defining our function to use a filename; the function
    doesn''t open the file. A function that opens a file is slightly more difficult
    to test. Instead, we defined our `tests_run()` function to use any file-like object.
    This allows us to write unit tests like the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义我们的函数时使用文件名很重要；函数不会打开文件。打开文件的函数稍微难以测试。相反，我们定义了 `tests_run()` 函数以使用任何文件类似对象。这允许我们编写如下单元测试：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We've imported the `io` module so that we can create an `io.StringIO` object
    that contains simulated input. We can provide this file-like object to the `tests_run()`
    function. Since `StringIO` behaves like a file, we can use it in place of an actual
    file to test our function to be sure that it properly locates the `Tests run`
    lines and ignores other lines. We'll look at unit testing in [Chapter 14](ch14.html
    "Chapter 14. Fit and Finish – Unit Testing, Packaging, and Documentation"), *Fit
    and Finish – Unit Testing, Packaging, and Documentation*.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经导入了`io`模块，以便我们可以创建一个包含模拟输入的`io.StringIO`对象。我们可以将这个类似文件的对象提供给`tests_run()`函数。由于`StringIO`的行为类似于文件，我们可以用它来代替实际文件来测试我们的函数，以确保它正确地定位了`Tests
    run`行并忽略了其他行。我们将在[第14章](ch14.html "第14章。完善 - 单元测试、打包和文档")中查看单元测试，*完善 - 单元测试、打包和文档*。
- en: Using a context manager via the with statement
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过`with`语句使用上下文管理器
- en: 'A Python file object is generally entangled with OS resources. When we''re
    done using the file, we need to be sure that the file is properly closed so that
    the OS resources can be released. For small command-line applications, this consideration
    is not that important: when we exit from Python, and the reference counts for
    all objects are decreased to zero, the files will be closed during object delete
    processing.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Python的文件对象通常与操作系统资源纠缠在一起。当我们完成文件的使用时，我们需要确保文件被正确关闭，以便操作系统资源可以被释放。对于小型命令行应用程序，这个考虑并不是那么重要：当我们从Python退出时，并且所有对象的引用计数都减少到零，文件将在对象删除处理过程中关闭。
- en: For a large, long-running server, however, files that are not properly closed
    will accumulate OS resources. Since pools of OS resources are finite, a file handle
    leak will, eventually, cause problems.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于大型、长时间运行的服务器，未正确关闭的文件将积累操作系统资源。由于操作系统资源的池是有限的，文件句柄泄露最终将导致问题。
- en: As a general practice, we can use a context manager to be sure that files are
    closed when we're done using them. The idea is to constrain an open file to the
    suite of statements within the context manager. Once that suite of statements
    is finished, the context manager will ensure that the file is closed.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一般实践，我们可以使用上下文管理器来确保在完成使用文件后文件被关闭。想法是将一个打开的文件约束在上下文管理器内的语句集中。一旦这个语句集完成，上下文管理器将确保文件被关闭。
- en: We specify the context using the `with` statement. A file object is a context
    manager; the `with` statement uses the file as a manager. At the end of the `with`
    statement, the context manager will exit and the file will be closed. Some more
    complex file structures are also context managers. For example, a `ZipFile` object,
    defined in the `zipfile` module, is a proper context manager; when used in a `with`
    statement, the file will be neatly closed.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`with`语句来指定上下文。文件对象是一个上下文管理器；`with`语句使用文件作为管理器。在`with`语句结束时，上下文管理器将退出，文件将被关闭。一些更复杂的文件结构也是上下文管理器。例如，`zipfile`模块中定义的`ZipFile`对象是一个合适的上下文管理器；当在`with`语句中使用时，文件将被整洁地关闭。
- en: 'It should be considered a best practice to wrap all file input-output processing
    in a `with` statement to be absolutely sure that the file is properly closed.
    Here''s an example of how we can use the `tests_run()` function (shown earlier)
    using a context manager:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 应该将所有文件输入输出处理都包裹在`with`语句中，以确保文件被正确关闭，这是一个最佳实践。以下是我们如何使用（前面展示的）`tests_run()`函数（作为一个上下文管理器的例子）的示例：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We've opened two files to serve as context managers. The file which is opened
    for reading, `"Chapter_10/log_example.txt"`, is assigned to the `source` variable.
    The file opened for writing, `"Chapter_10/summary.txt"`, is assigned to the `target`
    variable. We can then process these files knowing that they will close properly.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经打开了两个文件作为上下文管理器。用于读取的文件`"Chapter_10/log_example.txt"`被分配给`source`变量。用于写入的文件`"Chapter_10/summary.txt"`被分配给`target`变量。然后我们可以处理这些文件，知道它们将正确关闭。
- en: If an exception is raised, the files will be closed. This is very important.
    Each of these context managers is notified if an exception occurs in the suite
    of statements inside the `with` statement. In this case, both of the managers
    are file objects. Each will see the exception and close the file—releasing all
    OS resources—and allow the exception handling to continue. Our application will
    crash with an exception, but the files will also close properly.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生异常，文件将被关闭。这非常重要。如果`with`语句内部的语句组中发生异常，每个上下文管理器都会收到通知。在这种情况下，这两个管理器都是文件对象。每个对象都会看到异常并关闭文件——释放所有操作系统资源——并允许异常处理继续。我们的应用程序将因异常而崩溃，但文件也将正确关闭。
- en: Tip
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Always wrap file processing in a `with` statement.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 总是使用`with`语句包装文件处理。
- en: Closing file-like objects with contextlib
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用contextlib关闭文件类似对象
- en: In some cases, we want to be sure that our application closes a file-like object
    that does not implement the context manager methods. Modules such as `http.client`
    will create an `HTTPConnection` object that may be entangled with network resources.
    We'd like to ensure that any network resources are released when we're done using
    the connection object. However, since this object is not a proper context manager,
    it won't be closed automatically when used in a `with` statement.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们想确保我们的应用程序关闭一个没有实现上下文管理器方法的文件类似对象。例如，`http.client`模块将创建一个`HTTPConnection`对象，该对象可能与网络资源纠缠在一起。我们希望确保在完成使用连接对象后释放任何网络资源。然而，由于此对象不是合适的上下文管理器，当在`with`语句中使用时，它不会自动关闭。
- en: Indeed, trying to use an `HTTPConnection` object as context manager in a `with`
    statement will raise an `AttributeError` exception. This error will show that
    the `HTTPConnection` object does not implement the correct methods to behave as
    a context manager.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，尝试在`with`语句中使用`HTTPConnection`对象作为上下文管理器将引发`AttributeError`异常。这个错误将显示`HTTPConnection`对象没有实现作为上下文管理器所需的方法。
- en: We can leverage a generic context manager in the `contextlib` module. The `contextlib.closing()`
    function will wrap any object that has a `close()` method with the required special
    methods to make the wrapped object into a context manager.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用`contextlib`模块中的通用上下文管理器。`contextlib.closing()`函数将包装任何具有`close()`方法的对象，并添加所需的特殊方法，使包装的对象成为一个上下文管理器。
- en: 'A RESTful web services request might look like this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一个RESTful网络服务请求可能看起来像这样：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We're interested in making a GET request to a web service. The `http.client.HTTPConnection`
    object isn't a context manager; there's no guarantee that it will be closed if
    an exception occurs. By wrapping it with the `contextlib.closing()` function,
    we've made it into a proper context manager. We can make requests and process
    responses, in the knowledge that the `HTTPConnection` object will have its `close()`
    method called properly.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对向网络服务发送GET请求感兴趣。`http.client.HTTPConnection`对象不是上下文管理器；如果没有异常发生，无法保证它会被关闭。通过使用`contextlib.closing()`函数包装它，我们使其成为一个合适的上下文管理器。我们可以发送请求并处理响应，同时知道`HTTPConnection`对象将正确调用其`close()`方法。
- en: Using the shelve module as a database
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将shelve模块用作数据库
- en: Files offer us persistent storage. The simple use of files is limited by the
    fact that the data must be accessed sequentially. How can we access items in an
    arbitrary order?
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 文件为我们提供了持久存储。文件简单使用的局限性在于数据必须按顺序访问。我们如何以任意顺序访问项目？
- en: We'll use the term "database" for a file (a set of files) on which we're going
    to perform **Create, Retrieve, Update, and Delete** (**CRUD**) operations on data
    elements in an arbitrary order. If we create objects of a consistent size, we
    can open an ordinary text file in `r+` mode and use the `seek()` method to position
    at the start of any particular record. This is rather complex, however, and we
    can do better.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用“数据库”一词来指代一个文件（一组文件），我们将在其中以任意顺序对数据元素执行**创建、检索、更新和删除**（**CRUD**）操作。如果我们创建大小一致的对象，我们可以在`r+`模式下打开一个普通文本文件，并使用`seek()`方法定位到任何特定记录的开始。然而，这相当复杂，我们可以做得更好。
- en: The core database concept of readable and writable storage can be extended with
    a seemingly endless list of ancillary features. We'll ignore locking, logging,
    auditing, journaling, distributed transaction management, and many other features,
    for now to focus on the core feature of persistence.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 核心数据库概念——可读和可写存储——可以通过看似无穷无尽的辅助功能进行扩展。现在，我们将忽略锁定、日志记录、审计、日志记录、分布式事务管理以及许多其他功能，以专注于持久化的核心功能。
- en: The `shelve` module provides us with a very flexible database. A shelf object
    behaves like an ordinary Python mapping with the bonus feature that the content
    is persistent. One additional constraint is that keys used for a shelf must be
    strings.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`shelve`模块为我们提供了一个非常灵活的数据库。书架对象的行为类似于一个普通的Python映射，并且具有内容持久化的附加功能。一个额外的约束是，用于书架的键必须是字符串。'
- en: Generally, we use multi-part strings as shelf keys so that we can include some
    class information along with a unique identifier for the instance of the class.
    We can use a simple `class:id` format to include both the class name and an object's
    identifier value as the composite key for the shelf.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们使用多部分字符串作为书架键，这样我们就可以包含一些类信息以及类的实例的唯一标识符。我们可以使用简单的`class:id`格式来包含类名和对象的标识值，作为书架的复合键。
- en: Here's an example of creating a shelf that maps a key to a list of values. In
    this example, the input file has a sequence of words, plus some blank lines and
    a trailer line that we want to ignore. The shelf has keys which are the initial
    letters of words. The value associated with each key is a list of words that share
    that common first letter.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个创建将键映射到值列表的书架的示例。在这个例子中，输入文件有一系列单词，还有一些空白行和一个我们想要忽略的尾随行。书架的键是单词的首字母。与每个键关联的值是与该共同首字母共享的单词列表。
- en: 'Here''s the entire function:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是整个函数：
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We've opened the shelf object using `shelve.open()`. The `"n"` mode creates
    a new, empty shelf file each time the application runs. Since a shelf is not a
    proper context manager, we need to wrap it with the `contextlib.closing()` function.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`shelve.open()`打开了书架对象。`"n"`模式会在每次应用程序运行时创建一个新的、空的书架文件。由于书架不是一个合适的上下文管理器，我们需要用`contextlib.closing()`函数将其包装。
- en: The `shelve` module relies on a platform-specific database module. This may
    necessitate one or more underlying files to support the shelf. We've provided
    a base filename of `"Chapter_10/shelf"`. We may see a `.dat` or `.db` file get
    created, depending on the OS we're using.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`shelve`模块依赖于特定平台的数据库模块。这可能会导致需要一个或多个底层文件来支持书架。我们提供了一个基本文件名为`"Chapter_10/shelf"`。根据我们使用的操作系统，可能会创建一个`.dat`或`.db`文件。'
- en: The `for` loop traverses the input sequence of words generated by the `txt_non_empty`
    expression. The suite starts by building a two-part key. The first part is the
    string `word_list`; this is clearly not the Python data class, but it serves as
    a summary of what the data means. After the colon, we've put the first character
    of the word.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环遍历由`txt_non_empty`表达式生成的输入单词序列。套件首先构建一个两部分的键。第一部分是字符串`word_list`；这显然不是Python数据类，但它作为数据含义的总结。在冒号之后，我们放上了单词的第一个字符。'
- en: We fetch the current list of words associated with this key. If there is no
    such key in the shelf, we handle the `KeyError` exception by creating a fresh,
    empty list. Once we have a list—either new or fetched from the shelf—we can update
    the list by appending our new word. We then save the word list in the shelf.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们获取与该键关联的当前单词列表。如果没有这样的键在书架中，我们通过创建一个新的、空列表来处理`KeyError`异常。一旦我们有一个列表——无论是新的还是从书架中检索的——我们就可以通过追加我们的新单词来更新列表。然后我们将单词列表保存在书架中。
- en: To query words with a certain first letter, we can use `shelf["word_list:"+letter]`.
    We need to create a complete key string that includes a classifier so that we
    have a shelf with multiple collections.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要查询以特定首字母开头的单词，我们可以使用`shelf["word_list:"+letter]`。我们需要创建一个完整的键字符串，包括一个分类器，这样我们就有了一个包含多个集合的书架。
- en: 'To retrieve and summarize the data, we use a simple loop based on this generator
    expression:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检索和总结数据，我们使用基于这个生成器表达式的简单循环：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This will select only the keys from our `word_list` collection in the shelf
    database. In a more sophisticated database, there may be other collections with
    other key prefixes.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这将只选择来自书架数据库中的`word_list`集合的键。在一个更复杂的数据库中，可能有其他带有其他键前缀的集合。
- en: Using the sqlite database
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用sqlite数据库
- en: The `sqlite` module provides us with a SQL-based database. An application that
    leverages SQL is—in principle—portable. We should be able to use MySQL or PostgreSQL
    as our database instead of SQLite without making dramatic changes to our Python
    application.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`sqlite`模块为我们提供了一个基于SQL的数据库。利用SQL的应用程序在原则上是可以移植的。我们应该能够在不大幅修改我们的Python应用程序的情况下，使用MySQL或PostgreSQL作为我们的数据库而不是SQLite。'
- en: While there are several applicable standards for SQL, each implementation seems
    to suffer from its own particular problems. SQL-based applications are therefore
    rarely perfectly portable between database platforms.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有几种适用于SQL的标准，但每个实现似乎都存在自己特有的问题。因此，基于SQL的应用程序很少能够在数据库平台之间完美移植。
- en: 'SQL databases require a formal schema definition. This means that SQL applications
    must always include some provision for creating or confirming the schema. As in
    the previous example, we''ll work with a database that has a single table with
    two columns: a non-unique key which is the initial letter of a word, and the word
    which has that initial letter.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: SQL数据库需要一个正式的模式定义。这意味着SQL应用程序必须始终包含创建或确认模式的一些规定。就像前面的例子一样，我们将与一个只有一个表且有两个列的数据库一起工作：一个非唯一键，它是单词的首字母，以及具有该首字母的单词。
- en: 'Here''s the table definition in SQL:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这是SQL中的表定义：
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This defines a table that has two columns, `letter` and `word`. To find all
    of the words which have a common first letter, we'll need to retrieve multiple
    rows from this table. This is a common type of SQL design. It doesn't fit neatly
    with Python's object-oriented design, a common limitation when using SQL.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了一个有两个列的表，`letter`和`word`。要找到所有具有共同首字母的单词，我们需要从该表中检索多行。这是一种常见的SQL设计。它并不完全符合Python的面向对象设计，这是使用SQL时的一个常见限制。
- en: 'We need to execute the SQL `CREATE TABLE` statement to create (or confirm the
    existence of) the table in a SQLite database. Here''s a function that will establish
    (or confirm) the schema:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要执行SQL `CREATE TABLE`语句来在SQLite数据库中创建（或确认）表。以下是一个将建立（或确认）模式的函数：
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The essential statement is the `execute()` method of the SQLite connection object.
    We've provided the SQL with a triple-quoted string. If there's a problem, an exception
    will be raised.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的语句是SQLite连接对象的`execute()`方法。我们提供了一个三引号字符串的SQL。如果出现问题，将引发异常。
- en: 'Here''s a function that will load this table with data from a text file:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个函数，它将从文本文件加载数据到这个表中：
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note that we begin by deleting all the rows from the `word` table. This parallels
    the way that our previous example worked by creating a fresh, empty `shelve` database.
    There may be high overheads in creating an empty SQL database; this example expects
    an established database with a table already defined, and deletes rows from the
    defined table.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们首先从`word`表中删除所有行。这类似于我们之前的例子，通过创建一个全新的空`shelve`数据库来工作。创建空SQL数据库可能会有很高的开销；此示例期望有一个已建立的数据库，其中已经定义了表，并从定义的表中删除行。
- en: As with the previous example, we've used two generator expressions to filter
    out these lines of junk from the input file. The loop traverses the words generated
    by the `no_summary` expression. The suite executes a SQL `INSERT` statement binding
    two values for the `letter` and `word` columns of the table. This statement creates
    a new row in the word table in our database.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的例子一样，我们使用了两个生成器表达式来从输入文件中过滤掉这些垃圾行。循环遍历由`no_summary`表达式生成的单词。该代码块执行一个SQL
    `INSERT`语句，为表中的`letter`和`word`列绑定两个值。这个语句在我们的数据库中为单词表创建了一个新行。
- en: To see counts of words which begin with a given letter, we can use SQL aggregation.
    We would execute the following `SELECT` statement.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看以给定字母开头的单词计数，我们可以使用SQL聚合。我们将执行以下`SELECT`语句。
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: When we execute this, we get a SQL iterator (called a "cursor") that yields
    a sequence of two-tuples based on the `SELECT` clause. Each tuple will have the
    letter and the number of words that share that letter. We can use this to display
    a summary of counts of words with a given initial letter.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行这个操作时，我们得到一个SQL迭代器（称为“游标”），它根据`SELECT`子句产生一系列二元组。每个元组将包含字母和共享该字母的单词数量。我们可以使用这个来显示具有给定首字母的单词计数的摘要。
- en: Using object-relational mapping
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用对象关系映射
- en: Many popular SQL databases offer Python drivers. Some have better levels of
    support than others. When working with SQL databases, it's sometimes difficult
    to locate SQL syntax that is effective and portable. A feature on one database
    may be a problem on another.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 许多流行的SQL数据库提供了Python驱动程序。有些比其他的有更好的支持级别。当与SQL数据库一起工作时，有时很难找到有效且可移植的SQL语法。一个数据库上的特性可能在另一个数据库上成为问题。
- en: More importantly, however, there's a mismatch between the completely flat column-and-row
    structure of a SQL table and the requirements of more complex class definitions
    in an object-oriented language like Python. This impedance mismatch is often addressed
    with an **object-relational mapping** (**ORM**) package. Two popular packages
    are SQLAlchemy or SQLObject.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，然而，SQL表的完全扁平的列-行结构与面向对象语言如Python中更复杂的类定义的要求之间存在不匹配。这种阻抗不匹配通常通过**对象关系映射**（**ORM**）包来解决。两个流行的包是SQLAlchemy或SQLObject。
- en: These packages help with the mapping of complex objects to simple SQL tables.
    It also helps by divorcing the application programming for the details of a particular
    SQL database.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这些包帮助将复杂对象映射到简单的SQL表。它还通过将特定SQL数据库的细节与应用程序编程分离来提供帮助。
- en: Databases which don't use SQL, such as `shelve`, MongoDB, CouchDB, and other
    NoSQL databases, don't have the same object-relational impedance mismatch problem
    that SQL databases have. We have many choices for persistence technology; Python
    can be used with a wide variety of databases.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 不使用SQL的数据库，如`shelve`、MongoDB、CouchDB和其他NoSQL数据库，没有SQL数据库所具有的相同的对象关系阻抗不匹配问题。我们在持久化技术方面有很多选择；Python可以与各种数据库一起使用。
- en: Web services and Internet protocols
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 互联网服务和互联网协议
- en: 'As we noted earlier, many TCP/IP protocols, like HTTP, depend on the socket
    abstraction. Sockets are designed to be file-like: we can use ordinary file operations
    to read or write a socket. At a very low level, we can use the Python `socket`
    module. We can create, read, and write sockets to connect client and server programs.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，许多TCP/IP协议，如HTTP，依赖于套接字抽象。套接字被设计成类似文件：我们可以使用普通的文件操作来读取或写入套接字。在非常低级的情况下，我们可以使用Python的`socket`模块。我们可以创建、读取和写入套接字来连接客户端和服务器程序。
- en: Rather than work directly with sockets, however, we'll make use of higher-level
    modules, such as `urllib` and `http.client`. These give us the client-side operations
    of the HTTP protocol, allowing us to connect to a web server, make requests, and
    get replies. We looked briefly at the `http.client` module in the previous *Closing
    file-like objects with contextlib* section.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们不会直接与套接字工作，而是会使用更高级的模块，例如`urllib`和`http.client`。这些模块为我们提供了HTTP协议的客户端操作，使我们能够连接到Web服务器，发出请求，并获取回复。我们在之前的*使用contextlib关闭文件类似对象*部分简要介绍了`http.client`模块。
- en: To implement a server, we can use `http.server`. In practice, though, we'll
    often leverage a frontend application, such as Apache HTTPD or NGINX, to provide
    the static content of a website. For the dynamic content, we'll often use a WSGI
    gateway to pass web requests from the frontend to a Python framework. There are
    several Python web server frameworks, each with a variety of features, strengths,
    and weaknesses.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现服务器，我们可以使用`http.server`。然而，在实践中，我们通常会利用前端应用程序，如Apache HTTPD或NGINX，来提供网站的静态内容。对于动态内容，我们通常会使用WSGI网关将前端传递到Python框架的Web请求。有几个Python网络服务器框架，每个框架都有各种功能、优势和劣势。
- en: Physical format considerations
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 物理格式考虑
- en: The Python library offers us a number of modules to help process common physical
    file formats. *Chapter 13*, *File Formats*, of the *Python Standard Library* describes
    file compression and archiving; this includes modules to handle files compressed
    using zip or BZip2\. *Chapter 14*, *Cryptographic Services* describes modules
    which handle file formats such as CSV, configuration files, and PLIST files. *Chapter
    19*, *Structured Markup Processing Tools* describes Internet data handling, which
    includes the JSON file format. *Chapter 20*, *Internet Protocols and Support*
    describes modules to handle markup languages such as HTML and XML. For modules
    that are not part of the standard library, the **Python Package Index** (**PyPI**)
    may have a package that handles the file format. See [http://pypi.python.org](http://pypi.python.org).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Python库为我们提供了许多模块来帮助处理常见的物理文件格式。《Python标准库》的第13章*文件格式*描述了文件压缩和归档；这包括处理使用zip或BZip2压缩的文件的模块。第14章*加密服务*描述了处理CSV、配置文件和PLIST文件等文件格式的模块。第19章*结构化标记处理工具*描述了互联网数据处理，其中包括JSON文件格式。第20章*互联网协议和支持*描述了处理HTML和XML等标记语言的模块。对于不是标准库一部分的模块，**Python包索引**（**PyPI**）可能有处理文件格式的包。请参阅[http://pypi.python.org](http://pypi.python.org)。
- en: We'll look quickly at the CSV module because it is often used when working on
    "big data" problems. For example, the Apache Hadoop software library—a framework
    that allows for the distributed processing of large datasets—leverages simple
    programming models. We can use Python with Hadoop streaming.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将快速查看 CSV 模块，因为它在处理“大数据”问题时经常被使用。例如，Apache Hadoop 软件库——一个允许分布式处理大数据集的框架——利用简单的编程模型。我们可以使用
    Python 与 Hadoop 流处理。
- en: A Hadoop file is often a CSV-formatted file. In some instances, it will have
    "`|`" instead of a comma, and quoting or escapes won't be used. In other cases,
    an `\x01` (ASCII SOH) character could be used as a separator. This is relatively
    simple to handle with the Python CSV module.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Hadoop 文件通常是 CSV 格式的文件。在某些情况下，它将使用 "`|`" 而不是逗号，并且不会使用引号或转义符。在其他情况下，可以使用 `\x01`（ASCII
    SOH）字符作为分隔符。这可以通过 Python CSV 模块相对简单地处理。
- en: When we create a CSV file from a spreadsheet, the first row may have header
    information. This can be very helpful. The `csv.DictReader()` class uses the first
    line of a CSV file as the header. Each remaining line is transformed into a `dict`.
    The keys in this `dict` will be the column names from the first line.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从电子表格创建 CSV 文件时，第一行可能包含标题信息。这可能非常有帮助。`csv.DictReader()` 类使用 CSV 文件的第一个行作为标题。每一行剩余的内容将被转换为一个
    `dict`。这个 `dict` 中的键将是第一行中的列名。
- en: When working with other CSV files, a header line may not be present. This means
    that we'll need a separate schema definition to determine the meaning of each
    column. In most cases, we can simply represent the schema as a list or tuple of
    column names.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当与其他 CSV 文件一起工作时，可能不存在标题行。这意味着我们需要一个单独的模式定义来确定每个列的含义。在大多数情况下，我们可以简单地用一个列名列表或元组来表示模式。
- en: 'We might have a line like this to provide the missing column names:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能有一行这样的内容来提供缺失的列名：
- en: '[PRE15]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This gives us pleasant Python-friendly column names in a simple tuple. We've
    included a gratuitous comma at the end of the items in the tuple to make it easier
    to add new columns without getting a syntax error. In general, we can simply put
    this into a file and import this schema definition.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们提供了一个简单的元组，其中包含友好的 Python 列名。我们在元组项的末尾添加了一个多余的逗号，以便更容易添加新列而不会出现语法错误。一般来说，我们可以简单地将这个定义放入文件中并导入这个模式定义。
- en: 'Let''s assume that we have a function named `log_parser()` that can parse a
    complex log file to extract the fields shown earlier. This function will use regular
    expressions to locate lines with the test results, the module name, and the time
    stamp in the log. The data from a log will be used to build a simple dictionary
    with the keys defined by the `TEST_LOG_SUMMARY` global variable. The parser will
    return a sequence of `dict` objects which looks like this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个名为 `log_parser()` 的函数，它可以解析一个复杂的日志文件以提取之前显示的字段。这个函数将使用正则表达式来定位日志中包含测试结果、模块名称和时间戳的行。日志数据将被用来构建一个简单的字典，其键由
    `TEST_LOG_SUMMARY` 全局变量定义。解析器将返回一系列 `dict` 对象，其外观如下：
- en: '[PRE16]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can use this `log_parser()` function to write a CSV summary file from a
    log. We''ll call this function `mapper()` because it maps a sequence of filenames
    to file to a sequence of data rows, preserving the relevant details:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个 `log_parser()` 函数从日志中写入一个 CSV 摘要文件。我们将把这个函数称为 `mapper()`，因为它将文件名序列映射到数据行序列，同时保留相关细节：
- en: '[PRE17]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This function expects two parameters: an iterator which yields log file names,
    and an open file into which the results are written. This function will create
    a CSV `DictWriter` object using the output file, the set of field names that will
    be part of each dictionary to be written, and finally, a delimiter.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数期望两个参数：一个生成日志文件名的迭代器，以及一个打开的文件，结果将被写入其中。此函数将使用输出文件创建一个 CSV `DictWriter` 对象，包括每个将被写入的字典中的字段名集合，最后是一个分隔符。
- en: 'For each name, the log is opened and parsed. The results of the parse, `dict`,
    are written to the CSV file to summarize the processing. We might use this function
    in a script that looks like this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个名称，日志将被打开并解析。解析的结果 `dict` 将被写入 CSV 文件以总结处理过程。我们可能在类似这样的脚本中使用这个函数：
- en: '[PRE18]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We've written the output to the OS standard out. This allows us to pipe these
    results into a separate program which computes statistics on the log summaries.
    We might call the statistical summary a reducer, since it reduces a large number
    of values to single results. The reducer would share the `TEST_LOG_SUMMARY` variable
    to assure that both programs agree on the content of the file that passes between
    them.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将输出写入到操作系统的标准输出。这允许我们将这些结果管道传输到另一个程序，该程序对日志摘要进行统计分析。我们可能会将统计摘要称为reducer，因为它将大量值减少到单个结果。reducer会共享`TEST_LOG_SUMMARY`变量，以确保两个程序对它们之间传递的文件内容达成一致。
- en: Summary
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we've seen how we can use Python exceptions to write programs
    which work with files of various kinds. We've focused on text files, since they
    are easy to work with. We've also looked at parsing binary files, which often
    require support from the `struct` module.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了如何使用Python异常来编写与各种文件类型一起工作的程序。我们专注于文本文件，因为它们易于处理。我们还研究了解析二进制文件，这通常需要`struct`模块的支持。
- en: A file is also a context manager. The best practice is to use files in a `with`
    statement so that the file is closed properly and all OS resources are released.
    In a command-line program, this may not be that important; in long-running servers,
    it's absolutely essential to be sure that resources don't leak from improperly
    closed files.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 文件也是一个上下文管理器。最佳实践是使用`with`语句来使用文件，以确保文件被正确关闭，并且所有操作系统资源都被释放。在命令行程序中，这可能不是那么重要；在长时间运行的服务器中，确保资源不会因文件关闭不当而泄漏是绝对必要的。
- en: 'We''ve also looked at more complex persistence mechanisms, including the `shelve`
    module and the SQLite database. These provide us with ways to perform CRUD operations
    on data objects in a file. The SQLite database requires us to use the SQL language
    to describe data access: this can make our programs more portable to other databases.
    It can also be confusing to leverage SQL in addition to Python. We can overcome
    that small problem by using a library such as SQLAlchemy so that we can work entirely
    in Python, and leave it to SQLAlchemy to create the SQL appropriate for our database.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还研究了更复杂的持久化机制，包括`shelve`模块和SQLite数据库。这些为我们提供了在文件中对数据对象执行CRUD操作的方法。SQLite数据库要求我们使用SQL语言来描述数据访问：这可以使我们的程序更容易移植到其他数据库。同时使用SQL和Python可能会让人感到困惑。我们可以通过使用如SQLAlchemy这样的库来克服这个小问题，这样我们就可以完全在Python中工作，让SQLAlchemy来创建适合我们数据库的SQL语句。
- en: The standard library has numerous packages to handle different physical file
    formats. One of these can help to create and retrieve data in the CSV format.
    The role of the comma delimiter can be any sequence of characters, extending the
    concept so that many kinds of delimited files can be read or written by this module.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库有多个包来处理不同的物理文件格式。其中之一可以帮助创建和检索CSV格式的数据。逗号分隔符的角色可以是任何字符序列，扩展了这个概念，使得许多类型的分隔文件都可以由这个模块读取或写入。
- en: In [Chapter 11](ch11.html "Chapter 11. Class Definitions"), *Class Definitions*,
    we'll look at how we can define our own customized classes in Python. Class definitions
    are the heart of object-oriented programming. We'll touch on several of the class
    design patterns that are common in Python programming.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第11章](ch11.html "第11章。类定义")，*类定义*中，我们将探讨如何在Python中定义我们自己的定制类。类定义是面向对象编程的核心。我们将简要介绍在Python编程中常见的几种类设计模式。
