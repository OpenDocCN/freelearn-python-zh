<html><head></head><body>
  <div><div><div><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Maintaining Your Test Suite</h1></div></div></div><p>If we do TDD regularly, we can easily end up with a large test suite containing thousands of tests. This is great—it gives us a lot of confidence to boldly go in and add new features without worrying about breaking old features. However, it is crucial that we make test maintenance easy, otherwise we will soon be in a mess just managing the tests.</p><p>Tests that are not written to be maintained will soon bring about a number of headaches. Tests that are strewn all over the filesystem will make it impossible to locate specific tests. Tests that are difficult to read will be hard to understand and fix when the tests need to be changed due to changes in functionality. Long, poorly written tests will pose the same challenges that poor production quality code does. And brittle tests will ensure that even small changes will break a large number of tests.</p><p>Remember that test code is still code. And just like any production code, we must do our best to keep it readable, maintainable, and easy to change. It is easy for us to fall into the trap of hacking out test cases and then forgetting about them. A year later, we find that maintaining the tests is a huge headache, and it is more difficult to add new features than it was before.</p><div><div><div><div><h1 class="title"><a id="ch06lvl1sec44"/>Goals of test maintenance</h1></div></div></div><p>As we have seen<a id="id273" class="indexterm"/> throughout this book, unit tests serve a number of different purposes:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Serve as a test suite</strong>: This is the most obvious goal of unit tests. A comprehensive test suite reduces the number of bugs that can escape into production.</li><li class="listitem" style="list-style-type: disc"><strong>Serve as documentation</strong>: When we are trying to understand what a class or method is trying to do, it is useful to take a look at the test suite. A well-written test suite will illustrate how the piece of code is supposed to behave.</li><li class="listitem" style="list-style-type: disc"><strong>Serve as a safety net</strong>: This frees us from pressure when we refactor or clean up the code.</li><li class="listitem" style="list-style-type: disc"><strong>Illustrate the design</strong>: Using mocks, we can depict the interactions between different classes or modules.</li></ul></div><p>The goal of <a id="id274" class="indexterm"/>a well-written suite of unit tests is to enable these purposes as well as possible.</p><p>For example, if we want to understand what a method does, then we need to work out the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Can we locate its unit test suite easily?</li><li class="listitem" style="list-style-type: disc">Once located, is it easy to understand the tests and what they are testing for?</li><li class="listitem" style="list-style-type: disc">Can we understand how this method interacts with other classes?</li><li class="listitem" style="list-style-type: disc">Once we understand what the method does, then is it easy to refactor it? Does making small refactorings break all the tests?</li><li class="listitem" style="list-style-type: disc">Is it easy to identify which tests have broken due to our refactoring and which failures are bugs in the refactoring?</li><li class="listitem" style="list-style-type: disc">If we need to make changes in the test case due to the refactoring, then how difficult is it to understand the test and make the required change?</li></ul></div><p>Any large, long-term project will involve answering all these questions.</p><p>Our goal in this chapter is to look at ways to make it easier to perform the preceding activities.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec45"/>Organizing tests</h1></div></div></div><p>The first step in easing test maintenance is to have a systematic way of organizing tests. When we are implementing a new feature, we need to be able to quickly and easily locate the existing test <a id="id275" class="indexterm"/>code for a given method or class. There are three steps to making this easy. We have to decide:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Where the files are stored on the filesystem</li><li class="listitem" style="list-style-type: disc">What the files are called</li><li class="listitem" style="list-style-type: disc">The names of the test classes</li></ul></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec44"/>Filesystem layout</h2></div></div></div><p>The main <a id="id276" class="indexterm"/>consideration in deciding where to place our test<a id="id277" class="indexterm"/> code is the ease with which we can locate the tests for a specific class or module. Apart from this, there are two other considerations to keep in mind:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">How will this module be packaged and distributed?</li><li class="listitem" style="list-style-type: disc">How will this code be put into production?</li></ul></div><p>For the first consideration, we have to keep in mind that we will want to distribute unit tests along with the main code. For code that goes into production, we might not always want tests to be deployed, so we would be looking at a way to separate the code and tests.</p><p>Given all these <a id="id278" class="indexterm"/>considerations, there are two popular ways<a id="id279" class="indexterm"/> of laying out the test code.</p><p>In the first pattern, the test code is placed as a submodule of the main code like the following:</p><div><pre class="programlisting">module
|
+- file
+- file
+- tests
   |
   + test_file
   + test_file</pre></div><p>This allows us to package up both the module and the tests by just zipping up the module directory and putting it in an <code class="literal">egg</code> file. The whole package is self-contained and can be used directly. The module is accessed using an <code class="literal">import module</code> statement, and the tests are accessed by using <code class="literal">import module.tests</code>.</p><p>Running the tests also requires no configuration, as the tests can access the classes in the test code with relative imports such as <code class="literal">from ..file import class</code>.</p><p>This pattern is excellent for standalone modules that will be packaged in <code class="literal">egg</code> files and distributed.</p><p>The other pattern is to keep tests in a separate folder hierarchy altogether. The file layout will be something like the following:</p><div><pre class="programlisting">root
|
+- module
|  |
|  +- file
|  +- file
|
+- tests
   |
   + test_file
   + test_file</pre></div><p>The preceding pattern is suitable for situations where there is a need to separate out the tests from the code. This could be because we are making a product and don't want to send tests to our customers, or it could be because we don't want to deploy tests to the production servers. This pattern is suitable because it is easy to zip up the module alone into an <code class="literal">egg</code> file and deploy.</p><p>The downside <a id="id280" class="indexterm"/>of the pattern is that if the project involves <a id="id281" class="indexterm"/>many modules, then it can be troublesome to separate out tests for the different modules. One pattern is to use different roots for each directory, as shown in the following:</p><div><pre class="programlisting">root
|
+- src
|  |
|  +- module1
|     |
|     +- file
|     +- file
|
+- tests
   |
   +- module1
      |
      + test_file
      + test_file</pre></div><p>The preceding pattern is commonly seen in languages such as Java, but it is overall quite cumbersome and verbose. However, it could be a solution for specific needs like the ones mentioned previously.</p><p>Two patterns we definitely <em>don't</em> want to do are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Place the tests in the same file as the code</li><li class="listitem" style="list-style-type: disc">Place the test files in the same directory as the code</li></ul></div><p>Placing tests in the same file as code is okay for single file scripts, but it is messy for anything bigger than that. The problem is that if the file is long, then it becomes very difficult to navigate the file. And since tests often need to import other classes, it pollutes the namespace. It also increases the chances for circular imports. Finally, it makes it difficult to execute all the tests at once because the test runners look for patterns in the filename.</p><p>As for placing files in the same directory, it once again messes up the module, making it difficult to find files in the directory. It doesn't have any specific advantages apart from not having to create a separate tests directory. Avoid this pattern and create a submodule instead.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec45"/>Naming conventions</h2></div></div></div><p>The next step is<a id="id282" class="indexterm"/> to decide on a naming convention for <a id="id283" class="indexterm"/>test files, test classes, and test methods.</p><p>For test files, it is best to go with the <code class="literal">test_</code> prefix for the file. For example, a file called <code class="literal">file1.py</code> will have its tests in <code class="literal">test_file1.py</code>. This makes it easy for us to locate the corresponding test code when we are looking at some production code. Having the <code class="literal">test_</code> prefix is preferable because this is the default pattern that is searched by most test runners. If we use some other prefix, or use a suffix like <code class="literal">file1_test.py</code>, then most probably we will have to pass additional configuration into the test runner to find and execute the tests. This extra configuration is easily avoidable by just sticking to the default convention that is expected from most of the commonly used tools.</p><p>For example, we can run the tests with the following command:</p><div><pre class="programlisting"><strong>python3 -m unittest discover</strong>
</pre></div><p>But if we were to name our tests with a suffix of <code class="literal">_test</code>, then we have to use the following command:</p><div><pre class="programlisting"><strong>python3 -m unittest discover -p *_test.py</strong>
</pre></div><p>It works, but it is just extra configuration that can be avoided. We should use this only if we have a legacy naming convention that needs to be preserved.</p><p>What about test classes and test methods? The <code class="literal">unittest</code> module looks at all classes that inherit from <code class="literal">unittest.TestCase</code>. So, the class name does not matter. However, other test runners such as <code class="literal">nose2</code> also pick up test classes based on the name of the class. The default pattern is to search for classes that end with <code class="literal">Test</code>. It therefore makes sense to name all the test classes to end with <code class="literal">Test</code>. It is also descriptive, so there really is no good reason to do anything else.</p><p>Similarly, test methods should start with <code class="literal">test</code>. This is the default pattern that test runners search for, and once again it makes sense to just stick to this convention. Methods that do not start with <code class="literal">test</code> can be used as helper methods.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec46"/>Test suite grouping</h2></div></div></div><p>Finally, we come to the question of what a class should contain—should one test class contain tests for a target class, or should we store all the tests for a method in a test class? Here, it is<a id="id284" class="indexterm"/> more a question of personal preference. Neither is objectively better or worse, it just depends on which is more readable. My personal preference is to use both patterns within a single codebase, depending on how many tests there are and which pattern makes it easier to find the tests that I am looking for. In general, if there are a lot of tests for a single method, then I would refactor them into a separate test class.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec46"/>Making tests readable</h1></div></div></div><p>In the previous section, we looked at the rather mundane issue of file layout and naming conventions. We <a id="id285" class="indexterm"/>are now going to take a look at the ways we can improve the test cases themselves.</p><p>Our first goal is to make it easier to understand the tests themselves.  There is nothing worse than locating a test case and then having a hard time figuring out what the test is trying to do.</p><p>I'm sure I will not be the first to confess that there have been multiple occasions where I have returned to a test that I myself wrote a year back, and struggled to understand what I was trying to do.</p><p>This is an area that is often ignored because when we write the test, it seems perfectly obvious what the test does. We will need to put ourselves in the shoes of someone who is looking at the test for the first time or after a couple of years and trying to understand the test without having the contextual knowledge that we had while writing the test. This is a recurring problem when working on large codebases.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec47"/>Using docstrings</h2></div></div></div><p>The first line <a id="id286" class="indexterm"/>of defense for an unreadable test is to use a <a id="id287" class="indexterm"/>docstring. <strong>Docstrings</strong> are a great feature of Python because they are available at runtime. Test runners typically pick up a docstring and display it<a id="id288" class="indexterm"/> during test errors and failures, making it easy to see what is failing from the test report itself.</p><p>Some people will say that a well-written test has no need for additional explanation. In fact, we said something similar in <a class="link" href="ch03.html" title="Chapter 3. Code Smells and Refactoring">Chapter 3</a>, <em>Code Smells and Refactoring</em> when we discussed the value of comments. To repeat what we said there: there is no value in comments that explain what is going on, but there is value in comments that explain why we have implemented the code as we have. The same principle applies to docstrings as well.</p><p>For example, take a look at the following code:</p><div><pre class="programlisting">    def get_closing_price_list(self, on_date, num_days):
        closing_price_list = []
        for i in range(num_days):
            chk = on_date.date() - timedelta(i)
            for price_event in reversed(self.series):
                if price_event.timestamp.date() &gt; chk:
                    pass
                if price_event.timestamp.date() == chk:
                    closing_price_list.insert(0, price_event)
                    break
                if price_event.timestamp.date() &lt; chk:
                    closing_price_list.insert(0, price_event)
                    break
        return closing_price_list</pre></div><p>This is the <code class="literal">get_closing_price_list</code> method from the <code class="literal">TimeSeries</code> class that we refactored in <a id="id289" class="indexterm"/>
<a class="link" href="ch03.html" title="Chapter 3. Code Smells and Refactoring">Chapter 3</a>, <em>Code Smells and Refactoring</em>. The following is<a id="id290" class="indexterm"/> a test for that method:</p><div><pre class="programlisting">class TimeSeriesTest(unittest.TestCase):
    def test_closing_price_list_before_series_start_date(self):
        series = TimeSeries()
        series.update(datetime(2014, 3, 10), 5)
        on_date = datetime(2014, 3, 9)
        self.assertEqual([], series.get_closing_price_list(on_date, 1))</pre></div><p>This test checks that an empty list is returned when the date passed is before the start of the timeseries. This is quite clear from the test. But why does it return an empty list instead of, say, throwing an exception? A docstring provides a good place to explain this design decision, as shown in the following:</p><div><pre class="programlisting">    def test_closing_price_list_before_series_start_date(self):
        """
        Empty list is returned if on_date is before the start of the
        series
        The moving average calculation might be done before any data
        has been added to the stock. We return an empty list so that
        the calculation can still proceed as usual.
        """
        series = TimeSeries()
        series.update(datetime(2014, 3, 10), 5)
        on_date = datetime(2014, 3, 9)
        self.assertEqual([], series.get_closing_price_list(on_date, 1))</pre></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec48"/>Using fixtures</h2></div></div></div><p>Having looked at <a id="id291" class="indexterm"/>docstrings, we can now turn our attention to<a id="id292" class="indexterm"/> the tests themselves.</p><p>If we look at the general structure of unit tests, they generally follow the Arrange-Act-Assert structure. Of these, the Act section is usually only a couple of lines and the Assert section is also a few lines at most. By far the biggest part of the test is in the Arrange section. For more complex tests, where a specific scenario might take many lines to set up, the Arrange section could easily be 75 percent to 80 percent of the whole test.</p><p>One way of avoiding repetitive code is to move it all into the appropriate <code class="literal">setUp</code> and <code class="literal">tearDown</code> methods. As we saw in <a class="link" href="ch02.html" title="Chapter 2. Red-Green-Refactor – The TDD Cycle">Chapter 2</a>, <em>Red-Green-Refactor – The TDD Cycle</em>, <code class="literal">unittest</code> provides three levels of setup and teardown methods:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">setUp</code> and <code class="literal">tearDown</code> that are run before and after each test</li><li class="listitem" style="list-style-type: disc"><code class="literal">setUpClass</code> and <code class="literal">tearDownClass</code> that are run before and after each test class</li><li class="listitem" style="list-style-type: disc"><code class="literal">setUpModule</code> and <code class="literal">tearDownModule</code> that are run before and after each test file</li></ul></div><p>This<a id="id293" class="indexterm"/> method of setting up the data for a test is called a <strong>fixture</strong>. Using<a id="id294" class="indexterm"/> fixtures is a good idea to reduce common code duplication between tests. However, there are some downsides to be aware of:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Sometimes, there is a lot of setup to be done, but each of the tests only use a small part of the overall fixture. In this case, it can be confusing for a new developer to figure out which part of the fixture is used by each test.</li><li class="listitem" style="list-style-type: disc">We have to be careful when using class- and module-level fixtures. Because the fixture is shared between multiple tests, we have to be careful that we don't change the state of the fixture. If we do, then there is the possibility that the result of one test could alter the fixture state for the next. This could lead to very strange bugs when tests are executed in a different order.</li></ul></div><p>One thing to be aware of is that if the <code class="literal">setUp</code> method throws an exception, then the <code class="literal">tearDown</code> method is not called. Take the following example:</p><div><pre class="programlisting">class SomeTest(unittest.TestCase):
    def setUp(self):
        connect_to_database()
        connect_to_server()

    def tearDown(self):
        disconnect_from_database()
        disconnect_from_server()</pre></div><p>If an exception is raised in the <code class="literal">connect_to_server</code> call, then the <code class="literal">tearDown</code> method will not be called. This will leave the connection to the database hanging open. When <code class="literal">setUp</code> is called for the next test, the first line might fail (because the connection is already open), causing all the other tests to fail.</p><p>To avoid this situation, the <code class="literal">unittest</code> module provides the <code class="literal">addCleanup</code> method. This method takes a callback function, which is called no matter whether the setup passed or failed, as shown in the following:</p><div><pre class="programlisting">class SomeTest2(unittest.TestCase):
    def setUp(self):
        connect_to_database()
        self.addCleanup(self.disconnect_database)
        connect_to_server()
        self.addCleanup(self.disconnect_server)

    def disconnect_database(self):
        disconnect_from_database()

    def disconnect_server(self):
        disconnect_from_server()</pre></div><p>With this<a id="id295" class="indexterm"/> structure, how execution will flow is given as<a id="id296" class="indexterm"/> follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">If the database call failed, then no cleanup will be performed</li><li class="listitem" style="list-style-type: disc">If the database call succeeded but the server call failed, then <code class="literal">disconnect_database</code> will be called during cleanup</li><li class="listitem" style="list-style-type: disc">If both calls succeeded, then both <code class="literal">disconnect_database</code> and <code class="literal">disconnect_server</code> will be called during cleanup</li></ul></div><p>When would we use <code class="literal">addCleanup</code> versus <code class="literal">tearDown</code>? In general, when accessing resources that must be closed, <code class="literal">addCleanup</code> is the way to go. <code class="literal">tearDown</code> is a good place to put other types of cleanup, or in cases where <code class="literal">setUp</code> cannot throw an exception.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec49"/>Fixtures and patching</h2></div></div></div><p>There is <a id="id297" class="indexterm"/>one complication in using <a id="id298" class="indexterm"/>patched mocks along with fixtures. Take a look at the following code:</p><div><pre class="programlisting">@mock.patch.object(smtplib, "SMTP")
class EmailActionTest(unittest.TestCase):
    def setUp(self):
        self.action = EmailAction(to="siddharta@silverstripesoftware.com")

    def test_connection_closed_after_sending_mail(self, mock_smtp_class):
        mock_smtp = mock_smtp_class.return_value
        self.action.execute("MSFT has crossed $10 price level")
        mock_smtp.send_message.assert_called_with(mock.ANY)
        self.assertTrue(mock_smtp.quit.called)
        mock_smtp.assert_has_calls([
            mock.call.send_message(mock.ANY),
            mock.call.quit()])</pre></div><p>This is one of the tests for the <code class="literal">EmailAction</code> class that we looked at earlier. The <code class="literal">patch</code> decorator is used at a class level to patch the <code class="literal">smtplib.SMTP</code> class and pass the mock as a parameter to all the test cases. Because of the way the patch decorator works, it only passes the mock to the test case methods, which means that we cannot access it in our <code class="literal">setUp</code> method.</p><p>If we look<a id="id299" class="indexterm"/> at this test, it uses the <code class="literal">mock_smtp</code> object, which is derived from <code class="literal">mock_smtp_class</code>. The line that gets the <code class="literal">mock_smtp</code> object<a id="id300" class="indexterm"/> can be moved into the <code class="literal">setUp</code> method, if only we could access <code class="literal">mock_smtp_class</code> over there. Is there a way by which we can apply the patch in the <code class="literal">setUp</code> method so that we can do some common setup with the mock?</p><p>Fortunately, the <code class="literal">unittest</code> module gives us the tools to do just this. Instead of using the decorator syntax for patching, we will use the regular object syntax like the following:</p><div><pre class="programlisting">    def setUp(self):
        patcher = mock.patch("smtplib.SMTP")
        self.addCleanup(patcher.stop)
        self.mock_smtp_class = patcher.start()
        self.mock_smtp = self.mock_smtp_class.return_value
        self.action = EmailAction(to="siddharta@silverstripesoftware.com")</pre></div><p>What we are doing here is passing the object to be patched—in this case <code class="literal">smtplib.SMTP</code>—to the <code class="literal">patch</code> function. This returns a patcher object with two methods: <code class="literal">start</code> and <code class="literal">stop</code>. When we call the <code class="literal">start</code> method, the patch is applied, and when we call the <code class="literal">stop</code> method, the patch is removed.</p><p>We set the <code class="literal">patcher.stop</code> method to be executed during the test cleanup phase by passing it to the <code class="literal">addCleanup</code> function. We then start the patch. The <code class="literal">start</code> method returns the mock object, which we use for the rest of the setup.</p><p>With this setup, we can use <code class="literal">self.mock_smtp</code> directly in our tests, without having to get it from <code class="literal">mock_smtp_class</code> in every test. The test would now look like the following:</p><div><pre class="programlisting">    def test_connection_closed_after_sending_mail(self):
        self.action.execute("MSFT has crossed $10 price level")
        self.mock_smtp.send_message.assert_called_with(mock.ANY)
        self.assertTrue(self.mock_smtp.quit.called)
        self.mock_smtp.assert_has_calls([
            mock.call.send_message(mock.ANY),
            mock.call.quit()])</pre></div><p>Compare this test with the one earlier in this section. Since we are not using the decorator patch syntax, we no longer need the extra parameter. We also don't need to derive <code class="literal">mock_smtp</code> from <code class="literal">mock_smtp_class</code> in every test. Instead, all that work is done in <code class="literal">setUp</code>. The test can then access <code class="literal">self.mock_smtp</code> and use it directly.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec50"/>Using a custom test case class hierarchy</h2></div></div></div><p>One more way of reducing code duplication is to create our own test class hierarchy. For example, if a helper method is used often in many test classes, then we can pull it up to a higher <a id="id301" class="indexterm"/>class and inherit test classes <a id="id302" class="indexterm"/>from that instead. The following is an example to make the concept clearer:</p><div><pre class="programlisting">class MyTestCase(unittest.TestCase):
    def create_start_object(self, value):
        do_something(value)

class SomeTest(MyTestCase):
    def test_1(self):
        create_start_object("value 1")

class SomeTest2(MyTestCase):
    def test_2(self):
        create_start_object("value 2")

    def test_3(self):
        create_start_object("value 3")</pre></div><p>In this example, we create a class called <code class="literal">MyTestCase</code> that inherits from <code class="literal">unittest.TestCase</code>, and we put in some helper methods in this class. The actual test classes inherit from <code class="literal">MyTestCase</code> and can access the helper methods that are in the parent class.</p><p>Using this technique, we can take common groups of helper methods and put them into reusable parent classes. The hierarchy need not be only one level deep; sometimes, we might create further subclasses for specific areas of the application that we are testing.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec47"/>Writing tests closer to the domain</h1></div></div></div><p>The other way to make tests easier to read is to write tests in terms of the domain language instead of just the generic functions provided by <code class="literal">unittest</code>. In this section, we look at some ways to do this.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec51"/>Writing helper methods</h2></div></div></div><p>The first<a id="id303" class="indexterm"/> technique is to write helper methods. We employed this<a id="id304" class="indexterm"/> technique earlier in this book. The following are some tests that don't use a helper method:</p><div><pre class="programlisting">    def test_increasing_trend_is_false_if_price_decreases(self):
        timestamps = [datetime(2014, 2, 11), datetime(2014, 2, 12),
                      datetime(2014, 2, 13)]
        prices = [8, 12, 10]
        for timestamp, price in zip(timestamps, prices):
            self.goog.update(timestamp, price)
        self.assertFalse(self.goog.is_increasing_trend())

    def test_increasing_trend_is_false_if_price_equal(self):
        timestamps = [datetime(2014, 2, 11), datetime(2014, 2, 12),
                      datetime(2014, 2, 13)]
        prices = [8, 10, 10]
        for timestamp, price in zip(timestamps, prices):
            self.goog.update(timestamp, price)
        self.assertFalse(self.goog.is_increasing_trend())</pre></div><p>While the<a id="id305" class="indexterm"/> tests are short, it isn't really <a id="id306" class="indexterm"/>clear what is happening in the tests. Let's move some of that code into a helper method, as shown in the following:</p><div><pre class="programlisting">    def given_a_series_of_prices(self, prices):
        timestamps = [datetime(2014, 2, 10), datetime(2014, 2, 11),
                      datetime(2014, 2, 12), datetime(2014, 2, 13)]
        for timestamp, price in zip(timestamps, prices):
        self.goog.update(timestamp, price)</pre></div><p>The following are the same two tests using the new helper method:</p><div><pre class="programlisting">    def test_increasing_trend_is_false_if_price_decreases(self):
        self.given_a_series_of_prices([8, 12, 10])
        self.assertFalse(self.goog.is_increasing_trend())

    def test_increasing_trend_is_false_if_price_equal(self):
        self.given_a_series_of_prices([8, 10, 10])
        self.assertFalse(self.goog.is_increasing_trend())</pre></div><p>As we can see, the tests are a lot clearer now. This is because the helper method clearly expresses the intent of the calculation, making it easy for a new developer to correlate the steps in the test case with their mental model of the requirements.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec52"/>Writing better asserts</h2></div></div></div><p>An easy <a id="id307" class="indexterm"/>way to enhance test readability is to write our own assert<a id="id308" class="indexterm"/> methods that are higher level than the generic asserts provided by <code class="literal">unittest</code>. For example, suppose we wanted to write a test to verify the price history of a stock. The following is how such a test might look:</p><div><pre class="programlisting">class TimeSeriesEqualityTest(unittest.TestCase):
    def test_timeseries_price_history(self):
        series = TimeSeries()
        series.update(datetime(2014, 3, 10), 5)
        series.update(datetime(2014, 3, 11), 15)
        self.assertEqual(5, series[0].value)
        self.assertEqual(15, series[1].value)</pre></div><p>Now, another way to write the test is as follows:</p><div><pre class="programlisting">class TimeSeriesTestCase(unittest.TestCase):
    def assert_has_price_history(self, price_list, series):
        for index, expected_price in enumerate(price_list):
            actual_price = series[index].value
            if actual_price != expected_price:
                raise self.failureException("[%d]: %d != %d".format(index, expected_price, actual_price))

class TimeSeriesEqualityTest(TimeSeriesTestCase):
    def test_timeseries_price_history(self):
        series = TimeSeries()
        series.update(datetime(2014, 3, 10), 5)
        series.update(datetime(2014, 3, 11), 15)
        self.assert_has_price_history([5, 15], series)</pre></div><p>In the<a id="id309" class="indexterm"/> preceding example, we have created our own base test class and <a id="id310" class="indexterm"/>with a custom assert method. The test case inherits from this base test class and uses the assert in the test.</p><p>The implementation of the <code class="literal">assert_has_price_history</code> method gives an idea of how simple it is to write our own assert methods. All we have to do is to implement our assertion logic, and raise <code class="literal">self.failureException</code> whenever the assert should signal a test failure. <code class="literal">self.failureException</code> is an attribute of <code class="literal">unittest.TestCase</code>, and it is usually set to the <code class="literal">AssertionError</code> exception. We could raise <code class="literal">AssertionError</code> ourselves, but the <code class="literal">unittest</code> module allows us to configure using a different exception, so it is best to raise <code class="literal">self.failureException</code>, which is always set to the correct value to be used.</p><p>When the same sequence of asserts is made again and again in multiple tests, we should see whether there is an opportunity to replace the calls to the built-in asserts with a higher level assert that more clearly expresses the intent that we want to convey.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec53"/>Using custom equality checkers</h2></div></div></div><p>A cool <a id="id311" class="indexterm"/>feature of the <code class="literal">assertEqual</code> method is the way it gives <a id="id312" class="indexterm"/>custom failure messages depending on the type of object being compared. If we try to assert two integers, the following is what we get:</p><div><pre class="programlisting"><strong>&gt;&gt;&gt; import unittest</strong>
<strong>&gt;&gt;&gt; testcase = unittest.TestCase()</strong>
<strong>&gt;&gt;&gt; testcase.assertEqual(1, 2)</strong>
<strong>Traceback (most recent call last):</strong>
<strong>    ...</strong>
<strong>AssertionError: 1 != 2</strong>
</pre></div><p>On the other hand, asserting lists gives us another message showing the difference in the expected and actual lists, as shown in the following:</p><div><pre class="programlisting"><strong>&gt;&gt;&gt; import unittest</strong>
<strong>&gt;&gt;&gt; testcase = unittest.TestCase()</strong>
<strong>&gt;&gt;&gt; testcase.assertEqual([1, 2], [1, 3])</strong>
<strong>Traceback (most recent call last):</strong>
<strong>    ...</strong>
<strong>AssertionError: Lists differ: [1, 2] != [1, 3]</strong>

<strong>First differing element 1:</strong>
<strong>2</strong>
<strong>3</strong>

<strong>- [1, 2]</strong>
<strong>?     ^</strong>

<strong>+ [1, 3]</strong>
<strong>?     ^</strong>
</pre></div><p>Under the <a id="id313" class="indexterm"/>hood, <code class="literal">assertEqual</code> delegates to a different <a id="id314" class="indexterm"/>function depending on the type of object being compared. This is how we get specific and relevant equality checks for most common built-in data structures such as strings, sequences, lists, tuples, sets, and dicts.</p><p>Fortunately, this flexible system is open to use by developers, which means we can add our own equality checkers for our application objects. The following is a default scenario where we try to compare two <code class="literal">Stock</code> objects:</p><div><pre class="programlisting"><strong>&gt;&gt;&gt; import unittest</strong>
<strong>&gt;&gt;&gt; from stock_alerter.stock import Stock</strong>
<strong>&gt;&gt;&gt; test_case = unittest.TestCase()</strong>
<strong>&gt;&gt;&gt; stock_1 = Stock("GOOG")</strong>
<strong>&gt;&gt;&gt; stock_2 = Stock("GOOG")</strong>
<strong>&gt;&gt;&gt; test_case.assertEqual(stock_1, stock_2)</strong>
<strong>Traceback (most recent call last):</strong>
<strong>    ...</strong>
<strong>AssertionError: &lt;stock_alerter.stock.Stock object at 0x000000000336EDD8&gt; != &lt;stock_alerter.stock.Stock object at 0x00000000033E9588&gt;</strong>
</pre></div><p>The assertion fails because although both objects contain the same data, they are still different objects in memory. Now let's try to register our own equality function for the <code class="literal">Stock</code> class that just compares the symbol to identify equality between <code class="literal">Stock</code> objects. All we have to do is to register our checker using the <code class="literal">addTypeEqualityFunc</code> method like the following:</p><div><pre class="programlisting"><strong>&gt;&gt;&gt; test_case.addTypeEqualityFunc(Stock, lambda stock_1, stock_2, msg: stock_1.symbol == stock_2.symbol)</strong>
<strong>&gt;&gt;&gt; test_case.assertEqual(stock_1, stock_2)</strong>
<strong>&gt;&gt;&gt; print(test_case.assertEqual(stock_1, stock_2))</strong>
<strong>None</strong>
<strong>&gt;&gt;&gt;</strong>
</pre></div><p>The equality <a id="id315" class="indexterm"/>checker takes three parameters: the first object, the <a id="id316" class="indexterm"/>second object, and the optional message that the user passed to <code class="literal">assertEqual</code>. Once we register the function like this, we can call <code class="literal">assertEqual</code> passing in two <code class="literal">Stock</code> objects and <code class="literal">assertEqual</code> will delegate the comparison to the function that we registered.</p><p>Using equality functions this way is a nice way to assert application domain objects in the unit test code. This method has two limitations though:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We have to use the same comparison function for a given type. There is no way to use one comparison function in some tests and another comparison function in other tests.</li><li class="listitem" style="list-style-type: disc">Both parameters to <code class="literal">assertEqual</code> have to be objects of that type. There is no way we can pass in two objects of differing types.</li></ul></div><p>Both these limitations can be overcome using matchers, which is what we will now turn our attention to.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec54"/>Using matchers</h2></div></div></div><p>A third <a id="id317" class="indexterm"/>way to make asserts more readable is to create custom matcher<a id="id318" class="indexterm"/> objects to make comparisons more readable during assertions. We saw a glimpse of using matchers while writing tests for the <code class="literal">EmailAction</code> class earlier. The following is a look at that matcher again:</p><div><pre class="programlisting">class MessageMatcher:
    def __init__(self, expected):
        self.expected = expected

    def __eq__(self, other):
        return self.expected["Subject"] == other["Subject"] and \
            self.expected["From"] == other["From"] and \
            self.expected["To"] == other["To"] and \
            self.expected["Message"] == other._payload</pre></div><p>A matcher can be any class that implements the <code class="literal">__eq__</code> method. The method will take the actual object as a parameter and the method can implement any comparison logic required. Using this method, we can directly compare domain objects in the assertion without cluttering it with a number of separate asserts.</p><p>The matcher<a id="id319" class="indexterm"/> does not need to compare complete domain objects. We can compare only the attributes that we are interested in. In fact, we can create different matchers to match against specific subsets of objects. For example, we might create an <code class="literal">AlertMessageMatcher</code> like the following:</p><div><pre class="programlisting">class AlertMessageMatcher:
    def __init__(self, expected):
        self.expected = expected

    def __eq__(self, other):
        return self.expected["Subject"] == "New Stock Alert" and \
            self.expected["From"] == other["From"] and \
            self.expected["To"] == other["To"] and \
            self.expected["Message"] == other._payload</pre></div><p>This<a id="id320" class="indexterm"/> matcher will only match alert messages that have the given subject, while taking the other parameters from the expected object.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec48"/>Summary</h1></div></div></div><p>In this chapter, you looked a little more in detail at the important but often overlooked topic of keeping tests maintainable. You looked at the importance of having a consistent test file layout scheme and the pros and cons of various alternatives. You looked at naming tests and grouping tests, before moving to the topic of making tests easier to understand. Some of the strategies that we discussed were using docstrings, creating custom test class hierarchies, and utilizing fixtures. Finally, you looked at making code more readable by using helper functions, custom asserts, equality functions, and writing custom matchers.</p><p>In the next chapter, you will look at incorporating tests in your documentation using the <code class="literal">doctest</code> module.</p></div></div>
</body></html>