- en: Working with Models, SQLAlchemy, and Hyperlinked APIs in Flask
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will expand the capabilities of the RESTful API that we
    started in the previous chapter. We will use SQLAlchemy as our ORM to work with
    a PostgreSQL database, and we will take advantage of advanced features included
    in Flask and Flask-RESTful that will allow us to easily organize code for complex
    APIs, such as models and blueprints.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will go through the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Design a RESTful API to interact with a PostgreSQL 10.5 database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand the tasks performed by each HTTP method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Install packages with the `requirements.txt` file to simplify our common tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configure the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write code for the models with their ...
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing a RESTful API to interact with a PostgreSQL 10.5 database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, our RESTful API has performed CRUD operations on a simple in-memory
    dictionary that acted as a data repository. The dictionary is never persisted
    and, therefore, the data is lost whenever we restart our Flask development server.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we want to create a more complex RESTful API with Flask RESTful to interact
    with a database model that allows us to work with notifications that are grouped
    into notification categories. In our previous RESTful API, we used a string attribute
    to specify the notification category for a notification. In this case, we want
    to be able to easily retrieve all the notifications that belong to a specific
    notification category and, therefore, we will have a relationship between a notification
    and a notification category.
  prefs: []
  type: TYPE_NORMAL
- en: 'We must be able to perform CRUD operations on different related resources and
    resource collections. The following table enumerates the resources and the class
    name that we will create to represent the model:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Resources | Class name that represents the model |'
  prefs: []
  type: TYPE_TB
- en: '| Notification categories | `NotificationCategory` |'
  prefs: []
  type: TYPE_TB
- en: '| Notifications | `Notification` |'
  prefs: []
  type: TYPE_TB
- en: 'The notification category (`NotificationCategory`) just requires the following
    data:'
  prefs: []
  type: TYPE_NORMAL
- en: An integer identifier
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A string name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We need the following data for a notification (`Notification`):'
  prefs: []
  type: TYPE_NORMAL
- en: An integer identifier
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A foreign key to a notification category (`NotificationCategory`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A string message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **TTL** (short for **Time to Live**), that is, a duration in seconds that
    will indicate the amount of time the notification message has to be displayed
    on the OLED display
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A creation date and time. The timestamp will be added automatically when adding
    a new notification to the collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An integer counter that indicates the times when the notification message has
    been displayed on the OLED display
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A bool value indicating whether the notification message was displayed at least
    once on the OLED display
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will take advantage of many packages related to Flask RESTful and SQLAlchemy
    that make it easier to serialize and deserialize data, perform validations, and
    integrate SQLAlchemy with Flask and Flask RESTful. This way, we will reduce the
    boilerplate code.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the tasks performed by each HTTP method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following table shows the HTTP verbs, the scope, and the semantics for
    the methods that our new API must support. Each method is composed by an HTTP
    verb and a scope, and all the methods have well-defined meanings for all the resources
    and collections:'
  prefs: []
  type: TYPE_NORMAL
- en: '| HTTP verb | Scope | Semantics |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | Collection of notification categories | Retrieve all the stored notification
    categories in the collection, sorted by their name in ascending order. Each notification
    category must include the full URL for the resource. In addition, each notification
    category must include a list containing all the details of the notifications that
    belong to the category. The notifications don''t have to include ... |'
  prefs: []
  type: TYPE_TB
- en: Installing packages with the requirements.txt file to simplify our common tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Make sure you quit Flask's development server. You just need to press *Ctrl*
    + *C* in the Terminal or Command Prompt window in which it is running.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will install a number of additional packages. Make sure you have activated
    the virtual environment we created in the previous chapter and named `Flask01`.
    After you activate the virtual environment, it is time to run numerous commands,
    which will be the same for either macOS, Linux, or Windows.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will edit the existing `requirements.txt` file to specify the additional
    set of packages that our application requires to be installed in any supported
    platform. This way, it will be extremely easy to repeat the installation of the
    specified packages with their versions in any new virtual environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use your favorite editor to edit the existing text file named `requirements.txt`
    within the root folder for the virtual environment. Add the following lines after
    the last line to declare the additional packages and the versions that our new
    version of the API requires. The code file for the sample is included in the `restful_python_2_02_01`
    folder, in the `Flask01/requirements.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Each additional line added to the `requirements.txt` file indicates the package
    and the version that needs to be installed. The following table summarizes the
    packages and the version numbers that we specified as additional requirements
    to the previously included packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Package name | Version to be installed |'
  prefs: []
  type: TYPE_TB
- en: '| `Flask-SQLAlchemy` | 2.3.2 |'
  prefs: []
  type: TYPE_TB
- en: '| `Flask-Migrate` | 2.2.1 |'
  prefs: []
  type: TYPE_TB
- en: '| `marshmallow` | 2.16.0 |'
  prefs: []
  type: TYPE_TB
- en: '| `marshmallow-sqlalchemy` | 0.14.1 |'
  prefs: []
  type: TYPE_TB
- en: '| `flask-marshmallow` | 0.9.0 |'
  prefs: []
  type: TYPE_TB
- en: '| `psycopg2` | 2.7.5 |'
  prefs: []
  type: TYPE_TB
- en: '`Flask-SQLAlchemy` adds support for the SQLAlchemy ORM to Flask applications.
    This extension simplifies executing common SQLAlchemy tasks within a Flask application.
    SQLAlchemy is a dependency for `Flask-SQLAlchemy`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Flask-Migrate` uses the Alembic package to handle SQLAlchemy database migrations
    for Flask applications. We will use `Flask-Migrate` to set up our PostgreSQL database.'
  prefs: []
  type: TYPE_NORMAL
- en: If you've worked with previous versions of `Flask-Migrate`, it is very important
    to notice that Flask-Script is no longer a dependency for `Flask-Migrate` . Flask-Script
    was a popular package that added support for writing external scripts in Flask,
    including scripts to set up a database. The newest Flask versions install the
    `flask` script and a command-line interface based on the Click package in the
    virtual environment. Hence, it is no longer necessary to combine `Flask-Migrate`
    with Flask-Script.
  prefs: []
  type: TYPE_NORMAL
- en: Marshmallow is a lightweight library for converting complex datatypes to and
    from native Python datatypes. Marshmallow provides schemas that we can use to
    validate input data, deserialize input data to app-level objects, and serialize
    app-level objects to Python primitive types.
  prefs: []
  type: TYPE_NORMAL
- en: '`marshmallow-sqlalchemy` provides SQLAlchemy integration with the previously
    installed `marshmallow` validation, serialization, and deserialization lightweight
    library.'
  prefs: []
  type: TYPE_NORMAL
- en: Flask-Marshmallow integrates the previously installed `marshmallow` library
    with Flask applications and makes it easy to generate URL and hyperlink fields.
  prefs: []
  type: TYPE_NORMAL
- en: Psycopg 2 (`psycopg2`) is a Python-PostgreSQL database adapter and SQLAlchemy
    will use it to interact with our recently created PostgreSQL database. Again,
    it is very important to make sure that the PostgreSQL `bin` folder is included
    in the `PATH` environmental variable before we run the installation for this package.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we must run the following command on macOS, Linux, or Windows to install
    the additional packages and the versions explained in the previous table with
    `pip` by using the recently edited `requirements` file. Make sure you are located
    in the folder that has the `requirements.txt` file before running the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The last lines for the output will indicate that all the new packages and their
    dependencies have been successfully installed. If you downloaded the source code
    for the example and you didn''t work with the previous version of the API, `pip`
    will also install the other packages included in the `requirements.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Creating the database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we will create the PostgreSQL 10.5 database that we will use as a repository
    for our API. You will have to download and install a PostgreSQL database server
    if you aren't already running it in your computer or on a development server.
    You can download and install this database management system from its web page
    ([http://www.postgresql.org)](http://www.postgresql.org). If you are working with
    macOS, `Postgres.app` provides a really easy way to install and use PostgreSQL
    on this operating system. You can refer to it from [http://postgresapp.com](http://postgresapp.com).
    If you are working with Windows, EnterpriseDB and BigSQL provide graphics installers
    that simplify the configuration process on modern Windows server or desktop versions
    (visit [https://www.postgresql.org/download/windows ...](https://www.postgresql.org/download/windows)
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are using the same virtual environment we have created for the previous
    example, or you downloaded the code sample, the `service` folder already exists.
    If you created a new virtual environment, create a folder named `service` within
    the root folder for the  virtual environment created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new `config.py` file within the `service` folder. The following lines
    show the code that declares variables that determine the configuration for Flask
    and SQLAlchemy. The `SQL_ALCHEMY_DATABASE_URI` variable generates an SQLAlchemy
    URI for the PostgreSQL database. Make sure you specify the desired database name
    in the value for `DB_NAME` and that you configure the user, password, host, and
    port based on your PostgreSQL configuration. If you followed the previous steps,
    use the settings specified in these steps. The code file for the sample is included
    in the `restful_python_2_02_01` folder, in the `Flask01/service/config.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We will specify the previously created module (`config`) as an argument to a
    function that will create a Flask app. This way, we have one module that specifies
    all the values for the different configuration variables related to SQLAlchemy,
    and another module that creates a Flask app. We will create the Flask app factory
    as our final step toward our new API.
  prefs: []
  type: TYPE_NORMAL
- en: Creating models with their relationships
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we will create the models that we will use to represent and persist the
    notification categories, notifications, and their relationships in the PostgreSQL
    database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `service/models.py` file and replace its contents with the following
    code. The lines that declare fields related to other models are highlighted in
    the code listing. If you created a new virtual environment, create a new `models.py`
    file within the `service` folder. The code file for the sample is included in
    the `restful_python_2_02_01` folder, in the `Flask01/service/models.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Creating schemas to validate, serialize, and deserialize models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we will create the Flask-Marshmallow schemas that we will use to validate,
    serialize, and deserialize the previously declared `NotificationCategory` and
    `Notification` models, and their relationships.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `models.py` file within the `service` folder and add the following
    code after the last line. The lines that declare fields related to other schemas
    are highlighted in the code listing. The code file for the sample is included
    in the `restful_python_2_02_01` folder, in the `Flask01/service/models.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The code declares the following two schemas, that is, two subclasses of the
    `ma.Schema` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '`NotificationCategorySchema`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NotificationSchema`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We don't use the Flask-Marshmallow features that allow us to automatically determine
    the appropriate type for each attribute based on the fields declared in a model
    because we want to use specific options for each field.
  prefs: []
  type: TYPE_NORMAL
- en: We declare the attributes that represent fields as instances of the appropriate
    classes declared in the `marshmallow.fields` module. Whenever we specify the `True`
    value for the `dump_only` argument, it means that we want the field to be read-only.
    For example, we won't be able to provide a value for the `id` field in any of
    the schemas. The value for this field will be automatically generated by the auto-increment
    primary key in the PostgreSQL database.
  prefs: []
  type: TYPE_NORMAL
- en: The `NotificationCategorySchema` class declares the `name` attribute as an instance
    of `fields.String`. The `required` argument is set to `True` to specify that the
    field cannot be an empty string. The `validate` argument is set to `validate.Length(3)`
    to specify that the field must have a minimum length of three characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The class declares the `url` field with the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `url` attribute is an instance of the `ma.URLFor` class and this field
    will output the full URL of the resource, that is, the URL for the notification
    category. The first argument is the Flask endpoint''s name: `''service.notificationcategoryresource''`.
    We will create a `NotificationCategoryResource` class later and the `URLFor` class
    will use it to generate the URL. The `id` argument specifies `''<id>''` because
    we want the `id` to be pulled from the object to be serialized. The `id` string
    enclosed within less than (`<`) and greater than (`>`) symbols specifies that
    we want the field to be pulled from the object that has to be serialized. The
    `_external` attribute is set to `True` because we want to generate the full URL
    for the resource. This way, every time we serialize a `NotificationCategory`,
    it will include the full URL for the resource in the `url` key or property.'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we are using our insecure API behind HTTP. If our API is configured
    with HTTPS, we should set the `_scheme` argument to `'https'` when we create the
    `ma.URLFor` instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The class declares the `notifications` field with the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `notifications` attribute is an instance of the `marshmallow.fields.Nested`
    class, and this field will nest a collection of `Schema`, so, therefore, we specify
    `True` for the `many` argument. The first argument specifies the name for the
    nested `Schema` class as a string. We declare the `NotificationSchema` class after
    we defined the `NotificationCategorySchema` class. Thus, we specify the `Schema`
    class name as a string instead of using the type that we haven't defined yet.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, we will end up with two objects that nest to each other; that is, we
    will create a two-way nesting between notification categories and notifications.
    We use the `exclude` parameter with a tuple of string to indicate that we want
    the `notification_category` field to be excluded from the fields that are serialized
    for each notification. This way, we avoid infinite recursion because the inclusion
    of the `notification_category` field would serialize all the notifications related
    to the category.
  prefs: []
  type: TYPE_NORMAL
- en: When we declared the `Notification` model, we used the `orm.relationship` function
    to provide a many-to-one relationship to the `NotificationCategory` model. The
    `backref` argument specified a call to the `orm.backref` function with `'notifications'`
    as the first value that indicates the name to use for the relation from the related
    `NotificationCategory` object back to a `Notification` object. With the previously
    explained line, we created the `notifications` fields that use the same name we
    indicated for the `db.backref` function.
  prefs: []
  type: TYPE_NORMAL
- en: The `NotificationSchema` class declares the `notification` attribute as an instance
    of `fields.String`. The `required` argument is set to `True` to specify that the
    field cannot be an empty string. The `validate` argument is set to `validate.Length(5)`
    to specify that the field must have a minimum length of five characters. The class
    declares the `ttl`, `creation_date`, `displayed_times`, and `displayed_once` fields
    with the corresponding classes based on the types we used in the `Message` model.
  prefs: []
  type: TYPE_NORMAL
- en: 'The class declares the `notification_category` field with the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `notification_category` attribute is an instance of the `marshmallow.fields.Nested`
    class, and this field will nest a single `NotificationCategorySchema`. We specify
    `True` for the `required` argument because a notification must belong to a category.
    The first argument specifies the name for the nested `Schema` class. We already
    declared the `NotificationCategorySchema` class and, therefore, we specify `NotificationCategorySchema`
    as the value for the first argument. We use the `only` parameter with a list of
    strings to indicate the field names that we want to be included when the nested
    `NotificationCategorySchema` is serialized. We want the `id`, `url`, and `name`
    fields to be included. We don't specify the `notifications` field because we don't
    want the notification category to serialize the list of notifications that belong
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The class declares the `url` field with the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `url` attribute is an instance of the `ma.URLFor` class and this field
    will output the full URL of the resource, that is, of the notification resource.
    The first argument is the Flask endpoint name: `''service.notificationresource''`.
    We will create a `NotificationResource` class later and the `URLFor` class will
    use it to generate the URL. The `id` argument specifies `''<id>''` because we
    want `id` to be pulled from the object to be serialized. The `_external` attribute
    is set to `True` because we want to generate the full URL for the resource. This
    way, each time we serialize a `Notification`, it will include the full URL for
    the resource in the `url` key.'
  prefs: []
  type: TYPE_NORMAL
- en: The `NotificationSchema` class declares a `process_notification_category` method
    that uses the `@pre_load` decorator, specifically, `marshmallow.pre_load`. This
    decorator registers a method to invoke before deserializing an object. This way,
    before Marshmallow deserializes a notification, the `process_category` method
    will be executed.
  prefs: []
  type: TYPE_NORMAL
- en: The method receives the data to be deserialized in the `data` argument and it
    returns the processed data. When we receive a request to `POST` a new notification,
    the notification category name can be specified in a key named `'notification_category'`.
    If a category with the specified name exists, we will use the existing category
    as the one that is related to the new notification. If a category with the specified
    name doesn't exist, we will create a new notification category and then we will
    use this new category as the one that is related to the new notification. This
    way, we make it easy and straightforward for the user to create new notifications
    related to categories.
  prefs: []
  type: TYPE_NORMAL
- en: The `data` argument might have a notification category name specified as a string
    for the `'notification_category'` key. However, in other cases, the `'notification_category'`
    key will include the key-value pairs with the field name and field values for
    an existing notification category.
  prefs: []
  type: TYPE_NORMAL
- en: The code in the `process_notification_category` method checks the value of the
    `'notification_category'` key and returns a dictionary with the appropriate data
    to make sure that we are able to deserialize a notification category with the
    appropriate key-value pairs, irrespective of the differences between the incoming
    data. Finally, the method returns the processed dictionary. We will dive deep
    on the work done by the `process_notification_category` method later when we start
    composing and sending HTTP requests to the new API.
  prefs: []
  type: TYPE_NORMAL
- en: Combining blueprints with resourceful routing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we will create the resources that compose our main building blocks for
    the RESTful API. First, we will create a few instances that we will use in the
    different resources. Create a new `views.py` file within the `services` folder
    and add the following lines. Notice that the code imports the `HttpStatus` enum
    declared in the `http_status.py` module that we created in the previous chapter.
    The code file for the sample is included in the `restful_python_2_02_01` folder,
    in the `Flask01/service/views.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Understanding and configuring resourceful routing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following table shows the method of our previously created classes that
    we want to be executed for each combination of HTTP verb and scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '| HTTP verb | Scope | Class and method |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | Collection of notifications | `NotificationListResource.get` |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | Notification | `NotificationResource.get` |'
  prefs: []
  type: TYPE_TB
- en: '| `POST` | Collection of notifications | `NotificationListResource.post` |'
  prefs: []
  type: TYPE_TB
- en: '| `PATCH` | Notification | `NotificationResource.patch` |'
  prefs: []
  type: TYPE_TB
- en: '| `DELETE` | Notification | `NotificationResource.delete` |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | Collection of notification categories | `NotificationCategoryListResource.get`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | Notification category | `NotificationCategoryResource.get` |'
  prefs: []
  type: TYPE_TB
- en: '| `POST` | Collection of notification categories | `NotificationCategoryListResource.post`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `PATCH` | Notification category | `NotificationCategoryResource.patch` |'
  prefs: []
  type: TYPE_TB
- en: '| `DELETE` | Notification category | `NotificationCategoryResource.delete`
    |'
  prefs: []
  type: TYPE_TB
- en: If the request results in the invocation of a resource with an unsupported HTTP
    method, Flask-RESTful will return a response with the HTTP `405 Method Not Allowed`
    status code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We must make the necessary resource routing configurations to call the appropriate
    methods and pass them all the necessary arguments by defining URL rules. The following
    lines configure the resource routing for the service. Open the previously created
    `views.py` file within the `service` folder and add the following code after the
    last line. The code file for the sample is included in the `restful_python_2_02_01`
    folder, in the `Flask01/service/views.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Each call to the `service.add_resource` method routes a URL to a resource; specifically,
    to one of the previously declared subclasses of the `flask_restful.Resource` superclass.
    Whenever there is a request to the API, and the URL matches one of the URLs specified
    in the `service.add_resource` method, Flask will call the method that matches
    the HTTP verb in the request for the specified class.
  prefs: []
  type: TYPE_NORMAL
- en: Registering the blueprint and running migrations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new `app.py` file within the `service` folder. The following lines
    show the code that creates a Flask application. The code file for the sample is
    included in the `restful_python_2_02_01` folder, in the `Flask01/service/app.py`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The code in the `service/app.py` file declares a `create_app` function ...
  prefs: []
  type: TYPE_NORMAL
- en: Verifying the contents of the PostgreSQL database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After we run the previous scripts, we can use the PostgreSQL command line or
    any other application that allows us to easily verify the contents of the PostgreSQL
    10.5 database to check the tables that the migration generated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to list the generated tables. If the database name
    you are using is not named `flask_notifications`, make sure you use the appropriate
    database name. The code file for the sample is included in the `restful_python_2_02_01`
    folder, in the `Flask01/list_database_tables.sql` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines show the output with all the generated table names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'SQLAlchemy generated the following two tables with the unique constraints and
    the foreign keys based on the information included in our models:'
  prefs: []
  type: TYPE_NORMAL
- en: '`notification_category`: This table persists the `NotificationCategory` model.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`notification`: This table persists the `Notification` model.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following command will allow you to check the contents of the two tables
    after we compose and send HTTP requests to the RESTful API and execute CRUD operations
    on the two tables. The commands assume that you are running PostgreSQL 10.5 on
    the same computer in which you are running the command. The code file for the
    sample is included in the `restful_python_2_02_01` folder, in the `Flask01/check_tables_contents.sql`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Instead of working with the PostgreSQL command-line utility, you can use your
    favorite GUI tool to check the contents of the PostgreSQL database.
  prefs: []
  type: TYPE_NORMAL
- en: Alembic generated an additional table named `alembic_version` that saves the
    version number for the database in the `version_num` column. This table makes
    it possible for the migration commands to retrieve the current version for the
    database and upgrade or downgrade it based on our needs.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and retrieving related resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we will use the flask script to launch Flask's development server and our
    RESTful API. We want to enable the debug mode and, therefore, we will set the
    value for the `FLASK_ENV` environment variable to `development`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command in the Terminal in Linux or macOS with a bash shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In Windows, if you are using the Command Prompt, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In Windows, if you are using Windows PowerShell, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now, run the `flask` script that launches Flask's development server and the
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the `FLASK_ENV` environment variable is configured to work in development
    ...
  prefs: []
  type: TYPE_NORMAL
- en: Test your knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see whether you can answer the following questions correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Which of the following commands start the Flask development server and the
    Flask application, and makes it listen on every interface on port `5000`?:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`flask run -h 0.0.0.0`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`flask run -p 0.0.0.0 -h 5000`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`flask run -p 0.0.0.0`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Flask-Migrate` is:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A lightweight library for converting complex datatypes to and from native Python
    datatypes.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A library that uses the Alembic package to handle SQLAlchemy database migrations
    for Flask applications.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A library that replaces SQLAlchemy to run queries on PostgreSQL.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Marshmallow is:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A lightweight library for converting complex datatypes to and from native Python
    datatypes.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: An ORM.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A lightweight web framework that replaces Flask.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'SQLAlchemy is:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A lightweight library for converting complex datatypes to and from native Python
    datatypes.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: An ORM.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A lightweight web framework that replaces Flask.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `marshmallow.pre_load` decorator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Registers a method to run after any instance of the `Resource` class is created.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Registers a method to invoke after serializing an object.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Registers a method to invoke before deserializing an object.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `dump` method for any instance of a `Schema` subclass:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Routes URLs to Python primitives.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Persists the instance or collection of instances passed as an argument to the
    database.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Takes the instance or collection of instances passed as an argument and applies
    the field filtering and output formatting specified in the `Schema` subclass to
    the instance or collection of instances.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When we declare an attribute as an instance of the `marshmallow.fields.Nested`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The field will nest a single `Schema` or a collection of `Schema` based on the
    value for the `many` argument.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The field will nest a single `Schema`. If we want to nest a collection of `Schema`,
    we have to use an instance of the `marshmallow.fields.NestedCollection` class.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The field will nest a collection of `Schema`. If we want to nest a single `Schema`,
    we have to use an instance of the `marshmallow.fields.NestedSingle` class.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we expanded the capabilities of the previous version of the
    RESTful API we created in the preceding chapter. We used SQLAlchemy as our ORM
    to work with a PostgreSQL 10.5 database. We added many packages to simplify many
    common tasks, we wrote code for the models and their relationships, and we worked
    with schemas to validate, serialize, and deserialize these models.
  prefs: []
  type: TYPE_NORMAL
- en: We combined blueprints with resourceful routing, and we were able to generate
    the database from the models. We composed and sent many HTTP requests to our RESTful
    API and analyzed how each HTTP request was processed in our code and how the models
    persisted in the database tables.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have built a complex API with Flask, Flask-RESTful, and SQLAlchemy,
    ...
  prefs: []
  type: TYPE_NORMAL
