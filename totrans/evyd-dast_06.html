<html><head></head><body>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch06" class="calibre1"/>Chapter 6. Dictionaries: Keyed Collections</h1></div></div></div><p class="calibre7">A <strong class="calibre16">dictionary</strong> is an abstract data structure that can be described as a collection of keys and associated values, where each key only appears once within the collection. This associated relationship between the keys and values is why dictionaries are sometimes referred to as <strong class="calibre16">associative arrays</strong>. Dictionaries are also known as <strong class="calibre16">maps</strong>, or more specifically, <strong class="calibre16">hash maps</strong> for <strong class="calibre16">hash table</strong>-based dictionaries and <strong class="calibre16">tree maps</strong> for <strong class="calibre16">search tree</strong>-based dictionaries. The four most common functions associated with a dictionary are <strong class="calibre16">add</strong>, <strong class="calibre16">update</strong>, <strong class="calibre16">get</strong>, and <strong class="calibre16">remove</strong>. Other common operations include <strong class="calibre16">contains</strong>, <strong class="calibre16">count</strong>, <strong class="calibre16">reassign</strong>, and <strong class="calibre16">set</strong>. Each of these operations will be examined in detail later in this chapter.</p><p class="calibre7">The mapped, or associative, nature of dictionaries allows for extremely efficient insert, search, and update operations. By specifying the key when creating, editing, or getting a value, most operations in a well-designed dictionary have a minimal <strong class="calibre16">O</strong>(<em class="calibre20">1</em>) cost. Perhaps, it's because of this efficiency that dictionaries are one of the most common data structures you will encounter in your day-to-day development experience.</p><p class="calibre7">You might be wondering why something described as a collection of associated keys and values should be referred to as a dictionary. This name is an analogy with a physical dictionary, where each word (key) has an associated definition (value). If this is still a little too abstract, consider a valet service. When you pull up a car to an event, you step out of your car and someone hands you a little ticket before driving away with your vehicle. This ticket represents your car, and only your car. There are no other tickets with the same identifier as the one you are now holding. Therefore, there is only one-way to get your car back is presenting this specific ticket to the valet service. Once you do so, someone rolls up with your vehicle, you hand them a tip, and then you drive away.</p><p class="calibre7">This process is a concrete example of the dictionary data structure. Each ticket represents a <em class="calibre20">key</em>, while each vehicle represents a <em class="calibre20">value</em> of some type. Each key is unique and uniquely identifies one specific value. When your code calls for a value, the valet service is the <em class="calibre20">collection</em> that uses the key to locate and return the value you are looking for. Tipping your development machine is optional.</p><p class="calibre7">In this chapter, we will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem">Definition of a dictionary data structure</li><li class="listitem">Initializing dictionaries</li><li class="listitem">Hash tables</li><li class="listitem">Common dictionary operations</li><li class="listitem">Case study - arcade ticket totals</li><li class="listitem">Hash table based dictionaries</li><li class="listitem">Search tree based dictionaries</li></ul></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_1"><a id="ch06lvl1sec29" class="calibre1"/>Initializing dictionaries</h1></div></div></div><p class="calibre7">Dictionaries are so commonplace that it's no wonder that each of the languages we are examining supports them with concrete implementations. Here are some examples of initializing a dictionary, adding a few key/value pairs to the collection, and then removing one of those pairs from the collection.</p><p class="calibre7"><strong class="calibre16">C#</strong></p><p class="calibre7">C# provides a concrete implementation of the dictionary data structure through the <code class="literal">Dictionary&lt;TKey, TValue&gt;</code> class. Since this class is generic, the caller may define the types used for both the keys and values. Here is an example:</p><pre class="programlisting">    Dictionary&lt;string, int&gt; dict = new Dictionary&lt;string, int&gt;(); 
</pre><p class="calibre7">This example initializes a new dictionary where the keys will be <code class="literal">string</code> types, and the values will be <code class="literal">int</code> types:</p><pre class="programlisting">    dict.Add("green", 1); 
    dict.Add("yellow", 2);  
    dict.Add("red", 3); 
    dict.Add("blue", 4); 
    dict.Remove("blue"); 
    Console.WriteLine("{0}", dict["red"]); 

    // Output: 3 
</pre><strong class="calibre16">Java</strong><p class="calibre7">Java provides a <code class="literal">Dictionary&lt;K, V&gt;</code> class, but it has been recently deprecated in favor of any class that implements the <code class="literal">Map&lt;K, V&gt;</code> interface. Here, we'll look at an example of the <code class="literal">HashMap&lt;K, V&gt;</code> class. This class extends <code class="literal">AbstractMap&lt;K, V&gt;</code> and implements the <code class="literal">Map&lt;K, V&gt;</code> interface:</p><pre class="programlisting">    HashMap&lt;String, String&gt; dict = new HashMap&lt;String, String&gt;(); 
    dict.put("green", "1"); 
    dict.put("yellow", "2");  
    dict.put("red", "3"); 
    dict.put("blue", "4"); 
    dict.remove("blue"); 
    System.out.println(dict.get("red")); 

    // Output: 3 
</pre><p class="calibre7">This class is called <code class="literal">HashMap</code> because it is a concrete, hash table based implementation of a map. It is interesting to note that Java will not permit primitives to be used as either the keys or the values in a <code class="literal">HashMap</code> class, so in our preceding example, we are substituting String types for our values.</p><div><h3 class="title1"><a id="tip29" class="calibre1"/>Tip</h3><p class="calibre7"><strong class="calibre16">Hash tables</strong></p><p class="calibre7">Since one of Java's dictionary implementations is called a <strong class="calibre16">hash map</strong>, this seems like a good time to introduce <strong class="calibre16">hash tables</strong>, which are sometimes referred to as hash maps. Hash tables use a <strong class="calibre16">hash function</strong> to map data to indexed positions in an array. Technically, a hash function is any function that can be used to plot data of a random size to data of a static size.</p><p class="calibre7">In well-designed hash tables, the search, insert, and delete functions have an <strong class="calibre16">O</strong>(1) cost, as the complexity is independent of the number of elements the collection contains. In many situations, hash tables are much more efficient in comparison to arrays, lists, or other lookup data structures. This is the reason they are so frequently used to build dictionaries. This is also the reason they are commonly used in database indexing, caches, and as the foundation of the <strong class="calibre16">set</strong> data structure. We will discuss sets in more detail in <a class="calibre1" title="Chapter 7. Sets: No Duplicates" href="part0041_split_000.html#173722-77f2b5b248f04368a6f723b0e9357ef3">Chapter 7</a>, <em class="calibre20">Sets: No Duplicates</em>.</p><p class="calibre7">In truth, hash tables are a data structure unto themselves, although they are most commonly used to create associative arrays. So, why then are we not examining the hash table data structure in more depth? In most languages, a dictionary is preferred over a hash table for similar applications. This is because dictionaries are <strong class="calibre16">generically typed</strong>, while hash tables rely on the language's root object type to assign values internally, such as C#'s <code class="literal">object</code> type. While hash tables permit virtually any object to be used as a key or value, a generically typed dictionary will limit the caller to assigning only objects of the declared types as the key or value of an element. This approach is both type-safe as well as more efficient because values do not need to be <strong class="calibre16">boxed</strong> and <strong class="calibre16">unboxed</strong> (cast) every time a value is updated or retrieved.</p><p class="calibre7">That being said, do not make the mistake of assuming that a dictionary is simply a hash table by another name. It is true that a hash table roughly corresponds to some variation of <code class="literal">Dictionary&lt;object, object&gt;</code>, but it is a different class with different functionality and methods.</p></div><p class="calibre7"><strong class="calibre16">Objective-C</strong></p><p class="calibre7">Objective-C provides immutable as well as mutable dictionary classes, <code class="literal">NSDictionary</code> and <code class="literal">NSMutableDictionary</code>, respectively. Since we'll be working with a mutable dictionary in our example later, let's just examine <code class="literal">NSDictionary</code> here. <code class="literal">NSDictionary</code> can be initialized with a literal array of <em class="calibre20">1.</em>..<em class="calibre20">n</em> key/value pairs using the <code class="literal">@{K : V, K : V}</code> syntax. There are also two common initializer methods. The first is <code class="literal">dictionaryWithObjectsAndKeys:</code>, which accepts an array of object/key pairs terminated by <code class="literal">nil</code>. The second is <code class="literal">dictionaryWithObjects:forKeys:</code>, which accepts an array of objects and a second array of keys. Similar to Java's <code class="literal">HashMap</code>, Objective-C's <code class="literal">NSDictionary</code> and <code class="literal">NSMutableDictionary</code> class clusters do not permit scalar data to be used as keys or values:</p><pre class="programlisting">    NSDictionary *dict = [NSDictionary dictionaryWithObjectsAndKeys: 
    [NSNumber numberWithInt:1], @"green",   
    [NSNumber numberWithInt:2], @"yellow",  
    [NSNumber numberwithInt:3], @"red", nil]; 
 
    NSArray *colors = @[@"green", @"yellow", @"red"]; 
    NSArray *positions = @[[NSNumber numberWithInt:1],  
                           [NSNumber numberWithInt:2],  
                           [NSNumber numberWithInt:3]]; 

    dict = [NSDictionary dictionaryWithObjects:positions forKeys:colors]; 
    NSLog(@"%li", (long)[(NSNumber*)[_points valueForKey:@"red"] integerValue]); 

    // Output: 3 
</pre><p class="calibre7">You might notice that the <code class="literal">dictionaryWithObjects:forKeys:</code> approach is more verbose, making it slightly more readable. However, you must take extra care to ensure that your keys and values are correctly mapped to one another.</p><p class="calibre7"><strong class="calibre16">Swift</strong></p><p class="calibre7">Dictionaries in Swift are created using the <code class="literal">Dictionary</code> class. Swift dictionaries are mutable when initialized as variables using <code class="literal">var</code>, but can also be created as immutable by initializing them as constants using <code class="literal">let</code>. Keys used in the dictionary can be either integers or strings. The <code class="literal">Dictionary</code> class can also accept values of any type, including those types normally considered primitives in other languages, since these are actually named types in Swift and are defined in the Swift standard library using structures. In either case, both your key and value types must be declared when the collection is initialized, and these cannot be changed later. Since we'll be working with a variable, or mutable, dictionary later, we'll initialize a constant immutable collection here:</p><pre class="programlisting">    let dict:[String: Int] = ["green":1, "yellow":2, "red":3]  
    print(dict[red]) 

    // Output: 3 
</pre><div><h3 class="title1"><a id="note30" class="calibre1"/>Note</h3><p class="calibre7">We will examine <strong class="calibre16">structures</strong> in more detail later in <a class="calibre1" title="Chapter 8. Structs: Complex Types" href="part0047_split_000.html#1CQAE2-77f2b5b248f04368a6f723b0e9357ef3">Chapter 8</a>, <em class="calibre20">Structs: Complex Types</em>.</p></div></div></div>

<div><div><div><div><div><div><h2 class="title2" id="calibre_pb_2"><a id="ch06lvl2sec33" class="calibre1"/>Dictionary operations</h2></div></div></div><p class="calibre7">Not all concrete implementations of the dictionary data structures expose the same operational methods. However, the more common operations should be available or made available as needed by the developer. Here are some operations:</p><div><ul class="itemizedlist"><li class="listitem"><strong class="calibre16">add</strong>: The add operation, sometimes referred to as an insert, introduces a new key/value pair into the collection. Add operations have an <strong class="calibre16">O</strong>(<em class="calibre20">1</em>) cost.</li><li class="listitem"><strong class="calibre16">get</strong>: The get operation, sometimes called a <strong class="calibre16">lookup</strong>, returns the value mapped to a given key. If no value is found for the given key, some dictionaries will raise an <em class="calibre20">exception</em>. By specifying the key, get operations have an <strong class="calibre16">O</strong>(<em class="calibre20">1</em>) cost.</li><li class="listitem"><strong class="calibre16">update</strong>: The update operation allows the caller to modify a value that is already a part of the collection. Not all dictionary implementations provide a defined update method, but rather support updating a value via <em class="calibre20">reference</em>. This means the object can be modified directly once it has been pulled from the dictionary using a get operation. By specifying the key, update operations have an <strong class="calibre16">O</strong>(<em class="calibre20">1</em>) cost.</li><li class="listitem"><strong class="calibre16">remove</strong>: The remove, or <em class="calibre20">delete</em>, operation will remove a key/value pair from the collection given a valid key. Most dictionaries will gracefully ignore a specified key that does not exist. By specifying the key, remove operations have an <strong class="calibre16">O</strong>(1) cost.</li><li class="listitem"><strong class="calibre16">contains</strong>: The contains operation returns a Boolean value, identifying whether a given key can be found in the collection. Contains operations must iterate through the collection of keys in the dictionary to search for a match. Therefore, this operation has a worst-case cost of <strong class="calibre16">O</strong>(<em class="calibre20">n</em>).</li><li class="listitem"><strong class="calibre16">count</strong>: Count, sometimes referred to as <em class="calibre20">size</em>, can be either a method or simply a property of the collection that returns the number of key/value elements within the dictionary. Count is typically a simple property on the collection and, therefore, has an <strong class="calibre16">O</strong>(<em class="calibre20">1</em>) cost.</li><li class="listitem"><strong class="calibre16">reassign</strong>: A reassign operation allows for assigning a new value to an existing key. This operation is somewhat less common in many implementations as the update operation serves as the reassign operation. By specifying the key, reassign operations have an <strong class="calibre16">O</strong>(<em class="calibre20">1</em>) cost.</li><li class="listitem"><strong class="calibre16">set</strong>: The set operation is sometimes seen as a single replacement for both add and reassign operations. Set will either insert a new key/value pair if the key does not already exist, or it will reassign the value to the specified key. There is no need to support set, add, and reassign operations within the same implementation. As with add and update, set operations have an <strong class="calibre16">O</strong>(<em class="calibre20">1</em>) cost.</li></ul></div></div></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec30" class="calibre1"/>Case study: arcade ticket totals</h1></div></div></div><p class="calibre7"><strong class="calibre16">Business problem</strong>: an arcade manager wants to cut costs by eliminating physical tickets from her games. Tickets are very costly and wasteful, since they must be thrown away or recycled once a customer has redeemed them. She has decided to introduce an electronic point system that allows customers to earn points rather than tickets, and store the points digitally. Once she has the hardware in place to support the changeover, she needs a mobile app that allows her and her customers to efficiently track their current point totals.</p><p class="calibre7">This app has several key requirements. First, it should store data for the customer based solely on the name they provide during check-in. Second, it must keep a running total of all points earned, lost, and redeemed. Third, it must be capable of showing the customer's points and the total number of customers in the arcade at any given time. Finally, it should allow for the removal of individual customer records or all customer records at once. Based on these requirements, the developer decides that a dictionary will be the most efficient way to track all customer points, so the core class's functionality will be based on that data structure.</p><p class="calibre7"><strong class="calibre16">C#</strong></p><p class="calibre7">C# provides the generic collection <code class="literal">Dictionary&lt;TKey, TValue&gt;</code>. This class provides all of the basic operations we would expect to see in a concrete dictionary implementation, with the added benefit of generic type casting:</p><pre class="programlisting">    Dictionary&lt;string, int&gt; _points; 
    public PointsDictionary() 
    { 
        _points = new Dictionary&lt;string, int&gt;(); 
    } 
</pre><p class="calibre7">Using <code class="literal">Dictionary&lt;TKey, TValue&gt;</code>, we create one private field for our class called <code class="literal">_points</code>. Our constructor instantiates this field, giving us the underlying data structure to build our <code class="literal">PointsDictionary</code> class on:</p><pre class="programlisting">    //Update - private 
    private int UpdateCustomerPoints(string customerName, int points)  
    { 
        if (this.CustomerExists(customerName)) 
        { 
            _points[customerName] = _points[customerName] += points; 
            return _points[customerName]; 
        } 
        return 0; 
    } 
</pre><p class="calibre7">The <code class="literal">UpdateCustomerPoints(string customerName, int points)</code> method provides the core <em class="calibre20">update</em> functionality for our class. This method first confirms that the key exists in our collection. If the key does not exist, the method immediately returns <code class="literal">0</code>. Otherwise, we use subscript notation to both get the key and update the key's value. Using subscript notation once again, we finally return the updated value to the caller.</p><p class="calibre7">We keep this method private, choosing to create several additional update methods that are more fitting to our business requirements. These public methods, discussed later, will expose the update functionality to the caller:</p><pre class="programlisting">    //Add 
    public void RegisterCustomer(string customerName) 
    { 
        this.RegisterCustomer(customerName, 0); 
    } 
 
    public void RegisterCustomer(string customerName, int previousBalance) 
    { 
        _points.Add(customerName, previousBalance); 
    } 
</pre><p class="calibre7">The two <code class="literal">RegisterCustomer()</code> methods provide the <em class="calibre20">add</em> functionality to our class. In both cases, we require a customer name to act as the key. If a returning customer checks in with a previous balance, we want to acknowledge it so that our class overloads the method. Ultimately, the overloaded method calls <code class="literal">Dictionary&lt;TKey, TValue&gt;.Add(T)</code> to insert a new record into the collection:</p><pre class="programlisting">    //Get 
    public int GetCustomerPoints(string customerName) 
    { 
        int points; 
        _points.TryGetValue(customerName, out points); 
 
        return points; 
    } 
</pre><p class="calibre7">Our <em class="calibre20">get</em> functionality is introduced by the <code class="literal">GetCustomerPoints(string customerName)</code> method. In this method, we use <code class="literal">TryGetValue()</code> to safely confirm that the <code class="literal">customerName</code> key exists and to get the value at the same time. If the key does not exist, the app handles the issue gracefully and does not assign any value to <code class="literal">points</code>. The method then returns whatever value is currently set in <code class="literal">points</code>:</p><pre class="programlisting">    //Update - public 
    public int AddCustomerPoints(string customerName, int points) 
    { 
        return this.UpdateCustomerPoints(customerName, points); 
    } 
 
    public int RemoveCustomerPoints(string customerName, int points) 
    { 
        return this.UpdateCustomerPoints(customerName, -points); 
    } 
 
    public int RedeemCustomerPoints(string customerName, int points) 
    { 
        //Perform any accounting actions 
        return this.UpdateCustomerPoints(customerName, -points); 
    } 
</pre><p class="calibre7">Next, we come to the public update methods, <code class="literal">AddCustomerPoints(string customerName, int points)</code>, <code class="literal">RemoveÇustomerPoints(string customerName, int points)</code>, and <code class="literal">RedeemCustomerPoints(string customerName, int points)</code>. Each of these methods calls the private <code class="literal">UpdateCustomerPoints(string customerName, int points)</code> method, but first it negates <code class="literal">points</code> in the case of the latter two:</p><pre class="programlisting">    //Remove 
    public int CustomerCheckout(string customerName) 
    { 
        int points = this.GetCustomerPoints(customerName); 
        _points.Remove(customerName); 
        return points;  
    } 
</pre><p class="calibre7">The <code class="literal">CustomerCheckout(string customerName)</code> method introduces the collection's <em class="calibre20">remove</em> functionality. The method first records the final value for the customer key, and then calls <code class="literal">Dictionary&lt;TKey, TValue&gt;.Remove(T)</code> to delete the customer's key from the collection. Finally, it returns the customer's last point value to the caller:</p><pre class="programlisting">    //Contains 
    public bool CustomerExists(string customerName) 
    { 
        return _points.ContainsKey(customerName); 
    } 
</pre><p class="calibre7">The <code class="literal">Dictionary&lt;TKey, TValue&gt;</code> interface conveniently provides the <code class="literal">ContainsKey()</code> method, which the <code class="literal">CustomerExists(string customerName)</code> method uses to introduce our class' <em class="calibre20">contains</em> functionality:</p><pre class="programlisting">    //Count 
    public int CustomersOnPremises() 
    { 
        return _points.Count; 
    } 
</pre><p class="calibre7">Using the <code class="literal">Count</code> field on the <code class="literal">Dictionary&lt;TKey, TValue&gt;</code> class, <code class="literal">CustomersOnPremises()</code> provides the <em class="calibre20">count</em> functionality:</p><pre class="programlisting">    public void ClosingTime() 
    { 
        //Perform any accounting actions 
        _points.Clear(); 
    } 
</pre><p class="calibre7">Finally, as per our business requirements, we need a way to remove all of the objects from the collection. The <code class="literal">ClosingTime()</code> method uses the <code class="literal">Dictionary&lt;TKey, TValue&gt;.Clear()</code> method to accomplish this task.</p><p class="calibre7"><strong class="calibre16">Java</strong></p><p class="calibre7">As mentioned previously, Java supplies a <code class="literal">Dictionary</code> class, but it has been deprecated in favor of any class that implements <code class="literal">Map&lt;K, V&gt;</code> interface. The <code class="literal">HashMap&lt;K, V&gt;</code> implements the interface and provides a dictionary based on a hash table. As with the previous C# example, the <code class="literal">HashMap&lt;K, V&gt;</code> class exposes all the basic operations we would expect to see in a concrete implementation of a dictionary:</p><pre class="programlisting">    HashMap&lt;String, Integer&gt; _points; 
    public PointsDictionary() 
    { 
        _points = new HashMap&lt;&gt;(); 
    } 
</pre><p class="calibre7">An instance of <code class="literal">HashMap&lt;K, V&gt;</code> becomes the core of our Java <code class="literal">PointsDictionary</code> class. Again, we name the private field <code class="literal">_points</code>, while our constructor instantiates the collection. You may note that we are not explicitly declaring types when we instantiate the <code class="literal">_points</code> collection. In Java, it is not necessary to explicitly declare types at instantiation when we have already defined the key and value types at declaration. You can declare the types if you really want to, but this will generate a warning in the compiler:</p><pre class="programlisting">    private Integer UpdateCustomerPoints(String customerName, int points) 
    { 
        if (this.CustomerExists(customerName)) 
        { 
            _points.put(customerName, _points.get(customerName) + points); 
            return _points.get(customerName); 
        }  
        return 0; 
    } 
</pre><p class="calibre7">The <code class="literal">UpdateCustomerPoints(string customerName, int points)</code> method provides the core <em class="calibre20">update</em> functionality for our class. This method first confirms that the key exists in our collection. If the key does not exist, the method immediately returns <code class="literal">0</code>. Otherwise, we use <code class="literal">put()</code> and <code class="literal">get()</code> to update the key's value. Using <code class="literal">get()</code> once again, we finally return the updated value to the caller:</p><pre class="programlisting">    //Add 
    public void RegisterCustomer(String customerName) 
    { 
        this.RegisterCustomer(customerName, 0); 
    } 
 
    public void RegisterCustomer(String customerName, int previousBalance) 
    { 
        _points.put(customerName, previousBalance); 
    } 
</pre><p class="calibre7">The two <code class="literal">RegisterCustomer()</code> methods provide the <em class="calibre20">add</em> functionality to our class. In both cases, we require a customer name to act as the key. If a returning customer is checking in with a previous balance, we want to acknowledge it so that our class overloads the method. Ultimately, the overloaded method calls <code class="literal">HashMap&lt;K, V&gt;.put(E)</code> to insert a new record into the collection:</p><pre class="programlisting">    //Get 
    public Integer GetCustomerPoints(String customerName) 
    { 
        return _points.get(customerName) == null ? 0 : _points.get(customerName); 
    } 
</pre><p class="calibre7">Our <em class="calibre20">get</em> functionality is introduced by the <code class="literal">GetCustomerPoints(string customerName)</code> method. In this method, we use the <code class="literal">get()</code> method, checking that the return value is not null, to safely confirm that the <code class="literal">customerName</code> key exists. Using a ternary operator, we return <code class="literal">0</code> if it does not or the value if it does:</p><pre class="programlisting">    //Update 
    public Integer AddCustomerPoints(String customerName, int points) 
    { 
        return this.UpdateCustomerPoints(customerName, points); 
    } 
 
    public Integer RemoveCustomerPoints(String customerName, int points) 
    { 
        return this.UpdateCustomerPoints(customerName, -points); 
    } 
 
    public Integer RedeemCustomerPoints(String customerName, int points) 
    { 
        //Perform any accounting actions 
        return this.UpdateCustomerPoints(customerName, -points); 
    } 
</pre><p class="calibre7">Next, we come to the public update methods, <code class="literal">AddCustomerPoints(String customerName, int points)</code>, <code class="literal">RemoveÇustomerPoints(String customerName, int points)</code>, and <code class="literal">RedeemCustomerPoints(String customerName, int points)</code>. Each of these methods calls the private <code class="literal">UpdateCustomerPoints(String customerName, int points)</code> method, but first it negates <code class="literal">points</code> in the case of the latter two:</p><pre class="programlisting">    //Remove 
    public Integer CustomerCheckout(String customerName) 
    { 
        Integer points = this.GetCustomerPoints(customerName); 
        _points.remove(customerName); 
        return points; 
    } 
</pre><p class="calibre7">The <code class="literal">CustomerCheckout(String customerName)</code> method introduces the collection's <em class="calibre20">remove</em> functionality. The method first records the final value for the customer key and then calls <code class="literal">HashMap&lt;K, V&gt;.remove(E)</code> to delete the customer's key from the collection. Finally, it returns the customer's last point value to the caller:</p><pre class="programlisting">    //Contains 
    public boolean CustomerExists(String customerName) 
    { 
        return _points.containsKey(customerName); 
    } 
</pre><p class="calibre7">The <code class="literal">HashMap&lt;K, V&gt;</code> method conveniently provides the <code class="literal">containsKey()</code> method, which the <code class="literal">CustomerExists(String customerName)</code> method uses to introduce our class' <em class="calibre20">contains</em> functionality:</p><pre class="programlisting">    //Count 
    public int CustomersOnPremises() 
    { 
        return _points.size(); 
    } 
</pre><p class="calibre7">Using the <code class="literal">size()</code> field on the <code class="literal">HashMap&lt;K, V&gt;</code> class, <code class="literal">CustomersOnPremises()</code> provides the <em class="calibre20">count</em> functionality:</p><pre class="programlisting">    //Clear 
    public void ClosingTime() 
    { 
        //Perform accounting actions 
        _points.clear(); 
    } 
</pre><p class="calibre7">Finally, per our business requirements, we need a way to remove all of the objects from the collection. The <code class="literal">ClosingTime()</code> method uses the <code class="literal">HashMap&lt;K, V&gt;.clear()</code> method to accomplish this task.</p><p class="calibre7"><strong class="calibre16">Objective-C</strong></p><p class="calibre7">For our Objective-C example, we will use the <code class="literal">NSMutableDictionary</code> class cluster to represent our collection. The <code class="literal">NSMutableDictionary</code> class cluster does not expose all of the basic operations we would expect to see in a concrete implementation of a dictionary, but those that are not readily available are very simple to replicate. It is important to note that Objective-C does not allow scalar values to be added to instances of the <code class="literal">NSDictionary</code> or <code class="literal">NSMutableDictionary</code> collections. Therefore, since we are trying to store integers for our values, we will have to place each of the <code class="literal">NSInteger</code> scalars in <code class="literal">NSNumber</code> wrappers before they can be added to the collection. Unfortunately, this adds some overhead to our implementation as all of these values must be boxed and unboxed as they are inserted or retrieved from the collection:</p><pre class="programlisting">    @interface EDSPointsDictionary() 
    { 
        NSMutableDictionary&lt;NSString*, NSNumber*&gt; *_points; 
    } 
 
    @implementation EDSPointsDictionary 
 
    -(instancetype)init 
    { 
        if (self = [super init]) 
        { 
            _points = [NSMutableDictionary dictionary]; 
        } 
     
        return self; 
    } 
</pre><p class="calibre7">Using the class cluster <code class="literal">NSMutableDictionary</code>, we create an ivar for our class called <code class="literal">_points</code>. Our initializer instantiates this dictionary, giving us the underlying data structure to build our <code class="literal">PointsDictionary</code> class on:</p><pre class="programlisting">    -(NSInteger)updatePoints:(NSInteger)points 
        forCustomer:(NSString*)customerName 
    {  
        if ([self customerExists:customerName]) 
        { 
            NSInteger exPoints = [[_points objectForKey:customerName] integerValue]; 
            exPoints += points; 
         
            [_points setValue:[NSNumber numberWithInteger:exPoints] forKey:customerName]; 
            return [[_points objectForKey:customerName] integerValue]; 
        } 
        return 0; 
    } 
</pre><p class="calibre7">The <code class="literal">updatePoints:forCustomer:</code> method provides the core <em class="calibre20">update</em> functionality for our class. This method first confirms that the key exists in our collection by calling our <code class="literal">customerExists:</code> method. If the key does not exist, the method immediately returns <code class="literal">0</code>. Otherwise, the method uses <code class="literal">objectForKey:</code> to get the stored <code class="literal">NSNumber</code> object. From this, we immediately extract the <code class="literal">NSInteger</code> value by calling <code class="literal">integerValue</code> on the object. Next, the value is adjusted and updated in the dictionary using <code class="literal">setValue:forKey:</code>. Using <code class="literal">objectForKey:</code> once again, we finally return the updated value to the caller:</p><pre class="programlisting">    //Add 
    -(void)registerCustomer:(NSString*)customerName 
    { 
        [self registerCustomer:customerName withPreviousBalance:0]; 
    } 
 
    -(void)registerCustomer:(NSString*)customerName 
        withPreviousBalance:(NSInteger)previousBalance 
    { 
        NSNumber *points = [NSNumber numberWithInteger:previousBalance]; 
        [_points setObject:points forKey:customerName]; 
    } 
</pre><p class="calibre7">The <code class="literal">registerCustomer:</code> methods provide the <em class="calibre20">add</em> functionality to our class. In both cases, we require a customer name to act as the key. If a returning customer is checking in with a previous balance, we want to acknowledge it so that our class overloads the method in <code class="literal">registerCustomer:withPreviousBalance:</code>. Ultimately, the overloaded method is calls <code class="literal">setObject:forKey:</code> to insert a new key/value pair into the dictionary:</p><pre class="programlisting">    //Get 
    -(NSInteger)getCustomerPoints:(NSString*)customerName 
    { 
        NSNumber *rawsPoints = [_points objectForKey:customerName]; 
        return rawsPoints ? [rawsPoints integerValue] : 0; 
    } 
</pre><p class="calibre7">Our <em class="calibre20">get</em> functionality is introduced by the <code class="literal">getCustomerPoints:</code> method. In this method, we use <code class="literal">objectForKey:</code> to get the <code class="literal">NSNumber</code> object for the passed key and assign it to <code class="literal">rawPoints</code>. Next, the method checks that <code class="literal">rawPoints</code> is not <code class="literal">nil</code> and returns <code class="literal">integerValue</code> of <code class="literal">rawPoints</code> if it is available, or 0 otherwise:</p><pre class="programlisting">    //Update 
    -(NSInteger)addPoints:(NSInteger)points 
        toCustomer:(NSString*)customerName 
    { 
        return [self updatePoints:points forCustomer:customerName]; 
    } 
 
    -(NSInteger)removePoints:(NSInteger)points 
        fromCustomer:(NSString*)customerName 
    { 
        return [self updatePoints:-points forCustomer:customerName]; 
    } 
 
    -(NSInteger)redeemPoints:(NSInteger)points 
        forCustomer:(NSString*)customerName 
    { 
        //Perform any accounting actions 
        return [self updatePoints:-points forCustomer:customerName]; 
    } 
</pre><p class="calibre7">Next, we come to the public update methods, <code class="literal">addPoints:toCustomer:</code>, <code class="literal">removePoints:fromCustomer:</code> and <code class="literal">redeemPoints:forCustomer:</code>. Each of these methods calls the private <code class="literal">updatePoints:forCustomer:</code> method, but first, it negates <code class="literal">points</code> in the case of the latter two:</p><pre class="programlisting">    -(NSInteger)customerCheckout:(NSString*)customerName 
    { 
        NSInteger points = [[_points objectForKey:customerName] integerValue]; 
        [_points removeObjectForKey:customerName]; 
        return points; 
    } 
</pre><p class="calibre7">The <code class="literal">customerCheckout:</code>, method introduces the collection's <em class="calibre20">remove</em> functionality. The method first records the final value for the customer key, and then calls <code class="literal">removeObjectForKey:</code> to delete the customer's key from the collection. Finally, it returns the customer's last point value to the caller:</p><pre class="programlisting">    //Contains 
    -(bool)customerExists:(NSString*)customerName 
    { 
        return [_points objectForKey:customerName]; 
    } 
</pre><p class="calibre7">The <code class="literal">NSMutableDictionary</code> class cluster does not provide a mechanism for determining whether a key exists in the collection. A simple workaround is to just call <code class="literal">objectForKey:</code>; and if the returned value is <code class="literal">nil</code>, the key does not exist, and <code class="literal">nil</code> evaluates to <code class="literal">NO</code>. Based on this principle, therefore, our <code class="literal">customerExists:</code> method simply returns <code class="literal">objectForKey:</code>, allowing the return value to be evaluated as a <code class="literal">BOOL</code>:</p><pre class="programlisting">    //Count 
    -(NSInteger)customersOnPremises 
    { 
        return [_points count]; 
    } 
</pre><p class="calibre7">Using the <code class="literal">count</code> property on the <code class="literal">NSDictionary </code>class, <code class="literal">customersOnPremises</code> provides the <em class="calibre20">count</em> functionality:</p><pre class="programlisting">    //Clear 
    -(void)closingTime 
    { 
        [_points removeAllObjects]; 
    } 
</pre><p class="calibre7">Finally, as per our business requirements, we need a way to remove all of the objects from the collection. The <code class="literal">closingTime</code> method uses the <code class="literal">removeAllObjects</code> method to accomplish this task.</p><p class="calibre7"><strong class="calibre16">Swift</strong></p><p class="calibre7">Swift provides the <code class="literal">Dictionary</code> class which, like Objective-C's <code class="literal">NSMutableDictionary</code>, does not expose all of the operations we would expect to see in a concrete implementation of a dictionary data structure. Again, these missing functions are simple to replicate. It is worth noting the difference between the Swift dictionary's value type and its Objective-C counterpart. Since primitives in Swift are wrapped in <code class="literal">structs</code>, we have no problem adding <code class="literal">Int</code> objects to our collection:</p><pre class="programlisting">    var _points = Dictionary&lt;String, Int&gt;() 
</pre><p class="calibre7">Using the <code class="literal">Dictionary</code> class, we create a private property for our class called <code class="literal">_points</code>. Since our property is declared and instantiated simultaneously and there is no other custom code requiring instantiation, we can exclude the explicit public initializer and rely on the default initializer:</p><pre class="programlisting">    public func updatePointsForCustomer(points: Int, customerName: String) -&gt; Int 
    { 
        if customerExists(customerName) 
        { 
            _points[customerName] = _points[customerName]! + points 
            return _points[customerName]! 
        } 
        return 0 
    } 
</pre><p class="calibre7">The <code class="literal">updatePointsForCustomer()</code> method provides the core <em class="calibre20">update</em> functionality for our class. This method first confirms that the key exists in our collection by calling our <code class="literal">customerExists()</code> method. If the key does not exist, the method immediately returns <code class="literal">0</code>. Otherwise, the method uses subscript notation to get the stored value. Next, the value is adjusted and updated in the dictionary, again using subscript notation. Finally, we return the updated value to the caller:</p><pre class="programlisting">    //Add 
    public func registerCustomer(customerName: String) 
    { 
        registerCustomerWithPreviousBalance(customerName, previousBalance: 0) 
    } 
 
    public func registerCustomerWithPreviousBalance(customerName: String, previousBalance: Int) 
    { 
        _points[customerName] = previousBalance; 
    } 
</pre><p class="calibre7">The <code class="literal">registerCustomer()</code> methods provide the <em class="calibre20">add</em> functionality to our class. In both cases, we require a customer name to act as the key. If a returning customer checks in with a previous balance, we want to acknowledge it so that our class overloads the method in <code class="literal">registerCustomerWithPreviousBalance()</code>. Ultimately, the overloaded method uses subscript notation to insert a new key/value pair into the dictionary:</p><pre class="programlisting">    //Get 
    public func getCustomerPoints(customerName: String) -&gt; Int 
    { 
        let rawsPoints = _points[customerName] 
        return rawsPoints != nil ? rawsPoints! : 0; 
    } 
</pre><p class="calibre7">Our <em class="calibre20">get</em> functionality is introduced by the <code class="literal">getCustomerPoints()</code> method. In this method, we use subscript notation to get the value for our key, but then we confirm the return value is not <code class="literal">nil</code> before returning the value. If the value is not <code class="literal">nil</code>, our method returns the value; otherwise, it returns <code class="literal">0</code>:</p><pre class="programlisting">    //Update 
    public func addPointsToCustomer(points: Int, customerName: String) -&gt; Int 
    { 
        return updatePointsForCustomer(points, customerName: customerName) 
    } 
 
    public func removePointsFromCustomer(points: Int, customerName: String) -&gt; Int 
    { 
        return updatePointsForCustomer(-points, customerName: customerName) 
    } 
 
    public func redeemPointsForCustomer(points: Int, customerName: String) -&gt; Int 
    { 
        //Perform any accounting actions 
        return updatePointsForCustomer(-points, customerName: customerName) 
    } 
</pre><p class="calibre7">Next, we come to the public update methods, <code class="literal">addPointsToCustomer()</code>, <code class="literal">removePointsFromCustomer()</code>, and <code class="literal">redeemPointsForCustomer()</code>. Each of these methods calls the private <code class="literal">updatePointsForCustomer()</code> method, but first, it negates <code class="literal">points</code> in the case of the latter two:</p><pre class="programlisting">    public func customerCheckout(customerName: String) -&gt; Int 
    { 
        let points = _points[customerName] 
        _points.removeValueForKey(customerName) 
        return points!; 
    } 
</pre><p class="calibre7">The <code class="literal">customerCheckout()</code> method introduces the collection's <em class="calibre20">remove</em> functionality. The method first records the final value for the customer key, and then calls <code class="literal">removeObjectForKey:</code> to delete the customer's key from the collection. Finally, it returns the customer's last point value to the caller:</p><pre class="programlisting">    //Contains 
    public func customerExists(customerName: String) -&gt; Bool 
    { 
        return _points[customerName] != nil 
    } 
</pre><p class="calibre7">Similar to <code class="literal">NSMutableDictionary</code>, <code class="literal">Dictionary</code> does not provide a mechanism for determining whether a key exists in the collection. Luckily, our workaround from Objective-C works just fine in Swift as well. Our method uses subscript notation, and if the returned value is <code class="literal">nil</code>, the key does not exist, and <code class="literal">nil</code> evaluates to <code class="literal">false</code>. Based on this principle, therefore, our <code class="literal">customerExists()</code> method simply returns <code class="literal">_points[cusrtomerName]</code>, allowing the return value to be evaluated as <code class="literal">Bool</code>:</p><pre class="programlisting">    //Count 
    public func customersOnPremises() -&gt; Int 
    { 
        return _points.count 
    } 
</pre><p class="calibre7">Using the <code class="literal">count</code> property on the <code class="literal">Dictionary</code> class, <code class="literal">customersOnPremises()</code> provides the <em class="calibre20">count</em> functionality:</p><pre class="programlisting">    //Clear 
    public func closingTime() 
    { 
        _points.removeAll() 
    } 
</pre><p class="calibre7">Finally, per our business requirements we need a way to remove all of the objects from the collection. The <code class="literal">closingTime()</code> method uses the <code class="literal">Dictionary.removeAll()</code> method to accomplish this task.</p></div>

<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec31" class="calibre1"/>Advanced topics</h1></div></div></div><p class="calibre7">Now that we have examined how dictionaries are used in common applications, we should take some time to examine how dictionaries are implemented under the hood. The majority of dictionaries come in two distinct flavors: hash table based and search tree based. Although the mechanics of the two approaches are similar, and they typically share many of the same methods and functionality, the inner workings and ideal applications for each type are very different.</p></div>

<div><div><div><div><div><h2 class="title2" id="calibre_pb_1"><a id="ch06lvl2sec34" class="calibre1"/>Hash table based dictionaries</h2></div></div></div><p class="calibre7">The most common implementation of a dictionary is the <strong class="calibre16">hash table based</strong> associative array. When properly implemented, the hash table approach is extremely efficient and allows for <strong class="calibre16">O</strong>(1) complexity searches, inserts, and deletes. In each of the languages we are examining, the basic dictionary classes are based on hash tables by default. The general concept of a hash table based dictionary is that mapping for a specified key is stored at an index of an array, where the index is obtained by applying a hash function to the key. Callers then examine the same index of the array for the specified key and use the binding that is stored there to retrieve the value of the element.</p><p class="calibre7">Hash table based dictionaries have one drawback, the hash function has the potential to create <strong class="calibre16">collisions</strong>, or it can sometimes attempt to map two keys to the same index. Therefore, hash table based implementations must have a mechanism in place to resolve these conflicts. Many <strong class="calibre16">collision resolution strategies</strong> exist, but the details of these are beyond the scope of this text.</p></div></div>

<div><div><div><div><div><h2 class="title2" id="calibre_pb_2"><a id="ch06lvl2sec35" class="calibre1"/>Search tree based dictionaries</h2></div></div></div><p class="calibre7">A less common implementation of a dictionary is the <strong class="calibre16">search tree based</strong> associative array. Dictionaries based on search trees are well suited to sorting keys and values by some criteria or property of the value, plus they can be built to work more efficiently with custom key or value types. Another advantage of a search tree based implementation is the addition of operations beyond the basic functions described earlier, such as the ability to find a mapping whose key is similar to a specified key. These advantages come at a price, however, in that, the basic operations in search tree based implementations have a higher cost, while the collections themselves are more restrictive on the types of data they can work with. Sorting operations relating to search tree based dictionaries will be discussed in more detail in <a class="calibre1" title="Chapter 12. Sorting: Bringing Order Out Of Chaos" href="part0069_split_000.html#21PMQ2-77f2b5b248f04368a6f723b0e9357ef3">Chapter 12</a>, <em class="calibre20">Sorting: Bringing Order Out Of Chaos</em>.</p></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec32" class="calibre1"/>Summary</h1></div></div></div><p class="calibre7">In this chapter, you learned the basic definition of the dictionary, or associative array, data structure. You learned how to initialize dictionaries, and we examined the hash table data structure upon which most concrete dictionary implementations are based. We discussed the various common operations found in dictionaries, including their operational costs. Following this, we examined a case study where dictionaries would be very beneficial. Finally, we looked at two varying implementations of dictionaries, including the hash table based dictionary and the search tree based dictionary.</p></div></body></html>