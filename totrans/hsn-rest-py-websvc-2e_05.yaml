- en: Developing RESTful APIs with Django 2.1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will start working with Django and Django REST framework,
    and we will create a RESTful web API that performs CRUD operations on a simple
    SQLite database. We will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Design a RESTful API to interact with a simple SQLite database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand the tasks performed by each HTTP method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set up a virtual environment with Django REST framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manage serialization and deserialization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand status codes for responses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write API views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make HTTP requests to the API with command-line tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make HTTP requests to the API with GUI tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing a RESTful API to interact with a simple SQLite database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine that we have to start working on a mobile app that has to interact with
    a RESTful API to perform CRUD operations with games. We don't want to spend time
    choosing and configuring the most appropriate **ORM** (short for **Object-Relational
    Mapping**); we just want to finish the RESTful API as soon as possible to start
    interacting with it in our mobile app. We really want the games to persist in
    a database but we don't need it to be production-ready, and therefore, we can
    use the simplest possible relational database, as long as we don't have to spend
    time making complex installations or configurations.
  prefs: []
  type: TYPE_NORMAL
- en: We need the shortest possible development time. **Django Rest Framework** (**DRF**)
    will allow us to easily accomplish this task and start making HTTP requests to
    our first version of our RESTful web service. In this case, we will work with
    a very simple SQLite database, the default database for a new Django Rest Framework
    project.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we must specify the requirements for our main resource: a game. We need
    the following attributes or fields for a game:'
  prefs: []
  type: TYPE_NORMAL
- en: An integer identifier
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A name or title
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A release date
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An **ESRB** (short for **Entertainment Software Rating Board**) rating description,
    such as *T* (*Teen*) and *EC* (*Early Childhood*). You can read more about the
    ESRB at [http://www.esrb.org](http://www.esrb.org)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `bool` value indicating whether the game was played at least once by a player
    or not
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An integer indicating the number of times the game was played
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition, we want our database to save a timestamp with the date and time
    in which the game was inserted in the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows the HTTP verbs, the scope, and the semantics for
    the methods that our first version of the API must support. Each method is composed
    by an HTTP verb and a scope and all the methods have a well-defined meaning for
    the games and the collection of games:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **HTTP verb** | **Scope** | **Semantics** |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | Collection of games | Retrieve all the stored games in the collection,
    sorted by their name in ascending order |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | Game | Retrieve a single game |'
  prefs: []
  type: TYPE_TB
- en: '| `POST` | Collection of games | Create a new game in the collection |'
  prefs: []
  type: TYPE_TB
- en: '| `PUT` | Game | Update an existing game |'
  prefs: []
  type: TYPE_TB
- en: '| `DELETE` | Game | Delete an existing game |'
  prefs: []
  type: TYPE_TB
- en: In a RESTful API, each resource has its own unique URL. In our API, each game
    has its own unique URL.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the tasks performed by each HTTP method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous table, the `GET` HTTP verb appears twice but with two different
    scopes. The first row shows a `GET` HTTP verb applied to a collection of games
    (collection of resources) and the second row shows a `GET` HTTP verb applied to
    a game (a single resource).
  prefs: []
  type: TYPE_NORMAL
- en: Let's assume that `http://localhost:8000/games/` is the URL for the collection
    of games. If we add a number and a slash (`/`) to the previous URL, we identify
    a specific game whose ID is equal to the specified numeric value. For example,
    `http://localhost:8000/games/25/` identifies the game whose ID is equal to `25`.
  prefs: []
  type: TYPE_NORMAL
- en: We have to compose and send an HTTP request with the following HTTP verb (`POST`)
    and request URL (`http://localhost:8000/games/ ...`
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the virtual environment with Django REST framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 1](dbf75cef-4962-4e40-8192-03873b774c48.xhtml), *Developing RESTful
    APIs and Microservices with Flask 1.0.2*, we learned that, throughout this book,
    we are going to work with the lightweight virtual environments introduced and
    improved in Python 3.4\. Now we will follow many steps to create a new lightweight
    virtual environment to work with Flask and Flask-RESTful.
  prefs: []
  type: TYPE_NORMAL
- en: It is highly recommended that you read the section named *Working with lightweight
    virtual environments* in [Chapter 1](dbf75cef-4962-4e40-8192-03873b774c48.xhtml),
    *Developing RESTful APIs and Microservices with Flask 1.0.2*, if you don't have
    experience with lightweight virtual environments in modern Python. The chapter
    includes all the detailed explanations about the effects of the steps we are going
    to follow.
  prefs: []
  type: TYPE_NORMAL
- en: The following commands assume that you have Python 3.7.1 or greater installed
    on Linux, macOS, or Windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we have to select the target folder or directory for our lightweight
    virtual environment. The following is the path we will use in the example for
    Linux and macOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The target folder for the virtual environment will be the `HillarPythonREST2/Django01`
    folder within our home directory. For example, if our home directory in macOS
    or Linux is `/Users/gaston`, the virtual environment will be created within `/Users/gaston/HillarPythonREST2/Django01`.
    You can replace the specified path with your desired path in each command.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the path we will use in the example for Windows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The target folder for the virtual environment will be the `HillarPythonREST2\Django01`
    folder within our user profile folder. For example, if our user profile folder
    is `C:\Users\gaston`, the virtual environment will be created within `C:\Users\gaston\HillarPythonREST2\Django01`.
    Of course, you can replace the specified path with your desired path in each command.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Windows PowerShell, the previous path would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now we have to use the `-m` option followed by the `venv` module name and the
    desired path to make Python run this module as a script and create a virtual environment
    in the specified path. The instructions are different depending on the platform
    in which we are creating the virtual environment. Thus, make sure you follow the
    instructions for your operating system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a Terminal in Linux or macOS and execute the following command to create
    a virtual environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In Windows, in the Command Prompt, execute the following command to create
    a virtual environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to work with Windows PowerShell, execute the following command
    to create a virtual environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The previous commands don't produce any output. Now that we have created a virtual
    environment, we will run a platform-specific script to activate it. After we activate
    the virtual environment, we will install packages that will only be available
    in this virtual environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your Terminal is configured to use the `bash` shell in macOS or Linux, run
    the following command to activate the virtual environment. The command also works
    for the `zsh` shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If your Terminal is configured to use either the `csh` or `tcsh` shell, run
    the following command to activate the virtual environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If your Terminal is configured to use the `fish` shell, run the following command
    to activate the virtual environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In Windows, you can run either a batch file in the Command Prompt or a Windows
    PowerShell script to activate the virtual environment. If you prefer the Command
    Prompt, run the following command in the Windows command line to activate the
    virtual environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If you prefer the Windows PowerShell, launch it and run the following commands
    to activate the virtual environment. However, notice that you should have script
    execution enabled in Windows PowerShell to be able to run the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: After you activate the virtual environment, the Command Prompt will display
    the virtual environment root folder name enclosed in parenthesis as a prefix of
    the default prompt to remind us that we are working in the virtual environment.
    In this case, we will see (`Django01`) as a prefix for the Command Prompt because
    the root folder for the activated virtual environment is `Django01`.
  prefs: []
  type: TYPE_NORMAL
- en: We have followed the necessary steps to create and activate a virtual environment.
    Now we will create a `requirements.txt` file to specify the set of packages that
    our application requires to be installed in any supported platform. This way,
    it will be extremely easy to repeat the installation of the specified packages
    with their versions in any new virtual environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use your favorite editor to create a new text file named `requirements.txt`
    within the root folder for the recently created virtual environment. The following
    lines show the contents for the file that declares the packages and the versions
    that our API requires. The code file for the sample is included in the `restful_python_2_05_01`
    folder, in the `Django01/requirements.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Each line in the `requirements.txt` file indicates the package and the version
    that needs to be installed. In this case, we are working with exact versions by
    using the `==` operator because we want to make sure that the specified version
    is installed. The following table summarizes the packages and the version numbers
    that we specified as requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Package name | Version to be installed |'
  prefs: []
  type: TYPE_TB
- en: '| `Django` | 2.1.4 |'
  prefs: []
  type: TYPE_TB
- en: '| `djangorestframework` | 3.9.0 |'
  prefs: []
  type: TYPE_TB
- en: '| `httpie` | 1.0.2 |'
  prefs: []
  type: TYPE_TB
- en: 'Go to the root folder for the virtual environment: `Django01`. In macOS or
    Linux, enter the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In Windows Command Prompt, enter the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In Windows PowerShell, enter the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we must run the following command on macOS, Linux, or Windows to install
    the packages and the versions explained in the previous table with `pip` by using
    the recently created `requirements` file. Notice that `Django` is a dependency
    for `djangorestframework`. Make sure you are in the folder that has the `requirements.txt`
    file before running the command (`Django01`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The final lines for the output will indicate all the packages that have been
    successfully installed, including `Django`, `djangorestframework`, and `httpie`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now run the following command to create a new Django project named `games_service`.
    The command won''t produce any output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous command created a `games_service` folder with other subfolders
    and Python files. Now go to the recently created `games_service` folder. Just
    execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, run the following command to create a new Django app named `games` within
    the `games_service` Django project. The command won''t produce any output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous command created a new `games_service/games` subfolder, with the
    following files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`__init__.py`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`admin.py`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`apps.py`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`models.py`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tests.py`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`views.py`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In addition, the `games_service/games` folder will have a `migrations` subfolder
    with a `__init__.py` Python script. The following screenshot shows the folders
    and files in the directory trees starting at the `games_service` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a9394409-5001-444d-bc88-bc861894f1b4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s check the Python code in the `apps.py` file within the `games_service/games`
    folder. The following lines show the code for this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The code declares the `GamesConfig` class as a subclass of the `django.apps.AppConfig`
    superclass, which represents a Django application and its configuration. The `GamesConfig`
    class just defines the `name` class attribute and sets its value to `'games'`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have to add `games.apps.GamesConfig` as one of the installed apps in the
    `games_service/game_service/settings.py` file, which configures settings for the
    `games_service` Django project. We built the previous string as follows: `app
    name` + `.apps.` + `class name`, which is `games` + `.apps.` + `GamesConfig`.
    In addition, we have to add the `rest_framework` app to make it possible for us
    to use Django REST Framework.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `games_service/games_service/settings.py` file is a Python module with
    module-level variables that define the configuration of Django for the `games_service`
    project. We will make some changes to this Django settings file. Open the `games_service/games_service/settings.py`
    file and locate the following lines, which specify the strings list that declares
    the installed apps and save it in the `INSTALLED_APPS` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following two strings to the `INSTALLED_APPS` strings list and save
    the changes to the `games_service/games_service/settings.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''rest_framework''`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''games.apps.GamesConfig''`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following lines show the new code that declares the `INSTALLED_APPS` strings
    list with the added lines highlighted. The code file for the sample is included
    in the `restful_python_2_05_01` folder, in the `Django01/games_service/games-service/settings.py`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This way, we have added Django REST Framework and the `games` application to
    our initial Django project named `games_service`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we will create a simple `Game` model that we will use to represent and
    persist games. Open the `games_service/games/models.py` file. The following lines
    show the initial code for this file, with just one import statement and a comment
    that indicates we should create the models:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace the code for the `games_service/games/models.py` file with the following
    lines. The new code creates a `Game` class, specifically, a `Game` model in the
    `games/models.py` file. The code file for the sample is included in the `restful_python_2_05_01`
    folder, in the `Django01/games_service/games/apps.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Managing serialization and deserialization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our RESTful web API has to be able to serialize the game instances into JSON
    representations and also deserialize the JSON representations to build game instances.
    With Django REST Framework, we just need to create a serializer class for the
    game instances to manage serialization to JSON and deserialization from JSON.
  prefs: []
  type: TYPE_NORMAL
- en: Django REST Framework uses a two-phase process for serialization. The serializers
    are mediators between the model instances and Python primitives. Parsers and renderers
    act as mediators between Python primitives and HTTP requests and responses.
  prefs: []
  type: TYPE_NORMAL
- en: We will configure our mediator between the `Game` model instances and Python
    primitives by creating a subclass of the `rest_framework.serializers.Serializer`
    class to declare the fields and the necessary methods to manage serialization
    and deserialization. We will repeat some of the information about the fields that
    we have included in the `Game` model so that we understand all the things that
    we can configure in a subclass of the `Serializer` class. However, we will work
    with shortcuts that will reduce boilerplate code later in the next examples. We
    will write less code in the next examples by using the `ModelSerializer` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now go to the `games_service/games` folder and create a new Python code file
    named `serializers.py`. The following lines show the code that declares the new
    `GameSerializer` class. The code file for the sample is included in the `restful_python_2_05_01`
    folder, in the `Django01/games_service/games/serializers.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `GameSerializer` class declares the attributes that represent the fields
    that we want to be serialized. Notice that we have omitted the `created_timestamp`
    attribute that was present in the `Game` model. When there is a call to the inherited
    `save` method for this class, the overridden `create` and `update` methods define
    how to create or modify an instance. In fact, these methods must be implemented
    in our class because they just raise a `NotImplementedError` exception in their
    base declaration in the `Serializer` superclass.
  prefs: []
  type: TYPE_NORMAL
- en: The `create` method receives the validated data in the `validated_data` argument.
    The code creates and returns a new `Game` instance based on the received validated
    data.
  prefs: []
  type: TYPE_NORMAL
- en: The `update` method receives an existing `Game` instance that is being updated
    and the new validated data in the `instance` and `validated_data` arguments. The
    code updates the values for the attributes of the instance with the updated attribute
    values retrieved from the validated data, calls the save method for the updated
    `Game` instance, and returns the updated and saved instance.
  prefs: []
  type: TYPE_NORMAL
- en: We can launch our default Python interactive shell and make all the Django project
    modules available before it starts. This way, we can check that the serializer
    works as expected. In addition, it will help us understand how serialization works
    in Django.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to launch the interactive shell. Make sure you are
    within the `games_service` folder in the Terminal or Command Prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'You will notice that a line that says (`InteractiveConsole`) is displayed after
    the usual lines that introduce your default Python interactive shell. Enter the
    following code in the Python interactive shell to import all the things we will
    need to test the `Game` model and its serializer. The code file for the sample
    is included in the `restful_python_2_05_01` folder, in the `Django01/cmd/serializers_test_01.py`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now enter the following code to create two instances of the `Game` model and
    save them. The code file for the sample is included in the `restful_python_2_05_01`
    folder, in the `Django01/cmd/serializers_test_01.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'After we execute the previous code, we can check the SQLite database with the
    previously introduced command-line command or GUI tool to check the contents of
    the `games_game` table. We will notice the table has two rows and the columns
    have the values we have provided to the different attributes of the `Game` instances.
    However, make sure you run the commands in another Terminal or Command Prompt
    to avoid leaving the interactive shell that we will continue to use. The following
    screenshot shows the contents of the `games_game` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/da48bd1e-6a9c-4946-b66f-0988c38183f8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Enter the following commands in the interactive shell to check the values for
    the identifiers for the saved `Game` instances and the value of the `created_timestamp`
    attribute that includes the date and time in which we saved the instance to the
    database. The code file for the sample is included in the `restful_python_2_05_01`
    folder, in the `Django01/cmd/serializers_test_01.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s write the following code to serialize the first game instance (`game1`).
    The code file for the sample is included in the `restful_python_2_05_01` folder,
    in the `Django01/cmd/serializers_test_01.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The following line shows the generated dictionary, specifically, a `rest_framework.utils.serializer_helpers.ReturnDict`
    instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s serialize the second game instance (`game2`). The code file for
    the sample is included in the `restful_python_2_05_01` folder, in the `Django01/cmd/serializers_test_01.py`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The following line shows the generated dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We can easily render the dictionaries held in the `data` attribute into JSON
    with the help of the `rest_framework.renderers.JSONRenderer` class. The following
    lines create an instance of this class and then call the `render` method to render
    the dictionaries held in the `data` attribute into their JSON representation.
    The code file for the sample is included in the `restful_python_2_05_01` folder,
    in the `Django01/cmd/serializers_test_01.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines show the output generated from the two calls to the `render`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we will work in the opposite direction, from serialized data to the population
    of a `Game` instance. The following lines generate a new `Game` instance from
    a JSON string (serialized data); that is, we will write code that deserializes.
    The code file for the sample is included in the `restful_python_2_05_01` folder,
    in the `Django01/cmd/serializers_test_01.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The first line creates a new string with the JSON that defines a new game (`json_string_for_new_game`).
    Then, the code converts the string to `bytes` and saves the results of the conversion
    in the `json_bytes_for_new_game` variable. The `django.utils.six.BytesIO` class
    provides a buffered I/O implementation using an in-memory bytes buffer. The code
    uses this class to create a stream from the previously generated JSON bytes with
    the serialized data, `json_bytes_for_new_game`, and saves the generated instance
    in the `stream_for_new_game` variable.
  prefs: []
  type: TYPE_NORMAL
- en: We can easily deserialize and parse a stream into the Python models with the
    help of the `rest_framework.parsers.JSONParser` class. The next line creates an
    instance of this class and then calls the `parse` method with `stream_for_new_game`
    as an argument, parses the stream into Python native datatypes, and saves the
    results in the `parsed_new_game` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'After executing the previous lines, `parsed_new_game` holds a Python dictionary,
    parsed from the stream. The following lines show the output generated after executing
    the previous code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines use the `GameSerializer` class to generate a fully populated
    `Game` instance named `new_game` from the Python dictionary, parsed from the stream.
    The code file for the sample is included in the `restful_python_2_05_01` folder,
    in the `Django01/cmd/serializers_test_01.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: First, the code creates an instance of the `GameSerializer` class with the Python
    dictionary that we previously parsed from the stream (`parsed_new_game`) passed
    as the `data` keyword argument. Then, the code calls the `is_valid` method to
    determine whether the data is valid or not.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we must always call `is_valid` before we attempt to access the serialized
    data representation when we pass a `data` keyword argument in the creation of
    a serializer.
  prefs: []
  type: TYPE_NORMAL
- en: If the method returns `true`, we can access the serialized representation in
    the `data` attribute, and therefore, the code calls the `save` method that inserts
    the corresponding row in the database and returns a fully populated `Game` instance,
    saved in the `new_game` local variable. Then, the code prints one of the attributes
    from the fully populated `Game` instance named `new_game`.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see from the previous code, Django REST Framework makes it easy to
    serialize from objects to JSON and deserialize from JSON to objects, which are
    core requirements for our RESTful web API, which has to perform CRUD operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following command to leave the shell with the Django project modules
    that we started to test serialization and deserialization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Understanding status codes for the responses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Django REST Framework declares a set of named constants for the different HTTP
    status codes in the `status` module. We will always use these named constants
    to return HTTP status codes.
  prefs: []
  type: TYPE_NORMAL
- en: It is bad practice to return numbers as status codes. We want our code to be
    easy to read and understand, and therefore, we will use descriptive HTTP status
    codes.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in case we have to return a `404 Not Found` status code, we will
    return `status.HTTP_404_NOT_FOUND`, instead of just `404`. If we have to return
    a `201 Created` status code, we will return `status.HTTP_201_CREATED`, instead
    of just `201`.
  prefs: []
  type: TYPE_NORMAL
- en: Writing API views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we will create Django views that will use the previously created `GameSerializer`
    class to return JSON representations for each HTTP request that our API will handle.
    Open the `views.py` file located within the `games_service/games` folder. The
    following lines show the initial code for this file, with just one import statement
    and a comment that indicates we should create the views:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace the existing code with the following lines. The new code creates a
    `JSONResponse` class and declares two functions: `game_collection` and `game_detail`.
    We are creating our first version of the API, and we use functions to keep the
    code as simple as possible. We will work with classes and more complex code in
    the next examples. The highlighted lines show the expressions that evaluate the
    value of the `request.method` attribute to determine the actions to be performed
    based on the HTTP verb. The code file for the sample is included in the `restful_python_2_05_01`
    folder, in the `Django01/games-service/games/views.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The `JSONResponse` class is a subclass of the `django.http.HttpResponse` class.
    The superclass represents an HTTP response with a string as content. The `JSONResponse`
    class renders its content into JSON. The class defines just declare the `__init__`
    method that created a `rest_framework.renderers.JSONRenderer` instance and calls
    its `render` method to render the received data into JSON and save the returned
    `bytestring` in the `content` local variable. Then, the code adds the `'content_type'`
    key to the response header with `'application/json'` as its value. Finally, the
    code calls the initializer for the base class with the JSON `bytestring` and the
    key-value pair added to the header. This way, the class represents a JSON response
    that we use in the two functions to easily return a JSON response.
  prefs: []
  type: TYPE_NORMAL
- en: The code uses the `@csrf_exempt` decorator in the two functions to ensure that
    the view sets a **CSRF** (short for **Cross-Site Request Forgery**) cookie. We
    do this to make it simple to test this example that doesn't represent a production-ready
    web service. We will add security features to our RESTful API later.
  prefs: []
  type: TYPE_NORMAL
- en: When the Django server receives an HTTP request, Django creates an `HttpRequest`
    instance, specifically a `django.http.HttpRequest` object. This instance contains
    metadata about the request, including the HTTP verb. The `method` attribute provides
    a string representing the HTTP verb or method used in the request.
  prefs: []
  type: TYPE_NORMAL
- en: When Django loads the appropriate view that will process the requests, it passes
    the `HttpRequest` instance as the first argument to the view function. The view
    function has to return an `HttpResponse` instance, specifically, a `django.http.HttpResponse`
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `game_collection` function lists all the games or creates a new game. The
    function receives an `HttpRequest` instance in the `request` argument. The function
    is capable of processing two HTTP verbs: `GET` and `POST`. The code checks the
    value of the `request.method` attribute to determine the code to be executed based
    on the HTTP verb. If the HTTP verb is `GET`, the `request.method == ''GET''` expression
    will evaluate to `True` and the code has to list all the games. The code will
    retrieve all the `Game` objects from the database, use the `GameSerializer` to
    serialize all of them and return a `JSONResponse` instance built with the data
    generated by `GameSerializer`. The code creates the `GameSerializer` instance
    with the `many=True` argument to specify that multiple instances have to be serialized
    and not just one. Under the hood, Django uses a `ListSerializer` when the `many`
    argument value is set to `True`.'
  prefs: []
  type: TYPE_NORMAL
- en: If the HTTP verb is `POST`, the code has to create a new game based on the JSON
    data that is included in the HTTP request. First, the code uses a `JSONParser`
    instance and calls its parse method with `request` as an argument to parse the
    game data provided as `JSON` data in the request and saves the results in the
    `game_data` local variable. Then, the code creates a `GameSerializer` instance
    with the previously retrieved data and calls the `is_valid` method to determine
    whether the `Game` instance is valid or not. If the instance is valid, the code
    calls the `save` method to persist the instance in the database and returns a
    `JSONResponse` with the saved data in its body and a status equal to `status.HTTP_201_CREATED`,
    that is, `201 Created`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `game_detail` function retrieves, updates, or deletes an existing game.
    The function receives an `HttpRequest` instance in the `request` argument and
    the ID for the game to be retrieved, updated, or deleted in the `id` argument.
    The function is capable of processing three HTTP verbs: `GET`, `PUT`, and `DELETE`.
    The code checks the value of the `request.method` attribute to determine the code
    to be executed based on the HTTP verb. Irrespective of the HTTP verb, the function
    calls the `Game.objects.get` method with the received `id` as the `id` argument
    to retrieve a `Game` instance from the database based on the specified id, and
    saves it in the `game` local variable. If a game with the specified id doesn''t
    exist in the database, the code returns an `HttpResponse` with its status equal
    to `status.HTTP_404_NOT_FOUND`, that is, `404 Not Found`.'
  prefs: []
  type: TYPE_NORMAL
- en: If the HTTP verb is `GET`, the code creates a `GameSerializer` instance with
    `game` as an argument and returns the data for the serialized game in a `JSONResponse`
    that will include the default `200 OK` status. The code returns the retrieved
    game serialized as JSON.
  prefs: []
  type: TYPE_NORMAL
- en: If the HTTP verb is `PUT`, the code has to create a new game based on the JSON
    data that is included in the HTTP request, and use it to replace an existing game.
    First, the code uses a `JSONParser` instance and calls its parse method with `request`
    as an argument to parse the game data provided as `JSON` data in the request and
    saves the results in the `game_data` local variable. Then, the code creates a
    `GameSerializer` instance with the `Game` instance previously retrieved from the
    database, `game`, and the retrieved data that will replace the existing data,
    `game_data`. Then, the code calls the `is_valid` method to determine whether the
    `Game` instance is valid or not. If the instance is valid, the code calls the
    `save` method to persist the instance with the replaced values in the database
    and returns a `JSONResponse` with the saved data in its body and the default `200
    OK` status. If the parsed data doesn't generate a valid `Game` instance, the code
    returns a `JSONResponse` with a status equal to `status.HTTP_400_BAD_REQUEST`,
    that is, `400 Bad Request`.
  prefs: []
  type: TYPE_NORMAL
- en: If the HTTP verb is `DELETE`, the code calls the `delete` method for the `Game`
    instance previously retrieved from the database (`game`). The call to the `delete`
    method erases the underlying row in the `games_game` table, and therefore, the
    game won't be available anymore. Then, the code returns a `JSONResponse` with
    a status equal to `status.HTTP_204_NO_CONTENT` that is, `204 No Content`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we have to create a new Python file named `urls.py` in the `games_service/games`
    folder, specifically, the `games_service/games/urls.py` file. The following lines
    show the code for this file that defines the URL patterns that specifies the regular
    expressions that have to be matched in the request to run a specific function
    defined in the `views.py` file. The code file for the sample is included in the
    `restful_python_2_05_01` folder, in the `Django01/games-service/games/urls.py`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The `urlpatterns` list makes it possible to route URLs to views. The code calls
    the `django.conf.urls.url` function with the regular expression that has to be
    matched, and the view function defined in the views module as arguments to create
    a `RegexURLPattern` instance for each entry in the `urlpatterns` list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we have to replace the code in the `urls.py` that Django built automatically
    in the `games_service` folder, specifically, the `games_service/urls.py` file.
    Don''t confuse this file with the previously created `urls.py` file that is saved
    in another folder. The `games_service/urls.py` file defines the root URL configurations,
    and therefore, we must include the URL patterns declared in the previously coded
    `games_service/games/urls.py` file. The following lines show the new code for
    the `games_service/urls.py` file. The code file for the sample is included in
    the `restful_python_2_05_01` folder, in the `Django01/games-service/urls.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Making HTTP requests to the Django API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we can launch Django''s development server to compose and send HTTP requests
    to our unsecure web API (we will definitely add security later). Execute the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The following lines show the output after we execute the previous command. The
    development server is listening at port `8000`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: With the previous command, we will start Django development server and we will
    only be able to access it in our development computer. ...
  prefs: []
  type: TYPE_NORMAL
- en: Working with command-line tools - curl and httpie
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will start composing and sending HTTP requests with the `curl` and HTTPie
    command-line tools we introduced in [Chapter 1](dbf75cef-4962-4e40-8192-03873b774c48.xhtml),
    *Developing RESTful APIs and Microservice with Flask 1.0.2*, in the section named
    *Working with command-line tools - curl and httpie*. Make sure you read this section
    before executing the next examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whenever we compose HTTP requests with the command line, we will use two versions
    of the same command: the first one with HTTPie and the second one with `curl`.
    This way, you will be able to use the most convenient for you.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure you leave the Django development server running. Don''t close the
    Terminal or Command Prompt that is running this development server. Open a new
    Terminal in macOS or Linux, or a Command Prompt in Windows, and run the following
    command. We will compose and send an HTTP request to create a new notification.
    The code file for the sample is included in the `restful_python_2_05_01` folder,
    in the `Django01/cmd/cmd01.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent `curl` command. The code file for the sample
    is included in the `restful_python_2_05_01` folder, in the `Django01/cmd/cmd02.txt`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: It is very important that you enter the ending slash (`/`) when specified because
    `/service/notifications` won't match any of the configured URL routes. Thus, we
    must enter `/service/notifications/`, including the ending slash (`/`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous command will compose and send the following HTTP request: `GET
    http://localhost:8000/games/`. The request is the simplest case in our RESTful
    API because it will match and run the `views.game_collection` function, that is,
    the `game_collection` function declared within the `game_service/games/views.py`
    file. The function only receives `request` as a parameter because the URL pattern
    doesn''t include any parameters. As the HTTP verb for the request is `GET`, the
    `request.method` property is equal to `''GET''`, and therefore, the function will
    execute the code that retrieves all the `Game` objects and generate a JSON response
    with all of these `Game` objects serialized.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following lines show an example response for the HTTP request, with three
    `Game` objects in the JSON response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'After we run a request, we will see the following line in the window that is
    running the Django development server. The output indicates that the server received
    an HTTP request with the `GET` verb and `/games/` as the URI. The server processed
    the HTTP requests, the returned status code `200` and the response length was
    equal to `438` characters. The response length can be different because the value
    for `id` assigned to each game will have an incidence in the response length.
    The first number after `HTTP/1.1."` indicates the returned status code (`200`)
    and the second number the response length (`438`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows two Terminal windows side by side on macOS.
    The Terminal window at the left-hand side is running the Django development server
    and displays the received and processed HTTP requests. The Terminal window at
    the right-hand side is running `http` commands to generate the HTTP requests.
    It is a good idea to use a similar configuration to check the output while we
    compose and send the HTTP requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6ffae235-3361-45e1-bb29-66247cdef340.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we will select one of the games from the previous list and we will compose
    an HTTP request to retrieve just the chosen game. For example, in the previous
    list, the first game has an `id` value equal to `3`. Run the following command
    to retrieve this game. Use the `id` value you have retrieved in the previous command
    for the first game, as the `id` number might be different. The code file for the
    sample is included in the `restful_python_2_05_01` folder, in the `Django01/cmd/cmd03.txt`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent `curl` command. The code file for the sample
    is included in the `restful_python_2_05_01` folder, in the `Django01/cmd/cmd04.txt`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous commands will compose and send the following HTTP request: `GET
    http://localhost:8000/games/3/`. The request has a number after `/games/`, and
    therefore, it will match `''^games/(?P<id>[0-9]+)/$''` and run the `views.game_detail`
    function, that is, the `game_detail` function declared within the `games_service/games/views.py`
    file. The function receives `request` and `id` as parameters because the URL pattern
    passes the number specified after `/games/` in the `id` parameter. As the HTTP
    verb for the request is `GET`, the `request.method` property is equal to `''GET''`,
    and therefore, the function will execute the code that retrieves the `Game` object
    whose primary key matches the `id` value received as an argument and, if found,
    generates a JSON response with this `Game` object serialized. The following lines
    show an example response for the HTTP request, with the `Game` object that matches
    the `id` value in the JSON response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we will compose and send an HTTP request to retrieve a game that doesn''t
    exist. For example, in the previous list, there is no game with an `id` value
    equal to `888`. Run the following command to try to retrieve this game. Make sure
    you use an `id` value that doesn''t exist. We must make sure that the utilities
    display the headers as part of the response because the response won''t have a
    body. The code file for the sample is included in the `restful_python_2_05_01`
    folder, in the `Django01/cmd/cmd05.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent `curl` command. The code file for the sample
    is included in the `restful_python_2_05_01` folder, in the `Django01/cmd/cmd06.txt`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous commands will compose and send the following HTTP request: `GET
    http://localhost:8000/games/888/`. The request is the same as the previous one
    we have analyzed, with a different number for the `id` parameter. The server will
    run the `views.game_detail` function, that is, the `game_detail` function declared
    within the `games_service/games/views.py` file. The function will execute the
    code that retrieves the `Game` object whose primary key matches the `id` value
    received as an argument and a `Game.DoesNotExist` exception will be thrown and
    captured because there is no game with the specified `id` value. Thus, the code
    will return an HTTP `404 Not Found` status code. The following lines show an example
    header response for the HTTP request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Now run the following command to compose and send an HTTP `POST` request to
    create a new game. The code file for the sample is included in the `restful_python_2_05_01`
    folder, in the `Django01/cmd/cmd07.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent `curl` command. It is very important to use
    the `-H "Content-Type: application/json"` option to indicate `curl` to send the
    data specified after the `-d` option as `application/json` instead of the default
    `application/x-www-form-urlencoded`. The code file for the sample is included
    in the `restful_python_2_05_01` folder, in the `Django01/cmd/cmd08.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous commands will compose and send the following HTTP request: `POST
    http://localhost:8000/games/` with the following JSON key-value pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The request specifies `/games/`, and therefore, it will match `''^games/$''`
    and run the `views.game_collection` function, that is, the `game_collection` function
    declared within the `games_service/ames/views.py` file. The function just receives
    `request` as a parameter because the URL pattern doesn''t include any parameters.
    As the HTTP verb for the request is `POST`, the `request.method` property is equal
    to `''POST''`, and therefore, the function executes the code that parses the JSON
    data received in the request, creates a new `Game` and, if the data is valid,
    it saves the new `Game` instance. If the new `Game` instance was successfully
    persisted in the database, the function returns an HTTP `201 Created` status code
    and the recently persisted `Game` serialized to JSON in the response body. The
    following lines show an example response for the HTTP request, with the new `Game`
    object in the JSON response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we run the following command to compose and send an HTTP `PUT` request
    to update an existing game, specifically, to replace the previously added game
    with a new one. We have to check the value assigned to `id` in the previous response
    and replace `4` in the command with the returned value. For example, if the value
    for `id` was `8`, you should use `games/8/` instead of `games/4/`. The code file
    for the sample is included in the `restful_python_2_05_01` folder, in the `Django01/cmd/cmd09.txt`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent `curl` command. As happened with the previous
    `curl` example, it is very important to use the `-H "Content-Type: application/json"`
    option to indicate `curl` to send the data specified after the `-d` option as
    `application/json` instead of the default `application/x-www-form-urlencoded`.
    The code file for the sample is included in the `restful_python_2_05_01` folder,
    in the `Django01/cmd/cmd10.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous commands will compose and send the HTTP request `PUT http://localhost:8000/games/15/`
    with the following JSON key-value pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The request has a number after `/games/`, and therefore, it will match `''^games/(?P<id>[0-9]+)/$''`
    and run the `views.game_detail` function, that is, the `game_detail` function
    declared within the `games_service/games/views.py` file. The function receives
    `request` and `id` as parameters because the URL pattern passes the number specified
    after `/games/` in the `id` parameter. As the HTTP verb for the request is `PUT`,
    the `request.method` property is equal to `''PUT''`, and therefore, the function
    executes the code that parses the JSON data received in the request, creates a
    `Game` instance from this data and updates all the fields for the existing game
    in the database. If the game was successfully updated in the database, the function
    returns an HTTP `200 OK` status code and the recently updated `Game` serialized
    to JSON in the response body. The following lines show an example response for
    the HTTP request, with the updated `Game` object in the JSON response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to successfully process an HTTP `PUT` request that updates an existing
    game with a new one, we must provide values for all the required fields. We will
    compose and send an HTTP request to try to update an existing game, and we will
    fail to do so because we will just provide a value for the name. As happened in
    the previous request, we will use the value assigned to `id` in the last game
    we added. The code file for the sample is included in the `restful_python_2_05_01`
    folder, in the `Django01/cmd/cmd11.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent `curl` command. The code file for the sample
    is included in the `restful_python_2_05_01` folder, in the `Django01/cmd/cmd12.txt`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous commands will compose and send the HTTP request `PUT http://localhost:8000/games/15/`
    with the following JSON key-value pair:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The request will execute the same code we explained for the previous request.
    Because we didn''t provide all the required values for a `Game` instance, the
    `game_serializer.is_valid()` method will return `False` and the function will
    return an HTTP `400 Bad Request` status code and the details generated in the
    `game_serializer.errors` attribute are serialized to JSON in the response body.
    The following lines show an example response for the HTTP request, with the required
    fields that didn''t include values in our request listed in the JSON response.
    The list uses the field name as a key and the error message as a value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: When we want our API to be able to update a single field for an existing resource,
    in this case, an existing game, we should provide an implementation for the `PATCH`
    method. The `PUT` method is meant to replace an entire resource and the `PATCH`
    method is meant to apply a delta to an existing resource. We can write code in
    the handler for the `PUT` method to apply a delta to an existing resource, but
    it is a better practice to use the `PATCH` method for this specific task. We will
    work with the `PATCH` method later when we code an improved version of our API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now run the following command to compose and send an HTTP request to delete
    an existing game, specifically, the last game we added and updated. As happened
    in our last HTTP requests, we have to check the value assigned to `id` in the
    previous response and replace `4` in the command with the returned value. The
    code file for the sample is included in the `restful_python_2_05_01` folder, in
    the `Django01/cmd/cmd13.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent `curl` command. The code file for the sample
    is included in the `restful_python_2_05_01` folder, in the `Django01/cmd/cmd14.txt`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous commands will compose and send the following HTTP request: `DELETE
    http://localhost:8000/games/4/`. The request has a number after `/games/`, and
    therefore, it will match `''^games/(?P<id>[0-9]+)/$''` and run the `views.game_detail`
    function, that is, the `game_detail` function declared within the `games_service/views.py`
    file. The function receives `request` and `id` as parameters because the URL pattern
    passes the number specified after `/games/` in the `id` parameter. As the HTTP
    verb for the request is `DELETE`, the `request.method` property is equal to `''DELETE''`,
    and therefore, the function will execute the code that parses the JSON data received
    in the request, creates a `Game` instance from this data and deletes the existing
    game in the database. If the game was successfully deleted in the database, the
    function returns an HTTP `204 No Content` status code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following lines show an example response for the HTTP request after successfully
    deleting an existing game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Working with GUI tools - Postman and others
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have been working with two Terminal-based or command-line tools
    to compose and send HTTP requests to our Django development server: cURL and HTTPie.
    Now we will work with Postman, one of the GUI tools we used when composing and
    sending HTTP requests to the Flask development server on [Chapter 1](dbf75cef-4962-4e40-8192-03873b774c48.xhtml),
    *Developing RESTful APIs and Microservices with Flask 1.0.2*. If you skipped this
    chapter, make sure you check the installation instructions in the section named
    *Working with GUI tools - Postman and others* in that chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Once you launch Postman, make sure you close the modal dialog box that provides
    shortcuts to common tasks. Select GET Request in the + new drop-down menu at the
    upper-left corner ...
  prefs: []
  type: TYPE_NORMAL
- en: Test your knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see whether you can answer the following questions correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Which of the following commands run the script to create a new Django app named
    `recipes`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`python django.py startapp recipes`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`python manage.py startapp recipes`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`python starapp.py recipes`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Which of the following strings must be added to the `INSTALLED_APPS` variable
    to add Django REST Framework in the Django application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`''rest-framework''`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`''django-rest-framework''`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`''rest_framework''`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Django''s ORM:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is integrated with Django
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Has to be configured as an optional component in Django
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Has to be installed after configuring SQLAlchemy
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In Django REST Framework, serializers are:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Mediators between the view functions and Python primitives
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Mediators between the URLs and view functions
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Mediators between the model instances and Python primitives
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `urlpatterns` list declared in the `urls.py` file makes it possible to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Route URLs to models
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Route URLs to Python primitives
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Route URLs to views
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In Django REST Framework, parsers and renderers handle as mediators between:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Model instances and Python primitives
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Python primitives and HTTP requests and responses
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: URLs and view functions
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If we want to create a simple `Game` model to represent and persist games in
    Django REST Framework, we can create:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A `Game` class as a subclass of the `django.db.models.Model` superclass
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A `Game` class as a subclass of the `djangorestframework.models.Model` superclass
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A `Game` function in the `restframeworkmodels.py` file
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we designed a RESTful API to interact with a simple SQLite
    database and perform CRUD operations with games. We defined the requirements for
    our API and we understood the tasks performed by each HTTP method. We set up a
    virtual environment with Django and Django REST Framework.
  prefs: []
  type: TYPE_NORMAL
- en: We created a model to represent and persist games and we executed migrations
    in Django. We learned to manage serialization and serialization of game instances
    into JSON representations with Django REST Framework. We wrote API views to process
    the different HTTP requests and we configured the URL patterns list to route URLs
    to views.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we started the Django development server and we used command-line tools
    to compose and send HTTP requests ...
  prefs: []
  type: TYPE_NORMAL
