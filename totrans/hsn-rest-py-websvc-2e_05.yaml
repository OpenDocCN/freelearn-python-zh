- en: Developing RESTful APIs with Django 2.1
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Django 2.1 开发 RESTful API
- en: 'In this chapter, we will start working with Django and Django REST framework,
    and we will create a RESTful web API that performs CRUD operations on a simple
    SQLite database. We will do the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开始使用 Django 和 Django REST framework，并创建一个 RESTful 网络 API，该 API 在简单的
    SQLite 数据库上执行 CRUD 操作。我们将做以下事情：
- en: Design a RESTful API to interact with a simple SQLite database
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计一个与简单 SQLite 数据库交互的 RESTful API
- en: Understand the tasks performed by each HTTP method
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解每个 HTTP 方法执行的任务
- en: Set up a virtual environment with Django REST framework
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Django REST framework 设置虚拟环境
- en: Create models
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建模型
- en: Manage serialization and deserialization
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理序列化和反序列化
- en: Understand status codes for responses
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解响应的状态码
- en: Write API views
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写 API 视图
- en: Make HTTP requests to the API with command-line tools
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用命令行工具向 API 发送 HTTP 请求
- en: Make HTTP requests to the API with GUI tools
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 GUI 工具向 API 发送 HTTP 请求
- en: Designing a RESTful API to interact with a simple SQLite database
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计一个与简单 SQLite 数据库交互的 RESTful API
- en: Imagine that we have to start working on a mobile app that has to interact with
    a RESTful API to perform CRUD operations with games. We don't want to spend time
    choosing and configuring the most appropriate **ORM** (short for **Object-Relational
    Mapping**); we just want to finish the RESTful API as soon as possible to start
    interacting with it in our mobile app. We really want the games to persist in
    a database but we don't need it to be production-ready, and therefore, we can
    use the simplest possible relational database, as long as we don't have to spend
    time making complex installations or configurations.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我们必须开始开发一个需要与 RESTful API 交互以执行游戏 CRUD 操作的移动应用。我们不希望花费时间选择和配置最合适的 **ORM**（**对象关系映射**）；我们只想尽快完成
    RESTful API，以便在移动应用中与之交互。我们确实希望游戏持久化在数据库中，但我们不需要它准备好投入生产，因此，我们可以使用最简单的可能的关系数据库，只要我们不需要花费时间进行复杂的安装或配置。
- en: We need the shortest possible development time. **Django Rest Framework** (**DRF**)
    will allow us to easily accomplish this task and start making HTTP requests to
    our first version of our RESTful web service. In this case, we will work with
    a very simple SQLite database, the default database for a new Django Rest Framework
    project.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要尽可能短的开发时间。**Django Rest Framework**（**DRF**）将使我们能够轻松完成这项任务，并开始向我们的第一个 RESTful
    网络服务发送 HTTP 请求。在这种情况下，我们将使用一个非常简单的 SQLite 数据库，它是新 Django Rest Framework 项目的默认数据库。
- en: 'First, we must specify the requirements for our main resource: a game. We need
    the following attributes or fields for a game:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须指定我们主要资源：一个游戏。对于一个游戏，我们需要以下属性或字段：
- en: An integer identifier
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个整数标识符
- en: A name or title
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名称或标题
- en: A release date
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布日期
- en: An **ESRB** (short for **Entertainment Software Rating Board**) rating description,
    such as *T* (*Teen*) and *EC* (*Early Childhood*). You can read more about the
    ESRB at [http://www.esrb.org](http://www.esrb.org)
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 **ESRB**（**娱乐软件分级委员会**）评级描述，例如 *T*（青少年）和 *EC*（幼儿）。您可以在 [http://www.esrb.org](http://www.esrb.org)
    上了解更多关于 ESRB 的信息
- en: A `bool` value indicating whether the game was played at least once by a player
    or not
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `bool` 值，表示游戏是否至少被玩家玩过一次
- en: An integer indicating the number of times the game was played
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个整数，表示游戏被玩过的次数
- en: In addition, we want our database to save a timestamp with the date and time
    in which the game was inserted in the database.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们希望我们的数据库能够保存一个时间戳，记录游戏被插入数据库的日期和时间。
- en: 'The following table shows the HTTP verbs, the scope, and the semantics for
    the methods that our first version of the API must support. Each method is composed
    by an HTTP verb and a scope and all the methods have a well-defined meaning for
    the games and the collection of games:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了我们的 API 第一个版本必须支持的 HTTP 动词、范围和语义。每个方法由一个 HTTP 动词和一个范围组成，所有方法都对游戏和游戏集合有明确的含义：
- en: '| **HTTP verb** | **Scope** | **Semantics** |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| **HTTP 动词** | **范围** | **语义** |'
- en: '| `GET` | Collection of games | Retrieve all the stored games in the collection,
    sorted by their name in ascending order |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | 游戏集合 | 获取集合中存储的所有游戏，按名称升序排序 |'
- en: '| `GET` | Game | Retrieve a single game |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | 游戏 | 获取单个游戏 |'
- en: '| `POST` | Collection of games | Create a new game in the collection |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| `POST` | 游戏集合 | 在集合中创建一个新的游戏 |'
- en: '| `PUT` | Game | Update an existing game |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| `PUT` | 游戏 | 更新现有的游戏 |'
- en: '| `DELETE` | Game | Delete an existing game |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| `DELETE` | 游戏 | 删除现有的游戏 |'
- en: In a RESTful API, each resource has its own unique URL. In our API, each game
    has its own unique URL.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在 RESTful API 中，每个资源都有自己的唯一 URL。在我们的 API 中，每个游戏都有自己的唯一 URL。
- en: Understanding the tasks performed by each HTTP method
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解每个 HTTP 方法执行的任务
- en: In the previous table, the `GET` HTTP verb appears twice but with two different
    scopes. The first row shows a `GET` HTTP verb applied to a collection of games
    (collection of resources) and the second row shows a `GET` HTTP verb applied to
    a game (a single resource).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的表格中，`GET` HTTP 动词出现了两次，但具有两个不同的范围。第一行显示将 `GET` HTTP 动词应用于游戏集合（资源集合），而第二行显示将
    `GET` HTTP 动词应用于单个游戏（资源）。
- en: Let's assume that `http://localhost:8000/games/` is the URL for the collection
    of games. If we add a number and a slash (`/`) to the previous URL, we identify
    a specific game whose ID is equal to the specified numeric value. For example,
    `http://localhost:8000/games/25/` identifies the game whose ID is equal to `25`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 `http://localhost:8000/games/` 是游戏集合的 URL。如果我们向之前的 URL 添加一个数字和一个斜杠 (`/`)，我们就可以识别一个具有等于指定数值的
    ID 的特定游戏。例如，`http://localhost:8000/games/25/` 识别 ID 等于 `25` 的游戏。
- en: We have to compose and send an HTTP request with the following HTTP verb (`POST`)
    and request URL (`http://localhost:8000/games/ ...`
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须使用以下 HTTP 动词 (`POST`) 和请求 URL (`http://localhost:8000/games/ ...`) 编写并发送一个
    HTTP 请求
- en: Setting up the virtual environment with Django REST framework
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Django REST 框架设置虚拟环境
- en: In [Chapter 1](dbf75cef-4962-4e40-8192-03873b774c48.xhtml), *Developing RESTful
    APIs and Microservices with Flask 1.0.2*, we learned that, throughout this book,
    we are going to work with the lightweight virtual environments introduced and
    improved in Python 3.4\. Now we will follow many steps to create a new lightweight
    virtual environment to work with Flask and Flask-RESTful.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 1 章](dbf75cef-4962-4e40-8192-03873b774c48.xhtml)，*使用 Flask 1.0.2 开发 RESTful
    API 和微服务* 中，我们了解到，在本书中，我们将使用 Python 3.4 中引入和改进的轻量级虚拟环境。现在我们将遵循许多步骤来创建一个新的轻量级虚拟环境，以便使用
    Flask 和 Flask-RESTful。
- en: It is highly recommended that you read the section named *Working with lightweight
    virtual environments* in [Chapter 1](dbf75cef-4962-4e40-8192-03873b774c48.xhtml),
    *Developing RESTful APIs and Microservices with Flask 1.0.2*, if you don't have
    experience with lightweight virtual environments in modern Python. The chapter
    includes all the detailed explanations about the effects of the steps we are going
    to follow.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在现代 Python 中没有轻量级虚拟环境的使用经验，强烈建议您阅读第 1 章 *使用轻量级虚拟环境工作*，*使用 Flask 1.0.2 开发
    RESTful API 和微服务* 中命名的部分。该章节包含了关于我们将要遵循的步骤的所有详细解释。
- en: The following commands assume that you have Python 3.7.1 or greater installed
    on Linux, macOS, or Windows.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令假设您已在 Linux、macOS 或 Windows 上安装了 Python 3.7.1 或更高版本。
- en: 'First, we have to select the target folder or directory for our lightweight
    virtual environment. The following is the path we will use in the example for
    Linux and macOS:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须选择我们的轻量级虚拟环境的目标文件夹或目录。以下是我们将在 Linux 和 macOS 中的示例中使用的路径：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The target folder for the virtual environment will be the `HillarPythonREST2/Django01`
    folder within our home directory. For example, if our home directory in macOS
    or Linux is `/Users/gaston`, the virtual environment will be created within `/Users/gaston/HillarPythonREST2/Django01`.
    You can replace the specified path with your desired path in each command.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟环境的目标文件夹将位于我们主目录内的 `HillarPythonREST2/Django01` 文件夹中。例如，如果我们的 macOS 或 Linux
    中的主目录是 `/Users/gaston`，则虚拟环境将在 `/Users/gaston/HillarPythonREST2/Django01` 中创建。您可以在每个命令中将指定的路径替换为您想要的路径。
- en: 'The following is the path we will use in the example for Windows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们将在 Windows 中的示例中使用的路径：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The target folder for the virtual environment will be the `HillarPythonREST2\Django01`
    folder within our user profile folder. For example, if our user profile folder
    is `C:\Users\gaston`, the virtual environment will be created within `C:\Users\gaston\HillarPythonREST2\Django01`.
    Of course, you can replace the specified path with your desired path in each command.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟环境的目标文件夹将位于我们用户配置文件文件夹内的 `HillarPythonREST2\Django01` 文件夹中。例如，如果我们的用户配置文件文件夹是
    `C:\Users\gaston`，则虚拟环境将在 `C:\Users\gaston\HillarPythonREST2\Django01` 中创建。当然，您可以在每个命令中将指定的路径替换为您想要的路径。
- en: 'In Windows PowerShell, the previous path would be as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows PowerShell 中，之前的路径如下：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now we have to use the `-m` option followed by the `venv` module name and the
    desired path to make Python run this module as a script and create a virtual environment
    in the specified path. The instructions are different depending on the platform
    in which we are creating the virtual environment. Thus, make sure you follow the
    instructions for your operating system.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们必须使用 `-m` 选项后跟 `venv` 模块名称和所需的路径，以便 Python 将此模块作为脚本运行并创建指定路径中的虚拟环境。根据我们创建虚拟环境的平台，指令可能会有所不同。因此，请确保您遵循您操作系统的说明。
- en: 'Open a Terminal in Linux or macOS and execute the following command to create
    a virtual environment:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 或 macOS 中打开一个终端并执行以下命令以创建虚拟环境：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In Windows, in the Command Prompt, execute the following command to create
    a virtual environment:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 中，在命令提示符中执行以下命令以创建虚拟环境：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you want to work with Windows PowerShell, execute the following command
    to create a virtual environment:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想使用 Windows PowerShell，请执行以下命令以创建虚拟环境：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The previous commands don't produce any output. Now that we have created a virtual
    environment, we will run a platform-specific script to activate it. After we activate
    the virtual environment, we will install packages that will only be available
    in this virtual environment.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令不会产生任何输出。现在我们已经创建了虚拟环境，我们将运行特定于平台的脚本以激活它。激活虚拟环境后，我们将安装仅在此虚拟环境中可用的包。
- en: 'If your Terminal is configured to use the `bash` shell in macOS or Linux, run
    the following command to activate the virtual environment. The command also works
    for the `zsh` shell:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的终端配置为在 macOS 或 Linux 中使用 `bash` shell，请运行以下命令以激活虚拟环境。该命令也适用于 `zsh` shell：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If your Terminal is configured to use either the `csh` or `tcsh` shell, run
    the following command to activate the virtual environment:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的终端配置为使用 `csh` 或 `tcsh` shell，请运行以下命令以激活虚拟环境：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If your Terminal is configured to use the `fish` shell, run the following command
    to activate the virtual environment:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的终端配置为使用 `fish` shell，请运行以下命令以激活虚拟环境：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In Windows, you can run either a batch file in the Command Prompt or a Windows
    PowerShell script to activate the virtual environment. If you prefer the Command
    Prompt, run the following command in the Windows command line to activate the
    virtual environment:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 中，您可以在命令提示符中运行批处理文件或 Windows PowerShell 脚本来激活虚拟环境。如果您更喜欢命令提示符，请在 Windows
    命令行中运行以下命令以激活虚拟环境：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If you prefer the Windows PowerShell, launch it and run the following commands
    to activate the virtual environment. However, notice that you should have script
    execution enabled in Windows PowerShell to be able to run the script:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您更喜欢 Windows PowerShell，启动它并运行以下命令以激活虚拟环境。但是请注意，您需要在 Windows PowerShell 中启用脚本执行才能运行脚本：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: After you activate the virtual environment, the Command Prompt will display
    the virtual environment root folder name enclosed in parenthesis as a prefix of
    the default prompt to remind us that we are working in the virtual environment.
    In this case, we will see (`Django01`) as a prefix for the Command Prompt because
    the root folder for the activated virtual environment is `Django01`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 激活虚拟环境后，命令提示符将显示括号内的虚拟环境根文件夹名称作为默认提示的前缀，以提醒我们我们正在虚拟环境中工作。在这种情况下，我们将看到（`Django01`）作为命令提示符的前缀，因为已激活的虚拟环境的根文件夹是
    `Django01`。
- en: We have followed the necessary steps to create and activate a virtual environment.
    Now we will create a `requirements.txt` file to specify the set of packages that
    our application requires to be installed in any supported platform. This way,
    it will be extremely easy to repeat the installation of the specified packages
    with their versions in any new virtual environment.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经遵循了创建和激活虚拟环境的必要步骤。现在我们将创建一个 `requirements.txt` 文件来指定我们的应用程序需要安装在任何支持平台上的包集。这样，在新的虚拟环境中重复安装指定包及其版本将变得极其容易。
- en: 'Use your favorite editor to create a new text file named `requirements.txt`
    within the root folder for the recently created virtual environment. The following
    lines show the contents for the file that declares the packages and the versions
    that our API requires. The code file for the sample is included in the `restful_python_2_05_01`
    folder, in the `Django01/requirements.txt` file:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 使用您喜欢的编辑器在最近创建的虚拟环境的根文件夹中创建一个名为`requirements.txt`的新文本文件。以下几行显示了该文件的内容，该文件声明了我们的API所需的包及其版本。示例的代码文件包含在`restful_python_2_05_01`文件夹中的`Django01/requirements.txt`文件中：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Each line in the `requirements.txt` file indicates the package and the version
    that needs to be installed. In this case, we are working with exact versions by
    using the `==` operator because we want to make sure that the specified version
    is installed. The following table summarizes the packages and the version numbers
    that we specified as requirements:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`requirements.txt`文件中的每一行都指示需要安装的包及其版本。在本例中，我们通过使用`==`运算符使用精确版本，因为我们想确保安装的是指定版本。以下表格总结了我们所指定的作为要求的包及其版本号：'
- en: '| Package name | Version to be installed |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| 包名 | 要安装的版本 |'
- en: '| `Django` | 2.1.4 |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `Django` | 2.1.4 |'
- en: '| `djangorestframework` | 3.9.0 |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `djangorestframework` | 3.9.0 |'
- en: '| `httpie` | 1.0.2 |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `httpie` | 1.0.2 |'
- en: 'Go to the root folder for the virtual environment: `Django01`. In macOS or
    Linux, enter the following command:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 转到虚拟环境的根文件夹：`Django01`。在macOS或Linux中，输入以下命令：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In Windows Command Prompt, enter the following command:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows命令提示符中，输入以下命令：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In Windows PowerShell, enter the following command:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows PowerShell中，输入以下命令：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now we must run the following command on macOS, Linux, or Windows to install
    the packages and the versions explained in the previous table with `pip` by using
    the recently created `requirements` file. Notice that `Django` is a dependency
    for `djangorestframework`. Make sure you are in the folder that has the `requirements.txt`
    file before running the command (`Django01`):'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在macOS、Linux或Windows上运行以下命令，使用最近创建的`requirements`文件通过`pip`安装之前表格中解释的包和版本。注意，`Django`是`djangorestframework`的依赖项。在运行命令之前，请确保您位于包含`requirements.txt`文件的文件夹中（`Django01`）：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The final lines for the output will indicate all the packages that have been
    successfully installed, including `Django`, `djangorestframework`, and `httpie`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的最后几行将指示所有已成功安装的包，包括`Django`、`djangorestframework`和`httpie`：
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now run the following command to create a new Django project named `games_service`.
    The command won''t produce any output:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行以下命令以创建一个名为`games_service`的新Django项目。该命令不会产生任何输出：
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The previous command created a `games_service` folder with other subfolders
    and Python files. Now go to the recently created `games_service` folder. Just
    execute the following command:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令创建了一个包含其他子文件夹和Python文件的`games_service`文件夹。现在转到最近创建的`games_service`文件夹。只需执行以下命令：
- en: '[PRE18]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, run the following command to create a new Django app named `games` within
    the `games_service` Django project. The command won''t produce any output:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，运行以下命令以在`games_service` Django项目中创建一个名为`games`的新Django应用。该命令不会产生任何输出：
- en: '[PRE19]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The previous command created a new `games_service/games` subfolder, with the
    following files:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令创建了一个新的`games_service/games`子文件夹，其中包含以下文件：
- en: '`__init__.py`'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__init__.py`'
- en: '`admin.py`'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`admin.py`'
- en: '`apps.py`'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apps.py`'
- en: '`models.py`'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`models.py`'
- en: '`tests.py`'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tests.py`'
- en: '`views.py`'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`views.py`'
- en: 'In addition, the `games_service/games` folder will have a `migrations` subfolder
    with a `__init__.py` Python script. The following screenshot shows the folders
    and files in the directory trees starting at the `games_service` folder:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`games_service/games`文件夹将有一个包含`__init__.py` Python脚本的`migrations`子文件夹。以下截图显示了以`games_service`文件夹为起点的目录树中的文件夹和文件：
- en: '![](img/a9394409-5001-444d-bc88-bc861894f1b4.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a9394409-5001-444d-bc88-bc861894f1b4.png)'
- en: 'Let''s check the Python code in the `apps.py` file within the `games_service/games`
    folder. The following lines show the code for this file:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查位于`games_service/games`文件夹内的`apps.py`文件中的Python代码。以下几行展示了该文件的代码：
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The code declares the `GamesConfig` class as a subclass of the `django.apps.AppConfig`
    superclass, which represents a Django application and its configuration. The `GamesConfig`
    class just defines the `name` class attribute and sets its value to `'games'`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 代码声明`GamesConfig`类为`django.apps.AppConfig`超类的子类，该超类代表Django应用及其配置。`GamesConfig`类仅定义了`name`类属性并将其值设置为`'games'`。
- en: 'We have to add `games.apps.GamesConfig` as one of the installed apps in the
    `games_service/game_service/settings.py` file, which configures settings for the
    `games_service` Django project. We built the previous string as follows: `app
    name` + `.apps.` + `class name`, which is `games` + `.apps.` + `GamesConfig`.
    In addition, we have to add the `rest_framework` app to make it possible for us
    to use Django REST Framework.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须在`games_service/game_service/settings.py`文件中将`games.apps.GamesConfig`添加为已安装应用之一，这将为`games_service`
    Django项目配置设置。我们构建前面的字符串如下：`应用名` + `.apps.` + `类名`，即`games` + `.apps.` + `GamesConfig`。此外，我们还需要添加`rest_framework`应用，以便我们能够使用Django
    REST Framework。
- en: 'The `games_service/games_service/settings.py` file is a Python module with
    module-level variables that define the configuration of Django for the `games_service`
    project. We will make some changes to this Django settings file. Open the `games_service/games_service/settings.py`
    file and locate the following lines, which specify the strings list that declares
    the installed apps and save it in the `INSTALLED_APPS` variable:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`games_service/games_service/settings.py`文件是一个Python模块，其中包含模块级变量，这些变量定义了`games_service`项目的Django配置。我们将对此Django设置文件进行一些修改。打开`games_service/games_service/settings.py`文件，找到以下行，这些行指定了声明已安装应用的字符串列表并将其保存在`INSTALLED_APPS`变量中：'
- en: '[PRE21]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Add the following two strings to the `INSTALLED_APPS` strings list and save
    the changes to the `games_service/games_service/settings.py` file:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下两个字符串添加到`INSTALLED_APPS`字符串列表中，并将更改保存到`games_service/games_service/settings.py`文件中：
- en: '`''rest_framework''`'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''rest_framework''`'
- en: '`''games.apps.GamesConfig''`'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''games.apps.GamesConfig''`'
- en: 'The following lines show the new code that declares the `INSTALLED_APPS` strings
    list with the added lines highlighted. The code file for the sample is included
    in the `restful_python_2_05_01` folder, in the `Django01/games_service/games-service/settings.py`
    file:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了声明`INSTALLED_APPS`字符串列表的新代码，其中添加的行被突出显示。示例代码文件包含在`restful_python_2_05_01`文件夹中，位于`Django01/games_service/games-service/settings.py`文件中：
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This way, we have added Django REST Framework and the `games` application to
    our initial Django project named `games_service`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就将Django REST Framework和`games`应用添加到了我们的初始Django项目`games_service`中。
- en: Creating the models
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建模型
- en: 'Now we will create a simple `Game` model that we will use to represent and
    persist games. Open the `games_service/games/models.py` file. The following lines
    show the initial code for this file, with just one import statement and a comment
    that indicates we should create the models:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个简单的`Game`模型，我们将使用它来表示和持久化游戏。打开`games_service/games/models.py`文件。以下行显示了该文件的初始代码，其中只有一个导入语句和一个注释，表明我们应该创建模型：
- en: '[PRE23]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Replace the code for the `games_service/games/models.py` file with the following
    lines. The new code creates a `Game` class, specifically, a `Game` model in the
    `games/models.py` file. The code file for the sample is included in the `restful_python_2_05_01`
    folder, in the `Django01/games_service/games/apps.py` file:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 将`games_service/games/models.py`文件的代码替换为以下行。新代码创建了一个`Game`类，具体来说，是在`games/models.py`文件中创建了一个`Game`模型。示例代码文件包含在`restful_python_2_05_01`文件夹中，位于`Django01/games_service/games/apps.py`文件中：
- en: '[PRE24]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Managing serialization and deserialization
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理序列化和反序列化
- en: Our RESTful web API has to be able to serialize the game instances into JSON
    representations and also deserialize the JSON representations to build game instances.
    With Django REST Framework, we just need to create a serializer class for the
    game instances to manage serialization to JSON and deserialization from JSON.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的RESTful Web API必须能够将游戏实例序列化为JSON表示，并且也能将JSON表示反序列化以构建游戏实例。使用Django REST Framework，我们只需为游戏实例创建一个序列化器类来管理序列化为JSON和从JSON反序列化。
- en: Django REST Framework uses a two-phase process for serialization. The serializers
    are mediators between the model instances and Python primitives. Parsers and renderers
    act as mediators between Python primitives and HTTP requests and responses.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Django REST Framework使用两阶段过程进行序列化。序列化器是模型实例和Python原语之间的中介。解析器和渲染器充当Python原语和HTTP请求和响应之间的中介。
- en: We will configure our mediator between the `Game` model instances and Python
    primitives by creating a subclass of the `rest_framework.serializers.Serializer`
    class to declare the fields and the necessary methods to manage serialization
    and deserialization. We will repeat some of the information about the fields that
    we have included in the `Game` model so that we understand all the things that
    we can configure in a subclass of the `Serializer` class. However, we will work
    with shortcuts that will reduce boilerplate code later in the next examples. We
    will write less code in the next examples by using the `ModelSerializer` class.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过创建 `rest_framework.serializers.Serializer` 类的子类来配置 `Game` 模型实例和 Python
    原始数据之间的中介，以声明字段和必要的序列化和反序列化管理方法。我们将重复一些关于字段的信息，这些信息我们已经包含在 `Game` 模型中，以便我们理解在
    `Serializer` 类的子类中可以配置的所有内容。然而，我们将使用快捷方式，这将在下一个示例中减少样板代码。我们将通过使用 `ModelSerializer`
    类来在下一个示例中编写更少的代码。
- en: 'Now go to the `games_service/games` folder and create a new Python code file
    named `serializers.py`. The following lines show the code that declares the new
    `GameSerializer` class. The code file for the sample is included in the `restful_python_2_05_01`
    folder, in the `Django01/games_service/games/serializers.py` file:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，转到 `games_service/games` 文件夹，并创建一个名为 `serializers.py` 的新 Python 代码文件。以下行显示了声明新
    `GameSerializer` 类的代码。示例代码文件包含在 `restful_python_2_05_01` 文件夹中，位于 `Django01/games_service/games/serializers.py`
    文件中：
- en: '[PRE25]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `GameSerializer` class declares the attributes that represent the fields
    that we want to be serialized. Notice that we have omitted the `created_timestamp`
    attribute that was present in the `Game` model. When there is a call to the inherited
    `save` method for this class, the overridden `create` and `update` methods define
    how to create or modify an instance. In fact, these methods must be implemented
    in our class because they just raise a `NotImplementedError` exception in their
    base declaration in the `Serializer` superclass.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`GameSerializer` 类声明了代表我们想要序列化的字段的属性。请注意，我们省略了在 `Game` 模型中存在的 `created_timestamp`
    属性。当对这个类调用继承的 `save` 方法时，重写的 `create` 和 `update` 方法定义了如何创建或修改实例。实际上，这些方法必须在我们的类中实现，因为它们在其基类
    `Serializer` 中的声明中只是抛出一个 `NotImplementedError` 异常。'
- en: The `create` method receives the validated data in the `validated_data` argument.
    The code creates and returns a new `Game` instance based on the received validated
    data.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`create` 方法接收 `validated_data` 参数中的验证数据。代码根据接收到的验证数据创建并返回一个新的 `Game` 实例。'
- en: The `update` method receives an existing `Game` instance that is being updated
    and the new validated data in the `instance` and `validated_data` arguments. The
    code updates the values for the attributes of the instance with the updated attribute
    values retrieved from the validated data, calls the save method for the updated
    `Game` instance, and returns the updated and saved instance.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`update` 方法接收一个正在更新的现有 `Game` 实例以及 `instance` 和 `validated_data` 参数中的新验证数据。代码使用从验证数据中检索到的更新属性值来更新实例的属性值，为更新的
    `Game` 实例调用保存方法，并返回更新并保存的实例。'
- en: We can launch our default Python interactive shell and make all the Django project
    modules available before it starts. This way, we can check that the serializer
    works as expected. In addition, it will help us understand how serialization works
    in Django.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在启动默认 Python 交互式外壳之前使其包含所有 Django 项目模块。这样，我们可以检查序列化器是否按预期工作。此外，它将帮助我们理解
    Django 中的序列化是如何工作的。
- en: 'Run the following command to launch the interactive shell. Make sure you are
    within the `games_service` folder in the Terminal or Command Prompt:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以启动交互式外壳。确保你在终端或命令提示符中的 `games_service` 文件夹内：
- en: '[PRE26]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You will notice that a line that says (`InteractiveConsole`) is displayed after
    the usual lines that introduce your default Python interactive shell. Enter the
    following code in the Python interactive shell to import all the things we will
    need to test the `Game` model and its serializer. The code file for the sample
    is included in the `restful_python_2_05_01` folder, in the `Django01/cmd/serializers_test_01.py`
    file:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，在介绍默认 Python 交互式外壳的常规行之后，会显示一行说 (`InteractiveConsole`) 的内容。在 Python 交互式外壳中输入以下代码以导入测试
    `Game` 模型和其序列化器所需的所有内容。示例代码文件包含在 `restful_python_2_05_01` 文件夹中，位于 `Django01/cmd/serializers_test_01.py`
    文件中：
- en: '[PRE27]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now enter the following code to create two instances of the `Game` model and
    save them. The code file for the sample is included in the `restful_python_2_05_01`
    folder, in the `Django01/cmd/serializers_test_01.py` file:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在输入以下代码以创建两个`Game`模型的实例并将它们保存。示例的代码文件包含在`restful_python_2_05_01`文件夹中，位于`Django01/cmd/serializers_test_01.py`文件中：
- en: '[PRE28]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'After we execute the previous code, we can check the SQLite database with the
    previously introduced command-line command or GUI tool to check the contents of
    the `games_game` table. We will notice the table has two rows and the columns
    have the values we have provided to the different attributes of the `Game` instances.
    However, make sure you run the commands in another Terminal or Command Prompt
    to avoid leaving the interactive shell that we will continue to use. The following
    screenshot shows the contents of the `games_game` table:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 执行前面的代码后，我们可以使用之前介绍的命令行命令或GUI工具检查SQLite数据库中的`games_game`表的内容。我们会注意到表中有两行，列的值是我们提供给不同`Game`实例的不同属性的值。然而，请确保你在另一个终端或命令提示符中运行命令，以避免留下我们将继续使用的交互式shell。以下截图显示了`games_game`表的内容：
- en: '![](img/da48bd1e-6a9c-4946-b66f-0988c38183f8.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/da48bd1e-6a9c-4946-b66f-0988c38183f8.png)'
- en: 'Enter the following commands in the interactive shell to check the values for
    the identifiers for the saved `Game` instances and the value of the `created_timestamp`
    attribute that includes the date and time in which we saved the instance to the
    database. The code file for the sample is included in the `restful_python_2_05_01`
    folder, in the `Django01/cmd/serializers_test_01.py` file:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在交互式shell中输入以下命令以检查保存的`Game`实例的标识符值以及包含我们保存实例到数据库的日期和时间的`created_timestamp`属性值。示例的代码文件包含在`restful_python_2_05_01`文件夹中，位于`Django01/cmd/serializers_test_01.py`文件中：
- en: '[PRE29]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now let''s write the following code to serialize the first game instance (`game1`).
    The code file for the sample is included in the `restful_python_2_05_01` folder,
    in the `Django01/cmd/serializers_test_01.py` file:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编写以下代码以序列化第一个游戏实例（`game1`）。示例的代码文件包含在`restful_python_2_05_01`文件夹中，位于`Django01/cmd/serializers_test_01.py`文件中：
- en: '[PRE30]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The following line shows the generated dictionary, specifically, a `rest_framework.utils.serializer_helpers.ReturnDict`
    instance:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了生成的字典，具体来说，是一个`rest_framework.utils.serializer_helpers.ReturnDict`实例：
- en: '[PRE31]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now let''s serialize the second game instance (`game2`). The code file for
    the sample is included in the `restful_python_2_05_01` folder, in the `Django01/cmd/serializers_test_01.py`
    file:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们序列化第二个游戏实例（`game2`）。示例的代码文件包含在`restful_python_2_05_01`文件夹中，位于`Django01/cmd/serializers_test_01.py`文件中：
- en: '[PRE32]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The following line shows the generated dictionary:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了生成的字典：
- en: '[PRE33]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We can easily render the dictionaries held in the `data` attribute into JSON
    with the help of the `rest_framework.renderers.JSONRenderer` class. The following
    lines create an instance of this class and then call the `render` method to render
    the dictionaries held in the `data` attribute into their JSON representation.
    The code file for the sample is included in the `restful_python_2_05_01` folder,
    in the `Django01/cmd/serializers_test_01.py` file:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`rest_framework.renderers.JSONRenderer`类轻松地将`data`属性中持有的字典渲染成JSON。以下行创建了这个类的实例，然后调用`render`方法将`data`属性中持有的字典渲染成它们的JSON表示。示例的代码文件包含在`restful_python_2_05_01`文件夹中，位于`Django01/cmd/serializers_test_01.py`文件中：
- en: '[PRE34]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The following lines show the output generated from the two calls to the `render`
    method:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了从`render`方法调用生成的输出：
- en: '[PRE35]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now we will work in the opposite direction, from serialized data to the population
    of a `Game` instance. The following lines generate a new `Game` instance from
    a JSON string (serialized data); that is, we will write code that deserializes.
    The code file for the sample is included in the `restful_python_2_05_01` folder,
    in the `Django01/cmd/serializers_test_01.py` file:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将反向操作，从序列化数据到`Game`实例的种群。以下行从JSON字符串（序列化数据）生成一个新的`Game`实例；也就是说，我们将编写反序列化代码。示例的代码文件包含在`restful_python_2_05_01`文件夹中，位于`Django01/cmd/serializers_test_01.py`文件中：
- en: '[PRE36]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The first line creates a new string with the JSON that defines a new game (`json_string_for_new_game`).
    Then, the code converts the string to `bytes` and saves the results of the conversion
    in the `json_bytes_for_new_game` variable. The `django.utils.six.BytesIO` class
    provides a buffered I/O implementation using an in-memory bytes buffer. The code
    uses this class to create a stream from the previously generated JSON bytes with
    the serialized data, `json_bytes_for_new_game`, and saves the generated instance
    in the `stream_for_new_game` variable.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行创建了一个新的字符串，其中包含定义新游戏的JSON（`json_string_for_new_game`）。然后，代码将字符串转换为`bytes`，并将转换结果保存在`json_bytes_for_new_game`变量中。`django.utils.six.BytesIO`类提供了一个使用内存字节数组的缓冲I/O实现。代码使用这个类从之前生成的序列化数据字节数组`json_bytes_for_new_game`创建一个流，并将生成的实例保存在`stream_for_new_game`变量中。
- en: We can easily deserialize and parse a stream into the Python models with the
    help of the `rest_framework.parsers.JSONParser` class. The next line creates an
    instance of this class and then calls the `parse` method with `stream_for_new_game`
    as an argument, parses the stream into Python native datatypes, and saves the
    results in the `parsed_new_game` variable.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`rest_framework.parsers.JSONParser`类轻松地将流反序列化并解析成Python模型。下一行创建了这个类的实例，然后使用`stream_for_new_game`作为参数调用`parse`方法，将流解析成Python原生数据类型，并将结果保存在`parsed_new_game`变量中。
- en: 'After executing the previous lines, `parsed_new_game` holds a Python dictionary,
    parsed from the stream. The following lines show the output generated after executing
    the previous code snippet:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 执行前面的行后，`parsed_new_game`包含从流中解析出的Python字典。以下行显示了执行前面的代码片段后生成的输出：
- en: '[PRE37]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The following lines use the `GameSerializer` class to generate a fully populated
    `Game` instance named `new_game` from the Python dictionary, parsed from the stream.
    The code file for the sample is included in the `restful_python_2_05_01` folder,
    in the `Django01/cmd/serializers_test_01.py` file:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行使用`GameSerializer`类从流中解析出的Python字典生成一个名为`new_game`的完全填充的`Game`实例。示例代码文件包含在`restful_python_2_05_01`文件夹中，位于`Django01/cmd/serializers_test_01.py`文件中：
- en: '[PRE38]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: First, the code creates an instance of the `GameSerializer` class with the Python
    dictionary that we previously parsed from the stream (`parsed_new_game`) passed
    as the `data` keyword argument. Then, the code calls the `is_valid` method to
    determine whether the data is valid or not.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，代码使用我们从流中解析出的Python字典（`parsed_new_game`）作为`data`关键字参数创建`GameSerializer`类的实例。然后，代码调用`is_valid`方法来确定数据是否有效。
- en: Notice that we must always call `is_valid` before we attempt to access the serialized
    data representation when we pass a `data` keyword argument in the creation of
    a serializer.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们尝试在创建序列化器时传递`data`关键字参数以访问序列化数据表示时，我们必须始终调用`is_valid`。
- en: If the method returns `true`, we can access the serialized representation in
    the `data` attribute, and therefore, the code calls the `save` method that inserts
    the corresponding row in the database and returns a fully populated `Game` instance,
    saved in the `new_game` local variable. Then, the code prints one of the attributes
    from the fully populated `Game` instance named `new_game`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果方法返回`true`，我们可以访问`data`属性中的序列化表示，因此代码调用`save`方法将相应的行插入数据库，并返回一个完全填充的`Game`实例，保存在`new_game`局部变量中。然后，代码打印出完全填充的`Game`实例中的一个属性，名为`new_game`。
- en: As we can see from the previous code, Django REST Framework makes it easy to
    serialize from objects to JSON and deserialize from JSON to objects, which are
    core requirements for our RESTful web API, which has to perform CRUD operations.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，Django REST Framework使得从对象到JSON的序列化和从JSON到对象的反序列化变得简单，这是我们RESTful Web
    API的核心要求，必须执行CRUD操作。
- en: 'Enter the following command to leave the shell with the Django project modules
    that we started to test serialization and deserialization:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 输入以下命令以退出包含我们开始测试序列化和反序列化的Django项目模块的shell：
- en: '[PRE39]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Understanding status codes for the responses
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解响应状态码
- en: Django REST Framework declares a set of named constants for the different HTTP
    status codes in the `status` module. We will always use these named constants
    to return HTTP status codes.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Django REST Framework在`status`模块中声明了一组用于不同HTTP状态码的命名常量。我们将始终使用这些命名常量来返回HTTP状态码。
- en: It is bad practice to return numbers as status codes. We want our code to be
    easy to read and understand, and therefore, we will use descriptive HTTP status
    codes.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 返回数字作为状态代码是不良的做法。我们希望我们的代码易于阅读和理解，因此，我们将使用描述性的HTTP状态代码。
- en: For example, in case we have to return a `404 Not Found` status code, we will
    return `status.HTTP_404_NOT_FOUND`, instead of just `404`. If we have to return
    a `201 Created` status code, we will return `status.HTTP_201_CREATED`, instead
    of just `201`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们必须返回`404 Not Found`状态代码，我们将返回`status.HTTP_404_NOT_FOUND`，而不是仅仅`404`。如果我们必须返回`201
    Created`状态代码，我们将返回`status.HTTP_201_CREATED`，而不是仅仅`201`。
- en: Writing API views
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写API视图
- en: 'Now we will create Django views that will use the previously created `GameSerializer`
    class to return JSON representations for each HTTP request that our API will handle.
    Open the `views.py` file located within the `games_service/games` folder. The
    following lines show the initial code for this file, with just one import statement
    and a comment that indicates we should create the views:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将创建Django视图，这些视图将使用之前创建的`GameSerializer`类来为API处理的每个HTTP请求返回JSON表示。打开位于`games_service/games`文件夹中的`views.py`文件。以下行显示了该文件的初始代码，只有一个导入语句和一个注释，表明我们应该创建视图：
- en: '[PRE40]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Replace the existing code with the following lines. The new code creates a
    `JSONResponse` class and declares two functions: `game_collection` and `game_detail`.
    We are creating our first version of the API, and we use functions to keep the
    code as simple as possible. We will work with classes and more complex code in
    the next examples. The highlighted lines show the expressions that evaluate the
    value of the `request.method` attribute to determine the actions to be performed
    based on the HTTP verb. The code file for the sample is included in the `restful_python_2_05_01`
    folder, in the `Django01/games-service/games/views.py` file:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 将现有代码替换为以下行。新代码创建了一个`JSONResponse`类，并声明了两个函数：`game_collection`和`game_detail`。我们正在创建API的第一个版本，我们使用函数来使代码尽可能简单。在下一个示例中，我们将使用类和更复杂的代码。突出显示的行显示了评估`request.method`属性值的表达式，以确定基于HTTP动词要执行的操作。示例代码文件包含在`restful_python_2_05_01`文件夹中，位于`Django01/games-service/games/views.py`文件中：
- en: '[PRE41]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `JSONResponse` class is a subclass of the `django.http.HttpResponse` class.
    The superclass represents an HTTP response with a string as content. The `JSONResponse`
    class renders its content into JSON. The class defines just declare the `__init__`
    method that created a `rest_framework.renderers.JSONRenderer` instance and calls
    its `render` method to render the received data into JSON and save the returned
    `bytestring` in the `content` local variable. Then, the code adds the `'content_type'`
    key to the response header with `'application/json'` as its value. Finally, the
    code calls the initializer for the base class with the JSON `bytestring` and the
    key-value pair added to the header. This way, the class represents a JSON response
    that we use in the two functions to easily return a JSON response.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`JSONResponse`类是`django.http.HttpResponse`类的子类。超类表示一个以字符串为内容的HTTP响应。`JSONResponse`类将其内容渲染为JSON。该类仅声明了`__init__`方法，该方法创建了一个`rest_framework.renderers.JSONRenderer`实例，并调用其`render`方法将接收到的数据渲染为JSON，并将返回的`bytestring`保存到`content`局部变量中。然后，代码将`''content_type''`键添加到响应头中，其值为`''application/json''`。最后，代码调用基类的初始化器，传递JSON
    `bytestring`和添加到头部的键值对。这样，该类代表了一个我们用于两个函数的JSON响应，以便轻松返回JSON响应。'
- en: The code uses the `@csrf_exempt` decorator in the two functions to ensure that
    the view sets a **CSRF** (short for **Cross-Site Request Forgery**) cookie. We
    do this to make it simple to test this example that doesn't represent a production-ready
    web service. We will add security features to our RESTful API later.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 代码在两个函数中使用`@csrf_exempt`装饰器来确保视图设置一个**CSRF**（即**跨站请求伪造**）cookie。我们这样做是为了使测试这个示例变得简单，这个示例不代表一个生产就绪的Web服务。我们将在稍后的RESTful
    API中添加安全功能。
- en: When the Django server receives an HTTP request, Django creates an `HttpRequest`
    instance, specifically a `django.http.HttpRequest` object. This instance contains
    metadata about the request, including the HTTP verb. The `method` attribute provides
    a string representing the HTTP verb or method used in the request.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当Django服务器接收到HTTP请求时，Django创建一个`HttpRequest`实例，具体是一个`django.http.HttpRequest`对象。此实例包含有关请求的元数据，包括HTTP动词。`method`属性提供了一个表示请求中使用的HTTP动词或方法的字符串。
- en: When Django loads the appropriate view that will process the requests, it passes
    the `HttpRequest` instance as the first argument to the view function. The view
    function has to return an `HttpResponse` instance, specifically, a `django.http.HttpResponse`
    instance.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Django 加载将处理请求的适当视图时，它将 `HttpRequest` 实例作为第一个参数传递给视图函数。视图函数必须返回一个 `HttpResponse`
    实例，具体来说，是一个 `django.http.HttpResponse` 实例。
- en: 'The `game_collection` function lists all the games or creates a new game. The
    function receives an `HttpRequest` instance in the `request` argument. The function
    is capable of processing two HTTP verbs: `GET` and `POST`. The code checks the
    value of the `request.method` attribute to determine the code to be executed based
    on the HTTP verb. If the HTTP verb is `GET`, the `request.method == ''GET''` expression
    will evaluate to `True` and the code has to list all the games. The code will
    retrieve all the `Game` objects from the database, use the `GameSerializer` to
    serialize all of them and return a `JSONResponse` instance built with the data
    generated by `GameSerializer`. The code creates the `GameSerializer` instance
    with the `many=True` argument to specify that multiple instances have to be serialized
    and not just one. Under the hood, Django uses a `ListSerializer` when the `many`
    argument value is set to `True`.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`game_collection` 函数列出所有游戏或创建一个新的游戏。该函数接收一个 `HttpRequest` 实例作为 `request` 参数。该函数能够处理两种
    HTTP 动词：`GET` 和 `POST`。代码会检查 `request.method` 属性的值，以确定根据 HTTP 动词要执行的代码。如果 HTTP
    动词是 `GET`，则 `request.method == ''GET''` 表达式将评估为 `True`，代码必须列出所有游戏。代码将从数据库检索所有
    `Game` 对象，使用 `GameSerializer` 将它们全部序列化，并返回一个由 `GameSerializer` 生成数据的 `JSONResponse`
    实例。代码使用 `many=True` 参数创建 `GameSerializer` 实例，以指定必须序列化多个实例，而不仅仅是单个实例。在底层，当 `many`
    参数值设置为 `True` 时，Django 使用 `ListSerializer`。'
- en: If the HTTP verb is `POST`, the code has to create a new game based on the JSON
    data that is included in the HTTP request. First, the code uses a `JSONParser`
    instance and calls its parse method with `request` as an argument to parse the
    game data provided as `JSON` data in the request and saves the results in the
    `game_data` local variable. Then, the code creates a `GameSerializer` instance
    with the previously retrieved data and calls the `is_valid` method to determine
    whether the `Game` instance is valid or not. If the instance is valid, the code
    calls the `save` method to persist the instance in the database and returns a
    `JSONResponse` with the saved data in its body and a status equal to `status.HTTP_201_CREATED`,
    that is, `201 Created`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 HTTP 动词是 `POST`，则代码必须根据包含在 HTTP 请求中的 JSON 数据创建一个新的游戏。首先，代码使用一个 `JSONParser`
    实例，并使用 `request` 作为参数调用其 `parse` 方法，以解析请求中提供的作为 `JSON` 数据的游戏数据，并将结果保存在 `game_data`
    本地变量中。然后，代码使用之前检索到的数据创建一个 `GameSerializer` 实例，并调用 `is_valid` 方法以确定 `Game` 实例是否有效。如果实例有效，代码将调用
    `save` 方法将实例持久化到数据库中，并返回一个包含保存数据的 `JSONResponse`，其状态等于 `status.HTTP_201_CREATED`，即
    `201 Created`。
- en: 'The `game_detail` function retrieves, updates, or deletes an existing game.
    The function receives an `HttpRequest` instance in the `request` argument and
    the ID for the game to be retrieved, updated, or deleted in the `id` argument.
    The function is capable of processing three HTTP verbs: `GET`, `PUT`, and `DELETE`.
    The code checks the value of the `request.method` attribute to determine the code
    to be executed based on the HTTP verb. Irrespective of the HTTP verb, the function
    calls the `Game.objects.get` method with the received `id` as the `id` argument
    to retrieve a `Game` instance from the database based on the specified id, and
    saves it in the `game` local variable. If a game with the specified id doesn''t
    exist in the database, the code returns an `HttpResponse` with its status equal
    to `status.HTTP_404_NOT_FOUND`, that is, `404 Not Found`.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`game_detail` 函数检索、更新或删除现有的游戏。该函数接收一个 `HttpRequest` 实例作为 `request` 参数，以及要检索、更新或删除的游戏的
    ID 作为 `id` 参数。该函数能够处理三种 HTTP 动词：`GET`、`PUT` 和 `DELETE`。代码会检查 `request.method`
    属性的值，以确定根据 HTTP 动词要执行的代码。无论 HTTP 动词是什么，该函数都会调用 `Game.objects.get` 方法，将接收到的 `id`
    作为 `id` 参数，从数据库中根据指定的 ID 检索一个 `Game` 实例，并将其保存在 `game` 本地变量中。如果数据库中不存在具有指定 ID 的游戏，代码将返回一个状态等于
    `status.HTTP_404_NOT_FOUND` 的 `HttpResponse`，即 `404 Not Found`。'
- en: If the HTTP verb is `GET`, the code creates a `GameSerializer` instance with
    `game` as an argument and returns the data for the serialized game in a `JSONResponse`
    that will include the default `200 OK` status. The code returns the retrieved
    game serialized as JSON.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果HTTP动词是`GET`，代码使用`game`作为参数创建一个`GameSerializer`实例，并在一个包含默认`200 OK`状态的`JSONResponse`中返回序列化游戏的
    数据。代码返回检索到的游戏序列化为JSON。
- en: If the HTTP verb is `PUT`, the code has to create a new game based on the JSON
    data that is included in the HTTP request, and use it to replace an existing game.
    First, the code uses a `JSONParser` instance and calls its parse method with `request`
    as an argument to parse the game data provided as `JSON` data in the request and
    saves the results in the `game_data` local variable. Then, the code creates a
    `GameSerializer` instance with the `Game` instance previously retrieved from the
    database, `game`, and the retrieved data that will replace the existing data,
    `game_data`. Then, the code calls the `is_valid` method to determine whether the
    `Game` instance is valid or not. If the instance is valid, the code calls the
    `save` method to persist the instance with the replaced values in the database
    and returns a `JSONResponse` with the saved data in its body and the default `200
    OK` status. If the parsed data doesn't generate a valid `Game` instance, the code
    returns a `JSONResponse` with a status equal to `status.HTTP_400_BAD_REQUEST`,
    that is, `400 Bad Request`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果HTTP动词是`PUT`，代码必须根据HTTP请求中包含的JSON数据创建一个新的游戏，并使用它来替换现有的游戏。首先，代码使用一个`JSONParser`实例，并使用`request`作为参数调用其`parse`方法来解析请求中提供的作为`JSON`数据的游戏数据，并将结果保存在`game_data`局部变量中。然后，代码使用从数据库中检索到的`Game`实例`game`和将要替换现有数据的检索数据`game_data`创建一个`GameSerializer`实例。接着，代码调用`is_valid`方法来确定`Game`实例是否有效。如果实例有效，代码调用`save`方法将实例持久化到数据库中，并返回一个包含保存数据的`JSONResponse`和默认的`200
    OK`状态。如果解析的数据没有生成有效的`Game`实例，代码返回一个状态等于`status.HTTP_400_BAD_REQUEST`的`JSONResponse`，即`400
    Bad Request`。
- en: If the HTTP verb is `DELETE`, the code calls the `delete` method for the `Game`
    instance previously retrieved from the database (`game`). The call to the `delete`
    method erases the underlying row in the `games_game` table, and therefore, the
    game won't be available anymore. Then, the code returns a `JSONResponse` with
    a status equal to `status.HTTP_204_NO_CONTENT` that is, `204 No Content`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果HTTP动词是`DELETE`，代码调用从数据库中先前检索到的`Game`实例（`game`）的`delete`方法。对`delete`方法的调用擦除了`games_game`表中的底层行，因此，该游戏将不再可用。然后，代码返回一个状态等于`status.HTTP_204_NO_CONTENT`的`JSONResponse`，即`204
    No Content`。
- en: 'Now we have to create a new Python file named `urls.py` in the `games_service/games`
    folder, specifically, the `games_service/games/urls.py` file. The following lines
    show the code for this file that defines the URL patterns that specifies the regular
    expressions that have to be matched in the request to run a specific function
    defined in the `views.py` file. The code file for the sample is included in the
    `restful_python_2_05_01` folder, in the `Django01/games-service/games/urls.py`
    file:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们必须在`games_service/games`文件夹中创建一个名为`urls.py`的新Python文件，具体来说，是`games_service/games/urls.py`文件。以下行显示了该文件的代码，该代码定义了URL模式，该模式指定了请求中必须匹配的正则表达式，以运行在`views.py`文件中定义的特定函数。示例的代码文件包含在`restful_python_2_05_01`文件夹中，在`Django01/games-service/games/urls.py`文件中：
- en: '[PRE42]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `urlpatterns` list makes it possible to route URLs to views. The code calls
    the `django.conf.urls.url` function with the regular expression that has to be
    matched, and the view function defined in the views module as arguments to create
    a `RegexURLPattern` instance for each entry in the `urlpatterns` list.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`urlpatterns`列表使得将URL路由到视图成为可能。代码使用`django.conf.urls.url`函数调用必须匹配的正则表达式，以及定义在视图模块中的视图函数作为参数，为`urlpatterns`列表中的每个条目创建一个`RegexURLPattern`实例。'
- en: 'Now we have to replace the code in the `urls.py` that Django built automatically
    in the `games_service` folder, specifically, the `games_service/urls.py` file.
    Don''t confuse this file with the previously created `urls.py` file that is saved
    in another folder. The `games_service/urls.py` file defines the root URL configurations,
    and therefore, we must include the URL patterns declared in the previously coded
    `games_service/games/urls.py` file. The following lines show the new code for
    the `games_service/urls.py` file. The code file for the sample is included in
    the `restful_python_2_05_01` folder, in the `Django01/games-service/urls.py` file:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须替换 Django 在 `games_service` 文件夹中自动生成的 `urls.py` 中的代码，具体来说，是 `games_service/urls.py`
    文件。不要将此文件与之前创建并保存在另一个文件夹中的 `urls.py` 文件混淆。`games_service/urls.py` 文件定义了根 URL 配置，因此我们必须包含之前编码的
    `games_service/games/urls.py` 文件中声明的 URL 模式。以下行显示了 `games_service/urls.py` 文件的新代码。示例代码文件包含在
    `restful_python_2_05_01` 文件夹中，位于 `Django01/games-service/urls.py` 文件：
- en: '[PRE43]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Making HTTP requests to the Django API
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向 Django API 发送 HTTP 请求
- en: 'Now we can launch Django''s development server to compose and send HTTP requests
    to our unsecure web API (we will definitely add security later). Execute the following
    command:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以启动 Django 的开发服务器来编写和发送 HTTP 请求到我们的不安全 Web API（我们肯定会添加安全性）。执行以下命令：
- en: '[PRE44]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The following lines show the output after we execute the previous command. The
    development server is listening at port `8000`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了执行上一个命令后的输出。开发服务器正在监听端口 `8000`。
- en: '[PRE45]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: With the previous command, we will start Django development server and we will
    only be able to access it in our development computer. ...
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上一个命令，我们将启动 Django 开发服务器，并且我们只能在我们的开发计算机上访问它。 ...
- en: Working with command-line tools - curl and httpie
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用命令行工具 - curl 和 httpie
- en: We will start composing and sending HTTP requests with the `curl` and HTTPie
    command-line tools we introduced in [Chapter 1](dbf75cef-4962-4e40-8192-03873b774c48.xhtml),
    *Developing RESTful APIs and Microservice with Flask 1.0.2*, in the section named
    *Working with command-line tools - curl and httpie*. Make sure you read this section
    before executing the next examples.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始使用我们在 [第 1 章](dbf75cef-4962-4e40-8192-03873b774c48.xhtml) 中介绍的 `curl` 和
    HTTPie 命令行工具来编写和发送 HTTP 请求，该章名为 *使用 Flask 1.0.2 开发 RESTful API 和微服务*，在名为 *使用命令行工具
    - curl 和 httpie* 的部分。在执行下一个示例之前，请确保您已阅读此部分。
- en: 'Whenever we compose HTTP requests with the command line, we will use two versions
    of the same command: the first one with HTTPie and the second one with `curl`.
    This way, you will be able to use the most convenient for you.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们使用命令行编写 HTTP 请求时，我们将使用同一命令的两个版本：第一个使用 HTTPie，第二个使用 `curl`。这样，您就可以使用最方便的一种。
- en: 'Make sure you leave the Django development server running. Don''t close the
    Terminal or Command Prompt that is running this development server. Open a new
    Terminal in macOS or Linux, or a Command Prompt in Windows, and run the following
    command. We will compose and send an HTTP request to create a new notification.
    The code file for the sample is included in the `restful_python_2_05_01` folder,
    in the `Django01/cmd/cmd01.txt` file:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您让 Django 开发服务器继续运行。不要关闭运行此开发服务器的终端或命令提示符。在 macOS 或 Linux 中打开一个新的终端，或在 Windows
    中打开一个命令提示符，然后运行以下命令。我们将编写并发送一个 HTTP 请求来创建一个新的通知。示例代码文件包含在 `restful_python_2_05_01`
    文件夹中，位于 `Django01/cmd/cmd01.txt` 文件：
- en: '[PRE46]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The following is the equivalent `curl` command. The code file for the sample
    is included in the `restful_python_2_05_01` folder, in the `Django01/cmd/cmd02.txt`
    file:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的 `curl` 命令。示例代码文件包含在 `restful_python_2_05_01` 文件夹中，位于 `Django01/cmd/cmd02.txt`
    文件：
- en: '[PRE47]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: It is very important that you enter the ending slash (`/`) when specified because
    `/service/notifications` won't match any of the configured URL routes. Thus, we
    must enter `/service/notifications/`, including the ending slash (`/`).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在指定的情况下，您必须输入结束斜杠（`/`）非常重要，因为 `/service/notifications` 不会匹配任何配置的 URL 路由。因此，我们必须输入
    `/service/notifications/`，包括结束斜杠（`/`）。
- en: 'The previous command will compose and send the following HTTP request: `GET
    http://localhost:8000/games/`. The request is the simplest case in our RESTful
    API because it will match and run the `views.game_collection` function, that is,
    the `game_collection` function declared within the `game_service/games/views.py`
    file. The function only receives `request` as a parameter because the URL pattern
    doesn''t include any parameters. As the HTTP verb for the request is `GET`, the
    `request.method` property is equal to `''GET''`, and therefore, the function will
    execute the code that retrieves all the `Game` objects and generate a JSON response
    with all of these `Game` objects serialized.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将编写并发送以下 HTTP 请求：`GET http://localhost:8000/games/`。这个请求是我们 RESTful API
    中最简单的情况，因为它将匹配并运行 `views.game_collection` 函数，即 `game_service/games/views.py` 文件中声明的
    `game_collection` 函数。该函数只接收 `request` 作为参数，因为 URL 模式不包含任何参数。由于请求的 HTTP 动词是 `GET`，因此
    `request.method` 属性等于 `'GET'`，因此该函数将执行检索所有 `Game` 对象并生成包含所有这些序列化 `Game` 对象的 JSON
    响应的代码。
- en: 'The following lines show an example response for the HTTP request, with three
    `Game` objects in the JSON response:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了 HTTP 请求的一个示例响应，其中 JSON 响应包含三个 `Game` 对象：
- en: '[PRE48]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'After we run a request, we will see the following line in the window that is
    running the Django development server. The output indicates that the server received
    an HTTP request with the `GET` verb and `/games/` as the URI. The server processed
    the HTTP requests, the returned status code `200` and the response length was
    equal to `438` characters. The response length can be different because the value
    for `id` assigned to each game will have an incidence in the response length.
    The first number after `HTTP/1.1."` indicates the returned status code (`200`)
    and the second number the response length (`438`):'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们运行请求后，将在运行 Django 开发服务器的窗口中看到以下行。输出表明服务器接收了一个带有 `GET` 动词和 `/games/` 作为 URI
    的 HTTP 请求。服务器处理了 HTTP 请求，返回的状态码为 `200`，响应长度等于 `438` 个字符。响应长度可能不同，因为分配给每个游戏的 `id`
    值将对响应长度产生影响。`HTTP/1.1."` 后的第一个数字表示返回的状态码（`200`），第二个数字表示响应长度（`438`）：
- en: '[PRE49]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The following screenshot shows two Terminal windows side by side on macOS.
    The Terminal window at the left-hand side is running the Django development server
    and displays the received and processed HTTP requests. The Terminal window at
    the right-hand side is running `http` commands to generate the HTTP requests.
    It is a good idea to use a similar configuration to check the output while we
    compose and send the HTTP requests:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了 macOS 上并排的两个终端窗口。左侧的终端窗口正在运行 Django 开发服务器，并显示接收和处理的 HTTP 请求。右侧的终端窗口正在运行
    `http` 命令以生成 HTTP 请求。在编写和发送 HTTP 请求时使用类似的配置来检查输出是一个好主意：
- en: '![](img/6ffae235-3361-45e1-bb29-66247cdef340.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6ffae235-3361-45e1-bb29-66247cdef340.png)'
- en: 'Now we will select one of the games from the previous list and we will compose
    an HTTP request to retrieve just the chosen game. For example, in the previous
    list, the first game has an `id` value equal to `3`. Run the following command
    to retrieve this game. Use the `id` value you have retrieved in the previous command
    for the first game, as the `id` number might be different. The code file for the
    sample is included in the `restful_python_2_05_01` folder, in the `Django01/cmd/cmd03.txt`
    file:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将从上一个列表中选择一个游戏，并编写一个 HTTP 请求来检索所选的游戏。例如，在上一个列表中，第一个游戏的 `id` 值等于 `3`。运行以下命令来检索此游戏。使用上一个命令中检索到的第一个游戏的
    `id` 值，因为 `id` 号码可能不同。示例代码文件包含在 `restful_python_2_05_01` 文件夹中，位于 `Django01/cmd/cmd03.txt`
    文件：
- en: '[PRE50]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The following is the equivalent `curl` command. The code file for the sample
    is included in the `restful_python_2_05_01` folder, in the `Django01/cmd/cmd04.txt`
    file:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的 `curl` 命令。示例代码文件包含在 `restful_python_2_05_01` 文件夹中，位于 `Django01/cmd/cmd04.txt`
    文件：
- en: '[PRE51]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The previous commands will compose and send the following HTTP request: `GET
    http://localhost:8000/games/3/`. The request has a number after `/games/`, and
    therefore, it will match `''^games/(?P<id>[0-9]+)/$''` and run the `views.game_detail`
    function, that is, the `game_detail` function declared within the `games_service/games/views.py`
    file. The function receives `request` and `id` as parameters because the URL pattern
    passes the number specified after `/games/` in the `id` parameter. As the HTTP
    verb for the request is `GET`, the `request.method` property is equal to `''GET''`,
    and therefore, the function will execute the code that retrieves the `Game` object
    whose primary key matches the `id` value received as an argument and, if found,
    generates a JSON response with this `Game` object serialized. The following lines
    show an example response for the HTTP request, with the `Game` object that matches
    the `id` value in the JSON response:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将组合并发送以下 HTTP 请求：`GET http://localhost:8000/games/3/`。请求在 `/games/` 后面有一个数字，因此，它将匹配
    `'^games/(?P<id>[0-9]+)/$'` 并运行 `views.game_detail` 函数，即 `games_service/games/views.py`
    文件中声明的 `game_detail` 函数。该函数接收 `request` 和 `id` 作为参数，因为 URL 模式将 `/games/` 后面指定的数字作为
    `id` 参数传递。由于请求的 HTTP 动词是 `GET`，`request.method` 属性等于 `'GET'`，因此，该函数将执行检索与作为参数接收的
    `id` 值匹配的 `Game` 对象的代码，如果找到，则生成包含此 `Game` 对象序列化的 JSON 响应。以下行显示了 HTTP 请求的示例响应，其中包含
    JSON 响应中与 `id` 值匹配的 `Game` 对象：
- en: '[PRE52]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now we will compose and send an HTTP request to retrieve a game that doesn''t
    exist. For example, in the previous list, there is no game with an `id` value
    equal to `888`. Run the following command to try to retrieve this game. Make sure
    you use an `id` value that doesn''t exist. We must make sure that the utilities
    display the headers as part of the response because the response won''t have a
    body. The code file for the sample is included in the `restful_python_2_05_01`
    folder, in the `Django01/cmd/cmd05.txt` file:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将组合并发送一个 HTTP 请求以检索一个不存在的游戏。例如，在之前的列表中，没有 `id` 值等于 `888` 的游戏。运行以下命令尝试检索此游戏。确保您使用一个不存在的
    `id` 值。我们必须确保实用工具将标题作为响应的一部分显示，因为响应将没有主体。示例代码文件包含在 `restful_python_2_05_01` 文件夹中，在
    `Django01/cmd/cmd05.txt` 文件中：
- en: '[PRE53]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The following is the equivalent `curl` command. The code file for the sample
    is included in the `restful_python_2_05_01` folder, in the `Django01/cmd/cmd06.txt`
    file:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的 `curl` 命令。示例代码文件包含在 `restful_python_2_05_01` 文件夹中，在 `Django01/cmd/cmd06.txt`
    文件中：
- en: '[PRE54]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The previous commands will compose and send the following HTTP request: `GET
    http://localhost:8000/games/888/`. The request is the same as the previous one
    we have analyzed, with a different number for the `id` parameter. The server will
    run the `views.game_detail` function, that is, the `game_detail` function declared
    within the `games_service/games/views.py` file. The function will execute the
    code that retrieves the `Game` object whose primary key matches the `id` value
    received as an argument and a `Game.DoesNotExist` exception will be thrown and
    captured because there is no game with the specified `id` value. Thus, the code
    will return an HTTP `404 Not Found` status code. The following lines show an example
    header response for the HTTP request:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将组合并发送以下 HTTP 请求：`GET http://localhost:8000/games/888/`。请求与之前我们分析过的请求相同，只是
    `id` 参数的数字不同。服务器将运行 `views.game_detail` 函数，即 `games_service/games/views.py` 文件中声明的
    `game_detail` 函数。该函数将执行检索与作为参数接收的 `id` 值匹配的 `Game` 对象的代码，并抛出并捕获 `Game.DoesNotExist`
    异常，因为没有与指定的 `id` 值匹配的游戏。因此，代码将返回 HTTP `404 Not Found` 状态码。以下行显示了 HTTP 请求的示例响应头：
- en: '[PRE55]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now run the following command to compose and send an HTTP `POST` request to
    create a new game. The code file for the sample is included in the `restful_python_2_05_01`
    folder, in the `Django01/cmd/cmd07.txt` file:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行以下命令来组合并发送一个 HTTP `POST` 请求以创建一个新的游戏。示例代码文件包含在 `restful_python_2_05_01`
    文件夹中，在 `Django01/cmd/cmd07.txt` 文件中：
- en: '[PRE56]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The following is the equivalent `curl` command. It is very important to use
    the `-H "Content-Type: application/json"` option to indicate `curl` to send the
    data specified after the `-d` option as `application/json` instead of the default
    `application/x-www-form-urlencoded`. The code file for the sample is included
    in the `restful_python_2_05_01` folder, in the `Django01/cmd/cmd08.txt` file:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '以下是对应的 `curl` 命令。使用 `-H "Content-Type: application/json"` 选项来指示 `curl` 将 `-d`
    选项之后指定的数据作为 `application/json` 发送，而不是默认的 `application/x-www-form-urlencoded`，这一点非常重要。示例代码文件包含在
    `restful_python_2_05_01` 文件夹中，位于 `Django01/cmd/cmd08.txt` 文件：'
- en: '[PRE57]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The previous commands will compose and send the following HTTP request: `POST
    http://localhost:8000/games/` with the following JSON key-value pairs:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将组合并发送以下 HTTP 请求：`POST http://localhost:8000/games/`，并带有以下 JSON 键值对：
- en: '[PRE58]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The request specifies `/games/`, and therefore, it will match `''^games/$''`
    and run the `views.game_collection` function, that is, the `game_collection` function
    declared within the `games_service/ames/views.py` file. The function just receives
    `request` as a parameter because the URL pattern doesn''t include any parameters.
    As the HTTP verb for the request is `POST`, the `request.method` property is equal
    to `''POST''`, and therefore, the function executes the code that parses the JSON
    data received in the request, creates a new `Game` and, if the data is valid,
    it saves the new `Game` instance. If the new `Game` instance was successfully
    persisted in the database, the function returns an HTTP `201 Created` status code
    and the recently persisted `Game` serialized to JSON in the response body. The
    following lines show an example response for the HTTP request, with the new `Game`
    object in the JSON response:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 请求指定了 `/games/`，因此它将匹配 `'^games/$'` 并运行 `views.game_collection` 函数，即 `games_service/ames/views.py`
    文件中声明的 `game_collection` 函数。该函数仅接收 `request` 作为参数，因为 URL 模式不包含任何参数。由于请求的 HTTP
    动词是 `POST`，因此 `request.method` 属性等于 `'POST'`，因此函数执行解析请求中接收到的 JSON 数据的代码，创建一个新的
    `Game` 对象，如果数据有效，则保存新的 `Game` 实例。如果新的 `Game` 实例成功持久化到数据库中，函数返回 HTTP `201 Created`
    状态码，并在响应体中将最近持久化的 `Game` 序列化为 JSON。以下行显示了 HTTP 请求的示例响应，其中包含 JSON 响应中的新 `Game`
    对象：
- en: '[PRE59]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Now we run the following command to compose and send an HTTP `PUT` request
    to update an existing game, specifically, to replace the previously added game
    with a new one. We have to check the value assigned to `id` in the previous response
    and replace `4` in the command with the returned value. For example, if the value
    for `id` was `8`, you should use `games/8/` instead of `games/4/`. The code file
    for the sample is included in the `restful_python_2_05_01` folder, in the `Django01/cmd/cmd09.txt`
    file:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们运行以下命令来组合并发送一个 HTTP `PUT` 请求以更新现有的游戏，具体来说，用新的游戏替换之前添加的游戏。我们必须检查之前响应中分配给
    `id` 的值，并将命令中的 `4` 替换为返回的值。例如，如果 `id` 的值为 `8`，则应使用 `games/8/` 而不是 `games/4/`。示例代码文件包含在
    `restful_python_2_05_01` 文件夹中，位于 `Django01/cmd/cmd09.txt` 文件：
- en: '[PRE60]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The following is the equivalent `curl` command. As happened with the previous
    `curl` example, it is very important to use the `-H "Content-Type: application/json"`
    option to indicate `curl` to send the data specified after the `-d` option as
    `application/json` instead of the default `application/x-www-form-urlencoded`.
    The code file for the sample is included in the `restful_python_2_05_01` folder,
    in the `Django01/cmd/cmd10.txt` file:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '以下是对应的 `curl` 命令。与之前的 `curl` 示例一样，使用 `-H "Content-Type: application/json"`
    选项来指示 `curl` 将 `-d` 选项之后指定的数据作为 `application/json` 发送，而不是默认的 `application/x-www-form-urlencoded`，这一点非常重要。示例代码文件包含在
    `restful_python_2_05_01` 文件夹中，位于 `Django01/cmd/cmd10.txt` 文件：'
- en: '[PRE61]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The previous commands will compose and send the HTTP request `PUT http://localhost:8000/games/15/`
    with the following JSON key-value pairs:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将组合并发送 HTTP 请求 `PUT http://localhost:8000/games/15/`，并带有以下 JSON 键值对：
- en: '[PRE62]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The request has a number after `/games/`, and therefore, it will match `''^games/(?P<id>[0-9]+)/$''`
    and run the `views.game_detail` function, that is, the `game_detail` function
    declared within the `games_service/games/views.py` file. The function receives
    `request` and `id` as parameters because the URL pattern passes the number specified
    after `/games/` in the `id` parameter. As the HTTP verb for the request is `PUT`,
    the `request.method` property is equal to `''PUT''`, and therefore, the function
    executes the code that parses the JSON data received in the request, creates a
    `Game` instance from this data and updates all the fields for the existing game
    in the database. If the game was successfully updated in the database, the function
    returns an HTTP `200 OK` status code and the recently updated `Game` serialized
    to JSON in the response body. The following lines show an example response for
    the HTTP request, with the updated `Game` object in the JSON response:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 请求在`/games/`之后有一个数字，因此它将匹配`'^games/(?P<id>[0-9]+)/$'`并运行`views.game_detail`函数，即`games_service/games/views.py`文件中声明的`game_detail`函数。该函数接收`request`和`id`作为参数，因为URL模式将`/games/`之后指定的数字传递给`id`参数。由于请求的HTTP动词是`PUT`，所以`request.method`属性等于`'PUT'`，因此函数执行解析请求中接收到的JSON数据的代码，从这些数据创建一个`Game`实例，并更新数据库中现有游戏的全部字段。如果游戏在数据库中成功更新，函数将返回HTTP
    `200 OK`状态码，并将最近更新的`Game`序列化为JSON格式放在响应体中。以下行显示了HTTP请求的一个示例响应，其中在JSON响应中显示了更新的`Game`对象：
- en: '[PRE63]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'In order to successfully process an HTTP `PUT` request that updates an existing
    game with a new one, we must provide values for all the required fields. We will
    compose and send an HTTP request to try to update an existing game, and we will
    fail to do so because we will just provide a value for the name. As happened in
    the previous request, we will use the value assigned to `id` in the last game
    we added. The code file for the sample is included in the `restful_python_2_05_01`
    folder, in the `Django01/cmd/cmd11.txt` file:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 为了成功处理更新现有游戏为新游戏的HTTP `PUT`请求，我们必须为所有所需字段提供值。我们将组合并发送一个HTTP请求来尝试更新一个现有游戏，我们将无法做到这一点，因为我们只为名称提供了一个值。就像之前的请求一样，我们将使用最后添加的游戏中分配给`id`的值。示例的代码文件包含在`restful_python_2_05_01`文件夹中，在`Django01/cmd/cmd11.txt`文件中：
- en: '[PRE64]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The following is the equivalent `curl` command. The code file for the sample
    is included in the `restful_python_2_05_01` folder, in the `Django01/cmd/cmd12.txt`
    file:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的`curl`命令。示例的代码文件包含在`restful_python_2_05_01`文件夹中，在`Django01/cmd/cmd12.txt`文件中：
- en: '[PRE65]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The previous commands will compose and send the HTTP request `PUT http://localhost:8000/games/15/`
    with the following JSON key-value pair:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将组合并发送HTTP请求`PUT http://localhost:8000/games/15/`，带有以下JSON键值对：
- en: '[PRE66]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The request will execute the same code we explained for the previous request.
    Because we didn''t provide all the required values for a `Game` instance, the
    `game_serializer.is_valid()` method will return `False` and the function will
    return an HTTP `400 Bad Request` status code and the details generated in the
    `game_serializer.errors` attribute are serialized to JSON in the response body.
    The following lines show an example response for the HTTP request, with the required
    fields that didn''t include values in our request listed in the JSON response.
    The list uses the field name as a key and the error message as a value:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 请求将执行我们之前解释的相同代码。因为我们没有提供`Game`实例所需的所有值，所以`game_serializer.is_valid()`方法将返回`False`，函数将返回HTTP
    `400 Bad Request`状态码，并且`game_serializer.errors`属性中生成的详细信息将序列化为JSON格式放在响应体中。以下行显示了HTTP请求的一个示例响应，其中列出了我们请求中没有包含值的所需字段，在JSON响应中使用字段名作为键，错误信息作为值：
- en: '[PRE67]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: When we want our API to be able to update a single field for an existing resource,
    in this case, an existing game, we should provide an implementation for the `PATCH`
    method. The `PUT` method is meant to replace an entire resource and the `PATCH`
    method is meant to apply a delta to an existing resource. We can write code in
    the handler for the `PUT` method to apply a delta to an existing resource, but
    it is a better practice to use the `PATCH` method for this specific task. We will
    work with the `PATCH` method later when we code an improved version of our API.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们希望我们的API能够更新现有资源的一个字段时，在这种情况下，一个现有的游戏，我们应该提供一个`PATCH`方法的实现。`PUT`方法旨在替换整个资源，而`PATCH`方法旨在对现有资源应用一个增量。我们可以在`PUT`方法的处理器中编写代码来对现有资源应用一个增量，但使用`PATCH`方法来完成这个特定任务是一个更好的实践。当我们编写API的改进版本时，我们将使用`PATCH`方法。
- en: 'Now run the following command to compose and send an HTTP request to delete
    an existing game, specifically, the last game we added and updated. As happened
    in our last HTTP requests, we have to check the value assigned to `id` in the
    previous response and replace `4` in the command with the returned value. The
    code file for the sample is included in the `restful_python_2_05_01` folder, in
    the `Django01/cmd/cmd13.txt` file:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行以下命令以组合并发送一个HTTP请求来删除一个现有的游戏，特别是我们最后添加和更新的游戏。就像我们之前的HTTP请求一样，我们必须检查之前响应中分配给`id`的值，并将命令中的`4`替换为返回的值。示例代码文件包含在`restful_python_2_05_01`文件夹中的`Django01/cmd/cmd13.txt`文件：
- en: '[PRE68]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The following is the equivalent `curl` command. The code file for the sample
    is included in the `restful_python_2_05_01` folder, in the `Django01/cmd/cmd14.txt`
    file:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的`curl`命令。示例代码文件包含在`restful_python_2_05_01`文件夹中的`Django01/cmd/cmd14.txt`文件：
- en: '[PRE69]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The previous commands will compose and send the following HTTP request: `DELETE
    http://localhost:8000/games/4/`. The request has a number after `/games/`, and
    therefore, it will match `''^games/(?P<id>[0-9]+)/$''` and run the `views.game_detail`
    function, that is, the `game_detail` function declared within the `games_service/views.py`
    file. The function receives `request` and `id` as parameters because the URL pattern
    passes the number specified after `/games/` in the `id` parameter. As the HTTP
    verb for the request is `DELETE`, the `request.method` property is equal to `''DELETE''`,
    and therefore, the function will execute the code that parses the JSON data received
    in the request, creates a `Game` instance from this data and deletes the existing
    game in the database. If the game was successfully deleted in the database, the
    function returns an HTTP `204 No Content` status code.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将组合并发送以下HTTP请求：`DELETE http://localhost:8000/games/4/`。请求在`/games/`之后有一个数字，因此，它将匹配`'^games/(?P<id>[0-9]+)/$'`并运行`views.game_detail`函数，即`games_service/views.py`文件中声明的`game_detail`函数。该函数接收`request`和`id`作为参数，因为URL模式将`/games/`之后指定的数字传递给`id`参数。由于请求的HTTP动词是`DELETE`，所以`request.method`属性等于`'DELETE'`，因此，该函数将执行解析请求中接收到的JSON数据的代码，从这些数据创建一个`Game`实例，并在数据库中删除现有的游戏。如果游戏在数据库中成功删除，则函数返回HTTP
    `204 No Content`状态码。
- en: 'The following lines show an example response for the HTTP request after successfully
    deleting an existing game:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了在成功删除现有游戏后对HTTP请求的示例响应：
- en: '[PRE70]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Working with GUI tools - Postman and others
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用GUI工具 - Postman和其他工具
- en: 'So far, we have been working with two Terminal-based or command-line tools
    to compose and send HTTP requests to our Django development server: cURL and HTTPie.
    Now we will work with Postman, one of the GUI tools we used when composing and
    sending HTTP requests to the Flask development server on [Chapter 1](dbf75cef-4962-4e40-8192-03873b774c48.xhtml),
    *Developing RESTful APIs and Microservices with Flask 1.0.2*. If you skipped this
    chapter, make sure you check the installation instructions in the section named
    *Working with GUI tools - Postman and others* in that chapter.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用两个基于终端或命令行工具来组合并发送HTTP请求到我们的Django开发服务器：cURL和HTTPie。现在我们将使用Postman，这是我们用于在[第1章](dbf75cef-4962-4e40-8192-03873b774c48.xhtml)中组合并发送HTTP请求到Flask开发服务器的GUI工具之一：*Developing
    RESTful APIs and Microservices with Flask 1.0.2*。如果你跳过了这一章，请确保检查该章节中名为*使用GUI工具
    - Postman和其他工具*的部分中的安装说明。
- en: Once you launch Postman, make sure you close the modal dialog box that provides
    shortcuts to common tasks. Select GET Request in the + new drop-down menu at the
    upper-left corner ...
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦启动Postman，请确保关闭提供常见任务快捷方式的模态对话框。在左上角的+ new下拉菜单中选择GET请求 ...
- en: Test your knowledge
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试你的知识
- en: 'Let''s see whether you can answer the following questions correctly:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看你是否能正确回答以下问题：
- en: 'Which of the following commands run the script to create a new Django app named
    `recipes`:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个命令运行脚本以创建一个名为`recipes`的新Django应用程序：
- en: '`python django.py startapp recipes`'
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`python django.py startapp recipes`'
- en: '`python manage.py startapp recipes`'
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`python manage.py startapp recipes`'
- en: '`python starapp.py recipes`'
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`python starapp.py recipes`'
- en: 'Which of the following strings must be added to the `INSTALLED_APPS` variable
    to add Django REST Framework in the Django application:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个字符串必须添加到`INSTALLED_APPS`变量中，以便在Django应用程序中添加Django REST Framework：
- en: '`''rest-framework''`'
  id: totrans-260
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`''rest-framework''`'
- en: '`''django-rest-framework''`'
  id: totrans-261
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`''django-rest-framework''`'
- en: '`''rest_framework''`'
  id: totrans-262
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`''rest_framework''`'
- en: 'Django''s ORM:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Django的ORM：
- en: Is integrated with Django
  id: totrans-264
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 集成到Django中
- en: Has to be configured as an optional component in Django
  id: totrans-265
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 必须在Django中配置为可选组件
- en: Has to be installed after configuring SQLAlchemy
  id: totrans-266
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 必须在配置SQLAlchemy之后安装
- en: 'In Django REST Framework, serializers are:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Django REST Framework中，序列化器作为：
- en: Mediators between the view functions and Python primitives
  id: totrans-268
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 视图函数和Python基本类型之间的中介
- en: Mediators between the URLs and view functions
  id: totrans-269
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: URL和视图函数之间的中介
- en: Mediators between the model instances and Python primitives
  id: totrans-270
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模型实例和Python基本类型之间的中介
- en: 'The `urlpatterns` list declared in the `urls.py` file makes it possible to:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`urls.py`文件中声明的`urlpatterns`列表使得：
- en: Route URLs to models
  id: totrans-272
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将URL路由到模型
- en: Route URLs to Python primitives
  id: totrans-273
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将URL路由到Python基本类型
- en: Route URLs to views
  id: totrans-274
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将URL路由到视图
- en: 'In Django REST Framework, parsers and renderers handle as mediators between:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Django REST Framework中，解析器和渲染器作为中介处理：
- en: Model instances and Python primitives
  id: totrans-276
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模型实例和Python基本类型
- en: Python primitives and HTTP requests and responses
  id: totrans-277
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Python基本类型和HTTP请求与响应
- en: URLs and view functions
  id: totrans-278
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: URL和视图函数
- en: 'If we want to create a simple `Game` model to represent and persist games in
    Django REST Framework, we can create:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们想在Django REST Framework中创建一个简单的`Game`模型来表示和持久化游戏，我们可以创建：
- en: A `Game` class as a subclass of the `django.db.models.Model` superclass
  id: totrans-280
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个作为`django.db.models.Model`超类子类的`Game`类
- en: A `Game` class as a subclass of the `djangorestframework.models.Model` superclass
  id: totrans-281
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个作为`djangorestframework.models.Model`超类子类的`Game`类
- en: A `Game` function in the `restframeworkmodels.py` file
  id: totrans-282
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`restframeworkmodels.py`文件中的`Game`函数'
- en: Summary
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we designed a RESTful API to interact with a simple SQLite
    database and perform CRUD operations with games. We defined the requirements for
    our API and we understood the tasks performed by each HTTP method. We set up a
    virtual environment with Django and Django REST Framework.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们设计了一个RESTful API来与简单的SQLite数据库交互，并使用游戏执行CRUD操作。我们定义了API的要求，并理解了每个HTTP方法执行的任务。我们使用Django和Django
    REST Framework设置了虚拟环境。
- en: We created a model to represent and persist games and we executed migrations
    in Django. We learned to manage serialization and serialization of game instances
    into JSON representations with Django REST Framework. We wrote API views to process
    the different HTTP requests and we configured the URL patterns list to route URLs
    to views.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个模型来表示和持久化游戏，并在Django中执行了迁移。我们学会了使用Django REST Framework管理游戏实例的序列化和反序列化到JSON表示。我们编写了API视图来处理不同的HTTP请求，并配置了URL模式列表将URL路由到视图。
- en: Finally, we started the Django development server and we used command-line tools
    to compose and send HTTP requests ...
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们启动了Django开发服务器，并使用命令行工具来组合和发送HTTP请求...
