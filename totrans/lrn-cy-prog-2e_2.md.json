["```py\ncdef int AddFunction(int, int)\n```", "```py\ndef square(int x):\n    return x ** 2\n```", "```py\n#ifndef __MYCODE_H__\n#define __MYCODE_H__\n\nstruct mystruct {\n char * string;\n int integer;\n char ** string_array;\n};\n\nextern void printStruct (struct mystruct *);\n\n#endif //__MYCODE_H__\n```", "```py\ncdef extern from \"mycode.h\":\n struct mystruct:\n char * string\n int integer\n char ** string_array\n  void printStruct (mystruct *)\n```", "```py\ndef testStruct ():\n cdef mystruct s\n cdef char *array [2]\n    s.string = \"Hello World\"\n s.integer = 2\n    array [0] = \"foo\"\n    array [1] = \"bar\"\n    s.string_array = array\n printStruct (&s)\n\n```", "```py\n  void myfunc (struct mystruct * x)\n```", "```py\n  void myfunc (mystruct * x)\n```", "```py\n#include <stdio.h>\n#include \"mycode.h\"\n\nvoid printStruct (struct mystruct * s)\n{\n    printf(\".string = %s\\n\", s->string);\n    printf(\".integer = %i\\n\", s->integer);\n    printf(\".string_array = \\n\");\n\n    int i;\n    for (i = 0; i < s->integer; ++i)\n        printf (\"\\t[%i] = %s\\n\", i, s->string_array [i]);\n}\n```", "```py\n$ cd chapter2/cpy-cdef-reference\n$ make\n$ python\n>>> from mycodepy import testStruct\n>>> testStruct ()\n.string = Hello World\n.integer = 2\n.string_array =\n [0] = foo\n [1] = bar\n\n```", "```py\nenum cardsuit {\n   CLUBS,\n   DIAMONDS,\n   HEARTS,\n   SPADES\n};\n```", "```py\ncdef enum cardsuit:\n  CLUBS, DIAMONDS, HEARTS, SPADES\n```", "```py\ncdef cardsuit card = CLUBS\n```", "```py\nstruct foobar {\n  int x;\n  char * y;\n};\ntypedef struct foobar foobar_t;\n\n```", "```py\ncdef struct foobar:\n    int x\n    char * y\nctypedef foobar foobar_t\n\n```", "```py\nctypedef int * int_ptr\n\n```", "```py\ntypedef void (*cfptr) (int)\n```", "```py\nctypedef void (*cfptr)(int)\n```", "```py\ncdef cfptr myfunctionptr = &myfunc\n```", "```py\ncdef public struct CythonStruct:\n    size_t number_of_elements;\n    char ** elements;\n```", "```py\n struct CythonStruct {\n    size_t number_of_elements;\n    char ** elements;\n};\n```", "```py\n#include <Python.h>\n\nint main(int argc, char **argv) {\n    Py_Initialize ();\n    // code in here\n    Py_Finalize ();\n    return 0;\n}\n```", "```py\ncdef public void cythonFunction ():\n    print \"inside cython function!!!\"\n```", "```py\n/* Boiler plate init Python */\n  Py_SetProgramName (argv [0]);\n  Py_Initialize ();\n  /* Init our config module into Python memory */\n initpublicTest ();\n cythonFunction ();\n\n  /* cleanup python before exit ... */\n  Py_Finalize ();\n```", "```py\nimport cythonfile\n```", "```py\ncpdef public test (int x):\n   â€¦\n return 1\n\n```", "```py\n__PYX_EXTERN_C DL_IMPORT(PyObject) *test(int, int __pyx_skip_dispatch);\n```", "```py\nlong returnValue = PyInt_AsLong (test (1, 0))\n```", "```py\nimport logging\n\ncdef public void initLoggingWithLogFile(const char * logfile):\n logging.basicConfig(filename = logfile,\n level = logging.DEBUG,\n format = '%(levelname)s %(asctime)s: %(message)s',\n datefmt = '%m/%d/%Y %I:%M:%S')\n\ncdef public void python_info(char * message):\n logging.info(message)\n\ncdef public void python_debug(char * message):\n logging.debug(message)\n\ncdef public void python_error(char * message):\n logging.error(message)\n\n```", "```py\n#ifndef __NATIVE_LOGGING_H__\n#define __NATIVE_LOGGING_H__\n#define printflike __attribute__ ((format (printf, 3, 4)))\n\nextern void printflike native_logging_info(const char *, unsigned, const char *, ...);\nextern void printflike native_logging_debug(const char *, unsigned, const char *, ...);\nextern void printflike native_logging_error(const char *, unsigned, const char *, ...);\n\n#define info(...)  native_logging_info(__FILE__, __LINE__, __VA_ARGS__)\n#define error(...) native_logging_debug(__FILE__, __LINE__, __VA_ARGS__)\n#define debug(...) native_logging_error(__FILE__, __LINE__, __VA_ARGS__)\n\nextern void SetupNativeLogging(const char * logFileName);\nextern void CloseNativeLogging();\n\n#endif // __NATIVE_LOGGING_H__\n```", "```py\nvoid SetupNativeLogging(const char * logFileName)\n{\n    /* Boiler plate init Python */\n    Py_Initialize();\n\n    /* Init our config module into Python memory */\n    initPythonLoggingBackend();\n\n    /* call directly into our cython module  */\n    initLoggingWithLogFile(logFileName);\n}\n```", "```py\nvoid native_logging_info(const char * file, unsigned line, const char * fmt, ...)\n{\n    char buffer[256];\n    va_list args;\n    va_start(args, fmt);\n    vsprintf(buffer, fmt, args);\n    va_end(args);\n\n// append file/line information\n    char buf[512];\n    snprintf(buf, sizeof(buf), \"%s:%i -> %s\", file, line, buffer);\n\n// call python logging.info\n    python_info(buf);\n}\n```", "```py\nvoid CloseNativeLogging()\n{\n    /* cleanup python before exit ... */\n    Py_Finalize();\n}\n```", "```py\n#include \"NativeLogging.h\"\n\nint main(int argc, char **argv)\n{\n    // we want to ensure we use a command line argument for the output log file\n    if (argc < 2) {\n        return -1;\n    }\n\n    // use the first argument as log file\n    SetupNativeLogging(argv[1]);\n\n    // log out some stuff at different levels\n    info(\"info message\");\n    debug(\"debug message\");\n    error(\"error message\");\n\n    // close up everything including Python\n    CloseNativeLogging();\n\n    return 0;\n}\n```", "```py\n$ cd chapter2/PythonLogging\n$ make\n$ ./example output.log\n$ cat output.log\nINFO 10/25/2015 07:04:45: main.c:14 -> info message\nERROR 10/25/2015 07:04:45: main.c:15 -> debug message\nDEBUG 10/25/2015 07:04:45: main.c-16 -> error message\n```", "```py\n[example]\nnumber = 15\npath = some/path/to/something\n\n[another_section]\ntest = something\n```", "```py\nfrom ConfigParser import SafeConfigParser\nfrom libc.stdlib cimport malloc\n\ncdef public struct ConfigSections:\n size_t number_of_sections\n char ** sections\n\ncdef public void ParseSectionsFromConfig(const char *config_path, ConfigSections * const sections):\n    parser = SafeConfigParser()\n    with open(config_path) as config_fd:\n        try:\n            parser.readfp(config_fd)\n            sectionsInConfig = parser.sections()\n            sections.number_of_sections = len(sectionsInConfig)\n            sections.sections = <char **>malloc(sections.number_of_sections)\n            for i in range(sections.number_of_sections):\n                sections.sections[i] = sectionsInConfig[i]\n        except:\n            sections.number_of_sections = 0\n            sections.sections = NULL\n```", "```py\ncdef public struct ConfigSections\n```", "```py\ncdef public void ParseSectionsFromConfig(const char *config_path, ConfigSections * const sections):\n```", "```py\nsections.sections = <char **>malloc(sections.number_of_sections)\n```", "```py\ncdef public void ParseKeysFromSectionFromConfig(const char * config_path, const char * section, ConfigSectionKeys * keys):\n```", "```py\ncdef public char * ParseConfigKeyFromSection(const char *config_path, const char * section, const char * key):\n```", "```py\n#include \"PythonConfigParser.h\"\n\nstatic\nvoid print_config(const char * config_file)\n{\n struct ConfigSections sections;\n ParseSectionsFromConfig(config_file, &sections);\n\n    size_t i;\n    for (i = 0; i < sections.number_of_sections; ++i) {\n        const char *current_section = sections.sections[i];\n        printf(\"[%s]\\n\", current_section);\n\n struct ConfigSectionKeys sectionKeys;\n ParseKeysFromSectionFromConfig(config_file, current_section, &sectionKeys);\n\n        size_t j;\n        for (j = 0; j < sectionKeys.number_of_keys; ++j) {\n            const char * current_key = sectionKeys.keys[j];\n            char *key_value = ParseConfigKeyFromSection(config_file, current_section, current_key);\n\n            printf(\"%s = %s\\n\", current_key, key_value);\n        }\n free(sectionKeys.keys);\n    }\n free(sections.sections);\n}\n```", "```py\ncdef public char * ParseConfigKeyFromSection(const char *config_path, const char * section, const char * key):\n    parser = SafeConfigParser()\n    with open(config_path) as config_fd:\n        try:\n            parser.readfp(config_fd)\n return parser.get(section, key)\n        except:\n            return NULL\n```", "```py\n$ cd Chapter2/PythonConfigParser\n$ make\n$ ./example sample.cfg\n[example]\nnumber = 15\npath = some/path/to/something\n[another_section]\ntest = something\n```", "```py\ncdef public:\n    ctypedef void (*callback)(int)\n```", "```py\ncdef callback GlobalCallback\n```", "```py\ncdef public void SetCallback(callback cb):\n    global GlobalCallback\n    GlobalCallback = cb\n```", "```py\ncdef public void Notify(int value):\n    global GlobalCallback\n    if GlobalCallback != <callback>0:\n        GlobalCallback(value)\n```", "```py\nstatic\nvoid MyCallback(int val)\n{\n    printf(\"[MYCALLBACK] %i\\n\", val);\n}\n```", "```py\nSetCallback(&MyCallback);\n```", "```py\nNotify(12345);\n```", "```py\n$ cd Chapter2/PythonCallbacks\n$ make\n$ ./example\n[MYCALLBACK] 12345\n```", "```py\ncdef extern from \"AddFunction.h\":\n    cdef int AddFunction(int, int)\n```", "```py\ncimport bindings\n```", "```py\nfrom distutils.core import setup\nfrom Cython.Build import cythonize\n\nsetup(\n    ext_modules = cythonize(\"sourcecode.pyx\")\n)\n```", "```py\nfound_python=no\nAC_ARG_ENABLE(\n python,\n AC_HELP_STRING(--enable-python, create python support),\n found_python=yes\n)\nAM_CONDITIONAL(IS_PYTHON, test \"x%found_python\" = xyes)\n\nPYLIBS=\"\"\nPYINCS=\"\"\nif test \"x$found_python\" = xyes; then\n AC_CHECK_PROG(CYTHON_CHECK,cython,yes)\n   if test x\"$CYTHON_CHECK\" != x\"yes\" ; then\n      AC_MSG_ERROR([Please install cython])\n   fi\n AC_CHECK_PROG(PYTHON_CONF_CHECK,python-config,yes)\n PYLIBS=`python-config --libs`\n PYINCS=`python-config --includes`\n   if test \"x$PYLIBS\" == x; then\n      AC_MSG_ERROR(\"python-dev not found\")\n   fi\nfi\nAC_SUBST(PYLIBS)\nAC_SUBST(PYINCS)\n\n```", "```py\nbin_PROGRAMS = myprog\nACLOCAL_AMFLAGS = -I etc\nCFLAGS += -I$(PYINCS)\n\nLIBTOOL_DEPS = @LIBTOOL_DEPS@\nlibtool: $(LIBTOOL_DEPS)\n        $(SHELL) ./config.status libtool\n\nSUFFIXES = .pyx\n.pyx.c:\n @echo \"  CPY   \" $<\n @cython -2 -o $@ $<\n\nmyprog_SOURCES = \\\n        src/bla.pyx \\\n...\nmyprog_LDADD = \\\n $(PYLIBS)\n\n```"]