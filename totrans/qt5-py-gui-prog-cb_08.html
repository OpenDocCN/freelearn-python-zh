<html><head></head><body>
  <div><div><div><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Internationalization and Testing</h1></div></div></div><p>In this chapter, we will internationalize and test our Python GUI covering the following recipes:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Displaying widget text in different languages</li><li class="listitem" style="list-style-type: disc">Changing the entire GUI language all at once</li><li class="listitem" style="list-style-type: disc">Localizing the GUI</li><li class="listitem" style="list-style-type: disc">Preparing the GUI for internationalization</li><li class="listitem" style="list-style-type: disc">How to design a GUI in an agile fashion</li><li class="listitem" style="list-style-type: disc">Do we need to test the GUI code?</li><li class="listitem" style="list-style-type: disc">Setting debug watches</li><li class="listitem" style="list-style-type: disc">Configuring different debug output levels</li><li class="listitem" style="list-style-type: disc">Creating self-testing code using Python's __main__ section</li><li class="listitem" style="list-style-type: disc">Creating robust GUIs using unit tests</li><li class="listitem" style="list-style-type: disc">How to write unit tests using the Eclipse PyDev IDE</li></ul></div><div><div><div><div><h1 class="title"><a id="ch08lvl1sec70"/>Introduction</h1></div></div></div><p>In this chapter, we will internationalize our GUI by displaying text on labels, buttons, tabs, and other widgets, in different languages.</p><p>We will start simply and then explore how we can prepare our GUI for internationalization at the design level.</p><p>We will also localize the GUI, which is slightly different from internationalization.</p><div><div><h3 class="title"><a id="note93"/>Note</h3><p>As these words are long, they have been abbreviated to use the first character of the word, followed by the total number of characters in between the first and last character, followed by the last character of the word.</p><p>So, internationalization becomes I18N and localization becomes L10N.</p></div></div><p>We will also test our GUI code and write unit tests and explore the value unit tests can provide in our development efforts which will lead us to the best practice of <em>refactoring</em> our code.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch08lvl1sec71"/>Displaying widget text in different languages</h1></div></div></div><p>The<a id="id319" class="indexterm"/> easiest way to internationalize text strings in Python is by moving them into a separate Python module and then selecting the language to be displayed in our GUI by passing in a parameter to this module.</p><p>While this approach is not highly recommended, according to online search results, depending on the specific requirements of the application you are developing, this approach might still be the most pragmatic and fastest to implement.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec182"/>Getting ready</h2></div></div></div><p>We will reuse the Python GUI we created earlier. We have commented out one line of Python code that creates the MySQL tab because we do not talk to a MySQL database in this chapter.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec183"/>How to do it...</h2></div></div></div><p>In this recipe, we will start to I18N our GUI by changing the Windows title from English to another language.</p><p>As the name "GUI" is the same in other languages, we will first expand the name that enables us to see the visual effects of our changes.</p><p>Let's change our previous line of code:</p><div><pre class="programlisting">self.win.title("Python GUI")</pre></div><p>to:</p><div><pre class="programlisting">self.win.title("Python Graphical User Interface")</pre></div><p>The preceding code change results in the following title for our GUI program:</p><div><img src="img/B04829_08_01.jpg" alt="How to do it..."/></div><div><div><h3 class="title"><a id="note94"/>Note</h3><p>In this chapter, we will use English and German to exemplify the principle of internationalizing our Python GUI.</p></div></div><p>Hard-coding strings into code is never too good an idea, so the first step we can do to improve <a id="id320" class="indexterm"/>our code is to separate all the strings that are visible in our GUI into a Python module of their own. This is the beginning of internationalizing the visible aspects of our GUI.</p><div><div><h3 class="title"><a id="note95"/>Note</h3><p>While we are into I18N, we will do this very positive refactoring and the language translation all in one step.</p></div></div><p>Let's create a new Python module and name it <code class="literal">Resources.py</code>. Let's next move the English string of our GUI title into this module and then import this module into our GUI code.</p><div><div><h3 class="title"><a id="note96"/>Note</h3><p>We are separating the GUI from the languages it displays, which is an OOP design principle.</p></div></div><p>Our new Python module, containing internationalized strings, now looks like this:</p><div><pre class="programlisting">Class I18N():
'''Internationalization'''
    def __init__(self, language):
        if    language == 'en': self.resourceLanguageEnglish()
        elif  language == 'de': self.resourceLanguageGerman()
        else: raise NotImplementedError('Unsupported language.')

    def resourceLanguageEnglish(self):
        self.title = "Python Graphical User Interface"

    def resourceLanguageGerman(self):
        self.title = 'Python Grafische Benutzeroberflaeche'</pre></div><p>We import this new Python module into our main Python GUI code, and then use it.</p><div><pre class="programlisting">from B04829_Ch08_Resources import I18N
class OOP():
    def __init__(self): 
        self.win = tk.Tk()                # Create instance
        self.i18n = I18N('de')            # Select language
        self.win.title(self.i18n.title)   # Add a title</pre></div><p>Depending <a id="id321" class="indexterm"/>on which language we pass into the I18N class, our GUI will be displayed in that language. </p><p>Running the preceding code gives us the following internationalized result:</p><div><img src="img/B04829_08_02.jpg" alt="How to do it..."/></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec184"/>How it works...</h2></div></div></div><p>We are breaking out the hard-coded strings that are part of our GUI into their own separate modules. We do this by creating a class, and within the class's <code class="literal">__init__()</code> method, we select which language our GUI will display, depending on the passed in language argument.</p><p>This works.</p><p>We can further modularize our code by separating the internationalized strings into separate files, potentially in XML or another format. We could also read them in from a MySQL database.</p><div><div><h3 class="title"><a id="note97"/>Note</h3><p>This is a "Separation of Concerns" coding approach, which is at the heart of OOP programming.</p></div></div></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch08lvl1sec72"/>Changing the entire GUI language all at once</h1></div></div></div><p>In this<a id="id322" class="indexterm"/> recipe, we will change the entire GUI display names all at once by refactoring all the previously hard-coded English strings into a separate Python module and then internationalizing those strings.</p><p>This recipe shows that it is a good design principle to avoid hard-coding any strings that our GUI displays but to separate the GUI code from the text that the GUI displays.</p><div><div><h3 class="title"><a id="note98"/>Note</h3><p>Designing our GUI in a modular way makes internationalizing it much easier.</p></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec185"/>Getting ready</h2></div></div></div><p>We will continue to use the GUI from the previous recipe. In that recipe, we had already internationalized the title of the GUI.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec186"/>How to do it...</h2></div></div></div><p>In order to internationalize the text being displayed in all of our GUI widgets, we have to move all hard-coded strings into a separate Python module, and this is what we do next.</p><p>Previously, strings of words that our GUI displayed were scattered all over our Python code.</p><p>Here is what our GUI looked like without I18N.</p><div><img src="img/B04829_08_03.jpg" alt="How to do it..."/></div><p>Every<a id="id323" class="indexterm"/> single string of every widget, including the title of our GUI, the tab control names, and so on, were all hard-coded and intermixed with the code that creates the GUI.</p><div><div><h3 class="title"><a id="note99"/>Note</h3><p>It is a good idea to think about how we can best internationalize our GUI at the design phase of our GUI software development process.</p></div></div><p>The following is an excerpt of what our code looks like.</p><div><pre class="programlisting">WIDGET_LABEL = ' Widgets Frame '
class OOP():
    def __init__(self): 
        self.win = tk.Tk()              # Create instance
        self.win.title("Python GUI")    # Add a title
    
    
    # Radiobutton callback function
    def radCall(self):
        radSel=self.radVar.get()
        if   radSel == 0: self.monty2.configure(text='Blue')
        elif radSel == 1: self.monty2.configure(text='Gold')
        elif radSel == 2: self.monty2.configure(text='Red')</pre></div><p>In this recipe, we are internationalizing all strings displayed in our GUI widgets. We are not internationalizing the text <em>entered</em> into our GUI, because this depends on the local settings on your PC.</p><p>The following <a id="id324" class="indexterm"/>is the code for the English internationalized strings:</p><div><pre class="programlisting">classI18N():
'''Internationalization'''
    
    def __init__(self, language):
        if   language == 'en': self.resourceLanguageEnglish()
        elif language == 'de': self.resourceLanguageGerman()
        else: raiseNotImplementedError('Unsupported language.')

    def resourceLanguageEnglish(self):
        self.title = "Python Graphical User Interface"
        
        self.file  = "File"
        self.new   = "New"
        self.exit  = "Exit"
        self.help  = "Help"
        self.about = "About"
        
        self.WIDGET_LABEL = ' Widgets Frame '
        
        self.disabled  = "Disabled"
        self.unChecked = "UnChecked"
        self.toggle    = "Toggle"
        
        # Radiobutton list
        self.colors   = ["Blue", "Gold", "Red"]
        self.colorsIn = ["in Blue", "in Gold", "in Red"]
        
        self.labelsFrame  = ' Labels within a Frame '
        self.chooseNumber = "Choose a number:"
        self.label2       = "Label 2"
        
        self.mgrFiles = ' Manage Files '
        
        self.browseTo = "Browse to File..."
        self.copyTo   = "Copy File To :   "</pre></div><p>In our Python GUI module, all previously hard-coded strings are now replaced by an instance of our new I18N class, which resides in the <code class="literal">Resources.py</code> module.</p><p>Here is an<a id="id325" class="indexterm"/> example from our refactored <code class="literal">GUI.py</code> module:</p><div><pre class="programlisting">from B04829_Ch08_Resources import I18N

class OOP():
    def __init__(self): 
        self.win = tk.Tk()              # Create instance
        self.i18n = I18N('de')          # Select language
        self.win.title(self.i18n.title) # Add a title
    
    # Radiobutton callback function
    def radCall(self):
          radSel = self.radVar.get()
        if   radSel == 0: self.widgetFrame.configure(text=self.i18n.WIDGET_LABEL + self.i18n.colorsIn[0])
        elif radSel == 1: self.widgetFrame.configure(text=self.i18n.WIDGET_LABEL + self.i18n.colorsIn[1])
        elif radSel == 2: self.widgetFrame.configure(text=self.i18n.WIDGET_LABEL + self.i18n.colorsIn[2])</pre></div><p>Note how all of the previously hard-coded English strings have been replaced by calls to the instance of our new I18N class.</p><p>An example is <code class="literal">self.win.title(self.i18n.title)</code>.</p><p>What this gives us is the ability to internationalize our GUI. We simply have to use the same variable names and combine them by passing in a parameter to select the language we wish to display.</p><p>We could change languages on the fly as part of the GUI as well, or we could read the local PC settings and decide which language our GUI text should display according to those settings.</p><p>We can now implement the translation to German by simply filling in the variable names with the corresponding words.</p><div><pre class="programlisting">        
class I18N():
    '''Internationalization'''
    def __init__(self, language):      
        if   language == 'en': self.resourceLanguageEnglish()
        elif language == 'de': self.resourceLanguageGerman()
        else: raise NotImplementedError('Unsupported language.')

def resourceLanguageGerman(self):
        self.file  = "Datei"
        self.new   = "Neu"
        self.exit  = "Schliessen"
        self.help  = "Hilfe"
        self.about = "Ueber"

        self.WIDGET_LABEL = ' Widgets Rahmen '
        
        self.disabled  = "Deaktiviert"
        self.unChecked = "NichtMarkiert"
        self.toggle    = "Markieren"
        
        # Radiobutton list
        self.colors   = ["Blau", "Gold", "Rot"]    
        self.colorsIn = ["in Blau", "in Gold", "in Rot"]  
        
        self.labelsFrame  = ' EtikettenimRahmen '
        self.chooseNumber = "WaehleeineNummer:"
        self.label2       = "Etikette 2"
    
        self.mgrFiles = ' DateienOrganisieren '
        
        self.browseTo = "WaehleeineDatei... "
        self.copyTo   = "KopiereDateizu :     "</pre></div><p>In our<a id="id326" class="indexterm"/> GUI code, we can now change the entire GUI display language in one line of Python code.</p><div><pre class="programlisting">class OOP():
    def __init__(self): 
        self.win = tk.Tk()        # Create instance
        self.i18n = I18N('de')    # Pass in language</pre></div><p>Running the preceding code creates the following internationalized GUI:</p><div><img src="img/B04829_08_04.jpg" alt="How to do it..."/></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec187"/>How it works...</h2></div></div></div><p>In order to<a id="id327" class="indexterm"/> internationalize our GUI, we refactored hard-coded strings into a separate module and then used the same class members to internationalize our GUI by passing in a string as the initializer of our I18N class, effectively controlling the language our GUI displays.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch08lvl1sec73"/>Localizing the GUI</h1></div></div></div><p>After <a id="id328" class="indexterm"/>the first step of internationalizing our GUI, the next step is to localize it. Why would we wish to do this?</p><p>Well, here in the United States of America, we are all cowboys and we live in different time zones.</p><p>So while we are "internationalized" to the USA, our horses do wake up in different time zones (and do expect to be fed according to their own inner horse time zone schedule).</p><p>This is where localization comes in.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec188"/>Getting ready</h2></div></div></div><p>We are extending the GUI we developed in the previous recipe by localizing it.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec189"/>How to do it...</h2></div></div></div><p>We start by first installing the Python pytz time zone module, using pip. We type the following<a id="id329" class="indexterm"/> command in a command processor prompt:</p><div><pre class="programlisting">
<strong>pip install pytz</strong>
</pre></div><div><div><h3 class="title"><a id="note100"/>Note</h3><p>In this book, we are using Python 3.4, which comes with the <code class="literal">pip</code> module built-in. If you are using an older version of Python, then you might have to install the <code class="literal">pip</code> module first.</p></div></div><p>When successful, we get the following result.</p><div><img src="img/B04829_08_05.jpg" alt="How to do it..."/></div><div><div><h3 class="title"><a id="note101"/>Note</h3><p>The screenshot shows that the command downloaded the <code class="literal">.whl</code> format. If you have not done so, you might have to install the Python <code class="literal">wheel</code> module first.</p></div></div><p>This installed the Python <code class="literal">pytz</code> module into the <code class="literal">site-packages</code> folder, so now we can import this module from our Python GUI code.</p><p>We can list all the existing time zones by running the following code, which will display the time zones in our <code class="literal">ScrolledText</code> widget. First we add a new <code class="literal">Button</code> widget to our GUI.</p><div><pre class="programlisting">import pytz
class OOP():
    
    # TZ Button callback
    def allTimeZones(self):
        for tz in all_timezones:
            self.scr.insert(tk.INSERT, tz + '\n')
    

    def createWidgets(self):
        # Adding a TZ Button
        self.allTZs = ttk.Button(self.widgetFrame, 
                                 text=self.i18n.timeZones, 
                                 command=self.allTimeZones)
        self.allTZs.grid(column=0, row=9, sticky='WE')</pre></div><p>Clicking<a id="id330" class="indexterm"/> our new <code class="literal">Button</code> widget results in the following output:</p><div><img src="img/B04829_08_06.jpg" alt="How to do it..."/></div><p>After we install the tzlocal Python module, we can print our current locale by running the following code:</p><div><pre class="programlisting">    # TZ Local Button callback
    def localZone(self):   
        from tzlocal import get_localzone
        self.scr.insert(tk.INSERT, get_localzone())

    def createWidgets(self):
        # Adding local TZ Button
        self.localTZ = ttk.Button(self.widgetFrame, 
                                  text=self.i18n.localZone, 
                                  command=self.localZone
        self.localTZ.grid(column=1, row=9, sticky='WE')</pre></div><p>We have internationalized the strings of our two new action <code class="literal">Buttons</code> in <code class="literal">Resources.py</code>.</p><p>English version:</p><div><pre class="programlisting">        self.timeZones = "All Time Zones"
        self.localZone = "Local Zone"</pre></div><p>German version:</p><div><pre class="programlisting">        self.timeZones = "Alle Zeitzonen"
        self.localZone = "Lokale Zone"</pre></div><p>Clicking our new button now tells us which time zone we are in (hey, we didn't know that, didn't we…).</p><div><img src="img/B04829_08_07.jpg" alt="How to do it..."/></div><p>We can <a id="id331" class="indexterm"/>now translate our local time to a different time zone. Let's use USA Eastern Standard Time as an example.</p><p>We display our current local time in our unused Label 2 by improving our existing code.</p><div><pre class="programlisting">import pytz
from datetime import datetime
class OOP():
    # Format local US time
    def getDateTime(self):
        fmtStrZone = ""%Y-%m-%d %H:%M:%S""
        self.lbl2.set(datetime.now().strftime(fmtStrZone))

        # Place labels into the container element
        ttk.Label(labelsFrame, text=self.i18n.chooseNumber).grid(column=0, row=0)
        self.lbl2 = tk.StringVar()
        self.lbl2.set(self.i18n.label2)
        ttk.Label(labelsFrame, textvariable=self.lbl2).grid(column=0, row=1)
        
        # Adding getTimeTZ Button
        self.dt = ttk.Button(self.widgetFrame, text=self.i18n.getTime, command=self.getDateTime)
        self.dt.grid(column=2, row=9, sticky='WE')</pre></div><p>When we run the code, our internationalized Label 2 (displayed as <code class="literal">Etikette 2</code> in German) will display the current local time.</p><div><img src="img/B04829_08_08.jpg" alt="How to do it..."/></div><p>We can <a id="id332" class="indexterm"/>now change our local time to US EST by first converting it to <strong>Coordinated Universal Time</strong> (<strong>UTC</strong>) and then applying the <code class="literal">timezone</code> function from<a id="id333" class="indexterm"/> the imported <code class="literal">pytz</code> module.</p><div><pre class="programlisting">import pytz
class OOP():
    # Format local US time with TimeZone info
    def getDateTime(self):
        fmtStrZone = "%Y-%m-%d %H:%M:%S %Z%z"
        # Get Coordinated Universal Time
        utc = datetime.now(timezone('UTC'))
        print(utc.strftime(fmtStrZone))
        
        # Convert UTC datetime object to Los Angeles TimeZone
        la = utc.astimezone(timezone('America/Los_Angeles'))
        print(la.strftime(fmtStrZone))

        # Convert UTC datetime object to New York TimeZone
        ny = utc.astimezone(timezone('America/New_York'))
        print(ny.strftime(fmtStrZone))
        
        # update GUI label with NY Time and Zone
        self.lbl2.set(ny.strftime(fmtStrZone))</pre></div><p>Clicking the button now renamed as New York results in the following output:</p><div><img src="img/B04829_08_09.jpg" alt="How to do it..."/></div><p>Our Label 2 got<a id="id334" class="indexterm"/> updated with the current time in New York and we are printing the UTC times of the cities Los Angeles and New York with their respective time zone conversions, relative to UTC time to the Eclipse console, using a US date formatting string.</p><div><img src="img/B04829_08_10.jpg" alt="How to do it..."/></div><div><div><h3 class="title"><a id="note102"/>Note</h3><p>UTC <a id="id335" class="indexterm"/>never observes Daylight Saving Time. During <strong>Eastern Daylight Time</strong> (<strong>EDT</strong>) UTC is four <a id="id336" class="indexterm"/>hours ahead and during <strong>Standard Time</strong> (<strong>EST</strong>) it is five hours ahead of the local time.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec190"/>How it works...</h2></div></div></div><p>In order to localize date and time information, we first need to convert our local time to UTC time. We then apply <code class="literal">timezone</code> information and use the <code class="literal">astimezone</code> function from the <code class="literal">pytz</code> Python time zone module to convert to any time zone in the entire world!</p><p>In this recipe, we have converted the local time of the USA west coast to UTC and then displayed the USA east coast time in Label 2 of our GUI.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch08lvl1sec74"/>Preparing the GUI for internationalization</h1></div></div></div><p>In this<a id="id337" class="indexterm"/> recipe, we will prepare our GUI for internationalization by realizing that not all is as easy as could be expected when translating English into foreign languages.</p><p>We still have one problem to solve and that is how to properly display non-English Unicode characters from foreign languages.</p><p>One might expect that displaying the German ä, ö, and ü Unicode umlaut characters would be handled by Python 3 automatically, but this is not the case.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec191"/>Getting ready</h2></div></div></div><p>We will continue to use the Python GUI we developed in recent chapters. First, we will change the default language to German in the <code class="literal">GUI.py</code> initialization code.</p><p>We do this by uncommenting the line <code class="literal">self.i18n = I18N('de')</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec192"/>How to do it...</h2></div></div></div><p>When we change the word <code class="literal">Ueber</code> to the correct German <code class="literal">Űber</code> using the umlaut character, the Eclipse PyDev plugin is not too happy.</p><div><img src="img/B04829_08_11.jpg" alt="How to do it..."/></div><p>We get an error message, which is a little bit confusing, because when we run the same line of code from within the Eclipse PyDev Console, we get the expected result.</p><div><img src="img/B04829_08_12.jpg" alt="How to do it..."/></div><p>When we ask for the Python default encoding, we get the expected result, which is UTF-8.</p><div><img src="img/B04829_08_13.jpg" alt="How to do it..."/></div><div><div><h3 class="title"><a id="note103"/>Note</h3><p>We can, of course, always resort to the direct representation of Unicode.</p></div></div><p>Using<a id="id338" class="indexterm"/> Windows' built-in character map, we can find the Unicode representation of the umlaut character, which is U+00DC for the capital U with an umlaut.</p><div><img src="img/B04829_08_14.jpg" alt="How to do it..."/></div><p>While this workaround is truly ugly, it does the trick. Instead of typing in the literal character Ü, we can pass in the Unicode of \u00DC to get this character correctly displayed in our GUI.</p><div><img src="img/B04829_08_15.jpg" alt="How to do it..."/></div><p>We <a id="id339" class="indexterm"/>can also just accept the change in the default encoding from Cp1252 to UTF-8 using PyDev with Eclipse, but we might not always get the prompt to do so.</p><p>Instead, we might see the following error message displayed:</p><div><img src="img/B04829_08_16.jpg" alt="How to do it..."/></div><p>The way to solve this problem is to change the PyDev project's <strong>Text file encoding</strong> property to UTF-8.</p><div><img src="img/B04829_08_17.jpg" alt="How to do it..."/></div><p>After<a id="id340" class="indexterm"/> changing the PyDev default encoding, we now can display those German umlaut characters. We also updated the title to use the correct German ä character.</p><div><img src="img/B04829_08_18.jpg" alt="How to do it..."/></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec193"/>How it works...</h2></div></div></div><p>Internationalization and working with foreign language Unicode characters is often not as straightforward as we would wish. Sometimes, we have to find workarounds and expressing Unicode characters via Python by using the direct representation by prepending <code class="literal">\u</code> can do the trick.</p><p>At other times, we just have to find the settings of our development environment to adjust.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch08lvl1sec75"/>How to design a GUI in an agile fashion</h1></div></div></div><p>The <a id="id341" class="indexterm"/>modern agile software development approach to design and coding came out of the lessons learned by software professionals. This method applies to a GUI as much as to any other code. One of the main keys of agile software development is the continuously applied process of refactoring.</p><p>One practical example of how refactoring our code can help us in our software development work is by first implementing some simple functionality using functions.</p><p>As our code grows in complexity, we might want to refactor our functions into methods of a class. This approach would enable us to remove global variables and also be more flexible about where inside the class we place methods.</p><p>While the functionality of our code has not changed, the structure has.</p><p>In this process, we code, test, refactor, and then test again. We do this in short cycles and often start with the minimum code required to get some functionality to work.</p><div><div><h3 class="title"><a id="note104"/>Note</h3><p>Test-driven software development is one particular style of the agile development methodology.</p></div></div><p>While our GUI is working nicely, our main <code class="literal">GUI.py</code> code has been ever increasing in complexity and it has started to get a little bit harder to maintain an overview of our code.</p><p>This means we need to refactor our code.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec194"/>Getting ready</h2></div></div></div><p>We will refactor the GUI we created in previous chapters. We will use the English version of the GUI.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec195"/>How to do it...</h2></div></div></div><p>We have already broken out all names our GUI displays when we internationalized it in the previous recipe. That was an excellent start to refactoring our code.</p><div><div><h3 class="title"><a id="note105"/>Note</h3><p>Refactoring is the process of improving the structure, readability, and maintainability of existing code. We are not adding new functionality.</p></div></div><p>In the previous chapters and recipes, we have been extending our GUI in a "Top-to-bottom" waterfall development approach, adding <code class="literal">import</code> to the top and code towards the bottom of the existing code.</p><p>While this was useful when looking at the code it now looks a little bit messy and we can improve this to help our future development.</p><p>Let us <a id="id342" class="indexterm"/>first clean up our <code class="literal">import</code> statement section, which currently looks like this:</p><div><pre class="programlisting">#======================
# imports
#======================
import tkinter as tk
from tkinter import ttk
from tkinter import scrolledtext
from tkinter import Menu
from tkinter import Spinbox
import B04829_Ch08_ToolTip as tt
from threading import Thread
from time import sleep
from queue import Queue
from tkinter import filedialog as fd
from os import path 
from tkinter import messagebox as mBox
from B04829_Ch08_MySQL import MySQL
from B04829_Ch08_Resources import I18N
from datetime import datetime
from pytz import all_timezones, timezone

# Module level GLOBALS
GLOBAL_CONST = 42</pre></div><p>By simply grouping related imports, we can reduce the number of lines of code, which improves the readability of our imports, making them appear less overwhelming.</p><div><pre class="programlisting">#======================
# imports
#======================
import tkinter as tk
from tkinter import ttk, scrolledtext, Menu, Spinbox, filedialog as fd, messagebox as mBox
from queue import Queue
from os import path 
import B04829_Ch08_ToolTip as tt
from B04829_Ch08_MySQL import MySQL
from B04829_Ch08_Resources import I18N
from B04829_Ch08_Callbacks_Refactored import Callbacks
from B04829_Ch08_Logger import Logger, LogLevel

# Module level GLOBALS
GLOBAL_CONST = 42</pre></div><p>We can further refactor our code by breaking out the callback methods into their own modules. This improves readability by separating the different import statements into the modules they are required in.</p><p>Let us <a id="id343" class="indexterm"/>rename our <code class="literal">GUI.py</code> as <code class="literal">GUI_Refactored.py</code> and create a new module, which we name <code class="literal">Callbacks_Refactored.py</code>.</p><p>This gives us this new architecture.</p><div><pre class="programlisting">#======================
# imports
#======================
import tkinter as tk
from tkinter import ttk, scrolledtext, Menu, Spinbox, \
                    filedialog as fd, messagebox as mBox
from queue import Queue
from os import path 
import B04829_Ch08_ToolTip as tt
from B04829_Ch08_MySQL import MySQL
from B04829_Ch08_Resources import I18N
from B04829_Ch08_Callbacks_Refactored import Callbacks

# Module level GLOBALS
GLOBAL_CONST = 42

class OOP():
    def __init__(self): 
    
        # Callback methods now in different module
        self.callBacks = Callbacks(self)</pre></div><p>Note how we are passing in an instance of our own GUI class (<code class="literal">self</code>) when calling the <code class="literal">Callbacks</code> initializer.</p><p>Our new <code class="literal">Callbacks</code> class is as follows:</p><div><pre class="programlisting">#======================
# imports
#======================
import tkinter as tk
from time import sleep
from threading import Thread
from pytz import all_timezones, timezone
from datetime import datetime

class Callbacks():
    def __init__(self, oop):
        self.oop = oop
        
    def defaultFileEntries(self): 
        self.oop.fileEntry.delete(0, tk.END)
        self.oop.fileEntry.insert(0, 'Z:\\')        # bogus path
        self.oop.fileEntry.config(state='readonly')         
        self.oop.netwEntry.delete(0, tk.END)
        self.oop.netwEntry.insert(0, 'Z:\\Backup')  # bogus path
    
    # Combobox callback 
    def _combo(self, val=0):
        value = self.oop.combo.get()
        self.oop.scr.insert(tk.INSERT, value + '\n')</pre></div><p>In the <a id="id344" class="indexterm"/>initializer of our new class, the passed-in GUI instance is saved under the name <code class="literal">self.oop</code> and used throughout this new Python class module.</p><p>Running the refactored GUI code still works. We have only increased readability and reduced the complexity of our code in preparation for further development work.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec196"/>How it works...</h2></div></div></div><p>We have first improved the readability of our code by grouping related import statements. We next broke out the callback methods into their own class and module in order to further reduce the complexity of our code.</p><p>We had already taken the same OOP approach by having the <code class="literal">ToolTip</code> class reside in its own module and by internationalizing all GUI strings in the previous recipes.</p><p>In this recipe, we went one step further in refactoring by passing our own instance into the callback method's class our GUI relies upon.</p><div><div><h3 class="title"><a id="note106"/>Note</h3><p>Now that we better understand the value of a modular approach to software development, we will most likely start with this approach in our future software designs.</p></div></div></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch08lvl1sec76"/>Do we need to test the GUI code?</h1></div></div></div><p>Testing<a id="id345" class="indexterm"/> our software is an important activity during the coding phase, as well as when releasing service packs or bug fixes.</p><p>There are different levels of testing. The first level is developer testing, which often starts with the compiler or interpreter not letting us run our buggy code forcing us to test small parts of our code on the level of individual methods.</p><p>This is<a id="id346" class="indexterm"/> the first level of defense.</p><p>A second level of coding defensively is when our source code control system tells us about some conflicts to be resolved and does not let us check in our modified code.</p><p>This is very useful and absolutely necessary when we work professionally in a team of developers. The source code control system is our friend and points out changes that have been committed to a particular branch or top-of-tree either by ourselves or by our other developers, and tells us that our local version of the code is both outdated and has some conflicts that need to be resolved before we can submit our code into the repository.</p><p>This part assumes you use a source control system to manage and store your code. Examples include git, mercurial, svn, and several others. Git is a very popular source control and it is free for a single user.</p><p>A third level is the level of APIs where we encapsulate potential future changes to our code by only allowing interactions with our code via published interfaces.</p><div><div><h3 class="title"><a id="note107"/>Note</h3><p>Please refer to "Program to an Interface, never an Implementation", <em>Design Patterns</em>, Page 17.</p></div></div><p>Another level of testing is integration testing, when half of the bridge we finally built meets the other half that the other development teams created and the two don't meet at the same height (say, one half ended up two meters or yards higher than the other half…).</p><p>Then, there is end user testing. While we built what they specified, it is not really what they wanted.</p><p>Oh well…I guess all of the preceding examples are valid reasons why we need to test our code both in the design and implementation stages.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec197"/>Getting ready</h2></div></div></div><p>We will test the GUI we have created in recent recipes and chapters. We will also show some simple examples of what can go wrong and why we need to keep testing our code and code we do call via APIs.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec198"/>How to do it...</h2></div></div></div><p>While many experienced developers grew up sprinkling <code class="literal">printf()</code> statements all over their code while debugging, many developers in the 21st century are accustomed to modern IDE development environments that efficiently speed up development time.</p><p>In this book, we are using the PyDev Python plug-in for the Eclipse IDE.</p><p>If you are just starting using an IDE like Eclipse with the PyDev plug-in, it might be a little bit overwhelming at first. The Python IDLE tool that ships with Python 3 also has a simpler debugger and you might wish to explore that first.</p><p>Whenever<a id="id347" class="indexterm"/> something goes wrong in our code, we have to debug it. The first step in doing this is to set break points and then step through our code, line by line, or method by method.</p><p>Stepping in and out of our code is a daily activity until the code runs smoothly.</p><p>In Python GUI programming, one of the first things that can go wrong is missing out on importing the required modules or importing existing modules.</p><p>Here is a simple example:</p><div><img src="img/B04829_08_19.jpg" alt="How to do it..."/></div><p>We are trying to create an instance of the tkinter class but things don't work as expected.</p><p>Well, we simply forgot to import the module and we can fix this by adding a line of Python code above our class creation, where the import statements live.</p><div><pre class="programlisting">#======================
# imports
#======================
import tkinter as tk</pre></div><p>This is an example in which our development environment does the testing for us. We just have to do the debugging and code fixing.</p><p>Another example more closely related to developer testing is when we code conditionals and, during our regular development, do not exercise all branches of logic.</p><p>Using an <a id="id348" class="indexterm"/>example from the previous chapter, let's say we click on the <strong>Get Quotes</strong> button and this works, but we never clicked on the <strong>Mody Quote</strong> button. The first button click creates the desired result, but the second throws an exception (because we had not yet implemented this code and probably forgot all about it).</p><div><img src="img/B04829_08_20.jpg" alt="How to do it..."/></div><p>Clicking the <strong>Mody Quote</strong> button creates the following result:</p><div><img src="img/B04829_08_21.jpg" alt="How to do it..."/></div><p>Another potential area of bugs is when a function or method suddenly no longer returns the expected result. Let's say we are calling the following function, which returns the expected result.</p><div><img src="img/B04829_08_22.jpg" alt="How to do it..."/></div><p>Then, someone<a id="id349" class="indexterm"/> makes a mistake, and we no longer get the previous results.</p><div><img src="img/B04829_08_23.jpg" alt="How to do it..."/></div><p>Instead of multiplying, we are raising by the power of the passed in number, and the result is no longer what it used to be.</p><div><div><h3 class="title"><a id="note108"/>Note</h3><p>In software testing, this sort of bug is called regression.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec199"/>How it works...</h2></div></div></div><p>In this recipe, we emphasized the importance of software testing during several phases of the software development life cycle by showing several examples of where code can go wrong and introduce software defects (aka bugs).</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch08lvl1sec77"/>Setting debug watches</h1></div></div></div><p>In<a id="id350" class="indexterm"/> modern <strong>Integrated Development Environments</strong> (<strong>IDEs</strong>) like <a id="id351" class="indexterm"/>the PyDev plugin in Eclipse or another IDE such as NetBeans, we can set debug watches to monitor the state of our GUI during the execution of our code.</p><p>This is very similar to the Microsoft IDEs of Visual Studio and the more recent versions of Visual Studio.NET.</p><div><div><h3 class="title"><a id="note109"/>Note</h3><p>Setting debug watches is a very convenient way to help our development efforts.</p></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec200"/>Getting ready</h2></div></div></div><p>In this recipe, we will reuse the Python GUI we developed in earlier recipes. We are stepping through the code we previously developed and setting debug watches.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec201"/>How to do it...</h2></div></div></div><div><div><h3 class="title"><a id="note110"/>Note</h3><p>While this recipe applies to the PyDev plugin in the Java-based Eclipse IDE, its principles also apply to many modern IDEs.</p></div></div><p>The first position where we might wish to place a breakpoint is at the place where we make our GUI visible by calling the tkinter main event loop.</p><p>The green balloon symbol on the left is a breakpoint in PyDev/Eclipse. When we execute our code in debug mode, once the execution reaches the breakpoint, the execution of the code will be halted. At this point, we can see the values of all variables that are currently in scope. We can also type expressions into one of the debugger windows which will execute them, showing us the results. If the result is what we want, we might decide to change our code using what we have just learned.</p><p>We normally step through the code by either clicking an icon in the toolbar of our IDE or by using a keyboard shortcut (like pressing <em>F5</em> to step into code, <em>F6</em> to step over, and <em>F7</em> to step out of the current method).</p><div><img src="img/B04829_08_24.jpg" alt="How to do it..."/></div><p>Placing the breakpoint where we did and then stepping into this code turns out to be a problem because we end up in some low-level tkinter code we really do not wish to debug right <a id="id352" class="indexterm"/>now. We get out of the low-level tkinter code by clicking the Step-Out toolbar icon (which is the third yellow arrow on the right below the project menu) or by pressing <em>F7</em> (assuming we are using PyDev in Eclipse).</p><p>We started the debugging session by clicking the bug toolbar icon towards the right of the screenshot. If we execute without debugging, we click the green circle with the white triangle inside it, which is the icon to the right of the bug icon.</p><div><img src="img/B04829_08_25.jpg" alt="How to do it..."/></div><p>A better idea is to place our breakpoint closer to our own code in order to watch the values of some of our own Python variables.</p><p>In the event-driven world of modern GUIs, we have to place our breakpoints at code that gets invoked during events, for example button clicks.</p><p>Currently, one of our main functionalities resides in a button click event. When we click the button labeled <strong>New York</strong>, we create an event that then results in something happening in our GUI.</p><p>Let's place a breakpoint at the <strong>New York</strong> button callback method, which we named <code class="literal">getDateTime()</code>.</p><p>When we <a id="id353" class="indexterm"/>now run a debug session, we will stop at the breakpoint and then we can enable watches of variables that are in scope.</p><p>Using PyDev in Eclipse, we can right-click a variable and then select the watch command from the pop-up menu. The name of the variable, its type, and current value will be displayed in the expressions debug window shown in the next screenshot. We can also directly type into the expressions window.</p><p>The variables we are watching are not limited to simple data types. We can watch class instances, lists, dictionaries, and so on.</p><p>When watching these more complex objects, we can expand them in the expressions window and drill down into all of the values of the class instances, dictionaries, and so on.</p><p>We do this by clicking on the triangle to the left of our watched variable that appears left-most under the <strong>Name</strong> column next to each variable.</p><div><img src="img/B04829_08_26.jpg" alt="How to do it..."/></div><p>While we<a id="id354" class="indexterm"/> are printing out the values of the different time zone locations, in the long term, it is much more convenient and efficient to set debug watches. We do not have to clutter our code with old-fashioned C-style <code class="literal">printf()</code> statements.</p><div><div><h3 class="title"><a id="note111"/>Note</h3><p>If you are interested in learning how to install Eclipse with the PyDev plugin for Python, there is a great tutorial that will get you started installing all the necessary free software and then introduce you to PyDev <a id="id355" class="indexterm"/>within Eclipse by creating a simple, working Python program. <a class="ulink" href="http://www.vogella.com/tutorials/Python/article.html">http://www.vogella.com/tutorials/Python/article.html</a>
</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec202"/>How it works...</h2></div></div></div><p>We use<a id="id356" class="indexterm"/> modern Integrated Development Environments (IDEs) in the 21st century that are freely available to help us to create solid code.</p><p>This recipe showed how to set debug watches, which is a fundamental tool in every developer's skill set. Stepping through our own code even when not hunting down bugs ensures that we understand our code and can lead to improving our code via refactoring.</p><p>The following is a quote from the first programming book I read, <em>Thinking in Java</em>, written by Bruce Eckel.</p><div><table border="0" width="100%" cellspacing="0" cellpadding="0" class="blockquote" summary="Block quote"><tr><td valign="top"> </td><td valign="top"><p><em>"Resist the urge to hurry, it will only slow you down."</em></p></td><td valign="top"> </td></tr><tr><td valign="top"> </td><td colspan="2" align="right" valign="top" style="text-align: center">--<em>Bruce Eckel</em></td></tr></table></div><p>Almost two decades later, this advice has passed the test of time.</p><div><div><h3 class="title"><a id="note112"/>Note</h3><p>Debug watches help us to create solid code and are not a waste of time.</p></div></div></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch08lvl1sec78"/>Configuring different debug output levels</h1></div></div></div><p>In this recipe,<a id="id357" class="indexterm"/> we will configure different debug levels that we can select and change at runtime. This allows us to control how much we want to drill down into our code when debugging our code.</p><p>We will create two new Python classes and place both of them into the same module.</p><p>We will use four different logging levels and we will write our debugging output to a log file we will create. If the log folder does not exist, we will create it automatically as well.</p><p>The name of the log file is the name of the executing script which is our refactored <code class="literal">GUI.py</code>. We can also choose other names for our log files by passing in the full path to the initializer of our logger class.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec203"/>Getting ready</h2></div></div></div><p>We will continue to use our refactored <code class="literal">GUI.py</code> code from the previous recipe.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec204"/>How to do it...</h2></div></div></div><p>First, we create a new Python module into which we place two new <code class="literal">classes</code>. The first <code class="literal">class</code> is very simple and defines the logging levels. This is basically an <code class="literal">enumeration</code>.</p><div><pre class="programlisting">class LogLevel:
'''Define logging levels.'''
    OFF     = 0
    MINIMUM = 1
    NORMAL  = 2
    DEBUG   = 3</pre></div><p>The<a id="id358" class="indexterm"/> second <code class="literal">class</code> creates a log file by using the passed in full path of the file name and places this into a <code class="literal">logs</code> folder. On first run, the <code class="literal">logs</code> folder might not exist so the code automatically creates the folder.</p><div><pre class="programlisting">class Logger:   
    ''' Create a test log and write to it. '''     
    #-------------------------------------------------------
    def __init__(self, fullTestName, loglevel=LogLevel.DEBUG):
        testName = os.path.splitext(os.path.basename(fullTestName))[0]
        logName  = testName  + '.log'    
                   
        logsFolder = 'logs'          
        if not os.path.exists(logsFolder):                     
            os.makedirs(logsFolder, exist_ok = True)
            
        self.log = os.path.join(logsFolder, logName)           
        self.createLog()
        
        self.loggingLevel = loglevel
        self.startTime    = time.perf_counter()
    
    #------------------------------------------------------
    def createLog(self):    
        with open(self.log, mode='w', encoding='utf-8') as logFile:
            logFile.write(self.getDateTime() + 
                          '\t\t*** Starting Test ***\n')
        logFile.close()</pre></div><p>In order to write to our log file, we use the <code class="literal">writeToLog()</code> method. Inside the method, the first thing we do is check if the message has a logging level higher than the limit we set our desired logging output to. If the message has a lower level, we discard it and immediately return from the method.</p><p>If the message has a logging level that we want to display, we then check if it starts with a newline character, and if it does, we discard the newline by slicing the method starting at index 1, using Python's slice operator (<code class="literal">msg = msg[1:]</code>).</p><p>We then <a id="id359" class="indexterm"/>write one line to our log file consisting of the current date timestamp, two tab spaces, our message, and ending in a newline character.</p><div><pre class="programlisting">    def writeToLog(self, msg='', loglevel=LogLevel.DEBUG): 
        # control how much gets logged
        if loglevel &gt; self.loggingLevel:
            return
        
        # open log file in append mode 
        with open(self.log, mode='a', encoding='utf-8') as logFile:
            msg = str(msg)
            if msg.startswith('\n'):
                msg = msg[1:]
            logFile.write(self.getDateTime() + '\t\t' + msg + '\n')
                
        logFile.close()</pre></div><p>We can now import our new Python module, and inside the <code class="literal">__init__</code> section of our GUI code, we can create an instance of the <code class="literal">Logger</code> class.</p><div><pre class="programlisting">from os import path 
from B04829_Ch08_Logger import Logger
class OOP():
    def __init__(self): 
        # create Logger instance
        fullPath = path.realpath(__file__)
        self.log = Logger(fullPath)
        print(self.log)</pre></div><p>We are retrieving the full path to our running GUI script via <code class="literal">path.realpath(__file__)</code> and passing this into the initializer of the <code class="literal">Logger</code> class. If the <code class="literal">logs</code> folder does not exist, it will automatically get created by our Python code.</p><p>This creates the following results:</p><div><img src="img/B04829_08_27.jpg" alt="How to do it..."/></div><p>The preceding screenshot shows that we created an instance of our new <code class="literal">Logger</code> class and the screenshot below shows that both the <code class="literal">logs</code> folder as well as the log were created.</p><div><img src="img/B04829_08_28.jpg" alt="How to do it..."/></div><p>When we open up the log, we can see that the current date and time as well as a default string have been written into the log.</p><div><img src="img/B04829_08_29.jpg" alt="How to do it..."/></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec205"/>How it works...</h2></div></div></div><p>In this recipe, we created our own logging class. While Python ships with a Logging module, it is very easy to create our own, which gives us absolute control over our logging format. This is very useful when we combine our own logging output with MS Excel or the Matplotlib we explored in previous recipes in a previous chapter.</p><p>In the next recipe, we will use Python's built-in <code class="literal">__main__</code> functionality to use the four different <a id="id360" class="indexterm"/>logging levels we have just created.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch08lvl1sec79"/>Creating self-testing code using Python's __main__ section</h1></div></div></div><p>Python<a id="id361" class="indexterm"/> comes with a very nice feature<a id="id362" class="indexterm"/> that enables each module to self-test. Making use of this feature is a great way of making sure that changes to our code do not break existing code and, additionally, the <code class="literal">__main__</code> self-testing section can serve as documentation for how each module works.</p><div><div><h3 class="title"><a id="note113"/>Note</h3><p>After a few months or years, we sometimes forget what our code is doing, so having an explanation written in the code itself is indeed a great help.</p></div></div><p>It is a good idea to always add a self-testing section to every Python module, when possible. It is sometimes not possible, but, in most modules, it is possible to do so.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec206"/>Getting ready</h2></div></div></div><p>We will extend the previous recipe, so, in order to understand what the code in this recipe is doing, we have to first read and understand the code of the previous recipe.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec207"/>How to do it...</h2></div></div></div><p>First, we will explore the power of the Python <code class="literal">__main__</code> self-testing section by adding this self-testing section to our <code class="literal">Resources.py</code> module. Whenever we run a module that has this self-testing section located at the bottom of the module, when the module is executed by itself, this code will run.</p><p>When the module is imported and used from other modules, the code in the <code class="literal">__main__</code> self-testing section will not be executed.</p><p>This is the code that is also shown in the screenshot that follows:</p><div><pre class="programlisting">if __name__ == '__main__':
    language = 'en'
    inst = I18N(language)
    print(inst.title)
    
    language = 'de'
    inst = I18N(language)
    print(inst.title)</pre></div><p>After adding the self-testing section, we now can run this module by itself and it creates useful output, while, at the same time, showing us that our code works as intended.</p><div><img src="img/B04829_08_30.jpg" alt="How to do it..."/></div><p>We<a id="id363" class="indexterm"/> are first passing in English as the <a id="id364" class="indexterm"/>language to be displayed in our GUI, and then we pass in German as the language that our GUI will display.</p><p>We are printing out the title of our GUI to show that our Python module works as we intended it to work.</p><div><div><h3 class="title"><a id="note114"/>Note</h3><p>The next step is to use our logging capabilities which we created in the previous recipe.</p></div></div><p>We do this by first adding a <code class="literal">__main__</code> self-testing section to our refactored <code class="literal">GUI.py</code> module and we then verify that we created an instance of our <code class="literal">Logger</code> class.</p><div><img src="img/B04829_08_31.jpg" alt="How to do it..."/></div><p>We <a id="id365" class="indexterm"/>next write to our log file by using <a id="id366" class="indexterm"/>the command shown. We have designed our logging level to default to log every message, which is the DEBUG level and, because of this, we do not have to change anything. We just pass in the message to be logged to the <code class="literal">writeToLog</code> method.</p><div><pre class="programlisting">if __name__ == '__main__':
#======================
# Start GUI
#======================
oop = OOP()
    print(oop.log)
    oop.log.writeToLog('Test message')
    oop.win.mainloop()</pre></div><p>This gets written to our log file, as can be seen in the following screenshot of the log:</p><div><img src="img/B04829_08_32.jpg" alt="How to do it..."/></div><p>Now we can control the logging by adding logging levels to our logging statements and set the level we wish to output. Let's add this capability to our New York button callback method in the <code class="literal">Callbacks.py</code> module which is the <code class="literal">getDateTime</code> method.</p><p>We change the previous <code class="literal">print</code> statements to <code class="literal">log</code> statements using different debug levels.</p><p>In the <code class="literal">GUI.py</code>, we import both new classes from our logger module.</p><div><pre class="programlisting">from B04829_Ch08_Logger import Logger, LogLevel</pre></div><p>Next, we create local instances of those classes.</p><div><pre class="programlisting"># create Logger instance
fullPath = path.realpath(__file__)
self.log = Logger(fullPath)

# create Log Level instance
self.level = LogLevel()</pre></div><p>As <a id="id367" class="indexterm"/>we are passing in an instance <a id="id368" class="indexterm"/>of the GUI class to the <code class="literal">Callbacks.py</code> initializer, we can use logging level constraints according to the <code class="literal">LogLevel</code> class we have created.</p><div><pre class="programlisting">    # Format local US time with TimeZone info
    def getDateTime(self):
        fmtStrZone = "%Y-%m-%d %H:%M:%S %Z%z"
        # Get Coordinated Universal Time
        utc = datetime.now(timezone('UTC'))
        self.oop.log.writeToLog(utc.strftime(fmtStrZone), 
                                self.oop.level.MINIMUM)
        
        # Convert UTC datetime object to Los Angeles TimeZone
        la = utc.astimezone(timezone('America/Los_Angeles'))
        self.oop.log.writeToLog(la.strftime(fmtStrZone), 
                                self.oop.level.NORMAL)

        # Convert UTC datetime object to New York TimeZone
        ny = utc.astimezone(timezone('America/New_York'))
        self.oop.log.writeToLog(ny.strftime(fmtStrZone), 
                                self.oop.level.DEBUG)
        
        # update GUI label with NY Time and Zone
        self.oop.lbl2.set(ny.strftime(fmtStrZone))</pre></div><p>When we now click our New York button, depending upon the selected logging level, we get different output written to our log file. The default logging level is <code class="literal">DEBUG</code>, which means everything gets written to our log.</p><div><img src="img/B04829_08_33.jpg" alt="How to do it..."/></div><p>When we change the logging level, we control what gets written to our log. We do this by calling the <code class="literal">setLoggingLevel</code> method of the <code class="literal">Logger</code> class.</p><div><pre class="programlisting">    #----------------------------------------------------------------
    def setLoggingLevel(self, level):  
        '''change logging level in the middle of a test.''' 
        self.loggingLevel = level</pre></div><p>In<a id="id369" class="indexterm"/> the <code class="literal">__main__</code> section of our GUI, we <a id="id370" class="indexterm"/>change the logging level to <code class="literal">MINIMUM</code>, which results in reduced output written to our log file.</p><div><pre class="programlisting">if __name__ == '__main__':
#======================
# Start GUI
#======================
oop = OOP()
    oop.log.setLoggingLevel(oop.level.MINIMUM)
    oop.log.writeToLog('Test message')
    oop.win.mainloop()</pre></div><p>Now, our log file no longer shows the <code class="literal">Test Message</code> and only shows messages that meet the set logging level.</p><div><img src="img/B04829_08_34.jpg" alt="How to do it..."/></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec208"/>How it works...</h2></div></div></div><p>In this recipe, we are making good use of Python's built-in <code class="literal">__main__</code> self-testing section. We introduced our own logging file and, at the same time, how to create different logging levels.</p><p>By doing this, we have full control over what gets written to our log files.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch08lvl1sec80"/>Creating robust GUIs using unit tests</h1></div></div></div><p>Python <a id="id371" class="indexterm"/>comes with a built-in unit testing framework <a id="id372" class="indexterm"/>and, in this recipe, we will start to use this framework to test our Python GUI code.</p><p>Before we start to write unit tests, we want to design our testing strategy. We could easily intermix the unit tests with the code they are testing, but a better strategy is to separate the application code from the unit test code.</p><div><div><h3 class="title"><a id="note115"/>Note</h3><p>PyUnit has been designed according to the principles of all the other xUnit testing Frameworks.</p></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec209"/>Getting ready</h2></div></div></div><p>We will test the internationalized GUI we created earlier in this chapter.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec210"/>How to do it...</h2></div></div></div><p>In order to use Python's built-in unit testing framework, we have to import the Python <code class="literal">unittest</code> module. Let's create a new module and name it <code class="literal">UnitTests.py</code>.</p><p>We first import the <code class="literal">unittest</code> module, then we create our own class and within this class we inherit and extend the <code class="literal">unittest.TestCase</code> class.</p><p>The simplest code to do it looks like this:</p><div><pre class="programlisting">import unittest

class GuiUnitTests(unittest.TestCase):
    pass

if __name__ == '__main__':
    unittest.main()</pre></div><p>The code isn't doing much yet, but when we run it, we do not get any errors, which is a good sign.</p><div><img src="img/B04829_08_35.jpg" alt="How to do it..."/></div><p>We actually <a id="id373" class="indexterm"/>do get an output written to the console<a id="id374" class="indexterm"/> stating that we successfully ran zero tests…</p><p>Hmm, that output is a bit misleading as all we have done so far is create a class that contains no actual testing methods.</p><p>We add testing methods that do the actual unit testing by following the default naming for all test methods to start with the word "test". This is an option that can be changed but it seems to be much easier and clearer to stick to this naming convention.</p><p>Let's add a test method that will test the title of our GUI. This will verify that, by passing in the expected arguments, we get the expected result.</p><div><pre class="programlisting">import unittest
from B04829_Ch08_Resources import I18N

class GuiUnitTests(unittest.TestCase):
    
    def test_TitleIsEnglish(self):
        i18n = I18N('en')
        self.assertEqual(i18n.title, 
                       "Python Graphical User Interface")</pre></div><p>We are importing our <code class="literal">I18N</code> class from our <code class="literal">Resources.py</code> module, passing in English as the language to be displayed in our GUI. As this is our first unit test, we are printing out the Title result as well, just to make sure we know what we are getting back. We next use the <code class="literal">unittest assertEqual</code> method to verify that our title is correct.</p><p>Running this code gives us an <strong>OK</strong>, which means that the unit test passed.</p><div><img src="img/B04829_08_36.jpg" alt="How to do it..."/></div><p>The unit<a id="id375" class="indexterm"/> test runs and succeeds, which is indicated by <a id="id376" class="indexterm"/>one dot and the word "OK". If it had failed or gotten an error we would not have got the dot but an "F" or "E" as the output.</p><p>We can now do the same automated unit testing check by verifying the title for the German version of our GUI.</p><p>We simply copy, paste, and modify our code.</p><div><pre class="programlisting">import unittest
from B04829_Ch08_Resources import I18N

class GuiUnitTests(unittest.TestCase):
    
    def test_TitleIsEnglish(self):
        i18n = I18N('en')
        self.assertEqual(i18n.title, 
                         "Python Graphical User Interface")
        
    def test_TitleIsGerman(self):
        i18n = I18N('en')           
        self.assertEqual(i18n.title, 
                         'Python Grafische Benutzeroberfl' 
                       + "\u00E4" + 'che')</pre></div><p>Now we are testing our internationalized GUI title in two languages and getting the following result when running the code:</p><div><img src="img/B04829_08_37.jpg" alt="How to do it..."/></div><p>We<a id="id377" class="indexterm"/> ran two unit tests but, instead of an OK, we<a id="id378" class="indexterm"/> got a failure. What happened?</p><p>Our <code class="literal">assertion</code> failed for the German version of our GUI…</p><p>While debugging our code, it turns out that in the copy, paste, and modify approach of our unit test code, we forgot to pass in German as the language. We can easily fix this.</p><div><pre class="programlisting">    def test_TitleIsGerman(self):
        # i18n = I18N('en')           # &lt;= Bug in Unit Test
        i18n = I18N('de') 
        self.assertEqual(i18n.title, 
                         'Python Grafische Benutzeroberfl' 
                         + "\u00E4" + 'che')</pre></div><p>When we rerun our unit tests, we again get the expected result of all tests passing.</p><div><img src="img/B04829_08_38.jpg" alt="How to do it..."/></div><div><div><h3 class="title"><a id="note116"/>Note</h3><p>Unit testing code is code and can have bugs too.</p></div></div><p>While<a id="id379" class="indexterm"/> the purpose of writing unit tests is really to <a id="id380" class="indexterm"/>test our application code, we have to make sure that <a id="id381" class="indexterm"/>our tests are written correctly. One approach from the <strong>Test-Driven-Development</strong> (<strong>TDD</strong>) methodology might help us.</p><div><div><h3 class="title"><a id="note117"/>Note</h3><p>In TDD, we develop the unit tests before we actually write the application code. Now, if a test passes for a method that does not even exist, something is wrong. The next step is to create the non-existing method and make sure it will fail. After that, we can write the minimum amount of code necessary to make the unit test pass.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec211"/>How it works...</h2></div></div></div><p>In this recipe, we have begun to test our Python GUI, writing unit tests in Python. We have seen that Python unit test code is just code and can contain mistakes that need to be corrected. In the next recipe, we will extend this recipe's code and use the graphical unit test runner that comes with the PyDev plugin for the Eclipse IDE.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch08lvl1sec81"/>How to write unit tests using the Eclipse PyDev IDE</h1></div></div></div><p>In<a id="id382" class="indexterm"/> the previous recipe, we started to use <a id="id383" class="indexterm"/>Python's unit testing capabilities, and in this recipe, we will ensure the quality of our GUI code by further using this capability.</p><p>We will unit test our GUI in order to make sure that the internationalized strings our GUI displays are as expected.</p><p>In the previous recipe, we encountered some bugs in our unit testing code but, typically, our unit tests will find regression bugs that are caused by modifying existing application code, not the unit test code. Once we have verified that our unit testing code is correct, we do not usually change it.</p><div><div><h3 class="title"><a id="note118"/>Note</h3><p>Our unit tests also serve as documentation of what we expect our code to do.</p></div></div><p>By default, Python's unit tests are executed with a textural unit test runner and we can run this in the PyDev plug-in from within the Eclipse IDE. We can also run the very same unit tests from a console window.</p><p>In addition to the text runner in this recipe, we will explore PyDev's graphical unit test feature that can be used from within the Eclipse IDE.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec212"/>Getting ready</h2></div></div></div><p>We <a id="id384" class="indexterm"/>are extending the previous recipe, in<a id="id385" class="indexterm"/> which we began to use Python unit tests.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec213"/>How to do it...</h2></div></div></div><p>The Python <a id="id386" class="indexterm"/>unit testing framework comes with what are called fixtures.</p><p>Refer to<a id="id387" class="indexterm"/> the following URLs for a description of what a test fixture is:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><a class="ulink" href="https://docs.python.org/3.4/library/unittest.html">https://docs.python.org/3.4/library/unittest.html</a></li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="https://en.wikipedia.org/wiki/Test_fixture">https://en.wikipedia.org/wiki/Test_fixture</a></li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://www.boost.org/doc/libs/1_51_0/libs/test/doc/html/utf/user-guide/fixture.html">http://www.boost.org/doc/libs/1_51_0/libs/test/doc/html/utf/user-guide/fixture.html</a></li></ul></div><p>What this means is that we can create <code class="literal">setup()</code> and <code class="literal">teardown()</code> unit testing methods so that the <code class="literal">setup()</code> method is called at the beginning before any single test is executed, and at the end of every single unit test, the <code class="literal">teardown()</code> method is called.</p><div><div><h3 class="title"><a id="note119"/>Note</h3><p>This fixture capability provides us with a very controlled environment in which we can run our unit tests. It is similar to using pre- and post-conditions.</p></div></div><p>Let's set up our unit testing environment. We will create a new testing class which focuses on the previously mentioned correctness of code.</p><div><div><h3 class="title"><a id="note120"/>Note</h3><p>
<code class="literal">unittest.main()</code> runs any method that starts with the prefix "test", no matter how many classes we create within a given Python module.</p></div></div><div><pre class="programlisting">import unittest
from B04829_Ch08_Resources import I18N
from B04829_Ch08_GUI_Refactored import OOP as GUI

class GuiUnitTests(unittest.TestCase):
    
    def test_TitleIsEnglish(self):
        i18n = I18N('en')
        self.assertEqual(i18n.title, 
                         "Python Graphical User Interface")
        
    def test_TitleIsGerman(self):
        # i18n = I18N('en')           # &lt;= Bug in Unit Test
        i18n = I18N('de') 
        self.assertEqual(i18n.title, 
                         'Python Grafische Benutzeroberfl' 
                         + "\u00E4" + 'che')
 
class WidgetsTestsEnglish(unittest.TestCase):
     
    def setUp(self):
        self.gui = GUI('en')
        
    def tearDown(self):
        self.gui = None
         
    def test_WidgetLabels(self):
        self.assertEqual(self.gui.i18n.file, "File")
        self.assertEqual(self.gui.i18n.mgrFiles, ' Manage Files ')
        self.assertEqual(self.gui.i18n.browseTo, 
                                            "Browse to File...")
if __name__ == '__main__':
    unittest.main()</pre></div><p>This <a id="id388" class="indexterm"/>creates<a id="id389" class="indexterm"/> the following output:</p><div><img src="img/B04829_08_39.jpg" alt="How to do it..."/></div><p>The preceding unit testing code shows that we can create several unit testing classes and they can all be run in the same module by calling <code class="literal">unittest.main</code>.</p><p>It also shows that the <code class="literal">setup()</code> method does not count as a test in the output of the unit test report (the count of tests is 3) while, at the same time, it did its intended job as we can now access our class instance variable <code class="literal">self.gui</code> from within the unit test method.</p><p>We are interested in testing the correctness of all of our labels and especially catching bugs when we make changes to our code.</p><p>If we <a id="id390" class="indexterm"/>have copied and pasted strings <a id="id391" class="indexterm"/>from our application code to the testing code, it will catch any unintended changes with the click of a unit testing framework button.</p><p>We also want to test that invoking any of our <code class="literal">Radiobutton</code> widgets in any language results in the <code class="literal">labelframe</code> widget <code class="literal">text</code> being updated. In order to automatically test this, we have to do two things.</p><p>First, we have to retrieve the value of the <code class="literal">labelframe text</code> widget and assign the value to a variable we name <code class="literal">labelFrameText</code>. We have to use the following syntax because the properties of this widget are being passed in and retrieved via a dictionary data type:</p><div><pre class="programlisting">self.gui.widgetFrame['text']</pre></div><p>We can now verify the default text and then the internationalized versions after clicking one of the Radiobutton widgets programmatically.</p><div><pre class="programlisting">class WidgetsTestsGerman(unittest.TestCase):
     
    def setUp(self):
        self.gui = GUI('de')

    def test_WidgetLabels(self):
        self.assertEqual(self.gui.i18n.file, "Datei")
        self.assertEqual(self.gui.i18n.mgrFiles, 
                                        ' Dateien Organisieren ')
        self.assertEqual(self.gui.i18n.browseTo, 
                                        "Waehle eine Datei... ")
        
    def test_LabelFrameText(self):
        labelFrameText = self.gui.widgetFrame['text']
        self.assertEqual(labelFrameText, " Widgets Rahmen ")
        self.gui.radVar.set(1)
        self.gui.callBacks.radCall()
        labelFrameText = self.gui.widgetFrame['text']
        self.assertEqual(labelFrameText, 
                                    " Widgets Rahmen in Gold")</pre></div><p>After verifying the default <code class="literal">labelFrameText</code> we programmatically set the radio button to index 1 and then programmatically invoke the radio button's callback method.</p><div><pre class="programlisting">        self.gui.radVar.set(1)
        self.gui.callBacks.radCall()</pre></div><div><div><h3 class="title"><a id="note121"/>Note</h3><p>This is basically the same action as clicking the radio button in the GUI but we do this button click event via code in the unit tests.</p></div></div><p>Then<a id="id392" class="indexterm"/> we verify that our text in the <code class="literal">labelframe</code> widget has changed as intended.</p><p>When <a id="id393" class="indexterm"/>we run the unit tests from within Eclipse with the Python PyDev plugin, we get the following output written to the Eclipse console.</p><div><img src="img/B04829_08_40.jpg" alt="How to do it..."/></div><p>Run from a command prompt, we get similar output once we navigate to the folder where our code currently resides.</p><div><img src="img/B04829_08_41.jpg" alt="How to do it..."/></div><p>Using Eclipse, we can also choose to run our unit tests, not as a simple Python script, but as a Python unit test script, which gives us some colorful output instead of the black and white world of the old DOS prompt.</p><div><img src="img/B04829_08_42.jpg" alt="How to do it..."/></div><p>The<a id="id394" class="indexterm"/> unit testing result bar is green, which<a id="id395" class="indexterm"/> means that all our unit tests have passed. The preceding screenshot also shows that the GUI test runner is much slower than the textual test runner: 1.01 seconds compared to 0.466 seconds in Eclipse.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec214"/>How it works...</h2></div></div></div><p>We have extended our unit testing code by testing <code class="literal">labels</code>, programmatically invoking a <code class="literal">Radiobutton</code> and then verifying in our unit tests that the corresponding <code class="literal">text</code> property of the <code class="literal">labelframe</code> widget has changed as expected. We have tested two different languages.</p><p>We then moved on to use the built-in Eclipse/PyDev graphical unit test runner.</p></div></div></div>
</body></html>