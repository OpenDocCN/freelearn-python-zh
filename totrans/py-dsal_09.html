<html><head></head><body>
        <section>

            <header>
                <h1 class="header-title">Searching</h1>
            </header>

            <article>
                
<p>With the data structures that have been developed in the preceding chapters, one critical operation performed on all of them is searching. In this chapter, we shall explore the different strategies that can be used to find elements in a collection of items.</p>
<p>One other important operation that makes use of searching is sorting. It is virtually impossible to sort without some variant of a search operation. The "how of searching" is also important as it has a bearing on how quick a sorting algorithm ends up performing.</p>
<p>Searching algorithms are categorized under two broad types. One category assumes that the list of items to apply the searching operation on, has already been sorted whiles the other does not.</p>
<p>The performance of a search operation is heavily influenced by whether the items about to be searched have already been sorted or not as we will see in the subsequent topics too.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Linear Search</h1>
            </header>

            <article>
                
<p>Let us focus our discussions on linear search, performed on a typical Python list.</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="image-border" height="90" src="assets/image_09_001.jpg" width="349"/></div>
<p>The preceding list has elements that are accessible through the list index. To find an element in the list we employ the linear searching technique. This technique traverses the list of elements, by using the index to move from the beginning of the list to the end. Each element is examined and if it does not match the search item, the next item is examined. By hopping from one item to its next, the list is traversed sequentially.</p>
<div class="packt_infobox">In treating the sections in this chapter and others, we use a list with integers to enhance our understanding since integers lend themselves to easy comparison.</div>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Unordered linear search</h1>
            </header>

            <article>
                
<p>A list containing elements <strong>60</strong>, <strong>1</strong>, <strong>88</strong>, <strong>10</strong>, and <strong>100</strong> is an example of an unordered list. The items in the list have no order by magnitude. To perform a search operation on such a list, one proceeds from the very first item, compares that with the search item. If a match is not made the next element in the list is examined. This continues till we reach the last element in the list or until a match is made.</p>
<pre>
    def search(unordered_list, term): <br/>       unordered_list_size = len(unordered_list) <br/>        for i in range(unordered_list_size): <br/>            if term == unordered_list[i]: <br/>                return i <br/><br/>        return None 
</pre>
<p>The <kbd>search</kbd> function takes as parameters, the list that houses our data and the item that we are looking for called the <strong>search term</strong>.</p>
<p>The size of the array is obtained and determines the number of times the <kbd>for</kbd> loop is executed.</p>
<pre>
        if term == unordered_list[i]: <br/>            ... 
</pre>
<p>On every pass of the <kbd>for</kbd> loop, we test if the search term is equal to the item that the index points to. If true, then there is no need to proceed with the search. We return the position where the match occurred.</p>
<p>If the loop runs to the end of the list with no match being made, <kbd>None</kbd> is returned to signify that there is no such item in the list.</p>
<p>In an unordered list of items, there is no guiding rule for how elements are inserted. This therefore impacts the way the search is done. The lack of order means that we cannot rely on any rule to perform the search. As such, we must visit the items in the list one after the other. As can be seen in the following image, the search for the term <strong>66</strong>, starts from the first element and moves to next element in the list. Thus <strong>60</strong> compared with <strong>66</strong> and if it is not equal, we compare <strong>66</strong> with <strong>1</strong>, <strong>88</strong> and so on till we find the search term in the list.</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="image-border" height="183" src="assets/image_09_002.jpg" width="251"/></div>
<p>The unordered linear search has a worst case running time of <kbd>O(n)</kbd>. All the elements may need to be visited before finding the search term. This will be the case if the search term is located at the last position of the list.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Ordered linear search</h1>
            </header>

            <article>
                
<p>In the case where the elements of a list have been already sorted, our search algorithm can be improved. Assuming the elements have been sorted in ascending order, the search operation can take advantage of the ordered nature of the list to make search more efficient.</p>
<p>The algorithm is reduced to the following steps:</p>
<ol>
<li>Move through the list sequentially.</li>
<li>If a search item is greater than the object or item currently under inspection in the loop, then quit and return None.</li>
</ol>
<p>In the process of iterating through the list, if the search term is greater than the current item, then there is no need to continue with the search.</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="image-border" height="253" src="assets/image_09_003.jpg" width="427"/></div>
<p>When the search operation starts and the first element is compared with (<strong>5</strong>), no match is made. But because there are more elements in the list the search operation moves on to examine the next element. A more compelling reason to move on is that we know the search item may match any of the elements greater than <strong>2</strong>.</p>
<p>After the 4th comparison, we come to the conclusion that the search term, can not be found in any position above where <strong>6</strong> is located. In other words, if the current item is greater than the search term, then it means there is no need to further search the list.</p>
<pre>
    def search(ordered_list, term): <br/>        ordered_list_size = len(ordered_list) <br/>        for i in range(ordered_list_size): <br/>            if term == ordered_list[i]: <br/>                return i <br/>            elif ordered_list[i] &gt; term: <br/>                return None <br/><br/>        return None 
</pre>
<p>The <kbd>if</kbd> statement now caters for this check. The <kbd>elif</kbd> portion tests the condition where <kbd>ordered_list[i] &gt; term</kbd>. The method returns <kbd>None</kbd> if the comparison evaluates to <kbd>True</kbd>.</p>
<p>The last line in the method returns <kbd>None</kbd> because the loop may go through the list and still not find any element matching the search term.</p>
<p>The worst case time complexity of an ordered linear search is <kbd>O(n)</kbd>. In general, this kind of search is considered inefficient especially when dealing with large data sets.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Binary search</h1>
            </header>

            <article>
                
<p>A binary search is a search strategy used to find elements within a list by consistently reducing the amount of data to be searched and thereby increasing the rate at which the search term is found.</p>
<p>To use a binary search algorithm, the list to be operated on must have already been sorted.</p>
<p>The <em>binary</em> term carries a number of meanings and helps us put our minds in the right frame to understand the algorithm.</p>
<p>A binary decision has to be made at each attempt to find an item in the list. One critical decision is to guess which part of the list is likely to house the item we are looking for. Would the search term be in the first half of second half of the list, that is, if we always perceive the list as being comprised of two parts?</p>
<p>Instead of moving from one cell of the list to the other, if we employ the use of an educated guessing strategy, we are likely to arrive at the position where the item will be found much faster.</p>
<p>As an example, lets take it that we want to find the middle page of a 1000 page book. We already know that every book has its pages numbered sequentially from 1 upwards. So it figures that the 500th page should be found right at the middle of the book, instead of moving and flipping from page 1, 2 to reach the 500th page. Let's say we decide to now look for the page 250. We can still use our strategy to find the page easily. We guess that page 500 cuts the book in half. Page 250, will lay to the left of the book. No need to worry about whether we can find 250th page between page 500 and 1000 because it can never be found there. So using page 500 as reference, we can open to about half of the pages that lay between the 1st and 500th page. That brings us closer to finding the 250th page.</p>
<p>The following is the algorithm for conducting a binary search on an ordered list of items:</p>
<pre>
def binary_search(ordered_list, term): <br/><br/>    size_of_list = len(ordered_list) - 1 <br/><br/>    index_of_first_element = 0 <br/>    index_of_last_element = size_of_list <br/><br/>    while index_of_first_element &lt;= index_of_last_element: <br/>        mid_point = (index_of_first_element + index_of_last_element)/2 <br/><br/>        if ordered_list[mid_point] == term: <br/>            return mid_point <br/><br/>        if term &gt; ordered_list[mid_point]: <br/>            index_of_first_element = mid_point + 1 <br/>        else: <br/>            index_of_last_element = mid_point - 1 <br/><br/>    if index_of_first_element &gt; index_of_last_element: <br/>        return None 
</pre>
<p>Let's assume we have to find the position where the item <strong>10</strong> is located in the list as follows:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="image-border" height="124" src="assets/image_09_004.jpg" width="499"/></div>
<p>The algorithm uses a <kbd>while</kbd> loop to iteratively adjust the limits in the list within which to find a search term. So far as the difference between the starting index, <kbd>index_of_first_element</kbd> and the <kbd>index_of_last_element</kbd> index is positive, the <kbd>while</kbd> loop will run.</p>
<p>The algorithm first finds the mid point of the list by adding the index of the first element (<strong>0</strong>) to that of the last (<strong>4</strong>) and dividing it by <strong>2</strong> to find the middle index, <kbd>mid_point</kbd>.</p>
<pre>
mid_point = (index_of_first_element + index_of_last_element)/2 
</pre>
<p>In this case, <strong>10</strong> is not found at the middle position or index in the list. If we were searching for <strong>120</strong>, we would have had to adjust the <kbd>index_of_first_element</kbd> to <kbd>mid_point +1</kbd>. But because <strong>10</strong> lies on the other side of the list, we adjust <kbd>index_of_last_element</kbd> to <kbd>mid_point-1</kbd>:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="image-border" height="153" src="assets/image_09_005.jpg" width="423"/></div>
<p>With our new index of <kbd>index_of_first_element</kbd> and <kbd>index_of_last_element</kbd> now being <strong>0</strong> and <strong>1</strong> respectively, we compute the mid <kbd>(0 + 1)/2</kbd>, which equals <kbd>0</kbd>. The new midpoint is <strong>0</strong> , We find the middle item and compare with the search item, <kbd>ordered_list[0]</kbd> which yields the value <strong>10</strong>. Voila! Our search term is found.</p>
<p>This reduction of our list size by half, by re-adjusting the index of the <kbd>index_of_first_element</kbd> and <kbd>index_of_last_element</kbd> continues as long as <kbd>index_of_first_element</kbd> is less than <kbd>index_of_last_element</kbd>. When this fails to be the case it is most likely that our search term is not in the list.</p>
<p>The implementation here is an iterative one. We can also develop a recursive variant of the algorithm by applying the same principle of shifting the pointers that mark the beginning and ending of the search list.</p>
<pre>
def binary_search(ordered_list, first_element_index, last_element_index, term): <br/><br/>    if (last_element_index &lt; first_element_index): <br/>        return None <br/>    else: <br/>        mid_point = first_element_index + ((last_element_index - first_element_index) / 2) <br/><br/>        if ordered_list[mid_point] &gt; term: <br/>            return binary_search(ordered_list, first_element_index, mid_point-1,term) <br/>        elif ordered_list[mid_point] &lt; term: <br/>            return binary_search(ordered_list, mid_point+1, last_element_index, term) <br/>        else: <br/>            return mid_point 
</pre>
<p>A call to this recursive implementation of the binary search algorithm and its output is as follows:</p>
<pre>
    store = [2, 4, 5, 12, 43, 54, 60, 77]<br/>    print(binary_search(store, 0, 7, 2))   <br/><br/><strong>Output:</strong><br/><strong>&gt;&gt;</strong> <strong>0</strong>
</pre>
<p>There only distinction between the recursive binary search and the iterative binary search is the function definition and also the way in which <kbd>mid_point</kbd> is calculated. The calculation for the <kbd>mid_point</kbd> after the <kbd>((last_element_index - first_element_index) / 2)</kbd> operation must add its result to <kbd>first_element_index</kbd>. That way we define the portion of the list to attempt the search.</p>
<p>The binary search algorithm has a worst time complexity of <kbd>O(log n)</kbd>. The half-ing of the list on each iteration follows a log n of the number of elements progression.</p>
<div class="packt_infobox">It goes without saying that in <kbd>log x</kbd> is assumed to be referring to log base 2.</div>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Interpolation search</h1>
            </header>

            <article>
                
<p>There is another variant of the binary search algorithm that may closely be said to mimic more, how humans perform search on any list of items. It is still based off trying to make a good guess of where in a sorted list of items, a search item is likely to be found.</p>
<p>Examine the following list of items for example:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="image-border" height="91" src="assets/image_09_006.jpg" width="355"/></div>
<p>To find <strong>120</strong>, we know to look at the right hand portion of the list. Our initial treatment of binary search would typically examine the middle element first in order to determine if it matches the search term.</p>
<p>A more human thing would be to pick a middle element in a such a way as to not only split the array in half but to get as close as possible to the search term. The middle position was calculated for using the following rule:</p>
<pre>
mid_point = (index_of_first_element + index_of_last_element)/2 
</pre>
<p>We shall replace this formula with a better one that brings us close to the search term. <kbd>mid_point</kbd> will receive the return value of the <kbd>nearest_mid</kbd> function.</p>
<pre>
def nearest_mid(input_list, lower_bound_index, upper_bound_index, search_value): <br/>    return lower_bound_index + (( upper_bound_index -lower_bound_index)/ (input_list[upper_bound_index] -input_list[lower_bound_index])) * (search_value -input_list[lower_bound_index]) 
</pre>
<p>The <kbd>nearest_mid</kbd> function takes as arguments, the list on which to perform the search. The <kbd>lower_bound_index</kbd> and <kbd>upper_bound_index</kbd> parameters represent the bounds in the list within which we are hoping to find the search term. <kbd>search_value</kbd> represents the value being searched for.</p>
<p>These are used in the formula:</p>
<pre>
lower_bound_index + (( upper_bound_index - lower_bound_index)/ (input_list[upper_bound_index] - input_list[lower_bound_index])) * (search_value - input_list[lower_bound_index]) 
</pre>
<p>Given our search list, <strong>44</strong>, <strong>60</strong>, <strong>75</strong>, <strong>100</strong>, <strong>120</strong>, <strong>230</strong> and <strong>250</strong>, the <kbd>nearest_mid</kbd> will be computed with the following values:</p>
<pre>
lower_bound_index = 0<br/>upper_bound_index = 6<br/>input_list[upper_bound_index] = 250<br/>input_list[lower_bound_index] = 44<br/>search_value = 230
</pre>
<p>It can now be seen that, the <kbd>mid_point</kbd> will receive the value <strong>5</strong>, which is the index of the location of our search term. A binary search would have chosen <strong>100</strong> as the mid which will require another run of the algorithm.</p>
<p>A more visual illustration of how a typical binary search differs from an interpolation is given as follows. For a typical binary search finds the midpoint like so:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="image-border" height="145" src="assets/image_09_007.jpg" width="316"/></div>
<p>One can see that the midpoint is actually standing approximately in the middle of the preceding list. This is as a result of dividing by list 2.</p>
<p>An interpolation search on the other hand would move like so:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="image-border" height="150" src="assets/image_09_008.jpg" width="316"/></div>
<p>In interpolation search, our midpoint is swayed more to the left or right. This is caused by the effect of the multiplier used when dividing to obtain the midpoint. From the preceding image, our midpoint has been skewed to the right.</p>
<p>The remainder of the interpolation algorithm remains the same as that of the binary search except for the way the mid position is calculated for.</p>
<pre>
def interpolation_search(ordered_list, term): <br/><br/>    size_of_list = len(ordered_list) - 1 <br/><br/>    index_of_first_element = 0 <br/>    index_of_last_element = size_of_list <br/><br/>    while index_of_first_element &lt;= index_of_last_element: <br/>        mid_point = nearest_mid(ordered_list, index_of_first_element, index_of_last_element, term) <br/><br/>        if mid_point &gt; index_of_last_element or mid_point &lt; index_of_first_element: <br/>            return None <br/><br/>        if ordered_list[mid_point] == term: <br/>            return mid_point <br/><br/>        if term &gt; ordered_list[mid_point]: <br/>            index_of_first_element = mid_point + 1 <br/>        else: <br/>            index_of_last_element = mid_point - 1 <br/><br/>    if index_of_first_element &gt; index_of_last_element: <br/>        return None 
</pre>
<p>The <kbd>nearest_mid</kbd> function makes use of a multiplication operation. This can produce values that are greater than the <kbd>upper_bound_index</kbd> or lower than the <kbd>lower_bound_index</kbd>. When this occurs, it means the search term, <kbd>term</kbd>, is not in the list. <kbd>None</kbd> is therefore returned to represent this.</p>
<p>So what happens when <kbd>ordered_list[mid_point]</kbd> does not equal the search them? Well, we must now re-adjust the <kbd>index_of_first_element</kbd> and <kbd>index_of_last_element</kbd> such that the algorithm will focus on the part of the array that is likely to contain the search term. This is like exactly what we did in the binary search.</p>
<pre>
if term &gt; ordered_list[mid_point]: <br/>index_of_first_element = mid_point + 1 
</pre>
<p>If the search term is greater than the value stored at <kbd>ordered_list[mid_point]</kbd>, then we only adjust the <kbd>index_of_first_element</kbd> variable to point to the index <kbd>mid_point + 1</kbd>.</p>
<p>The following image shows how the adjustment occurs. The <kbd>index_of_first_element</kbd> is adjusted and pointed to the index of <kbd>mid_point+1.</kbd></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="image-border" height="175" src="assets/image_09_009.jpg" width="410"/></div>
<div class="packt_tip">The image only illustrates the adjustment of the midpoint. In interpolation rarely does the midpoint divide the list in 2 equal halves.</div>
<p>On the other hand, if the search term is lesser than the value stored at <kbd>ordered_list[mid_point]</kbd>, then we only adjust the <kbd>index_of_last_element</kbd> variable to point to the index <kbd>mid_point - 1</kbd>. This logic is captured in the else part of the if statement <kbd>index_of_last_element = mid_point - 1</kbd>.</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="image-border" height="168" src="assets/image_09_010.jpg" width="341"/></div>
<p>The image shows the effect of the recalculation of <kbd>index_of_last_element</kbd> on the position of the midpoint.</p>
<p>Let's use a more practical example to understand the inner workings of both the binary search and interpolation algorithms.</p>
<p>Take the list with elements:</p>
<pre>
[ 2, 4, 5, 12, 43, 54, 60, 77] 
</pre>
<p>At index 0 is stored 2 and at index 7 is found the value 77. Now, assume that we want to find the element 2 in the list. How will the two different algorithms go about it?</p>
<p>If we pass this list to the interpolation <kbd>search</kbd> function, the <kbd>nearest_mid</kbd> function will return a value equal to <kbd>0</kbd>. Just by one comparison, we would have found the search term.</p>
<p>On the other hand, the binary search algorithm would need three comparisons to arrive at the search term as illustrated in the following image:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="189" src="assets/CH_09_01.png" width="384"/></div>
<p>The first <kbd>mid_point</kbd> calculated is <kbd>3</kbd>. The second <kbd>mid_point</kbd> is <kbd>1</kbd> and the last <kbd>mid_point</kbd> where the search term is found is <kbd>0</kbd>.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Choosing a search algorithm</h1>
            </header>

            <article>
                
<p>The binary search and interpolation search operations are better in performance than both ordered and unordered linear search functions. Because of the sequential probing of elements in the list to find the search term, ordered and unordered linear search have a time complexity of <kbd>O(n)</kbd>. This gives very poor performance when the list is large.</p>
<p>The binary search operation on the other hand, slices the list in two, anytime a search is attempted. On each iteration, we approach the search term much faster than in a linear strategy. The time complexity yields <kbd>O(log n)</kbd>. Despite the speed gain in using binary search, it is most it can not be used on an unsorted list of items neither is it advised to be used for list of small sizes.</p>
<p>The ability to get to the portion of the list that houses a search term determines to a large extent, how well a search algorithm will perform. In the interpolation search algorithm, the mid is calculated for which gives a higher probability of obtaining our search term. The time complexity of the interpolation search is <kbd>O( log ( log n))</kbd>. This gives rise to a faster search compared to its variant, binary search.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Summary</h1>
            </header>

            <article>
                
<p>In this chapter, we have examined two breeds of search algorithms. The implementation of both linear and binary search algorithms have been discussed and their comparisons drawn. The binary search variant, interpolation search has also been treated in this section. Knowing which kind of search operation to use will be relevant in subsequent chapters.</p>
<p>In our next chapter, we shall use the knowledge that we have gained to enable us perform sorting operations on a list of items.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    </body></html>