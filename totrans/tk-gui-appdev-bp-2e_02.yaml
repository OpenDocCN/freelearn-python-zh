- en: Making a Text Editor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We got a fairly high-level overview of Tkinter in [Chapter 1](39a58f50-293e-4ff5-9b65-0d9e0c0cc15e.xhtml),
    *Meet Tkinter*. Now that we know some things about Tkinter's core widgets, geometry
    management, and the binding of commands and events to callbacks, let's use our
    skills in this project to create a text editor.
  prefs: []
  type: TYPE_NORMAL
- en: We will, in the process of creating a text editor, take a closer look at some
    widgets and learn how to tweak them to meet our specific needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the key objectives for this project:'
  prefs: []
  type: TYPE_NORMAL
- en: Delving into some commonly used widgets, such as the Menu, Menubutton, Text,
    Entry, Checkbutton, and Button widgets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the `filedialog` and `messagebox` modules of Tkinter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning the vital concepts of indexing and tagging, as applied to Tkinter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifying the different types of Toplevel windows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The goal here is to build a text editor with some nifty features. Let''s call
    it the Footprint Editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bd68997a-c934-4d03-b092-ed80b010bf13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We intend to include the following features in the text editor:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating new documents, opening and editing existing documents, and saving documents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing common editing options such as cut, copy, paste, undo, and redo
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Searching within a file for a given search term
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing line numbering and the ability to show/hide line numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing theme selection to let a user choose custom color themes for the
    editor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the about and help windows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started – setting up the editor skeleton
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our first goal is to implement the broad visual elements of the text editor.
    As programmers, we have all used text editors to edit code. We are mostly aware
    of the common GUI elements of a text editor. So, without further ado, let's get
    started.
  prefs: []
  type: TYPE_NORMAL
- en: The first phase implements the Menu, Menubutton, Label, Button, Text, and Scrollbar widgets.
    Although we'll cover all of these in detail, you might find it helpful to look at
    the widget-specific options in the documentation of Tkinter maintained by its author,
    Frederick Lundh, at [http://effbot.org/tkinterbook/](http://effbot.org/tkinterbook/).
    You can also use the interactive shell, as discussed in [Chapter 1](39a58f50-293e-4ff5-9b65-0d9e0c0cc15e.xhtml)*,
    Meet Tkinter*.
  prefs: []
  type: TYPE_NORMAL
- en: You might also want to bookmark the official documentation page of Tcl/Tk at [http://www.tcl.tk/man/tcl8.6/TkCmd/contents.htm](http://www.tcl.tk/man/tcl8.6/TkCmd/contents.htm).
    This site includes the original Tcl/Tk reference. While it does not relate to
    Python, it provides a detailed overview of each widget and is a useful reference.
    Remember that Tkinter is just a wrapper around Tk.
  prefs: []
  type: TYPE_NORMAL
- en: In this iteration, we will complete the implementation of broader visual elements
    of the editor.
  prefs: []
  type: TYPE_NORMAL
- en: We will use the `pack()` geometry manager to place all the widgets. We have
    chosen the pack manager because it is ideally suited for the placing of widgets,
    either in a side-by-side or top-down position.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, in a text editor, we have all the widgets placed either side by
    side or in top-down positions. Thus, it is beneficial to use the pack manager.
    We can do the same thing with the grid manager as well.
  prefs: []
  type: TYPE_NORMAL
- en: A note on code styling
  prefs: []
  type: TYPE_NORMAL
- en: One of the key insights of the Python community is that code is read much more
    often than it is written. Following good naming conventions and consistency in
    code styling are key to maintaining readable and scalable programs. We will try
    to stick to the official Python styling guide, which is specified in the PEP8
    documentation at [https://www.python.org/dev/peps/pep-0008](https://www.python.org/dev/peps/pep-0008).
  prefs: []
  type: TYPE_NORMAL
- en: 'Some important styling conventions that we will stick to include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Use four spaces per indentation level
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variable and function names will be lowercase, with words separated by underscores
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class names will use the `CapWords` convention
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s start by adding the Toplevel window using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Note a slight difference in the way we import `tkinter` here. In the last chapter,
    we imported `tkinter` using this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Since we used `tk` as an alias, we had to append the alias name to every call
    made to a class defined in Tkinter, as in `tk.Tk()`, `tk.Frame`, `tk.Button`,
    `tk.END`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'From this chapter onward, we will directly import the individual class that
    we will need for a given program. So, now that we need the `Tk()` class from Tkinter,
    we directly import it into our namespace as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This, in turn, means that we can now directly reference it as the `Tk` class
    in our program without needing to append any alias name to it as in `root = Tk()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A third method is to import all (`*`) the classes from Tkinter into the namespace
    by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The asterisk symbol means we want everything from `tkinter` to be imported into
    the namespace, regardless of whether we use it. This is, however, bad programming
    practice as it leads to namespace pollution. Furthermore, in larger programs,
    it can be hard to tell which module a particular class has been imported from,
    thus making debugging a difficult task.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a menu and menu items
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Menus offer a very compact way of presenting a large number of choices to the user
    without cluttering the interface. Tkinter offers the following two widgets to
    handle menus:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Menu widget**: This appears at the top of applications, which is always visible
    to end users'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Menu items**: These show up when a user clicks on a menu'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will use the following code to add Toplevel menu buttons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, to add a `File` menu, we will use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot is the result of the preceding code (`2.01.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a27eb2da-668c-4f19-b38f-3999e4804f98.png)'
  prefs: []
  type: TYPE_IMG
- en: Similarly, we will add the Edit, View, and About menus (`2.01.py`*)*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will also define a constant as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we''ll set the root window tile, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Most Linux platforms support **tear-off menus**. When `tearoff` is set to `1`
    (enabled), the menu appears with a dotted line above the menu options. Clicking
    on the dotted line enables the user to literally tear off or separate the menu
    from the top. However, as this is not a cross-platform feature, we have decided
    to disable tear-off, marking it as `tearoff = 0`.
  prefs: []
  type: TYPE_NORMAL
- en: Adding menu items
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, we will add menu items in every individual menu. Not surprisingly, the
    code for the menu items needs to be added in the respective menu instance, as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/49bcab0c-fb53-475a-abe7-07cdf34224f9.png)'
  prefs: []
  type: TYPE_IMG
- en: In our example, we will add menu items to the File, Edit, and About menus (`2.02.py`).
  prefs: []
  type: TYPE_NORMAL
- en: The View menu has certain menu item variations, which will be tackled in the following
    section and are therefore not dealt with here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Menu items are added by using the `add_command()` method. The format used to
    add menu items is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, you can create the Undo menu item by using the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Some new menu-specific options that are introduced in the preceding code are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`accelerator`: This option is used to specify a string, typically a keyboard shortcut,
    that can be used to invoke a menu. The string specified as an `accelerator` appears
    next to the text of the menu item. Please note that this does not automatically
    create bindings for the keyboard shortcut. We will have to manually set them up.
    This will be discussed later.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`compound`: Specifying a `compound` option for a menu item lets you add images
    beside a menu label. A specification such as `compound=''left''`,  `label= ''Cut''`,
    `image=cut_icon` means that the cut icon will appear to the left of the Cut menu
    label. The icons that we will use here are stored and referenced in a separate
    folder called `icons`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`underline`: The `underline` option lets you specify the index of a character in
    the menu text that needs to be underlined. The indexing starts at `0`, which means
    that specifying `underline=1` underlines the second character of the text. Besides
    underlining, Tkinter also uses it to define the default bindings for the keyboard
    traversal of menus. This means that we can select the menu either with the mouse
    pointer or with the *Alt* + *<character_at_the_underlined_index>* shortcut.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To add the `New` menu item in the File menu, use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Menu separators
  prefs: []
  type: TYPE_NORMAL
- en: Occasionally, in menu items, you will come across code such as `my_menu.add_separator()`.
    This widget displays a separator bar and is solely used to organize similar menu
    items in groups, separating groups by horizontal bars.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will add a Frame widget to hold the shortcut icons. We will also add a
    Text widget to the left to display line numbers, as shown in the following screenshot
    (`2.02.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5542a195-8fa9-46d9-adde-842056ebe5fd.png)'
  prefs: []
  type: TYPE_IMG
- en: When working with the pack geometry manager, it is important to add widgets
    in the order in which they will appear because `pack()` uses the concept of available
    space to fit the widgets. This is why the text content widget will appear lower
    in the code compared to the two label widgets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having reserved the space, we can later add shortcut icons or line numbers
    and keep the Frame widget as the parent widget. Adding frames is easy; we have
    done that in the past. The code is as follows (refer to `2.02.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We have applied a background color to these two widgets, for now, to differentiate
    them from the body of the Toplevel window.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, let's add the main Text widget and the Scrollbar widget, as follows
    (`2.02.py`)*:*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The code is similar to how we instantiated all the other widgets so far. However, note
    that the scrollbar is configured to `yview` of the Text widget, and the Text widget is
    configured to connect to the Scrollbar widget. This way, the widgets are cross-connected
    to each other.
  prefs: []
  type: TYPE_NORMAL
- en: Now, when you scroll down the Text widget, the scrollbar reacts to it. Alternatively,
    when you move the scrollbar, the Text widget reacts in turn.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the View menu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Tkinter offers the following three varieties of menu item:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Checkbutton menu items**: These let you make a yes/no choice by checking/unchecking
    the menu item'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Radiobutton menu items**: These let you choose an option from many different
    options'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cascade menu items**: These menu items only open up to show another list
    of choices'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following View menu shows these three menu item types in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f3cae6b3-ec45-482f-a8c3-54fb7960cc3b.png)'
  prefs: []
  type: TYPE_IMG
- en: The first three menu items in the View menu let users make a definite yes or
    no choice by checking or unchecking thems. These are examples of the Checkbutton
    menu.
  prefs: []
  type: TYPE_NORMAL
- en: The Themes menu item in the preceding screenshot is an example of a Cascade menu.
    Hovering over this Cascade menu simply opens another list of menu items. However,
    we can also bind a menu item by using the `postcommand=callback` option. This
    can be used to manage something just before bringing up the cascading menu item's
    contents and is often used for dynamic list creation.
  prefs: []
  type: TYPE_NORMAL
- en: Within the Cascade menu, you are presented with a list of choices for your editor's theme.
    However, you can only select one theme. Selecting one theme deselects any previous
    selections. This is an example of the Radiobutton menu.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will not present the entire code here (refer to the `2.03.py` code in the
    code bundle). However, the example code used to add these three types of menu item
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now, we need to track whether a selection has been made by adding a variable, which
    can be `BooleanVar()`, `IntVar()`, or `Stringvar()`, as discussed in [Chapter
    1](39a58f50-293e-4ff5-9b65-0d9e0c0cc15e.xhtml)*, Meet Tkinter*.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our first iteration. In this iteration, we laid down the majority
    of the visual elements of the text editor. Now it's time to add some functionalities
    to the editor.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a built-in functionality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tkinter's Text widget comes with some handy built-in functionalities to handle common
    text-related functions. Let's leverage these functionalities to implement some
    common features in the text editor.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by implementing the `cut`, `copy`, and `paste` features. We now
    have the editor GUI ready. If you open the program and play with the Text widget,
    you will see that you can perform basic functions such as `cut`, `copy`, and `paste`
    in the text area by using *Ctrl* + *X*, *Ctrl* + *C*, and *Ctrl* + *V*, respectively.
    All of these functions exist without us having to add a single line of code for
    these functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: The Text widget clearly comes with these built-in events. Now, we simply want
    to connect these events to their respective menu items.
  prefs: []
  type: TYPE_NORMAL
- en: 'The documentation of the Tcl/Tk universal widget methods tells us that we can
    trigger events without an external stimulus by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'To trigger the Cut event, all we need is the following line in the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s call it by using a `cut` function and associate it with the Cut menu
    by using the callback command (`2.04.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, define a callback command from the existing Cut menu, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, trigger the `copy` and `paste` functions from their respective menu
    items.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will move on to the implementation of the `undo` and `redo` features.
    The Tcl/Tk text documentation tells us that the Text widget has an unlimited Undo
    and Redo mechanism provided we set the undo option to `true` or `1`. To leverage
    this option, let''s first set the Text widget''s undo option to `true` or `1`,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now, if you open the text editor and try out the `undo` feature by using *Ctrl*
    + *Z*, it should work well. Now, we only have to associate the events to functions
    and call back the functions from the Undo menu. This is similar to what we did
    for `cut`, `copy`, and `paste`. Refer to the code in `2.03.py`.
  prefs: []
  type: TYPE_NORMAL
- en: However, `redo` has a little quirk that needs to be addressed. By default, `redo`
    is not bound to the *Ctrl* + *Y* keys. Instead, *Ctrl* + *Y* is bound to the `paste`
    functionality. This is not how we expect the binding to behave, but it exists
    due to some historical reasons related to Tcl/Tk.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, it is easy to override this functionality by adding an event binding, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Since an event binding like the one in the preceding code sends an event argument, the
    `undo` function must be able to handle this incoming parameter. Therefore, we''ll add
    the `event=None` optional parameter to the `redo` function, as follows (`2.04.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Events propagate from the operating system level and are accessible to the window that
    subscribes to the event or wants to make use of it. The `return 'break'` expression
    in the preceding function tells the system that it has performed the event and
    that it should not be propagated further.
  prefs: []
  type: TYPE_NORMAL
- en: This prevents the same event from firing the `paste` event even though it is
    the default behavior in Tkinter. Now, *Ctrl* + *Y* fires the `redo` event instead
    of firing the `paste` event.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, once we have performed an event, we do not want it to propagate further. Thus,
    we will add return `break` to all event-driven functions.
  prefs: []
  type: TYPE_NORMAL
- en: Indexing and tagging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Though we managed to leverage some built-in functionalities to gain a quick advantage,
    we need more control over the text area so that we can bend it to our will. This
    will require the ability to target each character or text location with precision.
  prefs: []
  type: TYPE_NORMAL
- en: We will need to know the exact position of each character, the cursor, or the
    selected area in order to do anything with the contents of the editor.
  prefs: []
  type: TYPE_NORMAL
- en: The Text widget offers us the ability to manipulate its content using **index**,
    **tags**, and **mark**, which let us target a position or place within the text
    area for manipulation.
  prefs: []
  type: TYPE_NORMAL
- en: Index
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Indexing helps you target a particular place within a piece of text. For example,
    if you want to mark a particular word in bold, red, or in a different font size,
    you can do so if you know the index of the starting point and the index of the
    endpoint that needs to be targeted.
  prefs: []
  type: TYPE_NORMAL
- en: 'The index must be specified in one of the following formats:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **The index format** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `x.y` | This refers to the character at row `x` and column `y`. |'
  prefs: []
  type: TYPE_TB
- en: '| `@x,y` | This refers to the character that covers the `x,y` coordinate within
    the text''s window. |'
  prefs: []
  type: TYPE_TB
- en: '| `end` | This refers to the end of the text. |'
  prefs: []
  type: TYPE_TB
- en: '| `mark` | This refers to the character after a named mark. |'
  prefs: []
  type: TYPE_TB
- en: '| `tag.first` | This refers to the first character in the text that has been
    tagged with a given tag. |'
  prefs: []
  type: TYPE_TB
- en: '| `tag.last` | This refers to the last character in the text that has been
    tagged with a given tag. |'
  prefs: []
  type: TYPE_TB
- en: '| `selection` (`SEL_` `FIRST`, `SEL_LAST`) | This corresponds to the current
    selection. The `SEL_FIRST` and `SEL_LAST` constants refer to the start position
    and end position in the selection. Tkinter raises a `TclError` exception if there
    is no selection. |'
  prefs: []
  type: TYPE_TB
- en: '| `window_name` | This refers to the position of the embedded window named `window_name`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `image_name` | This refers to the position of the embedded image named `image_name`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `INSERT` | This refers to the position of the insertion cursor. |'
  prefs: []
  type: TYPE_TB
- en: '| `CURRENT` | This refers to the position of the character that is closest
    to the mouse pointer. |'
  prefs: []
  type: TYPE_TB
- en: Note a small quirk here. The counting of rows in a Text widget starts at 1,
    while the counting of columns starts at 0\. Therefore, the index for the starting
    position of the Text widget is 1.0 (that is, row number 1 and column number 0).
  prefs: []
  type: TYPE_NORMAL
- en: 'An index can be further manipulated by using modifiers and submodifiers. Some examples
    of modifiers and submodifiers are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`end - 1 chars` or `end - 1 c`: This refers to the index of the character before
    the one at the end'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`insert +5lines`: This refers to the index five lines ahead of the insertion cursor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`insertwordstart - 1 c`: This refers to the character just before the first
    one in a word containing the insertion cursor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`end linestart`: This refers to the index of the line start of the end line'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Indexes are often used as arguments to functions. Refer to the following list
    for some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '`my_text.delete`(`1.0`,`END`) : This means that you can delete from line `1`
    , column `0` until the end'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`my_text.get`(`1.0,` `END`) : This gets the content from 1.0 (beginning) to
    the end'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`my_text.delete`(''`insert-1c`'', `INSERT`) : This deletes a character at the insertion
    cursor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tags
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tags are used to annotate text with an identification string that can then be
    used to manipulate the tagged text. Tkinter has a built-in tag called **SEL**,
    which is automatically applied to the selected text. In addition to SEL, you can
    define your own tags. A text range can be associated with multiple tags, and the
    same tag can be used for many different text ranges.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples of tagging:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: You can specify the visual style for a given tag with `tag_config`, using options such
    as `background` (color), `bgstipple` (bitmap), `borderwidth` (distance), `fgstipple`
    (bitmap), `font` (font), `foreground` (color), `justify` (constant), `lmargin1`
    (distance), `lmargin2` (distance), `offset` (distance), `overstrike`
  prefs: []
  type: TYPE_NORMAL
- en: (flag), `relief` (constant), `rmargin` (distance), `spacing1` (distance), `tabs` (string),
    `underline` (flag), and `wrap` (constant).
  prefs: []
  type: TYPE_NORMAL
- en: 'For a complete reference about text indexing and tagging, type the following
    command into the Python interactive shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Equipped with a basic understanding of indexing and tagging, let's implement
    some more features in the code editor.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Select All feature
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We know that Tkinter has a built-in `sel` tag that applies a selection to a
    given text range. We want to apply this tag to the entire text in the widget.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can simply define a function to handle this, as follows (`2.05.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'After doing this, add a callback to the `Select All` menu item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to bind the function to the *Ctrl* + *A* keyboard shortcut. We
    do this by using the following key bindings (`2.05.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The coding of the `Select All` feature is complete. To try it out, add some
    text to the text widget and then click on the menu item, `Select All`, or use
    *Ctrl* + *A* (`accelerator` shortcut key).
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Find Text feature
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, let''s code the `Find Text` feature (`2.05.py`). The following screenshot
    shows an example of the `Find Text` feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e65263f9-ca09-42f9-9550-1d9176729b9c.png)'
  prefs: []
  type: TYPE_IMG
- en: Here's a quick summary of the desired functionality. When a user clicks on the
    Find menu item, a new Toplevel window opens up. The user enters a search keyword
    and specifies whether the search needs to be case-sensitive. When the user clicks
    on the Find All button, all matches are highlighted.
  prefs: []
  type: TYPE_NORMAL
- en: 'To search through the document, we rely on the `text_widget.search()`method.
    The search method takes in the following arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'For the editor, define a function called `find_text` and attach it as a callback
    to the Find menu (`2.05.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, bind it to the *Ctrl* + *F* shortcut, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, define the `find_text` function, as follows (`2.05.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is a description of the preceding code (`2.05.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: When a user clicks on the Find menu item, it invokes a `find_text` callback.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first four lines of the `find_text()` function create a new Toplevel window,
    add a window title, specify its geometry (size, shape, and location), and set
    it as a *transient window*. Setting it as a transient window means that it is
    always drawn on top of its parent or root window. If you comment out this line
    and click on the root editor window, the Find window will go behind the root window.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next eight lines of code are pretty self-explanatory; they set the widgets
    of the Find window. They add the Label, Entry, Button, and Checkbutton widgets,
    and set up the `search_string` and `ignore_case_value` variables to track the
    value a user enters into the Entry widget and whether the user has checked off Checkbutton.
    The widgets are arranged by using the grid geometry manager to fit into the Find
    window.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Find All button has a command option that calls a `search_output` function,
    passing the search string as the first argument and whether the search needs to
    be case-sensitive as its second argument. The third, fourth, and fifth arguments
    pass the Toplevel window, the Text widget, and the Entry widget as parameters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We override the Close button of the Find window and redirect it to a callback
    named `close_search()`. The `close_search` function is defined within the `find_text`
    function. This function takes care of removing the match tag that was added during
    the search. If we do not override the Close button and remove these tags, the matched
    string will continue to be marked in red and yellow even after the search has
    ended.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, we define the `search_output` function, which does the actual searching
    and adds the match tag to the matching text. The code for this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is a description of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: This part of the code is the heart of the `search` function. It searches through the
    entire document by using the `while True` loop, breaking out of the loop only
    if no more text items remain to be searched.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code first removes the previous search-related match tags if there are
    any, as we do not want to append the results of the new search to the previous
    search results. The function uses the `search()` method, which is provided in
    Tkinter in the Text widget. The `search()` method takes the following arguments:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The `search()` method returns the starting position of the first match. We store it
    in a variable named `start_pos`, calculate the position of the last character in
    the matched word, and store it in the `end_pos` variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For every search match that it finds, it adds the match tag to the text ranging from
    the first position to the last position. After every match, we set the value of
    `start_pos` to be equal to `end_pos`. This ensures that the next search starts after
    `end_pos`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The loop also keeps track of the number of matches by using the `count` variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Outside the loop, the tag match is configured to have a red font and yellow background.
    The last line of this function updates the title of the Find window with the number
    of matches that were found.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In case of event bindings, interaction occurs between input devices (keyboard/mouse)
    and your application. In addition to event binding, Tkinter also supports protocol
    handling.
  prefs: []
  type: TYPE_NORMAL
- en: The term protocol refers to the interaction between your application and the
    window manager. An example of a protocol is `WM_DELETE_WINDOW`, which handles
    the close window event for your window manager.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tkinter lets you override these protocol handlers by mentioning your own handler
    for the root or Toplevel widget. To override the window exit protocol, we use
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '`root.protocol(WM_DELETE_WINDOW, callback)`'
  prefs: []
  type: TYPE_NORMAL
- en: Once you add this command, Tkinter reroutes protocol handling to the specified
    callback/handler.
  prefs: []
  type: TYPE_NORMAL
- en: Types of Toplevel window
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Previously in this chapter, we used the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s explore what it means here. Tkinter supports the following four types
    of Toplevel window:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The main Toplevel window**: This is the type we have been constructing so
    far.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The child Toplevel window**: This type is independent of the root. The Toplevel
    child behaves independently of its root, but it gets destroyed if its parent is
    destroyed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The transient Toplevel window:** This always appears at the top of its parent, but
    it does not entirely grab the focus. Clicking again on the parent window allows
    you to interact with it. The transient window is hidden when the parent is minimized,
    and it is destroyed if the parent is destroyed. Compare this to what is called
    a **modal window**. A modal window grabs all the focus from the parent window
    and asks a user to first close the modal window before regaining access to the
    parent window.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The undecorated Toplevel window:** A Toplevel window is undecorated if it
    does not have a window manager decoration around it. It is created by setting
    the **overrideredirect** flag to `1`. An undecorated window cannot be resized
    or moved.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refer to the `2.06.py` code for a demonstration of all four types of Toplevel
    window.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our second iteration. Congratulations! We have completed coding
    the `Select All` and `Find Text` functionality into our program.
  prefs: []
  type: TYPE_NORMAL
- en: More importantly, you have been introduced to indexing and tagging—two very powerful
    concepts associated with many Tkinter widgets. You will find yourself using these
    two concepts all the time in your projects.
  prefs: []
  type: TYPE_NORMAL
- en: We also explored the four types of Toplevel window and the use cases for each
    of them.
  prefs: []
  type: TYPE_NORMAL
- en: Working with forms and dialogs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The goal for this iteration is to implement the functionality of the File menu
    options: Open, Save, and Save As.
  prefs: []
  type: TYPE_NORMAL
- en: We can implement these dialogs by using the standard Tkinter widgets. However, since
    these are so commonly used, a specific Tkinter module called `filedialog` has been
    included in the standard Tkinter distribution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of a typical `filedialog`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a40730bd-4116-4362-9a5d-1f382b377be3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Tkinter defines the following common use cases for `filedialogs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Functions** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `askopenfile` | This returns the opened file object |'
  prefs: []
  type: TYPE_TB
- en: '| `askopenfilename` | This returns the filename string, not the opened file
    object |'
  prefs: []
  type: TYPE_TB
- en: '| `askopenfilenames` | This returns a list of filenames |'
  prefs: []
  type: TYPE_TB
- en: '| `askopenfiles` | This returns a list of open file objects or an empty list
    if Cancel is selected |'
  prefs: []
  type: TYPE_TB
- en: '| `asksaveasfile` | This asks for a filename to save as and returns the opened
    file object |'
  prefs: []
  type: TYPE_TB
- en: '| `asksaveasfilename` | This asks for a filename to save as and returns the
    filename |'
  prefs: []
  type: TYPE_TB
- en: '| `askdirectory` | This asks for a directory and returns the directory name
    |'
  prefs: []
  type: TYPE_TB
- en: 'The usage is simple. Import the `filedialog` module and call the required function. Here''s
    an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We then call the required function using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, we use this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The `mode='r'` option specified in the preceding code is one of many configurable
    options that are available for dialogs.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can specify the following additional options for `filedialog`:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **File dialog** | **Configurable options** |'
  prefs: []
  type: TYPE_TB
- en: '| `askopenfile` (`mode=''r''`, `**options`) | `parent`, `title`, `message`,
    `defaultextension`, `filetypes`, `initialdir`, `initialfile`, and multiple |'
  prefs: []
  type: TYPE_TB
- en: '| `askopenfilename` (`**options`) | `parent`, `title`, `message`, `defaultextension`, `filetypes`,
    `initialdir`, `initialfile`, and multiple |'
  prefs: []
  type: TYPE_TB
- en: '| `asksaveasfile` (`mode=''w''`, `**options`) | `parent`, `title`, `message`,
    `defaultextension`, `filetypes`, `initialdir`, `initialfile`, and multiple |'
  prefs: []
  type: TYPE_TB
- en: '| `asksaveasfilename` (`**options`) | `parent`, `title`, `message`, `defaultextension`, `filetypes`,
    `initialdir`, `initialfile`, and multiple |'
  prefs: []
  type: TYPE_TB
- en: '| `askdirectory` (`**options`) | `parent`, `title`, and `initialdir` must exist
    |'
  prefs: []
  type: TYPE_TB
- en: Equipped with a basic understanding of the `filedialog` module, let's now have
    a look at its practical usage. We'll begin by implementing the File | Open feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by importing the required modules, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s create a global variable, which will store the name of the currently
    open file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The use of global variables is generally considered bad programming practice
    because it is very difficult to understand a program that uses lots of global
    variables.
  prefs: []
  type: TYPE_NORMAL
- en: A global variable can be modified or accessed from many different places in
    the program. Therefore, it becomes difficult to remember or work out every possible
    use of the variable.
  prefs: []
  type: TYPE_NORMAL
- en: A global variable is not subject to access control, which may pose security hazards
    in certain situations, say when this program needs to interact with third-party
    code.
  prefs: []
  type: TYPE_NORMAL
- en: However, when you work on programs in a procedural style such as this one, global
    variables are sometimes unavoidable.
  prefs: []
  type: TYPE_NORMAL
- en: An alternative approach to programming involves writing code in a class structure
    (also called object-oriented programming), where a variable can only be accessed
    by members of predefined classes. We will see a lot of examples of object-oriented
    programming in the chapters that follow.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is present in `open_file` (`2.07.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Modify the Open menu to add a callback command to this newly defined method, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is a description of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: We declared a `file_name` variable in the `global` scope to keep track of the filename
    of the opened file. This is required to keep track of whether a file has been
    opened. We need this variable in the `global` scope as we want this variable to
    be available to other methods, such as `save()` and `save_as()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not specifying it as `global` would mean that it is only available within the function.
    So, the `save()` and `save_as()` functions would not be able to check whether
    a file is already open in the editor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use `askopenfilename` to fetch the filename of the opened file. If a user
    cancels opening the file or no file is chosen, the `file_name` returned is `None`.
    In that case, we do nothing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, if `filedialog` returns a valid filename, we isolate the filename using
    the `os` module and add it as the title of the root window.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the `Text` widget already contains some text, we delete it all.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We then open the given file in read mode and insert its content into the Content
    widget.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use the context manager (the `with` command), which takes care of closing
    the file properly for us, even in the case of an exception.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we add a command callback to the File | Open menu item.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This completes the coding of File | Open. If you now navigate to File | Open,
    select a text file, and click on Open, the content area will be populated with
    the content of the text file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will have a look at how to save a file. There are two aspects to saving
    a file:'
  prefs: []
  type: TYPE_NORMAL
- en: Save
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Save As
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the Content text widget already contains a file, we do not prompt the user
    for a filename. We simply overwrite the contents of the existing file. If there
    is no filename associated with the current content of the text area, we prompt
    the user with a Save As dialog. Moreover, if the text area has an open file and
    the user clicks on Save As, we still prompt them with a Save As dialog to allow
    them to write the contents to a different filename.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for `save` and `save_as` is as follows (`2.07.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Having defined the `save` and `save_as` functions, let''s connect them to the
    respective menu callback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is a description of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: The `save` function first tries to check whether a file is open. If a file is
    open, it simply overwrites the contents of the file with the current contents
    of the text area. If no file is open, it simply passes the work to the `save_as`
    function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `save_as` function opens a dialog by using `asksaveasfilename` and tries to
    get the filename provided by the user for the given file. If it succeeds, it opens
    the new file in write mode and writes the contents of the text under this new
    filename. After writing, it closes the current file object and changes the title
    of the window to reflect the new filename.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the user does not specify a filename or the user cancels the `save_as` operation,
    it simply ignores the process by using a pass command.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We added a `write_to_file(file_name)` helper function to do the actual writing
    to the file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'While we are at it, let''s complete the functionality of File | New. The code
    is simple (`2.07.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, add a callback command to this new function to the File | New menu item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is a description of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: The `new_file` function begins by changing the title attribute of the root window
    to `Untitled`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It then sets the value of the `global` filename variable to `None`. This is important
    because the `save` and `save_as` functionalities use this global variable name
    to track whether the file already exists or is new.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The function then deletes all the contents of the `Text` widget, creating a
    fresh document in its place.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s wrap up this iteration by adding keyboard shortcuts for the newly created features
    (`2.07.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: In this iteration, we implemented the coding functionality for the New, Open,
    Save, and Save As menu items.  More importantly, we saw how to use the `filedialog`
    module to achieve certain commonly used file features in the program. We also
    had a look at how to use indexing to achieve a wide variety of tasks for programs.
  prefs: []
  type: TYPE_NORMAL
- en: Working with message boxes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's complete the code for the About and Help menus. The functionality
    is simple. When a user clicks on the Help or About menu, a message window pops
    up and waits for the user to respond by clicking on a button. Though we can easily
    code new Toplevel windows to show the About and Help messages, we will instead
    use a module called `messagebox` to achieve this functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `messagebox` module provides ready-made message boxes to display a wide variety
    of messages in applications. The functions available through this module include
    `showinfo`, `showwarning`, `showerror`, `askquestion`, `askokcancel`, `askyesno`, `askyesnocancel`,
    and `askretrycancel`, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2cf16643-5cbb-4ba8-ab6a-fd7bd085e4e3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To use this module, we simply import it into the current namespace by using
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'A demonstration of the commonly used functions of `messagebox` is provided
    in `2.08.py` in the code bundle. The following are some common usage patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Equipped with an understanding of the `messagebox` module, let's code the `about` and
    `help` functions for the code editor. The functionality is simple. When a user clicks
    on the About or Help menu item, a `showinfomessagebox` pops up.
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve this, include the following code in the editor (`2.09.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, attach these functions to the respective menu items, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will add the quit confirmation feature. Ideally, we should have implemented
    file saving in the event the text content has been modified, but for the sake
    of simplicity I am not putting in that logic here and instead am displaying a
    prompt for the user to determine whether the program should be closed or kept
    open. Accordingly, when the user clicks on File | Exit, it prompts an Ok-Cancel
    dialog to confirm the quit action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we override the Close button and redirect it to the `exit_editor` function
    that we previously defined, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we add a callback command for all the individual menu items, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, add the bindings for the keyboard shortcut to display help:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: This completes the iteration.
  prefs: []
  type: TYPE_NORMAL
- en: The icons toolbar and View menu functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this iteration, we will add the following functionalities to the text editor:'
  prefs: []
  type: TYPE_NORMAL
- en: Showing shortcut icons on the toolbar
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying line numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Highlighting the current line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the color theme of the editor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s start with a simple task first. In this step, we will add shortcut icons
    to the toolbar, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2d7d1652-4c63-4c07-aaf7-a13eb4683fa3.png)'
  prefs: []
  type: TYPE_IMG
- en: You may recall that we have already created a frame to hold these icons. Let's
    add these icons now.
  prefs: []
  type: TYPE_NORMAL
- en: While adding these icons, we have followed a convention. The icons have been named
    exactly the same as the corresponding function that handles them. Following this
    convention has enabled us to loop through a list, simultaneously apply the icon image
    to each button, and add the command callback from within the loop. All the icons
    have been placed in the icons folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code adds icons to the toolbar (`2.10.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is a description of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: We have already created a shortcut bar in the first iteration. Now, we will simply
    add buttons with images in the frame.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We create a list of icons, taking care to name them exactly the same as the
    name of the icons.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We then loop through the list by creating a Button widget, adding an image to
    the button, and adding the respective callback command.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before adding the callback command, we have to convert the string to an equivalent
    expression by using the `eval` command. If we do not apply `eval`, it cannot be
    applied as an expression to the callback command.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thus, we've added shortcut icons to the shortcut bar. Now, if you run the code
    (refer to `2.10.py` in the code bundle), it should show all of the shortcut icons.
    Moreover, as we have linked each button to its callback, all of these shortcut
    icons should work.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying line numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's work toward showing line numbers to the left of the Text widget. This
    will require us to tweak the code in various places. So, before we start coding,
    let's look at what we are trying to achieve.
  prefs: []
  type: TYPE_NORMAL
- en: 'The View menu has a menu item that allows users to choose whether to Show Line Number.
    We only want to show line numbers if the option is selected, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/326c66d9-eb54-493f-b0f0-4630f1b38235.png)'
  prefs: []
  type: TYPE_IMG
- en: If the option is selected, we need to display line numbers in the left frame
    that we created earlier.
  prefs: []
  type: TYPE_NORMAL
- en: The line number should update every time a user enters a new line, deletes a
    line, cuts or pastes line text, performs an undo or a redo operation, opens an existing
    file, or clicks on the New menu item. In short, the line number should be updated
    after every activity results in a change of content. Therefore, we need to define
    a function called `on_content_changed()`. This function should be called after
    the definitions of every `press`, `cut`, `paste`, `undo`, `redo`, `new`, and `open` key,
    to check whether lines have been added or removed from the text area and accordingly
    update the line numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'We achieve this by using the following two strategies (refer to `2.10.py` in
    the code bundle):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Bind a key press event to the `update_line_number()` function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Next, add a call to the `on_content_changed()` function in each of the definitions
    of `cut`*,* `paste`*,* `undo`*,* `redo`*,* `new`*,* and `open`*.*
  prefs: []
  type: TYPE_NORMAL
- en: Then define a `get_line_numbers()` function that returns a string containing
    all the numbers until the last row, separated by line breaks.
  prefs: []
  type: TYPE_NORMAL
- en: So for instance, if the last non-empty row in the content widget is `5`, this
    function returns us a string of the `1 /n 2 /n 3 /n 4/n 5 /n` form.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the function definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s define the `update_line_numbers()` function, which simply updates
    the text widget that displays the line using the string output from the previous
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is a description of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You may recall that we assigned a `show_line_number` variable to the menu item
    earlier:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`show_line_number = IntVar()`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`show_line_number.set(1)`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`view_menu.add_checkbutton(label="Show Line Number", variable=show_line_number)`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If the `show_line_number` option is set to `1` (that is to say, it has been
    checked off in the menu item), we calculate the last line and last column in the
    text.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We then create a text string consisting of numbers from `1` to the number of
    the last line, with each number separated by a line break (`\n`). This string
    is then added to the left label by using the `line_number_bar.config()` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `Show Line Number` is unchecked in the menu, the variable text remains blank,
    thereby displaying no line numbers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we update each of the previously defined `cut`, `paste`, `undo`, `redo`, `new`,
    and `open` functions to invoke the `on_content_changed()` function at its end.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have finished adding the line number functionality to the text editor. However,
    I would like to add that this implementation, though simple, has some limitations
    in that it does not handle word wrapping and font size variability very well.
    A foolproof line numbering solution would require the use of the Canvas widget
    – something that we discuss Chapter 4 Game of Chess and onward. Meanwhile, if
    you are curious, take a look at a sample Canvas-based implementation at [https://stackoverflow.com/a/16375233/2348704](https://stackoverflow.com/a/16375233/2348704).
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, in this iteration, we will implement a feature where a user can choose
    to highlight the current line (`2.10.py`).
  prefs: []
  type: TYPE_NORMAL
- en: The idea is simple. We need to locate the line of the cursor and add a tag to
    the line. We also need to configure the tag so that it appears with a differently
    colored background to highlight it.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may recall that we have already provided a menu choice to users to decide whether
    to highlight the current line. We will now add a callback command from this menu
    item to a function that we will define as `toggle_highlight`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we define three functions to handle this for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is a description of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: Every time a user checks/unchecks View | Highlight Current Line, this invokes
    the `toggle_highlight` function. This function checks whether the menu item is
    checked. If it is checked, it invokes the `highlight_line` function. Otherwise,
    if the menu item is unchecked, it invokes the `undo_highlight` function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `highlight_line` function simply adds a tag called `active_line` to the current
    line, and after every 100 milliseconds it calls the `toggle_highlight` function
    to check whether the current line should still be highlighted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `undo_highlight` function is invoked when the user unchecks highlighting
    in the View menu. Once invoked, it simply removes the `active_line` tag from the
    entire text area.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, we can configure the tag named `active_line` so that it is displayed
    with a different background color, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: We used the `.widget.after(ms, callback)` handler in the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Methods that let us perform some periodic actions are called alarm handlers.
    The following are some commonly used Tkinter alarm handlers:'
  prefs: []
  type: TYPE_NORMAL
- en: '• `after(delay_ms, callback, args...)`: This registers a callback alarm, which
    can be called after a given number of milliseconds.'
  prefs: []
  type: TYPE_NORMAL
- en: '• `after_cancel(id)`: This cancels the given callback alarm.'
  prefs: []
  type: TYPE_NORMAL
- en: '• `after_idle(callback, args...)`: This calls back only when there are no more
    events to process in `mainloop`; that is, after the system becomes idle.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding the cursor information bar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The cursor information bar is simply a small label at the bottom-right corner
    of the Text widget that displays the current position of the cursor, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1028f9ca-8c45-4c73-a0a3-05b66c6c3bc8.png)'
  prefs: []
  type: TYPE_IMG
- en: The user can choose to show/hide this info bar from the View menu (`2.11.py`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Begin by creating a Label widget within the Text widget and pack it in the
    bottom-right corner, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'In many ways, this is similar to displaying line numbers. Here, too, the positions must
    be calculated after every keystroke, after events such as `cut`, `paste`, `undo`,
    `redo`, `new`, and `open`, or activities that lead to a change in cursor positions.
    Because this too needs to be updated for all the changed content, for every keystroke,
    we will update `on_content_changed` to update this, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The code is simple. We get the row and column for the current cursor position
    by using the `index(INSERT)` method and update the labels with the latest row
    and column of the cursor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the function is connected to the existing menu item by using a callback
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Adding themes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You may recall that, while defining the Themes menu, we defined a color scheme dictionary
    containing the name and hexadecimal color codes as a key-value pair, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The theme choice menu has already been defined. Let''s add a callback command
    to handle the selected menu (`2.12.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '`themes_menu.add_radiobutton(label=k, variable=theme_choice, command=change_theme)`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s define the `change_theme` function to handle the changing of
    themes, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The function is simple. It picks up the key-value pair from the defined color
    scheme dictionary. It splits the color into its two components and applies one
    color each to the Text widget foreground and background using `widget.config()`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, if you select a different color from the Themes menu, the background and foreground
    colors change accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: This completes the iteration. We completed coding the shortcut icon toolbar
    and the functionality of the View menu in this iteration. In the process, we learned
    how to handle the `Checkbutton` and `Radiobutton` menu items. We also had a look
    at how to create compound buttons while reinforcing several Tkinter options that
    were covered in the previous sections.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a context/pop-up menu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s complete the editor in this final iteration by adding a contextual menu
    to the editor *(*`2.12.py`)*,* as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e8870938-b80e-4be4-b902-e2af2920b8ed.png)'
  prefs: []
  type: TYPE_IMG
- en: The menu that pops up on a right-click at the location of the cursor is called
    the **context menu** or the **pop-up menu**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s code this feature in the text editor. First, define the context menu,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, bind the right-click of a mouse with a callback named `show_popup_menu`, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, define the `show_popup_menu` function in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: You can now right-click anywhere on the Text widget in the editor to open the contextual
    menu.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes the iteration as well as the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we covered the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: We completed coding the editor in twelve iterations. We started by placing all
    the widgets on the Toplevel window.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We then leveraged some built-in features of the Text widget to code some functionality.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We learned the important concepts of indexing and tagging.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also saw how to use the `filedialog` and `messagebox` modules to quickly
    code some common features in programs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Congratulations! You completed coding your text editor. In the next chapter,
    we will make a programmable drum machine.
  prefs: []
  type: TYPE_NORMAL
- en: QA section
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a few questions to reflect upon:'
  prefs: []
  type: TYPE_NORMAL
- en: What's the difference between the Checkbutton menu item and the Radio button
    menu item?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What's the Cascade menu button used for?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identify different kinds of Toplevel window.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: List the different types of `filedialogs` and message boxes available in Tkinter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We used the pack geometry manager to build this text editor. Could we have built
    this using the grid geometry manager? How would the grid geometry manager fare
    against pack?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can we trigger events without an external stimulus in Tkinter?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are accelerator options in menu items?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is a transient window?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The source code for the `filedialog` module can be found within the Tkinter
    source code in a separate file named `filedialog.py`. You are encouraged to take
    a look at its implementation.
  prefs: []
  type: TYPE_NORMAL
- en: If you are feeling adventurous and want to further explore the Text Editor program,
    I encourage you to have a look at the source code for Python's built-in editor
    named IDLE, which is written in Tkinter. The source code for IDLE can be found
    in your local Python library directory in a folder called `idlelib`. On Linux
    Mint, this is located at `/usr/lib/python3.4/idlelib`.
  prefs: []
  type: TYPE_NORMAL
- en: Read the official Python styling guide, which is specified in the PEP8 documentation
    at [https://www.python.org/dev/peps/pep-0008](https://www.python.org/dev/peps/pep-0008).
  prefs: []
  type: TYPE_NORMAL
- en: If you like, try to implement syntax highlighting of Python code in the text
    editor. A naive implementation would first involve defining a list of keywords.
    Then we can bind the `<KeyRelease>` event to check whether the typed word is one
    of the keywords. We can then add a custom tag to the word using `tag_add`. Finally,
    we can change its color by using code such as `textarea.tag_config("the_keyword_tag",
    foreground="blue")`.
  prefs: []
  type: TYPE_NORMAL
- en: A slightly advanced idea to read up on and implement is called **lazy loading**. 
    This is particularly helpful if you want to open a very large file in the text
    editor. In the present implementation, it may take very long time to open a very
    large file. In contrast, lazy loading will read only the section of the file that
    is currently visible in the text editor, thus making the program much more responsive.
  prefs: []
  type: TYPE_NORMAL
