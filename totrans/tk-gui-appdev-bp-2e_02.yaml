- en: Making a Text Editor
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制作一个文本编辑器
- en: We got a fairly high-level overview of Tkinter in [Chapter 1](39a58f50-293e-4ff5-9b65-0d9e0c0cc15e.xhtml),
    *Meet Tkinter*. Now that we know some things about Tkinter's core widgets, geometry
    management, and the binding of commands and events to callbacks, let's use our
    skills in this project to create a text editor.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第1章](39a58f50-293e-4ff5-9b65-0d9e0c0cc15e.xhtml)，“认识Tkinter”中，对Tkinter有一个相当高级的概述。现在，既然我们已经了解了一些关于Tkinter核心小部件、布局管理和将命令和事件绑定到回调函数的知识，让我们运用这些技能在这个项目中创建一个文本编辑器。
- en: We will, in the process of creating a text editor, take a closer look at some
    widgets and learn how to tweak them to meet our specific needs.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建文本编辑器的过程中，我们将更深入地了解一些小部件，并学习如何调整它们以满足我们的特定需求。
- en: 'The following are the key objectives for this project:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是这个项目的关键目标：
- en: Delving into some commonly used widgets, such as the Menu, Menubutton, Text,
    Entry, Checkbutton, and Button widgets
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入了解一些常用的小部件，例如菜单（Menu）、菜单按钮（Menubutton）、文本框（Text）、输入框（Entry）、复选框（Checkbutton）和按钮（Button）小部件
- en: Exploring the `filedialog` and `messagebox` modules of Tkinter
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索 Tkinter 的 `filedialog` 和 `messagebox` 模块
- en: Learning the vital concepts of indexing and tagging, as applied to Tkinter
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习Tkinter中索引和标签的重要概念
- en: Identifying the different types of Toplevel windows
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别不同类型的顶层窗口
- en: Project overview
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目概述
- en: 'The goal here is to build a text editor with some nifty features. Let''s call
    it the Footprint Editor:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 此处的目标是创建一个具有一些实用功能的文本编辑器。让我们称它为 Footprint Editor：
- en: '![](img/bd68997a-c934-4d03-b092-ed80b010bf13.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bd68997a-c934-4d03-b092-ed80b010bf13.png)'
- en: 'We intend to include the following features in the text editor:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们打算在文本编辑器中包含以下功能：
- en: Creating new documents, opening and editing existing documents, and saving documents
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建新文档、打开和编辑现有文档以及保存文档
- en: Implementing common editing options such as cut, copy, paste, undo, and redo
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现常见的编辑选项，如剪切、复制、粘贴、撤销和重做
- en: Searching within a file for a given search term
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在文件中搜索给定的搜索词
- en: Implementing line numbering and the ability to show/hide line numbers
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现行号显示和隐藏功能
- en: Implementing theme selection to let a user choose custom color themes for the
    editor
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现主题选择功能，让用户可以为编辑器选择自定义颜色主题
- en: Implementing the about and help windows
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现关于和帮助窗口
- en: Getting started – setting up the editor skeleton
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用 – 设置编辑器框架
- en: Our first goal is to implement the broad visual elements of the text editor.
    As programmers, we have all used text editors to edit code. We are mostly aware
    of the common GUI elements of a text editor. So, without further ado, let's get
    started.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的首要目标是实现文本编辑器的广泛视觉元素。作为程序员，我们所有人都使用过文本编辑器来编辑代码。我们对文本编辑器的常见GUI元素大多有所了解。因此，无需多言，让我们开始吧。
- en: The first phase implements the Menu, Menubutton, Label, Button, Text, and Scrollbar widgets.
    Although we'll cover all of these in detail, you might find it helpful to look at
    the widget-specific options in the documentation of Tkinter maintained by its author,
    Frederick Lundh, at [http://effbot.org/tkinterbook/](http://effbot.org/tkinterbook/).
    You can also use the interactive shell, as discussed in [Chapter 1](39a58f50-293e-4ff5-9b65-0d9e0c0cc15e.xhtml)*,
    Meet Tkinter*.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 第一阶段实现了菜单（Menu）、菜单按钮（Menubutton）、标签（Label）、按钮（Button）、文本（Text）和滚动条（Scrollbar）小部件。尽管我们将在详细内容中涵盖所有这些，但你可能会发现查看Tkinter作者Frederick
    Lundh维护的文档中的小部件特定选项很有帮助，该文档位于[http://effbot.org/tkinterbook/](http://effbot.org/tkinterbook/)。你还可以使用如[第1章](39a58f50-293e-4ff5-9b65-0d9e0c0cc15e.xhtml)*，遇见Tkinter*中讨论的交互式shell。
- en: You might also want to bookmark the official documentation page of Tcl/Tk at [http://www.tcl.tk/man/tcl8.6/TkCmd/contents.htm](http://www.tcl.tk/man/tcl8.6/TkCmd/contents.htm).
    This site includes the original Tcl/Tk reference. While it does not relate to
    Python, it provides a detailed overview of each widget and is a useful reference.
    Remember that Tkinter is just a wrapper around Tk.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还想将 Tcl/Tk 的官方文档页面收藏起来，网址为 [http://www.tcl.tk/man/tcl8.6/TkCmd/contents.htm](http://www.tcl.tk/man/tcl8.6/TkCmd/contents.htm)。该网站包含了原始的
    Tcl/Tk 参考信息。虽然它与 Python 无关，但它提供了每个小部件的详细概述，是一个有用的参考资料。请记住，Tkinter 只是 Tk 的一个包装器。
- en: In this iteration, we will complete the implementation of broader visual elements
    of the editor.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次迭代中，我们将完成编辑器更广泛视觉元素的实现。
- en: We will use the `pack()` geometry manager to place all the widgets. We have
    chosen the pack manager because it is ideally suited for the placing of widgets,
    either in a side-by-side or top-down position.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`pack()`布局管理器来放置所有小部件。我们选择使用pack管理器，因为它非常适合放置小部件，无论是并排还是自上而下的位置。
- en: Fortunately, in a text editor, we have all the widgets placed either side by
    side or in top-down positions. Thus, it is beneficial to use the pack manager.
    We can do the same thing with the grid manager as well.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，在文本编辑器中，我们所有的组件都放置在左右两侧或上下位置。因此，使用打包管理器是有益的。我们也可以用网格管理器做同样的事情。
- en: A note on code styling
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 关于代码风格的说明
- en: One of the key insights of the Python community is that code is read much more
    often than it is written. Following good naming conventions and consistency in
    code styling are key to maintaining readable and scalable programs. We will try
    to stick to the official Python styling guide, which is specified in the PEP8
    documentation at [https://www.python.org/dev/peps/pep-0008](https://www.python.org/dev/peps/pep-0008).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Python 社区的一个重要洞见是代码的阅读频率远高于其编写频率。遵循良好的命名规范和代码风格的统一是保持程序可读性和可扩展性的关键。我们将努力遵守官方的
    Python 风格指南，该指南在 PEP8 文档中指定，网址为 [https://www.python.org/dev/peps/pep-0008](https://www.python.org/dev/peps/pep-0008)。
- en: 'Some important styling conventions that we will stick to include the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将坚持的一些重要格式规范包括以下内容：
- en: Use four spaces per indentation level
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个缩进级别使用四个空格
- en: Variable and function names will be lowercase, with words separated by underscores
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量和函数名称将采用小写，单词之间用下划线分隔
- en: Class names will use the `CapWords` convention
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类名将使用`CapWords`约定
- en: 'Let''s start by adding the Toplevel window using the following code:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从使用以下代码添加顶层窗口开始：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Note a slight difference in the way we import `tkinter` here. In the last chapter,
    we imported `tkinter` using this code:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们在这里导入 `tkinter` 的方式略有不同。在上一章中，我们使用以下代码导入 `tkinter`：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Since we used `tk` as an alias, we had to append the alias name to every call
    made to a class defined in Tkinter, as in `tk.Tk()`, `tk.Frame`, `tk.Button`,
    `tk.END`, and so on.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用了`tk`作为别名，因此必须将别名名称添加到对Tkinter中定义的每个类的调用中，例如`tk.Tk()`、`tk.Frame`、`tk.Button`、`tk.END`等等。
- en: 'From this chapter onward, we will directly import the individual class that
    we will need for a given program. So, now that we need the `Tk()` class from Tkinter,
    we directly import it into our namespace as:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 从本章开始，我们将直接导入给定程序所需的单个类。因此，现在我们需要从Tkinter导入`Tk()`类，我们将其直接导入到我们的命名空间中，如下所示：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This, in turn, means that we can now directly reference it as the `Tk` class
    in our program without needing to append any alias name to it as in `root = Tk()`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们现在可以直接在我们的程序中将它引用为`Tk`类，而不需要像在`root = Tk()`中那样给它添加任何别名。
- en: 'A third method is to import all (`*`) the classes from Tkinter into the namespace
    by using the following command:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种方法是使用以下命令将Tkinter中的所有（`*`）类导入到命名空间中：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The asterisk symbol means we want everything from `tkinter` to be imported into
    the namespace, regardless of whether we use it. This is, however, bad programming
    practice as it leads to namespace pollution. Furthermore, in larger programs,
    it can be hard to tell which module a particular class has been imported from,
    thus making debugging a difficult task.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 星号符号表示我们希望将`tkinter`库中的所有内容导入到命名空间中，无论我们是否使用它。然而，这种做法是糟糕的编程习惯，因为它会导致命名空间污染。此外，在更大的程序中，很难确定某个类是从哪个模块导入的，这使得调试变得困难。
- en: Adding a menu and menu items
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加菜单和菜单项
- en: 'Menus offer a very compact way of presenting a large number of choices to the user
    without cluttering the interface. Tkinter offers the following two widgets to
    handle menus:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 菜单提供了一种非常紧凑的方式来向用户展示大量选择，而不会使界面显得杂乱。Tkinter提供了以下两个小部件来处理菜单：
- en: '**Menu widget**: This appears at the top of applications, which is always visible
    to end users'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**菜单小部件**：这出现在应用程序的顶部，始终对最终用户可见'
- en: '**Menu items**: These show up when a user clicks on a menu'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**菜单项**：当用户点击菜单时显示出来'
- en: 'We will use the following code to add Toplevel menu buttons:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下代码来添加顶层菜单按钮：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'For example, to add a `File` menu, we will use the following code:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要添加一个“文件”菜单，我们将使用以下代码：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following screenshot is the result of the preceding code (`2.01.py`):'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图是前面代码（`2.01.py`）的结果：
- en: '![](img/a27eb2da-668c-4f19-b38f-3999e4804f98.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a27eb2da-668c-4f19-b38f-3999e4804f98.png)'
- en: Similarly, we will add the Edit, View, and About menus (`2.01.py`*)*.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们将添加编辑、查看和关于菜单（`2.01.py`*）。
- en: 'We will also define a constant as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将定义一个如下常量：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, we''ll set the root window tile, as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将设置根窗口瓷砖，如下所示：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Most Linux platforms support **tear-off menus**. When `tearoff` is set to `1`
    (enabled), the menu appears with a dotted line above the menu options. Clicking
    on the dotted line enables the user to literally tear off or separate the menu
    from the top. However, as this is not a cross-platform feature, we have decided
    to disable tear-off, marking it as `tearoff = 0`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数Linux平台支持**可撕离菜单**。当`tearoff`设置为`1`（启用）时，菜单选项上方会出现一条虚线。点击虚线允许用户实际上撕离或从顶部分离菜单。然而，由于这不是一个跨平台特性，我们已决定禁用撕离功能，将其标记为`tearoff
    = 0`。
- en: Adding menu items
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加菜单项
- en: 'Next, we will add menu items in every individual menu. Not surprisingly, the
    code for the menu items needs to be added in the respective menu instance, as
    shown in the following screenshot:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在每个单独的菜单中添加菜单项。不出所料，菜单项的代码需要添加到相应的菜单实例中，如下面的截图所示：
- en: '![](img/49bcab0c-fb53-475a-abe7-07cdf34224f9.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/49bcab0c-fb53-475a-abe7-07cdf34224f9.png)'
- en: In our example, we will add menu items to the File, Edit, and About menus (`2.02.py`).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们将向文件、编辑和关于菜单中添加菜单项 (`2.02.py`)。
- en: The View menu has certain menu item variations, which will be tackled in the following
    section and are therefore not dealt with here.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 视图菜单包含某些菜单项变体，这些将在下一节中讨论，因此在此处不予处理。
- en: 'Menu items are added by using the `add_command()` method. The format used to
    add menu items is as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 菜单项是通过使用`add_command()`方法添加的。添加菜单项所使用的格式如下：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'For example, you can create the Undo menu item by using the following syntax:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可以通过以下语法创建撤销菜单项：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Some new menu-specific options that are introduced in the preceding code are as
    follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面代码中引入的一些特定菜单选项如下：
- en: '`accelerator`: This option is used to specify a string, typically a keyboard shortcut,
    that can be used to invoke a menu. The string specified as an `accelerator` appears
    next to the text of the menu item. Please note that this does not automatically
    create bindings for the keyboard shortcut. We will have to manually set them up.
    This will be discussed later.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`加速器`: 此选项用于指定一个字符串，通常是键盘快捷键，可以用来调用菜单。作为`加速器`指定的字符串将出现在菜单项文本旁边。请注意，这并不会自动创建键盘快捷键的绑定。我们还需要手动设置它们。这将在稍后讨论。'
- en: '`compound`: Specifying a `compound` option for a menu item lets you add images
    beside a menu label. A specification such as `compound=''left''`,  `label= ''Cut''`,
    `image=cut_icon` means that the cut icon will appear to the left of the Cut menu
    label. The icons that we will use here are stored and referenced in a separate
    folder called `icons`.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`compound`: 为菜单项指定`compound`选项可以让您在菜单标签旁边添加图片。例如，`compound=''left''`, `label=
    ''Cut''`, `image=cut_icon`这样的指定意味着剪切图标将出现在“剪切”菜单标签的左侧。我们将在这里使用的图标存储并引用在一个名为`icons`的单独文件夹中。'
- en: '`underline`: The `underline` option lets you specify the index of a character in
    the menu text that needs to be underlined. The indexing starts at `0`, which means
    that specifying `underline=1` underlines the second character of the text. Besides
    underlining, Tkinter also uses it to define the default bindings for the keyboard
    traversal of menus. This means that we can select the menu either with the mouse
    pointer or with the *Alt* + *<character_at_the_underlined_index>* shortcut.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`下划线`: `下划线`选项允许您指定菜单文本中需要加下划线的字符索引。索引从`0`开始，这意味着指定`underline=1`将下划线添加到文本的第二个字符。除了下划线外，Tkinter还使用它来定义菜单键盘遍历的默认绑定。这意味着我们可以用鼠标指针或使用*Alt*
    + *下划线索引处的字符*快捷键来选择菜单。'
- en: 'To add the `New` menu item in the File menu, use the following code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要在文件菜单中添加“新建”菜单项，请使用以下代码：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Menu separators
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 菜单分隔符
- en: Occasionally, in menu items, you will come across code such as `my_menu.add_separator()`.
    This widget displays a separator bar and is solely used to organize similar menu
    items in groups, separating groups by horizontal bars.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在菜单项中，你会遇到如下代码 `my_menu.add_separator()`。此小部件显示一个分隔条，仅用于将相似菜单项分组，通过水平条分隔各个组。
- en: 'Next, we will add a Frame widget to hold the shortcut icons. We will also add a
    Text widget to the left to display line numbers, as shown in the following screenshot
    (`2.02.py`):'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '接下来，我们将添加一个框架小部件来容纳快捷图标。我们还将向左侧添加一个文本小部件来显示行号，如下面的屏幕截图所示 (`2.02.py`):'
- en: '![](img/5542a195-8fa9-46d9-adde-842056ebe5fd.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5542a195-8fa9-46d9-adde-842056ebe5fd.png)'
- en: When working with the pack geometry manager, it is important to add widgets
    in the order in which they will appear because `pack()` uses the concept of available
    space to fit the widgets. This is why the text content widget will appear lower
    in the code compared to the two label widgets.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用包装布局管理器时，按照它们将出现的顺序添加小部件非常重要，因为`pack()`使用可用空间的概念来适应小部件。这就是为什么文本内容小部件在代码中相对于两个标签小部件会出现在更低的位置。
- en: 'Having reserved the space, we can later add shortcut icons or line numbers
    and keep the Frame widget as the parent widget. Adding frames is easy; we have
    done that in the past. The code is as follows (refer to `2.02.py`):'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 保留空间后，我们可以在以后添加快捷图标或行号，并将框架小部件作为父小部件。添加框架非常简单；我们以前已经这样做过了。代码如下（参考`2.02.py`）：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We have applied a background color to these two widgets, for now, to differentiate
    them from the body of the Toplevel window.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经为这两个小部件应用了背景颜色，目前是为了将它们与Toplevel窗口的主体区分开来。
- en: Lastly, let's add the main Text widget and the Scrollbar widget, as follows
    (`2.02.py`)*:*
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们添加主文本小部件和滚动条小部件，如下所示 (`2.02.py`)*:*
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The code is similar to how we instantiated all the other widgets so far. However, note
    that the scrollbar is configured to `yview` of the Text widget, and the Text widget is
    configured to connect to the Scrollbar widget. This way, the widgets are cross-connected
    to each other.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 代码与我们迄今为止实例化所有其他小部件的方式相似。然而，请注意，滚动条被配置为与 Text 小部件的 `yview` 相关联，而 Text 小部件被配置为连接到滚动条小部件。这样，小部件之间就实现了交叉连接。
- en: Now, when you scroll down the Text widget, the scrollbar reacts to it. Alternatively,
    when you move the scrollbar, the Text widget reacts in turn.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你向下滚动文本小部件时，滚动条会做出反应。或者，当你移动滚动条时，文本小部件会相应地做出反应。
- en: Implementing the View menu
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现视图菜单
- en: 'Tkinter offers the following three varieties of menu item:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter 提供以下三种菜单项类型：
- en: '**Checkbutton menu items**: These let you make a yes/no choice by checking/unchecking
    the menu item'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复选框菜单项**：这些选项允许您通过勾选/取消勾选菜单项来做出是/否的选择'
- en: '**Radiobutton menu items**: These let you choose an option from many different
    options'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单选按钮菜单项**：这些选项允许您从许多不同的选项中选择一个'
- en: '**Cascade menu items**: These menu items only open up to show another list
    of choices'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**级联菜单项**：这些菜单项仅展开以显示另一列表选项'
- en: 'The following View menu shows these three menu item types in action:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 以下视图菜单显示了这三种菜单项类型在实际操作中的效果：
- en: '![](img/f3cae6b3-ec45-482f-a8c3-54fb7960cc3b.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f3cae6b3-ec45-482f-a8c3-54fb7960cc3b.png)'
- en: The first three menu items in the View menu let users make a definite yes or
    no choice by checking or unchecking thems. These are examples of the Checkbutton
    menu.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 视图菜单中的前三个菜单项允许用户通过勾选或取消勾选它们来做出明确的肯定或否定选择。这些都是复选框菜单的例子。
- en: The Themes menu item in the preceding screenshot is an example of a Cascade menu.
    Hovering over this Cascade menu simply opens another list of menu items. However,
    we can also bind a menu item by using the `postcommand=callback` option. This
    can be used to manage something just before bringing up the cascading menu item's
    contents and is often used for dynamic list creation.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 前一截图中的“主题”菜单项是一个级联菜单的示例。将鼠标悬停在此级联菜单上会简单地打开另一个菜单项列表。然而，我们也可以通过使用`postcommand=callback`选项来绑定一个菜单项。这可以在显示级联菜单项的内容之前管理某些事情，通常用于动态列表创建。
- en: Within the Cascade menu, you are presented with a list of choices for your editor's theme.
    However, you can only select one theme. Selecting one theme deselects any previous
    selections. This is an example of the Radiobutton menu.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在级联菜单中，您将看到为您的编辑器主题提供的选项列表。然而，您只能选择一个主题。选择一个主题将取消之前的选择。这是一个单选按钮菜单的示例。
- en: 'We will not present the entire code here (refer to the `2.03.py` code in the
    code bundle). However, the example code used to add these three types of menu item
    is as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在此处不会展示完整的代码（请参考代码包中的`2.03.py`代码）。然而，用于添加这三种菜单项的示例代码如下：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now, we need to track whether a selection has been made by adding a variable, which
    can be `BooleanVar()`, `IntVar()`, or `Stringvar()`, as discussed in [Chapter
    1](39a58f50-293e-4ff5-9b65-0d9e0c0cc15e.xhtml)*, Meet Tkinter*.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要通过添加一个变量来跟踪是否已做出选择，这个变量可以是`BooleanVar()`、`IntVar()`或`StringVar()`，正如在[第1章](39a58f50-293e-4ff5-9b65-0d9e0c0cc15e.xhtml)*，认识Tkinter*中讨论的那样。
- en: This concludes our first iteration. In this iteration, we laid down the majority
    of the visual elements of the text editor. Now it's time to add some functionalities
    to the editor.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这标志着我们第一次迭代的结束。在这个迭代中，我们奠定了文本编辑器的大部分视觉元素。现在，是时候给编辑器添加一些功能了。
- en: Adding a built-in functionality
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加内置功能
- en: Tkinter's Text widget comes with some handy built-in functionalities to handle common
    text-related functions. Let's leverage these functionalities to implement some
    common features in the text editor.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter的Text小部件提供了一些方便的内置功能来处理常见的文本相关功能。让我们利用这些功能来实现文本编辑器中的常见特性。
- en: Let's start by implementing the `cut`, `copy`, and `paste` features. We now
    have the editor GUI ready. If you open the program and play with the Text widget,
    you will see that you can perform basic functions such as `cut`, `copy`, and `paste`
    in the text area by using *Ctrl* + *X*, *Ctrl* + *C*, and *Ctrl* + *V*, respectively.
    All of these functions exist without us having to add a single line of code for
    these functionalities.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从实现`剪切`、`复制`和`粘贴`功能开始。现在我们已经准备好了编辑器GUI。如果你打开程序并玩一下文本小部件，你会看到你可以通过使用*Ctrl*
    + *X*、*Ctrl* + *C*和*Ctrl* + *V*分别来在文本区域执行基本的`剪切`、`复制`和`粘贴`操作。所有这些功能都存在，我们不需要为这些功能添加任何一行代码。
- en: The Text widget clearly comes with these built-in events. Now, we simply want
    to connect these events to their respective menu items.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 文本小部件显然自带了这些内置事件。现在，我们只需要将这些事件连接到它们各自的菜单项。
- en: 'The documentation of the Tcl/Tk universal widget methods tells us that we can
    trigger events without an external stimulus by using the following command:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Tcl/Tk通用小部件方法的文档告诉我们，我们可以通过以下命令来触发事件，而不需要外部刺激：
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To trigger the Cut event, all we need is the following line in the code:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 要触发剪切事件，我们只需要在代码中添加以下这一行：
- en: '[PRE15]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let''s call it by using a `cut` function and associate it with the Cut menu
    by using the callback command (`2.04.py`):'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过使用一个`cut`函数来称呼它，并通过回调命令将其与Cut菜单关联（`2.04.py`）：
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then, define a callback command from the existing Cut menu, as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，从现有的剪切菜单中定义一个回调命令，如下所示：
- en: '[PRE17]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Similarly, trigger the `copy` and `paste` functions from their respective menu
    items.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，从各自的菜单项中触发`复制`和`粘贴`功能。
- en: 'Next, we will move on to the implementation of the `undo` and `redo` features.
    The Tcl/Tk text documentation tells us that the Text widget has an unlimited Undo
    and Redo mechanism provided we set the undo option to `true` or `1`. To leverage
    this option, let''s first set the Text widget''s undo option to `true` or `1`,
    as shown in the following code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now, if you open the text editor and try out the `undo` feature by using *Ctrl*
    + *Z*, it should work well. Now, we only have to associate the events to functions
    and call back the functions from the Undo menu. This is similar to what we did
    for `cut`, `copy`, and `paste`. Refer to the code in `2.03.py`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: However, `redo` has a little quirk that needs to be addressed. By default, `redo`
    is not bound to the *Ctrl* + *Y* keys. Instead, *Ctrl* + *Y* is bound to the `paste`
    functionality. This is not how we expect the binding to behave, but it exists
    due to some historical reasons related to Tcl/Tk.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, it is easy to override this functionality by adding an event binding, as
    follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，通过添加事件绑定，可以轻松覆盖此功能，如下所示：
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Since an event binding like the one in the preceding code sends an event argument, the
    `undo` function must be able to handle this incoming parameter. Therefore, we''ll add
    the `event=None` optional parameter to the `redo` function, as follows (`2.04.py`):'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Events propagate from the operating system level and are accessible to the window that
    subscribes to the event or wants to make use of it. The `return 'break'` expression
    in the preceding function tells the system that it has performed the event and
    that it should not be propagated further.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: This prevents the same event from firing the `paste` event even though it is
    the default behavior in Tkinter. Now, *Ctrl* + *Y* fires the `redo` event instead
    of firing the `paste` event.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: In fact, once we have performed an event, we do not want it to propagate further. Thus,
    we will add return `break` to all event-driven functions.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Indexing and tagging
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Though we managed to leverage some built-in functionalities to gain a quick advantage,
    we need more control over the text area so that we can bend it to our will. This
    will require the ability to target each character or text location with precision.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: We will need to know the exact position of each character, the cursor, or the
    selected area in order to do anything with the contents of the editor.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: The Text widget offers us the ability to manipulate its content using **index**,
    **tags**, and **mark**, which let us target a position or place within the text
    area for manipulation.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Index
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Indexing helps you target a particular place within a piece of text. For example,
    if you want to mark a particular word in bold, red, or in a different font size,
    you can do so if you know the index of the starting point and the index of the
    endpoint that needs to be targeted.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'The index must be specified in one of the following formats:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '| **The index format** | **Description** |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
- en: '| `x.y` | This refers to the character at row `x` and column `y`. |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
- en: '| `@x,y` | This refers to the character that covers the `x,y` coordinate within
    the text''s window. |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
- en: '| `end` | This refers to the end of the text. |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
- en: '| `mark` | This refers to the character after a named mark. |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
- en: '| `tag.first` | This refers to the first character in the text that has been
    tagged with a given tag. |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
- en: '| `tag.last` | This refers to the last character in the text that has been
    tagged with a given tag. |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
- en: '| `selection` (`SEL_` `FIRST`, `SEL_LAST`) | This corresponds to the current
    selection. The `SEL_FIRST` and `SEL_LAST` constants refer to the start position
    and end position in the selection. Tkinter raises a `TclError` exception if there
    is no selection. |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
- en: '| `window_name` | This refers to the position of the embedded window named `window_name`.
    |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
- en: '| `image_name` | This refers to the position of the embedded image named `image_name`.
    |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
- en: '| `INSERT` | This refers to the position of the insertion cursor. |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
- en: '| `CURRENT` | This refers to the position of the character that is closest
    to the mouse pointer. |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
- en: Note a small quirk here. The counting of rows in a Text widget starts at 1,
    while the counting of columns starts at 0\. Therefore, the index for the starting
    position of the Text widget is 1.0 (that is, row number 1 and column number 0).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: 'An index can be further manipulated by using modifiers and submodifiers. Some examples
    of modifiers and submodifiers are as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '`end - 1 chars` or `end - 1 c`: This refers to the index of the character before
    the one at the end'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`insert +5lines`: This refers to the index five lines ahead of the insertion cursor'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`insertwordstart - 1 c`: This refers to the character just before the first
    one in a word containing the insertion cursor'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`end linestart`: This refers to the index of the line start of the end line'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Indexes are often used as arguments to functions. Refer to the following list
    for some examples:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '`my_text.delete`(`1.0`,`END`) : This means that you can delete from line `1`
    , column `0` until the end'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`my_text.get`(`1.0,` `END`) : This gets the content from 1.0 (beginning) to
    the end'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`my_text.delete`(''`insert-1c`'', `INSERT`) : This deletes a character at the insertion
    cursor'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tags
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tags are used to annotate text with an identification string that can then be
    used to manipulate the tagged text. Tkinter has a built-in tag called **SEL**,
    which is automatically applied to the selected text. In addition to SEL, you can
    define your own tags. A text range can be associated with multiple tags, and the
    same tag can be used for many different text ranges.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples of tagging:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You can specify the visual style for a given tag with `tag_config`, using options such
    as `background` (color), `bgstipple` (bitmap), `borderwidth` (distance), `fgstipple`
    (bitmap), `font` (font), `foreground` (color), `justify` (constant), `lmargin1`
    (distance), `lmargin2` (distance), `offset` (distance), `overstrike`
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: (flag), `relief` (constant), `rmargin` (distance), `spacing1` (distance), `tabs` (string),
    `underline` (flag), and `wrap` (constant).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 'For a complete reference about text indexing and tagging, type the following
    command into the Python interactive shell:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Equipped with a basic understanding of indexing and tagging, let's implement
    some more features in the code editor.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Select All feature
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We know that Tkinter has a built-in `sel` tag that applies a selection to a
    given text range. We want to apply this tag to the entire text in the widget.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'We can simply define a function to handle this, as follows (`2.05.py`):'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'After doing this, add a callback to the `Select All` menu item:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We also need to bind the function to the *Ctrl* + *A* keyboard shortcut. We
    do this by using the following key bindings (`2.05.py`):'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The coding of the `Select All` feature is complete. To try it out, add some
    text to the text widget and then click on the menu item, `Select All`, or use
    *Ctrl* + *A* (`accelerator` shortcut key).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Find Text feature
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, let''s code the `Find Text` feature (`2.05.py`). The following screenshot
    shows an example of the `Find Text` feature:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e65263f9-ca09-42f9-9550-1d9176729b9c.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
- en: Here's a quick summary of the desired functionality. When a user clicks on the
    Find menu item, a new Toplevel window opens up. The user enters a search keyword
    and specifies whether the search needs to be case-sensitive. When the user clicks
    on the Find All button, all matches are highlighted.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: 'To search through the document, we rely on the `text_widget.search()`method.
    The search method takes in the following arguments:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'For the editor, define a function called `find_text` and attach it as a callback
    to the Find menu (`2.05.py`):'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Also, bind it to the *Ctrl* + *F* shortcut, as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Then, define the `find_text` function, as follows (`2.05.py`):'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The following is a description of the preceding code (`2.05.py`):'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: When a user clicks on the Find menu item, it invokes a `find_text` callback.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first four lines of the `find_text()` function create a new Toplevel window,
    add a window title, specify its geometry (size, shape, and location), and set
    it as a *transient window*. Setting it as a transient window means that it is
    always drawn on top of its parent or root window. If you comment out this line
    and click on the root editor window, the Find window will go behind the root window.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next eight lines of code are pretty self-explanatory; they set the widgets
    of the Find window. They add the Label, Entry, Button, and Checkbutton widgets,
    and set up the `search_string` and `ignore_case_value` variables to track the
    value a user enters into the Entry widget and whether the user has checked off Checkbutton.
    The widgets are arranged by using the grid geometry manager to fit into the Find
    window.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Find All button has a command option that calls a `search_output` function,
    passing the search string as the first argument and whether the search needs to
    be case-sensitive as its second argument. The third, fourth, and fifth arguments
    pass the Toplevel window, the Text widget, and the Entry widget as parameters.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We override the Close button of the Find window and redirect it to a callback
    named `close_search()`. The `close_search` function is defined within the `find_text`
    function. This function takes care of removing the match tag that was added during
    the search. If we do not override the Close button and remove these tags, the matched
    string will continue to be marked in red and yellow even after the search has
    ended.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, we define the `search_output` function, which does the actual searching
    and adds the match tag to the matching text. The code for this is as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The following is a description of the preceding code:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: This part of the code is the heart of the `search` function. It searches through the
    entire document by using the `while True` loop, breaking out of the loop only
    if no more text items remain to be searched.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code first removes the previous search-related match tags if there are
    any, as we do not want to append the results of the new search to the previous
    search results. The function uses the `search()` method, which is provided in
    Tkinter in the Text widget. The `search()` method takes the following arguments:'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `search()` method returns the starting position of the first match. We store it
    in a variable named `start_pos`, calculate the position of the last character in
    the matched word, and store it in the `end_pos` variable.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For every search match that it finds, it adds the match tag to the text ranging from
    the first position to the last position. After every match, we set the value of
    `start_pos` to be equal to `end_pos`. This ensures that the next search starts after
    `end_pos`.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The loop also keeps track of the number of matches by using the `count` variable.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Outside the loop, the tag match is configured to have a red font and yellow background.
    The last line of this function updates the title of the Find window with the number
    of matches that were found.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In case of event bindings, interaction occurs between input devices (keyboard/mouse)
    and your application. In addition to event binding, Tkinter also supports protocol
    handling.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: The term protocol refers to the interaction between your application and the
    window manager. An example of a protocol is `WM_DELETE_WINDOW`, which handles
    the close window event for your window manager.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'Tkinter lets you override these protocol handlers by mentioning your own handler
    for the root or Toplevel widget. To override the window exit protocol, we use
    the following command:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '`root.protocol(WM_DELETE_WINDOW, callback)`'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Once you add this command, Tkinter reroutes protocol handling to the specified
    callback/handler.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Types of Toplevel window
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Previously in this chapter, we used the following line of code:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Let''s explore what it means here. Tkinter supports the following four types
    of Toplevel window:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '**The main Toplevel window**: This is the type we have been constructing so
    far.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The child Toplevel window**: This type is independent of the root. The Toplevel
    child behaves independently of its root, but it gets destroyed if its parent is
    destroyed.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The transient Toplevel window:** This always appears at the top of its parent, but
    it does not entirely grab the focus. Clicking again on the parent window allows
    you to interact with it. The transient window is hidden when the parent is minimized,
    and it is destroyed if the parent is destroyed. Compare this to what is called
    a **modal window**. A modal window grabs all the focus from the parent window
    and asks a user to first close the modal window before regaining access to the
    parent window.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The undecorated Toplevel window:** A Toplevel window is undecorated if it
    does not have a window manager decoration around it. It is created by setting
    the **overrideredirect** flag to `1`. An undecorated window cannot be resized
    or moved.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refer to the `2.06.py` code for a demonstration of all four types of Toplevel
    window.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our second iteration. Congratulations! We have completed coding
    the `Select All` and `Find Text` functionality into our program.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: More importantly, you have been introduced to indexing and tagging—two very powerful
    concepts associated with many Tkinter widgets. You will find yourself using these
    two concepts all the time in your projects.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: We also explored the four types of Toplevel window and the use cases for each
    of them.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Working with forms and dialogs
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The goal for this iteration is to implement the functionality of the File menu
    options: Open, Save, and Save As.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: We can implement these dialogs by using the standard Tkinter widgets. However, since
    these are so commonly used, a specific Tkinter module called `filedialog` has been
    included in the standard Tkinter distribution.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of a typical `filedialog`:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a40730bd-4116-4362-9a5d-1f382b377be3.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
- en: 'Tkinter defines the following common use cases for `filedialogs`:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '| **Functions** | **Description** |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
- en: '| `askopenfile` | This returns the opened file object |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
- en: '| `askopenfilename` | This returns the filename string, not the opened file
    object |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
- en: '| `askopenfilenames` | This returns a list of filenames |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
- en: '| `askopenfiles` | This returns a list of open file objects or an empty list
    if Cancel is selected |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
- en: '| `asksaveasfile` | This asks for a filename to save as and returns the opened
    file object |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
- en: '| `asksaveasfilename` | This asks for a filename to save as and returns the
    filename |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
- en: '| `askdirectory` | This asks for a directory and returns the directory name
    |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
- en: 'The usage is simple. Import the `filedialog` module and call the required function. Here''s
    an example:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We then call the required function using the following code:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Or, we use this code:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `mode='r'` option specified in the preceding code is one of many configurable
    options that are available for dialogs.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: 'You can specify the following additional options for `filedialog`:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '| **File dialog** | **Configurable options** |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
- en: '| `askopenfile` (`mode=''r''`, `**options`) | `parent`, `title`, `message`,
    `defaultextension`, `filetypes`, `initialdir`, `initialfile`, and multiple |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
- en: '| `askopenfilename` (`**options`) | `parent`, `title`, `message`, `defaultextension`, `filetypes`,
    `initialdir`, `initialfile`, and multiple |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
- en: '| `asksaveasfile` (`mode=''w''`, `**options`) | `parent`, `title`, `message`,
    `defaultextension`, `filetypes`, `initialdir`, `initialfile`, and multiple |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
- en: '| `asksaveasfilename` (`**options`) | `parent`, `title`, `message`, `defaultextension`, `filetypes`,
    `initialdir`, `initialfile`, and multiple |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
- en: '| `askdirectory` (`**options`) | `parent`, `title`, and `initialdir` must exist
    |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
- en: Equipped with a basic understanding of the `filedialog` module, let's now have
    a look at its practical usage. We'll begin by implementing the File | Open feature.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by importing the required modules, as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Next, let''s create a global variable, which will store the name of the currently
    open file, as follows:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The use of global variables is generally considered bad programming practice
    because it is very difficult to understand a program that uses lots of global
    variables.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: A global variable can be modified or accessed from many different places in
    the program. Therefore, it becomes difficult to remember or work out every possible
    use of the variable.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: A global variable is not subject to access control, which may pose security hazards
    in certain situations, say when this program needs to interact with third-party
    code.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: However, when you work on programs in a procedural style such as this one, global
    variables are sometimes unavoidable.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: An alternative approach to programming involves writing code in a class structure
    (also called object-oriented programming), where a variable can only be accessed
    by members of predefined classes. We will see a lot of examples of object-oriented
    programming in the chapters that follow.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is present in `open_file` (`2.07.py`):'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Modify the Open menu to add a callback command to this newly defined method, as
    follows:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The following is a description of the preceding code:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: We declared a `file_name` variable in the `global` scope to keep track of the filename
    of the opened file. This is required to keep track of whether a file has been
    opened. We need this variable in the `global` scope as we want this variable to
    be available to other methods, such as `save()` and `save_as()`.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not specifying it as `global` would mean that it is only available within the function.
    So, the `save()` and `save_as()` functions would not be able to check whether
    a file is already open in the editor.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use `askopenfilename` to fetch the filename of the opened file. If a user
    cancels opening the file or no file is chosen, the `file_name` returned is `None`.
    In that case, we do nothing.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, if `filedialog` returns a valid filename, we isolate the filename using
    the `os` module and add it as the title of the root window.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the `Text` widget already contains some text, we delete it all.
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We then open the given file in read mode and insert its content into the Content
    widget.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use the context manager (the `with` command), which takes care of closing
    the file properly for us, even in the case of an exception.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we add a command callback to the File | Open menu item.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This completes the coding of File | Open. If you now navigate to File | Open,
    select a text file, and click on Open, the content area will be populated with
    the content of the text file.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will have a look at how to save a file. There are two aspects to saving
    a file:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: Save
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Save As
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the Content text widget already contains a file, we do not prompt the user
    for a filename. We simply overwrite the contents of the existing file. If there
    is no filename associated with the current content of the text area, we prompt
    the user with a Save As dialog. Moreover, if the text area has an open file and
    the user clicks on Save As, we still prompt them with a Save As dialog to allow
    them to write the contents to a different filename.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for `save` and `save_as` is as follows (`2.07.py`):'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Having defined the `save` and `save_as` functions, let''s connect them to the
    respective menu callback:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The following is a description of the preceding code:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: The `save` function first tries to check whether a file is open. If a file is
    open, it simply overwrites the contents of the file with the current contents
    of the text area. If no file is open, it simply passes the work to the `save_as`
    function.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `save_as` function opens a dialog by using `asksaveasfilename` and tries to
    get the filename provided by the user for the given file. If it succeeds, it opens
    the new file in write mode and writes the contents of the text under this new
    filename. After writing, it closes the current file object and changes the title
    of the window to reflect the new filename.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the user does not specify a filename or the user cancels the `save_as` operation,
    it simply ignores the process by using a pass command.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We added a `write_to_file(file_name)` helper function to do the actual writing
    to the file.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'While we are at it, let''s complete the functionality of File | New. The code
    is simple (`2.07.py`):'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, add a callback command to this new function to the File | New menu item:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The following is a description of the preceding code:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: The `new_file` function begins by changing the title attribute of the root window
    to `Untitled`.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It then sets the value of the `global` filename variable to `None`. This is important
    because the `save` and `save_as` functionalities use this global variable name
    to track whether the file already exists or is new.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The function then deletes all the contents of the `Text` widget, creating a
    fresh document in its place.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s wrap up this iteration by adding keyboard shortcuts for the newly created features
    (`2.07.py`):'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In this iteration, we implemented the coding functionality for the New, Open,
    Save, and Save As menu items.  More importantly, we saw how to use the `filedialog`
    module to achieve certain commonly used file features in the program. We also
    had a look at how to use indexing to achieve a wide variety of tasks for programs.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: Working with message boxes
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's complete the code for the About and Help menus. The functionality
    is simple. When a user clicks on the Help or About menu, a message window pops
    up and waits for the user to respond by clicking on a button. Though we can easily
    code new Toplevel windows to show the About and Help messages, we will instead
    use a module called `messagebox` to achieve this functionality.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: 'The `messagebox` module provides ready-made message boxes to display a wide variety
    of messages in applications. The functions available through this module include
    `showinfo`, `showwarning`, `showerror`, `askquestion`, `askokcancel`, `askyesno`, `askyesnocancel`,
    and `askretrycancel`, as shown in the following screenshot:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2cf16643-5cbb-4ba8-ab6a-fd7bd085e4e3.png)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
- en: 'To use this module, we simply import it into the current namespace by using
    the following command:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'A demonstration of the commonly used functions of `messagebox` is provided
    in `2.08.py` in the code bundle. The following are some common usage patterns:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Equipped with an understanding of the `messagebox` module, let's code the `about` and
    `help` functions for the code editor. The functionality is simple. When a user clicks
    on the About or Help menu item, a `showinfomessagebox` pops up.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve this, include the following code in the editor (`2.09.py`):'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Then, attach these functions to the respective menu items, as follows:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Next, we will add the quit confirmation feature. Ideally, we should have implemented
    file saving in the event the text content has been modified, but for the sake
    of simplicity I am not putting in that logic here and instead am displaying a
    prompt for the user to determine whether the program should be closed or kept
    open. Accordingly, when the user clicks on File | Exit, it prompts an Ok-Cancel
    dialog to confirm the quit action:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Then, we override the Close button and redirect it to the `exit_editor` function
    that we previously defined, as follows:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Then, we add a callback command for all the individual menu items, as follows:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Finally, add the bindings for the keyboard shortcut to display help:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This completes the iteration.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: The icons toolbar and View menu functions
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this iteration, we will add the following functionalities to the text editor:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: Showing shortcut icons on the toolbar
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying line numbers
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Highlighting the current line
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the color theme of the editor
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s start with a simple task first. In this step, we will add shortcut icons
    to the toolbar, as shown in the following screenshot:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2d7d1652-4c63-4c07-aaf7-a13eb4683fa3.png)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
- en: You may recall that we have already created a frame to hold these icons. Let's
    add these icons now.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: While adding these icons, we have followed a convention. The icons have been named
    exactly the same as the corresponding function that handles them. Following this
    convention has enabled us to loop through a list, simultaneously apply the icon image
    to each button, and add the command callback from within the loop. All the icons
    have been placed in the icons folder.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code adds icons to the toolbar (`2.10.py`):'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The following is a description of the preceding code:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: We have already created a shortcut bar in the first iteration. Now, we will simply
    add buttons with images in the frame.
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We create a list of icons, taking care to name them exactly the same as the
    name of the icons.
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We then loop through the list by creating a Button widget, adding an image to
    the button, and adding the respective callback command.
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before adding the callback command, we have to convert the string to an equivalent
    expression by using the `eval` command. If we do not apply `eval`, it cannot be
    applied as an expression to the callback command.
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thus, we've added shortcut icons to the shortcut bar. Now, if you run the code
    (refer to `2.10.py` in the code bundle), it should show all of the shortcut icons.
    Moreover, as we have linked each button to its callback, all of these shortcut
    icons should work.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: Displaying line numbers
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's work toward showing line numbers to the left of the Text widget. This
    will require us to tweak the code in various places. So, before we start coding,
    let's look at what we are trying to achieve.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: 'The View menu has a menu item that allows users to choose whether to Show Line Number.
    We only want to show line numbers if the option is selected, as shown in the following
    screenshot:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/326c66d9-eb54-493f-b0f0-4630f1b38235.png)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
- en: If the option is selected, we need to display line numbers in the left frame
    that we created earlier.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: The line number should update every time a user enters a new line, deletes a
    line, cuts or pastes line text, performs an undo or a redo operation, opens an existing
    file, or clicks on the New menu item. In short, the line number should be updated
    after every activity results in a change of content. Therefore, we need to define
    a function called `on_content_changed()`. This function should be called after
    the definitions of every `press`, `cut`, `paste`, `undo`, `redo`, `new`, and `open` key,
    to check whether lines have been added or removed from the text area and accordingly
    update the line numbers.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: 'We achieve this by using the following two strategies (refer to `2.10.py` in
    the code bundle):'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Bind a key press event to the `update_line_number()` function, as follows:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Next, add a call to the `on_content_changed()` function in each of the definitions
    of `cut`*,* `paste`*,* `undo`*,* `redo`*,* `new`*,* and `open`*.*
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: Then define a `get_line_numbers()` function that returns a string containing
    all the numbers until the last row, separated by line breaks.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: So for instance, if the last non-empty row in the content widget is `5`, this
    function returns us a string of the `1 /n 2 /n 3 /n 4/n 5 /n` form.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the function definition:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now, let''s define the `update_line_numbers()` function, which simply updates
    the text widget that displays the line using the string output from the previous
    function:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The following is a description of the preceding code:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: 'You may recall that we assigned a `show_line_number` variable to the menu item
    earlier:'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`show_line_number = IntVar()`'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`show_line_number.set(1)`'
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`view_menu.add_checkbutton(label="Show Line Number", variable=show_line_number)`'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If the `show_line_number` option is set to `1` (that is to say, it has been
    checked off in the menu item), we calculate the last line and last column in the
    text.
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We then create a text string consisting of numbers from `1` to the number of
    the last line, with each number separated by a line break (`\n`). This string
    is then added to the left label by using the `line_number_bar.config()` method.
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `Show Line Number` is unchecked in the menu, the variable text remains blank,
    thereby displaying no line numbers.
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we update each of the previously defined `cut`, `paste`, `undo`, `redo`, `new`,
    and `open` functions to invoke the `on_content_changed()` function at its end.
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have finished adding the line number functionality to the text editor. However,
    I would like to add that this implementation, though simple, has some limitations
    in that it does not handle word wrapping and font size variability very well.
    A foolproof line numbering solution would require the use of the Canvas widget
    – something that we discuss Chapter 4 Game of Chess and onward. Meanwhile, if
    you are curious, take a look at a sample Canvas-based implementation at [https://stackoverflow.com/a/16375233/2348704](https://stackoverflow.com/a/16375233/2348704).
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, in this iteration, we will implement a feature where a user can choose
    to highlight the current line (`2.10.py`).
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: The idea is simple. We need to locate the line of the cursor and add a tag to
    the line. We also need to configure the tag so that it appears with a differently
    colored background to highlight it.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: 'You may recall that we have already provided a menu choice to users to decide whether
    to highlight the current line. We will now add a callback command from this menu
    item to a function that we will define as `toggle_highlight`:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now, we define three functions to handle this for us:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The following is a description of the preceding code:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: Every time a user checks/unchecks View | Highlight Current Line, this invokes
    the `toggle_highlight` function. This function checks whether the menu item is
    checked. If it is checked, it invokes the `highlight_line` function. Otherwise,
    if the menu item is unchecked, it invokes the `undo_highlight` function.
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `highlight_line` function simply adds a tag called `active_line` to the current
    line, and after every 100 milliseconds it calls the `toggle_highlight` function
    to check whether the current line should still be highlighted.
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `undo_highlight` function is invoked when the user unchecks highlighting
    in the View menu. Once invoked, it simply removes the `active_line` tag from the
    entire text area.
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, we can configure the tag named `active_line` so that it is displayed
    with a different background color, as follows:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: We used the `.widget.after(ms, callback)` handler in the code.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: 'Methods that let us perform some periodic actions are called alarm handlers.
    The following are some commonly used Tkinter alarm handlers:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: '• `after(delay_ms, callback, args...)`: This registers a callback alarm, which
    can be called after a given number of milliseconds.'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: '• `after_cancel(id)`: This cancels the given callback alarm.'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: '• `after_idle(callback, args...)`: This calls back only when there are no more
    events to process in `mainloop`; that is, after the system becomes idle.'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: Adding the cursor information bar
  id: totrans-375
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The cursor information bar is simply a small label at the bottom-right corner
    of the Text widget that displays the current position of the cursor, as shown
    in the following screenshot:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1028f9ca-8c45-4c73-a0a3-05b66c6c3bc8.png)'
  id: totrans-377
  prefs: []
  type: TYPE_IMG
- en: The user can choose to show/hide this info bar from the View menu (`2.11.py`).
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: 'Begin by creating a Label widget within the Text widget and pack it in the
    bottom-right corner, as follows:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'In many ways, this is similar to displaying line numbers. Here, too, the positions must
    be calculated after every keystroke, after events such as `cut`, `paste`, `undo`,
    `redo`, `new`, and `open`, or activities that lead to a change in cursor positions.
    Because this too needs to be updated for all the changed content, for every keystroke,
    we will update `on_content_changed` to update this, as follows:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The code is simple. We get the row and column for the current cursor position
    by using the `index(INSERT)` method and update the labels with the latest row
    and column of the cursor.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the function is connected to the existing menu item by using a callback
    command:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Adding themes
  id: totrans-386
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You may recall that, while defining the Themes menu, we defined a color scheme dictionary
    containing the name and hexadecimal color codes as a key-value pair, as follows:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The theme choice menu has already been defined. Let''s add a callback command
    to handle the selected menu (`2.12.py`):'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: '`themes_menu.add_radiobutton(label=k, variable=theme_choice, command=change_theme)`.'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s define the `change_theme` function to handle the changing of
    themes, as follows:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The function is simple. It picks up the key-value pair from the defined color
    scheme dictionary. It splits the color into its two components and applies one
    color each to the Text widget foreground and background using `widget.config()`.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: Now, if you select a different color from the Themes menu, the background and foreground
    colors change accordingly.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: This completes the iteration. We completed coding the shortcut icon toolbar
    and the functionality of the View menu in this iteration. In the process, we learned
    how to handle the `Checkbutton` and `Radiobutton` menu items. We also had a look
    at how to create compound buttons while reinforcing several Tkinter options that
    were covered in the previous sections.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: Creating a context/pop-up menu
  id: totrans-396
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s complete the editor in this final iteration by adding a contextual menu
    to the editor *(*`2.12.py`)*,* as shown in the following screenshot:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e8870938-b80e-4be4-b902-e2af2920b8ed.png)'
  id: totrans-398
  prefs: []
  type: TYPE_IMG
- en: The menu that pops up on a right-click at the location of the cursor is called
    the **context menu** or the **pop-up menu**.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s code this feature in the text editor. First, define the context menu,
    as follows:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Then, bind the right-click of a mouse with a callback named `show_popup_menu`, as
    follows:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Finally, define the `show_popup_menu` function in the following way:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: You can now right-click anywhere on the Text widget in the editor to open the contextual
    menu.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: This concludes the iteration as well as the chapter.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-408
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we covered the following points:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: We completed coding the editor in twelve iterations. We started by placing all
    the widgets on the Toplevel window.
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We then leveraged some built-in features of the Text widget to code some functionality.
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We learned the important concepts of indexing and tagging.
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also saw how to use the `filedialog` and `messagebox` modules to quickly
    code some common features in programs.
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Congratulations! You completed coding your text editor. In the next chapter,
    we will make a programmable drum machine.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: QA section
  id: totrans-415
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a few questions to reflect upon:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: What's the difference between the Checkbutton menu item and the Radio button
    menu item?
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What's the Cascade menu button used for?
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identify different kinds of Toplevel window.
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: List the different types of `filedialogs` and message boxes available in Tkinter.
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We used the pack geometry manager to build this text editor. Could we have built
    this using the grid geometry manager? How would the grid geometry manager fare
    against pack?
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can we trigger events without an external stimulus in Tkinter?
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are accelerator options in menu items?
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is a transient window?
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-425
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The source code for the `filedialog` module can be found within the Tkinter
    source code in a separate file named `filedialog.py`. You are encouraged to take
    a look at its implementation.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: If you are feeling adventurous and want to further explore the Text Editor program,
    I encourage you to have a look at the source code for Python's built-in editor
    named IDLE, which is written in Tkinter. The source code for IDLE can be found
    in your local Python library directory in a folder called `idlelib`. On Linux
    Mint, this is located at `/usr/lib/python3.4/idlelib`.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: Read the official Python styling guide, which is specified in the PEP8 documentation
    at [https://www.python.org/dev/peps/pep-0008](https://www.python.org/dev/peps/pep-0008).
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: If you like, try to implement syntax highlighting of Python code in the text
    editor. A naive implementation would first involve defining a list of keywords.
    Then we can bind the `<KeyRelease>` event to check whether the typed word is one
    of the keywords. We can then add a custom tag to the word using `tag_add`. Finally,
    we can change its color by using code such as `textarea.tag_config("the_keyword_tag",
    foreground="blue")`.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: A slightly advanced idea to read up on and implement is called **lazy loading**. 
    This is particularly helpful if you want to open a very large file in the text
    editor. In the present implementation, it may take very long time to open a very
    large file. In contrast, lazy loading will read only the section of the file that
    is currently visible in the text editor, thus making the program much more responsive.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
