<html><head></head><body>
  <div><div><div><div><div><h1 class="title"><a id="ch09"/>Chapter 9. Design Approaches and Techniques</h1></div></div></div><p>In this chapter, we will cover:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Creating Singletons</li><li class="listitem" style="list-style-type: disc">Implementing an observer pattern</li><li class="listitem" style="list-style-type: disc">Strategy pattern</li><li class="listitem" style="list-style-type: disc">Model View Controller</li><li class="listitem" style="list-style-type: disc">Using mixin classes</li><li class="listitem" style="list-style-type: disc">Using decorators</li></ul></div><div><div><div><div><h1 class="title"><a id="ch09lvl1sec01"/>Introduction</h1></div></div></div><p>Programming is all about patterns. There are patterns at every level, from the programming language itself, to the toolkit, to the application. Being able to discern and choose the optimal approach to use to solve the problem at hand can at times be a difficult task. The more patterns you know, the bigger your toolbox, and the easier it will become to be able to choose the right tool for the job.<a id="id327" class="indexterm"/>
</p><p>Different programming languages and toolkits often lend themselves to certain patterns and approaches to problem solving. The Python programming language and wxPython are no different, so let's jump in and take a look at how to apply some common design approaches and techniques to wxPython applications.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch09lvl1sec02"/>Creating Singletons</h1></div></div></div><p>In object oriented programming, the Singleton pattern is a fairly simple concept of only allowing exactly one instance of a given object to exist at a given time. This means that it only allows for only one instance of the object to be in memory at any given time, so that all references to the object are shared throughout the application. Singletons are often used to maintain a global state in an application since all occurances of one in an application reference the same exact instance of the object. Within the core wxPython library, there are a number of singleton objects, such as<code class="literal"> ArtProvider, ColourDatabase</code>, and<code class="literal"> SystemSettings</code>. This recipe shows how to make a singleton<code class="literal"> Dialog</code> class, which can be useful for creating non-modal dialogs that should only have a single instance present at a given time, such as a settings dialog or a special tool window.<a id="id328" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec01"/>How to do it...</h2></div></div></div><p>To get started, we will define a metaclass that can be reused on any class that needs to be turned into a singleton. We will get into more detail later in the<em> How it works</em> section. A metaclass is a class that creates a class. It is passed a class to it's<code class="literal"> __init__</code> and<code class="literal"> __call__</code> methods when someone tries to create an instance of the class.<a id="id329" class="indexterm"/>
</p><div><pre class="programlisting">class Singleton(type):
    def __init__(cls, name, bases, dict):
        super(Singleton, cls).__init__(name, bases, dict)
        cls.instance = None
 
    def __call__(cls, *args, **kw):
        if not cls.instance:
            # Not created or has been Destroyed
            obj = super(Singleton, cls).__call__(*args, **kw)
            cls.instance = obj
            cls.instance.SetupWindow()
 
        return cls.instance

</pre></div><p>Here we have an example of the use of our metaclass, which shows how easy it is to turn the following class into a singleton class by simply assigning the<code class="literal"> Singleton</code> class as the<code class="literal"> __metaclass__</code> of<code class="literal"> SingletonDialog</code>. The only other requirement is to define the<code class="literal"> SetupWindow</code> method that the<code class="literal"> Singleton</code> metaclass uses as an initialization hook to set up the window the first time an instance of the class is created.</p><div><h3 class="title"><a id="note11"/>Note</h3><p>Note that in Python 3+ the<code class="literal"> __metaclass__</code> attribute has been replaced with a metaclass keyword argument in the class definition.</p></div><div><pre class="programlisting">class SingletonDialog(wx.Dialog):
    __metaclass__ = Singleton

    def SetupWindow(self):
        """Hook method for initializing window"""
        self.field = wx.TextCtrl(self)
        self.check = wx.CheckBox(self, label="Enable Foo")

        # Layout
        vsizer = wx.BoxSizer(wx.VERTICAL)
        label = wx.StaticText(self, label="FooBar")
        hsizer = wx.BoxSizer(wx.HORIZONTAL)
        hsizer.AddMany([(label, 0, wx.ALIGN_CENTER_VERTICAL),
                        ((5, 5), 0),
                        (self.field, 0, wx.EXPAND)])
        btnsz = self.CreateButtonSizer(wx.OK)
        vsizer.AddMany([(hsizer, 0, wx.ALL|wx.EXPAND, 10),
                        (self.check, 0, wx.ALL, 10),
                        (btnsz, 0, wx.EXPAND|wx.ALL, 10)])
        self.SetSizer(vsizer)
        self.SetInitialSize()

</pre></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec02"/>How it works...</h2></div></div></div><p>There are a number of ways to implement a Singleton in Python. In this recipe, we used a metaclass to accomplish the task. This is a nicely contained and easily reusable pattern to accomplish this task. The<code class="literal"> Singleton</code> class that we defined can be used by any class that has a<code class="literal"> SetupWindow</code> method defined for it. So now that we have done it, let's take a quick look at how a singleton works.<a id="id330" class="indexterm"/>
</p><p>The Singleton metaclass dynamically creates and adds a class variable called<code class="literal"> instance</code> to the passed in class. So just to get a picture of what is going on, the metaclass would generate the following code in our example:</p><div><pre class="programlisting">class SingletonDialog(wx.Dialog):
instance = None
</pre></div><p>Then the first time the metaclass's<code class="literal"> __call__</code> method is invoked, it will then assign the instance of the class object returned by the super class's<code class="literal"> __call__</code> method, which in this recipe is an instance of our<code class="literal"> SingletonDialog</code>. So basically, it is the equivalent of the following:</p><div><pre class="programlisting">SingletonDialog.instance = SingletonDialog(*args,**kwargs)
</pre></div><p>Any subsequent initializations will cause the previously-created one to be returned, instead of creating a new one since the class definition maintains the lifetime of the object and not an individual reference created in the user code.</p><p>Our<code class="literal"> SingletonDialog</code> class is a very simple Dialog that has<code class="literal"> TextCtrl, CheckBox</code>, and<code class="literal"> Ok Button</code> objects on it. Instead of invoking initialization in the dialog's<code class="literal"> __init__</code> method, we instead defined an interface method called<code class="literal"> SetupWindow</code> that will be called by the Singleton metaclass when the object is initially created. In this method, we just perform a simple layout of our controls in the dialog. If you run the sample application that accompanies this topic, you can see that no matter how many times the show dialog button is clicked, it will only cause the existing instance of the dialog to be brought to the front. Also, if you make changes in the dialog's<code class="literal"> TextCtrl</code> or<code class="literal"> CheckBox</code>, and then close and reopen the dialog, the changes will be retained since the same instance of the dialog will be re-shown instead of creating a new one.<a id="id331" class="indexterm"/>
</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch09lvl1sec03"/>Implementing an observer pattern</h1></div></div></div><p>The observer pattern is a design approach where objects can subscribe as observers of events that other objects are publishing. The publisher(s) of the events then just broadcasts the events to all of the subscribers. This allows the creation of an extensible, loosely-coupled framework of notifications, since the publisher(s) don't require any specific knowledge of the observers. The<code class="literal"> pubsub</code> module provided by the<code class="literal"> wx.lib</code> package provides an easy-to-use implementation of the observer pattern through a publisher/subscriber approach. Any arbitrary number of objects can subscribe their own callback methods to messages that the publishers will send to make their notifications. This recipe shows how to use the<code class="literal"> pubsub</code> module to send configuration notifications in an application.<a id="id332" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec03"/>How to do it...</h2></div></div></div><p>Here, we will create our application configuration object that stores runtime configuration variables for an application and provides a notification mechanism for whenever a value is added or modified in the configuration, through an interface that uses the observer pattern:<a id="id333" class="indexterm"/>
</p><div><pre class="programlisting">import wx
from wx.lib.pubsub import Publisher

# PubSub message classification
MSG_CONFIG_ROOT = ('config',)

class Configuration(object):
    """Configuration object that provides
    notifications.
    """
    def __init__(self):
        super(Configuration, self).__init__()

        # Attributes
        self._data = dict()

    def SetValue(self, key, value):
        self._data[key] = value
        # Notify all observers of config change
        Publisher.sendMessage(MSG_CONFIG_ROOT + (key,),
                              value)

    def GetValue(self, key):
        """Get a value from the configuration"""
        return self._data.get(key, None)

</pre></div><p>Now, we will create a very simple application to show how to subscribe observers to configuration changes in the<code class="literal"> Configuration</code> class:<a id="id334" class="indexterm"/>
</p><div><pre class="programlisting">class ObserverApp(wx.App):
    def OnInit(self):
        self.config = Configuration()
        self.frame = ObserverFrame(None,
                                   title="Observer Pattern")
        self.frame.Show()
        self.configdlg = ConfigDialog(self.frame,
                                      title="Config Dialog")
        self.configdlg.Show()
        return True

    def GetConfig(self):
        return self.config

</pre></div><p>This dialog will have one configuration option on it to allow the user to change the applications font:<a id="id335" class="indexterm"/>
</p><div><pre class="programlisting">class ConfigDialog(wx.Dialog):
    """Simple setting dialog"""
    def __init__(self, parent, *args, **kwargs):
        super(ConfigDialog, self).__init__(*args, **kwargs)

        # Attributes
        self.panel = ConfigPanel(self)

        # Layout
        sizer = wx.BoxSizer(wx.VERTICAL)
        sizer.Add(self.panel, 1, wx.EXPAND)
        self.SetSizer(sizer)
        self.SetInitialSize((300, 300))

class ConfigPanel(wx.Panel):
    def __init__(self, parent):
        super(ConfigPanel, self).__init__(parent)

        # Attributes
        self.picker = wx.FontPickerCtrl(self)

        # Setup
        self.__DoLayout()

        # Event Handlers
        self.Bind(wx.EVT_FONTPICKER_CHANGED,
                  self.OnFontPicker)

    def __DoLayout(self):
        vsizer = wx.BoxSizer(wx.VERTICAL)
        hsizer = wx.BoxSizer(wx.HORIZONTAL)

        vsizer.AddStretchSpacer()
        hsizer.AddStretchSpacer()
        hsizer.AddWindow(self.picker)
        hsizer.AddStretchSpacer()
        vsizer.Add(hsizer, 0, wx.EXPAND)
        vsizer.AddStretchSpacer()
        self.SetSizer(vsizer)

</pre></div><p>Here, in the<code class="literal"> FontPicker's</code> event handler, we get the newly-selected font and call<code class="literal"> SetValue</code> on the<code class="literal"> Configuration</code> object owned by the<code class="literal"> App</code> object in order to change the configuration, which will then cause the<code class="literal"> ('config', 'font')</code> message to be published:<a id="id336" class="indexterm"/>
</p><div><pre class="programlisting">    def OnFontPicker(self, event):
        """Event handler for the font picker control"""
        font = self.picker.GetSelectedFont()
        # Update the configuration
        config = wx.GetApp().GetConfig()
        config.SetValue('font', font)

</pre></div><p>Now, here, we define the application's main window that will subscribe it's<code class="literal"> OnConfigMsg</code> method as an observer of all<code class="literal"> ('config',)</code> messages, so that it will be called whenever the configuration is modified:</p><div><pre class="programlisting">class ObserverFrame(wx.Frame):
    """Window that observes configuration messages"""
    def __init__(self, parent, *args, **kwargs):
        super(ObserverFrame, self).__init__(*args, **kwargs)
        
        # Attributes
        self.txt = wx.TextCtrl(self, style=wx.TE_MULTILINE)
        self.txt.SetValue("Change the font in the config "
                          "dialog and see it update here.")
    
        # Observer of configuration changes
        Publisher.subscribe(self.OnConfigMsg, MSG_CONFIG_ROOT)

    def __del__(self):
        # Unsubscribe when deleted
        Publisher.unsubscribe(self.OnConfigMsg)

</pre></div><p>Here is the observer method that will be called when any message beginning with<code class="literal">'config'</code> is sent by the<code class="literal"> pubsub Publisher</code>. In this sample application, we just check for the<code class="literal"> ('config', 'font')</code> message and update the font of the<code class="literal"> TextCtrl</code> object to use the newly-configured one:</p><div><pre class="programlisting">    def OnConfigMsg(self, msg):
        """Observer method for config change messages"""
        if msg.topic[-1] == 'font':
            # font has changed so update controls
            self.SetFont(msg.data)
            self.txt.SetFont(msg.data)

if __name__ == '__main__':
    app = ObserverApp(False)
    app.MainLoop()

</pre></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec04"/>How it works...</h2></div></div></div><p>This recipe shows a convenient way to manage an application's configuration by allowing the interested parts of an application to subscribe to updates when certain parts of the configuration are modified. Let's start with a quick walkthrough of how pubsub works.<a id="id337" class="indexterm"/>
</p><p>Pubsub messages use a tree structure to organize the categories of different messages. A message type can be defined either as a tuple<code class="literal"> ('root', 'child1', 'grandchild1')</code> or as a dot-separated string (<code class="literal">'root.child1.grandchild1'</code>). Subscribing a callback to<code class="literal"> ('root',)</code> will cause your callback method to be called for all messages that start with<code class="literal"> ('root',)</code>. This means that if a component publishes<code class="literal"> ('root', 'child1', 'grandchild1')</code> or<code class="literal"> ('root', 'child1')</code>, then any method that is subscribed to<code class="literal"> ('root',)</code> will also be called.<a id="id338" class="indexterm"/>
</p><p>Pubsub basically works by storing the mapping of message types to callbacks in static memory in the<code class="literal"> pubsub</code> module. In Python, modules are only imported once any other part of your application that uses the<code class="literal"> pubsub</code> module shares the same singleton<code class="literal"> Publisher</code> object.<a id="id339" class="indexterm"/>
</p><p>In our recipe, the<code class="literal"> Configuration</code> object is a simple object for storing data about the configuration of our application. Its<code class="literal"> SetValue</code> method is the important part to look at. This is the method that will be called whenever a configuration change is made in the application. In turn, when this is called, it will send a pubsub message of<code class="literal"> ('config',) + (key,)</code> that will allow any observers to subscribe to either the root item or more specific topics determined by the exact configuration item.</p><p>Next, we have our simple<code class="literal"> ConfigDialog</code> class. This is just a simple example that only has an option for configuring the application's font. When a change is made in the<code class="literal"> FontPickerCtrl</code> in the<code class="literal"> ConfigPanel</code>, the<code class="literal"> Configuration</code> object will be retrieved from the<code class="literal"> App</code> and will be updated to store the newly-selected<code class="literal"> Font</code>. When this happens, the<code class="literal"> Configuration</code> object will publish an update message to all subscribed observers.<a id="id340" class="indexterm"/>
</p><p>Our<code class="literal"> ObserverFrame</code> is an observer of all<code class="literal"> ('config',)</code> messages by subscribing its<code class="literal"> OnConfigMsg</code> method to<code class="literal"> MSG_CONFIG_ROOT. OnConfigMsg</code> will be called any time the<code class="literal"> Configuration</code> object's<code class="literal"> SetValue</code> method is called. The<code class="literal"> msg</code> parameter of the callback will contain a<code class="literal"> Message</code> object that has a<code class="literal"> topic</code> and<code class="literal"> data</code> attribute. The<code class="literal"> topic</code> attribute will contain the tuple that represents the message that triggered the callback and the<code class="literal"> data</code> attribute will contain any data that was associated with the<code class="literal"> topic</code> by the publisher of the message. In the case of a<code class="literal"> ('config', 'font')</code> message, our handler will update the<code class="literal"> Font</code> of the<code class="literal"> Frame</code> and its<code class="literal"> TextCtrl</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec05"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">See the<em> Creating Singletons</em> recipe in this chapter for an explanation of how singleton objects like the Publisher from this recipe work.</li><li class="listitem" style="list-style-type: disc">See the<em> Making a tool window</em> recipe in<a class="link" href="ch10.html" title="Chapter 10. Creating Components and Extending Functionality"> Chapter 10</a>,<em> Creating Components and Extending Functionality</em> for another example of the publisher pattern in action.</li></ul></div></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch09lvl1sec04"/>Strategy pattern</h1></div></div></div><p>The strategy pattern is an approach that allows for an application to choose the strategy or behavior that will be used at run time. It accomplishes this by encapsulating different algorithms and making them usable by the client regardless of what the underlying behavior of the algorithm is. This is probably one of the most fundamental design patterns in programming, and you're probably already using it in one form or another without even knowing it. This recipe shows how to create a reusable<code class="literal"> Dialog</code> class that uses the strategy pattern to allow for the main content to vary depending on the strategy used.<a id="id341" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec06"/>How to do it...</h2></div></div></div><p>First, we will start by defining a base interface with all of the strategies that our dialog class will use:</p><div><pre class="programlisting">class BaseDialogStrategy:
    """Defines the strategy interface"""
    def GetWindowObject(self, parent):
        """Must return a Window object"""
        raise NotImplementedError, "Required method"

    def DoOnOk(self):
        """@return: bool (True to exit, False to not)"""
        return True

    def DoOnCancel(self):
        """@return: bool (True to exit, False to not)"""
        return True

</pre></div><p>Now let's define our simple Ok/Cancel dialog, which will use a strategy derived from our<code class="literal"> BaseDialogStrategy</code> class to allow its main content area to vary depending on the strategy used:<a id="id342" class="indexterm"/>
</p><div><pre class="programlisting">class StrategyDialog(wx.Dialog):
    """Simple dialog with builtin OK/Cancel button and
    strategy based content area.   
    """
    def __init__(self, parent, strategy, *args, **kwargs):
        super(StrategyDialog, self).__init__(parent,
                                             *args,
                                             **kwargs)

        # Attributes
        self.strategy = strategy
        self.pane = self.strategy.GetWindowObject(self)

        # Layout
        self.__DoLayout()

        # Event Handlers
        self.Bind(wx.EVT_BUTTON, self.OnButton)

</pre></div><p>Here, in the following methods of our<code class="literal"> StrategyDialog</code>, we just delegate to the current strategy to allow it to define the behavior of the dialog:</p><div><pre class="programlisting">    def __DoLayout(self):
        sizer = wx.BoxSizer(wx.VERTICAL)
        sizer.Add(self.pane, 1, wx.EXPAND)
        btnsz = self.CreateButtonSizer(wx.OK|wx.CANCEL)
        sizer.Add(btnsz, 0, wx.EXPAND|wx.ALL, 8)
        self.SetSizer(sizer)

    def GetStrategy(self):
        return self.strategy

    def OnButton(self, event):
        evt_id = event.GetId()
        bCanExit = False
        if evt_id == wx.ID_OK:
            bCanExit = self.strategy.DoOnOk()
        elif evt_id == wx.ID_OK:
            bCanExit = self.strategy.DoOnCancel()
        else:
            evt.Skip()

        if bCanExit:
            self.EndModal(evt_id)

</pre></div><p>Now let's implement a simple strategy that can be used to get the dialog to display a control for selecting a file:</p><div><pre class="programlisting">class FileTreeStrategy(BaseDialogStrategy):
    """File chooser strategy"""
    def GetWindowObject(self, parent):
        assert not hasattr(self, 'dirctrl')
        self.dirctrl = wx.GenericDirCtrl(parent)
        return self.dirctrl

    def DoOnOk(self):
        path = self.dirctrl.GetPath()
        if path:
            wx.MessageBox("You selected: %s" % path)
            return True
        else:
            wx.MessageBox("No file selected!")
            return False

</pre></div><p>Then, in an application, all that needs to be done to create a dialog that uses this strategy would be the following:<a id="id343" class="indexterm"/>
</p><div><pre class="programlisting"># Note: ‘self’ is some window object (i.e a Frame)
strategy = FileTreeStrategy()
dlg = StrategyDialog(self, strategy, title=”Choose File”)
dlg.ShowModal()

</pre></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec07"/>How it works...</h2></div></div></div><p>Since all strategies that our dialog will use must be interchangeable, it is important to define an interface that they will implement. So, in our<code class="literal"> BaseDialogStrategy</code> class, we defined a simple three-method interface that our<code class="literal"> StrategyDialog</code> will delegate to.</p><p>The<code class="literal"> StrategyDialog</code> is basically just a simple generic shell that delegates all decisions regarding its appearance and behavior to the strategy. When the dialog is initialized, it asks the strategy for a window object that will be used as the main content area of the dialog. The dialog then creates and adds some standard OK/Cancel buttons to the interface.<a id="id344" class="indexterm"/>
</p><p>When a user clicks on one of these buttons, the<code class="literal"> StrategyDialog</code> will then simply delegate to its strategy, to allow the strategy to handle the user action. This allows us to reuse this dialog class in many different ways, by simply implementing different strategies.<a id="id345" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec08"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">See the<em> Model View Controller</em> recipe in this chapter for some more examples of a strategy pattern.</li></ul></div></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch09lvl1sec05"/>Model View Controller</h1></div></div></div><p>
<strong>Model View Controller</strong> (<strong>MVC</strong>) is a design pattern that creates a clear separation of concerns within a program's architecture. It breaks down into three layers: the<strong> Model</strong>, which is the application's data objects and business logic at the bottom, the<strong> View</strong> at the top, which typically consists of controls for displaying and editing data, and finally the<strong> Controller</strong> in the middle, which is responsible for mediating the flow of data from the Model to the View and vice versa:<a id="id346" class="indexterm"/>
</p><div><img src="img/1780OS_09_01.jpg" alt="Model View Controller"/></div><p>MVC is really one big monster pattern made up of other, simpler patterns working together. The Model implements an observer pattern to keep interested parties updated on changes, which allows it to be implemented separately from the View and Controller. The View and the Controller, on the other hand, implement a strategy pattern where the Controller is a strategy that implements the behavior of the View.<a id="id347" class="indexterm"/>
</p><p>In this recipe, we explore how to create a simple number generator application that implements this pattern in wxPython.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec09"/>How to do it...</h2></div></div></div><p>Since there are multiple components that need to work together, having defined interfaces is an important step in the process, so first let us define some base classes that define the interface for our number generator's model and controller.</p><p>Beginning with our Model's interface, we provide a class that simply requires its<code class="literal"> Generate</code> method to be overridden in order to provide the implementation-specific behavior. We have also built in a simple observer pattern mechanism to allow the view to subscribe to update notifications in the model:<a id="id348" class="indexterm"/>
</p><div><pre class="programlisting">class ModelInterface(object):
    """Defines an interface for a simple value
    generator model.
    """
    def __init__(self):
        super(ModelInterface, self).__init__()

        # Attributes
        self.val = 0
        self.observers = list()

    def Generate(self):
        """Interface method to be implemented by
        subclasses.
        """
        raise NotImplementedError

    def SetValue(self, val):
        self.val = val
        self.NotifyObservers()

    def GetValue(self):
        return self.val

    def RegisterObserver(self, callback):
        """Register an observer callback
        @param: callable(newval)
        """
        self.observers.append(callback)

    def NotifyObservers(self):
        """Notify all observers of current value"""
        for observer in self.observers:
            observer()

</pre></div><p>Next we have the base interface definition for the controllers of our framework's view to derive from. This just defines one simple<code class="literal"> DoGenerateNext</code> method that must be overridden by the specific implementation:</p><div><pre class="programlisting">class ControllerInterface(object):
    """Defines an interface a value generator
    controller.
    """
    def __init__(self, model):
        super(ControllerInterface, self).__init__()
        
        # Attributes
        self.model = model
        self.view = TheView(None, self, self.model,
                            "Fibonacci Generator")

        # Setup
        self.view.Show()

    def DoGenerateNext(self):
        """User action request next value"""
        raise NotImplementedError

</pre></div><p>Now let's define some subclasses that implement the interface and provide the specialization.<a id="id349" class="indexterm"/>
</p><p>Beginning with our<code class="literal"> FibonacciModel</code> class, we define a model that will generate Fibonacci numbers:<a id="id350" class="indexterm"/>
</p><div><pre class="programlisting">class FibonacciModel(ModelInterface):
    def Generate(self):
        cval = self.GetValue()
        # Get the next one
        for fib in self.fibonacci():
            if fib &gt; cval:
                self.SetValue(fib)
                break

    @staticmethod
    def fibonacci():
        """Fibonacci generator method"""
        a, b = 0, 1
        while True1:
            yield a
            a, b = b, a + b

</pre></div><p>Then our<code class="literal"> FibonacciController</code> provides the controller specialization, which in this example just makes one update to the user interface, to disable the button while the model is calculating the next value:<a id="id351" class="indexterm"/>
</p><div><pre class="programlisting">class FibonacciController(ControllerInterface):
    def DoGenerateNext(self):
        self.view.EnableButton(False)
        self.model.Generate()

</pre></div><p>Now that the model and controller have been defined, let's take a look at our view, which is composed of a<code class="literal"> Frame</code>, a<code class="literal"> Panel</code> that has a<code class="literal"> TextCtrl</code> for displaying the current value stored in the model, and a<code class="literal"> Button</code> for retrieving the next value in the sequence defined by the model:</p><div><pre class="programlisting">class TheView(wx.Frame):
    def __init__(self, parent, controller, model, title):
        """The view for """
        super(TheView, self).__init__(parent, title=title)

        # Attributes
        self.panel = ViewPanel(self, controller, model)

        # Layout
        sizer = wx.BoxSizer(wx.VERTICAL)
        sizer.Add(self.panel, 1, wx.EXPAND)
        self.SetSizer(sizer)
        self.SetInitialSize((300, 300))

    def EnableButton(self, enable=True):
        self.panel.button.Enable(enable)

</pre></div><p>Here, the<code class="literal"> ViewPanel</code> is where we interface with the model and controller. We retrieve the initial value from the model on initialization and then register as an observer of changes in the model:<a id="id352" class="indexterm"/>
</p><div><pre class="programlisting">class ViewPanel(wx.Panel):
    def __init__(self, parent, controller, model):
        super(ViewPanel, self).__init__(parent)

        # Attributes
        self.model = model
        self.controller = controller
        initial = str(self.model.GetValue())
        self.text = wx.TextCtrl(self, value=initial)
        self.button = wx.Button(self, label="Generate")

        # Layout
        self.__DoLayout()

        # Setup
        self.model.RegisterObserver(self.OnModelUpdate)

        # Event Handlers
        self.Bind(wx.EVT_BUTTON, self.OnAction)

    def __DoLayout(self):
        vsizer = wx.BoxSizer(wx.VERTICAL)
        hsizer = wx.BoxSizer(wx.HORIZONTAL)

        vsizer.AddStretchSpacer()
        vsizer.Add(self.text, 0, wx.ALIGN_CENTER|wx.ALL, 8)
        hsizer.AddStretchSpacer()
        hsizer.AddWindow(self.button)
        hsizer.AddStretchSpacer()
        vsizer.Add(hsizer, 0, wx.EXPAND)
        vsizer.AddStretchSpacer()
        self.SetSizer(vsizer)

</pre></div><p>Here is our observer method that will be called when the model is updated with a new value:<a id="id353" class="indexterm"/>
</p><div><pre class="programlisting">    def OnModelUpdate(self):
        """Observer method"""
        value = self.model.GetValue()
        self.text.SetValue(str(value))
        self.button.Enable(True)

</pre></div><p>This event handler is for the<code class="literal"> Button</code>, and it delegates to the controller in order to allow the controller to perform the implementation-specific action:</p><div><pre class="programlisting">    def OnAction(self, event):
        self.controller.DoGenerateNext()

</pre></div><p>Finally, we put it all together and implement an application:</p><div><pre class="programlisting">class ModelViewApp(wx.App):
    def OnInit(self):
        self.model = FibonacciModel()
        self.controller = FibonacciController(self.model)
        return True

if __name__ == '__main__':
    app = ModelViewApp(False)
    app.MainLoop()

</pre></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec10"/>How it works...</h2></div></div></div><p>Using MVC to design an application's framework takes a fair amount of discipline. As can be seen in this simple example, there is quite a bit of extra "stuff" that needs to be done. As described before, MVC separates concerns into three main roles:<a id="id354" class="indexterm"/>
</p><div><ol class="orderedlist arabic"><li class="listitem">The Model</li><li class="listitem">The View</li></ol></div><div><ol class="orderedlist arabic"><li class="listitem">The Controller</li></ol></div><p>So let's take a look at how these roles came together in our sample recipe.</p><p>First the Model: This has the ability to store a value and to generate the next one in the sequence when its<code class="literal"> Generate</code> method is called. In this recipe, we implemented a Model that calculates and stores Fibonacci numbers. The important part to take away from this is that the Model does not have any direct knowledge of the View or the Controller.</p><p>Next let's jump to the View, which just displays a<code class="literal"> TextCtrl</code> field and a<code class="literal"> Button</code>. It does not know any of the details of how the Controller or Model works. It only interacts with them through a defined interface. When the user clicks the<code class="literal"> Button</code>, it asks the Controller to decide what to do. In order to know when the Model has changed, it registers a callback function with the Model, as an observer of when the Model's<code class="literal"> SetValue</code> method is called.</p><p>Now to the Controller which is the glue that holds the Model and View together. The Controller is primarily charged with implementing the View's behavior in regards to the Model's state. Our simple Controller for this recipe only has one interface method that is called in response to a<code class="literal"> Button</code> click in the View. This action first disables the<code class="literal"> Button</code>, and then tells the Model to generate the next number in the sequence.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec11"/>There's more...</h2></div></div></div><p>You may be wondering "what's the point?" of all that extra rigmarole to create such a simple application. Well since the Model is completely separate from the View, it can be more easily unit tested in an automated test suite. In addition to this, since the View is just simply a view and does not implement any behavior, it can easily be reused if, for example, we wanted to add a Prime Number generator model to our application.</p><p>Maintainability is also improved since all three parts are separated and can be worked on individually without interfering with the other components. Because of these benefits, many other toolkits, such as Django and web2py make use of this pattern.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec12"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">See the<em> Implementing an observer pattern</em> recipe in this chapter for another approach to using an observer pattern.</li><li class="listitem" style="list-style-type: disc">See the<em> Strategy pattern</em> recipe in this chapter for more information on using strategies.</li></ul></div></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch09lvl1sec06"/>Using mixin classes</h1></div></div></div><p>A mixin class is a design approach that is similar to the strategy pattern, but directly uses inheritance in order to add extended/common functionality to a new class. This recipe shows how to create a mixin class that adds debug logging facilities to any class that uses it.<a id="id355" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec13"/>How to do it...</h2></div></div></div><p>First, let's start by creating our<code class="literal"> LoggerMixin</code> class, which will provide the logging functionality to classes that need to have logging. It simply provides a<code class="literal"> Log</code> method that will write the passed in string to a file:<a id="id356" class="indexterm"/>
</p><div><pre class="programlisting">import os
import time
import wx

class LoggerMixin:
    def __init__(self, logfile="log.txt"):
        """@keyword logfile: path to log output file"""
        # Attributes
        self.logfile = logfile

    def Log(self, msg):
        """Write a message to the log.
        Automatically adds timestamp and originating class
        information.
        """
        if self.logfile is None:
            return

        # Open and write to the log file
        with open(self.logfile, 'ab') as handle:
            # Make a time stamp
            ltime = time.localtime(time.time())
            tstamp = "%s:%s:%s" % (str(ltime[3]).zfill(2),
                                   str(ltime[4]).zfill(2),
                                   str(ltime[5]).zfill(2))
            # Add client info
            client = getattr(self, 'GetName',
                             lambda: "unknown")()
            # Construct the final message
            output = "[%s][%s] %s%s" % (tstamp, client,
                                        msg, os.linesep)
            handle.write(output)

</pre></div><p>Then, to use the<code class="literal"> LoggerMixin</code> in an application, it can simply be mixed in to any class to give it a<code class="literal"> Log</code> method:<a id="id357" class="indexterm"/>
</p><div><pre class="programlisting">class MixinRecipeFrame(wx.Frame, LoggerMixin):
    """Main application window"""
    def __init__(self, parent, *args, **kwargs):
        wx.Frame.__init__(self, parent, *args, **kwargs)
        LoggerMixin.__init__(self)
        self.Log("Creating instance...")

        # Attributes
        self.panel = MixinRecipePanel(self)

        # Layout
        sizer = wx.BoxSizer(wx.VERTICAL)
        sizer.Add(self.panel, 1, wx.EXPAND)
        self.SetSizer(sizer)
        self.SetInitialSize((300, 300))

</pre></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec14"/>How it works...</h2></div></div></div><p>The mixin class in this recipe is the<code class="literal"> LoggerMixin</code> class. It will add a<code class="literal"> Log</code> method to the classes that use it, which will take a simple string as an argument and write it to the specified log file with a timestamp and ID that shows where the message came from.<a id="id358" class="indexterm"/>
</p><p>A mixin works by using multiple inheritance in order to add additional functionality to a class. The<code class="literal"> LoggerMixin</code> mixin class can be used with any Python class, but it expects (but doesn't require) that the class it is being mixed into has a<code class="literal"> GetName</code> method to use for getting the ID portion of the log message:</p><div><pre class="programlisting"><strong>[17:42:24][unknown] OnInit called
[17:42:24][frame] Creating instance...
[17:42:24][panel] Begin Layout
[17:42:24][panel] End Layout
[17:42:26][panel] Button -203: Clicked
[17:42:26][panel] Button -203: Clicked
</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec15"/>There's more</h2></div></div></div><p>There are a number of handy mixin classes provided by the<code class="literal"> wx.lib.mixins</code> package. Here is a quick rundown on some of the mixins that are available and what functionality they provide.</p><div><div><div><div><h3 class="title"><a id="ch09lvl3sec01"/>ListCtrl mixins</h3></div></div></div><p>All of the following mixins classes are intended for use with a<code class="literal"> ListCtrl</code> subclass and are provided by the<code class="literal"> wx.lib.mixins.listctrl</code> module:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Mixins classes</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">CheckListCtrlMixin</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Adds<code class="literal"> CheckBox</code> functionality to the first column of a<code class="literal"> ListCtrl</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">ColumnSorterMixin</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Handles sorting of items in the<code class="literal"> ListCtrl</code> when its column header is clicked</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">ListCtrlAutoWidthMixin</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Automatically resizes the last column of a<code class="literal"> ListCtrl</code> to fill any remaining space</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">ListRowHighlighter</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Automatically changes the background color on alternating rows in the<code class="literal"> ListCtrl</code> to give it a stripped appearance</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">TextEditMixin</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Adds the ability to show an editable text field in any column of a<code class="literal"> ListCtrl</code>
</p>
</td></tr></tbody></table></div></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec02"/>TreeCtrl mixins</h3></div></div></div><p>All of the following mixin classes are for use with a<code class="literal"> TreeCtrl</code> subclass, and are provided by the<code class="literal"> wx.lib.mixins.treectrl</code> module:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Mixins classes</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">DragAndDrop</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Helps to simplify the addition of Drag and Drop support to a<code class="literal"> TreeCtrl</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">ExpansionState</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Helper to save and restore the expansion state of nodes in a<code class="literal"> TreeCtrl</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">VirtualTree</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Allow the<code class="literal"> TreeCtrl</code> to be virtualized so that nodes are added and removed on demand, instead of having to construct the whole tree up front</p>
</td></tr></tbody></table></div></div></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch09lvl1sec07"/>Using decorators</h1></div></div></div><p>Due to the window hierarchy, there are some architectural issues that can be presented to the programmer that lead to some tedious and unnecessary code duplication due to the need to have delegate accessor methods or properties at each level of the containment hierarchy. Typically, any Frame or Dialog in an application is structured as shown in the following diagram:<a id="id359" class="indexterm"/>
</p><div><img src="img/1780OS_09_02.jpg" alt="Using decorators"/></div><p>When needing to retrieve or modify the data that is shown in the window, it is the widgets and<strong> Controls</strong> that need to be accessed. These are contained by the<strong> Panel</strong> which is in turn contained by the<strong> Top Level Window</strong>. Since the Panel is responsible for its children, it will often have methods for modifying and accessing the data that is maintained by its children's controls. Because of this, the top-level window class often needs to have duplicate methods that simply delegate to the Panel's methods for getting and setting the window's data. These delegate methods are needed because the top-level window is the object that is instantiated at the application level and the application should not need to know the details of the top-level window's<code class="literal"> Panel</code> in order to use it.</p><p>This recipe shows how to create a simple decorator method that takes advantage of Python's dynamic nature in order to expose a select method of a custom Panel class to its top-level window container.<a id="id360" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec16"/>How to do it...</h2></div></div></div><p>This decorator class takes the name of a class as an argument and will dynamically define the<code class="literal"> delegate</code> method in the targeted child<code class="literal"> Panel</code> of the top level window:<a id="id361" class="indexterm"/>
</p><div><pre class="programlisting">class expose(object):
    """Expose a panels method to a to a specified class
    The panel that is having its method exposed by this
    decorator must be a child of the class its exposing
    itself too.
    """
    def __init__(self, cls):
        """@param cls: class to expose the method to"""
        super(expose, self).__init__()
        self.cls = cls

</pre></div><p>Here is where the magic occurs. We use<code class="literal"> setattr</code> to dynamically add a function with the same name as the function being decorated to the targeted class. When called from the targeted class, the new method will walk through the window's children to find its<code class="literal"> Panel</code>, and will delegate the call to the child class's method:<a id="id362" class="indexterm"/>
</p><div><pre class="programlisting">    def __call__(self, funct):
        """Dynamically bind and expose the function
        to the toplevel window class.
        """
        fname = funct.func_name
        def delegate(*args, **kwargs):
            """Delegate method for panel"""
            self = args[0] # The TLW
            # Find the panel this method belongs to
            panel = None
            for child in self.GetChildren():
                if isinstance(child, wx.Panel) and \
                   hasattr(child, fname):
                    panel = child
                    break
            assert panel is not None, "No matching child!"
            # Call the panels method
            return getattr(panel, fname)(*args[1:], **kwargs)

        # Bind the new delegate method to the tlw class
        delegate.__name__ = funct.__name__
        delegate.__doc__ = funct.__doc__
        setattr(self.cls, fname, delegate)

        # Return original function to the current class
        return funct

</pre></div><p>The example code that accompanies this chapter has a sample application that shows how to use this decorator.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec17"/>How it works...</h2></div></div></div><p>This recipe isn't so much a design pattern as it is a technique to help make writing new<code class="literal"> Dialog</code> and<code class="literal"> Frame</code> classes quicker and also to reduce code duplication. To do this, we created a decorator class for exposing methods from child<code class="literal"> Panel</code> classes to their parent top-level window. Let's start with a look at the<code class="literal"> expose</code> decorator to see how it works its magic.</p><p>The<code class="literal"> expose</code> decorator takes a single argument, which is the class that the method should be exposed to. A reference to this is saved in the constructor for later use when the decorator is applied in its<code class="literal"> __call__</code> method. The<code class="literal"> __call__</code> method creates a method called<code class="literal"> delegate</code> which will search for the first child panel that has a method with the same name as the one that is being exposed. If it finds an appropriate panel, then it simply calls the panel's method and returns its value. Next, it uses<code class="literal"> setattr</code> to insert the newly-generated<code class="literal"> delegate</code> method with an alias matching the<code class="literal"> Panel's</code> method into the namespace of the class specified in the decorator's constructor. At this point, the method is available for use in the top-level window that<code class="literal"> expose</code> was called with. Finally, we just return the unaltered original function to the<code class="literal"> Panel</code> class it belongs to.</p><p>Just to be clear, this decorator, as it is defined in this recipe, can only be used by<code class="literal"> Panel</code> subclasses that have a known relationship of being the only child of their parent window. This is typical of how most<code class="literal"> Frame</code> and<code class="literal"> Dialog</code> subclasses are constructed, as can be seen in the example<code class="literal"> CommentDialog</code> class that is included in this chapter's sample code.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec18"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">See the<em> Understanding the window hierarchy</em> recipe in<a class="link" href="ch01.html" title="Chapter 1. Getting Started with wxPython"> Chapter 1</a>,<em> Getting Started with wxPython</em> for an additional explanation of the containment hierarchy of different objects.</li></ul></div></div></div></div>
</body></html>