- en: Making Jarvis IoT Enabled
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There was a time when we used to imagine controlling the world with our fingertips.
    Now, this imagination has become a reality. With the advent of smartphones, we
    have been doing stuff which one could have only imagined until a decade back.
    With mobile phones becoming smart, the industry and businesses have also tried
    their best to keep up with the disruptive change. However, there is one part that
    is still lagging behind. Which is that part? Your home!
  prefs: []
  type: TYPE_NORMAL
- en: Think about what you can control in your home using your smartphone? Not many
    things! There are some devices that can turn on or off a bunch of devices such
    as your AC. However, the list is exhaustive. So, with all the knowledge gained
    in the previous chapters and the powerful hardware in our hands, why don't we
    become the trendsetters and the disrupters and make something that is still just
    a part of our imagination.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Basics of **Internet of Things** (**IoT**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Message Queuing Telemetry Transport** (**MQTT**) protocol'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up MQTT broker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making an IoT-based intrusion detector
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling the home
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basics of IoT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will be controlling devices in our home using our smartphones,
    but before doing this, we should understand the basics of this technology. The
    first topic of this chapter is IoT—the overused jargon in the modern world. It
    is something that everyone wants to know about but no one does. IoT can be related
    to a technology, where your refrigerator will tell you what items are low in supply
    and will order it automatically for you. Poor thing! This technology has some
    time to invade our houses. But IoT does not mean this alone. IoT is a very wide
    term, something which can be applied to almost all the places for optimization.
    So what is IoT then?
  prefs: []
  type: TYPE_NORMAL
- en: Let's break this acronym, **Internet of Things** sometimes also known as cyber
    physical systems. Now, what is **Things**? Any electronic object that has the
    ability to collect or receive data without human intervention can be called a
    thing here. So this thing can be your mobile, a pacemaker, a health monitoring
    device, and so on. The only *if* is that it should be connected to the internet
    and has the ability to collect and/or receive data. The second term is **Internet**;
    the internet refers to the internet, Duh! Now, all of these IoT devices send and
    receive data from a cloud or a central computer. The reason why it does that is
    because any IoT device, whether big or small, is considered a resource-constrained
    environment. That is, the resources such as computing power is much less. This
    is because the IoT devices have to be simple and cheap. Imagine you have to put
    IoT sensors on all of the street lights to monitor traffic. If the device costs
    $500, then it would be impractical to install this kind of device. However, if
    it could be made for $5-$10, then no one would bat an eye. That's the thing with
    IoT devices; they are extremely cheap. Now the flip side to this story is that
    they do not have a lot of computing power. Hence, to balance this equation, instead
    of computing the raw data on their own processors, they simply send this data
    to a cloud computing device or perhaps a server where this data is computed and
    the meaningful result is taken. So, this solves all our problems then. Well, no!
    The second problem with these devices are that they can be battery operated, use-and-throw
    devices as well. For example, where temperature sensors are installed all across
    the forests; in such situations, no one and absolutely no one will go and change
    the batteries every week. Hence, these devices are made in such a way that they
    consume little to almost no power, thereby making the programming very tricky.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have understood the IoT concepts, in this chapter, we'll be making
    our home IoT enabled. This means, we will be able to receive and collect data
    from the sensors from our home, see it on our mobile devices, and if needed, we
    can control the devices using your smartphones as well. There is one thing though,
    instead of computing it on cloud, we will simply be uploading all of our data
    onto the cloud and just accessing that data or sending our data to the cloud from
    where it can be accessed. We will be talking about the cloud computing aspect
    in a different book as this can be a whole new dimension and will be out of the
    scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: The MQTT protocol
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MQTT is an ISO-certified protocol and is in use very widely. The interesting
    thing about this protocol is that it was developed by Andy Stanford and Arlen
    Nipper in 1999 for monitoring of an oil pipeline through the desert. As you can
    imagine, in middle of a desert, the protocol they developed had to be energy efficient
    and bandwidth efficient as well.
  prefs: []
  type: TYPE_NORMAL
- en: How this protocol works is quite interesting. It has a publish-subscribe architecture.
    This means, it has a central server, which we also call a broker. Any device can
    register with this broker and publish any meaningful data onto it. Now, the data
    that is being published should have a topic, for example, air temperature.
  prefs: []
  type: TYPE_NORMAL
- en: These topics are particularly important. Why, you may ask? To the broker, there
    can be one or many devices that can be connected. With the connection, they also
    need to subscribe to a topic. Let's say they are subscribed to the topic *Air-*Temperature.
    Now, whenever any new data comes, it gets published to the subscribed devices.
  prefs: []
  type: TYPE_NORMAL
- en: One important thing to know is that there need not be any request to gain the
    data from the broker like what we have in HTTP. Rather, whenever the data is received,
    it will be pushed to the device which is subscribed to that topic. It is very
    obvious that the TCP protocol will also be up and working during the whole time
    and the port related to the broker will always be connected for seamless data
    transmission. However, should there be any break in the data, the broker will
    buffer all the data and send it to the subscriber whenever the connection is resumed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/13bec90f-2720-4a6a-b32a-7160d779f889.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see The motion sensor and the temperature sensors are giving the
    data to MQTT server by a specific topic namely **Temperature** and **Motion**.
    Those whose are subscribed to these topics would get the reading from this device.
    Hence there is no direct communication needed between the actual sensor and the
    mobile device.
  prefs: []
  type: TYPE_NORMAL
- en: The good thing about this whole architecture is that there can be limitless
    devices attached with this protocol and there need not be any scalability issues.
    Also, the protocol is relatively simple and easy to work with even a huge amount
    of data. Hence, this becomes the preferred protocol for IoT as it provides an
    easy, scalable, and seamless link between the data producer and the data receivers.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the MQTT broker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Remember the old boring update process of vision processing? How can you forget?
    We have to do the same here as well. But lucky for us, this time it''s not very
    long. So, let''s see what we have to do to set up this server. Open up your command
    line and type in these following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You know what this line does. If you don''t have a clear memory of it, then
    refer to [Chapter 9](e8d477b8-8ece-4d9e-b62b-29dca9508f78.xhtml), *Vision Processing*. Once
    the update and upgrade processes are complete, go ahead and install the following
    packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This will install the Mosquitto broker onto your Raspberry Pi. This broker
    will take care of all the data transfer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now, this line will install the client packages. As you can imagine, Raspberry
    Pi in itself will be a client to the broker. Hence, it will take care of the needful.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have now installed the packages; yes exactly, it was that small. Now, all
    we need to do is configure the Mosquitto broker. To do this, you need to type
    in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, this command will open the file where the Mosquitto file configuration
    is saved. To configure it, you need to get to the end of this file, where you
    will see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can comment out the the preceding line of code by simply adding `#`
    before the lines. Once done then go ahead and add the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Let's see what we have done here. The `allow_anonymous false` line tells the
    broker that not everyone can access the data. The next line, `password_file /etc/mosquitto/pwfile`
    is telling the broker the location of password file, which is located at `/etc/mosquitto/pwfile`.
    Finally, we will define the port of this broker, which is `1883`, using the `listener
    1883` command.
  prefs: []
  type: TYPE_NORMAL
- en: So finally, we have completed setting up the MQTT client in our Raspberry Pi.
    Now we are ready to go ahead and use it for the IoT-enabled home.
  prefs: []
  type: TYPE_NORMAL
- en: Making an IoT-based intrusion detector
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that Raspberry Pi is set up and we are ready to make it IoT enabled let''s
    see how we are going to connect the system to the internet and make things work.
    Firstly, we need to connect Raspberry Pi to the devices, which we want to control
    using the IoT technology. So go ahead and use the following diagram to make the
    connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/850b503e-0226-46eb-b76b-dd84ee83b7e2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you have set up all the components, let''s go ahead and upload the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This code, unlike the other chunks of code that we have seen so far, will be
    quite new to you. So I will be explaining every part of it except for a few obvious
    parts. So, let''s see what we have here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this part, we are importing the `pho.mqtt.client` library as `mqtt`. So whenever
    this library needs to be accessed, we simply need to use the line `mqtt` instead
    of the entire name of the library.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We are defining a client using the client method of the `mqtt` library. This
    can be called using the `client` variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: So we are defining the broker in our program. For this program, we are using
    the broker as `broker.hivemq.com`, which is providing us the broker services.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now as we have done earlier, we will once again define the port at which the
    protocol will be working, which in our case is `1883`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are defining the value of the variable called `pub_topic`, which is
    `IntruderDetector_Home`. This will be the final topic to which one can subscribe
    once the code is running.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are defining a function called `SendData()`,  will publish the data `Warning
    : SOMEONE DETECTED AT YOUR PLACE` to the broker with the topic which we had declared
    previously.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In this line, we are defining a function named `on_message()`, which will print
    a value `message is :` followed by whatever the data is. This will be done using
    the line `print(str(message.payload))`. What this is doing is, it is printing
    whatever is being passed on in the arguments of the function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In this line, we are defining the `on_connect()` function, which will print
    the line `connection returned` followed by the value of `rc`. `rc` stands for
    return code. So, whenever the message is delivered, a code is generated, even
    if it is not, then the specific code will be returned notifying the error. So,
    consider this as an acknowledgement. After this is done, the `SendData()` function
    that we defined earlier will be used to send the data to the broker.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`connect()` is a function of the MQTT library which connects the client to
    the broker. Doing this is very simple. All we need to do is pass on the arguments
    of the broker which we want to connect to and the port which would be used. In
    our case, `broker = broker.hivemq.com` and `port = 1883`. So when we call the
    function, Raspberry Pi gets connected to our broker.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This is the heart of the program. What the `client.on_connect` function is doing
    is that every time Raspberry Pi gets connected to the broker, it starts executing
    the `on_connect` function defined by us. This in-turn will send the data continuously to
    the broker after every 5 seconds, exactly the way in which we have defined in
    the function. This process is also called callback, which makes it event driven.
    That is, if it is not connected, it will not try to send the data to the broker.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: the sendData() function is called when the PIR sensor gets high or whenever
    the motion is detected the message is sent on the broker with the warning that
    someone is detected at your place.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This is my favorite function, especially because of the lovely name it has.
    As you can expect, the `client.loop_forver()` function will keep looking for any
    event and whenever it is detected it will trigger the data to be sent to the broker.
    Now comes the part where we will see this data. For this, we'll have to download
    the *MyMQTT* app from App Store if you are running iOS or from Playstore if you
    are running android.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0189638d-62f7-4eb5-b6b2-d12833d89293.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Once you start the app, you will be presented with the preceding screen. You
    need to fill in the name of the broker URL, which in our case is `broker.hivemq.com`.
    Then, fill in the port, which in our case is `1883`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once this is done, you will see a screen similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3f1828e0-7304-4a5e-8756-e0a44eed0f84.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Simply add the name of the subscription you need, which is `IntruderDetector_Home`.
    Once done, you'll see the magic!
  prefs: []
  type: TYPE_NORMAL
- en: You can also apply the same logic that we used in [Chapter 10](f5d8044d-e608-4ab6-adca-52ec2689f115.xhtml), *Making
    a Guard Robot*. So go ahead and play with it; I will leave you here.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will be controlling things based on IoT; see you then.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the home
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, using the following diagram, make the connections and upload the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9be0f710-94d2-4854-bf2b-ff106efea2f7.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, there is not much I need to tell you in this code; it''s pretty straightforward.
    We are sending the data just like we did last time. However, this time we are
    using a new function. So, let''s see what this code is all about:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here we are defining what the `on_message()` function is doing. There are three
    arguments to the function over which the message would be working on. This includes `client`,
    which we have already declared previously; `userdata`, which we are not using
    right now; and finally, `message`, which we will be sending through our smartphones
    over the internet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you look inside the program, this function will print the message using
    the lines `print(''message is : '')` and `print(str(message.payload))`. Once this
    is done, the value of `data` will be set as the message sent by the subscriber.'
  prefs: []
  type: TYPE_NORMAL
- en: This data will be evaluated by our conditions. If the data is kept `on`, then
    the GPIO port number `3` will be set to `HIGH`, and if the string is `off`, then
    the GPIO port number `3` will be set to `LOW`—in simple words, switching your
    device on or off your device.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We have defined the `on_connect()` function previously as well. However, this
    time it is slightly different. Rather than just printing the connection returned
    with the value of `rc`, we are also using another function called `client.subscribe(sub_topic)`,
    which will let us get connected to the broker on the specific topic that we have
    defined earlier in this program.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As we know that the entire algorithm is based on an event-driven system, this
    `client.on_message` function will keep waiting for a message to be received. Once
    received, it will then execute the `on_message` function. This will decide whether
    to turn the appliance on or off.
  prefs: []
  type: TYPE_NORMAL
- en: To use it, just go ahead and send the data based on the topic and it will be
    received by your Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6cd0c92b-fd78-4962-a161-9f3f16ec79a9.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Once received, the decision-making function, `on_message()`, will decide what
    data is being received by the MyMQTT app. If the data received is `on`, then the
    lights will be turned on. If the data received is `off`, then the lights will
    be turned off. It's as simple as that.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have understood the basics of IoT and how the MQTT server
    works. We also made an intruder detection system that will alert you whenever
    someone is in your home, no matter where you are in the world. Finally, we also
    created a system to switch on a device in your home using a simple mobile command.
    In the next chapter, we will let Jarvis enable to let you interact with the system
    based on your voices.
  prefs: []
  type: TYPE_NORMAL
