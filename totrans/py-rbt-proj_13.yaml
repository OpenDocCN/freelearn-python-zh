- en: Making Jarvis IoT Enabled
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制作Jarvis物联网启用版
- en: There was a time when we used to imagine controlling the world with our fingertips.
    Now, this imagination has become a reality. With the advent of smartphones, we
    have been doing stuff which one could have only imagined until a decade back.
    With mobile phones becoming smart, the industry and businesses have also tried
    their best to keep up with the disruptive change. However, there is one part that
    is still lagging behind. Which is that part? Your home!
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 曾经，我们曾想象用指尖控制世界。现在，这个想象已经变成了现实。随着智能手机的出现，我们一直在做十年前只能想象的事情。随着手机变得智能，行业和企业也尽力跟上颠覆性的变革。然而，还有一部分仍然落后。那是哪一部分呢？ 你的家！
- en: Think about what you can control in your home using your smartphone? Not many
    things! There are some devices that can turn on or off a bunch of devices such
    as your AC. However, the list is exhaustive. So, with all the knowledge gained
    in the previous chapters and the powerful hardware in our hands, why don't we
    become the trendsetters and the disrupters and make something that is still just
    a part of our imagination.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 想想你能用智能手机控制家里哪些东西？没多少吧！有一些设备可以打开或关闭一串设备，比如你的空调。然而，这个列表是详尽的。所以，在前面章节中获得的所有知识和我们手中的强大硬件面前，为什么我们不成为潮流的引领者和颠覆者，创造出仍然只是我们想象中的一部分的东西呢。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Basics of **Internet of Things** (**IoT**)
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**物联网**（**IoT**）基础'
- en: '**Message Queuing Telemetry Transport** (**MQTT**) protocol'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消息队列遥测传输**（**MQTT**）协议'
- en: Setting up MQTT broker
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置MQTT代理
- en: Making an IoT-based intrusion detector
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 制作基于物联网的入侵检测器
- en: Controlling the home
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制家庭
- en: Basics of IoT
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 物联网基础
- en: In this chapter, we will be controlling devices in our home using our smartphones,
    but before doing this, we should understand the basics of this technology. The
    first topic of this chapter is IoT—the overused jargon in the modern world. It
    is something that everyone wants to know about but no one does. IoT can be related
    to a technology, where your refrigerator will tell you what items are low in supply
    and will order it automatically for you. Poor thing! This technology has some
    time to invade our houses. But IoT does not mean this alone. IoT is a very wide
    term, something which can be applied to almost all the places for optimization.
    So what is IoT then?
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用智能手机控制家里的设备，但在这样做之前，我们应该了解这项技术的基础。本章的第一个主题是物联网——现代世界中被过度使用的术语。它是每个人都想了解但没有人真正了解的东西。物联网可以与一种技术相关联，比如你的冰箱会告诉你哪些物品供应不足，并自动为你订购。可怜的家伙！这项技术需要一段时间才能侵入我们的家庭。但物联网不仅仅意味着这一点。物联网是一个非常广泛的概念，几乎可以应用于所有地方进行优化。那么，物联网究竟是什么呢？
- en: Let's break this acronym, **Internet of Things** sometimes also known as cyber
    physical systems. Now, what is **Things**? Any electronic object that has the
    ability to collect or receive data without human intervention can be called a
    thing here. So this thing can be your mobile, a pacemaker, a health monitoring
    device, and so on. The only *if* is that it should be connected to the internet
    and has the ability to collect and/or receive data. The second term is **Internet**;
    the internet refers to the internet, Duh! Now, all of these IoT devices send and
    receive data from a cloud or a central computer. The reason why it does that is
    because any IoT device, whether big or small, is considered a resource-constrained
    environment. That is, the resources such as computing power is much less. This
    is because the IoT devices have to be simple and cheap. Imagine you have to put
    IoT sensors on all of the street lights to monitor traffic. If the device costs
    $500, then it would be impractical to install this kind of device. However, if
    it could be made for $5-$10, then no one would bat an eye. That's the thing with
    IoT devices; they are extremely cheap. Now the flip side to this story is that
    they do not have a lot of computing power. Hence, to balance this equation, instead
    of computing the raw data on their own processors, they simply send this data
    to a cloud computing device or perhaps a server where this data is computed and
    the meaningful result is taken. So, this solves all our problems then. Well, no!
    The second problem with these devices are that they can be battery operated, use-and-throw
    devices as well. For example, where temperature sensors are installed all across
    the forests; in such situations, no one and absolutely no one will go and change
    the batteries every week. Hence, these devices are made in such a way that they
    consume little to almost no power, thereby making the programming very tricky.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来分解这个缩写词，**物联网**有时也被称为网络物理系统。现在，什么是**事物**？任何能够无需人工干预收集或接收数据的电子设备都可以称为事物。所以这个事物可以是你的手机、起搏器、健康监测设备等等。唯一的条件是它应该连接到互联网，并且具有收集和/或接收数据的能力。第二个术语是**互联网**；互联网指的是互联网，嗯！现在，所有这些物联网设备都从云或中央计算机发送和接收数据。它之所以这样做的原因是，任何物联网设备，无论大小，都被视为资源受限的环境。也就是说，资源，如计算能力，要少得多。这是因为物联网设备必须简单且便宜。想象一下，你必须把物联网传感器安装在所有的路灯上以监控交通。如果设备成本为500美元，那么安装这种设备就不切实际了。然而，如果它可以用5-10美元的价格制造出来，那么没有人会眨一下眼。这就是物联网设备的特点；它们极其便宜。然而，这个故事的反面是，它们没有太多的计算能力。因此，为了平衡这个方程，它们不是在自己的处理器上计算原始数据，而是简单地发送这些数据到云计算设备或服务器，在那里这些数据被计算，并提取出有意义的结论。所以，这解决了我们所有的问题。嗯，不！这些设备的第二个问题是，它们可以是电池供电的，一次性使用设备。例如，在森林中安装的所有温度传感器；在这种情况下，没有人，绝对没有人会每周去更换电池。因此，这些设备被设计成消耗很少甚至没有电力，这使得编程变得非常棘手。
- en: Now that we have understood the IoT concepts, in this chapter, we'll be making
    our home IoT enabled. This means, we will be able to receive and collect data
    from the sensors from our home, see it on our mobile devices, and if needed, we
    can control the devices using your smartphones as well. There is one thing though,
    instead of computing it on cloud, we will simply be uploading all of our data
    onto the cloud and just accessing that data or sending our data to the cloud from
    where it can be accessed. We will be talking about the cloud computing aspect
    in a different book as this can be a whole new dimension and will be out of the
    scope of this book.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了物联网的概念，在本章中，我们将使我们的家庭物联网化。这意味着，我们将能够从我们的家庭传感器接收和收集数据，并在我们的移动设备上查看，如果需要，我们还可以通过智能手机控制这些设备。不过有一件事，我们不会在云上计算，而是将所有数据上传到云上，仅访问这些数据或从云上发送我们的数据，以便可以访问。我们将另开一册书来讨论云计算方面，因为这可以是一个全新的维度，并且超出了本书的范围。
- en: The MQTT protocol
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MQTT协议
- en: MQTT is an ISO-certified protocol and is in use very widely. The interesting
    thing about this protocol is that it was developed by Andy Stanford and Arlen
    Nipper in 1999 for monitoring of an oil pipeline through the desert. As you can
    imagine, in middle of a desert, the protocol they developed had to be energy efficient
    and bandwidth efficient as well.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: MQTT是一个ISO认证的协议，并且被广泛使用。这个协议有趣的地方在于，它是由Andy Stanford和Arlen Nipper在1999年开发的，用于通过沙漠监控石油管道。正如你可以想象的那样，在沙漠的中间，他们开发的协议必须既节能又带宽高效。
- en: How this protocol works is quite interesting. It has a publish-subscribe architecture.
    This means, it has a central server, which we also call a broker. Any device can
    register with this broker and publish any meaningful data onto it. Now, the data
    that is being published should have a topic, for example, air temperature.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这种协议是如何工作的非常有趣。它有一个发布-订阅架构。这意味着，它有一个中央服务器，我们通常称之为代理。任何设备都可以注册到这个代理并发布任何有意义的到它。现在，正在发布的数据应该有一个主题，例如，空气温度。
- en: These topics are particularly important. Why, you may ask? To the broker, there
    can be one or many devices that can be connected. With the connection, they also
    need to subscribe to a topic. Let's say they are subscribed to the topic *Air-*Temperature.
    Now, whenever any new data comes, it gets published to the subscribed devices.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这些主题特别重要。为什么你会问？对于代理来说，可以连接一个或多个设备。随着连接的建立，它们还需要订阅一个主题。假设它们订阅了主题*Air-*Temperature。现在，每当有新的数据到来时，它将被发布到订阅的设备。
- en: One important thing to know is that there need not be any request to gain the
    data from the broker like what we have in HTTP. Rather, whenever the data is received,
    it will be pushed to the device which is subscribed to that topic. It is very
    obvious that the TCP protocol will also be up and working during the whole time
    and the port related to the broker will always be connected for seamless data
    transmission. However, should there be any break in the data, the broker will
    buffer all the data and send it to the subscriber whenever the connection is resumed.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个重要的事情需要了解，那就是从代理获取数据不需要像HTTP中那样发出请求。相反，每当接收到数据时，它将被推送到订阅了该主题的设备。很明显，在整个过程中，TCP协议也将处于运行状态，并且与代理相关的端口将始终保持连接，以便实现无缝的数据传输。然而，如果数据出现中断，代理将缓冲所有数据，并在连接恢复时将数据发送给订阅者。
- en: '![](img/13bec90f-2720-4a6a-b32a-7160d779f889.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](img/13bec90f-2720-4a6a-b32a-7160d779f889.png)'
- en: As you can see The motion sensor and the temperature sensors are giving the
    data to MQTT server by a specific topic namely **Temperature** and **Motion**.
    Those whose are subscribed to these topics would get the reading from this device.
    Hence there is no direct communication needed between the actual sensor and the
    mobile device.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，运动传感器和温度传感器通过特定的主题将数据发送给MQTT服务器，这些主题分别是**温度**和**运动**。订阅了这些主题的用户将从这个设备获取读数。因此，实际传感器和移动设备之间不需要直接通信。
- en: The good thing about this whole architecture is that there can be limitless
    devices attached with this protocol and there need not be any scalability issues.
    Also, the protocol is relatively simple and easy to work with even a huge amount
    of data. Hence, this becomes the preferred protocol for IoT as it provides an
    easy, scalable, and seamless link between the data producer and the data receivers.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 整个架构的好处是，可以连接无限数量的设备，并且不需要考虑可扩展性问题。此外，该协议相对简单，易于处理，即使处理大量数据也是如此。因此，它成为物联网的首选协议，因为它提供了一个简单、可扩展且无缝的数据生产者和数据接收者之间的链接。
- en: Setting up the MQTT broker
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置MQTT代理
- en: 'Remember the old boring update process of vision processing? How can you forget?
    We have to do the same here as well. But lucky for us, this time it''s not very
    long. So, let''s see what we have to do to set up this server. Open up your command
    line and type in these following lines:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 记得那个老套的视觉处理更新过程吗？你怎么能忘记？我们在这里也要做同样的事情。但幸运的是，这次它并不长。那么，让我们看看我们为了设置这个服务器需要做什么。打开你的命令行，输入以下这些行：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You know what this line does. If you don''t have a clear memory of it, then
    refer to [Chapter 9](e8d477b8-8ece-4d9e-b62b-29dca9508f78.xhtml), *Vision Processing*. Once
    the update and upgrade processes are complete, go ahead and install the following
    packages:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道这一行的作用。如果你对它的记忆不是很清楚，那么请参考[第9章](e8d477b8-8ece-4d9e-b62b-29dca9508f78.xhtml)，*视觉处理*。一旦更新和升级过程完成，继续安装以下包：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This will install the Mosquitto broker onto your Raspberry Pi. This broker
    will take care of all the data transfer:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在你的Raspberry Pi上安装Mosquitto代理。这个代理将负责所有的数据传输：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now, this line will install the client packages. As you can imagine, Raspberry
    Pi in itself will be a client to the broker. Hence, it will take care of the needful.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这一行将安装客户端包。正如你所想象的那样，Raspberry Pi本身将是代理的一个客户端。因此，它将负责所需的一切。
- en: 'We have now installed the packages; yes exactly, it was that small. Now, all
    we need to do is configure the Mosquitto broker. To do this, you need to type
    in the following command:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经安装了包；是的，就是那么简单。现在，我们只需要配置 Mosquitto 代理。为此，你需要输入以下命令：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, this command will open the file where the Mosquitto file configuration
    is saved. To configure it, you need to get to the end of this file, where you
    will see the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个命令将打开保存 Mosquitto 文件配置的文件。为了配置它，你需要到达文件末尾，在那里你会看到以下内容：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, you can comment out the the preceding line of code by simply adding `#`
    before the lines. Once done then go ahead and add the following lines:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以通过在行前添加 `#` 来注释掉前面的代码行。完成后，继续添加以下行：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Let's see what we have done here. The `allow_anonymous false` line tells the
    broker that not everyone can access the data. The next line, `password_file /etc/mosquitto/pwfile`
    is telling the broker the location of password file, which is located at `/etc/mosquitto/pwfile`.
    Finally, we will define the port of this broker, which is `1883`, using the `listener
    1883` command.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们在这里做了什么。`allow_anonymous false` 这一行告诉代理不是每个人都可以访问数据。下一行，`password_file
    /etc/mosquitto/pwfile` 告诉代理密码文件的存放位置，该文件位于 `/etc/mosquitto/pwfile`。最后，我们将使用 `listener
    1883` 命令定义这个代理的端口，该端口是 `1883`。
- en: So finally, we have completed setting up the MQTT client in our Raspberry Pi.
    Now we are ready to go ahead and use it for the IoT-enabled home.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，最终，我们在我们的 Raspberry Pi 上完成了 MQTT 客户端的设置。现在我们准备好继续使用它来为物联网化的家庭服务。
- en: Making an IoT-based intrusion detector
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制作一个基于物联网的入侵检测器
- en: 'Now that Raspberry Pi is set up and we are ready to make it IoT enabled let''s
    see how we are going to connect the system to the internet and make things work.
    Firstly, we need to connect Raspberry Pi to the devices, which we want to control
    using the IoT technology. So go ahead and use the following diagram to make the
    connection:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Raspberry Pi 已经设置好，我们准备将其变为物联网设备，让我们看看我们将如何将系统连接到互联网并使其工作。首先，我们需要将 Raspberry
    Pi 连接到我们想要使用物联网技术控制的设备。所以，请继续使用以下图表来建立连接：
- en: '![](img/850b503e-0226-46eb-b76b-dd84ee83b7e2.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/850b503e-0226-46eb-b76b-dd84ee83b7e2.png)'
- en: 'Once you have set up all the components, let''s go ahead and upload the following
    code:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置好所有组件，让我们继续上传以下代码：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This code, unlike the other chunks of code that we have seen so far, will be
    quite new to you. So I will be explaining every part of it except for a few obvious
    parts. So, let''s see what we have here:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前看到的其他代码块不同，这段代码对你来说将相当新颖。所以，我将解释它的每一部分，除了几个显而易见的部分。那么，让我们看看这里有什么：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this part, we are importing the `pho.mqtt.client` library as `mqtt`. So whenever
    this library needs to be accessed, we simply need to use the line `mqtt` instead
    of the entire name of the library.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分，我们导入 `pho.mqtt.client` 库作为 `mqtt`。所以每当需要访问这个库时，我们只需使用 `mqtt` 这一行，而不是整个库的名称。
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We are defining a client using the client method of the `mqtt` library. This
    can be called using the `client` variable.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `mqtt` 库的客户端方法定义了一个客户端。这可以通过 `client` 变量来调用。
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: So we are defining the broker in our program. For this program, we are using
    the broker as `broker.hivemq.com`, which is providing us the broker services.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们在程序中定义了代理。对于这个程序，我们使用代理 `broker.hivemq.com`，它为我们提供代理服务。
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now as we have done earlier, we will once again define the port at which the
    protocol will be working, which in our case is `1883`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经像之前做的那样，将再次定义协议将工作的端口，在我们的例子中是 `1883`。
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, we are defining the value of the variable called `pub_topic`, which is
    `IntruderDetector_Home`. This will be the final topic to which one can subscribe
    once the code is running.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在定义一个名为 `pub_topic` 的变量的值，它是 `IntruderDetector_Home`。这将是在代码运行后可以订阅的最终主题。
- en: '[PRE12]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here, we are defining a function called `SendData()`,  will publish the data `Warning
    : SOMEONE DETECTED AT YOUR PLACE` to the broker with the topic which we had declared
    previously.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，我们定义了一个名为 `SendData()` 的函数，将数据 `Warning : SOMEONE DETECTED AT YOUR PLACE`
    发布到我们之前声明的主题的代理。'
- en: '[PRE13]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this line, we are defining a function named `on_message()`, which will print
    a value `message is :` followed by whatever the data is. This will be done using
    the line `print(str(message.payload))`. What this is doing is, it is printing
    whatever is being passed on in the arguments of the function.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一行，我们正在定义一个名为`on_message()`的函数，该函数将打印出`message is:`值，后跟数据。这将通过`print(str(message.payload))`行来完成。这个操作是在打印函数参数中传递的任何内容。
- en: '[PRE14]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this line, we are defining the `on_connect()` function, which will print
    the line `connection returned` followed by the value of `rc`. `rc` stands for
    return code. So, whenever the message is delivered, a code is generated, even
    if it is not, then the specific code will be returned notifying the error. So,
    consider this as an acknowledgement. After this is done, the `SendData()` function
    that we defined earlier will be used to send the data to the broker.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一行，我们正在定义`on_connect()`函数，该函数将打印出`connection returned`行，后跟`rc`的值。`rc`代表返回码。因此，每当消息送达时，都会生成一个代码，即使没有错误发生，也会返回特定的代码来通知错误。所以，这可以被视为一个确认。完成此操作后，我们将使用之前定义的`SendData()`函数将数据发送到代理。
- en: '[PRE15]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`connect()` is a function of the MQTT library which connects the client to
    the broker. Doing this is very simple. All we need to do is pass on the arguments
    of the broker which we want to connect to and the port which would be used. In
    our case, `broker = broker.hivemq.com` and `port = 1883`. So when we call the
    function, Raspberry Pi gets connected to our broker.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`connect()`是MQTT库中的一个函数，用于将客户端连接到代理。这样做非常简单。我们只需要传递我们想要连接的代理的参数以及将要使用的端口。在我们的例子中，`broker
    = broker.hivemq.com`和`port = 1883`。因此，当我们调用该函数时，树莓派就会连接到我们的代理。'
- en: '[PRE16]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This is the heart of the program. What the `client.on_connect` function is doing
    is that every time Raspberry Pi gets connected to the broker, it starts executing
    the `on_connect` function defined by us. This in-turn will send the data continuously to
    the broker after every 5 seconds, exactly the way in which we have defined in
    the function. This process is also called callback, which makes it event driven.
    That is, if it is not connected, it will not try to send the data to the broker.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这是程序的核心。`client.on_connect`函数所做的就是在树莓派每次连接到代理时，它都会执行我们定义的`on_connect`函数。这将连续每5秒将数据发送到代理，这正是我们在函数中定义的方式。这个过程也被称为回调，这使得它是事件驱动的。也就是说，如果没有连接，它不会尝试将数据发送到代理。
- en: '[PRE17]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: the sendData() function is called when the PIR sensor gets high or whenever
    the motion is detected the message is sent on the broker with the warning that
    someone is detected at your place.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当PIR传感器检测到高电平或检测到运动时，`sendData()`函数会被调用，将带有警告信息“有人在你这里被检测到”的消息发送到代理。
- en: '[PRE18]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is my favorite function, especially because of the lovely name it has.
    As you can expect, the `client.loop_forver()` function will keep looking for any
    event and whenever it is detected it will trigger the data to be sent to the broker.
    Now comes the part where we will see this data. For this, we'll have to download
    the *MyMQTT* app from App Store if you are running iOS or from Playstore if you
    are running android.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我最喜欢的函数，尤其是因为它有一个可爱的名字。正如你所预期的，`client.loop_forver()`函数将不断寻找任何事件，一旦检测到，就会触发将数据发送到代理。现在，我们将看到这些数据。为此，如果你正在运行iOS，我们需要从App
    Store下载*MyMQTT*应用；如果你正在运行Android，则需要从Playstore下载。
- en: '![](img/0189638d-62f7-4eb5-b6b2-d12833d89293.jpeg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0189638d-62f7-4eb5-b6b2-d12833d89293.jpeg)'
- en: Once you start the app, you will be presented with the preceding screen. You
    need to fill in the name of the broker URL, which in our case is `broker.hivemq.com`.
    Then, fill in the port, which in our case is `1883`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦启动应用，你将看到前面的屏幕。你需要填写代理URL的名称，在我们的例子中是`broker.hivemq.com`。然后，填写端口，在我们的例子中是`1883`。
- en: 'Once this is done, you will see a screen similar to the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些操作后，你将看到类似于以下屏幕的屏幕：
- en: '![](img/3f1828e0-7304-4a5e-8756-e0a44eed0f84.jpeg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3f1828e0-7304-4a5e-8756-e0a44eed0f84.jpeg)'
- en: Simply add the name of the subscription you need, which is `IntruderDetector_Home`.
    Once done, you'll see the magic!
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 简单地添加你需要订阅的名称，即`IntruderDetector_Home`。完成这些操作后，你将看到魔法！
- en: You can also apply the same logic that we used in [Chapter 10](f5d8044d-e608-4ab6-adca-52ec2689f115.xhtml), *Making
    a Guard Robot*. So go ahead and play with it; I will leave you here.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以应用我们在第10章中使用的相同逻辑，即*制作一个守卫机器人*。所以，请继续尝试；我会在这里等你。
- en: In the next section, we will be controlling things based on IoT; see you then.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将根据物联网来控制事物；到时候见。
- en: Controlling the home
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制家庭
- en: 'Finally, using the following diagram, make the connections and upload the following
    code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用以下图表，建立连接并上传以下代码：
- en: '![](img/9be0f710-94d2-4854-bf2b-ff106efea2f7.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9be0f710-94d2-4854-bf2b-ff106efea2f7.png)'
- en: '[PRE19]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, there is not much I need to tell you in this code; it''s pretty straightforward.
    We are sending the data just like we did last time. However, this time we are
    using a new function. So, let''s see what this code is all about:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在这段代码中，我没有什么要告诉你的；它相当直接。我们发送数据的方式和上次一样。然而，这次我们使用了一个新的函数。那么，让我们看看这段代码是关于什么的：
- en: '[PRE20]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here we are defining what the `on_message()` function is doing. There are three
    arguments to the function over which the message would be working on. This includes `client`,
    which we have already declared previously; `userdata`, which we are not using
    right now; and finally, `message`, which we will be sending through our smartphones
    over the internet.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了`on_message()`函数的作用。该函数有三个参数，消息将在这三个参数上工作。这包括我们之前已经声明的`client`；`userdata`，我们现在没有使用；最后是`message`，我们将通过智能手机通过互联网发送它。
- en: 'Once you look inside the program, this function will print the message using
    the lines `print(''message is : '')` and `print(str(message.payload))`. Once this
    is done, the value of `data` will be set as the message sent by the subscriber.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '一旦你查看程序内部，这个函数将使用`print(''message is : '')`和`print(str(message.payload))`这些行打印消息。一旦完成，`data`的值将被设置为订阅者发送的消息。'
- en: This data will be evaluated by our conditions. If the data is kept `on`, then
    the GPIO port number `3` will be set to `HIGH`, and if the string is `off`, then
    the GPIO port number `3` will be set to `LOW`—in simple words, switching your
    device on or off your device.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这份数据将由我们的条件进行评估。如果数据保持`on`，那么GPIO端口号`3`将被设置为`HIGH`，如果字符串是`off`，那么GPIO端口号`3`将被设置为`LOW`——简单来说，就是打开或关闭你的设备。
- en: '[PRE21]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We have defined the `on_connect()` function previously as well. However, this
    time it is slightly different. Rather than just printing the connection returned
    with the value of `rc`, we are also using another function called `client.subscribe(sub_topic)`,
    which will let us get connected to the broker on the specific topic that we have
    defined earlier in this program.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经定义了`on_connect()`函数。然而，这次它略有不同。我们不仅打印出带有`rc`值的连接返回值，还使用了一个名为`client.subscribe(sub_topic)`的另一个函数，这将使我们能够连接到我们在程序中之前定义的特定主题的代理。
- en: '[PRE22]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As we know that the entire algorithm is based on an event-driven system, this
    `client.on_message` function will keep waiting for a message to be received. Once
    received, it will then execute the `on_message` function. This will decide whether
    to turn the appliance on or off.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，整个算法基于事件驱动系统，这个`client.on_message`函数将一直等待接收消息。一旦接收到，它将执行`on_message`函数。这将决定是否打开或关闭设备。
- en: To use it, just go ahead and send the data based on the topic and it will be
    received by your Raspberry Pi.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用它，只需根据主题发送数据，它就会被你的树莓派接收。
- en: '![](img/6cd0c92b-fd78-4962-a161-9f3f16ec79a9.jpeg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6cd0c92b-fd78-4962-a161-9f3f16ec79a9.jpeg)'
- en: Once received, the decision-making function, `on_message()`, will decide what
    data is being received by the MyMQTT app. If the data received is `on`, then the
    lights will be turned on. If the data received is `off`, then the lights will
    be turned off. It's as simple as that.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦接收到，决策函数`on_message()`将决定MyMQTT应用接收到的数据是什么。如果接收到的数据是`on`，那么灯就会打开。如果接收到的数据是`off`，那么灯就会关闭。就这么简单。
- en: Summary
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have understood the basics of IoT and how the MQTT server
    works. We also made an intruder detection system that will alert you whenever
    someone is in your home, no matter where you are in the world. Finally, we also
    created a system to switch on a device in your home using a simple mobile command.
    In the next chapter, we will let Jarvis enable to let you interact with the system
    based on your voices.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了物联网的基本知识以及MQTT服务器的工作原理。我们还创建了一个入侵检测系统，无论你在世界上的任何地方，只要有人进入你的家，它就会发出警报。最后，我们还创建了一个系统，可以通过简单的手机命令在家中的设备上打开。在下一章中，我们将让Jarvis能够让你根据声音与系统交互。
