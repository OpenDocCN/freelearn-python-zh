["```py\n#!/usr/bin/python3 \n#painting.py \nimport tkinter as TK \n\n#Set defaults \nbtn1pressed = False \nnewline = True \n\ndef main(): \n  root = TK.Tk() \n  the_canvas = TK.Canvas(root) \n  the_canvas.pack() \n  the_canvas.bind(\"<Motion>\", mousemove) \n  the_canvas.bind(\"<ButtonPress-1>\", mouse1press) \n  the_canvas.bind(\"<ButtonRelease-1>\", mouse1release) \n  root.mainloop() \n\ndef mouse1press(event): \n  global btn1pressed \n  btn1pressed = True \n\ndef mouse1release(event): \n  global btn1pressed, newline \n  btn1pressed = False \n  newline = True \n\ndef mousemove(event): \n  if btn1pressed == True: \n    global xorig, yorig, newline \n    if newline == False: \n      event.widget.create_line(xorig,yorig,event.x,event.y, \n                               smooth=TK.TRUE) \n    newline = False \n    xorig = event.x \n    yorig = event.y \n\nif __name__ == \"__main__\": \n  main() \n#End\n```", "```py\n#!/usr/bin/python3 \n# bouncingball.py \nimport tkinter as TK \nimport time \n\nVERT,HOREZ=0,1 \nxTOP,yTOP = 0,1 \nxBTM,yBTM = 2,3 \nMAX_WIDTH,MAX_HEIGHT = 640,480 \nxSTART,ySTART = 100,200 \nBALL_SIZE=20 \nRUNNING=True \n```", "```py\ndef close(): \n  global RUNNING \n  RUNNING=False \n  root.destroy() \n\ndef move_right(event): \n  if canv.coords(paddle)[xBTM]<(MAX_WIDTH-7): \n    canv.move(paddle, 7, 0) \n\ndef move_left(event): \n  if canv.coords(paddle)[xTOP]>7: \n    canv.move(paddle, -7, 0) \n\ndef determineDir(ball,obj): \n  global delta_x,delta_y \n  if (ball[xTOP] == obj[xBTM]) or (ball[xBTM] ==  \n      obj[xTOP]): \n    delta_x = -delta_x \n  elif (ball[yTOP] == obj[yBTM]) or (ball[yBTM] ==  \n        obj[yTOP]): \n    delta_y = -delta_y \n```", "```py\nroot = TK.Tk() \nroot.title(\"Bouncing Ball\") \nroot.geometry('%sx%s+%s+%s' %(MAX_WIDTH, MAX_HEIGHT, 100, 100)) \nroot.bind('<Right>', move_right) \nroot.bind('<Left>', move_left) \nroot.protocol('WM_DELETE_WINDOW', close) \n\ncanv = TK.Canvas(root, highlightthickness=0) \ncanv.pack(fill='both', expand=True)\n```", "```py\ntop = canv.create_line(0, 0, MAX_WIDTH, 0, fill='blue', \n                       tags=('top')) \nleft = canv.create_line(0, 0, 0, MAX_HEIGHT, fill='blue', \n                        tags=('left')) \nright = canv.create_line(MAX_WIDTH, 0, MAX_WIDTH, MAX_HEIGHT, \n                         fill='blue', tags=('right')) \nbottom = canv.create_line(0, MAX_HEIGHT, MAX_WIDTH, MAX_HEIGHT, \n                          fill='blue', tags=('bottom')) \n\nball = canv.create_rectangle(0, 0, BALL_SIZE, BALL_SIZE, \n                             outline='black', fill='black',  \n                             tags=('ball')) \npaddle = canv.create_rectangle(100, MAX_HEIGHT - 30, 150, 470, \n                               outline='black',  \n                               fill='green', tags=('rect')) \n```", "```py\nbrick=list() \nfor i in range(0,16): \n  for row in range(0,4): \n    brick.append(canv.create_rectangle(i*40, row*20, \n                 ((i+1)*40)-2, ((row+1)*20)-2, \n                 outline='black', fill='red', \n                 tags=('rect'))) \n\ndelta_x = delta_y = 1 \nxold,yold = xSTART,ySTART \ncanv.move(ball, xold, yold) \n```", "```py\nwhile RUNNING: \n  objects = canv.find_overlapping(canv.coords(ball)[0], \n                                  canv.coords(ball)[1], \n                                  canv.coords(ball)[2], \n                                  canv.coords(ball)[3]) \n\n  #Only change the direction once (so will bounce off 1st \n  # block even if 2 are hit) \n  dir_changed=False \n  for obj in objects: \n    if (obj != ball): \n      if dir_changed==False: \n        determineDir(canv.coords(ball),canv.coords(obj)) \n        dir_changed=True \n      if (obj >= brick[0]) and (obj <= brick[len(brick)-1]): \n        canv.delete(obj) \n      if (obj == bottom): \n        text = canv.create_text(300,100,text=\"YOU HAVE MISSED!\") \n        canv.coords(ball, (xSTART,ySTART, \n                    xSTART+BALL_SIZE,ySTART+BALL_SIZE)) \n        delta_x = delta_y = 1 \n        canv.update() \n        time.sleep(3) \n        canv.delete(text) \n  new_x, new_y = delta_x, delta_y \n  canv.move(ball, new_x, new_y) \n\n  canv.update() \n  time.sleep(0.005) \n#End \n```", "```py\nbrick=list() \nfor i in range(0,16): \n  for row in range(0,4): \n    brick.append(canv.create_rectangle(i*40, row*20,  \n                 ((i+1)*40)-2, ((row+1)*20)-2, outline='black',  \n                 fill='red', tags=('rect'))) \n```", "```py\nif (ball[xTOP] == obj[xBTM]) or (ball[xBTM] == obj[xTOP]): \n    delta_x = -delta_x \n```", "```py\nif (obj >= brick[0]) and (obj <= brick[-1]): \n    canv.delete(obj) \n```", "```py\n#!/usr/bin/python3 \n# scroller.py \nimport tkinter as TK \nimport time \nimport math \nfrom random import randint \n\nSTEP=7 \nxVAL,yVAL=0,1 \nMAX_WIDTH,MAX_HEIGHT=640,480 \nSPACE_WIDTH=MAX_WIDTH*2 \nSPACE_HEIGHT=MAX_HEIGHT*2 \nLEFT,UP,RIGHT,DOWN=0,1,2,3 \nSPACE_LIMITS=[0,0,SPACE_WIDTH-MAX_WIDTH, \n              SPACE_HEIGHT-MAX_HEIGHT] \nDIS_LIMITS=[STEP,STEP,MAX_WIDTH-STEP,MAX_HEIGHT-STEP] \nBGN_IMG=\"bg.gif\" \nPLAYER_IMG=[\"playerL.gif\",\"playerU.gif\", \n            \"playerR.gif\",\"playerD.gif\"] \nWALL_IMG=[\"wallH.gif\",\"wallV.gif\"] \nGOLD_IMG=\"gold.gif\" \nMARK_IMG=\"mark.gif\" \nnewGame=False \nchecks=list() \n```", "```py\ndef move_right(event): \n  movePlayer(RIGHT,STEP) \ndef move_left(event): \n  movePlayer(LEFT,-STEP) \ndef move_up(event): \n  movePlayer(UP,-STEP) \ndef move_down(event): \n  movePlayer(DOWN,STEP) \n\ndef foundWall(facing,move): \n  hitWall=False \n  olCoords=[canv.coords(player)[xVAL], \n            canv.coords(player)[yVAL], \n            canv.coords(player)[xVAL]+PLAYER_SIZE[xVAL], \n            canv.coords(player)[yVAL]+PLAYER_SIZE[yVAL]] \n  olCoords[facing]+=move \n  objects = canv.find_overlapping(olCoords[0],olCoords[1], \n                                  olCoords[2],olCoords[3]) \n  for obj in objects: \n    objTags = canv.gettags(obj) \n    for tag in objTags: \n      if tag == \"wall\": \n        hitWall=True \n  return hitWall \n\ndef moveBackgnd(movement): \n  global bg_offset \n  bg_offset[xVAL]+=movement[xVAL] \n  bg_offset[yVAL]+=movement[yVAL] \n  for obj in canv.find_withtag(\"bg\"): \n    canv.move(obj, -movement[xVAL], -movement[yVAL]) \n\ndef makeMove(facing,move): \n  if facing == RIGHT or facing == LEFT: \n    movement=[move,0] #RIGHT/LEFT \n    bgOffset=bg_offset[xVAL] \n    playerPos=canv.coords(player)[xVAL] \n  else: \n    movement=[0,move] #UP/DOWN \n    bgOffset=bg_offset[yVAL] \n    playerPos=canv.coords(player)[yVAL] \n  #Check Bottom/Right Corner \n  if facing == RIGHT or facing == DOWN:  \n    if (playerPos+PLAYER_SIZE[xVAL]) < DIS_LIMITS[facing]: \n      canv.move(player, movement[xVAL], movement[yVAL]) \n    elif bgOffset < SPACE_LIMITS[facing]: \n      moveBackgnd(movement) \n  else: \n    #Check Top/Left Corner \n    if (playerPos) > DIS_LIMITS[facing]: \n      canv.move(player, movement[xVAL], movement[yVAL]) \n    elif bgOffset > SPACE_LIMITS[facing]: \n      moveBackgnd(movement) \n\ndef movePlayer(facing,move): \n  hitWall=foundWall(facing,move) \n  if hitWall==False: \n    makeMove(facing,move) \n  canv.itemconfig(player,image=playImg[facing])\n```", "```py\ndef check(event): \n  global checks,newGame,text \n  if newGame: \n    for chk in checks: \n      canv.delete(chk) \n    del checks[:] \n    canv.delete(gold,text) \n    newGame=False \n    hideGold() \n  else: \n    checks.append( \n                  canv.create_image(canv.coords(player)[xVAL], \n                  canv.coords(player)[yVAL], \n                  anchor=TK.NW, image=checkImg, \n                  tags=('check','bg'))) \n    distance=measureTo(checks[-1],gold) \n    if(distance<=0): \n      canv.itemconfig(gold,state='normal') \n      canv.itemconfig(check,state='hidden') \n      text = canv.create_text(300,100,fill=\"white\", \n                              text=(\"You have found the gold in\"+  \n                              \" %d tries!\"%len(checks))) \n      newGame=True \n    else: \n      text = canv.create_text(300,100,fill=\"white\", \n                              text=(\"You are %d steps away!\"%distance)) \n      canv.update() \n      time.sleep(1) \n      canv.delete(text) \n\ndef measureTo(objectA,objectB): \n  deltaX=canv.coords(objectA)[xVAL]- \n                     canv.coords(objectB)[xVAL] \n  deltaY=canv.coords(objectA)[yVAL]- \n                     canv.coords(objectB)[yVAL] \n  w_sq=abs(deltaX)**2 \n  h_sq=abs(deltaY)**2 \n  hypot=math.sqrt(w_sq+h_sq) \n  return round((hypot/5)-20,-1)\n```", "```py\ndef hideGold(): \n  global gold \n  goldPos=findLocationForGold() \n  gold=canv.create_image(goldPos[xVAL], goldPos[yVAL], \n                         anchor=TK.NW, image=goldImg, \n                         tags=('gold','bg'), \n                         state='hidden') \n\ndef findLocationForGold(): \n  placeGold=False \n  while(placeGold==False): \n    goldPos=[randint(0-bg_offset[xVAL], \n             SPACE_WIDTH-GOLD_SIZE[xVAL]-bg_offset[xVAL]), \n             randint(0-bg_offset[yVAL], \n             SPACE_HEIGHT-GOLD_SIZE[yVAL]-bg_offset[yVAL])] \n    objects = canv.find_overlapping(goldPos[xVAL], \n                                    goldPos[yVAL], \n                                    goldPos[xVAL]+GOLD_SIZE[xVAL], \n                                    goldPos[yVAL]+GOLD_SIZE[yVAL]) \n    findNewPlace=False \n    for obj in objects: \n      objTags = canv.gettags(obj) \n      for tag in objTags: \n        if (tag == \"wall\") or (tag == \"player\"): \n          findNewPlace=True \n    if findNewPlace == False: \n      placeGold=True \n  return goldPos \n```", "```py\nroot = TK.Tk() \nroot.title(\"Overhead Game\") \nroot.geometry('%sx%s+%s+%s' %(MAX_WIDTH,  \n                              MAX_HEIGHT,  \n                              100, 100)) \nroot.resizable(width=TK.FALSE, height=TK.FALSE) \nroot.bind('<Right>', move_right) \nroot.bind('<Left>', move_left) \nroot.bind('<Up>', move_up) \nroot.bind('<Down>', move_down) \nroot.bind('<Return>', check) \n\ncanv = TK.Canvas(root, highlightthickness=0) \ncanv.place(x=0,y=0,width=SPACE_WIDTH,height=SPACE_HEIGHT)\n```", "```py\n#Create background tiles \nbgnImg = TK.PhotoImage(file=BGN_IMG) \nBGN_SIZE = bgnImg.width(),bgnImg.height() \nbackground=list() \nCOLS=int(SPACE_WIDTH/BGN_SIZE[xVAL])+1 \nROWS=int(SPACE_HEIGHT/BGN_SIZE[yVAL])+1 \nfor col in range(0,COLS): \n  for row in range(0,ROWS): \n    background.append(canv.create_image(col*BGN_SIZE[xVAL], \n                      row*BGN_SIZE[yVAL], anchor=TK.NW, \n                      image=bgnImg, \n                      tags=('background','bg'))) \nbg_offset=[0,0] \n\n#Create player \nplayImg=list() \nfor img in PLAYER_IMG: \n  playImg.append(TK.PhotoImage(file=img)) \n#Assume images are all same size/shape \nPLAYER_SIZE=playImg[RIGHT].width(),playImg[RIGHT].height() \nplayer = canv.create_image(100,100, anchor=TK.NW, \n                           image=playImg[RIGHT], \n                           tags=('player')) \n\n#Create walls \nwallImg=[TK.PhotoImage(file=WALL_IMG[0]), \n         TK.PhotoImage(file=WALL_IMG[1])] \nWALL_SIZE=[wallImg[0].width(),wallImg[0].height()] \nwallPosH=[(0,WALL_SIZE[xVAL]*1.5), \n          (WALL_SIZE[xVAL],WALL_SIZE[xVAL]*1.5), \n          (SPACE_WIDTH-WALL_SIZE[xVAL],WALL_SIZE[xVAL]*1.5), \n          (WALL_SIZE[xVAL],SPACE_HEIGHT-WALL_SIZE[yVAL])] \nwallPosV=[(WALL_SIZE[xVAL],0),(WALL_SIZE[xVAL]*3,0)] \nwallPos=[wallPosH,wallPosV] \nwall=list() \nfor i,img in enumerate(WALL_IMG): \n  for item in wallPos[i]: \n    wall.append(canv.create_image(item[xVAL],item[yVAL], \n                anchor=TK.NW, image=wallImg[i], \n                tags=('wall','bg'))) \n\n#Place gold \ngoldImg = TK.PhotoImage(file=GOLD_IMG) \nGOLD_SIZE=[goldImg.width(),goldImg.height()] \nhideGold() \n#Check mark \ncheckImg = TK.PhotoImage(file=MARK_IMG) \n```", "```py\n#Wait for actions from user \nroot.mainloop() \n#End \n```"]