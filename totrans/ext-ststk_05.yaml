- en: Chapter 5. Rendering Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章：渲染数据
- en: Having the ability to write your own execution and state modules is powerful
    from a developer's point of view, but you cannot overlook being able to provide
    that kind of power to users who do not have the ability to provide modules of
    their own.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 能够编写自己的执行和状态模块对于开发者来说是一种强大的能力，但你不能忽视为那些没有能力提供自己模块的用户提供这种能力。
- en: 'Renderers allow users to provide data to various parts of Salt using different
    kinds of data input formats. The handful of renderers that ship with Salt cover
    the majority of use cases, but what if your users need to apply data in a specialized
    format? Or even a more common one that is not yet supported, such as XML? In this
    chapter, we''ll discuss:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染器允许用户使用不同类型的数据输入格式向Salt的各个部分提供数据。Salt附带的一小部分渲染器涵盖了大多数用例，但如果你用户需要以专用格式应用数据怎么办？或者甚至是一个尚未支持但更常见的格式，如XML？在本章中，我们将讨论：
- en: Writing renderers
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写渲染器
- en: Troubleshooting renderers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决渲染器问题
- en: Understanding file formats
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解文件格式
- en: 'By default, Salt uses YAML for its various files. There are two primary reasons
    for this:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Salt使用YAML处理其各种文件。有两个主要原因：
- en: YAML is easily converted into Python data structures
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: YAML可以轻松转换为Python数据结构
- en: YAML is easy for humans to read and modify
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: YAML易于人类阅读和修改
- en: Salt configuration files must be in YAML as well (or JSON, which can be read
    by YAML parsers), but other files such as states, pillars, reactors, and so on
    can use other formats. A data serialization format is the most common, but any
    format that can be translated into a Python dictionary will do just fine.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Salt配置文件也必须使用YAML（或JSON，可以被YAML解析器读取），但其他文件，如状态、支柱、反应器等，可以使用其他格式。数据序列化格式是最常见的，但任何可以转换为Python字典的格式都可以。
- en: 'For example, there are three different Python renderers that ship with Salt:
    `py`, `pyobjects`, and `pydsl`. Each has its strengths and weaknesses, but the
    end result is the same: they execute Python code that results in a dictionary,
    which is then passed into Salt.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Salt附带三个不同的Python渲染器：`py`、`pyobjects`和`pydsl`。每个都有其优点和缺点，但最终结果相同：它们执行Python代码，生成字典，然后传递给Salt。
- en: Generally speaking, you will find two types of renderers inside of Salt. The
    first returns data in a Python data structure. Both serializers and code-based
    modules fit into this category. The second is for managing text formatting and
    templating. Let's talk about each in turn, and then build our own renderers later
    on in the chapter.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 一般而言，你会在Salt中找到两种类型的渲染器。第一种返回Python数据结构中的数据。序列化和基于代码的模块都属于这一类别。第二种用于管理文本格式化和模板。让我们依次讨论每个部分，然后在章节的后面构建我们自己的渲染器。
- en: Serializing data
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 序列化数据
- en: Data can be stored in any number of formats, but in the end, that data must
    be something that can be turned into instructions. Formats such as YAML and JSON
    are obvious choices, because they are easy to modify and mirror the resulting
    data structures in the program that uses them. Binary formats such as Message
    Pack aren't as easily modified by humans, but they still result in the same data
    structures.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 数据可以存储在任何数量的格式中，但最终，这些数据必须是能够转换为指令的东西。YAML和JSON等格式是明显的选择，因为它们易于修改，并且反映了使用它们的程序中的结果数据结构。二进制格式，如Message
    Pack，虽然不易于人类修改，但它们仍然产生相同的数据结构。
- en: Other formats, such as XML, are more difficult because they don't directly resemble
    the internal data structures of programs like Salt. They're great for modeling
    code that makes heavy use of classes, but Salt doesn't make much use of such code.
    However, when you know how such a format can be converted into a data structure
    that Salt can use, then building a renderer for it is not difficult.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 其他格式，如XML，更难处理，因为它们并不直接类似于Salt等程序的内部数据结构。它们非常适合建模大量使用类的代码，但Salt并不大量使用这种代码。然而，当你知道如何将这种格式转换为Salt可以使用的数据结构时，为其构建渲染器并不困难。
- en: Working with templates
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与模板一起工作
- en: Templates are important because they allow end users to use certain programmatic
    elements without having to write actual modules. Variables are certainly one of
    the most critical elements of a templating engine, but other constructs such as
    loops and branching can also give a lot of power to the user.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 模板很重要，因为它们允许最终用户使用某些程序元素，而无需编写实际的模块。变量无疑是模板引擎中最关键元素之一，但其他结构，如循环和分支，也可以给用户带来很大的权力。
- en: Templating renderers differ from data-serializing renderers in that instead
    of returning data in a dictionary format, which is then ingested by Salt, they
    return data that must be converted at least one more time, using a data-serialization
    renderer.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 模板渲染器与数据序列化渲染器不同，因为它们不是以字典格式返回数据，然后由Salt摄取，而是返回至少需要使用数据序列化渲染器转换一次的数据。
- en: This may seem counterintuitive on some levels, but the use of render pipes brings
    these two elements together.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些层面上，这可能会显得有些反直觉，但使用渲染管道将这两个元素结合起来。
- en: Using render pipes
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用渲染管道
- en: Render pipes are based on Unix pipes; data can be passed from module to module
    through a series of pipes, in order to arrive at the final data structure. You
    may not realize it, but if you've ever written an SLS file, you've used a render
    pipe.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染管道基于Unix管道；数据可以通过一系列管道从模块传递到模块，以便到达最终的数据结构。你可能没有意识到，但如果你曾经编写过SLS文件，你就已经使用了渲染管道。
- en: 'To set up a render pipe, you add a line to the top of the file to be rendered,
    which contains the classic Unix hashbang, followed by the renderers to be used,
    in the order to be used, separated by the pipe character. The default rendering
    sequence is effectively:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置渲染管道，你需要在要渲染的文件顶部添加一行，其中包含经典的Unix hashbang，后面跟着要使用的渲染器，按照使用的顺序，由管道字符分隔。默认的渲染顺序实际上是：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This means that the file in question will be first parsed by Jinja2, and compiled
    into a format that can be read by the YAML library.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着相关的文件将首先由Jinja2解析，然后编译成YAML库可以读取的格式。
- en: 'It''s generally not reasonable or necessary to pipe more than two different
    renderers together; the more that are used, the more complicated the resulting
    file is to understand by humans, and the greater the chance for errors. Generally,
    a templating engine that adds programmatic shortcuts, and a data serializer, is
    plenty. One notable exception is the `gpg` renderer, which can be used for encryption-at-rest
    scenarios. The hashbang for this would look like:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 通常来说，将两个以上的不同渲染器组合在一起并不合理或必要；使用的越多，结果文件对人类来说就越复杂，出错的可能性也越大。一般来说，一个添加了程序性快捷方式的模板引擎和一个数据序列化器就足够了。一个值得注意的例外是`gpg`渲染器，它可以用于静态加密场景。这个hashbang看起来会是这样：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Building a serializing renderer
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建序列化渲染器
- en: Renderers are reasonably easy to build, because they typically do little more
    than import a library, shove data through it, and then return the result. Our
    example renderer will make use of Python's own Pickle format.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染器相对容易构建，因为它们通常做的只是导入一个库，将数据通过它，然后返回结果。我们的示例渲染器将使用Python自己的Pickle格式。
- en: The basic structure
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本结构
- en: Outside of any necessary imports, a renderer requires only a `render()` function.
    The most important argument is the first. As with other modules, the name of this
    argument is not important to Salt, so long as it is defined. Because our example
    uses the `pickle` library, we'll use `pickle_data` as our argument name.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何必要的导入之外，渲染器只需要一个`render()`函数。最重要的参数是第一个。与其他模块一样，这个参数的名称对Salt来说并不重要，只要它被定义即可。因为我们的例子使用了`pickle`库，所以我们将使用`pickle_data`作为我们的参数名称。
- en: Other arguments are also passed into renderers, but in our case we'll only use
    them for troubleshooting. In particular, we need to accept `saltenv` and `sls`,
    with the defaults shown later. We'll cover those in the *Troubleshooting Renderers*
    section, but for now we'll just use `kwargs` to cover them.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 其他参数也会传递给渲染器，但在这个例子中，我们只会用它们来解决问题。特别是，我们需要接受`saltenv`和`sls`，稍后会显示它们的默认值。我们将在“*渲染器故障排除*”部分介绍它们，但现在我们只需使用`kwargs`来涵盖它们。
- en: We also need to start with a special kind of `import`, called `absolute_import`,
    that allows us to import the `pickle` library from a file that's also called `pickle`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要从一种特殊的`import`开始，称为`absolute_import`，它允许我们从也称为`pickle`的文件中导入`pickle`库。
- en: 'Let''s go ahead and lay out the module, and then talk about the components
    in the `render()` function:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先列出模块，然后讨论`render()`函数中的组件：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This function does not do much, other than:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数除了以下内容之外不做太多：
- en: First, check to see whether the data being passed in is a string, and if not,
    treat it as a file-like object.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，检查传入的数据是否为字符串，如果不是，则将其视为文件对象。
- en: Check for the existence of a `#!`, indicating the use of an explicit render
    pipe. Because that pipe is handled elsewhere, and it will cause errors with the
    `pickle` library, discard it.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查是否存在`#!`，表示使用了显式的渲染管道。因为那个管道在其他地方处理，并且会导致与`pickle`库的错误，所以将其丢弃。
- en: Check to see whether the resulting content is empty. If so, return an empty
    dictionary.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查结果内容是否为空。如果是，则返回一个空字典。
- en: Run the data through the `pickle` library, and return the result.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`pickle`库运行数据，并返回结果。
- en: If you start comparing this code with the renderers that ship with Salt, you'll
    find that many of them are almost identical. This is in part because so many data
    serialization libraries in Python use exactly the same methods.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您开始将此代码与Salt附带的自定义渲染器进行比较，您会发现它们几乎完全相同。这在很大程度上是因为Python中许多数据序列化库使用完全相同的方法。
- en: 'Let''s put together a file that can be used. The example data that we''ll use
    is:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个可以使用的文件。我们将使用的示例数据如下：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The best way to create this file is with Python itself. Go ahead and open up
    a Python shell and type the following commands:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 创建此文件的最佳方式是使用Python本身。请打开Python shell并输入以下命令：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When you exit out of the Python shell, you should be able to open this file
    in your favorite text editor. When you add a hashbang line to the top that specifies
    the `pickle` renderer, your file will probably look like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当您退出Python shell时，您应该能够用您最喜欢的文本编辑器打开此文件。当您在顶部添加一个指定`pickle`渲染器的hashbang行时，您的文件可能看起来像这样：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Save the file, and use `salt-call` to test out your renderer. This time, we''ll
    tell Salt to dump out the resulting SLS, as Salt sees it:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件，并使用`salt-call`测试您的渲染器。这次，我们将告诉Salt将结果SLS以Salt看到的形式输出：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Salt's state compiler adds some extra information that it uses internally, but
    we can see that the basics of what we requested are there.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Salt的状态编译器添加了一些它内部使用的额外信息，但我们可以看到我们请求的基本内容都在那里。
- en: Building a templating renderer
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建模板渲染器
- en: 'Building a renderer that handles templating files is not that different from
    one that does serialization. In fact, the renderer itself is pretty much the same,
    outside of the library-specific code. This time, we''ll use a Python library called
    `tenjin`. You may need to install it using pip:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 构建处理模板文件的渲染器与处理序列化的渲染器没有太大区别。实际上，渲染器本身除了库特定的代码外，几乎相同。这次，我们将使用一个名为`tenjin`的Python库。您可能需要使用pip安装它：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Templating with Tenjin
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Tenjin进行模板化
- en: 'This module makes use of a third-party library, so there will be a `__virtual__()`
    function to make sure it''s installed:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 此模块使用第三方库，因此将有一个`__virtual__()`函数来确保它已安装：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `render()` function itself is fundamentally identical to the one that we
    used for `pickle`, except for the last two lines, which handles the templating
    engine slightly differently.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`render()`函数本身与用于`pickle`的函数基本相同，除了最后两行，它们对模板引擎的处理略有不同。'
- en: Take note of the `kwargs` that are passed into this function. Templating engines
    generally have the ability to merge in an external data structure, which can be
    used with the various data structures in the templating engine itself. Salt will
    make some data available inside kwargs, so we'll pass that in for Tenjin to use.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 注意传递给此函数的`kwargs`。模板引擎通常具有合并外部数据结构的能力，这可以与模板引擎本身的各种数据结构一起使用。Salt会在`kwargs`中提供一些数据，因此我们将传递这些数据以供Tenjin使用。
- en: Using a templating renderer
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用模板渲染器
- en: 'Of course, you''ll need a hashbang line in your SLS files as before, but since
    our Tenjin renderer isn''t set up to return straight data, you will need to add
    the name of the desired data-serialization renderer to your render pipe. We''ll
    use the same actual SLS data as before, but with a couple of Tenjin-specific elements
    added:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您需要在SLS文件中添加一个hashbang行，就像之前一样，但由于我们的Tenjin渲染器没有设置为直接返回数据，您需要将所需的数据序列化渲染器的名称添加到您的渲染管道中。我们将使用之前相同的实际SLS数据，但添加了一些Tenjin特定的元素：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We haven't done anything special here, just set a couple of variables, and then
    used them. The resulting content will be in YAML format, so we've added `yaml`
    to our render pipe.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里没有做任何特别的事情，只是设置了一些变量，然后使用了它们。结果内容将是YAML格式，因此我们向我们的渲染管道添加了`yaml`。
- en: 'A number of templating engines, including Tenjin, have the ability to process
    templates that output either strings (as we''ve done in our example), or an actual
    data structure, such as what a data serializer would return. When using such a
    library, take a moment to consider how much of it you plan to use, and whether
    it makes sense to create two distinct renderers for it: one for data and one for
    strings.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 许多模板引擎，包括Tenjin，都有能力处理输出字符串（如我们示例中所做）或实际数据结构（如数据序列化器返回的数据）的模板。当使用此类库时，请花点时间考虑您计划使用多少，以及是否需要为它创建两个不同的渲染器：一个用于数据，一个用于字符串。
- en: 'Testing is much the same as before:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 测试与之前相同：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We can see slight differences between our first example and our second, but
    those differences just show which module was used to render the data.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们的第一个示例和第二个示例之间有一些细微的差异，但这些差异只是显示了用于渲染数据的模块。
- en: Troubleshooting renderers
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染器故障排除
- en: Because renderers are so often used to manage SLS files, it is often easiest
    to troubleshoot them using the state compiler, as we have been doing already in
    this chapter.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 由于渲染器经常被用来管理SLS文件，因此使用状态编译器进行故障排除通常是最简单的，正如我们在本章中已经做的那样。
- en: First, generate a small SLS file that contains the specific elements which you
    need to test. This will either be a data file in the format that a serialization
    engine uses, or a text-based file that results in a data-serialization file format.
    If you are writing a templating renderer, it is often easiest to just use YAML.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，生成一个包含你需要测试的特定元素的SLS小文件。这可能是使用序列化引擎格式的数据文件，或者是一个生成数据序列化文件格式的基于文本的文件。如果你正在编写模板渲染器，通常最简单的方法就是使用YAML。
- en: 'The `state` execution module contains a number of functions that exist primarily
    for troubleshooting. We used `state.show_sls` in our examples, with `--out yaml`,
    because it displays the output in a format that we''re already used to in our
    SLS files. However, some other useful functions are:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`state`执行模块包含许多主要用于故障排除的函数。我们在示例中使用了`state.show_sls`，并带有`--out yaml`选项，因为它以我们在SLS文件中已经习惯的格式显示输出。然而，还有一些其他有用的函数：'
- en: '`state.show_low_sls`: Shows data from a single SLS file, after it has been
    converted to low data by the State compiler. Low data is often easier to visualize
    when writing state modules.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`state.show_low_sls`：显示单个SLS文件在状态编译器将其转换为低数据后的数据。在编写状态模块时，低数据通常更容易可视化。'
- en: '`state.show_highstate`: Shows all of the states, as they would be applied to
    a Minion, according to the `top.sls` file. The output from this will look as if
    all of the SLS files have been shoved together. This can be useful when troubleshooting
    rendering issues that you believe span across multiple SLS files.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`state.show_highstate`：显示所有状态，根据`top.sls`文件，它们将被应用到Minion上。此输出的外观就像所有SLS文件都被堆在一起一样。这在故障排除你认为跨越多个SLS文件的渲染问题时可能很有用。'
- en: '`state.show_lowstate`: The data returned from this function is the same as
    what `state.show_highstate` returns, but after being processed by the state compiler.
    Again, this is like a long version of `state.show_low_sls`.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`state.show_lowstate`：此函数返回的数据与`state.show_highstate`返回的数据相同，但经过状态编译器处理。这又像是`state.show_low_sls`的长版本。'
- en: Summary
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Renderers are used to convert various file formats into a data structure that
    is usable internally by Salt. Data-serialization renderers return data in a dictionary
    format, whereas templating renderers return data that can be processed by a data
    serializer. Both types of renderer look the same, and require a `render()` function.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染器用于将各种文件格式转换为Salt内部可用的数据结构。数据序列化渲染器以字典格式返回数据，而模板渲染器返回可以由数据序列化器处理的数据。这两种类型的渲染器看起来相同，都需要一个`render()`函数。
- en: 'Now that we know how to handle the data going into Salt, it''s time to look
    at the data coming back out of Salt. Next up: handling return data.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道如何处理进入Salt的数据，是时候看看从Salt返回的数据了。接下来：处理返回数据。
