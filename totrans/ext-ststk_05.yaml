- en: Chapter 5. Rendering Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having the ability to write your own execution and state modules is powerful
    from a developer's point of view, but you cannot overlook being able to provide
    that kind of power to users who do not have the ability to provide modules of
    their own.
  prefs: []
  type: TYPE_NORMAL
- en: 'Renderers allow users to provide data to various parts of Salt using different
    kinds of data input formats. The handful of renderers that ship with Salt cover
    the majority of use cases, but what if your users need to apply data in a specialized
    format? Or even a more common one that is not yet supported, such as XML? In this
    chapter, we''ll discuss:'
  prefs: []
  type: TYPE_NORMAL
- en: Writing renderers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Troubleshooting renderers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding file formats
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By default, Salt uses YAML for its various files. There are two primary reasons
    for this:'
  prefs: []
  type: TYPE_NORMAL
- en: YAML is easily converted into Python data structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: YAML is easy for humans to read and modify
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Salt configuration files must be in YAML as well (or JSON, which can be read
    by YAML parsers), but other files such as states, pillars, reactors, and so on
    can use other formats. A data serialization format is the most common, but any
    format that can be translated into a Python dictionary will do just fine.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, there are three different Python renderers that ship with Salt:
    `py`, `pyobjects`, and `pydsl`. Each has its strengths and weaknesses, but the
    end result is the same: they execute Python code that results in a dictionary,
    which is then passed into Salt.'
  prefs: []
  type: TYPE_NORMAL
- en: Generally speaking, you will find two types of renderers inside of Salt. The
    first returns data in a Python data structure. Both serializers and code-based
    modules fit into this category. The second is for managing text formatting and
    templating. Let's talk about each in turn, and then build our own renderers later
    on in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Serializing data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Data can be stored in any number of formats, but in the end, that data must
    be something that can be turned into instructions. Formats such as YAML and JSON
    are obvious choices, because they are easy to modify and mirror the resulting
    data structures in the program that uses them. Binary formats such as Message
    Pack aren't as easily modified by humans, but they still result in the same data
    structures.
  prefs: []
  type: TYPE_NORMAL
- en: Other formats, such as XML, are more difficult because they don't directly resemble
    the internal data structures of programs like Salt. They're great for modeling
    code that makes heavy use of classes, but Salt doesn't make much use of such code.
    However, when you know how such a format can be converted into a data structure
    that Salt can use, then building a renderer for it is not difficult.
  prefs: []
  type: TYPE_NORMAL
- en: Working with templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Templates are important because they allow end users to use certain programmatic
    elements without having to write actual modules. Variables are certainly one of
    the most critical elements of a templating engine, but other constructs such as
    loops and branching can also give a lot of power to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Templating renderers differ from data-serializing renderers in that instead
    of returning data in a dictionary format, which is then ingested by Salt, they
    return data that must be converted at least one more time, using a data-serialization
    renderer.
  prefs: []
  type: TYPE_NORMAL
- en: This may seem counterintuitive on some levels, but the use of render pipes brings
    these two elements together.
  prefs: []
  type: TYPE_NORMAL
- en: Using render pipes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Render pipes are based on Unix pipes; data can be passed from module to module
    through a series of pipes, in order to arrive at the final data structure. You
    may not realize it, but if you've ever written an SLS file, you've used a render
    pipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set up a render pipe, you add a line to the top of the file to be rendered,
    which contains the classic Unix hashbang, followed by the renderers to be used,
    in the order to be used, separated by the pipe character. The default rendering
    sequence is effectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This means that the file in question will be first parsed by Jinja2, and compiled
    into a format that can be read by the YAML library.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s generally not reasonable or necessary to pipe more than two different
    renderers together; the more that are used, the more complicated the resulting
    file is to understand by humans, and the greater the chance for errors. Generally,
    a templating engine that adds programmatic shortcuts, and a data serializer, is
    plenty. One notable exception is the `gpg` renderer, which can be used for encryption-at-rest
    scenarios. The hashbang for this would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Building a serializing renderer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Renderers are reasonably easy to build, because they typically do little more
    than import a library, shove data through it, and then return the result. Our
    example renderer will make use of Python's own Pickle format.
  prefs: []
  type: TYPE_NORMAL
- en: The basic structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Outside of any necessary imports, a renderer requires only a `render()` function.
    The most important argument is the first. As with other modules, the name of this
    argument is not important to Salt, so long as it is defined. Because our example
    uses the `pickle` library, we'll use `pickle_data` as our argument name.
  prefs: []
  type: TYPE_NORMAL
- en: Other arguments are also passed into renderers, but in our case we'll only use
    them for troubleshooting. In particular, we need to accept `saltenv` and `sls`,
    with the defaults shown later. We'll cover those in the *Troubleshooting Renderers*
    section, but for now we'll just use `kwargs` to cover them.
  prefs: []
  type: TYPE_NORMAL
- en: We also need to start with a special kind of `import`, called `absolute_import`,
    that allows us to import the `pickle` library from a file that's also called `pickle`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go ahead and lay out the module, and then talk about the components
    in the `render()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This function does not do much, other than:'
  prefs: []
  type: TYPE_NORMAL
- en: First, check to see whether the data being passed in is a string, and if not,
    treat it as a file-like object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check for the existence of a `#!`, indicating the use of an explicit render
    pipe. Because that pipe is handled elsewhere, and it will cause errors with the
    `pickle` library, discard it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check to see whether the resulting content is empty. If so, return an empty
    dictionary.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run the data through the `pickle` library, and return the result.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you start comparing this code with the renderers that ship with Salt, you'll
    find that many of them are almost identical. This is in part because so many data
    serialization libraries in Python use exactly the same methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s put together a file that can be used. The example data that we''ll use
    is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The best way to create this file is with Python itself. Go ahead and open up
    a Python shell and type the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'When you exit out of the Python shell, you should be able to open this file
    in your favorite text editor. When you add a hashbang line to the top that specifies
    the `pickle` renderer, your file will probably look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the file, and use `salt-call` to test out your renderer. This time, we''ll
    tell Salt to dump out the resulting SLS, as Salt sees it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Salt's state compiler adds some extra information that it uses internally, but
    we can see that the basics of what we requested are there.
  prefs: []
  type: TYPE_NORMAL
- en: Building a templating renderer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Building a renderer that handles templating files is not that different from
    one that does serialization. In fact, the renderer itself is pretty much the same,
    outside of the library-specific code. This time, we''ll use a Python library called
    `tenjin`. You may need to install it using pip:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Templating with Tenjin
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This module makes use of a third-party library, so there will be a `__virtual__()`
    function to make sure it''s installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `render()` function itself is fundamentally identical to the one that we
    used for `pickle`, except for the last two lines, which handles the templating
    engine slightly differently.
  prefs: []
  type: TYPE_NORMAL
- en: Take note of the `kwargs` that are passed into this function. Templating engines
    generally have the ability to merge in an external data structure, which can be
    used with the various data structures in the templating engine itself. Salt will
    make some data available inside kwargs, so we'll pass that in for Tenjin to use.
  prefs: []
  type: TYPE_NORMAL
- en: Using a templating renderer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Of course, you''ll need a hashbang line in your SLS files as before, but since
    our Tenjin renderer isn''t set up to return straight data, you will need to add
    the name of the desired data-serialization renderer to your render pipe. We''ll
    use the same actual SLS data as before, but with a couple of Tenjin-specific elements
    added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We haven't done anything special here, just set a couple of variables, and then
    used them. The resulting content will be in YAML format, so we've added `yaml`
    to our render pipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'A number of templating engines, including Tenjin, have the ability to process
    templates that output either strings (as we''ve done in our example), or an actual
    data structure, such as what a data serializer would return. When using such a
    library, take a moment to consider how much of it you plan to use, and whether
    it makes sense to create two distinct renderers for it: one for data and one for
    strings.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Testing is much the same as before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We can see slight differences between our first example and our second, but
    those differences just show which module was used to render the data.
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting renderers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Because renderers are so often used to manage SLS files, it is often easiest
    to troubleshoot them using the state compiler, as we have been doing already in
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: First, generate a small SLS file that contains the specific elements which you
    need to test. This will either be a data file in the format that a serialization
    engine uses, or a text-based file that results in a data-serialization file format.
    If you are writing a templating renderer, it is often easiest to just use YAML.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `state` execution module contains a number of functions that exist primarily
    for troubleshooting. We used `state.show_sls` in our examples, with `--out yaml`,
    because it displays the output in a format that we''re already used to in our
    SLS files. However, some other useful functions are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`state.show_low_sls`: Shows data from a single SLS file, after it has been
    converted to low data by the State compiler. Low data is often easier to visualize
    when writing state modules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`state.show_highstate`: Shows all of the states, as they would be applied to
    a Minion, according to the `top.sls` file. The output from this will look as if
    all of the SLS files have been shoved together. This can be useful when troubleshooting
    rendering issues that you believe span across multiple SLS files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`state.show_lowstate`: The data returned from this function is the same as
    what `state.show_highstate` returns, but after being processed by the state compiler.
    Again, this is like a long version of `state.show_low_sls`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Renderers are used to convert various file formats into a data structure that
    is usable internally by Salt. Data-serialization renderers return data in a dictionary
    format, whereas templating renderers return data that can be processed by a data
    serializer. Both types of renderer look the same, and require a `render()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we know how to handle the data going into Salt, it''s time to look
    at the data coming back out of Salt. Next up: handling return data.'
  prefs: []
  type: TYPE_NORMAL
