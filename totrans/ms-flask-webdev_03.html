<html><head></head><body>
        

                            
                    <h1 class="header-title">Creating Views with Templates</h1>
                
            
            
                
<p>Now that we have our data in an easily accessible format, displaying the information in a web page becomes much easier. In this chapter, we will learn how to do the following:</p>
<ul>
<li>Use the included templating language for Flask, Jinja, to dynamically create HTML for our SQLAlchemy models</li>
<li>Use Jinja's methods to automate the creation of HTML and modify data for presentation inside a template</li>
<li>Automatically create and validate HTML forms with Jinja</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Jinja's syntax</h1>
                
            
            
                
<p><strong>Jinja</strong> is a templating language written in Python. A <strong>templating language</strong> is a simple format that is designed to help automate the creation of documents. In any templating language, variables passed to the template replace predefined elements in the template. In Jinja, variable substitutions are defined by <kbd>{{ }}</kbd>. The <kbd>{{ }}</kbd> syntax is called a <strong>variable block</strong>. There are also <strong>control blocks</strong> defined by <kbd>{% %}</kbd> that declare language functions, such as <strong>loops</strong> or <kbd>if</kbd> statements. For example, when the <kbd>Post</kbd> model from <a href="42af8825-fb77-4eb9-a010-7d7fc9644f7c.xhtml" target="_blank">Chapter 2</a>, <em>Creating Models with SQLAlchemy</em>, is passed to it, we get the following Jinja code:</p>
<pre>&lt;h1&gt;{{ post.title }}&lt;/h1&gt; </pre>
<p>This produces the following:</p>
<pre>&lt;h1&gt;First Post&lt;/h1&gt; </pre>
<p>The variables displayed in a Jinja template can be any Python type or object as long as they can be converted into a string via the Python function <kbd>str()</kbd>. For example, a dictionary or a list passed to a template can have its attributes displayed via the following code:</p>
<pre>{{ your_dict['key'] }} 
{{ your_list[0] }} </pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>Many programmers prefer to use JavaScript to template and dynamically create their HTML documents to take the HTML rendering load off the server. This will not be covered in this chapter as it is an advanced JavaScript topic. However, many JavaScript templating engines use the <kbd>{{ }}</kbd> syntax as well. If you choose to combine Jinja and your JavaScript templates that are defined in your HTML files, then wrap the JavaScript templates in the <kbd>raw</kbd> control block to tell Jinja to ignore them, as follows:</p>
<pre>{% raw %} 
&lt;script id="template" type="text/x-handlebars-template"&gt; 
  &lt;h1&gt;{{title}}&lt;/h1&gt; 
  &lt;div class="body"&gt; 
    {{body}} 
  &lt;/div&gt; 
&lt;/script&gt; 
{% endraw %} </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Filters</h1>
                
            
            
                
<p>It's a common mistake to believe that Jinja and Python's syntax are the same because of their similarity. However, there is a lot of difference between the two. As you will see in this section, normal Python functions do not really exist. Instead, in Jinja, variables can be passed to built-in functions that modify the variables for display purposes. These functions, called filters, are called in the variable block with the pipe character, <kbd>|</kbd>, as shown in the following code:</p>
<pre>{{ variable | filter_name(*args) }} </pre>
<p>Otherwise, if no arguments are passed to the filter, the parentheses can be omitted as follows:</p>
<pre>{{ variable | filter_name }} </pre>
<p>Filters called control blocks can also be applied to blocks of text, as follows:</p>
<pre>{% filter filter_name %} 
  A bunch of text 
{% endfilter %} </pre>
<p>There are many filters in Jinja; this book will cover only the most useful filters. For the sake of brevity, in each example, the output of each filter will be listed directly beneath the filter itself.</p>
<p class="mce-root"/>
<p>For a full list of all the default filters in Jinja, visit <a href="http://jinja.pocoo.org/docs/dev/templates/#list-of-builtin-filters">http://jinja.pocoo.org/docs/dev/templates/#list-of-builtin-filters</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The default filter</h1>
                
            
            
                
<p>If the passed variable is <kbd>None</kbd>, then replace it with a <kbd>default</kbd> value as follows:</p>
<pre>{{ post.date | default('2015-01-01') }} 
2015-01-01 </pre>
<p>If you wish to replace the variable with the <kbd>default</kbd> value, and if the variable evaluates to <kbd>False</kbd>, then pass <kbd>True</kbd> to the optional second parameter, as follows:</p>
<pre>{{ '' | default('An empty string', True) }} 
An empty string</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">The escape filter</h1>
                
            
            
                
<p>If the passed variable is a string of HTML, then the <kbd>&amp;</kbd>, <kbd>&lt;</kbd>, <kbd>&gt;</kbd>, <kbd>'</kbd>, and <kbd>"</kbd> characters will be printed as HTML <kbd>escape</kbd> sequences:</p>
<pre>{{ "&lt;h1&gt;Title&lt;/h1&gt;" | escape }} 
&lt;h1&gt;Title&lt;/h1&gt; </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">The float filter</h1>
                
            
            
                
<p>The <kbd>float</kbd> filter converts the passed value to a floating point number with the Python <kbd>float()</kbd> function as follows:</p>
<pre>{{ 75 | float }} 
75.0 </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">The int filter</h1>
                
            
            
                
<p>The <kbd>int</kbd> filter converts the passed value to an integer with the Python <kbd>int()</kbd> function as follows:</p>
<pre>{{ 75.7 | int }} 
75 </pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>


            

            
        
    

        

                            
                    <h1 class="header-title">The join filter</h1>
                
            
            
                
<p>The <kbd>join</kbd> filter joins elements of a list with a string, and works in exactly the same way as the <kbd>list</kbd> method of the same name. It is given as follows:</p>
<pre>{{ ['Python', 'SQLAlchemy'] | join(',') }} 
Python, SQLAlchemy </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">The length filter</h1>
                
            
            
                
<p>The <kbd>length</kbd> filter fills the same role as the Python <kbd>len()</kbd> function. It is used as follows:</p>
<pre>Tag Count: {{ post.tags | length }} 
Tag Count: 2 </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">The round filter</h1>
                
            
            
                
<p>The <kbd>round</kbd> filter rounds off a float to the specified precision, as follows:</p>
<pre>{{ 3.141592653589793238462 | round(1) }} 
3.1 </pre>
<p>You can also specify how you want the number to be rounded off, as shown in the following code:</p>
<pre>{{ 4.7 | round(1, "common") }} 
5 
{{ 4.2 | round(1, "common") }} 
4 
{{ 4.7 | round(1, "floor") }} 
4 
{{ 4.2 | round(1, "ceil") }} 
5 </pre>
<p>The <kbd>common</kbd> option rounds such figures in the same way that a person would: Any number at or above 0.5 is rounded up, and any number lower than 0.5 is rounded down. The <kbd>floor</kbd> option always rounds the number down and the <kbd>ceil</kbd> option always rounds up, regardless of the decimal value.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>


            

            
        
    

        

                            
                    <h1 class="header-title">The safe filter</h1>
                
            
            
                
<p>If you try to insert HTML into your page from a variable—for example, when you wish to display a blog post—Jinja will automatically try to add HTML <kbd>escape</kbd> sequences to the output. Look at the following example:</p>
<pre>{{ "&lt;h1&gt;Post Title&lt;/h1&gt;" }} 
&lt;h1&gt;Post Title&lt;/h1&gt; </pre>
<p>This is a necessary security feature. When an application has inputs that allow users to submit arbitrary text, it creates a vulnerability that a malicious user can use to input HTML code. For example, if a user were to submit a script tag as a comment and Jinja didn't have this feature, the script would be executed on all the browsers that visited the page.</p>
<p>However, we still need a way to display HTML that we know is safe to show, such as the HTML of our blog posts. We can achieve this using the <kbd>safe</kbd> filter as follows:</p>
<pre>{{ "&lt;h1&gt;Post Title&lt;/h1&gt;" | safe }} 
&lt;h1&gt;Post Title&lt;/h1&gt; </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">The title filter</h1>
                
            
            
                
<p>The <kbd>title</kbd> filter enables us to capitalize a string using the <kbd>title</kbd> case format as follows:</p>
<pre>{{ "post title" | title }} 
Post Title </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">The tojson filter</h1>
                
            
            
                
<p>We use the <kbd>tojson</kbd> filter to pass the variable to the Python <kbd>json.dumps</kbd> function, as shown in the following code. Remember that your passed object must be serializable by the <kbd>json</kbd> module:</p>
<pre>{{ {'key': False, 'key2': None, 'key3': 45} | tojson }} 
{key: false, key2: null, key3: 45} </pre>
<p>This feature is most commonly used to pass SQLAlchemy models to JavaScript MVC frameworks upon the loading of the page load than waiting for an AJAX request. If you use <kbd>tojson</kbd> in this way, remember to pass the result to the <kbd>safe</kbd> filter as well to make sure that you don't get HTML <kbd>escape</kbd> sequences in your JavaScript. Here is an example with a collection of models from <kbd>Backbone.js</kbd>, a popular JavaScript MVC framework:</p>
<pre>var collection = new PostCollection({{ posts | tojson | safe }}); </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">The truncate filter</h1>
                
            
            
                
<p>The <kbd>truncate</kbd> filter takes a long string, returns a string cutoff at the specified length in characters, and appends an ellipsis, as shown in the following code:</p>
<pre>{{ "A Longer Post Body Than We Want" | truncate(10) }} 
A Longer... </pre>
<p>By default, any words that are cut in the middle are discarded. To disable this, pass <kbd>True</kbd> as an extra parameter as follows:</p>
<pre>{{ "A Longer Post Body Than We Want" | truncate(10, True) }} 
A Longer P... </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Custom filters</h1>
                
            
            
                
<p>Adding your own filter into Jinja is as simple as writing a Python function. To understand custom filters, we will look at an example. Our simple filter will count the number of occurrences of a substring in a string and return this figure. Look at the following call:</p>
<pre>{{ variable | count_substring("string") }} </pre>
<p>We need to write a new Python function with the following signature, where the first argument is the <em>piped </em>variable:</p>
<pre>def count_substring(variable, sub_string) </pre>
<p>We can define our filter as the following:</p>
<pre>@app.template_filter<br/>def count_substring(string, sub_string): return string.count(sub_string)</pre>
<p>To add this function to the list of available filters on <strong>Jinja2</strong>, we have to register it and add it to the <kbd>filters</kbd> dictionary of the <kbd>jinja_env</kbd> object in our <kbd>main.py</kbd> file. To do this, we can simply use a decorator that will handle this procedure for us—<kbd>@app.template_filter</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Comments</h1>
                
            
            
                
<p>Comments in the template are defined by <kbd>{# #}</kbd>, as shown in the following code. They will be ignored by Jinja, and will not be in the returned HTML code:</p>
<pre>{# Note to the maintainers of this code #} </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Using if statements</h1>
                
            
            
                
<p>Using <kbd>if</kbd> statements in Jinja is similar to using them in Python. Anything that returns, or is, a Boolean determines the flow of the code, as shown in the following code:</p>
<pre>{%if user.is_logged_in() %} 
  &lt;a href='/logout'&gt;Logout&lt;/a&gt; 
{% else %} 
  &lt;a href='/login'&gt;Login&lt;/a&gt; 
{% endif %} </pre>
<p>Filters can also be used in <kbd>if</kbd> statements, as follows:</p>
<pre>{% if comments | length &gt; 0 %} 
  There are {{ comments | length }} comments 
{% else %} 
  There are no comments 
{% endif %} </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Loops</h1>
                
            
            
                
<p>We can use loops in Jinja to iterate over any list or generator function, as follows:</p>
<pre>{% for post in posts %} 
  &lt;div&gt; 
    &lt;h1&gt;{{ post.title }}&lt;/h1&gt; 
    &lt;p&gt;{{ post.text | safe }}&lt;/p&gt; 
  &lt;/div&gt; 
{% endfor %} </pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>Loops and <kbd>if</kbd> statements can be combined to mimic the <kbd>break</kbd> functionality in Python loops. In this example, the loop will only use the post <kbd>if post.text</kbd> is not <kbd>None</kbd>:</p>
<pre>{% for post in posts if post.text %}
  &lt;div&gt;
    &lt;h1&gt;{{ post.title }}&lt;/h1&gt;
    &lt;p&gt;{{ post.text | safe }}&lt;/p&gt;
  &lt;/div&gt;
{% endfor %}</pre>
<p>Inside the loop, you have access to a special variable called <kbd>loop</kbd>, which gives you access to information about the <kbd>for</kbd> loop. For example, if we want to know the current index of the current loop to emulate the <kbd>enumerate</kbd> function in Python, we can use the index variable of the <kbd>loop</kbd> variable as follows:</p>
<pre>{% for post in posts %} 
  {{ loop.index }}. {{ post.title }} 
{% endfor %} </pre>
<p>This will produce the following output:</p>
<pre>1. Post Title 
2. Second Post </pre>
<p>All the variables and functions that the <kbd>loop</kbd> object exposes are listed in the following table:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td>
<p><strong>Variable</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>loop.index</kbd></p>
</td>
<td>
<p>The current iteration of the loop (1 indexed)</p>
</td>
</tr>
<tr>
<td>
<p><kbd>loop.index0</kbd></p>
</td>
<td>
<p>The current iteration of the loop (0 indexed)</p>
</td>
</tr>
<tr>
<td>
<p><kbd>loop.revindex</kbd></p>
</td>
<td>
<p>The number of iterations from the end of the loop (1 indexed)</p>
</td>
</tr>
<tr>
<td>
<p><kbd>loop.revindex0</kbd></p>
</td>
<td>
<p>The number of iterations from the end of the loop (0 indexed)</p>
</td>
</tr>
<tr>
<td>
<p><kbd>loop.first</kbd></p>
</td>
<td>
<p>True if the current item is first in the iterator</p>
</td>
</tr>
<tr>
<td>
<p><kbd>loop.last</kbd></p>
</td>
<td>
<p>True if the current item is last in the iterator</p>
</td>
</tr>
<tr>
<td>
<p><kbd>loop.length</kbd></p>
</td>
<td>
<p>The number of items in the iterator</p>
</td>
</tr>
<tr>
<td>
<p><kbd>loop.cycle</kbd></p>
</td>
<td>
<p>The <kbd>helper</kbd> function to cycle between the items in the iterator (this is explained later)</p>
</td>
</tr>
<tr>
<td>
<p><kbd>loop.depth</kbd></p>
</td>
<td>
<p>Indicates how deep in a recursive loop the loop currently is (starts at level 1)</p>
</td>
</tr>
<tr>
<td>
<p><kbd>loop.depth0</kbd></p>
</td>
<td>
<p>Indicates how deep in a recursive loop the loop currently is (starts at level 0)</p>
</td>
</tr>
</tbody>
</table>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p>The <kbd>cycle</kbd> function is a function that goes through an iterator one item at a time in every loop. We can use the previous example to demonstrate, as shown in the following code:</p>
<pre>{% for post in posts %} 
  {{ loop.cycle('odd', 'even') }} {{ post.title }} 
{% endfor %} </pre>
<p>This will output the following:</p>
<pre>odd Post Title 
even Second Post </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Macros</h1>
                
            
            
                
<p>A <strong>macro</strong> is best understood as a function in Jinja that returns a template or HTML string. This is used to avoid reproducing code that is repeated over and over again and reduce it to one function call. For example, the following is a macro to add a Bootstrap CSS input and a label to your template:</p>
<pre>{% macro input(name, label, value='', type='text') %} 
  &lt;div class="form-group"&gt; 
    &lt;label for"{{ name }}"&gt;{{ label }}&lt;/label&gt; 
    &lt;input type="{{ type }}" name="{{ name }}" 
      value="{{ value | escape }}" class="form-control"&gt; 
  &lt;/div&gt; 
{% endmacro %} </pre>
<p>Now, to quickly add an input to a form in any template, call your macro using the following:</p>
<pre>{{ input('name', 'Name') }} </pre>
<p>This will output the following:</p>
<pre>&lt;div class="form-group"&gt; 
  &lt;label for"name"&gt;Name&lt;/label&gt; 
  &lt;input type="text" name="name" value="" class="form-control"&gt; 
&lt;/div&gt; </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Flask-specific variables and functions</h1>
                
            
            
                
<p>Flask makes several functions and objects available to you by default in your template.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">The config object</h1>
                
            
            
                
<p>Flask makes the current <kbd>config</kbd> object available in templates as follows:</p>
<pre>{{ config.SQLALCHEMY_DATABASE_URI }} 
sqlite:///database.db </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">The request object</h1>
                
            
            
                
<p>The Flask <kbd>request</kbd> object refers to the current request:</p>
<pre>{{ request.url }} 
http://127.0.0.1/ </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">The session object</h1>
                
            
            
                
<p>The Flask <kbd>session</kbd> object is as follows:</p>
<pre>{{ session.new }} 
True </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">The url_for() function</h1>
                
            
            
                
<p>The <kbd>url_for</kbd> function returns the URL of a route by giving the route function name as a parameter, as shown in the following code. This allows URLs to be changed without worrying about where links will break:</p>
<pre>{{ url_for('home') }} 
/ </pre>
<p>Here, <kbd>home</kbd><strong> </strong>is the name of a function that is registered as an endpoint on Flask,<strong> </strong>and the relative URL root associated with it, so on our <kbd>main.py</kbd>, we must define a function to deal with the HTTP request and register it on Flask using the decorator <kbd>app.route(rule, **options)</kbd>, as shown in the following code:</p>
<pre>@app.route('/')<br/>def home():<br/>...</pre>
<p>If we had a route that had positional arguments in the URL, we pass them as <kbd>kwargs</kbd>. They will be filled in for us in the resultant URL as follows:</p>
<pre>{{ url_for('post', post_id=1) }}
/post/1</pre>
<p>With the respective function that we use to handle the request, we restrict this method to handle only GET and POST HTTP requests, as follows:</p>
<pre>@app.route('/post/&lt;int:post_id&gt;', methods=('GET', 'POST'))<br/>def post(post_id):<br/>...</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">The get_flashed_messages() function</h1>
                
            
            
                
<p>The <kbd>get_flashed_messages()</kbd> function returns a list of all the messages passed through the <kbd>flash()</kbd> function in Flask. The <kbd>flash</kbd> function is a simple function that queues messages—which consist of Python tuples of (category, message) phrases—for the <kbd>get_flashed_messages</kbd> function to consume, as shown in the following code:</p>
<pre>{% with messages = get_flashed_messages(with_categories=true) %}<br/>    {% if messages %}<br/>        {% for category, message in messages %}<br/>        &lt;div class="alert alert-{{ category }} alert-dismissible"               <br/>       role="alert"&gt;<br/>        &lt;button type="button" class="close" data-dismiss="alert" aria-   <br/>   label="Close"&gt;&lt;span aria-hidden="true"&gt;&amp;times;&lt;/span&gt;&lt;/button&gt;<br/>            {{ message }}<br/>        &lt;/div&gt;<br/>        {% endfor %}<br/>    {% endif %}<br/>{% endwith %}</pre>
<p>Proper feedback to the user is very important, and Flask makes it very simple to implement—for example, when handling a new post entry, we want to let the user know that his/her post was saved correctly. The <kbd>flash()</kbd> function accepts three different categories: <kbd>info</kbd>, <kbd>error</kbd>, and <kbd>warning</kbd>. Refer to the following code snippet:</p>
<pre>@app.route('/post/&lt;int:post_id&gt;', methods=('GET', 'POST'))<br/>def post(post_id):<br/>...<br/>    db.session.commit()<br/>    flash("New post added.", 'info')<br/>...</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating our views</h1>
                
            
            
                
<p>To get started, we need to create a new folder named <kbd>templates</kbd> in our project directory. This folder will store all of our Jinja files, which are just HTML files with Jinja syntax mixed in. Our first template will be our home page, which will be a list of the first 10 posts with summaries. There will also be a view for a post that will just show the post content, the comments on the page, links to the author's user page, and links to tag pages. There will also be user and tag pages that show all the posts that have been made by a user and all the posts with a specific tag. Each page will also have a sidebar showing the five most recent posts and the top five most used tags.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The view function</h1>
                
            
            
                
<p>Because each page will have the same sidebar information, we can break that into a separate function to simplify our code. In the <kbd>main.py</kbd> file, add the following code:</p>
<pre>from sqlalchemy import func 
... 
def sidebar_data(): 
  recent = Post.query.order_by( 
    Post.publish_date.desc() 
  ).limit(5).all() 
  top_tags = db.session.query( 
    Tag, func.count(tags.c.post_id).label('total') 
  ).join( 
    tags 
  ).group_by(Tag).order_by('total DESC').limit(5).all() 
 
  return recent, top_tags </pre>
<p>The most recent posts query is straightforward, but the most popular tags query looks somewhat familiar, but a little odd. This is a bit outside the scope of this book, but using the SQLAlchemy <kbd>func</kbd> library to return a count on a group by query, we are able to order our tags by the most used tags. The <kbd>func</kbd> function is explained in detail at <a href="http://docs.sqlalchemy.org/en/latest/core/functions.html#module-sqlalchemy.sql.expression">http://docs.sqlalchemy.org/en/rel_1_0/core/sqlelement.html#sqlalchemy.sql.expression.func</a>.</p>
<p>The <kbd>home</kbd> page function in <kbd>main.py</kbd> will need all the posts ordered by their publish date in a pagination object and the sidebar information, as follows:</p>
<pre>from flask import Flask, render_template 
...<br/>@app.route('/')<br/>@app.route('/&lt;int:page&gt;')<br/>def home(page=1):<br/>    posts = Post.query.order_by(Post.publish_date.desc()).paginate(page, app.config['POSTS_PER_PAGE'], False)<br/>    recent, top_tags = sidebar_data()<br/><br/>    return render_template(<br/>        'home.html',<br/>        posts=posts,<br/>        recent=recent,<br/>        top_tags=top_tags<br/>    )</pre>
<p>Note that using the <kbd>app.config['POSTS_PER_PAGE']</kbd> phrase gives us the option to configure it without having to change code, which is nice. It's a candidate config key for the main <kbd>Config</kbd> class, and let all environments inherit its value. </p>
<p>Here, we finally see how Flask and Jinja tie together. The Flask function <kbd>render_template</kbd> takes the name of a file in the folder <kbd>templates</kbd> and passes all the <kbd>kwargs</kbd> to the template as variables. Also, our <kbd>home</kbd> function now has multiple routes to handle pagination, and will default to the first page if there is nothing after the slash.</p>
<p>Now that you have all the information that you need to write view functions, let's define the first view functions that we need:</p>
<ul>
<li><kbd>GET /post/&lt;POST_ID&gt;</kbd> to render a specific post by its ID. This also renders all recent posts and tags.</li>
<li><kbd>GET /posts_by_tag/&lt;TAG_NAME&gt;</kbd> to render all posts by a specific tag name. This also renders all recent posts and tags.</li>
<li><kbd>GET /posts_by_user/&lt;USER_NAME&gt;</kbd> to render all posts authored by a specific user. This also renders all recent posts and tags.</li>
</ul>
<p>This translates to the following view functions:</p>
<pre>@app.route('/post/&lt;int:post_id&gt;') 
def post(post_id)<br/>....
@app.route('/posts_by_tag/&lt;string:tag_name&gt;') 
def posts_by_tag(tag_name): <br/>...
@app.route('/posts_by_user/&lt;string:username&gt;') 
def posts_by_user(username): <br/>...</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>In Flask SQLAlchemy, there are two convenience functions that return HTTP <kbd>404</kbd> in the case of a nonexistent entry in the database, <kbd>get_or_404</kbd> and <kbd>first_or_404</kbd>, so on our get post by ID, as shown in the following code:</p>
<pre>@app.route('/post/&lt;int:post_id&gt;') 
def post(post_id)<br/>    post = Post.query.get_or_404(post_id)</pre>
<p>All posts made by a user can be returned using the following code:</p>
<pre>@app.route('/posts_by_user/&lt;string:username&gt;') 
def posts_by_user(username): 
  user = User.query.filter_by(username=username).first_or_404() 
  posts = user.posts.order_by(Post.publish_date.desc()).all() 
  recent, top_tags = sidebar_data() 
 
  return render_template( 
    'user.html', 
    user=user, 
    posts=posts, 
    recent=recent, 
    top_tags=top_tags 
  ) </pre>
<p>However, this doesn't check the <kbd>posts_by_tag</kbd> function in the <kbd>main.py</kbd> file (see the provided code for this chapter). After all of your views are written, the only thing left to do is to write the templates.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Writing the templates and inheritance</h1>
                
            
            
                
<p>Because this book does not focus on interface design, we will use the CSS library <strong>Bootstrap</strong> and avoid writing custom CSS. If you have never used it before, Bootstrap is a set of default CSS rules that make your website work well across all browsers and platforms, from desktop to mobile. Bootstrap has tools that allow you to easily control the layout of your website.</p>
<p>We will be downloading Bootstrap, JQuery, and Font Awesome directly from their CDN upon page load, but any extra assets you may need should be included in a project directory named <kbd>static</kbd>. It's common practice to use <kbd>static/css</kbd> for CSS, <kbd>static/js</kbd> for JavaScript, <kbd>static/img</kbd> for images, and <kbd>static/fonts</kbd> for fonts. One of the best ways to use Bootstrap is to download its <kbd>sass</kbd> files and use <kbd>sass </kbd>to customize it.</p>
<p class="mce-root"/>
<p>For the official documentation about SASS and Bootstrap, visit <a href="https://getbootstrap.com/docs/4.0/getting-started/theming/">https://getbootstrap.com/docs/4.0/getting-started/theming/</a>.<a href="https://getbootstrap.com/docs/4.0/getting-started/theming/"/></p>
<p>Because every route will have a template assigned to it, each template will need the requisite HTML boilerplate code with our metainformation, style sheets, common JavaScript libraries, and so on. To keep our templates <strong>DRY</strong> (<strong>don't repeat yourself</strong>), we will use one of the most powerful features of Jinja, <strong>template inheritance</strong>. Template inheritance is when a child template can import a base template as a starting point and only replace marked sections in the base. You can also include full sections of Jinja templates from other files; this will allow you to set some rigid default sections. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">The base template</h1>
                
            
            
                
<p>We need to outline the base layout for our site, split it into sections, and give each section a specific purpose. The following diagram is an abstract description of the layout:</p>
<div><img class="aligncenter size-full wp-image-537 image-border" src="img/f31d75a6-e6b6-45aa-9297-14f2b0675f52.png" style="width:52.42em;height:32.75em;"/></div>
<p class="mce-root"/>
<p>Some of these sections will always get rendered, and you don't want to repeat them on each template. Some possible options for these sections are the navigation bar, header, messages, and footer.</p>
<p>We will use the following include and block structure to maintain our DRY principal and implement the layout:</p>
<ul>
<li><strong>Include navbar</strong>: Jinja2 template: <kbd>navbar.html</kbd>—Renders a navigation bar.</li>
<li><strong>Block head</strong>: The header with the name of the site. Already includes the <kbd>head.html </kbd>Jinja2 template.</li>
<li><strong>Include messages</strong>: Jinja2 template: <kbd>messages.html</kbd>—Renders alerts for the users with different categories.</li>
<li><strong>Block body:</strong>
<ul>
<li><strong>Block left body</strong>: Normally, templates will override this block.</li>
<li><strong>Block right body</strong>: This will display the most recent posts and tags.</li>
</ul>
</li>
<li><strong>Block footer</strong>: Jinja2 template: <kbd>footer.html</kbd>.</li>
</ul>
<p>Note how the fixed sections, the ones that will almost always get rendered, already include templates even when inside blocks. The base template will handle these by default. If for some reason you want to override these, you just have to implement/inherit their block on the rendered template. For example, say that you want to render a whole body section on a certain page, taking the space of the right body section that displays the most recent posts and tags. A good candidate for this will be the login page.</p>
<p>To start our base template, we need a basic HTML skeleton and the Jinja2 block structure that we previously outlined (see the highlighted code in the following snippet):</p>
<pre><br/>&lt;!DOCTYPE html&gt;<br/>&lt;html&gt;<br/>&lt;head&gt;<br/>    &lt;meta charset="utf-8"&gt;<br/>    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;<br/>    &lt;meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"&gt;<br/>    &lt;title&gt;{% block title %}Blog{% endblock %}&lt;/title&gt;<br/>    &lt;link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.0/css/bootstrap.min.css" integrity="sha384-9gVQ4dYFwwWSjIDZnLEWnxCjeSWFphJiwGPXr1jddIhOegiu1FwO5qRGvFXOdJZ4" crossorigin="anonymous"&gt;<br/>    &lt;link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.10/css/all.css" integrity="sha384-+d0P83n9kaQMCwj8F4RJB66tzIwOKmrdb46+porD/OvrJ+37WqIM7UoBtwHO6Nlg" crossorigin="anonymous"&gt;<br/>&lt;/head&gt;<br/>&lt;body&gt;<br/><strong>{% include 'navbar.html' %}</strong><br/>&lt;div class="container"&gt;<br/>    &lt;div class="row row-lg-4"&gt;<br/>        &lt;div class="col"&gt;<br/>            <strong>{% block head %}</strong><br/><strong>            {% include 'head.html' %}</strong><br/><strong>            {% endblock %}</strong><br/>        &lt;/div&gt;<br/>    &lt;/div&gt;<br/>    <strong>{% include 'messages.html' %}</strong><br/><strong>    {% block body %}</strong><br/>    &lt;div class="row"&gt;<br/>        &lt;div class="col-lg-9"&gt;<br/>            <strong>{% block leftbody %}</strong><br/><strong>            {% endblock %}</strong><br/>        &lt;/div&gt;<br/>        &lt;div class="col-lg-3 rounded"&gt;<br/>            <strong>{% block rightbody %}</strong><br/><strong>            {% include 'rightbody.html' %}</strong><br/><strong>            {% endblock %}</strong><br/>        &lt;/div&gt;<br/>    &lt;/div&gt;<br/>    <strong>{% endblock %}</strong><br/><strong>    {% include 'footer.html' %}</strong><br/>&lt;/div&gt;<br/>&lt;/body&gt;<br/>&lt;script src="img/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"&gt;&lt;/script&gt;<br/>&lt;script src="img/popper.min.js" integrity="sha384-cs/chFZiN24E4KMATLdqdvsezGxaGsi4hLGOzlXwp5UZB1LY//20VyM2taTB4QvJ" crossorigin="anonymous"&gt;&lt;/script&gt;<br/>&lt;script src="img/bootstrap.min.js" integrity="sha384-uefMccjFJAIv6A+rW+L4AHf99KvxDjWSu1z9VI8SKNVmz4sk7buKt/6v9KI65qnm" crossorigin="anonymous"&gt;&lt;/script&gt;    &lt;/body&gt;<br/>&lt;/html&gt;<br/></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>This is the <kbd>base.html</kbd> template in the provided code in your <kbd>templates</kbd> directory. First, we include the Bootstrap and Font Awesome CSS, then implement the HTML body section, and finally include all the necessary JavaScript libraries.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The child templates</h1>
                
            
            
                
<p>Now that we have outlined the base layout, we need to implement all the child pages that will extend the base. Take a look at the way we are implementing the home page and inherit/override the left body block, as shown in the following code:</p>
<pre>{% extends "base.html" %}<br/>{% import 'macros.html' as macros %}<br/>{% block title %}Home{% endblock %}<br/><strong>{% block leftbody %}</strong><br/>{{ macros.render_posts(posts) }}<br/>{{ macros.render_pagination(posts, 'home') }}<br/><strong>{% endblock %}</strong></pre>
<p>Surprisingly simple, this template extends the base template has expected, and then overrides the <kbd>title</kbd> and <kbd>leftbody</kbd> block sections. Inside, the <kbd>leftbody</kbd> uses two macros to render the posts and their pagination. The macros help us to reuse Jinja2 code and use it like functions, and also to hide some complexity.</p>
<p>The <kbd>render_posts</kbd> macro is in the <kbd>macros.html</kbd> that was imported at the top of the file. We use macros more or less like modules in Python, as shown in the following code:</p>
<pre>{% macro render_posts(posts, pagination=True) %}<br/>...<br/><strong>{% for post in _posts %}</strong><br/>&lt;div &gt;<br/>    &lt;h1&gt;<br/>        &lt;a class="text-dark" href="<strong>{{ url_for('post', post_id=post.id) }}</strong>"&gt;{{ post.title }}&lt;/a&gt;<br/>    &lt;/h1&gt;<br/>&lt;/div&gt;<br/>&lt;div class="row"&gt;<br/>    &lt;div class="col"&gt;<br/>        <strong>{{ post.text | truncate(500) | safe }}</strong><br/>        &lt;a href="<strong>{{ url_for('post', post_id=post.id) }}</strong>"&gt;Read More&lt;/a&gt;<br/>    &lt;/div&gt;<br/>&lt;/div&gt;<br/><strong>{% endfor %}</strong><br/>{% endmacro %}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>The macro iterates on each post, and on each <kbd>post.title</kbd>, there is a link to the Flask endpoint <kbd>post</kbd> with its respective post ID. As explained, we always use <kbd>url_for</kbd> to generate the right URL that references Flask's endpoints. </p>
<p>We are using this macro three times on the templates: to render all posts, all posts by a certain tag, and all posts by a certain user.</p>
<p>The <kbd>tag.html</kbd> template renders all posts by a certain tag, as shown in the following code:</p>
<pre>{% extends "base.html" %}<br/>{% import 'macros.html' as macros %}<br/><br/>{% block title %}{{ tag.title }}{% endblock %}<br/><strong>{% block leftbody %}</strong><br/>&lt;div class="row"&gt;<br/>    &lt;div class="col bg-light"&gt;<br/>        &lt;h1 class="text-center"&gt;Posts With Tag {{ tag.title }}&lt;/h1&gt;<br/>    &lt;/div&gt;<br/>&lt;/div&gt;<br/><strong>{{ macros.render_posts(posts, pagination=False) }}</strong><br/><br/><strong>{% endblock %}</strong></pre>
<p>If you look at the <kbd>user.html</kbd> template in the preceding code, you'll see that they are almost identical. These templates are called by the Flask endpoint functions <kbd>posts_by_tag</kbd> and <kbd>posts_by_user</kbd>. When rendering the templates, they pass arguments for the <kbd>tag</kbd>/<kbd>user</kbd> object and a list of posts, as we saw before.</p>
<p>Let's check out how the blog site looks now. In the command line, call <kbd>init.sh</kbd> to build a Python virtualenv, and then migrate/create our database and insert some fake data, as follows:</p>
<pre><strong>$ ./init.sh<br/>....<br/></strong><strong>$ source venv/bin/activate<br/></strong><strong>$ export FLASK_APP=main.py; flask run</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>Open <kbd>http://127.0.0.1:5000/</kbd> in your browser. You should see the following:</p>
<div><img class="aligncenter size-full wp-image-538 image-border" src="img/ce1ce568-d1bd-431c-849b-3fef57b9d1b6.png" style="width:162.50em;height:85.92em;"/></div>
<p class="mce-root">The <kbd>init.sh</kbd> phrase calls the <kbd>test_data.py</kbd>, which inserts fake data into the database. This Python module uses the <kbd>faker</kbd> library to generate data for user names and post text and tags (using color names).</p>
<p>For more details regarding <kbd>faker</kbd>, you can go to <a href="http://faker.readthedocs.io/en/master/">http://faker.readthedocs.io/en/master/</a>.<a href="http://faker.readthedocs.io/en/master/"/></p>
<p>The following code is an example taken from <kbd>test_data.py</kbd> that inserts users into the database and returns a list of user objects that is reused to insert posts:</p>
<pre>import logging<br/>from main import db<br/>from main import User, Post, Tag<br/>from faker import Faker<br/>...<br/><br/>def generate_users(n):<br/>    users = list()<br/>    for i in range(n):<br/>        user = User()<br/>        user.username = faker.name()<br/>        user.password = "password"<br/>        try:<br/>            db.session.add(user)<br/>            db.session.commit()<br/>            users.append(user)<br/>        except Exception as e:<br/>            log.error("Fail to add user %s: %s" % (str(user), e))<br/>            db.session.rollback()<br/>    return users</pre>
<p>The <kbd>template</kbd> folder contains the following templates that are rendered using the aforementioned hierarchy:</p>
<ul>
<li><kbd>base.html</kbd>: Extended by all the other templates</li>
<li><kbd>footer.html</kbd>: Included by <kbd>base.html</kbd></li>
<li><kbd>head.html</kbd>: Included by <kbd>base.html</kbd></li>
<li><kbd>messages.html</kbd>: Included by <kbd>base.html</kbd></li>
<li><kbd>navbar.html</kbd>: Included by <kbd>base.html</kbd></li>
<li><kbd>rightbody.html</kbd>: Included by <kbd>base.html</kbd></li>
<li><kbd>home.html</kbd>: Rendered by the <kbd>home</kbd> Flask endpoint function</li>
<li><kbd>post.html</kbd>: Rendered by the <kbd>post</kbd> Flask endpoint function</li>
<li><kbd>tag.html</kbd>: Rendered by the <kbd>posts_by_tag</kbd> endpoint function</li>
<li><kbd>user.html</kbd>: Rendered by the <kbd>posts_by_user</kbd> endpoint function</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Writing the other templates</h1>
                
            
            
                
<p>Now that you know the ins and outs of inheritance, and you know which data is going to go to which template, you can have a clear idea of how to structure your web application to easily scale and maintain the same look and feel on every page. There is one final bit of functionality to add in this chapter—the ability for readers to add comments. For this, we will be using web forms.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Flask WTForms</h1>
                
            
            
                
<p>Adding forms to your application seems to be an easy task, but when you start coding the server-side code, the task of validating user input grows bigger and bigger as the form becomes more complex. Security is paramount, as the data is from an untrustworthy source, and is going to be entered into the database. <strong>WTForms</strong> is a library that handles server form validation for you by checking input against common form types. Flask WTForms is a Flask extension that is built on top of WTForms that adds features, such as Jinja HTML rendering, and protects you against attacks, such as SQL injection and cross-site request forgery. This extension is already installed in your virtualenv, because it's declared in the <kbd>requirements.txt</kbd> file.</p>
<p>Protecting yourself against SQL injection and cross-site request forgery is extremely important, as these are the most common forms of attacks that your website will receive. To learn more about these attacks, visit <a href="https://en.wikipedia.org/wiki/SQL_injection" target="_blank">https://en.wikipedia.org/wiki/SQL_injection</a> and <a href="https://en.wikipedia.org/wiki/Cross-site_request_forgery" target="_blank">https://en.wikipedia.org/wiki/Cross-site_request_forgery</a> for information on SQL injection and cross-site request forgery, respectively.</p>
<p>To have Flask WTForms' security measures working properly, we will need a <strong>secret key</strong>. A secret key is a random string of characters that will be used to cryptographically sign anything that needs to be tested for its authenticity. This cannot be just any string; it must be randomized and be of a certain length so that brute-force or dictionary attacks won't be able to crack it in any viable amount of time. To generate a random string, enter a Python session and enter the following:</p>
<pre><strong>$ python<br/>&gt;&gt;&gt; import os<br/>&gt;&gt;&gt; os.urandom(24)        '\xa8\xcc\xeaP+\xb3\xe8|\xad\xdb\xea\xd0\xd4\xe8\xac\xee\xfaW\x072@O3'</strong></pre>
<p>You should generate a different secret key for each environment. Just copy the output from <kbd>os.urandom</kbd> and paste it into each environment <kbd>config</kbd> class, as follows:</p>
<pre>class ProdConfig(object): 
  SECRET_KEY = 'Your secret key here'<br/>....
class DevConfig(object): 
  SECRET_KEY = 'The other secret key here'<br/>....</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>


            

            
        
    

        

                            
                    <h1 class="header-title">WTForms basics</h1>
                
            
            
                
<p>There are three main parts of WTForms—<strong>forms</strong>, <strong>fields</strong>, and <strong>validators</strong>. Fields are representations of input fields and perform rudimentary type checking, and validators are functions that are attached to fields that make sure that the data submitted in the form is within our constraints. The form is a class that contains fields and validators, and validates itself on a <kbd>POST</kbd> request. Let's see this in action to get a better idea. In the <kbd>main.py</kbd> file, add the following:</p>
<pre>from flask_wtf import FlaskForm as Form 
from wtforms import StringField, TextAreaField 
from wtforms.validators import DataRequired, Length 
... 
class CommentForm(Form): 
  name = StringField( 
    'Name', 
    validators=[DataRequired(), Length(max=255)] 
  ) 
  text = TextAreaField(u'Comment', validators=[DataRequired()]) </pre>
<p>Here, we have a class that inherits from Flask WTForm's <kbd>Form</kbd> object and defines inputs with class variables that equal WTForm fields. The fields take an optional parameter, <kbd>validators</kbd>, which is a list of WTForm validators that will be applied to our data. The most commonly used fields are as follows:</p>
<ul>
<li><kbd>fields.DateField</kbd> and <kbd>fields.DateTimeField</kbd>: Represents a Python <kbd>date</kbd> or <kbd>datetime</kbd> object and takes an optional parameter format that takes a <kbd>stftime</kbd> format string to translate the data.</li>
<li><kbd>fields.IntegerField</kbd>: This attempts to coerce passed data to an integer and is rendered in the template as a number input.</li>
<li><kbd>fields.FloatField</kbd>: This attempts to coerce passed data to a float and is rendered in the template as a number input.</li>
<li><kbd>fields.RadioField</kbd>: This represents a set of radio inputs and takes a <kbd>choices </kbd>parameter , which is a list of tuples that act as the displayed value and the returned value.</li>
<li><kbd>fields.SelectField</kbd>: Along with <kbd>SelectMultipleField</kbd>, this represents a set of radio inputs. It takes a <kbd>choices </kbd>parameter, which is a list of tuples that act as the displayed and returned values.</li>
<li><kbd>fields.StringField</kbd>: This represents a normal text input, and will attempt to coerce the returned data to a string.</li>
</ul>
<p>For a full list of validators and fields, visit the WTForms documentation at <a href="http://wtforms.readthedocs.org">http://wtforms.readthedocs.org</a>.</p>
<p>The most common validators are as follows:</p>
<ul>
<li><kbd>validators.DataRequired()</kbd></li>
<li><kbd>validators.Email()</kbd></li>
<li><kbd>validators.Length(min=-1, max=-1)</kbd></li>
<li><kbd>validators.NumberRange(min=None, max=None)</kbd></li>
<li><kbd>validators.Optional()</kbd></li>
<li><kbd>validators.Regexp(regex)</kbd></li>
<li><kbd>validators.URL()</kbd></li>
</ul>
<p>Each of these validations follows the Pythonic naming scheme. Therefore, it is rather straightforward as to what they do. All validators take an optional parameter called <kbd>message</kbd>, which is the error message that will be returned if the validator fails. If a message is not set, it uses the library defaults.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Custom validations</h1>
                
            
            
                
<p>Writing a custom validation function is very simple. All that is required is to write a function that takes the <kbd>form</kbd> object and the <kbd>field</kbd> object as parameters and raises a WTForm. A <kbd>ValidationError</kbd> is raised if the data does not pass the test. Here is an example of a custom email validator:</p>
<pre>import re 
import wtforms 
def custom_email(form, field): 
  if not re.match(r"[^@]+@[^@]+.[^@]+", field.data): 
    raise wtforms.ValidationError('Field must be a valid email <br/>       address.')</pre>
<p>To use this function, just add it to the list of validators for your field.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Posting comments</h1>
                
            
            
                
<p>Now that we have our comment form and we understand how to build it, we need to add it to the start of our post view, as follows:</p>
<pre>@app.route('/post/&lt;int:post_id&gt;', methods=('GET', 'POST'))<br/>def post(post_id):<br/>    form = CommentForm()<br/>    if form.validate_on_submit():<br/>        new_comment = Comment()<br/>        new_comment.name = form.name.data<br/>        new_comment.text = form.text.data<br/>        new_comment.post_id = post_id<br/>        try:<br/>            db.session.add(new_comment)<br/>            db.session.commit()<br/>        except Exception as e:<br/>            flash('Error adding your comment: %s' % str(e), 'error')<br/>            db.session.rollback()<br/>        else:<br/>            flash('Comment added', 'info')<br/>        return redirect(url_for('post', post_id=post_id))<br/><br/>    post = Post.query.get_or_404(post_id)<br/>    tags = post.tags<br/>    comments = post.comments.order_by(Comment.date.desc()).all()<br/>    recent, top_tags = sidebar_data()<br/><br/>    return render_template(<br/>        'post.html',<br/>        post=post,<br/>        tags=tags,<br/>        comments=comments,<br/>        recent=recent,<br/>        top_tags=top_tags,<br/>        form=form<br/>    )</pre>
<p>First, we add the <kbd>POST</kbd> method to the list of our view's allowed methods. Then, a new instance of our form object is created. The <kbd>validate_on_submit()</kbd> method then checks whether the Flask request is a <kbd>POST</kbd> request. If it is a <kbd>POST</kbd> request, it sends the request form data to the form object. If the data is validated, then <kbd>validate_on_submit()</kbd> returns <kbd>True</kbd> and adds the data to the <kbd>form</kbd> object. We then take the data from each field, populate a new comment, and add it to the database. Note how we don't need to fill in the comment data, because we have set a default value for it in the SQLAlchemy model definition—in this case, the <kbd>datatime.now</kbd> function that is going to be evaluated upon the object creation.</p>
<p>It is also important to ensure that we wrap all our database calls with a <kbd>try</kbd>/<kbd>except</kbd> block, and in the case of an error, roll back the session transaction and send proper feedback to the users.</p>
<p>Note the final <kbd>redirect</kbd> Flask call to the same endpoint, this time with an <kbd>HTTP GET</kbd>. This means that after a user inserts a new comment, the same page is rendered again with a clean form and shows the newly added comment. </p>
<p>If the form does not validate, or if we are handling an <kbd>HTTP GET</kbd>, we fetch the <kbd>Post</kbd> object from the database by <kbd>post_id</kbd>, collect all the related comments, and finally get all the necessary side-bar data.</p>
<p>The template itself is divided into three main sections. The first renders the post, the second displays the form where the user can submit a new comment about the post, and the third is where we render all the comments related to the post. Let's focus on the third section, as shown in the following code:</p>
<pre>&lt;div class="p-4 shadow-sm"&gt;<br/>    &lt;div class="row"&gt;<br/>        &lt;div class="col"&gt;<br/>            &lt;h4&gt;New Comment:&lt;/h4&gt;<br/>        &lt;/div&gt;<br/>    &lt;/div&gt;<br/>    &lt;div class="row"&gt;<br/>        &lt;div class="col"&gt;<br/><strong>            &lt;form method="POST" action="{{ url_for('post', <br/>            post_id=post.id) }}"</strong><strong>&gt;</strong><br/>                <strong>{{ form.hidden_tag() }}</strong><br/>                &lt;div class="form-group"&gt;<br/>                    <strong>{{ form.name.label }}</strong><br/>                    <strong>{% if form.name.errors %}</strong><br/><strong>                        {% for e in form.name.errors %}</strong><br/>                            &lt;p class="help-block"&gt;{{ e }}&lt;/p&gt;<br/>                        <strong>{% endfor %}</strong><br/><strong>                    {% endif %}</strong><br/><strong>                    {{ form.name(class_='form-control') }}</strong><br/>                &lt;/div&gt;<br/>                &lt;div class="form-group"&gt;<br/>                    <strong>{{ form.text.label }}</strong><br/><strong>                    {% if form.text.errors %}</strong><br/>                        <strong>{% for e in form.text.errors %}</strong><br/>                            &lt;p class="help-block"&gt;{{ e }}&lt;/p&gt;<br/>                        <strong>{% endfor %}</strong><br/><strong>                    {% endif %}</strong><br/><strong>                    {{ form.text(class_='form-control') }}</strong><br/>                &lt;/div&gt;<br/>                &lt;input class="btn btn-primary" type="submit" value="Add <br/>              Comment"&gt;<br/>            &lt;/form&gt;<br/>        &lt;/div&gt;<br/>    &lt;/div&gt;<br/>&lt;/div&gt;</pre>
<p>There are several new things happening here. First, we declare an HTML form section and make it submit (using <kbd>HTTP POST</kbd>) to our <kbd>post</kbd> Flask endpoint function with the current post ID.</p>
<p>Next, the <kbd>form.hidden_tag()</kbd> method adds an anticross-site request forgery measure automatically.</p>
<p>Then, when calling <kbd>field.label</kbd>, an HTML label will automatically be created for our input. This can be customized when we define our <kbd>WTForm FlaskForm</kbd> class; if not, WTForm will pretty print the field name.</p>
<p>Next, we check for any errors using <kbd>field.errors</kbd>, and if there are any, we will iterate all of them and render the form validation message to the user. Finally, calling the field itself as a method will render the HTML code of that field. </p>
<p>This third section of the template will display the following:</p>
<div><img class="aligncenter size-full wp-image-539 image-border" src="img/f0cdd727-2108-49f3-94e6-1f08c71f1c6f.png" style="width:29.92em;height:32.50em;"/></div>
<p>One challenge for the reader is to make a macro that takes a <kbd>form</kbd> object and an endpoint to send the <kbd>POST</kbd> request to and autogenerates HTML for the entire form tag. Refer to the WTForms documentation if you get stuck. It's tricky, but not too difficult.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>Now, after only two chapters, you already have a fully functional blog. This is where a lot of books on web development technologies would end. However, there are still 10 more chapters to go to turn your utilitarian blog into something that a user would actually use for their website.</p>
<p>In the next chapter, we will focus on structuring Flask apps to accommodate long-term development and larger scale projects.</p>


            

            
        
    </body></html>