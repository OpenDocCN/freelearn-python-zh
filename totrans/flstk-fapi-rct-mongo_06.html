<html><head></head><body>
<div id="book-content" class="calibre2">
<div id="sbo-rt-content" class="calibre3"><div id="_idContainer031" class="calibre4">
			<h1 id="_idParaDest-98" class="contributor"><a id="_idTextAnchor105" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/><a id="_idTextAnchor106" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>6</h1>
			<h1 id="_idParaDest-99" class="contributor"><a id="_idTextAnchor107" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Authentication and Authorization</h1>
			<p class="calibre5">The concepts of authentication—proving that the user is who they claim to be—and authorization—making sure that the authenticated user should or should not be able to perform certain operations on your API—are very complex. In this chapter, you will explore the topics of authentication and authorization from a very practical standpoint and from the FARM <span>stack perspective.</span></p>
			<p class="calibre5">The chapter will detail a simple yet robust and extensible setup for your FastAPI backend, based on <strong class="bold">JSON Web Token</strong> (<strong class="bold">JWT</strong>)—arguably the most popular and practical authentication method that has emerged in the last years. Then, you will see how to integrate your JWT-based authentication methods into React, leveraging some of React’s powerful features—namely, Hooks, Context, and <span>React Router.</span></p>
			<p class="calibre5">By the end of this chapter, you should have a solid grasp of authentication methods that both FastAPI on the backend and React on the frontend have to offer, and you will be able to authenticate users and control what they can and cannot do within your application with granularity <span>and precision.</span></p>
			<p class="calibre5">The chapter will cover the <span>following topics:</span></p>
			<ul class="calibre14">
				<li class="calibre17">The user model and how it relates to <span>other resources</span></li>
				<li class="calibre17">JWT authentication mechanism—the <span>big picture</span></li>
				<li class="calibre17">Authentication and authorization tools <span>in FastAPI</span></li>
				<li class="calibre17">How to protect the routes, routers, or the <span>entire app</span></li>
				<li class="calibre17">Various solutions for authenticating <span>with React</span></li>
			</ul>
			<h1 id="_idParaDest-100" class="contributor"><a id="_idTextAnchor108" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Technical requirements</h1>
			<p class="calibre5">To run the sample application in this chapter, you should have <span>the following:</span></p>
			<ul class="calibre14">
				<li class="calibre17">Node.js version 18 <span>or later</span></li>
				<li class="calibre17">Python 3.11.7 <span>or later</span></li>
			</ul>
			<p class="calibre5">The requirements are identical to those in the previous chapters, and the new packages that you will install will be described as they <span>are used.</span></p>
			<h1 id="_idParaDest-101" class="contributor"><a id="_idTextAnchor109" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Understanding JSON Web Token</h1>
			<p class="calibre5">HTTP is a stateless protocol, and that fact alone implies several important consequences. One of them is that if you want to persist some kind of state between requests, you must resort to a mechanism that will be able to remember a set of data, such as who the logged-in user was, what the selected items during a previous browser session were, or what the site preferences were. In order to achieve such functionality, and identify the current user, you as a developer have numerous options at your disposal. Some of the most popular and modern solutions are <span>the following:</span></p>
			<ul class="calibre14">
				<li class="calibre17"><strong class="bold">Credential-based authentication: </strong>It requires the user to enter personal credentials, such as a username or email, along with <span>a password</span></li>
				<li class="calibre17"><strong class="bold">Passwordless login: </strong>Users receive a secure, time-limited token via email or another communication channel for authentication instead of using a traditional password after creating an account. The secure token is used for session authentication, eliminating the need to type or <span>remember passwords.</span></li>
				<li class="calibre17"><strong class="bold">Biometric passwords: </strong>It utilizes a bio-feature of the user, such as a fingerprint, <span>for authentication.</span></li>
				<li class="calibre17"><strong class="bold">Social authentication: </strong>Users leverage their existing social media accounts (e.g., Google, Facebook, or LinkedIn) for authentication. This associates the user’s social media account with their account on <span>the platform.</span></li>
				<li class="calibre17"><strong class="bold">Classic personal credentials method: </strong>Users provide an email and choose a password during registration. Optionally, users can also select <span>a username.</span></li>
			</ul>
			<p class="calibre5">This chapter will consider the classic personal credentials method. When users register, they provide an email and choose a password and, optionally, <span>a username.</span></p>
			<h2 id="_idParaDest-102" class="about-the-author"><a id="_idTextAnchor110" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>What is JWT?</h2>
			<p class="calibre5">While there are different ways of maintaining the identity of a user across different parts of an app, JWT is arguably the most common and popular method of connecting frontend applications (React, Vue.js, and Angular) or mobile apps with an API (in our case, a REST API). JWT is nothing but a standard, a way of structuring a big string composed of seemingly random characters and numbers that encapsulate user data in a <span>secure way.</span></p>
			<p class="calibre5">JWTs contain three parts—the <strong class="bold">header</strong>, the <strong class="bold">payload</strong>, and the <strong class="bold">signature</strong>. The header hosts metadata about the token itself—the algorithm used for signing the token and the type of <span>the token.</span></p>
			<p class="calibre5">The payload is the most interesting part. It contains the following information necessary <span>for authentication:</span></p>
			<ul class="calibre14">
				<li class="calibre17">Data (claims): The ID of the user (or <span>the username)</span></li>
				<li class="calibre17">The <strong class="bold">issued at field</strong> (<strong class="bold">iat</strong>): The date and time of issuing <span>the token</span></li>
				<li class="calibre17">The time at which the token ceases to be valid: Tied to the duration of <span>the token</span></li>
				<li class="calibre17">Optionally, other fields: For example, the username, <span>roles etc.</span></li>
			</ul>
			<p class="calibre5">The payload is decodable and readable by everyone. You can read more about tokens and understand how they look in the JWT <span>documentation: </span><a href="https://jwt.io" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"><span><span lang="en-US" xml:lang="en-US">https://jwt.io</span></span></a><span>.</span></p>
			<p class="calibre5">Finally, the most important part of the token is the signature. The signature guarantees the claims made by the token. The signature is reproduced (calculated) and compared with the original—thus preventing the modification of <span>the claims.</span></p>
			<p class="calibre5">For example, consider a JWT stating that the username is <strong class="source-inline">John</strong>. Now, if someone were to attempt to change this to <strong class="source-inline">Rita</strong>, they would also need to modify the signature to match. However, altering the signature would render the token invalid. This mechanism ensures that the token’s content remains unchanged <span>and authentic.</span></p>
			<p class="calibre5">The token is hence able to completely replace the authentication data—user or email and password combinations that do not need to be transmitted more <span>than once.</span></p>
			<p class="calibre5">In the upcoming sections, you will learn how to implement a JWT-based authentication flow in <span>your app.</span></p>
			<h1 id="_idParaDest-103" class="contributor"><a id="_idTextAnchor111" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>FastAPI backend with users and dependencies</h1>
			<p class="calibre5">Web applications (or mobile apps, for that matter) are not very useful if they are not secure. You must have heard about tiny errors in the authentication implementations that result in hundreds of thousands or even millions of compromised accounts, potentially exposing sensitive and <span>valuable information.</span></p>
			<p class="calibre5">FastAPI is based on OpenAPI—previously known as <strong class="bold">Swagger</strong>—an open specification for crafting APIs. OpenAPI enables you to define various security schemes, compatible with the various protocols (<strong class="source-inline">apiKey</strong>, <strong class="source-inline">http</strong>, <strong class="source-inline">OAuth 2.0</strong>, <strong class="source-inline">openIdConnect</strong>, and so on). While the FastAPI documentation website (<a href="https://fastapi.tiangolo.com/tutorial/security/" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"><span>https://fastapi.tiangolo.com/tutorial/security/</span></a>) provides an excellent and detailed tutorial on creating an authentication flow, it is based on the <strong class="source-inline">OAuth 2.0</strong> protocol, which uses form data to send the credentials (username <span>and password).</span></p>
			<p class="calibre5">In the following sections, you will devise a simple user model that will enable an authentication flow. You will then learn how to encode the user data into a JWT and how to use the token for accessing protected routes. </p>
			<h2 id="_idParaDest-104" class="about-the-author"><a id="_idTextAnchor112" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>User model for authentication</h2>
			<p class="calibre5">The basis of every authentication flow is the user model, which has to be able to store a minimum set of data needed for unequivocally identifying the users. The most common unique fields are an email address, a username, and, of course, a primary key—an <strong class="source-inline">ObjectId</strong> instance in the case <span>of MongoDB.</span></p>
			<p class="calibre5">Modeling data with MongoDB is inherently different from modeling relational databases as discussed in <a href="B22406_02.xhtml#_idTextAnchor026" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"><span><em class="italic">Chapter 2</em></span></a>, <em class="italic">Setting Up the Database with MongoDB</em>. The driving idea is to think of queries upfront and model your relationships taking into account the queries that your app is going to be making <span>most frequently.</span></p>
			<h2 id="_idParaDest-105" class="about-the-author"><a id="_idTextAnchor113" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Authentication and authorization with FastAPI: a walk-through</h2>
			<p class="calibre5">Authentication and authorization with FastAPI are much easier to understand through an example. In the next few sub-sections, you will develop a simple yet fully functional authentication system that will contain all the mandatory steps. To highlight the important parts, while keeping the example as concise as possible, you will not use a real MongoDB connection. Instead, you will make your own JSON file-based <strong class="bold">database</strong> that will store users as they register into the app and effectively mock a MongoDB collection. The first and foremost step is to review your <span>authentication system.</span></p>
			<h3 class="calibre8">Reviewing all the parts of your authentication system</h3>
			<p class="calibre5">The following list provides a quick recapitulation of the tools and packages needed for implementing a FastAPI <span>authentication workflow:</span></p>
			<ul class="calibre14">
				<li class="calibre17">To implement a FastAPI authentication workflow, you must use FastAPI’s security tools. In FastAPI, when you need to declare dependencies with <strong class="bold" lang="en-US" xml:lang="en-US">OAuth2</strong> scopes, you will use the <strong class="source-inline" lang="en-US" xml:lang="en-US">Security()</strong> class. The other FastAPI import that will be needed is the type of dependable—in this case, you will use <strong class="bold">bearer</strong> tokens for authorization. You can refer to the FastAPI <span>documentation: </span><a href="https://fastapi.tiangolo.com/reference/security/#fastapi.security.HTTPBearer" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"><span><span>https://fastapi.tiangolo.com/reference/security/#fastapi.security.HTTPBearer</span></span></a><span>.</span></li>
				<li class="calibre17">You also need password hashing and comparing functionality, which <strong class="source-inline">passlib</strong> can provide. The <strong class="source-inline">passlib.context</strong> module contains one main class: <strong class="source-inline">passlib.context.CryptContext</strong>, designed to take care of many of the more frequent coding tasks associated with hashing and comparing strings through various algorithms. Your authentication system requires two main functionalities: hashing passwords during user registration and comparing hashed passwords during login with those stored in <span>your database.</span></li>
				<li class="calibre17">Finally, <strong class="bold" lang="en-US" xml:lang="en-US">PyJWT</strong> will provide the functionality to encode and <span>decode JWT.</span></li>
			</ul>
			<h3 class="calibre8">Creating the model</h3>
			<p class="calibre5">The next steps involve creating the basic FastAPI application in a new virtual environment, activating the environment, installing the necessary packages, and creating a suitable model of the users with the <span>required fields:</span></p>
			<ol class="calibre14">
				<li class="calibre15">Create a new directory, set it as the working directory with the <strong class="source-inline" lang="en-US" xml:lang="en-US">cd</strong> (change directory) command, create a new Python environment in <strong class="source-inline" lang="en-US" xml:lang="en-US">/venv</strong>, and <span>activate it:</span><pre class="source-code">
<strong class="source-inline">mkdir chapter6</strong>
<strong class="source-inline">cd chapter6</strong>
<strong class="source-inline">python -m venv venv</strong>
<strong class="source-inline">source ./venv/bin/activate</strong></pre></li>				<li class="calibre15">Once the new Python environment is active, install the needed packages for the authentication system and the <span>application overall:</span><pre class="source-code">
pip install fastapi uvicorn bcrypt==4.0.1 passlib pyjwt</pre></li>			</ol>
			<p class="callout-heading">Note</p>
			<p class="callout">If you want to be able to reproduce exactly the code in the book, you are strongly encouraged to use the <strong class="source-inline">/backend/requirements.txt</strong> file from the accompanying repository and install the packages with the <strong class="source-inline">pip install -r </strong><span><strong class="source-inline">requirements.txt </strong></span><span>command.</span></p>
			<p class="calibre5">The following are the last three packages needed for your <span>authentication system:</span></p>
			<ul class="calibre14">
				<li class="calibre17"><strong class="source-inline" lang="en-US" xml:lang="en-US">Passlib</strong> is a password hashing library for Python, and it supports a wide range of hashing algorithms, including <strong class="source-inline">bcrypt</strong>. It is very useful as it provides a unified interface for hashing and <span>verifying passwords.</span></li>
				<li class="calibre17">The <strong class="source-inline" lang="en-US" xml:lang="en-US">bcrypt</strong> package is a Python module that provides the password hashing method based on the Blowfish password hashing algorithm that you will be using. Please stick to the provided version of the package as there are some unresolved issues with <span>later versions.</span></li>
				<li class="calibre17"><strong class="source-inline" lang="en-US" xml:lang="en-US">PyJWT</strong> is the Python library for encoding and <span>decoding JWT.</span></li>
			</ul>
			<ol class="calibre14">
				<li value="3" class="calibre15">Next, create the models for the application. As this app will only deal with users, the <strong class="source-inline" lang="en-US" xml:lang="en-US">models.py</strong> file is <span>rather simple:</span><pre class="source-code">
from pydantic import BaseModel, Field
from typing import List
class UserBase(BaseModel):
    id: str = Field(...)
    username: str = Field(
        ..., 
        min_length=3, 
        max_length=15)
    password: str = Field(...)
class UserIn(BaseModel):
    username: str = Field(
        ..., 
        min_length=3,
        max_length=15)
    password: str = Field(...)
class UserOut(BaseModel):
    id: str = Field(...)
    username: str = Field(
        ..., 
        min_length=3, 
        max_length=15)
class UsersList(BaseModel):
    users: List[UserOut]</pre></li>			</ol>
			<p class="calibre5">The models are self-explanatory, and they are left to be as explicit as possible. <strong class="source-inline">UserBase</strong> corresponds to the user representation that will be stored in your dummy database, or in a MongoDB collection (pay special attention to <strong class="source-inline">Object_id</strong>). In the given solution, the <strong class="source-inline">id</strong> field will be a UUID, so you set it to a <span>string type.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">A Python <strong class="bold">UUID</strong> (which stands for <strong class="bold">universally unique identifier</strong>) is a 128-bit string that uniquely identifies an object, entity, or resource in both space and time. In our case, it will mimic MongoDB’s <strong class="source-inline">ObjectId()</strong> class for the purpose of <span>this demonstration.</span></p>
			<p class="calibre5">The <strong class="source-inline">models.py</strong> file contains two additional auxiliary Pydantic models: <strong class="source-inline">UserIn</strong>, which accepts the user data for registration or login (typically username and password, but can easily be extended to include email or other data), and <strong class="source-inline">UserOut</strong>, which is responsible for representing users within the application, excluding the hashed password but including the ID and <span>the username.</span></p>
			<p class="calibre5"><strong class="source-inline">UsersList</strong> finally just outputs the list of all users, and you will use this model as an example for your protected route. Now, build your <strong class="source-inline">app.py</strong> file and create the actual application. </p>
			<h3 class="calibre8">Creating the application file</h3>
			<p class="calibre5">After defining the models, you can now proceed and create the main FastAPI application and the <span>authentication class:</span></p>
			<ol class="calibre14">
				<li class="calibre15">Open a new Python file and name it <strong class="source-inline" lang="en-US" xml:lang="en-US">app.py</strong>. Inside this file, create a minimal <span>FastAPI application:</span><pre class="source-code">
from fastapi import FastAPI
app = FastAPI()</pre><p class="list-inset">We will return to this file shortly, but for now, let’s keep it as short as possible. Now it is time to build out the heart of your <span>authentication system.</span></p></li>				<li class="calibre15">In the same folder, create the <strong class="source-inline">authentication.py</strong> file and start building it. Having all this at hand, open the newly created <strong class="source-inline">authentication.py</strong> file and begin crafting the authentication class. For this, you must first scaffold the <strong class="source-inline" lang="en-US" xml:lang="en-US">AuthHandler</strong> class and add the <span>required imports:</span><pre class="source-code">
import datetime
import jwt
from fastapi import HTTPException, Security
from fastapi.security import HTTPAuthorizationCredentials, HTTPBearer
from passlib.context import CryptContext
class AuthHandler:
    security = HTTPBearer()
    pwd_context = CryptContext(schemes=[“bcrypt”], deprecated=”auto”)
    secret = “FARMSTACKsecretString”</pre></li>			</ol>
			<p class="calibre5">Now that you have learned about all these imports, you can craft a class named <strong class="source-inline">AuthHandler</strong>, that uses FastAPI’s <strong class="source-inline">HTTPBearer</strong> as the security dependency and defines a password-processing context <span>from </span><span><strong class="source-inline">passlib</strong></span><span>.</span></p>
			<h3 class="calibre8">Adding security dependency and password-processing context</h3>
			<p class="calibre5">This procedure consists of multiple steps. You’ll need to add a secret string that would ideally be generated randomly and kept safe in an environment variable, far from any <strong class="source-inline">git commit</strong>. The secret string is necessary for hashing the passwords. Here, you will hardcode it in this file <span>for simplicity.</span></p>
			<p class="calibre5">So, continue with the same file and code the desired functionality step by step, <span>as follows:</span></p>
			<ol class="calibre14">
				<li class="calibre15"><strong class="bold">Hashing </strong><span><strong class="bold">the passwords</strong></span><p class="list-inset">First, you will need a function for generating the hashed password. Add the following code into your <strong class="source-inline">authentication.py</strong> file under the <span><strong class="source-inline">AuthHandler</strong></span><span> class:</span></p><pre class="source-code">
def get_password_hash(self, password: str) -&gt; str:
        return self.pwd_context.hash(password)</pre><p class="list-inset">This function simply creates a hash of the given password, and this result is what you will be storing in your database. It is making good use of your previously defined <span><strong class="source-inline" lang="en-US" xml:lang="en-US">passlib</strong></span><span> context.</span></p></li>				<li class="calibre15"><strong class="bold">Verifying the </strong><span><strong class="bold">hashed passwords</strong></span><p class="list-inset">In the next step, you need a way of verifying that the hash of the provided plain password matches the stored hashed version. Add the following code into your <span><strong class="source-inline">authentication.py</strong></span><span> file:</span></p><pre class="source-code">
    def verify_password(
        self,
        plain_password: str, 
        hashed_password: str) -&gt; bool:
        return self.pwd_context.verify(
           plain_password, 
            hashed_password)</pre><p class="list-inset">Similar to the previous function, <strong class="source-inline" lang="en-US" xml:lang="en-US">verify_password</strong> simply verifies that the hash of <strong class="source-inline" lang="en-US" xml:lang="en-US">plain_password</strong> is indeed equal to the (already) hashed password and it returns <strong class="source-inline" lang="en-US" xml:lang="en-US">True</strong> <span>or </span><span><strong class="source-inline" lang="en-US" xml:lang="en-US">False</strong></span><span>.</span></p></li>				<li class="calibre15"><span><strong class="bold">Token encoding</strong></span><p class="list-inset">Now you can take care of the token encoding. Add the following code at the end of your <span><strong class="source-inline">authentication.py</strong></span><span> file:</span></p><pre class="source-code">
def encode_token(self, user_id: int, username: str) -&gt; str:
payload = {
            “exp”: datetime.datetime.now(datetime.timezone.utc)
            + datetime.timedelta(minutes=30),
            “iat”: datetime.datetime.now(datetime.timezone.utc),
            “sub”: {“user_id”: user_id, “username”: username},
        }
        return jwt.encode(payload, self.secret, algorithm=”HS256”)</pre><p class="list-inset">The <strong class="source-inline" lang="en-US" xml:lang="en-US">encode_token</strong> method of your class leverages the <strong class="source-inline" lang="en-US" xml:lang="en-US">PyJWT</strong> package’s <strong class="source-inline" lang="en-US" xml:lang="en-US">encode</strong> method to create the JWT itself, and it is very explicit; the payload contains the expiration time (very important—you do not want the JWTs to last for too long) and the <em class="italic" lang="en-US" xml:lang="en-US">issued-at time</em> (the <strong class="source-inline" lang="en-US" xml:lang="en-US">iat</strong> part). Also, it references the dictionary named <strong class="source-inline" lang="en-US" xml:lang="en-US">sub</strong>, which contains all the data that you wish to encode—in this case, the user ID and the username, although you could also add a role (regular user, administrator, and so on) or other data. To recap, the JWT encodes three pieces <span>of data:</span></p><ul class="calibre19"><li class="calibre15">The expiration duration, in this example, <span>30 minutes.</span></li><li class="calibre15">The time of issuing the token, in this example, it is set <span>to </span><span><strong class="source-inline" lang="en-US" xml:lang="en-US">now()</strong></span><span lang="en-US" xml:lang="en-US">.</span></li><li class="calibre15">The <strong class="source-inline">sub</strong> part is the data (in the form of a dictionary) that you want to include in the token. In this example, it is the user ID and <span>the username.</span></li></ul></li>				<li class="calibre15"><strong class="bold">Decoding </strong><span><strong class="bold">the token</strong></span><p class="list-inset">Continue building out the class, as now the reverse functionality is required—a way of decoding <span>the token:</span></p><pre class="source-code">
def decode_token(self, token: str):
    try:
        payload = jwt.decode(
            token, 
            self.secret,
            algorithms=[“HS256”])
        return payload[“sub”]
    except jwt.ExpiredSignatureError:
        raise HTTPException(
            status_code=401, 
            detail=”Signature has expired”)
    except jwt.InvalidTokenError:
        raise HTTPException(
            status_code=401, 
            detail=”Invalid token”)</pre><p class="list-inset">The previous snippet is also pretty straightforward. Here, you try to decode the JWT and in case of expiry or an invalid token, you raise a nice exception with the status code and a <span>descriptive message.</span></p></li>				<li class="calibre15"><strong class="bold">Defining </strong><span><strong class="bold">the dependency</strong></span><p class="list-inset">Finalize your class with the dependency to be injected in the routes that will <span>need protection:</span></p><pre class="source-code">
def auth_wrapper(
    self, 
    auth: HTTPAuthorizationCredentials = Security(security)) -&gt; dict:
    return self.decode_token(auth.credentials)</pre></li>			</ol>
			<p class="calibre5">You will use this <strong class="source-inline">auth_wrapper</strong> as the dependency—it will check for the presence of a valid JWT passed as a bearer token in the request headers for all the routes or entire routers that <span>need authorization.</span></p>
			<p class="calibre5">The <strong class="source-inline">authorization.py</strong> file is a minimal implementation of an <span>authentication/authorization flow.</span></p>
			<p class="calibre5">In the previous steps you wrapped most of the authentication and authorization functionality into a simple and compact class. The creation of the token, its encoding and decoding, as well as the password hashing and verification. Finally, you have created a simple dependency that will be used for verifying the user and enabling or disabling access to <span>protected routes.</span></p>
			<p class="calibre5">Building the FastAPI router for the application will be very similar to the ones that you have already built in <a href="B22406_02.xhtml#_idTextAnchor026" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"><span><em class="italic" lang="en-US" xml:lang="en-US">C</em></span><span><em class="italic">hapter 2</em></span></a>, <em class="italic">Setting Up the Database with MongoDB</em>. You will have two basic endpoints for registering and logging in, and they will rely heavily on the <span><strong class="source-inline">AuthHandler</strong></span><span> class.</span></p>
			<h3 class="calibre8">Creating the APIRouter for the users</h3>
			<p class="calibre5">In this section, you will create the APIRouter for the users and implement the login and register functionalities with the help of the authentication class and a mock database service implemented with dictionaries and UUID. To achieve this functionality, perform the <span>following steps:</span></p>
			<ol class="calibre14">
				<li class="calibre15">Create a folder <strong class="source-inline">routers</strong> in the root of your application and a file named <strong class="source-inline">users.py</strong> inside of it. Add the following code to the <span><strong class="source-inline">users.py</strong></span><span> file:</span><pre class="source-code">
import json
import uuid
from fastapi import APIRouter, Body, Depends, HTTPException, Request
from fastapi.encoders import jsonable_encoder
from fastapi.responses import JSONResponse
from authentication import AuthHandler
from models import UserBase, UserIn, UserOut, UsersList</pre></li>				<li class="calibre15">After adding the imports at the start of the file, create the APIRouter and the registration endpoint. The registration function uses the fake JSON database to store the username and the hashed password, by using the <strong class="source-inline">authentication.py</strong> file that you <span>created before.</span><pre class="source-code">
router = APIRouter()
auth_handler = AuthHandler()
@router.post(“/register”, response_description=”Register user”)
async def register(request: Request, newUser: UserIn = Body(...)) -&gt; UserBase:
    users = json.loads(open(“users.json”).read())[“users”]
    newUser.password = auth_handler.get_password_hash(newUser.password)
    if any(user[“username”] == newUser.username for user in users):
        raise HTTPException(status_code=409, detail=”Username already taken”)
    newUser = jsonable_encoder(newUser)
    newUser[“id”] = str(uuid. uuid4())
    users.append(newUser)
    with open(“users.json”, “w”) as f:
        json.dump({“users”: users}, f, indent=4)
    return newUser</pre><p class="list-inset">In order to demonstrate a basic JWT-based authentication and authorization system, a fake data storage solution is used. Instead of connecting through a driver to a MongoDB cluster, you use a simple JSON file for storing users along with their hashed passwords—a solution similar to the popular JSON Server Node package, used for testing and scaffolding purposes. However, all the functionality and logic presented will apply to real database scenarios, and it is easily adaptable for MongoDB drivers or ODMs, such as PyMongo, Motor, <span>or Beanie.</span></p><p class="list-inset">After the imports, which include a couple of packages that you will likely not need when working with a real MongoDB database, such as <strong class="bold" lang="en-US" xml:lang="en-US">JSON</strong> and <strong class="source-inline" lang="en-US" xml:lang="en-US">uuid</strong>, you have instantiated <span lang="en-US" xml:lang="en-US">APIRouter</span> and the custom-made <span><strong class="source-inline" lang="en-US" xml:lang="en-US">AuthHandler</strong></span><span> class.</span></p><p class="list-inset">The <strong class="source-inline" lang="en-US" xml:lang="en-US">/register</strong> endpoint accepts the new user’s data in the body and molds it through the <strong class="source-inline" lang="en-US" xml:lang="en-US">UserIn</strong> Pydantic class defined in the <strong class="source-inline" lang="en-US" xml:lang="en-US">models.py</strong> file, while the output is set to be of class <strong class="source-inline" lang="en-US" xml:lang="en-US">UserBase</strong>. This is something that you would likely avoid as it will send the hashed password back to the newly <span>registered user.</span></p><p class="list-inset">Instead of a real MongoDB database, you are reading the contents of a JSON file called <strong class="source-inline" lang="en-US" xml:lang="en-US">users.json</strong>—this file will host a very simple data structure that will mimic your users’ MongoDB collection: a simple array of dictionaries containing user data – the ID, the username, and the <span>hashed password.</span></p><p class="list-inset">Now that you have this “database,” or array of users, it is easy to just loop over them and verify whether it contains a user with the same username as the user trying to register—if so, you just dismiss it with a gentle <strong class="source-inline">HTTP 409</strong> response code and a <strong class="source-inline">Username already </strong><span><strong class="source-inline">taken</strong></span><span> message.</span></p><p class="list-inset">If the username is not taken, proceed to start using your <strong class="source-inline" lang="en-US" xml:lang="en-US">auth_handler</strong> instance and set the plain-text raw password to its hashed counterpart, safe to be stored inside <span>the database.</span></p><p class="list-inset">In order to be able to store the user as a Python dictionary, use <strong class="source-inline" lang="en-US" xml:lang="en-US">jsonable_encoder</strong> and add a new key to it: the <strong class="source-inline" lang="en-US" xml:lang="en-US">uuid</strong> string that will be used as the ID of the <span>new user.</span></p><p class="list-inset">Finally, append the user (represented as a dictionary with an ID, username, and hashed password) to your list of users, write the modified list to the JSON file, and return <span>the user.</span></p></li>				<li class="calibre15">Now, continuing with the <strong class="source-inline">users.py</strong> router, you can create the <strong class="source-inline">login</strong> endpoint as well by adding the following code at the end of <span>the file:</span><pre class="source-code">
@router.post(“/login”, response_description=”Login user”)
async def login(request: Request, loginUser: UserIn = Body(...)) -&gt; str:
    users = json.loads(open(“users.json”).read())[“users”]
    user = next(
        (user for user in users if user[“username”] == loginUser.username), None
    )
    if (user is None) or (
        not auth_handler.verify_password(loginUser.password, user[“password”])
    ):
        raise HTTPException(status_code=401, detail=”Invalid username and/or password”)
    token = auth_handler.encode_token(str(user[“id”]), user[“username”])
    response = JSONResponse(content={“token”: token})
    return response</pre><p class="list-inset">This code follows a similar logic: it loads the user data and attempts to find the login user by their username (similar to a find query). If the user is not found or the password verification fails, the endpoint raises an exception. It’s considered a good security practice to inform the user that the entire combination of username and password is invalid, without specifying which part exactly failed. If both checks pass, you encode the token and return it to <span>the user.</span></p></li>				<li class="calibre15">Time to hook up the router. Edit the previously created <strong class="source-inline">app.py</strong> file by replacing the contents of the file with the <span>following code:</span><pre class="source-code">
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from routers.users import router as users_router
origins = [“*”]
app = FastAPI()
app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=[“*”],
    allow_headers=[“*”],
)
app.include_router(users_router, prefix=”/users”, tags=[“users”])</pre><p class="list-inset">Here, you added the <strong class="bold">CORS middleware</strong> in order to facilitate the connection with your future React frontend, and you added the <span><strong class="source-inline">users</strong></span><span> router.</span></p></li>				<li class="calibre15">Now, create a file called <strong class="source-inline">users.json</strong> in the root of your project and populate it with an empty <span><strong class="source-inline">users</strong></span><span> array:</span><pre class="source-code">
{
    users:[]
}</pre></li>				<li class="calibre15">Save the file and start the FastAPI application from <span>the shell:</span><pre class="source-code">
uvicorn app:app --reload</pre></li>				<li class="calibre15">You should be able to perform a user registration and a user login. Try it with the <span>HTTPie client:</span><pre class="source-code">
http 127.0.0.1:8000/users/register username=”marko” password=”marko123”</pre></li>				<li class="calibre15">The server should send the following response, but bear in mind that your hash and UUID will <span>be different:</span><pre class="source-code">
HTTP/1.1 200 OK
content-length: 138
content-type: application/json
date: Sun, 07 Apr 2024 18:38:41 GMT
server: uvicorn
{
    “id”: “45cd212b-71eb-42b4-9d06-a74f2609764b”,
    “password”: “$2b$12$owWXcY5KgI9s6Rdfjcpx7eXaZOMWf8NaxN.SoLJ4h8O.xzFpRqEee”,
    “username”: “marko”
}</pre><p class="list-inset">If you peek in the <strong class="source-inline" lang="en-US" xml:lang="en-US">users.json</strong> file, you should see something <span>like this:</span></p><pre class="source-code">{
    “users”: [
        {
            “username”: “marko”,
            “password”: “$2b$12$owWXcY5KgI9s6Rdfjcpx7eXaZOMWf8NaxN.SoLJ4h8O.xzFpRqEee”,
            “id”: “45cd212b-71eb-42b4-9d06-a74f2609764b”
        }
    ]</pre></li>			</ol>
			<p class="callout-heading">Note</p>
			<p class="callout">In a real-world system, you would not want to send the hashed password even to the logged-in user, but this whole system is for demonstration purposes and created to be as illustrative <span>as possible.</span></p>
			<p class="calibre5">You have created a full authentication flow (for demonstration purposes—you will not use a JSON file with dictionaries and UUIDs in production) and you have crafted all the mandatory functionalities: creating users (registration), checking for the validity of the submitted data, and user login. Finally, you tested the registration functionality by creating a <span>test user.</span></p>
			<h3 class="calibre8">Testing the login functionality with HTTPie</h3>
			<p class="calibre5">Now, test the login functionality with the correct user/password combination and then a wrong one. </p>
			<ol class="calibre14">
				<li class="calibre15">First, log in. In the terminal, issue the following <span>HTTPie command:</span><pre class="source-code">
http POST 127.0.0.1:8000/users/login username=”marko” password=”marko123”</pre><p class="list-inset">The response should be just a big string—your JWT—the value of this token (here, it starts with the string <em class="italic">eyJhbGciOiJ…</em>) should be copied and saved for testing the authenticated <span>route later:</span></p><pre class="source-code">HTTP/1.1 200 OK
content-length: 241
content-type: application/json
date: Sun, 07 Apr 2024 18:43:07 GMT
server: uvicorn
{
    “token”: 
“eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE3MTI1MTcxODgsImlhdCI6MTcxMjUxNTM4OCwic3ViIjp7InVzZXJfaWQ iOiI0NWNkMjEyYi03MWViLTQyYjQtOWQwNi1hNzRmMjYwOTc2NGIiLCJ1c2VybmFtZS I6Im1hcmtvIn19.tFcJoKhTdDBDIBhCX-dCUEkCD3Fc8E-smQd2M_h5h2k”
}</pre></li>				<li class="calibre15">Try something like the following (notice the password <span>is wrong):</span><pre class="source-code">
http POST 127.0.0.1:8000/users/login username=”marko” password=”marko111”</pre><p class="list-inset">The response will be similar to <span>the following:</span></p><pre class="source-code">HTTP/1.1 401 Unauthorized
content-length: 45
content-type: application/json
date: Sun, 07 Apr 2024 18:44:34 GMT
server: uvicorn
{
    “detail”: “Invalid username and/or password”
}</pre></li>			</ol>
			<p class="calibre5">You have just implemented your own authentication system with FastAPI from scratch. Now it would be great to put it to use in <span>a route.</span></p>
			<h3 class="calibre8">Creating a protected route</h3>
			<p class="calibre5">Say that now you want a new endpoint that lists all the users in your system, and you want to make it visible only to logged-in users. This method would allow you to protect any route in different routers, just by leveraging the powerful FastAPI dependency <span>injection system:</span></p>
			<ol class="calibre14">
				<li class="calibre15">Open the <strong class="source-inline">users.py</strong> file and add the following route at <span>the end:</span><pre class="source-code">
@router.get(“/list”, response_description=”List all users”)
async def list_users(request: Request, user_data=Depends(auth_handler.auth_wrapper)):
    
    users = json.loads(open(“users.json”).read())[“users”]
    return UsersList(users=users)</pre><p class="list-inset">The key to this route is the <strong class="source-inline">user_data</strong> part—if the dependency is not met, the route will respond with an exception and the messages defined <span>in </span><span><strong class="source-inline">authentication.py</strong></span><span>.</span></p></li>				<li class="calibre15">Try to log in, grab the JWT that you got from the login endpoint and have copied (if it hasn't expired!), and then pass it as the <span>bearer token:</span><pre class="source-code">
http GET 127.0.0.1:8000/users/list ‘Authorization:Bearer &lt;your Bearer Token&gt;’     </pre><p class="list-inset">The result should contain all the users that you have created <span>so far:</span></p><pre class="source-code">HTTP/1.1 200 OK
content-length: 76
content-type: application/json
date: Sun, 07 Apr 2024 19:07:45 GMT
server: uvicorn
{
    “users”: [
        {
            “id”: “45cd212b-71eb-42b4-9d06-a74f2609764b”,
            “username”: “marko”
        }
    ]
}</pre></li>				<li class="calibre15">If you try to modify the token, or if you let it expire, the result will be <span>the following:</span><pre class="source-code">
HTTP/1.1 401 Unauthorized
content-length: 26
content-type: application/json
date: Sun, 07 Apr 2024 19:10:12 GMT
server: uvicorn
{
    “detail”: “Invalid token”
}</pre></li>			</ol>
			<p class="calibre5">In this section, you saw how to create a simple but efficient authentication system on your FastAPI backend, create a JWT generator, verify the tokens, protect some routes, and provide the routes needed for creating (registering) new users and logging in. The next section will show how things work on the <span>front end.</span></p>
			<h1 id="_idParaDest-106" class="contributor"><a id="_idTextAnchor114" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Authenticating the users in React</h1>
			<p class="calibre5">In this section, you will go through a basic mechanism that will enable you to have a simple authentication flow on the client side. Everything will revolve around the JWT and the way you decide to <span>handle it.</span></p>
			<p class="calibre5">React.js is an unopinionated UI library. It provides numerous ways of implementing user authentication and authorization. Since your FastAPI backend implements JWT-based authentication, you have to decide how to deal with the JWT <span>in React.</span></p>
			<p class="calibre5">In this chapter, you are going to store it in memory, then in <strong class="source-inline">localStorage</strong> (an HTML5 simple web storage object in JavaScript that allows applications to store key-value pairs in a user’s web browser with no expiration date). This chapter will not cover cookie-based solutions, which tend to be the most robust and secure, as one such solution will be covered in the <span>next chapter.</span></p>
			<p class="calibre5">Each of these methods has its benefits and drawbacks, and it is very useful to get acquainted with them. Authentication should always be taken very seriously and, depending on your application scope and requirements, it should always be a topic that requires <span>thorough analysis.</span></p>
			<p class="calibre5">There is an ongoing debate on what the optimal solution for storing authentication data is—in this case, the JWT. As always, there are pros and cons to <span>each solution.</span></p>
			<p class="calibre5">Cookies have been around for a very long time—they can store data in key-value pairs in the browser and are readable from both the browser and the server. Their popularity coincided with the classic server-side-rendered websites. However, they can store a very limited amount of data and the structure of said data has to be <span>very simple.</span></p>
			<p class="calibre5"><strong class="source-inline">localstorage</strong> and <strong class="source-inline">sessionStorage</strong> were introduced with HTML5 as a way to address the need for storing complex data structures in <strong class="bold">single-page applications</strong> (<strong class="bold">SPAs</strong>), among other things. Their capacity is around 10 MB, depending on the browser’s implementation, compared to 4 KB of cookie capacity. Session storage data persists through a session, while local storage remains in the browser even after it is closed and reopened until manually deleted, making SPAs the most pleasant but also the most vulnerable solution. Both can host complex JSON <span>data structures.</span></p>
			<p class="calibre5">Storing JWTs in <strong class="source-inline">localstorage</strong> is easy and it provides a great user and <span>developer experience.</span></p>
			<p class="calibre5">The majority of authorities on the subject suggest storing JWTs in HTTP-only cookies, as they cannot be accessed through JavaScript and require the frontend and the backend to run on the same domain. </p>
			<p class="calibre5">This can be accomplished in different ways, through routing requests or using a proxy. Another popular strategy is the use of so-called refresh tokens. In this method, the application issues one token upon login, and then this token is used to generate other (refresh) tokens automatically, allowing you to strike the right balance between security and <span>user experience.</span></p>
			<h3 class="calibre8">The Context API</h3>
			<p class="calibre5">In <a href="B22406_03.xhtml#_idTextAnchor051" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"><span><em class="italic">Chapter 3</em></span></a>, <em class="italic">Python Type Hints and Pydantic</em>, you learned how to manage simple pieces of the state of a component through the <strong class="source-inline">useState</strong> hook. </p>
			<p class="calibre5">Imagine that you have a top-level component—maybe even the root <strong class="source-inline">App.js</strong> component—and you need to pass some piece of state to a deeply nested component inside the React component tree. You would need to pass that piece of data to a component that is inside the <strong class="source-inline">App.js</strong> stateful component and then pass it further down the tree until it reaches the subcomponent that actually needs <span>said data.</span></p>
			<p class="calibre5">This pattern is known as <strong class="bold">prop drilling</strong>—passing a state value through props and having multiple components that do not use this state value; they just pass it on. Prop drilling has several implications, most of which are <span>best avoided:</span></p>
			<ul class="calibre14">
				<li class="calibre17">Refactoring and changing code is more difficult because you must keep the state value channels of communication intact at <span>all times</span></li>
				<li class="calibre17">Code is less reusable as components need to always provide the <span>state value</span></li>
				<li class="calibre17">More code needs to be written, as components need to accept and <span>forward props</span></li>
			</ul>
			<p class="calibre5">React introduced the <strong class="bold" lang="en-US" xml:lang="en-US">Context API</strong> as a way of providing values across components without the need for prop drilling. </p>
			<h3 class="calibre8">Creating a simple SPA</h3>
			<p class="calibre5">In the following section, you will create a very simple SPA that will allow users to register (if they are not registered yet), log in with a username and password, and, if authenticated, see the list of all registered users. The UI will tightly mimic <span>your backend.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">In order for the frontend to be functional and testable, it is mandatory to provide the backend from the previous section, so be sure to run the FastAPI <span>backend with:</span></p>
			<p class="callout"><strong class="source-inline">uvicorn </strong><span><strong class="source-inline">app:app --reload</strong></span></p>
			<p class="calibre5">The frontend will connect to the running FastAPI backend through the API. While FastAPI is serving the application on the address <strong class="source-inline">http://127.0.0.1:8000</strong>, the React frontend will use this same URL to connect, perform GET and POST requests, authenticate users and <span>list resources.</span></p>
			<p class="calibre5">You will go through the main concepts of the Context API storing the JWT in the application. Begin with the <span>following steps:</span></p>
			<ol class="calibre14">
				<li class="calibre15">Create a new Vite React project, install Tailwind, and add Tailwind CSS as it simplifies the styling of the application. Please refer to <a href="B22406_05.xhtml#_idTextAnchor090" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"><span><em class="italic">Chapter 5</em></span></a>, <em class="italic">Setting up a React Workflow</em>, in order to do so. Also, delete files and folder that will not be needed (assets such <span>as </span><span><strong class="source-inline">App.css</strong></span><span>).</span></li>
				<li class="calibre15">Create in the <strong class="source-inline">/src</strong> folder a new file and name it <strong class="source-inline">AuthContext.jsx</strong>. The <strong class="source-inline">.jsx</strong> extension is a reminder that the context is indeed a React component that will wrap all the other components that need access to the context variables, functions, objects, <span>or arrays:</span><pre class="source-code">
import {
    createContext
} from ‘react’;
const AuthContext = createContext();
export const AuthProvider = ({
    children
}) =&gt; {
    const [user, setUser] = useState(null);
    const [jwt, setJwt] = useState(null);
    const [message, setMessage] = useState(null);
    return (&lt;AuthContext.Provider value={
        {
            user,
            jwt,
            register,
            login,
            logout,
            message,
            setMessage
        }
    } &gt; {
            children
        } &lt;/AuthContext.Provider&gt;)
}</pre><p class="list-inset">The preceding code shows the structure of the context creation – you imported <strong class="source-inline">createContext</strong> from React and created your first context (<strong class="source-inline">AuthContext</strong>). After defining a couple of state variables and setters (for the user, the <strong class="source-inline">jwt</strong> token and the message), you returned the <strong class="source-inline">AuthContext</strong> component and the values that will be available in the context. The syntax is a bit different from the one used for the hooks examined in <a href="B22406_04.xhtml#_idTextAnchor071" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"><span><em class="italic">Chapter 4</em></span></a>, <em class="italic">Getting Started with FastAPI</em>, but this is a straightforward template that you will reuse many times, should you opt for the <span>Context API.</span></p></li>				<li class="calibre15">While simple, creating a context involves several steps: <ol class="calibre19"><li class="calibre15">First, you will need to create the actual context that will be shared across the application. </li><li class="calibre15">After that, the context should be provided to all the components needing access to <span>its values.</span></li><li class="calibre15">The components that need to access the context values need to subscribe to the context in order to be able to read, but also write to it. </li></ol><p class="list-inset">So, the first step when creating a context should be defining exactly what type of information you need to pass to components. If you think about it, you would definitely want the JWT since that is the whole point of this exercise. In order to showcase context functionality, you will also include the logged-in user and a message that will display the state of the application. </p><p class="list-inset">But since the context can also contain and pass functions—and that’s indeed one of its most useful features—you will also add to the context the <strong class="source-inline" lang="en-US" xml:lang="en-US">register</strong>, <strong class="source-inline" lang="en-US" xml:lang="en-US">login</strong>, and <strong class="source-inline" lang="en-US" xml:lang="en-US">logout</strong> functions. That may not be something you would do in a production system, but it will showcase the capabilities of Context API. </p></li>
				<li class="calibre15">Now, the only thing left to do is add the functions to the context. To do that, edit the existing <strong class="source-inline">AuthContext.jsx</strong> file and, after declaring the state variables, define the function for registering <span>new users:</span><pre class="source-code">
    const register = async (username, password) =&gt; {
      try {
        const response = await fetch(‘http://127.0.0.1:8000/users/register’, {
          method: ‘POST’,
          headers: {
            ‘Content-Type’: ‘application/json’,
          },
          body: JSON.stringify({
            username,
            password
          }),
        });
        if (response.ok) {
          const data = await response.json();
          setMessage(`Registration successful: user ${data.username} created`);
        } else {
          const data = await response.json();
          setMessage(`Registration failed: ${JSON.stringify(data)}`);
        }
      } catch (error) {
        setMessage(`Registration failed: ${JSON.stringify(error)}`);
      }
    };</pre><p class="list-inset">This simple JavaScript function is part of the context, and the only thing that interacts with your context is the setting of the status message—if a user is successfully created, the message confirms it. In case of an error, the message is set to the error. You will want to provide a more complex validation logic and a nicer UI, but this is quite illustrative of the <span>context functioning.</span></p></li>				<li class="calibre15">Now add the other function related to authentication—the <span><strong class="source-inline">login()</strong></span><span> function:</span><pre class="source-code">
const login = async (username, password) =&gt; {
  setJwt(null)
  const response = await     fetch(‘http://127.0.0.1:8000/users/login’, {
    method: ‘POST’,
    headers: {
      ‘Content-Type’: ‘application/json’,
    },
    body: JSON.stringify({
      username,
      password
    }),
  });
  if (response.ok) {
    const data = await response.json();
    setJwt(data.token);
    setUser({
      username
    });
    setMessage(`Login successful: token ${data.token.slice(0, 10)}..., user ${username}`);
  } else {
    const data = await response.json();
    setMessage(‘Login failed: ‘ + data.detail);
    setUser({
      username: null
    });
  }
};</pre><p class="list-inset">The preceding code is similar to the <strong class="source-inline">register</strong> function—it sends a <strong class="source-inline">POST</strong> request to the FastAPI <strong class="source-inline">/login</strong> endpoint with the user-provided username and password, and it clears any pre-existing JWT in the process. If the request is successful, the retrieved token is set to its state variable and the <span>username accordingly.</span></p></li>				<li class="calibre15">The final piece of the puzzle is logging the user out. Since you are dealing only with the Context API and not some persistent storage solutions, the code is very short; it just needs to clear the context variables and set the <span>appropriate message:</span><pre class="source-code">
const logout = () =&gt; {
  setUser(null);
  setJwt(null);
  setMessage(‘Logout successful’);
};</pre></li>				<li class="calibre15">Your <strong class="source-inline">AuthContext</strong> is nearly complete—the only thing left is to inform the context that it needs to provide the previously defined functions. So, modify the <strong class="source-inline">return</strong> statement to <span>include everything:</span><pre class="source-code">
return ( &lt;
  AuthContext.Provider value = {
    {
      user,
      jwt,
      register,
      login,
      logout,
      message,
      setMessage
    }
  } &gt; {
    children
  } &lt;
  /AuthContext.Provider&gt;
);</pre></li>				<li class="calibre15">As a final touch, add a <strong class="source-inline">useContext</strong> React hook that facilitates working <span>with contexts:</span><pre class="source-code">
export const useAuth = () =&gt; useContext(AuthContext);</pre><p class="list-inset">This simple one-line hook allows you to now use <strong class="source-inline">AuthContext</strong> in any component that has access to the context—so any component wrapped inside <strong class="source-inline">AuthContext</strong>—with some simple ES6 destructuring. With your <strong class="source-inline">AuthContext</strong> now in place, you can put it directly in the <strong class="source-inline">App.jsx</strong> component and wrap it around all the other components. </p></li>				<li class="calibre15">Open the <strong class="source-inline">App.jsx</strong> file and <span>edit it:</span><pre class="source-code">
import { AuthProvider } from “./AuthContext”;
const App = () =&gt; {
  return (
    &lt;div className=”bg-blue-200 flex flex-col justify-center items-center min-h-screen”&gt;
      &lt;AuthProvider&gt;
        &lt;h1 className=”text-2xl text-blue-800”&gt; Simple Auth App &lt;/h1&gt;
      &lt;/AuthProvider&gt;{“ “}
    &lt;/div&gt;
  );
};
export default App</pre><p class="list-inset">This root component doesn’t contain anything that you haven’t seen already—apart from importing <strong class="source-inline" lang="en-US" xml:lang="en-US">AuthProvider</strong>—the component of your custom authentication context responsible for wrapping the area of components and a bit of <span>Tailwind styles.</span></p></li>				<li class="calibre15">Now comes the part where you will define the components that will be wrapped inside the context – as those components will be able to consume the context, have access to the context data, and modify it. For a bit more complex application, you would likely resort to the React Router package, but since this will be a very simple application, you will cram all the components into one page. There aren’t many <span>of them:</span><ul class="calibre19"><li class="calibre15"><strong class="bold" lang="en-US" xml:lang="en-US">Login</strong>: A simple login component form that will accept a username and password and then call the <strong class="source-inline" lang="en-US" xml:lang="en-US">login()</strong> function from <span>the context.</span></li><li class="calibre15"><strong class="bold" lang="en-US" xml:lang="en-US">Register</strong>: Similar to the login component, but for registering <span>new users.</span></li><li class="calibre15"><strong class="bold">Message</strong>: The simplest component, used only to display the status of <span>the app.</span></li><li class="calibre15"><strong class="bold">Users</strong>: The component whose state depends on the authentication status: if the user is logged in, they can see the list of users, meaning the JWT is present and valid; otherwise, the user is prompted to make <span>a login.</span></li></ul></li>
				<li class="calibre15">The <strong class="source-inline">Register</strong> component will be used for user registration. It needs to display a form. Create the <strong class="source-inline">Register.jsx</strong> file in the <strong class="source-inline">/src</strong> folder and create a simple form with <span>two fields:</span><pre class="source-code">
import { useState } from ‘react’;
import { useAuth } from ‘./AuthContext’;
const Register = () =&gt; {
    const [username, setUsername] = useState(‘’);
    const [password, setPassword] = useState(‘’);
    const { register } = useAuth();
    const handleSubmit = (e) =&gt; {
        e.preventDefault();
        register(username, password)
        setUsername(‘’)
        setPassword(‘’)
    };
    return (
        &lt;div className=”m-5 p-5  border-2”&gt;
            &lt;form onSubmit={handleSubmit} className=’grid grid-rows-3 gap-2’&gt;
                &lt;input
                    type=”text”
                    placeholder=”Username”
                    className=’p-2’
                    value={username}
                    onChange={(e) =&gt; setUsername(e.target.value)}
                /&gt;
                &lt;input
                    type=”password”
                    placeholder=”Password”
                    className=’p-2’
                    value={password}
                    onChange={(e) =&gt; setPassword(e.target.value)}
                /&gt;
                &lt;button type=”submit” className=’bg-blue-500 text-white rounded’&gt;Register&lt;/button&gt;
            &lt;/form&gt;
        &lt;/div&gt;
    );
};
export default Register</pre><p class="list-inset">You have just created a React-specific form with the help of two local state variables that take care of keeping track and sending the username and password to your FastAPI instance. The <strong class="source-inline">register</strong> function is imported from <strong class="source-inline" lang="en-US" xml:lang="en-US">AuthContext</strong> through the <strong class="source-inline" lang="en-US" xml:lang="en-US">useAuth()</strong> hook. That line really shows how easy it is to work with the context from within the wrapped components. </p><p class="list-inset">Finally, <strong class="source-inline">handleSubmit</strong> performs the call to the <strong class="source-inline">register</strong> function, clears the fields, and prevents the default HTML form behavior. </p></li>				<li class="calibre15">Create the <strong class="source-inline">Login.jsx</strong> file, which is nearly identical (and here you could practice your React skills and perform some refactoring). The component has a login form that will be used for <span>logging in:</span><pre class="source-code">
import { useState } from ‘react’;
import { useAuth } from ‘./AuthContext’;
const Login = () =&gt; {
    const [username, setUsername] = useState(‘’);
    const [password, setPassword] = useState(‘’);
    const { login } = useAuth();
    const handleSubmit = (e) =&gt; {
        e.preventDefault();
        login(username, password);
        setUsername(‘’);
        setPassword(‘’);
    };
    return (
        &lt;div className=”m-5 p-5  border-2”&gt;
            &lt;form onSubmit={handleSubmit} className=’grid grid-rows-3 gap-2’&gt;
                &lt;input
                    type=”text”
                    placeholder=”Username”
                    className=’p-2’
                    value={username}
                    onChange={(e) =&gt; setUsername(e.target.value)}
                /&gt;
                &lt;input
                    type=”password”
                    placeholder=”Password”
                    className=’p-2’
                    value={password}
                    onChange={(e) =&gt; setPassword(e.target.value)}
                /&gt;
                &lt;button type=”submit” className=’bg-blue-500 text-white rounded’&gt;Login&lt;/button&gt;
            &lt;/form&gt;
        &lt;/div&gt;
    );
};
export default Login</pre></li>				<li class="calibre15">There are two components left to be inserted in your simple auth application powered by FastAPI and React. First, create the <strong class="source-inline">src/Message.jsx</strong> component, which will be used to display the <span>status message:</span><pre class="source-code">
import { useAuth } from “./AuthContext”
const Message = () =&gt; {
    const { message } = useAuth()
    return (
        &lt;div className=”p-2 my-2”&gt;
            &lt;p&gt;{message}&lt;/p&gt;
        &lt;/div&gt;
    )
}
export default Message</pre><p class="list-inset">The <strong class="source-inline">Messages</strong> component reads the message state variable from the context and displays it to the users. </p></li>				<li class="calibre15">Now, you can finally create the <strong class="source-inline">src/Users.jsx</strong> component and <span>edit it:</span><pre class="source-code">
import { useEffect, useState } from ‘react’;
import { useAuth } from ‘./AuthContext’;
const Users = () =&gt; {
    const { jwt, logout } = useAuth();
    const [users, setUsers] = useState(null);
    useEffect(() =&gt; {
        const fetchUsers = async () =&gt; {
            const response = await fetch(‘http://127.0.0.1:8000/users/list’, {
                headers: {
                    Authorization: `Bearer ${jwt}`,
                },
            });
            const data = await response.json();
            setUsers(data.users);
        };
        if (jwt) {
            fetchUsers();
        }
    }, [jwt]);
    if (!jwt) return &lt;div&gt;Please log in to see all the users&lt;/div&gt;;
    return (
        &lt;div&gt;
            {users ? (
                &lt;div className=’flex flex-col’&gt;
                    &lt;h1&gt;The list of users&lt;/h1&gt;
                    &lt;ol&gt;
                        {users.map((user) =&gt; (
                            &lt;li key={user.id}&gt;{user.username}&lt;/li&gt;
                        ))}
                    &lt;/ol&gt;
                    &lt;button onClick={logout} className=’bg-blue-500 text-white rounded’&gt;Logout&lt;/button&gt;
                &lt;/div&gt;
            ) : (
                &lt;p&gt;Loading...&lt;/p&gt;
            )}
        &lt;/div&gt;
    );
};
export default Users;</pre><p class="list-inset">This component does a bit of heavy lifting compared to the others. It imports <strong class="source-inline" lang="en-US" xml:lang="en-US">jwt</strong> (along with the <strong class="source-inline" lang="en-US" xml:lang="en-US">logout</strong> function) from the context. This is important since the output of the <strong class="source-inline" lang="en-US" xml:lang="en-US">Users.jsx</strong> component depends entirely on the existence and validity of <span>the JWT.</span></p><p class="list-inset">After declaring a local state variable—<strong class="source-inline" lang="en-US" xml:lang="en-US">users</strong>—the component uses the <strong class="source-inline" lang="en-US" xml:lang="en-US">useEffect</strong> React hook to perform a call to the REST API, and since the <strong class="source-inline" lang="en-US" xml:lang="en-US">/users/list</strong> endpoint is protected, the JWT token needs to be present <span>and valid.</span></p><p class="list-inset">If the call to the <strong class="source-inline" lang="en-US" xml:lang="en-US">/users/list</strong> endpoint is successful, the retrieved users data is sent to the <strong class="source-inline" lang="en-US" xml:lang="en-US">users</strong> variable and displayed. Finally, if there is no <strong class="source-inline" lang="en-US" xml:lang="en-US">jwt</strong> in the context, the user is asked to perform a login and the <strong class="bold">Logout</strong> button you added simply calls the <strong class="source-inline">logout</strong> function from <span>the context.</span></p></li>				<li class="calibre15">Finally, to tie everything together, replace the <strong class="source-inline">App.jsx</strong> file with the following code to import the components, and finalize the <span>root component:</span><pre class="source-code">
import { useState } from ‘react’;
import { AuthProvider } from ‘./AuthContext’;
import Register from ‘./Register’;
import Login from ‘./Login’;
import Users from ‘./Users’;
import Message from ‘./Message’;
const App = () =&gt; {
  const [showLogin, setShowLogin] = useState(true)
  return (
    &lt;div className=’bg-blue-200 flex flex-col justify-center items-center min-h-screen’&gt;
      &lt;AuthProvider&gt;
        &lt;h1 className=’text-2xl text-blue-800’&gt;Simple Auth App&lt;/h1&gt;
        &lt;Message /&gt;
        {showLogin ? &lt;Login /&gt; : &lt;Register /&gt;}
        &lt;button onClick={() =&gt; setShowLogin(!showLogin)}&gt;{showLogin ? ‘Register’ : ‘Login’}&lt;/button&gt;
        &lt;hr /&gt;
        &lt;Users /&gt;
      &lt;/AuthProvider&gt;
    &lt;/div&gt;
  );
};
export default App;</pre></li>			</ol>
			<p class="calibre5">Now, you’ll be able to test the application—try registering, logging in, entering invalid data, and so on. You have created a very simple but complete full stack authentication solution. In the next section, you will learn about some methods of persisting the <span>login data.</span></p>
			<h2 id="_idParaDest-107" class="about-the-author"><a id="_idTextAnchor115" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Persisting authentication data with localStorage</h2>
			<p class="calibre5">As mentioned before, the most developer-friendly option for persisting authentication is the use of <strong class="source-inline">localStorage</strong> or <strong class="source-inline">sessionStorage</strong>. <strong class="source-inline">localStorage</strong> becomes very useful when it comes to storing temporary, local data. It is widely used for tasks such as remembering shopping cart data or user login on any website where security is not paramount. <strong class="source-inline">localStorage</strong> has a higher storage limit than cookies (5 MB versus 4 KB) and does not get sent with every HTTP request. This makes it a better choice for <span>client-side storage.</span></p>
			<p class="calibre5">To use <strong class="source-inline">localStorage</strong>, you can set and get JSON items using the <strong class="source-inline">setItem()</strong> and <strong class="source-inline">getItem()</strong> methods, respectively. One important thing to remember is that <strong class="source-inline">localStorage</strong> only stores strings, so you will need to use <strong class="source-inline">JSON.stringify()</strong> and <strong class="source-inline">JSON.parse()</strong> to convert between JavaScript objects <span>and strings.</span></p>
			<p class="calibre5">Armed with this knowledge, try to summarize what the app requirements are – you want the user to be able to refresh or close and reopen the application window/tab and remain logged in if they were logged in, in the first place. Translated into React language, you need a <strong class="source-inline">useEffect</strong> hook that will run and verify whether there is a token stored in <strong class="source-inline">localStorage</strong>. If it is present, you want to check this token through the FastAPI <strong class="source-inline">/me</strong> endpoint and set the <span>username accordingly:</span></p>
			<ol class="calibre14">
				<li class="calibre15">Open the existing <strong class="source-inline">AuthContext.jsx</strong> file, and after the <strong class="source-inline">useState</strong> hook, define the <span><strong class="source-inline">useEffect</strong></span><span> call:</span><pre class="source-code">
    export const AuthProvider = ({ children }) =&gt; {
    const [user, setUser] = useState(null);
    const [jwt, setJwt] = useState(null);
    const [message, setMessage] = useState(null);
    useEffect(() =&gt; {
        
        const storedJwt = localStorage.getItem(‘jwt’);
        if (storedJwt) {
            setJwt(storedJwt);
            fetch(‘http://127.0.0.1:8000/users/me’, {
                headers: {
                    Authorization: `Bearer ${storedJwt}`,
                },
            })
                .then(res =&gt; res.json())
                .then(data =&gt; {
                    if (data.username) {
                        setUser({ username: data.username });
                        setMessage(`Welcome back, ${data.username}!`);
                    }
<span lang="pt-PT" xml:lang="pt-PT">                </span>})
                .catch(() =&gt; {
                    localStorage.removeItem(‘jwt’);
                });
        }
    }, []);</pre><p class="list-inset">The bulk of your persistence logic is located in the <strong class="source-inline">useEffect</strong> call. First, you can try to get the <strong class="source-inline">jwt</strong> token from <strong class="source-inline">localStorage</strong> and then use that token to get the user data from the <strong class="source-inline">/me</strong> route. If the username is found, it is set in the context and the user is (already) logged in. If not, you clear <strong class="source-inline">localStorage</strong> or send a message that the token has expired (in the <span><strong class="source-inline">Users.jsx</strong></span><span> component).</span></p></li>				<li class="calibre15">The <strong class="source-inline">login()</strong> function also has to be modified in order to take account of <strong class="source-inline">localStorage</strong>. In the same <strong class="source-inline">AuthContext.jsx</strong>, modify the <span><strong class="source-inline">login()</strong></span><span> function:</span><pre class="source-code">
const login = async (username,
  password) =&gt; {
    <strong class="bold">setJwt(null)</strong>
    const response = await fetch(
      ‘http://127.0.0.1:8000/users/login’, {
        method: ‘POST’,
        headers: {
          ‘Content-Type’: ‘application/json’,
        },
        body: JSON.stringify({
          username,
          password
        }),
      });
    if (response.ok) {
      const data = await response
        .json();
      setJwt(data.token);
<strong class="bold">      localStorage.setItem(‘jwt’, data.token);</strong>
      setUser({
        username
      });
      setMessage(
        `Login successful: token ${data.token.slice(0, 10)}..., user ${username}`
        );
    } else {
      const data = await response
        .json();
      setMessage(‘Login failed: ‘ +
        data.detail);
      setUser({
        username: null
      });
    }
  };</pre><p class="list-inset">The only modification involves setting the new JWT to the <strong class="source-inline">localStorage</strong> <strong class="source-inline">jwt</strong> variable. Hence, the <strong class="source-inline">logout()</strong> function will also need to <span>clear </span><span><strong class="source-inline">localstorage</strong></span><span>.</span></p></li>				<li class="calibre15">In the same <strong class="source-inline">AuthContext.jsx</strong> file, modify the <span><strong class="source-inline">logout</strong></span><span> function:</span><pre class="source-code">
const logout = () =&gt; {
    setUser(null);
    setJwt(‘’);
    localStorage .removeItem(‘jwt’);
    setMessage(‘Logout successful’);
};</pre></li>				<li class="calibre15">Finally, in order to make your application even more explicit and informative, open the <strong class="source-inline">Users.jsx</strong> component and replace it with the <span>following code:</span><pre class="source-code">
import { useEffect, useState } from ‘react’;
import { useAuth } from ‘./AuthContext’;
const Users = () =&gt; {
    const { jwt, logout } = useAuth();
    const [users, setUsers] = useState(null);
    const [error, setError] = useState(null);
    useEffect(() =&gt; {
        const fetchUsers = async () =&gt; {
            const response = await fetch(‘http://127.0.0.1:8000/users/list’, {
                headers: {
                    Authorization: `Bearer ${jwt}`,
                },
            });
            const data = await response.json();
            if (!response.ok) {
                setError(data.detail);
            }
            setUsers(data.users);
        };
        if (jwt) {
            fetchUsers();
        }
    }, [jwt]);
    if (!jwt) return &lt;div&gt;Please log in to see all the users&lt;/div&gt;;
    return (
        &lt;div&gt;
            {users ? (
                &lt;div className=’flex flex-col’&gt;
                    &lt;h1&gt;The list of users&lt;/h1&gt;
                    &lt;ol&gt;
                        {users.map((user) =&gt; (
                            &lt;li className=’’ key={user.id}&gt;{user.username}&lt;/li&gt;
                        ))}
                    &lt;/ol&gt;
                    &lt;button onClick={logout} className=’bg-blue-500 text-white rounded’&gt;Logout&lt;/button&gt;
                &lt;/div&gt;
            ) : (
                &lt;p&gt;{error}&lt;/p&gt;
            )}
        &lt;/div&gt;
    );
};
export default Users;</pre></li>			</ol>
			<p class="calibre5">The app is now able to persist the logged-in user, retrieve the stored JWT, and restore the previous authentication state. Before trying to log in, make sure that the FastAPI backend is working properly on <span>port </span><span><strong class="source-inline">8000</strong></span><span>.</span></p>
			<p class="calibre5">Try logging in, refreshing the browser, closing the tab, and <span>reopening it.</span></p>
			<p class="calibre5">You can also try this with the token inside the <strong class="bold">Application</strong> tab in the developer toolbar of Chrome or Firefox and see what happens if you tamper with it or <span>delete it.</span></p>
			<h2 id="_idParaDest-108" class="about-the-author"><a id="_idTextAnchor116" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Other authentication solutions</h2>
			<p class="calibre5">It is important to emphasize again that the <strong class="bold">FARM</strong> stack can be a great prototyping tool. So, knowing your way around it when creating an authentication flow, even if it is not ideal or bulletproof, might be just good enough to get you over that <strong class="bold">MVP</strong> hump in the race for the next great data-driven product. You could easily implement a similar solution with cookies instead of <strong class="source-inline">localStorage</strong> for instance, but keeping in mind the specificities of <span>both solutions.</span></p>
			<p class="calibre5">Finally, it is important to get acquainted with the various third-party authentication options. <strong class="bold">Firebase</strong> and <strong class="bold">Supabase</strong> are popular database and authentication services that can be used solely for managing users and authenticating them. <strong class="bold">Clerk</strong> and <strong class="bold">Kinde</strong> are newer players in the field and are particularly geared toward the React/Next.js/Remix.js ecosystem, while <strong class="bold">Auth0</strong> and <strong class="bold">Cognito</strong> are industry-standard solutions. Almost all third-party authentication systems offer a generous free or almost-free tier, but once your application grows, you are bound to hit a paid tier, and the costs vary and replacing these services, should the need arise, is <span>not easy.</span></p>
			<h1 id="_idParaDest-109" class="contributor"><a id="_idTextAnchor117" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Summary</h1>
			<p class="calibre5">In this chapter, you’ve seen a very basic, but quite representative, implementation of two versions of an authentication mechanism. You learned how FastAPI enables the use of standard-compliant authentication methods and implemented one of the simplest possible yet effective solutions – without persisting the authentication data and storing the <strong class="bold">JWT</strong> <span>in </span><span><strong class="source-inline">localStorage</strong></span><span>.</span></p>
			<p class="calibre5">You have learned how elegant and flexible FastAPI is when it comes to defining granular roles and permissions, especially with MongoDB, with the aid of <strong class="bold">Pydantic</strong> as the middleman. This chapter was focused exclusively on <strong class="bold">JWTs</strong> as the means of communication because it is the primary and most popular tool in SPAs nowadays, and it enables great connectivity between services or microservices. <strong class="bold">JWT</strong> mechanisms shine when you need to develop different applications with the same FastAPI and MongoDB-powered backend—for instance, a React web application and a React Native or Flutter-based <span>mobile app.</span></p>
			<p class="calibre5">Furthermore, carefully considering your authentication and authorization strategy is crucial, especially when extracting user data from third-party systems may not be feasible or practical. This highlights the importance of devising robust authentication and authorization methods. </p>
			<p class="calibre5">In the next chapter, you will create a more complex FastAPI backend, with image uploading through a third-party service and use a MongoDB database <span>for persistance.</span></p>
		</div>
	</div>
</div>
</body></html>