<html><head></head><body>
<div><div><div><h1 id="_idParaDest-98" class="contributor"><a id="_idTextAnchor105" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/><a id="_idTextAnchor106" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>6</h1>
			<h1 id="_idParaDest-99" class="contributor"><a id="_idTextAnchor107" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Authentication and Authorization</h1>
			<p class="calibre5">The concepts of authentication—proving that the user is who they claim to be—and authorization—making sure that the authenticated user should or should not be able to perform certain operations on your API—are very complex. In this chapter, you will explore the topics of authentication and authorization from a very practical standpoint and from the FARM stack perspective.</p>
			<p class="calibre5">The chapter will detail a simple yet robust and extensible setup for your FastAPI backend, based on <strong class="bold">JSON Web Token</strong> (<strong class="bold">JWT</strong>)—arguably the most popular and practical authentication method that has emerged in the last years. Then, you will see how to integrate your JWT-based authentication methods into React, leveraging some of React’s powerful features—namely, Hooks, Context, and React Router.</p>
			<p class="calibre5">By the end of this chapter, you should have a solid grasp of authentication methods that both FastAPI on the backend and React on the frontend have to offer, and you will be able to authenticate users and control what they can and cannot do within your application with granularity and precision.</p>
			<p class="calibre5">The chapter will cover the following topics:</p>
			<ul class="calibre14">
				<li class="calibre17">The user model and how it relates to other resources</li>
				<li class="calibre17">JWT authentication mechanism—the big picture</li>
				<li class="calibre17">Authentication and authorization tools in FastAPI</li>
				<li class="calibre17">How to protect the routes, routers, or the entire app</li>
				<li class="calibre17">Various solutions for authenticating with React</li>
			</ul>
			<h1 id="_idParaDest-100" class="contributor"><a id="_idTextAnchor108" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Technical requirements</h1>
			<p class="calibre5">To run the sample application in this chapter, you should have the following:</p>
			<ul class="calibre14">
				<li class="calibre17">Node.js version 18 or later</li>
				<li class="calibre17">Python 3.11.7 or later</li>
			</ul>
			<p class="calibre5">The requirements are identical to those in the previous chapters, and the new packages that you will install will be described as they are used.</p>
			<h1 id="_idParaDest-101" class="contributor"><a id="_idTextAnchor109" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Understanding JSON Web Token</h1>
			<p class="calibre5">HTTP is a stateless protocol, and that fact alone implies several important consequences. One of them is that if you want to persist some kind of state between requests, you must resort to a mechanism that will be able to remember a set of data, such as who the logged-in user was, what the selected items during a previous browser session were, or what the site preferences were. In order to achieve such functionality, and identify the current user, you as a developer have numerous options at your disposal. Some of the most popular and modern solutions are the following:</p>
			<ul class="calibre14">
				<li class="calibre17"><strong class="bold">Credential-based authentication: </strong>It requires the user to enter personal credentials, such as a username or email, along with a password</li>
				<li class="calibre17"><strong class="bold">Passwordless login: </strong>Users receive a secure, time-limited token via email or another communication channel for authentication instead of using a traditional password after creating an account. The secure token is used for session authentication, eliminating the need to type or remember passwords.</li>
				<li class="calibre17"><strong class="bold">Biometric passwords: </strong>It utilizes a bio-feature of the user, such as a fingerprint, for authentication.</li>
				<li class="calibre17"><strong class="bold">Social authentication: </strong>Users leverage their existing social media accounts (e.g., Google, Facebook, or LinkedIn) for authentication. This associates the user’s social media account with their account on the platform.</li>
				<li class="calibre17"><strong class="bold">Classic personal credentials method: </strong>Users provide an email and choose a password during registration. Optionally, users can also select a username.</li>
			</ul>
			<p class="calibre5">This chapter will consider the classic personal credentials method. When users register, they provide an email and choose a password and, optionally, a username.</p>
			<h2 id="_idParaDest-102" class="about-the-author"><a id="_idTextAnchor110" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>What is JWT?</h2>
			<p class="calibre5">While there are different ways of maintaining the identity of a user across different parts of an app, JWT is arguably the most common and popular method of connecting frontend applications (React, Vue.js, and Angular) or mobile apps with an API (in our case, a REST API). JWT is nothing but a standard, a way of structuring a big string composed of seemingly random characters and numbers that encapsulate user data in a secure way.</p>
			<p class="calibre5">JWTs contain three parts—the <strong class="bold">header</strong>, the <strong class="bold">payload</strong>, and the <strong class="bold">signature</strong>. The header hosts metadata about the token itself—the algorithm used for signing the token and the type of the token.</p>
			<p class="calibre5">The payload is the most interesting part. It contains the following information necessary for authentication:</p>
			<ul class="calibre14">
				<li class="calibre17">Data (claims): The ID of the user (or the username)</li>
				<li class="calibre17">The <strong class="bold">issued at field</strong> (<strong class="bold">iat</strong>): The date and time of issuing the token</li>
				<li class="calibre17">The time at which the token ceases to be valid: Tied to the duration of the token</li>
				<li class="calibre17">Optionally, other fields: For example, the username, roles etc.</li>
			</ul>
			<p class="calibre5">The payload is decodable and readable by everyone. You can read more about tokens and understand how they look in the JWT documentation: <a href="https://jwt.io" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2">https://jwt.io</a>.</p>
			<p class="calibre5">Finally, the most important part of the token is the signature. The signature guarantees the claims made by the token. The signature is reproduced (calculated) and compared with the original—thus preventing the modification of the claims.</p>
			<p class="calibre5">For example, consider a JWT stating that the username is <code>John</code>. Now, if someone were to attempt to change this to <code>Rita</code>, they would also need to modify the signature to match. However, altering the signature would render the token invalid. This mechanism ensures that the token’s content remains unchanged and authentic.</p>
			<p class="calibre5">The token is hence able to completely replace the authentication data—user or email and password combinations that do not need to be transmitted more than once.</p>
			<p class="calibre5">In the upcoming sections, you will learn how to implement a JWT-based authentication flow in your app.</p>
			<h1 id="_idParaDest-103" class="contributor"><a id="_idTextAnchor111" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>FastAPI backend with users and dependencies</h1>
			<p class="calibre5">Web applications (or mobile apps, for that matter) are not very useful if they are not secure. You must have heard about tiny errors in the authentication implementations that result in hundreds of thousands or even millions of compromised accounts, potentially exposing sensitive and valuable information.</p>
			<p class="calibre5">FastAPI is based on OpenAPI—previously known as <code>apiKey</code>, <code>http</code>, <code>OAuth 2.0</code>, <code>openIdConnect</code>, and so on). While the FastAPI documentation website (<a href="https://fastapi.tiangolo.com/tutorial/security/" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2">https://fastapi.tiangolo.com/tutorial/security/</a>) provides an excellent and detailed tutorial on creating an authentication flow, it is based on the <code>OAuth 2.0</code> protocol, which uses form data to send the credentials (username and password).</p>
			<p class="calibre5">In the following sections, you will devise a simple user model that will enable an authentication flow. You will then learn how to encode the user data into a JWT and how to use the token for accessing protected routes. </p>
			<h2 id="_idParaDest-104" class="about-the-author"><a id="_idTextAnchor112" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>User model for authentication</h2>
			<p class="calibre5">The basis of every authentication flow is the user model, which has to be able to store a minimum set of data needed for unequivocally identifying the users. The most common unique fields are an email address, a username, and, of course, a primary key—an <code>ObjectId</code> instance in the case of MongoDB.</p>
			<p class="calibre5">Modeling data with MongoDB is inherently different from modeling relational databases as discussed in <a href="B22406_02.xhtml#_idTextAnchor026" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"><em class="italic">Chapter 2</em></a>, <em class="italic">Setting Up the Database with MongoDB</em>. The driving idea is to think of queries upfront and model your relationships taking into account the queries that your app is going to be making most frequently.</p>
			<h2 id="_idParaDest-105" class="about-the-author"><a id="_idTextAnchor113" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Authentication and authorization with FastAPI: a walk-through</h2>
			<p class="calibre5">Authentication and authorization with FastAPI are much easier to understand through an example. In the next few sub-sections, you will develop a simple yet fully functional authentication system that will contain all the mandatory steps. To highlight the important parts, while keeping the example as concise as possible, you will not use a real MongoDB connection. Instead, you will make your own JSON file-based <strong class="bold">database</strong> that will store users as they register into the app and effectively mock a MongoDB collection. The first and foremost step is to review your authentication system.</p>
			<h3 class="calibre8">Reviewing all the parts of your authentication system</h3>
			<p class="calibre5">The following list provides a quick recapitulation of the tools and packages needed for implementing a FastAPI authentication workflow:</p>
			<ul class="calibre14">
				<li class="calibre17">To implement a FastAPI authentication workflow, you must use FastAPI’s security tools. In FastAPI, when you need to declare dependencies with <code>Security()</code> class. The other FastAPI import that will be needed is the type of dependable—in this case, you will use <strong class="bold">bearer</strong> tokens for authorization. You can refer to the FastAPI documentation: <a href="https://fastapi.tiangolo.com/reference/security/#fastapi.security.HTTPBearer" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2">https://fastapi.tiangolo.com/reference/security/#fastapi.security.HTTPBearer</a>.</li>
				<li class="calibre17">You also need password hashing and comparing functionality, which <code>passlib</code> can provide. The <code>passlib.context</code> module contains one main class: <code>passlib.context.CryptContext</code>, designed to take care of many of the more frequent coding tasks associated with hashing and comparing strings through various algorithms. Your authentication system requires two main functionalities: hashing passwords during user registration and comparing hashed passwords during login with those stored in your database.</li>
				<li class="calibre17">Finally, <strong class="bold" lang="en-US" xml:lang="en-US">PyJWT</strong> will provide the functionality to encode and decode JWT.</li>
			</ul>
			<h3 class="calibre8">Creating the model</h3>
			<p class="calibre5">The next steps involve creating the basic FastAPI application in a new virtual environment, activating the environment, installing the necessary packages, and creating a suitable model of the users with the required fields:</p>
			<ol class="calibre14">
				<li class="calibre15">Create a new directory, set it as the working directory with the <code>cd</code> (change directory) command, create a new Python environment in <code>/venv</code>, and activate it:<pre class="source-code">
<code>mkdir chapter6</code>
<code>cd chapter6</code>
<code>python -m venv venv</code>
<code>source ./venv/bin/activate</code></pre></li>				<li class="calibre15">Once the new Python environment is active, install the needed packages for the authentication system and the application overall:<pre class="source-code">
pip install fastapi uvicorn bcrypt==4.0.1 passlib pyjwt</pre></li>			</ol>
			<p class="callout-heading">Note</p>
			<p class="callout">If you want to be able to reproduce exactly the code in the book, you are strongly encouraged to use the <code>/backend/requirements.txt</code> file from the accompanying repository and install the packages with the <code>pip install -r </code><code>requirements.txt </code>command.</p>
			<p class="calibre5">The following are the last three packages needed for your authentication system:</p>
			<ul class="calibre14">
				<li class="calibre17"><code>Passlib</code> is a password hashing library for Python, and it supports a wide range of hashing algorithms, including <code>bcrypt</code>. It is very useful as it provides a unified interface for hashing and verifying passwords.</li>
				<li class="calibre17">The <code>bcrypt</code> package is a Python module that provides the password hashing method based on the Blowfish password hashing algorithm that you will be using. Please stick to the provided version of the package as there are some unresolved issues with later versions.</li>
				<li class="calibre17"><code>PyJWT</code> is the Python library for encoding and decoding JWT.</li>
			</ul>
			<ol class="calibre14">
				<li value="3" class="calibre15">Next, create the models for the application. As this app will only deal with users, the <code>models.py</code> file is rather simple:<pre class="source-code">
from pydantic import BaseModel, Field
from typing import List
class UserBase(BaseModel):
    id: str = Field(...)
    username: str = Field(
        ..., 
        min_length=3, 
        max_length=15)
    password: str = Field(...)
class UserIn(BaseModel):
    username: str = Field(
        ..., 
        min_length=3,
        max_length=15)
    password: str = Field(...)
class UserOut(BaseModel):
    id: str = Field(...)
    username: str = Field(
        ..., 
        min_length=3, 
        max_length=15)
class UsersList(BaseModel):
    users: List[UserOut]</pre></li>			</ol>
			<p class="calibre5">The models are self-explanatory, and they are left to be as explicit as possible. <code>UserBase</code> corresponds to the user representation that will be stored in your dummy database, or in a MongoDB collection (pay special attention to <code>Object_id</code>). In the given solution, the <code>id</code> field will be a UUID, so you set it to a string type.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">A Python <code>ObjectId()</code> class for the purpose of this demonstration.</p>
			<p class="calibre5">The <code>models.py</code> file contains two additional auxiliary Pydantic models: <code>UserIn</code>, which accepts the user data for registration or login (typically username and password, but can easily be extended to include email or other data), and <code>UserOut</code>, which is responsible for representing users within the application, excluding the hashed password but including the ID and the username.</p>
			<p class="calibre5"><code>UsersList</code> finally just outputs the list of all users, and you will use this model as an example for your protected route. Now, build your <code>app.py</code> file and create the actual application. </p>
			<h3 class="calibre8">Creating the application file</h3>
			<p class="calibre5">After defining the models, you can now proceed and create the main FastAPI application and the authentication class:</p>
			<ol class="calibre14">
				<li class="calibre15">Open a new Python file and name it <code>app.py</code>. Inside this file, create a minimal FastAPI application:<pre class="source-code">
from fastapi import FastAPI
app = FastAPI()</pre><p class="list-inset">We will return to this file shortly, but for now, let’s keep it as short as possible. Now it is time to build out the heart of your authentication system.</p></li>				<li class="calibre15">In the same folder, create the <code>authentication.py</code> file and start building it. Having all this at hand, open the newly created <code>authentication.py</code> file and begin crafting the authentication class. For this, you must first scaffold the <code>AuthHandler</code> class and add the required imports:<pre class="source-code">
import datetime
import jwt
from fastapi import HTTPException, Security
from fastapi.security import HTTPAuthorizationCredentials, HTTPBearer
from passlib.context import CryptContext
class AuthHandler:
    security = HTTPBearer()
    pwd_context = CryptContext(schemes=[“bcrypt”], deprecated=”auto”)
    secret = “FARMSTACKsecretString”</pre></li>			</ol>
			<p class="calibre5">Now that you have learned about all these imports, you can craft a class named <code>AuthHandler</code>, that uses FastAPI’s <code>HTTPBearer</code> as the security dependency and defines a password-processing context from <code>passlib</code>.</p>
			<h3 class="calibre8">Adding security dependency and password-processing context</h3>
			<p class="calibre5">This procedure consists of multiple steps. You’ll need to add a secret string that would ideally be generated randomly and kept safe in an environment variable, far from any <code>git commit</code>. The secret string is necessary for hashing the passwords. Here, you will hardcode it in this file for simplicity.</p>
			<p class="calibre5">So, continue with the same file and code the desired functionality step by step, as follows:</p>
			<ol class="calibre14">
				<li class="calibre15"><code>authentication.py</code> file under the <code>AuthHandler</code> class:</p><pre class="source-code">
def get_password_hash(self, password: str) -&gt; str:
        return self.pwd_context.hash(password)</pre><p class="list-inset">This function simply creates a hash of the given password, and this result is what you will be storing in your database. It is making good use of your previously defined <code>passlib</code> context.</p></li>				<li class="calibre15"><code>authentication.py</code> file:</p><pre class="source-code">
    def verify_password(
        self,
        plain_password: str, 
        hashed_password: str) -&gt; bool:
        return self.pwd_context.verify(
           plain_password, 
            hashed_password)</pre><p class="list-inset">Similar to the previous function, <code>verify_password</code> simply verifies that the hash of <code>plain_password</code> is indeed equal to the (already) hashed password and it returns <code>True</code> or <code>False</code>.</p></li>				<li class="calibre15"><code>authentication.py</code> file:</p><pre class="source-code">
def encode_token(self, user_id: int, username: str) -&gt; str:
payload = {
            “exp”: datetime.datetime.now(datetime.timezone.utc)
            + datetime.timedelta(minutes=30),
            “iat”: datetime.datetime.now(datetime.timezone.utc),
            “sub”: {“user_id”: user_id, “username”: username},
        }
        return jwt.encode(payload, self.secret, algorithm=”HS256”)</pre><p class="list-inset">The <code>encode_token</code> method of your class leverages the <code>PyJWT</code> package’s <code>encode</code> method to create the JWT itself, and it is very explicit; the payload contains the expiration time (very important—you do not want the JWTs to last for too long) and the <em class="italic" lang="en-US" xml:lang="en-US">issued-at time</em> (the <code>iat</code> part). Also, it references the dictionary named <code>sub</code>, which contains all the data that you wish to encode—in this case, the user ID and the username, although you could also add a role (regular user, administrator, and so on) or other data. To recap, the JWT encodes three pieces of data:</p><ul class="calibre19"><li class="calibre15">The expiration duration, in this example, 30 minutes.</li><li class="calibre15">The time of issuing the token, in this example, it is set to <code>now()</code>.</li><li class="calibre15">The <code>sub</code> part is the data (in the form of a dictionary) that you want to include in the token. In this example, it is the user ID and the username.</li></ul></li>				<li class="calibre15"><strong class="bold">Decoding </strong><strong class="bold">the token</strong><p class="list-inset">Continue building out the class, as now the reverse functionality is required—a way of decoding the token:</p><pre class="source-code">
def decode_token(self, token: str):
    try:
        payload = jwt.decode(
            token, 
            self.secret,
            algorithms=[“HS256”])
        return payload[“sub”]
    except jwt.ExpiredSignatureError:
        raise HTTPException(
            status_code=401, 
            detail=”Signature has expired”)
    except jwt.InvalidTokenError:
        raise HTTPException(
            status_code=401, 
            detail=”Invalid token”)
<strong class="bold">Defining </strong><strong class="bold">the dependency</strong><p class="list-inset">Finalize your class with the dependency to be injected in the routes that will need protection:</pre><pre class="source-code">
def auth_wrapper(
    self, 
    auth: HTTPAuthorizationCredentials = Security(security)) -&gt; dict:
    return self.decode_token(auth.credentials)</pre></li>			</ol>
			<p class="calibre5">You will use this <code>auth_wrapper</code> as the dependency—it will check for the presence of a valid JWT passed as a bearer token in the request headers for all the routes or entire routers that need authorization.</p>
			<p class="calibre5">The <code>authorization.py</code> file is a minimal implementation of an authentication/authorization flow.</p>
			<p class="calibre5">In the previous steps you wrapped most of the authentication and authorization functionality into a simple and compact class. The creation of the token, its encoding and decoding, as well as the password hashing and verification. Finally, you have created a simple dependency that will be used for verifying the user and enabling or disabling access to protected routes.</p>
			<p class="calibre5">Building the FastAPI router for the application will be very similar to the ones that you have already built in <a href="B22406_02.xhtml#_idTextAnchor026" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"><em class="italic" lang="en-US" xml:lang="en-US">C</em><em class="italic">hapter 2</em></a>, <em class="italic">Setting Up the Database with MongoDB</em>. You will have two basic endpoints for registering and logging in, and they will rely heavily on the <code>AuthHandler</code> class.</p>
			<h3 class="calibre8">Creating the APIRouter for the users</h3>
			<p class="calibre5">In this section, you will create the APIRouter for the users and implement the login and register functionalities with the help of the authentication class and a mock database service implemented with dictionaries and UUID. To achieve this functionality, perform the following steps:</p>
			<ol class="calibre14">
				<li class="calibre15">Create a folder <code>routers</code> in the root of your application and a file named <code>users.py</code> inside of it. Add the following code to the <code>users.py</code> file:<pre class="source-code">
import json
import uuid
from fastapi import APIRouter, Body, Depends, HTTPException, Request
from fastapi.encoders import jsonable_encoder
from fastapi.responses import JSONResponse
from authentication import AuthHandler
from models import UserBase, UserIn, UserOut, UsersList</pre></li>				<li class="calibre15">After adding the imports at the start of the file, create the APIRouter and the registration endpoint. The registration function uses the fake JSON database to store the username and the hashed password, by using the <code>authentication.py</code> file that you created before.<pre class="source-code">
router = APIRouter()
auth_handler = AuthHandler()
@router.post(“/register”, response_description=”Register user”)
async def register(request: Request, newUser: UserIn = Body(...)) -&gt; UserBase:
    users = json.loads(open(“users.json”).read())[“users”]
    newUser.password = auth_handler.get_password_hash(newUser.password)
    if any(user[“username”] == newUser.username for user in users):
        raise HTTPException(status_code=409, detail=”Username already taken”)
    newUser = jsonable_encoder(newUser)
    newUser[“id”] = str(uuid. uuid4())
    users.append(newUser)
    with open(“users.json”, “w”) as f:
        json.dump({“users”: users}, f, indent=4)
    return newUser</pre><p class="list-inset">In order to demonstrate a basic JWT-based authentication and authorization system, a fake data storage solution is used. Instead of connecting through a driver to a MongoDB cluster, you use a simple JSON file for storing users along with their hashed passwords—a solution similar to the popular JSON Server Node package, used for testing and scaffolding purposes. However, all the functionality and logic presented will apply to real database scenarios, and it is easily adaptable for MongoDB drivers or ODMs, such as PyMongo, Motor, or Beanie.</p><p class="list-inset">After the imports, which include a couple of packages that you will likely not need when working with a real MongoDB database, such as <code>uuid</code>, you have instantiated APIRouter and the custom-made <code>AuthHandler</code> class.</p><p class="list-inset">The <code>/register</code> endpoint accepts the new user’s data in the body and molds it through the <code>UserIn</code> Pydantic class defined in the <code>models.py</code> file, while the output is set to be of class <code>UserBase</code>. This is something that you would likely avoid as it will send the hashed password back to the newly registered user.</p><p class="list-inset">Instead of a real MongoDB database, you are reading the contents of a JSON file called <code>users.json</code>—this file will host a very simple data structure that will mimic your users’ MongoDB collection: a simple array of dictionaries containing user data – the ID, the username, and the hashed password.</p><p class="list-inset">Now that you have this “database,” or array of users, it is easy to just loop over them and verify whether it contains a user with the same username as the user trying to register—if so, you just dismiss it with a gentle <code>HTTP 409</code> response code and a <code>Username already </code><code>taken</code> message.</p><p class="list-inset">If the username is not taken, proceed to start using your <code>auth_handler</code> instance and set the plain-text raw password to its hashed counterpart, safe to be stored inside the database.</p><p class="list-inset">In order to be able to store the user as a Python dictionary, use <code>jsonable_encoder</code> and add a new key to it: the <code>uuid</code> string that will be used as the ID of the new user.</p><p class="list-inset">Finally, append the user (represented as a dictionary with an ID, username, and hashed password) to your list of users, write the modified list to the JSON file, and return the user.</p></li>				<li class="calibre15">Now, continuing with the <code>users.py</code> router, you can create the <code>login</code> endpoint as well by adding the following code at the end of the file:<pre class="source-code">
@router.post(“/login”, response_description=”Login user”)
async def login(request: Request, loginUser: UserIn = Body(...)) -&gt; str:
    users = json.loads(open(“users.json”).read())[“users”]
    user = next(
        (user for user in users if user[“username”] == loginUser.username), None
    )
    if (user is None) or (
        not auth_handler.verify_password(loginUser.password, user[“password”])
    ):
        raise HTTPException(status_code=401, detail=”Invalid username and/or password”)
    token = auth_handler.encode_token(str(user[“id”]), user[“username”])
    response = JSONResponse(content={“token”: token})
    return response</pre><p class="list-inset">This code follows a similar logic: it loads the user data and attempts to find the login user by their username (similar to a find query). If the user is not found or the password verification fails, the endpoint raises an exception. It’s considered a good security practice to inform the user that the entire combination of username and password is invalid, without specifying which part exactly failed. If both checks pass, you encode the token and return it to the user.</p></li>				<li class="calibre15">Time to hook up the router. Edit the previously created <code>app.py</code> file by replacing the contents of the file with the following code:<pre class="source-code">
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from routers.users import router as users_router
origins = [“*”]
app = FastAPI()
app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=[“*”],
    allow_headers=[“*”],
)
app.include_router(users_router, prefix=”/users”, tags=[“users”])</pre><p class="list-inset">Here, you added the <code>users</code> router.</p></li>				<li class="calibre15">Now, create a file called <code>users.json</code> in the root of your project and populate it with an empty <code>users</code> array:<pre class="source-code">
{
    users:[]
}</pre></li>				<li class="calibre15">Save the file and start the FastAPI application from the shell:<pre class="source-code">
uvicorn app:app --reload</pre></li>				<li class="calibre15">You should be able to perform a user registration and a user login. Try it with the HTTPie client:<pre class="source-code">
http 127.0.0.1:8000/users/register username=”marko” password=”marko123”</pre></li>				<li class="calibre15">The server should send the following response, but bear in mind that your hash and UUID will be different:<pre class="source-code">
HTTP/1.1 200 OK
content-length: 138
content-type: application/json
date: Sun, 07 Apr 2024 18:38:41 GMT
server: uvicorn
{
    “id”: “45cd212b-71eb-42b4-9d06-a74f2609764b”,
    “password”: “$2b$12$owWXcY5KgI9s6Rdfjcpx7eXaZOMWf8NaxN.SoLJ4h8O.xzFpRqEee”,
    “username”: “marko”
}</pre><p class="list-inset">If you peek in the <code>users.json</code> file, you should see something like this:</p><pre class="source-code">{
    “users”: [
        {
            “username”: “marko”,
            “password”: “$2b$12$owWXcY5KgI9s6Rdfjcpx7eXaZOMWf8NaxN.SoLJ4h8O.xzFpRqEee”,
            “id”: “45cd212b-71eb-42b4-9d06-a74f2609764b”
        }
    ]</pre></li>			</ol>
			<p class="callout-heading">Note</p>
			<p class="callout">In a real-world system, you would not want to send the hashed password even to the logged-in user, but this whole system is for demonstration purposes and created to be as illustrative as possible.</p>
			<p class="calibre5">You have created a full authentication flow (for demonstration purposes—you will not use a JSON file with dictionaries and UUIDs in production) and you have crafted all the mandatory functionalities: creating users (registration), checking for the validity of the submitted data, and user login. Finally, you tested the registration functionality by creating a test user.</p>
			<h3 class="calibre8">Testing the login functionality with HTTPie</h3>
			<p class="calibre5">Now, test the login functionality with the correct user/password combination and then a wrong one. </p>
			<ol class="calibre14">
				<li class="calibre15">First, log in. In the terminal, issue the following HTTPie command:<pre class="source-code">
http POST 127.0.0.1:8000/users/login username=”marko” password=”marko123”</pre><p class="list-inset">The response should be just a big string—your JWT—the value of this token (here, it starts with the string <em class="italic">eyJhbGciOiJ…</em>) should be copied and saved for testing the authenticated route later:</p><pre class="source-code">HTTP/1.1 200 OK
content-length: 241
content-type: application/json
date: Sun, 07 Apr 2024 18:43:07 GMT
server: uvicorn
{
    “token”: 
“eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE3MTI1MTcxODgsImlhdCI6MTcxMjUxNTM4OCwic3ViIjp7InVzZXJfaWQ iOiI0NWNkMjEyYi03MWViLTQyYjQtOWQwNi1hNzRmMjYwOTc2NGIiLCJ1c2VybmFtZS I6Im1hcmtvIn19.tFcJoKhTdDBDIBhCX-dCUEkCD3Fc8E-smQd2M_h5h2k”
}</pre></li>				<li class="calibre15">Try something like the following (notice the password is wrong):<pre class="source-code">
http POST 127.0.0.1:8000/users/login username=”marko” password=”marko111”</pre><p class="list-inset">The response will be similar to the following:</p><pre class="source-code">HTTP/1.1 401 Unauthorized
content-length: 45
content-type: application/json
date: Sun, 07 Apr 2024 18:44:34 GMT
server: uvicorn
{
    “detail”: “Invalid username and/or password”
}</pre></li>			</ol>
			<p class="calibre5">You have just implemented your own authentication system with FastAPI from scratch. Now it would be great to put it to use in a route.</p>
			<h3 class="calibre8">Creating a protected route</h3>
			<p class="calibre5">Say that now you want a new endpoint that lists all the users in your system, and you want to make it visible only to logged-in users. This method would allow you to protect any route in different routers, just by leveraging the powerful FastAPI dependency injection system:</p>
			<ol class="calibre14">
				<li class="calibre15">Open the <code>users.py</code> file and add the following route at the end:<pre class="source-code">
@router.get(“/list”, response_description=”List all users”)
async def list_users(request: Request, user_data=Depends(auth_handler.auth_wrapper)):
    
    users = json.loads(open(“users.json”).read())[“users”]
    return UsersList(users=users)</pre><p class="list-inset">The key to this route is the <code>user_data</code> part—if the dependency is not met, the route will respond with an exception and the messages defined in <code>authentication.py</code>.</p></li>				<li class="calibre15">Try to log in, grab the JWT that you got from the login endpoint and have copied (if it hasn't expired!), and then pass it as the bearer token:<pre class="source-code">
http GET 127.0.0.1:8000/users/list ‘Authorization:Bearer &lt;your Bearer Token&gt;’     </pre><p class="list-inset">The result should contain all the users that you have created so far:</p><pre class="source-code">HTTP/1.1 200 OK
content-length: 76
content-type: application/json
date: Sun, 07 Apr 2024 19:07:45 GMT
server: uvicorn
{
    “users”: [
        {
            “id”: “45cd212b-71eb-42b4-9d06-a74f2609764b”,
            “username”: “marko”
        }
    ]
}</pre></li>				<li class="calibre15">If you try to modify the token, or if you let it expire, the result will be the following:<pre class="source-code">
HTTP/1.1 401 Unauthorized
content-length: 26
content-type: application/json
date: Sun, 07 Apr 2024 19:10:12 GMT
server: uvicorn
{
    “detail”: “Invalid token”
}</pre></li>			</ol>
			<p class="calibre5">In this section, you saw how to create a simple but efficient authentication system on your FastAPI backend, create a JWT generator, verify the tokens, protect some routes, and provide the routes needed for creating (registering) new users and logging in. The next section will show how things work on the front end.</p>
			<h1 id="_idParaDest-106" class="contributor"><a id="_idTextAnchor114" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Authenticating the users in React</h1>
			<p class="calibre5">In this section, you will go through a basic mechanism that will enable you to have a simple authentication flow on the client side. Everything will revolve around the JWT and the way you decide to handle it.</p>
			<p class="calibre5">React.js is an unopinionated UI library. It provides numerous ways of implementing user authentication and authorization. Since your FastAPI backend implements JWT-based authentication, you have to decide how to deal with the JWT in React.</p>
			<p class="calibre5">In this chapter, you are going to store it in memory, then in <code>localStorage</code> (an HTML5 simple web storage object in JavaScript that allows applications to store key-value pairs in a user’s web browser with no expiration date). This chapter will not cover cookie-based solutions, which tend to be the most robust and secure, as one such solution will be covered in the next chapter.</p>
			<p class="calibre5">Each of these methods has its benefits and drawbacks, and it is very useful to get acquainted with them. Authentication should always be taken very seriously and, depending on your application scope and requirements, it should always be a topic that requires thorough analysis.</p>
			<p class="calibre5">There is an ongoing debate on what the optimal solution for storing authentication data is—in this case, the JWT. As always, there are pros and cons to each solution.</p>
			<p class="calibre5">Cookies have been around for a very long time—they can store data in key-value pairs in the browser and are readable from both the browser and the server. Their popularity coincided with the classic server-side-rendered websites. However, they can store a very limited amount of data and the structure of said data has to be very simple.</p>
			<p class="calibre5"><code>localstorage</code> and <code>sessionStorage</code> were introduced with HTML5 as a way to address the need for storing complex data structures in <strong class="bold">single-page applications</strong> (<strong class="bold">SPAs</strong>), among other things. Their capacity is around 10 MB, depending on the browser’s implementation, compared to 4 KB of cookie capacity. Session storage data persists through a session, while local storage remains in the browser even after it is closed and reopened until manually deleted, making SPAs the most pleasant but also the most vulnerable solution. Both can host complex JSON data structures.</p>
			<p class="calibre5">Storing JWTs in <code>localstorage</code> is easy and it provides a great user and developer experience.</p>
			<p class="calibre5">The majority of authorities on the subject suggest storing JWTs in HTTP-only cookies, as they cannot be accessed through JavaScript and require the frontend and the backend to run on the same domain. </p>
			<p class="calibre5">This can be accomplished in different ways, through routing requests or using a proxy. Another popular strategy is the use of so-called refresh tokens. In this method, the application issues one token upon login, and then this token is used to generate other (refresh) tokens automatically, allowing you to strike the right balance between security and user experience.</p>
			<h3 class="calibre8">The Context API</h3>
			<p class="calibre5">In <a href="B22406_03.xhtml#_idTextAnchor051" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"><em class="italic">Chapter 3</em></a>, <em class="italic">Python Type Hints and Pydantic</em>, you learned how to manage simple pieces of the state of a component through the <code>useState</code> hook. </p>
			<p class="calibre5">Imagine that you have a top-level component—maybe even the root <code>App.js</code> component—and you need to pass some piece of state to a deeply nested component inside the React component tree. You would need to pass that piece of data to a component that is inside the <code>App.js</code> stateful component and then pass it further down the tree until it reaches the subcomponent that actually needs said data.</p>
			<p class="calibre5">This pattern is known as <strong class="bold">prop drilling</strong>—passing a state value through props and having multiple components that do not use this state value; they just pass it on. Prop drilling has several implications, most of which are best avoided:</p>
			<ul class="calibre14">
				<li class="calibre17">Refactoring and changing code is more difficult because you must keep the state value channels of communication intact at all times</li>
				<li class="calibre17">Code is less reusable as components need to always provide the state value</li>
				<li class="calibre17">More code needs to be written, as components need to accept and forward props</li>
			</ul>
			<p class="calibre5">React introduced the <strong class="bold" lang="en-US" xml:lang="en-US">Context API</strong> as a way of providing values across components without the need for prop drilling. </p>
			<h3 class="calibre8">Creating a simple SPA</h3>
			<p class="calibre5">In the following section, you will create a very simple SPA that will allow users to register (if they are not registered yet), log in with a username and password, and, if authenticated, see the list of all registered users. The UI will tightly mimic your backend.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">In order for the frontend to be functional and testable, it is mandatory to provide the backend from the previous section, so be sure to run the FastAPI backend with:</p>
			<p class="callout"><code>uvicorn </code><code>app:app --reload</code></p>
			<p class="calibre5">The frontend will connect to the running FastAPI backend through the API. While FastAPI is serving the application on the address <code>http://127.0.0.1:8000</code>, the React frontend will use this same URL to connect, perform GET and POST requests, authenticate users and list resources.</p>
			<p class="calibre5">You will go through the main concepts of the Context API storing the JWT in the application. Begin with the following steps:</p>
			<ol class="calibre14">
				<li class="calibre15">Create a new Vite React project, install Tailwind, and add Tailwind CSS as it simplifies the styling of the application. Please refer to <a href="B22406_05.xhtml#_idTextAnchor090" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"><em class="italic">Chapter 5</em></a>, <em class="italic">Setting up a React Workflow</em>, in order to do so. Also, delete files and folder that will not be needed (assets such as <code>App.css</code>).</li>
				<li class="calibre15">Create in the <code>/src</code> folder a new file and name it <code>AuthContext.jsx</code>. The <code>.jsx</code> extension is a reminder that the context is indeed a React component that will wrap all the other components that need access to the context variables, functions, objects, or arrays:<pre class="source-code">
import {
    createContext
} from ‘react’;
const AuthContext = createContext();
export const AuthProvider = ({
    children
}) =&gt; {
    const [user, setUser] = useState(null);
    const [jwt, setJwt] = useState(null);
    const [message, setMessage] = useState(null);
    return (&lt;AuthContext.Provider value={
        {
            user,
            jwt,
            register,
            login,
            logout,
            message,
            setMessage
        }
    } &gt; {
            children
        } &lt;/AuthContext.Provider&gt;)
}</pre><p class="list-inset">The preceding code shows the structure of the context creation – you imported <code>createContext</code> from React and created your first context (<code>AuthContext</code>). After defining a couple of state variables and setters (for the user, the <code>jwt</code> token and the message), you returned the <code>AuthContext</code> component and the values that will be available in the context. The syntax is a bit different from the one used for the hooks examined in <a href="B22406_04.xhtml#_idTextAnchor071" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"><em class="italic">Chapter 4</em></a>, <em class="italic">Getting Started with FastAPI</em>, but this is a straightforward template that you will reuse many times, should you opt for the Context API.</p></li>				<li class="calibre15">While simple, creating a context involves several steps: <ol class="calibre19"><li class="calibre15">First, you will need to create the actual context that will be shared across the application. </li><li class="calibre15">After that, the context should be provided to all the components needing access to its values.</li><li class="calibre15">The components that need to access the context values need to subscribe to the context in order to be able to read, but also write to it. </li></ol><p class="list-inset">So, the first step when creating a context should be defining exactly what type of information you need to pass to components. If you think about it, you would definitely want the JWT since that is the whole point of this exercise. In order to showcase context functionality, you will also include the logged-in user and a message that will display the state of the application. </p><p class="list-inset">But since the context can also contain and pass functions—and that’s indeed one of its most useful features—you will also add to the context the <code>register</code>, <code>login</code>, and <code>logout</code> functions. That may not be something you would do in a production system, but it will showcase the capabilities of Context API. </p></li>
				<li class="calibre15">Now, the only thing left to do is add the functions to the context. To do that, edit the existing <code>AuthContext.jsx</code> file and, after declaring the state variables, define the function for registering new users:<pre class="source-code">
    const register = async (username, password) =&gt; {
      try {
        const response = await fetch(‘http://127.0.0.1:8000/users/register’, {
          method: ‘POST’,
          headers: {
            ‘Content-Type’: ‘application/json’,
          },
          body: JSON.stringify({
            username,
            password
          }),
        });
        if (response.ok) {
          const data = await response.json();
          setMessage(`Registration successful: user ${data.username} created`);
        } else {
          const data = await response.json();
          setMessage(`Registration failed: ${JSON.stringify(data)}`);
        }
      } catch (error) {
        setMessage(`Registration failed: ${JSON.stringify(error)}`);
      }
    };</pre><p class="list-inset">This simple JavaScript function is part of the context, and the only thing that interacts with your context is the setting of the status message—if a user is successfully created, the message confirms it. In case of an error, the message is set to the error. You will want to provide a more complex validation logic and a nicer UI, but this is quite illustrative of the context functioning.</p></li>				<li class="calibre15">Now add the other function related to authentication—the <code>login()</code> function:<pre class="source-code">
const login = async (username, password) =&gt; {
  setJwt(null)
  const response = await     fetch(‘http://127.0.0.1:8000/users/login’, {
    method: ‘POST’,
    headers: {
      ‘Content-Type’: ‘application/json’,
    },
    body: JSON.stringify({
      username,
      password
    }),
  });
  if (response.ok) {
    const data = await response.json();
    setJwt(data.token);
    setUser({
      username
    });
    setMessage(`Login successful: token ${data.token.slice(0, 10)}..., user ${username}`);
  } else {
    const data = await response.json();
    setMessage(‘Login failed: ‘ + data.detail);
    setUser({
      username: null
    });
  }
};</pre><p class="list-inset">The preceding code is similar to the <code>register</code> function—it sends a <code>POST</code> request to the FastAPI <code>/login</code> endpoint with the user-provided username and password, and it clears any pre-existing JWT in the process. If the request is successful, the retrieved token is set to its state variable and the username accordingly.</p></li>				<li class="calibre15">The final piece of the puzzle is logging the user out. Since you are dealing only with the Context API and not some persistent storage solutions, the code is very short; it just needs to clear the context variables and set the appropriate message:<pre class="source-code">
const logout = () =&gt; {
  setUser(null);
  setJwt(null);
  setMessage(‘Logout successful’);
};</pre></li>				<li class="calibre15">Your <code>AuthContext</code> is nearly complete—the only thing left is to inform the context that it needs to provide the previously defined functions. So, modify the <code>return</code> statement to include everything:<pre class="source-code">
return ( &lt;
  AuthContext.Provider value = {
    {
      user,
      jwt,
      register,
      login,
      logout,
      message,
      setMessage
    }
  } &gt; {
    children
  } &lt;
  /AuthContext.Provider&gt;
);</pre></li>				<li class="calibre15">As a final touch, add a <code>useContext</code> React hook that facilitates working with contexts:<pre class="source-code">
export const useAuth = () =&gt; useContext(AuthContext);</pre><p class="list-inset">This simple one-line hook allows you to now use <code>AuthContext</code> in any component that has access to the context—so any component wrapped inside <code>AuthContext</code>—with some simple ES6 destructuring. With your <code>AuthContext</code> now in place, you can put it directly in the <code>App.jsx</code> component and wrap it around all the other components. </p></li>				<li class="calibre15">Open the <code>App.jsx</code> file and edit it:<pre class="source-code">
import { AuthProvider } from “./AuthContext”;
const App = () =&gt; {
  return (
    &lt;div className=”bg-blue-200 flex flex-col justify-center items-center min-h-screen”&gt;
      &lt;AuthProvider&gt;
        &lt;h1 className=”text-2xl text-blue-800”&gt; Simple Auth App &lt;/h1&gt;
      &lt;/AuthProvider&gt;{“ “}
    &lt;/div&gt;
  );
};
export default App</pre><p class="list-inset">This root component doesn’t contain anything that you haven’t seen already—apart from importing <code>AuthProvider</code>—the component of your custom authentication context responsible for wrapping the area of components and a bit of Tailwind styles.</p></li>				<li class="calibre15">Now comes the part where you will define the components that will be wrapped inside the context – as those components will be able to consume the context, have access to the context data, and modify it. For a bit more complex application, you would likely resort to the React Router package, but since this will be a very simple application, you will cram all the components into one page. There aren’t many of them:<ul class="calibre19"><li class="calibre15"><code>login()</code> function from the context.</li><li class="calibre15"><strong class="bold" lang="en-US" xml:lang="en-US">Register</strong>: Similar to the login component, but for registering new users.</li><li class="calibre15"><strong class="bold">Message</strong>: The simplest component, used only to display the status of the app.</li><li class="calibre15"><strong class="bold">Users</strong>: The component whose state depends on the authentication status: if the user is logged in, they can see the list of users, meaning the JWT is present and valid; otherwise, the user is prompted to make a login.</li></ul></li>
				<li class="calibre15">The <code>Register</code> component will be used for user registration. It needs to display a form. Create the <code>Register.jsx</code> file in the <code>/src</code> folder and create a simple form with two fields:<pre class="source-code">
import { useState } from ‘react’;
import { useAuth } from ‘./AuthContext’;
const Register = () =&gt; {
    const [username, setUsername] = useState(‘’);
    const [password, setPassword] = useState(‘’);
    const { register } = useAuth();
    const handleSubmit = (e) =&gt; {
        e.preventDefault();
        register(username, password)
        setUsername(‘’)
        setPassword(‘’)
    };
    return (
        &lt;div className=”m-5 p-5  border-2”&gt;
            &lt;form onSubmit={handleSubmit} className=’grid grid-rows-3 gap-2’&gt;
                &lt;input
                    type=”text”
                    placeholder=”Username”
                    className=’p-2’
                    value={username}
                    onChange={(e) =&gt; setUsername(e.target.value)}
                /&gt;
                &lt;input
                    type=”password”
                    placeholder=”Password”
                    className=’p-2’
                    value={password}
                    onChange={(e) =&gt; setPassword(e.target.value)}
                /&gt;
                &lt;button type=”submit” className=’bg-blue-500 text-white rounded’&gt;Register&lt;/button&gt;
            &lt;/form&gt;
        &lt;/div&gt;
    );
};
export default Register</pre><p class="list-inset">You have just created a React-specific form with the help of two local state variables that take care of keeping track and sending the username and password to your FastAPI instance. The <code>register</code> function is imported from <code>AuthContext</code> through the <code>useAuth()</code> hook. That line really shows how easy it is to work with the context from within the wrapped components. </p><p class="list-inset">Finally, <code>handleSubmit</code> performs the call to the <code>register</code> function, clears the fields, and prevents the default HTML form behavior. </p></li>				<li class="calibre15">Create the <code>Login.jsx</code> file, which is nearly identical (and here you could practice your React skills and perform some refactoring). The component has a login form that will be used for logging in:<pre class="source-code">
import { useState } from ‘react’;
import { useAuth } from ‘./AuthContext’;
const Login = () =&gt; {
    const [username, setUsername] = useState(‘’);
    const [password, setPassword] = useState(‘’);
    const { login } = useAuth();
    const handleSubmit = (e) =&gt; {
        e.preventDefault();
        login(username, password);
        setUsername(‘’);
        setPassword(‘’);
    };
    return (
        &lt;div className=”m-5 p-5  border-2”&gt;
            &lt;form onSubmit={handleSubmit} className=’grid grid-rows-3 gap-2’&gt;
                &lt;input
                    type=”text”
                    placeholder=”Username”
                    className=’p-2’
                    value={username}
                    onChange={(e) =&gt; setUsername(e.target.value)}
                /&gt;
                &lt;input
                    type=”password”
                    placeholder=”Password”
                    className=’p-2’
                    value={password}
                    onChange={(e) =&gt; setPassword(e.target.value)}
                /&gt;
                &lt;button type=”submit” className=’bg-blue-500 text-white rounded’&gt;Login&lt;/button&gt;
            &lt;/form&gt;
        &lt;/div&gt;
    );
};
export default Login</pre></li>				<li class="calibre15">There are two components left to be inserted in your simple auth application powered by FastAPI and React. First, create the <code>src/Message.jsx</code> component, which will be used to display the status message:<pre class="source-code">
import { useAuth } from “./AuthContext”
const Message = () =&gt; {
    const { message } = useAuth()
    return (
        &lt;div className=”p-2 my-2”&gt;
            &lt;p&gt;{message}&lt;/p&gt;
        &lt;/div&gt;
    )
}
export default Message</pre><p class="list-inset">The <code>Messages</code> component reads the message state variable from the context and displays it to the users. </p></li>				<li class="calibre15">Now, you can finally create the <code>src/Users.jsx</code> component and edit it:<pre class="source-code">
import { useEffect, useState } from ‘react’;
import { useAuth } from ‘./AuthContext’;
const Users = () =&gt; {
    const { jwt, logout } = useAuth();
    const [users, setUsers] = useState(null);
    useEffect(() =&gt; {
        const fetchUsers = async () =&gt; {
            const response = await fetch(‘http://127.0.0.1:8000/users/list’, {
                headers: {
                    Authorization: `Bearer ${jwt}`,
                },
            });
            const data = await response.json();
            setUsers(data.users);
        };
        if (jwt) {
            fetchUsers();
        }
    }, [jwt]);
    if (!jwt) return &lt;div&gt;Please log in to see all the users&lt;/div&gt;;
    return (
        &lt;div&gt;
            {users ? (
                &lt;div className=’flex flex-col’&gt;
                    &lt;h1&gt;The list of users&lt;/h1&gt;
                    &lt;ol&gt;
                        {users.map((user) =&gt; (
                            &lt;li key={user.id}&gt;{user.username}&lt;/li&gt;
                        ))}
                    &lt;/ol&gt;
                    &lt;button onClick={logout} className=’bg-blue-500 text-white rounded’&gt;Logout&lt;/button&gt;
                &lt;/div&gt;
            ) : (
                &lt;p&gt;Loading...&lt;/p&gt;
            )}
        &lt;/div&gt;
    );
};
export default Users;</pre><p class="list-inset">This component does a bit of heavy lifting compared to the others. It imports <code>jwt</code> (along with the <code>logout</code> function) from the context. This is important since the output of the <code>Users.jsx</code> component depends entirely on the existence and validity of the JWT.</p><p class="list-inset">After declaring a local state variable—<code>users</code>—the component uses the <code>useEffect</code> React hook to perform a call to the REST API, and since the <code>/users/list</code> endpoint is protected, the JWT token needs to be present and valid.</p><p class="list-inset">If the call to the <code>/users/list</code> endpoint is successful, the retrieved users data is sent to the <code>users</code> variable and displayed. Finally, if there is no <code>jwt</code> in the context, the user is asked to perform a login and the <code>logout</code> function from the context.</p></li>				<li class="calibre15">Finally, to tie everything together, replace the <code>App.jsx</code> file with the following code to import the components, and finalize the root component:<pre class="source-code">
import { useState } from ‘react’;
import { AuthProvider } from ‘./AuthContext’;
import Register from ‘./Register’;
import Login from ‘./Login’;
import Users from ‘./Users’;
import Message from ‘./Message’;
const App = () =&gt; {
  const [showLogin, setShowLogin] = useState(true)
  return (
    &lt;div className=’bg-blue-200 flex flex-col justify-center items-center min-h-screen’&gt;
      &lt;AuthProvider&gt;
        &lt;h1 className=’text-2xl text-blue-800’&gt;Simple Auth App&lt;/h1&gt;
        &lt;Message /&gt;
        {showLogin ? &lt;Login /&gt; : &lt;Register /&gt;}
        &lt;button onClick={() =&gt; setShowLogin(!showLogin)}&gt;{showLogin ? ‘Register’ : ‘Login’}&lt;/button&gt;
        &lt;hr /&gt;
        &lt;Users /&gt;
      &lt;/AuthProvider&gt;
    &lt;/div&gt;
  );
};
export default App;</pre></li>			</ol>
			<p class="calibre5">Now, you’ll be able to test the application—try registering, logging in, entering invalid data, and so on. You have created a very simple but complete full stack authentication solution. In the next section, you will learn about some methods of persisting the login data.</p>
			<h2 id="_idParaDest-107" class="about-the-author"><a id="_idTextAnchor115" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Persisting authentication data with localStorage</h2>
			<p class="calibre5">As mentioned before, the most developer-friendly option for persisting authentication is the use of <code>localStorage</code> or <code>sessionStorage</code>. <code>localStorage</code> becomes very useful when it comes to storing temporary, local data. It is widely used for tasks such as remembering shopping cart data or user login on any website where security is not paramount. <code>localStorage</code> has a higher storage limit than cookies (5 MB versus 4 KB) and does not get sent with every HTTP request. This makes it a better choice for client-side storage.</p>
			<p class="calibre5">To use <code>localStorage</code>, you can set and get JSON items using the <code>setItem()</code> and <code>getItem()</code> methods, respectively. One important thing to remember is that <code>localStorage</code> only stores strings, so you will need to use <code>JSON.stringify()</code> and <code>JSON.parse()</code> to convert between JavaScript objects and strings.</p>
			<p class="calibre5">Armed with this knowledge, try to summarize what the app requirements are – you want the user to be able to refresh or close and reopen the application window/tab and remain logged in if they were logged in, in the first place. Translated into React language, you need a <code>useEffect</code> hook that will run and verify whether there is a token stored in <code>localStorage</code>. If it is present, you want to check this token through the FastAPI <code>/me</code> endpoint and set the username accordingly:</p>
			<ol class="calibre14">
				<li class="calibre15">Open the existing <code>AuthContext.jsx</code> file, and after the <code>useState</code> hook, define the <code>useEffect</code> call:<pre class="source-code">
    export const AuthProvider = ({ children }) =&gt; {
    const [user, setUser] = useState(null);
    const [jwt, setJwt] = useState(null);
    const [message, setMessage] = useState(null);
    useEffect(() =&gt; {
        
        const storedJwt = localStorage.getItem(‘jwt’);
        if (storedJwt) {
            setJwt(storedJwt);
            fetch(‘http://127.0.0.1:8000/users/me’, {
                headers: {
                    Authorization: `Bearer ${storedJwt}`,
                },
            })
                .then(res =&gt; res.json())
                .then(data =&gt; {
                    if (data.username) {
                        setUser({ username: data.username });
                        setMessage(`Welcome back, ${data.username}!`);
                    }
                })
                .catch(() =&gt; {
                    localStorage.removeItem(‘jwt’);
                });
        }
    }, []);</pre><p class="list-inset">The bulk of your persistence logic is located in the <code>useEffect</code> call. First, you can try to get the <code>jwt</code> token from <code>localStorage</code> and then use that token to get the user data from the <code>/me</code> route. If the username is found, it is set in the context and the user is (already) logged in. If not, you clear <code>localStorage</code> or send a message that the token has expired (in the <code>Users.jsx</code> component).</p></li>				<li class="calibre15">The <code>login()</code> function also has to be modified in order to take account of <code>localStorage</code>. In the same <code>AuthContext.jsx</code>, modify the <code>login()</code> function:<pre class="source-code">
const login = async (username,
  password) =&gt; {
    <strong class="bold">setJwt(null)</strong>
    const response = await fetch(
      ‘http://127.0.0.1:8000/users/login’, {
        method: ‘POST’,
        headers: {
          ‘Content-Type’: ‘application/json’,
        },
        body: JSON.stringify({
          username,
          password
        }),
      });
    if (response.ok) {
      const data = await response
        .json();
      setJwt(data.token);
<strong class="bold">      localStorage.setItem(‘jwt’, data.token);</strong>
      setUser({
        username
      });
      setMessage(
        `Login successful: token ${data.token.slice(0, 10)}..., user ${username}`
        );
    } else {
      const data = await response
        .json();
      setMessage(‘Login failed: ‘ +
        data.detail);
      setUser({
        username: null
      });
    }
  };</pre><p class="list-inset">The only modification involves setting the new JWT to the <code>localStorage</code> <code>jwt</code> variable. Hence, the <code>logout()</code> function will also need to clear <code>localstorage</code>.</p></li>				<li class="calibre15">In the same <code>AuthContext.jsx</code> file, modify the <code>logout</code> function:<pre class="source-code">
const logout = () =&gt; {
    setUser(null);
    setJwt(‘’);
    localStorage .removeItem(‘jwt’);
    setMessage(‘Logout successful’);
};</pre></li>				<li class="calibre15">Finally, in order to make your application even more explicit and informative, open the <code>Users.jsx</code> component and replace it with the following code:<pre class="source-code">
import { useEffect, useState } from ‘react’;
import { useAuth } from ‘./AuthContext’;
const Users = () =&gt; {
    const { jwt, logout } = useAuth();
    const [users, setUsers] = useState(null);
    const [error, setError] = useState(null);
    useEffect(() =&gt; {
        const fetchUsers = async () =&gt; {
            const response = await fetch(‘http://127.0.0.1:8000/users/list’, {
                headers: {
                    Authorization: `Bearer ${jwt}`,
                },
            });
            const data = await response.json();
            if (!response.ok) {
                setError(data.detail);
            }
            setUsers(data.users);
        };
        if (jwt) {
            fetchUsers();
        }
    }, [jwt]);
    if (!jwt) return &lt;div&gt;Please log in to see all the users&lt;/div&gt;;
    return (
        &lt;div&gt;
            {users ? (
                &lt;div className=’flex flex-col’&gt;
                    &lt;h1&gt;The list of users&lt;/h1&gt;
                    &lt;ol&gt;
                        {users.map((user) =&gt; (
                            &lt;li className=’’ key={user.id}&gt;{user.username}&lt;/li&gt;
                        ))}
                    &lt;/ol&gt;
                    &lt;button onClick={logout} className=’bg-blue-500 text-white rounded’&gt;Logout&lt;/button&gt;
                &lt;/div&gt;
            ) : (
                &lt;p&gt;{error}&lt;/p&gt;
            )}
        &lt;/div&gt;
    );
};
export default Users;</pre></li>			</ol>
			<p class="calibre5">The app is now able to persist the logged-in user, retrieve the stored JWT, and restore the previous authentication state. Before trying to log in, make sure that the FastAPI backend is working properly on port <code>8000</code>.</p>
			<p class="calibre5">Try logging in, refreshing the browser, closing the tab, and reopening it.</p>
			<p class="calibre5">You can also try this with the token inside the <strong class="bold">Application</strong> tab in the developer toolbar of Chrome or Firefox and see what happens if you tamper with it or delete it.</p>
			<h2 id="_idParaDest-108" class="about-the-author"><a id="_idTextAnchor116" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Other authentication solutions</h2>
			<p class="calibre5">It is important to emphasize again that the <code>localStorage</code> for instance, but keeping in mind the specificities of both solutions.</p>
			<p class="calibre5">Finally, it is important to get acquainted with the various third-party authentication options. <strong class="bold">Firebase</strong> and <strong class="bold">Supabase</strong> are popular database and authentication services that can be used solely for managing users and authenticating them. <strong class="bold">Clerk</strong> and <strong class="bold">Kinde</strong> are newer players in the field and are particularly geared toward the React/Next.js/Remix.js ecosystem, while <strong class="bold">Auth0</strong> and <strong class="bold">Cognito</strong> are industry-standard solutions. Almost all third-party authentication systems offer a generous free or almost-free tier, but once your application grows, you are bound to hit a paid tier, and the costs vary and replacing these services, should the need arise, is not easy.</p>
			<h1 id="_idParaDest-109" class="contributor"><a id="_idTextAnchor117" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Summary</h1>
			<p class="calibre5">In this chapter, you’ve seen a very basic, but quite representative, implementation of two versions of an authentication mechanism. You learned how FastAPI enables the use of standard-compliant authentication methods and implemented one of the simplest possible yet effective solutions – without persisting the authentication data and storing the <code>localStorage</code>.</p>
			<p class="calibre5">You have learned how elegant and flexible FastAPI is when it comes to defining granular roles and permissions, especially with MongoDB, with the aid of <strong class="bold">Pydantic</strong> as the middleman. This chapter was focused exclusively on <strong class="bold">JWTs</strong> as the means of communication because it is the primary and most popular tool in SPAs nowadays, and it enables great connectivity between services or microservices. <strong class="bold">JWT</strong> mechanisms shine when you need to develop different applications with the same FastAPI and MongoDB-powered backend—for instance, a React web application and a React Native or Flutter-based mobile app.</p>
			<p class="calibre5">Furthermore, carefully considering your authentication and authorization strategy is crucial, especially when extracting user data from third-party systems may not be feasible or practical. This highlights the importance of devising robust authentication and authorization methods. </p>
			<p class="calibre5">In the next chapter, you will create a more complex FastAPI backend, with image uploading through a third-party service and use a MongoDB database for persistance.</p>
		</div>
	</div>
</div>
</body></html>