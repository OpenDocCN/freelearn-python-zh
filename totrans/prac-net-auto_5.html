<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Ansible for Network Automation</h1>
                </header>
            
            <article>
                
<p class="mce-root">In this chapter, we will see the use of a popular network automation tool called <strong>Ansible</strong>. This chapter will guide you through the basics of Ansible, including installation and basic configurations, and will give examples of how to perform tasks related to network automation from Ansible.</p>
<p>This will cover various terminologies and concepts used in Ansible, examples, executions using Ansible, some use cases like using Ansible to create configurations for various devices based upon the templates, and how to fetch some information about the managed nodes from Ansible.</p>
<p>This chapter will introduce readers to:</p>
<ul>
<li>Overview and installation of Ansible</li>
<li>Understanding programming concepts of Ansible</li>
<li>Playbooks</li>
<li>Use case scenarios for Ansible</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Ansible overview and terminology</h1>
                </header>
            
            <article>
                
<p>Ansible is an automation tool or platform, which is available as open source, and used to configure devices such as routers, switches, and various types of servers. Ansible's primary purpose is to configure three main type of tasks:</p>
<ul>
<li><strong>Configuration management</strong>:<strong> </strong>This is used to fetch and push configs on various devices that we call as inventory in Ansible. Based upon the type of inventory, Ansible is capable of pushing in bulk specific or full configs.</li>
<li><strong>Application deployment</strong>: In server scenarios, many a time we need to bulk deploy some specific applications or patches. Ansible takes care of that as well as bulk uploading patches or applications on the server, installing on them, and even configuring the applications of a particular task. Ansible can also take care of customizing settings based upon the devices in the inventory.</li>
<li><strong>Task automation</strong>:<strong> </strong>This is a feature of Ansible that performs a certain written task on a single device or a group of devices. The tasks can be written and Ansible can be configured to run those tasks once or on a periodic basis.</li>
</ul>
<p><span>Another powerful feature of Ansible is IT or infrastructure orchestration. To explain this in detail, let us say we need to code upgrade certain routers or network devices. Ansible can perform sequential steps to isolate the particular router, push code, update code, and then move on to next router based upon the return values of the previous result or task.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Basic requirements of Ansible</h1>
                </header>
            
            <article>
                
<p>Ansible is very easy to install and set up. It works on a controller and managed nodes model. In this model, Ansible is installed on a controller, which is a Linux server, and has access to all the inventory or nodes that we want to manage. As we have seen, Ansible is supported on Linux (there is a beta version out there for the Windows controller but it's not yet fully supported), and it relies on the SSH protocol to communicate with nodes. So, apart from the configuration of the controller, we need to ensure the nodes that are going to be managed are SSH capable.</p>
<p>There is an additional requirement of Python being installed on the managed nodes, since multiple Ansible modules are written in Python and Ansible copies the module locally to the client and executes it from the node itself. In servers running Linux this is already met, however, in network devices such as Cisco IOS, this might not be a possibility as Python is not available on the Cisco node.</p>
<p>To overcome this limitation, there is something called a <strong>raw module</strong> that executes raw commands, like <kbd>show version</kbd> to fetch the output from the Cisco device. This might not help a lot, but there is another way in which Ansible can be made to run its modules on the server itself, rather than executing those modules on the client (or managed node). This ensures that modules use the resources of the Ansible server (including Python), and they can call the SSH or HTTP APIs of Cisco vendors to perform tasks that are configured locally on the server. Even SNMP can also be used for devices that don't have a good set of APIs (such as Cisco IOS), to perform our tasks.</p>
<p>As we have seen earlier, SNMP can be used in both read and write mode, so using Ansible and running the module locally, we can even configure old IOS devices with the assistance of the SNMP protocol.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Installation of Ansible</h1>
                </header>
            
            <article>
                
<p>An Ansible controller (the main component that manages the nodes), is supported on multiple flavors of Linux, but it cannot be installed on Windows.</p>
<p>For managed nodes, the core requirement is anything with Python 2.6 and above. Additionally, since Ansible uses SSH to communicate with managed nodes, the node must be able to be accessed from SSH. For any file transfers, the default is <strong>SSH File Transfer Protocol</strong> (<strong>SFTP</strong>), but there is always an option to use <kbd>scp</kbd> for the default file transfer protocol. This being said, as mentioned earlier, if Python installation is not possible, then we would be using the raw modules of Ansible running from the server itself.</p>
<p>Going back to controller machine installation, Python 2 (2.6 or above) needs to be installed. In our case, we are using Ubuntu as our OS, hence our focus would be on working with Ansible using Ubuntu as the underlying OS. A way of installing Ansible is to use the <strong><span class="em emphasis">Advanced Packaging Tool</span></strong><span> (</span><strong>APT)</strong><strong> </strong>in Ubuntu. The following commands will configure the <strong>Personal Package Archives</strong> (<strong>PPA</strong>) and install Ansible.</p>
<p>Here are the basic commands, in the same order they are needed for the installation of Ansible:</p>
<pre><strong>$ sudo apt-get update<br/></strong><strong>$ sudo apt-get install software-properties-common<br/></strong><strong>$ sudo apt-add-repository ppa:ansible/ansible<br/></strong><strong>$ sudo apt-get update<br/></strong><strong>$ sudo apt-get install ansible</strong></pre>
<p>In our case Ansible is already installed. Here is a sample output that we get if we run the command <kbd>sudo apt-get install ansible</kbd> again. In this case if there is a new update available, Ansible will upgrade to the latest version, otherwise it would exit out of the command stating that we already have the newest version as shown in the following screenshot):</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/fb447213-d5c2-4b9b-aa1b-cb2b5d1f0cf6.jpg" style="width:34.00em;height:10.58em;"/></div>
<p>Another way of installing Ansible is by using our well known Python library installation command <kbd>pip</kbd>. The command for this will be:</p>
<pre style="padding-left: 30px"><strong>pip install --user ansible</strong></pre>
<p>Once the installation is done, here is the information about the folder:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/bd2d10a2-4cc7-4e6f-b815-e4dc5a5da243.jpg" style="width:30.75em;height:11.08em;"/></div>
<p class="mce-root">The <kbd>hosts</kbd> file is the inventory file where we add our managed nodes to be controlled by Ansible. <kbd>ansible.cfg</kbd> is the actual configuration file used to tweak Ansible parameters. Once the installation is done, we need to add some nodes in the <kbd>hosts</kbd> file. In our case as a fresh installation, we need to add our localhost (<kbd>127.0.0.1</kbd>). This node is accessible from SSH with the username <kbd>abhishek</kbd> and password <kbd>abhishek</kbd>.</p>
<p class="mce-root">Here is a sample output of our <kbd>/etc/hosts</kbd> file:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/16bde62c-2b2b-48eb-9992-18fa4d9ca766.jpg" style="width:38.75em;height:37.83em;"/></div>
<div class="packt_infobox">The line <kbd>127.0.0.1 ansible_connection=ssh ansible_user=abhishek ansible_ssh_pass=abhishek</kbd> is where we specify the parameters that are needed to access this system.</div>
<p>We can use any text editor (in our case we are using nano or the vi editor) to add or modify the changes to these files. To modify the <kbd>hosts</kbd> file, we use the following command:</p>
<pre><strong>$ sudo nano /etc/ansible/hosts</strong></pre>
<p>The next step is to verify the accessibility/reachability of the nodes that we added into the <kbd>hosts</kbd><strong> </strong>file, which can be done using the <span><kbd>ansible all -m ping</kbd> </span>command as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-268 image-border" src="assets/5482103c-42cc-4457-94fa-95b4de76817a.jpg" style="width:36.00em;height:14.25em;"/></div>
<p>As we can see in the previous screenshot, the command <kbd>ansible all -m ping</kbd> pings all the configured nodes in the <kbd>hosts</kbd> file and responds with a ping. Additionally, in the same output, if we use the command <kbd>ansible all -m ping --ask-pass</kbd>, this asks for a password to be accessed for that particular node. In our case, we give the password, and then we get the response back. Now, you might ask: <em>I am performing a simple ping, so what is the need for SSH now in this case?</em></p>
<p>Let us add the global DNS server (<kbd>4.2.2.2</kbd>) in our <kbd>hosts</kbd> file and then test it as shown in the following screenshot. As mentioned earlier, we invoke the nano editor using <kbd>sudo nano /etc/ansible/hosts</kbd>:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/ac3d933a-f7c7-45d5-a3b3-5c594f8c81e9.jpg" style="width:48.08em;height:34.33em;"/></div>
<p>Once done, we try to perform the same ping test again:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/53c964ee-87e5-45c1-ba1e-2be7637bbb15.jpg" style="width:54.25em;height:19.25em;"/></div>
<p>What do we see now? Even though I can easily <kbd>ping 4.2.2.2</kbd> from my machine, Ansible returns the value of <kbd>false</kbd>, since Ansible first tries to log in to the device using SSH and then tries to ping the IP. In this case, <kbd>4.2.2.2</kbd> SSH is not open, and we get a failure message for that specific IP address from Ansible. Additionally, we can group the managed objects under a specific name, such as <kbd>routers</kbd>, <kbd>switches</kbd>, <kbd>servers</kbd>, or whatever name we like in the <kbd>hosts</kbd> file.</p>
<p>Consider the following example:</p>
<p>We group our current IPs (localhost and <kbd>4.2.2.2</kbd>) under a new group, <kbd>myrouters</kbd>. We go back and modify the file <kbd>/etc/ansible/hosts</kbd> for this:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/e7c34eda-17f5-41cc-b2a9-f4f2c18e3b06.jpg" style="width:36.08em;height:24.75em;"/></div>
<p>Notice the addition of the <kbd>myrouters</kbd> group in the file. Once we save it, let's now use the group to perform a ping task:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/2ab16961-f8e7-44fe-b046-59b6b9581fd8.jpg" style="width:57.75em;height:17.17em;"/></div>
<p>As we see now, instead of pinging all, we just ping the group <kbd>myrouters</kbd>, which in our case is the loopback IP and <kbd>4.2.2.2</kbd>.</p>
<p>Of course, results will be the same as earlier, but now we have the added flexibility of ensuring that we perform our tasks based upon either individual nodes or a group of nodes under a specific name.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction to ad hoc commands</h1>
                </header>
            
            <article>
                
<p class="mce-root"><strong>Ad hoc</strong> commands in Ansible are used to perform tasks or operations that are needed on an ad hoc basis or only once based upon the requirement. In other words, these are tasks that a user wants to be performed on the fly but doesn’t want to be saved for later use. A quick example of an use case for Ansible ad hoc commands could be to quickly fetch the version information of the group of managed nodes for some other use as a one time task. As this is a quick information need and does not need to be repeated, we would use an ad hoc task to perform this request.</p>
<p class="mce-root">As we proceed with the chapter, there will be some additional switches (extra options that we pass to Ansible commands), that would be introduced based upon the requirements. Invoking the <kbd>ansible</kbd> command only will produce all the values that can be passed as options or parameters:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/454c0042-2085-4353-8e49-d7e5c25029d4.jpg" style="width:55.17em;height:35.08em;"/></div>
<p class="mce-root">Some examples of ad-hoc commands are as follows:</p>
<ol>
<li class="mce-root"><strong> </strong>Let us say we need to ping the same set of devices, but now in parallel (the default is sequential but to make tasks faster, we would use parallelism in our approach):</li>
</ol>
<pre style="padding-left: 90px" class="mce-root"><strong>ansible myrouters -m ping -f 5</strong></pre>
<ol start="2">
<li>If we want use a separate <kbd>username</kbd> instead of the default configured one:</li>
</ol>
<pre style="padding-left: 90px" class="mce-root"><strong>ansible myrouters -m ping -f 5 -u &lt;username&gt;</strong></pre>
<ol start="3">
<li>If we want to enhance the session (or use <kbd>sudo</kbd> or <kbd>root</kbd>):</li>
</ol>
<pre style="padding-left: 90px" class="mce-root"><strong>ansible myrouters -m ping -f 5 -u username --become -k (-k will ask for password)</strong></pre>
<p style="padding-left: 60px" class="mce-root">For a separate username, we use the <kbd>--become-user switch</kbd><span>.</span></p>
<ol start="4">
<li>For executing a specific command, we use the <kbd>-a</kbd><strong> </strong><span>option (Let us say we want to fetch the <kbd>show version</kbd> of the routers in <kbd>myrouters</kbd> list in a parallel method ):</span></li>
</ol>
<pre style="padding-left: 90px" class="mce-root"><strong>ansible myrouters -a "show version" -f 5</strong> </pre>
<p style="padding-left: 60px" class="mce-root">The <kbd>5</kbd> is the default value for number of parallel threads, but to change this value again, we can modify it in the Ansible configuration file.</p>
<ol start="5">
<li>Another example is to copy a file from source to destination. Let us say we need to copy a file from the current source to multiple servers that are under, let's say, the <kbd>servers</kbd> group:</li>
</ol>
<pre style="padding-left: 90px" class="mce-root"><strong>ansible servers -m copy -a "src=/home/user1/myfile.txt dest=/tmp/myfile.txt"</strong></pre>
<ol start="6">
<li>We want to start the <kbd>httpd</kbd> on the web servers:</li>
</ol>
<pre style="padding-left: 90px" class="mce-root"><strong>ansible mywebservers -m service -a "name=httpd state=started"</strong></pre>
<p style="padding-left: 60px" class="mce-root">In reverse, if we want to stop the <kbd>httpd</kbd>:</p>
<pre style="padding-left: 90px" class="mce-root"><strong>ansible mywebservers -m service -a "name=httpd state=stopped"</strong></pre>
<ol start="7">
<li class="mce-root">As another important example to look at, let us say we want to run a long running command like <kbd>show tech-support</kbd>, but do not want to wait for it in the foreground. We can specify a timeout (600 seconds in our case) for this:</li>
</ol>
<pre style="padding-left: 90px" class="mce-root"><strong>ansible servers -B 600 -m -a "show tech-support"</strong></pre>
<p style="padding-left: 60px" class="mce-root">This would return a <kbd>jobid</kbd> that can be referred later on for the update. Once we have the <kbd>jobid</kbd>, we can check the status of that particular <kbd>jobid</kbd> using the command given as follows:</p>
<pre style="padding-left: 90px" class="mce-root"><strong>ansible servers -m async_status -a "jobid"</strong></pre>
<ol start="8">
<li>There is an additional command that provides all the information about a particular node that Ansible can fetch and work upon:</li>
</ol>
<pre style="padding-left: 90px" class="mce-root"><strong>ansible localhost -m setup |more</strong> </pre>
<p style="padding-left: 60px" class="mce-root">The output to view the facts on the local machine (localhost) is as follows:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/80a11e09-4efb-4d5a-989f-98b6949e92b2.jpg" style="width:32.17em;height:44.25em;"/></div>
<ol start="9">
<li>Another ad hoc command that is commonly used is the <kbd>shell</kbd> command. This is used to control the overall OS, or shell, or root scenarios. Let us see an example to reboot the managed nodes in the <kbd>servers</kbd> group:</li>
</ol>
<pre style="padding-left: 90px"><strong>ansible servers -m shell -a "reboot"</strong></pre>
<p style="padding-left: 60px">If we want to shut down the same set of servers instead of reboot:</p>
<pre style="padding-left: 90px"><strong>ansible servers -m shell -a "shutdown"</strong></pre>
<p class="mce-root">This way, we can ensure that using the ad hoc task we can quickly perform basic tasks on individual or groups of managed nodes to quickly get results.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Ansible playbooks</h1>
                </header>
            
            <article>
                
<p>Playbooks are simply a set of instructions that we create for Ansible to configure, deploy, and manage the nodes. These act as guidelines, using Ansible to perform a certain set of tasks on individuals or groups. Think of Ansible as your drawing book, playbooks as your colors, and managed nodes as the picture. Taking that example, playbooks ensure what color needs to be added to which part of the picture, and the Ansible framework performs the task of executing the playbook for the managed nodes.</p>
<p>Playbooks are written in a basic text language referred to as <strong>YAML Ain't Markup Langu</strong><span><strong>age</strong> (<strong>YAML</strong>).</span> Playbooks consist of configurations to perform certain tasks on managed nodes. Additionally, playbooks are used to defined a workflow in which, based upon conditions (like different type of devices or different type of OS), specific tasks can be executed, and validations can be performed based upon the results retrieved from task executions. It also combines multiple tasks (and configuration steps in each task) and can execute those tasks sequentially, or in parallel against selective or all managed nodes.</p>
<div class="packt_tip packt_infobox">Good information about YAML can be referenced here:<br/>
<a href="https://learn.getgrav.org/advanced/yaml">https://learn.getgrav.org/advanced/yaml</a> </div>
<div>
<p>At a basic level a playbook consists of multiple <strong>plays</strong> in a list. Each play is written to perform certain Ansible tasks (or a collection of commands to be executed) on a certain group of managed nodes (for example <kbd>myrouters</kbd>, or <kbd>servers</kbd>).</p>
</div>
<p class="mce-root">From the Ansible website, here is a sample playbook:</p>
<pre><span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">hosts</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">webservers</span>
  <span class="l l-Scalar l-Scalar-Plain">vars</span><span class="p p-Indicator">:</span>
    <span class="l l-Scalar l-Scalar-Plain">http_port</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">80</span>
    <span class="l l-Scalar l-Scalar-Plain">max_clients</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">200</span>
  <span class="l l-Scalar l-Scalar-Plain">remote_user</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">root</span>
  <span class="l l-Scalar l-Scalar-Plain">tasks</span><span class="p p-Indicator">:</span>
  <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">name</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">test connection</span>
    ping:</pre>
<div class="wy-grid-for-nav">
<div class="wy-nav-content">
<div class="rst-content">
<p>In this example, there are certain sections that we need to understand:</p>
<ol>
<li><kbd>hosts</kbd>: This lists the group or managed nodes (in this case <kbd>webservers</kbd>), or individual nodes separated by a space.</li>
<li><kbd>vars</kbd>: This is the declaration section where we can define variables, similar to how we define them in any other programming language. In this case <kbd>http_port: 80</kbd> means the value of <kbd>80</kbd> is assigned to the <kbd>http_port</kbd> variable.</li>
<li><kbd>tasks</kbd>: This is the actual declaration section on what task needs to be performed on the group (or managed nodes) that was defined under the <kbd>- hosts</kbd> section.</li>
<li><kbd>name</kbd>: This <span>denotes the remark line used to identify a particular task.</span></li>
</ol>
<p class="highlight"><span>Using this example, let us create our playbook to ping our managed nodes in earlier examples:</span></p>
</div>
</div>
</div>
<pre><span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">hosts</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">myrouters</span>
  <span class="l l-Scalar l-Scalar-Plain">vars</span><span class="p p-Indicator">:</span>
    <span class="l l-Scalar l-Scalar-Plain">http_port</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">80</span>
    <span class="l l-Scalar l-Scalar-Plain">max_clients</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">200</span>
  <span class="l l-Scalar l-Scalar-Plain">remote_user</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">root</span>
  <span class="l l-Scalar l-Scalar-Plain">tasks</span><span class="p p-Indicator">:</span>
  <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">name</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">test connection</span>
    ping:</pre>
<p>To create the config, we type:</p>
<pre><strong>nano checkme.yml</strong></pre>
<p>In the editor, we copy and paste the previous code, and save it. For execution , we can use the <kbd>--check</kbd> parameter. This ensures that on the remote systems, if there is a change intended to be performed in the playbook, it will be simulated locally and not actually executed on the remote systems:</p>
<pre class="mce-root"><strong>ansible-playbook checkme.yml --check<br/></strong></pre>
<p>The output for execution of the preceding given command is as follows:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/be0c2000-33c0-4fbc-944e-e33ffe1a8869.jpg" style="width:41.50em;height:13.75em;"/></div>
<p>As we see in the preceding output, a simulation of our playbook <kbd>checkme.yml</kbd> was performed and the results were displayed in the <kbd>PLAY RECAP</kbd> section. </p>
<p>Another example is if we want to call specific tasks based upon our initial results. In Ansible, we use <kbd>handlers</kbd> to perform that task.  In a play, we create a task that can perform <kbd>notify</kbd> actions based upon any changes from that task. These actions are triggered after all the tasks are completed through a handler. In other words, after all the tasks in a play are completed, <span>only</span><span> </span><span>then will the <kbd>handlers</kbd> condition be triggered (for example, rebooting a server if all the configuration tasks are completed).</span></p>
<p>Handlers are simply another type of tasks, but referenced by a globally unique name and executed only when called by <kbd>notify</kbd>:</p>
<pre>- hosts: myrouters<br/>tasks:<br/> - name: show uptime<br/>   command: echo "this task will show uptime of all hosts"<br/>   notify: "show device uptime"<br/>handlers:<br/> - name: show variables<br/>   shell: uptime<br/>   listen: "show device uptime"</pre>
<p>As we can see in the preceding example, the task is executed on <kbd>myrouters</kbd>, which calls <kbd>notify</kbd> to perform a handler task. The <kbd>-name</kbd> in <kbd>handlers</kbd> depicts the handler name that the task will be calling.</p>
<div class="mce-root packt_infobox">Ansible is case-sensitive (for example: two variables named <kbd>x</kbd> and <kbd>X</kbd> will be different).</div>
<p>Once the notified handler is called, the <kbd>shell: uptime</kbd> <span>command</span><span> </span><span>will run the <kbd>uptime</kbd> command on the remote shell and fetch the output to be displayed. The <kbd>listen</kbd> command under a <kbd>handlers</kbd> section is also an alternate or a more generic way of calling the specific handler. In this case, the <kbd>notify</kbd> section can call the specific handler under <kbd>handlers</kbd> , which matches the</span> <kbd>listen</kbd> <span>declaration with the <kbd>notify</kbd> declaration  (for example, in our case <kbd>notify : "show device uptime"</kbd> will call the specific handler that is listening to the command</span> <kbd>show device uptime</kbd><span>, which in this case is defined by <kbd>-name</kbd> as show variables) , instead of calling the  <kbd>- name</kbd> declaration under <kbd>handlers</kbd> that we currently see in config.</span></p>
<p>The Ansible playbook (<kbd>showenv.yml</kbd> in this case) needs to be invoked with a <kbd>-v</kbd> switch to see the <kbd>verbose</kbd> output where verbose output is an output where we can see all the activities as they are happening by execution rather than just displaying only the final result).</p>
<ul>
<li>The output without the <kbd>-v</kbd> command(v<span>erbose output is not enabled) </span>is as follows:</li>
</ul>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/d76689bc-28a2-4f10-9f0f-9a2950368ac8.jpg" style="width:63.00em;height:18.67em;"/></div>
<ul>
<li>The output with the <kbd>-v</kbd> command (verbose output is enabled) is as follows:</li>
</ul>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/7bfe0a44-f4f5-410c-85b8-51a1d4376e04.jpg" style="width:69.17em;height:17.17em;"/></div>
<p>In the preceding screenshot, notice the output of the <kbd>uptime</kbd> command in playbook execution (from the preceding screenshot, <kbd>changed: [127.0.0.1] =&gt; {"changed": true, "cmd": "uptime", "delta":"</kbd>) . The verbose output states the output and the command that was executed (in this case <kbd>uptime</kbd>), with the values fetched for the managed nodes.</p>
<p class="mce-root">In many cases, if we have created multiple playbooks and want to run them in a master playbook, we can import the created playbooks:</p>
<pre><span class="p p-Indicator">#example<br/>-</span> <span class="l l-Scalar l-Scalar-Plain">import_playbook</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">myroutercheck.yml</span>
<span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">import_playbook</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">myserver.yml<br/></span></pre>
<p>If we explicitly import certain tasks from a <kbd>.yml</kbd> file:</p>
<pre><span class="c1"># mytask.yml</span>
<span class="nn">---</span>
<span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">name</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">uptime</span>
  shell: uptime</pre>
<p>Looking at the configuration inside <kbd>main.yml</kbd>:</p>
<pre><span class="l l-Scalar l-Scalar-Plain">tasks</span><span class="p p-Indicator">:</span>
<span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">import_tasks</span><span class="p p-Indicator">:</span> mytask<span class="l l-Scalar l-Scalar-Plain">.yml</span>
<span class="c1"># or</span>
<span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">include_tasks</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">mytask.yml</span></pre>
<p>Similarly, we can call handlers from another <kbd>.yml</kbd> file:</p>
<pre><span class="c1"># extrahandler.yml</span>
<span class="nn">---</span>
<span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">name</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">show uptime</span>
  shell: uptime    </pre>
<p>In the configuration of <kbd>main.yml</kbd>:</p>
<pre><span class="l l-Scalar l-Scalar-Plain">handlers</span><span class="p p-Indicator">:</span>
<span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">include_tasks</span><span class="p p-Indicator">: </span><span class="c1">extrahandler.yml<br/></span><span class="c1"># or</span> <br/><span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">import_tasks</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">extrahandler.yml</span></pre>
<p>Additionally when we define variables in Ansible, there are some considerations that we need to keep in mind. Variables cannot have special characters (except underscores) or spaces in between two characters or words and should not start with a number or special character.</p>
<p>For example:</p>
<ul>
<li><kbd>check_me</kbd> and <kbd>check123</kbd> are good variables</li>
<li><kbd>check-me</kbd>, <kbd>check me</kbd>, and <kbd>check.me</kbd> are invalid variables</li>
</ul>
<p>In YAML, we can create dictionaries using the colon approach:</p>
<pre><span class="l l-Scalar l-Scalar-Plain">myname</span><span class="p p-Indicator">:</span>
  <span class="l l-Scalar l-Scalar-Plain">name</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">checkme</span>
  <span class="l l-Scalar l-Scalar-Plain">age</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">30</span></pre>
<p>To reference or retrieve any values from this dictionary created with the name <kbd>myname</kbd>, we would specify command like: <kbd>myname['name']</kbd> or  <kbd>myname.name</kbd><strong>.</strong></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Working with Ansible facts</h1>
                </header>
            
            <article>
                
<p>As we saw earlier, we can gather facts about a managed node using the following command:</p>
<pre><strong>ansible &lt;hostname&gt; -m setup</strong></pre>
<p>For example:</p>
<pre><strong>ansible localhost -m setup</strong></pre>
<p>Now, as we get the values back (called <strong>facts</strong>), we can refer to those system variables. Each system variable will hold a unique value based upon each of the managed node that was called under the <kbd>hosts</kbd> section:</p>
<pre><span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">hosts</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">myrouters</span>
  <span class="l l-Scalar l-Scalar-Plain">vars</span><span class="p p-Indicator">:</span>
      <span class="l l-Scalar l-Scalar-Plain">mypath</span><span class="p p-Indicator">:</span> "<span class="cp">{{</span> <span class="nv">base_path</span> <span class="cp">}}</span><span class="l l-Scalar l-Scalar-Plain">/etc"</span></pre>
<p>The system variables can be called using the <kbd>{{variable name}}</kbd>, but in a playbook, they need to be referenced with double quotes.</p>
<p>Let us see an example where we get the value of <kbd>hostname</kbd> in our playbook:</p>
<pre>- hosts: myrouters<br/>  tasks: <br/>   - debug:<br/>       msg: "System {{ inventory_hostname }} has hostname as {{ ansible_nodename }}"</pre>
<p>The output of the playbook to fetch the hostname:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/989916fc-e94d-4b15-bdd9-c0c06247db6e.jpg" style="width:50.75em;height:18.17em;"/></div>
<p>As we can see, in the playbook (in the preceding code),  we referred to the <kbd>{{inventory_hostname}}</kbd> and <kbd>{{ansible_nodename}}</kbd> <span>variables,</span><span> which results in the output in the <kbd>msg</kbd> section:</span> <kbd>System 127.0.0.1 has host hostname as ubuntutest</kbd><span>. Using the same playbook configuration , we can use all or any of the other facts that were retrieved by replacing the system variables in the configuration.</span></p>
<div class="packt_tip">If we want to get additional information from inside the facts, we can refer to the specific values within square brackets:<br/>
<kbd>{{ ansible_eth0.ipv4.address }}</kbd> or <kbd>{{ ansible_eth0["ipv4"]["address"] }}</kbd>.</div>
<p class="mce-root">We can also pass the variable using the command line to the playbook, as in this example:</p>
<pre>- hosts: "{{hosts}}"<br/>  tasks: <br/>   - debug:<br/>       msg: "Hello {{user}}, System {{ inventory_hostname }} has hostname as {{ ansible_nodename }}"</pre>
<p>The execution command to execute the playbook with passing variables:</p>
<pre><strong>ansible-playbook gethosts.yml --extra-vars "hosts=myrouters user=Abhishek"</strong></pre>
<p>The output of the command with variables provided during command line execution:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/8c914523-202e-426d-8227-bf1ec8ef724d.jpg" style="width:46.25em;height:15.67em;"/></div>
<p>As we see, the value of <kbd>myrouters</kbd><strong> </strong>was passed to <kbd>hosts</kbd> and the value of <kbd>Abhishek</kbd><strong> </strong>was passed to the <kbd>user</kbd> variable. As we see in output of the playbook execution, the <kbd>msg</kbd> variable output contains the value of the <kbd>user</kbd> variable and the IP address of the host(s) configured in the <kbd>myrouters</kbd> group (In this case, the single host is part of this group with the IP address <kbd>127.0.0.1</kbd>).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Ansible conditions</h1>
                </header>
            
            <article>
                
<p>There are times when we want to execute certain tasks based upon the conditions. <kbd>when</kbd> statement is used to determine those conditions and execute the specified task if the condition evaluates to true. Let us take an example to execute the <kbd>uptime</kbd> command, if we pass the parameter clock to the variable clock:</p>
<pre>- hosts: myrouters<br/> tasks: <br/> - shell: uptime<br/> - debug:<br/> msg: "This is clock condition" <br/> when: clock == "clock"<br/> <br/> - debug: <br/> msg: "This is NOT a clock condition"<br/> when: clock != "clock"<br/> </pre>
<p><strong>Execution from command line</strong>: With and incorrect value <kbd>clock123</kbd> being passed to <kbd>clock</kbd> variable):</p>
<pre><strong>ansible-playbook checkif.yml --extra-vars "clock=clock123"</strong></pre>
<p>The output of the execution with incorrect values provided:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/cb9088bc-4481-41b0-821d-5a5323f1ee6a.jpg" style="width:43.00em;height:19.92em;"/></div>
<p>As we see in preceding output, the message <kbd>This is NOT a clock condition</kbd> is executed based upon the value that we passed. Similarly, if we pass the clock variable shown as follows:</p>
<pre><strong>ansible-playbook checkif.yml --extra-vars "clock=clock"</strong></pre>
<p>The output with correct variable values passed from command line:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/fce7b487-e622-46e8-85e2-58a5c28b945a.jpg" style="width:43.58em;height:20.58em;"/></div>
<p>The message <kbd>This is clock condition</kbd> is now executed based upon the parameter passed. Looking at another example, in a similar way, we can ensure that based upon a certain fact, we can take some action:</p>
<pre>- hosts: myrouters<br/>  tasks: <br/>   - shell: uptime<br/>   - debug:<br/>       msg: "This is clock condition on Ubuntu" <br/>     when: <br/>      - clock == "clock"<br/>      - ansible_distribution == "Ubuntu"<br/>   <br/>   - debug: <br/>       msg: "This is clock condition on Red HAT"<br/>     when: <br/>      - clock = "clock" <br/>      - ansible_distribution == "Red Hat"<br/><br/></pre>
<p>As we see, the condition is triggered on the <kbd>ansible_distribution</kbd> <span>fact</span><span>. If the response is Ubuntu, then the first condition is executed, otherwise, based upon <kbd>Red Hat</kbd>, the other condition is executed. </span>Additionally, we are also validating if the clock value is <kbd>clock</kbd>, when the playbook is being called from command line with <kbd>clock</kbd> as the variable passed to the playbook. In the previous code, both the conditions need to be evaluated to true if we want to get that particular result.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Ansible loops</h1>
                </header>
            
            <article>
                
<p>We can loop for repetitive operations using <kbd>with_items</kbd><strong>. </strong>Let us see an example where we parse the list and print the values:</p>
<pre>---<br/>- hosts : all<br/> vars:<br/> - test: Server<br/>tasks:<br/> - debug: <br/> msg: "{{ test }} {{ item }}" <br/> with_items: [ 0, 2, 4, 6, 8, 10 ]</pre>
<p>The output of the playbook execution using the preceding code:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/eb971bc1-f997-4bce-8c72-1a99b659f49d.jpg" style="width:41.17em;height:30.42em;"/></div>
<p>As we can see in the preceding screenshot, the iteration prints the value of <kbd>Server</kbd> plus the item value in the list for each item in the list. Similarly, for an integer iteration we can perform a loop using the <kbd>with_sequence</kbd><strong> </strong>command:</p>
<pre>---<br/>- hosts : all<br/> vars:<br/> - test: Server<br/>tasks:<br/> - debug: <br/> msg: "{{ test }} {{ item }}" <br/> with_sequence: count=10</pre>
<p>Additionally, let us say we want to print values skipping 2 (even numbers from 0 to 10), the same <kbd>with_sequence</kbd> command will be written as:</p>
<pre>with_sequence: start=0 end=10 stride=2</pre>
<p>Sometimes, we also need to pick any random value for performing specific task. The following sample code picks a random value from the 4 options available (in our case, <kbd>Choice Random 1</kbd> till <kbd>Choice Random 4</kbd>) and displays it using <kbd>msg</kbd> variable:</p>
<pre>---<br/>- hosts : all<br/> vars:<br/> - test: Server<br/>tasks:<br/> - debug: <br/> msg: "{{ test }} {{ item }}" <br/> with_random_choice:<br/>    - "Choice Random 1"<br/>    - "Choice Random 2"<br/>    - "Choice Random 3"<br/>    - "Choice Random 4"</pre>
<p>This will pick any random value from the list from the given options under the <kbd>with_random_choice</kbd> declaration.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Python API with Ansible</h1>
                </header>
            
            <article>
                
<p class="mce-root">Ansible code can be called using Python, using the Ansible API. Ansible has released version 2.0 of its API for better integration with programming languages. One important aspect to note is that Ansible has extended its capability to support development using Python, but it also suggests on its website that, based upon its own discretion, it can also stop supporting the API (creating or even bug fixing its current API version) framework.</p>
<p>Let us see an example of creating a play with the task of seeing the username from our earlier inventory of <kbd>myrouters</kbd>:</p>
<pre>#call libraries<br/>import json<br/>from collections import namedtuple<br/>from ansible.parsing.dataloader import DataLoader<br/>from ansible.vars.manager import VariableManager<br/>from ansible.inventory.manager import InventoryManager<br/>from ansible.playbook.play import Play<br/>from ansible.executor.task_queue_manager import TaskQueueManager<br/>from ansible.plugins.callback import CallbackBase<br/><br/>Options = namedtuple('Options', ['connection', 'module_path', 'forks', 'become', 'become_method', 'become_user', 'check', 'diff'])<br/><br/># initialize objects<br/>loader = DataLoader()<br/>options = Options(connection='local', module_path='', forks=100, become=None, become_method=None, become_user=None, check=False,<br/>                  diff=False)<br/>passwords = dict(vault_pass='secret')<br/><br/># create inventory<br/>inventory = InventoryManager(loader=loader, sources=['/etc/ansible/hosts'])<br/>variable_manager = VariableManager(loader=loader, inventory=inventory)<br/><br/># create play with task<br/>play_source = dict(<br/>        name = "mypythoncheck",<br/>        hosts = 'myrouters',<br/>        gather_facts = 'no',<br/>        tasks = [<br/>            dict(action=dict(module='shell', args='hostname'), register='shell_out'),<br/>            dict(action=dict(module='debug', args=dict(msg='{{shell_out.stdout}}')))<br/>         ]<br/>    )<br/>play = Play().load(play_source, variable_manager=variable_manager, loader=loader)<br/><br/># execution<br/>task = None<br/>try:<br/>    task = TaskQueueManager(<br/>              inventory=inventory,<br/>              variable_manager=variable_manager,<br/>              loader=loader,<br/>              options=options,<br/>              passwords=passwords,<br/>              stdout_callback='default'<br/>          )<br/>    result = task.run(play)<br/>finally:<br/>    if task is not None:<br/>        task.cleanup()</pre>
<p>In the preceding <span>code for displaying the username from managed nodes</span><span>:</span></p>
<ol>
<li><kbd>'#call libraries'</kbd>: These are used to initialize the available Ansible API libraries. Some of the important ones are:
<ul>
<li><kbd>from ansible.parsing.dataloader import DataLoader</kbd>: This is used for loading or parsing a YAML or JSON format file or value if called</li>
<li><kbd>from ansible.vars import VariableManager</kbd>: This is used for inventory file location</li>
<li><kbd>from ansible.inventory.manager import InventoryManager</kbd>: This is used for inventory initialization</li>
<li><kbd>from ansible.playbook.play import Play</kbd>: This is used for configuring a play</li>
<li><kbd>from ansible.executor.task_queue_manager import TaskQueueManager</kbd>: This is used for actual execution of the configured play</li>
</ul>
</li>
<li><kbd># initialize objects</kbd>: This section initializes the various components, such as the root user, <kbd>become_user</kbd> (if any) and other parameters required to run the play.</li>
<li><kbd># create inventory</kbd>: This is where we specify the actual inventory location and initialize it.</li>
<li><kbd># create play with task</kbd>:  This is where we create the task in a similar way that we create the <kbd>.yml</kbd> file. In this case, it is to show the hostname for all nodes in the <kbd>myrouters</kbd> section of the inventory.</li>
<li><kbd># execution</kbd>:<strong> </strong>This is the execution of the play that we created using the <kbd>run()</kbd> method of the task.</li>
</ol>
<p>The output of the preceding code is as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/13f8d60b-01d5-417f-82c7-377d1eed0484.jpg" style="width:40.75em;height:12.67em;"/></div>
<p>As we can see, after invoking the Python file, we got the hostname of the localhost defined under the <kbd>myrouters</kbd> inventory section in the <kbd>hosts</kbd> file (<kbd>/etc/ansible/hosts</kbd>).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating network configuration templates</h1>
                </header>
            
            <article>
                
<p>As we are now familiar with the basics of Ansible, let us look at an example in which we generate configs ready to be deployed for some routers. To start with, we need to understand roles in Ansible. <strong>Roles</strong> are used to create a file structure for Ansible playbooks. Based upon roles, we can group similar data. Sharing the roles with others would mean we share the entire defined file structure for a common set of content. A typical role file structure would contain the main folder and the content folder, and under the content folder, we would have <kbd>templates</kbd>, <kbd>vars</kbd>, and <kbd>tasks</kbd> folders.</p>
<p>In our case, the hierarchy is as follows:</p>
<ul>
<li>Main directory
<ul>
<li>-Roles
<ul>
<li>-Routers
<ul>
<li>-Templates</li>
<li>-Vars</li>
<li>-Tasks</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Under each of the templates, vars, or tasks folders, if we call that specific role, a file named <kbd>main.yml</kbd> is searched automatically and any configs in that file are taken into consideration for that particular role. Using the details of hierarchy as previously mentioned , in our test machine (running Ubuntu) here is how our file structure looks in the example:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/bbbcab9e-9683-484b-973b-b4df1e3f7dd4.jpg" style="width:28.17em;height:12.00em;"/></div>
<p>As we see, under the <kbd>rtrconfig</kbd> folder, we have defined the folders as per Ansible standards. Once we create the folder hierarchy, the next step is to configure/create the files under each of the sections, based upon our requirements.</p>
<p>To start with, as we will be using a router template to generate the configs, we create a template and put it in the <kbd>roles/routers/templates</kbd> folder.</p>
<p class="mce-root">Router config template is as follows (used as a generic router template to generate router configs):</p>
<pre class="mce-root">no service pad<br/> service tcp-keepalives-in<br/> service tcp-keepalives-out<br/> service password-encryption<br/> username test password test<br/> !<br/> hostname {{item.hostname}}<br/> logging server {{logging_server}}<br/> !<br/> logging buffered 32000<br/> no logging console<br/> !<br/> ip domain-lookup enable<br/> !<br/> exit</pre>
<p>As we can see in the template, <kbd>{{item.hostname}}</kbd> and <kbd>{{logging_server}}</kbd> are two values that we would replace while creating the actual config. As this is a Jinja template, we would save this template as <kbd>somename.j2</kbd> (in our case, <kbd>routers.j2</kbd>). The next step is to define the variable values.</p>
<p class="mce-root">As we saw earlier, we need to ensure that the <kbd>logging_server</kbd> variable has already been defined a value. This will be in the <kbd>roles/routers/vars</kbd> folder:</p>
<pre>---<br/>logging_server: 10.10.10.10</pre>
<p>We save this file as <kbd>main.yml</kbd> in the <kbd>vars</kbd> folder, which will be picked by default while executing the playbook for the variable value declarations. Once we have the definitions and template in place, the next step is to define the actual task that needs to be performed.</p>
<p>This will be done in the <kbd>roles/routers/tasks</kbd> folder and again saved as <kbd>main.yml</kbd> for auto discovery during the execution of that specific role.</p>
<p>Let us see the config for this:</p>
<pre>---<br/>- name: Generate configuration files<br/>  template: src=routers.j2 dest=/home/abhishek/{{item.hostname}}.txt<br/>  with_items: <br/>  - { hostname: myrouter1 }<br/>  - { hostname: myrouter2 }</pre>
<p>In the config for the task, we call the template that we created (in this case, <kbd>routers.j2</kbd>), and provide a destination folder where the config files will be saved (in this case, <kbd>/home/abhishek/{{item.hostname}}.txt</kbd>).</p>
<p>A specific point to note here is that <kbd>{{item.hostname}}</kbd> will resolve to each of the hostnames that we have provided using the <kbd>with_items</kbd> loop. As a result, the filename that will be generated will be each item defined in the <kbd>with_items</kbd> loop (in our case, <kbd>myrouter1.txt</kbd> and <kbd>myrouter2.txt</kbd>).</p>
<p>As mentioned previously, the <kbd>with_items</kbd> will loop with each value, with the hostname variable value being changed with each iteration. Once we have the template, vars, and task created, we will call the role in our main playbook and get it executed.</p>
<p>The main playbook config is as follows:</p>
<pre>---<br/>- name: Generate router configuration files<br/>  hosts: localhost<br/><br/>  roles:<br/>    - routers</pre>
<p>Here we just call the hosts (which is localhost in our case since we want to get this executed locally), and call the role that needs to be executed in the playbook (in our case, <kbd>routers</kbd>). We save it as any name with a <kbd>.yml</kbd> extension (in our case, <kbd>makeconfig.yml</kbd>).</p>
<p>The final validation to ensure all <kbd>.yml</kbd> files are created in respective folders are as follows:</p>
<ol>
<li><strong> </strong>To recap, here is the detailed file structure, as we now <span>see</span><span> </span><span>the files under the <kbd>rtrconfig</kbd> folder:</span></li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/3591c748-27ae-46b1-844f-f96a3220fcc7.jpg" style="width:37.50em;height:13.83em;"/></div>
<ol start="2">
<li>To generate the config for routers , we execute the <kbd>makeconfig.yml</kbd> playbook:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/21dc946b-6154-4f5c-b40f-35bc02cf3f21.jpg" style="width:47.17em;height:17.42em;"/></div>
<ol start="3">
<li>Once executed successfully, we should have two files (<kbd>myrouter1.txt</kbd> and <kbd>myrouter2.txt</kbd>) in the <kbd>/home/abhishek</kbd> folder with the generated config:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/f7019e1f-025f-441f-acf8-5ca2fb2d8ad4.jpg" style="width:46.50em;height:9.08em;"/></div>
<ol start="4">
<li>Here is the content from one of the generated files:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/187efb7c-51bc-49a7-af5a-4a275c9ad11e.jpg" style="width:35.58em;height:21.58em;"/></div>
<ol start="5">
<li>As we can see, now we have a generated config, using the template, with the values replaced for the hostname and <kbd>logging _server</kbd> section.</li>
</ol>
<p>The config is now generated and ready to be pushed on those particular routers (which were part of <kbd>main.yml</kbd> under <kbd>roles/routers/tasks</kbd>), and in a similar way, we can generate configs with various roles and multiple devices in each role, such as switches, routers, load balancers, and so on with each role containing specific information, such as variables, templates, and tasks relevant to that role.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we learned what Ansible <span>is</span><span>, its installation, and basic usage of Ansible. </span>This chapter also introduced concepts and terminology used in Ansible, with reference to how to create playbooks, tasks, and other basic functions in Ansible. We also got familar with ad-hoc commands and understand the concept of facts and their usage in Ansible.</p>
<p>Finally, using Jinja templates we understood how to create a full configuration using templates with reference to device/role specific information using roles in Ansible.</p>
<p>In the next chapter, we will see how to call miscellaneous other aspects of automation, such as using Splunk for syslog collection and fetching information from Python, working with basic automation on BGP, UC integration examples, and other relevant examples that can be used for ready reference when creating automation scripts.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    </body></html>