- en: 4 Ingesting HTTP Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next building block in application development involves **data**. Without
    data, the Web has little utility. I do not mean to get too philosophical here,
    but it is axiomatic that the purpose of the Internet is the facilitation of the
    transfer of data and knowledge from one location to another. It is therefore critical
    to our development as web professionals to learn how data can be transferred not
    just *from* our applications (which we deal with in *Chapter 5,* *Handling and
    Responding Views*), but also *to* our applications (which is the purpose of this
    chapter). The simplest applications we can build simply provide data. But to become
    interactive web applications participating in the global exchange of knowledge,
    even simple applications must be capable of extracting data from web requests.
  prefs: []
  type: TYPE_NORMAL
- en: A web application that receives no data is like a screencast. Viewers can come
    to watch the presentation, but the presenter has no *personal* connection to the
    people watching. During the COVID-19 global pandemic, I was fortunate enough to
    still be able to participate in several Python conventions. Much applause is due
    the volunteers that pushed forward to present the community with a continuation
    of the sharing and learning atmosphere that exists with technology conferences.
    However, I would be remiss to point out that as a presenter, I had zero connection
    to my audience. It was not until after the presentation was done that I even knew
    how many people watched my content.
  prefs: []
  type: TYPE_NORMAL
- en: This model can be useful to disperse information to those that need to intake
    information from it. However, the transaction is entirely one-sided. My presentations
    could not adjust based upon cues from the audience, and even during chat or Q&A
    sessions, there was an interpersonal experience that was missing. In much the
    same way, a web application that receives no data operates under a similar principal.
    The server has no knowledge about who is listening and cannot alter its behavior
    or content based upon user input. These types of applications are purely for dissemination
    of data and resources only.
  prefs: []
  type: TYPE_NORMAL
- en: Web APIs of this kind generally only have `GET` methods since they exist entirely
    to spit back information. They can be useful for relaying information about weather,
    flight details, or other centralized repositories of information that many people
    might want to access.
  prefs: []
  type: TYPE_NORMAL
- en: To build a truly interactive API, we need it to operate not like a screencast,
    but more like a video chat. Both sides of the conversation will participate in
    the passing of information back and forth. And it is this bi-directional communication
    that we will explore in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you will recall from our earlier discussions, there are three main sections
    in the raw HTTP request: **the first line**, **the HTTP headers**, and **the body**.
    So far, we have focused on intaking HTTP requests as they relate to the HTTP method
    and the path: information that both appear in that first line of the HTTP request.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn about how we can get data from the client from
    all three sections. Data can be passed to a web server in query arguments, headers,
    and of course the body itself. Therefore, in this chapter we will explore:'
  prefs: []
  type: TYPE_NORMAL
- en: Extracting data from cookies and headers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using data from query arguments, uploaded files, and JSON data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validating the data is received as expected
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this chapter you should have the same tools available as in the previous
    Chapters at your disposal in order to be able to follow along with the examples
    (IDE, modern Python, and curl). You can access source code for this chapter on
    GitHub: [https://github.com/PacktPublishing/Web-Development-with-Sanic/tree/main/chapters/04](https://github.com/PacktPublishing/Web-Development-with-Sanic/tree/main/chapters/04).'
  prefs: []
  type: TYPE_NORMAL
- en: Reading cookies and headers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we have seen throughout the earlier chapters of this book, when any HTTP
    client sends a request to a web server, it includes one or more headers that are
    in a key/value pair. These headers are meant to be part of a meta-conversation
    between the client and the server. And since a HTTP connection is a two-sided
    transaction with both a request and a response, we must keep in mind that there
    is a distinction between request headers and response headers.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter still focuses on the HTTP request only. Therefore, we will only
    be covering material as related to request headers. This is worth pointing out
    because there are some headers that are commonly found in both the request and
    the response. One such example is *Content-Type*, which can be used by both HTTP
    requests and HTTP responses. So, for example, keep in mind when we talk about
    *Content-Type* in this section, it relates to HTTP requests only. There is a time
    and a place for discussing response headers. Feel free to skip ahead, or to read
    this section in conjunction with *Chapter 5, Handling and Responding Views* where
    we will discuss the other side of the same coin.
  prefs: []
  type: TYPE_NORMAL
- en: Headers are flexible
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: HTTP headers are not magic. There is no predefined, finite list of header names.
    Furthermore, deviating from what is considered *standard* will have no impact
    on your application. Remember back when we discussed HTTP methods, we said that
    you could invent your own methods? Well, you have that control and ability to
    create your own *headers* as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'This practice is actually encouraged and commonplace. Are you familiar with
    **Cloudflare**? In short, Cloudflare is a popular tool used as a proxy for web
    applications. We will discuss proxies further in *Chapter 8, Running a Server*.
    The idea is simple: Cloudflare runs a web server, a request comes into their server,
    they do *something* to it, and then bundle that up and send the request on to
    your server. When they do that, they include their own set of non-standard headers.
    For example, they will forward the request to you with `CF-Connection-IP` and
    `CF-IPCountry` headers to give you some helpful information about the IP address
    and the location of its origin.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s imagine that we are building an API to be used by a farmer’s market.
    They want to setup a web API that will help coordinate among the various participants
    in the market: farmers, restaurant owners, and consumers. The first endpoint we
    want to build will be used to provide information about the market stalls for
    a given day:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The response content from this endpoint does not require authentication (more
    on that later), but really ought to be tailored to each of the types of users.
    A farmer might want to know how many stalls are available. Consumers and restaurant
    owners instead might be more interested in knowing the kinds of products that
    will be available. We, therefore, have identified at least two different use cases
    for the same endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option might be to split this single endpoint into two: `/stalls/<market_date:ymd>/availability`
    `/stalls/<market_date:ymd>/products`'
  prefs: []
  type: TYPE_NORMAL
- en: However, this does add some complexity to the overall API design. Furthermore,
    `availability` and `products` as used in this context are not really resources
    in and of themselves. To give them their own endpoint sort of muddies the water
    of the structure of our API so far.
  prefs: []
  type: TYPE_NORMAL
- en: What we are really saying is that we have a single resource—the collection of
    market stalls for a given day of the year—and we simply want to present those
    resources in different ways based upon the participant type. It really is only
    one endpoint with two different ways of displaying the same information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perhaps instead of two different endpoints, a second option might be to use
    query parameters (more on those later in this Chapter in the section on *Query
    arguments*). That would look like this: `/stalls/<market_date:ymd>?participant=farmer`
    and `/stalls/<market_date:ymd>?participant=consumer`. This also sort of breaks
    the paradigm of query parameters—or at least the way I like to use them—which
    are typically meant to be used for filtering and sorting results.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, we will opt for creating a custom header for our use case: `Participant-Type:
    farmer`. We will also create an Enum to help us validate and limit the acceptable
    participants:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: When the request comes in, the handler will try and read the header expecting
    there to be a valid `ParticipantType` object. If there is no `Participant-Type`
    header, or the passed value is an unknown type, we will simply fall back to `ParticipantType.UNKNOWN`.
  prefs: []
  type: TYPE_NORMAL
- en: '**IMPORTANT NOTE**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: As you can see in this example, the `request.headers.get("participant-type")`
    is in lower case. It really does not matter. It could be upper case, lower case,
    or a mix. All headers will be read as case-insensitive keys. So, even though the
    `request.headers` object is a `dict`, it is a special kind of dictionary that
    does not care about case. It is a convention only to use lowercase letters when
    retrieving headers from Sanic. Feel free to do what makes sense to you. I would,
    however, just caution you to try and stay consistent throughout a project. It
    can be confusing if sometimes you see `headers.get("Content-Type")` and other
    times `headers.get("content-type")`.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**TIP**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Enums are great. You should really use them everywhere you can. While using
    them for validation like here may not be their most obvious use case, they are
    super helpful when needing to pass around some types of constants. Imagine needing
    to remember deep inside the bowels of your application: is it *restaurant-owner*,
    *restaurant_owner*, or *restaurant*? Using enums helps reduce bugs, provides a
    single place to maintain and update, and can provide you with code completion
    if your IDE supports it. You will see me use enums in a variety of ways in this
    book. Next to `asyncio`, the standard library `enum` package might just be one
    of my favorites.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Getting back to our example, we will now try and hit our endpoint with a few
    different examples to see how it responds with different headers.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will access the information with a known type pretending to be a farmer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we will leave out the header to see how the endpoint will respond to the
    absence of any type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we will hit the endpoint with some type we have not anticipated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have successfully implemented a custom HTTP header that can be used by our
    endpoint to decide how it will display and customize the output. This may be getting
    ahead of ourselves since we will cover middleware in *Chapter 6, Outside the response
    cycle*, but what if we want to reuse the `Participant-Type` header on other endpoints?
    Here is a quick showcase to make this universal to our entire application.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: By evaluating the header inside middleware, we can now place `participant_type`
    on the request object for easy access.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing that I would like to point out about this development example
    is the mindset towards testability. Notice how we identified three different potential
    uses of the endpoint: a known type, a lack of a type, and an unknown type. We
    will talk about testing in *Chapter 9*, *Best practices to improve your web applications*.
    As we continue working through this book, however, it is good to be reminded not
    only of how to work with Sanic, but the types of things we should be thinking
    about when we uncover a problem. Thinking ahead about how the application could
    be used helped us understand the types of use cases we might want to test for,
    and therefore the types of use cases that our application needs to handle.'
  prefs: []
  type: TYPE_NORMAL
- en: '**TIP**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'It is also worth pointing out that the `request.ctx` object is there for you
    to attach any information you want to it. This is really powerful to help pass
    information around and to abstract some logic to middleware as shown above. Keep
    in mind that this lasts only as long as the request lasts. After there is a response,
    anything on that `request.ctx` will be disposed of. There is also similar context
    for the entire lifespan of the application, and the lifespan of a single client
    connection. These are respectively: `app.ctx` and `request.conn_info.ctx`. Please
    see *Chapter 6, Outside the response cycle* for more information on these `ctx`
    objects.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Even though it is entirely possible to create your own set of headers—and indeed,
    I highly encourage it—there does exist a set of common headers that are standard
    among clients and servers. In the next sections, we will explore what some of
    those are.
  prefs: []
  type: TYPE_NORMAL
- en: Common headers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There is a set of predefined standard headers in RFC 2731, section 5\. [https://datatracker.ietf.org/doc/html/rfc7231#section-5](https://datatracker.ietf.org/doc/html/rfc7231#section-5).
    If you are so inclined, put the book down and go read that section. We’ll be waiting
    for you. If not, let’s try and pull out some highlights and some of the more important
    request headers that you should probably know about.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication headers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One of the primary mechanisms for authenticating web requests is through the
    use of headers. The other basic method is with cookies (which is technically also
    a header, but more on that later in the *Getting information from cookies (yum!)*
    section.) While there are certainly different types of authentication schemes
    (basic auth, JWT, and session tokens to name a few), they generally share the
    same construct: the use of the Authorization header.'
  prefs: []
  type: TYPE_NORMAL
- en: You may have just noticed something peculiar. We are talking about *authentication*,
    at least, that’s what the title of this section is called. But, we just said that
    the primary *authentication* header is called *Authorization*. How can this be?
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover more details about this in *Chapter 7, Dealing with Security
    Concerns* when we discuss access control more thoroughly, but it is worth mentioning
    the distinction, and the fundamental questions that these two related concepts
    are trying to answer:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Authentication**: Do I know who this person is?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Authorization**: Should I let them in?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A failure to authenticate results in a *401 Unauthorized* error message and
    a failure of authorization is a *403 Forbidden* error message. It is an unfortunate
    quirk of the history of the Internet that these terms are befuddled, and that
    they developed as they did. They are confusing and inconsistent.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, even though the header is called *Authorization*, and even though its failure
    should lead to an *Unauthorized* response, we are still exclusively talking about
    authentication and answering the question: *Do I know who this person is?*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Because Sanic does not take a stance about how you should build your application,
    we obviously have a lot of freedom in choosing how we want to consume the *Authorization*
    request header. Three main strategies come to mind here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Decorators**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Middleware**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Blueprints**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s look at these individually:'
  prefs: []
  type: TYPE_NORMAL
- en: Decorators
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s first look at an example using decorators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The core of this example is the inner `decorated_function`. This basically
    is saying: before running our actual handler (which is `f`), run `check_authentication`.
    This allows us the opportunity to execute code inside *the route* but before we
    get to the actual defined handler.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This decorator pattern is extremely common in Sanic. Not only for running checks,
    but also to inject arguments into our handler. If you are not using some form
    of decorators in your application, you are leaving some real power on the table.
    It is a useful way to duplicate logic across endpoints, and I highly recommend
    you get familiar and comfortable with using them. There is a very helpful starter
    example that can be found in the Sanic User guide: [https://sanicframework.org/en/guide/best-practices/decorators.html](https://sanicframework.org/en/guide/best-practices/decorators.html).'
  prefs: []
  type: TYPE_NORMAL
- en: '**TIP**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Notice the `handler=None` and the last return line?
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: def `authenticated(handler=None):`
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`...`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**return** `decorator(handler)` **if** `handler` **else** `decorator`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The reason we do this is because we are allowing for our decorator to be used
    in one of two ways: either via `@authenticated` or `@authenticated()`. You will
    have to decide which one (or whether both) is appropriate for your needs.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Middleware
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have seen how this works with decorators, how can we achieve the
    same logic with middleware? In the next example, we will try and achieve the same
    functionality that the decorator example provided, except using middleware:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The downside of this method is that we just now locked up our *entire* API!
    What about our `/stalls/<market_date:ymd>` endpoint, or even endpoints that are
    meant for logging in? One way to fix this is to check if the request has a matched
    `Route` instance (it should, unless we are responding to a *404 Not Found*), and
    if it does, make sure it is not one of the exempt routes. We can see an example
    of how to do that here by cross-referencing the name of the matched route with
    an express list of exempt endpoints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This time, in the middleware we are taking a look at the route’s name to see
    if it is one of the routes that we know should be safe.
  prefs: []
  type: TYPE_NORMAL
- en: '**IMPORTANT NOTE**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'As a quick aside—since we have not seen it before—all routes will have a *name*.
    You can of course name them manually:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: More likely than not, we can just let Sanic name our routes. It will by default
    use the handler function’s name, and then append it to our application name (and
    any blueprints) with dot notation. That is why we see `MyApp.login` and `MyApp.market_stalls`.
    They are presuming our application is called `MyApp`, and the handlers for our
    exempt endpoints are `login` and `market_stalls`, respectively.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*“Hang on a minute?! You want me to keep a list of names of exempt endpoints?
    That sounds like a nightmare to maintain!”* True. If you are handling only two
    items like this simple use case, it is probably manageable enough. But once we
    start really building out an application, this might start to get super unwieldy.
    Feel free to decide which of the two patterns makes more sense. Using decorators
    is much more explicit and clear. However, it does lead to more code repetition.
    The middleware alternative is much simpler to implement, and easier to audit to
    make sure that we are not forgetting to protect any routes. Its downside, however,
    is that it hides some functionality and would be harder to maintain if the list
    of *safe* endpoints grows. If you are in doubt about which makes sense for your
    needs, I would suggest the more explicit authentication decorators. This does,
    however, show that there usually are different ways to tackle the same problems.
    Coming back to the point of *Chapter 1*, *Introduction to Sanic and async frameworks*,
    if one of these solutions seems more *obviously* correct, then that likely is
    the one that you should use.'
  prefs: []
  type: TYPE_NORMAL
- en: Blueprints
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'And this is where our third solution comes in: our friend Blueprints again.
    This time, we are going to continue using middleware, but we are only going to
    apply the middleware to Blueprints that contain the protected endpoints.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Since we are placing the middleware on the `“protected” Blueprint`, it will
    only run on the routes that are attached to it. This leaves everything else open.
  prefs: []
  type: TYPE_NORMAL
- en: Context headers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These headers provide you with some information about the web browser where
    the request originated. Generally, they are useful in analytics and logging to
    provide some information about how your application is being used. We will examine
    some of the more common contextual headers.
  prefs: []
  type: TYPE_NORMAL
- en: '**Referer** This header contains the name of the page that directed the user
    to the current request. It is really helpful if you want to know from which page
    on your application an API request came from. If your API is not meant to be used
    by a browser, perhaps it is less important. Yes, it is misspelled. The Internet
    is not perfect. And now for a bit of trivia knowledge: RFC 1945 was published
    in 1996 as a specification of the HTTP/1.0 protocol. The team that published it
    included none other than Tim Berners-Lee (aka, the inventor of the World Wide
    Web). Section 10.13 introduced the `Referer` header, but it was inadvertently
    misspelled in the specification! Subsequent specifications and implementations
    have adopted this misspelling, and it has stuck with us for almost 30 years. If
    nothing else, it is a certain warning about the use of spell check. [https://datatracker.ietf.org/doc/html/rfc1945#section-10.13](https://datatracker.ietf.org/doc/html/rfc1945#section-10.13)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Origin** This header is similar to `Referer`. While the `Referer` will generally
    include the full path of where the request originated, the `Origin` header is
    just the URL usually in the form: `<scheme>://<hostname>:<port>` without the path.
    We will look into how we can use it to protect our application from CORS attacks
    in *Chapter 7*, *Dealing with Security Concerns*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User-Agent** This header is almost always sent by every HTTP client. It identifies
    the type of application that is accessing your API. Commonly it is a browser,
    but it could also be `curl`, a Python library, or a tool like Postman or Insomnia.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Host** Back in *Chapter 3*, *Routing and Intaking HTTP Requests* we saw how
    we could do host-based routing with *virtual hosts*. This is accomplished by reading
    the `Host` header. While `Origin` is the domain where the request is coming from,
    `Host` is where it is going to. Usually, we know this information ahead of time.
    Except, sometimes we have either a dynamic host (like a wildcard subdomain), or
    multiple domain pointing to one application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Forwarded headers** This encompasses both `Forwarded` and a bunch of `X-Forwarded-*
    headers`. Generally, when you see a header that starts with `X-` it means that
    it is a header that has come into common practice and usage, but its implementation
    is not necessarily standard.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are these headers? They contain details about the web request and are used
    by the intermediary proxies (like Nginx or Cloudflare) to pass along relevant
    details about the request. The most common is `X-Forwarded-For`. This is a list
    of all of the IP addresses from the originating request to the current server
    that handled the request (this is not the same as a traceroute). This is incredibly
    helpful and important when trying to identify a request by IP address.
  prefs: []
  type: TYPE_NORMAL
- en: '**IMPORTANT NOTE**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: As with *all* headers and input data, you should *NEVER* assume that incoming
    user data is accurate and harmless. It is very simple for someone to spoof headers.
    Just as always, we need to be cautious when reading headers and not just take
    them at face value.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Sanic extracts some header data for us
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sanic will automatically extract some information about the request from headers
    and place them on easily accessible attributes on the `Request` object. It makes
    them very helpful to get when needed. Below is a reference for some of the common
    attributes you might encounter.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Request Property** | **HTTP Header used to generate** |'
  prefs: []
  type: TYPE_TB
- en: '| `request.accept` | Accept |'
  prefs: []
  type: TYPE_TB
- en: '| `request.forwarded` | Forwarded |'
  prefs: []
  type: TYPE_TB
- en: '| `request.host` | Host |'
  prefs: []
  type: TYPE_TB
- en: '| `request.id` | X-Request-ID (can be configured |'
  prefs: []
  type: TYPE_TB
- en: '| `request.remote_addr` | Forwarded, or X-Forwarded-For (depends upon more
    configuration covered in *Chapter 11* , *A Complete Real-World Example* ) |'
  prefs: []
  type: TYPE_TB
- en: '| `request.token` | Authorization |'
  prefs: []
  type: TYPE_TB
- en: Table 4.1 - Extracted header data
  prefs: []
  type: TYPE_NORMAL
- en: '**TIP**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It sometimes may be confusing to know when to use `request.ip` and when to use
    `request.remote_addr`. The former property will always be set and will always
    return the IP address of the client that is connecting to it. This might not actually
    be what you want. If your application is behind a proxy server, and you need to
    rely upon `X-Forwarded-For`, then most likely the attribute you want is `request.remote_addr`.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Headers as multi-dict
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Headers are stored in Sanic as a multi-dict. This is a special data type that
    will operate both as a one-to-one key-to-value dictionary, and a one-to-many key-to-value
    dictionary. To illustrate the point, here are what those would typically look
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The Header object in Sanic functions as both of those simultaneously. Moreover,
    it looks at the keys as case insensitive. Did you notice in the last example that
    the keys are different cases? Using standard dictionaries, the following would
    be False.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: However, because the HTTP specification allows for HTTP headers to be case-insensitive,
    the Sanic `Header` object is also case-insensitive. But how does it handle the
    issue between one-to-one and one-to-many?
  prefs: []
  type: TYPE_NORMAL
- en: Again, the HTTP specification allows for multiple identical headers to be concatenated
    without overriding one another. Sanic opts for this special data type to be standards
    compliant. If you do nothing special and merely treat the `Header` object as a
    regular Python `dict` in your application, it will work just fine. You might not
    ever even notice that it is not a regular dictionary. However, you will only ever
    access the first value passed to it for each header. If you need to support multiple
    values for the same header, you are able to access the full *list* of values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Let’s now hit this endpoint with multiple `Fruit` headers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Using either square brackets or `.get()` method provides us with `apples` because
    that was the first `Fruit` header that was sent. A more explicit usage would be
    to use `.getone()`. Alternatively, we can use `.getall()` to return the full list
    of `Fruit` header values. Again, case does *not* matter for header keys. For values,
    however, it does. Notice how in our example `Fruit` became `fruit`, but `Bananas`
    did not change case at all.
  prefs: []
  type: TYPE_NORMAL
- en: Getting information from cookies (yum!)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Building a web application without cookies is like ending a meal without cookies.
    Sure, it could be done. But why would you want to? Given a choice, pick the cookies.
  prefs: []
  type: TYPE_NORMAL
- en: Jokes aside, cookies are obviously an extremely important topic to consider.
    They are the backbone of many of the rich user experiences of web applications.
    Cookies also are inherently full of potential security pitfalls. The security
    issues are generally more of a concern when we talk about setting cookies (*Chapter
    5*, *Handling and Responding Views*), and securing our web applications (*Chapter
    7*, *Dealing with Security Concerns*). Here, we are mainly interested in how to
    access cookies so that we can read the data from them.
  prefs: []
  type: TYPE_NORMAL
- en: 'A web cookie is a specialized HTTP header: `Cookie`. This header contains a
    structured set of data defined by RFC 6265, § 5.4\. [https://tools.ietf.org/html/rfc6265#section-5.4](https://tools.ietf.org/html/rfc6265#section-5.4).
    The incoming cookie from a request is treated in Sanic like a regular dictionary.'
  prefs: []
  type: TYPE_NORMAL
- en: In order to get an explicit look at how cookies are structured, setup a debug
    handler like this
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we will send some cookies using curl:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, the data is just a simple key/value dictionary. Accessing cookies
    should therefore be very straightforward. Like other forms of data, it is, of
    course, advisable to treat them with suspect. These values are not immune to tampering
    and can easily be spoofed. Nonetheless, they are an important part of the web,
    especially if your application needs to support a frontend UI.
  prefs: []
  type: TYPE_NORMAL
- en: While using cookies will be an invaluable source of data for your applications,
    the primary method for users to pass information will come in other forms. Next
    up, we look at those other methods for passing data from web client to web server.
  prefs: []
  type: TYPE_NORMAL
- en: Reading forms, query arguments, files, JSON, and more
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we know about pulling input from the path and from the headers, we
    will turn our attention to more classic types of passing input values. Typically,
    we think of request data as being those bits of information that come from the
    request body. Before we turn to the request body, however, we still have one more
    item in the first line of the HTTP request to examine: **Query arguments**.'
  prefs: []
  type: TYPE_NORMAL
- en: Query arguments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As a reminder, the first line of a HTTP request looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: If you have previous web experience, you may know that a URL can have a section
    of arbitrary parameters separated from the rest of the path by a question mark
    (`?`). These are known as query arguments (or parameters), follow in the form
    `key=value`, and are concatenated with an ampersand (`&`). Sometimes they are
    called parameters, sometimes arguments. We will call them arguments here, since
    this is what Sanic opts for to be able to distinguish them from path parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Query arguments are very simple to use, and we can get access to them on our
    request instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '**IMPORTANT INFO**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'You may have noticed my `curl` command included `\?` instead of just `?`. This
    is a necessary pattern in some command line applications since `?` itself could
    have a different meaning. It just as well could have been wrapped in quotes: `curl
    "localhost:7777?fruit=apples"`, but I prefer to leave off the quotes and opt for
    the character escaping.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Usage seems simple enough, right? Well, not so fast. The obvious next question
    is what happens when the key is repeated? Or, what happens when we want to past
    an array of data?
  prefs: []
  type: TYPE_NORMAL
- en: 'There is *no* single standard way to pass array data on the Internet inside
    query arguments. Several methods do exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '`?fruit[]=apples&fruit[]=bananas`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`?fruit=apples,bananas`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`?fruit=[apples,bananas]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`?fruit=apples&fruit=bananas`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first three approaches were rejected by Sanic, which has instead opted to
    implement the fourth option. A quick look at the three rejected models will explain
    why the chosen model makes sense, and how we can use it going forward.
  prefs: []
  type: TYPE_NORMAL
- en: First, `fruit[]` is a strange construct that is not obvious to newcomers, and
    actually is a hijacking and alteration of the key. Yuck, no thank you.
  prefs: []
  type: TYPE_NORMAL
- en: Second, `fruit=apples,bananas` seems nice, but what if we wanted to just pass
    a string `apples,bananas` and not actually separate them? Hmm, this does not seem
    possible. Pass.
  prefs: []
  type: TYPE_NORMAL
- en: Third, `fruit=[apples,bananas]` seems better, but it is again somewhat awkward
    and not intuitive. It also suffers the same ambiguity problem. Is `apples,bananas`
    a single string, or two items?
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, the second and third options suffer another problem about how to
    handle duplicate keys. Take the first? The last? Merge? Error? Again, there is
    no consensus and different servers handle this differently.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most reasonable approach seems to be the fourth, which can handle all of
    these problems. Keep it simple: we have a key and a value. Nothing more. If there
    are duplicate keys, we treat it as a list append. There are no surprising losses
    of data, no errors, and data integrity is maintained.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In our last example, we printed to the console the value of `request.args`.
    Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Wait?! A `list`? I thought it was a single value: `apples`. At least that is
    what the response gave us. Query arguments are a special dictionary that contains
    lists, but has a unique `.get()` that will fetch only the first value from that
    list. If you want all of the elements, use `.getlist().`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'When we hit this endpoint now, we can see what these values are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Another point worth mentioning is that `request.args` is not the only way to
    look at these key/value pairs. We also have `request.query_args`, which is just
    a list of tuples of all the pairs that were passed. The above request would look
    something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'A data structure such as this can, of course, easily be turned into a standard
    dictionary if desired. Just be careful because you will lose out on duplicate
    key data; being left only with the last of each duplicated key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Forms and files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By learning how we can pull data from the query arguments, we have inadvertently
    also learned how to get both form data and uploaded file data! That is because
    query arguments, forms, and files all operate identically. To prove it, we will
    setup a couple of endpoints like we have before and see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will test the form handler.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Just like before, we see that it looks like a dict with a list. Well, that’s
    because it is. But it will still behave like request.args. We can use .get() for
    a the first item, and .getlist() for all of them in a list.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: And, of course, we will see the same result with files.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We might want to take a closer look at this one to see what it is doing.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you upload a file to Sanic, it will convert that into a File object. The
    `File` object is really just a namedtuple containing the basic information about
    the file. If we do a `print(request.files.get("po"))`, we should see an object
    that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '**TIP**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Are you unfamiliar with namedtuples? They are a really great tool for modelling
    concise objects. I highly recommend using them since they behave as tuples, but
    have the convenience of having dot notation to access specific properties. They
    are great in place of dictionaries, as long as you do not need to modify their
    contents. This is why Sanic uses them here as file objects. It is a convenient
    small structure that is easy for us as developers to work with, while keeping
    some safety around the data so that it is not accidentally corrupted.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Consuming JSON data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Arguably the most important type of request data is JSON. Modern web applications
    have embraced and clung to serializing and transmitting data with JSON because
    of its simplicity. It supports basic types of scalar values, is easy for humans
    to read, and easy to implement and widely supported in many programming languages.
    It is no wonder that it is the default methodology.
  prefs: []
  type: TYPE_NORMAL
- en: 'It should therefore come as no surprise that Sanic makes it very easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We have now seen all of the typical ways to access data in a single request.
    Next up, we will learn about how data could alternatively be streamed to Sanic
    in multiple chunks.
  prefs: []
  type: TYPE_NORMAL
- en: Getting streaming data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The term **streaming** has become somewhat of a buzzword. Many people even outside
    the tech industry use it all the time. The word—and more specifically the actual
    technological concept that it represents—has become an important part of society
    as consumption of media content continues its march to the cloud. What exactly
    is streaming? For those that are not entirely clear what this term means, we will
    take a brief moment to understand it before moving on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Streaming is the act of sending data in multiple, consecutive chunks from one
    side of an open connection to the other. One of the core foundations of the HTTP
    model is that there is a request followed by a response after a connection is
    established between the client and server. The client sends a complete HTTP request
    message and then waits for the server to send back a complete HTTP response message.
    It looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 - Normal HTTP request/response cycle](img/file1.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 - Normal HTTP request/response cycle
  prefs: []
  type: TYPE_NORMAL
- en: I like to think of these as *finite* transactions. Both the request and the
    response have a definite and known endpoint. These finite requests are what we
    have been looking at up until now. A request comes in, the server does something
    to process it, and a response goes out. What is important to note is that both
    the request and the response are sent in whole in a single block.
  prefs: []
  type: TYPE_NORMAL
- en: 'One header that we did not discuss earlier is the `Content-Length` header.
    This header can be found on both requests and responses. The actual specification
    on when it *should* be sent versus when it *must* be sent is really beyond the
    scope of this discussion. Sanic will take care of providing this for us when necessary.
    I bring it up here because this header is exactly what it purports to be: the
    length of the content in a HTTP message. This tells the recipient that there is
    a message of a certain length that is being transmitted. And, it is important
    here because the known length of a message cannot necessarily be computed when
    the request headers are sent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'What happens if there is a large amount of data to be sent that might overwhelm
    a single connection, or the data being sent is not 100% available when the connection
    opens? Streaming is a methodology for one side of the connection to tell the other
    that it is transmitting some bytes, but it is not yet done. The connection should
    be held open so that more data can be sent. The way that this interaction happens
    is by replacing the `Content-Length` header with a `Transfer-Encoding: chunked`
    header. This is the way that one side of the connection can tell the other that
    it should continue to receive data until notified that the stream of data is closed.'
  prefs: []
  type: TYPE_NORMAL
- en: When most laypeople hear the term *streaming*, the immediate thought goes to
    streaming media, like movies or music. They might describe the concept as the
    consumption of the media before it is fully downloaded. And, this is correct.
    Streaming is the sending of data in multiple *chunks* instead of sending it all
    at once. This is extremely efficient and can reduce overall resource overhead.
    When supported, it allows the receiving side to start processing that data if
    it desires instead of blocking and waiting for it to be complete. So, when you
    go to watch your favorite movie, you can start watching it without waiting for
    the entire file to be downloaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'Streaming does not, however, only apply to media, and also is not only done
    by a server. There are two basic flavors we are concerned about: request streaming
    and response streaming. Here is what those flows look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 - HTTP streaming request](img/file2.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 - HTTP streaming request
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 4.2,* we see what a streaming request looks like. Once the HTTP connection
    is opened, the client starts sending data. But, it does not send the message all
    at once. Instead, it breaks the message up into chunks, sending each chunk of
    bytes on its own.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 - HTTP streaming response](img/file3.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 - HTTP streaming response
  prefs: []
  type: TYPE_NORMAL
- en: The streaming response in *Figure 4.3* is basically the reverse of the streaming
    request. The request is sent in its entirety, but the server decides to send the
    response in chunks until it is complete. When someone talks about streaming media,
    they are referring to the response stream. We will look more at this option in
    *Chapter 5*, *Handling and Responding Views* when we talk about different types
    of responses.
  prefs: []
  type: TYPE_NORMAL
- en: We currently are concerned with learning about request streaming as depicted
    in *Figure 4.2*. It should definitely be noted that between the two, this is by
    far the lesser utilized feature. When you search for *streaming HTTP* on the internet,
    you are likely to find less information on it. Nonetheless, it can be a powerful
    tool in the right situation.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, first we will ask, when should we think about using request streaming?
    One potential use case is if a client wants to *warm up* the HTTP connection.
    Let’s say you are building a stock trading platform. Latency between the frontend
    UI and the backend server is critically important. The difference in milliseconds
    having potential financial impacts. Your task is to get the data from the frontend
    as fast as possible. The solution is to initiate the `POST` request as soon as
    the user clicks on the input box. Simultaneously, the frontend UI opens the HTTP
    connection with a `Transfer-Encoding: chunked` header signaling that more data
    is coming. So, while the user is typing their values, we have already performed
    the operations and suffered any overhead that is related to the opening of a connection.
    The server now is on alert waiting for data to come as soon as the user hits the
    *Enter* button.'
  prefs: []
  type: TYPE_NORMAL
- en: What might this endpoint look like?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Let’s point out a few important parts one at a time.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to tell Sanic that we are going to be streaming the response here.
    There are two options: passing `stream=True` in the route definition, or using
    the `@stream` decorator. They work the same, so it is more a matter of personal
    choice.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There should be some sort of a loop that continues to read from the stream until
    it is complete. How do we know it is complete? There will be an empty read from
    the stream. If you skip the `if body is None` line, you could end up crashing
    your server as it gets stuck in an infinite loop.The data when read is a `bytes`
    string, so you may want to convert that to a regular `str` as we do here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It is important to note that in this example, we are reading the body completely
    down before continuing on with processing the request. Another alternative might
    be to take those bytes and write them to something else that can consume and act
    upon them immediately. In just a moment we will see an example that does this.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You need to decode the body yourself. On regular requests, if you send JSON
    data, Sanic will decode it for you. But here, all we have are the raw bytes (converted
    to a string). If we need further processing, we should do it ourselves. We use
    `ujson.loads` in our example, which ships with Sanic as a speedy way to convert
    the JSON to a Python `dict`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our example works because we are expecting a single *delayed* input from the
    client. The other important place you might use this is with file uploads. If
    you are expecting large file uploads, you may want to start reading and writing
    the bytes as soon as they are received.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example to do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We should notice that the loop here looks very similar to the last one. The
    concept is the same: loop until there is nothing left to read. The difference
    is that instead of writing the data to a local variable, we are using the `aiofiles`
    library to asynchronously write bytes to the file.'
  prefs: []
  type: TYPE_NORMAL
- en: Why would you want to do this? The biggest reason would be efficiency and memory
    utilization. If you use the regular `request.files` accessor to read file data,
    then you are effectively reading the entire contents before doing anything with
    them. This could be a lot of memory usage if there are large files at play. By
    reading and writing in chunks, we keep the buffers small.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter has focused entirely upon different methods of reading data. We
    know we can access it from the body, files, form data, streams, and query arguments.
    All of these mechanisms on their own lack one critical component: validation.'
  prefs: []
  type: TYPE_NORMAL
- en: Validating data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What we are about to get into next is the first glimpse of security related
    topics in this book. We cover some more concepts later in *Chapter 7*, *Dealing
    with Security Concerns*. This is, however, not a security book. There is unfortunately
    too much material to be able cover it all in this book. There are too many risks
    and too many potential mitigation measures for our one chapter dedicated to security.
    We will, therefore, instead touch upon the concepts in general for those that
    are unfamiliar, and then show some ways to combat the issue in Sanic.
  prefs: []
  type: TYPE_NORMAL
- en: The first of those topics is data validation. If you have been around the web,
    then you know what I am saying and the *why* is obvious to you. You are concerned
    with SQL injection attacks, or XSS attacks. You know the potential threats posed
    by blindly accepting data and acting upon it. I trust that you already know this
    is a big no-no, and are here to learn *how* to implement standard practices in
    Sanic. If the concept of data validation is completely foreign to you, I suggest
    you spend some time searching other online materials about the security issues
    posed by attacks like those mentioned above.
  prefs: []
  type: TYPE_NORMAL
- en: 'Web API security is not a singular approach. Data validation is only a small
    part of a much larger plan that you will need to protect your application, resources,
    and users. Our focus in this section will primarily be upon the most common scenario
    in modern web applications: making sure that JSON data conforms to expectations.
    These techniques alone will not make your application secure from attacks. See
    *Chapter 7*, *Dealing with Security Concerns* for more on this. Our goal here
    is much more modest: when we expect a number, we get a number, when expect a UUID,
    we get a UUID.'
  prefs: []
  type: TYPE_NORMAL
- en: If you recall in *Chapter 3*, *Routing and Intaking HTTP Requests*, we actually
    had our first brush with data validation. We were trying to make sure that the
    data received was one of a known list of ice cream flavors. We are going to expand
    this concept here. There are *many* libraries out there that do this for us. Some
    popular choices include marshmallow, attrs, and pydantic. Before we try and leverage
    an existing package, we are going to try to build our own validation library using
    Python’s dataclasses.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is good to remember why we are doing this. Sanic, as we know, tries hard
    to not make decisions for developers. Data validation is one of the most critical
    components of an application, and it can vary wildly from one use case to the
    next. Therefore, the core Sanic project does not have a single method for doing
    this and leaves the choice to you: the developer. Of course, there are a number
    of plugins out there that add validation, but we are going to take a crack at
    building one ourselves that will fit our needs. Ultimately, I hope this inspires
    some ideas in your own projects for you to take principles and apply them to your
    own unique situations. This next section will deviate from Sanic, and is more
    about Python programming in general. Ultimately, however, I think it is illustrative
    to see how Sanic tries to get out of your way to allow you to implement your own
    solutions and business logic, and only involve itself where needed.'
  prefs: []
  type: TYPE_NORMAL
- en: With that said, let’s get started.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step one: getting started and making a decorator'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first thing we need to do is create a framework that we are going to work
    in. To accomplish our goals, we are going to rely heavily upon decorators. This
    is a fantastic approach because it lets us create per route definitions, but also
    easily repeat our logic across the application as needed. What we are after is
    something that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This looks like a super clean interface. What will this achieve?
  prefs: []
  type: TYPE_NORMAL
- en: 'No repetition: Rather than explicitly telling the `validate` function what
    to do, we are going to use some Python tricks to read `body: BookStallBody` from
    the handler signature.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Dependency injection: Out `validate` function will need to inject a `body`
    argument. This means that we should have a clean data structure with exactly the
    information that we want and cast as the types of data we expect them to be. If
    something is missing, it should raise an exception and cause a failure response.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Type annotations: By annotating the `body` argument, we will have helpful features
    from `mypy` and our IDE to make sure our code is clean, consistent, and bug-free.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To begin, we want to make a decorator that will be capable of being callable,
    or not callable. This will give us both `@validate` and `@validate()`, which will
    make our experience more flexible and easier as we expand our usage. We already
    saw an example of this earlier in *Chapter 3*, *Routing and Intaking HTTP Requests*.
    Let’s see what the minimal decorator looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: With this in place, we have a minimally viable decorator. Obviously, it does
    not do anything useful yet, but we can begin to build our validation logic off
    of this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step two: reading the handler signature'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The next thing we want to do is determine which parts of the request we want
    to validate. We are going to start off with the JSON body. In our target implementation,
    we want to control this with the handler signature. We do, however, have an alternative
    approach. We could try for this for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Arguably, this is a *much* easier decorator to build. In this version, we are
    explicitly telling the `validate` function that we want it to look in the request
    body and validate against a model called `BookStallBody`. But, if we also want
    type annotations, we end up with duplicated code since we need to put the model
    in a typed function argument. We are not going to let the difficulty scare us
    away! After all, we know this decorator will be used all over our application.
    Building a better version up front will help us down the road as we reuse and
    expand the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: So, how do we get the model and the location information? We are going to use
    Python’s `typing` module that comes with the standard library. We need to be very
    careful here. When dealing with decorators, we need to remember there are different
    layers that get executed at different times. Since we are evaluating the handler,
    we only want to do this *once*. If we set this up wrong, we might end up executing
    the setup code on *every single request*! We will try to avoid that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is where we are at now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We inspect the handler and loop over the parameters that are defined inside
    of it. If there is a parameter that is called `body`, then we grab its annotation
    and save it for later use.
  prefs: []
  type: TYPE_NORMAL
- en: 'One potential downside to this approach is we are boxing ourselves in by *only*
    allowing our validations to be on a parameter called `body`. What if we had a
    URL that needed to be: `/path/to/<body>`? Or, we just plain want to call the variable
    something else? Let’s make the decorator slightly more flexible.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: There, by moving the name of the body argument to `body_arg`, we have the flexibility
    to rename it if we want to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step three: modeling'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next critical piece is our model. This could be a place where we add in
    a pre-built library; for example, one of the packages mentioned earlier. I, of
    course, suggest you take a look at them. There are many devoted contributors that
    have spent a lot of time building, testing, and supporting these packages that
    will cover far more use cases than our simple example. But, since we are still
    learning here, we will continue on building our own validation logic on top of
    dataclasses.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create a basic payload that we might expect on our endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Okay, so there is not too much new here. We are defining some models using Python’s
    dataclasses. I encourage you to go look them up if you are unfamiliar with them.
    In brief, they are type-annotated data structures that will be super easy for
    us to work with. One problem with them is that the type annotations are *not*
    enforced at runtime. Even though we say that `BookStallBody.vendor_id` is a `UUID`,
    Python will happily inject a boolean or any other kind of value there. This is
    where the `ValidatorModel` comes in. We are going to add some simple logic to
    the `dataclass` to make sure it is populating with the correct data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another nice trick added to this simple structure is that we are defining `ProductType`
    as an `Enum`. By defining `_generate_next_value_,` we are forcing the values of
    each enum to be a lowercase string value of the key. As an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '**TIP**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Whenever your application is dealing with an ID of any kind, you should try
    and avoid passing it the sequential ID record from your database. Many common
    databases increment the row number every time you insert a record. If your API
    relies upon that ID, you are inadvertently broadcasting information about the
    state of your application to the world. Stick with UUIDs or some other form that
    will add some obscurity for client facing applications. Do not let your database
    IDs leave your server.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Step four: model hydration'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Ultimately, we want to be able to send a JSON request to our endpoint that
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Therefore, our goal is to turn this nested structure into Python objects. Dataclasses
    can get us part of the way there. What is missing is the specific type-casting,
    and nesting. This is what our `ValidatorModel` class will provide for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'It may look like a lot going on here, but it is really quite simple. After
    a model instance is created, we loop through all of its fields. There are really
    now two options: either the field annotation is another dataclass, or it’s something
    else. If it is something else, then we just want to make sure that we cast it
    to the new type.'
  prefs: []
  type: TYPE_NORMAL
- en: If we are dealing with a dataclass, then we have two more options we need to
    determine. Either it is a single item or a list of items. If it is a list, then
    we simply need to make sure we loop over all values and try to hydrate each individual
    item.
  prefs: []
  type: TYPE_NORMAL
- en: Admittedly, this will not cover all use cases. But since we are creating our
    own solution, we only care that it covers the cases we need, and that it is relatively
    simple to maintain if we need to add more complexity in the future.
  prefs: []
  type: TYPE_NORMAL
- en: This solution will do that for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step five: performing validations'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that our models are capable of handling nested logic and converting all
    of our values to their desired types, we need to hook it back up to our decorator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is where we stand now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The important changes are these lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This will convert our raw JSON request data into usable (and well annotated)
    data structures. If there is a failure on a data type, an exception should be
    raised. So, what would that look like?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: If our dataclass models cannot cast a value into the expected type, then it
    should raise a `ValueError` or a `TypeError`. We want to catch either one of them
    and convert it into our own `ValidationError` for two reason. First, by subclassing
    `SanicException`, we can give the exception a `status_code` and when that exception
    is raised, Sanic will automatically know to return a `400` response. *Chapter
    9*, *Best Practices to Improve your Web Applications* discusses more about exception
    handling, which is another important consideration. For now, just know that Sanic
    will give us some exception handling out of the box in both debug, and regular
    mode.
  prefs: []
  type: TYPE_NORMAL
- en: Taking it to the next level with third-party packages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The input validation from the last section was admittedly a bit thin. It works
    well for our very limited use cases, but lacks some of the richness that can be
    achieved from a proper package. If your projects in the future require some customized
    validation logic, then, by all means use what was started to launch your project.
  prefs: []
  type: TYPE_NORMAL
- en: We are, however, going to switch our mode here. Instead of using plain vanilla
    dataclasses and our custom `ValidatorModel`, we are going to use a third-party
    package. We will keep the rest of what we built, so we are not entirely grabbing
    an off-the-shelf solution.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what it would be like if we used Pydantic.
  prefs: []
  type: TYPE_NORMAL
- en: Validation with Pydantic
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Pydantic is a popular package for creating models in Python. It generally plays
    very nicely with type annotations, and even has a drop-in replacement for dataclasses.
    Therefore, we can take our previous example, change the `dataclass` import line,
    and remove `ValidatorModel` and we upgraded our capabilities!
  prefs: []
  type: TYPE_NORMAL
- en: 'We change our models to use the `Pydantic dataclass`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Remove the `ValidatorModel`, since it is no longer needed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The only other change is to make sure that `do_validation` will raise the appropriate
    error message (more on exception handling in *Chapter 6*, *Outside the Response
    Cycle*)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It is an almost identical solution. Please take a look at the full example in
    the GitHub repository. We now have the full power of a proper library to handle
    much more complicated validation logic. Perhaps we should build out our decorator
    just a bit more to handle other types of input validation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: First a model for what our expected query parameters will look like.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we extend the decorator to handle both body and query parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this example, instead of only looking for the body argument, we are also
    looking for query. The implementation between them looks remarkably similar. We
    can now reuse our decorator in other situations:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now it is time for a little experiment. We started off by validating against
    the request JSON. This was validated and injected as the `body` argument. We then
    saw that it was super easy to extend this to `query` arguments with the query
    argument. Your challenge now is to put the book down and see if you can make a
    similar implementation for both regular forms and for file upload validation.
    Take a look at the approaches here, and also reference the `request.files` and
    `request.form` objects we talked about earlier in the book.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is a fairly safe assumption that all web APIs need some input from users
    at some point. Even APIs that are read-only often might allow for filtering, searching,
    or paginating data. Therefore, to become proficient at building web applications
    in general, and Sanic applicaitons specifically, you must learn the data tools
    at your disposal.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we covered a great deal of material. We learned about how to
    pull data from headers, cookies, and the request body. When using headers, form
    data, query arguments, and file data, we saw that these objects could operate
    as regular dictionaries, or dictionaries of lists to be both compliant with HTTP
    standards and also usable for most regular use cases. We also saw that the request
    body itself could be sent as a single chunk, or in multiple chunks.
  prefs: []
  type: TYPE_NORMAL
- en: However, perhaps the biggest takeaway is that reading data cannot and does not
    take a single path. As a reminder, Sanic provides the tools to build the most
    obvious solution for your needs. Whereas many other projects could fill a similar
    discussion with the minutiae of how to implement form data retrieval in their
    specific API, much of our focus was on how to build solutions *with* Sanic, not
    *from* Sanic. It is a framework that tries not to get in the way.
  prefs: []
  type: TYPE_NORMAL
- en: For example, we saw that it was super simple to add both custom and off-the-shelf
    validation logic. Sanic did not tell us how to do it. Instead, it provided some
    conveniences to help make our business logic easier to build. Decorator logic
    gave us the flexibility to have reusable code across the application. Exception
    definitions can automatically catch and handle responses. Building applications
    with Sanic is much more about building well-structured Python applications.
  prefs: []
  type: TYPE_NORMAL
- en: Once information is gathered and validated, it is time to do something with
    it. This is the purpose of the next chapter where we explore how to handle and
    ultimately respond to web requests.
  prefs: []
  type: TYPE_NORMAL
