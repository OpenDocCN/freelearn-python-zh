- en: 4 Ingesting HTTP Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4 摄入HTTP数据
- en: The next building block in application development involves **data**. Without
    data, the Web has little utility. I do not mean to get too philosophical here,
    but it is axiomatic that the purpose of the Internet is the facilitation of the
    transfer of data and knowledge from one location to another. It is therefore critical
    to our development as web professionals to learn how data can be transferred not
    just *from* our applications (which we deal with in *Chapter 5,* *Handling and
    Responding Views*), but also *to* our applications (which is the purpose of this
    chapter). The simplest applications we can build simply provide data. But to become
    interactive web applications participating in the global exchange of knowledge,
    even simple applications must be capable of extracting data from web requests.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序开发中的下一个构建块涉及**数据**。没有数据，Web几乎没有实用性。我并不想在这里过于哲学化，但一个公理是，互联网的目的是促进数据从一地到另一地的传输。因此，对我们作为网络专业人士的发展来说，了解数据如何从我们的应用程序（我们在*第5章*，“处理和响应用户视图”中处理）传输出去，以及如何传输到我们的应用程序（这是本章的目的）至关重要。我们可以构建的最简单的应用程序只是提供数据。但为了成为参与全球知识交流的交互式Web应用程序，即使是简单的应用程序也必须能够从Web请求中提取数据。
- en: A web application that receives no data is like a screencast. Viewers can come
    to watch the presentation, but the presenter has no *personal* connection to the
    people watching. During the COVID-19 global pandemic, I was fortunate enough to
    still be able to participate in several Python conventions. Much applause is due
    the volunteers that pushed forward to present the community with a continuation
    of the sharing and learning atmosphere that exists with technology conferences.
    However, I would be remiss to point out that as a presenter, I had zero connection
    to my audience. It was not until after the presentation was done that I even knew
    how many people watched my content.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 没有接收数据的Web应用程序就像屏幕录制。观众可以来观看演示，但演讲者与观看的人没有任何*个人*联系。在COVID-19全球大流行期间，我很幸运还能参加几个Python会议。许多掌声应归功于那些推动前进、向社区提供技术会议中存在的分享和学习氛围的志愿者。然而，我必须指出，作为一个演讲者，我甚至不知道有多少人观看了我的内容。
- en: This model can be useful to disperse information to those that need to intake
    information from it. However, the transaction is entirely one-sided. My presentations
    could not adjust based upon cues from the audience, and even during chat or Q&A
    sessions, there was an interpersonal experience that was missing. In much the
    same way, a web application that receives no data operates under a similar principal.
    The server has no knowledge about who is listening and cannot alter its behavior
    or content based upon user input. These types of applications are purely for dissemination
    of data and resources only.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模型可以用来向需要从中获取信息的人传播信息。然而，这种交易完全是单方面的。我的演示无法根据观众的线索进行调整，即使在聊天或问答环节，也缺少了人际交往的经验。同样，没有接收数据的Web应用程序在类似的原则下运行。服务器不知道谁在收听，无法根据用户输入改变其行为或内容。这类应用程序纯粹是为了传播数据和资源。
- en: Web APIs of this kind generally only have `GET` methods since they exist entirely
    to spit back information. They can be useful for relaying information about weather,
    flight details, or other centralized repositories of information that many people
    might want to access.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的Web API通常只有`GET`方法，因为它们完全是为了返回信息而存在的。它们可以用于传递有关天气、航班详情或其他许多人都可能希望访问的信息集中存储库的信息。
- en: To build a truly interactive API, we need it to operate not like a screencast,
    but more like a video chat. Both sides of the conversation will participate in
    the passing of information back and forth. And it is this bi-directional communication
    that we will explore in this chapter.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建一个真正交互式的API，我们需要它不像屏幕录制那样操作，而更像视频聊天。对话的双方都将参与信息的来回传递。正是这种双向通信，我们将在本章中探讨。
- en: 'If you will recall from our earlier discussions, there are three main sections
    in the raw HTTP request: **the first line**, **the HTTP headers**, and **the body**.
    So far, we have focused on intaking HTTP requests as they relate to the HTTP method
    and the path: information that both appear in that first line of the HTTP request.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得我们之前的讨论，原始HTTP请求中有三个主要部分：**第一行**、**HTTP头信息**和**正文**。到目前为止，我们一直专注于与HTTP方法和路径相关的HTTP请求的接收：这些信息都出现在HTTP请求的第一行中。
- en: 'In this chapter, we will learn about how we can get data from the client from
    all three sections. Data can be passed to a web server in query arguments, headers,
    and of course the body itself. Therefore, in this chapter we will explore:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何从客户端的所有三个部分获取数据。数据可以通过查询参数、头信息和当然还有正文本身传递给Web服务器。因此，在本章中，我们将探讨：
- en: Extracting data from cookies and headers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从cookies和头信息中提取数据
- en: Using data from query arguments, uploaded files, and JSON data
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用查询参数、上传的文件和JSON数据中的数据
- en: Validating the data is received as expected
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证接收到的数据是否符合预期
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In this chapter you should have the same tools available as in the previous
    Chapters at your disposal in order to be able to follow along with the examples
    (IDE, modern Python, and curl). You can access source code for this chapter on
    GitHub: [https://github.com/PacktPublishing/Web-Development-with-Sanic/tree/main/chapters/04](https://github.com/PacktPublishing/Web-Development-with-Sanic/tree/main/chapters/04).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你应该拥有与之前章节相同的工具，以便能够跟随示例（IDE、现代Python和curl）。你可以通过GitHub访问本章的源代码：[https://github.com/PacktPublishing/Web-Development-with-Sanic/tree/main/chapters/04](https://github.com/PacktPublishing/Web-Development-with-Sanic/tree/main/chapters/04)。
- en: Reading cookies and headers
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读取cookies和头信息
- en: As we have seen throughout the earlier chapters of this book, when any HTTP
    client sends a request to a web server, it includes one or more headers that are
    in a key/value pair. These headers are meant to be part of a meta-conversation
    between the client and the server. And since a HTTP connection is a two-sided
    transaction with both a request and a response, we must keep in mind that there
    is a distinction between request headers and response headers.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本书的前几章中看到的那样，当任何HTTP客户端向Web服务器发送请求时，它包括一个或多个键/值对形式的头信息。这些头信息旨在成为客户端和服务器之间元对话的一部分。由于HTTP连接是一个双向交易，包括请求和响应，我们必须记住请求头和响应头之间的区别。
- en: This chapter still focuses on the HTTP request only. Therefore, we will only
    be covering material as related to request headers. This is worth pointing out
    because there are some headers that are commonly found in both the request and
    the response. One such example is *Content-Type*, which can be used by both HTTP
    requests and HTTP responses. So, for example, keep in mind when we talk about
    *Content-Type* in this section, it relates to HTTP requests only. There is a time
    and a place for discussing response headers. Feel free to skip ahead, or to read
    this section in conjunction with *Chapter 5, Handling and Responding Views* where
    we will discuss the other side of the same coin.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章仍然只关注HTTP请求。因此，我们只涵盖与请求头相关的材料。这一点值得指出，因为有些头信息在请求和响应中都常见。一个这样的例子是*Content-Type*，它既可用于HTTP请求，也可用于HTTP响应。所以，例如，当我们在本节中讨论*Content-Type*时，它仅与HTTP请求相关。讨论响应头的时间和地点是存在的。你可以自由地跳过，或者与*第5章，处理和响应视图*一起阅读这一节，我们将讨论同一枚硬币的另一面。
- en: Headers are flexible
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 头信息是灵活的
- en: HTTP headers are not magic. There is no predefined, finite list of header names.
    Furthermore, deviating from what is considered *standard* will have no impact
    on your application. Remember back when we discussed HTTP methods, we said that
    you could invent your own methods? Well, you have that control and ability to
    create your own *headers* as well.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP头信息并非魔法。不存在预定义的、有限的头名称列表。此外，偏离被认为是*标准*的内容对您的应用程序没有任何影响。记得我们之前讨论HTTP方法时，我们说你可以发明自己的方法吗？好吧，你也有这样的控制和能力来创建自己的*头信息*。
- en: 'This practice is actually encouraged and commonplace. Are you familiar with
    **Cloudflare**? In short, Cloudflare is a popular tool used as a proxy for web
    applications. We will discuss proxies further in *Chapter 8, Running a Server*.
    The idea is simple: Cloudflare runs a web server, a request comes into their server,
    they do *something* to it, and then bundle that up and send the request on to
    your server. When they do that, they include their own set of non-standard headers.
    For example, they will forward the request to you with `CF-Connection-IP` and
    `CF-IPCountry` headers to give you some helpful information about the IP address
    and the location of its origin.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这种做法实际上是受到鼓励并且很常见的。你熟悉**Cloudflare**吗？简而言之，Cloudflare是一个流行的工具，用作Web应用的代理。我们将在*第8章，运行服务器*中进一步讨论代理。这个想法很简单：Cloudflare运行一个Web服务器，一个请求进入他们的服务器，他们对它进行一些操作，然后将请求捆绑起来并发送到你的服务器。当他们这样做时，他们会包含他们自己的一套非标准头。例如，他们将通过`CF-Connection-IP`和`CF-IPCountry`头将请求转发给你，以提供一些关于IP地址及其来源位置的有用信息。
- en: 'Let’s imagine that we are building an API to be used by a farmer’s market.
    They want to setup a web API that will help coordinate among the various participants
    in the market: farmers, restaurant owners, and consumers. The first endpoint we
    want to build will be used to provide information about the market stalls for
    a given day:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象一下，我们正在构建一个用于农民市场的API。他们希望设置一个Web API，以帮助协调市场中的各种参与者：农民、餐馆老板和消费者。我们想要构建的第一个端点将用于提供有关某一天市场摊位的信息：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The response content from this endpoint does not require authentication (more
    on that later), but really ought to be tailored to each of the types of users.
    A farmer might want to know how many stalls are available. Consumers and restaurant
    owners instead might be more interested in knowing the kinds of products that
    will be available. We, therefore, have identified at least two different use cases
    for the same endpoint.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 来自此端点的响应内容不需要身份验证（关于这一点将在后面讨论），但确实应该针对每种用户类型进行定制。农民可能想知道有多少摊位可用。而消费者和餐馆老板可能更感兴趣的是了解将有哪些产品可供选择。因此，我们已经为同一端点确定了至少两种不同的使用场景。
- en: 'One option might be to split this single endpoint into two: `/stalls/<market_date:ymd>/availability`
    `/stalls/<market_date:ymd>/products`'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一种选择可能是将这个单一端点拆分为两个：`/stalls/<market_date:ymd>/availability` 和 `/stalls/<market_date:ymd>/products`
- en: However, this does add some complexity to the overall API design. Furthermore,
    `availability` and `products` as used in this context are not really resources
    in and of themselves. To give them their own endpoint sort of muddies the water
    of the structure of our API so far.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这确实给整体API设计增加了一些复杂性。此外，在这个上下文中使用的`availability`和`products`并不是真正的资源。给它们自己的端点可能会弄乱我们API到目前为止的结构。
- en: What we are really saying is that we have a single resource—the collection of
    market stalls for a given day of the year—and we simply want to present those
    resources in different ways based upon the participant type. It really is only
    one endpoint with two different ways of displaying the same information.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们真正想要表达的是，我们有一个单一的资源——一年中某一天的市场摊位集合——我们只想根据参与者类型以不同的方式展示这些资源。这实际上只有一个端点，但有两种不同的方式来展示相同的信息。
- en: 'Perhaps instead of two different endpoints, a second option might be to use
    query parameters (more on those later in this Chapter in the section on *Query
    arguments*). That would look like this: `/stalls/<market_date:ymd>?participant=farmer`
    and `/stalls/<market_date:ymd>?participant=consumer`. This also sort of breaks
    the paradigm of query parameters—or at least the way I like to use them—which
    are typically meant to be used for filtering and sorting results.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 可能的另一种选择是使用查询参数（关于这些内容将在本章的*查询参数*部分进一步讨论）。这看起来可能是这样的：`/stalls/<market_date:ymd>?participant=farmer`
    和 `/stalls/<market_date:ymd>?participant=consumer`。这也多少打破了查询参数的范式——至少是我喜欢使用它们的方式——它们通常被用来过滤和排序结果。
- en: 'Instead, we will opt for creating a custom header for our use case: `Participant-Type:
    farmer`. We will also create an Enum to help us validate and limit the acceptable
    participants:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '相反，我们将选择为我们的用例创建一个自定义头：`Participant-Type: farmer`。我们还将创建一个枚举来帮助我们验证和限制可接受的参与者：'
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When the request comes in, the handler will try and read the header expecting
    there to be a valid `ParticipantType` object. If there is no `Participant-Type`
    header, or the passed value is an unknown type, we will simply fall back to `ParticipantType.UNKNOWN`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '**IMPORTANT NOTE**'
  id: totrans-29
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-30
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: As you can see in this example, the `request.headers.get("participant-type")`
    is in lower case. It really does not matter. It could be upper case, lower case,
    or a mix. All headers will be read as case-insensitive keys. So, even though the
    `request.headers` object is a `dict`, it is a special kind of dictionary that
    does not care about case. It is a convention only to use lowercase letters when
    retrieving headers from Sanic. Feel free to do what makes sense to you. I would,
    however, just caution you to try and stay consistent throughout a project. It
    can be confusing if sometimes you see `headers.get("Content-Type")` and other
    times `headers.get("content-type")`.
  id: totrans-31
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**TIP**'
  id: totrans-32
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-33
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Enums are great. You should really use them everywhere you can. While using
    them for validation like here may not be their most obvious use case, they are
    super helpful when needing to pass around some types of constants. Imagine needing
    to remember deep inside the bowels of your application: is it *restaurant-owner*,
    *restaurant_owner*, or *restaurant*? Using enums helps reduce bugs, provides a
    single place to maintain and update, and can provide you with code completion
    if your IDE supports it. You will see me use enums in a variety of ways in this
    book. Next to `asyncio`, the standard library `enum` package might just be one
    of my favorites.'
  id: totrans-34
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Getting back to our example, we will now try and hit our endpoint with a few
    different examples to see how it responds with different headers.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 'We will access the information with a known type pretending to be a farmer:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, we will leave out the header to see how the endpoint will respond to the
    absence of any type:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Finally, we will hit the endpoint with some type we have not anticipated:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We have successfully implemented a custom HTTP header that can be used by our
    endpoint to decide how it will display and customize the output. This may be getting
    ahead of ourselves since we will cover middleware in *Chapter 6, Outside the response
    cycle*, but what if we want to reuse the `Participant-Type` header on other endpoints?
    Here is a quick showcase to make this universal to our entire application.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: By evaluating the header inside middleware, we can now place `participant_type`
    on the request object for easy access.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing that I would like to point out about this development example
    is the mindset towards testability. Notice how we identified three different potential
    uses of the endpoint: a known type, a lack of a type, and an unknown type. We
    will talk about testing in *Chapter 9*, *Best practices to improve your web applications*.
    As we continue working through this book, however, it is good to be reminded not
    only of how to work with Sanic, but the types of things we should be thinking
    about when we uncover a problem. Thinking ahead about how the application could
    be used helped us understand the types of use cases we might want to test for,
    and therefore the types of use cases that our application needs to handle.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我还想指出关于这个开发示例的最后一个要点是关于可测试性的心态。注意我们如何确定了端点的三种不同潜在用途：已知类型、缺少类型和未知类型。我们将在*第9章，最佳实践以改进你的Web应用程序*中讨论测试。然而，当我们继续阅读这本书时，提醒自己不仅要了解如何使用Sanic，还要在发现问题时我们应该思考的类型。提前考虑应用程序的用途有助于我们理解我们可能想要测试的类型，因此也理解我们的应用程序需要处理的使用案例。
- en: '**TIP**'
  id: totrans-46
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**提示**'
- en: ''
  id: totrans-47
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'It is also worth pointing out that the `request.ctx` object is there for you
    to attach any information you want to it. This is really powerful to help pass
    information around and to abstract some logic to middleware as shown above. Keep
    in mind that this lasts only as long as the request lasts. After there is a response,
    anything on that `request.ctx` will be disposed of. There is also similar context
    for the entire lifespan of the application, and the lifespan of a single client
    connection. These are respectively: `app.ctx` and `request.conn_info.ctx`. Please
    see *Chapter 6, Outside the response cycle* for more information on these `ctx`
    objects.'
  id: totrans-48
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 还有一点值得指出的是，`request.ctx`对象可供你附加任何你想要的信息。这真的很强大，可以帮助传递信息，并将一些逻辑抽象为中间件，如上所示。请记住，这仅持续到请求结束。一旦有响应，`request.ctx`上的任何内容都将被销毁。对于整个应用程序的生命周期和单个客户端连接的生命周期，也存在类似的环境。这些分别是：`app.ctx`和`request.conn_info.ctx`。请参阅*第6章，响应周期之外*以获取有关这些`ctx`对象的更多信息。
- en: Even though it is entirely possible to create your own set of headers—and indeed,
    I highly encourage it—there does exist a set of common headers that are standard
    among clients and servers. In the next sections, we will explore what some of
    those are.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然完全可以创建自己的头信息集——实际上，我强烈鼓励这样做——但确实存在一套在客户端和服务器之间标准化的常见头信息。在接下来的几节中，我们将探讨其中的一些内容。
- en: Common headers
  id: totrans-50
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 常见头信息
- en: There is a set of predefined standard headers in RFC 2731, section 5\. [https://datatracker.ietf.org/doc/html/rfc7231#section-5](https://datatracker.ietf.org/doc/html/rfc7231#section-5).
    If you are so inclined, put the book down and go read that section. We’ll be waiting
    for you. If not, let’s try and pull out some highlights and some of the more important
    request headers that you should probably know about.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在RFC 2731的第5节中有一组预定义的标准头信息。[https://datatracker.ietf.org/doc/html/rfc7231#section-5](https://datatracker.ietf.org/doc/html/rfc7231#section-5)。如果你有兴趣，放下这本书去阅读那一节。我们会等你回来。如果没有，让我们尝试提取一些亮点和一些你可能需要了解的重要请求头信息。
- en: Authentication headers
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 认证头
- en: 'One of the primary mechanisms for authenticating web requests is through the
    use of headers. The other basic method is with cookies (which is technically also
    a header, but more on that later in the *Getting information from cookies (yum!)*
    section.) While there are certainly different types of authentication schemes
    (basic auth, JWT, and session tokens to name a few), they generally share the
    same construct: the use of the Authorization header.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 验证Web请求的主要机制之一是通过使用头信息。另一种基本方法是使用cookies（技术上讲，cookies也是一种头信息，但关于这一点将在*从cookies获取信息（yum!）*部分中进一步说明。）虽然确实存在不同类型的认证方案（基本认证、JWT和会话令牌等），但它们通常具有相同的结构：使用授权头。
- en: You may have just noticed something peculiar. We are talking about *authentication*,
    at least, that’s what the title of this section is called. But, we just said that
    the primary *authentication* header is called *Authorization*. How can this be?
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能刚刚注意到了一些奇怪的地方。我们在谈论*认证*，至少，这是本节标题的名称。但是，我们刚才说主要的*认证*头信息被称为*授权*。这怎么可能呢？
- en: 'We will cover more details about this in *Chapter 7, Dealing with Security
    Concerns* when we discuss access control more thoroughly, but it is worth mentioning
    the distinction, and the fundamental questions that these two related concepts
    are trying to answer:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们更深入地讨论访问控制时，我们将在*第7章，处理安全关注点*中详细介绍这方面的更多细节，但提到这种区别以及这两个相关概念试图回答的基本问题是很值得的：
- en: '**Authentication**: Do I know who this person is?'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**认证**：我认识这个人吗？'
- en: '**Authorization**: Should I let them in?'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**授权**：我应该让他们进入吗？'
- en: A failure to authenticate results in a *401 Unauthorized* error message and
    a failure of authorization is a *403 Forbidden* error message. It is an unfortunate
    quirk of the history of the Internet that these terms are befuddled, and that
    they developed as they did. They are confusing and inconsistent.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 认证失败会导致*401未授权*错误消息，而授权失败则是一个*403禁止*错误消息。遗憾的是，互联网的历史中存在一个怪癖，这些术语被混淆了，并且它们以这种方式发展起来。它们是令人困惑且不一致的。
- en: 'So, even though the header is called *Authorization*, and even though its failure
    should lead to an *Unauthorized* response, we are still exclusively talking about
    authentication and answering the question: *Do I know who this person is?*'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，尽管标题被称为*授权*，并且尽管其失败应该导致*未授权*响应，但我们仍然在专门讨论认证并回答问题：*我认识这个人吗？*
- en: 'Because Sanic does not take a stance about how you should build your application,
    we obviously have a lot of freedom in choosing how we want to consume the *Authorization*
    request header. Three main strategies come to mind here:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Sanic没有关于您应该如何构建应用程序的立场，我们显然在如何选择消费*授权*请求头方面有很大的自由。以下有三种主要策略：
- en: '**Decorators**'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**装饰器**'
- en: '**Middleware**'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**中间件**'
- en: '**Blueprints**'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**蓝图**'
- en: 'Let’s look at these individually:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一看看这些：
- en: Decorators
  id: totrans-65
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 装饰器
- en: 'Let’s first look at an example using decorators:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们通过一个装饰器的例子来看一下：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The core of this example is the inner `decorated_function`. This basically
    is saying: before running our actual handler (which is `f`), run `check_authentication`.
    This allows us the opportunity to execute code inside *the route* but before we
    get to the actual defined handler.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子中的核心是内部的`decorated_function`。这基本上是在说：在我们实际的处理程序（即`f`）运行之前，先运行`check_authentication`。这让我们有机会在*路由*中执行代码，但在我们到达实际定义的处理程序之前。
- en: 'This decorator pattern is extremely common in Sanic. Not only for running checks,
    but also to inject arguments into our handler. If you are not using some form
    of decorators in your application, you are leaving some real power on the table.
    It is a useful way to duplicate logic across endpoints, and I highly recommend
    you get familiar and comfortable with using them. There is a very helpful starter
    example that can be found in the Sanic User guide: [https://sanicframework.org/en/guide/best-practices/decorators.html](https://sanicframework.org/en/guide/best-practices/decorators.html).'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这种装饰器模式在Sanic中非常常见。不仅用于运行检查，还用于将参数注入我们的处理程序。如果您在应用程序中没有使用某种形式的装饰器，您就放弃了真正的力量。这是一种在端点之间复制逻辑的有用方式，我强烈建议您熟悉并习惯使用它们。在Sanic用户指南中可以找到一个非常有帮助的入门示例：[https://sanicframework.org/en/guide/best-practices/decorators.html](https://sanicframework.org/en/guide/best-practices/decorators.html)。
- en: '**TIP**'
  id: totrans-70
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**提示**'
- en: ''
  id: totrans-71
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Notice the `handler=None` and the last return line?
  id: totrans-72
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意到`handler=None`和最后一行返回吗？
- en: ''
  id: totrans-73
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: def `authenticated(handler=None):`
  id: totrans-74
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: def `authenticated(handler=None):`
- en: ''
  id: totrans-75
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`...`'
  id: totrans-76
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`...`'
- en: ''
  id: totrans-77
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**return** `decorator(handler)` **if** `handler` **else** `decorator`'
  id: totrans-78
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**返回** `decorator(handler)` **如果** `handler` **否则** `decorator`'
- en: ''
  id: totrans-79
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The reason we do this is because we are allowing for our decorator to be used
    in one of two ways: either via `@authenticated` or `@authenticated()`. You will
    have to decide which one (or whether both) is appropriate for your needs.'
  id: totrans-80
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们这样做的原因是我们允许我们的装饰器以两种方式之一使用：要么通过`@authenticated`，要么通过`@authenticated()`。您必须决定哪一种（或是否两者都）适合您的需求。
- en: Middleware
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 中间件
- en: 'Now that we have seen how this works with decorators, how can we achieve the
    same logic with middleware? In the next example, we will try and achieve the same
    functionality that the decorator example provided, except using middleware:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了装饰器是如何工作的，我们如何使用中间件实现相同的逻辑呢？在下一个例子中，我们将尝试实现装饰器示例提供的相同功能，但使用中间件：
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The downside of this method is that we just now locked up our *entire* API!
    What about our `/stalls/<market_date:ymd>` endpoint, or even endpoints that are
    meant for logging in? One way to fix this is to check if the request has a matched
    `Route` instance (it should, unless we are responding to a *404 Not Found*), and
    if it does, make sure it is not one of the exempt routes. We can see an example
    of how to do that here by cross-referencing the name of the matched route with
    an express list of exempt endpoints:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This time, in the middleware we are taking a look at the route’s name to see
    if it is one of the routes that we know should be safe.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '**IMPORTANT NOTE**'
  id: totrans-87
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-88
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'As a quick aside—since we have not seen it before—all routes will have a *name*.
    You can of course name them manually:'
  id: totrans-89
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: More likely than not, we can just let Sanic name our routes. It will by default
    use the handler function’s name, and then append it to our application name (and
    any blueprints) with dot notation. That is why we see `MyApp.login` and `MyApp.market_stalls`.
    They are presuming our application is called `MyApp`, and the handlers for our
    exempt endpoints are `login` and `market_stalls`, respectively.
  id: totrans-91
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*“Hang on a minute?! You want me to keep a list of names of exempt endpoints?
    That sounds like a nightmare to maintain!”* True. If you are handling only two
    items like this simple use case, it is probably manageable enough. But once we
    start really building out an application, this might start to get super unwieldy.
    Feel free to decide which of the two patterns makes more sense. Using decorators
    is much more explicit and clear. However, it does lead to more code repetition.
    The middleware alternative is much simpler to implement, and easier to audit to
    make sure that we are not forgetting to protect any routes. Its downside, however,
    is that it hides some functionality and would be harder to maintain if the list
    of *safe* endpoints grows. If you are in doubt about which makes sense for your
    needs, I would suggest the more explicit authentication decorators. This does,
    however, show that there usually are different ways to tackle the same problems.
    Coming back to the point of *Chapter 1*, *Introduction to Sanic and async frameworks*,
    if one of these solutions seems more *obviously* correct, then that likely is
    the one that you should use.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Blueprints
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'And this is where our third solution comes in: our friend Blueprints again.
    This time, we are going to continue using middleware, but we are only going to
    apply the middleware to Blueprints that contain the protected endpoints.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Since we are placing the middleware on the `“protected” Blueprint`, it will
    only run on the routes that are attached to it. This leaves everything else open.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Context headers
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These headers provide you with some information about the web browser where
    the request originated. Generally, they are useful in analytics and logging to
    provide some information about how your application is being used. We will examine
    some of the more common contextual headers.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这些标题为您提供了有关请求来源的网页浏览器的某些信息。通常，它们在分析和日志记录中非常有用，可以提供有关您的应用程序如何被使用的某些信息。我们将检查一些更常见的上下文标题。
- en: '**Referer** This header contains the name of the page that directed the user
    to the current request. It is really helpful if you want to know from which page
    on your application an API request came from. If your API is not meant to be used
    by a browser, perhaps it is less important. Yes, it is misspelled. The Internet
    is not perfect. And now for a bit of trivia knowledge: RFC 1945 was published
    in 1996 as a specification of the HTTP/1.0 protocol. The team that published it
    included none other than Tim Berners-Lee (aka, the inventor of the World Wide
    Web). Section 10.13 introduced the `Referer` header, but it was inadvertently
    misspelled in the specification! Subsequent specifications and implementations
    have adopted this misspelling, and it has stuck with us for almost 30 years. If
    nothing else, it is a certain warning about the use of spell check. [https://datatracker.ietf.org/doc/html/rfc1945#section-10.13](https://datatracker.ietf.org/doc/html/rfc1945#section-10.13)'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**引用者** 这个标题包含将用户引导到当前请求的页面的名称。如果您想知道API请求是从您的应用程序的哪个页面发起的，这将非常有帮助。如果您的API不是为浏览器设计的，这可能就不那么重要了。是的，它拼写错误了。互联网并不完美。现在，让我们来一点趣闻知识：RFC
    1945于1996年作为HTTP/1.0协议的规范发布。发布它的团队中包括了蒂姆·伯纳斯-李（即万维网的发明者）。第10.13节介绍了`Referer`标题，但在规范中不小心拼错了！随后的规范和实现都采用了这个拼写错误，并且它已经伴随着我们近30年了。如果不是其他的话，这确实是对使用拼写检查器的一个警告。[https://datatracker.ietf.org/doc/html/rfc1945#section-10.13](https://datatracker.ietf.org/doc/html/rfc1945#section-10.13)'
- en: '**Origin** This header is similar to `Referer`. While the `Referer` will generally
    include the full path of where the request originated, the `Origin` header is
    just the URL usually in the form: `<scheme>://<hostname>:<port>` without the path.
    We will look into how we can use it to protect our application from CORS attacks
    in *Chapter 7*, *Dealing with Security Concerns*.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**来源** 这个标题与`Referer`类似。虽然`Referer`通常会包括请求来源的完整路径，但`Origin`标题只是URL，通常形式为`<scheme>://<hostname>:<port>`，不包含路径。我们将在*第7章*，*处理安全关注点*中探讨我们如何使用它来保护我们的应用程序免受CORS攻击。'
- en: '**User-Agent** This header is almost always sent by every HTTP client. It identifies
    the type of application that is accessing your API. Commonly it is a browser,
    but it could also be `curl`, a Python library, or a tool like Postman or Insomnia.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户代理** 这个标题几乎总是由每个HTTP客户端发送。它标识了访问您的API的应用程序类型。通常它是一个浏览器，但也可能是`curl`、Python库或Postman或Insomnia等工具。'
- en: '**Host** Back in *Chapter 3*, *Routing and Intaking HTTP Requests* we saw how
    we could do host-based routing with *virtual hosts*. This is accomplished by reading
    the `Host` header. While `Origin` is the domain where the request is coming from,
    `Host` is where it is going to. Usually, we know this information ahead of time.
    Except, sometimes we have either a dynamic host (like a wildcard subdomain), or
    multiple domain pointing to one application.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主机** 在*第3章*，*路由和接收HTTP请求*中，我们看到了如何使用*虚拟主机*进行基于主机的路由。这是通过读取`Host`标题来实现的。虽然`Origin`是请求来源的域名，但`Host`是它将要到达的地方。通常，我们事先就知道这些信息。但是，有时我们可能有一个动态主机（如通配符子域名），或者多个域名指向一个应用程序。'
- en: '**Forwarded headers** This encompasses both `Forwarded` and a bunch of `X-Forwarded-*
    headers`. Generally, when you see a header that starts with `X-` it means that
    it is a header that has come into common practice and usage, but its implementation
    is not necessarily standard.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**转发标题** 这包括`Forwarded`和许多以`X-Forwarded-*`开头的标题。通常，当你看到一个以`X-`开头的标题时，这意味着它已经成为常见的实践和使用的标题，但其实现并不一定是标准的。'
- en: What are these headers? They contain details about the web request and are used
    by the intermediary proxies (like Nginx or Cloudflare) to pass along relevant
    details about the request. The most common is `X-Forwarded-For`. This is a list
    of all of the IP addresses from the originating request to the current server
    that handled the request (this is not the same as a traceroute). This is incredibly
    helpful and important when trying to identify a request by IP address.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '**IMPORTANT NOTE**'
  id: totrans-105
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-106
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: As with *all* headers and input data, you should *NEVER* assume that incoming
    user data is accurate and harmless. It is very simple for someone to spoof headers.
    Just as always, we need to be cautious when reading headers and not just take
    them at face value.
  id: totrans-107
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Sanic extracts some header data for us
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sanic will automatically extract some information about the request from headers
    and place them on easily accessible attributes on the `Request` object. It makes
    them very helpful to get when needed. Below is a reference for some of the common
    attributes you might encounter.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '| **Request Property** | **HTTP Header used to generate** |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
- en: '| `request.accept` | Accept |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
- en: '| `request.forwarded` | Forwarded |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
- en: '| `request.host` | Host |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
- en: '| `request.id` | X-Request-ID (can be configured |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
- en: '| `request.remote_addr` | Forwarded, or X-Forwarded-For (depends upon more
    configuration covered in *Chapter 11* , *A Complete Real-World Example* ) |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
- en: '| `request.token` | Authorization |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
- en: Table 4.1 - Extracted header data
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '**TIP**'
  id: totrans-118
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-119
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It sometimes may be confusing to know when to use `request.ip` and when to use
    `request.remote_addr`. The former property will always be set and will always
    return the IP address of the client that is connecting to it. This might not actually
    be what you want. If your application is behind a proxy server, and you need to
    rely upon `X-Forwarded-For`, then most likely the attribute you want is `request.remote_addr`.
  id: totrans-120
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Headers as multi-dict
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Headers are stored in Sanic as a multi-dict. This is a special data type that
    will operate both as a one-to-one key-to-value dictionary, and a one-to-many key-to-value
    dictionary. To illustrate the point, here are what those would typically look
    like:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The Header object in Sanic functions as both of those simultaneously. Moreover,
    it looks at the keys as case insensitive. Did you notice in the last example that
    the keys are different cases? Using standard dictionaries, the following would
    be False.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: However, because the HTTP specification allows for HTTP headers to be case-insensitive,
    the Sanic `Header` object is also case-insensitive. But how does it handle the
    issue between one-to-one and one-to-many?
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Again, the HTTP specification allows for multiple identical headers to be concatenated
    without overriding one another. Sanic opts for this special data type to be standards
    compliant. If you do nothing special and merely treat the `Header` object as a
    regular Python `dict` in your application, it will work just fine. You might not
    ever even notice that it is not a regular dictionary. However, you will only ever
    access the first value passed to it for each header. If you need to support multiple
    values for the same header, you are able to access the full *list* of values.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Let’s now hit this endpoint with multiple `Fruit` headers.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Using either square brackets or `.get()` method provides us with `apples` because
    that was the first `Fruit` header that was sent. A more explicit usage would be
    to use `.getone()`. Alternatively, we can use `.getall()` to return the full list
    of `Fruit` header values. Again, case does *not* matter for header keys. For values,
    however, it does. Notice how in our example `Fruit` became `fruit`, but `Bananas`
    did not change case at all.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Getting information from cookies (yum!)
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Building a web application without cookies is like ending a meal without cookies.
    Sure, it could be done. But why would you want to? Given a choice, pick the cookies.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Jokes aside, cookies are obviously an extremely important topic to consider.
    They are the backbone of many of the rich user experiences of web applications.
    Cookies also are inherently full of potential security pitfalls. The security
    issues are generally more of a concern when we talk about setting cookies (*Chapter
    5*, *Handling and Responding Views*), and securing our web applications (*Chapter
    7*, *Dealing with Security Concerns*). Here, we are mainly interested in how to
    access cookies so that we can read the data from them.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: 'A web cookie is a specialized HTTP header: `Cookie`. This header contains a
    structured set of data defined by RFC 6265, § 5.4\. [https://tools.ietf.org/html/rfc6265#section-5.4](https://tools.ietf.org/html/rfc6265#section-5.4).
    The incoming cookie from a request is treated in Sanic like a regular dictionary.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: In order to get an explicit look at how cookies are structured, setup a debug
    handler like this
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, we will send some cookies using curl:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you can see, the data is just a simple key/value dictionary. Accessing cookies
    should therefore be very straightforward. Like other forms of data, it is, of
    course, advisable to treat them with suspect. These values are not immune to tampering
    and can easily be spoofed. Nonetheless, they are an important part of the web,
    especially if your application needs to support a frontend UI.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: While using cookies will be an invaluable source of data for your applications,
    the primary method for users to pass information will come in other forms. Next
    up, we look at those other methods for passing data from web client to web server.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Reading forms, query arguments, files, JSON, and more
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we know about pulling input from the path and from the headers, we
    will turn our attention to more classic types of passing input values. Typically,
    we think of request data as being those bits of information that come from the
    request body. Before we turn to the request body, however, we still have one more
    item in the first line of the HTTP request to examine: **Query arguments**.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Query arguments
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As a reminder, the first line of a HTTP request looks like this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If you have previous web experience, you may know that a URL can have a section
    of arbitrary parameters separated from the rest of the path by a question mark
    (`?`). These are known as query arguments (or parameters), follow in the form
    `key=value`, and are concatenated with an ampersand (`&`). Sometimes they are
    called parameters, sometimes arguments. We will call them arguments here, since
    this is what Sanic opts for to be able to distinguish them from path parameters.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: 'Query arguments are very simple to use, and we can get access to them on our
    request instance:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '**IMPORTANT INFO**'
  id: totrans-151
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-152
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'You may have noticed my `curl` command included `\?` instead of just `?`. This
    is a necessary pattern in some command line applications since `?` itself could
    have a different meaning. It just as well could have been wrapped in quotes: `curl
    "localhost:7777?fruit=apples"`, but I prefer to leave off the quotes and opt for
    the character escaping.'
  id: totrans-153
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Usage seems simple enough, right? Well, not so fast. The obvious next question
    is what happens when the key is repeated? Or, what happens when we want to past
    an array of data?
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: 'There is *no* single standard way to pass array data on the Internet inside
    query arguments. Several methods do exist:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '`?fruit[]=apples&fruit[]=bananas`'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`?fruit=apples,bananas`'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`?fruit=[apples,bananas]`'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`?fruit=apples&fruit=bananas`'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first three approaches were rejected by Sanic, which has instead opted to
    implement the fourth option. A quick look at the three rejected models will explain
    why the chosen model makes sense, and how we can use it going forward.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: First, `fruit[]` is a strange construct that is not obvious to newcomers, and
    actually is a hijacking and alteration of the key. Yuck, no thank you.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Second, `fruit=apples,bananas` seems nice, but what if we wanted to just pass
    a string `apples,bananas` and not actually separate them? Hmm, this does not seem
    possible. Pass.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Third, `fruit=[apples,bananas]` seems better, but it is again somewhat awkward
    and not intuitive. It also suffers the same ambiguity problem. Is `apples,bananas`
    a single string, or two items?
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, the second and third options suffer another problem about how to
    handle duplicate keys. Take the first? The last? Merge? Error? Again, there is
    no consensus and different servers handle this differently.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'The most reasonable approach seems to be the fourth, which can handle all of
    these problems. Keep it simple: we have a key and a value. Nothing more. If there
    are duplicate keys, we treat it as a list append. There are no surprising losses
    of data, no errors, and data integrity is maintained.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'In our last example, we printed to the console the value of `request.args`.
    Here is the output:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Wait?! A `list`? I thought it was a single value: `apples`. At least that is
    what the response gave us. Query arguments are a special dictionary that contains
    lists, but has a unique `.get()` that will fetch only the first value from that
    list. If you want all of the elements, use `.getlist().`'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'When we hit this endpoint now, we can see what these values are:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Another point worth mentioning is that `request.args` is not the only way to
    look at these key/value pairs. We also have `request.query_args`, which is just
    a list of tuples of all the pairs that were passed. The above request would look
    something like this:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'A data structure such as this can, of course, easily be turned into a standard
    dictionary if desired. Just be careful because you will lose out on duplicate
    key data; being left only with the last of each duplicated key:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Forms and files
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By learning how we can pull data from the query arguments, we have inadvertently
    also learned how to get both form data and uploaded file data! That is because
    query arguments, forms, and files all operate identically. To prove it, we will
    setup a couple of endpoints like we have before and see what happens.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Next, we will test the form handler.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Just like before, we see that it looks like a dict with a list. Well, that’s
    because it is. But it will still behave like request.args. We can use .get() for
    a the first item, and .getlist() for all of them in a list.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: And, of course, we will see the same result with files.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We might want to take a closer look at this one to see what it is doing.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: 'When you upload a file to Sanic, it will convert that into a File object. The
    `File` object is really just a namedtuple containing the basic information about
    the file. If we do a `print(request.files.get("po"))`, we should see an object
    that looks like this:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '**TIP**'
  id: totrans-188
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-189
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Are you unfamiliar with namedtuples? They are a really great tool for modelling
    concise objects. I highly recommend using them since they behave as tuples, but
    have the convenience of having dot notation to access specific properties. They
    are great in place of dictionaries, as long as you do not need to modify their
    contents. This is why Sanic uses them here as file objects. It is a convenient
    small structure that is easy for us as developers to work with, while keeping
    some safety around the data so that it is not accidentally corrupted.
  id: totrans-190
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Consuming JSON data
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Arguably the most important type of request data is JSON. Modern web applications
    have embraced and clung to serializing and transmitting data with JSON because
    of its simplicity. It supports basic types of scalar values, is easy for humans
    to read, and easy to implement and widely supported in many programming languages.
    It is no wonder that it is the default methodology.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: 'It should therefore come as no surprise that Sanic makes it very easy:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We have now seen all of the typical ways to access data in a single request.
    Next up, we will learn about how data could alternatively be streamed to Sanic
    in multiple chunks.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Getting streaming data
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The term **streaming** has become somewhat of a buzzword. Many people even outside
    the tech industry use it all the time. The word—and more specifically the actual
    technological concept that it represents—has become an important part of society
    as consumption of media content continues its march to the cloud. What exactly
    is streaming? For those that are not entirely clear what this term means, we will
    take a brief moment to understand it before moving on.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: 'Streaming is the act of sending data in multiple, consecutive chunks from one
    side of an open connection to the other. One of the core foundations of the HTTP
    model is that there is a request followed by a response after a connection is
    established between the client and server. The client sends a complete HTTP request
    message and then waits for the server to send back a complete HTTP response message.
    It looks like this:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 - Normal HTTP request/response cycle](img/file1.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 - Normal HTTP request/response cycle
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: I like to think of these as *finite* transactions. Both the request and the
    response have a definite and known endpoint. These finite requests are what we
    have been looking at up until now. A request comes in, the server does something
    to process it, and a response goes out. What is important to note is that both
    the request and the response are sent in whole in a single block.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: 'One header that we did not discuss earlier is the `Content-Length` header.
    This header can be found on both requests and responses. The actual specification
    on when it *should* be sent versus when it *must* be sent is really beyond the
    scope of this discussion. Sanic will take care of providing this for us when necessary.
    I bring it up here because this header is exactly what it purports to be: the
    length of the content in a HTTP message. This tells the recipient that there is
    a message of a certain length that is being transmitted. And, it is important
    here because the known length of a message cannot necessarily be computed when
    the request headers are sent.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: 'What happens if there is a large amount of data to be sent that might overwhelm
    a single connection, or the data being sent is not 100% available when the connection
    opens? Streaming is a methodology for one side of the connection to tell the other
    that it is transmitting some bytes, but it is not yet done. The connection should
    be held open so that more data can be sent. The way that this interaction happens
    is by replacing the `Content-Length` header with a `Transfer-Encoding: chunked`
    header. This is the way that one side of the connection can tell the other that
    it should continue to receive data until notified that the stream of data is closed.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: When most laypeople hear the term *streaming*, the immediate thought goes to
    streaming media, like movies or music. They might describe the concept as the
    consumption of the media before it is fully downloaded. And, this is correct.
    Streaming is the sending of data in multiple *chunks* instead of sending it all
    at once. This is extremely efficient and can reduce overall resource overhead.
    When supported, it allows the receiving side to start processing that data if
    it desires instead of blocking and waiting for it to be complete. So, when you
    go to watch your favorite movie, you can start watching it without waiting for
    the entire file to be downloaded.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'Streaming does not, however, only apply to media, and also is not only done
    by a server. There are two basic flavors we are concerned about: request streaming
    and response streaming. Here is what those flows look like:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 - HTTP streaming request](img/file2.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 - HTTP streaming request
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 4.2,* we see what a streaming request looks like. Once the HTTP connection
    is opened, the client starts sending data. But, it does not send the message all
    at once. Instead, it breaks the message up into chunks, sending each chunk of
    bytes on its own.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 - HTTP streaming response](img/file3.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 - HTTP streaming response
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: The streaming response in *Figure 4.3* is basically the reverse of the streaming
    request. The request is sent in its entirety, but the server decides to send the
    response in chunks until it is complete. When someone talks about streaming media,
    they are referring to the response stream. We will look more at this option in
    *Chapter 5*, *Handling and Responding Views* when we talk about different types
    of responses.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: We currently are concerned with learning about request streaming as depicted
    in *Figure 4.2*. It should definitely be noted that between the two, this is by
    far the lesser utilized feature. When you search for *streaming HTTP* on the internet,
    you are likely to find less information on it. Nonetheless, it can be a powerful
    tool in the right situation.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 'So, first we will ask, when should we think about using request streaming?
    One potential use case is if a client wants to *warm up* the HTTP connection.
    Let’s say you are building a stock trading platform. Latency between the frontend
    UI and the backend server is critically important. The difference in milliseconds
    having potential financial impacts. Your task is to get the data from the frontend
    as fast as possible. The solution is to initiate the `POST` request as soon as
    the user clicks on the input box. Simultaneously, the frontend UI opens the HTTP
    connection with a `Transfer-Encoding: chunked` header signaling that more data
    is coming. So, while the user is typing their values, we have already performed
    the operations and suffered any overhead that is related to the opening of a connection.
    The server now is on alert waiting for data to come as soon as the user hits the
    *Enter* button.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: What might this endpoint look like?
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Let’s point out a few important parts one at a time.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to tell Sanic that we are going to be streaming the response here.
    There are two options: passing `stream=True` in the route definition, or using
    the `@stream` decorator. They work the same, so it is more a matter of personal
    choice.'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: There should be some sort of a loop that continues to read from the stream until
    it is complete. How do we know it is complete? There will be an empty read from
    the stream. If you skip the `if body is None` line, you could end up crashing
    your server as it gets stuck in an infinite loop.The data when read is a `bytes`
    string, so you may want to convert that to a regular `str` as we do here.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: It is important to note that in this example, we are reading the body completely
    down before continuing on with processing the request. Another alternative might
    be to take those bytes and write them to something else that can consume and act
    upon them immediately. In just a moment we will see an example that does this.
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You need to decode the body yourself. On regular requests, if you send JSON
    data, Sanic will decode it for you. But here, all we have are the raw bytes (converted
    to a string). If we need further processing, we should do it ourselves. We use
    `ujson.loads` in our example, which ships with Sanic as a speedy way to convert
    the JSON to a Python `dict`.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our example works because we are expecting a single *delayed* input from the
    client. The other important place you might use this is with file uploads. If
    you are expecting large file uploads, you may want to start reading and writing
    the bytes as soon as they are received.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example to do that:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We should notice that the loop here looks very similar to the last one. The
    concept is the same: loop until there is nothing left to read. The difference
    is that instead of writing the data to a local variable, we are using the `aiofiles`
    library to asynchronously write bytes to the file.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: Why would you want to do this? The biggest reason would be efficiency and memory
    utilization. If you use the regular `request.files` accessor to read file data,
    then you are effectively reading the entire contents before doing anything with
    them. This could be a lot of memory usage if there are large files at play. By
    reading and writing in chunks, we keep the buffers small.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter has focused entirely upon different methods of reading data. We
    know we can access it from the body, files, form data, streams, and query arguments.
    All of these mechanisms on their own lack one critical component: validation.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Validating data
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What we are about to get into next is the first glimpse of security related
    topics in this book. We cover some more concepts later in *Chapter 7*, *Dealing
    with Security Concerns*. This is, however, not a security book. There is unfortunately
    too much material to be able cover it all in this book. There are too many risks
    and too many potential mitigation measures for our one chapter dedicated to security.
    We will, therefore, instead touch upon the concepts in general for those that
    are unfamiliar, and then show some ways to combat the issue in Sanic.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: The first of those topics is data validation. If you have been around the web,
    then you know what I am saying and the *why* is obvious to you. You are concerned
    with SQL injection attacks, or XSS attacks. You know the potential threats posed
    by blindly accepting data and acting upon it. I trust that you already know this
    is a big no-no, and are here to learn *how* to implement standard practices in
    Sanic. If the concept of data validation is completely foreign to you, I suggest
    you spend some time searching other online materials about the security issues
    posed by attacks like those mentioned above.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 'Web API security is not a singular approach. Data validation is only a small
    part of a much larger plan that you will need to protect your application, resources,
    and users. Our focus in this section will primarily be upon the most common scenario
    in modern web applications: making sure that JSON data conforms to expectations.
    These techniques alone will not make your application secure from attacks. See
    *Chapter 7*, *Dealing with Security Concerns* for more on this. Our goal here
    is much more modest: when we expect a number, we get a number, when expect a UUID,
    we get a UUID.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: If you recall in *Chapter 3*, *Routing and Intaking HTTP Requests*, we actually
    had our first brush with data validation. We were trying to make sure that the
    data received was one of a known list of ice cream flavors. We are going to expand
    this concept here. There are *many* libraries out there that do this for us. Some
    popular choices include marshmallow, attrs, and pydantic. Before we try and leverage
    an existing package, we are going to try to build our own validation library using
    Python’s dataclasses.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'It is good to remember why we are doing this. Sanic, as we know, tries hard
    to not make decisions for developers. Data validation is one of the most critical
    components of an application, and it can vary wildly from one use case to the
    next. Therefore, the core Sanic project does not have a single method for doing
    this and leaves the choice to you: the developer. Of course, there are a number
    of plugins out there that add validation, but we are going to take a crack at
    building one ourselves that will fit our needs. Ultimately, I hope this inspires
    some ideas in your own projects for you to take principles and apply them to your
    own unique situations. This next section will deviate from Sanic, and is more
    about Python programming in general. Ultimately, however, I think it is illustrative
    to see how Sanic tries to get out of your way to allow you to implement your own
    solutions and business logic, and only involve itself where needed.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: With that said, let’s get started.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: 'Step one: getting started and making a decorator'
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first thing we need to do is create a framework that we are going to work
    in. To accomplish our goals, we are going to rely heavily upon decorators. This
    is a fantastic approach because it lets us create per route definitions, but also
    easily repeat our logic across the application as needed. What we are after is
    something that looks like this:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This looks like a super clean interface. What will this achieve?
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'No repetition: Rather than explicitly telling the `validate` function what
    to do, we are going to use some Python tricks to read `body: BookStallBody` from
    the handler signature.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Dependency injection: Out `validate` function will need to inject a `body`
    argument. This means that we should have a clean data structure with exactly the
    information that we want and cast as the types of data we expect them to be. If
    something is missing, it should raise an exception and cause a failure response.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Type annotations: By annotating the `body` argument, we will have helpful features
    from `mypy` and our IDE to make sure our code is clean, consistent, and bug-free.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To begin, we want to make a decorator that will be capable of being callable,
    or not callable. This will give us both `@validate` and `@validate()`, which will
    make our experience more flexible and easier as we expand our usage. We already
    saw an example of this earlier in *Chapter 3*, *Routing and Intaking HTTP Requests*.
    Let’s see what the minimal decorator looks like:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: With this in place, we have a minimally viable decorator. Obviously, it does
    not do anything useful yet, but we can begin to build our validation logic off
    of this.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: 'Step two: reading the handler signature'
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The next thing we want to do is determine which parts of the request we want
    to validate. We are going to start off with the JSON body. In our target implementation,
    we want to control this with the handler signature. We do, however, have an alternative
    approach. We could try for this for example:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Arguably, this is a *much* easier decorator to build. In this version, we are
    explicitly telling the `validate` function that we want it to look in the request
    body and validate against a model called `BookStallBody`. But, if we also want
    type annotations, we end up with duplicated code since we need to put the model
    in a typed function argument. We are not going to let the difficulty scare us
    away! After all, we know this decorator will be used all over our application.
    Building a better version up front will help us down the road as we reuse and
    expand the implementation.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: So, how do we get the model and the location information? We are going to use
    Python’s `typing` module that comes with the standard library. We need to be very
    careful here. When dealing with decorators, we need to remember there are different
    layers that get executed at different times. Since we are evaluating the handler,
    we only want to do this *once*. If we set this up wrong, we might end up executing
    the setup code on *every single request*! We will try to avoid that.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is where we are at now:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We inspect the handler and loop over the parameters that are defined inside
    of it. If there is a parameter that is called `body`, then we grab its annotation
    and save it for later use.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: 'One potential downside to this approach is we are boxing ourselves in by *only*
    allowing our validations to be on a parameter called `body`. What if we had a
    URL that needed to be: `/path/to/<body>`? Or, we just plain want to call the variable
    something else? Let’s make the decorator slightly more flexible.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: There, by moving the name of the body argument to `body_arg`, we have the flexibility
    to rename it if we want to.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: 'Step three: modeling'
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next critical piece is our model. This could be a place where we add in
    a pre-built library; for example, one of the packages mentioned earlier. I, of
    course, suggest you take a look at them. There are many devoted contributors that
    have spent a lot of time building, testing, and supporting these packages that
    will cover far more use cases than our simple example. But, since we are still
    learning here, we will continue on building our own validation logic on top of
    dataclasses.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create a basic payload that we might expect on our endpoint.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Okay, so there is not too much new here. We are defining some models using Python’s
    dataclasses. I encourage you to go look them up if you are unfamiliar with them.
    In brief, they are type-annotated data structures that will be super easy for
    us to work with. One problem with them is that the type annotations are *not*
    enforced at runtime. Even though we say that `BookStallBody.vendor_id` is a `UUID`,
    Python will happily inject a boolean or any other kind of value there. This is
    where the `ValidatorModel` comes in. We are going to add some simple logic to
    the `dataclass` to make sure it is populating with the correct data type.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: 'Another nice trick added to this simple structure is that we are defining `ProductType`
    as an `Enum`. By defining `_generate_next_value_,` we are forcing the values of
    each enum to be a lowercase string value of the key. As an example:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '**TIP**'
  id: totrans-264
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-265
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Whenever your application is dealing with an ID of any kind, you should try
    and avoid passing it the sequential ID record from your database. Many common
    databases increment the row number every time you insert a record. If your API
    relies upon that ID, you are inadvertently broadcasting information about the
    state of your application to the world. Stick with UUIDs or some other form that
    will add some obscurity for client facing applications. Do not let your database
    IDs leave your server.
  id: totrans-266
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Step four: model hydration'
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Ultimately, we want to be able to send a JSON request to our endpoint that
    looks like this:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Therefore, our goal is to turn this nested structure into Python objects. Dataclasses
    can get us part of the way there. What is missing is the specific type-casting,
    and nesting. This is what our `ValidatorModel` class will provide for us:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'It may look like a lot going on here, but it is really quite simple. After
    a model instance is created, we loop through all of its fields. There are really
    now two options: either the field annotation is another dataclass, or it’s something
    else. If it is something else, then we just want to make sure that we cast it
    to the new type.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: If we are dealing with a dataclass, then we have two more options we need to
    determine. Either it is a single item or a list of items. If it is a list, then
    we simply need to make sure we loop over all values and try to hydrate each individual
    item.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: Admittedly, this will not cover all use cases. But since we are creating our
    own solution, we only care that it covers the cases we need, and that it is relatively
    simple to maintain if we need to add more complexity in the future.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: This solution will do that for us.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: 'Step five: performing validations'
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that our models are capable of handling nested logic and converting all
    of our values to their desired types, we need to hook it back up to our decorator.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is where we stand now:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The important changes are these lines:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This will convert our raw JSON request data into usable (and well annotated)
    data structures. If there is a failure on a data type, an exception should be
    raised. So, what would that look like?
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: If our dataclass models cannot cast a value into the expected type, then it
    should raise a `ValueError` or a `TypeError`. We want to catch either one of them
    and convert it into our own `ValidationError` for two reason. First, by subclassing
    `SanicException`, we can give the exception a `status_code` and when that exception
    is raised, Sanic will automatically know to return a `400` response. *Chapter
    9*, *Best Practices to Improve your Web Applications* discusses more about exception
    handling, which is another important consideration. For now, just know that Sanic
    will give us some exception handling out of the box in both debug, and regular
    mode.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: Taking it to the next level with third-party packages
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The input validation from the last section was admittedly a bit thin. It works
    well for our very limited use cases, but lacks some of the richness that can be
    achieved from a proper package. If your projects in the future require some customized
    validation logic, then, by all means use what was started to launch your project.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: We are, however, going to switch our mode here. Instead of using plain vanilla
    dataclasses and our custom `ValidatorModel`, we are going to use a third-party
    package. We will keep the rest of what we built, so we are not entirely grabbing
    an off-the-shelf solution.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what it would be like if we used Pydantic.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: Validation with Pydantic
  id: totrans-289
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Pydantic is a popular package for creating models in Python. It generally plays
    very nicely with type annotations, and even has a drop-in replacement for dataclasses.
    Therefore, we can take our previous example, change the `dataclass` import line,
    and remove `ValidatorModel` and we upgraded our capabilities!
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: 'We change our models to use the `Pydantic dataclass`:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Remove the `ValidatorModel`, since it is no longer needed.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The only other change is to make sure that `do_validation` will raise the appropriate
    error message (more on exception handling in *Chapter 6*, *Outside the Response
    Cycle*)
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: It is an almost identical solution. Please take a look at the full example in
    the GitHub repository. We now have the full power of a proper library to handle
    much more complicated validation logic. Perhaps we should build out our decorator
    just a bit more to handle other types of input validation.
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: First a model for what our expected query parameters will look like.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Then, we extend the decorator to handle both body and query parameters:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In this example, instead of only looking for the body argument, we are also
    looking for query. The implementation between them looks remarkably similar. We
    can now reuse our decorator in other situations:'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Now it is time for a little experiment. We started off by validating against
    the request JSON. This was validated and injected as the `body` argument. We then
    saw that it was super easy to extend this to `query` arguments with the query
    argument. Your challenge now is to put the book down and see if you can make a
    similar implementation for both regular forms and for file upload validation.
    Take a look at the approaches here, and also reference the `request.files` and
    `request.form` objects we talked about earlier in the book.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is a fairly safe assumption that all web APIs need some input from users
    at some point. Even APIs that are read-only often might allow for filtering, searching,
    or paginating data. Therefore, to become proficient at building web applications
    in general, and Sanic applicaitons specifically, you must learn the data tools
    at your disposal.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we covered a great deal of material. We learned about how to
    pull data from headers, cookies, and the request body. When using headers, form
    data, query arguments, and file data, we saw that these objects could operate
    as regular dictionaries, or dictionaries of lists to be both compliant with HTTP
    standards and also usable for most regular use cases. We also saw that the request
    body itself could be sent as a single chunk, or in multiple chunks.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: However, perhaps the biggest takeaway is that reading data cannot and does not
    take a single path. As a reminder, Sanic provides the tools to build the most
    obvious solution for your needs. Whereas many other projects could fill a similar
    discussion with the minutiae of how to implement form data retrieval in their
    specific API, much of our focus was on how to build solutions *with* Sanic, not
    *from* Sanic. It is a framework that tries not to get in the way.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: For example, we saw that it was super simple to add both custom and off-the-shelf
    validation logic. Sanic did not tell us how to do it. Instead, it provided some
    conveniences to help make our business logic easier to build. Decorator logic
    gave us the flexibility to have reusable code across the application. Exception
    definitions can automatically catch and handle responses. Building applications
    with Sanic is much more about building well-structured Python applications.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: Once information is gathered and validated, it is time to do something with
    it. This is the purpose of the next chapter where we explore how to handle and
    ultimately respond to web requests.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
