- en: '*Chapter 4*: Working with Metaclasses'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第4章*：与元类一起工作'
- en: Metaclasses, the focal point of this chapter, can manipulate the way a new class
    is created by decorating the arguments without impacting the actual class definition
    itself. Metaclasses are not very frequently used in Python application development
    unless there is a need for more advanced implementations of frameworks or APIs
    that need features such as manipulation of classes or dynamic class generation
    and so on.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 元类，本章的重点，可以通过装饰参数的方式来操纵新类的创建方式，而不会影响实际的类定义本身。除非需要更高级的实现框架或API，例如需要操纵类或动态生成类等功能，否则元类在Python应用开发中并不常用。
- en: In the previous chapter, we looked at the concept of decorators with some examples.
    Understanding decorators helps in following metaclasses with more ease since both
    decorators and metaclasses deal with metaprogramming on Python 3 program objects
    by manipulating them externally.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们通过一些示例了解了装饰器的概念。理解装饰器有助于更轻松地理解元类，因为装饰器和元类都通过外部操作处理Python 3程序对象的元编程。
- en: 'In this chapter, we will cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Overview of metaclasses
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元类的概述
- en: The structure of a metaclass
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元类的结构
- en: The application of metaclasses
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元类的应用
- en: Switching metaclasses
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 切换元类
- en: Inheritance in metaclasses
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元类中的继承
- en: Manipulating class variables
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操纵类变量
- en: By the end of this chapter, you should be able to create your own metaclasses,
    implement inheritance on metaclasses, and reuse ones that are already created.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你应该能够创建自己的元类，实现元类上的继承，并重用已经创建的元类。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code examples shared in this chapter are available on GitHub under the
    code for this chapter here: [https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter04](https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter04).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中分享的代码示例可在GitHub上找到，地址为：[https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter04](https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter04)。
- en: Overview of metaclasses
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元类的概述
- en: 'Metaclasses are classes that can be created separately with certain features
    that can alter the behavior of other classes or can help in dynamically manufacturing
    new classes. The base class of all metaclasses is the `type` class and the object
    or instance of a metaclass will be a class. Any custom metaclass that we create
    will be inherited from the `type` class. `type` is the class of all data types
    in Python as well and everything else in Python 3 is an object of the `type` class.
    We can test this statement by checking the type of different program objects in
    Python, as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 元类是可以单独创建的类，具有可以改变其他类行为或帮助动态制造新类的某些特性。所有元类的基类是`type`类，元类的对象或实例将是一个类。我们创建的任何自定义元类都将继承自`type`类。`type`也是Python中所有数据类型的类，Python
    3中的其他一切都是`type`类的对象。我们可以通过检查Python中不同程序对象的类型来测试这个陈述，如下所示：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this chapter, we will look at some examples of how to use these metaclasses,
    how to implement them, and how to reuse them. We will continue with our *ABC Megamart*
    examples to proceed further with the understanding of metaclasses.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨一些如何使用这些元类、如何实现它们以及如何重用它们的示例。我们将继续使用我们的*ABC Megamart*示例，以进一步理解元类。
- en: The structure of a metaclass
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元类的结构
- en: A metaclass is like any other class, but it has the ability to alter the behavior
    of other classes that take it as their metaclass. Understanding the structure
    of a metaclass helps us create our own customized metaclasses, which can be used
    further in manipulating new classes. The superclass of a metaclass is the type
    itself. When we create a class with `type` as its superclass and override the
    `__new__` method to manipulate the metadata of a class it returns, then we have
    created a metaclass. Let’s take a closer look with the help of some simple examples.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 元类就像任何其他类一样，但它有能力改变将其作为元类的其他类的行为。理解元类的结构有助于我们创建自己的定制元类，这些元类可以进一步用于操纵新类。元类的超类是`type`本身。当我们使用`type`作为超类创建一个类，并重写`__new__`方法来操纵返回的类的元数据时，我们就创建了一个元类。让我们通过一些简单的示例来更深入地了解。
- en: 'The `__new__` method takes `cls` as its first argument, which is the class
    itself. The members of the class that has `cls` as its first argument can be accessed
    by the class name and the rest of the arguments as other metadata of the class,
    as seen here:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`__new__`方法接受`cls`作为其第一个参数，即类本身。具有`cls`作为第一个参数的类的成员可以通过类名和其余参数作为类的其他元数据来访问，如下所示：'
- en: '[PRE14]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the preceding code, we have created the class `ExampleMetaClass1`, which
    inherits the class `type` and overrides the `__new__` method to print the class
    instance and its other arguments.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了名为`ExampleMetaClass1`的类，它继承自类`type`，并重写了`__new__`方法以打印类实例及其其他参数。
- en: 'Let’s now create the class `ExampleClass1` and add the preceding metaclass
    to it:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建名为`ExampleClass1`的类，并将前面的元类添加到其中：
- en: '[PRE19]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Running the preceding code displays the following result:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码显示以下结果：
- en: '[PRE24]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The first part of this output is the class instance `<class ''__main__.ExampleMetaClass1''>`
    and the remaining arguments are the class name and the arguments of the class.
    A simple representation of the metaclass definition is as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 此输出的第一部分是类实例`<class '__main__.ExampleMetaClass1'>`，其余参数是类名和类的参数。元类定义的简单表示如下：
- en: '![Figure 4.1 – Example metaclass definition ](img/B13426_04_01.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1 – 示例元类定义](img/B13426_04_01.jpg)'
- en: Figure 4.1 – Example metaclass definition
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – 示例元类定义
- en: Let’s dive into a little more detail with another example in our next subsection.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一个小节中通过另一个示例来深入了解。
- en: Analyzing the arguments
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参数分析
- en: 'We now will dig deeper into the arguments of the `__new__` method of a metaclass.
    Analyzing the arguments of a metaclass will provide clarity on what information
    of a class can be customized using a metaclass. The data that can be manipulated
    in the classes that adds a metaclass while defining is represented in the following
    figure:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将深入探讨元类中`__new__`方法的参数。分析元类的参数将有助于了解可以使用元类自定义的类的哪些信息。在定义类时添加元类可以操纵的数据在以下图中表示：
- en: '![Figure 4.2 – Example metaclass with more arguments ](img/B13426_04_02.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.2 – 带更多参数的示例元类](img/B13426_04_02.jpg)'
- en: Figure 4.2 – Example metaclass with more arguments
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 – 带更多参数的示例元类
- en: 'Let’s now follow these steps to see how the behavior of arguments affects classes:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们遵循以下步骤，看看参数的行为如何影响类：
- en: 'First, look at the following code where we have all arguments of a metaclass
    segregated—class instance; class name; all parent classes, superclasses, or base
    classes of the class; and all variables and methods created within the class:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，看看以下代码，其中我们将元类的所有参数分离——类实例；类名；类的所有父类、超类或基类；以及类内创建的所有变量和方法：
- en: '[PRE26]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Next, we will be creating two parent classes—`ExampleParentClass1` and `ExampleParentClass2`:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建两个父类——`ExampleParentClass1`和`ExampleParentClass2`：
- en: '[PRE27]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, we will create the class `ExampleClass2` where we will be inheriting both
    of the preceding parent classes and adding the metaclass as `ExampleMetaClass2`:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将创建名为`ExampleClass2`的类，我们将继承前两个父类，并将元类作为`ExampleMetaClass2`添加：
- en: '[PRE28]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Executing the preceding code results in the following output:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行前面的代码会产生以下输出：
- en: '[PRE29]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This example shows us the highlighted arguments that are returned by the metaclass
    and gives an overview of which values can possibly be manipulated from a class
    using metaprogramming.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例展示了元类返回的突出显示的参数，并概述了使用元编程从类中可能操纵哪些值。
- en: 'Let us look at the type of each of the classes created in this example:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看在这个例子中创建的每个类的类型：
- en: '[PRE30]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As we can see, the type of all other classes is the type itself whereas the
    type of `ExampleClass2` is `ExampleMetaClass2`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，所有其他类的类型都是其自身类型，而`ExampleClass2`的类型是`ExampleMetaClass2`。
- en: Now that you understand the structure of a metaclass, we can look further into
    applications of metaclasses on our *ABC Megamart* example.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了元类的结构，我们可以进一步探讨在“ABC Megamart”示例中元类的应用。
- en: The application of metaclasses
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元类应用
- en: 'In this section, we will look at an example where we will create a metaclass
    that can automatically modify the user-defined method attributes of any branch
    class that is newly created. To test this, let us follow these steps:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将查看一个示例，我们将创建一个元类，它可以自动修改新创建的任何分支类的用户定义方法属性。为了测试这一点，让我们遵循以下步骤：
- en: 'Create a metaclass with the name `BranchMetaclass`:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`BranchMetaclass`的元类：
- en: '[PRE31]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Create a `__new__` method with class instance, class name, base classes, and
    attributes as its arguments. In the `__new__` method, import the `inspect` library,
    which can help inspect the input attributes:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `__new__` 方法，其参数为类实例、类名、基类和属性。在 `__new__` 方法中，导入 `inspect` 库，该库可以帮助检查输入属性：
- en: '[PRE32]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Create a new dictionary, `newattributes`:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的字典 `newattributes`：
- en: '[PRE33]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Iterate over the class attributes, check that the attributes start with `__`,
    and don’t change the value.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历类属性，检查属性是否以 `__` 开头，并且不要改变其值。
- en: 'Continue iterating over the other attributes and check if the attributes are
    functions. If they are functions, prefix `branch` to the class method and convert
    the method name into title case:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续遍历其他属性，并检查属性是否为函数。如果是函数，则在类方法前添加 `branch` 前缀，并将方法名改为标题格式：
- en: '[PRE34]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If the preceding conditions are not met, save the value of the attribute as
    it is:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果不满足前面的条件，则按原样保存属性的值：
- en: '[PRE35]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Return the `new` method with new attributes:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回带有新属性的 `new` 方法：
- en: '[PRE36]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Within the metaclass, also create a regular user-defined method, `buy_product`,
    to calculate the sales price of a product:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在元类内部，还创建一个常规用户定义方法 `buy_product` 来计算产品的销售价格：
- en: '[PRE37]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Next, we will create another new class, `Brooklyn`, and add this metaclass to
    the class. By adding the metaclass, we want the methods in the class `Brooklyn`
    to have a prefix branch and change the methods to title case while creating the
    methods of `Brooklyn`.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建另一个新的类，名为 `Brooklyn`，并将这个元类添加到该类中。通过添加元类，我们希望 `Brooklyn` 类中的方法具有前缀分支，并在创建
    `Brooklyn` 类的方法时将方法名改为标题格式。
- en: 'The `Brooklyn` class has four variables, `product_id`, `product_name`, `product_category`,
    and `unit_price`. We will also create a method to calculate the maintenance cost
    and this method should be converted from `maintenance_cost` to `branchMaintenance_cost`
    due to the metaclass that alters the behavior of the newly created class. Here’s
    the new class:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`Brooklyn` 类有四个变量，分别是 `product_id`、`product_name`、`product_category` 和 `unit_price`。我们还将创建一个计算维护成本的方法，由于元类会改变新创建类的行为，因此这个方法应从
    `maintenance_cost` 改为 `branchMaintenance_cost`。以下是新类：'
- en: '[PRE38]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We can list all the arguments of the class `Brooklyn` and check if the metaclass
    has altered its behavior:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以列出 `Brooklyn` 类的所有参数，并检查元类是否改变了其行为：
- en: '[PRE39]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Let us now create an object and look at its methods and variables, as follows:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们创建一个对象，并查看其方法和变量，如下所示：
- en: '[PRE40]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'A simple representation of this example is as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的简单表示如下：
- en: '![Figure 4.3 – Application of metaclass on ABC Megamart – Branch example ](img/B13426_04_03.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.3 – 在 ABC Megamart 上应用元类 – 分支示例](img/B13426_04_03.jpg)'
- en: Figure 4.3 – Application of metaclass on ABC Megamart – Branch example
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3 – 在 ABC Megamart 上应用元类 – 分支示例
- en: So far, we’ve looked at an overview of a metaclass, understood its structure,
    performed an analysis of its arguments, and applied our understanding by creating
    a custom metaclass on our core example. We will look at a few more applications
    in the following section.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经概述了元类，了解了其结构，对其参数进行了分析，并通过在核心示例上创建自定义元类来应用我们的理解。在下一节中，我们将探讨更多应用。
- en: Inheriting the metaclass
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继承元类
- en: 'In this section, we will walk through an example where we will inherit the
    metaclass to check whether it can be inherited as a regular parent class without
    altering the behavior of the new class that is being created. Take a look at the
    following code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过一个示例来演示如何继承元类，以检查它是否可以作为常规父类继承，而不会改变正在创建的新类的行为。请看以下代码：
- en: '[PRE41]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Let''s now create an object for the preceding class to check if an object can
    be created:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们为前面的类创建一个对象来检查是否可以创建对象：
- en: '[PRE50]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We get the following `TypeError`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下 `TypeError`：
- en: '![Figure 4.4 – Error while creating an object for the class inheriting a metaclass
    ](img/B13426_04_04.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.4 – 为继承元类的类创建对象时出错](img/B13426_04_04.jpg)'
- en: Figure 4.4 – Error while creating an object for the class inheriting a metaclass
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4 – 为继承元类的类创建对象时出错
- en: 'This error occurred as `__new__` is a static method that is called to create
    a new instance for the class and it expects three arguments of the class, which
    are not provided while creating the class object. However, there is another way
    of calling the newly created class, `Queens`. The class can be called directly,
    and its methods can be used without having to create an object:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误发生是因为`__new__`是一个静态方法，它被调用以创建类的新的实例，并且它期望类有三个参数，但在创建类对象时没有提供这些参数。然而，还有一种方法可以调用新创建的类`Queens`。可以直接调用这个类，并使用其方法，而无需创建对象：
- en: '[PRE51]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The `maintenance_cost` method did not get modified into `branchMaintenance_cost`
    since the metaclass is not used as a metaclass but as a parent class. Since the
    metaclass is inherited, `Queens` also inherits the user-defined methods of `BranchMetaclass`
    as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 由于元类没有被用作元类，而是作为父类使用，`maintenance_cost`方法没有被修改成`branchMaintenance_cost`。由于元类被继承，`Queens`也继承了`BranchMetaclass`的用户定义方法，如下所示：
- en: '[PRE53]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Inheriting as a parent and metaclass
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 作为父类和元类的继承
- en: 'Let’s now look at what happens when we inherit a class as a parent and also
    add it as a metaclass while creating a new class:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看当我们继承一个类作为父类，并在创建新类时将其添加为元类时会发生什么：
- en: '[PRE55]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'In the preceding code, we have added `BranchMetaclass` as the parent class
    for the class `Queens` and we have also added it as a metaclass. This definition
    should make the class `Queens` inherit the custom methods from `BranchMetaclass`
    and also change the `maintenance_cost` method into `branchMaintenance_cost`. Let’s
    see if it does:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们将`BranchMetaclass`添加为`Queens`类的父类，并且我们还将其添加为元类。这个定义应该使`Queens`类继承`BranchMetaclass`的自定义方法，并将`maintenance_cost`方法改为`branchMaintenance_cost`。让我们看看它是否真的做到了：
- en: '[PRE64]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'In the preceding code execution and output, the `maintenance_cost` method is
    converted into the `branchMaintenance_cost` method as expected. Now run the following
    command:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码执行和输出中，`maintenance_cost`方法被转换成了预期的`branchMaintenance_cost`方法。现在运行以下命令：
- en: '[PRE66]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The `buy_product` method, which is a custom method from `BranchMetaclass`, is
    also inherited since it is a parent class.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 来自`BranchMetaclass`的自定义方法`buy_product`也被继承，因为它是一个父类。
- en: 'Here is a simple representation of this example:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是这个示例的一个简单表示：
- en: '![Figure 4.5 – Application of metaclass and also inheriting it on ABC Megamart
    branch example ](img/B13426_04_05.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图4.5 – 在ABC Megamart分支示例中应用元类及其继承](img/B13426_04_05.jpg)'
- en: Figure 4.5 – Application of metaclass and also inheriting it on ABC Megamart
    branch example
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5 – 在ABC Megamart分支示例中应用元类及其继承
- en: Let us look further into examples of switching metaclasses from one class to
    another.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步探讨从一类切换到另一类元类的示例。
- en: Switching metaclasses
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 切换元类
- en: We can now look into the concept of switching metaclasses for a class. You may
    think, *why do we need to switch metaclasses?* Switching metaclasses reinforces
    the reusability concept of metaprogramming and in this case, it helps in understanding
    how a metaclass created for use on one class can also be used for a different
    class without impacting the class definition.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以探讨一个类中切换元类的概念。你可能想知道，*为什么我们需要切换元类呢？* 切换元类强化了元编程的可重用性概念，在这种情况下，它有助于理解一个为使用一个类而创建的元类也可以用于不同的类，而不会影响类的定义。
- en: In the example for this section, we will be creating two meta classes – `IncomeStatementMetaClass`
    and `BalanceSheetMetaClass`. For the Malibu branch of *ABC Megamart*, we will
    create a class to capture the information required for its financial statements.
    The two financial statements relevant for this example are Income Statement attributes
    and Balance Sheet attributes for the Malibu branch. To differentiate where a particular
    attribute or method of a class should go, we will be creating two metaclasses
    that look at the names of the attributes and tag them under Income Statement or
    Balance Sheet accordingly.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的示例中，我们将创建两个元类 – `IncomeStatementMetaClass`和`BalanceSheetMetaClass`。对于*ABC
    Megamart*的Malibu分支，我们将创建一个类来捕获其财务报表所需的信息。与这个示例相关的两个财务报表是Malibu分支的损益表属性和资产负债表属性。为了区分一个类的特定属性或方法应该放在哪里，我们将创建两个元类，它们会查看属性的名称，并根据损益表或资产负债表相应地标记它们。
- en: 'The following is a simple representation of the attributes that will be manipulated
    by the aforementioned metaclasses:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对上述元类将要操作的属性的一个简单表示：
- en: '![Figure 4.6 – Finance attributes used in this metaclass example ](img/B13426_04_06.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图4.6 – 在这个元类示例中使用的财务属性](img/B13426_04_06.jpg)'
- en: Figure 4.6 – Finance attributes used in this metaclass example
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following code snippet:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Here, the `new` method is modified to check for attributes that have the key
    as one of the parameters that belong to an income statement such as `revenue`,
    `expense`, `profit`, or `loss`. If any of this terminology occurs in the method
    name or variable name, we will add a prefix of `IncomeStatement` to segregate
    those methods and variables.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: 'To test this metaclass, we will be creating a new class, `Malibu`, with four
    variables and four methods, as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'In the preceding code, we have added the metaclass `IncomeStatementMetaClass`
    and we see that the attributes of the class `Malibu` modify the behavior of variables
    and methods as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.7 – Malibu without metaclass (left) and Malibu with metaclass (right)
    ](img/B13426_04_07.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
- en: Figure 4.7 – Malibu without metaclass (left) and Malibu with metaclass (right)
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: 'We will further add another metaclass, `BalanceSheetMetaClass`, to deal with
    the balance sheet-related attributes in the class `Malibu`. In the following metaclass,
    the new method is modified to check for attributes that have the key as one of
    the parameters that belong to a balance sheet such as `assets`, `liabilities`,
    `goodwill`, and cash. If any of these terms occur in the method name or variable
    name, we will add a prefix of `BalanceSheet` to segregate those methods and variables:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'In the preceding code, we have added the metaclass `BalanceSheetMetaClass`
    and we see that the attributes of the class `Malibu` modify the behavior of variables
    and methods as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.8 – Malibu with IncomeStatementMetaClass (left) and Malibu with
    BalanceSheetMetaClass (right) ](img/B13426_04_08.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
- en: Figure 4.8 – Malibu with IncomeStatementMetaClass (left) and Malibu with BalanceSheetMetaClass
    (right)
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know why we need to switch metaclasses, let us look at the application
    of metaclasses in inheritance.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance in metaclasses
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Inheritance**, in a literal sense, means a child acquiring the properties
    of a parent and it means the same in the case of object-oriented programming too.
    A new class can inherit the attributes and methods of a parent class and it can
    also have its own properties and methods.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we will look at how inheritance works on metaclasses by creating
    two classes, `California` and `Pasadena` – `California` being the parent class
    and `Pasadena` the child class.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s check these steps out to understand inheritance better:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous section, we already created two metaclasses that inherited
    type as their parent class – `IncomeStatementMetaClass` and `BalanceSheetMetaClass`.
    We will start by creating the class `California` with the `IncomeStatement` metaclass:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE121]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: Here, we have defined only those attributes that can be modified by the `IncomeStatement`
    metaclass.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will create another class, `Pasadena`, with the `BalanceSheet` metaclass:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: We have defined here only those attributes that can be modified by the `BalanceSheet`
    metaclass.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里定义了那些可以被 `BalanceSheet` 元类修改的属性。
- en: 'Executing the code of the `Pasadena` class results in the following error:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行 `Pasadena` 类的代码会导致以下错误：
- en: '![Figure 4.9 – Error while executing a child class that has a different metaclass
    ](img/B13426_04_09.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.9 – 执行具有不同元类的子类时出错](img/B13426_04_09.jpg)'
- en: Figure 4.9 – Error while executing a child class that has a different metaclass
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.9 – 执行具有不同元类的子类时出错
- en: This error was thrown since `Pasadena` inherited the parent class `California`,
    which has a different metaclass, `IncomeStatementMetaClass`, which is inherited
    from type, and Pasadena’s metaclass `BalanceSheetMetaClass` is also inherited
    from type.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 抛出这个错误是因为 `Pasadena` 继承了父类 `California`，它有一个不同的元类 `IncomeStatementMetaClass`，它是从类型继承的，而
    Pasadena 的元类 `BalanceSheetMetaClass` 也是从类型继承的。
- en: 'To resolve this error, we can redefine the `BalanceSheetMetaClass` with the
    parent class as `IncomeStatementMetaClass` instead of the type class, as follows:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要解决这个错误，我们可以将 `BalanceSheetMetaClass` 重新定义为以父类 `IncomeStatementMetaClass` 代替类型类，如下所示：
- en: '[PRE123]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Let’s now rerun the `California` parent class and also the `Pasadena` child
    class to check if the behavior modification of both the metaclasses is implemented
    in the `Pasadena` class:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们重新运行 `California` 父类和 `Pasadena` 子类，以检查两个元类的行为修改是否在 `Pasadena` 类中实现：
- en: '[PRE124]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'Here is the output from the `Pasadena` class, and as we can see, both the `BalanceSheet`
    and `IncomeStatement` attributes are modified as per their metaclasses:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是 `Pasadena` 类的输出，正如我们所见，`BalanceSheet` 和 `IncomeStatement` 属性都按照它们的元类进行了修改：
- en: '![Figure 4.10 – Pasadena class with inheritance](img/B13426_04_10.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.10 – 具有继承的 Pasadena 类](img/B13426_04_10.jpg)'
- en: Figure 4.10 – Pasadena class with inheritance
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.10 – 具有继承的 Pasadena 类
- en: 'A simple representation of this application is as follows:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用的简单表示如下：
- en: '![Figure 4.11 – Inheritance in metaclasses ](img/B13426_04_11.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.11 – 元类中的继承](img/B13426_04_11.jpg)'
- en: Figure 4.11 – Inheritance in metaclasses
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.11 – 元类中的继承
- en: In this case, we have redefined the parent class of `BalanceSheetMetaClass`
    to be `IncomeStatementMetaClass` since Python does not automatically resolve their
    parent classes while they were both inherited by type and instead throws a metaclass
    conflict. Redefining the parent class of `BalanceSheetMetaClass` not only resolves
    the error but will also not impact the overall functionality of the class since
    `IncomeStatementMetaClass` is in turn inherited from type.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将 `BalanceSheetMetaClass` 的父类重新定义为 `IncomeStatementMetaClass`，因为 Python
    在它们都从类型继承时不会自动解析它们的父类，而是抛出元类冲突。重新定义 `BalanceSheetMetaClass` 的父类不仅解决了错误，而且不会影响类的整体功能，因为
    `IncomeStatementMetaClass` 最终也是从类型继承的。
- en: Let us look at another example where we will be adding additional information
    to class attributes.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看另一个例子，我们将向类属性添加额外的信息。
- en: Manipulating class variables
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作类变量
- en: 'In this section, we will take an example to look at manipulating class variables
    further using metaclasses. We will be creating a metaclass named `SchemaMetaClass`
    and will define the `__new__` method to manipulate attributes of a class if they
    are variables of data types that belong to `integer`, `float`, `string`, or `boolean`.
    Let’s go through the steps real quick:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过一个例子进一步探讨使用元类操作类变量。我们将创建一个名为 `SchemaMetaClass` 的元类，并将定义 `__new__`
    方法以操作属于 `integer`、`float`、`string` 或 `boolean` 数据类型的类属性。让我们快速浏览一下步骤：
- en: 'We will now create the `SchemaMetaClass` with the parent class as type and
    have modified the `new` method to check the following conditions:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将创建 `SchemaMetaClass`，以类型作为父类，并修改了 `new` 方法以检查以下条件：
- en: '[PRE125]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'Create the dictionary object `newattributes`. If the `class` attribute is a
    built-in `class` method that starts with `__`, then the attribute’s value is stored
    as such in `newattributes`:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建字典对象 `newattributes`。如果 `class` 属性是一个以 `__` 开头的内置 `class` 方法，则将属性的值存储为 `newattributes`
    中的此类：
- en: '[PRE126]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'If the `class` attribute is an integer or float variable, then the class returns
    a dictionary item with the attribute name as `ColumnName`, the value as `Value`,
    `Type` as `NUMERIC`, and `Length` as the length of the value:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 `class` 属性是整数或浮点变量，则类返回一个字典项，其中属性名为 `ColumnName`，值为 `Value`，`Type` 为 `NUMERIC`，`Length`
    为值的长度：
- en: '[PRE127]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'If the `class` attribute is a string variable, then the class returns a similar
    dictionary item with `Type` as `VARCHAR`:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`class`属性是一个字符串变量，那么类返回一个类似的字典项，其中`Type`为`VARCHAR`：
- en: '[PRE128]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'Similarly, if the `class` attribute is a boolean object, a similar kind of
    dictionary item with `Type` as `BOOLEAN` is returned:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似地，如果`class`属性是一个布尔对象，则返回一个类似类型的字典项，其中`Type`为`BOOLEAN`：
- en: '[PRE129]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Any other variable or method is stored like so in `newattributes`:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 任何其他变量或方法都像这样存储在`newattributes`中：
- en: '[PRE130]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'We will now create the class `Arizona` with the metaclass as `SchemaMetaClass`,
    define all the variables for a product, and define a method that creates a schema
    out of the metaprogrammed class attributes:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个具有元类`SchemaMetaClass`的`Arizona`类，定义产品的所有变量，并定义一个从元编程类属性创建模式的方法：
- en: '[PRE131]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE131]'
- en: We have added product details of an example product (in this case, an iPhone)
    and the variables are a combination of different data types – `string`, `integer`,
    `float`, and `bool`. We will define the method `create_schema`, which imports
    the pandas library to create a DataFrame that gives a table-like structure to
    the variables and returns the data frame as a table schema.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个示例产品的产品详情（在这种情况下，是一个iPhone）和变量是不同数据类型的组合 – `string`、`integer`、`float`和`bool`。我们将定义`create_schema`方法，该方法导入pandas库以创建一个DataFrame，该DataFrame为变量提供类似表格的结构，并将数据帧作为表模式返回。
- en: 'Now, consider a scenario where the metaclass is not added to the preceding
    code. Calling the `product_name` variable would have resulted in the following:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，考虑一个场景，其中元类没有被添加到前面的代码中。调用`product_name`变量将导致以下结果：
- en: '[PRE132]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Since we have added the metaclass in the preceding `Arizona` class definition,
    calling the `product_name` results in the following:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们在前面的`Arizona`类定义中添加了元类，调用`product_name`结果如下：
- en: '[PRE133]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'Similarly, we can look at the results of a few other variables as follows:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似地，我们可以查看其他几个变量的结果如下：
- en: '[PRE134]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'Using the metaprogrammed class variables further, we have defined the method
    `create_schema` to return a table schema:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进一步使用元编程类变量，我们定义了`create_schema`方法来返回一个表模式：
- en: '[PRE135]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'We get the following table, which includes all of the variables defined in
    the class:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下表，其中包含类中定义的所有变量：
- en: '![Figure 4.12 – Output of the method create_schema ](img/B13426_04_12.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.12 – `create_schema` 方法的输出](img/B13426_04_12.jpg)'
- en: Figure 4.12 – Output of the method create_schema
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.12 – `create_schema` 方法的输出
- en: These are some examples of how metaclasses can be used in developing applications.
    Metaclasses can further be used in more complex scenarios such as automated code
    generation and framework development.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是元类在开发应用程序中可以使用的几个示例。元类还可以在更复杂的场景中使用，例如自动代码生成和框架开发。
- en: Summary
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned how to create metaclasses and some applications
    of metaclasses.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何创建元类以及元类的一些应用。
- en: We then saw how to switch metaclasses, reuse the functionalities, and how to
    implement inheritance on classes that use metaclasses. Finally, we also saw how
    to manipulate the variables of metaclasses further.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们看到了如何切换元类，重用功能，以及如何在使用元类的类上实现继承。最后，我们还看到了如何进一步操作元类的变量。
- en: All of these concepts are part of Python metaprogramming and they are used to
    change the behavior of a class externally and without impacting the internal functionalities
    of the class itself.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些概念都是Python元编程的一部分，并且它们被用来在类外部更改类的行为，而不影响类本身的内部功能。
- en: In the next chapter, we will be looking at the concept of reflection with different
    examples.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过不同的示例来探讨反射的概念。
