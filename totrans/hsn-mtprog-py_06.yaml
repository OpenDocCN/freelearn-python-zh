- en: '*Chapter 4*: Working with Metaclasses'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Metaclasses, the focal point of this chapter, can manipulate the way a new class
    is created by decorating the arguments without impacting the actual class definition
    itself. Metaclasses are not very frequently used in Python application development
    unless there is a need for more advanced implementations of frameworks or APIs
    that need features such as manipulation of classes or dynamic class generation
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, we looked at the concept of decorators with some examples.
    Understanding decorators helps in following metaclasses with more ease since both
    decorators and metaclasses deal with metaprogramming on Python 3 program objects
    by manipulating them externally.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Overview of metaclasses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The structure of a metaclass
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The application of metaclasses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Switching metaclasses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inheritance in metaclasses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manipulating class variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you should be able to create your own metaclasses,
    implement inheritance on metaclasses, and reuse ones that are already created.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code examples shared in this chapter are available on GitHub under the
    code for this chapter here: [https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter04](https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter04).'
  prefs: []
  type: TYPE_NORMAL
- en: Overview of metaclasses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Metaclasses are classes that can be created separately with certain features
    that can alter the behavior of other classes or can help in dynamically manufacturing
    new classes. The base class of all metaclasses is the `type` class and the object
    or instance of a metaclass will be a class. Any custom metaclass that we create
    will be inherited from the `type` class. `type` is the class of all data types
    in Python as well and everything else in Python 3 is an object of the `type` class.
    We can test this statement by checking the type of different program objects in
    Python, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In this chapter, we will look at some examples of how to use these metaclasses,
    how to implement them, and how to reuse them. We will continue with our *ABC Megamart*
    examples to proceed further with the understanding of metaclasses.
  prefs: []
  type: TYPE_NORMAL
- en: The structure of a metaclass
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A metaclass is like any other class, but it has the ability to alter the behavior
    of other classes that take it as their metaclass. Understanding the structure
    of a metaclass helps us create our own customized metaclasses, which can be used
    further in manipulating new classes. The superclass of a metaclass is the type
    itself. When we create a class with `type` as its superclass and override the
    `__new__` method to manipulate the metadata of a class it returns, then we have
    created a metaclass. Let’s take a closer look with the help of some simple examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `__new__` method takes `cls` as its first argument, which is the class
    itself. The members of the class that has `cls` as its first argument can be accessed
    by the class name and the rest of the arguments as other metadata of the class,
    as seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have created the class `ExampleMetaClass1`, which
    inherits the class `type` and overrides the `__new__` method to print the class
    instance and its other arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now create the class `ExampleClass1` and add the preceding metaclass
    to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the preceding code displays the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The first part of this output is the class instance `<class ''__main__.ExampleMetaClass1''>`
    and the remaining arguments are the class name and the arguments of the class.
    A simple representation of the metaclass definition is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – Example metaclass definition ](img/B13426_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – Example metaclass definition
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dive into a little more detail with another example in our next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing the arguments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We now will dig deeper into the arguments of the `__new__` method of a metaclass.
    Analyzing the arguments of a metaclass will provide clarity on what information
    of a class can be customized using a metaclass. The data that can be manipulated
    in the classes that adds a metaclass while defining is represented in the following
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – Example metaclass with more arguments ](img/B13426_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – Example metaclass with more arguments
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now follow these steps to see how the behavior of arguments affects classes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, look at the following code where we have all arguments of a metaclass
    segregated—class instance; class name; all parent classes, superclasses, or base
    classes of the class; and all variables and methods created within the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will be creating two parent classes—`ExampleParentClass1` and `ExampleParentClass2`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we will create the class `ExampleClass2` where we will be inheriting both
    of the preceding parent classes and adding the metaclass as `ExampleMetaClass2`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Executing the preceding code results in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This example shows us the highlighted arguments that are returned by the metaclass
    and gives an overview of which values can possibly be manipulated from a class
    using metaprogramming.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us look at the type of each of the classes created in this example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As we can see, the type of all other classes is the type itself whereas the
    type of `ExampleClass2` is `ExampleMetaClass2`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you understand the structure of a metaclass, we can look further into
    applications of metaclasses on our *ABC Megamart* example.
  prefs: []
  type: TYPE_NORMAL
- en: The application of metaclasses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will look at an example where we will create a metaclass
    that can automatically modify the user-defined method attributes of any branch
    class that is newly created. To test this, let us follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a metaclass with the name `BranchMetaclass`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `__new__` method with class instance, class name, base classes, and
    attributes as its arguments. In the `__new__` method, import the `inspect` library,
    which can help inspect the input attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new dictionary, `newattributes`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Iterate over the class attributes, check that the attributes start with `__`,
    and don’t change the value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Continue iterating over the other attributes and check if the attributes are
    functions. If they are functions, prefix `branch` to the class method and convert
    the method name into title case:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the preceding conditions are not met, save the value of the attribute as
    it is:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Return the `new` method with new attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Within the metaclass, also create a regular user-defined method, `buy_product`,
    to calculate the sales price of a product:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, we will create another new class, `Brooklyn`, and add this metaclass to
    the class. By adding the metaclass, we want the methods in the class `Brooklyn`
    to have a prefix branch and change the methods to title case while creating the
    methods of `Brooklyn`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `Brooklyn` class has four variables, `product_id`, `product_name`, `product_category`,
    and `unit_price`. We will also create a method to calculate the maintenance cost
    and this method should be converted from `maintenance_cost` to `branchMaintenance_cost`
    due to the metaclass that alters the behavior of the newly created class. Here’s
    the new class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We can list all the arguments of the class `Brooklyn` and check if the metaclass
    has altered its behavior:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let us now create an object and look at its methods and variables, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A simple representation of this example is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – Application of metaclass on ABC Megamart – Branch example ](img/B13426_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – Application of metaclass on ABC Megamart – Branch example
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve looked at an overview of a metaclass, understood its structure,
    performed an analysis of its arguments, and applied our understanding by creating
    a custom metaclass on our core example. We will look at a few more applications
    in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Inheriting the metaclass
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will walk through an example where we will inherit the
    metaclass to check whether it can be inherited as a regular parent class without
    altering the behavior of the new class that is being created. Take a look at the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now create an object for the preceding class to check if an object can
    be created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following `TypeError`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 – Error while creating an object for the class inheriting a metaclass
    ](img/B13426_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.4 – Error while creating an object for the class inheriting a metaclass
  prefs: []
  type: TYPE_NORMAL
- en: 'This error occurred as `__new__` is a static method that is called to create
    a new instance for the class and it expects three arguments of the class, which
    are not provided while creating the class object. However, there is another way
    of calling the newly created class, `Queens`. The class can be called directly,
    and its methods can be used without having to create an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The `maintenance_cost` method did not get modified into `branchMaintenance_cost`
    since the metaclass is not used as a metaclass but as a parent class. Since the
    metaclass is inherited, `Queens` also inherits the user-defined methods of `BranchMetaclass`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Inheriting as a parent and metaclass
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s now look at what happens when we inherit a class as a parent and also
    add it as a metaclass while creating a new class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we have added `BranchMetaclass` as the parent class
    for the class `Queens` and we have also added it as a metaclass. This definition
    should make the class `Queens` inherit the custom methods from `BranchMetaclass`
    and also change the `maintenance_cost` method into `branchMaintenance_cost`. Let’s
    see if it does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code execution and output, the `maintenance_cost` method is
    converted into the `branchMaintenance_cost` method as expected. Now run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: The `buy_product` method, which is a custom method from `BranchMetaclass`, is
    also inherited since it is a parent class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a simple representation of this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5 – Application of metaclass and also inheriting it on ABC Megamart
    branch example ](img/B13426_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.5 – Application of metaclass and also inheriting it on ABC Megamart
    branch example
  prefs: []
  type: TYPE_NORMAL
- en: Let us look further into examples of switching metaclasses from one class to
    another.
  prefs: []
  type: TYPE_NORMAL
- en: Switching metaclasses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can now look into the concept of switching metaclasses for a class. You may
    think, *why do we need to switch metaclasses?* Switching metaclasses reinforces
    the reusability concept of metaprogramming and in this case, it helps in understanding
    how a metaclass created for use on one class can also be used for a different
    class without impacting the class definition.
  prefs: []
  type: TYPE_NORMAL
- en: In the example for this section, we will be creating two meta classes – `IncomeStatementMetaClass`
    and `BalanceSheetMetaClass`. For the Malibu branch of *ABC Megamart*, we will
    create a class to capture the information required for its financial statements.
    The two financial statements relevant for this example are Income Statement attributes
    and Balance Sheet attributes for the Malibu branch. To differentiate where a particular
    attribute or method of a class should go, we will be creating two metaclasses
    that look at the names of the attributes and tag them under Income Statement or
    Balance Sheet accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a simple representation of the attributes that will be manipulated
    by the aforementioned metaclasses:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6 – Finance attributes used in this metaclass example ](img/B13426_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.6 – Finance attributes used in this metaclass example
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `new` method is modified to check for attributes that have the key
    as one of the parameters that belong to an income statement such as `revenue`,
    `expense`, `profit`, or `loss`. If any of this terminology occurs in the method
    name or variable name, we will add a prefix of `IncomeStatement` to segregate
    those methods and variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test this metaclass, we will be creating a new class, `Malibu`, with four
    variables and four methods, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we have added the metaclass `IncomeStatementMetaClass`
    and we see that the attributes of the class `Malibu` modify the behavior of variables
    and methods as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.7 – Malibu without metaclass (left) and Malibu with metaclass (right)
    ](img/B13426_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.7 – Malibu without metaclass (left) and Malibu with metaclass (right)
  prefs: []
  type: TYPE_NORMAL
- en: 'We will further add another metaclass, `BalanceSheetMetaClass`, to deal with
    the balance sheet-related attributes in the class `Malibu`. In the following metaclass,
    the new method is modified to check for attributes that have the key as one of
    the parameters that belong to a balance sheet such as `assets`, `liabilities`,
    `goodwill`, and cash. If any of these terms occur in the method name or variable
    name, we will add a prefix of `BalanceSheet` to segregate those methods and variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we have added the metaclass `BalanceSheetMetaClass`
    and we see that the attributes of the class `Malibu` modify the behavior of variables
    and methods as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.8 – Malibu with IncomeStatementMetaClass (left) and Malibu with
    BalanceSheetMetaClass (right) ](img/B13426_04_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.8 – Malibu with IncomeStatementMetaClass (left) and Malibu with BalanceSheetMetaClass
    (right)
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know why we need to switch metaclasses, let us look at the application
    of metaclasses in inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance in metaclasses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Inheritance**, in a literal sense, means a child acquiring the properties
    of a parent and it means the same in the case of object-oriented programming too.
    A new class can inherit the attributes and methods of a parent class and it can
    also have its own properties and methods.'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we will look at how inheritance works on metaclasses by creating
    two classes, `California` and `Pasadena` – `California` being the parent class
    and `Pasadena` the child class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s check these steps out to understand inheritance better:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous section, we already created two metaclasses that inherited
    type as their parent class – `IncomeStatementMetaClass` and `BalanceSheetMetaClass`.
    We will start by creating the class `California` with the `IncomeStatement` metaclass:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we have defined only those attributes that can be modified by the `IncomeStatement`
    metaclass.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will create another class, `Pasadena`, with the `BalanceSheet` metaclass:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have defined here only those attributes that can be modified by the `BalanceSheet`
    metaclass.
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing the code of the `Pasadena` class results in the following error:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.9 – Error while executing a child class that has a different metaclass
    ](img/B13426_04_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.9 – Error while executing a child class that has a different metaclass
  prefs: []
  type: TYPE_NORMAL
- en: This error was thrown since `Pasadena` inherited the parent class `California`,
    which has a different metaclass, `IncomeStatementMetaClass`, which is inherited
    from type, and Pasadena’s metaclass `BalanceSheetMetaClass` is also inherited
    from type.
  prefs: []
  type: TYPE_NORMAL
- en: 'To resolve this error, we can redefine the `BalanceSheetMetaClass` with the
    parent class as `IncomeStatementMetaClass` instead of the type class, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s now rerun the `California` parent class and also the `Pasadena` child
    class to check if the behavior modification of both the metaclasses is implemented
    in the `Pasadena` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here is the output from the `Pasadena` class, and as we can see, both the `BalanceSheet`
    and `IncomeStatement` attributes are modified as per their metaclasses:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.10 – Pasadena class with inheritance](img/B13426_04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.10 – Pasadena class with inheritance
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple representation of this application is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.11 – Inheritance in metaclasses ](img/B13426_04_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.11 – Inheritance in metaclasses
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we have redefined the parent class of `BalanceSheetMetaClass`
    to be `IncomeStatementMetaClass` since Python does not automatically resolve their
    parent classes while they were both inherited by type and instead throws a metaclass
    conflict. Redefining the parent class of `BalanceSheetMetaClass` not only resolves
    the error but will also not impact the overall functionality of the class since
    `IncomeStatementMetaClass` is in turn inherited from type.
  prefs: []
  type: TYPE_NORMAL
- en: Let us look at another example where we will be adding additional information
    to class attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating class variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will take an example to look at manipulating class variables
    further using metaclasses. We will be creating a metaclass named `SchemaMetaClass`
    and will define the `__new__` method to manipulate attributes of a class if they
    are variables of data types that belong to `integer`, `float`, `string`, or `boolean`.
    Let’s go through the steps real quick:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now create the `SchemaMetaClass` with the parent class as type and
    have modified the `new` method to check the following conditions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the dictionary object `newattributes`. If the `class` attribute is a
    built-in `class` method that starts with `__`, then the attribute’s value is stored
    as such in `newattributes`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the `class` attribute is an integer or float variable, then the class returns
    a dictionary item with the attribute name as `ColumnName`, the value as `Value`,
    `Type` as `NUMERIC`, and `Length` as the length of the value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the `class` attribute is a string variable, then the class returns a similar
    dictionary item with `Type` as `VARCHAR`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Similarly, if the `class` attribute is a boolean object, a similar kind of
    dictionary item with `Type` as `BOOLEAN` is returned:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Any other variable or method is stored like so in `newattributes`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will now create the class `Arizona` with the metaclass as `SchemaMetaClass`,
    define all the variables for a product, and define a method that creates a schema
    out of the metaprogrammed class attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have added product details of an example product (in this case, an iPhone)
    and the variables are a combination of different data types – `string`, `integer`,
    `float`, and `bool`. We will define the method `create_schema`, which imports
    the pandas library to create a DataFrame that gives a table-like structure to
    the variables and returns the data frame as a table schema.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, consider a scenario where the metaclass is not added to the preceding
    code. Calling the `product_name` variable would have resulted in the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since we have added the metaclass in the preceding `Arizona` class definition,
    calling the `product_name` results in the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Similarly, we can look at the results of a few other variables as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Using the metaprogrammed class variables further, we have defined the method
    `create_schema` to return a table schema:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We get the following table, which includes all of the variables defined in
    the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.12 – Output of the method create_schema ](img/B13426_04_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.12 – Output of the method create_schema
  prefs: []
  type: TYPE_NORMAL
- en: These are some examples of how metaclasses can be used in developing applications.
    Metaclasses can further be used in more complex scenarios such as automated code
    generation and framework development.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned how to create metaclasses and some applications
    of metaclasses.
  prefs: []
  type: TYPE_NORMAL
- en: We then saw how to switch metaclasses, reuse the functionalities, and how to
    implement inheritance on classes that use metaclasses. Finally, we also saw how
    to manipulate the variables of metaclasses further.
  prefs: []
  type: TYPE_NORMAL
- en: All of these concepts are part of Python metaprogramming and they are used to
    change the behavior of a class externally and without impacting the internal functionalities
    of the class itself.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be looking at the concept of reflection with different
    examples.
  prefs: []
  type: TYPE_NORMAL
