["```py\ndef hello():\n  print('Hello, World!')\n```", "```py\n$ cython hello.pyx\n\n```", "```py\n$ gcc -shared -pthread -fPIC -fwrapv -O2 -Wall -fno-strict-aliasing -lm -I/usr/include/python3.3/ -o hello.so hello.c\n\n```", "```py\n>>> import hello\n>>> hello.hello()\nHello, World!\n```", "```py\n$ cython -3 hello.pyx\n\n```", "```py\n$ gcc -I/usr/include/python3.3 # ... other options\n$ gcc -I/usr/include/python2.7 # ... other options\n\n```", "```py\nfrom distutils.core import setup\nfrom Cython.Build import cythonize\n\nsetup(\n  name='Hello',ext_modules = cythonize('hello.pyx'),)\n```", "```py\ncythonize(['hello.pyx', 'world.pyx', '*.pyx'])\n```", "```py\n$ python setup.py build_ext --inplace\n\n```", "```py\n>>> import pyximport\n>>> pyximport.install()\n>>> import hello # This will compile hello.pyx\n```", "```py\nIn [1]: %load_ext cythonmagic\n```", "```py\nIn [2]: %%cython\n  ....:  def hello_snippet():\n   ....:    print(\"Hello, Cython!\")\n  ....:\nIn [3]:  hello_snippet()\nHello,  Cython!\n```", "```py\ncdef int i\n```", "```py\ncdef double a, b = 2.0, c = 3.0\n```", "```py\na = 'hello'\n```", "```py\na = 1\n```", "```py\nIn [4]: %%cython\n  ....: cdef int i\n  ....: i = 3.0\n  ....:\n# Output has been cut\n...cf4b.pyx:2:4 Cannot assign type 'double' to 'int'\n\n```", "```py\nIn [5]: %%cython\n  ....: def example():\n  ....:   cdef int i, j=0\n  ....:   for i in range(100):....:      j += 1\n  ....:   return j\n  ....:\nIn [6]: example()\nOut[6]: 100\n```", "```py\nIn [7]: def example_python():\n  ....:    j=0\n  ....:    for i in range(100):....:      j += 1\n  ....:    return j\n  ....:\nIn [8]: %timeit example()\n10000000 loops, best of 3: 25 ns per loop\nIn [9]: %timeit example_python()\n100000 loops, best of 3: 2.74 us per loop\n```", "```py\ncdef object a_py\n# both 'hello' and 1 are Python objects\na_py = 'hello'\na_py = 1\n```", "```py\ncdef int a = 0\ncdef double b\nb = <double> a\n\n```", "```py\ndef max_python(int a, int b):\n  return a if a > b else b\n```", "```py\ncdef int max_cython(int a, int b):\n  return a if a > b else b\n```", "```py\ncpdef int max_hybrid(int a, int b):\n  return a if a > b else b\n```", "```py\ncdef inline int max_inline(int a, int b):\n  return a if a > b else b\n```", "```py\ncdef class Point:\n cdef double x\n cdef double y\n\n  def __init__(self, double x,double y):\n    self.x = x\n    self.y = y\n```", "```py\ncdef double norm(Point p):\n  return p.x**2 + p.y**2\n```", "```py\n>>> a = Point(0.0, 0.0)\n>>> a.x\nAttributeError: 'Point' object has no attribute 'x'\n\n```", "```py\ncdef class Point:\n  cdef public double x\n```", "```py\ncdef int max(int a, int b)\ncdef int min(int a, int b)\n```", "```py\ncdef int max(int a, int b):\n  return a if a > b else b\n\ncdef int min(int a, int b):\n  return a if a < b else b\n```", "```py\nmax(abs(x1 – x2), abs(y1 – y2))\n```", "```py\nfrom mathlib cimport max\n\ndef chebyshev(int x1,int y1,int x2,int y2):\n  return max(abs(x1 - x2), abs(y1 - y2))\n```", "```py\nIn [1]: %%cython\n  ...: cdef double a\n  ...: from libc.stdio cimport printf\n  ...: printf(\"%p\", &a)\n  ...:\n0x7fc8bb611210\n```", "```py\nfrom libc.stdio cimport printf\ncdef double a\ncdef double *a_pointer\na_pointer = &a # They are of the same data type\n```", "```py\ncdef double a\ncdef double *a_pointer\na_pointer = &a\na = 3.0\nprint(*a_pointer) # prints 3.0\n\n```", "```py\ncdef double arr[10]\n```", "```py\ncdef double arr[5][2]\n```", "```py\narr[0] = 1.0\n```", "```py\nIn [1]: %%cython\n  ...: from libc.stdio cimport printf\n  ...: cdef double arr[10]\n  ...: printf(\"%p\\n\", arr)\n  ...: printf(\"%p\\n\", &arr[0])\n  ...:\n0x7ff6de204220\n0x7ff6de204220\n```", "```py\ncimport numpy as c_np\n```", "```py\ncdef c_np.ndarray[double, ndim=2] arr\n```", "```py\nIn [1]:  %%cython\n  ...:  import numpy as np\n  ...:  def numpy_bench_py():...:    py_arr = np.random.rand(1000)\n  ...:    cdef int i\n  ...:    for i in range(1000):\n  ...:       py_arr[i] += 1\n```", "```py\nIn [2]:  %%cython\n  ...:  import numpy as np\n  ...:  cimport numpy as c_np\n  ...:  def numpy_bench_c():\n  ...:    cdef c_np.ndarray[double, ndim=1] c_arr\n  ...:    c_arr = np.random.rand(1000)\n  ...:    cdef int i\n  ...:\n  ...:    for i in range(1000):\n  ...:       c_arr[i] += 1\n```", "```py\nIn [10]: %timeit numpy_bench_c()\n100000 loops, best of 3: 11.5 us per loop\nIn [11]: %timeit numpy_bench_py()\n1000 loops, best of\n 3: 603 us per loop\n```", "```py\ncdef int[:] a\ncdef double[:, :] b\n```", "```py\nimport numpy as np\n\ncdef int[:] arr\narr_np = np.zeros(10, dtype='int32')\narr = arr_np # We bind the array to the memoryview\n```", "```py\narr[2] = 1 # Changing memoryview\nprint(arr_np)\n# [0 0 1 0 0 0 0 0 0 0]\n```", "```py\ncdef int[:, :, :] a\narr[0, :, :] # Is a 2-dimensional memoryview\narr[0, 0, :] # Is a 1-dimensional memoryview\narr[0, 0, 0] # Is an int\n```", "```py\nimport numpy as np\n\ncdef double[:, :] b\ncdef double[:] r\nb = np.random.rand(10, 3)\nr = np.zeros(3, dtype='float64')\n\nb[0, :] = r # Copy the value of r in the first row of b\n```", "```py\n  def evolve_numpy(self, dt):\n    timestep = 0.00001\n    nsteps = int(dt/timestep)\n\n    r_i = np.array([[p.x, p.y] for p in self.particles])    \n    ang_speed_i = np.array([p.ang_speed for pin self.particles])\n    v_i = np.empty_like(r_i)\n\n    for i in range(nsteps):\n      norm_i = np.sqrt((r_i ** 2).sum(axis=1))\n\n      v_i = r_i[:, [1, 0]]\n      v_i[:, 0] *= -1\n      v_i /= norm_i[:, np.newaxis]        \n\n      d_i = timestep * ang_speed_i[:, np.newaxis] * v_i\n\n      r_i += d_i\n\n    for i, p in enumerate(self.particles):\n      p.x, p.y = r_i[i]\n```", "```py\n# file: simul.py\n# ... other code\n  def evolve_cython(self, dt):\n    timestep = 0.00001\n    nsteps = int(dt/timestep)\n\n    r_i = np.array([[p.x, p.y] for p in self.particles])    \n    ang_speed_i = np.array([p.ang_speed forp in self.particles])\n\n    c_evolve(r_i, ang_speed_i, timestep, nsteps)\n\n    for i, p in enumerate(self.particles):\n      p.x, p.y = r_i[i]\n\n# file: cevolve.pyx\nimport numpy as np\n\ndef c_evolve(r_i, ang_speed_i, timestep, nsteps):\n  v_i = np.empty_like(r_i)\n\n  for i in range(nsteps):\n    norm_i = np.sqrt((r_i ** 2).sum(axis=1))\n\n    v_i = r_i[:, [1, 0]]\n    v_i[:, 0] *= -1\n    v_i /= norm_i[:, np.newaxis]        \n\n    d_i = timestep * ang_speed_i[:, np.newaxis] * v_i\n\n    r_i += d_i\n```", "```py\ndef benchmark(npart=100, method='python'):\n  particles = [Particle(uniform(-1.0, 1.0),uniform(-1.0, 1.0),uniform(-1.0, 1.0))for i in range(npart)]\n\n  simulator = ParticleSimulator(particles)\n  if method=='python':\n    simulator.evolve_python(0.1)\n\n if method == 'cython':\n simulator.evolve_cython(0.1)\n\n  elif method == 'numpy':\n simulator.evolve_numpy(0.1)\n\n```", "```py\nIn [4]: %timeit benchmark(100, 'cython')\n1 loops, best of 3: 401 ms per loop\nIn [5]: %timeit benchmark(100, 'numpy')\n1 loops, best of 3: 413 ms per loop\n```", "```py\ndef c_evolve(double[:, :] r_i, double[:] ang_speed_i,double timestep, int nsteps):\n```", "```py\n  cdef int i, j\n  cdef int nparticles = r_i.shape[0]\n```", "```py\n  for i in range(nsteps):\n    for j in range(nparticles):\n      x = r_i[j, 0]\n      y = r_i[j, 1]\n      ang_speed = ang_speed_i[j]\n\n      norm = sqrt(x ** 2 + y ** 2)\n\n      vx = (-y)/norm\n      vy = x/norm\n\n      dx = timestep * ang_speed * vx\n      dy = timestep * ang_speed * vy\n\n      r_i[j, 0] += dx\n      r_i[j, 1] += dy\n```", "```py\ncdef double norm, x, y, vx, vy, dx, dy, ang_speed\n```", "```py\nfrom libc.math cimport sqrt\n```", "```py\nIn [4]: %timeit benchmark(100, 'cython')\n100 loops, best of 3: 13.4 ms per loop\nIn [5]: %timeit benchmark(100, 'numpy')\n1 loops, best of 3: 429 ms per loop\n```", "```py\nIn [2]: %timeit benchmark(1000, 'cython')\n10 loops, best of 3: 134 ms per loop\nIn [3]: %timeit benchmark(1000, 'numpy')\n1 loops, best of 3: 877 ms per loop\n```", "```py\n$ cython -a cevolve.pyx\n$ google-chrome cevolve.html\n\n```", "```py\ncimport cython\n\n@cython.boundscheck(False)\ndef myfunction:\n  # Code here\n```", "```py\nwith cython.boundscheck(False):\n  # Code here\n```", "```py\n# cython: boundscheck=False\n```", "```py\n$ cython -X boundscheck=True\n\n```", "```py\ncimport cython\n\n@cython.boundscheck(False)\n@cython.cdivision(True)\ndef c_evolve(double[:, :] r_i,double[:] ang_speed_i,double timestep,int nsteps):\n```", "```py\nIn [3]: %timeit benchmark(100, 'cython')\n100 loops, best of 3: 13.4 ms per loop\n```", "```py\nimport numpy as np\nfrom distance import chebyshev\n\ndef benchmark():\n  a = np.random.rand(100, 2)\n  b = np.random.rand(100, 2)\n  for x1, y1 in a:\n    for x2, y2 in b:\n      chebyshev(x1, x2, y1, y2)\n```", "```py\n# cython: profile=True\n\ncdef int max(int a, int b):\n  # Code here\n```", "```py\nIn [2]: import cheb\nIn [3]: %prun cheb.benchmark()\n     2000005 function calls in 2.066 seconds\n\n  Ordered by: internal time\n\n  ncalls tottime percall cumtime percall filename:lineno(function)\n    1  1.664  1.664  2.066  2.066 cheb.py:4(benchmark)\n 1000000  0.351  0.000  0.401  0.000 {distance.chebyshev}\n 1000000  0.050  0.000  0.050  0.000 mathlib.pyx:2(max)\n    2  0.000  0.000  0.000  0.000 {method 'rand' of 'mtrand.RandomState' objects}\n    1  0.000  0.000  2.066  2.066 <string>:1(<module>)\n    1  0.000  0.000  0.000  0.000 {method 'disable' of '_lsprof.Profiler' objects}\n```"]