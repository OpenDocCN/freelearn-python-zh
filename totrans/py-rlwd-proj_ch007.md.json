["```py\n% python src/acquire.py -o quartet Anscombe_quartet_data.csv\n```", "```py\n{\"x\": \"10.0\", \"y\": \"8.04\"}\n{\"x\": \"8.0\", \"y\": \"6.95\"}\n{\"x\": \"13.0\", \"y\": \"7.58\"}\n...\n```", "```py\nif __name__ == \"__main__\":\n    logging.basicConfig(level=logging.INFO)\n    main()\n```", "```py\nfrom dataclasses import dataclass\nfrom typing import TypeAlias\n\n@dataclass\nclass XYPair:\n    # Definition goes here\n\nRawData: TypeAlias = XYPair\n```", "```py\nfrom dataclasses import dataclass\nfrom typing import TypeAlias\n\n@dataclass\nclass XYPair:\n    # Definition goes here\n    pass\n\n@dataclass\nclass SomeOtherStructure:\n    # Some other definition, here\n    pass\n\nRawData: TypeAlias = XYPair | SomeOtherStructure\n```", "```py\nfrom model import RawData, XYPair\nfrom abc import ABC, abstractmethod\n\nclass PairBuilder(ABC):\n    target_class: type[RawData]\n\n    @abstractmethod\n    def from_row(self, row: list[str]) -> RawData:\n        ...\n\nclass Series1Pair(PairBuilder):\n    target_class = XYPair\n\n    def from_row(self, row: list[str]) -> RawData:\n        cls = self.target_class\n        # the rest of the implementation...\n        # return cls(arguments based on the value of row)\n```", "```py\ndef get_options(argv: list[str]) -> argparse.Namespace:\n    defaults = argparse.Namespace(\n        extract_class=Extract,\n        series_classes=[Series1Pair, Series2Pair, Series3Pair, Series4Pair],\n    )\n```", "```py\ndef series_1_pair(row: list[str]) -> RawData:\n    ...\n\ndef series_2_pair(row: list[str]) -> RawData:\n    ...\n\ndef series_3_pair(row: list[str]) -> RawData:\n    ...\n\ndef series_4_pair(row: list[str]) -> RawData:\n    ...\n```", "```py\nSeriesBuilder: TypeVar = Callable[[list[str]], RawData]\n\ndef extract(row: list[str], builders: list[SeriesBuilder]) -> list[RawData]:\n    ...\n```", "```py\nFeature: Extract four data series from a file with\nthe peculiar Anscombe Quartet format.\n\nScenario: When requested, the application extracts all four series.\n  Given the \"Anscombe_quartet_data.csv\" source file exists\n  And the \"quartet\" directory exists\n  When we run\n    command \"python src/acquire.py -o quartet Anscombe_quartet_data.csv\"\n  Then the \"quartet/series_1.json\" file exists\n  And the \"quartet/series_2.json\" file exists\n  And the \"quartet/series_3.json\" file exists\n  And the \"quartet/series_3.json\" file exists\n  And the \"quartet/series_1.json\" file starts with\n    ’{\"x\": \"10.0\", \"y\": \"8.04\"}’\n```", "```py\nAnd the \"quartet/series_1.json\" file starts with’{\"x\": \"10.0\", \"y\": \"8.04\"}’\n```", "```py\nScenario: When the file does not exist, the log has the expected\nerror message.\n  Given the \"Anscombe_quartet_data.csv\" source file does not exist\n  And the \"quartet\" directory exists\n  When we run command \"python src/acquire.py -o quartet\n  Anscombe_quartet_data.csv\"\n  Then the log contains \"File not found: Anscombe_quartet_data.csv\"\n```", "```py\nfrom unittest.mock import sentinel\nfrom dataclasses import asdict\n\ndef test_xypair():\n    pair = XYPair(x=sentinel.X, y=sentinel.Y)\n    assert pair.x == sentinel.X\n    assert pair.y == sentinel.Y\n    assert asdict(pair) == {\"x\": sentinel.X, \"y\": sentinel.Y}\n```", "```py\nfrom unittest.mock import Mock, sentinel, call\n\ndef test_series1pair():\n    mock_raw_class = Mock()\n    p1 = Series1Pair()\n    p1.target_class = mock_raw_class\n    xypair = p1.from_row([sentinel.X, sentinel.Y])\n    assert mock_raw_class.mock_calls == [\n        call(sentinel.X, sentinel.Y)\n    ]\n```", "```py\nlogger.info(\"%d rows processed\", input_count)\n```", "```py\nEXTRACT_CLASS: type[Extract] = Extract\nBUILDER_CLASSES: list[type[PairBuilder]] = [\n    Series1Pair, Series2Pair, Series3Pair, Series4Pair]\n\ndef main(argv: list[str]) -> None:\n    builders = [cls() for vls in BUILDER_CLASSES]\n    extractor = EXTRACT_CLASS(builders)\n    # etc.\n```"]