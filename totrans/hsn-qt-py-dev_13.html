<html><head></head><body>
        

                            
                    <h1 class="header-title">Graphical Effects and Multimedia</h1>
                
            
            
                
<p class="mce-root">This chapter is a continuation of the previous chapter about graphics implementations. Here, we will be describing the possibility of adding some effects to the graphical elements that were used in the previous chapter. The Qt framework provides the classes and modules that are most commonly used when we are working with various types of graphical implementation, such as OpenGL, SVG, and 3D graphics. Classes are also available so that you can add effects to the standard graphical elements, such as the rectangle or other shapes. </p>
<p class="mce-root">In this chapter, we will cover the following topics:</p>
<ul>
<li>Standard graphical effects</li>
<li>Standard animations and transformations</li>
<li>Additional modules</li>
<li>Multimedia</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Standard graphical effects</h1>
                
            
            
                
<p>The Qt library provides standard graphical effects that can be used in relation to items such as <kbd>QGraphicsRectItem</kbd> and <kbd>QGraphicsLineItem</kbd>. Effects make the graphical elements of the application more representative and, as a result, styled in a modern fashion. The source of these effects can be images, pictures, graphical elements, parts of the images/elements, and so on. Usually, effects can be added to the graphical item using a setting function such as the following:</p>
<pre><strong>graphics_item</strong> = QtWidgets.QGraphicsRectItem()<br/><strong>blur_effect</strong> = QtWidgets.QGraphicsBlurEffect()<br/><strong>graphics_item</strong>.setGraphicsEffect(<strong>blur_effect</strong>)</pre>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">QGraphicsEffect</h1>
                
            
            
                
<p>This class is the base class for all graphics effects that are used with Qt. The <kbd>QGraphicsEffect</kbd> class improves functionality by means of the following functions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">set</h1>
                
            
            
                
<p>This function sets the parameters/properties in relation to the graphical effects:</p>
<p><kbd>setEnabled(bool)</kbd>: If the parameter is <kbd>True</kbd>, this sets this effect as being enabled.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">is</h1>
                
            
            
                
<p>This function returns a Boolean value (<kbd>bool</kbd>) related to these graphical effect states:</p>
<p><kbd>isEnabled()</kbd>: This returns <kbd>True</kbd> if this effect is enabled.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">functional</h1>
                
            
            
                
<p>These are functions that are related to the current values of the graphical effect, changes in functionality, and so on:</p>
<p><kbd>boundingRect()</kbd>: This returns the bounding rectangle of the <kbd>QtCore.QRectF</kbd> type for this effect.</p>
<p><kbd>boundingRectFor(QtCore.QRectF)</kbd>: This returns the bounding rectangle of the <kbd>QtCore.QRectF</kbd> type, which depends on the rectangle, specified in the parameter, in device coordinates, for this effect.</p>
<p><kbd>draw(QtGui.QPainter)</kbd>: This draws the effect and is called when it needs to be drawn.</p>
<p><kbd>drawSource(QtGui.QPainter)</kbd>: This draws the source directly using the painter specified in the parameter.</p>
<p><kbd>sourceBoundingRect(QtCore.Qt.CoordinateSystem)</kbd>: This returns the bounding rectangle of the source that is mapped to the system specified in the parameter.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p><kbd>sourceChanged(QtWidgets.QGraphicsEffect.ChangeFlags)</kbd>: This notifies that the source of this effect has changed, with flags, specified in the parameter, that describe what has changed. The available flags are as follows:</p>
<ul>
<li><kbd>QtWidgets.QGraphicsEffect.SourceAttached</kbd>: The effect is installed on a source.</li>
<li><kbd>QtWidgets.QGraphicsEffect.SourceDetached</kbd>: The effect is uninstalled from a source.</li>
<li><kbd>QtWidgets.QGraphicsEffect.SourceBoundingRectChanged</kbd>: The bounding rectangle of the source has changed.</li>
<li><kbd>QtWidgets.QGraphicsEffect.SourceInvalidated</kbd>: The visual appearance of the source has changed.</li>
</ul>
<p><kbd>sourceIsPixmap()</kbd>: This returns <kbd>True</kbd> if the source of the effect is a pixmap.</p>
<p><kbd>sourcePixmap(QtCore.Qt.CoordinateSystem, PySide2.QtCore.QPoint, QtWidgets.QGraphicsEffect.PixmapPadMode)</kbd>: This returns a pixmap of the <kbd>QtGui.QPixmap</kbd> type with the source painted. The first parameter defines the coordinate system used for the source. The second parameter is the offset where the pixmap should be painted. The pad mode (the third parameter) defines how the pixmap is padded. The available parameters for the pad mode are as follows:</p>
<ul>
<li><kbd>QtWidgets.QGraphicsEffect.NoPad</kbd>—<kbd>0</kbd>: The pixmap doesn't receive additional padding.</li>
<li><kbd>QtWidgets.QGraphicsEffect.PadToTransparentBorder</kbd>—<kbd>1</kbd>: The pixmap will be padded to fully match the transparent border.</li>
<li><kbd>QtWidgets.QGraphicsEffect.PadToEffectiveBoundingRect</kbd>—<kbd>2</kbd>: The pixmap will be padded to match the effective bounding rectangle of this effect.</li>
</ul>
<p><kbd>update()</kbd>: This schedules a redraw of this effect.</p>
<p><kbd>updateBoundingRect()</kbd>: This notifies when the bounding rectangle of this effect has changed.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">signals</h1>
                
            
            
                
<p>The available signal in the <kbd>QGraphicsEffect</kbd> class is as follows:</p>
<p><kbd>enabledChanged(bool)</kbd>: This signal is emitted when the effect becomes enabled or disabled, according to the state passed in the parameter.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">QGraphicsBlurEffect</h1>
                
            
            
                
<p>This class realizes the blur effect for the graphical element. Blur effects reduce source details. The declaration syntax of this class is as follows:</p>
<pre><strong>blur_effect</strong> = QtWidgets.QGraphicsBlurEffect()</pre>
<p><kbd>QGraphicsBlurEffect</kbd> inherits from the <kbd>QGraphicsEffect</kbd> class and improves functionality by means of the following functions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">set</h1>
                
            
            
                
<p>These are functions related to setting the parameters/properties in relation to the blur effect:</p>
<p><kbd>blur_effect.setBlurHints(QtWidgets.QGraphicsBlurEffect.BlurHints)</kbd>: This sets the blur hints for this effect, which describes how blur effects are applied. The available hints are as follows:</p>
<ul>
<li><kbd>QtWidgets.QGraphicsBlurEffect.PerformanceHint</kbd>: This sets the rendering performance as the most important factor.</li>
<li><kbd>QtWidgets.QGraphicsBlurEffect.QualityHint</kbd>: This sets the rendering quality as the most important factor.</li>
<li><kbd>QtWidgets.QGraphicsBlurEffect.AnimationHint</kbd>: This indicates that the blur radius will be animated.</li>
</ul>
<p><kbd>blur_effect.setBlurRadius(float)</kbd>: This sets the blur radius, specified in the parameter, for this effect. A bigger radius gives a more blurred appearance, while a smaller radius makes the appearance seem sharper.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">functional</h1>
                
            
            
                
<p>These are the functions that are related to the current values of the blur effect, changes in functionality, and so on:</p>
<p><kbd>blur_effect.blurHints()</kbd>: This returns hints of the <kbd>QtWidgets.QGraphicsBlurEffect.BlurHints</kbd> type that are used for this blur effect.</p>
<p><kbd>blur_effect.blurRadius()</kbd>: This returns the blur radius of this effect.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">signals</h1>
                
            
            
                
<p>The available signals of the <kbd>QGraphicsBlurEffect</kbd> class are as follows:</p>
<p><kbd>blur_effect.blurHintsChanged(QtWidgets.QGraphicsBlurEffect.BlurHints)</kbd>: This signal is emitted when the blur hint changes, with new blur hints passed in the parameter.</p>
<p><kbd>blur_effect.blurRadiusChanged(float)</kbd>: This signal is emitted when the blur radius changes, with the new blur radius passed in the parameter.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">QGraphicsColorizeEffect</h1>
                
            
            
                
<p>This class implements colorizing. This effect tints the color of the source. The declaration syntax of this class is as follows:</p>
<pre><strong>colorize_effect</strong> = QtWidgets.QGraphicsColorizeEffect()</pre>
<p><kbd>QGraphicsColorizeEffect</kbd> inherits from the <kbd>QGraphicsEffect</kbd> class and improves functionality by means of the following functions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">set</h1>
                
            
            
                
<p class="mce-root">These are functions related to setting the parameters/properties in relation to the colorizing effect:</p>
<p><kbd>colorize_effect.setColor(QtGui.QColor)</kbd>: This sets the color that will be used for this colorizing effect.</p>
<p><kbd>colorize_effect.setStrength(float)</kbd>: This sets the strength of the effect (<kbd>0.0</kbd>—no effect, and <kbd>1.0</kbd>—full colorization).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">functional</h1>
                
            
            
                
<p>These are functions that are related to the current values of the colorizing effect, changes in functionality, and so on:</p>
<p><kbd>colorize_effect.color()</kbd>: This returns the color of the <kbd>QtGui.QColor</kbd> type that's used to colorize this effect.</p>
<p><kbd>colorize_effect.strength()</kbd>: This returns the strength of the effect.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>


            

            
        
    

        

                            
                    <h1 class="header-title">signals</h1>
                
            
            
                
<p>The available signals of the <kbd>QGraphicsColorizeEffect</kbd> class are as follows:</p>
<p><kbd>colorize_effect.colorChanged(QtGui.QColor)</kbd>: This signal is emitted when the color of the effect changes, with a new color passed in the parameter.</p>
<p><kbd>colorize_effect.strengthChanged(float)</kbd>: This signal is emitted when the strength of the effect changes, with a new strength passed in the parameter.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">QGraphicsDropShadowEffect</h1>
                
            
            
                
<p>This class provides the drop shadow effect for the source that's provided. The declaration syntax of this class is as follows:</p>
<pre><strong>shadow_effect</strong> = QtWidgets.QGraphicsDropShadowEffect()</pre>
<p><kbd>QGraphicsDropShadowEffect</kbd> inherits from the <kbd>QGraphicsEffect</kbd> class and improves functionality by means of the following functions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">set</h1>
                
            
            
                
<p>These are functions related to setting the parameters/properties in relation to the shadow effect:</p>
<p><kbd>shadow_effect.setBlurRadius(float)</kbd>: This sets the blur radius in pixels for this drop shadow effect.</p>
<p><kbd>shadow_effect.setColor(QtGui.QColor)</kbd>: This sets the color for this drop shadow effect.</p>
<p><kbd>shadow_effect.setOffset(QtCore.QPointF)</kbd>: This sets the shadow offset specified in the parameter.</p>
<p><kbd>shadow_effect.setOffset(float)</kbd>: This sets the shadow offset specified in the parameter.</p>
<p><kbd>shadow_effect.setOffset(dx, dy)</kbd>: This sets the shadow offset, as specified by the <kbd>dx</kbd> and <kbd>dy</kbd> values of the offset.</p>
<p class="mce-root"/>
<p><kbd>shadow_effect.setXOffset(float)</kbd>: This sets the horizontal shadow offset in pixels specified in the parameter.</p>
<p><kbd>shadow_effect.setYOffset(float)</kbd>: This sets the vertical shadow offset in pixels specified in the parameter.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">functional</h1>
                
            
            
                
<p>These are functions that are related to the current values of the shadow effect, changes in functionality, and so on:</p>
<p><kbd>shadow_effect.blurRadius()</kbd>: This returns the blur radius in pixels of this drop shadow effect.</p>
<p><kbd>shadow_effect.color()</kbd>: This returns the color of the <kbd>QtGui.QColor</kbd> type for this drop shadow.</p>
<p><kbd>shadow_effect.offset()</kbd>: This returns the shadow offset of the <kbd>QtCore.QPointF</kbd> type.</p>
<p><kbd>shadow_effect.xOffset()</kbd>: This returns the horizontal shadow offset.</p>
<p><kbd>shadow_effect.yOffset()</kbd>: This returns the vertical shadow offset.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">signals</h1>
                
            
            
                
<p>The available signals of the <kbd>QGraphicsDropShadowEffect</kbd> class are as follows:</p>
<p><kbd>shadow_effect.blurRadiusChanged(float)</kbd>: This signal is emitted when the blur radius changes, with a new blur radius passed in the parameter.</p>
<p><kbd>shadow_effect.colorChanged(QtGui.QColor)</kbd>: This signal is emitted when the color of the effect changes, with a new color passed in the parameter.</p>
<p><kbd>shadow_effect.offsetChanged(QtCore.QPointF)</kbd>: This signal is emitted when the offset of the effect changes, with a new offset passed in the parameter.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">QGraphicsOpacityEffect</h1>
                
            
            
                
<p>This is the class that implements the opacity effect for the source. The declaration syntax of this class is as follows:</p>
<pre><strong>opacity_effect</strong> = QtWidgets.QGraphicsOpacityEffect()</pre>
<p><kbd>QGraphicsDropShadowEffect</kbd> inherits from the <kbd>QGraphicsEffect</kbd> class and improves functionality by means of the following functions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">set</h1>
                
            
            
                
<p>These are functions related to setting the parameters/properties in relation to the opacity effect:</p>
<p><kbd>opacity_effect.setOpacity(float)</kbd>: This sets the opacity for this effect (<kbd>0.0</kbd>—fully transparent, and <kbd>1.0</kbd>—fully opaque).</p>
<p><kbd>opacity_effect.setOpacityMask(QtGui.QBrush)</kbd>: This sets the opacity mask, specified in the parameter, for this effect. This allows opacity to be applied to portions of an element.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">functional</h1>
                
            
            
                
<p>These are functions that are related to the current values of the opacity effect, changes in functionality, and so on:</p>
<p><kbd>opacity_effect.opacity()</kbd>: This returns the opacity of this effect.</p>
<p><kbd>opacity_effect.opacityMask()</kbd>: This returns the opacity mask of the <kbd>QtGui.QBrush</kbd> type for this effect.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">signals</h1>
                
            
            
                
<p>The available signals of the <kbd>QGraphicsOpacityEffect</kbd> class are as follows:</p>
<p><kbd>opacity_effect.opacityChanged(float)</kbd>: This signal is emitted when the opacity changes, with the new opacity passed in the parameter.</p>
<p><kbd>opacity_effect.opacityMaskChanged(QtGui.QBrush)</kbd>: This signal is emitted when the opacity mask changes, with the new opacity mask passed in the parameter.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Standard animations and transformation</h1>
                
            
            
                
<p>Effects, with the help of the Qt framework, can be realized as animations of standard graphics items. These classes animate various items, such as <kbd>QGraphicsEllipseItem</kbd>, <kbd>QGraphicsTextItem</kbd>, and so on. The <kbd>QGraphicsItemAnimation</kbd> class can also be considered for the PySide binding.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">QGraphicsTransform</h1>
                
            
            
                
<p>This is an abstract base class for building advanced transformations with a graphics item. The <kbd>QGraphicsTransform</kbd> class inherits from the <kbd>QObject</kbd> class and improves functionality by means of the following functions:</p>
<p><kbd>applyTo(QtGui.QMatrix4x4)</kbd>: This function applies this transformation to the matrix specified in the parameter. This method needs to be reimplemented in derived classes.</p>
<p><kbd>update()</kbd>: This notifies that the operation associated with this transform operation has changed.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">QGraphicsRotation</h1>
                
            
            
                
<p>This class provides the rotation of a graphics item in the application. The declaration syntax of this class is as follows:</p>
<pre><strong>graphics_rotation</strong> = QtWidgets.QGraphicsRotation()</pre>
<p><kbd>QGraphicsRotation</kbd> inherits from the <kbd>QGraphicsTransform</kbd> class and improves functionality by means of the following functions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">set</h1>
                
            
            
                
<p>These are functions related to setting the parameters/properties in relation to the rotation:</p>
<p><kbd>graphics_rotation.setAngle(float)</kbd>: This sets the angle of this rotation. A value of <kbd>180.0</kbd> will rotate this item 180 degrees clockwise, while a value of <kbd>-180.0</kbd> will rotate this item 180 degrees counter-clockwise.</p>
<p class="mce-root"/>
<p><kbd>graphics_rotation.setAxis(QtGui.QVector3D)</kbd>: This sets the rotation axis, as specified in the parameter as a vector in 3D space. The vector can be (0, 0, 1), rotation around the <em>z</em> axis (the default), or (1, 0, 0), which will rotate the item around the <em>x</em> axis.</p>
<p><kbd>graphics_rotation.setAxis(QtCore.Qt.Axis)</kbd>: This sets the rotation axis specified in the parameter.</p>
<p><kbd>graphics_rotation.setOrigin(QtGui.QVector3D)</kbd>: This sets the origin point of the rotation in 3D space.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">functional</h1>
                
            
            
                
<p>These are functions that are related to the returns of the current values of the rotation:</p>
<p><kbd>graphics_rotation.angle()</kbd>: This returns the angle of this rotation in degrees.</p>
<p><kbd>graphics_rotation.axis()</kbd>: This returns the axis of the <kbd>QtGui.QVector3D</kbd> type for this rotation.</p>
<p><kbd>graphics_rotation.origin()</kbd>: This returns the origin of the <kbd>QtGui.QVector3D</kbd> type for this rotation.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">signals</h1>
                
            
            
                
<p>The available signals of the <kbd>QGraphicsRotation</kbd> class are as follows:</p>
<p><kbd>graphics_rotation.angleChanged()</kbd>: This signal is emitted when the angle of rotation changes.</p>
<p><kbd>graphics_rotation.axisChanged()</kbd>: This signal is emitted when the axis of rotation changes.</p>
<p><kbd>graphics_rotation.originChanged()</kbd>: This signal is emitted when the origin point of the rotation changes.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">QGraphicsScale</h1>
                
            
            
                
<p>This class provides a scale transformation of a graphics item. The declaration syntax of this class is as follows:</p>
<pre><strong>graphics_scale</strong> = QtWidgets.QGraphicsScale()</pre>
<p><kbd>QGraphicsScale</kbd> inherits from the <kbd>QGraphicsTransform</kbd> class and improves functionality by means of the following functions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">set</h1>
                
            
            
                
<p>These are functions related to setting the parameters/properties in relation to the scale:</p>
<p><kbd>graphics_scale.setOrigin(QtGui.QVector3D)</kbd>: This sets the origin point of the scale in a 3D space.</p>
<p><kbd>graphics_scale.setXScale(float)</kbd>: This sets the horizontal scale factor specified in the parameter. The default value is <kbd>1.0</kbd>. If the factor is <kbd>0.0</kbd>, the item will be collapsed into a single point. If the factor is a negative value, the item will be mirrored horizontally.</p>
<p><kbd>graphics_scale.setYScale(float)</kbd>: This sets the vertical scale factor specified in the parameter. The default value is <kbd>1.0</kbd>. If the factor is <kbd>0.0</kbd>, the item will be collapsed into a single point. If the factor is a negative value, the item will be flipped vertically.</p>
<p><kbd>graphics_scale.setZScale(float)</kbd>: This sets the depth scale factor specified in the parameter. The default value is <kbd>1.0</kbd>. If the factor is <kbd>0.0</kbd>, the item will be collapsed into a single point. If the factor is a negative value, the item will be flipped end to end.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">functional</h1>
                
            
            
                
<p>These are functions that are related to the returns of the current values of the scale:</p>
<p><kbd>graphics_scale.origin()</kbd>: This returns the origin of the <kbd>QtGui.QVector3D</kbd> type for this scale.</p>
<p><kbd>graphics_scale.xScale()</kbd>: This returns the horizontal scale factor.</p>
<p><kbd>graphics_scale.yScale()</kbd>: This returns the vertical scale factor.</p>
<p><kbd>graphics_scale.zScale()</kbd>: This returns the depth scale factor.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">signals</h1>
                
            
            
                
<p>The available signals of the <kbd>QGraphicsScale</kbd> class are as follows:</p>
<p><kbd>graphics_scale.originChanged()</kbd>: This signal is emitted when the origin point of the scale changes.</p>
<p><kbd>graphics_scale.scaleChanged()</kbd>: This signal is emitted when the scale changes.</p>
<p><kbd>graphics_scale.xScaleChanged()</kbd>: This signal is emitted when the horizontal scale changes.</p>
<p><kbd>graphics_scale.yScaleChanged()</kbd>: This signal is emitted when the vertical scale changes.</p>
<p><kbd>graphics_scale.zScaleChanged()</kbd>: This signal is emitted when the depth scale changes.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">QGraphicsItemAnimation</h1>
                
            
            
                
<p>In the PySide Python bindings, this class realizes animation support for graphics item-related classes. This class includes operations that are the most useful for an item in terms of receiving animation. The declaration syntax of this class is as follows:</p>
<pre><strong>item_animation</strong> = QtWidgets.QGraphicsItemAnimation()</pre>
<p>The <kbd>QGraphicsItemAnimation</kbd> class improves functionality by means of the following functions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">set</h1>
                
            
            
                
<p>These are functions related to setting the parameters/properties in relation to the item's animation:</p>
<p><kbd>item_animation.setItem(QtWidgets.QGraphicsItem)</kbd>: This sets the item that will be used in this animation.</p>
<p><kbd>item_animation.setPosAt(float, QtCore.QPointF)</kbd>: This sets the item's position at the step (the first parameter) to the point (the second parameter).</p>
<p class="mce-root"/>
<p><kbd>item_animation.setRotationAt(float, float)</kbd>: This sets the item's rotation at the step (the first parameter) to the angle (the second parameter).</p>
<p><kbd>item_animation.setScaleAt(float, float, float)</kbd>: This sets the item's scale at the step (the first parameter) with horizontal (the second parameter) and vertical (the third parameter) scale factors.</p>
<p><kbd>item_animation.setShearAt(float, float, float)</kbd>: This sets the item's shear at the step (the first parameter) with horizontal (the second parameter) and vertical (the third parameter) shear factors.</p>
<p><kbd>item_animation.setStep(float)</kbd>: This sets the current step, specified in the parameter, for this animation. The transformations are to be performed at this step.</p>
<p><kbd>item_animation.setTimeLine(QtCore.QTimeLine)</kbd>: This sets the timeline, specified in the parameter, that is used to control the rate of this animation.</p>
<p><kbd>item_animation.setTranslationAt(float, float, float)</kbd>: This sets the item's translation at the step (the first parameter) with horizontal (the second parameter) and vertical (the third parameter) coordinates.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">functional</h1>
                
            
            
                
<p>These are functions that are related to the returns of the current values of the item's animation, changes in functionality, and so on:</p>
<p><kbd>item_animation.clear()</kbd>: This clears the transformations that are used for this animation, with the item and timeline retained.</p>
<p><kbd>item_animation.horizontalScaleAt(float)</kbd>: This returns the horizontal scale for this item at the step specified in the parameter.</p>
<p><kbd>item_animation.horizontalShearAt(float)</kbd>: This returns the horizontal shear for this item at the step specified in the parameter.</p>
<p><kbd>item_animation.item()</kbd>: This returns the item of the <kbd>QtWidgets.QGraphicsItem</kbd> type on which this animation operates.</p>
<p><kbd>item_animation.matrixAt(float)</kbd>: This returns the matrix of the <kbd>QtGui.QMatrix</kbd> type that is used to transform the item at the step specified in the parameter.</p>
<p><kbd>item_animation.posAt(float)</kbd>: This returns the item's position of the <kbd>QtCore.QPointF</kbd> type at the step specified in the parameter.</p>
<p><kbd>item_animation.posList()</kbd>: This returns the list of all explicitly inserted positions.</p>
<p><kbd>item_animation.reset()</kbd>: This resets the item's animation to the starting position and transformation.</p>
<p><kbd>item_animation.rotationAt(float)</kbd>: This returns the angle at which this item is rotated at the step specified in the parameter.</p>
<p><kbd>item_animation.rotationList()</kbd>: This returns a list of all explicitly inserted rotations.</p>
<p><kbd>item_animation.scaleList()</kbd>: This returns a list of all explicitly inserted scales.</p>
<p><kbd>item_animation.shearList()</kbd>: This returns a list of all explicitly inserted shears.</p>
<p><kbd>item_animation.timeLine()</kbd>: This returns the timeline of the <kbd>QtCore.QTimeLine</kbd> type for this animation.</p>
<p><kbd>item_animation.translationList()</kbd>: This returns a list of all explicitly inserted translations.</p>
<p><kbd>item_animation.verticalScaleAt(float)</kbd>: This returns the vertical scale of the item at the step specified in the parameter.</p>
<p><kbd>item_animation.verticalShearAt(float)</kbd>: This returns the vertical shear of the item at the step specified in the parameter.</p>
<p><kbd>item_animation.xTranslationAt(float)</kbd>: This returns the horizontal translation of the item at the step specified in the parameter.</p>
<p><kbd>item_animation.yTranslationAt(float)</kbd>: This returns the vertical translation of the item at the step specified in the parameter.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Additional modules</h1>
                
            
            
                
<p>In addition to the graphics classes we've already described, Qt provides support for OpenGL, which is represented in a wide set of classes from the <kbd>QtGui</kbd> module. Also, the Qt library has additional modules for working with graphics in the GUI application. Modules that realize graphics support, such as <kbd>QtSvg</kbd>, <kbd>QtCharts</kbd>, <kbd>QtDataVisualization</kbd>, and 3D modules, such as <kbd>Qt3DCore</kbd>, <kbd>Qt3DInput</kbd> <kbd>Qt3DLogic</kbd>, <kbd>Qt3DRender</kbd>, <kbd>Qt3DExtras</kbd>, and <kbd>Qt3DAnimation</kbd>, are commonly used in development.</p>
<p>Now, let's consider the <kbd>QtSvg</kbd> module. It is recommended that you read the documentation (PySide2—<a href="https://doc.qt.io/qtforpython/index.html">https://doc.qt.io/qtforpython/index.html</a> and PyQt5—<a href="https://www.riverbankcomputing.com/static/Docs/PyQt5/">https://www.riverbankcomputing.com/static/Docs/PyQt5/</a>) if you want to learn about the other modules.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">QtSvg</h1>
                
            
            
                
<p>The <kbd>QtSvg</kbd> module realizes the handling of SVG images. SVG is a language that implements two-dimensional vector graphics. For use in an application, this module needs to be imported with the following statements:</p>
<p>First, we have the PySide2 <kbd>import</kbd> statement, as follows:</p>
<pre>from PySide2 import QtSvg</pre>
<p>Then, we have the PyQt5 <kbd>import</kbd> statement, as follows:</p>
<pre>from PyQt5 import QtSvg</pre>
<p>The <kbd>QtSvg</kbd> module includes the following classes.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">QSvgRenderer</h1>
                
            
            
                
<p>This class draws content from the SVG files using paint devices, such as <kbd>QPaintDevice</kbd>. The declaration syntax is as follows:</p>
<pre><strong>svg_renderer</strong> = QtSvg.QSvgRenderer()</pre>
<p>The <kbd>QSvgRenderer</kbd> class improves functionality by means of the following functions.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">set</h1>
                
            
            
                
<p>These are functions related to setting the parameters/properties in relation to the SVG renderer:</p>
<p><kbd>svg_renderer.setCurrentFrame(int)</kbd>: This sets the current frame in the animation.</p>
<p><kbd>svg_renderer.setFramesPerSecond(int)</kbd>: This sets the number of frames to be shown per second.</p>
<p><kbd>svg_renderer.setViewBox(QtCore.QRect)</kbd>: This sets the rectangle, specified in the parameter with integer values, that will be a visible area of the document.</p>
<p><kbd>svg_renderer.setViewBox(QRectF)</kbd>: This sets the rectangle, specified in the parameter with float values, that will be a visible area of the document.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">functional</h1>
                
            
            
                
<p>These are functions that are related to the returns of the current values of the SVG renderer, changes in functionality, and so on:</p>
<p><kbd>svg_renderer.animated()</kbd>: This returns <kbd>True</kbd> if animated elements are included.</p>
<p><kbd>svg_renderer.animationDuration()</kbd>: This returns the number of frames that are used in the animation.</p>
<p><kbd>svg_renderer.boundsOnElement(str)</kbd>: This returns the bounding rectangle of the <kbd>QtCore.QRectF</kbd> type for the item with the ID specified in the parameter.</p>
<p><kbd>svg_renderer.currentFrame()</kbd>: This returns the number of current frame in the animation.</p>
<p><kbd>svg_renderer.defaultSize()</kbd>: This returns the default size of the contents of the SVG file.</p>
<p><kbd>svg_renderer.elementExists(str)</kbd>: This returns <kbd>True</kbd> if the element with the ID specified in the parameter exists in the SVG file.</p>
<p><kbd>svg_renderer.framesPerSecond()</kbd>: This returns the number of frames to be shown per second.</p>
<p><kbd>svg_renderer.isValid()</kbd>: This returns <kbd>True</kbd> if the current document is valid.</p>
<p class="mce-root"/>
<p><kbd>svg_renderer.load("Path/to/file.svg")</kbd>: This loads the SVG file specified in the parameter, and returns <kbd>True</kbd> if the content was successfully parsed.</p>
<p><kbd>svg_renderer.load(QtCore.QXmlStreamReader)</kbd>: This loads SVG in content specified in the parameter, and returns <kbd>True</kbd> if the content was successfully parsed.</p>
<p><kbd>svg_renderer.load(QtCore.QByteArray)</kbd>: This loads the SVG format content specified in the parameter, and returns <kbd>True</kbd> if the content was successfully parsed.</p>
<p><kbd>svg_renderer.render(QtGui.QPainter)</kbd>: This renders the current document, or the current frame of the animated document, using the painter specified in the parameter.</p>
<p><kbd>svg_renderer.render(QtGui.QPainter, str, QtCore.QRectF)</kbd>: This renders the element with the ID (the second parameter) using the painter (the first parameter) on the bounds (the third parameter).</p>
<p><kbd>svg_renderer.render(QtGui.QPainter, QtCore.QRectF)</kbd>: This renders the current document using the painter (the first parameter) on the bounds (the second parameter).</p>
<p><kbd>svg_renderer.viewBox()</kbd>: This returns the visible area as the <kbd>QtCore.QRect</kbd> of the document.</p>
<p><kbd>svg_renderer.viewBoxF()</kbd>: This returns the visible area as the <kbd>QtCore.QRectF</kbd> of the document.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">signals</h1>
                
            
            
                
<p>The available signal of the <kbd>QSvgRenderer</kbd> class is as follows:</p>
<p><kbd>svg_renderer.repaintNeeded()</kbd>: The signal is emitted when the rendering of the document needs to be updated</p>


            

            
        
    

        

                            
                    <h1 class="header-title">QSvgGenerator</h1>
                
            
            
                
<p>This class is a write-only paint device for creations of the SVG drawings. The declaration syntax is as follows:</p>
<pre><strong>svg_generator</strong> = QtSvg.QSvgGenerator()</pre>
<p>The <kbd>QSvgGenerator</kbd> class improves functionality by means of the following functions.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">set</h1>
                
            
            
                
<p>These are functions related to setting the parameters/properties in relation to the SVG generator:</p>
<p><kbd>svg_generator.setDescription(str)</kbd>: This sets the description, specified in the parameter, for the generated SVG drawing.</p>
<p><kbd>svg_generator.setFileName("Path/to/file.svg")</kbd>: This sets the filename, specified in the parameter, that is used for generation of the SVG drawing.</p>
<p><kbd>svg_generator.setOutputDevice(QtCore.QIODevice)</kbd>: This sets the output device, specified in the parameter, that is used for generation of the SVG drawing.</p>
<p><kbd>svg_generator.setResolution(int)</kbd>: This sets the resolution for the generated output, in <strong>dots per inch</strong> (<strong>dpi</strong>), that will be used for calculating the physical size of the SVG drawing.</p>
<p><kbd>svg_generator.setSize(QtCore.QSize)</kbd>: This sets the size, specified in the parameter, that is used for generation of the SVG drawing.</p>
<p><kbd>svg_generator.setTitle(str)</kbd>: This sets the title, specified in the parameter, that is used for generation of the SVG drawing.</p>
<p><kbd>svg_generator.setViewBox(QtCore.QRect)</kbd>: This sets the view box, specified in the parameter with integer values, that is used for the generation of the SVG drawing.</p>
<p><kbd>svg_generator.setViewBox(QtCore.QRectF)</kbd>: This sets the view box, specified in the parameter with float values, that is used for the generation of the SVG drawing.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">functional</h1>
                
            
            
                
<p>These are functions that are related to the returns of the current values of the SVG generator, changes in functionality, and so on:</p>
<p><kbd>svg_generator.description()</kbd>: This returns a description of the SVG drawing that was generated.</p>
<p><kbd>svg_generator.fileName()</kbd>: This returns the filename of the SVG drawing that was generated.</p>
<p><kbd>svg_generator.outputDevice()</kbd>: This returns the output device of the <kbd>QtCore.QIODevice</kbd> type for the SVG drawing that was generated.</p>
<p><kbd>svg_generator.resolution()</kbd>: This returns the resolution of the output that was generated, in dpi.</p>
<p><kbd>svg_generator.size()</kbd>: This returns the size of the <kbd>QtCore.QSize</kbd> type for the SVG drawing that was generated.</p>
<p><kbd>svg_generator.title()</kbd>: This returns title of the SVG drawing that was  generated.</p>
<p><kbd>svg_generator.viewBox()</kbd>: This returns the view box of the <kbd>QtCore.QRect</kbd> type for the SVG drawing that was generated.</p>
<p><kbd>svg_generator.viewBoxF()</kbd>: This returns the view box of the <kbd>QtCore.QRectF</kbd> type for the SVG drawing that was generated.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">QGraphicsSvgItem</h1>
                
            
            
                
<p>This class is used to render the SVG file's contents. This can be used to render the content to the graphics view using the <kbd>QGraphicsView</kbd> class described in the previous chapter. The declaration syntax is as follows:</p>
<pre><strong>svg_item</strong> = QtSvg.QGraphicsSvgItem()</pre>
<p>The <kbd>QGraphicsSvgItem</kbd> class improves functionality by means of the following functions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">set</h1>
                
            
            
                
<p>These are functions related to setting the parameters/properties in relation to the SVG item:</p>
<p><kbd>svg_item.setElementId(str)</kbd>: This sets the XML ID, specified in the parameter, for the element.</p>
<p><kbd>svg_item.setMaximumCacheSize(QtCore.QSize)</kbd>: This sets the maximum size, specified in the parameter, of the device coordinate cache size for this item.</p>
<p><kbd>svg_item.setSharedRenderer(QtSvg.QSvgRenderer)</kbd>: This sets the renderer as shared. The renderer can be used on a number of items.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">functional</h1>
                
            
            
                
<p>These are functions that are related to the returns of the current values of the SVG item:</p>
<p><kbd>svg_item.elementId()</kbd>: This returns the XML ID of the currently rendered element.</p>
<p><kbd>svg_item.maximumCacheSize()</kbd>: This returns the maximum size of the device coordinate cache for this item.</p>
<p><kbd>svg_item.renderer()</kbd><strong>:</strong> This returns the current renderer of the <kbd>QtSvg.QSvgRenderer</kbd> type that is used for this SVG item.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">QSvgWidget</h1>
                
            
            
                
<p>This class displays SVG files with the widget. The declaration syntax is as follows:</p>
<pre><strong>svg_widget</strong> = QtSvg.QSvgWidget()</pre>
<p>The <kbd>QSvgWidget</kbd> class improves functionality by means of the following functions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">functional</h1>
                
            
            
                
<p>These are functions that are related to the returns of the current values of the SVG widget:</p>
<p><kbd>svg_widget.load("Path/to/file.svg")</kbd>: This loads the SVG file, specified in the parameter, and updates the widget.</p>
<p><kbd>svg_widget.load(QtCore.QByteArray)</kbd>: This loads the SVG format's contents, specified in the parameter, and updates the widget.</p>
<p><kbd>svg_widget.renderer()</kbd>: This returns the renderer of the <kbd>QtSvg.QSvgRenderer</kbd> type that's used to display the contents of the SVG widget.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Multimedia</h1>
                
            
            
                
<p>The Qt framework provides multimedia support for audio, video, radio, and camera functionality in the GUI application. The modules that can help you realize this are <kbd>QtMultimedia</kbd> and <kbd>QtMultimediaWidgets</kbd>. <kbd>QtMultimedia</kbd> includes classes for low-level working with multimedia, while <kbd>QtMultimediaWidgets</kbd> can represent the widget for media objects. The <kbd>QMediaPlayer</kbd> class of the <kbd>QtMultimedia</kbd> module can be organized to play a media source.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">QtMultimedia</h1>
                
            
            
                
<p>The <kbd>QtMultimedia</kbd> module realizes functionality for working with multimedia such as audio, video, radio, and camera. For use in the application, this module needs to be imported with the following statements.</p>
<p>We have the PySide2 <kbd>import</kbd> statement, as follows:</p>
<pre>from PySide2 import QtMultimedia</pre>
<p>We also have the PyQt5 <kbd>import</kbd> statement, as follows:</p>
<pre>from PyQt5 import QtMultimedia</pre>
<p>The <kbd>QtMultimedia</kbd> module includes classes such as <kbd>QAudio</kbd>, <kbd>QSound</kbd>, <kbd>QRadioTuner</kbd>, and <kbd>QVideoWindowControl</kbd>. Let's consider the available camera functionality, since this technology combines all media functionality.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">QMediaObject</h1>
                
            
            
                
<p>This is a basic class for multimedia objects in the <kbd>QtMultimedia</kbd> module. This class provides the basic functionality that's inherited by other multimedia classes that can be used in the application. The declaration of this class is as follows:</p>
<pre><strong>media_object</strong> = QtMultimedia.QMediaObject()</pre>
<p>The <kbd>QMediaObject</kbd> class improves functionality by means of the following functions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">add</h1>
                
            
            
                
<p>This function is related to the addition of properties to the media object:</p>
<p><kbd>media_object.addPropertyWatch(QtCore.QByteArray)</kbd>: This enables the media object to watch the property name.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">set</h1>
                
            
            
                
<p>This function is related to setting parameters/properties in relation to the media object:</p>
<p><kbd>media_object.setNotifyInterval(int)</kbd>: This sets the interval, specified in the parameter, for updating the properties, in milliseconds (the default is <kbd>1000</kbd>).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">is</h1>
                
            
            
                
<p>These are functions that return a Boolean value (<kbd>bool</kbd>) related to these media object states:</p>
<p><kbd>media_object.isAvailable()</kbd>: This returns <kbd>True</kbd> if the service is available.</p>
<p><kbd>media_object.isMetaDataAvailable()</kbd>: This returns <kbd>True</kbd> if the metadata associated with this media object is available.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">functional</h1>
                
            
            
                
<p>These are functions that are related to the returns of the current values of the media object, changes in functionality, and so on:</p>
<p><kbd>media_object.availability()</kbd>: This returns the availability of the functionality offered by this object as the <kbd>QtMultimedia.QMultimedia.AvailabilityStatus</kbd> type.</p>
<p><kbd>media_object.availableMetaData()</kbd>: This returns a list of keys available for the metadata of the media object.</p>
<p><kbd>media_object.bind(QtCore.QObject)</kbd>: This binds the object, specified in the parameter, to this media object instance.</p>
<p><kbd>media_object.metaData(str)</kbd>: This returns the value associated with the metadata key specified in the parameter.</p>
<p><kbd>media_object.notifyInterval()</kbd>: This returns the interval for updating the properties.</p>
<p><kbd>media_object.removePropertyWatch(QtCore.QByteArray)</kbd>: This removes the property name from the list of properties.</p>
<p><kbd>media_object.service()</kbd>: This returns the media service that provides the functionality for this multimedia.</p>
<p><kbd>media_object.unbind(QtCore.QObject)</kbd>: This unbinds the object, specified in the parameter, from this media object.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">signals</h1>
                
            
            
                
<p>The available signals of the <kbd>QMediaObject</kbd> class are as follows:</p>
<p><kbd>media_object.availabilityChanged(bool)</kbd>: This signal is emitted when the availability state of this media object has changed, with respect to the availability passed in the parameter.</p>
<p><kbd>media_object.availabilityChanged(QtMultimedia.QMultimedia.AvailabilityStatus)</kbd>: This signal is emitted when the availability of the service of this media object has changed, with respect to the availability passed in the parameter.</p>
<p><kbd>media_object.metaDataAvailableChanged(bool)</kbd>: This signal is emitted when the metadata of this media object has changed, with respect to the available state passed in the parameter.</p>
<p><kbd>media_object.metaDataChanged()</kbd>: This signal is emitted when the metadata of this media object has changed.</p>
<p><kbd>media_object.metaDataChanged(str, object)</kbd>: This signal is emitted when the metadata element value (the second parameter) with the key (the first parameter) of this media object has changed.</p>
<p><kbd>media_object.notifyIntervalChanged(int)</kbd>: This signal is emitted when the notify interval period of this media object has changed, with the interval in milliseconds that is passed in the parameter.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">QCamera</h1>
                
            
            
                
<p>This class realizes the interface for available system camera devices. Implementing the camera functionality in the application demonstrates and combines almost all multimedia opportunities. The following multimedia classes will dive into various features that can be used with the camera device. The declaration syntax of this class is as follows:</p>
<pre><strong>camera</strong> = QtMultimedia.QCamera()</pre>
<p>The <kbd>QCamera</kbd> class improves functionality by means of the following functions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">set</h1>
                
            
            
                
<p>These are functions related to setting parameters/properties in relation to the camera:</p>
<p><kbd>camera.setCaptureMode(QtMultimedia.QCamera.CaptureModes)</kbd>: This sets the capture mode for this camera, and the configurations of what the camera captures, such as video or still images. The available capture modes are as follows:</p>
<ul>
<li><kbd>QtMultimedia.QCamera.CaptureViewfinder</kbd>: Only configured to display viewfinder.</li>
<li><kbd>QtMultimedia.QCamera.CaptureStillImage</kbd>: Configured for still frame capture.</li>
<li><kbd>QtMultimedia.QCamera.CaptureVideo</kbd>: Configured for video capture.</li>
</ul>
<p><kbd>camera.setViewfinder(QtMultimediaWidgets.QVideoWidget)</kbd>: This sets the video widget-based camera, with the viewfinder specified.</p>
<p><kbd>camera.setViewfinder(QtMultimediaWidgets.QGraphicsVideoItem)</kbd>: This sets the video item-based camera, with the viewfinder specified.</p>
<p><kbd>camera.setViewfinder(QtMultimedia.QAbstractVideoSurface)</kbd>: This sets a video surface, specified in the parameter, as the viewfinder of a camera.</p>
<p><kbd>camera.setViewfinderSettings(QtMultimedia.QCameraViewfinderSettings)</kbd>: This sets the viewfinder settings, specified in the parameter.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">is</h1>
                
            
            
                
<p>This function returns a Boolean value (<kbd>bool</kbd>) related to the camera states:</p>
<p><kbd>camera.isCaptureModeSupported(QtMultimedia.QCamera.CaptureModes)</kbd>: This returns <kbd>True</kbd> if the capture mode, specified in the parameter, is supported.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">functional</h1>
                
            
            
                
<p>These are functions that are related to the returns of the current values of the camera, changes in functionality, and so on:</p>
<p><kbd>camera.availableDevices()</kbd>: This returns a list of the camera devices that are available from the default service provider.</p>
<p><kbd>camera.captureMode()</kbd>: This returns the capture mode of the <kbd>QtMultimedia.QCamera.CaptureModes</kbd> type for this camera, and the configurations of what the camera captures, such as video or still images.</p>
<p><kbd>camera.deviceDescription(QtCore.QByteArray)</kbd>: This returns a description of this camera device.</p>
<p><kbd>camera.error()</kbd>: This returns the error state of the <kbd>QtMultimedia.QCamera.Error</kbd> type for this camera device. The errors that may occur are as follows:</p>
<ul>
<li><kbd>QtMultimedia.QCamera.NoError</kbd>—<kbd>0</kbd>: No errors.</li>
<li><kbd>QtMultimedia.QCamera.CameraError</kbd>—<kbd>1</kbd>: An error.</li>
<li><kbd>QtMultimedia.QCamera.InvalidRequestError</kbd>—<kbd>2</kbd>: The system resource doesn't support the functionality requested.</li>
<li><kbd>QtMultimedia.QCamera.ServiceMissingError</kbd>—<kbd>3</kbd>: No camera service available.</li>
<li><kbd>QtMultimedia.QCamera.NotSupportedFeatureError</kbd>—<kbd>4</kbd>: The feature is not supported.</li>
</ul>
<p><kbd>camera.errorString()</kbd>: This returns the error state as a description string for this camera device.</p>
<p><kbd>camera.exposure()</kbd>: This returns the exposure control object of this camera.</p>
<p><kbd>camera.focus()</kbd>: This returns the focus control object of this camera.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p><kbd>camera.imageProcessing()</kbd>: This returns the image processing control object of this camera.</p>
<p><kbd>camera.load()</kbd>: This opens this camera device. The status of the camera is changed to <kbd>QCamera.LoadedStatus</kbd>. It is used to read and change the supported camera settings and capabilities.</p>
<p><kbd>camera.lockStatus()</kbd>: This returns the lock status of the <kbd>QtMultimedia.QCamera.LockStatus</kbd> type for the requested camera settings locks. The lock statuses that can be returned are as follows:</p>
<ul>
<li><kbd>QtMultimedia.QCamera.Unlocked</kbd>—<kbd>0</kbd>: Unlocked.</li>
<li><kbd>QtMultimedia.QCamera.Searching</kbd>—<kbd>1</kbd>: Focusing or calculating exposure and white balance.</li>
<li><kbd>QtMultimedia.QCamera.Locked</kbd>—<kbd>2</kbd>: Ready to capture.</li>
</ul>
<p><kbd>camera.lockStatus(QtMultimedia.QCamera.LockType)</kbd>: This returns the lock status for the lock type, specified in the parameter. The available lock types are as follows:</p>
<ul>
<li><kbd>QtMultimedia.QCamera.NoLock</kbd>: No locks.</li>
<li><kbd>QtMultimedia.QCamera.LockExposure</kbd>: Locks exposure.</li>
<li><kbd>QtMultimedia.QCamera.LockWhiteBalance</kbd>: Locks white balance.</li>
<li><kbd>QtMultimedia.QCamera.LockFocus</kbd>: Locks focus.</li>
</ul>
<p><kbd>camera.requestedLocks()</kbd>: This returns the requested lock types.</p>
<p><kbd>camera.searchAndLock()</kbd>: This locks all the supported camera settings.</p>
<p><kbd>camera.searchAndLock(QtMultimedia.QCamera.LockTypes)</kbd>: This locks the camera with requested locks, as specified in the parameter.</p>
<p><kbd>camera.start()</kbd>: This starts this camera device.</p>
<p><kbd>camera.state()</kbd>: This returns the current state of the <kbd>QtMultimedia.QCamera.State</kbd> type for this camera object. The states that can be returned are as follows:</p>
<ul>
<li><kbd>QtMultimedia.QCamera.UnloadedState</kbd>—<kbd>0</kbd>: Initial camera state.</li>
<li><kbd>QtMultimedia.QCamera.LoadedState</kbd>—<kbd>1</kbd>: Camera is loaded and ready to be configured.</li>
<li><kbd>QtMultimedia.QCamera.ActiveState</kbd>—<kbd>2</kbd>: Camera is ready for capture.</li>
</ul>
<p><kbd>camera.status()</kbd>: This returns the current status of the <kbd>QtMultimedia.QCamera.Status</kbd> type for this camera object. The statuses that can be returned are as follows:</p>
<ul>
<li><kbd>QtMultimedia.QCamera.UnavailableStatus</kbd>—<kbd>0</kbd>: Camera unavailable.</li>
<li><kbd>QtMultimedia.QCamera.UnloadedStatus</kbd>—<kbd>1</kbd>: Camera not loaded.</li>
<li><kbd>QtMultimedia.QCamera.LoadingStatus</kbd>—<kbd>2</kbd>: Camera loading.</li>
<li><kbd>QtMultimedia.QCamera.UnloadingStatus</kbd>—<kbd>3</kbd>: Camera unloading.</li>
<li><kbd>QtMultimedia.QCamera.LoadedStatus</kbd>—<kbd>4</kbd>: Camera is loaded and ready to be configured.</li>
<li><kbd>QtMultimedia.QCamera.StandbyStatus</kbd>—<kbd>5</kbd>: Camera is in power saving standby mode.</li>
<li><kbd>QtMultimedia.QCamera.StartingStatus</kbd>—<kbd>6</kbd>: Camera is starting.</li>
<li><kbd>QtMultimedia.QCamera.StoppingStatus</kbd>—<kbd>7</kbd>: Camera is stopping.</li>
<li><kbd>QtMultimedia.QCamera.ActiveStatus</kbd>—<kbd>8</kbd>: Camera has been started and can produce data.</li>
</ul>
<p><kbd>camera.stop()</kbd>: This stops the camera. The camera state is changed from <kbd>ActiveState</kbd> to <kbd>LoadedState</kbd>.</p>
<p><kbd>camera.supportedLocks()</kbd>: This returns the supported lock types for this camera device.</p>
<p><kbd>camera.supportedViewfinderFrameRateRanges(QtMultimedia.QCameraViewfinderSettings)</kbd>: This returns a list of viewfinder frame rate ranges that are supported for this camera device.</p>
<p><kbd>camera.supportedViewfinderPixelFormats(QtMultimedia.QCameraViewfinderSettings)</kbd>: This returns a list of viewfinder pixel formats that are supported for this camera device.</p>
<p><kbd>camera.supportedViewfinderResolutions(QtMultimedia.QCameraViewfinderSettings)</kbd>: This returns a list of viewfinder resolutions that are supported for this camera device.</p>
<p><kbd>camera.supportedViewfinderSettings(QtMultimedia.QCameraViewfinderSettings)</kbd>: This returns a list of viewfinder settings that are supported for this camera device.</p>
<p><kbd>camera.unload()</kbd>: This closes the camera and deallocates the related resources by changing the status of the camera to <kbd>UnloadedStatus</kbd>.</p>
<p><kbd>camera.unlock()</kbd>: This unlocks all the camera locks.</p>
<p><kbd>camera.unlock(QtMultimedia.QCamera.LockTypes)</kbd>: This unlocks the camera settings specified in the parameter.</p>
<p><kbd>camera.viewfinderSettings()</kbd>: This returns the viewfinder settings of the <kbd>QtMultimedia.QCameraViewfinderSettings</kbd> type that are used by this camera.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">signals</h1>
                
            
            
                
<p>The available signals of the <kbd>QCamera</kbd> class are as follows:</p>
<p><kbd>camera.captureModeChanged(QtMultimedia.QCamera.CaptureModes)</kbd>: This signal is emitted when the capture mode changes.</p>
<p><kbd>camera.error()</kbd>: This signal is emitted when the error state changes.</p>
<p><kbd>camera.error(QtMultimedia.QCamera.Error)</kbd>: This signal is emitted when the error state changes to the value passed in the parameter.</p>
<p><kbd>camera.locked()</kbd>: This signal is emitted when all the requested camera settings are locked.</p>
<p><kbd>camera.lockFailed()</kbd>: This signal is emitted when the locking of at least one requested camera setting fails.</p>
<p><kbd>camera.lockStatusChanged(QtMultimedia.QCamera.LockStatus, QtMultimedia.QCamera.LockChangeReason)</kbd>: This signal is emitted when the overall status (the first parameter) for all the requested camera locks is changed without a reason (the second parameter). The available change reason parameters are as follows:</p>
<ul>
<li><kbd>QtMultimedia.QCamera.UserRequest</kbd>—<kbd>0</kbd>: Lock status changed with a user request.</li>
<li><kbd>QtMultimedia.QCamera.LockAcquired</kbd>—<kbd>1</kbd>: Lock status successfully changed to <kbd>Locked</kbd>.</li>
<li><kbd>QtMultimedia.QCamera.LockFailed</kbd>—<kbd>2</kbd>: Failed to acquire the requested lock.</li>
<li><kbd>QtMultimedia.QCamera.LockLost</kbd>—<kbd>3</kbd>: No longer able to maintain the requested lock; status changed to <kbd>Unlocked</kbd>.</li>
<li><kbd>QtMultimedia.QCamera.LockTemporaryLost</kbd>—<kbd>4</kbd>: The lock is lost, but the camera is working to reacquire it.</li>
</ul>
<p><kbd>camera.stateChanged(QtMultimedia.QCamera.State)</kbd>: This signal is emitted when the camera state, specified in the parameter, changes.</p>
<p><kbd>camera.statusChanged(QtMultimedia.QCamera.Status)</kbd>: This signal is emitted when the camera status, specified in the parameter, changes.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">QCameraFocusZone</h1>
                
            
            
                
<p>This class provides information about zones that are used for autofocusing a camera. The zones and zone locations that will be used depend on the camera's capabilities. This can be used for drawing rectangles around areas of the camera frame that are in focus, or for changing the color of a zone. The declaration of this class is as follows:</p>
<pre><strong>camera_focus_zone</strong> = QtMultimedia.QCameraFocusZone()</pre>
<p>The <kbd>QCameraFocusZone</kbd> class improves functionality by means of the following functions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">set</h1>
                
            
            
                
<p>This  function is related to setting parameters/properties in relation to the camera focus zone:</p>
<p><kbd>camera_focus_zone.setStatus(QtMultimedia.QCameraFocusZone.FocusZoneStatus)</kbd>: This sets the status, specified in the parameter, for this camera focus zone. The available focus zone parameters are as follows:</p>
<ul>
<li><kbd>QtMultimedia.QCameraFocusZone.Invalid</kbd>—<kbd>0</kbd>: Zone is not valid.</li>
<li><kbd>QtMultimedia.QCameraFocusZone.Unused</kbd>—<kbd>1</kbd>: Zone is unused but available.</li>
<li><kbd>QtMultimedia.QCameraFocusZone.Selected</kbd>—<kbd>2</kbd>: Zone is used for autofocusing, but is not in focus.</li>
<li><kbd>QtMultimedia.QCameraFocusZone.Focused</kbd>—<kbd>3</kbd>: Zone is used for autofocusing, and is in focus.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">is</h1>
                
            
            
                
<p>This function returns a Boolean value (<kbd>bool</kbd>) related to these camera focus zone states:</p>
<p><kbd>camera_focus_zone.isValid()</kbd>: This returns <kbd>True</kbd> if the camera focus zone has a valid area and status.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">functional</h1>
                
            
            
                
<p>These are functions that are related to the current values of the camera focus zone:</p>
<p><kbd>camera_focus_zone.area()</kbd>: This returns the camera's frame area of the <kbd>QtCore.QRectF</kbd> type that this focus zone encompasses.</p>
<p><kbd>camera_focus_zone.status()</kbd>: This returns the current status of the <kbd>QtMultimedia.QCameraFocusZone.FocusZoneStatus</kbd> type for this camera focus zone.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">QCameraImageCapture</h1>
                
            
            
                
<p>This is the class that's used for recording the media content from the camera device. The declaration of this class is as follows:</p>
<pre><strong>camera_image_capture</strong> = QtMultimedia.QCameraImageCapture()</pre>
<p>The <kbd>QCameraImageCapture</kbd> class improves functionality by means of the following functions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">set</h1>
                
            
            
                
<p>These are functions related to setting parameters/properties in relation to the camera image capture:</p>
<p><kbd>camera_image_capture.setBufferFormat(QtMultimedia.QVideoFrame.PixelFormat)</kbd>: This sets the buffer image capture format, specified in the parameter, that will be used.</p>
<p class="mce-root"/>
<p><kbd>camera_image_capture.setCaptureDestination(QtMultimedia.QCameraImageCapture.CaptureDestinations)</kbd>: This sets the capture destination, specified in the parameter, that will be used. The available capture destinations are as follows:</p>
<ul>
<li><kbd>QtMultimedia.QCameraImageCapture.CaptureToFile</kbd>: This captures to a file.</li>
<li><kbd>QtMultimedia.QCameraImageCapture.CaptureToBuffer</kbd>: This captures to a buffer.</li>
</ul>
<p><kbd>camera_image_capture.setEncodingSettings(QtMultimedia.QImageEncoderSettings)</kbd>: This sets the image encoding settings specified in the parameter.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">is</h1>
                
            
            
                
<p>These are functions that return a Boolean value (<kbd>bool</kbd>) related to these camera image capture states:</p>
<p><kbd>camera_image_capture.isAvailable()</kbd>: This returns <kbd>True</kbd> if the image capture is ready to use.</p>
<p><kbd>camera_image_capture.isCaptureDestinationSupported(QtMultimedia.QCameraImageCapture.CaptureDestinations)</kbd>: This returns <kbd>True</kbd> if the image capture destination, specified in the parameter, is supported.</p>
<p><kbd>camera_image_capture.isReadyForCapture()</kbd>: This returns <kbd>True</kbd> if the service is ready to capture an image.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">functional</h1>
                
            
            
                
<p>These are functions that are related to the returns of the current values of the camera image capture, changes in functionality, and so on:</p>
<p><kbd>camera_image_capture.availability()</kbd>: This returns the availability of the <kbd>QtMultimedia.QMultimedia.AvailabilityStatus</kbd> type for this functionality.</p>
<p><kbd>camera_image_capture.bufferFormat()</kbd>: This returns the buffer image capture format of the <kbd>QtMultimedia.QVideoFrame.PixelFormat</kbd> type that is used.</p>
<p><kbd>camera_image_capture.cancelCapture()</kbd>: This cancels incomplete capture requests.</p>
<p><kbd>camera_image_capture.capture("Full/Path/to/the/folder/filename.jpg")</kbd>: This captures the image and saves it to file, as specified in the parameter.</p>
<p><kbd>camera_image_capture.captureDestination()</kbd>: This returns the image capture destination of the <kbd>QtMultimedia.QCameraImageCapture.CaptureDestinations</kbd> type that is used.</p>
<p><kbd>camera_image_capture.encodingSettings()</kbd>: This returns the image encoding settings of the <kbd>QtMultimedia.QImageEncoderSettings</kbd> type that is used.</p>
<p><kbd>camera_image_capture.error()</kbd>: This returns the error state of the <kbd>QtMultimedia.QCameraImageCapture.Error</kbd> type.</p>
<p><kbd>camera_image_capture.errorString()</kbd>: This returns the error state as a string description.</p>
<p><kbd>camera_image_capture.imageCodecDescription(str)</kbd>: This returns a description of the image codec specified in the parameter.</p>
<p><kbd>camera_image_capture.supportedBufferFormats()</kbd>: This returns a list of supported buffer image capture formats.</p>
<p><kbd>camera_image_capture.supportedImageCodecs()</kbd>: This returns a list of supported image codecs.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">signals</h1>
                
            
            
                
<p>The available signals of the <kbd>QCameraImageCapture</kbd> class are as follows:</p>
<p><kbd>camera_image_capture.bufferFormatChanged(QtMultimedia.QVideoFrame.PixelFormat)</kbd>: This signal is emitted when the buffer format, passed in the parameter, for the buffer image capture changes.</p>
<p><kbd>camera_image_capture.captureDestinationChanged(QtMultimedia.QCameraImageCapture.CaptureDestinations)</kbd>: This signal is emitted when the capture destination, passed in the parameter, changes.</p>
<p><kbd>camera_image_capture.imageAvailable(int, QtMultimedia.QVideoFrame)</kbd>: This signal is emitted when the frame (the second parameter) with the request ID (the first parameter) is available.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p><kbd>camera_image_capture.imageCaptured(int, QtGui.QImage)</kbd>: This signal is emitted when the frame (the second parameter) with the request ID (the first parameter) is captured.</p>
<p><kbd>camera_image_capture.imageExposed(int)</kbd>: This signal is emitted when the frame with the request ID, specified in the parameter, is exposed.</p>
<p><kbd>camera_image_capture.imageMetadataAvailable(int, str, object)</kbd>: This signal is emitted when the metadata for an image with the request ID (the first parameter) is available, with the key (the second parameter) and value (the third parameter) of the metadata included.</p>
<p><kbd>camera_image_capture.imageSaved(int, str)</kbd>: This signal is emitted when the frame with the request ID (the first parameter) is saved to the filename (the second parameter).</p>
<p><kbd>camera_image_capture.readyForCaptureChanged(bool)</kbd>: This signal is emitted when the camera's ready parameter changes, as specified, for the capture state.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">QCameraInfo</h1>
                
            
            
                
<p>This class represents general information regarding the available camera device. The declaration syntax of this class is as follows:</p>
<pre><strong>camera_info</strong> = QtMultimedia.QCameraInfo()</pre>
<p>The <kbd>QCameraInfo</kbd> class improves functionality by means of the following functions:</p>
<p><kbd>camera_info.availableCameras(QtMultimedia.QCamera.Position)</kbd>: This returns a list of available cameras that are located at positions specified in the parameter. The positions that can be used for this function are as follows:</p>
<ul>
<li><kbd>QtMultimedia.QCamera.UnspecifiedPosition</kbd>—<kbd>0</kbd>: Camera position is unspecified.</li>
<li><kbd>QtMultimedia.QCamera.BackFace</kbd>—<kbd>1</kbd>: Camera position on the opposite side to the device screen.</li>
<li><kbd>QtMultimedia.QCamera.FrontFace</kbd>—<kbd>2</kbd>: Camera position on the same side to the device screen.</li>
</ul>
<p><kbd>camera_info.defaultCamera()</kbd>: This returns the default camera.</p>
<p><kbd>camera_info.description()</kbd>: This returns a description regarding the camera.</p>
<p><kbd>camera_info.deviceName()</kbd>: This returns the name of the camera as a unique ID.</p>
<p><kbd>camera_info.isNull()</kbd>: This returns <kbd>True</kbd> if <kbd>QCameraInfo</kbd> is null or is invalid.</p>
<p><kbd>camera_info.orientation()</kbd>: This returns the physical orientation angle of this camera sensor.</p>
<p><kbd>camera_info.position()</kbd>: This returns the physical position of the <kbd>QtMultimedia.QCamera.Position</kbd> type for this camera on the hardware system.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">QCameraViewfinderSettings</h1>
                
            
            
                
<p>This class provides the viewfinder settings that can be set with the <kbd>QCamera</kbd> class. The declaration of this class is as follows:</p>
<pre><strong>viewfinder_settings</strong> = QtMultimedia.QCameraViewfinderSettings()</pre>
<p>The <kbd>QCameraViewfinderSettings</kbd> class improves functionality by means of the following functions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">set</h1>
                
            
            
                
<p>These are functions related to setting parameters/properties in relation to the viewfinder settings:</p>
<p><kbd>viewfinder_settings.setMaximumFrameRate(float)</kbd>: This sets the maximum frame rate, specified in the parameter, in frames per second for the viewfinder.</p>
<p><kbd>viewfinder_settings.setMinimumFrameRate(float)</kbd>: This sets the minimum frame rate, specified in the parameter, in frames per second for the viewfinder.</p>
<p><kbd>viewfinder_settings.setPixelAspectRatio(QtCore.QSize)</kbd>: This sets the pixel aspect ratio, specified in the parameter, for the viewfinder.</p>
<p><kbd>viewfinder_settings.setPixelAspectRatio(int, int)</kbd>: This sets the pixel aspect ratio as horizontal (the first parameter) and vertical (the second parameter) elements for the viewfinder.</p>
<p><kbd>viewfinder_settings.setPixelFormat(QtMultimedia.QVideoFrame.PixelFormat)</kbd>: This sets the pixel format, specified in the parameter, for the viewfinder.</p>
<p><kbd>viewfinder_settings.setResolution(QtCore.QSize)</kbd>: This sets the resolution, specified in the parameter, for the viewfinder.</p>
<p><kbd>viewfinder_settings.setResolution(w, h)</kbd>: This sets the resolution specified by <kbd>w</kbd> (width) and <kbd>h</kbd> (height) for the viewfinder.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">is</h1>
                
            
            
                
<p>This function returns a Boolean value (<kbd>bool</kbd>) related to these viewfinder setting states:</p>
<p><kbd>viewfinder_settings.isNull()</kbd>: This returns <kbd>True</kbd> if the viewfinder settings are <kbd>null</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">functional</h1>
                
            
            
                
<p>These are functions that are related to the returns of the current values of the viewfinder settings, changes in functionality, and so on:</p>
<p><kbd>viewfinder_settings.maximumFrameRate()</kbd>: This returns the maximum frame rate in frames per second for the viewfinder.</p>
<p><kbd>viewfinder_settings.minimumFrameRate()</kbd>: This returns the minimum frame rate in frames per second for the viewfinder.</p>
<p><kbd>viewfinder_settings.pixelAspectRatio()</kbd>: This returns the pixel aspect ratio of the <kbd>QtCore.QSize</kbd> type for the viewfinder.</p>
<p><kbd>viewfinder_settings.pixelFormat()</kbd>: This returns the pixel format of the <kbd>QtMultimedia.QVideoFrame.PixelFormat</kbd> type for the viewfinder.</p>
<p><kbd>viewfinder_settings.resolution()</kbd>: This returns the resolution of the <kbd>QtCore.QSize</kbd> type for the viewfinder.</p>
<p><kbd>viewfinder_settings.swap(QtMultimedia.QCameraViewfinderSettings)</kbd>: This swaps the settings of this viewfinder with those of the viewfinder specified in the parameter.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">QtMultimediaWidgets</h1>
                
            
            
                
<p>The <kbd>QtMultimediaWidgets</kbd> module realizes the visualization of the constructed multimedia objects. For use in the application, this module needs to be imported with the following statements.</p>
<p>We have the PySide2 <kbd>import</kbd> statement, as follows:</p>
<pre>from PySide2 import QtMultimediaWidgets</pre>
<p>We also have the PyQt5 <kbd>import</kbd> statement, as follows:</p>
<pre>from PyQt5 import QtMultimediaWidgets</pre>
<p>The <kbd>QtMultimediaWidgets</kbd> module includes classes such as <kbd>QCameraViewfinder</kbd> and <kbd>QGraphicsVideoItem</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">QVideoWidget</h1>
                
            
            
                
<p>This class represents the widget for a video that's produced by a media object. The declaration syntax of this class is as follows:</p>
<pre><strong>video_widget</strong> = QtMultimedia.QVideoWidget()</pre>
<p>The <kbd>QVideoWidget</kbd> class improves functionality by means of the following functions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">set</h1>
                
            
            
                
<p>These are functions related to setting parameters/properties in relation to the video widget:</p>
<p><kbd>video_widget.setAspectRatioMode(QtCore.Qt.AspectRatioMode)</kbd>: This sets the mode, specified in the parameter, that represents how video is scaled to its aspect ratio.</p>
<p><kbd>video_widget.setBrightness(int)</kbd>: This sets the brightness value, specified in the parameter, for video displayed in this video widget. A valid value lies in a range between <kbd>-100</kbd> and <kbd>100</kbd>.</p>
<p><kbd>video_widget.setContrast(int)</kbd>: This sets the contrast value, specified in the parameter, for video displayed in this video widget. A valid value lies in a range between <kbd>-100</kbd> and <kbd>100</kbd>.</p>
<p><kbd>video_widget.setFullScreen(bool)</kbd>: If the parameter is <kbd>True</kbd>, the video displayed will be in full screen mode.</p>
<p><kbd>video_widget.setHue(int)</kbd>: This sets the hue value, specified in the parameter, for video displayed in this video widget. A valid value lies in a range between <kbd>-100</kbd> and <kbd>100</kbd>.</p>
<p><kbd>video_widget.setMediaObject(QtMultimedia.QMediaObject)</kbd>: This sets the media object, specified in the parameter, that will be displayed by this video widget.</p>
<p><kbd>video_widget.setSaturation(int)</kbd>: This sets the saturation value, specified in the parameter, for video displayed in this video widget. A valid value lies in a range between <kbd>-100</kbd> and <kbd>100</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">functional</h1>
                
            
            
                
<p>These are functions that are related to the returns of the current values of the video widget:</p>
<p><kbd>video_widget.aspectRatioMode()</kbd>: This returns the aspect ratio mode of the <kbd>QtCore.Qt.AspectRatioMode</kbd> type.</p>
<p><kbd>video_widget.brightness()</kbd>: This returns the brightness of the video displayed.</p>
<p><kbd>video_widget.contrast()</kbd>: This returns the contrast of the video displayed.</p>
<p><kbd>video_widget.hue()</kbd>: This returns the hue of the video displayed.</p>
<p><kbd>video_widget.mediaObject()</kbd>: This returns the media object displayed by this video widget.</p>
<p><kbd>video_widget.saturation()</kbd>: This returns the saturation of the video displayed.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">events</h1>
                
            
            
                
<p>These are functions that are related to events, such as event handlers:</p>
<p><kbd>video_widget.event(QtCore.QEvent)</kbd>: This receives events to the video widget and should return <kbd>True</kbd> if the event is recognized and processed.</p>
<p><kbd>video_widget.hideEvent(QtGui.QHideEvent)</kbd>: This is an event handler that's designed to receive the hide events for the video widget, with events passed in the parameter.</p>
<p><kbd>video_widget.moveEvent(QtGui.QMoveEvent)</kbd>: This is an event handler that's designed to receive move events for the video widget, with events passed in the parameter.</p>
<p><kbd>video_widget.paintEvent(QtGui.QPaintEvent)</kbd>: This is an event handler that's designed to receive paint events for the video widget, with events passed in the parameter.</p>
<p><kbd>video_widget.resizeEvent(QtGui.QResizeEvent)</kbd>: This is an event handler that's designed to receive resize events for the video widget, with events passed in the parameter.</p>
<p><kbd>video_widget.showEvent(QtGui.QShowEvent)</kbd>: This is an event handler that's designed to receive show events for the video widget, with events passed in the parameter.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">signals</h1>
                
            
            
                
<p>The available signals of the <kbd>QVideoWidget</kbd> class are as follows:</p>
<p><kbd>video_widget.brightnessChanged(int)</kbd>: This signal is emitted when the brightness adjustment, passed in the parameter, changes.</p>
<p><kbd>video_widget.contrastChanged(int)</kbd>: This signal is emitted when the contrast adjustment, passed in the parameter, changes.</p>
<p><kbd>video_widget.fullScreenChanged(bool)</kbd>: This signal is emitted when the full screen mode of a video widget changes, with the availability of the mode passed in the parameter.</p>
<p><kbd>video_widget.hueChanged(int)</kbd>: This signal is emitted when the hue adjustment, passed in the parameter, changes.</p>
<p><kbd>video_widget.saturationChanged(int)</kbd>: This signal is emitted when the saturation adjustment, passed in the parameter, changes.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Camera example</h1>
                
            
            
                
<p>To demonstrate multimedia functionality in the GUI application, we will implement the camera with simple features, such as capturing an image. Using the camera in the application is the most popular and well-explained multimedia form. To begin, create <kbd>u_media.py</kbd> files in both the <kbd>App/App_PySide2/</kbd> and <kbd>App/App_PyQt5/</kbd> directories. Then, in these directories, create the <kbd>camera/</kbd> folder, and, within this, a <kbd>captures/</kbd> folder to save captured images. The paths will be <kbd>App/App_PySide2/camera/captures/</kbd> and <kbd>App/App_PyQt5/camera/captures/</kbd>. Insert the following lines into the <kbd>u_media.py</kbd> files:</p>
<ol>
<li>In the case of PyQt5, insert the following into the <kbd>import</kbd> section of the <kbd>u_media.py</kbd> file:</li>
</ol>
<pre style="padding-left: 60px">...<br/>import os<br/>from PyQt5 import QtMultimedia, QtMultimediaWidgets<br/>from PyQt5 import QtWidgets, QtCore, QtGui<br/>from u_style import UBut1<br/>...</pre>
<ol start="2">
<li>In the case of PySide2, insert the following into the <kbd>import</kbd> section of the <kbd>u_media.py</kbd> file:</li>
</ol>
<pre style="padding-left: 60px">...<br/>import os<br/>from PySide2 import QtMultimedia, QtMultimediaWidgets<br/>from PySide2 import QtWidgets, QtCore, QtGui<br/>from u_style import UBut1<br/>...</pre>
<ol start="3">
<li>Create the <kbd>UMedia</kbd> class using the <kbd>QCameraViewfinder</kbd> class that inherits from <kbd>QVideoWidget</kbd>:</li>
</ol>
<pre style="padding-left: 60px">...<br/>class UMedia(QtMultimediaWidgets.QCameraViewfinder):<br/><br/>    def __init__(self, parent=None):<br/>        super(UMedia, self).__init__(parent)<br/>        self.setWindowTitle("U Camera")<br/>        win_icon = QtGui.QIcon("Icons/python1.png")<br/>        self.setWindowIcon(win_icon)<br/>        self.setWindowOpacity(1)<br/>        self.camera = QtMultimedia.QCamera()<br/>        self.camera.setViewfinder(self)<br/>        self.camera.start()<br/>        self.cambut1 = UBut1(self, pad=10)<br/>        self.cambut1.setText("Capture")<br/>        self.cambut1.setVisible(False)<br/>        self.cambut1.clicked.connect(self.img_capture)<br/>        self.vc_grid = QtWidgets.QGridLayout()<br/>        self.vc_grid.addWidget(self.cambut1, 0, 0, 1, 1)<br/>        self.vc_grid.setAlignment(QtCore.Qt.AlignTop)<br/>        self.setLayout(self.vc_grid)<br/>    ...<br/>...</pre>
<p class="mce-root" style="padding-left: 60px">In this class, we have added the camera instance, set the viewfinder, added a button, and arranged all the elements with a grid layout.</p>
<ol start="4">
<li>Add the function for capturing images to this class:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    def img_capture(self):.<br/>        image_capture = QtMultimedia.QCameraImageCapture(<br/>                                               self.camera)<br/>        image_capture.setCaptureDestination(<br/>            QtMultimedia.QCameraImageCapture.CaptureToFile)<br/>        self.camera.setCaptureMode(<br/>                    QtMultimedia.QCamera.CaptureStillImage)<br/>        filename = os.path.dirname(os.path.abspath(__file__))<br/>        camera_path = os.path.join(filename, "camera/captures/")<br/>        image_capture.capture(os.path.normpath(camera_path))<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">This function will be called if the button is clicked. The current camera frame will be captured and saved to the <kbd>captures/</kbd> folder.</p>
<ol start="5">
<li>Add the enter event handler to the <kbd>UMedia</kbd> class, after the <kbd>img_capture()</kbd> function:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    def enterEvent(self, event):<br/>        self.cambut1.setVisible(True)<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">If the mouse pointer enters the widget area, the button will be displayed.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<ol start="6">
<li>Add the leave event handler for this widget:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    def leaveEvent(self, event):<br/>        self.cambut1.setVisible(False)<br/>...</pre>
<p style="padding-left: 60px">If the mouse pointer leaves the widget's area, the button will be invisible.</p>
<ol start="7">
<li>To use this file with the <kbd>subprocesses</kbd> module as much as possible. Add the following lines to the <kbd>u_media.py</kbd> file:</li>
</ol>
<pre style="padding-left: 60px">if __name__ == "__main__":<br/>    import sys<br/>    app = QtWidgets.QApplication(sys.argv)<br/>    uap_vc = UMedia()<br/>    uap_vc.show()<br/>    sys.exit(app.exec_())</pre>
<p style="padding-left: 60px">If this file starts as an application window or with the <kbd>subprocess</kbd> module, this instruction will be realized. If the class of this file is used as part of another application, this instruction will not be used.</p>
<p>Now, insert the following lines in the <kbd>u_app.py</kbd> files:</p>
<ol>
<li>At the end of the <kbd>UApp</kbd> class, add the following function:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    def video_camera(self):<br/>        subprocess.Popen(["python", r"u_media.py"])<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">This function will run the <kbd>u_media.py</kbd> file as a subprocess.</p>
<ol start="2">
<li>At the end of the <kbd>__init__()</kbd> function of the <kbd>UApp</kbd> class, temporarily add the following line to call the <kbd>video_camera</kbd> function:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    def __init__(self, parent=None):<br/>        ...<br/>        self.video_camera()<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">This will call the function with a subprocess when the application starts.</p>
<ol start="3">
<li>Finally, at the end of  the <kbd>u_app.py</kbd> file, we can add an <kbd>import</kbd> of the <kbd>subprocess</kbd><strong> </strong>Python standard library module as follows:</li>
</ol>
<pre style="padding-left: 60px">if __name__ == "__main__":<br/>    import sys, subprocess<br/>    ...</pre>
<p style="padding-left: 60px">Now, we can run the <kbd>u_app.py</kbd> file and try to capture an image from the camera device, as demonstrated in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/f5bde9b7-f4c1-4ee6-a8ea-3d5388202094.png" style="width:44.00em;height:23.17em;"/></p>
<p style="padding-left: 60px">When we click on the capture button, the current frame will be captured and saved as an image file to the <kbd>captures/</kbd> folder. It is important to note that camera (video and audio) functionality is dependent on the capabilities of the personal device and on the availability of the installed codecs. It is therefore recommended that you collect information regarding devices and codecs that can be used for application development. A third-party package such as OpenCV, which provides more functional features in relation to the camera device and the handling of images/video, can be used to implement the camera in the app. </p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>This chapter completes our examination of basic graphics. The following chapters will extend this functionality to include special tasks. The Qt library has the widest set of modules, classes, and tools available to work with graphics because it is a form of this library. In general, most of the classes that are represented in this framework are relative to this. It is also very important to understand the basic graphics principles that can be used with GUI development that are available in the Qt library.</p>
<p>The next chapter will continue our introduction to the Qt classes and cover basic dialog windows.</p>


            

            
        
    </body></html>