<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Building a Paint App</h1></div></div></div><p>In <a class="link" href="ch01.html" title="Chapter 1. Building a Clock App">Chapter 1</a>, <em>Building a Clock App</em>, we built an application from Kivy's standard components: layouts, text labels, and buttons. We were able to significantly customize the look of these components while retaining a very high level of abstraction—working with <a id="id101" class="indexterm"/>full-fledged widgets, as opposed to individual graphical primitives. This is convenient for certain types of applications but not always desirable, and as you will see shortly, the Kivy framework also provides tools to work with a lower level of abstraction: draw points and lines.</p><p>I believe that the best way to play with free-form graphics is by building a painting app. Our application, when complete, will be somewhat similar to the MS Paint application that comes bundled with the Windows OS.</p><p>Unlike Microsoft Paint, our Kivy Paint app will be fully cross-platform, including mobile devices running Android and iOS. Also, we will deliberately omit many features found in "real" software for image processing, such as rectangular selection, layers, and saving files to disk. Implementing them can be a good exercise for you.</p><div><div><h3 class="title"><a id="tip10"/>Tip</h3><p>Regarding mobile devices: while building a fully functional iOS application with Kivy is of course possible, it's still non-trivial if you have no experience with either iOS or Kivy development. Therefore, it's recommended that you write for easy platforms first so that you can quickly update your code and run the application without building binaries and such. In this sense, Android development is much simpler, thanks to Kivy Launcher, a generic environment to run <a id="id102" class="indexterm"/>Kivy apps on Android. It is available on Google Play at <a class="ulink" href="https://play.google.com/store/apps/details?id=org.kivy.pygame">https://play.google.com/store/apps/details?id=org.kivy.pygame</a>.</p><p>The ability to immediately launch and test your app without compiling is an incredibly important aspect of Kivy development. This allows programmers to iterate <a id="id103" class="indexterm"/>quickly and evaluate possible solutions on the spot, which is crucial for <strong>rapid application development</strong> (<strong>RAD</strong>) and the agile methodology as a whole.</p><p>With the notable exception of window resizing, which isn't widely used on mobiles, Kivy apps behave in a similar way on various mobile and desktop platforms. So it's perfectly feasible to write and debug just the desktop or Android version of the program until much later in the release cycle and then fill the compatibility gaps, if any.</p></div></div><p>We will <a id="id104" class="indexterm"/>also explore two distinctive, almost mutually exclusive features available to Kivy apps: multitouch controls, useful on devices with a touch screen, and changing mouse pointers on a desktop computer.</p><p>Staying true to its mobile-first approach, Kivy provides an emulation layer for multitouch input, usable with the mouse. It can be triggered with a right-click. This multitouch emulation isn't, however, suitable for any real-world usage, except for debugging; it will be turned off in the production version of the application when running on a desktop.</p><p>This is what our application will look like at the end of the chapter:</p><div><img src="img/B01620_02_01.jpg" alt="Building a Paint App"/><div><p>The Kivy Paint app, bad painting sold separately</p></div></div><div><div><div><div><h1 class="title"><a id="ch02lvl1sec18"/>Setting the stage</h1></div></div></div><p>Initially, the<a id="id105" class="indexterm"/> entire surface of our app is occupied by the <strong>root widget</strong>, in this <a id="id106" class="indexterm"/>case, that's the canvas the user can paint upon. We won't devote any screen space to the instruments' area until later.</p><p>As you probably know by now, the root widget is the outermost widget in the hierarchy. Every Kivy application has one, and it can be pretty much anything, depending on the desired behavior. As seen in <a class="link" href="ch01.html" title="Chapter 1. Building a Clock App">Chapter 1</a>, <em>Building a Clock App</em>, <code class="literal">BoxLayout</code> is a suitable root widget; it was sufficient as we had no additional requirements for it, and layouts are designed to work as containers for other controls.</p><p>In the case of a Paint app, we need its root widget to adhere to much more interesting requirements; the user should be able to draw lines, possibly utilizing multitouch functionality, if available. At the moment, Kivy has no built-in controls suitable for the task at hand, so we will need to create our own.</p><p>Building new Kivy widgets is simple. As soon as our class inherits from Kivy's <code class="literal">Widget</code> class, we're good to go. So the simplest custom widget that does nothing special, together with the Kivy application that uses it, can be implemented like this:</p><div><pre class="programlisting">from kivy.app import App
from kivy.uix.widget import Widget

class CanvasWidget(Widget):
    pass

class PaintApp(App):
    def build(self):
        return CanvasWidget()

if __name__ == '__main__':
    PaintApp().run()</pre></div><p>This is the full listing of our Paint app's starting point, <code class="literal">main.py</code>, complete with the <code class="literal">PaintApp</code> class. In future chapters, we will omit simple boilerplate like this; this one is provided for the sake of completeness.</p><div><div><h3 class="title"><a id="tip11"/>Tip</h3><p>The <code class="literal">Widget</code> class usually serves as a base class, like <code class="literal">object</code> in Python or <code class="literal">Object</code> Java. While it's possible to use it "as is" in the application, <code class="literal">Widget</code> itself is of very limited utility. It has no visual appearance and no properties that would be immediately useful in the program. Subclassing <code class="literal">Widget</code>, on the other hand, is pretty straightforward and useful in many different scenarios.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec19"/>Fine-tuning the looks</h1></div></div></div><p>First, let's tweak the appearance of our app. This isn't exactly a critical functionality, but bear with <a id="id107" class="indexterm"/>me here, as these customizations are commonly requested and also pretty easy to set up. I'll briefly describe the properties that we covered in the previous chapter, and we'll add a number of new tweaks, such as window size and change of the mouse cursor.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec24"/>Visual appearance</h2></div></div></div><p>I <a id="id108" class="indexterm"/>strongly believe that the background color of <a id="id109" class="indexterm"/>any Paint app should initially be white. You're probably already familiar with this setting from the first chapter. Here's the line of code we add after the <code class="literal">__name__ == '__main__'</code> line to achieve the desired effect:</p><div><pre class="programlisting">from kivy.core.window import Window
from kivy.utils import get_color_from_hex

Window.clearcolor = get_color_from_hex('#FFFFFF')</pre></div><p>You may want to put most of the <code class="literal">import</code> lines where they usually belong, near the beginning of a program file. As you will learn shortly, some imports in Kivy are actually order-dependent and have side effects, most notably the <code class="literal">Window</code> object. This is rarely the case in well-behaved Python programs, and the side effects of the import statement are generally considered bad application design.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec25"/>Window size</h2></div></div></div><p>Another<a id="id110" class="indexterm"/> commonly tweaked property of a desktop <a id="id111" class="indexterm"/>application is window size. The following changes will have absolutely no effect on mobile devices.</p><p>It's also worth noting that by default, Kivy's window on a desktop can be resized by the end user. We will learn how to disable that shortly (only for the sake of completeness; usually, that's not such a great idea).</p><div><div><h3 class="title"><a id="tip12"/>Tip</h3><p>Setting the window size programmatically is also a handy thing to do when you're targeting a mobile device whose specifications are known in advance. This allows you to test the application on a desktop using the correct screen resolution of the target device.</p></div></div><p>To assign the initial window size, insert the next code snippet right above the line that reads <code class="literal">from kivy.core.window import Window</code>. It's critical to apply these settings before the <code class="literal">Window</code> object is even imported; otherwise, they won't have any effect:</p><div><pre class="programlisting">from kivy.config import Config

Config.set('graphics', 'width', '960')
Config.set('graphics', 'height', '540')  # 16:9</pre></div><p>In addition, you may want to disable window resizing by adding this one line:</p><div><pre class="programlisting">Config.set('graphics', 'resizable', '0')</pre></div><p>Please<a id="id112" class="indexterm"/> don't do this unless you have a very good reason, since <a id="id113" class="indexterm"/>taking these trivial customizations away from the user is usually a bad idea and can easily ruin the overall user experience. Building a pixel-perfect app in just one resolution is tempting, but many of your customers (especially mobile users) won't be happy. Kivy layouts, on the other hand, make building scalable interfaces bearable.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec26"/>Mouse cursor</h2></div></div></div><p>The next <a id="id114" class="indexterm"/>customization that generally applies <a id="id115" class="indexterm"/>only to desktop apps is changing the mouse pointer. Kivy has no abstraction for this, so we will work at a lower level, importing and calling methods directly from Pygame, the SDL-based window and OpenGL context provider, which is commonly used by Kivy on desktop platforms.</p><p>This code, if you choose to implement it, should always be run conditionally. Most mobile and some desktop apps won't have a Pygame window, and we surely want to avoid crashing the program over a trivial and non-essential matter like the mouse cursor.</p><p>Long story short, this is the mouse pointer format that's used by Pygame:</p><div><img src="img/B01620_02_11.jpg" alt="Mouse cursor"/><div><p>The ASCII format used to describe a custom mouse pointer</p></div></div><p>Every <a id="id116" class="indexterm"/>character in this notation stands for one<a id="id117" class="indexterm"/> pixel: <code class="literal">'@'</code> is black and <code class="literal">'-'</code> is white; everything else is transparent. All lines have to be of equal width, divisible by eight (a restriction imposed by the underlying SDL implementation).</p><p>When used in an application, it should look as depicted in the next screenshot (the image is significantly zoomed in, obviously):</p><div><img src="img/B01620_02_02.jpg" alt="Mouse cursor"/><div><p>Mouse cursor for the Kivy Paint app: a crosshair</p></div></div><div><div><h3 class="title"><a id="note10"/>Note</h3><p>There is a caveat though. At the time of writing this, the version of Pygame that's commonly available in some operating systems has a bug in the <code class="literal">pygame.cursors.compile()</code> function that switches between white and black. Detecting the affected versions of Pygame is impractical, so we'll just include the correctly working function in our code and won't call the potentially buggy version of the same function.</p><p>The <a id="id118" class="indexterm"/>correct function, <code class="literal">pygame_compile_cursor()</code>, that translates the Pygame's mouse cursor definition <a id="id119" class="indexterm"/>into something expected by <strong>Simple DirectMedia Layer</strong> (<strong>SDL</strong>), Pygame's backend library, is available online at <a class="ulink" href="http://goo.gl/2KaepD">http://goo.gl/2KaepD</a>.</p></div></div><p>Now, to<a id="id120" class="indexterm"/> actually apply the resulting cursor to the<a id="id121" class="indexterm"/> application window, we'll replace our <code class="literal">PaintApp.build</code> method with the following:</p><div><pre class="programlisting">from kivy.base import EventLoop
class PaintApp(App):
    def build(self):
        EventLoop.ensure_window()
        if EventLoop.window.__class__.__name__.endswith('Pygame'):
            try:
                from pygame import mouse
                # pygame_compile_cursor is a fixed version of
                # pygame.cursors.compile
                a, b = pygame_compile_cursor()
                mouse.set_cursor((24, 24), (9, 9), a, b)
            except:
                pass

        return CanvasWidget()</pre></div><p>The<a id="id122" class="indexterm"/> code is pretty straightforward, but some aspects <a id="id123" class="indexterm"/>of it may need explanation. Here is a quick walk-through:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">EventLoop.ensure_window()</code>: This function call blocks the execution until we have<a id="id124" class="indexterm"/> the application window (<code class="literal">EventLoop.window</code>) ready.</li><li class="listitem" style="list-style-type: disc"><code class="literal">if EventLoop.window.__class__.__name__.endswith('Pygame')</code>: This condition checks the window class name (not the greatest way to make assertions about the code, but works in this case). We want to run our mouse cursor customization code only for a certain window provider, in this case, Pygame.</li><li class="listitem" style="list-style-type: disc">The remaining part of the code, enclosed in a <code class="literal">try ... except</code> block, is a Pygame-specific <code class="literal">mouse.set_cursor</code> call.</li><li class="listitem" style="list-style-type: disc">Variables <code class="literal">a</code> and <code class="literal">b</code> constitute the internal representation of the cursor used by SDL, namely the XOR and AND mask. They are binary and should be considered an opaque implementation detail of the SDL.</li></ul></div><div><div><h3 class="title"><a id="note11"/>Note</h3><p>As usual, please<a id="id125" class="indexterm"/> refer to the official reference manual for the full API specification. Pygame documentation can be found at <a class="ulink" href="http://www.pygame.org">http://www.pygame.org</a>.</p></div></div><p>This entire situation when we're working at a level of abstraction much lower than Kivy's isn't very common, but by all means, don't be afraid to dive into implementation details sometimes. There are many things that can be achieved only in the underlying library because Kivy does not provide meaningful abstractions for them. This especially applies to non-cross-platform functionality, such as OS-dependent app interoperability, notification services, and so on.</p><p>To reiterate, this diagram summarizes the abstraction levels we traverse in this specific case to set the mouse pointer:</p><div><img src="img/B01620_02_03.jpg" alt="Mouse cursor"/><div><p>The relationship of Kivy, Pygame, SDL, and the underlying operating system abstractions</p></div></div><p>Thankfully, we didn't have to work directly with the operating system—cross-platform functionality <a id="id126" class="indexterm"/>can be surprisingly hard to get right. This is <a id="id127" class="indexterm"/>exactly what SDL does.</p><div><div><h3 class="title"><a id="note12"/>Note</h3><p>While we don't work with the SDL directly, you might still want to take a look at the documentation found at <a class="ulink" href="https://www.libsdl.org/">https://www.libsdl.org/</a>—this will give you a perspective on the underlying low-level API calls that Kivy ultimately relies on.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec27"/>Multitouch emulation</h2></div></div></div><p>By<a id="id128" class="indexterm"/> default, Kivy provides an emulation <a id="id129" class="indexterm"/>mode for multitouch operations when running on a desktop system. It is activated with a right-click and spawns permanent touches rendered as semi-transparent red dots; they can also be dragged while holding the right mouse button.</p><p>This feature may be nice for debugging, especially when you don't have a real multitouch device to test on; users, on the other hand, won't be expecting this functionality bound to the right click. It's probably a good idea to disable it so that our users don't get confused by this not very useful or obvious emulation mode. For this, add the following to the initialization sequence:</p><div><pre class="programlisting">Config.set('input', 'mouse', 'mouse,disable_multitouch')</pre></div><p>This code can be made conditional (or just commented out temporarily) at the time of development if you're actually using this feature for debugging.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec20"/>Drawing touches</h1></div></div></div><p>To <a id="id130" class="indexterm"/>illustrate one possible scenario for reacting to the touch input, let's draw a circle every time the user touches (or clicks) the screen.</p><p>A <code class="literal">Widget</code> has an <code class="literal">on_touch_down</code> event that will come in handy for this task. We're interested in just the coordinates of every touch for the time being, and they are accessible as follows:</p><div><pre class="programlisting">class CanvasWidget(Widget):
    def on_touch_down(self, touch):
        print(touch.x, touch.y)</pre></div><p>This example prints the position of touches as they occur. To draw something on the screen instead, we will use the <code class="literal">Widget.canvas</code> property. Kivy's <code class="literal">Canvas</code> is a logical drawable surface that abstracts away the underlying OpenGL renderer. Unlike the low-level graphical API, the canvas is stateful and preserves the drawing instructions that were added to it.</p><p>Speaking<a id="id131" class="indexterm"/> of drawing primitives, many of those can be imported from the <code class="literal">kivy.graphics</code> package. Examples of drawing instructions are <code class="literal">Color</code>, <code class="literal">Line</code>, <code class="literal">Rectangle</code>, and <code class="literal">Bezier</code>, among others.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec28"/>A very short introduction to the canvas</h2></div></div></div><p>The <code class="literal">Canvas</code> API can <a id="id132" class="indexterm"/>be invoked directly or as a context handler <a id="id133" class="indexterm"/>using the <code class="literal">with</code> keyword. A simple (direct) invocation looks like this:</p><div><pre class="programlisting">self.canvas.add(Line(circle=(touch.x, touch.y, 25)))</pre></div><p>This adds a <code class="literal">Line</code> primitive with arguments to a graphical instructions queue.</p><div><div><h3 class="title"><a id="tip13"/>Tip</h3><p>If you want to try out this code right off the bat, please see the next section, <em>Displaying touches on the screen</em>, for a more comprehensive example of using canvas instructions in the context of our Paint app.</p></div></div><p>Using the context handler generally looks nicer and less cluttered, especially when applying multiple instructions. It is shown in the following example, which is functionally equivalent to the previous code snippet with <code class="literal">self.canvas.add()</code>:</p><div><pre class="programlisting">with self.canvas:
    Line(circle=(touch.x, touch.y, 25))</pre></div><p>This may seem a bit harder to grasp than the direct approach. Choosing the code style to use is a matter of personal preference, as they achieve the same thing.</p><p>Note that, as mentioned before, every subsequent call gets added to the canvas without affecting the instructions that were applied previously; at the core, the canvas is a growing array of instructions that are replayed every time the surface is rendered to the screen. Keep this in mind: as we aim for 60 fps refresh rate, we certainly don't want this list to grow indefinitely.</p><p>For example, one of the coding practices that works correctly on the immediate-mode-rendering surface (like HTML5's <code class="literal">&lt;canvas&gt;</code>) is erasing the previously drawn graphics from the view by overpainting it with background color. This is rather intuitive and works correctly in a browser:</p><div><pre class="programlisting">// JavaScript code for clearing the canvas
canvas.rect(0, 0, width, height)
canvas.fillStyle = '#FFFFFF'
canvas.fill()</pre></div><p>In Kivy, on the other hand, this pattern still just adds drawing instructions; it first renders all of the pre-existing primitives and then paints them over with a rectangle. This looks just about <a id="id134" class="indexterm"/>right (the canvas is visually empty) but does the<a id="id135" class="indexterm"/> wrong thing:</p><div><pre class="programlisting"># Same code as JavaScript above. <strong>This is wrong, don't do it!</strong>
with self.canvas:
    Color(1, 1, 1)
    Rectangle(pos=self.pos, size=self.size)</pre></div><div><div><h3 class="title"><a id="tip14"/>Tip</h3><p>Just like a memory leak, this bug can go unnoticed for a long time, quietly accumulating rendering instructions and degrading performance. Thanks to powerful video cards found in today's devices, including smartphones, rendering is generally very fast. So it's hard to realize that the overhead is there when debugging.</p><p>In order to properly clear the canvas in Kivy (that is, remove all the drawing instructions), you should use the <code class="literal">canvas.clear()</code> method, shown later in this chapter.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec29"/>Displaying touches on the screen</h2></div></div></div><p>We <a id="id136" class="indexterm"/>are going to implement a button to clear the screen <a id="id137" class="indexterm"/>shortly; in the meantime, let's display touches on the screen. We remove the call to <code class="literal">print()</code> and add the following method to the <code class="literal">CanvasWidget</code> class definition:</p><div><pre class="programlisting">class CanvasWidget(Widget):
    def on_touch_down(self, touch):
        with self.canvas:
            Color(*get_color_from_hex('#0080FF80'))
            Line(circle=(touch.x, touch.y, 25), width=4)</pre></div><p>This draws an empty circle around every touch that our widget receives. The <code class="literal">Color</code> instruction sets the color for the following <code class="literal">Line</code> primitive.</p><div><div><h3 class="title"><a id="note13"/>Note</h3><p>Note that the color format (here, <code class="literal">#RRGGBBAA</code>) isn't strictly CSS conformant, as it has the fourth component, namely the alpha channel (transparency). This syntax variation should be self-evident. It's akin to, for example, <code class="literal">rgb()</code> and <code class="literal">rgba()</code> notations commonly found elsewhere.</p></div></div><p>You may have also noticed how we're using <code class="literal">Line</code> in quite an unorthodox way here, drawing circles instead of straight lines. Many Kivy graphical primitives are powerful like that. For example, any canvas instruction, such as the <code class="literal">Rectangle</code> or <code class="literal">Triangle</code> primitive, can render a background image, given a <code class="literal">source</code> parameter.</p><p>If you're following along, this is how the result should look so far:</p><div><img src="img/B01620_02_04.jpg" alt="Displaying touches on the screen"/><div><p>Displaying touches on the screen</p></div></div><p>The <a id="id138" class="indexterm"/>full source code up to this point, which was used to<a id="id139" class="indexterm"/> produce the preceding demonstration, reads:</p><div><pre class="programlisting"># In main.py
from kivy.app import App
from kivy.config import Config
from kivy.graphics import Color, Line
from kivy.uix.widget import Widget
from kivy.utils import get_color_from_hex

class CanvasWidget(Widget):
    def on_touch_down(self, touch):
        with self.canvas:
            Color(*get_color_from_hex('#0080FF80'))
            Line(circle=(touch.x, touch.y, 25), width=4)

class PaintApp(App):
    def build(self):
        return CanvasWidget()

if __name__ == '__main__':
    Config.set('graphics', 'width', '400')
    Config.set('graphics', 'height', '400')
    Config.set('input', 'mouse',
               'mouse,disable_multitouch')

    from kivy.core.window import Window
    Window.clearcolor = get_color_from_hex('#FFFFFF')

    PaintApp().run()</pre></div><p>This <a id="id140" class="indexterm"/>excludes the nonessential mouse cursor part for the <a id="id141" class="indexterm"/>sake of keeping the example code short and sweet. The accompanying Kivy language file, <code class="literal">paint.kv</code>, is missing altogether at this point—instead, the <code class="literal">build()</code> method of the app class returns the root widget.</p><p>Observe the unusual placement of the <code class="literal">import Window</code> line. This is due to the side effects of this specific module, already mentioned earlier. <code class="literal">Config.set()</code> calls should precede this <code class="literal">import</code> statement to have any effect.</p><p>Next, we are going to add more features to our little program, bringing it in line with the desired Paint app behavior.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec21"/>Clearing the screen</h1></div></div></div><p>Right <a id="id142" class="indexterm"/>now, the only way to clear the screen in our little<a id="id143" class="indexterm"/> app is to restart it. Let's add a button for deleting everything from the canvas to our UI, which is very minimalistic at the moment. We'll reuse the button look from the previous app, so there will be nothing new about theming; the interesting part here is positioning.</p><p>In our first program, the Clock app from <a class="link" href="ch01.html" title="Chapter 1. Building a Clock App">Chapter 1</a>, <em>Building a Clock App</em>, we didn't work on any explicit positioning at all, as everything was being held in place by nested <code class="literal">BoxLayouts</code>. Now, however, we don't have any layout to our program as the root widget is our very own <code class="literal">CanvasWidget</code>, and we didn't implement any logic to position its children.</p><p>In Kivy, the absence of an explicit layout means that every widget has full control over its placement and size (this is pretty much the default state of affairs in many other UI toolkits, such as Delphi, Visual Basic, and so on).</p><p>To position the newly created delete button in the top-right corner, we do the following:</p><div><pre class="programlisting"># In paint.kv
&lt;CanvasWidget&gt;:
    Button:
        text: 'Delete'
        right: root.right
        top: root.top
        width: 80
        height: 40</pre></div><p>This is a<a id="id144" class="indexterm"/> property binding that says the button's <code class="literal">right</code> and <code class="literal">top</code> properties should be kept in sync with the root widget's properties accordingly. We could <a id="id145" class="indexterm"/>also do the math here, for example, <code class="literal">root.top – 20</code>. The rest is pretty straightforward, as <code class="literal">width</code> and <code class="literal">height</code> are absolute values.</p><p>Also note that we've defined a class rule for <code class="literal">&lt;CanvasWidget&gt;</code> without specifying its superclass. This works because this time we are extending the existing class with the same name, defined earlier in Python code. Kivy allows us to augment all the existing widget classes, both built-ins, such as <code class="literal">&lt;Button&gt;</code> and <code class="literal">&lt;Label&gt;</code>, and custom ones.</p><p>This illustrates a common good practice to describe visual attributes of objects using the Kivy language. At the same time, it's better to keep all program flow constructs, such as event handlers, on the Python side of things. Such separation of concerns makes both the Python source code and its corresponding Kivy language counterpart more readable and easier to follow.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec30"/>Passing events</h2></div></div></div><p>If you <a id="id146" class="indexterm"/>have kept up with this tutorial and already tried clicking <a id="id147" class="indexterm"/>the button, you may have noticed (or even guessed) that it doesn't work. The fact that it doesn't do anything useful is obviously due to the missing click handler that we're going to implement shortly. What's more interesting is that the click just doesn't get through, as there is no visual feedback; instead, the usual semi-transparent circle gets painted on top of the button, and that's it.</p><p>This strange effect happens because we're processing all the touches in the <code class="literal">CanvasWidget.on_touch_down</code> handler and don't pass them to the children, so they cannot react. Unlike HTML's <strong>Document Object Model</strong> (<strong>DOM</strong>), events in Kivy don't bubble <a id="id148" class="indexterm"/>up from the nested element up to its parent. They go the other way around, from the parent down to the children, that is, if the parent widget would pass them, which it doesn't.</p><p>This could be fixed by explicitly doing something along the lines of the following code:</p><div><pre class="programlisting"># <strong>Caution: suboptimal approach!</strong>
def on_touch_down(self, touch):
    for widget in self.children:
        widget.on_touch_down(touch)</pre></div><p>In reality, that's pretty much what the default behavior (<code class="literal">Widget.on_touch_down</code>) already does, so we may as well call it and make the code much more concise, as follows:</p><div><pre class="programlisting">def on_touch_down(self, touch):
    if Widget.on_touch_down(self, touch):
        return</pre></div><p>The<a id="id149" class="indexterm"/> default <code class="literal">on_touch_down</code> handler also returns <code class="literal">True</code> if the event <a id="id150" class="indexterm"/>was actually processed in a meaningful way. Touching a button will return <code class="literal">True</code> since the button reacts to it, and at the very least, changes its appearance. That's just what we need in order to cancel our own event processing, which amounts to drawing circles at this time, hence the <code class="literal">return</code> statement on the second line of the method.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec31"/>Clearing the canvas</h2></div></div></div><p>Now we <a id="id151" class="indexterm"/>move on to the easiest and also the most useful part <a id="id152" class="indexterm"/>of the <strong>Delete</strong> button—a touch handler that erases everything. Clearing the canvas is quite simple, so everything we need to do in order to get this function to work is here. Yup, just two lines of code grand total:</p><div><pre class="programlisting">def clear_canvas(self):
    self.canvas.clear()</pre></div><p>Don't forget to add this method as an event handler to the <code class="literal">paint.kv</code> file:</p><div><pre class="programlisting">Button:
    on_release: root.clear_canvas()</pre></div><p>It works, except that it also removes the <strong>Delete</strong> button itself! This happens because the button is a child of <code class="literal">CanvasWidget</code> (naturally, since <code class="literal">CanvasWidget</code> is a root widget, everything is its direct or indirect child). And while the button widget itself isn't deleted (and clicking it still clears the screen), its canvas (<code class="literal">Button.canvas</code>) gets removed from the <code class="literal">CanvasWidget.canvas.children</code> hierarchy and is thus no longer rendered.</p><p>The very straightforward way of fixing it is like this:</p><div><pre class="programlisting">def clear_canvas(self):
    self.canvas.clear()
    self.canvas.children = [widget.canvas
                            for widget in self.children]</pre></div><p>However, this isn't nice because widgets may do their own initialization and arrange things differently. A better way to solve this issue is to do the following:</p><div><ol class="orderedlist arabic"><li class="listitem">Remove all the children from the "offending" widget (<code class="literal">CanvasWidget</code>, in this case).</li><li class="listitem">Clear the canvas.</li><li class="listitem">Finally, re-add child widgets back so that they can initialize their rendering properly.</li></ol></div><p>The revised version of the code is a bit longer but works properly and is more bulletproof:</p><div><pre class="programlisting">class CanvasWidget(Widget):
    def clear_canvas(self):
        saved = self.children[:]  # See below
        self.clear_widgets()
        self.canvas.clear()
        for widget in saved:
            self.add_widget(widget)</pre></div><p>One line <a id="id153" class="indexterm"/>that may need explanation is the <code class="literal">saved = self.children[:]</code>expression. The <code class="literal">[:]</code> operation is an array copy (literally, "create a new array<a id="id154" class="indexterm"/> with these same elements"). If we write <code class="literal">saved = self.children</code> instead, this means we're copying a pointer to an array; later, when we call <code class="literal">self.clear_widgets()</code>, it will remove everything from both <code class="literal">self.children</code> and <code class="literal">saved</code> since they're referring to the same object in the memory. This is why <code class="literal">self.children[:]</code> is required. (The behavior we just discussed is how Python works and is not related to Kivy.)</p><div><div><h3 class="title"><a id="note14"/>Note</h3><p>If you're not familiar with the slicing syntax in Python, please see the StackOverflow<a id="id155" class="indexterm"/> thread at <a class="ulink" href="http://stackoverflow.com/questions/509211">http://stackoverflow.com/questions/509211</a> for an example.</p></div></div><p>At this stage, we can already kind of paint things with blue bubbles, as depicted in the following screenshot. This is clearly not the final behavior of our Paint app, so please read on to the next section in which we will make it draw actual lines.</p><div><img src="img/B01620_02_05.jpg" alt="Clearing the canvas"/><div><p>The Delete button in all its dreadful glory. Also, painting with a circle "brush"</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec22"/>Connecting the dots</h1></div></div></div><p>Our<a id="id156" class="indexterm"/> app already has a clear screen function but still draws<a id="id157" class="indexterm"/> just circles. Let's change it so that we can draw lines instead.</p><p>To follow continuous touch events (click-and-drag), we'll need to add a new event listener, <code class="literal">on_touch_move</code>. Every time the callback is invoked, it receives the latest point where the event occurred.</p><p>If we only had a single line going at every moment (like typically done on a desktop, since there is only one mouse pointer anyway), we could save the line we're currently drawing in <code class="literal">self.current_line</code>. But since we're aiming at multitouch support from the very beginning, we'll take another approach and store every line being drawn in the corresponding <code class="literal">touch</code> variable itself.</p><p>This works because for every continuous touch from start to end, all callbacks receive the same <code class="literal">touch</code> object. There is also a <code class="literal">touch.ud</code> property of the type <code class="literal">dict</code> (where <code class="literal">ud</code> is short for <a id="id158" class="indexterm"/>user data), which is specifically tailored to keep touch-specific attributes between event handler invocations. Initially, the <code class="literal">touch.ud</code> property is an empty Python dictionary, <code class="literal">{}</code>.</p><p>What we're going to do next is:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">In the <code class="literal">on_touch_down</code> handler, create a new line and store it in the <code class="literal">touch.ud</code> dictionary. This time, we will use regular straight lines instead of the fancy circular lines we employed earlier to illustrate where individual touches would land.</li><li class="listitem" style="list-style-type: disc">In <code class="literal">on_touch_move</code>, append a new point to the end of the corresponding line. We are adding a straight line segment, but since the event handler is going to be invoked many times per second, the end result will consist of a series of very short segments and will look rather smooth nevertheless.</li></ul></div><div><div><h3 class="title"><a id="tip15"/>Tip</h3><p>More advanced graphical programs are using sophisticated algorithms to make lines appear as if they were drawn on a real physical surface. This includes using Bezier curves to make lines seamless even at high resolution and extrapolating line thickness from the pointer movement's speed or pressure. We aren't going to implement these here as they bear no relation to Kivy, but adding these techniques to the resulting Paint app may constitute a nice exercise for the reader.</p></div></div><p>The code, as we just described, is listed as follows:</p><div><pre class="programlisting">from kivy.graphics import Color, Line

class CanvasWidget(Widget):
    def on_touch_down(self, touch):
        if Widget.on_touch_down(self, touch):
            return

        with self.canvas:
            Color(*get_color_from_hex('#0080FF80'))
            touch.ud['current_line'] = Line(
                points=(touch.x, touch.y), width=2)

    def on_touch_move(self, touch):
        if 'current_line' in touch.ud:
            touch.ud['current_line'].points += (touch.x, touch.y)</pre></div><p>This<a id="id159" class="indexterm"/> simple approach works, and we're able to draw boring <a id="id160" class="indexterm"/>blue lines on our canvas. Now let's give our users the ability to select color, then we'll be one step closer to a painting app that's actually somewhat useful.</p></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec23"/>The color palette</h1></div></div></div><p>Every <a id="id161" class="indexterm"/>painting program comes with a palette to choose colors from, and ours will be no exception by the time we reach the end of this section, real soon.</p><p>Conceptually, a palette is just a list of available colors, presented in a way that makes choosing the right color easy. In a full-fledged image editor, it usually includes every color available on the system (commonly a full 24-bit true color or the 16,777,216 unique colors). The customary representation of this all-encompassing palette typically looks like the following:</p><div><img src="img/B01620_02_06.jpg" alt="The color palette"/><div><p>Illustration of a true color palette window</p></div></div><p>On the<a id="id162" class="indexterm"/> other hand, if we aren't going to compete with popular proprietary image editing applications, we might as well ship a limited selection of colors. For a person with little to no background in graphics, this may even pose a competitive advantage—choosing fitting colors that look good together is hard. For this exact reason, there are palettes on the Internet that may be universally used for UI and graphic design.</p><p>In this<a id="id163" class="indexterm"/> tutorial, we are going to make use of the Flat UI style guide (available at <a class="ulink" href="http://designmodo.github.io/Flat-UI/">http://designmodo.github.io/Flat-UI/</a>), which is based on a list of carefully chosen colors that work great together. Alternatively, feel free to choose any other palette you like, which is purely an aesthetic preference.</p><div><div><h3 class="title"><a id="note15"/>Note</h3><p>There is much to learn in the area of colors, especially color compatibility and suitability for specific tasks. Low-contrast combinations may work great for decorative elements or big headlines, but they fall short for the main article's text; however, counterintuitively, very high contrast, like white on black, is not easy on the eyes and quickly strains them.</p><p>So, a good rule of thumb regarding colors is that unless you are absolutely confident in your artistic skills, preferably stick to well-established palettes that are successfully used by others. A great place to start is your favorite operating system's or desktop environment's guidelines. The following are some of the examples:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Tango palette, which<a id="id164" class="indexterm"/> is widely used in open source environments such as desktop Linux, can be found at <a class="ulink" href="http://tango.freedesktop.org/Tango_Icon_Theme_Guidelines">http://tango.freedesktop.org/Tango_Icon_Theme_Guidelines</a>.</li><li class="listitem" style="list-style-type: disc">Google Material design principles, presented at the Google I/O conference in 2014, is available at <a class="ulink" href="https://www.google.com/design/material-design.pdf">https://www.google.com/design/material-design.pdf</a>.</li><li class="listitem" style="list-style-type: disc">The<a id="id165" class="indexterm"/> unofficial iOS 7 color swatches can be found at <a class="ulink" href="http://ios7colors.com/">http://ios7colors.com/</a> (many people, including me, find these a bit exaggerated and too vibrant, thus best suited for games and maybe advertising, as opposed to a UI for daily use).</li></ul></div><p>There<a id="id166" class="indexterm"/> are many more color palettes for various tasks readily available—check Google if interested, or use a color picker on your favorite OS and programs.</p></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec32"/>Subclassing the buttons</h2></div></div></div><p>Since<a id="id167" class="indexterm"/> we're going for a rather short fixed list of colors, the<a id="id168" class="indexterm"/> UI controls that are best suited to represent such a list are likely toggle or radio buttons. Kivy's <code class="literal">ToggleButton</code> would be perfectly suitable for this task, but it has an unfortunate limitation: in a toggle group, all buttons may be deselected at once. This would mean that, in the context of the Paint app, there is no color selected. (One possible option in this case is to fall back to a default color, but this may be surprising to the user so we won't take this approach.)</p><p>The good news is that with Python's <strong>OOP</strong> (<strong>object-oriented programming</strong>) capabilities, we can<a id="id169" class="indexterm"/> easily subclass <code class="literal">ToggleButton</code> and alter its behavior to do what we need, that is, to forbid the deselection of the currently selected button. After this tweak, exactly one color will be selected at all times.</p><p>Subclassing will also achieve another goal in this case: for a palette, we want to paint every button in its distinctive color. While we could certainly employ the previously used technique of assigning background images to buttons, this would require us to produce a whole lot of different background images. Instead, we are going to use the background color property, which can be assigned from the <code class="literal">paint.kv</code> file.</p><p>This architecture allows us to keep the definition of the palette itself in a very readable declarative form inside <code class="literal">paint.kv</code>, while the implementation details stay out of our way in a subclass—exactly how an OOP program should be.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec33"/>Taking away the ability to deselect</h2></div></div></div><p>First, let's<a id="id170" class="indexterm"/> make toggle buttons that cannot<a id="id171" class="indexterm"/> all be deselected simultaneously.</p><p>To illustrate the problem (and also create the bare-bones implementation that will serve as a starting point), let's implement the desired UI using standard Kivy's <code class="literal">ToggleButton</code> widgets. This part is purely declarative; let's just add the following code to <code class="literal">paint.kv</code> to the bottom of the <code class="literal">&lt;CanvasWidget&gt;</code> section:</p><div><pre class="programlisting">BoxLayout:
    orientation: 'horizontal'
    padding: 3
    spacing: 3
    x: 0
    y: 0
    width: root.width
    height: 40

    ToggleButton:
        group: 'color'
        text: 'Red'

    ToggleButton:
        group: 'color'
        text: 'Blue'
        state: 'down'</pre></div><p>We use the familiar <code class="literal">BoxLayout</code> component here, acting as a toolbar for individual color buttons. The layout widget itself is positioned absolutely, with <code class="literal">x</code> and <code class="literal">y</code> both set to <code class="literal">0</code> (that is, the bottom-left corner), taking the full width of <code class="literal">CanvasWidget</code>.</p><p>Each <code class="literal">ToggleButton</code> belongs to the same group, <code class="literal">'color'</code>, so that at most only one of these can be selected (<code class="literal">state: 'down'</code>) at the same time.</p><div><div><div><div><h3 class="title"><a id="ch02lvl3sec04"/>Overriding the standard behavior</h3></div></div></div><p>As <a id="id172" class="indexterm"/>mentioned previously, the built-in <code class="literal">ToggleButton</code> behavior isn't exactly the radio button that we need; if you click on the selected button, it will be deselected, leaving the whole toggle group without a selected element.</p><p>To fix it, let's subclass <code class="literal">ToggleButton</code> as follows:</p><div><pre class="programlisting">from kivy.uix.behaviors import ToggleButtonBehavior
from kivy.uix.togglebutton import ToggleButton

class RadioButton(ToggleButton):
    def _do_press(self):
        if self.state == 'normal':
            ToggleButtonBehavior._do_press(self)</pre></div><p>That's it. We allow the button to toggle like it normally would only if it wasn't already selected (its <code class="literal">state</code> is <code class="literal">'normal'</code>, as opposed to <code class="literal">'down'</code>).</p><p>Now all that's left is to replace every instance of <code class="literal">ToggleButton</code> in the <code class="literal">paint.kv</code> file with <code class="literal">RadioButton</code>, the name of our custom class, and instantly see the difference in the behavior of buttons.</p><p>This is<a id="id173" class="indexterm"/> a major selling point of the Kivy framework: in only a few lines, you can override the built-in functions and methods, achieving practically unmatched flexibility.</p><div><div><h3 class="title"><a id="tip16"/>Tip</h3><p>To become usable in Kivy language, the <code class="literal">RadioButton</code> definition should reside in the <code class="literal">main.py</code> module or be imported into its scope. Since we have just one Python file now, that's a non-issue, but as your application grows, do keep this in mind: custom Kivy widgets, like other Python classes or functions, have to be imported prior to their first use.</p></div></div></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec34"/>Coloring buttons</h2></div></div></div><p>Now<a id="id174" class="indexterm"/> that our buttons behave properly, the next step is <a id="id175" class="indexterm"/>coloring. What we're aiming for will look like the following image:</p><div><img src="img/B01620_02_07.jpg" alt="Coloring buttons"/><div><p>Paint app's color palette, vibrant and inviting</p></div></div><p>To achieve this, we are going to use the <code class="literal">background_color</code> property. The background color in Kivy acts as a tint and not just a solid color; we need to prepare a pure white background image first, which, when tinted, will give us the color we want. This way, we only need to prepare two button textures (normal and pressed state) for any number of arbitrary colored buttons.</p><p>The<a id="id176" class="indexterm"/> images we use here aren't very different from those we <a id="id177" class="indexterm"/>prepared previously for the Clock app in <a class="link" href="ch01.html" title="Chapter 1. Building a Clock App">Chapter 1</a>, <em>Building a Clock App</em>, except that now the main area of a button is white to allow coloring, and the selected state features a black border:</p><div><img src="img/B01620_02_09.jpg" alt="Coloring buttons"/><div><p>The color button's texture, where the white area will be tinted using the background color property</p></div></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec05"/>A new kind of button</h3></div></div></div><p>This<a id="id178" class="indexterm"/> time, we can do most of the work, including<a id="id179" class="indexterm"/> creating a new button class, in the <code class="literal">paint.kv</code> file. The new class will be called <code class="literal">ColorButton</code>:</p><div><pre class="programlisting">&lt;ColorButton@RadioButton&gt;:
    group: 'color'
    on_release: app.canvas_widget.set_color(self.background_color)
    background_normal: 'color_button_normal.png'
    background_down: 'color_button_down.png'
    border: (3, 3, 3, 3)</pre></div><p>As you can see, we've moved the <code class="literal">group</code> property here to avoid cluttering the palette definition with repetitive <code class="literal">group: 'color'</code> lines.</p><p>We're also assigning an event handler, <code class="literal">on_release</code>, that will be called when a <code class="literal">ColorButton</code> is pressed. Every button passes its <code class="literal">background_color</code> property to the event handler, so all that's left to do is assign this color to the canvas. This event will be handled by <code class="literal">CanvasWidget</code>, which needs to be exposed from the <code class="literal">PaintApp</code> class, as follows:</p><div><pre class="programlisting">class PaintApp(App):
    def build(self):
        # The <code class="literal">set_color()</code> method will be implemented shortly.
        self.canvas_widget = CanvasWidget()
        self.canvas_widget.set_color(
            get_color_from_hex('#2980B9'))
        return self.canvas_widget</pre></div><p>The reason for this arrangement is that we cannot use the <code class="literal">root</code> shortcut in the preceding <code class="literal">paint.kv</code> class definition; it will point at the <code class="literal">ColorButton</code> itself (the root definition inside the class rule is indeed the class rule itself because it's defined at the top level in <code class="literal">paint.kv</code>). We can also set the default color here, as shown in the code snippet.</p><p>While <a id="id180" class="indexterm"/>we're in the <code class="literal">main.py</code> module, let's also implement <a id="id181" class="indexterm"/>the <code class="literal">set_color()</code> method on <code class="literal">CanvasWidget</code>, which will serve as an event handler for <code class="literal">ColorButton</code> clicks. The method in question is very straightforward:</p><div><pre class="programlisting">def set_color(self, new_color):
    self.canvas.add(Color(*new_color))</pre></div><p>Just set the color that was passed as an argument. That's it!</p></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec06"/>Defining the palette</h3></div></div></div><p>Here<a id="id182" class="indexterm"/> comes the creative part: defining the actual palette. With all<a id="id183" class="indexterm"/> the groundwork in place, let's remove the old <code class="literal">RadioButton</code> definitions from <code class="literal">paint.kv</code> and start anew.</p><p>To use the familiar CSS notation for colors, we'll need to import the appropriate function into the <code class="literal">paint.kv</code> file. Yes, it can import functions, just like a regular Python module.</p><p>Add this line to the beginning of <code class="literal">paint.kv</code>:</p><div><pre class="programlisting">#:import C kivy.utils.get_color_from_hex</pre></div><p>This is exactly the same as the following code in Python (with shorter alias for brevity, since we're going to use it a lot):</p><div><pre class="programlisting">from kivy.utils import get_color_from_hex as C</pre></div><p>As mentioned earlier, we will use Flat UI colors for this example, but feel free to choose whatever palette you like. The definition itself looks like this:</p><div><pre class="programlisting">BoxLayout:
    # ...
    ColorButton:
        background_color: C('#2980b9')
        state: 'down'

    ColorButton:
        background_color: C('#16A085')

    ColorButton:
        background_color: C('#27AE60')</pre></div><p>This notation is as clear as it can possibly get. There is just one property to define for every <code class="literal">ColorButton</code> widget, namely its <code class="literal">background_color</code> property. Everything else is inherited from the class definition, including the event handler.</p><p>The beauty of this architecture is that now we can add any number of such buttons, and they will <a id="id184" class="indexterm"/>align and perform correctly.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec24"/>Setting the line thickness</h1></div></div></div><p>The last<a id="id185" class="indexterm"/> and easiest feature that we are going to implement is a simple line thickness selector. As you can see in the following screenshot, we're reusing assets and styles from the previous part, the color palette.</p><div><img src="img/B01620_02_10.jpg" alt="Setting the line thickness"/><div><p>Line width selector</p></div></div><p>This UI uses yet another <code class="literal">RadioButton</code> subclass, unimaginatively named <code class="literal">LineWidthButton</code>. Append the following declaration to the <code class="literal">paint.kv</code> file:</p><div><pre class="programlisting">&lt;LineWidthButton@ColorButton&gt;:
    <strong>group: 'line_width'</strong>
    <strong>on_release: app.canvas_widget.set_line_width(self.text)</strong>
    color: C('#2C3E50')
    background_color: C('#ECF0F1')</pre></div><p>Key differences from <code class="literal">ColorButton</code> are highlighted in the preceding code. These new buttons belong to another radio group and fire another event handler when interacted with. Other than this, they are very similar.</p><p>The layout is equally simple, built in the same fashion as that of the color palette, except that it's vertical:</p><div><pre class="programlisting">BoxLayout:
    orientation: 'vertical'
    padding: 2
    spacing: 2
    x: 0
    top: root.top
    width: 80
    height: 110

    LineWidthButton:
        text: 'Thin'

    LineWidthButton:
        text: 'Normal'
        state: 'down'

    LineWidthButton:
        text: 'Thick'</pre></div><div><div><h3 class="title"><a id="note17"/>Note</h3><p>Note<a id="id186" class="indexterm"/> that our new event listener <code class="literal">CanvasWidget.set_line_width</code> will accept the <code class="literal">text</code> property of a pressed button. It is implemented like this for simplicity, as this allows us to define just one distinct property per widget.</p><p>In the real-world scenario, this approach isn't strictly forbidden or particularly unheard of but, still a bit questionable: what happens with these text labels when we decide to translate our application to Chinese or Hebrew?</p></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec35"/>Changing the line width</h2></div></div></div><p>With <a id="id187" class="indexterm"/>every part of the user interface in place, we can <a id="id188" class="indexterm"/>finally attach the event listener that's going to apply the selected line thickness to the painting. We will store the numeric value of the line width in <code class="literal">CanvasWidget.line_width</code>, based on the button's text mapping that's provided inline, and use it in the <code class="literal">on_touch_down</code> handler when beginning a new line. Long story short, these are relevant parts of the revised <code class="literal">CanvasWidget</code> class:</p><div><pre class="programlisting">class CanvasWidget(Widget):
    <strong>line_width = 2</strong>

    def on_touch_down(self, touch):
        # ...
        with self.canvas:
            touch.ud['current_line'] = Line(
                points=(touch.x, touch.y),
                <strong>width=self.line_width</strong>)

    def set_line_width(self, line_width='Normal'):
        <strong>self.line_width = {</strong>
<strong>            'Thin': 1, 'Normal': 2, 'Thick': 4</strong>
<strong>        }[line_width]</strong>
</pre></div><p>This concludes the Kivy Paint app tutorial. If you start the program now, you can probably <a id="id189" class="indexterm"/>paint something beautiful. (I cannot, as you<a id="id190" class="indexterm"/> have probably noticed from the illustrations.)</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec25"/>Summary</h1></div></div></div><p>In this chapter, we highlighted a number of common practices for the development of Kivy-based apps, such as customization of the main window, changing the mouse cursor, window size, and background color, the use of canvas instructions to draw free-form graphics programmatically, and handling touch events correctly across all supported platforms, with regards to multitouch.</p><p>One thing about Kivy that should be evident after building the Paint app is how open ended and versatile the framework is. Instead of providing a large number of rigid components, Kivy capitalizes on composability of simple building blocks: graphical primitives and behaviors. This means that while there are not many useful ready-made widgets bundled with Kivy, you can hack together anything you need in a few lines of highly readable Pythonic code.</p><p>The modular API design pays off nicely, thanks to its practically limitless flexibility. The end result meets your application's unique requirements perfectly. The customer wants something sensational, such as a triangular button—sure, you can also have a texture on it, all in a whopping three lines of code or so. (By comparison, try making a triangular button using <strong>WinAPI</strong>. That's like staring into the abyss, only less productive.)</p><p>These custom Kivy components also usually end up being reusable. In fact, you could easily import <code class="literal">CanvasWidget</code> from the <code class="literal">main.py</code> module and use it in another application.</p><p><strong>Natural user interface</strong></p><p>It's also worth mentioning that our second app is way more interactive than the first one: it responds not just to button clicks, but to arbitrary multitouch gestures as well.</p><p>All the available window surface reacts to touch, and as soon as it becomes evident to the end user, there is no cognitive overhead to painting, especially on a touch screen device. You just paint on a screen with your fingers, like it was a physical surface, and your fingers were sufficiently dirty to leave marks on it.</p><p>This kind of interface, or lack thereof, is called <strong>NUI</strong> (<strong>natural user interface</strong>). It has an interesting characteristic: a NUI application can be used by small kids and even pets—those capable of seeing and touching graphical objects on screen. This is literally a natural, intuitive interface, a "no-brainer" kind of thing, as opposed to the interface of, for example, Norton Commander, which was called intuitive back in the days. Let's face it: that was a lie. Intuition is not applicable to blue-screen, two-panel ASCII art programs in any practical way.</p><p>In the next chapter, we will build yet another Kivy-based program, this time limited to Android devices. It will exemplify the interoperability between Python code and Java classes that comprise the Android API.</p></div></body></html>