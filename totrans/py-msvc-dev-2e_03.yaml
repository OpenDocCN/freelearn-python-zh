- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: 'Coding, Testing, and Documentation: the Virtuous Cycle'
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编码、测试和文档：良性循环
- en: We write software because we want it to do something useful. But how do we know
    that the code does what we want it to? The obvious answer is that we test it.
    Sometimes we run a piece of code we've just written and look at what it does,
    to see if it is doing the right thing. There's often a lot of code, though, and
    there are a lot of things we want to ensure are working—and continue to work as
    we add new features.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写软件是因为我们希望它能做些有用的事情。但我们如何知道代码确实做了我们想要它做的事情呢？显而易见的答案是测试它。有时我们会运行刚刚编写的代码，看看它做了什么，以确定它是否在正确地执行。然而，代码通常很多，我们希望确保很多功能都在正常工作——并且在我们添加新功能时继续工作。
- en: Thankfully, most languages come with a way to automate testing your code, and
    Python is no exception. When we create tests along with the code we are writing,
    it will increase the likelihood of spotting an error. Bugs in our code cost time,
    and can cost a company money. Bugs are also impossible to eliminate completely—the
    best we can do is take reasonable steps to prevent as many as we can.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，大多数语言都提供了一种自动化测试代码的方法，Python也不例外。当我们与编写的代码一起创建测试时，会增加发现错误的概率。代码中的错误会耗费时间，也可能给公司造成损失。错误也不可能完全消除——我们能做的最好的事情就是采取合理的步骤来防止尽可能多的错误。
- en: 'Writing tests helps to provide a clearer idea of what software is meant to
    do. Take, for example, a function that is meant to return the five highest numbers
    in a list:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 编写测试有助于更清晰地了解软件的预期功能。例如，一个旨在从列表中返回五个最高数字的函数：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: It's a very simple function, so it probably does what we want. Or does it? The
    `.sort()` method works in place instead of returning a new value, so we've changed
    the order of the variable that we passed in as an argument; this can have unintended
    consequences in other areas of the program. The function also doesn't check to
    see that it's returning numbers, so what should be done if there are other objects
    in the list? If there are not enough numbers to return five of them, is that acceptable,
    or should the function raise an error?
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的函数，所以它可能确实做了我们想要它做的事情。或者呢？`.sort()`方法在原地工作而不是返回一个新值，所以我们改变了作为参数传递的变量的顺序；这可能在程序的其它区域产生意外的后果。该函数也没有检查它是否返回了数字，所以如果列表中有其他对象，应该怎么办？如果返回五个数字的数量不足，这是否可以接受，或者函数应该引发错误？
- en: 'By writing tests, we get a clear idea not just about what we want the function
    to do, but also how it should behave in different situations: We keep working
    towards the objective, but instead of thinking about "How to win" we think about
    "How to avoid losing."'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 通过编写测试，我们不仅对函数想要做什么有一个清晰的认识，而且对它在不同情况下应该如何表现也有了解：我们继续朝着目标努力，但不是思考“如何赢”，而是思考“如何避免失败”。
- en: '**Test-Driven Development** (**TDD**) is an approach where you write tests
    alongside the code you are creating and use the tests to guide what the code should
    do—and to demonstrate that it works as you expect. It will not always improve
    the quality of your project, but it will catch a lot of errors before they can
    cause damage, helping to make your team more agile. Developers who need to fix
    a bug or refactor a part of the application can do so with fewer concerns that
    they have broken something, and more easily show their team that the work is suitable.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试驱动开发**（**TDD**）是一种方法，你会在创建代码的同时编写测试，并使用这些测试来指导代码应该做什么——以及证明它按预期工作。它并不总是能提高项目的质量，但它会在错误造成损害之前捕捉到很多错误，帮助使团队更加敏捷。需要修复错误或重构应用程序一部分的开发者可以这样做，而不用担心他们破坏了什么，并且更容易向团队展示这项工作是合适的。'
- en: '**Behavior-Driven Development** (**BDD**) is another approach that can work
    well in combination with TDD. Using this method, tests describe the desired behavior
    of the software from a higher-level point of view and are often presented in more
    human-friendly language. A developer can write code to describe what happens when
    a test uses phrases such as "the user searches for" and "results are shown for,"
    allowing the people writing the tests to focus on what should happen; for example:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**行为驱动开发**（**BDD**）是另一种可以与TDD良好结合的方法。使用这种方法，测试从更高层次的角度描述软件的期望行为，并且通常使用更符合人类语言的表达方式。开发者可以编写代码来描述当测试使用诸如“用户搜索”和“显示结果”之类的短语时会发生什么，这样可以让编写测试的人专注于应该发生的事情；例如：'
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Some good examples of BDD tests are available at: [https://github.com/AndyLPK247/behavior-driven-python](https://github.com/AndyLPK247/behavior-driven-python)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 一些BDD测试的好例子可以在以下链接找到：[https://github.com/AndyLPK247/behavior-driven-python](https://github.com/AndyLPK247/behavior-driven-python)
- en: Writing tests is time-consuming at first, but in the long term, it is often
    the best approach to ensure a project is stable as it grows in size and scope.
    Of course, it's always possible to write bad tests and end up with poor results
    or create a test suite that is horrible to maintain and takes too long to run.
    The best tools and processes in the world won't prevent a careless developer from
    producing bad software.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 编写测试最初可能会很耗时，但从长远来看，这通常是确保项目在规模和范围增长时保持稳定性的最佳方法。当然，总是有可能编写出糟糕的测试，最终得到不良的结果，或者创建一个难以维护且运行时间过长的测试套件。世界上最好的工具和流程也无法阻止一个粗心的开发者生产出糟糕的软件。
- en: '![image3.png](img/B17108_03_01.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![image3.png](img/B17108_03_01.png)'
- en: 'Figure 3.1: The best tools on offer still won''t prevent complacent developers
    from producing bad software… Credit to: https://xkcd.com/303/'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1：即使提供的是最好的工具，也无法阻止自满的开发者生产出糟糕的软件……归功于：[https://xkcd.com/303/](https://xkcd.com/303/)
- en: A good set of tests should demonstrate that the software does what we intend
    it to do and that it should fail in a predictable and fixable way. That means
    that if you give it invalid data, or a dependency it relies on has broken, the
    behavior of the code is predictable.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一套好的测试应该证明软件确实做了我们想要它做的事情，并且它应该以可预测和可修复的方式失败。这意味着如果你给它无效的数据，或者它依赖的某个部分已经损坏，代码的行为是可预测的。
- en: Writing tests is also a good way to get some perspective on your code. Does
    the API you've designed make sense? Do things fit well together? And when the
    team gains more people or reorganizes, tests are a good source of information
    about the state of the code, detailing what its intentions are. The specific needs
    the software fulfils often change over time as well, meaning that significant
    refactoring—not just rewriting but changing the architecture—is often needed.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 编写测试也是了解代码的一种好方法。你设计的API是否合理？事物是否搭配得当？当团队人数增加或重组时，测试是了解代码状态的良好信息来源，详细说明了代码的意图。软件满足的具体需求也可能会随时间而变化，这意味着可能需要进行重大的重构——不仅仅是重写，还包括改变架构。
- en: Documentation is a crucial part of a project, although it's often the first
    area to fall behind. After a while, it becomes rare to see a project's documentation
    fully up to date with the state of the code, unless some dedicated people work
    on it. It can be an immense source of frustration for developers to find out that
    the code examples in the documentation are broken after some refactoring. But
    there are ways to mitigate these issues; for instance, code extracts in the documentation
    could be part of the test suite to make sure they work.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 文档是项目的一个关键部分，尽管它往往是第一个落后的领域。过了一段时间，除非有专人负责，否则很难看到项目的文档与代码状态完全同步。对于开发者来说，发现文档中的代码示例在重构后已经损坏，可能会非常沮丧。但有一些方法可以减轻这些问题；例如，文档中的代码摘录可以是测试套件的一部分，以确保它们可以正常工作。
- en: 'In any case, no matter how much energy you expend on tests and documentation,
    there is one golden rule: testing, documenting, and coding your projects should
    be done continuously. In other words, updating the tests and documentation is
    part of the process to update the code. We can make this process easier, as we
    shall see.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，无论你投入多少精力在测试和文档上，有一条黄金法则：测试、编写文档和编码你的项目应该是持续进行的。换句话说，更新测试和文档是更新代码的过程的一部分。我们将看到，我们可以使这个过程更容易。
- en: After providing a few general tips on how to test code in Python, this chapter
    focuses on what testing and documentation tools can be used in the context of
    building microservices with Quart, and how to set up continuous integration with
    some popular online services.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在提供了一些关于如何在Python中测试代码的一般性建议之后，本章重点介绍了在构建使用Quart的微服务时可以使用哪些测试和文档工具，以及如何与一些流行的在线服务设置持续集成。
- en: 'The chapter is organized into five parts:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本章分为五个部分：
- en: The different types of tests
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同的测试类型
- en: Using pytest and tox
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用pytest和tox
- en: Developer documentation
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发者文档
- en: Version control
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本控制
- en: Continuous integration
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续集成
- en: Different kinds of tests
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不同的测试类型
- en: 'There are many kinds of tests, and it can be confusing sometimes to know what
    is being spoken about. For instance, when people refer to functional tests, they
    may be referring to different kinds of tests depending on the project''s nature.
    In microservice land, we can classify tests into these five distinct goals:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 测试有很多种，有时很难知道正在讨论的是什么。例如，当人们提到功能测试时，他们可能根据项目的性质而指代不同的测试。在微服务领域，我们可以将测试分为以下五个不同的目标：
- en: '**Unit tests**: These make sure a class or a function works as expected in
    isolation.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单元测试**：这些确保类或函数在隔离状态下按预期工作。'
- en: '**Functional tests**: Verify that the microservice does what it says from the
    consumer''s point of view, and behaves correctly, even upon receiving bad requests.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**功能测试**：验证微服务是否从消费者的角度来看做了它所说的，并且即使在接收到不良请求时也能正确行为。'
- en: '**Integration tests**: Verify how a microservice integrates with all its network
    dependencies.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成测试**：验证微服务如何与其所有网络依赖项集成。'
- en: '**Load tests**: Measure the microservice performances.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**负载测试**：衡量微服务的性能。'
- en: '**End-to-end tests**: Verify that the whole system works—from initial request
    to final action—through all its components.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**端到端测试**：验证整个系统是否正常工作——从初始请求到最终操作——通过其所有组件。'
- en: We will dive deeper into the details in the following sections.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将更深入地探讨细节。
- en: Unit tests
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试
- en: Unit tests are the simplest and most self-contained tests to add to a project.
    The "unit" being tested is a small component of the code; for example, a single
    unit test might examine a single function, several unit tests might run a battery
    of tests against that function, and a whole suite of tests might run against the
    module that the function is in.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是添加到项目中 simplest 和最 self-contained 的测试。被测试的“单元”是代码的一个小组件；例如，一个单元测试可能检查一个函数，几个单元测试可能对该函数运行一系列测试，而整个测试套件可能对该函数所在的模块运行一系列测试。
- en: Python's standard library comes with everything needed to write unit tests.
    In most projects, there are functions and classes that can be tested in isolation,
    and projects based on Quart are no different.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Python的标准库包含了编写单元测试所需的一切。在大多数项目中，都有可以独立测试的函数和类，基于Quart的项目也不例外。
- en: Testing in isolation in Python usually means that you instantiate a class or
    call a function with specific arguments and verify that you get the expected result.
    If you have a function that gets given a large data structure and searches for
    a particular value within it, then that can be easily tested on its own as it
    is given everything it needs. However, when the class or function calls another
    piece of code that is not built in Python or its standard library, it is not in
    isolation anymore.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中进行隔离测试通常意味着您使用特定的参数实例化一个类或调用一个函数，并验证您是否得到预期的结果。如果您有一个函数接受一个大型数据结构并在其中搜索特定值，那么这可以很容易地单独测试，因为它已经得到了它所需的一切。然而，当类或函数调用不是由Python或其标准库构建的其他代码时，它就不再是隔离的了。
- en: In some cases, it will be useful to mock those calls to achieve isolation. Mocking
    means replacing a piece of code with a fake version which will return the value
    you need for the test, but fake the behavior that the real code performs. An example
    might be a function which queries a database and formats the data before returning
    it. In our unit test suite, we probably don't want to run a real database, but
    we can mock the database query so that it returns a predictable value, and make
    sure that our function does the right thing with what it gives us.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，模拟这些调用以实现隔离将是有用的。模拟意味着用假版本替换一段代码，该版本将返回测试所需的值，但模拟实际代码的行为。一个例子可能是一个查询数据库并在返回之前格式化数据的函数。在我们的单元测试套件中，我们可能不想运行真实的数据库，但我们可以模拟数据库查询，使其返回可预测的值，并确保我们的函数能够正确处理它所提供的内容。
- en: Mocking comes with its own risks, because it's easy to implement a different
    behavior in your mocks and end up with some code that works with your tests but
    not the real thing. That problem often occurs when you update your project's dependencies,
    or an external service changes what it sends, and your mocks are not updated to
    reflect the new behaviors.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟也伴随着其自身的风险，因为很容易在模拟中实现不同的行为，最终得到一些与测试兼容但与实际事物不兼容的代码。当您更新项目的依赖项或外部服务更改其发送的内容时，并且您的模拟没有更新以反映新的行为，这个问题通常会发生。
- en: 'So, limiting the usage of mocks to the three following use cases is good practice:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，将模拟的使用限制在以下三个用例中是一种良好的实践：
- en: '**I/O operations**: When the code performs calls to third-party services or
    a resource (socket, files, and so on), and you can''t run them from within your
    tests.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**I/O操作**：当代码对第三方服务或资源（套接字、文件等）进行调用，并且你无法在测试中运行它们时。'
- en: '**CPU-intensive operations**: When the call computes something that would make
    the test suite too slow.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CPU密集型操作**：当调用计算的内容会使测试套件运行得太慢时。'
- en: '**Specific behaviors to reproduce**: When you want to write a test to try out
    your code under specific behaviors (for example, a network error or changing the
    date or time by mocking the date time and time modules).'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**具体要复现的行为**：当你想要编写一个测试来测试你的代码在特定行为下（例如，网络错误或通过模拟日期和时间模块来更改日期和时间）的表现时。'
- en: 'Clean code techniques can help make our unit tests much more straightforward
    by trying to reduce the number of functions that have side effects and gathering
    all your I/O operations to the highest level possible. Consider the following
    scenario, where we are reading some data about superheroes from the Mozilla Developer
    Network''s documentation about JSON ([https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/JSON](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/JSON)):'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 清洁代码技术可以通过尝试减少具有副作用的功能数量并将所有I/O操作聚集到最高级别，从而帮助使我们的单元测试更加直接。考虑以下场景，我们正在从Mozilla开发者网络关于JSON的文档中读取有关超级英雄的一些数据（[https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/JSON](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/JSON)）：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In order to test the function that constructs the string, or the one that filters
    the names, we need to create a fake connection to the web. This means several
    of our functions are relying on mocked connections. Instead, we could write:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试构建字符串的功能或过滤名称的功能，我们需要创建一个到网络的假连接。这意味着我们的一些函数依赖于模拟连接。相反，我们可以编写：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: By rearranging our code this way, the network connection query is "higher up"—we
    encounter it first. We can write tests to examine and filter the results without
    ever creating a mocked connection, and it means we can use them in isolation in
    our code—perhaps we get the same data from a cache instead of the web, or receive
    it from a client who already has it. Our code is more flexible now, and simpler
    to test.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式重新排列我们的代码，网络连接查询是“更高层”——我们首先遇到它。我们可以编写测试来检查和过滤结果，而无需创建任何模拟连接，这意味着我们可以在代码中独立使用它们——也许我们从缓存而不是从网络中获取相同的数据，或者从已经拥有它的客户端接收它。我们的代码现在更加灵活，并且更容易测试。
- en: Of course, this is a somewhat contrived example, but the principle means that
    we are arranging our code so that there are functions with well-defined inputs
    and outputs, and that makes it easier to test. It's an important lesson from the
    world of functional programming languages, such as Lisp and Haskell, where functions
    are closer to mathematical functions.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这是一个有些牵强的例子，但原则意味着我们正在安排我们的代码，以便有定义良好的输入和输出的函数，这使得测试更容易。这是从函数式编程语言的世界中吸取的一个重要教训，例如Lisp和Haskell，在这些语言中，函数更接近数学函数。
- en: 'What might the tests look like? Here is a class using `unittest` that will
    perform some basic checks, including setting up any prerequisites that our tests
    have in a method called `setUp`, and cleaning up after ourselves if we add a method
    called `tearDown`. If this was a real service, we might also want to consider
    other situations, such as what `get_hero_names` does with no filter, or a filter
    that returns no results or throws an error. The following example uses `request_mock`,
    which is a handy library to mock request-based network calls (see [http://requests-mock.readthedocs.io](http://requests-mock.readthedocs.io)):'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 测试可能看起来像什么？以下是一个使用`unittest`的类，它将执行一些基本检查，包括在名为`setUp`的方法中设置测试所需的所有先决条件，并在添加名为`tearDown`的方法后进行清理。如果这是一个真实的服务，我们可能还想要考虑其他情况，例如`get_hero_names`在没有过滤器的情况下会做什么，或者一个返回无结果或抛出错误的过滤器。以下示例使用`request_mock`，这是一个方便的库，用于模拟基于请求的网络调用（见[http://requests-mock.readthedocs.io](http://requests-mock.readthedocs.io)）：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You should keep an eye on all your mocks as the project grows, and make sure
    they are not the only kind of tests that cover a particular feature. For instance,
    if the Bugzilla project comes up with a new structure for its REST API, and the
    server your project uses is updated, your tests will happily pass with your broken
    code until the mocks reflect the new behavior.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该密切关注所有模拟，随着项目的增长，确保它们不是覆盖特定功能的唯一测试类型。例如，如果Bugzilla项目为其REST API提出了一种新的结构，并且你项目使用的服务器进行了更新，你的测试将带着你损坏的代码高兴地通过，直到模拟反映了新的行为。
- en: How many tests and how good the test coverage is will depend on what your application
    is for. Unless your microservice is critical to your business, there is no need
    to have tests for all the failures you can come up with on day one. In a microservice
    project unit tests are not a priority, and aiming at 100% test coverage (where
    every line of your code is called somewhere in your tests) in your unit tests
    will add a lot of maintenance work for little benefit.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的数量和测试覆盖率的好坏将取决于您的应用程序用途。除非您的微服务对您的业务至关重要，否则没有必要在第一天就为所有可能出现的故障编写测试。在微服务项目中，单元测试不是优先事项，并且在单元测试中追求100%的测试覆盖率（即您的代码的每一行都在测试中被调用）将为维护工作增加很多，而好处却很少。
- en: It is better to focus on building a robust set of functional tests.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 最好专注于构建一个健壮的功能测试集。
- en: Functional tests
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 功能测试
- en: Functional tests for a microservice project are all the tests that interact
    with the published API by sending HTTP requests, and asserting that the HTTP responses
    are the expected ones. These differ from unit tests because they focus more on
    the behavior of a microservice, or a smaller part of a larger service.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务项目的功能测试是指所有通过发送HTTP请求与发布的API交互，并断言HTTP响应是预期结果的测试。这些测试与单元测试不同，因为它们更多地关注微服务或更大服务中较小部分的行为。
- en: 'This definition is broad enough to include any test that can call the application,
    from fuzzing tests (where gibberish is sent to your app and you see what happens)
    to penetration tests (you try to break the app security), and so on. The key part
    of a functional test is to investigate whether the software''s behavior meets
    its requirements. As developers, the two most important kinds of functional tests
    we should focus on are the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义足够广泛，可以包括任何可以调用应用程序的测试，从模糊测试（向您的应用程序发送乱码并查看会发生什么）到渗透测试（您尝试破坏应用程序的安全性），等等。功能测试的关键部分是调查软件的行为是否符合其要求。作为开发者，我们应该关注的最重要两种功能测试如下：
- en: Tests that verify that the application does what it was built for
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证应用程序是否按预期工作的测试
- en: Tests that ensure an abnormal behavior that was fixed is not happening anymore
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保已修复的异常行为不再发生的测试
- en: The way those scenarios are organized in the test class is up to the developers,
    but the general pattern is to create an instance of the application in the test
    class and then interact with it.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 测试类中这些场景的组织方式由开发者决定，但一般模式是在测试类中创建应用程序的实例，然后与之交互。
- en: In that context, the network layer is not used, and the application is called
    directly by the tests; the same request-response cycle happens, so it is realistic
    enough. However, we would still mock out any network calls happening within the
    application.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，网络层没有被使用，应用程序直接由测试调用；发生相同的请求-响应周期，因此足够真实。然而，我们仍然会模拟应用程序中发生的任何网络调用。
- en: 'Quart includes a `QuartClient` class to build requests, which can be created
    directly from the `app` object using its `test_client()` method. The following
    is an example of a test against the `quart_basic` app we showed in *Chapter 2*,
    *Discovering Quart*, which sends back a JSON body on `/api/`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Quart包含一个`QuartClient`类来构建请求，可以直接从`app`对象使用其`test_client()`方法创建。以下是对我们在*第2章*，*探索Quart*中展示的`quart_basic`应用进行的测试示例，该测试在`/api/`上返回JSON体：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `QuartClient` class has one method per HTTP method and sends back `Response`
    objects that can be used to assert the results. In the preceding example, we used
    `.get()`, and since it is asynchronous code, we had to await the call and the
    request to `get_data()`, as well as tell the `unittest` module that we were running
    asynchronous tests.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`QuartClient`类针对每种HTTP方法都有一个方法，并返回可以用来断言结果的`Response`对象。在先前的示例中，我们使用了`.get()`，由于它是异步代码，我们必须等待调用和对`get_data()`的请求，以及告诉`unittest`模块我们正在运行异步测试。'
- en: There is a testing flag in the `Quart` class which you can use to propagate
    exceptions to the test, but some prefer not to use it by default to get back from
    the app what a real client would get—for instance, to make sure the body of `5xx`
    or `4xx` errors is converted to JSON for API consistency.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`Quart`类中有一个测试标志，您可以使用它将异常传播到测试中，但有些人更喜欢默认不使用它，以便从应用程序中获取真实客户端会得到的内容——例如，确保`5xx`或`4xx`错误体的JSON转换，以保证API的一致性。'
- en: 'In the following example, the `/api/` call produces an exception, and we have
    error handlers for internal server errors and missing pages:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，`/api/`调用产生了一个异常，并且我们为内部服务器错误和缺失页面设置了错误处理器：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'With our tests, we are making sure the client gets a proper `500` with a structured
    JSON body in `test_raise()`. The `test_proper_404()` test method does the same
    tests on a non-existent path, and uses the asynchronous versions of the `TestCase`
    class along with its setup and teardown methods:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的测试中，我们确保在`test_raise()`中客户端得到一个适当的`500`状态码，并带有结构化的JSON体。`test_proper_404()`测试方法在非存在路径上执行相同的测试，并使用`TestCase`类的异步版本及其设置和清理方法：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'An alternative to the `QuartClient` method is **WebTest** ([https://docs.pylonsproject.org/projects/webtest/](https://docs.pylonsproject.org/projects/webtest/)),
    which offers a few more features out of the box. This will be covered later in
    this chapter. Also see the following for further details: ([http://webtest.pythonpaste.org](http://webtest.pythonpaste.org))'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`QuartClient`方法的替代方案是**WebTest** ([https://docs.pylonsproject.org/projects/webtest/](https://docs.pylonsproject.org/projects/webtest/))，它提供了一些开箱即用的额外功能。这将在本章后面进行讨论。有关更多详细信息，请参阅以下链接：([http://webtest.pythonpaste.org](http://webtest.pythonpaste.org))'
- en: Integration tests
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集成测试
- en: Unit tests and functional tests focus on testing your service code without calling
    other network resources, and so no other microservices in your application, or
    third-party services such as databases, need to be available. For the sake of
    speed, isolation, and simplicity, network calls are mocked.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试和功能测试专注于测试你的服务代码，而不调用其他网络资源，因此你的应用程序中的其他微服务或第三方服务，如数据库，不需要可用。为了速度、隔离和简单起见，网络调用被模拟。
- en: Integration tests are functional tests without any mocking and should be able
    to run on a real deployment of your application. For example, if your service
    interacts with Redis and RabbitMQ, they will be called by your service as normal
    when the integration tests are run. The benefit is that it avoids falling into
    the problems that were described earlier when mocking network interactions.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试是没有任何模拟的函数测试，应该能够在你的应用程序的实际部署上运行。例如，如果你的服务与Redis和RabbitMQ交互，当运行集成测试时，它们将像正常一样被你的服务调用。好处是它避免了在模拟网络交互时遇到的问题。
- en: You will be sure that your application works in a production execution context
    only if you try it in a fully integrated, realistic scenario.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在你在一个完全集成、真实场景中尝试你的应用程序时，你才能确保你的应用程序在生产执行上下文中工作。
- en: The caveat is that running tests against an actual deployment makes it harder
    to set up test data, or to clean up whatever data was produced from within the
    service during the test. Patching the application behavior to reproduce a service's
    response is also a difficult task.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 但要注意的是，针对实际部署运行测试使得设置测试数据或清理测试期间服务内部产生的任何数据变得更加困难。修补应用程序行为以重现服务的响应也是一个困难的任务。
- en: Good configuration management software can help significantly with integration
    tests, as having an Ansible playbook or Puppet configuration can mean deploying
    all these components is as simple as running a command. We will discuss this more
    in *Chapter 10*, *Deploying on AWS*, when we discuss deployment.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的配置管理软件可以显著帮助集成测试，因为拥有Ansible playbook或Puppet配置意味着部署所有这些组件就像运行一个命令一样简单。我们将在第10章*部署在AWS*中进一步讨论这个问题，当我们讨论部署时。
- en: Integration tests can also be run on a development or staging deployment of
    your service. With many developers pushing changes, this may cause contention
    on this limited resource, but it can be simpler—and less costly—to run all the
    integration tests while simulating the real environment that closely.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试也可以在你的服务开发或预发布部署上运行。由于许多开发者正在推送更改，这可能会导致对这个有限资源的竞争，但模拟真实环境运行所有集成测试可能更简单——且成本更低。
- en: You can use whatever tool you want to write your integration test. A bash script
    with `curl` might sometimes be enough on some microservices, while others might
    require careful orchestration.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用任何你想要的工具来编写你的集成测试。在某些微服务上，一个带有`curl`的bash脚本可能就足够了，而其他可能需要仔细的编排。
- en: It's better for integration tests to be written in Python, and be part of your
    project's collection of tests. To do this, a Python script that uses requests
    to call your microservice can do the trick. If you provide a client library for
    your microservice, this can be a good place to do its integration tests as well.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 对于集成测试来说，最好用Python编写，并成为你项目测试集合的一部分。为此，一个使用requests调用你的微服务的Python脚本可以做到这一点。如果你为你的微服务提供了一个客户端库，这也是进行集成测试的好地方。
- en: What differentiates integration tests from functional tests is mostly the fact
    that real services are being called. We discover the consequences of real interactions
    with databases, message queues, and other dependencies that the service possesses.
    What if we could write functional tests that can either be run on a local Quart
    application or against an actual deployment? This is possible with WebTest, as
    we will find out later in this chapter.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试与功能测试的区别主要在于调用的是真实的服务。我们发现了与数据库、消息队列和其他服务所拥有的依赖项的真实交互的后果。如果我们能够编写可以在本地Quart应用程序或针对实际部署运行的功能测试会怎样？这可以通过WebTest实现，正如我们将在本章后面了解到的那样。
- en: Load tests
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 负载测试
- en: The goal of a load test is to understand how your service performs under stress.
    Learning where it starts to fail under high load will tell you how to best plan
    for future eventualities, as well as distribute the workload your application
    currently has. The first version of your service may well be fast enough for the
    situation it finds itself in, but understanding its limitations will help you
    determine how you want to deploy it, and if its design is future-proof in the
    case of an increased load.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 负载测试的目标是了解你的服务在压力下的表现。了解它在高负载下开始失败的地方，将告诉你如何最好地规划未来的情况，以及分配应用程序当前的工作负载。你的服务的第一版可能已经足够快，以应对其所在的情况，但了解其局限性将帮助你确定你想要如何部署它，以及如果负载增加，其设计是否具有前瞻性。
- en: The information from load tests will, alongside numbers collected from the production
    service, allow you to balance your service's throughput with the number of queries
    it can reasonably respond to simultaneously, the amount of work that needs doing
    for a response, how long queries wait for a response, and how much the service
    will cost—this is known as capacity management.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 负载测试的信息，连同从生产服务收集到的数据，将帮助你平衡服务的吞吐量与它能够合理同时响应的查询数量、响应所需的工作量、查询等待响应的时间以及服务的成本——这被称为容量管理。
- en: A good load test can also point you to changes that can be made to remove a
    bottleneck, such as changing the way writes are made to a database so that they
    no longer require an exclusive lock.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的负载测试还可以指出可以做出哪些改变以消除瓶颈，例如改变写入数据库的方式，这样它们就不再需要独占锁。
- en: The real problem is that programmers have spent far too much time worrying about
    efficiency in the wrong places and at the wrong times; premature optimization
    is the root of all evil (or at least most of it) in programming.
  id: totrans-85
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 真正的问题在于程序员花费了太多时间在不恰当的地方和错误的时间担心效率；过早的优化是编程中所有邪恶（至少是大部分邪恶）的根源。
- en: ''
  id: totrans-86
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —Donald Knuth, The Art of Computer Programming
  id: totrans-87
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ——唐纳德·克努特，《计算机程序设计艺术》
- en: It's a common mistake to spend a lot of time on making each microservice as
    fast as possible, before we even know what the critical path is and what it is
    best to improve. Taking measurements before making changes allows us to see exactly
    what the benefits are of each change, and helps us prioritize our time and effort.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们甚至不知道关键路径是什么以及什么是最需要改进之前，花大量时间让每个微服务尽可能快，这是一个常见的错误。在做出改变之前进行测量，可以让我们确切地看到每个改变的益处，并帮助我们优先考虑时间和精力。
- en: 'Writing load tests can help you answer the following questions:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 编写负载测试可以帮助你回答以下问题：
- en: How many users can one instance of my service serve when I deploy it on this
    machine?
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我将服务部署到这台机器上时，一个实例可以服务多少用户？
- en: What is the average response time when there are 10, 100, or 1,000 concurrent
    requests? Can I handle that much concurrency?
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当有10、100或1000个并发请求时，平均响应时间是多少？我能处理这么多的并发量吗？
- en: When my service is under stress, is it running out of RAM or is it mainly CPU-bound?
    Is it waiting on another service?
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我的服务处于压力之下时，它是由于内存不足还是主要受CPU限制？它是在等待另一个服务吗？
- en: Can I add other instances of the same service and scale horizontally?
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我能否添加同一服务的其他实例并实现水平扩展？
- en: If my microservice calls other services, can I use pools of connectors, or do
    I have to serialize all the interactions through a single connection?
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我的微服务调用其他服务，我能使用连接器池，还是必须通过单个连接序列化所有交互？
- en: Can my service run for multiple days at a time without degradation?
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我的这项服务能否一次性运行多天而不会降低性能？
- en: Is my service working properly after a usage peak?
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在使用高峰之后，我的服务是否仍然运行正常？
- en: 'Depending on the kind of load you want to achieve, there are many tools available,
    from simple command-line tools to heavier distributed load systems. For performing
    a simple load test that does not require any specific scenario, Salvo is an **Apache
    Bench** (**AB**) equivalent written in Python, which can be used to apply load
    to your endpoints: [https://github.com/tarekziade/salvo](https://github.com/tarekziade/salvo).'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你想要达到的负载类型，有许多工具可供选择，从简单的命令行工具到更重的分布式负载系统。对于执行不需要任何特定场景的简单负载测试，Salvo是一个用Python编写的**Apache
    Bench**（**AB**）等效工具，可以用来对你的端点应用负载：[https://github.com/tarekziade/salvo](https://github.com/tarekziade/salvo)。
- en: 'In the following example, Salvo simulates 10 concurrent connections, each making
    100 sequential requests against a `Quart` web server on the `/api/` endpoint:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，Salvo模拟了10个并发连接，每个连接对`/api/`端点的`Quart`网络服务器进行100个连续请求：
- en: '[PRE8]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: These numbers don't mean much, as they will vary a lot depending on the deployment,
    and from where you run them. For instance, if your Flask application is served
    behind nginx with several workers, then the load will be distributed, some of
    the overhead will be handled by nginx, and for a complete picture we should test
    the entire service.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数字没有太多意义，因为它们会根据部署方式和运行位置有很大的变化。例如，如果你的Flask应用程序在nginx后面运行，并有多个工作进程，那么负载将会分散，一些开销将由nginx处理，为了获得完整的视图，我们应该测试整个服务。
- en: But this small test alone can often catch problems early on, in particular when
    your code is opening socket connections itself. If something is wrong in the microservice
    design, these tools make it easier to detect by highlighting unexpected responses,
    or causing the application to break in ways the developer was not expecting.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 但仅此小测试就常常能早期捕捉到问题，尤其是在你的代码本身打开套接字连接时。如果微服务设计中存在问题，这些工具通过突出显示意外的响应或以开发者未预料到的方式使应用程序崩溃，可以更容易地检测到。
- en: 'Salvo is based on **Molotov** ([https://molotov.readthedocs.io/en/stable/](https://molotov.readthedocs.io/en/stable/))
    which requires a bit more work to set up, but has more features, such as allowing
    interactive scenarios with sets of queries and expected responses. In the following
    example, each function is a possible scenario that gets picked by Molotov to run
    against the server:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Salvo基于**Molotov** ([https://molotov.readthedocs.io/en/stable/](https://molotov.readthedocs.io/en/stable/))，设置起来需要更多的工作，但具有更多功能，例如允许使用查询集和预期响应进行交互式场景。在以下示例中，每个函数都是一个Molotov可能选择的可能场景，以运行对服务器的测试：
- en: '[PRE9]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Both tools will give you some metrics, but they are not very accurate because
    of the network and client CPU variance on the box they are launched from. A load
    test will stress the resources of the machine running the test, and that will
    impact the metrics.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种工具都会提供一些指标，但由于它们启动的机器上的网络和客户端CPU差异，这些指标并不非常准确。负载测试会压力测试运行测试的机器的资源，这会影响指标。
- en: When performing a load test, server-side metrics allow greater visibility into
    your application. At the Quart level, you can use the Flask extension **Flask
    Profiler** ([https://github.com/muatik/flask-profiler](https://github.com/muatik/flask-profiler)),
    which collects the amount of time each request takes and offers a dashboard that
    will let you browse the collected times, as shown in *Figure 3.2*.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行负载测试时，服务器端指标可以让你更深入地了解你的应用程序。在Quart级别，你可以使用Flask扩展**Flask Profiler** ([https://github.com/muatik/flask-profiler](https://github.com/muatik/flask-profiler))，它收集每个请求所需的时间，并提供一个仪表板，让你浏览收集的时间，如图*图3.2*所示。
- en: '![image6.png](img/B17108_03_02.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![image6.png](img/B17108_03_02.png)'
- en: 'Figure 3.2: Flask Profiler enables the time taken for requests to be tracked,
    showing them in a graphical format'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2：Flask Profiler允许跟踪请求所需的时间，并以图形格式显示它们
- en: For a production service, it is best to use tools such as **Prometheus** ([https://prometheus.io/](https://prometheus.io/)),
    **InfluxDB** ([https://www.influxdata.com/](https://www.influxdata.com/)), or
    use one of your cloud hosting provider's built-in tools, such as AWS CloudWatch.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 对于生产服务，最好使用像**Prometheus** ([https://prometheus.io/](https://prometheus.io/))、**InfluxDB**
    ([https://www.influxdata.com/](https://www.influxdata.com/))这样的工具，或者使用你云托管提供商内置的工具，例如AWS
    CloudWatch。
- en: End-to-end tests
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 端到端测试
- en: An end-to-end test will check that the whole system works as expected from the
    end-user point of view. The test needs to behave like a real client, and call
    the system through the same **User Interface** (**UI**).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 端到端测试将检查整个系统从最终用户的角度来看是否按预期工作。测试需要表现得像真实客户端一样，并通过相同的**用户界面**（**UI**）调用系统。
- en: Depending on the type of application you are creating, a simple HTTP client
    might not be enough to simulate a real user. For instance, if the visible part
    of the system through which users are interacting is a web application with HTML
    pages that gets rendered on a client side, you will need to use a tool like **Selenium**
    ([https://www.selenium.dev/](https://www.selenium.dev/)). It will automate your
    browser in order to make sure that the client requests every CSS and JavaScript
    file and then renders every page accordingly.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你创建的应用程序类型，一个简单的HTTP客户端可能不足以模拟真实用户。例如，如果用户交互的系统可见部分是一个在客户端渲染HTML页面的Web应用程序，你需要使用像**Selenium**
    ([https://www.selenium.dev/](https://www.selenium.dev/))这样的工具。它将自动化你的浏览器，以确保客户端请求每个CSS和JavaScript文件，然后相应地渲染每个页面。
- en: JavaScript frameworks now do a lot of work on the client side to produce pages.
    Some of them have completely removed the server-side rendering of templates, and
    simply fetch data from the server to generate the HTML page by manipulating the
    **Document Object Model** (**DOM**) through the browser APIs. Calls to the server,
    in that case, consist of getting all the static JavaScript files needed for rendering
    a given URL, plus the data.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在JavaScript框架在客户端做了很多工作来生成页面。其中一些已经完全移除了模板的服务器端渲染，并通过浏览器API通过操作**文档对象模型**（**DOM**）从服务器获取数据来生成HTML页面。在这种情况下，对服务器的调用包括获取渲染给定URL所需的全部静态JavaScript文件，以及数据。
- en: Writing end-to-end tests is outside the scope of this book, but you can refer
    to *Selenium Testing Tools Cookbook* to learn more about this.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 编写端到端测试超出了本书的范围，但你可以参考《Selenium测试工具食谱》来了解更多关于这方面的内容。
- en: 'The following points summarize what we''ve learned in this section:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 以下要点总结了我们在本节中学到的内容：
- en: Functional tests are the most important tests to write for a web service, and
    it is easy to carry out in Quart by instantiating the app in the tests and interacting
    with it.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能测试是编写Web服务时最重要的测试，在Quart中通过在测试中实例化应用并与它交互，很容易执行。
- en: Unit tests are a good complement, but avoid misusing mocks.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试是一个很好的补充，但应避免误用模拟。
- en: Integration tests are like functional tests but run against a real deployment.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成测试类似于功能测试，但运行在真实的部署上。
- en: Load tests are useful to learn about your microservice bottlenecks and plan
    for the next steps of development.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负载测试有助于了解你的微服务瓶颈并规划下一步的开发。
- en: End-to-end tests require using the same UI that the client would normally use.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 端到端测试需要使用客户端通常会使用的相同UI。
- en: Knowing when you will need to write integration, load, or end-to-end tests depends
    on how your project is managed—but both unit and functional tests should be written
    every time you change something. Ideally, each change you make in your code should
    include a new test or modify an existing one. Unit tests can be written using
    standard Python, thanks to the excellent `unittest` package included in the standard
    library—we will see later how the **pytest** ([http://docs.pytest.org](http://docs.pytest.org))
    library adds extra features on top of it.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 了解何时需要编写集成、负载或端到端测试取决于你的项目管理方式——但每次你更改内容时，都应该编写单元和功能测试。理想情况下，你代码中的每个更改都应该包括一个新的测试或修改现有的测试。由于标准库中包含优秀的`unittest`包，单元测试可以使用标准Python编写——我们稍后会看到**pytest**
    ([http://docs.pytest.org](http://docs.pytest.org))库如何在它之上添加额外的功能。
- en: For functional tests, we shall look in the next section at pytest.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 对于功能测试，我们将在下一节中探讨pytest。
- en: Using pytest and tox
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用pytest和tox
- en: So far, all the tests we have written use `unittest` classes and `unittest.main()`
    to run them. As your project grows, you will have more and more test modules around.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们编写的所有测试都使用了`unittest`类和`unittest.main()`来运行。随着你的项目增长，你将拥有越来越多的测试模块。
- en: To automatically discover and run all the tests in a project, the `unittest`
    package introduced a Test Discovery feature in Python 3.2, which finds and runs
    tests, given a few options. This feature has been around for a while in projects
    like **Nose** ([https://nose.readthedocs.io](https://nose.readthedocs.io)) and
    pytest, and that was what inspired the test discovery feature in the `unittest`
    package in the standard library.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为了自动发现和运行项目中的所有测试，`unittest`包在Python 3.2中引入了测试发现功能，它根据一些选项查找并运行测试。这个功能在像**Nose**
    ([https://nose.readthedocs.io](https://nose.readthedocs.io))和pytest这样的项目中已经存在了一段时间，这也是标准库中`unittest`包测试发现功能的灵感来源。
- en: Which runner to use is a matter of taste, and as long as you stick to writing
    your tests in `TestCase` classes, your tests will be compatible with all of them.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 使用哪个运行器是一个口味问题，只要您坚持在 `TestCase` 类中编写测试，您的测试将与所有这些运行器兼容。
- en: 'That said, the pytest project is very popular in the Python community, and
    since it offers extensions, people have started to write useful tools around it.
    Its runner is also quite efficient, as it starts to run the tests while they are
    still discovered in the background, making it a little faster than the others.
    Its output in the console is also beautiful and bright. To use it in your project,
    you can simply install the `pytest` package with pip, and use the provided pytest
    command line. In the following example, the `pytest` command runs all the modules
    that start with `test_`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，pytest 项目在 Python 社区中非常受欢迎，并且由于它提供了扩展，人们已经开始围绕它编写有用的工具。它的运行器也非常高效，因为它在后台发现测试的同时开始运行测试，这使得它比其他运行器稍微快一点。它的控制台输出也非常漂亮和明亮。要在您的项目中使用它，您只需使用
    pip 安装 `pytest` 包，并使用提供的 pytest 命令行。在以下示例中，`pytest` 命令运行所有以 `test_` 开头的模块：
- en: '[PRE10]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `pytest` package comes with a lot of extensions, which are listed at [http://plugincompat.herokuapp.com/](http://plugincompat.herokuapp.com/).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`pytest` 包附带了许多扩展，这些扩展在 [http://plugincompat.herokuapp.com/](http://plugincompat.herokuapp.com/)
    上列出。'
- en: The code samples in this book have been formatted with `Black`, which is also
    available as a pytest extension. Other useful extensions are `pytest-cov` (`https://github.com/pytest-dev/pytest-cov`)
    and `pytest-flake8` ([https://github.com/tholo/pytest-flake8](https://github.com/tholo/pytest-flake8)).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的代码示例已使用 `Black` 格式化，它也作为 pytest 扩展提供。其他有用的扩展包括 `pytest-cov` (`https://github.com/pytest-dev/pytest-cov`)
    和 `pytest-flake8` ([https://github.com/tholo/pytest-flake8](https://github.com/tholo/pytest-flake8))。
- en: 'The first one uses the coverage tool ([https://coverage.readthedocs.io](https://coverage.readthedocs.io))
    to display the test coverage of your project, and the second one runs the `Flake8`
    ([https://gitlab.com/pycqa/flake8](https://gitlab.com/pycqa/flake8)) linter to
    make sure that your code is following the `PEP8` style, and avoids a variety of
    other problems. Here is an invocation example with some deliberate style issues:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个扩展使用覆盖率工具 ([https://coverage.readthedocs.io](https://coverage.readthedocs.io))
    来显示您项目的测试覆盖率，第二个扩展运行 `Flake8` ([https://gitlab.com/pycqa/flake8](https://gitlab.com/pycqa/flake8))
    检查器以确保您的代码遵循 `PEP8` 风格，并避免各种其他问题。以下是一个包含一些故意风格问题的调用示例：
- en: '[PRE11]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Another useful tool that can be used in conjunction with pytest is **tox** ([http://tox.readthedocs.io](http://tox.readthedocs.io)).
    If your projects need to run on several versions of Python or in several different
    environments, tox can automate the creation of these separate environments to
    run your tests.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可以与 pytest 一起使用的有用工具是 **tox** ([http://tox.readthedocs.io](http://tox.readthedocs.io))。如果您的项目需要在多个
    Python 版本或多个不同的环境中运行，tox 可以自动化创建这些单独的环境来运行您的测试。
- en: 'Once you have installed tox (using the `pip install tox` command), it requires
    a configuration file called `tox.ini` in the root directory of your project. Tox
    assumes that your project is a Python package and therefore has a `setup.py` file
    in the root directory alongside the `tox.ini` file, but that''s the only requirement.
    The `tox.ini` file contains the command lines to run the tests along with the
    Python versions that it should be run against:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您安装了 tox（使用 `pip install tox` 命令），它需要在您项目的根目录中一个名为 `tox.ini` 的配置文件。Tox 假设您的项目是一个
    Python 包，因此在 `tox.ini` 文件旁边，根目录中还有一个 `setup.py` 文件，但这只是唯一的要求。`tox.ini` 文件包含了运行测试的命令行以及它应该针对的
    Python 版本：
- en: '[PRE12]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: When tox is executed by calling the `tox` command, it will create a separate
    environment for each Python version, deploy your package and its dependencies
    in it, and run the tests in it using the `pytest` command.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当通过调用 `tox` 命令执行 tox 时，它将为每个 Python 版本创建一个单独的环境，在该环境中部署您的包及其依赖项，并使用 `pytest`
    命令在其中运行测试。
- en: You can run a single environment with `tox -e`, which is very handy when you
    want to run the tests in parallel using automated tools. For instance, `tox -e
    py38` will just run pytest under Python 3.8.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `tox -e` 运行单个环境，这在您想使用自动化工具并行运行测试时非常方便。例如，`tox -e py38` 将仅在 Python 3.8
    下运行 pytest。
- en: Even if you support a single Python version, using tox will ensure that your
    project can be installed in a current Python environment and that you have correctly
    described all the dependencies. We will use tox in our worked example in later
    chapters.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你支持单个Python版本，使用tox也能确保你的项目可以在当前的Python环境中安装，并且你已经正确描述了所有依赖项。我们将在后续章节的工作示例中使用tox。
- en: Developer documentation
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发者文档
- en: 'So far, we''ve looked at the different kinds of tests a microservice can have,
    and we''ve mentioned that the documentation should evolve with the code. We are
    talking here about developer documentation. This includes everything a developer
    should know about your microservices project, most notably:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经探讨了微服务可能具有的不同类型的测试，并且提到文档应该随着代码的演变而发展。这里我们谈论的是开发者文档。这包括开发者应该了解你微服务项目的所有内容，最值得注意的是：
- en: How it is designed.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是如何设计的。
- en: How to install it.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何安装它。
- en: How to run the tests.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何运行测试。
- en: What are the exposed APIs and what data moves in and out?
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公开的API有哪些，以及什么数据进出？
- en: 'People go to documentation to get their questions answered. There are Who,
    What, Where, When, Why, and How questions, such as:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 人们会查阅文档来获取问题的答案。这些问题包括谁（Who）、什么（What）、哪里（Where）、何时（When）、为什么（Why）和如何（How），例如：
- en: Who should use this software?
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 谁应该使用这款软件？
- en: What does this software do?
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这款软件做什么？
- en: Where can it be deployed?
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以部署在哪里？
- en: When is using it helpful?
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在什么情况下使用它是有帮助的？
- en: Why does it work this way?
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么它会以这种方式工作？
- en: How do I install and configure it?
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我该如何安装和配置它？
- en: Good documentation describes why decisions were made so that people—including
    yourself—returning to the code can decide whether a decision made in the past
    is worth following, or whether the situation has moved on and decisions need to
    be revisited. A developer reading the documentation should come away with a clear
    idea of the answers to Why questions, and information about the more difficult
    How questions.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的文档描述了为什么做出某些决策，以便人们——包括你自己——在返回代码时可以决定过去的决策是否值得遵循，或者情况是否已经发生变化，需要重新审视决策。阅读文档的开发者应该对“为什么”问题的答案有一个清晰的认识，以及关于更难回答的“如何”问题的信息。
- en: It is rare that each line of code or function needs to be mentioned in a separate
    document. Instead, the source code should have comments in it that help a developer
    navigate and understand what they are reading. Functions should have docstring
    comments that explain their purpose, arguments, and return values, unless they
    are truly short and obvious. These are easier to keep up to date when the code
    is changed and avoid the need to tightly couple the documentation and the implementation—a
    design principle that works here as well as when designing the software itself.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 很少有情况需要在一篇单独的文档中提及每一行代码或函数。相反，源代码中应该包含注释，帮助开发者导航和理解他们正在阅读的内容。函数应该有文档字符串注释来解释其目的、参数和返回值，除非它们确实非常简短且明显。当代码发生变化时，这些注释更容易保持更新，并且可以避免将文档和实现紧密耦合——这是一个既适用于设计软件本身也适用于这里的工程设计原则。
- en: Tools for documentation
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文档工具
- en: The **Sphinx** tool ([http://www.sphinx-doc.org/](http://www.sphinx-doc.org/)),
    which was developed by *Georg Brandl* to document Python itself, became the standard
    in the Python community. Sphinx treats documents like source code by separating
    the content from the layout. The usual way to use Sphinx is to have a `docs` directory
    in the project that contains the unprocessed content for the documentation, and
    then to generate the HTML files using Sphinx's command-line utility.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**Sphinx**工具（[http://www.sphinx-doc.org/](http://www.sphinx-doc.org/）），由*Georg
    Brandl*开发用于记录Python本身，已成为Python社区的行业标准。Sphinx通过将内容与布局分离来将文档视为源代码。使用Sphinx的常规方法是，在项目中有一个名为`docs`的目录，其中包含文档的未处理内容，然后使用Sphinx的命令行工具生成HTML文件。'
- en: Producing an HTML output with Sphinx makes an excellent static website, which
    can be published on the web; the tool adds index pages, a small JavaScript-based
    search engine, and navigation features.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Sphinx生成HTML输出可以创建一个出色的静态网站，可以发布到网络上；该工具添加索引页面、一个基于JavaScript的小型搜索引擎和导航功能。
- en: 'The content of the documentation must be written in **reStructuredText** (**reST**),
    which is the standard markup language in the Python community. A reST file is
    a simple text file with a non-intrusive syntax to mark section headers, links,
    text styles, and so on. Sphinx adds a few extensions and summarizes reST usage
    in this document: [https://www.sphinx-doc.org/en/master/usage/restructuredtext/basics.html](https://www.sphinx-doc.org/en/master/usage/restructuredtext/basics.html)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 文档的内容必须使用 **reStructuredText** (**reST**) 编写，这是 Python 社区中的标准标记语言。一个 reST 文件是一个简单的文本文件，具有非侵入性的语法来标记章节标题、链接、文本样式等。Sphinx
    在此文档中添加了一些扩展，并总结了 reST 的用法：[https://www.sphinx-doc.org/en/master/usage/restructuredtext/basics.html](https://www.sphinx-doc.org/en/master/usage/restructuredtext/basics.html)
- en: '**Markdown** ([https://daringfireball.net/projects/markdown/](https://daringfireball.net/projects/markdown/))
    is another popular markup language used in the open-source community, and you
    may have encountered it if you have updated README files on GitHub. Markdown and
    reST are similar enough that moving between the two should be straightforward.
    This can be quite useful, as Sphinx has limited support for Markdown.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**Markdown** ([https://daringfireball.net/projects/markdown/](https://daringfireball.net/projects/markdown/))
    是另一种在开源社区中广泛使用的标记语言，如果你在 GitHub 上更新过 README 文件，你可能已经遇到过它。Markdown 和 reST 足够相似，以至于在两者之间切换应该是直截了当的。这非常有用，因为
    Sphinx 对 Markdown 的支持有限。'
- en: 'When you start a project with Sphinx using `sphinx-quickstart`, it generates
    a source tree with an `index.rst` file, which is the landing page of your documentation.
    From there, calling `sphinx-build` on it will create your documentation. As an
    example, if you want to generate HTML documentation, you can add a `docs` environment
    in your `tox.ini` file, and let the tool build the documentation for you as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 `sphinx-quickstart` 开始一个 Sphinx 项目时，它将生成一个包含 `index.rst` 文件的源树，这是你文档的着陆页。从那里，调用
    `sphinx-build` 将创建你的文档。例如，如果你想生成 HTML 文档，你可以在 `tox.ini` 文件中添加一个 `docs` 环境，并让工具为你构建文档，如下所示：
- en: '[PRE13]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Running `tox -e docs` will generate your documentation.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `tox -e docs` 将生成你的文档。
- en: 'Showing code examples in Sphinx can be done by pasting your code in a literal
    block prefixed by using a `::` marker or a code-block directive. In HTML, Sphinx
    will render it using the **Pygments** ([http://pygments.org/](http://pygments.org/))
    syntax highlighter:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Sphinx 中展示代码示例可以通过粘贴你的代码到一个以 `::` 标记或代码块指令为前缀的文本块中来实现。在 HTML 中，Sphinx 将使用
    **Pygments** ([http://pygments.org/](http://pygments.org/)) 语法高亮器来渲染它：
- en: '[PRE14]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Below is the first example of a `**Quart**` app in the official documentation:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是官方文档中 `**Quart**` 应用程序的第一个示例：
- en: '[PRE15]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: That snippet is a fully working app!
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是一个完全工作的应用！
- en: '[PRE16]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This will grab docstrings to inject them in the documentation and is also how
    Python documents its standard library at: [https://docs.python.org/3/library/index.html](https://docs.python.org/3/library/index.html)'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这将抓取文档字符串以将其注入到文档中，这也是 Python 记录其标准库的方式：[https://docs.python.org/3/library/index.html](https://docs.python.org/3/library/index.html)
- en: 'In the following example, the `autofunction` directive will catch the docstring
    from the index function that is located in the `myservice/views/home.py` module:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，`autofunction` 指令将捕获位于 `myservice/views/home.py` 模块中的索引函数的文档字符串：
- en: '[PRE17]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: When rendered in HTML, the page will display as shown in *Figure 3.3*.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 当在 HTML 中渲染时，页面将显示如图 *图 3.3* 所示。
- en: '![image4.png](img/B17108_03_03.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![image4.png](img/B17108_03_03.png)'
- en: 'Figure 3.3: The above code, as it is rendered in HTML'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3：上述代码在 HTML 中的渲染效果
- en: 'The other option is to use a `literalinclude` directive, which will let you
    include source code directly. When the file is a Python module, it can be included
    in the test suite to make sure it works. The following is a full example of project
    documentation using Sphinx:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是使用 `literalinclude` 指令，这将允许你直接包含源代码。当文件是一个 Python 模块时，它可以包含在测试套件中以确保其工作。以下是一个使用
    Sphinx 的项目文档的完整示例：
- en: '[PRE18]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Views can return simple data structures, as we've been using in our example
    code so far. In that case, they will be converted into a JSON response. When rendered
    in HTML, the page will display as shown in *Figure 3.4*.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 视图可以返回简单的数据结构，就像我们迄今为止在示例代码中所使用的那样。在这种情况下，它们将被转换为 JSON 响应。当在 HTML 中渲染时，页面将显示如图
    *图 3.4* 所示。
- en: '![image5.png](img/B17108_03_04.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![image5.png](img/B17108_03_04.png)'
- en: 'Figure 3.4: Documentation rendered with Sphinx'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4：使用 Sphinx 渲染的文档
- en: Of course, using **Autodoc** and **literalinclude** will not fix your processes
    or design documents—maintaining proper documentation is hard and developers often
    prioritize changes to the code above changes to the documentation.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，使用**Autodoc**和**literalinclude**并不能修复你的流程或设计文档——维护适当的文档是困难的，开发者通常将代码的更改优先于文档的更改。
- en: It is an easy position to understand, as the code furthers the needs of the
    organization, but there will be consequences if it is not done. Anything that
    can be done to automate part of this documentation work is great.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个容易理解的位置，因为代码满足了组织的需要，但如果它没有完成，将会有后果。任何可以自动化这部分文档工作的方法都是极好的。
- en: In *Chapter 4*, *Designing* *Jeeves*, we will see how we can use Sphinx to document
    the microservice HTTP APIs by using OpenAPI and the Sphinx extension to support
    it.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第 4 章*，*设计* *Jeeves* 中，我们将看到如何使用 Sphinx 通过 OpenAPI 和支持它的 Sphinx 扩展来记录微服务
    HTTP API。
- en: 'The following points summarize this section:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 以下要点总结了本节内容：
- en: Sphinx is a powerful tool to document your project.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sphinx 是一个强大的工具，可以用来记录你的项目。
- en: Treating your documentation as source code will facilitate its maintenance.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将你的文档视为源代码将有助于其维护。
- en: Tox can be used to rebuild the documentation when something changes.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tox 可以在发生变化时重新构建文档。
- en: If your documentation points to your code, it will be easier to maintain.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的文档指向你的代码，维护起来会更简单。
- en: Version control
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 版本控制
- en: 'Many of us have worked on projects where we want to keep a copy of something
    "just in case." This can be homework from school, a project document for work,
    or, if you''re particularly organized, some planning notes for something at home.
    Often, when we make a lot of changes, we end up with copies of the file with different
    names that may make sense at the time but quickly get out of control:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们中的许多人都在一些项目中工作过，我们想要保留一些东西的副本以备不时之需。这可能是学校的作业，工作项目文档，或者如果你特别有组织，可能是家里某事的规划笔记。通常，当我们做了很多修改后，我们会得到不同名称的文件副本，这些名称在当时可能是有意义的，但很快就会变得难以控制：
- en: '[PRE19]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This situation gets even more chaotic when multiple people are working on a
    project. This is where version control really shines. Using a **Version Control
    System** (**VCS**) means that each project is kept as a repository of all its
    files, and every change you commit is kept forever, unless you work really hard
    to remove it from the repository's history. Accidentally deleted an important
    paragraph or a useful bit of Python code? It will be in the version control history,
    so it can easily be recovered. Have more than one person working on something?
    These tools make it easy to track, compare, and merge changes.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当多个人在一个项目上工作时，这种情况会变得更加混乱。这正是版本控制真正发挥作用的地方。使用**版本控制系统**（**VCS**）意味着每个项目都作为一个包含所有文件的仓库来维护，你提交的每个更改都将永远保留，除非你非常努力地将其从仓库的历史中删除。不小心删除了一个重要的段落或一段有用的
    Python 代码？它将在版本控制历史中，因此可以轻松恢复。有不止一个人在处理某事？这些工具使得跟踪、比较和合并更改变得容易。
- en: There are many version control systems out there, such as `Git`, `Mercurial`,
    and `Subversion`. The examples from this book will all work with Git, as we are
    taking advantage of the features available on GitHub, a popular hosted service
    for version control—and for our needs, we will be using a free-tier account. If
    you would like to experiment with the code examples, it is a good idea to sign
    up for an account at [https://github.com/](https://github.com/).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有许多版本控制系统，如 `Git`、`Mercurial` 和 `Subversion`。本书中的示例都将与 Git 一起工作，因为我们正在利用 GitHub
    上可用的功能，GitHub 是一个流行的版本控制托管服务——并且为了我们的需求，我们将使用免费层账户。如果你想尝试代码示例，注册一个 [https://github.com/](https://github.com/)
    的账户是个好主意。
- en: Many other services exist that do similar things, with a slightly different
    set of features or workflows that are possible. For example, **GitLab** ([http://gitlab.com](http://gitlab.com))
    and **Bitbucket** ([https://bitbucket.org/](https://bitbucket.org/)) are both
    excellent services for hosting a Git repository. Other version control software,
    such as Mercurial and Subversion mentioned above, are also popular choices, and
    you will see them (and others) in use in organizations around the world.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 许多其他服务也存在，它们执行类似的功能，具有略微不同的功能集或工作流程。例如，**GitLab** ([http://gitlab.com](http://gitlab.com))
    和 **Bitbucket** ([https://bitbucket.org/](https://bitbucket.org/)) 都是托管 Git 仓库的优秀服务。其他版本控制软件，如上面提到的
    Mercurial 和 Subversion，也是流行的选择，你将在世界各地的组织中看到它们（以及其他工具）的使用。
- en: 'Hosted services generally offer a wide range of features in addition to the
    core version control, such as issue tracking, project management, and our next
    topic: CI/CD systems.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 主机服务通常除了核心版本控制之外，还提供一系列功能，例如问题跟踪、项目管理，以及我们接下来要讨论的主题：CI/CD系统。
- en: Continuous Integration and Continuous Deployment
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续集成和持续部署
- en: 'Tox can automate many testing steps for your project: running tests on various
    different Python versions; verifying coverage and code styles; building documentation,
    and so on. This is still something you would need to run by hand, and would also
    need to be maintained across several different versions of Python—a task made
    easier with tools such as **pyenv** ([https://github.com/pyenv/pyenv](https://github.com/pyenv/pyenv)),
    although still involving some work to keep organized.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Tox可以为你的项目自动化许多测试步骤：在多种不同的Python版本上运行测试；验证覆盖率代码风格；构建文档等。这仍然是你需要手动运行的事情，并且还需要在多个Python版本之间维护——使用像**pyenv**（[https://github.com/pyenv/pyenv](https://github.com/pyenv/pyenv)）这样的工具可以使这项任务更容易，尽管仍然需要一些工作来保持组织。
- en: A **Continuous Integration** (**CI**) system solves this issue by listening
    for changes in your version control system for the right time to run the commands
    you decide on, and will often take care of the different environments for you.
    As an example, if you needed to make a change to an open-source project hosted
    on GitHub, you would be able to clone the repository. You would then have a complete
    copy of it on your own computer, including all of its history. You then make the
    change you need, commit it to your own copy's history, and make a **Pull Request**
    (**PR**) on GitHub, essentially asking the person who has the original copy of
    the repository to pull in your changes; allowing random people uncontrolled access
    is not a good idea!
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '**持续集成**（**CI**）系统通过监听版本控制系统的变化，在正确的时间运行你决定的命令，通常还会为你处理不同的环境。例如，如果你需要修改托管在GitHub上的开源项目，你将能够克隆该仓库。然后你会在自己的电脑上拥有它的完整副本，包括所有历史记录。然后你进行所需的更改，将其提交到自己的副本历史中，并在GitHub上发起一个**拉取请求**（**PR**），本质上是在请求拥有仓库原始副本的人拉取你的更改；允许随机人员无控制地访问并不是一个好主意！'
- en: You know the code you have written is good, but how does this project owner
    know? They might receive dozens of these requests each week, or each day. If they
    connect a CI system, they can set things up so that each time someone submits
    a PR, or a change is merged into their copy, the tests they want to run are done
    automatically. They can also deploy their software this way by letting the system
    know what commands to run to automatically build and release a package, update
    some published documentation, or copy code out to running servers and set up the
    new version of the software. This is known as **Continuous Deployment** (**CD**).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道你编写的代码是好的，但项目所有者如何知道呢？他们可能每周或每天都会收到数十个这样的请求。如果他们连接一个CI系统，他们可以设置系统，以便每次有人提交PR或更改合并到他们的副本时，他们想要的测试都会自动执行。他们还可以通过让系统知道要运行哪些命令来自动构建和发布软件包、更新一些已发布的文档或将代码复制到运行的服务器上并设置软件的新版本。这被称为**持续部署**（**CD**）。
- en: We mentioned integration tests earlier, and now we are discussing CI; it's important
    to remember that CI/CD systems run whatever commands you tell them to. They don't
    have to be integration tests—there doesn't have to be any integration at all—but
    they are immensely useful services for testing your code in the way that you want,
    without having to worry about forgetting or testing many different versions.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到了集成测试，现在我们正在讨论CI；重要的是要记住，CI/CD系统会运行你告诉它们的任何命令。它们不一定是集成测试——根本不需要任何集成——但它们是测试你代码的非常有用的服务，无需担心忘记测试或测试许多不同的版本。
- en: GitHub Actions
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GitHub Actions
- en: Many CI systems integrate with popular version control services and so there
    are many options to run your tests, such as `CircleCI` and `Jenkins`. For more
    complex requirements, there are also options such as **Taskcluster** ([https://taskcluster.net/](https://taskcluster.net/))
    which is used to build the Firefox web browser and needs to be built on half a dozen
    platforms and run tens of thousands of tests. However, GitHub comes with its own
    offering built in, and so to keep things clear, we will be using GitHub `Actions`
    for the examples in this book.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 许多CI系统与流行的版本控制服务集成，因此有许多选项可以运行测试，例如`CircleCI`和`Jenkins`。对于更复杂的需求，也有像**Taskcluster**([https://taskcluster.net/](https://taskcluster.net/))这样的选项，它用于构建Firefox网络浏览器，需要在半个平台上构建，并运行数万个测试。然而，GitHub自带内置的服务，因此为了保持清晰，我们将在这本书的示例中使用GitHub
    `Actions`。
- en: 'Most of the services run in a similar way, so it''s worth covering how it happens.
    Once a CI system is connected to your project, it will look for some configuration
    in your repository. GitHub Actions looks for files in a directory called `github/workflows`,
    CircleCI looks for a file named `.circleci/config.yml`, and so on. Let''s look
    at an example using GitHub Actions:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数服务运行方式相似，因此了解其工作原理是值得的。一旦CI系统连接到你的项目，它将在你的仓库中查找一些配置。GitHub Actions会在名为`github/workflows`的目录中查找文件，CircleCI会查找名为`.circleci/config.yml`的文件，等等。让我们通过GitHub
    Actions的示例来了解一下：
- en: '[PRE20]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We see that, thanks to `on:` `[push]`, this will be run every time the repository
    receives a new change—and this includes a pull request, so we can see whether
    the tests pass for anyone wanting to give us new code.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，由于`on:` `[push]`，这将每次仓库接收到新更改时运行——这包括拉取请求，因此我们可以看到是否有人想要给我们新代码时测试是否通过。
- en: 'The workflow has been told to run three times, using the selection of Python
    versions listed in the strategy, and for each Python version it will run the steps
    shown: checking out a copy of the push; setting up Python; installing tox; running
    tox.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 工作流程已被告知运行三次，使用策略中列出的Python版本，并且对于每个Python版本，它将运行显示的步骤：检出推送的副本；设置Python；安装tox；运行tox。
- en: Many different commands or services can be connected in CI/CD pipelines to let
    us examine code quality, formatting, check for outdated dependencies, building
    packages, and deploying our service. We will look at documentation control and
    code test coverage as examples.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在CI/CD管道中连接许多不同的命令或服务，以便我们检查代码质量、格式、检查过时的依赖项、构建软件包以及部署我们的服务。我们将以文档控制和代码测试覆盖率为例进行探讨。
- en: Documentation
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文档
- en: There are many good options for hosting documentation. GitHub even includes
    a built-in documentation service called GitHub `Pages`, although to keep ourselves
    in line with other Python projects, and to provide examples of using an external
    service, we will be using **ReadTheDocs** (**RTD**) ([https://docs.readthedocs.io](https://docs.readthedocs.io)
    ) for our example microservice. Whichever option you choose, a GitHub action or
    other CI integration can be set up to ensure your documentation is updated whenever
    a change is made.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 存档文档有许多优秀的选项。GitHub甚至包含一个内置的文档服务，称为GitHub `Pages`，尽管为了与其他Python项目保持一致，并提供使用外部服务的示例，我们将使用**ReadTheDocs**（**RTD**）([https://docs.readthedocs.io](https://docs.readthedocs.io)
    )作为我们的示例微服务。无论你选择哪种选项，都可以设置GitHub action或其他CI集成，以确保在每次更改时更新文档。
- en: Using this approach, your documentation will be in ReStructuredText (`.rst`)
    or Markdown (`.md`) files, which are very easy to create and are a useful format
    for reading across many different platforms with different accessibility needs.
    Pages and RTD will create HTML from these documents that are suitable for displaying
    on the web, and you can apply themes and templates to them to make the resulting
    web pages appear however you would like.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，你的文档将存储在ReStructuredText（`.rst`）或Markdown（`.md`）文件中，这些文件非常容易创建，并且是跨多个不同平台和不同可访问性需求的有用格式。Pages和RTD将从这些文档创建适合在网络上显示的HTML，你可以应用主题和模板，使生成的网页看起来符合你的要求。
- en: RTD comes with easy support for different versions of your software so that
    readers can change views between the documentation for, say, versions 1 and 2\.
    This is very useful when you are maintaining different versions, such as just
    after a new release, or migrating takes some users a long time. The versioning
    feature scans git tags and lets you build and publish your documentation per tag
    and decide which one is the default.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: RTD自带对软件不同版本的简单支持，以便读者可以在版本1和2的文档之间切换视图。当你维护不同版本时，这非常有用，比如在新版本发布后不久，或者迁移需要一些用户花费很长时间。版本功能扫描git标签，并允许你按标签构建和发布文档，并决定哪个是默认的。
- en: Coveralls
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Coveralls
- en: Once a project has tests, a natural question to ask is, "How much of this code
    is tested?" The answer to this question can be provided through another popular
    service called **Coveralls** ([https://coveralls.io/](https://coveralls.io/)).
    This service displays your test code coverage in a nice web UI and can be connected
    to your repository through its CI configuration.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦项目有了测试，一个自然的问题就是，“这段代码有多少被测试了？”这个问题的答案可以通过另一个流行的服务**Coveralls**([https://coveralls.io/](https://coveralls.io/))来提供。这个服务以友好的Web
    UI显示你的测试代码覆盖率，并且可以通过其CI配置连接到你的仓库。
- en: '![image2.png](img/B17108_03_05.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![image2.png](img/B17108_03_05.png)'
- en: 'Figure 3.5: A Coveralls report about test coverage'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5：关于测试覆盖率的Coveralls报告
- en: Every time you change your project and GitHub Actions triggers a build, it will,
    in turn, cause Coveralls to display an excellent summary of the coverage and how
    it evolves over time, similar to that shown in *Figure 3.5*.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 每次你更改项目并且GitHub Actions触发构建时，它反过来会导致Coveralls显示关于覆盖率及其随时间演变的出色总结，类似于*图3.5*中所示。
- en: Badges
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 徽章
- en: 'Once you start to add services to your project, it is good practice to use
    badges in your project''s README so the community can see at once the status for
    each one of them with links to the service. For example, add this `README.rst`
    file in your repository:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你开始在项目中添加服务，在项目的README中使用徽章是一个好习惯，这样社区可以立即看到每个服务的状态，并通过链接访问服务。例如，在你的仓库中添加这个`README.rst`文件：
- en: '[PRE21]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The preceding file will be displayed as shown in *Figure 3.6* in GitHub on your
    project's landing page, demonstrating three different status badges.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的文件将显示在GitHub上你的项目首页的*图3.6*中，展示了三个不同的状态徽章。
- en: '![image1.png](img/B17108_03_06.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![image1.png](img/B17108_03_06.png)'
- en: 'Figure 3.6: GitHub project status badges'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6：GitHub项目状态徽章
- en: Summary
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have covered the different kinds of tests that can be written
    for your projects. Functional tests are those that you will write more often,
    with `WebTest` being a great tool to use for such a purpose. To run the tests,
    pytest combined with Tox will make your life easier.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了可以为你的项目编写的不同类型的测试。功能测试是你将更频繁编写的测试，`WebTest`是用于此目的的绝佳工具。要运行测试，pytest结合Tox将使你的生活更加轻松。
- en: We also covered some tips on writing good documentation and ensuring that the
    tests are run in an automated way. Last, but not least, if you host your project
    on GitHub, you can set up a whole CI system for free, thanks to GitHub Actions.
    From there, numerous free services can be hooked to complement the tools available,
    like `Coveralls`. You can also automatically build and publish your documentation
    on ReadTheDocs.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还介绍了一些关于编写良好文档和确保测试以自动化方式运行的技巧。最后，但同样重要的是，如果你在GitHub上托管你的项目，你可以免费设置整个CI系统，这要归功于GitHub
    Actions。从那里，你可以连接到许多免费服务来补充可用的工具，如`Coveralls`。你还可以自动在ReadTheDocs上构建和发布你的文档。
- en: 'If you want to look at how everything fits together, the microservice project
    published on GitHub uses GitHub `Actions`, `ReadTheDocs`, and `coveralls.io` to
    do so: [https://github.com/PythonMicroservices/microservice-skeleton/](https://github.com/PythonMicroservices/microservice-skeleton/)'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想看看所有这些是如何结合在一起的，GitHub上发布的微服务项目使用GitHub `Actions`、`ReadTheDocs`和`coveralls.io`来实现这一点：[https://github.com/PythonMicroservices/microservice-skeleton/](https://github.com/PythonMicroservices/microservice-skeleton/)
- en: Now that we've covered how a Quart project can be continuously developed, tested,
    and documented, we can look at how to design a full microservices-based project.
    The next chapter will go through the design of such an application.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了如何持续开发、测试和记录Quart项目，我们可以看看如何设计一个基于微服务的完整项目。下一章将介绍此类应用程序的设计。
