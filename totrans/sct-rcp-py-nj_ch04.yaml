- en: Using Python Collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will look at Python collection objects, which take the
    regular, built-in Python containers (list, tuple, dictionary, and set being the
    most common) and add special functionality for particular situations. We will
    cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing namedtuple
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing deque
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing ChainMap
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing Counters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing OrderedDict
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing defaultdict
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing UserDict
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing UserList
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing UserString
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving Python collections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looking at the collections – extended module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While the base containers do the grunt work of holding data for most programmers,
    there are times when something with a bit more functionality and capability is
    required. Collections are built-in tools that provide specialized alternatives
    to the regular containers. Most of them are just subclasses or wrappers to existing
    containers that can make life easier for a developer, provide new features, or
    just provide more options for a programmer so a developer doesn't have to worry
    about making boilerplate code and can focus on getting the work done.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we get into collections, we will take a little bit of time to review
    the existing containers so we know what is, and is not, provided with them. This
    will allow us to better understand the capabilities and potential limitations
    of collections.
  prefs: []
  type: TYPE_NORMAL
- en: Sequence types include lists, tuples, and ranges, though only lists and tuples
    are relevant here. Sequence types include the `__iter___` function by default,
    so they can naturally iterate over the sequence of objects they contain.
  prefs: []
  type: TYPE_NORMAL
- en: Lists are mutable sequences, that is, they can be modified in-place. They most
    commonly hold homogeneous items, but this is not a requirement. Lists are probably
    the most common container to be used in Python, as it is easy to add new items
    to a list by simply using `<list>.append` to extend the sequence.
  prefs: []
  type: TYPE_NORMAL
- en: Tuples are immutable, meaning they cannot be modified in-place and a new tuple
    must be created if a modification is to occur. They frequently hold heterogeneous
    data, such as capturing multiple return values. Because they cannot be modified,
    they are also useful to use if you want to ensure that a sequential list isn't
    modified by accident.
  prefs: []
  type: TYPE_NORMAL
- en: Dictionaries map values to keys. They are known as hash tables, associated arrays,
    or by other names in different programming languages. Dictionaries are mutable,
    just like lists, so they can be changed in-place without having to create a new
    dictionary. A key feature of dictionaries is that keys must be hashable, that
    is, the hash digest of the object cannot change during its lifetime. Thus, mutable
    objects, such as lists or other dictionaries, cannot be used as keys. However,
    they can be used as values mapped to the keys.
  prefs: []
  type: TYPE_NORMAL
- en: Sets are similar to dictionaries in that they are containers of unordered, hashable
    objects, but they are just values; no keys exist in a set. Sets are used to test
    for membership, removing duplicates from sequences, and a variety of mathematical
    operations.
  prefs: []
  type: TYPE_NORMAL
- en: Sets are mutable objects, while frozensets are immutable. Since sets can be
    modified, they are not suitable for dictionary keys or as elements of another
    set. Frozensets, being unchanging, can be used as dictionary keys or as a set
    element.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sequence objects (lists and tuples) have the following common operations. Note:
    `s` and `t` are sequences of the same type; `n`, `i`, `j`, and `k` are integer
    values, and `x` is an object that meets the restrictions required by `s`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`x in s`: This returns `true` if an item in sequence `s` is equal to `x`; otherwise,
    it returns `false`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x not in s`: This returns true if no item in sequence `s` is equal to `x`;
    otherwise, it returns `false`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`s + t`: This concatenates sequence `s` with sequence `t` (concatenating immutable
    sequences creates a new object)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`s * n`: This adds `s` to itself `n` times (items in the sequence are not copied,
    but referenced multiple times)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`s[i]`: This retrieves the `i^(th)` item in sequence `s`, with count starting
    from 0 (negative numbers start counting from the end of the sequence, rather than
    the beginning)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`s[i:j]`: This retrieves a slice of `s`, from `i` (inclusive) to `j` (exclusive)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`s[i:j:k]`: This retrieves a slice from `s`, from `i` to `j`, skipping `k`
    times'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`len(s)`: This returns the length of `s`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`min(s)`: This returns the smallest item in `s`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`max(s)`: This returns the largest item in `s`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`s.index(x[, i[, j]])`: This indexes the first instance of `x` in `s`; optionally,
    it returns `x` at or after index `i` and (optionally) before index `j`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`s.count(x)`: This returns the total count of `x` instances in `s`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Mutable sequence objects, such as lists, have the following specific operations
    available to them (note: `s` is a mutable sequence, `t` is an iterable object,
    `i` and `j` are integer values, and the `x` object meets any sequence restrictions).'
  prefs: []
  type: TYPE_NORMAL
- en: '`s[i] = x`: This replaces the object at index position `i` with object `x`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`s[i:j] = t`: The slice from `i` (inclusive) to `j` (exclusive) is replaced
    with the contents of object `t`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`del s[i:j]`: This deletes the contents of `s` from indexes `i` to `j`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`s[i:j:k] = t`: This replaces the slice of `i` to `j` (stepping by `k`) by
    object `t` (`t` must have the same length as `s`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`del s[i:j:k]`: This deletes elements of the sequence, as determined by the
    slice indexes and stepping, if present'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`s.append(x)`: This adds `x` to the end of `s`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`s.clear()`: This deletes all elements from the sequence'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`s.copy()`: This is used to shallow copy of `s`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`s.extend(t)`: This extends `s` with the contents of `t` (can also use `s +=
    t`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`s *= n`: This is used to update `s` with its contents repeated `n` times'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`s.insert(i, x)`: This inserts `x` into `s` at position `i`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`s.pop([i])`: This is used to extract an item at index `i` from `s`, returning
    it as a result and removing it from `s` (defaults to removing the last item from
    `s`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`s.remove(x)`: This is used to delete the first item from `s` that matches
    `x` (throws an exception if `x` is not present)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`s.reverse()`: This is used to reverse `s` in-place'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nearly every container in Python has special methods associated with it. While
    the methods described previously are universal for their respective containers,
    some containers have methods that apply just to them.
  prefs: []
  type: TYPE_NORMAL
- en: Lists and tuples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In addition to implementing all common and mutable sequence operations, lists
    and tuples also have the following special method available to them:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sort(*, [reverse=False, key=None])`: This is used to sort a list in-place,
    using the `*<*` comparator. Reverse comparison, that is, high-to-low, can be accomplished
    by using `reverse=True`. The optional `key` argument specifies a function that
    returns the list, as sorted by the function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As an example of how to use the `key` argument, assume you have a list of lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To sort this list, call the `sort()` method on the list, and then print the
    list. Without having a function that combines the two steps, they have to be called
    separately. This is actually a feature, as normally sorted lists are then programatically
    operated on, rather than always printed out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If you wanted a different sorting, such as sorting by the second item in each
    list item, you can pass that as a argument into a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this example, you can see that the sorting isn't by the first item in each
    sublist, but by the second item, that is, it is now `34->43->56->98` instead of
    `1->2->3->6`.
  prefs: []
  type: TYPE_NORMAL
- en: Dictionaries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mappable objects, dictionaries have a number of built-in methods, as they
    cannot use the normal sequence operations (note: `d` represents a dictionary,
    `key` is a particular key for the dictionary, and `value` is the value associated
    with a key):'
  prefs: []
  type: TYPE_NORMAL
- en: '`len(d)`: This returns the number of items in a dictionary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`d[key]`: This return the `value` associated with `key`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`d[key] = value`: This is used to set the mapping of `key` to `value`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`del d[key]`: This deletes the value associated with `key`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`key in d`: If `key` exists in the dictionary, return `True`; otherwise, return
    `False`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`key not in d`: If `key` exists in the dictionary, return `False`; otherwise,
    return `True`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`iter(d)`: This returns an interator object from the dictionary `keys`. To
    actually use the iterated `keys`, you must use a `for` loop.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`clear()`: This removes all items from the dictionary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`copy()`: This returns a shallow copy of the dictionary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fromkeys(seq[, value])`: This creates a new dictionary using the `keys` listed
    in `seq` and sets their `values` to `value`. If no `value` is provided, it defaults
    to `None`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get(key[, default])`: This returns the `value` associated with `key`, if `key`
    exists. Otherwise, the `default` value is returned. If `default` is not set, then
    `None` is returned, that is, no response, but not an error.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`items()`: This returns a `view` object of the `key:value` pairs in the dictionary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`keys()`: This returns a `view` object of just the dictionary keys.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pop(key[, default])`: This is used if `key` exists in the dictionary; remove
    it from the dictionary and return its `value`; otherwise, return `default`. If
    `default` isn''t provided and the `key` doesn''t exist, then an error is raised.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`popitem()`: This removes and returns an arbitrary pair from the dictionary.
    As dictionaries are unsorted, the returned pair is effectively randomly selected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setdefault(key[, default])`: This is used if `key` is present in the dictionary;
    return its `value`. If not present, then make a new `key:value` pair with the
    provided `key` and the `default` value. If `default` isn''t set, it defaults to
    `None`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`update([other])`: This modifies the dictionary by updating it with the pairs
    from `other`. If existing `keys` are present, they will be overwritten. `other`
    can be another dictionary or an iterable object of `key:value` pairs, such as
    a tuple.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`values()`: This returns a `view` object of the dictionaries values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Dictionary `view` objects are actually dynamic objects that show a dictionary''s
    items; when a dictionary changes, the view updates to reflect those changes. `view`
    objects actually have their own methods available to them:'
  prefs: []
  type: TYPE_NORMAL
- en: '`len(dictview)`: This returns the number of items in a dictionary'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`iter(dictview)`*:* This returns an iterator object over the dictionary `keys`*,*
    `values`*,* or `key:value` pairs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x in dictview`: This returns `True` if `x` exists within the `view` object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since sets are similar to dictionaries, they have a number of methods associated
    with them, which apply to both set and frozenset:'
  prefs: []
  type: TYPE_NORMAL
- en: '`len(s)`: This returns the number of items in set `s`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x in s`: This returns `True` if `x` exists in `s`;  otherwise, it is `False`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x not in s`: This returns `False` if `x` exists in `s`; otherwise, it is `True`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isdisjoint(other)`: This returns `True` if the set has no elements in common
    with object `other`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`issubset(other)`: This tests whether all elements in the `set` are also in
    `other`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`issuperset(other)`: This tests whether all elements in `other` are also in
    `set`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`union(*others)`: This returns a new set that includes elements from the original
    `set` and all `other` objects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`intersection(*others)`: This returns a new set that only contains objects
    that are in common between the `set` and all `other` objects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`difference(*others)`: This returns a new set that is only the elements that
    exist in the `set`, but are not in `others`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`symmetric_different(other)`: This returns a new set of elements that are either
    in `set` or `other`, but not both'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`copy()`: This returns a new set with a shallow copy of the set'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are methods only available to set, but not to frozenset:'
  prefs: []
  type: TYPE_NORMAL
- en: '`update(*others)`: This updates the set by adding elements from all `others`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`intersection_update(*others)`: This updates the set by keeping only the elements
    that are in the `set` and `others`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`difference_update(*others)`: This updates the set by keeping only the elements
    found in `others`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`symmetric_difference_update(other)`: This updates the set with only the elements
    found in either `set` or `other`, but not common to both'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`add(elem)`: This adds `elem` to the set'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`remove(elem)`: This deletes `elem` from the set; it throws an exception if `elem`
    is not present'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`discard(elem)`: This deletes `elem` from the set if present'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pop()`: This removes `elem` from the set, if present, and returns its value;
    it throws an exception if the set contains no values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`clear()`: This deletes all elements from the set'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing namedtuple
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using `namedtuple`, a developer can give meaning to each item in a tuple and
    allow the tuple's fields to be accessed by name rather than by index value. This
    allows for more readable and better self-documenting code. Named tuples can be
    used in place of regular tuples with no adverse effects.
  prefs: []
  type: TYPE_NORMAL
- en: Named tuples can be thought of as using dictionary-type `key:value` pairs, except
    in a tuple. It's not a true mapping of key to value, because named tuples are
    simply assigning a name to a sequence index position, that is, name=value, but
    it may help to conceptually think of them as unchanging mapped pairs. Named positions
    can be called by name or by position index.
  prefs: []
  type: TYPE_NORMAL
- en: '`namedtuple` is generated using the following command format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is an explanation of the parts of the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '`typename`: The name of the tuple subclass being created. Subclass instances
    automatically generate `docstrings` incorporating the `typename` and field names,
    as well as creating a `__repr__` method that automatically lists the tuple contents
    in `name=value` format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`field_names`: A sequence (list or tuple) of strings to signify the names of
    the tuple fields, for example, [*X*-axis, *Y*-axis, *Z*-axis]. The field names
    can also be signified using a single string, rather than a sequence object, with
    each field name separated by whitespace or commas, such as *X*-axis, *Y*-axis,
    *Z*-axis. Any legitimate Python name can be used; not allowed names include ones
    that start with numbers or underscores, as well as any Python keywords.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*`: It helps to capture all argument inputs. This is actually no different
    than the more commonly seen `*args`, as the `*` is the item of concern for Python
    when working with arguments; `args` is simply a convention used by programmers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`verbose`: (deprecated) if true, the class definition will be printed after
    it is built. The preferred way to do this nowadays is to print the `_source` attribute.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rename`: If true, invalid field names are automatically replaced with positional
    names. For example, `abc, def, xyz, abc` would automatically become `abc, _1,
    xyz, _3` to replace the redundant `abc` and the Python keyword `def`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`module`: If defined, the `__module__` attribute of the `namedtuple` is set
    to the value provided.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It doesn''t get much better than the official documentation, so here is an
    example from [https://docs.python.org/3/library/collections.html#collections.namedtuple](https://docs.python.org/3/library/collections.html#collections.namedtuple):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Make `namedtuple`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Make a new instance of the `namedtuple`. You can use positional or keyword
    arguments:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The new `namedtuple` can be indexed like a normal tuple:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'It can also be unpacked like a regular tuple:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Tuple objects can be accessed by their assigned names instead of index:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Because `__repr__` is provided automatically, calling the `namedtuple` instance
    provides all information about the `namedtuple`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Another example from the documentation shows how named tuples can be utilized
    with CSV or SQLite. First, create a `namedtuple` (`employee_record_tuple.py`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'For a CSV file, import the `csv` module and then map the imported file data
    to the `namedtuple`. "`rb`" is used because the CSV format is considered a binary
    file type, even though it is human-readable. The method `_make()` is explained
    in the next section (`import_csv.py`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'For SQLite, import the module and create the connection. After the cursor is
    executed to select the fields from the database, they are mapped to the `namedtuple`
    just like the CSV example (`import_sqlite.py`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As seen in the preceding examples, named tuples have special methods and attributes
    available to them, as well as the methods available to normal tuples. The `namedtuple`
    methods and attributes are denoted with an underscore prefix to ensure that they
    don''t conflict with field names, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<namedtuple>._make(iterable)`: A class method that creates a new instance
    from an existing sequence or iterable object:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '`<namedtuple>._asdict()`: It returns an `OrderedDict` object that maps field
    names to corresponding values:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`<namedtupled>._replace(**kwargs)`: It returns an instance of the named tuple
    that replaces specific fields with new values:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`<namedtuple>._source`: This attribute provides a string with the raw Python
    source code that actually creates the `namedtuple` class; this code makes the
    `namedtuple` self-documenting. The string can be printed, executed, saved to a
    file, imported as a module, and so on:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/aacec847-1206-4f3a-9c36-25e898fd5dcc.png)'
  prefs: []
  type: TYPE_IMG
- en: '`<namedtuple>._fields`: It returns a tuple of field names as strings. This
    is useful when needing to create new named tuples from existing named tuples:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the preceding methods and attributes, named tuples have some
    special functionality that can be utilized to maximize their versatility.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a field''s name is a string, `getattr()` can be used to obtain its value:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Dictionaries can be converted to named tuples, due to the `field:value` mapping.
    The double-star operator that unpacks argument lists, that is, `**kwargs`, is
    used to obtain this effect:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'As a normal Python class, named tuples can be subclassed to modify or add functionality.
    Here is an example from the documentation of adding a calculated field and fixed-width
    printing:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0ba20439-f05b-40b4-971e-548f4f8520a9.png)'
  prefs: []
  type: TYPE_IMG
- en: The `@property` decorator is an alternative to getter and setter interfaces.
    While not a detailed walk-through, here is a brief summary for the curious. If
    a module is written from the beginning to use getter and setter methods, there
    isn't an issue with updates. However, if a module incorporated them at a later
    time, any programs written with the module would have to be rewritten to incorporate
    the new features. This is because getter/setter methods retrieve and assign values
    to variables, replacing previous functionality, such as via initialization, or
    to throw exceptions when out-of-bounds values are used.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `@property` decorator means programs implementing the modified module
    don't have to be rewritten; all the changes are internal to the module. Thus,
    backwards compatibility is maintained and users of the module don't have to worry
    about the internals.
  prefs: []
  type: TYPE_NORMAL
- en: 'By directly modifying the `namedtuple __doc__` fields, `docstrings` can be
    customized to reflect the `namedtuple` fields:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, default values can be set via the `_replace()` method:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Implementing deque
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Deques (pronounced *decks*) are list-like containers that have fast appending
    and pop values from either end. The name deque comes from this action: double-ended
    queues. Deques are thread safe, meaning data is manipulated in such a way that
    all threads behave without overwriting data or otherwise operate with unintended
    actions. Popped values from either end of the deque have the same performance,
    regardless of being on the front or the rear of the queue.'
  prefs: []
  type: TYPE_NORMAL
- en: For those familiar with big *O* notation, performance is *O(1)* for both front-
    and rear-popped values. For those unfamiliar with big *O* notation, this just
    means it takes the same amount of time for a deque to pop a value from the front
    as it does for the back. This is significant because lists, which have similar
    operations as the deque, are optimized for quick, fixed-length operations and
    take a performance hit of *O(n)* to memory movement when popping and inserting
    values, as they both modify the size and position of the data structure. *O(n)*
    simply means that the time to completion of a process increases linearly and is
    proportional to the number of input values.
  prefs: []
  type: TYPE_NORMAL
- en: The downside to using deques is that they have slow data access; that is, reading
    data from a deque is functionally slower than reading from a list. Hence, deques
    are ideal when quick data insertion/removal from either end of the deque is necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'The format for using deque is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '`iterable`: A data object that can be iterated through. This iteration is used
    to generate a new deque object that is initialized in a left-to-right manner,
    that is, an empty deque object is filled using `append()` on each iterated object.
    If `iterable` is not specified, an empty deque object is created.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`maxlen`: It specifies how long a deque object can be. If this is not provided,
    or if it is equal to `None`, then the deque can be extended to any length. If
    the max length of a deque is exceeded, then for every item that is added to it,
    an equal quantity is removed from the opposite end. In terms of functionality,
    bounded-length deques operate like the `tail` command in *NIX; they are also used
    for transaction tracking, and monitoring recent data transactions within a pool
    of data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Methods used with deque are similar to lists, but they naturally have their
    own, special methods due to their nature:'
  prefs: []
  type: TYPE_NORMAL
- en: '`append(x)`: It adds value `x` to the end (right-sight) of the deque object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`appendleft(x)`: It adds value `x` to the front (left-sight) of the deque.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`clear()`: It deletes all items from the deque.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`copy()`: It creates a shallow copy of the deque.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`count(x)`: It counts the number of elements in the deque that are equal to
    `x`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`extend(iterable)`: It extends the end of the deque by appending items from
    `iterable`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`extendleft(iterable)`: It extends the front of the deque by appending items
    from `iterable`; this results in the items from `iterable` being reversed within
    the deque.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`index(x[, start[, stop]])`: It returns the position of `x` in the deque; if
    provided, the position will be limited to or after the `start` index and before
    the `stop` position. If found, the first match will be returned; otherwise, an
    error is given.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`insert(i, x)`: It inserts item `x` at position `i`; if the deque is bounded
    and the insertion results in exceeding the max length, an error will occur.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pop()`: It removes and returns an element from the end of the deque. If no
    items are in the deque, an error will occur.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`popleft()`: It removes and returns an element from the front of the deque;
    an error is returned if no items are present.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`remove(value)`: It deletes the first item that matches `value`; if there is
    no match, an error occurs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reverse()`: It reverses the deque in-place.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rotate(n=1)`: It rotates the deque to the right `n` times, moving the end
    element to the front. If `n` is negative, the rotation is to the left.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In addition to the preceding methods, deques can also perform the following
    operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Iteration`: Walk through sequence'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Pickling`: Data serialization'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`len(deque)`: Length assessment'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reversed(deque)`: Reversal object return'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`copy.copy(deque)`: Shallow copy'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`copy.deepcopy(deque)`: Deep copy'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`in`: Membership testing via the `in` operator'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`deque[1]`: Indexed accessing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Index access is fast *[O(1)]* at the end of the deque, but slows to *O(n)* in
    the middle. As mentioned earlier, if fast random access to items in the sequence
    is more important than having the ability to insert/remove from both ends, then
    a list object is the better choice.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s walk through an example from [https://docs.python.org/3/library/collections.html#collections.deque](https://docs.python.org/3/library/collections.html#collections.deque):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import `deque` from the `collections` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `deque` object. In this case, we will give it a string object as an
    argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Simple iteration over the string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Add additional items to the front and rear of the deque:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Show the new `deque` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Pop out the left- and right-most elements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Show the updated `deque` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'See that the deque can be accessed just like a list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Reverse the deque object in-place and create a list from it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Search for an item in the deque:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Add multiple items to the deque at the same time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Rotate the contents of the deque back and forth:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Make a new, reversed `deque` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Delete the contents of the deque and show that operations can no longer be
    performed on it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Add new items to the front of the deque (the result is in reverse order of
    input):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'If a deque object has `maxlength` assigned, it can function like `tail` in
    *NIX operating systems:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a **FIFO** (**first-in, first-out**) container. Input is appended on
    the right side of the `deque` object and output is popped from the left side:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Make a pure Python code version of `del d[n]` (`del` is actually a compiled
    C file when used by Python):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Implementing ChainMap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ChainMap is a dictionary-like class, used to create a single view of multiple
    mappings. It allows for quick linking between multiple mappings so they can all
    be considered as a single unit, which is useful when simulating nested scopes
    and when templating. This can be faster than creating a new dictionary and running
    `update()` calls repeatedly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The command to create a `ChainMap` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: As usual, the `*maps` is simply a number of dictionaries or other map objects
    passed in to be combined into a single, updateable view. If no mappings are passed
    in, then an empty dictionary is created so the new chain has at least one mapping
    available to it.
  prefs: []
  type: TYPE_NORMAL
- en: The mappings themselves are contained, behind the scenes, within a list. The
    list is a public object and it can be accessed or updated via the `maps` attribute.
    When looking for a key, the search occurs over the mapping list until the key
    is found. However, modifications to the list occur only on the first mapping.
  prefs: []
  type: TYPE_NORMAL
- en: To keep memory requirements low, `ChainMap` doesn't make a copy of all the mappings,
    but simply uses the mappings via reference. Thus, if an underlying mapping is
    modified, it is immediately available to the `ChainMap` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'All normal dictionary methods are available, as well as the following special
    `ChainMap` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`maps`: It is referred to earlier; this is a user-accessible list of mappings.
    The list is based on search order, that is, first-searched-to-last-searched. This
    list can be modified to change the mappings that are searched.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`new_child(m=None)`: It returns a new `ChainMap` that has a new map, followed
    by all the maps of the current instance. If a value for `m` is passed in, it becomes
    the first map at the front of the list. If not provided, an empty dictionary is
    used. This method can be used to create subcontexts that can be updated without
    modifying parent mapping values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`parents`: It returns a new `ChainMap` that holds all the maps in the current
    instance except for the first one. This is useful to skip the first map when searching.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`chainmap_import.py` is a basic example of how a `ChainMap` actually operates
    in use. First, `ChainMap` is imported, then two dictionaries are created. A `ChainMap`
    object is created from the two dictionaries. Finally, the key:value pairs from
    the `ChainMap` are printed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a837b3b1-0f8e-4f2f-b707-0dc48552a41d.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice how the ordering of the dictionaries impacts the results that are printed
    if two keys are the same, since the first mapping is the object that will be searched
    through first for the desired key.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following examples come from the Python documentation at [https://docs.python.org/3/library/collections.html#collections.ChainMap](https://docs.python.org/3/library/collections.html#collections.ChainMap).
    `chainmap_builtins.py` simulates how Python looks for references to objects: `locals`
    is searched first, then `globals`, and finally the Python `builtins`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '`chainmap_combined.py` shows how to allow user-specified arguments override
    environment variables which, in turn, override default values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Libraries are imported and default values are applied to a dictionary.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: User input capture is coded using `argparse`, specifically looking for the user
    and color arguments.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A dictionary of command-line arguments are generated from user input.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The command-line arguments, operating system environment values, and default
    values are all combined into a `ChainMap`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the selected color and user are printed to the screen. They would be,
    in order, the specified default values, the OS environment values, or command-line
    input values, depending on whether the environment values exist for color and
    user, or whether the user provided arguments to the Python command.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When ran, this code simply prints the following:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Context managers allow for proper management of resources. For example, `file_open.py` is
    a common method to open a file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding example uses a context manager to read the file and automatically
    closes it when it is no longer in use. `chainmap_nested_context.py` simulates
    nested contexts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: First, the `ChainMap` is created, along with two subclasses (remember, `ChainMap`
    is a class, even though it acts like a dictionary object)
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '`e.maps[0]` basically says: "Get the context of the local scope"'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`e.maps[-1]` goes backwards in the context, that is, up one level in the scope
    tree, and gets the global scope (if you went up another level, you would be at
    the Python `builtins` scope)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`e.parents` acts like the Python `nonlocal` statement, which allows binding
    to variables outside of the local scope, but are not global, that is, binding
    of encapsulated code to the enclosing code'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: After the variables are set, the first dictionary key in the chain is set and
    assigned a value, then deleted
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, all the items in the nested structure are listed (keys), checked, counted,
    and listed (pairs)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the nested child is converted to a regular dictionary
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Since the default action of `ChainMap` is to peruse the entire chain for lookups,
    but to only modify the first mapping listed in the chain, to modify mappings further
    down the chain, a subclass can be made that updates keys beyond the first mapping
    (`deep_chainmap.py`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/05bdae67-403f-4e3a-bfa2-c6be0cec4012.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This class defines two methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`__setitem__()`, accepts a key and value as arguments. Each mapping object
    within the `ChainMap` is checked to see whether the key exists. If so, a value
    is assigned to that particular mapping''s key. If the key doesn''t exist, then
    a new pair is added to the first mapping object.'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__delitem__()`, takes a key as its argument. Again, the mappings are cycled
    through to find a match to the key argument. If a match is found, the item pair
    is removed from the mapping. If no match is found, an error is generated.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing Counters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Counter` collection is another dictionary-like object that counts hashable
    objects. Like dictionaries, Counters are unordered mappings of elements (stored
    as keys) and their respective quantities (stored as values). Value counts are
    stored as integer values, but can be any value, including zero and negative numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Technically, Counter is a subclass of the dictionary class, so it has access
    to all the traditional dictionary methods. In addition, it has the following special
    methods available to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '`elements()`: It returns an iterator object over the key elements, repeating
    each key until its quantity value is reached. Elements are printed in random order
    and, if an element''s count is less than one, it will not be printed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`most_common([n])`: It returns a list of the most common elements and their
    counts from most common to least. If `n` is provided, only that number of elements
    are returned, otherwise all elements are returned.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`subtract([iterable or mapping])`: It subtracts the number elements in the
    provided argument from another iterable or mapping. Both inputs and outputs can
    be less than one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fromkeys(iterable)`: This method, common to normal dictionaries, is not available
    to Counter objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`update([iterable or mapping])`: Elements are added to an existing iterable
    or mapping. When adding to an iterable, just the sequence of elements is expected,
    rather than key:value pairs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is how to create a new `Counter` object, as demonstrated from [https://docs.python.org/3/library/collections.html#collections.Counter](https://docs.python.org/3/library/collections.html#collections.Counter):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The first object is simply an empty counter, much like creating an empty dictionary.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The second `Counter` creates a mapping of a text string, summing the count
    of each unique letter, is as follows:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The third `Counter` object is a direct creation from a dictionary, with the
    quantity of each key provided by the user.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: The final object is similar to the previous, except keyword arguments rather
    than a dictionary mapping.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Interaction with a `Counter` is the same as with dictionaries, except they
    have been optimized to return a value of `0` if an item doesn''t exist within
    the `Counter`, rather than raising an error:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The `del` statement must be used to remove an element from a `Counter`. Simply
    changing its value to zero only changes the value while leaving the element within
    the `Counter`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how to iterate over the `Counter` elements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how to retrieve the most common elements in a `Counter` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how to subtract values from elements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'As noted in the Python documentation ([https://docs.python.org/3/library/collections.html#collections.Counter](https://docs.python.org/3/library/collections.html#collections.Counter)),
    there are a number of common operations when working with Counters, that are listed
    below. Some may be obvious, as Counters are a type of dictionary; others are unique
    to Counters due to their number-centric behavior:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Because Counters are unique dictionaries, there are some math operations available
    to Counters to allow the combining of `Counter` objects into multisets (Counters
    that have counts greater than zero). Some of these are basic arithmetic, while
    others are similar to what *sets* has available.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Addition and subtraction add/subtract the elements of different `Counter` objects.
    Intersection and union return the minimum and maximum elements from their `Counter`
    objects. While signed integers are used as input, any values that would have an
    output value of zero or less are ignored and not returned. If negative values
    or zero are used as inputs, only outputs with positive values are returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'As noted in step 7 earlier, unary shortcuts are available for adding an empty
    `Counter` or subtracting from an empty `Counter`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As evident from zero and negative numbers not being returned, Counters are designed
    for use with positive integers, primarily in terms of maintaining running counts.
    However, this doesn't mean that negative values or other types cannot be used.
  prefs: []
  type: TYPE_NORMAL
- en: As a subclass of the dictionary class, Counters actually do not have any restrictions
    on keys or values. While the values are supposed to be used to represent increasing
    or decreasing counts, any Python object can be stored within a value field. For
    in-place operations, such as incrementing a value, the value type only needs to
    support addition and subtraction. As such, fractions, decimals, and float types
    can be used instead of integers and negative values are supported. This also applies
    to `update()` and `subtract()` methods; negative and zero values can be used as
    inputs or outputs.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing OrderedDict
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like `Counter`, the `OrderedDict` is a dictionary subclass the doesn't randomize
    the order of dictionary items. As items are added to the `OrderedDict`, it remembers
    the order that the keys were inserted and maintains that order. Even if a new
    entry overwrites an existing key, the position within the dictionary doesn't change.
    However, if an entry is deleted, re-inserting it will place it at the end of the
    dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: '`OrderedDict`, being a subclasses of `dict`, inherit all the methods available
    to dictionaries. There are also three special methods available to `OrderedDict`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`popitem(last=True)`: It returns and removes the key:value pair at the end
    of the dictionary. If `last` is not provided or manually set to `True`, then the
    popped value is **LIFO** (**last in, first out**). If `last` is set to `False`,
    then the popped value is FIFO.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`move_to_end(key, last=True)`: It moves the provided key to the end of the
    dictionary. If `last` is set to `True`, then the key moves to the right. If `last`
    is set to `False`, the key is sent to the front. If the key does not exist, an
    error is generated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reversed()`: Since `OrderedDict` objects are in order, they can be manipulated
    like an iterable object; in this case, reverse iteration can be performed on an
    `OrderedDict`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following examples come from [https://docs.python.org/3/library/collections.html#collections.OrderedDict.](https://docs.python.org/3/library/collections.html#collections.OrderedDict) `ordereddict_use.py`,
    below, shows how to use `OrderedDict` to create a sorted dictionary: [](https://docs.python.org/3/library/collections.html#collections.OrderedDict)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: While `d` is a normal dictionary, sorting it in place and then passing it into
    `OrderedDict` creates a dictionary that is not only sorted, like a list, but maintains
    that ordered arrangement when entries are deleted. However, adding new keys puts
    them at the end of the dictionary, thus breaking the sort.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the second argument to `OrderedDict` is a key that is generated by
    a lambda function. Lambda functions are simply anonymous functions: functions
    that don''t require a complete `def` statement to be created. They allow a function
    to operate where a variable or argument could be used, as they return a value
    like a normal function when processed.'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, in the first `OrderedDict`, the key is the value returned when
    the lambda function extracts the key from the dictionary. The second `OrderedDict`
    passes in the value of each dictionary item. The third `OrderedDict` uses a value
    equal to the length of each dictionary key.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows how to use `move_to_end()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: First, an `OrderedDict` object is created, using a short string that is parsed
    to generate the keys for the dictionary.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: The key `b` is moved to the end of the `OrderedDict`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `join()` method is used to convert the list of strings that are the keys
    to a single string, otherwise you would get the following:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The next move takes the key *b* and moves it to the front. The final value is
    joined and printed to verify that the move worked correctly.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ordereddict_stor_keys.py`, below, creates a class that retains the stored
    items in the order of keys that were added last:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: This class has a single method that sets the key:value pair in the dictionary.
    The method is actually recursive; the act of calling itself is what allows the
    *memory* of remembering the order the keys were last inserted.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: If the key argument already exists, the original entry is deleted and the insertion
    point is moved to the end of the dictionary.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ordereddict_counter.py`, below, demonstrates using `OrderedDict` with `Counter`
    so the `Counter` can remember the order the elements are first encountered:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: This class is somewhat unique as it inherits from two parent classes. Some people
    on the internet frown upon multiple inheritance because it can make code management
    difficult. Personally, this author considers whether the project really needs
    multiple inheritance or whether it could be accomplished with something else,
    such a decorator. This is not to say that multiple inheritance doesn't have its
    place, just that there should be a good reason for it.
  prefs:
  - PREF_OL
  - PREF_UL
  type: TYPE_NORMAL
- en: In this case, since we are making a unique class that combines the features
    of `Counter` and `OrderedDict`, there really isn't any other way to generate the
    solution without inheriting from those classes.
  prefs: []
  type: TYPE_NORMAL
- en: Two methods are defined in this class. Both methods use *name mangling* (double
    underscores) to create `private` instance methods without clashing with other
    methods of the same name. Name mangling essentially converts the method name to
    `classname__methodname`, so the underscored method is only associated with a particular
    class.
  prefs:
  - PREF_OL
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__repr__` generates a string representation of the class; otherwise, when
    attempting to print the class directly, all that would be shown would be the memory
    address of the class object. The string that is returned in this method is just
    the class name and the dictionary object.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `__reduce__` method performs two things. [https://docs.python.org/3.6/library/pickle.html#object](https://docs.python.org/3.6/library/pickle.html#object).
    `__reduce__` indicates that the method is used by `pickle` to create a tuple of
    a callable object (in this instance, the class itself) and a tuple of arguments
    for the callable object, that is, the dictionary. In addition, the `copy` protocol
    implements `__reduce__` to ensure copying objects works correctly.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As mentioned in the *pickle* documentation, using `__reduce__` directly in
    a class can lead to errors and higher-level interfaces should be used. `ordereddict_reduce.py`,
    below, is an example of when using it can help, as it actually does play a part
    in copying `OrderedCounter` objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, take away the `__reduce__` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Implementing defaultdict
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another dictionary subclass, `defaultdict` calls a factory function to provide
    missing values; basically, it creates any items that you try to access, but only
    if they don't currently exist. This way, you don't get `KeyError` when trying
    to access a non-existent key.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the standard dictionary methods are available, as well as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`__missing__(key)`: This method is used by the `dict` class `__getitem__()`
    method when the requested key is not found. Whatever key it returns (or an exception
    if no key is present) is passed to `__getitem__()`, which processes it accordingly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assuming the `default_factory` is not `None`, this method calls the factory
    to receive a default value for `key`, which is then placed in the dictionary as
    the `key`, and then returns back to the caller. If the factory value is `None`,
    then an exception is thrown with the `key` as the argument. If the `default_factory`
    raises an exception on its own, then the exception is passed along unaltered.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `__missing__()` method is only used with `__getitem__()`; all other dictionary
    methods are ignored. Thus, the `default_factory` can only be accessed via this
    method.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`default_factory`: While not a method, it is used as an attribute for the `__missing__()`
    method, it is initialized by the first argument to the dictionary constructor,
    if available; defaults to `None` if no argument is provided.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following examples are taken from the Python documentation at [https://docs.python.org/3/library/collections.html#collections.defaultdict](https://docs.python.org/3/library/collections.html#collections.defaultdict):'
  prefs: []
  type: TYPE_NORMAL
- en: 'A list is a common source for `default_factory`, as it makes it easy to group
    a sequence of key:value pairs into a dictionary of lists, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: First, a list of tuples is created. The tuples match a string with an integer.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: A `defaultdict` is created using an empty list as the factory argument.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The list of tuples is iterated through, assigning the tuple key:value pairs
    to the `defaultdict` list's factory.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: When the sorted dictionary is printed, it shows that the `defaultdict` created
    a new key for each new item from the tuple's list. If a key was already present
    in the dictionary, then the tuple's value was added to the key's value as a new
    item in a list via the `append` function. Basically, the tuple's list was shorted
    to a key:value pairing that identified all the values related to a particular
    key.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Another way to perform the previous operation is to use the `dict` class `setdefault()`
    method. However, `setdefault()` can be slower and more complex than using a `defaultdict`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: In this case, an empty dictionary is created (the same tuple's list is used
    in this example).
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, the tuples are split into keys and values. The `setdefault()` method is
    used to assign a key with a blank value to the dictionary, then the value is added
    to the key's empty list (or appended to an existing value).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: While the processing time for `setdefault()` may be very close to `defaultdict`
    for a small script such as this, it can add up for larger projects. In addition,
    using `setdefault()` doesn't look as intuitive as the `defaultdict` code.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the factory is set to an integer, the `defaultdict` can be used for counting:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: In this example, a string is set, followed by a `defaultdict` using an integer
    as the `default_factory`.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, for each character in the string, an incrementer is created to count each
    character as the string is iterated through. As each character is looked at, it
    is checked to see whether it already exists in the dictionary. If not, the factory
    calls the `int()` function to generate a default count equal to zero. Then, as
    the rest of the string is walked through, new values receive a count of zero while
    existing values are incremented.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The final dictionary is sorted and the contents displayed. In this case, the
    quantity of each character in the initial string is printed to the screen.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An alternative to the previous example is to use lambda functions. Because
    `int()` always returns zero, generating an alternate starting value (which could
    be type, not just an integer) can be accomplished with a (functionally) empty
    lambda:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `constant_factory` function accepts a value and then returns
    that value to the caller.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: The `defaultdict` uses `constant_factory` to generate whatever value is passed
    in; in this case, it is a string.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `defaultdict` is updated to pass in key arguments.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The values mapped to the dictionary keys are processed. Since an object is missing
    from the key arguments that were passed in, the lambda function provides it via
    the string that was passed to it.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the `default_factory` is giving the `set` type as an argument, the `defaultdict`
    can be used to create a dictionary of sets:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Here, a list of tuples is created. The `defaultdict` is provided with an empty
    `set` as the factory argument.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: The tuple's list is iterated through, generating the keys and values for the
    dictionary from the tuples. The values are added to the sets associated with the
    keys.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Printing the dictionary items shows how the various, duplicate tuples in the
    list have been combined into two dictionary mappings.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing UserDict
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: UserDict is a wrapper for dictionaries that makes it easier to subclass the
    `dict` class. It has been largely replaced by the ability to subclass `dict` directly,
    but it does make it easier to work with as it allows the underlying dictionary
    to be accessible as an attribute. Its primary use is for backwards-compatibility,
    that is, versions older then Python 2.2, so if you don't need the compatibility,
    it is generally better to just subclass `dict`*.*
  prefs: []
  type: TYPE_NORMAL
- en: 'The only special thing the `UserDict` has beyond the normal dictionary operations
    is a single attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '`data`: A real dictionary to hold the contents of the `UserDict` class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a `UserDict` is created, it accepts an optional argument of the initial
    data it is to hold; this initial data is accessible by the `data` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`UserDict` is very simple to use. Create an instance of a `UserDict` and provide
    a mapping to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'If you call the instance directly, it functions just like a normal dictionary,
    as expected:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/146b2128-a9c5-48ad-8716-68f07a0ed4b4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you use the `data` attribute, you get the same results with the `UserDict`
    instance. However, because normal dictionaries don''t support this attribute,
    you get an error, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'To get to the items in the dictionary, you have to either iterate over them
    or call `items()`. While the `UserDict` instance supports the same methods, the
    view returned by `items()` is noticeably different:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the dictionary object returns a tuple of key/values. The `UserDict`
    returns an actual dictionary object. Depending on what you are doing, this difference
    can be important, as is the ability to use the `data` attribute to access the
    dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing UserList
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This wrapper is similar to `UserDict`, except it applies to lists rather than
    dictionaries. Its main use is for creating a base class for list-like subclasses
    that allow for inheritance and method overriding or new methods. This allows for
    new functionality within lists.
  prefs: []
  type: TYPE_NORMAL
- en: Again, like `UserDict`, `UserList` has been largely superseded by the ability
    to subclass directly from `list`. But, again, it may be easier to use `UserList`
    than a `list` subclass. While `UserList` has the methods and capabilities of normal
    lists, it adds the `data` attribute to hold the underlying `list` object contents.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`userlist_import.py` shows how to use `UserList` as a superclass for a new
    list-like object. In this case, we are going to create a class that allows a list
    to be added by simply assigning values to it, rather than having to call the `append()`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ed9c0077-7bed-4eb7-9b0f-a1462b42064d.png)'
  prefs: []
  type: TYPE_IMG
- en: First, in *line 11*, `UserList` must be imported from the *collections* module.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, the `ExtendList` class is created in *line 12* as a subclass of `UserList`.
    This provides list functionality to any `ExtendList` instance. A setter method
    is created, accepting an integer and a value. If the integer provided equals the
    length of the list, then the value argument is appended to the list. Otherwise,
    the value at index `i` is replaced with a new value.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: An instance of the class is created in *line 13* and populated with a range
    of numbers in *line 14*.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Printing the instance (*line 15*) shows that the range of numbers was accepted
    via assignment, rather than using `append()`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Manually extending the list (*line 16*) is allowed by simply assigning a value
    to the given index position.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Replacing a value of a given index position is available as well, as shown in
    *line 18*.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, *line 20* shows that, like a normal list, if attempting to access an
    index value outside the existing range of the list, an error is received.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When subclassing `UserList`, the subclass is expected to provide a constructor
    that can be called with either no arguments or one argument. If a list operation
    is expected to return a new sequence, it attempts to create an instance of the
    actual implementation class. Thus, it expects the constructor to provide the ability
    to be called with a single parameter, that is, the sequence object that serves
    as the source of data.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to create a class that doesn't follow this requirement, but all
    the special methods of the derived class must be overridden, as functionality
    using the default methods cannot be guaranteed.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing UserString
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just like `UserDict` and `UserList`, `UserString` is a string wrapper that allows
    easier subclassing of strings due to providing the underlying string as an attribute.
    The preferred way to do this is to subclass `string` directly; this class is provided
    mainly due to backwards-compatibility or simple cases where subclassing `string`
    is overkill for functionality.
  prefs: []
  type: TYPE_NORMAL
- en: While all string methods are available, such as `UserDict` and `UserList`, `UserString`
    adds the `data` attribute for easy access to the underlying string object. The
    contents of `UserString` are initially set to a copy of some type of sequence;
    the sequence can be bytes, a string, another `UserString` or subclass, or any
    other sequence object that can be converted to a string.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`userstring_import.py` is simple in that it shows how to create a method to
    append a sequence to a string, much like adding more items to a list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: The first step, as always, is to import the `UserString` class from the `collections`
    module.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, a simple subclass of `AppendString` is created. The only method for it
    is `append()`, which takes a single sequence as its argument and returns the instance
    data concatenated with whatever sequence has been provided.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: An instance of the `AppendString` class is created, with a simple string passed
    in as its argument.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The class's method is tested by adding another string, and the final contents
    of the instance is printed. The printed string shows that the new string has been
    added to the end of the original argument.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we demonstrate that regular strings don't have the ability to concatenate
    strings using an `append()` method. A string is created and then a separate string
    is attempted to be appended to it. As the `str` class doesn't have an `append()`
    method, an error is generated.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving Python collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section is designed to showcase different ways to improve your coding methodology
    by using the various Python collections available to you. Not every collections
    datatype is represented, but some interesting use cases are explored for certain
    containers.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following examples are separated by the particular collection they utilize.
    iPython will be used to interactively create these examples.
  prefs: []
  type: TYPE_NORMAL
- en: Default dictionaries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this example (`book_catalog.py`), we will create a simplified ordering
    scheme for book categories; the `default_factory` will be an anonymous function
    that returns a string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a1277e87-dbec-41c1-90d1-a16a8468525d.png)'
  prefs: []
  type: TYPE_IMG
- en: The *line 1* simply imports the `collections` module, allowing access to the
    `defaultdict` class.
  prefs:
  - PREF_OL
  - PREF_UL
  type: TYPE_NORMAL
- en: The *line 2* creates an instance of `defaultdict`. The argument for the factory
    is a simple string indicating that the selected item doesn't exist.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The *lines 3* – *line 6* create items for the dictionary.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The *line 7* prints the default representation of the dictionary.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The *line 8* is a more human-readable representation of the dictionary. This
    just makes it easier to see the key:value mappings.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The *line 9* calls for a non-existent entry. Since it hasn't been added to the
    dictionary yet, a response is provided indicating that it is not available.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The *line 10* is another printing of the mappings in the dictionary. However,
    in this instance, it shows that the key `z` has been added to the dictionary,
    with the default value ascribed to it.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A common programming requirement is to group list elements based on particular
    criteria. One approach is to create a dictionary that is indexed by the criteria.
    For example, a class is created that gets a person''s age and returns a string
    representation (`class_adult.py`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: This creates the class `Adult`. Two methods are defined; `__init__()` simply
    populates the `age` variable when an instance is created. The `__repr__()` allows
    us to print a string representation of the value contained in the `age` variable
    without having the instance print its memory address instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'To populate instances for this class, we will assign ages manually in `adult_list_comp.py`,
    as we want to see how to group the same values together:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: In this case, a list comprehension is used to easily and quickly create all
    the instances of the `Adult` class, rather than setting up a `for` loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to group these individuals by age is by iterating through the instances,
    populating a dictionary, and then grouping them via lists, as shown below in `age_groups.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/56ae5955-c2c0-4dd7-9c64-6667efb3adbf.png)'
  prefs: []
  type: TYPE_IMG
- en: In *line 3* creates an empty dictionary.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: In *line 4* is a `for` loop that iterates through all the instances of `Adult`
    in the `persons` list. For each instance, the variable `age` is set to the instance's
    `age` value. If that value is already present in the dictionary, then a new item
    is appended to the list within the dictionary. If the age value isn't already
    in the dictionary, then a new entry is created.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In *line 5* shows the different age groups within the dictionary. In this case,
    out of ten entries, only seven groups have been created.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In *line 6* prints all the key:value pairs in the dictionary; this shows us
    greater detail of how the dictionary is generated. Looking closely, we can see
    that each unique age in the `persons` list has its own key. The values associated
    with each key are all individual values in `persons` that match the key. In other
    words, all duplicate values are placed in the same group.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In *line 7* is an alternative way to show the dictionary items. This makes it
    easier to see how the duplicate entries are actually tied to their respective
    keys.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An alternative way to do this, and a much cleaner way, is to use a `defaultdict`,
    as follows in `defaultdict_age_groups.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: The *line 8* imports `defaultdict` from the `collections` module.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: The *line 9* creates a `defaultdict` instance that accepts an empty list that
    will create values for the dictionary if a key is missing. Thus, each new key
    will have a list automatically generated for it.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The *line 10* is a simplified version of line 4, eliminating a lot of the busy
    work code.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The *line 11* is another printing of the dictionary, showing that the same results
    are achieved using a `defaultdict` rather than the more brute-force approach previously.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Named tuples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`namedtuples_sales.py`, below, will create a restaurant receipt, indicating
    the store ID, sales date, amount, and number of guests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b148cd53-e90a-4063-ac7b-559d336720f8.png)'
  prefs: []
  type: TYPE_IMG
- en: The *line 9* shows the creation of the named tuple. The first argument to the
    named tuple is the name of the tuple subclass. The remaining arguments are the
    fields for the tuple.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: The *lines 10* and 11 create two different restaurants, showing receipts for
    the same day.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The *line 12* and *line 13* show how to access the individual fields within
    the different tuples using the field names rather than the indexes.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The *line 14* shows that these restaurant instances are, indeed, actual tuples.
    They can be iterated over like regular sequences, using an integer to identify
    each field's index.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'One usual way to create named tuples without having to create each one individually
    is to simply convert an iterable object to a `namedtuple` using `_make`. The input
    iterable can be a list, tuple, or dictionary. In `receipts_make.py`, we take a
    list, with values that meet the requirements for the `namedtuple` fields, and
    convert it directly to a named tuple:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: The *line 18* creates the list used for the conversion.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: The *line 19* uses the `_make` method to convert the list to a `namedtuple`
    object.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The *line 20* prints out the new `namedtuple` instance, showing that the data
    in the converted `namedtuple` is no different than making the `namedtuple` manually.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you just want to see what the field names are in a named tuple object, you
    can use the `_fields` identifier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: The final example shows how named tuples can be used when working with CSV files,
    allowing data access via names rather than indexes. This way, the data is easier
    to work with, as there is meaning ascribed to each field, rather than trying to
    figure out which index value applies to the desired field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Of course, you have to have a CSV file available to use this example. `sales_csv.py`
    shows that the structure is easy, as all you have to have are four entries per
    line, signifying the store ID, the sales date, the sales amount, and the total
    number of guests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: In *line 22*, we import the `reader` method from the `csv` module.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: The *line 23* shows one way to import the CSV file. The traditional *with open...*
    methodology is used to ensure that the file is automatically closed when it is
    no longer being used.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Each field in the CSV file is read into a variable, which is then iterated over.
    The CSV fields are converted to a named tuple via the `_make` method.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the total amount of sales for all the entries in the CSV file are summed
    and put into a variable. Note that the values are cast to a `float` prior to being
    summed, to ensure no errors are generated due to mismatching types.
  prefs: []
  type: TYPE_NORMAL
- en: In *line 24*, the total sales are printed out, showing that the records in the
    CSV file were properly retrieved and converted.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: Ordered dictionaries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ordered dictionaries are an ideal tool for ranking problems, such as student
    grades or competitions. The following example looks at student grades, where the
    dictionary contains a key equal to the student''s name and its value is a test
    grade. The problem is to sort the students by test score, as shown in `student_grades.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: We create a blank dictionary in *line 30* and then populate it with the items
    in *lines 31* – *line 35*.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: The *line 36* is just a print out of the normal, randomized dictionary item
    ordering.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In *line 37*, a traditional sort is performed, that is, sorting the entries
    based on key. Since the keys are strings, they are sorted alphabetically.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An alternate sorting is performed in *line 38*: sort by value. In this case,
    the sorting is from lowest value to highest value.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: To get a sorting of grades from highest to lowest, we use an inverted sorting-by-value
    in *line 39*.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In *line 40*, we take the inverted sorting from *line 39* and use it to populate
    an `OrderedDict`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Printing out the `OrderedDict` instance in *line 41* shows that the dictionary
    has maintained the ordering of input values, rather than randomizing them, like
    in *line 36*.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Looking at the collections – extended module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you search PyPI, you will find the collections-extended module ([https://pypi.python.org/pypi/collections-extended/1.0.0](https://pypi.python.org/pypi/collections-extended/1.0.0)).
    Collections-extended expands the number of collections types available.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following classes are included:'
  prefs: []
  type: TYPE_NORMAL
- en: '`bag`: It is equivalent to a multiset, bags build upon the default *set* container
    by allowing multiple instances of the bag''s elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `bag` (also called a multiset in other languages) generalizes the concept
    of a set so that it allows multiple instances of elements. For example, *{a, a,
    b}*, and *{a, b}* are different bags, but part of the same set. Only hashable
    elements can be used in a `bag`. An important point about bags is the multiplicity
    of elements. Multiplicity is the the number of instances of an element in a specific
    bag, that is, how many duplicate values exist in a bag.
  prefs: []
  type: TYPE_NORMAL
- en: '`setlist`: This creates an ordered, indexed collection with unique elements.
    `setlist` is used to create an object that is similar to an *ordered set*, except
    that its elements are accessible by index, not just a linked set. Two classes
    of `setlist` are provided: `setlist` and `frozensetlist`. Comparing two `setlist`
    object won''t work; while equality testing is fine, other comparisons (such as
    s1 > s2) won''t work as there is no way to specify whether to compare by order
    or by set comparison.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bijection`: It is a function that maps keys to unique values onto functions. A
    `bijection` is a function between two sets, where each element in one set is paired
    to exactly one element in the other set and vice versa. All elements are paired
    and no elements are unpaired. An easy way to picture this assigned seating: each
    individual has a single seat, each seat has a person assigned, no person is assigned
    to more than one seat, and no seat has more than one person sitting in it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RangeMap`: This maps ranges to values. A `RangeMap` maps ranges to values;
    in other words, ranges become keys that are mapped to values. All keys must be
    hashable and comparable to other keys, but don''t have to be the same type. When
    creating a `RangeMap` instance, a mapping can be provided, or the instance can
    start out empty. Each item is assumed to be the start of a range and its associated
    value. The end of the range is the next largest key in the mapping, so if a range
    is left open-ended, it will automatically be closed if a larger range starting
    value is provided.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition to the preceding classes, hashable versions of bags and setlists
    are also included.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Collections-extended is available for installation from PyPI using `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Normal usage is like other modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will talk about each collection class separately in the following examples.
    These examples are from [http://collections-extended.lenzm.net.](http://collections-extended.lenzm.net)
  prefs: []
  type: TYPE_NORMAL
- en: setlist
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`ext_collections_setlist.py` demonstrates how to use `setlist`*:*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: First, `setlist` has to be imported. We also import the `string` class to provide
    access to its public module variables.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: A `setlist` instance is created, using the `string` class `ascii_lowercase`
    variable, which provides a string of all ASCII characters in lowercase.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The instance is printed, just to demonstrate what it contains.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Several indexing operations are shown, demonstrating that `setlist` works like
    a list in terms of accessing items by index. Note that *reverse indexing* is available,
    that is, rather than accessing a variable via its index position, searching for
    a value returns its index position.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: bags
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Bags can be compared to sets, including other bags. Following, we see how bags
    are evaluated compared to sets:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: First, comparison shows that an empty bag is equal to an empty set.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, the same, single element in both shows that they are still comparatively
    equal.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a new element to a bag upsets the balance with a single-element set,
    as expected. The same thing happens when an extra element is added to the set
    and compared to a single-element bag.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A bag with duplicate elements (multiplicity = 2) is not equal to a set with
    a single element, even if it is the same value.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Jumping ahead, a bag with two different elements cannot be adequately compared
    to a set with different elements. While testing for equality is expected to fail,
    both greater than and less than comparisons fail as well.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing bags against each other may prove successful, depending on the comparisons.
    A single-element bag is obviously equal to itself, and is less than a bag with
    the element multiplicity `> 1`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Conversely, multiplicity `> 1` will not be less than or equal to a multiplicity
    of 1.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Bags are roughly related to `Counter` collections, but provide different functionality.
    `ext_collections_bag_compare.py` shows how bags and Counters deal with adding
    and removing elements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: A `Counter` instance is created and populated with an element.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: When the element is removed via subtraction, it is still active in memory, as
    it hasn't actually been deleted from the `Counter` (to actually remove a `Counter`
    element, the `del` function must be used).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: When a bag instance is created and an element added to it, the existence of
    the element is evident. However, when the `remove()` function is used on a bag
    element, that element is, in fact, removed.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following example demonstrates how Counters and bags deal with object length
    as elements are added, removed, and duplicated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: A `Counter` instance is created and populated.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: With only one element added, the length of the instance is 1.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: When the element is subtracted from the `Counter`, the length is still 1, as
    the element hasn't actually been removed from the `Counter`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding multiple copies of an element to the `Counter` doesn't extend the length.
    The `Counter` simply tracks how many elements of the same value have been added,
    but doesn't append those values to its actual length.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding and removing elements to a bag, regardless of whether they are duplicates,
    actually affects the length of the bag object.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When iterating, bags again behave differently to Counters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: While a `Counter` prints only the element it contains (as the element is a key,
    with its value equal to the quantity of that key), a bag actually has all the
    elements contained in it, so it will print each and every element.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Several new methods are provided for bags:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`num_unique_elements`: It returns the number of unique elements in the bag.'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unique_elements()`: It returns a set of all the unique elements in the bag.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nlargest(n=None)`: It returns the `n` most common elements and their quantities,
    from most common to least common. If `n` is not provided, then all elements are
    returned.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`copy()`: It returns a shallow copy of the bag.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isdisjoint(other: Iterable)`: It tests whether the bag is disjoint with the
    provided `Iterable`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`from_mapping(map: Mapping)`: A class method to create a bag from the provided `Mapping`;
    maps the elements to counts.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: RangeMap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Below, we create an empty `RangeMap` and then manually populate it with the
    date ranges of US presidents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '`RangeMap` is imported from the `collections-extended` module, `date` is imported
    from `datetime`, and a new `RangeMap` instance is created.'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: A date range is provided as the key to two US presidents, while an open ended
    range is given to a third.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Like a dictionary, providing the appropriate key to the `RangeMap` instance
    returns its value.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If a range is entered that overlaps a previous entry, the new entry becomes
    the end of the overlapped range key and starts a new open-ended range. Thus, the
    `Someone New` value is ascribed to the year 2021, rather than `Barack Obama`,
    which was the value to the previous open-ended range.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Bijection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Bijective functions are commonly found in a variety of mathematical areas,
    such as in the definitions of isomorphism, homeomorphism, diffeomorphism, permutation
    group, and projective maps. The following example only demonstrates how a `bijection`
    object is created and checked, but doesn''t go into extensive detail on implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: As usual, the class is imported from the module and an instance is created.
    The instance argument is a simple dictionary, mapping a string to an integer.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `inverse` function, the key to a value is printed. Providing the key,
    like a normal dictionary, displays its corresponding value.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A truth test shows that the instance is equal to an abbreviated version of that
    instance. Note that this isn't comparing whether the two bijection instances have
    the exact same mappings, just that they do, indeed, map a single key to a single
    value.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
