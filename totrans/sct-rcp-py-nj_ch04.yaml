- en: Using Python Collections
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python集合
- en: 'In this chapter, we will look at Python collection objects, which take the
    regular, built-in Python containers (list, tuple, dictionary, and set being the
    most common) and add special functionality for particular situations. We will
    cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨Python集合对象，它们在常规的内置Python容器（列表、元组、字典和集合是最常见的）的基础上增加了特定情况下的特殊功能。我们将涵盖：
- en: Reviewing containers
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器回顾
- en: Implementing namedtuple
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现namedtuple
- en: Implementing deque
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现deque
- en: Implementing ChainMap
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现ChainMap
- en: Implementing Counters
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现Counters
- en: Implementing OrderedDict
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现OrderedDict
- en: Implementing defaultdict
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现defaultdict
- en: Implementing UserDict
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现UserDict
- en: Implementing UserList
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现UserList
- en: Implementing UserString
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现UserString
- en: Improving Python collections
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改进Python集合
- en: Looking at the collections – extended module
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看collections扩展模块
- en: Introduction
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: While the base containers do the grunt work of holding data for most programmers,
    there are times when something with a bit more functionality and capability is
    required. Collections are built-in tools that provide specialized alternatives
    to the regular containers. Most of them are just subclasses or wrappers to existing
    containers that can make life easier for a developer, provide new features, or
    just provide more options for a programmer so a developer doesn't have to worry
    about making boilerplate code and can focus on getting the work done.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然基础容器对大多数程序员来说已经足够处理数据存储的工作，但有时需要一些功能更强大、能力更全面的工具。集合是内置工具，它们提供了对常规容器的专业替代方案。大多数集合只是现有容器的子类或包装器，可以使开发者的生活更轻松，提供新功能，或者只为程序员提供更多选择，这样开发者就不必担心编写样板代码，可以专注于完成工作。
- en: Reviewing containers
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器回顾
- en: Before we get into collections, we will take a little bit of time to review
    the existing containers so we know what is, and is not, provided with them. This
    will allow us to better understand the capabilities and potential limitations
    of collections.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入研究集合之前，我们将花一点时间回顾现有的容器，以便我们知道它们提供了什么，没有提供什么。这将使我们更好地理解集合的功能和潜在限制。
- en: Sequence types include lists, tuples, and ranges, though only lists and tuples
    are relevant here. Sequence types include the `__iter___` function by default,
    so they can naturally iterate over the sequence of objects they contain.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 序列类型包括列表、元组和范围，尽管在这里只有列表和元组是相关的。序列类型默认包含`__iter___`函数，因此它们可以自然地遍历它们包含的对象序列。
- en: Lists are mutable sequences, that is, they can be modified in-place. They most
    commonly hold homogeneous items, but this is not a requirement. Lists are probably
    the most common container to be used in Python, as it is easy to add new items
    to a list by simply using `<list>.append` to extend the sequence.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 列表是可变序列，也就是说，它们可以在原地修改。它们最常持有同质项，但这不是必需的。列表可能是Python中最常用的容器，因为它很容易通过使用`<list>.append`来扩展序列添加新项目。
- en: Tuples are immutable, meaning they cannot be modified in-place and a new tuple
    must be created if a modification is to occur. They frequently hold heterogeneous
    data, such as capturing multiple return values. Because they cannot be modified,
    they are also useful to use if you want to ensure that a sequential list isn't
    modified by accident.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 元组是不可变的，这意味着它们不能在原地修改，如果需要修改，必须创建一个新的元组。它们经常持有异质数据，例如捕获多个返回值。由于它们不能修改，因此如果想要确保一个顺序列表不会意外修改，它们也是很有用的。
- en: Dictionaries map values to keys. They are known as hash tables, associated arrays,
    or by other names in different programming languages. Dictionaries are mutable,
    just like lists, so they can be changed in-place without having to create a new
    dictionary. A key feature of dictionaries is that keys must be hashable, that
    is, the hash digest of the object cannot change during its lifetime. Thus, mutable
    objects, such as lists or other dictionaries, cannot be used as keys. However,
    they can be used as values mapped to the keys.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 字典将值映射到键。它们被称为哈希表、关联数组或在不同的编程语言中有其他名称。字典是可变的，就像列表一样，因此可以在原地更改而不必创建一个新的字典。字典的一个关键特性是键必须是可哈希的，也就是说，对象的哈希摘要在其生命周期内不能改变。因此，可变对象，如列表或其他字典，不能用作键。然而，它们可以用作映射到键的值。
- en: Sets are similar to dictionaries in that they are containers of unordered, hashable
    objects, but they are just values; no keys exist in a set. Sets are used to test
    for membership, removing duplicates from sequences, and a variety of mathematical
    operations.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 集合类似于字典，因为它们是无序、可哈希对象的容器，但它们只是值；集合中不存在键。集合用于测试成员资格、从序列中删除重复项以及执行各种数学运算。
- en: Sets are mutable objects, while frozensets are immutable. Since sets can be
    modified, they are not suitable for dictionary keys or as elements of another
    set. Frozensets, being unchanging, can be used as dictionary keys or as a set
    element.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 集合是可变对象，而frozensets是不可变的。由于集合可以修改，因此它们不适合用作字典键或另一个集合的元素。frozensets是不可变的，因此可以用作字典键或集合元素。
- en: How to do it...
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Sequence objects (lists and tuples) have the following common operations. Note:
    `s` and `t` are sequences of the same type; `n`, `i`, `j`, and `k` are integer
    values, and `x` is an object that meets the restrictions required by `s`:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 序列对象（列表和元组）有以下共同操作。注意：`s`和`t`是相同类型的序列；`n`、`i`、`j`和`k`是整数值，`x`是满足`s`要求的限制条件的对象：
- en: '`x in s`: This returns `true` if an item in sequence `s` is equal to `x`; otherwise,
    it returns `false`'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x in s`: 如果序列`s`中的项等于`x`，则返回`true`；否则，返回`false`'
- en: '`x not in s`: This returns true if no item in sequence `s` is equal to `x`;
    otherwise, it returns `false`'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x not in s`: 如果序列`s`中没有项等于`x`，则返回`true`；否则，返回`false`'
- en: '`s + t`: This concatenates sequence `s` with sequence `t` (concatenating immutable
    sequences creates a new object)'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s + t`: 这将序列`s`与序列`t`连接（连接不可变序列会创建一个新对象）'
- en: '`s * n`: This adds `s` to itself `n` times (items in the sequence are not copied,
    but referenced multiple times)'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s * n`: 这将`s`添加到自身`n`次（序列中的项不会被复制，而是被多次引用）'
- en: '`s[i]`: This retrieves the `i^(th)` item in sequence `s`, with count starting
    from 0 (negative numbers start counting from the end of the sequence, rather than
    the beginning)'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s[i]`: 这检索序列`s`中的第`i`项，计数从0开始（负数从序列的末尾开始计数，而不是从开始）'
- en: '`s[i:j]`: This retrieves a slice of `s`, from `i` (inclusive) to `j` (exclusive)'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s[i:j]`: 这检索`s`的切片，从`i`（包含）到`j`（不包含）'
- en: '`s[i:j:k]`: This retrieves a slice from `s`, from `i` to `j`, skipping `k`
    times'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s[i:j:k]`: 这从`s`中检索一个切片，从`i`到`j`，跳过`k`次'
- en: '`len(s)`: This returns the length of `s`'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`len(s)`: 这返回`s`的长度'
- en: '`min(s)`: This returns the smallest item in `s`'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`min(s)`: 这返回`s`中的最小项'
- en: '`max(s)`: This returns the largest item in `s`'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`max(s)`: 这返回`s`中的最大项'
- en: '`s.index(x[, i[, j]])`: This indexes the first instance of `x` in `s`; optionally,
    it returns `x` at or after index `i` and (optionally) before index `j`'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s.index(x[, i[, j]])`: 这在`s`中索引`x`的第一个实例；可选地，它返回从索引`i`开始（可选地）并在索引`j`之前（可选地）的`x`'
- en: '`s.count(x)`: This returns the total count of `x` instances in `s`'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s.count(x)`: 这返回`s`中`x`实例的总数'
- en: 'Mutable sequence objects, such as lists, have the following specific operations
    available to them (note: `s` is a mutable sequence, `t` is an iterable object,
    `i` and `j` are integer values, and the `x` object meets any sequence restrictions).'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 可变序列对象（如列表）有以下特定操作可用（注意：`s`是可变序列，`t`是可迭代对象，`i`和`j`是整数值，`x`对象满足任何序列限制）：
- en: '`s[i] = x`: This replaces the object at index position `i` with object `x`'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s[i] = x`: 这用对象`x`替换索引位置`i`的对象'
- en: '`s[i:j] = t`: The slice from `i` (inclusive) to `j` (exclusive) is replaced
    with the contents of object `t`'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s[i:j] = t`: 从`i`（包含）到`j`（不包含）的切片被对象`t`的内容替换'
- en: '`del s[i:j]`: This deletes the contents of `s` from indexes `i` to `j`'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`del s[i:j]`: 这删除`s`从索引`i`到`j`的内容'
- en: '`s[i:j:k] = t`: This replaces the slice of `i` to `j` (stepping by `k`) by
    object `t` (`t` must have the same length as `s`)'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s[i:j:k] = t`: 这通过对象`t`（`t`必须与`s`具有相同的长度）替换从`i`到`j`（步长为`k`）的切片'
- en: '`del s[i:j:k]`: This deletes elements of the sequence, as determined by the
    slice indexes and stepping, if present'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`del s[i:j:k]`: 如果存在，根据切片索引和步长删除序列的元素'
- en: '`s.append(x)`: This adds `x` to the end of `s`'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s.append(x)`: 这将`x`添加到`s`的末尾'
- en: '`s.clear()`: This deletes all elements from the sequence'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s.clear()`: 这从序列中删除所有元素'
- en: '`s.copy()`: This is used to shallow copy of `s`'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s.copy()`: 这用于`s`的浅拷贝'
- en: '`s.extend(t)`: This extends `s` with the contents of `t` (can also use `s +=
    t`)'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s.extend(t)`: 这使用`t`的内容扩展`s`（也可以使用`s += t`）'
- en: '`s *= n`: This is used to update `s` with its contents repeated `n` times'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s *= n`: 这用于将`s`的内容重复`n`次更新到`s`'
- en: '`s.insert(i, x)`: This inserts `x` into `s` at position `i`'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s.insert(i, x)`: 这在`s`的`i`位置插入`x`'
- en: '`s.pop([i])`: This is used to extract an item at index `i` from `s`, returning
    it as a result and removing it from `s` (defaults to removing the last item from
    `s`)'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s.pop([i])`: 这用于从`s`中提取索引为`i`的项，作为结果返回，并从`s`中删除它（默认为从`s`中删除最后一个项）'
- en: '`s.remove(x)`: This is used to delete the first item from `s` that matches
    `x` (throws an exception if `x` is not present)'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s.remove(x)`: 这用于从`s`中删除第一个匹配`x`的项（如果`x`不存在，则抛出异常）'
- en: '`s.reverse()`: This is used to reverse `s` in-place'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s.reverse()`: 这用于就地反转`s`'
- en: There's more...
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Nearly every container in Python has special methods associated with it. While
    the methods described previously are universal for their respective containers,
    some containers have methods that apply just to them.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎Python中的每个容器都与特殊方法相关联。虽然之前描述的方法适用于各自的容器，但某些容器有仅适用于它们的方法。
- en: Lists and tuples
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表和元组
- en: 'In addition to implementing all common and mutable sequence operations, lists
    and tuples also have the following special method available to them:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 除了实现所有常见的可变序列操作外，列表和元组还具有以下特殊方法可供使用：
- en: '`sort(*, [reverse=False, key=None])`: This is used to sort a list in-place,
    using the `*<*` comparator. Reverse comparison, that is, high-to-low, can be accomplished
    by using `reverse=True`. The optional `key` argument specifies a function that
    returns the list, as sorted by the function.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sort(*, [reverse=False, key=None])`: 这用于就地排序列表，使用`*<*`比较器。通过使用`reverse=True`可以实现反向比较，即从高到低。可选的`key`参数指定一个函数，该函数返回按函数排序的列表。'
- en: 'As an example of how to use the `key` argument, assume you have a list of lists:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 作为使用`key`参数的示例，假设你有一个列表的列表：
- en: '[PRE0]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To sort this list, call the `sort()` method on the list, and then print the
    list. Without having a function that combines the two steps, they have to be called
    separately. This is actually a feature, as normally sorted lists are then programatically
    operated on, rather than always printed out:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要对列表进行排序，请在列表上调用`sort()`方法，然后打印列表。如果没有将两个步骤合并成一个函数，它们必须单独调用。这实际上是一个特性，因为通常排序后的列表会被程序操作，而不是总是打印出来：
- en: '[PRE1]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If you wanted a different sorting, such as sorting by the second item in each
    list item, you can pass that as a argument into a function:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要不同的排序，例如按每个列表项的第二个项目排序，可以将该参数作为函数的参数传递：
- en: '[PRE2]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this example, you can see that the sorting isn't by the first item in each
    sublist, but by the second item, that is, it is now `34->43->56->98` instead of
    `1->2->3->6`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你可以看到排序不是按每个子列表中的第一个项目进行的，而是按第二个项目进行的，即现在是`34->43->56->98`而不是`1->2->3->6`。
- en: Dictionaries
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字典
- en: 'As mappable objects, dictionaries have a number of built-in methods, as they
    cannot use the normal sequence operations (note: `d` represents a dictionary,
    `key` is a particular key for the dictionary, and `value` is the value associated
    with a key):'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 作为可映射对象，字典有许多内置方法，因为它们不能使用正常的序列操作（注意：`d`代表一个字典，`key`是字典的特定键，`value`是与键关联的值）：
- en: '`len(d)`: This returns the number of items in a dictionary.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`len(d)`: 这返回字典中的项目数量。'
- en: '`d[key]`: This return the `value` associated with `key`.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`d[key]`: 这返回与`key`关联的`value`。'
- en: '`d[key] = value`: This is used to set the mapping of `key` to `value`.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`d[key] = value`: 这用于设置`key`到`value`的映射。'
- en: '`del d[key]`: This deletes the value associated with `key`.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`del d[key]`: 这删除与`key`关联的值。'
- en: '`key in d`: If `key` exists in the dictionary, return `True`; otherwise, return
    `False`.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`key in d`: 如果`key`存在于字典中，则返回`True`；否则，返回`False`。'
- en: '`key not in d`: If `key` exists in the dictionary, return `False`; otherwise,
    return `True`.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`key not in d`: 如果`key`存在于字典中，则返回`False`；否则，返回`True`。'
- en: '`iter(d)`: This returns an interator object from the dictionary `keys`. To
    actually use the iterated `keys`, you must use a `for` loop.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iter(d)`: 这从字典`keys`返回一个迭代器对象。要实际使用迭代的`keys`，必须使用`for`循环。'
- en: '`clear()`: This removes all items from the dictionary.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clear()`: 这从字典中删除所有项。'
- en: '`copy()`: This returns a shallow copy of the dictionary.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`copy()`: 这返回字典的浅拷贝。'
- en: '`fromkeys(seq[, value])`: This creates a new dictionary using the `keys` listed
    in `seq` and sets their `values` to `value`. If no `value` is provided, it defaults
    to `None`.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fromkeys(seq[, value])`: 这使用`seq`中列出的`keys`创建一个新的字典，并将它们的`values`设置为`value`。如果没有提供`value`，则默认为`None`。'
- en: '`get(key[, default])`: This returns the `value` associated with `key`, if `key`
    exists. Otherwise, the `default` value is returned. If `default` is not set, then
    `None` is returned, that is, no response, but not an error.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get(key[, default])`: 如果 `key` 存在，则返回与 `key` 关联的 `value`。否则，返回 `default` 值。如果未设置
    `default`，则返回 `None`，即没有响应，但不是错误。'
- en: '`items()`: This returns a `view` object of the `key:value` pairs in the dictionary.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`items()`: 返回字典中 `key:value` 对的 `view` 对象。'
- en: '`keys()`: This returns a `view` object of just the dictionary keys.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`keys()`: 返回仅包含字典键的 `view` 对象。'
- en: '`pop(key[, default])`: This is used if `key` exists in the dictionary; remove
    it from the dictionary and return its `value`; otherwise, return `default`. If
    `default` isn''t provided and the `key` doesn''t exist, then an error is raised.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pop(key[, default])`: 当 `key` 存在于字典中时使用；从字典中移除并返回其 `value`；否则，返回 `default`。如果未提供
    `default` 且 `key` 不存在，则引发错误。'
- en: '`popitem()`: This removes and returns an arbitrary pair from the dictionary.
    As dictionaries are unsorted, the returned pair is effectively randomly selected.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`popitem()`: 从字典中移除并返回一个任意的键值对。由于字典是无序的，返回的键值对实际上是随机选择的。'
- en: '`setdefault(key[, default])`: This is used if `key` is present in the dictionary;
    return its `value`. If not present, then make a new `key:value` pair with the
    provided `key` and the `default` value. If `default` isn''t set, it defaults to
    `None`.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setdefault(key[, default])`: 当 `key` 存在于字典中时使用；返回其 `value`。如果不存在，则使用提供的 `key`
    和 `default` 值创建一个新的 `key:value` 对。如果未设置 `default`，则默认为 `None`。'
- en: '`update([other])`: This modifies the dictionary by updating it with the pairs
    from `other`. If existing `keys` are present, they will be overwritten. `other`
    can be another dictionary or an iterable object of `key:value` pairs, such as
    a tuple.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`update([other])`: 通过从 `other` 中更新对来修改字典。如果存在现有的 `keys`，则将覆盖它们。`other` 可以是另一个字典或
    `key:value` 对的迭代对象，例如元组。'
- en: '`values()`: This returns a `view` object of the dictionaries values.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`values()`: 返回字典值的 `view` 对象。'
- en: 'Dictionary `view` objects are actually dynamic objects that show a dictionary''s
    items; when a dictionary changes, the view updates to reflect those changes. `view`
    objects actually have their own methods available to them:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 字典 `view` 对象实际上是动态对象，显示字典的项；当字典发生变化时，视图会更新以反映这些变化。`view` 对象实际上有自己的方法可用：
- en: '`len(dictview)`: This returns the number of items in a dictionary'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`len(dictview)`: 返回字典中的项目数量'
- en: '`iter(dictview)`*:* This returns an iterator object over the dictionary `keys`*,*
    `values`*,* or `key:value` pairs'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iter(dictview)`：返回一个迭代器对象，遍历字典的 `keys`、`values` 或 `key:value` 对'
- en: '`x in dictview`: This returns `True` if `x` exists within the `view` object'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x in dictview`: 如果 `x` 存在于 `view` 对象中，则返回 `True`'
- en: Sets
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合
- en: 'Since sets are similar to dictionaries, they have a number of methods associated
    with them, which apply to both set and frozenset:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 由于集合与字典相似，它们有许多与它们相关联的方法，这些方法适用于集合和冻结集合：
- en: '`len(s)`: This returns the number of items in set `s`'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`len(s)`: 返回集合 `s` 中的项目数量'
- en: '`x in s`: This returns `True` if `x` exists in `s`;  otherwise, it is `False`'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x in s`: 如果 `x` 存在于 `s` 中，则返回 `True`；否则，返回 `False`'
- en: '`x not in s`: This returns `False` if `x` exists in `s`; otherwise, it is `True`'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x not in s`: 如果 `x` 存在于 `s` 中，则返回 `False`；否则，返回 `True`'
- en: '`isdisjoint(other)`: This returns `True` if the set has no elements in common
    with object `other`'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isdisjoint(other)`: 如果集合与对象 `other` 没有共同元素，则返回 `True`'
- en: '`issubset(other)`: This tests whether all elements in the `set` are also in
    `other`'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`issubset(other)`: 测试集合中的所有元素是否也存在于 `other` 中'
- en: '`issuperset(other)`: This tests whether all elements in `other` are also in
    `set`'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`issuperset(other)`: 测试 `other` 中的所有元素是否也存在于 `set` 中'
- en: '`union(*others)`: This returns a new set that includes elements from the original
    `set` and all `other` objects'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`union(*others)`: 返回一个新的集合，包含原始 `set` 和所有其他对象中的元素'
- en: '`intersection(*others)`: This returns a new set that only contains objects
    that are in common between the `set` and all `other` objects'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`intersection(*others)`: 返回一个新的集合，仅包含 `set` 和所有其他对象之间的共同元素'
- en: '`difference(*others)`: This returns a new set that is only the elements that
    exist in the `set`, but are not in `others`'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`difference(*others)`: 返回一个新的集合，仅包含存在于 `set` 中但不在 `others` 中的元素'
- en: '`symmetric_different(other)`: This returns a new set of elements that are either
    in `set` or `other`, but not both'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`symmetric_difference(other)`: 返回一个新的集合，包含存在于 `set` 或 `other` 中，但不同时存在于两者中的元素'
- en: '`copy()`: This returns a new set with a shallow copy of the set'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`copy()`: 返回一个新的集合，包含集合的浅拷贝'
- en: 'The following are methods only available to set, but not to frozenset:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些仅适用于集合而不适用于frozenset的方法：
- en: '`update(*others)`: This updates the set by adding elements from all `others`'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`update(*others)`: 这通过从所有`others`中添加元素来更新集合。'
- en: '`intersection_update(*others)`: This updates the set by keeping only the elements
    that are in the `set` and `others`'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`intersection_update(*others)`: 这通过仅保留在`set`和`others`中都存在的元素来更新集合。'
- en: '`difference_update(*others)`: This updates the set by keeping only the elements
    found in `others`'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`difference_update(*others)`: 这通过仅保留在`others`中找到的元素来更新集合。'
- en: '`symmetric_difference_update(other)`: This updates the set with only the elements
    found in either `set` or `other`, but not common to both'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`symmetric_difference_update(other)`: 这通过仅保留在`set`或`other`中找到的元素来更新集合，但不包括两者共有的元素。'
- en: '`add(elem)`: This adds `elem` to the set'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add(elem)`: 这将`elem`添加到集合中。'
- en: '`remove(elem)`: This deletes `elem` from the set; it throws an exception if `elem`
    is not present'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`remove(elem)`: 从集合中删除`elem`；如果`elem`不存在，则抛出异常。'
- en: '`discard(elem)`: This deletes `elem` from the set if present'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`discard(elem)`: 如果存在`elem`，则从集合中删除它。'
- en: '`pop()`: This removes `elem` from the set, if present, and returns its value;
    it throws an exception if the set contains no values'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pop()`: 如果集合中存在`elem`，则从集合中删除它并返回其值；如果集合中没有值，则抛出异常。'
- en: '`clear()`: This deletes all elements from the set'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clear()`: 这将从集合中删除所有元素。'
- en: Implementing namedtuple
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现namedtuple
- en: Using `namedtuple`, a developer can give meaning to each item in a tuple and
    allow the tuple's fields to be accessed by name rather than by index value. This
    allows for more readable and better self-documenting code. Named tuples can be
    used in place of regular tuples with no adverse effects.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`namedtuple`，开发者可以为元组中的每个项目赋予意义，并允许通过名称而不是索引值访问元组的字段。这允许代码更易读且具有更好的自文档性。命名元组可以替代常规元组而不会产生不利影响。
- en: Named tuples can be thought of as using dictionary-type `key:value` pairs, except
    in a tuple. It's not a true mapping of key to value, because named tuples are
    simply assigning a name to a sequence index position, that is, name=value, but
    it may help to conceptually think of them as unchanging mapped pairs. Named positions
    can be called by name or by position index.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 命名元组可以被视为使用字典类型的`key:value`对，但不是真正的键到值的映射，因为命名元组只是将名称分配给序列索引位置，即name=value，但可能有助于从概念上将其视为不变的映射对。命名位置可以通过名称或位置索引来调用。
- en: '`namedtuple` is generated using the following command format:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`namedtuple`是通过以下命令格式生成的：'
- en: '[PRE3]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following is an explanation of the parts of the preceding command:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对先前命令各部分的解释：
- en: '`typename`: The name of the tuple subclass being created. Subclass instances
    automatically generate `docstrings` incorporating the `typename` and field names,
    as well as creating a `__repr__` method that automatically lists the tuple contents
    in `name=value` format.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`typename`: 正在创建的元组子类的名称。子类实例会自动生成包含`typename`和字段名称的`docstrings`，以及创建一个自动以`name=value`格式列出元组内容的`__repr__`方法。'
- en: '`field_names`: A sequence (list or tuple) of strings to signify the names of
    the tuple fields, for example, [*X*-axis, *Y*-axis, *Z*-axis]. The field names
    can also be signified using a single string, rather than a sequence object, with
    each field name separated by whitespace or commas, such as *X*-axis, *Y*-axis,
    *Z*-axis. Any legitimate Python name can be used; not allowed names include ones
    that start with numbers or underscores, as well as any Python keywords.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`field_names`: 一个字符串序列（列表或元组），用于表示元组字段的名称，例如，[*X*-axis, *Y*-axis, *Z*-axis]。字段名称也可以使用单个字符串表示，而不是序列对象，字段名称之间由空格或逗号分隔，例如
    *X*-axis, *Y*-axis, *Z*-axis。可以使用任何合法的Python名称；不允许的名称包括以数字或下划线开头，以及任何Python关键字。'
- en: '`*`: It helps to capture all argument inputs. This is actually no different
    than the more commonly seen `*args`, as the `*` is the item of concern for Python
    when working with arguments; `args` is simply a convention used by programmers.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*`: 它有助于捕获所有参数输入。这实际上与更常见的`*args`没有区别，因为`*`是Python处理参数时关注的项；`args`只是程序员使用的一个约定。'
- en: '`verbose`: (deprecated) if true, the class definition will be printed after
    it is built. The preferred way to do this nowadays is to print the `_source` attribute.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`verbose`: (已弃用)如果为真，则构建后将会打印类定义。如今，首选的做法是打印`_source`属性。'
- en: '`rename`: If true, invalid field names are automatically replaced with positional
    names. For example, `abc, def, xyz, abc` would automatically become `abc, _1,
    xyz, _3` to replace the redundant `abc` and the Python keyword `def`.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rename`: 如果为真，无效的字段名称将自动替换为位置名称。例如，`abc, def, xyz, abc` 将自动变为 `abc, _1, xyz,
    _3` 以替换重复的 `abc` 和 Python 关键字 `def`。'
- en: '`module`: If defined, the `__module__` attribute of the `namedtuple` is set
    to the value provided.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`module`: 如果已定义，则将 `namedtuple` 的 `__module__` 属性设置为提供的值。'
- en: How to do it...
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'It doesn''t get much better than the official documentation, so here is an
    example from [https://docs.python.org/3/library/collections.html#collections.namedtuple](https://docs.python.org/3/library/collections.html#collections.namedtuple):'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 官方文档已经相当不错了，所以这里有一个例子来自 [https://docs.python.org/3/library/collections.html#collections.namedtuple](https://docs.python.org/3/library/collections.html#collections.namedtuple)：
- en: 'Make `namedtuple`:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `namedtuple`：
- en: '[PRE4]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Make a new instance of the `namedtuple`. You can use positional or keyword
    arguments:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `namedtuple` 的新实例。您可以使用位置或关键字参数：
- en: '[PRE5]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The new `namedtuple` can be indexed like a normal tuple:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 新的 `namedtuple` 可以像普通元组一样索引：
- en: '[PRE6]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'It can also be unpacked like a regular tuple:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它也可以像常规元组一样解包：
- en: '[PRE7]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Tuple objects can be accessed by their assigned names instead of index:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以通过分配的名称而不是索引来访问元组对象：
- en: '[PRE8]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Because `__repr__` is provided automatically, calling the `namedtuple` instance
    provides all information about the `namedtuple`:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为 `__repr__` 是自动提供的，所以调用 `namedtuple` 实例提供了有关 `namedtuple` 的所有信息：
- en: '[PRE9]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Another example from the documentation shows how named tuples can be utilized
    with CSV or SQLite. First, create a `namedtuple` (`employee_record_tuple.py`):'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '文档中的另一个例子展示了如何使用 CSV 或 SQLite 利用命名元组。首先，创建一个 `namedtuple` (`employee_record_tuple.py`):'
- en: '[PRE10]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'For a CSV file, import the `csv` module and then map the imported file data
    to the `namedtuple`. "`rb`" is used because the CSV format is considered a binary
    file type, even though it is human-readable. The method `_make()` is explained
    in the next section (`import_csv.py`):'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于 CSV 文件，导入 `csv` 模块，然后将导入的文件数据映射到 `namedtuple`。使用 "`rb`" 是因为 CSV 格式被认为是一种二进制文件类型，尽管它是可读的。`_make()`
    方法将在下一节（`import_csv.py`）中解释：
- en: '[PRE11]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'For SQLite, import the module and create the connection. After the cursor is
    executed to select the fields from the database, they are mapped to the `namedtuple`
    just like the CSV example (`import_sqlite.py`):'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于 SQLite，导入模块并创建连接。在执行游标以从数据库中选择字段之后，它们就像 CSV 示例（`import_sqlite.py`）一样映射到 `namedtuple`：
- en: '[PRE12]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: There's more...
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'As seen in the preceding examples, named tuples have special methods and attributes
    available to them, as well as the methods available to normal tuples. The `namedtuple`
    methods and attributes are denoted with an underscore prefix to ensure that they
    don''t conflict with field names, as shown here:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如前例所示，命名元组具有特殊的方法和属性可用，以及普通元组的方法。`namedtuple` 的方法和属性用下划线前缀表示，以确保它们不与字段名称冲突，如下所示：
- en: '`<namedtuple>._make(iterable)`: A class method that creates a new instance
    from an existing sequence or iterable object:'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<namedtuple>._make(iterable)`: 一个类方法，它从一个现有的序列或可迭代对象创建一个新的实例：'
- en: '[PRE13]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`<namedtuple>._asdict()`: It returns an `OrderedDict` object that maps field
    names to corresponding values:'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<namedtuple>._asdict()`: 它返回一个将字段名称映射到相应值的 `OrderedDict` 对象：'
- en: '[PRE14]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`<namedtupled>._replace(**kwargs)`: It returns an instance of the named tuple
    that replaces specific fields with new values:'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<namedtupled>._replace(**kwargs)`: 它返回一个命名元组的实例，该实例用新值替换特定字段：'
- en: '[PRE15]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`<namedtuple>._source`: This attribute provides a string with the raw Python
    source code that actually creates the `namedtuple` class; this code makes the
    `namedtuple` self-documenting. The string can be printed, executed, saved to a
    file, imported as a module, and so on:'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<namedtuple>._source`: 此属性提供了一个字符串，其中包含实际创建 `namedtuple` 类的原始 Python 源代码；此代码使
    `namedtuple` 具有自文档功能。该字符串可以打印、执行、保存到文件、作为模块导入等：'
- en: '![](img/aacec847-1206-4f3a-9c36-25e898fd5dcc.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aacec847-1206-4f3a-9c36-25e898fd5dcc.png)'
- en: '`<namedtuple>._fields`: It returns a tuple of field names as strings. This
    is useful when needing to create new named tuples from existing named tuples:'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<namedtuple>._fields`: 它返回一个字段名称字符串的元组。这在需要从现有的命名元组创建新的命名元组时很有用：'
- en: '[PRE16]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In addition to the preceding methods and attributes, named tuples have some
    special functionality that can be utilized to maximize their versatility.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前面提到的方法和属性外，命名元组还有一些特殊功能可以利用，以最大限度地提高其多功能性。
- en: 'If a field''s name is a string, `getattr()` can be used to obtain its value:'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个字段的名称是字符串，可以使用`getattr()`来获取其值：
- en: '[PRE17]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Dictionaries can be converted to named tuples, due to the `field:value` mapping.
    The double-star operator that unpacks argument lists, that is, `**kwargs`, is
    used to obtain this effect:'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于`field:value`映射，字典可以被转换为命名元组。用于展开参数列表的双星运算符，即`**kwargs`，被用来获得这种效果：
- en: '[PRE18]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As a normal Python class, named tuples can be subclassed to modify or add functionality.
    Here is an example from the documentation of adding a calculated field and fixed-width
    printing:'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为正常的Python类，命名元组可以被继承以修改或添加功能。以下是从文档中添加计算字段和固定宽度打印的示例：
- en: '[PRE19]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We will get the following output:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到以下输出：
- en: '![](img/0ba20439-f05b-40b4-971e-548f4f8520a9.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0ba20439-f05b-40b4-971e-548f4f8520a9.png)'
- en: The `@property` decorator is an alternative to getter and setter interfaces.
    While not a detailed walk-through, here is a brief summary for the curious. If
    a module is written from the beginning to use getter and setter methods, there
    isn't an issue with updates. However, if a module incorporated them at a later
    time, any programs written with the module would have to be rewritten to incorporate
    the new features. This is because getter/setter methods retrieve and assign values
    to variables, replacing previous functionality, such as via initialization, or
    to throw exceptions when out-of-bounds values are used.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`@property`装饰器是getter和setter接口的替代方案。虽然不是详细的说明，但以下是好奇者的简要总结。如果一个模块从一开始就使用getter和setter方法编写，则更新时没有问题。然而，如果一个模块在以后的时间加入了它们，任何使用该模块编写的程序都必须重写以包含新功能。这是因为getter/setter方法检索和分配值到变量，替换了以前的功能，例如通过初始化，或者在使用越界值时抛出异常。'
- en: Using the `@property` decorator means programs implementing the modified module
    don't have to be rewritten; all the changes are internal to the module. Thus,
    backwards compatibility is maintained and users of the module don't have to worry
    about the internals.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`@property`装饰器意味着实现修改后的模块的程序不需要重写；所有更改都在模块内部。因此，向后兼容性得到保持，模块的用户不需要担心内部细节。
- en: 'By directly modifying the `namedtuple __doc__` fields, `docstrings` can be
    customized to reflect the `namedtuple` fields:'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过直接修改`namedtuple __doc__`字段，可以自定义`docstrings`以反映`namedtuple`字段：
- en: '[PRE20]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Finally, default values can be set via the `_replace()` method:'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，可以通过`_replace()`方法设置默认值：
- en: '[PRE21]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Implementing deque
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现deque
- en: 'Deques (pronounced *decks*) are list-like containers that have fast appending
    and pop values from either end. The name deque comes from this action: double-ended
    queues. Deques are thread safe, meaning data is manipulated in such a way that
    all threads behave without overwriting data or otherwise operate with unintended
    actions. Popped values from either end of the deque have the same performance,
    regardless of being on the front or the rear of the queue.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Deques（发音为*decks*）是类似于列表的容器，可以从两端快速追加和弹出值。这个名字deque来源于这个动作：双端队列。Deques是线程安全的，这意味着数据以这种方式被操作，所有线程的行为都不会覆盖数据或以其他方式执行未预期的操作。从deque的两端弹出的值具有相同的性能，无论它们是在队列的前端还是后端。
- en: For those familiar with big *O* notation, performance is *O(1)* for both front-
    and rear-popped values. For those unfamiliar with big *O* notation, this just
    means it takes the same amount of time for a deque to pop a value from the front
    as it does for the back. This is significant because lists, which have similar
    operations as the deque, are optimized for quick, fixed-length operations and
    take a performance hit of *O(n)* to memory movement when popping and inserting
    values, as they both modify the size and position of the data structure. *O(n)*
    simply means that the time to completion of a process increases linearly and is
    proportional to the number of input values.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 对于熟悉大O符号的人来说，前端的弹出值和后端的弹出值的性能都是*O(1)*。对于不熟悉大O符号的人来说，这仅仅意味着deque从前面弹出值所需的时间与从后面弹出值所需的时间相同。这很重要，因为具有类似deque操作列表被优化用于快速、固定长度的操作，并且在弹出和插入值时，由于它们都修改数据结构的大小和位置，性能会受到影响，为*O(n)*。*O(n)*简单来说就是完成一个过程所需的时间与输入值的数量成线性关系，并且成正比。
- en: The downside to using deques is that they have slow data access; that is, reading
    data from a deque is functionally slower than reading from a list. Hence, deques
    are ideal when quick data insertion/removal from either end of the deque is necessary.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 使用双端队列的缺点是它们的数据访问速度较慢；也就是说，从双端队列中读取数据在功能上比从列表中读取要慢。因此，当需要快速从双端队列的任一端插入/删除数据时，双端队列是理想的。
- en: 'The format for using deque is as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 使用双端队列的格式如下：
- en: '[PRE22]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`iterable`: A data object that can be iterated through. This iteration is used
    to generate a new deque object that is initialized in a left-to-right manner,
    that is, an empty deque object is filled using `append()` on each iterated object.
    If `iterable` is not specified, an empty deque object is created.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iterable`: 可以迭代的 数据对象。这种迭代用于生成一个新的双端队列对象，该对象以从左到右的方式初始化，即使用 `append()` 在每个迭代的对象上填充一个空的双端队列对象。如果没有指定
    `iterable`，则创建一个空的双端队列对象。'
- en: '`maxlen`: It specifies how long a deque object can be. If this is not provided,
    or if it is equal to `None`, then the deque can be extended to any length. If
    the max length of a deque is exceeded, then for every item that is added to it,
    an equal quantity is removed from the opposite end. In terms of functionality,
    bounded-length deques operate like the `tail` command in *NIX; they are also used
    for transaction tracking, and monitoring recent data transactions within a pool
    of data.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`maxlen`: 它指定双端队列对象的最大长度。如果没有提供，或者如果它等于 `None`，则双端队列可以扩展到任何长度。如果双端队列的最大长度被超过，那么对于添加到其中的每个元素，都会从另一端移除等量的元素。在功能上，有限长度的双端队列类似于
    *NIX 中的 `tail` 命令；它们也用于事务跟踪，以及监控数据池中的最近数据事务。'
- en: 'Methods used with deque are similar to lists, but they naturally have their
    own, special methods due to their nature:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 与双端队列一起使用的方法与列表类似，但它们由于自身的性质而自然具有它们自己的特殊方法：
- en: '`append(x)`: It adds value `x` to the end (right-sight) of the deque object.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`append(x)`: 它将值 `x` 添加到双端队列对象的末尾（右侧）。'
- en: '`appendleft(x)`: It adds value `x` to the front (left-sight) of the deque.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`appendleft(x)`: 它将值 `x` 添加到双端队列的前端（左侧）。'
- en: '`clear()`: It deletes all items from the deque.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clear()`: 它从双端队列中删除所有项目。'
- en: '`copy()`: It creates a shallow copy of the deque.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`copy()`: 它创建双端队列的浅拷贝。'
- en: '`count(x)`: It counts the number of elements in the deque that are equal to
    `x`.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`count(x)`: 它计算双端队列中等于 `x` 的元素数量。'
- en: '`extend(iterable)`: It extends the end of the deque by appending items from
    `iterable`.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`extend(iterable)`: 它通过从 `iterable` 中追加项目来扩展双端队列的末尾。'
- en: '`extendleft(iterable)`: It extends the front of the deque by appending items
    from `iterable`; this results in the items from `iterable` being reversed within
    the deque.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`extendleft(iterable)`: 它通过从 `iterable` 中追加项目来扩展双端队列的前端；这导致 `iterable` 中的项目在双端队列中反转。'
- en: '`index(x[, start[, stop]])`: It returns the position of `x` in the deque; if
    provided, the position will be limited to or after the `start` index and before
    the `stop` position. If found, the first match will be returned; otherwise, an
    error is given.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index(x[, start[, stop]])`: 它返回 `x` 在双端队列中的位置；如果提供了，则位置将被限制在 `start` 索引之后和
    `stop` 位置之前。如果找到，则返回第一个匹配项；否则，给出错误。'
- en: '`insert(i, x)`: It inserts item `x` at position `i`; if the deque is bounded
    and the insertion results in exceeding the max length, an error will occur.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`insert(i, x)`: 它在位置 `i` 插入项目 `x`；如果双端队列是有限的，并且插入导致超过最大长度，则将发生错误。'
- en: '`pop()`: It removes and returns an element from the end of the deque. If no
    items are in the deque, an error will occur.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pop()`: 它从双端队列的末尾移除并返回一个元素。如果双端队列中没有元素，将发生错误。'
- en: '`popleft()`: It removes and returns an element from the front of the deque;
    an error is returned if no items are present.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`popleft()`: 它从双端队列的前端移除并返回一个元素；如果没有元素，则返回错误。'
- en: '`remove(value)`: It deletes the first item that matches `value`; if there is
    no match, an error occurs.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`remove(value)`: 它删除第一个匹配 `value` 的项目；如果没有匹配项，则发生错误。'
- en: '`reverse()`: It reverses the deque in-place.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reverse()`: 它就地反转双端队列。'
- en: '`rotate(n=1)`: It rotates the deque to the right `n` times, moving the end
    element to the front. If `n` is negative, the rotation is to the left.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rotate(n=1)`: 它将双端队列向右旋转 `n` 次，将末尾元素移动到前面。如果 `n` 是负数，则旋转方向为左。'
- en: 'In addition to the preceding methods, deques can also perform the following
    operations:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前面提到的方法外，双端队列还可以执行以下操作：
- en: '`Iteration`: Walk through sequence'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Iteration`: 遍历序列'
- en: '`Pickling`: Data serialization'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Pickling`: 数据序列化'
- en: '`len(deque)`: Length assessment'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`len(deque)`: 长度评估'
- en: '`reversed(deque)`: Reversal object return'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reversed(deque)`: 返回反转对象'
- en: '`copy.copy(deque)`: Shallow copy'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`copy.copy(deque)`: 浅拷贝'
- en: '`copy.deepcopy(deque)`: Deep copy'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`copy.deepcopy(deque)`: 深度复制'
- en: '`in`: Membership testing via the `in` operator'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`in`：通过 `in` 操作符进行成员资格测试'
- en: '`deque[1]`: Indexed accessing'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`deque[1]`: 索引访问'
- en: Index access is fast *[O(1)]* at the end of the deque, but slows to *O(n)* in
    the middle. As mentioned earlier, if fast random access to items in the sequence
    is more important than having the ability to insert/remove from both ends, then
    a list object is the better choice.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在双端队列末尾的索引访问是快速的 *[O(1)]*，但在中间会减慢到 *O(n)*。如前所述，如果对序列中项的快速随机访问比从两端插入/删除的能力更重要，那么列表对象是更好的选择。
- en: How to do it...
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s walk through an example from [https://docs.python.org/3/library/collections.html#collections.deque](https://docs.python.org/3/library/collections.html#collections.deque):'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来了解 [https://docs.python.org/3/library/collections.html#collections.deque](https://docs.python.org/3/library/collections.html#collections.deque)：
- en: 'Import `deque` from the `collections` module:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `collections` 模块导入 `deque`：
- en: '[PRE23]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Create a `deque` object. In this case, we will give it a string object as an
    argument:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `deque` 对象。在这种情况下，我们将将其作为参数传递一个字符串对象：
- en: '[PRE24]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Simple iteration over the string:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 简单地对字符串进行迭代：
- en: '[PRE25]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Add additional items to the front and rear of the deque:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向双端队列的前端和后端添加额外的项目：
- en: '[PRE26]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Show the new `deque` object:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示新的 `deque` 对象：
- en: '[PRE27]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Pop out the left- and right-most elements:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 弹出最左和最右的元素：
- en: '[PRE28]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Show the updated `deque` object:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示更新的 `deque` 对象：
- en: '[PRE29]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'See that the deque can be accessed just like a list:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 看到双端队列可以像列表一样访问：
- en: '[PRE30]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Reverse the deque object in-place and create a list from it:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在原地反转双端队列对象并从中创建一个列表：
- en: '[PRE31]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Search for an item in the deque:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在双端队列中搜索一个项目：
- en: '[PRE32]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Add multiple items to the deque at the same time:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同时向双端队列添加多个项目：
- en: '[PRE33]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Rotate the contents of the deque back and forth:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在双端队列的内容中来回旋转：
- en: '[PRE34]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Make a new, reversed `deque` object:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的、反转的 `deque` 对象：
- en: '[PRE35]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Delete the contents of the deque and show that operations can no longer be
    performed on it:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除双端队列的内容并显示无法再对其进行操作：
- en: '[PRE36]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Add new items to the front of the deque (the result is in reverse order of
    input):'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向双端队列（deque）的前端添加新项目（结果顺序与输入顺序相反）：
- en: '[PRE37]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'If a deque object has `maxlength` assigned, it can function like `tail` in
    *NIX operating systems:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果双端队列对象分配了 `maxlength`，它可以像 *NIX 操作系统中的 `tail` 一样工作：
- en: '[PRE38]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Create a **FIFO** (**first-in, first-out**) container. Input is appended on
    the right side of the `deque` object and output is popped from the left side:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 **FIFO**（**先进先出**）容器。输入被追加到 `deque` 对象的右侧，输出从左侧弹出：
- en: '[PRE39]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Make a pure Python code version of `del d[n]` (`del` is actually a compiled
    C file when used by Python):'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个纯 Python 代码版本的 `del d[n]`（`del` 在 Python 中实际上是一个编译后的 C 文件）：
- en: '[PRE40]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Implementing ChainMap
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现 ChainMap
- en: ChainMap is a dictionary-like class, used to create a single view of multiple
    mappings. It allows for quick linking between multiple mappings so they can all
    be considered as a single unit, which is useful when simulating nested scopes
    and when templating. This can be faster than creating a new dictionary and running
    `update()` calls repeatedly.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: ChainMap 是一个类似于字典的类，用于创建多个映射的单个视图。它允许快速链接多个映射，使它们都可以被视为单个单元，这在模拟嵌套作用域和模板时非常有用。这比创建新字典并反复运行
    `update()` 调用要快。
- en: 'The command to create a `ChainMap` is as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 `ChainMap` 的命令如下：
- en: '[PRE41]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: As usual, the `*maps` is simply a number of dictionaries or other map objects
    passed in to be combined into a single, updateable view. If no mappings are passed
    in, then an empty dictionary is created so the new chain has at least one mapping
    available to it.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，`*maps` 简单地是传递给组合成单个可更新视图的多个字典或其他映射对象的数量。如果没有传递映射，则创建一个空字典，以便新的链至少有一个映射可用。
- en: The mappings themselves are contained, behind the scenes, within a list. The
    list is a public object and it can be accessed or updated via the `maps` attribute.
    When looking for a key, the search occurs over the mapping list until the key
    is found. However, modifications to the list occur only on the first mapping.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 映射本身在幕后包含在一个列表中。该列表是一个公共对象，可以通过 `maps` 属性对其进行访问或更新。当查找键时，搜索发生在映射列表中，直到找到键。然而，对列表的修改仅发生在第一个映射上。
- en: To keep memory requirements low, `ChainMap` doesn't make a copy of all the mappings,
    but simply uses the mappings via reference. Thus, if an underlying mapping is
    modified, it is immediately available to the `ChainMap` object.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持内存需求低，`ChainMap` 不复制所有映射，而是通过引用使用映射。因此，如果底层映射被修改，它将立即对 `ChainMap` 对象可用。
- en: 'All normal dictionary methods are available, as well as the following special
    `ChainMap` methods:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 所有正常的字典方法都可用，以及以下特殊的`ChainMap`方法：
- en: '`maps`: It is referred to earlier; this is a user-accessible list of mappings.
    The list is based on search order, that is, first-searched-to-last-searched. This
    list can be modified to change the mappings that are searched.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`maps`：它之前被提到过；这是一个用户可访问的映射列表。该列表基于搜索顺序，即从第一个搜索到最后一个搜索。此列表可以被修改以更改要搜索的映射。'
- en: '`new_child(m=None)`: It returns a new `ChainMap` that has a new map, followed
    by all the maps of the current instance. If a value for `m` is passed in, it becomes
    the first map at the front of the list. If not provided, an empty dictionary is
    used. This method can be used to create subcontexts that can be updated without
    modifying parent mapping values.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`new_child(m=None)`:它返回一个新的`ChainMap`，包含一个新的映射，然后是当前实例的所有映射。如果传递了`m`的值，它将成为列表前面的第一个映射。如果没有提供，则使用空字典。此方法可以用来创建可以更新而不修改父映射值的子上下文。'
- en: '`parents`: It returns a new `ChainMap` that holds all the maps in the current
    instance except for the first one. This is useful to skip the first map when searching.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parents`：它返回一个新的`ChainMap`，包含当前实例中除了第一个之外的所有映射。这在搜索时跳过第一个映射很有用。'
- en: How to do it...
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: '`chainmap_import.py` is a basic example of how a `ChainMap` actually operates
    in use. First, `ChainMap` is imported, then two dictionaries are created. A `ChainMap`
    object is created from the two dictionaries. Finally, the key:value pairs from
    the `ChainMap` are printed:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`chainmap_import.py`是一个基本的示例，展示了`ChainMap`在实际使用中的操作。首先，导入`ChainMap`，然后创建两个字典。从这两个字典创建一个`ChainMap`对象。最后，打印出`ChainMap`中的键值对：'
- en: '![](img/a837b3b1-0f8e-4f2f-b707-0dc48552a41d.png)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a837b3b1-0f8e-4f2f-b707-0dc48552a41d.png)'
- en: Notice how the ordering of the dictionaries impacts the results that are printed
    if two keys are the same, since the first mapping is the object that will be searched
    through first for the desired key.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 注意字典的顺序如何影响打印的结果，如果两个键相同，因为第一个映射是首先搜索的对象。
- en: 'The following examples come from the Python documentation at [https://docs.python.org/3/library/collections.html#collections.ChainMap](https://docs.python.org/3/library/collections.html#collections.ChainMap).
    `chainmap_builtins.py` simulates how Python looks for references to objects: `locals`
    is searched first, then `globals`, and finally the Python `builtins`:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下示例来自Python文档[https://docs.python.org/3/library/collections.html#collections.ChainMap](https://docs.python.org/3/library/collections.html#collections.ChainMap)。`chainmap_builtins.py`模拟Python查找对象引用的方式：首先搜索`locals`，然后是`globals`，最后是Python的`builtins`：
- en: '[PRE42]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '`chainmap_combined.py` shows how to allow user-specified arguments override
    environment variables which, in turn, override default values:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`chainmap_combined.py`展示了如何允许用户指定的参数覆盖环境变量，而环境变量反过来又覆盖默认值：'
- en: '[PRE43]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Libraries are imported and default values are applied to a dictionary.
  id: totrans-261
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 库被导入，并将默认值应用于字典。
- en: User input capture is coded using `argparse`, specifically looking for the user
    and color arguments.
  id: totrans-262
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户输入捕获使用`argparse`编码，具体寻找用户和颜色参数。
- en: A dictionary of command-line arguments are generated from user input.
  id: totrans-263
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从用户输入生成命令行参数的字典。
- en: The command-line arguments, operating system environment values, and default
    values are all combined into a `ChainMap`.
  id: totrans-264
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令行参数、操作系统环境变量和默认值都被合并成一个`ChainMap`。
- en: Finally, the selected color and user are printed to the screen. They would be,
    in order, the specified default values, the OS environment values, or command-line
    input values, depending on whether the environment values exist for color and
    user, or whether the user provided arguments to the Python command.
  id: totrans-265
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，选定的颜色和用户被打印到屏幕上。按照顺序，它们将是指定的默认值、操作系统环境变量或命令行输入值，具体取决于颜色和环境变量是否存在，或者用户是否向Python命令提供了参数。
- en: 'When ran, this code simply prints the following:'
  id: totrans-266
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当运行时，此代码简单地打印以下内容：
- en: '[PRE44]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Context managers allow for proper management of resources. For example, `file_open.py` is
    a common method to open a file:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上下文管理器允许正确管理资源。例如，`file_open.py`是一个常见的打开文件的方法：
- en: '[PRE45]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The preceding example uses a context manager to read the file and automatically
    closes it when it is no longer in use. `chainmap_nested_context.py` simulates
    nested contexts:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例使用上下文管理器读取文件，并在不再使用时自动关闭它。`chainmap_nested_context.py`模拟嵌套上下文：
- en: '[PRE46]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: First, the `ChainMap` is created, along with two subclasses (remember, `ChainMap`
    is a class, even though it acts like a dictionary object)
  id: totrans-272
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，创建`ChainMap`及其两个子类（记住，`ChainMap`是一个类，尽管它表现得像字典对象）
- en: '`e.maps[0]` basically says: "Get the context of the local scope"'
  id: totrans-273
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`e.maps[0]`基本上表示：“获取局部作用域的上下文”'
- en: '`e.maps[-1]` goes backwards in the context, that is, up one level in the scope
    tree, and gets the global scope (if you went up another level, you would be at
    the Python `builtins` scope)'
  id: totrans-274
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`e.maps[-1]`在上下文中向后移动，即在作用域树中向上移动一级，并获取全局作用域（如果你再向上移动一级，你将处于Python的`builtins`作用域）'
- en: '`e.parents` acts like the Python `nonlocal` statement, which allows binding
    to variables outside of the local scope, but are not global, that is, binding
    of encapsulated code to the enclosing code'
  id: totrans-275
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`e.parents`的行为类似于Python的`nonlocal`语句，它允许绑定到局部作用域之外但不是全局的变量，即绑定封装代码到封装代码'
- en: After the variables are set, the first dictionary key in the chain is set and
    assigned a value, then deleted
  id: totrans-276
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量设置完成后，链中的第一个字典键被设置并赋值，然后被删除
- en: Next, all the items in the nested structure are listed (keys), checked, counted,
    and listed (pairs)
  id: totrans-277
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，列出（键）、检查、计数并列出（对）嵌套结构中的所有项
- en: Finally, the nested child is converted to a regular dictionary
  id: totrans-278
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，将嵌套子项转换为常规字典
- en: 'Since the default action of `ChainMap` is to peruse the entire chain for lookups,
    but to only modify the first mapping listed in the chain, to modify mappings further
    down the chain, a subclass can be made that updates keys beyond the first mapping
    (`deep_chainmap.py`):'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于`ChainMap`的默认操作是在查找时遍历整个链，但只修改链中列出的第一个映射，要修改链中更低的映射，可以创建一个子类来更新第一个映射之外的关键字（`deep_chainmap.py`）：
- en: '![](img/05bdae67-403f-4e3a-bfa2-c6be0cec4012.png)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/05bdae67-403f-4e3a-bfa2-c6be0cec4012.png)'
- en: 'This class defines two methods:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类定义了两个方法：
- en: '`__setitem__()`, accepts a key and value as arguments. Each mapping object
    within the `ChainMap` is checked to see whether the key exists. If so, a value
    is assigned to that particular mapping''s key. If the key doesn''t exist, then
    a new pair is added to the first mapping object.'
  id: totrans-282
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__setitem__()`，接受一个键和一个值作为参数。`ChainMap`中的每个映射对象都会检查键是否存在。如果存在，则将该值赋给特定映射的键。如果键不存在，则将新的一对添加到第一个映射对象。'
- en: '`__delitem__()`, takes a key as its argument. Again, the mappings are cycled
    through to find a match to the key argument. If a match is found, the item pair
    is removed from the mapping. If no match is found, an error is generated.'
  id: totrans-283
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__delitem__()`，接受一个键作为其参数。再次，映射会被遍历以找到与键参数匹配的项。如果找到匹配项，则从映射中删除该项对。如果没有找到匹配项，则生成错误。'
- en: Implementing Counters
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现Counter
- en: The `Counter` collection is another dictionary-like object that counts hashable
    objects. Like dictionaries, Counters are unordered mappings of elements (stored
    as keys) and their respective quantities (stored as values). Value counts are
    stored as integer values, but can be any value, including zero and negative numbers.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`Counter`集合是另一种类似字典的对象，用于计数可哈希对象。与字典类似，Counter是元素的未排序映射（存储为键）及其相应的数量（存储为值）。值计数以整数形式存储，但可以是任何值，包括零和负数。'
- en: 'Technically, Counter is a subclass of the dictionary class, so it has access
    to all the traditional dictionary methods. In addition, it has the following special
    methods available to it:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，Counter是字典类的子类，因此它可以访问所有传统的字典方法。此外，它还有以下特殊方法可用：
- en: '`elements()`: It returns an iterator object over the key elements, repeating
    each key until its quantity value is reached. Elements are printed in random order
    and, if an element''s count is less than one, it will not be printed.'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`elements()`: 它返回一个迭代器对象，遍历键元素，直到其数量值达到。元素以随机顺序打印，如果一个元素的计数小于一，则不会打印。'
- en: '`most_common([n])`: It returns a list of the most common elements and their
    counts from most common to least. If `n` is provided, only that number of elements
    are returned, otherwise all elements are returned.'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`most_common([n])`: 它返回一个列表，包含最常见的元素及其计数，从最常见到最少。如果提供了`n`，则只返回该数量的元素，否则返回所有元素。'
- en: '`subtract([iterable or mapping])`: It subtracts the number elements in the
    provided argument from another iterable or mapping. Both inputs and outputs can
    be less than one.'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subtract([iterable or mapping])`: 它从提供的参数中减去另一个可迭代对象或映射中的元素数量。输入和输出都可以小于一。'
- en: '`fromkeys(iterable)`: This method, common to normal dictionaries, is not available
    to Counter objects.'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fromkeys(iterable)`: 这个方法，对于普通字典来说是通用的，但对于Counter对象则不可用。'
- en: '`update([iterable or mapping])`: Elements are added to an existing iterable
    or mapping. When adding to an iterable, just the sequence of elements is expected,
    rather than key:value pairs.'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`update([iterable or mapping])`：将元素添加到现有的可迭代对象或映射中。当向可迭代对象添加时，只期望元素序列，而不是键：值对。'
- en: How to do it...
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Here is how to create a new `Counter` object, as demonstrated from [https://docs.python.org/3/library/collections.html#collections.Counter](https://docs.python.org/3/library/collections.html#collections.Counter):'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里是如何创建一个新的`Counter`对象，如从[https://docs.python.org/3/library/collections.html#collections.Counter](https://docs.python.org/3/library/collections.html#collections.Counter)所示：
- en: '[PRE47]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The first object is simply an empty counter, much like creating an empty dictionary.
  id: totrans-295
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个对象只是一个空Counter，就像创建一个空字典一样。
- en: 'The second `Counter` creates a mapping of a text string, summing the count
    of each unique letter, is as follows:'
  id: totrans-296
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第二个`Counter`创建了一个文本字符串的映射，计算每个唯一字母的计数，如下所示：
- en: '[PRE48]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The third `Counter` object is a direct creation from a dictionary, with the
    quantity of each key provided by the user.
  id: totrans-298
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个`Counter`对象是直接从字典创建的，每个键的数量由用户提供。
- en: The final object is similar to the previous, except keyword arguments rather
    than a dictionary mapping.
  id: totrans-299
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最终对象与前面的类似，只是关键字参数而不是字典映射。
- en: 'Interaction with a `Counter` is the same as with dictionaries, except they
    have been optimized to return a value of `0` if an item doesn''t exist within
    the `Counter`, rather than raising an error:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与`Counter`的交互与字典相同，只是它们已被优化，如果`Counter`中不存在项，则返回值为`0`，而不是引发错误：
- en: '[PRE49]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The `del` statement must be used to remove an element from a `Counter`. Simply
    changing its value to zero only changes the value while leaving the element within
    the `Counter`:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要从`Counter`中删除一个元素，必须使用`del`语句。简单地将它的值改为零只会改变值，而不会从`Counter`中删除元素：
- en: '[PRE50]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This is how to iterate over the `Counter` elements:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这就是遍历`Counter`元素的方式：
- en: '[PRE51]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This is how to retrieve the most common elements in a `Counter` object:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这就是如何检索`Counter`对象中最常见的元素：
- en: '[PRE52]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This is how to subtract values from elements:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这就是从元素中减去值的方式：
- en: '[PRE53]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'As noted in the Python documentation ([https://docs.python.org/3/library/collections.html#collections.Counter](https://docs.python.org/3/library/collections.html#collections.Counter)),
    there are a number of common operations when working with Counters, that are listed
    below. Some may be obvious, as Counters are a type of dictionary; others are unique
    to Counters due to their number-centric behavior:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如Python文档[https://docs.python.org/3/library/collections.html#collections.Counter](https://docs.python.org/3/library/collections.html#collections.Counter)中所述，当与Counter一起工作时，有一些常见的操作，如下所示。其中一些可能是显而易见的，因为Counter是一种字典类型；而另一些则是由于它们的以数字为中心的行为而独特于Counter：
- en: '[PRE54]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Because Counters are unique dictionaries, there are some math operations available
    to Counters to allow the combining of `Counter` objects into multisets (Counters
    that have counts greater than zero). Some of these are basic arithmetic, while
    others are similar to what *sets* has available.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为Counter是唯一的字典，所以Counter提供了一些数学运算，允许将`Counter`对象组合成多重集（计数大于零的Counter）。其中一些是基本的算术运算，而另一些则类似于*集合*中可用的操作。
- en: 'Addition and subtraction add/subtract the elements of different `Counter` objects.
    Intersection and union return the minimum and maximum elements from their `Counter`
    objects. While signed integers are used as input, any values that would have an
    output value of zero or less are ignored and not returned. If negative values
    or zero are used as inputs, only outputs with positive values are returned:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 加法和减法会将不同`Counter`对象的元素相加/减。交集和并集返回它们`Counter`对象的最小和最大元素。当使用有符号整数作为输入时，任何输出值为零或更小的值都会被忽略，并且不会返回。如果使用负值或零作为输入，则只返回具有正值的结果：
- en: '[PRE55]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'As noted in step 7 earlier, unary shortcuts are available for adding an empty
    `Counter` or subtracting from an empty `Counter`:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前文第7步所述，对于向空`Counter`添加或从空`Counter`中减去，有单目快捷方式可用：
- en: '[PRE56]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: There's more...
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: As evident from zero and negative numbers not being returned, Counters are designed
    for use with positive integers, primarily in terms of maintaining running counts.
    However, this doesn't mean that negative values or other types cannot be used.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 如从零和负数不被返回所明显，Counter设计用于与正整数一起使用，主要是在维护运行计数方面。然而，这并不意味着不能使用负值或其他类型。
- en: As a subclass of the dictionary class, Counters actually do not have any restrictions
    on keys or values. While the values are supposed to be used to represent increasing
    or decreasing counts, any Python object can be stored within a value field. For
    in-place operations, such as incrementing a value, the value type only needs to
    support addition and subtraction. As such, fractions, decimals, and float types
    can be used instead of integers and negative values are supported. This also applies
    to `update()` and `subtract()` methods; negative and zero values can be used as
    inputs or outputs.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 作为字典类的子类，`Counters`实际上对键或值没有任何限制。虽然值通常用于表示增加或减少的计数，但任何Python对象都可以存储在值字段中。对于就地操作，例如增加一个值，值类型只需要支持加法和减法。因此，可以使用分数、小数和浮点类型来代替整数，并且支持负值。这也适用于`update()`和`subtract()`方法；负数和零值可以作为输入或输出使用。
- en: Implementing OrderedDict
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现`OrderedDict`
- en: Like `Counter`, the `OrderedDict` is a dictionary subclass the doesn't randomize
    the order of dictionary items. As items are added to the `OrderedDict`, it remembers
    the order that the keys were inserted and maintains that order. Even if a new
    entry overwrites an existing key, the position within the dictionary doesn't change.
    However, if an entry is deleted, re-inserting it will place it at the end of the
    dictionary.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 与`Counter`类似，`OrderedDict`是字典子类，不会随机化字典项的顺序。当项被添加到`OrderedDict`中时，它会记住键插入的顺序并保持该顺序。即使新条目覆盖了现有键，字典中的位置也不会改变。然而，如果删除一个条目，重新插入它将把它放在字典的末尾。
- en: '`OrderedDict`, being a subclasses of `dict`, inherit all the methods available
    to dictionaries. There are also three special methods available to `OrderedDict`:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '`OrderedDict`作为`dict`的子类，继承了字典中所有可用的方法。`OrderedDict`也有三个特殊方法可用：'
- en: '`popitem(last=True)`: It returns and removes the key:value pair at the end
    of the dictionary. If `last` is not provided or manually set to `True`, then the
    popped value is **LIFO** (**last in, first out**). If `last` is set to `False`,
    then the popped value is FIFO.'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`popitem(last=True)`：它返回并移除字典末尾的键：值对。如果`last`未提供或手动设置为`True`，则弹出值是**后进先出**（**LIFO**）。如果`last`设置为`False`，则弹出值是先进先出（FIFO）。'
- en: '`move_to_end(key, last=True)`: It moves the provided key to the end of the
    dictionary. If `last` is set to `True`, then the key moves to the right. If `last`
    is set to `False`, the key is sent to the front. If the key does not exist, an
    error is generated.'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`move_to_end(key, last=True)`：它将提供的键移动到字典的末尾。如果`last`设置为`True`，则键向右移动。如果`last`设置为`False`，则键被发送到前面。如果键不存在，将生成错误。'
- en: '`reversed()`: Since `OrderedDict` objects are in order, they can be manipulated
    like an iterable object; in this case, reverse iteration can be performed on an
    `OrderedDict`.'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reversed()`：由于`OrderedDict`对象是有序的，它们可以像可迭代对象一样进行操作；在这种情况下，可以在`OrderedDict`上执行反向迭代。'
- en: How to do it...
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'The following examples come from [https://docs.python.org/3/library/collections.html#collections.OrderedDict.](https://docs.python.org/3/library/collections.html#collections.OrderedDict) `ordereddict_use.py`,
    below, shows how to use `OrderedDict` to create a sorted dictionary: [](https://docs.python.org/3/library/collections.html#collections.OrderedDict)'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下示例来自[https://docs.python.org/3/library/collections.html#collections.OrderedDict.](https://docs.python.org/3/library/collections.html#collections.OrderedDict)
    下的`ordereddict_use.py`，展示了如何使用`OrderedDict`创建一个排序后的字典：[https://docs.python.org/3/library/collections.html#collections.OrderedDict](https://docs.python.org/3/library/collections.html#collections.OrderedDict)
- en: '[PRE57]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: While `d` is a normal dictionary, sorting it in place and then passing it into
    `OrderedDict` creates a dictionary that is not only sorted, like a list, but maintains
    that ordered arrangement when entries are deleted. However, adding new keys puts
    them at the end of the dictionary, thus breaking the sort.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`d`是一个普通字典，但在就地排序后将其传递给`OrderedDict`创建的字典不仅像列表一样排序，而且在删除条目时保持有序排列。然而，添加新键会将它们放在字典的末尾，从而破坏排序。
- en: 'Note that the second argument to `OrderedDict` is a key that is generated by
    a lambda function. Lambda functions are simply anonymous functions: functions
    that don''t require a complete `def` statement to be created. They allow a function
    to operate where a variable or argument could be used, as they return a value
    like a normal function when processed.'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`OrderedDict`的第二个参数是一个由lambda函数生成的键。Lambda函数仅仅是匿名函数：不需要完整的`def`语句就可以创建的函数。它们允许函数在变量或参数可以使用的位置运行，因为当处理时，它们像正常函数一样返回一个值。
- en: In this case, in the first `OrderedDict`, the key is the value returned when
    the lambda function extracts the key from the dictionary. The second `OrderedDict`
    passes in the value of each dictionary item. The third `OrderedDict` uses a value
    equal to the length of each dictionary key.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，在第一个 `OrderedDict` 中，键是当 lambda 函数从字典中提取键时返回的值。第二个 `OrderedDict` 传递每个字典项的值。第三个
    `OrderedDict` 使用等于每个字典键长度的值。
- en: 'The following example shows how to use `move_to_end()`:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下示例展示了如何使用 `move_to_end()` 方法：
- en: '[PRE58]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: First, an `OrderedDict` object is created, using a short string that is parsed
    to generate the keys for the dictionary.
  id: totrans-334
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，创建了一个 `OrderedDict` 对象，使用一个简短的字符串解析以生成字典的键。
- en: The key `b` is moved to the end of the `OrderedDict`.
  id: totrans-335
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将键 `b` 移动到 `OrderedDict` 的末尾。
- en: 'The `join()` method is used to convert the list of strings that are the keys
    to a single string, otherwise you would get the following:'
  id: totrans-336
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `join()` 方法将字符串键的列表转换为单个字符串，否则你会得到以下结果：
- en: '[PRE59]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The next move takes the key *b* and moves it to the front. The final value is
    joined and printed to verify that the move worked correctly.
  id: totrans-338
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个操作将键 *b* 移动到前面。最终值被连接并打印出来以验证移动是否正确。
- en: '`ordereddict_stor_keys.py`, below, creates a class that retains the stored
    items in the order of keys that were added last:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下面的 `ordereddict_stor_keys.py` 创建了一个类，该类按照最后添加的键的顺序保留存储的项：
- en: '[PRE60]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This class has a single method that sets the key:value pair in the dictionary.
    The method is actually recursive; the act of calling itself is what allows the
    *memory* of remembering the order the keys were last inserted.
  id: totrans-341
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个类只有一个方法，用于在字典中设置键值对。实际上，该方法递归；调用自身的行为允许记住键最后插入的顺序。
- en: If the key argument already exists, the original entry is deleted and the insertion
    point is moved to the end of the dictionary.
  id: totrans-342
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果键参数已经存在，则删除原始条目并将插入点移动到字典的末尾。
- en: '`ordereddict_counter.py`, below, demonstrates using `OrderedDict` with `Counter`
    so the `Counter` can remember the order the elements are first encountered:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下面的 `ordereddict_counter.py` 展示了如何使用 `OrderedDict` 与 `Counter` 结合，以便 `Counter`
    可以记住首次遇到元素时的顺序：
- en: '[PRE61]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This class is somewhat unique as it inherits from two parent classes. Some people
    on the internet frown upon multiple inheritance because it can make code management
    difficult. Personally, this author considers whether the project really needs
    multiple inheritance or whether it could be accomplished with something else,
    such a decorator. This is not to say that multiple inheritance doesn't have its
    place, just that there should be a good reason for it.
  id: totrans-345
  prefs:
  - PREF_OL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个类有些独特，因为它从两个父类继承。互联网上的一些人不喜欢多重继承，因为它可能会使代码管理变得困难。个人而言，这位作者认为项目是否真的需要多重继承，或者是否可以用其他方式（如装饰器）完成，这并不是说多重继承没有其位置，只是应该有很好的理由。
- en: In this case, since we are making a unique class that combines the features
    of `Counter` and `OrderedDict`, there really isn't any other way to generate the
    solution without inheriting from those classes.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，由于我们正在创建一个结合了 `Counter` 和 `OrderedDict` 特性的独特类，实际上没有其他方法可以生成解决方案而不从这些类中继承。
- en: Two methods are defined in this class. Both methods use *name mangling* (double
    underscores) to create `private` instance methods without clashing with other
    methods of the same name. Name mangling essentially converts the method name to
    `classname__methodname`, so the underscored method is only associated with a particular
    class.
  id: totrans-347
  prefs:
  - PREF_OL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这个类中定义了两个方法。两个方法都使用 *名称改写*（双下划线）来创建不与其他同名方法冲突的 `private` 实例方法。名称改写本质上将方法名称转换为
    `classname__methodname`，因此下划线方法仅与特定类相关联。
- en: '`__repr__` generates a string representation of the class; otherwise, when
    attempting to print the class directly, all that would be shown would be the memory
    address of the class object. The string that is returned in this method is just
    the class name and the dictionary object.'
  id: totrans-348
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__repr__` 生成类的字符串表示形式；否则，当直接尝试打印类时，只会显示类对象的内存地址。此方法返回的字符串只是类名和字典对象。'
- en: The `__reduce__` method performs two things. [https://docs.python.org/3.6/library/pickle.html#object](https://docs.python.org/3.6/library/pickle.html#object).
    `__reduce__` indicates that the method is used by `pickle` to create a tuple of
    a callable object (in this instance, the class itself) and a tuple of arguments
    for the callable object, that is, the dictionary. In addition, the `copy` protocol
    implements `__reduce__` to ensure copying objects works correctly.
  id: totrans-349
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__reduce__` 方法执行两项操作。[https://docs.python.org/3.6/library/pickle.html#object](https://docs.python.org/3.6/library/pickle.html#object)
    `__reduce__` 指示该方法由 `pickle` 使用来创建一个可调用对象（在本例中，是类本身）的元组以及一个用于可调用对象的参数元组，即字典。此外，复制协议实现
    `__reduce__` 以确保对象的复制正确工作。'
- en: 'As mentioned in the *pickle* documentation, using `__reduce__` directly in
    a class can lead to errors and higher-level interfaces should be used. `ordereddict_reduce.py`,
    below, is an example of when using it can help, as it actually does play a part
    in copying `OrderedCounter` objects:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如 *pickle* 文档中所述，直接在类中使用 `__reduce__` 可能会导致错误，应使用高级接口。下面的 `ordereddict_reduce.py`
    是使用它时可以提供帮助的示例，因为它实际上在复制 `OrderedCounter` 对象时发挥了作用：
- en: '[PRE62]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Now, take away the `__reduce__` method:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，去掉 `__reduce__` 方法：
- en: '[PRE63]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Implementing defaultdict
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现 `defaultdict`
- en: Another dictionary subclass, `defaultdict` calls a factory function to provide
    missing values; basically, it creates any items that you try to access, but only
    if they don't currently exist. This way, you don't get `KeyError` when trying
    to access a non-existent key.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个字典子类 `defaultdict` 调用工厂函数以提供缺失的值；基本上，它创建任何你尝试访问的项目，但仅当它们当前不存在时。这样，在尝试访问不存在的键时，你不会得到
    `KeyError`。
- en: 'All the standard dictionary methods are available, as well as the following:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 所有标准字典方法都可用，以及以下方法：
- en: '`__missing__(key)`: This method is used by the `dict` class `__getitem__()`
    method when the requested key is not found. Whatever key it returns (or an exception
    if no key is present) is passed to `__getitem__()`, which processes it accordingly.'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__missing__(key)`: 当请求的键未找到时，`dict` 类的 `__getitem__()` 方法会使用此方法。它返回的任何键（或如果没有键则抛出异常）都会传递给
    `__getitem__()`，然后根据需要进行处理。'
- en: Assuming the `default_factory` is not `None`, this method calls the factory
    to receive a default value for `key`, which is then placed in the dictionary as
    the `key`, and then returns back to the caller. If the factory value is `None`,
    then an exception is thrown with the `key` as the argument. If the `default_factory`
    raises an exception on its own, then the exception is passed along unaltered.
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 假设 `default_factory` 不是 `None`，此方法会调用工厂以获取 `key` 的默认值，然后将该值作为 `key` 放入字典中，然后返回给调用者。如果工厂值是
    `None`，则抛出带有 `key` 作为参数的异常。如果 `default_factory` 自身抛出异常，则异常会原样传递。
- en: The `__missing__()` method is only used with `__getitem__()`; all other dictionary
    methods are ignored. Thus, the `default_factory` can only be accessed via this
    method.
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`__missing__()` 方法仅与 `__getitem__()` 一起使用；所有其他字典方法都被忽略。因此，`default_factory`
    只能通过此方法访问。'
- en: '`default_factory`: While not a method, it is used as an attribute for the `__missing__()`
    method, it is initialized by the first argument to the dictionary constructor,
    if available; defaults to `None` if no argument is provided.'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`default_factory`: 虽然它不是一个方法，但作为 `__missing__()` 方法的属性使用，它由字典构造函数的第一个参数初始化（如果有的话）；如果没有提供参数，则默认为
    `None`。'
- en: How to do it...
  id: totrans-361
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'The following examples are taken from the Python documentation at [https://docs.python.org/3/library/collections.html#collections.defaultdict](https://docs.python.org/3/library/collections.html#collections.defaultdict):'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例取自 Python 文档中的 [https://docs.python.org/3/library/collections.html#collections.defaultdict](https://docs.python.org/3/library/collections.html#collections.defaultdict)：
- en: 'A list is a common source for `default_factory`, as it makes it easy to group
    a sequence of key:value pairs into a dictionary of lists, as follows:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列表是 `default_factory` 的常见来源，因为它可以轻松地将一系列键：值对组合成列表字典，如下所示：
- en: '[PRE64]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: First, a list of tuples is created. The tuples match a string with an integer.
  id: totrans-365
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，创建一个元组列表。这些元组匹配一个字符串和一个整数。
- en: A `defaultdict` is created using an empty list as the factory argument.
  id: totrans-366
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用空列表作为工厂参数创建 `defaultdict`。
- en: The list of tuples is iterated through, assigning the tuple key:value pairs
    to the `defaultdict` list's factory.
  id: totrans-367
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遍历元组列表，将元组键：值对分配给 `defaultdict` 列表的工厂。
- en: When the sorted dictionary is printed, it shows that the `defaultdict` created
    a new key for each new item from the tuple's list. If a key was already present
    in the dictionary, then the tuple's value was added to the key's value as a new
    item in a list via the `append` function. Basically, the tuple's list was shorted
    to a key:value pairing that identified all the values related to a particular
    key.
  id: totrans-368
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当打印排序后的字典时，它显示`defaultdict`为元组列表中的每个新项创建了一个新键。如果一个键已经存在于字典中，那么元组的值将通过`append`函数添加到键的值作为列表中的新项。基本上，元组的列表被缩短为一个键:值对，该对识别与特定键相关的所有值。
- en: 'Another way to perform the previous operation is to use the `dict` class `setdefault()`
    method. However, `setdefault()` can be slower and more complex than using a `defaultdict`:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行之前操作的另一种方法是使用`dict`类的`setdefault()`方法。然而，`setdefault()`可能比使用`defaultdict`慢且复杂：
- en: '[PRE65]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: In this case, an empty dictionary is created (the same tuple's list is used
    in this example).
  id: totrans-371
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这种情况下，创建了一个空字典（在这个例子中使用了相同的元组列表）。
- en: Next, the tuples are split into keys and values. The `setdefault()` method is
    used to assign a key with a blank value to the dictionary, then the value is added
    to the key's empty list (or appended to an existing value).
  id: totrans-372
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，元组被拆分为键和值。使用`setdefault()`方法将一个带有空值的键分配给字典，然后值被添加到键的空列表中（或者追加到现有的值）。
- en: While the processing time for `setdefault()` may be very close to `defaultdict`
    for a small script such as this, it can add up for larger projects. In addition,
    using `setdefault()` doesn't look as intuitive as the `defaultdict` code.
  id: totrans-373
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然`setdefault()`的处理时间可能非常接近`defaultdict`，但对于像这样的小脚本，它可能会在大型项目中累积。此外，使用`setdefault()`看起来不如`defaultdict`代码直观。
- en: 'If the factory is set to an integer, the `defaultdict` can be used for counting:'
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果工厂设置为整数，可以使用`defaultdict`进行计数：
- en: '[PRE66]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: In this example, a string is set, followed by a `defaultdict` using an integer
    as the `default_factory`.
  id: totrans-376
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这个例子中，设置了一个字符串，然后使用整数作为`default_factory`的`defaultdict`。
- en: Next, for each character in the string, an incrementer is created to count each
    character as the string is iterated through. As each character is looked at, it
    is checked to see whether it already exists in the dictionary. If not, the factory
    calls the `int()` function to generate a default count equal to zero. Then, as
    the rest of the string is walked through, new values receive a count of zero while
    existing values are incremented.
  id: totrans-377
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，对于字符串中的每个字符，创建一个计数器来在遍历字符串时计数每个字符。在查看每个字符时，会检查它是否已经存在于字典中。如果没有，工厂调用`int()`函数生成一个默认计数等于零。然后，在遍历字符串的其余部分时，新值接收一个零计数，而现有值则递增。
- en: The final dictionary is sorted and the contents displayed. In this case, the
    quantity of each character in the initial string is printed to the screen.
  id: totrans-378
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最终的字典被排序并显示其内容。在这种情况下，初始字符串中每个字符的数量被打印到屏幕上。
- en: 'An alternative to the previous example is to use lambda functions. Because
    `int()` always returns zero, generating an alternate starting value (which could
    be type, not just an integer) can be accomplished with a (functionally) empty
    lambda:'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之前示例的一个替代方法是使用lambda函数。因为`int()`总是返回零，可以通过一个（功能上）空的lambda生成一个替代的起始值（这可以是类型，而不仅仅是整数）：
- en: '[PRE67]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: In this example, the `constant_factory` function accepts a value and then returns
    that value to the caller.
  id: totrans-381
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这个例子中，`constant_factory`函数接受一个值，然后将其返回给调用者。
- en: The `defaultdict` uses `constant_factory` to generate whatever value is passed
    in; in this case, it is a string.
  id: totrans-382
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`defaultdict`使用`constant_factory`生成传递给它的任何值；在这种情况下，它是一个字符串。'
- en: The `defaultdict` is updated to pass in key arguments.
  id: totrans-383
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`defaultdict`被更新以传递键参数。'
- en: The values mapped to the dictionary keys are processed. Since an object is missing
    from the key arguments that were passed in, the lambda function provides it via
    the string that was passed to it.
  id: totrans-384
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射到字典键的值被处理。由于从传递给键参数的对象中缺少一个，lambda函数通过传递给它的字符串提供它。
- en: 'If the `default_factory` is giving the `set` type as an argument, the `defaultdict`
    can be used to create a dictionary of sets:'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`default_factory`将`set`类型作为参数，可以使用`defaultdict`创建一个集合的字典：
- en: '[PRE68]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Here, a list of tuples is created. The `defaultdict` is provided with an empty
    `set` as the factory argument.
  id: totrans-387
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这里，创建了一个元组列表。将空`set`作为工厂参数提供给`defaultdict`。
- en: The tuple's list is iterated through, generating the keys and values for the
    dictionary from the tuples. The values are added to the sets associated with the
    keys.
  id: totrans-388
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遍历元组的列表，从元组中生成字典的键和值。值被添加到与键关联的集合中。
- en: Printing the dictionary items shows how the various, duplicate tuples in the
    list have been combined into two dictionary mappings.
  id: totrans-389
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印字典项显示了列表中的各种重复元组是如何合并成两个字典映射的。
- en: Implementing UserDict
  id: totrans-390
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现 UserDict
- en: UserDict is a wrapper for dictionaries that makes it easier to subclass the
    `dict` class. It has been largely replaced by the ability to subclass `dict` directly,
    but it does make it easier to work with as it allows the underlying dictionary
    to be accessible as an attribute. Its primary use is for backwards-compatibility,
    that is, versions older then Python 2.2, so if you don't need the compatibility,
    it is generally better to just subclass `dict`*.*
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: UserDict 是字典的包装器，使得子类化 `dict` 类更加容易。它已经被直接子类化 `dict` 的能力所取代，但它确实使得工作更加容易，因为它允许底层字典作为属性访问。其主要用途是向后兼容，即
    Python 2.2 之前的版本，所以如果你不需要兼容性，通常最好是直接子类化 `dict`*.*
- en: 'The only special thing the `UserDict` has beyond the normal dictionary operations
    is a single attribute:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserDict` 除了正常的字典操作之外，只有一个特殊属性：'
- en: '`data`: A real dictionary to hold the contents of the `UserDict` class'
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data`：一个真实的字典，用于保存 `UserDict` 类的内容'
- en: When a `UserDict` is created, it accepts an optional argument of the initial
    data it is to hold; this initial data is accessible by the `data` attribute.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建 `UserDict` 时，它接受一个可选参数，即它要持有的初始数据；这个初始数据可以通过 `data` 属性访问。
- en: How to do it...
  id: totrans-395
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: '`UserDict` is very simple to use. Create an instance of a `UserDict` and provide
    a mapping to it:'
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`UserDict` 非常简单易用。创建一个 `UserDict` 实例并向其提供一个映射：'
- en: '[PRE69]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'If you call the instance directly, it functions just like a normal dictionary,
    as expected:'
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你直接调用实例，它将像预期的正常字典一样工作：
- en: '![](img/146b2128-a9c5-48ad-8716-68f07a0ed4b4.png)'
  id: totrans-399
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/146b2128-a9c5-48ad-8716-68f07a0ed4b4.png)'
- en: 'If you use the `data` attribute, you get the same results with the `UserDict`
    instance. However, because normal dictionaries don''t support this attribute,
    you get an error, as follows:'
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你使用 `data` 属性，你将得到与 `UserDict` 实例相同的结果。然而，因为正常字典不支持此属性，你会得到一个错误，如下所示：
- en: '[PRE70]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'To get to the items in the dictionary, you have to either iterate over them
    or call `items()`. While the `UserDict` instance supports the same methods, the
    view returned by `items()` is noticeably different:'
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要访问字典中的项，你必须遍历它们或调用 `items()`。虽然 `UserDict` 实例支持相同的方法，但 `items()` 返回的视图有明显的不同：
- en: '[PRE71]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Notice that the dictionary object returns a tuple of key/values. The `UserDict`
    returns an actual dictionary object. Depending on what you are doing, this difference
    can be important, as is the ability to use the `data` attribute to access the
    dictionary.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到字典对象返回一个键/值元组。`UserDict` 返回实际的字典对象。根据你所做的工作，这个差异可能很重要，正如使用 `data` 属性访问字典的能力一样。
- en: Implementing UserList
  id: totrans-405
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现 UserList
- en: This wrapper is similar to `UserDict`, except it applies to lists rather than
    dictionaries. Its main use is for creating a base class for list-like subclasses
    that allow for inheritance and method overriding or new methods. This allows for
    new functionality within lists.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 这个包装器类似于 `UserDict`，但它应用于列表而不是字典。其主要用途是创建允许继承和方法重写或新方法的列表子类的基础类。这允许在列表中添加新功能。
- en: Again, like `UserDict`, `UserList` has been largely superseded by the ability
    to subclass directly from `list`. But, again, it may be easier to use `UserList`
    than a `list` subclass. While `UserList` has the methods and capabilities of normal
    lists, it adds the `data` attribute to hold the underlying `list` object contents.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，像 `UserDict` 一样，`UserList` 已经被直接从 `list` 继承的能力所取代。但是，再次，使用 `UserList` 可能比使用列表子类更容易。虽然
    `UserList` 具有正常列表的方法和能力，但它添加了 `data` 属性来保存底层列表对象的内容。
- en: How to do it...
  id: totrans-408
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: '`userlist_import.py` shows how to use `UserList` as a superclass for a new
    list-like object. In this case, we are going to create a class that allows a list
    to be added by simply assigning values to it, rather than having to call the `append()`
    function:'
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`userlist_import.py` 展示了如何将 `UserList` 作为新列表对象的超类使用。在这种情况下，我们将创建一个类，允许通过简单地对该列表赋值来添加列表，而不是必须调用
    `append()` 函数：'
- en: '![](img/ed9c0077-7bed-4eb7-9b0f-a1462b42064d.png)'
  id: totrans-410
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ed9c0077-7bed-4eb7-9b0f-a1462b42064d.png)'
- en: First, in *line 11*, `UserList` must be imported from the *collections* module.
  id: totrans-411
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，在*第11行*，需要从*collections*模块导入`UserList`。
- en: Next, the `ExtendList` class is created in *line 12* as a subclass of `UserList`.
    This provides list functionality to any `ExtendList` instance. A setter method
    is created, accepting an integer and a value. If the integer provided equals the
    length of the list, then the value argument is appended to the list. Otherwise,
    the value at index `i` is replaced with a new value.
  id: totrans-412
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，在*第12行*创建了一个名为`ExtendList`的类，它是`UserList`的子类。这为任何`ExtendList`实例提供了列表功能。创建了一个setter方法，它接受一个整数和一个值。如果提供的整数等于列表的长度，则将值参数追加到列表中。否则，索引`i`处的值将被新的值替换。
- en: An instance of the class is created in *line 13* and populated with a range
    of numbers in *line 14*.
  id: totrans-413
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*第13行*创建了一个类的实例，并在*第14行*用一系列数字填充。
- en: Printing the instance (*line 15*) shows that the range of numbers was accepted
    via assignment, rather than using `append()`.
  id: totrans-414
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印实例（*第15行*）显示，通过赋值而不是使用`append()`接受了数字的范围。
- en: Manually extending the list (*line 16*) is allowed by simply assigning a value
    to the given index position.
  id: totrans-415
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过简单地给指定的索引位置赋值来手动扩展列表（*第16行*）。
- en: Replacing a value of a given index position is available as well, as shown in
    *line 18*.
  id: totrans-416
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以替换给定索引位置的值，如*第18行*所示。
- en: Finally, *line 20* shows that, like a normal list, if attempting to access an
    index value outside the existing range of the list, an error is received.
  id: totrans-417
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，*第20行*显示，就像正常的列表一样，如果尝试访问列表现有范围之外的索引值，将收到错误。
- en: There's more...
  id: totrans-418
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: When subclassing `UserList`, the subclass is expected to provide a constructor
    that can be called with either no arguments or one argument. If a list operation
    is expected to return a new sequence, it attempts to create an instance of the
    actual implementation class. Thus, it expects the constructor to provide the ability
    to be called with a single parameter, that is, the sequence object that serves
    as the source of data.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 当子类化`UserList`时，期望子类提供一个可以无参数或有一个参数调用的构造函数。如果期望列表操作返回一个新的序列，它将尝试创建实际实现类的实例。因此，它期望构造函数能够接受单个参数，即作为数据源的服务于序列对象。
- en: It is possible to create a class that doesn't follow this requirement, but all
    the special methods of the derived class must be overridden, as functionality
    using the default methods cannot be guaranteed.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 可以创建一个不遵循此要求的类，但所有派生类的特殊方法都必须被重写，因为使用默认方法的功能不能得到保证。
- en: Implementing UserString
  id: totrans-421
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现`UserString`
- en: Just like `UserDict` and `UserList`, `UserString` is a string wrapper that allows
    easier subclassing of strings due to providing the underlying string as an attribute.
    The preferred way to do this is to subclass `string` directly; this class is provided
    mainly due to backwards-compatibility or simple cases where subclassing `string`
    is overkill for functionality.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`UserDict`和`UserList`一样，`UserString`是一个字符串包装器，它通过提供底层字符串作为属性，使得字符串的子类化更容易。这样做的方式是直接子类化`string`；这个类主要提供是为了向后兼容性或简单的情况，在这些情况下，子类化`string`对于功能来说过于冗余。
- en: While all string methods are available, such as `UserDict` and `UserList`, `UserString`
    adds the `data` attribute for easy access to the underlying string object. The
    contents of `UserString` are initially set to a copy of some type of sequence;
    the sequence can be bytes, a string, another `UserString` or subclass, or any
    other sequence object that can be converted to a string.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然所有字符串方法都是可用的，例如`UserDict`和`UserList`，但`UserString`添加了`data`属性，以便更容易地访问底层字符串对象。`UserString`的内容最初设置为某种类型的序列的副本；该序列可以是字节、字符串、另一个`UserString`或其子类，或任何其他可以转换为字符串的序列对象。
- en: How to do it...
  id: totrans-424
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: '`userstring_import.py` is simple in that it shows how to create a method to
    append a sequence to a string, much like adding more items to a list:'
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`userstring_import.py`很简单，它展示了如何创建一个方法来将序列追加到字符串中，就像向列表中添加更多项一样：'
- en: '[PRE72]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The first step, as always, is to import the `UserString` class from the `collections`
    module.
  id: totrans-427
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一步，像往常一样，是从`collections`模块导入`UserString`类。
- en: Next, a simple subclass of `AppendString` is created. The only method for it
    is `append()`, which takes a single sequence as its argument and returns the instance
    data concatenated with whatever sequence has been provided.
  id: totrans-428
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，创建了一个简单的`AppendString`子类。它的唯一方法是`append()`，它接受一个序列作为其参数，并返回实例数据与提供的任何序列连接的结果。
- en: An instance of the `AppendString` class is created, with a simple string passed
    in as its argument.
  id: totrans-429
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建了一个 `AppendString` 类的实例，并传入一个简单的字符串作为其参数。
- en: The class's method is tested by adding another string, and the final contents
    of the instance is printed. The printed string shows that the new string has been
    added to the end of the original argument.
  id: totrans-430
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过添加另一个字符串来测试类的函数，并打印实例的最终内容。打印的字符串显示，新字符串已被添加到原始参数的末尾。
- en: Next, we demonstrate that regular strings don't have the ability to concatenate
    strings using an `append()` method. A string is created and then a separate string
    is attempted to be appended to it. As the `str` class doesn't have an `append()`
    method, an error is generated.
  id: totrans-431
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们演示了常规字符串没有使用 `append()` 方法连接字符串的能力。创建了一个字符串，然后尝试将其附加到另一个字符串上。由于 `str`
    类没有 `append()` 方法，因此会生成错误。
- en: Improving Python collections
  id: totrans-432
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进 Python 集合
- en: This section is designed to showcase different ways to improve your coding methodology
    by using the various Python collections available to you. Not every collections
    datatype is represented, but some interesting use cases are explored for certain
    containers.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 这个部分旨在展示通过使用可用的各种 Python 集合来改进你的编码方法的不同方式。并不是每个集合数据类型都有代表，但某些容器的一些有趣的用例被探索了。
- en: How to do it...
  id: totrans-434
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: The following examples are separated by the particular collection they utilize.
    iPython will be used to interactively create these examples.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例根据它们使用的特定集合进行分隔。我们将使用 iPython 交互式地创建这些示例。
- en: Default dictionaries
  id: totrans-436
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 默认字典
- en: 'For this example (`book_catalog.py`), we will create a simplified ordering
    scheme for book categories; the `default_factory` will be an anonymous function
    that returns a string:'
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个示例（`book_catalog.py`），我们将为书籍类别创建一个简化的排序方案；`default_factory` 将是一个匿名函数，它返回一个字符串：
- en: '![](img/a1277e87-dbec-41c1-90d1-a16a8468525d.png)'
  id: totrans-438
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a1277e87-dbec-41c1-90d1-a16a8468525d.png)'
- en: The *line 1* simply imports the `collections` module, allowing access to the
    `defaultdict` class.
  id: totrans-439
  prefs:
  - PREF_OL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第1行* 简单地导入了 `collections` 模块，允许访问 `defaultdict` 类。'
- en: The *line 2* creates an instance of `defaultdict`. The argument for the factory
    is a simple string indicating that the selected item doesn't exist.
  id: totrans-440
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第2行* 创建了一个 `defaultdict` 的实例。工厂函数的参数是一个简单的字符串，表示所选的项目不存在。'
- en: The *lines 3* – *line 6* create items for the dictionary.
  id: totrans-441
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第3行* – *第6行* 为字典创建条目。'
- en: The *line 7* prints the default representation of the dictionary.
  id: totrans-442
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第7行* 打印了字典的默认表示形式。'
- en: The *line 8* is a more human-readable representation of the dictionary. This
    just makes it easier to see the key:value mappings.
  id: totrans-443
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第8行* 是字典的一个更易于阅读的表示形式。这只是为了更容易地看到键：值映射。'
- en: The *line 9* calls for a non-existent entry. Since it hasn't been added to the
    dictionary yet, a response is provided indicating that it is not available.
  id: totrans-444
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第9行* 调用了一个不存在的条目。由于它还没有被添加到字典中，所以提供了一个响应，表明它不可用。'
- en: The *line 10* is another printing of the mappings in the dictionary. However,
    in this instance, it shows that the key `z` has been added to the dictionary,
    with the default value ascribed to it.
  id: totrans-445
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第10行* 是字典映射的另一种打印。然而，在这个例子中，它显示键 `z` 已被添加到字典中，并赋予了默认值。'
- en: 'A common programming requirement is to group list elements based on particular
    criteria. One approach is to create a dictionary that is indexed by the criteria.
    For example, a class is created that gets a person''s age and returns a string
    representation (`class_adult.py`):'
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 常见的编程需求之一是根据特定标准对列表元素进行分组。一种方法是为标准创建一个按索引的字典。例如，创建了一个类，它获取一个人的年龄并返回一个字符串表示（`class_adult.py`）：
- en: '[PRE73]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: This creates the class `Adult`. Two methods are defined; `__init__()` simply
    populates the `age` variable when an instance is created. The `__repr__()` allows
    us to print a string representation of the value contained in the `age` variable
    without having the instance print its memory address instead.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了 `Adult` 类。定义了两个方法；`__init__()` 在创建实例时简单地填充 `age` 变量。`__repr__()` 允许我们打印
    `age` 变量中包含的值的字符串表示，而不是让实例打印其内存地址。
- en: 'To populate instances for this class, we will assign ages manually in `adult_list_comp.py`,
    as we want to see how to group the same values together:'
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了填充这个类的实例，我们将在 `adult_list_comp.py` 中手动分配年龄，因为我们想看看如何将相同的值分组在一起：
- en: '[PRE74]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: In this case, a list comprehension is used to easily and quickly create all
    the instances of the `Adult` class, rather than setting up a `for` loop.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用列表推导式轻松快速地创建 `Adult` 类的所有实例，而不是设置一个 `for` 循环。
- en: 'One way to group these individuals by age is by iterating through the instances,
    populating a dictionary, and then grouping them via lists, as shown below in `age_groups.py`:'
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这些个体按年龄分组的一种方法是通过遍历实例，填充字典，然后通过列表进行分组，如下所示在`age_groups.py`中：
- en: '![](img/56ae5955-c2c0-4dd7-9c64-6667efb3adbf.png)'
  id: totrans-453
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/56ae5955-c2c0-4dd7-9c64-6667efb3adbf.png)'
- en: In *line 3* creates an empty dictionary.
  id: totrans-454
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第3行创建了一个空字典。
- en: In *line 4* is a `for` loop that iterates through all the instances of `Adult`
    in the `persons` list. For each instance, the variable `age` is set to the instance's
    `age` value. If that value is already present in the dictionary, then a new item
    is appended to the list within the dictionary. If the age value isn't already
    in the dictionary, then a new entry is created.
  id: totrans-455
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第4行是一个`for`循环，遍历`persons`列表中所有`Adult`实例。对于每个实例，变量`age`被设置为实例的`age`值。如果该值已经在字典中，则将新项追加到字典内的列表中。如果年龄值不在字典中，则创建一个新的条目。
- en: In *line 5* shows the different age groups within the dictionary. In this case,
    out of ten entries, only seven groups have been created.
  id: totrans-456
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第5行显示了字典中的不同年龄组。在这种情况下，在十个条目中，只有创建了七个组。
- en: In *line 6* prints all the key:value pairs in the dictionary; this shows us
    greater detail of how the dictionary is generated. Looking closely, we can see
    that each unique age in the `persons` list has its own key. The values associated
    with each key are all individual values in `persons` that match the key. In other
    words, all duplicate values are placed in the same group.
  id: totrans-457
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第6行打印了字典中的所有键值对；这显示了字典是如何生成的更详细的情况。仔细观察，我们可以看到`persons`列表中的每个独特年龄都有一个自己的键。与每个键关联的值都是`persons`中与键匹配的单独值。换句话说，所有重复的值都被放在同一个组中。
- en: In *line 7* is an alternative way to show the dictionary items. This makes it
    easier to see how the duplicate entries are actually tied to their respective
    keys.
  id: totrans-458
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第7行是一个显示字典项的替代方法。这使得查看重复条目实际上是如何与各自的键相关联的更容易。
- en: 'An alternative way to do this, and a much cleaner way, is to use a `defaultdict`,
    as follows in `defaultdict_age_groups.py`:'
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 做这件事的另一种方法，并且是一种更干净的方法，是使用`defaultdict`，如下所示在`defaultdict_age_groups.py`中：
- en: '[PRE75]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The *line 8* imports `defaultdict` from the `collections` module.
  id: totrans-461
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第8行从`collections`模块导入`defaultdict`。
- en: The *line 9* creates a `defaultdict` instance that accepts an empty list that
    will create values for the dictionary if a key is missing. Thus, each new key
    will have a list automatically generated for it.
  id: totrans-462
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第9行创建了一个接受空列表的`defaultdict`实例，如果键缺失，将为字典创建值。因此，每个新键都将自动为其生成一个列表。
- en: The *line 10* is a simplified version of line 4, eliminating a lot of the busy
    work code.
  id: totrans-463
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第10行是第4行的简化版本，消除了大量的繁琐代码。
- en: The *line 11* is another printing of the dictionary, showing that the same results
    are achieved using a `defaultdict` rather than the more brute-force approach previously.
  id: totrans-464
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第11行是字典的另一种打印方式，显示使用`defaultdict`而不是之前更粗暴的方法也能达到相同的结果。
- en: Named tuples
  id: totrans-465
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名元组
- en: '`namedtuples_sales.py`, below, will create a restaurant receipt, indicating
    the store ID, sales date, amount, and number of guests:'
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下面的`namedtuples_sales.py`将创建一个餐厅收据，指示商店ID、销售日期、金额和客人数量：
- en: '![](img/b148cd53-e90a-4063-ac7b-559d336720f8.png)'
  id: totrans-467
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b148cd53-e90a-4063-ac7b-559d336720f8.png)'
- en: The *line 9* shows the creation of the named tuple. The first argument to the
    named tuple is the name of the tuple subclass. The remaining arguments are the
    fields for the tuple.
  id: totrans-468
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第9行显示了命名元组的创建。命名元组的第一个参数是元组子类的名称。其余参数是元组的字段。
- en: The *lines 10* and 11 create two different restaurants, showing receipts for
    the same day.
  id: totrans-469
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第10行和第11行创建了两个不同的餐厅，显示了同一天的收入。
- en: The *line 12* and *line 13* show how to access the individual fields within
    the different tuples using the field names rather than the indexes.
  id: totrans-470
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第12行和第13行显示了如何使用字段名而不是索引来访问不同元组中的单个字段。
- en: The *line 14* shows that these restaurant instances are, indeed, actual tuples.
    They can be iterated over like regular sequences, using an integer to identify
    each field's index.
  id: totrans-471
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第14行显示这些餐厅实例确实是实际的元组。它们可以像常规序列一样迭代，使用整数来标识每个字段的索引。
- en: 'One usual way to create named tuples without having to create each one individually
    is to simply convert an iterable object to a `namedtuple` using `_make`. The input
    iterable can be a list, tuple, or dictionary. In `receipts_make.py`, we take a
    list, with values that meet the requirements for the `namedtuple` fields, and
    convert it directly to a named tuple:'
  id: totrans-472
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建命名元组的一种常见方法是不必逐个创建每个实例，只需将可迭代对象转换为 `namedtuple` 使用 `_make`。输入的可迭代对象可以是列表、元组或字典。在
    `receipts_make.py` 中，我们取一个列表，其值符合 `namedtuple` 字段的要求，并将其直接转换为命名元组：
- en: '[PRE76]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The *line 18* creates the list used for the conversion.
  id: totrans-474
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第18行* 创建了用于转换的列表。'
- en: The *line 19* uses the `_make` method to convert the list to a `namedtuple`
    object.
  id: totrans-475
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第19行* 使用 `_make` 方法将列表转换为 `namedtuple` 对象。'
- en: The *line 20* prints out the new `namedtuple` instance, showing that the data
    in the converted `namedtuple` is no different than making the `namedtuple` manually.
  id: totrans-476
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第20行* 打印出新的 `namedtuple` 实例，显示转换后的 `namedtuple` 中的数据与手动创建的 `namedtuple` 没有区别。'
- en: 'If you just want to see what the field names are in a named tuple object, you
    can use the `_fields` identifier:'
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你只想查看命名元组对象中的字段名，可以使用 `._fields` 标识符：
- en: '[PRE77]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The final example shows how named tuples can be used when working with CSV files,
    allowing data access via names rather than indexes. This way, the data is easier
    to work with, as there is meaning ascribed to each field, rather than trying to
    figure out which index value applies to the desired field.
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一个示例展示了在处理CSV文件时如何使用命名元组，允许通过名称而不是索引访问数据。这样，数据更容易处理，因为每个字段都有意义，而不是试图确定哪个索引值适用于所需的字段。
- en: 'Of course, you have to have a CSV file available to use this example. `sales_csv.py`
    shows that the structure is easy, as all you have to have are four entries per
    line, signifying the store ID, the sales date, the sales amount, and the total
    number of guests:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你必须有一个可用的CSV文件才能使用这个示例。`sales_csv.py` 显示结构很简单，因为你只需要每行有四个条目，分别表示商店ID、销售日期、销售金额和总客人数：
- en: '[PRE78]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: In *line 22*, we import the `reader` method from the `csv` module.
  id: totrans-482
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *第22行*，我们从 `csv` 模块中导入 `reader` 方法。
- en: The *line 23* shows one way to import the CSV file. The traditional *with open...*
    methodology is used to ensure that the file is automatically closed when it is
    no longer being used.
  id: totrans-483
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第23行* 展示了导入CSV文件的一种方法。使用传统的 *with open...* 方法确保文件在不再使用时自动关闭。'
- en: Each field in the CSV file is read into a variable, which is then iterated over.
    The CSV fields are converted to a named tuple via the `_make` method.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: CSV文件中的每个字段都被读入一个变量，然后对其进行迭代。CSV字段通过 `_make` 方法转换为命名元组。
- en: Finally, the total amount of sales for all the entries in the CSV file are summed
    and put into a variable. Note that the values are cast to a `float` prior to being
    summed, to ensure no errors are generated due to mismatching types.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将CSV文件中所有条目的总销售额汇总并放入一个变量中。注意，在求和之前，将值转换为 `float`，以确保不会由于类型不匹配而产生错误。
- en: In *line 24*, the total sales are printed out, showing that the records in the
    CSV file were properly retrieved and converted.
  id: totrans-486
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *第24行*，打印出总销售额，显示CSV文件中的记录已被正确检索和转换。
- en: Ordered dictionaries
  id: totrans-487
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有序字典
- en: 'Ordered dictionaries are an ideal tool for ranking problems, such as student
    grades or competitions. The following example looks at student grades, where the
    dictionary contains a key equal to the student''s name and its value is a test
    grade. The problem is to sort the students by test score, as shown in `student_grades.py`:'
  id: totrans-488
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有序字典是解决排名问题（如学生成绩或比赛）的理想工具。以下示例查看学生成绩，其中字典包含一个等于学生姓名的键，其值是测试成绩。问题是按测试分数对学生进行排序，如
    `student_grades.py` 中所示：
- en: '[PRE79]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: We create a blank dictionary in *line 30* and then populate it with the items
    in *lines 31* – *line 35*.
  id: totrans-490
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在 *第30行* 创建了一个空字典，然后使用 *第31行* 到 *第35行* 中的项填充它。
- en: The *line 36* is just a print out of the normal, randomized dictionary item
    ordering.
  id: totrans-491
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第36行* 只是打印出正常的、随机的字典项顺序。'
- en: In *line 37*, a traditional sort is performed, that is, sorting the entries
    based on key. Since the keys are strings, they are sorted alphabetically.
  id: totrans-492
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *第37行*，执行了传统的排序，即根据键排序。由于键是字符串，它们按字母顺序排序。
- en: 'An alternate sorting is performed in *line 38*: sort by value. In this case,
    the sorting is from lowest value to highest value.'
  id: totrans-493
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *第38行* 执行了另一种排序：按值排序。在这种情况下，排序是从最低值到最高值。
- en: To get a sorting of grades from highest to lowest, we use an inverted sorting-by-value
    in *line 39*.
  id: totrans-494
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要从最高到最低对成绩进行排序，我们在 *第39行* 使用了倒序排序。
- en: In *line 40*, we take the inverted sorting from *line 39* and use it to populate
    an `OrderedDict`.
  id: totrans-495
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *第40行*，我们从 *第39行* 的倒序排序中取出，并使用它来填充一个 `OrderedDict`。
- en: Printing out the `OrderedDict` instance in *line 41* shows that the dictionary
    has maintained the ordering of input values, rather than randomizing them, like
    in *line 36*.
  id: totrans-496
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *第41行* 打印出 `OrderedDict` 实例显示，该字典保持了输入值的顺序，而不是像 *第36行* 那样随机化它们。
- en: Looking at the collections – extended module
  id: totrans-497
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看collections – extended模块
- en: If you search PyPI, you will find the collections-extended module ([https://pypi.python.org/pypi/collections-extended/1.0.0](https://pypi.python.org/pypi/collections-extended/1.0.0)).
    Collections-extended expands the number of collections types available.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你搜索 PyPI，你会找到 collections-extended 模块（[https://pypi.python.org/pypi/collections-extended/1.0.0](https://pypi.python.org/pypi/collections-extended/1.0.0)）。Collections-extended
    扩展了可用的集合类型数量。
- en: 'The following classes are included:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 以下类包括：
- en: '`bag`: It is equivalent to a multiset, bags build upon the default *set* container
    by allowing multiple instances of the bag''s elements.'
  id: totrans-500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bag`：它与多重集等价，bags 通过允许 bag 的元素有多个实例来构建在默认的 *set* 容器之上。'
- en: A `bag` (also called a multiset in other languages) generalizes the concept
    of a set so that it allows multiple instances of elements. For example, *{a, a,
    b}*, and *{a, b}* are different bags, but part of the same set. Only hashable
    elements can be used in a `bag`. An important point about bags is the multiplicity
    of elements. Multiplicity is the the number of instances of an element in a specific
    bag, that is, how many duplicate values exist in a bag.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `bag`（在其他语言中也称为多重集）将集合的概念推广，使其允许元素有多个实例。例如，*{a, a, b}* 和 *{a, b}* 是不同的 bag，但它们是同一个集合的一部分。`bag`
    中只能使用可哈希的元素。关于 bag 的一个重要点是元素的多重性。多重性是指特定 bag 中元素实例的数量，即 bag 中有多少个重复值。
- en: '`setlist`: This creates an ordered, indexed collection with unique elements.
    `setlist` is used to create an object that is similar to an *ordered set*, except
    that its elements are accessible by index, not just a linked set. Two classes
    of `setlist` are provided: `setlist` and `frozensetlist`. Comparing two `setlist`
    object won''t work; while equality testing is fine, other comparisons (such as
    s1 > s2) won''t work as there is no way to specify whether to compare by order
    or by set comparison.'
  id: totrans-502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setlist`：这创建了一个有序、索引化的唯一元素集合。`setlist` 用于创建一个类似于 *有序集合* 的对象，但其元素可以通过索引访问，而不仅仅是通过链接集合。提供了两种
    `setlist` 类：`setlist` 和 `frozensetlist`。比较两个 `setlist` 对象不会工作；虽然等价性测试是可行的，但其他比较（如
    s1 > s2）不会工作，因为没有方法可以指定是按顺序比较还是按集合比较。'
- en: '`bijection`: It is a function that maps keys to unique values onto functions. A
    `bijection` is a function between two sets, where each element in one set is paired
    to exactly one element in the other set and vice versa. All elements are paired
    and no elements are unpaired. An easy way to picture this assigned seating: each
    individual has a single seat, each seat has a person assigned, no person is assigned
    to more than one seat, and no seat has more than one person sitting in it.'
  id: totrans-503
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bijection`：它是一个将键映射到唯一值的函数。`bijection` 是两个集合之间的函数，其中一个集合中的每个元素与另一个集合中的唯一元素配对，反之亦然。所有元素都配对，没有元素是未配对的。一个简单的方式来想象这种分配座位：每个人都有一个座位，每个座位都有人分配，没有人被分配给多个座位，也没有座位有超过一个人坐着。'
- en: '`RangeMap`: This maps ranges to values. A `RangeMap` maps ranges to values;
    in other words, ranges become keys that are mapped to values. All keys must be
    hashable and comparable to other keys, but don''t have to be the same type. When
    creating a `RangeMap` instance, a mapping can be provided, or the instance can
    start out empty. Each item is assumed to be the start of a range and its associated
    value. The end of the range is the next largest key in the mapping, so if a range
    is left open-ended, it will automatically be closed if a larger range starting
    value is provided.'
  id: totrans-504
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RangeMap`：它将范围映射到值。`RangeMap` 将范围映射到值；换句话说，范围成为映射到值的键。所有键都必须是可哈希的，并且可以与其他键比较，但不必是同一类型。在创建
    `RangeMap` 实例时，可以提供映射，或者实例可以一开始就是空的。每个项目都被假定为范围的开始及其关联的值。范围的结束是映射中下一个最大的键，所以如果范围是开放的，当提供一个较大的范围起始值时，它将自动关闭。'
- en: In addition to the preceding classes, hashable versions of bags and setlists
    are also included.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 除了上述类之外，还包括 bags 和 setlists 的可哈希版本。
- en: Getting ready
  id: totrans-506
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Collections-extended is available for installation from PyPI using `pip`:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: '`collections-extended`可以通过PyPI使用`pip`进行安装：'
- en: '[PRE80]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Normal usage is like other modules:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 正常使用类似于其他模块：
- en: '[PRE81]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: How to do it...
  id: totrans-511
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: We will talk about each collection class separately in the following examples.
    These examples are from [http://collections-extended.lenzm.net.](http://collections-extended.lenzm.net)
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的例子中，我们将单独讨论每个集合类。这些例子来自[http://collections-extended.lenzm.net.](http://collections-extended.lenzm.net)
- en: setlist
  id: totrans-513
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合列表
- en: '`ext_collections_setlist.py` demonstrates how to use `setlist`*:*'
  id: totrans-514
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ext_collections_setlist.py`演示了如何使用`集合列表`：'
- en: '[PRE82]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: First, `setlist` has to be imported. We also import the `string` class to provide
    access to its public module variables.
  id: totrans-516
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，必须导入`集合列表`。我们还导入了`string`类，以便访问其公共模块变量。
- en: A `setlist` instance is created, using the `string` class `ascii_lowercase`
    variable, which provides a string of all ASCII characters in lowercase.
  id: totrans-517
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建了一个`集合列表`实例，使用`string`类的`ascii_lowercase`变量，它提供了一个所有ASCII字符的小写字符串。
- en: The instance is printed, just to demonstrate what it contains.
  id: totrans-518
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印实例，只是为了演示它包含的内容。
- en: Several indexing operations are shown, demonstrating that `setlist` works like
    a list in terms of accessing items by index. Note that *reverse indexing* is available,
    that is, rather than accessing a variable via its index position, searching for
    a value returns its index position.
  id: totrans-519
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 几种索引操作被展示出来，证明了`集合列表`在通过索引访问项目方面像列表一样工作。注意，*反向索引*是可用的，也就是说，不是通过变量的索引位置访问变量，而是通过搜索值返回其索引位置。
- en: bags
  id: totrans-520
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 袋子
- en: 'Bags can be compared to sets, including other bags. Following, we see how bags
    are evaluated compared to sets:'
  id: totrans-521
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 袋子可以与集合比较，包括其他袋子。以下我们看到袋子是如何与集合比较的：
- en: '[PRE83]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: First, comparison shows that an empty bag is equal to an empty set.
  id: totrans-523
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，比较显示空袋子等于空集合。
- en: Next, the same, single element in both shows that they are still comparatively
    equal.
  id: totrans-524
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，两个袋子中相同的单个元素显示它们仍然在比较上相等。
- en: Adding a new element to a bag upsets the balance with a single-element set,
    as expected. The same thing happens when an extra element is added to the set
    and compared to a single-element bag.
  id: totrans-525
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向袋子中添加新元素会破坏与单元素集合的平衡，正如预期的那样。当向集合中添加额外元素并与单元素袋子进行比较时，也会发生同样的事情。
- en: A bag with duplicate elements (multiplicity = 2) is not equal to a set with
    a single element, even if it is the same value.
  id: totrans-526
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含重复元素的袋子（多重性 = 2）不等于只有一个元素的集合，即使它们的值相同。
- en: Jumping ahead, a bag with two different elements cannot be adequately compared
    to a set with different elements. While testing for equality is expected to fail,
    both greater than and less than comparisons fail as well.
  id: totrans-527
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提前跳过，包含两个不同元素的袋子不能充分地与包含不同元素的集合相比较。虽然期望相等性测试失败，但大于和小于比较也失败了。
- en: Testing bags against each other may prove successful, depending on the comparisons.
    A single-element bag is obviously equal to itself, and is less than a bag with
    the element multiplicity `> 1`.
  id: totrans-528
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据比较，测试袋子之间可能成功。单元素袋子显然等于自身，并且小于元素多重性`> 1`的袋子。
- en: Conversely, multiplicity `> 1` will not be less than or equal to a multiplicity
    of 1.
  id: totrans-529
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相反，多重性`> 1`不会小于或等于多重性为1。
- en: 'Bags are roughly related to `Counter` collections, but provide different functionality.
    `ext_collections_bag_compare.py` shows how bags and Counters deal with adding
    and removing elements:'
  id: totrans-530
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 袋子与`Counter`集合大致相关，但提供不同的功能。`ext_collections_bag_compare.py`展示了袋子和Counter如何处理添加和删除元素：
- en: '[PRE84]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: A `Counter` instance is created and populated with an element.
  id: totrans-532
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建了一个`Counter`实例，并用一个元素填充。
- en: When the element is removed via subtraction, it is still active in memory, as
    it hasn't actually been deleted from the `Counter` (to actually remove a `Counter`
    element, the `del` function must be used).
  id: totrans-533
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当通过减法移除元素时，它仍然在内存中活跃，因为它实际上还没有从`Counter`中删除（要实际删除`Counter`元素，必须使用`del`函数）。
- en: When a bag instance is created and an element added to it, the existence of
    the element is evident. However, when the `remove()` function is used on a bag
    element, that element is, in fact, removed.
  id: totrans-534
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当创建袋子实例并向其中添加元素时，元素的存在是明显的。然而，当在袋子元素上使用`remove()`函数时，该元素实际上被移除了。
- en: 'The following example demonstrates how Counters and bags deal with object length
    as elements are added, removed, and duplicated:'
  id: totrans-535
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下示例演示了当添加、删除和重复元素时，Counter和袋子如何处理对象长度。
- en: '[PRE85]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: A `Counter` instance is created and populated.
  id: totrans-537
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建了一个`Counter`实例并填充。
- en: With only one element added, the length of the instance is 1.
  id: totrans-538
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只添加一个元素，实例的长度为1。
- en: When the element is subtracted from the `Counter`, the length is still 1, as
    the element hasn't actually been removed from the `Counter`.
  id: totrans-539
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当元素从`Counter`中减去时，长度仍然是1，因为该元素实际上并未从`Counter`中移除。
- en: Adding multiple copies of an element to the `Counter` doesn't extend the length.
    The `Counter` simply tracks how many elements of the same value have been added,
    but doesn't append those values to its actual length.
  id: totrans-540
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向`Counter`中添加多个相同元素的副本不会扩展长度。`Counter`仅跟踪添加了多少个具有相同值的元素，但不会将这些值附加到其实际长度上。
- en: Adding and removing elements to a bag, regardless of whether they are duplicates,
    actually affects the length of the bag object.
  id: totrans-541
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向袋子中添加和删除元素，无论它们是否重复，实际上都会影响袋子对象的长度。
- en: 'When iterating, bags again behave differently to Counters:'
  id: totrans-542
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当迭代时，袋子再次与`Counter`的行为不同：
- en: '[PRE86]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: While a `Counter` prints only the element it contains (as the element is a key,
    with its value equal to the quantity of that key), a bag actually has all the
    elements contained in it, so it will print each and every element.
  id: totrans-544
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然`Counter`只打印它包含的元素（因为元素是一个键，其值等于该键的数量），但实际上袋子包含所有包含的元素，所以它会打印每个元素。
- en: 'Several new methods are provided for bags:'
  id: totrans-545
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为袋子提供了几种新方法：
- en: '`num_unique_elements`: It returns the number of unique elements in the bag.'
  id: totrans-546
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`num_unique_elements`：它返回袋子中唯一元素的数量。'
- en: '`unique_elements()`: It returns a set of all the unique elements in the bag.'
  id: totrans-547
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unique_elements()`：它返回袋子中所有唯一元素的一个集合。'
- en: '`nlargest(n=None)`: It returns the `n` most common elements and their quantities,
    from most common to least common. If `n` is not provided, then all elements are
    returned.'
  id: totrans-548
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nlargest(n=None)`：它返回最常见的前`n`个元素及其数量，从最常见到最少见。如果未提供`n`，则返回所有元素。'
- en: '`copy()`: It returns a shallow copy of the bag.'
  id: totrans-549
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`copy()`：它返回袋子的浅拷贝。'
- en: '`isdisjoint(other: Iterable)`: It tests whether the bag is disjoint with the
    provided `Iterable`.'
  id: totrans-550
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isdisjoint(other: Iterable)`：它测试袋子是否与提供的`Iterable`不交集。'
- en: '`from_mapping(map: Mapping)`: A class method to create a bag from the provided `Mapping`;
    maps the elements to counts.'
  id: totrans-551
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`from_mapping(map: Mapping)`：一个类方法，用于从提供的`Mapping`创建袋子；将元素映射到计数。'
- en: RangeMap
  id: totrans-552
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RangeMap
- en: 'Below, we create an empty `RangeMap` and then manually populate it with the
    date ranges of US presidents:'
  id: totrans-553
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下面，我们创建一个空的`RangeMap`，然后手动用美国总统的日期范围填充它：
- en: '[PRE87]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '`RangeMap` is imported from the `collections-extended` module, `date` is imported
    from `datetime`, and a new `RangeMap` instance is created.'
  id: totrans-555
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RangeMap`是从`collections-extended`模块导入的，`date`是从`datetime`导入的，并创建了一个新的`RangeMap`实例。'
- en: A date range is provided as the key to two US presidents, while an open ended
    range is given to a third.
  id: totrans-556
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个日期范围作为两个美国总统的键，而一个开放式范围则给第三个。
- en: Like a dictionary, providing the appropriate key to the `RangeMap` instance
    returns its value.
  id: totrans-557
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与字典类似，向`RangeMap`实例提供适当的键会返回其值。
- en: If a range is entered that overlaps a previous entry, the new entry becomes
    the end of the overlapped range key and starts a new open-ended range. Thus, the
    `Someone New` value is ascribed to the year 2021, rather than `Barack Obama`,
    which was the value to the previous open-ended range.
  id: totrans-558
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果输入的范围与之前的条目重叠，则新条目成为重叠范围的末尾键，并开始一个新的开放式范围。因此，"Someone New"的值被分配给2021年，而不是之前开放式范围的值"Barack
    Obama"。
- en: Bijection
  id: totrans-559
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 双射
- en: 'Bijective functions are commonly found in a variety of mathematical areas,
    such as in the definitions of isomorphism, homeomorphism, diffeomorphism, permutation
    group, and projective maps. The following example only demonstrates how a `bijection`
    object is created and checked, but doesn''t go into extensive detail on implementation:'
  id: totrans-560
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双射函数在许多数学领域中都很常见，例如在等价关系、同胚、微分同胚、排列群和射影映射的定义中。以下示例仅演示如何创建和检查`bijection`对象，但并未深入到实现的细节：
- en: '[PRE88]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: As usual, the class is imported from the module and an instance is created.
    The instance argument is a simple dictionary, mapping a string to an integer.
  id: totrans-562
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如同往常，类是从模块中导入的，并创建了一个实例。实例参数是一个简单的字典，将字符串映射到整数。
- en: Using the `inverse` function, the key to a value is printed. Providing the key,
    like a normal dictionary, displays its corresponding value.
  id: totrans-563
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`inverse`函数，打印出值的键。提供键，就像正常字典一样，显示其对应的值。
- en: A truth test shows that the instance is equal to an abbreviated version of that
    instance. Note that this isn't comparing whether the two bijection instances have
    the exact same mappings, just that they do, indeed, map a single key to a single
    value.
  id: totrans-564
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 真值测试表明该实例等于该实例的缩略版。请注意，这并不是比较两个双射实例是否具有完全相同的映射，只是它们确实将单个键映射到单个值。
