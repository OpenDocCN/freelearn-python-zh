<html><head></head><body>
        

                            
                    <h1 class="header-title">Securing Your App</h1>
                
            
            
                
<p>We have a mostly functioning blog app, but it is missing some crucial features, such as a user login, registration function, and the ability to add and edit posts from the browser. The user authentication functionality can be achieved in many different ways, so each of the following sections in this chapter will demonstrate a mutually exclusive method to create a login functionality. Each authentication method can have different levels of security, or may be adequate for different kinds of applications, ranging from web exposed to enterprise back office.</p>
<p>In this chapter, we will explore the following topics:</p>
<ul>
<li>A brief overview of various authentication methods: basic authentication, remote user, LDAP, database authentication, and OpenID and Oauth</li>
<li>How to leverage Flask login (database/cookie authentication)</li>
<li>How to implement <strong>role-based access control</strong> (<strong>RBAC</strong>) to distinguish functionality and implement granular access to normal blog users</li>
</ul>
<p>If you haven't already, download the provided code and use the <kbd>init.sh</kbd> script to create a <kbd>virtualenv</kbd>, database schema, and test data. The test data will create three users, all with their passwords set to <kbd>password.</kbd> The users will each have the following permissions respectively:</p>
<ul>
<li><kbd>user_default</kbd> with minimal permissions</li>
<li><kbd>user_poster</kbd> with author permissions</li>
<li><kbd>admin</kbd> with admin permissions</li>
</ul>
<p>Let's first explore some very simple authentication methods.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Authentication methods</h1>
                
            
            
                
<p>An authentication method is a process of confirming an identity. In the case of an application, a user is given a username and a secret security token (password) and uses them to verify their identity on the application itself. There are several authentication methods and types, used for different types of applications (such as API, web exposed, intranet, and government). We will be covering the most used type of authentication—single factor.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Basic authentication</h1>
                
            
            
                
<p>As the name suggests, basic authentication is a very simple authentication method implemented by the HTTP protocol itself. It is part of the RFC7617. To use it, we can configure our web servers (IIS, Apache, and NGINX) to implement it, or we can implement it ourselves.</p>
<p>For details on how to configure NGINX for basic authentication, go to <a href="https://docs.nginx.com/nginx/admin-guide/security-controls/configuring-http-basic-authentication/">https://docs.nginx.com/nginx/admin-guide/security-controls/configuring-http-basic-authentication/</a>.</p>
<p>The basic authentication protocol goes through the following general steps:</p>
<ol>
<li>The user requests a protected resource from the server.</li>
<li>The server responds with <kbd>401</kbd> (unauthorized) and the HTTP header <kbd>WWW-Authenticate: Basic realm="Login required"</kbd><em>.</em></li>
<li>The browser will display a basic authentication login window for the user to send a username/password back to the server.</li>
<li>The username and password provided by the user will be sent to the server on the HTTP header with the form <kbd>Authorization: Basic &lt;Username&gt;:&lt;Password&gt;</kbd><em>.</em> The <kbd>username:password</kbd> will be base64-encoded.</li>
</ol>
<p>Flask will make it easy for us to implement this protocol, since it will automatically decode the base64 authorization from the HTTP header and place the username and password has properties of the <kbd>Request.authorization</kbd> object, as shown in the following code:</p>
<pre>def authenticate(username, password):<br/>    return username == 'admin' and password == 'password'<br/><br/>@app.route('/basic-auth-page')
def basic_auth_page():<br/>    auth = request.authorization<br/>    if not auth or not authenticate(auth.username, auth.password)<br/>        return Response('Login with username/password', 401, {'WWW-Authenticate': 'Basic realm="Login Required"'})<br/>    return render_template('some_page.html')</pre>
<p>This type of authentication is very simple, but not very secure. The username and password will be sent to the server on every request, so make sure that you always use HTTPS to properly encrypt their transmission over the wire. Additionally, as you may have already noticed in the code flow of the preceding example, the authentication method will be invoked on every request, so it is not very efficient. Yet this can be a good option for the internal use of a very simple back-office application, or for rapidly protecting a proof-of-concept application.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Remote-user authentication</h1>
                
            
            
                
<p>We can, with some intranet setups, use single sign-on authentication methods, where the web servers do all the heavy lifting related with security. This can be done using <strong>IIS integrated windows authentication</strong> or <strong>Apache mod_auth_sspi</strong>, <strong>Apache Samba</strong>, or others. The setup is beyond the scope of this book. </p>
<p>You can check out some examples of how to set up this kind of authentication with Apache Samba at <a href="https://wiki.samba.org/index.php/Authenticating_Apache_against_Active_Directory">https://wiki.samba.org/index.php/Authenticating_Apache_against_Active_Directory</a>.<a href="https://wiki.samba.org/index.php/Authenticating_Apache_against_Active_Directory"/></p>
<p>With this kind of authentication method, the web server will pass the already authenticated username as an environment key to the <strong>WSGI</strong> (<strong>web server gateway interface</strong>), so we just have to fetch it using the following:</p>
<pre> username = request.environ.get('REMOTE_USER')</pre>
<p>For our blog application, we could just check whether the user exists on the database, so no password database field is needed. This authentication method can be considered secure if it is properly set up on the server, and can be very convenient on intranet setups since the user, if already authenticated on the domain (for example, Active Directory) will no longer need to fill his/her login/password again (using Kerberos GSSAPI, or Windows SSPI, for example). </p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">LDAP authentication</h1>
                
            
            
                
<p><strong>LDAP</strong> (<strong>lightweight directory access protocol</strong>) is an open standard described currently by RFC4511. Its purpose is to implement a distributed information directory over the IP. This directory can contain different types of information normally related to users, groups, and devices. It has a fixed schema describing each object's attributes, but this schema can be changed using LDIF.</p>
<p>Active Directory is Microsoft's implementation of LDAP. You can take a look at the base-implemented user attributes that are available at <a href="http://www.kouti.com/tables/userattributes.htm">http://www.kouti.com/tables/userattributes.htm</a>.<a href="http://www.kouti.com/tables/userattributes.htm"/></p>
<p>An entry (for example, the user) on the directory is identified by a <strong>distinguished name</strong> (<strong>DN</strong>). For example, take a look at the following code:</p>
<pre>CN=user1,OU=Marketing,DC=example,DC=com</pre>
<p>The <kbd>DC</kbd><strong> </strong>phrase is the domain component, and it identifies the domain where the user is (an LDAP directory can have trees of domains and subdomains). In our example, the domain is <kbd>example.com</kbd>. The phrase<kbd> OU</kbd> refers to the organizational unit where the user is, and <kbd>CN</kbd><strong> </strong>is its common name. </p>
<p>The LDAP implements various operations, such as adding users, searching, deleting and so on. For authentication purposes only, we are interested on the <kbd>Bind</kbd> and <kbd>Search</kbd> operations. </p>
<p>To use the LDAP, we will need to install <kbd>python-ldap</kbd>, so let's do that first using the following code:</p>
<pre><strong>$ pip install python-ldap</strong></pre>
<p>The two most commonly used LDAP services nowadays are <strong>OpenLDAP</strong> (open and free) and <strong>Microsoft Active Directory</strong> (commercial). Their implementation differs a bit, mainly regarding their user attributes. The following code is an example of Active Directory. First, we need to define some configuration keys to connect to and authenticate with the service:</p>
<pre>import ldap<br/><br/>LDAP_SERVER="ldap://example.com:389"<br/>ROOT_DN="dc=example,dc=com"<br/>SERVICE_USER="ServiceAccount"<br/>SERVICE_PASSWORD="SOME_PASSWORD"<br/>UID_FIELD_NAME="userPrincipalName" # specific for AD<br/>USER_DOMAIN="example.com"</pre>
<p>Note that we are using nonencrypted communication between our application server and the LDAP server; we can turn encryption on by using digital certificates and using LDAPS on our <kbd>LDAP_SERVER</kbd> configuration key.</p>
<p>If we were to integrate LDAP authentication with our blog application, these values would be good candidates for our configuration on <kbd>config.py</kbd><em><strong>.</strong></em></p>
<p>Next, we will connect to and authenticate with the service as follows:</p>
<pre>con = ldap.initialize(LDAP_SERVER)<br/>con.set_option(ldap.OPT_REFERRALS, 0)<br/>con.bind_s(SERVICE_USER, SERVICE_PASSWORD)</pre>
<p>The <kbd>OPT_REFERRALS</kbd> is a specific workaround for MSFT AD. Take a look at the FAQ for <kbd>python-ldap</kbd> for more detailed information at <a href="https://www.python-ldap.org/en/latest/faq.html">https://www.python-ldap.org/en/latest/faq.html</a>.</p>
<p>Now that we have an authenticated connection, we will search for our user to fetch its username, as shown in the following code. In Active Directory, we could bind directly using the user's username and password, yet that method would fail in OpenLDAP. This way, we are following the standard method that will work on both systems:</p>
<pre>username = username + '@' + USER_DOMAIN<br/>filter_str = "%s=%s" % (UID_FIELD_NAME, username)<br/>user = con.search_s(ROOT_DN,<br/>                        ldap.SCOPE_SUBTREE,<br/>                        filter_str,<br/>                        ["givenName","sn","mail"])</pre>
<p>A complete authentication function for LDAP could be as follows:</p>
<pre>def ldap_auth(username, password):<br/>    con = ldap.initialize(LDAP_SERVER)<br/>    con.set_option(ldap.OPT_REFERRALS, 0)<br/>    username = username + '@' + USER_DOMAIN<br/>    con.bind_s(SERVICE_USER, SERVICE_PASSWORD)<br/>    filter_str = "%s=%s" % (UID_FIELD_NAME, username)<br/>    user = con.search_s(ROOT_DN,<br/>                        ldap.SCOPE_SUBTREE,<br/>                        filter_str,<br/>                        ["givenName","sn","mail"])<br/>    <strong>if user:</strong><br/><strong>        print("LDAP got User {0}".format(user))</strong><br/><strong>        # username = DN from search</strong><br/><strong>        username = user[0][0]</strong><br/><strong>        try:</strong><br/><strong>            con.bind_s(username, password)</strong><br/><strong>            return True</strong><br/><strong>        except ldap.INVALID_CREDENTIALS:</strong><br/><strong>            return False</strong><br/>    else:<br/>        return False</pre>
<p>Finally, with the LDAP username we make a final bind to authenticate our user (the highlighted code).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Database user model authentication</h1>
                
            
            
                
<p>Database authentication is widely used for internet-faced applications. If properly implemented, it can be considered a secure method. It has the advantages of being simple to add new users, and having no dependency on any external services. Security roles, groups, fine-grained access permissions, and extra user attributes are also all kept on the database. These can be easily changed without any external dependencies, and maintained within the scope change of the application.</p>
<p>This authentication method consists of checking the username and password submitted by a user against the stored attributes in our database's user model. But until now, our users had their passwords stored as plain text in the database. This is a major security flaw. If any malicious user were to gain access to the data in the database, they could log in to any account. The fallout of such a breach not be limited to our site. Large numbers of people on the internet use a common password for many sites. If an attacker had access to an email and password combination, it is very likely that this information could be used to log in to a Facebook account, or even a bank account.</p>
<p>To protect our user passwords, they will be encrypted with a one-way encryption method called a <strong>hashing algorithm</strong>. A one-way encryption means that after the information is encrypted, the original information cannot be regained from the result. However, given the same data, the hashing algorithm will always produce the same result. The data given to the hashing algorithm can be anything from a text file to a movie file. In this case, the data is just a string of characters. With this functionality, our passwords can be stored as <strong>hashes</strong> (data that has been hashed). Then, when a user enters their password in the login or registration page, the text entered for the password will be sent through the same hashing algorithm, and the stored hash and the entered hash will be verified.</p>
<p>This is one of the authentication methods we will use; further implementation details are described later in this chapter.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">OpenID and OAuth</h1>
                
            
            
                
<p>Integrating alternative login and registration options into your site becomes more important as time goes on. Every month, there is another announcement that passwords have been stolen from a popular website. Implementing the following login options means that our site's database never stores a password for that user. Verification is handled by a large brand-named company that the user already places their trust in. By using social logins, the amount of trust a user has to place in the website they are using is much higher. Your login process also becomes much shorter for the user, decreasing the barrier to entry to your app.</p>
<p>Socially authenticated users act as normal users, and unlike the password-based login methods, they can all be used in tandem.</p>
<p><strong>OpenID</strong> is an open-standard authentication protocol that allows users on one site to be authenticated by any third-party site that implements the protocol, which are called <strong>identity providers</strong>. An OpenID login is represented as a URL from one of the identity providers, typically the profile page of the website. The users that wish to use this authentication method need to be already registered on at least one of the OpenID providers.</p>
<p>To see a full list of sites that use OpenID, and to learn how to use each one, go to <a href="https://openid.net/get-an-openid/">https://openid.net/get-an-openid/</a>.</p>
<p>During the process of authentication, the user is redirected to the OpenID provider, where the user can authenticate—typically using a username/password, but it can be any other method—and is asked if they trust the party (our application). If the user trusts our application and authenticates successfully, then the user is redirected back with a document holding some requested user information (such as the username or email). A final request is made to check whether the data really came from the provider.</p>
<p><strong>OAuth</strong> is not an authentication method—it is an access-delegation method. It was mainly designed to enable third-party applications to interact with the OAuth providers (Facebook, Twitter, and so on). With it, we can design an application to interact with a user's Facebook account, performing actions such as posting on his behalf, sending notifications, retrieving their friends list, and so on.</p>
<p>To start using OAuth, we first need to register our application on the OAuth provider and use its consumer key and secret token.</p>
<p class="mce-root"/>
<p>For Facebook, we need to register our application at <a href="http://developers.facebook.com">http://developers.facebook.com</a>. Once you create a new app, look for the panel that lists your app's ID and secret key, as shown in the following screenshot:</p>
<div><img class="aligncenter size-full wp-image-546 image-border" src="img/b8f61c46-8451-47b2-ae17-0c5e849b5c87.png" style="width:157.00em;height:46.17em;"/></div>
<p> To create a Twitter app and receive your keys, go to <a href="https://apps.twitter.com/">https://apps.twitter.com/</a>. Please do so, since we are going to use these keys, tokens and configuration information to set up our blog application for OAuth pseudoauthentication. </p>
<p>The OAuth process is as follows:</p>
<ol>
<li>The application requests access to a user's resources from the OAuth provider.</li>
<li>The user is redirected and authorizes the requested access.</li>
<li>The application receives an authorization grant, and requests an access token by providing its own credentials (key and token) as well as the received grant.</li>
<li>The application receives the access token (this will serve as our authentication method) and can be further used to interact with the provider API on behalf of our user.</li>
</ol>
<p>For a view of the complete OAuth process, go to <a href="https://flask-dance.readthedocs.io/en/latest/how-oauth-works.html#oauth-2">https://flask-dance.readthedocs.io/en/latest/how-oauth-works.html#oauth-2</a>.<a href="https://flask-dance.readthedocs.io/en/latest/how-oauth-works.html#oauth-2"/></p>
<p>Since we will be using both methods in our application, you will find the implementation details in the following chapters.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Flask-Login overview</h1>
                
            
            
                
<p>Flask-Login is a popular Flask extension for handling the process of logging users in and out, properly handling cookie sessions, and even using basic authentication with HTTP headers. It will set up callbacks for user loading, header authentication, logging in, logging out, unauthorized events, and so on.</p>
<p>To start using Flask-Login, we first need to declare it as a dependency on our <kbd>requirements.txt</kbd>, as shown in the following code:</p>
<pre>...<br/>Flask-Login<br/>...</pre>
<p>Then, we need to update our Python virtual environment as follows:</p>
<pre><strong>$ source venv/bin/activate</strong><br/><strong>$ pip install -r requirements.txt</strong></pre>
<p>If you have executed the provided <kbd>init.sh</kbd> script, then there is no need to update the <kbd>virtualenv</kbd>. All the required dependencies for this chapter are already installed.</p>
<p>To use the session and login flow implemented by Flask-Login, we will need to do the following:</p>
<ul>
<li>Change the user model and implement the following functions:
<ul>
<li><kbd>is_authenticated</kbd>: This checks whether the current user is authenticated</li>
<li><kbd>is_active</kbd>: This checks whether a user is active</li>
<li><kbd>is_anonymous</kbd>: This supports anonymous accesses to our blog</li>
<li><kbd>get_id</kbd>: This fetches the user ID</li>
</ul>
</li>
<li>Initialize and configure the login manager object, declaring the following:
<ul>
<li>Where our login view is (URL)</li>
<li>The type of session</li>
<li>The login message (flashed login message)</li>
<li>The special user class for anonymous users</li>
<li>Register and implement a function to load our authenticated user</li>
<li>A function that returns a user object by its ID</li>
</ul>
</li>
</ul>
<p class="mce-root"/>
<p>Flask-Login is agnostic as to our authentication method, so the authentication system itself needs be implemented.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Setting up</h1>
                
            
            
                
<p>To implement the user authentication system, we will develop a new module in our application by following the rules that were previously proposed in <a href="dee931d4-a3b0-4355-acbd-37e05e158356.xhtml">Chapter 5</a>, <em>Advanced Application Structure</em>. Our application structure will be as follows:</p>
<pre>./<br/>  config.py<br/>  manage.py<br/>  main.py<br/>  config.py 
  database.db 
  webapp/ 
    __init__.py
    blog/
      __init__.py 
      controllers.py<br/>      forms.py<br/>      models.py<br/>    <strong>auth/</strong><br/><strong>      __init__.py</strong><br/><strong>      controllers.py</strong><br/><strong>      models.py</strong><br/><strong>      forms.py</strong><br/>    main/<br/>      __init__.py<br/>      controllers.py
    templates/ 
      blog/<br/>      auth/
  migrations/ 
    versions/ </pre>
<p>To keep the principle of separation of concerns in our approach to our module's design, we will make a simple change to the way we register each module blueprint. This is a nice thing to have, and it's necessity is more evident now because in this chapter, we will be using lots of new extensions to implement security, and we have to initialize them, register event methods, and configure them. All of these security bootstrapping procedures are best kept in the authentication module itself. To achieve this, we will create a new method in each <kbd>__init__.py</kbd> file for each module. Let's take a look at how this is done in our blog and authentication modules:</p>
<p class="mce-root"/>
<p class="mce-root">First, let's look at the code in the <kbd>blog/__<strong>init__</strong>.py </kbd>file:</p>
<pre>def create_module(app, **kwargs):<br/>    from .controllers import blog_blueprint<br/>    app.register_blueprint(blog_blueprint)</pre>
<p>In the authentication module, we will handle the Flask-Login configuration and initialization as previously described. The main Flask-Login object is the <kbd>LoginManager</kbd> object.</p>
<p>Let's look at the code in the <kbd>auth/__<strong>init__</strong>.py </kbd>file:</p>
<pre>from flask_login import LoginManager 
 
login_manager = LoginManager()<br/>login_manager.login_view = "auth.login" login_manager.session_protection = "strong" login_manager.login_message = "Please login to access this page" login_manager.login_message_category = "info" <br/><br/>@login_manager.user_loader <br/><strong>def load_user(userid):</strong><br/>    from models import User<br/>    return User.query.get(userid) <br/><br/>def create_module(app, **kwargs):<br/>    ...<br/>    <strong>login_manager.init_app(app)</strong><br/>    from .controllers import auth_blueprint<br/>    app.register_blueprint(auth_blueprint)<br/>    ...</pre>
<p>The preceding configuration values define which view should be treated as the login page, and what the message should be to the user after a successful login. Setting the <kbd>session_protection</kbd> option to <kbd>strong</kbd> better protects against malicious users tampering with their cookies. When a tampered cookie is identified, the session object for that user is deleted and the user is forced to log back in.</p>
<p>The <kbd>load_user</kbd> function takes an ID and returns the <kbd>User</kbd> object. When a cookie is validated, Flask-Login will use our function to fetch the user into the current session.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>Finally, in the <kbd>create_app</kbd> method itself, we just have to call the <kbd>create_module</kbd> on each module, as follows:</p>
<pre>...<br/><br/>def create_app(object_name):<br/>...<br/>    app = Flask(__name__)<br/>    app.config.from_object(object_name)<br/><br/>    db.init_app(app)<br/>    migrate.init_app(app, db)<br/><br/>    from .auth import create_module as auth_create_module<br/>    from .blog import create_module as blog_create_module<br/>    from .main import create_module as main_create_module<br/>    auth_create_module(app)<br/>    blog_create_module(app)<br/>    main_create_module(app)<br/><br/>    return app<br/><br/></pre>
<p>To implement an authentication system, we need a lot of setup code. To run any type of authentication, our app will need the following elements:</p>
<ul>
<li>The user models will need proper password hashing</li>
<li>It will need to implement a system to keep a secure user session context </li>
<li>A login form and a registration form will be needed to validate user input</li>
<li>A login view and a registration view (and templates for each) will be needed</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Updating the models</h1>
                
            
            
                
<p>There are many hashing algorithms, most of which are not secure because they are easy to <strong>brute force</strong>. With brute-force attacks, hackers continuously try sending data through a hashing algorithm until something matches. To best protect the user passwords, bcrypt will be our hashing algorithm of choice. Bcrypt is purposely designed to be inefficient and slow (milliseconds rather than microseconds) for the computer to process, thereby making it harder to brute force. To add bcrypt to our project, the package flask-bcrypt will need to be installed and added as a dependency on our <kbd>requirements.txt</kbd>, as follows:</p>
<pre>...<br/>flask-bcrypt<br/>...</pre>
<p>The <kbd>flask-bcrypt</kbd> package will have to be initialized. This is done in the <kbd>auth</kbd> module, <kbd>auth/__<strong>init__</strong>.py</kbd>, as shown in the following code:</p>
<pre>...<br/><strong>from flask.ext.bcrypt import Bcrypt 
bcrypt = Bcrypt()</strong><br/>...<br/>def create_module(app, **kwargs):<br/>    <strong>bcrypt.init_app(app)</strong><br/>    login_managet.init_app(app)<br/><br/>    from .controllers import auth_blueprint<br/>    app.register_blueprint(auth_blueprint)<br/> ...</pre>
<p>Bcrypt is now ready to use. To have our <kbd>User</kbd> object use bcrypt, we will add two methods that set the password and check whether a string matches the stored hash, as follows:</p>
<pre>from . import bcrypt<br/><br/>class User(db.Model):<br/>    ...<br/>    <strong>def set_password(self, password):</strong><br/><strong>        self.password = bcrypt.generate_password_hash(password)</strong><br/><br/><strong>    def check_password(self, password):</strong><br/><strong>        return bcrypt.check_password_hash(self.password, password)<br/></strong>...</pre>
<p>Now, our <kbd>User</kbd> models can store passwords securely. We also need to implement the Flask-Login methods previously described for the session and authentication flow. For this, we first need to define our anonymous user object.</p>
<p>On the <kbd>auth/__<strong>init__</strong>.py</kbd>, enter the following:</p>
<pre>from flask_login import AnonymousUserMixin<br/><br/>class BlogAnonymous(AnonymousUserMixin):<br/>    def __init__(self):<br/>        self.username = 'Guest'</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>Then add our <kbd>is_authenticated</kbd> property to the user model in <kbd>auth/models.py</kbd>, as shown in the following code. If the current user is not anonymous, then it is authenticated:</p>
<pre>class User(db.model):<br/>...<br/>    @property<br/><strong>    def is_authenticated(self):</strong><br/>        if isinstance(self, AnonymousUserMixin):<br/>            return False<br/>        else:<br/>            return True</pre>
<p>Then we add the <kbd>is_active</kbd> property; we will not be using it, but it checks whether the user has gone through some sort of activation process, such as an email confirmation. Otherwise, it allows site administrators to ban a user without deleting their data. To implement this, we will create a new Boolean property on our user model schema definition, as follows:</p>
<pre>class User(db.model):<br/>...<br/>    @property<br/><strong>    def is_active(self):</strong><br/>        return True</pre>
<p>Finally, we add the following <kbd>is_active</kbd> property and <kbd>get_id</kbd> method, which are pretty self explanatory:</p>
<pre>class User(db.model):<br/>...<br/>    @property<br/><strong>    def is_anonymous(self):</strong><br/>        if isinstance(self, AnonymousUserMixin):<br/>            return True<br/>        else:<br/>            return False<br/><br/><strong>    def get_id(self):</strong><br/>        return unicode(self.id)</pre>
<p>Next, our login process needs to use these methods to create new users and check passwords, and check whether a user is authenticated.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating the forms</h1>
                
            
            
                
<p>Three forms are required: a login form, a registration form, and a form for our <strong>post creation</strong> page. The login form will have username and password fields.</p>
<p>The following is the code for the <kbd>auth/forms.py</kbd> file:</p>
<pre><br/>from wtforms import ( 
  StringField, 
  TextAreaField, 
  PasswordField, 
  BooleanField 
) 
from wtforms.validators import DataRequired, Length, EqualTo, URL 
class LoginForm(Form): 
  username = StringField('Username', [ 
    DataRequired(), Length(max=255) 
  ]) 
  password = PasswordField('Password', [DataRequired()])<br/><br/>  def validate(self): 
    check_validate = super(LoginForm, self).validate() 
    # if our validators do not pass 
    if not check_validate: 
      return False 
    <strong># Does our user exist</strong>
    user = User.query.filter_by( 
      username=self.username.data 
    ).first() 
    if not user: 
      self.username.errors.append( 
        'Invalid username or password' 
      ) 
      return False 
    <strong># Do the passwords match 
    if not self.user.check_password(self.password.data):</strong> 
      self.username.errors.append( 
        'Invalid username or password' 
      ) 
      return False 
    return True </pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>Along with the normal validations, our <kbd>LoginForm</kbd> method will also check whether the username that was passed exists, and will use the <kbd>check_password()</kbd> method to check the hashes. This is done by overriding the <kbd>validate()</kbd> method called on the form <kbd>POST</kbd> requests. Here, we will first check whether the user exists on the database, and if it exists, check whether the encrypted passwords match (which will result in a successful login).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Protecting your form from spam</h1>
                
            
            
                
<p>The registration form will have a username field, a password field with a confirmation field, and a special field named a <kbd>reCAPTCHA</kbd> field. A <kbd>CAPTCHA</kbd> is a special field on a web form that checks whether the person who is entering data into the form is actually a person, or an automated program that is spamming your site. The <kbd>reCAPTCHA </kbd>field is simply one implementation of a <kbd>CAPTCHA</kbd> field. The <kbd>reCAPTCHA</kbd> method has been integrated into WTForms, as it is the most popular implementation on the web.</p>
<p>To use <kbd>reCAPTCHA</kbd>, you will need a <kbd>reCAPTCHA</kbd> login from <a href="https://www.google.com/recaptcha/intro/index.html">https://www.google.com/recaptcha/intro/index.html</a>. As <kbd>reCAPTCHA</kbd> is a Google product, you can log in with your Google account.</p>
<p>Once you log in, it will ask you to add a site. In this case, any name will do, but the domain field must have <kbd>localhost</kbd> as an entry. Once you deploy your site, your domain must also be added to this list.</p>
<p>Now that you have added a site, dropdowns with instructions on server and client integration will appear. The given <kbd>script</kbd> tag will need to be added to the templates of our login and registration views when we create them. What WTForms needs from this page are the keys, as shown in the following screenshot:</p>
<div><img class="aligncenter size-full wp-image-547 image-border" src="img/45813611-4cec-4f1f-a3d9-31bcdcc87738.png" style="width:140.92em;height:26.92em;"/></div>
<p>Remember to never show these keys to the public. As these keys are only registered to <kbd>localhost</kbd>, they can be shown here without any problem.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>Add these keys to the <kbd>config</kbd> object in the <kbd>config.py</kbd> file so that WTForms can access them as follows:</p>
<pre>class Config(object):<br/>    SECRET_KEY = '736670cb10a600b695a55839ca3a5aa54a7d7356cdef815d2ad6e19a2031182b'<br/>    RECAPTCHA_PUBLIC_KEY = "6LdKkQQTAAAAAEH0GFj7NLg5tGicaoOus7G9Q5Uw"<br/>    RECAPTCHA_PRIVATE_KEY = '6LdKkQQTAAAAAMYroksPTJ7pWhobYb88fTAcxcYn'</pre>
<p>The following code is our registration form in <kbd>auth/forms.py</kbd>:</p>
<pre><strong>class RegisterForm(Form):</strong> 
  username = StringField('Username', [ 
    DataRequired(), 
    Length(max=255) 
  ]) 
  password = PasswordField('Password', [ 
    DataRequired(), 
    Length(min=8) 
  ]) 
  confirm = PasswordField('Confirm Password', [ 
    DataRequired(), 
    EqualTo('password') 
  ]) 
  recaptcha = RecaptchaField() 
  def validate(self): 
    check_validate = super(RegisterForm, self).validate() 
    # if our validators do not pass 
    if not check_validate: 
      return False 
    user = User.query.filter_by( 
      username=self.username.data 
    ).first() 
    <strong># Is the username already being used 
    if user: 
      self.username.errors.append( 
        "User with that name already exists" 
      ) 
      return False</strong> 
    return True </pre>
<p>Note how we are preventing a user from registering itself twice by overriding the <kbd>validate</kbd> method. This is the right way to add extra form validation logic, as we previously explained.</p>
<p class="mce-root"/>
<p>The post creation form will just contain a text input for the title and a text area input for the post content. So the <kbd>blog/forms.py</kbd> will contain the following:</p>
<pre>class PostForm(Form): 
  title = StringField('Title', [ 
    DataRequired(), 
    Length(max=255) 
  ]) 
  text = TextAreaField('Content', [DataRequired()]) </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating views</h1>
                
            
            
                
<p>The login and registration views will create our form objects and pass them to the templates. After the <kbd>LoginForm</kbd> validates the user's credentials, we will use Flask-Login to actually log the user in.</p>
<p>In the <kbd>auth/controllers.py</kbd> controller, we will find the <kbd>login</kbd> view, as shown in the following code:</p>
<pre>...<br/>from flask_login import login_user, logout_user<br/>...<br/><strong><br/>@auth_blueprint.route('/login', methods=['GET', 'POST'])</strong><br/><strong>@oid.loginhandler<br/>def login():</strong><br/>    form = LoginForm()<br/>    ...<br/>    if form.validate_on_submit():<br/>        user = User.query.filter_by(username=form.username.data).one()<br/>        <strong>login_user(user, remember=form.remember.data)</strong><br/>        ...<br/>        flash("You have been logged in.", category="success")<br/>        return redirect(url_for('main.index'))<br/><br/>    ...<br/>    return render_template('login.html', form=form, openid_form=openid_form)</pre>
<p>The <kbd>logout</kbd> view is very simple, and will redirect the user to the main index page, as follows:</p>
<pre><strong>@auth_blueprint.route('/logout', methods=['GET', 'POST']) 
def logout():<br/></strong>  <strong>logout_user()</strong>
  flash("You have been logged out.", category="success") 
  return redirect(url_for('main.index'))</pre>
<p>The <kbd>register</kbd> view is used to register database users only, and will redirect users to the login page so that they can immediately log in, as follows:</p>
<pre><strong>@auth_blueprint.route('/register', methods=['GET', 'POST']) 
def register():</strong> 
  form = RegisterForm() 
  if form.validate_on_submit(): 
    new_user = User() 
    new_user.username = form.username.data 
    new_user.set_password(form.username.data) 
    db.session.add(new_user) 
    db.session.commit() 
    flash( 
      "Your user has been created, please login.", 
      category="success" 
    ) 
    return redirect(url_for('.login')) 
  return render_template('register.html', form=form) </pre>
<p>Your login page should now resemble the following screenshot:</p>
<div><img class="aligncenter size-full wp-image-548 image-border" src="img/ae9598f8-b18d-486b-b971-e1c04b640a52.png" style="width:16.58em;height:12.17em;"/></div>
<p>Your registration page should look like the following screenshot:</p>
<div><img class="aligncenter size-full wp-image-549 image-border" src="img/83ab564b-b8a8-4fc9-9b65-3c2840c60d89.png" style="width:25.00em;height:31.42em;"/></div>
<p>Now we need to create the post creation and editing page so that something can be secured. The two pages will need to transform the text area field into a <strong>WYSIWYG</strong> (short for <strong>what you see is what you get</strong>) editor to handle wrapping the post text in HTML. In the <kbd>blog/controllers.py</kbd> controller, you will find the following view to add new posts:</p>
<pre>...<br/>from flask_login import login_required, current_user<br/>from .forms import CommentForm, PostForm<br/>...<br/>@blog_blueprint.route('/new', methods=['GET', 'POST'])<br/><strong>@login_required</strong><br/>def new_post(): 
  form = PostForm() 
  if form.validate_on_submit(): 
    new_post = Post()<br/>    <strong>new_post.user_id = current_user.id</strong><br/>    new_post.title = form.title.data
    new_post.text = form.text.data 
    db.session.add(new_post) 
    db.session.commit()<br/>    flash("Post added", info)<br/>    return redirect(url_for('blog.post', post_id=new_post.id)<br/>return render_template('new.html', form=form)</pre>
<p>We are protecting our view using the Flask-Login decorator <kbd>@login_required</kbd> to ensure that only authenticated users can submit new posts. Next, using the proxy method <kbd>current_user</kbd>, we fetch the currently logged user ID so that the post is associated with the user. </p>
<p>The <kbd>new.html</kbd> template will need a JavaScript file for the WYSIWYG editor; <strong>CKEditor</strong> is very simple to install and use. Now, our <kbd>new.html</kbd> file can be created as follows. Name it <kbd>templates/blog/new.html</kbd>:</p>
<pre>{% extends "base.html" %}<br/>{% block title %}Post Creation{% endblock %}<br/>{% block body %}<br/>&lt;div class="p-4 shadow-sm"&gt;<br/>    &lt;div class="row"&gt;<br/>        &lt;div class="col"&gt;<br/>            &lt;h1&gt;Create a New Post&lt;/h1&gt;<br/>        &lt;/div&gt;<br/>    &lt;/div&gt;<br/><br/>&lt;div class="row"&gt;<br/>    &lt;form method="POST" action="{{ url_for('.new_post') }}"&gt;<br/>        {{ form.hidden_tag() }}<br/>        &lt;div class="form-group"&gt;<br/>            {{ form.title.label }}<br/>            {% if form.title.errors %}<br/>            {% for e in form.title.errors %}<br/>            &lt;p class="help-block"&gt;{{ e }}&lt;/p&gt;<br/>            {% endfor %}<br/>            {% endif %}<br/>            {{ form.title(class_='form-control') }}<br/>        &lt;/div&gt;<br/>        &lt;div class="form-group"&gt;<br/>            {{ form.text.label }}<br/>            {% if form.text.errors %}<br/>            {% for e in form.text.errors %}<br/>            &lt;p class="help-block"&gt;{{ e }}&lt;/p&gt;<br/>            {% endfor %}<br/>            {% endif %}<br/>            {{ form.text(id="editor", class_='form-control') }}<br/>        &lt;/div&gt;<br/>        &lt;input class="btn btn-primary" type="submit" value="Submit"&gt;<br/>    &lt;/form&gt;<br/>&lt;/div&gt;<br/>&lt;/div&gt;<br/>{% endblock %}<br/><br/><strong>{% block js %}</strong><br/><strong>&lt;script src="img/ckeditor.js"&gt;<br/>&lt;/script&gt;<br/>&lt;script&gt;<br/>    CKEDITOR.replace('editor');</strong><br/><strong>&lt;/script&gt;<br/>{% endblock %}</strong></pre>
<p>This is all that is needed to have the user's input stored as HTML in the database. Because we passed the <kbd>safe</kbd> filter in our post template, the HTML code appears correctly on our post pages. The <kbd>edit.html</kbd> template is similar to the <kbd>new.html</kbd> template. The only difference is the <kbd>form</kbd> opening tag, shown in the following code:</p>
<pre>&lt;form method="POST" action="{{ url_for('.edit_post', id=post.id) <br/>   }}"&gt; 
...  
&lt;/form&gt; </pre>
<p>The <kbd>post.html</kbd> template will need a button for authors to link them to the edit page, as shown in the following code:</p>
<pre>&lt;div class="row"&gt; 
  &lt;div class="col-lg-6"&gt; 
    &lt;p&gt;Written By &lt;a href="{{ url_for('.user', <br/>       username=post.user.username) }}"&gt;{{ post.user.username <br/>       }}&lt;/a&gt; on {{ post.publish_date }}&lt;/p&gt; 
  &lt;/div&gt; 
  ... <br/>  <strong>{% if current_user == post.user_id %}</strong>
  &lt;div class="row"&gt; 
    &lt;div class="col-lg-2"&gt; 
    &lt;a href="{{ url_for('.edit_post', id=post.id) }}" class="btn <br/>       btn-primary"&gt;Edit&lt;/a&gt; 
  &lt;/div&gt; <br/>  <strong>{% endif %}</strong>
&lt;/div&gt; </pre>
<p>Once again, we are using the <kbd>current_user</kbd> proxy to fetch the currently logged-in user, this time on a Jinja2 template, so that we only show the Edit button to the user that previously create the blog post.</p>
<p class="mce-root"/>
<p>Finally, we should add an entry to create new posts in the main navigation bar. We should also take a look at how the login, logout, and register options are enabled and disabled. In <kbd>templates/navbar.html</kbd>, enter the following:</p>
<pre><strong>{% if current_user.is_authenticated %}</strong><br/>&lt;li class="nav-item"&gt;<br/>    &lt;a class="nav-link" href="{{url_for('auth.logout')}}"&gt;<br/>    &lt;i class="fa fa-fw fa-sign-out"&gt;&lt;/i&gt;Logout&lt;/a&gt;<br/>&lt;/li&gt;<br/><strong>{% else %}</strong><br/>&lt;li class="nav-item"&gt;<br/>    &lt;a class="nav-link" href="{{url_for('auth.login')}}"&gt;<br/>    &lt;i class="fa fa-fw fa-sign-in"&gt;&lt;/i&gt;Login&lt;/a&gt;<br/>&lt;/li&gt;<br/>&lt;li class="nav-item"&gt;<br/>    &lt;a class="nav-link" href="{{url_for('auth.register')}}"&gt;<br/>    &lt;i class="fa fa-fw fa-sign-in"&gt;&lt;/i&gt;Register&lt;/a&gt;<br/>&lt;/li&gt;<br/><strong>{% endif %}</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">OpenID</h1>
                
            
            
                
<p>To integrate OpenID authentication with our application, we are going to use a new Flask extension named <strong>Flask-OpenID, </strong>implemented by the <strong>Flask </strong>creator itself. As always, the extension needs to be added to the <kbd>requirements.txt</kbd> file, as follows:</p>
<pre>...<strong><br/>Flask-OpenID<br/></strong>...</pre>
<p>Our app will also need a couple of things to implement OpenID:</p>
<ul>
<li>A new form object</li>
<li>The form validation in the login and registration pages</li>
<li>A callback after the form submission to log the user in or create a new user</li>
</ul>
<p>In the <kbd>auth/__init__.py</kbd> file, the <kbd>OpenID</kbd> object can be initialized as follows:</p>
<pre>...<br/>from flask_openid import OpenID<br/>...  
oid = OpenID() </pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p>In the <kbd>create_module</kbd> function, the <kbd>oid</kbd> object is registered to the <kbd>app</kbd> object, as follows:</p>
<pre>def create_module(app, **kwargs):<br/>    ...<br/>    oid.init_app(app)<br/>    ...</pre>
<p>The new <kbd>form</kbd> object will only need the URL of the <kbd>OpenID</kbd> provider. In <kbd>auth/forms.py</kbd>, enter the following:</p>
<pre>from wtforms.validators import DataRequired, Length, EqualTo, URL<br/>class OpenIDForm(Form): 
  openid = StringField('OpenID URL', [DataRequired(), URL()]) </pre>
<p>In the login and registration views, <kbd>OpenIDForm()</kbd> will be initialized, and if the data is valid, a login request will be sent. In <kbd>auth/views.py</kbd>, enter the following:</p>
<pre>...
 
@auth_blueprint.route('/login', methods=['GET', 'POST']) 
@oid.loginhandler 
def login(): 
  form = LoginForm() 
  <strong>openid_form = OpenIDForm() 
  if openid_form.validate_on_submit(): 
    return oid.try_login( 
      openid_form.openid.data, 
      ask_for=['nickname', 'email'], 
      ask_for_optional=['fullname'] 
    )</strong> 
  if form.validate_on_submit(): 
    flash("You have been logged in.", category="success") 
    return redirect(url_for('blog.home')) 
  <strong>openid_errors = oid.fetch_error() 
  if openid_errors: 
    flash(openid_errors, category="danger")</strong> 
  return render_template( 
    'login.html', 
    form=form, 
    <strong>openid_form=openid_form</strong> 
  ) 
 
@main_blueprint.route('/register', methods=['GET', 'POST']) 
@oid.loginhandler 
def register(): 
  form = RegisterForm() 
  <strong>openid_form = OpenIDForm() 
  if openid_form.validate_on_submit(): 
    return oid.try_login( 
      openid_form.openid.data, 
      ask_for=['nickname', 'email'], 
      ask_for_optional=['fullname'] 
    )</strong> 
  if form.validate_on_submit(): 
    new_user = User(form.username.data) 
    new_user.set_password(form.password.data) 
    db.session.add(new_user) 
    db.session.commit() 
    flash( 
      "Your user has been created, please login.", 
      category="success" 
    ) 
    return redirect(url_for('.login')) 
  <strong>openid_errors = oid.fetch_error() 
  if openid_errors: 
    flash(openid_errors, category="danger")</strong> 
  return render_template( 
    'register.html', 
    form=form, 
    openid_form=openid_form 
  ) </pre>
<p>Both the views have the new decorator <kbd>@oid.loginhandler</kbd>, which tells Flask-OpenID to listen for authentication information coming back from the provider. With OpenID, logging in and registering are the same. It is possible to create a user from the login form and to log in from the registration form. The same field appears on both pages to avoid confusing the user.</p>
<p>To handle the user creation and login, a new function in the <kbd>auth/__init__.py</kbd> file is needed, as shown in the following code:</p>
<pre>@oid.after_login 
def create_or_login(resp): 
    from models import db, User 
    username = resp.fullname or resp.nickname or resp.email 
    if not username: 
      flash('Invalid login. Please try again.', 'danger') 
      return redirect(url_for('main.login')) 
    user = User.query.filter_by(username=username).first() 
    <strong># if the user does not exist create it</strong><br/>    if user is None: 
      user = User(username) 
      db.session.add(user)</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<pre>      db.session.commit() 
    <strong>login_user(user)</strong>
    return redirect(url_for('main.index')) </pre>
<p>This function is called after every successful response from the provider. If the login is successful and a user object does not exist for the identity, then this function creates a new <kbd>User</kbd> object. If one already exists, the upcoming authentication methods will log the user in. OpenID does not require all possible information to be returned, so it is possible that not a full name, but only an email address will be returned. This is why the username can be the nickname, full name, or email address. The <kbd>db</kbd> and <kbd>User</kbd> object are imported inside the function to avoid cyclical imports from the <kbd>models.py</kbd> file that is importing the <kbd>bcrypt</kbd> object.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">OAuth</h1>
                
            
            
                
<p>To log in with Facebook and Twitter, the <strong>OAuth</strong> protocol is used as previously described. Our app will not use OAuth directly; instead, another Flask extension will be used, named <strong>Flask Dance</strong>. In the <kbd>requirements.txt</kbd>, enter the following:</p>
<pre>...<br/>flask-dance<br/>...</pre>
<p>As previously described, the OAuth protocol needs a previously created application in each provider's developer page. After our application is created, we will have a key and secret token for each provider. For now, we are going to keep these credentials on the configuration file as is. Later, we will be using environment variables to handle them. So, in the configuration file <kbd>config.py</kbd>, add the following:</p>
<pre>...<br/>class Config(object):<br/>    ...<br/>    TWITTER_API_KEY = "XXX"<br/>    TWITTER_API_SECRET = "XXXX"<br/>    FACEBOOK_CLIENT_ID = "YYYY"<br/>    FACEBOOK_CLIENT_SECRET = "YYYY"</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>Now we are ready to initialize and configure our OAuth extension. <strong>Flask-Dance </strong>will help us create a new Flask blueprint for each provider we want to add. Once again, <kbd>auth/__init__.py</kbd> is the place where we configure all our authentication extensions, as follows:</p>
<pre>...<br/>from flask_dance.contrib.twitter import make_twitter_blueprint, twitter<br/>from flask_dance.contrib.facebook import make_facebook_blueprint, facebook<br/>...<br/>def create_module(app, **kwargs):<br/>...<br/>    twitter_blueprint = make_twitter_blueprint(<br/>        api_key=app.config.get("TWITTER_API_KEY"),<br/>        api_secret=app.config.get("TWITTER_API_SECRET"),<br/>    )<br/>    app.register_blueprint(twitter_blueprint, url_prefix="/auth/login")<br/><br/>    facebook_blueprint = make_facebook_blueprint(<br/>        client_id=app.config.get("FACEBOOK_CLIENT_ID"),<br/>        client_secret=app.config.get("FACEBOOK_CLIENT_SECRET"),<br/>)<br/>    app.register_blueprint(facebook_blueprint, url_prefix="auth/login"<br/>...</pre>
<p>Flask-Dance will create the following routes for us:</p>
<ul>
<li><kbd>/auth/login/twitter/authorized</kbd>: Here, the user is redirected after authorization is successful on Twitter</li>
<li><kbd>/auth/login/twitter</kbd>: This is the initial login view for Twitter OAuth</li>
<li><kbd>/auth/login/facebook/authorized</kbd></li>
<li><kbd>/auth/login/facebook</kbd></li>
</ul>
<p>After a successful login/authorization is accomplished, we need to log the user in on Flask-Login; if the user does not exist on the database, add them. To do this, we register for the authorized signal event. Enter the following in <kbd>auth/__init__.py</kbd>:</p>
<pre>...<br/>from flask_dance.consumer import oauth_authorized<br/>...<br/>@oauth_authorized.connect<br/>def logged_in(blueprint, token):<br/>    from .models import db, User<br/>    <strong>if blueprint.name == 'twitter':</strong><br/><strong>        username = session.get('screen_name')</strong><br/><strong>    elif blueprint.name == 'facebook':</strong><br/><strong>        resp = facebook.get("/me")</strong><br/><strong>        username = resp.json()['name']</strong><br/>    user = User.query.filter_by(username=username).first()<br/>    if not user:<br/>        user = User()<br/>        user.username = username<br/>        db.session.add(user)<br/>        db.session.commit()<br/><br/>    <strong>login_user(user)</strong><br/>    flash("You have been logged in.", category="success")</pre>
<p>The <kbd>@oauth_authorized</kbd> is the decorator from Flask-Dance that we use to register our function to handle the after-authorized signal. This is a generic signal handler for all our providers, so we need to know what provider are we currently handling. We need to know this because we need to fetch our username, and each provider is going to expose different user information in a different way. On Twitter, we will use the <kbd>screen_name</kbd> key that has already been returned by the provider and has already been pushed to our Flask session object by Flask-Dance. But on Facebook, we need to make a further request to Facebook's API to fetch the username.</p>
<p>During development, you will probably not use HTTPS. This will trigger an error when using <kbd>OAuth2</kbd>. To get around this, you have to tell <kbd>oauthlib</kbd> to accept insecure connections. In the command line, enter  <kbd>$ export OAUTHLIB_INSECURE_TRANSPORT=1</kbd>.</p>
<p>Finally, in the register and login templates, we have the following links to start the login process:</p>
<pre>&lt;h2 class="text-center"&gt;Register/Login With Facebook&lt;/h2&gt;<br/>&lt;a href="{{ url_for('facebook.login') }}"&gt;Login&lt;/a&gt;<br/><br/>&lt;h2 class="text-center"&gt;Register/Login With Twitter&lt;/h2&gt;<br/>&lt;a href="{{ url_for('twitter.login') }}"&gt;Login&lt;/a&gt;</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Role-based access control (RBAC)</h1>
                
            
            
                
<p>To implement a simple role-based access control system, we need to create a new database entity <kbd>Role</kbd> model that will need a many-to-many relationship for our <kbd>User</kbd> model so that a user can have multiple roles.</p>
<p>With our code from <a href="42af8825-fb77-4eb9-a010-7d7fc9644f7c.xhtml">Chapter 2</a>, <em>Creating Models with SQLAlchemy</em>, adding a many-to-many relationship to the <kbd>User</kbd> object is easy, as shown in the following code: </p>
<pre>roles = db.Table(<br/>    'role_users',<br/>    db.Column('user_id', db.Integer, db.ForeignKey('user.id')),<br/>    db.Column('role_id', db.Integer, db.ForeignKey('role.id'))<br/>)<br/><br/><br/>class User(db.Model):<br/>    ...<br/>    <strong>roles = db.relationship(</strong><br/><strong>        'Role',<br/>        secondary=roles,<br/>        backref=db.backref('users', lazy='dynamic')</strong><br/><strong>    )</strong><br/><br/>    def __init__(self, username=""):<br/>        <strong>default = Role.query.filter_by(name="default").one()</strong><br/><strong>        self.roles.append(default)</strong><br/>        self.username = username<br/><br/>    ...<br/>    <strong>def has_role(self, name):</strong><br/><strong>        for role in self.roles:</strong><br/><strong>            if role.name == name:</strong><br/><strong>                return True<br/>        return </strong><strong>False</strong><br/>...<br/>class Role(db.Model):<br/>    id = db.Column(db.Integer(), primary_key=True)<br/>    name = db.Column(db.String(80), unique=True)<br/>    description = db.Column(db.String(255))<br/><br/>    def __init__(self, name):<br/>        self.name = name<br/><br/>    def __repr__(self):<br/>        return '&lt;Role {}&gt;'.format(self.name)</pre>
<p>Also, when a user is created, a default role is always inserted into it. Note the <kbd>has_role</kbd> method that will help us easily check whether a user has a certain role; this will be useful for templates.</p>
<p>Our test data Python script has already populated the <kbd>Role</kbd> model with admin, poster, and default.</p>
<p>Next, we will need a decorator function to enable RBAC in our views. Python's decorator functions are very useful, and security is certainly a context where they can be welcome. Without them, we would have to write the same code over and over again (violating the DRY principal). We need a decorator function that receives an argument—on our case, the role name—and then checks whether the user has the required role. It returns <kbd>HTTP 403</kbd> if they do not. This is enabled using the following code:</p>
<pre>import functools<br/>...<br/>def has_role(name):<br/>    def real_decorator(f):<br/>        def wraps(*args, **kwargs):<br/>            if current_user.has_role(name):<br/>                return f(*args, **kwargs)<br/>            else:<br/>                abort(403)<br/>        return functools.update_wrapper(wraps, f)<br/>    return real_decorator</pre>
<p>The <kbd>functools.update_wrapper</kbd> is needed so that the decorated function returns the function definition instead of the wrapper definition; without it, we would lose the routing definition from Flask.</p>
<p>Now, we are ready to protect our <strong>new post</strong> view and <strong>edit</strong> view. Since only a user with the <strong>poster</strong> role can access them, this is now very simple using the <kbd>has_access</kbd> decorator.</p>
<p>Look at the <kbd>auth/__init__.py</kbd> file:</p>
<pre>...<br/>from ..auth import has_role <br/>...<br/>@blog_blueprint.route('/new, methods=['GET', 'POST']) 
@login_required 
<strong>@has_role('poster')</strong> 
def new_post(id): 
    ... </pre>
<p>We can also add a user check to the view, to ensure that only a user that has created a post can actually edit it. We have already disabled the edit option, but a user can always access the view by typing the URL directly in the browser.</p>
<p>Go to the file named <kbd>blog/controllers.py</kbd>:</p>
<pre>@blog_blueprint.route('/edit/&lt;int:id&gt;', methods=['GET', 'POST'])<br/>@login_required<br/><strong>@has_role('poster')</strong><br/>def edit_post(id):<br/>    post = Post.query.get_or_404(id)<br/>    # We want admins to be able to edit any post<br/>    <strong>if current_user.id == post.user.id:</strong><br/>        form = PostForm()<br/>        if form.validate_on_submit():<br/>            post.title = form.title.data<br/>            post.text = form.text.data<br/>            post.publish_date = datetime.datetime.now()<br/>            db.session.add(post)<br/>            db.session.commit()<br/>            return redirect(url_for('.post', post_id=post.id))<br/>        form.title.data = post.title<br/>        form.text.data = post.text<br/>        return render_template('edit.html', form=form, post=post)<br/>    abort(403)</pre>
<p>Also, in the navigation bar, we want to show the New Post option only to the users that have the poster role.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>Our users now have secure logins, multiple login and registration options, and explicit access permissions. Our app has everything that is needed to be a fully fledged blog app. In the next chapter, we will stop following this example application in order to introduce a technology named <strong>NoSQL</strong>.</p>


            

            
        
    </body></html>