- en: <st c="0">9</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="2">Securing Flask Applications</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="29">Like any web application, Flask applications have vulnerabilities
    that require protection from external attacks, which exploit these software defects.</st>
    <st c="181">These cyber-attacks are mainly due to broken access control problems,</st>
    **<st c="251">Cross-Site Scripting</st>** <st c="271">(</st>**<st c="273">XSS</st>**<st
    c="276">),</st> **<st c="280">Cross-Site Request Forgery</st>** <st c="306">(</st>**<st
    c="308">CSRF</st>**<st c="312">),</st> **<st c="316">Server-Side Request Forgery</st>**
    <st c="344">(</st>**<st c="345">SSRF</st>**<st c="349">),</st> **<st c="353">SQL
    Injection</st>**<st c="366">, and</st> **<st c="372">Denial-of-Service</st>**
    <st c="389">(</st>**<st c="391">DoS</st>**<st c="394">), as well as outdated modules</st>
    <st c="426">and libraries.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="440">Implementing security measures must be an utmost priority of any
    Flask application, especially if it is more dependent on external modules when
    building its models, repository layers, and workflow-related transactions.</st>
    <st c="660">Using third-party libraries can inflict risks to the Flask applications
    because some library codes can contain coding errors or vulnerabilities.</st>
    <st c="805">This is especially true for codes sourced from outdated third-party
    modules and libraries with</st> <st c="900">unreliable sources.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="919">It is easier to build Flask components and features with external
    modules, such as implementing the authentication and authorization measures using
    the</st> **<st c="1072">Authlib</st>** <st c="1079">module instead of composing
    it from the ground up.</st> <st c="1131">To decrease the chance of, if not avoid,
    web attacks, one should devise a security plan that will employ only reliable
    and updated modules.</st> <st c="1271">This will protect the application from</st>
    <st c="1310">outside attackers.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1328">The main goal of this chapter is to provide possible security solutions
    for Flask applications to avoid some of the well-known web attacks using Flask’s
    built-in components, as well as some up-to-date and reliable</st> <st c="1543">third-party
    libraries.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1565">Here are the topics that we will cover in the context of helping
    us secure our</st> <st c="1645">Flask applications:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1664">Adding protection from</st> <st c="1688">web vulnerabilities</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1707">Securing</st> <st c="1717">response data</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1730">Managing</st> <st c="1740">user credentials</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1756">Implementing web</st> <st c="1774">form authentication</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1793">Preventing</st> <st c="1805">CSRF attacks</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1817">Implementing user authentication</st> <st c="1851">and authorization</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1868">Controlling the view or</st> <st c="1893">API access</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1903">Technical requirements</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="1926">This chapter is about a</st> `<st c="2705">Flask[async]</st>` <st
    c="2717">features, including asynchronous</st> `<st c="2751">Flask-SQLAlchemy</st>`
    <st c="2767">transactions.</st> <st c="2782">They are available</st> <st c="2801">at</st>
    [<st c="2804">https://github.com/PacktPublishing/Mastering-Flask-Web-Development/tree/main/ch09</st>](https://github.com/PacktPublishing/Mastering-Flask-Web-Development/tree/main/ch09)<st
    c="2885">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="2886">Adding protection from web vulnerabilities</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="2929">SQL injection, SSRF, and XSS attacks are the most common web vulnerabilities
    that corrupt many web applications.</st> <st c="3043">They also affect any applications
    that use HTTP-based transactions, such as</st> `<st c="3119">POST</st>`<st c="3123">,</st>
    `<st c="3125">PUT</st>`<st c="3128">,</st> `<st c="3130">PATCH</st>`<st c="3135">,
    and</st> `<st c="3141">DELETE</st>`<st c="3147">. SQL injection occurs when an
    attacker infiltrates the backend datastore that manages the content of the trusted
    application.</st> <st c="3274">Embedded</st> <st c="3283">malicious SQL code can
    tamper with the data, rendering unwanted pages or destroying the database.</st>
    <st c="3381">XSS attacks commonly insert malicious scripts into the pages of the
    application to steal cookies, session data, and sensitive credentials from the
    system.</st> <st c="3536">On the other hand, CSRF occurs inside an authenticated
    environment.</st> <st c="3604">It happens when a valid user performs an HTTP transaction
    and a malicious script lurking in the browser usurps valid credentials with bogus
    and invalid ones to lead transactions to</st> <st c="3785">untrusted systems.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="3803">Applying form validation to request data</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="3844">One solution to avoid these attacks is to design a form validation
    that will not cost several lines of code or add more performance</st> <st c="3976">overhead
    to the view or API functions.</st> <st c="4016">The</st> `<st c="4066">FlaskForm</st>`
    <st c="4075">class that sub-classes form models with attributes mapped to the
    appropriate field classes.</st> <st c="4168">Each field class (e.g.,</st> `<st
    c="4192">StringField</st>`<st c="4203">,</st> `<st c="4205">BooleanField</st>`<st
    c="4217">,</st> `<st c="4219">DateField</st>`<st c="4228">, or</st> `<st c="4233">TimeField</st>`<st
    c="4242">) has properties and built-in validators (e.g.,</st> `<st c="4291">Length()</st>`<st
    c="4299">,</st> `<st c="4301">Email()</st>`<st c="4308">, or</st> `<st c="4313">DataRequired()</st>`<st
    c="4327">) with support on custom validators</st> <st c="4364">when the validation
    procedure requires intricate conditions.</st> <st c="4425">With the validators
    in place, it can more or less protect the application from exploits.</st> <st
    c="4514">Further discussion on using Flask-WTF is included in</st> [*<st c="4567">Chapter
    4</st>*](B19383_04.xhtml#_idTextAnchor087)<st c="4576">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="4577">If the application is non-web or web-based and does not need form
    model classes,</st> `<st c="5199">pip</st>` <st c="5202">command:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: <st c="5239">After the installation, the module does not need further setup.</st>
    <st c="5304">It can be used readily when building the validation rules, such as
    in the following validation rules that scrutinize the incoming</st> <st c="5434">administrator’s
    profile:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '@current_app.route(''/admin/profile/add'', methods=[''GET'', ''POST''])'
  prefs: []
  type: TYPE_NORMAL
- en: 'async def add_admin_profile():'
  prefs: []
  type: TYPE_NORMAL
- en: 'if not session.get("user"):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return redirect('/login/auth')
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: … … … … … …
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if request.method == ''GET'':'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return render_template('admin/add_admin_profile.html', admin=admin_rec), 200
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'else:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: result = validate_form(request.form)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if result == False:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: flash(f'Validation problem.', 'error')
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: return render_template('admin/add_admin_profile.html', admin=admin_rec), 200
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: … … … … … …
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: return render_template('admin/add_admin_profile.html', admin=admin_rec), 200
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '@current_app.route(''/admin/profile/add'', methods=[''GET'', ''POST''])'
  prefs: []
  type: TYPE_NORMAL
- en: 'async def add_admin_profile():'
  prefs: []
  type: TYPE_NORMAL
- en: … … … … … …
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: result = validate_form(request.form)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if result == False:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: flash(f'Validation problem.', 'error')
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: return render_template('admin/add_admin_profile.html', admin=admin_rec), 200
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: username = request.form['username']
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: … … … … … …
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: admin_details = {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"adminid": escape(request.form[''adminid''].strip()),'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '"username": escape(request.form[''username''].strip()),'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '"firstname": escape(request.form[''firstname''].strip()),'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: … … … … … …
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '"gender": escape(request.form[''gender''].strip())'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: admin = Administrator(**admin_details)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: result = await repo.insert_admin(admin)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if result == False:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: flash(f'Error adding … profile.', 'error')
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'else:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: flash(f'Successfully added a user … )
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: return render_template('admin/add_admin_profile.html', admin=admin_rec), 200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '<st c="14222">@app.after_request</st> def create_sec_resp_headers(response):'
  prefs: []
  type: TYPE_NORMAL
- en: response.headers['Content-Type'] = 'text/html; charset=UTF-8'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: response.headers['X-Content-Type-Options'] = 'nosniff'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: response.headers['X-Frame-Options'] = 'SAMEORIGIN'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'response.headers[''Strict-Transport-Security''] = ''Strict-Transport-Security:
    max-age=63072000; includeSubDomains; preload'''
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return response
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: pip install flask-talisman
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '<st c="16327">from flask_talisman import Talisman</st> def create_app(config_file):'
  prefs: []
  type: TYPE_NORMAL
- en: app = Flask(__name__,template_folder= '../modules/pages', static_folder= '../modules/resources')
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: app.config.from_file(config_file, toml.load)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: … … … … … … <st c="16547">talisman = Talisman(app)</st> csp = {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '''default-src'': ['
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '''\''self\'''','
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '''https://code.jquery.com'','
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '''https://cdnjs.com'','
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '''https://cdn.jsdelivr.net'','
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ']'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: hsts = {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '''max-age'': 31536000,'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '''includeSubDomains'': True'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '} <st c="16747">talisman.force_https = True</st> talisman.force_file_save =
    True <st c="16807">talisman.x_xss_protection = True</st><st c="16839">talisman.session_cookie_secure
    = True</st> talisman.frame_options_allow_from = ''https://www.google.com'' <st
    c="17226">default-src</st>, <st c="17239">image-src</st>, <st c="17250">style-src</st>,
    <st c="17261">media-src</st>, <st c="17272">object-src</st> ). In our configuration,
    JS files must only come from <st c="17337">https://code.jquery.com</st>, <st c="17362">https://cdnjs.com</st>,
    <st c="17381">https://cdn.jsdelivr.net</st>, and the localhost, while both CSS
    and images must be fetched from the localhost as indicated in <st c="17503">default-src</st>,
    the fallback resources for each view page. Specifying <st c="17570">script-src</st>
    with specific JS sources, <st c="17607">style-src</st> with CSS resources, and
    <st c="17641">image-src</st> with the targeted images will bypass the <st c="17692">default-src</st>
    setting.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="17712">Aside from CSP, the Talisman can add</st> `<st c="17750">X-XSS-Protection</st>`<st
    c="17766">,</st> `<st c="17768">Referrer-Policy</st>`<st c="17783">, and</st>
    `<st c="17789">Set-Cookie</st>`<st c="17799">, as well as the headers previously
    included in the response by the</st> `<st c="17867">@after_request</st>` <st c="17881">function.</st>
    <st c="17892">Caution is needed in combining the two approaches because overlapping
    of header settings</st> <st c="17981">may happen.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="17992">Adding the</st> `<st c="18004">Strict-Transport-Security</st>`
    <st c="18029">header in the response and setting the</st> `<st c="18069">force_https</st>`
    <st c="18080">of Talisman’s property to</st> `<st c="18107">True</st>` <st c="18111">requires
    running the application in HTTPS mode.</st> <st c="18160">Let us explore the latest
    and easiest way to enable HTTPS for a</st> <st c="18224">Flask application.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="18242">Using HTTPS to run request/response transactions</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="18291">HTTPS is a TLS-encrypted HTTP protocol.</st> <st c="18332">It
    establishes secured communication between the transmitter and receiver of data,
    protecting</st> <st c="18425">the cookies, URLs, and sensitive information</st>
    <st c="18471">that flows during the exchange.</st> <st c="18503">It also guards
    the integrity of the data and the user’s authenticity since it requires the user’s
    private key to allow access.</st> <st c="18630">With that, to enable the HTTPS
    protocol, the WSGI server must run with a public and private key certificate generated
    by an SSL key generator.</st> <st c="18773">By convention, the certificate must
    be saved inside the project directory or somewhere safe in the host server.</st>
    <st c="18885">This chapter</st> <st c="18897">utilizes the</st> **<st c="18911">OpenSSL</st>**
    <st c="18918">tool to produce</st> <st c="18935">the certificate.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="18951">Install the latest</st> `<st c="18971">pyopenssl</st>` <st c="18980">using
    the following</st> `<st c="19001">pip</st>` <st c="19004">command:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: <st c="19035">Now, to run the application, include the</st> <st c="19076">private
    and public keys in</st> `<st c="19104">run()</st>` <st c="19109">through its</st>
    `<st c="19122">ssl_context</st>` <st c="19133">parameter.</st> <st c="19145">The
    following</st> `<st c="19159">main.py</st>` <st c="19166">snippet shows how to
    run the application using HTTPS</st> <st c="19220">on a</st> <st c="19225">development
    server:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: <st c="22650">from werkzeug.security import generate_password_hash</st> @current_app.post('/login/signup')
  prefs: []
  type: TYPE_NORMAL
- en: 'async def add_signup():'
  prefs: []
  type: TYPE_NORMAL
- en: 'login_json = request.get_json() <st c="22795">password = login_json["password"]</st><st
    c="22828">passphrase = generate_password_hash(password)</st> async with db_session()
    as sess:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'async with sess.begin():'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: repo = LoginRepository(sess)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: login = Login(username=login_json["username"], <st c="23009">password=passphrase</st>,
    role=login_json["role"])
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: result = await repo.insert_login(login)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if result == False:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: return jsonify(message="error in insert"), 201
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: return jsonify(record=login_json), 200
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: <st c="24662">from werkzeug.security import check_password_hash</st> @auth.verify_password
  prefs: []
  type: TYPE_NORMAL
- en: 'def verify_password(username, password):'
  prefs: []
  type: TYPE_NORMAL
- en: task = get_user_task_wrapper.apply_async( args=[username])
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: login:Login = task.get()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if login == None:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'abort(403) <st c="24889">if check_password_hash(login.password, password)</st>:
    <st c="24940">return login.username</st> else:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: abort(403)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: pip install hashlib
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: pip install bcrypt
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: <st c="25876">from flask_bcrypt import Bcrypt</st>
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="25908">bcrypt = Bcrypt()</st> def create_app(config_file):'
  prefs: []
  type: TYPE_NORMAL
- en: app = Flask(__name__, template_folder='../modules/pages', static_folder='../modules/resources')
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: app.config.from_file(config_file, toml.load)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: app.config.from_prefixed_env()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: … … … … … … <st c="26140">bcrypt.init_app(app)</st> … … … … … …
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: <st c="26489">from modules import bcrypt</st> @current_app.post('/login/signup')
  prefs: []
  type: TYPE_NORMAL
- en: 'async def add_signup():'
  prefs: []
  type: TYPE_NORMAL
- en: login_json = request.get_json()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'password = login_json["password"] <st c="26642">passphrase = bcrypt.generate_password_hash(password)</st><st
    c="26694">.decode(''utf-8'')</st> async with db_session() as sess:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'async with sess.begin():'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: repo = LoginRepository(sess)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: … … … … … …
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: result = await repo.insert_login(login)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if result == False:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: return jsonify(message="error in insert"), 201
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: return jsonify(record=login_json), 200
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: pip install cryptography
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '<st c="28451">from cryptography.fernet import Fernet</st> def create_app(config_file):'
  prefs: []
  type: TYPE_NORMAL
- en: app = Flask(__name__,  template_folder='../modules/pages', static_folder='../modules/resources')
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: app.config.from_file(config_file, toml.load)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: … … … … … … <st c="28764">Fernet</st> token or secret key is a URL-safe base64-encoded
    alphanumeric that will instigate the encryption and decryption algorithms. The
    application should store the key in a safe and inaccessible location during startup,
    such as saving it in a file inside a secured directory. Missing the key will lead
    to <st c="29069">cryptography.fernet.InvalidToken</st> and <st c="29106">cryptography.exceptions.InvalidSignature</st>
    errors.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="29154">After generating the secret key, instantiate the</st> `<st c="29204">Fernet</st>`
    <st c="29210">class with the key as the constructor argument to emit the</st>
    `<st c="29270">encrypt()</st>` <st c="29279">method.</st> <st c="29288">The following</st>
    `<st c="29302">ch09-auth-digest</st>`<st c="29318">’s version of</st> `<st c="29333">add_signup()</st>`
    <st c="29345">encrypts the user password</st> <st c="29373">using</st> `<st c="29379">Fernet</st>`<st
    c="29385">:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: <st c="29850">To instantiate</st> `<st c="29866">Fernet</st>`<st c="29872">,</st>
    `<st c="29874">add_signup()</st>` <st c="29886">must extract the token from the
    file, convert it into bytes, and pass it as a constructor argument to the</st>
    `<st c="29993">Fernet</st>` <st c="29999">class.</st> <st c="30007">The</st> `<st
    c="30011">Fernet</st>` <st c="30017">instance provides an</st> `<st c="30039">encrypt()</st>`
    <st c="30048">method that</st> <st c="30061">uses the</st> `<st c="30174">decrypt()</st>`
    <st c="30183">method to</st> <st c="30194">extract the original</st> <st c="30214">password
    from the encrypted message.</st> <st c="30252">The following is</st> `<st c="30269">ch09-auth-digest</st>`<st
    c="30285">’s password validation scheme that retrieves the user credentials from
    the database with the encoded password and decrypts the encoded message to extract
    the</st> <st c="30444">actual password:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: <st c="30806">Again,</st> `<st c="30814">get_passwd()</st>` <st c="30826">needs
    the token from the file to instantiate</st> `<st c="30872">Fernet</st>`<st c="30878">.
    Using the</st> `<st c="30890">Fernet</st>` <st c="30896">instance,</st> `<st c="30907">get_passwd()</st>`
    <st c="30919">can emit the</st> `<st c="30933">decrypt()</st>` <st c="30942">method
    to reassemble the encrypted message and extract the actual password in the</st>
    `<st c="31025">UTF-8</st>` <st c="31030">format.</st> <st c="31039">Compared to
    hashing, encryption involves reassembling plain text into an unreadable and uncrackable
    ciphertext</st> <st c="31150">using a token and reverting that ciphertext into
    its original readable form.</st> <st c="31227">So, it’s a two-way process, unlike</st>
    <st c="31262">in hashing.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="31273">If the goal is to persist encoded data into the database without
    adding unnecessary cryptographic blunders that can slow down software performance,
    the solution is to</st> <st c="31441">use</st> `<st c="31445">sqlalchemy_utils</st>`<st
    c="31461">.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="31462">Using sqlalchemy_utils for encrypted columns</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="31507">The</st> `<st c="31512">sqlalchemy_utils</st>` <st c="31528">module
    provides additional utility methods and column types to SQLAlchemy model classes,
    which include</st> `<st c="31632">StringEncryptedType</st>`<st c="31651">. Since
    the module utilizes cryptographic</st> <st c="31692">recipes of the cryptography</st>
    <st c="31721">module, be sure to install the latter before</st> `<st c="31766">sqlalchemy_utils</st>`
    <st c="31782">using the following</st> `<st c="31803">pip</st>` <st c="31806">command:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: <st c="31857">Afterward, design your model classes by applying</st> `<st c="31907">StringEncryptedType</st>`
    <st c="31926">to table columns that need</st> `<st c="31954">Fernet</st>`<st c="31960">’s
    encryption, such as the</st> `<st c="31988">username</st>` <st c="31996">and</st>
    `<st c="32001">password</st>` <st c="32009">columns.</st> <st c="32019">The following
    is the</st> `<st c="32040">Login</st>` <st c="32045">model class of the</st> `<st
    c="32065">ch09-web-passphrase</st>` <st c="32084">project with</st> `<st c="32098">username</st>`
    <st c="32106">and</st> `<st c="32111">password</st>` <st c="32119">columns</st>
    <st c="32128">of</st> `<st c="32131">StringEncryptedType</st>`<st c="32150">:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '`<st c="32566">StringEncryptedType</st>` <st c="32586">automatically encrypts
    the column data during the</st> `<st c="32637">INSERT</st>` <st c="32643">transaction
    and decrypts the encoded field value during the</st> `<st c="32704">SELECT</st>`
    <st c="32710">statements.</st> <st c="32723">To apply the utility class to the
    column, map it to the column field enclosing the actual SQLAlchemy column</st>
    <st c="32830">type with the custom-generated</st> `<st c="32862">Fernet</st>`
    <st c="32868">token.</st> <st c="32876">It may look like a column field wrapper
    that will filter and encrypt the inserted field value and decrypt it during retrieval.</st>
    <st c="33003">No other additional coding from the</st> `<st c="33039">view</st>`
    <st c="33043">functions or repository layer is needed to perform the encryption</st>
    <st c="33109">and decryption processes on these</st> <st c="33144">field values.</st>'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="33157">When using</st> `<st c="33169">Flask-Migrate</st>`<st c="33182">,
    add the</st> `<st c="33192">import sqlalchemy_utils</st>` <st c="33215">statement
    to the generated</st> `<st c="33243">env.py</st>` <st c="33249">and</st> `<st
    c="33254">script.py.mako</st>` <st c="33268">files inside the</st> `<st c="33286">migrations</st>`
    <st c="33296">folder after running the</st> `<st c="33322">db init</st>` <st c="33329">command
    and before running the</st> `<st c="33361">db migrate</st>` <st c="33371">and</st>
    `<st c="33376">db upgrade</st>` <st c="33386">operations.</st> <st c="33399">The
    following are the modified</st> `<st c="33430">ch09-web-passphrase</st>` <st c="33449">migration
    files with the imported</st> `<st c="33484">sqlalchemy_utils</st>` <st c="33500">module:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: <st c="33903">The highlighted lines provided in</st> <st c="33937">the given
    migration files are the proper places to add extra imports used in the SQLAlchemy
    model classes.</st> <st c="34045">This includes not only the</st> `<st c="34072">sqlalchemy_util</st>`
    <st c="34087">classes but also other libraries that may help to establish the
    desired</st> <st c="34160">model layer.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="34172">When customizing user authentication, the application utilizes
    the default Flask session to store user information, such as username.</st> <st
    c="34307">This session saves information to the browser.</st> <st c="34354">To
    protect the app from broken access control attacks, you can use a reliable authentication
    and authorization mechanism or apply server-side session handling through the</st>
    **<st c="34525">Flask-Session</st>** <st c="34538">module if custom session-based
    authentication suits</st> <st c="34591">your requirements.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="34609">Utilizing the server-side sessions</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="34644">In</st> [*<st c="34648">Chapter 4</st>*](B19383_04.xhtml#_idTextAnchor087)<st
    c="34657">, the</st> `<st c="35144">username</st>`<st c="35152">, to</st> <st
    c="35157">the public.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="35168">After setting up the</st> `<st c="35190">Session</st>` <st c="35197">class
    of the module through the</st> `<st c="35230">app</st>` <st c="35233">instance,
    Flask’s built-in</st> `<st c="35261">session</st>` <st c="35268">dictionary object
    can readily store session data on the server side.</st> <st c="35338">The following</st>
    `<st c="35352">login_user()</st>` <st c="35364">view function stores the</st>
    `<st c="35390">username</st>` <st c="35398">of the credentia</st><st c="35415">l
    to the server-side session after user</st> <st c="35456">credential</st> <st c="35467">confirmation:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: <st c="36087">All session data needs to be cleared when logging out.</st> <st
    c="36143">Removing all session data will</st> `<st c="36294">logout()</st>` <st
    c="36302">view function of the</st> `<st c="36324">ch09-web-paraphrase</st>` <st
    c="36343">project:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: <st c="36473">Aside from setting the</st> <st c="36496">session attribute to</st>
    `<st c="36518">None</st>`<st c="36522">, the</st> `<st c="36528">pop()</st>` <st
    c="36533">method of the</st> `<st c="36548">session</st>` <st c="36555">object
    can also help remove the session data.</st> <st c="36602">Removing all session
    data is the same as invalidating the</st> <st c="36660">current session.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="36676">Now, if custom web login implementation does not apply to your
    requirement, the</st> **<st c="36757">Flask-Login</st>** <st c="36768">module
    can offer built-in utilities for user login and logout.</st> <st c="36832">Let
    us now discuss how to use Flask-Login for a</st> <st c="36880">Flask application.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="36898">Implementing web form authentication</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`<st c="37184">flask-login</st>`<st c="37195">, install it first using the
    following</st> `<st c="37234">pip</st>` <st c="37237">command:</st>'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: <st c="37270">Also, install and set up the Flask-Session module for Flask-Login
    to store its user session in</st> <st c="37366">the filesystem.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="37381">Then, to integrate Flask-login into the Flask application, instantiate
    its</st> `<st c="37457">LoginManager</st>` <st c="37469">class in the</st> `<st
    c="37483">create_app()</st>` <st c="37495">method and set it up through the</st>
    `<st c="37529">app</st>` <st c="37532">instance.</st> <st c="37543">Define some
    of its properties such as</st> `<st c="37581">session_protection</st>`<st c="37599">,
    which requires the installation of Flask-Bcrypt, and</st> `<st c="37654">login_view</st>`<st
    c="37664">, which designates the</st> `<st c="37687">login view</st>` <st c="37697">function.</st>
    <st c="37708">The following snippet</st> <st c="37730">shows the setup of Flask-Login
    for our</st> `<st c="37769">ch09-web-login</st>` <st c="37783">project:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: <st c="38475">from flask_login import UserMixin</st> from sqlalchemy_utils import
    StringEncryptedType
  prefs: []
  type: TYPE_NORMAL
- en: enc_key = "packt_pazzword" <st c="38585">class Login(UserMixin, Base):</st>
    __tablename__ = 'login'
  prefs: []
  type: TYPE_NORMAL
- en: id = Column(Integer, Sequence('login_id_seq', increment=1), primary_key = True)
  prefs: []
  type: TYPE_NORMAL
- en: username = Column(StringEncryptedType(String(20), enc_key), nullable=False,
    unique=True)
  prefs: []
  type: TYPE_NORMAL
- en: password = Column(StringEncryptedType(String(50), enc_key), nullable=False)
  prefs: []
  type: TYPE_NORMAL
- en: role = Column(Integer, nullable=False)
  prefs: []
  type: TYPE_NORMAL
- en: … … … … … …
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '<st c="39901">@login_auth.user_loader</st> def load_user(<st c="39940">id</st>):'
  prefs: []
  type: TYPE_NORMAL
- en: task = get_user_task_wrapper.apply_async(args=[id])
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: result = task.get() <st c="40077">main.py</st> module. Now, using the <st c="40108">get_user_task_wrapper()</st>
    Celery task, the <st c="40149">load_user()</st> uses the <st c="40170">select_login()</st>
    transaction of the <st c="40204">LoginRepository</st> to retrieve a <st c="40234">Login</st>
    record based on the given <st c="40266">id</st> parameter. The application automatically
    calls <st c="40316">load_user()</st> for every request to access the views. The
    continuous call to the callback function checks the validity of the user. The
    returned <st c="40458">Login</st> object serves as a token that permits the user
    to access the application. To declare a user loader callback function, create
    a function with one local <st c="40615">id</st> parameter and decorate it with
    the <st c="40653">userloader()</st> decorator of the <st c="40683">LoginManager</st>
    instance.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="40705">The</st> `<st c="40710">login view</st>` <st c="40720">function
    caches the</st> `<st c="40741">Login</st>` <st c="40746">object, saves the</st>
    `<st c="40765">Login</st>`<st c="40770">’s</st> `<st c="40774">id</st>` <st c="40776">to
    the session, and maps it to the</st> `<st c="40812">current_user</st>` <st c="40824">proxy
    object of the</st> `<st c="40845">flask_login</st>` <st c="40856">module.</st>
    <st c="40865">The following snippet</st> <st c="40887">shows the</st> `<st c="40897">login
    view</st>` <st c="40907">function indicated in</st> <st c="40930">our setup:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: <st c="41562">If the</st> `<st c="41570">POST</st>`<st c="41574">-submitted
    user credentials are correct based on the database validation, the</st> `<st c="41653">login
    view</st>` <st c="41663">function, namely our</st> `<st c="41685">login_valid_user()</st>`<st
    c="41703">, should invoke the</st> `<st c="41723">login_user()</st>` <st c="41735">method
    of the</st> `<st c="41750">flask_login</st>` <st c="41761">module.</st> <st c="41770">The
    view must pass the queried</st> `<st c="41801">Login</st>` <st c="41806">object
    containing the user’s login credentials to the</st> `<st c="41861">login_user()</st>`
    <st c="41873">function.</st> <st c="41884">Aside from the</st> `<st c="41899">Login</st>`
    <st c="41904">object, the method has other options, such as</st> <st c="41951">the
    following:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`<st c="41965">remember</st>`<st c="41974">: A boolean</st> <st c="41987">parameter
    that enables the</st> `<st c="42014">remember_me</st>` <st c="42025">feature,
    which allows the user session to be alive even after a browser’s</st> <st c="42100">accidental
    exit.</st>'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="42116">fresh</st>`<st c="42122">: A boolean parameter that sets a user
    as</st> `<st c="42165">not fresh</st>` <st c="42174">if their session is valid
    right after the closing of</st> <st c="42228">a browser.</st>'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="42238">force</st>`<st c="42244">: A boolean parameter that forces a
    user to be</st> <st c="42292">logged in.</st>'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="42302">duration</st>`<st c="42311">: The amount of time before the</st>
    `<st c="42344">remember_me</st>` <st c="42356">cookie expires.</st>'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '<st c="42371">After the successful authentication, users</st> <st c="42415">can
    now access the restricted views or APIs that are off-limits to non-authenticated
    users: those views with</st> `<st c="42524">@login_required</st>` <st c="42539">decorator.</st>
    <st c="42551">The following is a samp</st><st c="42574">le view function of our</st>
    `<st c="42599">ch09-web-login</st>` <st c="42613">that needs authenticated</st>
    <st c="42639">user access:</st>'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: <st c="43215">Aside from the decorator, the</st> `<st c="43246">current_user</st>`<st
    c="43258">’s</st> `<st c="43262">is_authenticated</st>` <st c="43278">property
    can also restrict the execution</st> <st c="43320">of some code fragments in the
    views and</st> <st c="43360">Jinja templates.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="43376">Lastly, to complete the integration of</st> <st c="43416">Flask-Login,
    implement a</st> `<st c="43468">logout_user()</st>` <st c="43481">utility of the</st>
    `<st c="43497">flask_login</st>` <st c="43508">module.</st> <st c="43517">The
    following code is the logout view implementation for</st> <st c="43574">our project:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: <st c="43731">Be sure that the logout view redirects the user to the login view
    page instead of just rendering the login page to</st> <st c="43846">avoid</st>
    **<st c="43853">HTTP status code 405</st>** <st c="43873">(</st>*<st c="43875">Method
    Not Allowed</st>*<st c="43893">)</st> <st c="43896">during re-login.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="43912">Does having a secured</st> <st c="43934">web form authentication
    prevent CSRF attacks from happening?</st> <st c="43996">Let us focus on protecting
    our applications from attackers who want to divert transactions to other</st>
    <st c="44096">suspicious sites.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="44113">Preventing CSRF attacks</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="44137">CSRF is an attack whereby authenticated users are duped into diverting
    sensitive data to hidden and malicious sites.</st> <st c="44255">This attack happens</st>
    <st c="44274">when users perform</st> `<st c="44294">POST</st>`<st c="44298">,</st>
    `<st c="44300">DELETE</st>`<st c="44306">,</st> `<st c="44308">PUT</st>`<st c="44311">,
    or</st> `<st c="44316">PATCH</st>` <st c="44321">transactions, whereby form data
    are retrieved and submitted to the application.</st> <st c="44402">In Flask, the
    most common solution is to use</st> `<st c="44447">Flask-WTF</st>` <st c="44456">because
    it has a built-in</st> `<st c="44483">CSRFProtect</st>` <st c="44494">class that
    globally protects every form transaction of the application.</st> <st c="44567">Once
    enabled,</st> `<st c="44581">CSRFProtect</st>` <st c="44592">allows the generation
    of unique tokens for every form transaction.</st> <st c="44660">Those form submissions
    that will not generate a token will cause</st> `<st c="44725">CSRFProtect</st>`
    <st c="44736">to trigger an error message, detecting a</st> <st c="44778">CSRF
    attack.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[*<st c="44790">Chapter 4</st>*](B19383_04.xhtml#_idTextAnchor087) <st c="44800">highlights
    the setup of the Flask-</st>`<st c="44835">WTF</st>` <st c="44839">module in a
    Flask application.</st> <st c="44871">After its installation, import</st> `<st
    c="44902">CSRFProtect</st>` <st c="44913">and instantiate it in</st> `<st c="44936">create_app()</st>`<st
    c="44948">, as shown in the following</st> <st c="44976">code snippet:</st>'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '<st c="47138">from flask_httpauth import HTTPBasicAuth</st> def create_app(config_file):'
  prefs: []
  type: TYPE_NORMAL
- en: app = Flask(__name__,template_folder= '../modules/pages', static_folder= '../modules/resources')
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: app.config.from_file(config_file, toml.load)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '… … … … … … <st c="47408">HTTPBasicAuth</st> implementation needs a callback
    function that will retrieve the username and password from the client, query the
    database to check the user’s records, and return the valid username to the application
    if it exists, like in the following code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '<st c="48869">from werkzeug.datastructures.auth import Authorization</st> app,
    celery_app, <st c="48942">auth</st> = <st c="48949">create_app(''../config_dev.toml'')</st>
    … … … … … … <st c="48993">@auth.get_user_roles</st> def get_scope(<st c="49028">user:Authorization</st>):'
  prefs: []
  type: TYPE_NORMAL
- en: task = get_user_task_wrapper.apply_async( args=[user.username])
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'login:Login = task.get() <st c="49173">get_scope()</st> automatically retrieves
    the <st c="49213">werkzeug.datastructures.auth.Authorization</st> object from
    the request. The <st c="49285">Authorization</st> object contains the <st c="49319">username</st>
    on which the <st c="49341">get_user_task_wrapper()</st> Celery task will base
    its search for the <st c="49406">Login</st> record object of the user from the
    database. The return value of the callback function can be a single role in string
    format or a list of roles attributed to the user. The given <st c="49590">del_doctor_profile_id()</st>
    from the <st c="49623">ch09-auth-digest</st> project does not permit any authenticated
    users except for doctors whose <st c="49713">role</st> is equivalent to the <st
    c="49739">1</st> code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: <st c="50018">Here,</st> `<st c="50025">del_doctor_profile_id()</st>` <st c="50048">is
    an API function that deletes a doctor’s profile information in the database.</st>
    <st c="50129">No</st> <st c="50131">role can perform the transaction but the doctor
    (</st>`<st c="50181">role=1</st>`<st c="50188">) himself/herself.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="50207">Digest authentication</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="50229">On the other hand, the module’s</st> `<st c="50262">HTTPDigestAuth</st>`
    <st c="50276">builds a digest authentication scheme for the API-based applications,
    which</st> <st c="50352">encrypts the credentials and some of its additional headers
    to the applications such as</st> `<st c="50441">realm</st>`<st c="50446">,</st>
    `<st c="50448">nonce</st>`<st c="50453">,</st> `<st c="50455">opaque</st>`<st
    c="50461">, and</st> `<st c="50467">nonce count</st>`<st c="50478">. Thus, it
    is more secure than</st> <st c="50509">the basic authentication scheme.</st> <st
    c="50542">The following snippet shows how to set up digest authentication in the</st>
    `<st c="50613">create_app()</st>` <st c="50625">factory:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: <st c="53886">server_nonce = "H9OVSzjcB57StMQFPInmX22uZ0Kwu_4JptsWrj0oPpU"</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="53947">server_opaque = "XJIXDX615CMGXXL0COHQQ0IJRG33OFTNGNFYT72VJ8XF5U3RYZ"</st>
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="54016">@auth.generate_nonce</st> def gen_nonce():'
  prefs: []
  type: TYPE_NORMAL
- en: 'return server_nonce <st c="54075">@auth.generate_opaque</st> def gen_opaque():'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return server_opaque
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '<st c="54758">@auth.verify_nonce</st> def verify_once(nonce):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if nonce == server_nonce:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return True
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'else:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'return False <st c="54859">@auth.verify_opaque</st> def verify_opaque(opaque):'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if opaque == server_opaque:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return True
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'else:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return False
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '<st c="55300">@auth.get_password</st> def get_passwd(username):'
  prefs: []
  type: TYPE_NORMAL
- en: print(username)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: task = get_user_task_wrapper.apply_async(args=[username])
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: login:Login = task.get()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: … … … … … …
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if login == None: <st c="55475">return None</st> else: <st c="55548">get_password()</st>
    method every access to an API resource and provides the valid user’s password
    as a token.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="55652">Bearer token authentication</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="55680">Aside from Basic and Digest, the</st> `<st c="55714">Flask-HTTPAuth</st>`
    <st c="55728">module also supports the Bearer token authentication scheme by utilizing
    the</st> `<st c="55806">HTTPTokenAuth</st>` <st c="55819">class.</st> <st c="55827">The
    following</st> `<st c="55841">create_app()</st>` <st c="55853">snippet</st> <st
    c="55861">of the</st> `<st c="55869">ch09-auth-token</st>` <st c="55884">project
    sets</st> <st c="55897">up the Bearer</st> <st c="55912">token authentication:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: <st c="56530">from jwt import encode</st>
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="56553">@current_app.post(''/login/signup'')</st> async def add_signup():'
  prefs: []
  type: TYPE_NORMAL
- en: login_json = request.get_json()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: password = login_json["password"]
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'passphrase = generate_password_hash(password) <st c="56725">token = encode({''username'':
    login_json["username"],</st> <st c="56776">''exp'': int(time()) + 3600},</st>
    <st c="56804">current_app.config[''SECRET_KEY''],</st> <st c="56838">algorithm=''HS256'')</st>
    async with db_session() as sess:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'async with sess.begin():'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: repo = LoginRepository(sess)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: login = Login(username=login_json["username"], password=passphrase, <st c="57013">token=token</st>,   role=login_json["role"])
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: result = await repo.insert_login(login)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: … … … … … …
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: return jsonify(record=login_json), 200
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: <st c="57661">from jwt import decode</st>
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="57684">@auth.verify_token</st> def verify_token(token):'
  prefs: []
  type: TYPE_NORMAL
- en: 'try: <st c="57734">data = decode(token, app.config[''SECRET_KEY''],</st><st
    c="57780">algorithms=[''HS256''])</st> except:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return False
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if ''username'' in data:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return data['username']
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: pip install authlib
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: <st c="59932">from authlib.integrations.flask_oauth2 import AuthorizationServer</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="59998">from authlib.integrations.flask_oauth2 import ResourceProtector</st>
    from modules.security.oauth2_config import <st c="60106">PasswordGrant</st>, <st
    c="60121">query_client</st>, <st c="60135">save_token</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="60145">require_oauth = ResourceProtector()</st>
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="60181">oauth_server = AuthorizationServer()</st> def create_app(config_file):'
  prefs: []
  type: TYPE_NORMAL
- en: app = Flask(__name__,template_folder= '../modules/pages', static_folder=   '../modules/resources')
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: … … … … … …
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: oauth_server.init_app(app, query_client=<st c="60397">query_client</st>, save_token=<st
    c="60423">save_token</st>)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: oauth_server.register_grant(<st c="60485">AuthorizationServer</st> class manages
    the authentication requests and responses of the application. It provides different
    types of endpoints that are suited to the authentication grant enforced by the
    application. Now, instantiating the class is the first step in building the OAuth2
    authorization server for clients or other applications. It needs <st c="60830">query_client()</st>
    and <st c="60849">save_token()</st> for its token generation and the grant type
    of the authorization mechanism.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="60937">Authlib</st> <st c="60946">provides the</st> `<st c="60959">ResourceOwnerPasswordCredentialsGrant</st>`
    <st c="60996">class to implement the</st> `<st c="61133">authenticate_user()</st>`
    <st c="61152">to perform validation before performing the</st> `<st c="61197">query_client()</st>`
    <st c="61211">and</st> `<st c="61216">save_token()</st>` <st c="61228">methods.</st>
    <st c="61238">The following snippet shows the</st> `<st c="61270">ResourceOwnerPasswordCredentialsGrant</st>`
    <st c="61307">subclass of our</st> `<st c="61324">ch09-oauth2-password</st>` <st
    c="61344">project:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'def query_client(<st c="62911">client_id</st>):'
  prefs: []
  type: TYPE_NORMAL
- en: task = get_client_task_wrapper.apply_async( args=[<st c="62975">client_id</st>])
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: client:Client = task.get()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return client
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '<st c="63427">from authlib.integrations.sqla_oauth2 import OAuth2ClientMixin</st>
    class Client(Base, <st c="63509">OAuth2ClientMixin</st>):'
  prefs: []
  type: TYPE_NORMAL
- en: __tablename__ = 'oauth2_client'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: id = Column(Integer, Sequence('oauth2_client_id_seq', increment=1), primary_key
    = True)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: user_id = Column(String(20), ForeignKey('login.username'), unique=True)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: login = relationship('Login', back_populates="client")
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: … … … … … …
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '<st c="64333">from authlib.integrations.flask_oauth2.requests import FlaskOAuth2Request</st>
    def save_token(token_data, <st c="64434">request:FlaskOAuth2Request</st>):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if request.user:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: user_id = request.user.user_id
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'else:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: user_id = request.client.user_id
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: token_dict = dict()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: token_dict['client_id'] = request.client.client_id
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: token_dict['user_id'] = user_id
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: token_dict['issued_at'] = request.client.client_id_issued_at
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: token_dict['access_token_revoked_at'] = 0
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: token_dict['refresh_token_revoked_at'] = 0
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: token_dict['scope'] = request.client.client_metadata["scope"]
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: token_dict.update(token_data)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'token_str = dumps(token_dict) <st c="64998">token_data</st> contains the <st
    c="65022">access_token</st>, and the request has the <st c="65060">Client</st>
    data retrieved from the <st c="65091">query_client()</st>. The method merges all
    these details into one <st c="65152">token_dict</st>, instantiates the <st c="65181">Token</st>
    class with <st c="65198">token_dict</st> as parameter, and stores the object record
    in the database. The following is the blueprint of the <st c="65307">Token</st>
    model:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: <st c="65676">The</st> `<st c="65681">OAuth2TokenMixin</st>` <st c="65697">pads
    the</st> `<st c="65707">Token</st>` <st c="65712">class with the attributes related
    to</st> `<st c="65750">access_token</st>`<st c="65762">, such as</st> `<st c="65772">id,</st>`
    `<st c="65775">user_id</st>`<st c="65783">,</st> `<st c="65785">client_id</st>`<st
    c="65794">,</st> `<st c="65796">token_type</st>`<st c="65806">,</st> `<st c="65808">refresh_token</st>`<st
    c="65821">, and</st> `<st c="65827">scope</st>`<st c="65832">. By the way,</st>
    `<st c="65846">scope</st>` <st c="65851">is a mandatory field in Authlib that
    restricts access to the API resources based on some access level</st> <st c="65954">or
    role.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="65962">To trigger the authorization</st> <st c="65992">server, the client
    must access the</st> `<st c="66027">/oauth/token</st>` <st c="66039">endpoint
    through basic authentication or form-based transactions.</st> <st c="66106">The
    following code shows the endpoint implementation of</st> <st c="66162">our application:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: curl -u Xd3LH9mveF524LOscPq4MzLY:t8w56Y9OBRsxdVV9vrNwdtMzQ 8gY4hkKLKf4b6F6RQZlT2zI
    -XPOST http://localhost:5000/oauth/token -F grant_type=password -F username=sjctrags
    -F password=sjctrags -F scope=user_admin -F token_endpoint_auth_method=client_secret_basic
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '{"access_token": "fVFyaS06ECKIKFVtIfVj3ykgjhQjtc80JwCKyTMlZ2", "expires_in":
    864000, "scope": "user_admin", "token_type": "Bearer"}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'curl -H "Authorization: Bearer fVFyaS06ECKIKFVtIfVj3y kgjhQjtc80JwCKyTMlZ2"
    http://localhost:5000/doctor/profile/add'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '<st c="67915">from modules import require_oauth</st> @current_app.route(''/doctor/profile/add'',
    methods = [''GET'', ''POST'']) <st c="68019">@require_oauth("user_admin")</st>
    async def add_doctor_profile():'
  prefs: []
  type: TYPE_NORMAL
- en: … … … … … …
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'async with db_session() as sess:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'async with sess.begin():'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: repo = DoctorRepository(sess)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: doc = Doctor(**doctor_json)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: result = await repo.insert_doctor(doc)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: … … … … … …
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: return jsonify(record=doctor_json), 200
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: pip install flask-limiter
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: pip install flask-limiter[redis]
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: <st c="69772">from flask_limiter import Limiter</st> from flask_limiter.util
    import get_remote_address
  prefs: []
  type: TYPE_NORMAL
- en: 'def create_app(config_file):'
  prefs: []
  type: TYPE_NORMAL
- en: app = Flask(__name__,template_folder= '../modules/pages', static_folder=   '../modules/resources')
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: … … … … … …
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: global limiter
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: limiter = <st c="70020">Limiter</st>(
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: app=app, key_func=get_remote_address,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: default_limits=["30 per day", "5 per hour"],
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: storage_uri="memory://", )
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '<st c="70647">from modules import limiter</st> @current_app.route(''/login/auth'',
    methods=[''GET'', ''POST'']) <st c="70734">@limiter.limit("5 per minute")</st>
    async def login_user():'
  prefs: []
  type: TYPE_NORMAL
- en: 'if request.method == ''GET'':'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return render_template(  'login/authenticate.html'), 200
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: username = request.form['username'].strip()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: password = request.form['password'].strip()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'async with db_session() as sess:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'async with sess.begin():'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: repo = LoginRepository(sess)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: … … … … … …
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: return render_template( 'login/authenticate.html'), 200
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: <st c="0">Part 3:Testing, Deploying, and Building Enterprise-Grade Applications</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="70">In this last part, you will learn some options and workarounds to
    test, deploy, and run our Flask 3 applications.</st> <st c="185">Moreover, you
    will also understand the process of integrating Flask applications into GraphQL,
    React forms, Flutter mobile applications, and other applications built with FastAPI,
    Django, Tornado, and Flask using the</st> <st c="402">interoperability feature.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="427">This part includes the</st> <st c="451">following chapters:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[*<st c="470">Chapter 10</st>*](B19383_10.xhtml#_idTextAnchor281)<st c="481">,</st>
    *<st c="483">Creating Test Cases for Flask</st>*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*<st c="512">Chapter 11</st>*](B19383_11.xhtml#_idTextAnchor306)<st c="523">,</st>
    *<st c="525">Deploying Flask Applications</st>*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*<st c="553">Chapter 12</st>*](B19383_12.xhtml#_idTextAnchor322)<st c="564">,</st>
    *<st c="566">Integrating Flask with Other Tools and Frameworks</st>*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
