- en: <st c="0">9</st>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="0">9</st>
- en: <st c="2">Securing Flask Applications</st>
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="2">保护Flask应用程序</st>
- en: <st c="29">Like any web application, Flask applications have vulnerabilities
    that require protection from external attacks, which exploit these software defects.</st>
    <st c="181">These cyber-attacks are mainly due to broken access control problems,</st>
    **<st c="251">Cross-Site Scripting</st>** <st c="271">(</st>**<st c="273">XSS</st>**<st
    c="276">),</st> **<st c="280">Cross-Site Request Forgery</st>** <st c="306">(</st>**<st
    c="308">CSRF</st>**<st c="312">),</st> **<st c="316">Server-Side Request Forgery</st>**
    <st c="344">(</st>**<st c="345">SSRF</st>**<st c="349">),</st> **<st c="353">SQL
    Injection</st>**<st c="366">, and</st> **<st c="372">Denial-of-Service</st>**
    <st c="389">(</st>**<st c="391">DoS</st>**<st c="394">), as well as outdated modules</st>
    <st c="426">and libraries.</st>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="29">像任何Web应用程序一样，Flask应用程序都有需要保护免受外部攻击的漏洞，这些攻击利用了这些软件缺陷。</st> <st c="181">这些网络攻击主要是由于访问控制问题不完善，</st>
    **<st c="251">跨站脚本</st>** <st c="271">(</st>**<st c="273">XSS</st>**<st c="276">)，</st>
    **<st c="280">跨站请求伪造</st>** <st c="306">(</st>**<st c="308">CSRF</st>**<st c="312">)，</st>
    **<st c="316">服务器端请求伪造</st>** <st c="344">(</st>**<st c="345">SSRF</st>**<st c="349">)，</st>
    **<st c="353">SQL注入</st>**<st c="366">，以及</st> **<st c="372">拒绝服务</st>** <st c="389">(</st>**<st
    c="391">DoS</st>**<st c="394">)，以及过时的模块</st> <st c="426">和库。</st>
- en: <st c="440">Implementing security measures must be an utmost priority of any
    Flask application, especially if it is more dependent on external modules when
    building its models, repository layers, and workflow-related transactions.</st>
    <st c="660">Using third-party libraries can inflict risks to the Flask applications
    because some library codes can contain coding errors or vulnerabilities.</st>
    <st c="805">This is especially true for codes sourced from outdated third-party
    modules and libraries with</st> <st c="900">unreliable sources.</st>
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="440">实施安全措施必须是任何Flask应用程序的最高优先级，尤其是当它在构建模型、仓库层和工作流相关事务时更加依赖外部模块时。</st>
    <st c="660">使用第三方库可能会给Flask应用程序带来风险，因为一些库代码可能包含编码错误或漏洞。</st> <st c="805">这对于来自过时第三方模块和库的代码来说尤其如此，这些模块和库的来源不可靠。</st>
- en: <st c="919">It is easier to build Flask components and features with external
    modules, such as implementing the authentication and authorization measures using
    the</st> **<st c="1072">Authlib</st>** <st c="1079">module instead of composing
    it from the ground up.</st> <st c="1131">To decrease the chance of, if not avoid,
    web attacks, one should devise a security plan that will employ only reliable
    and updated modules.</st> <st c="1271">This will protect the application from</st>
    <st c="1310">outside attackers.</st>
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="919">使用外部模块，如使用</st> **<st c="1072">Authlib</st>** <st c="1079">模块而不是从头开始构建，来构建Flask组件和功能更容易。</st>
    <st c="1131">为了减少，如果不是避免，网络攻击的机会，应该制定一个仅使用可靠和更新模块的安全计划。</st> <st c="1271">这将保护应用程序免受</st>
    <st c="1310">外部攻击者。</st>
- en: <st c="1328">The main goal of this chapter is to provide possible security solutions
    for Flask applications to avoid some of the well-known web attacks using Flask’s
    built-in components, as well as some up-to-date and reliable</st> <st c="1543">third-party
    libraries.</st>
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1328">本章的主要目标是提供可能的解决方案，以帮助Flask应用程序避免使用Flask内置组件进行的一些知名网络攻击，以及一些最新且可靠的</st>
    <st c="1543">第三方库。</st>
- en: <st c="1565">Here are the topics that we will cover in the context of helping
    us secure our</st> <st c="1645">Flask applications:</st>
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1565">以下是我们将在帮助保护我们的</st> <st c="1645">Flask应用程序的上下文中涵盖的主题：</st>
- en: <st c="1664">Adding protection from</st> <st c="1688">web vulnerabilities</st>
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1664">添加对</st> <st c="1688">网络漏洞</st>的保护
- en: <st c="1707">Securing</st> <st c="1717">response data</st>
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1707">保护</st> <st c="1717">响应数据</st>
- en: <st c="1730">Managing</st> <st c="1740">user credentials</st>
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1730">管理</st> <st c="1740">用户凭据</st>
- en: <st c="1756">Implementing web</st> <st c="1774">form authentication</st>
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1756">实现网络</st> <st c="1774">表单认证</st>
- en: <st c="1793">Preventing</st> <st c="1805">CSRF attacks</st>
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1793">防止</st> <st c="1805">CSRF攻击</st>
- en: <st c="1817">Implementing user authentication</st> <st c="1851">and authorization</st>
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1817">实现用户身份验证</st> <st c="1851">和授权</st>
- en: <st c="1868">Controlling the view or</st> <st c="1893">API access</st>
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1868">控制视图或</st> <st c="1893">API访问</st>
- en: <st c="1903">Technical requirements</st>
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="1903">技术要求</st>
- en: <st c="1926">This chapter is about a</st> `<st c="2705">Flask[async]</st>` <st
    c="2717">features, including asynchronous</st> `<st c="2751">Flask-SQLAlchemy</st>`
    <st c="2767">transactions.</st> <st c="2782">They are available</st> <st c="2801">at</st>
    [<st c="2804">https://github.com/PacktPublishing/Mastering-Flask-Web-Development/tree/main/ch09</st>](https://github.com/PacktPublishing/Mastering-Flask-Web-Development/tree/main/ch09)<st
    c="2885">.</st>
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1926">本章介绍的是</st> `<st c="2705">Flask[async]</st>` <st c="2717">功能，包括异步</st>
    `<st c="2751">Flask-SQLAlchemy</st>` <st c="2767">事务。</st> <st c="2782">它们可在</st>
    [<st c="2804">https://github.com/PacktPublishing/Mastering-Flask-Web-Development/tree/main/ch09</st>](https://github.com/PacktPublishing/Mastering-Flask-Web-Development/tree/main/ch09)<st
    c="2885">找到。</st>
- en: <st c="2886">Adding protection from web vulnerabilities</st>
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="2886">添加对网络漏洞的保护</st>
- en: <st c="2929">SQL injection, SSRF, and XSS attacks are the most common web vulnerabilities
    that corrupt many web applications.</st> <st c="3043">They also affect any applications
    that use HTTP-based transactions, such as</st> `<st c="3119">POST</st>`<st c="3123">,</st>
    `<st c="3125">PUT</st>`<st c="3128">,</st> `<st c="3130">PATCH</st>`<st c="3135">,
    and</st> `<st c="3141">DELETE</st>`<st c="3147">. SQL injection occurs when an
    attacker infiltrates the backend datastore that manages the content of the trusted
    application.</st> <st c="3274">Embedded</st> <st c="3283">malicious SQL code can
    tamper with the data, rendering unwanted pages or destroying the database.</st>
    <st c="3381">XSS attacks commonly insert malicious scripts into the pages of the
    application to steal cookies, session data, and sensitive credentials from the
    system.</st> <st c="3536">On the other hand, CSRF occurs inside an authenticated
    environment.</st> <st c="3604">It happens when a valid user performs an HTTP transaction
    and a malicious script lurking in the browser usurps valid credentials with bogus
    and invalid ones to lead transactions to</st> <st c="3785">untrusted systems.</st>
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2929">SQL 注入、SSRF 和 XSS 攻击是最常见的网络漏洞，它们破坏了许多网络应用程序。</st> <st c="3043">它们还影响任何使用基于
    HTTP 的事务的应用程序，例如</st> `<st c="3119">POST</st>`<st c="3123">,</st> `<st c="3125">PUT</st>`<st
    c="3128">,</st> `<st c="3130">PATCH</st>`<st c="3135">, 和</st> `<st c="3141">DELETE</st>`<st
    c="3147">。</st> SQL 注入发生在攻击者渗透管理受信任应用程序内容的后端数据存储时。</st> <st c="3274">嵌入</st> <st
    c="3283">恶意 SQL 代码可以篡改数据，生成不想要的页面或破坏数据库。</st> <st c="3381">XSS 攻击通常会将恶意脚本插入到应用程序的页面中，以从系统中窃取
    cookie、会话数据和敏感凭证。</st> <st c="3536">另一方面，CSRF 发生在认证环境中。</st> <st c="3604">它发生在有效用户执行
    HTTP 事务时，浏览器中的恶意脚本篡改了有效的凭据，用虚假和无效的凭据来引导事务到</st> <st c="3785">不受信任的系统。</st>
- en: <st c="3803">Applying form validation to request data</st>
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="3803">将表单验证应用于请求数据</st>
- en: <st c="3844">One solution to avoid these attacks is to design a form validation
    that will not cost several lines of code or add more performance</st> <st c="3976">overhead
    to the view or API functions.</st> <st c="4016">The</st> `<st c="4066">FlaskForm</st>`
    <st c="4075">class that sub-classes form models with attributes mapped to the
    appropriate field classes.</st> <st c="4168">Each field class (e.g.,</st> `<st
    c="4192">StringField</st>`<st c="4203">,</st> `<st c="4205">BooleanField</st>`<st
    c="4217">,</st> `<st c="4219">DateField</st>`<st c="4228">, or</st> `<st c="4233">TimeField</st>`<st
    c="4242">) has properties and built-in validators (e.g.,</st> `<st c="4291">Length()</st>`<st
    c="4299">,</st> `<st c="4301">Email()</st>`<st c="4308">, or</st> `<st c="4313">DataRequired()</st>`<st
    c="4327">) with support on custom validators</st> <st c="4364">when the validation
    procedure requires intricate conditions.</st> <st c="4425">With the validators
    in place, it can more or less protect the application from exploits.</st> <st
    c="4514">Further discussion on using Flask-WTF is included in</st> [*<st c="4567">Chapter
    4</st>*](B19383_04.xhtml#_idTextAnchor087)<st c="4576">.</st>
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3844">避免这些攻击的一个解决方案是设计一个表单验证，它不会占用几行代码或给视图或API函数增加更多性能开销</st> <st c="3976">开销。</st>
    <st c="4016">The</st> `<st c="4066">FlaskForm</st>` <st c="4075">类通过将属性映射到适当的字段类来子类化表单模型。</st>
    <st c="4168">每个字段类（例如，</st> `<st c="4192">StringField</st>`<st c="4203">,</st>
    `<st c="4205">BooleanField</st>`<st c="4217">,</st> `<st c="4219">DateField</st>`<st
    c="4228">, 或</st> `<st c="4233">TimeField</st>`<st c="4242">）都有属性和内置验证器（例如，</st>
    `<st c="4291">Length()</st>`<st c="4299">,</st> `<st c="4301">Email()</st>`<st
    c="4308">, 或</st> `<st c="4313">DataRequired()</st>`<st c="4327">），并支持自定义验证器</st>
    <st c="4364">当验证过程需要复杂条件时。</st> <st c="4425">有了这些验证器，它可以在一定程度上保护应用程序免受利用。</st>
    <st c="4514">关于使用 Flask-WTF 的进一步讨论包括在</st> [*<st c="4567">第 4 章</st>*](B19383_04.xhtml#_idTextAnchor087)<st
    c="4576">。</st>
- en: <st c="4577">If the application is non-web or web-based and does not need form
    model classes,</st> `<st c="5199">pip</st>` <st c="5202">command:</st>
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4577">如果应用程序不是基于Web或不需要表单模型类，</st> `<st c="5199">pip</st>` <st c="5202">命令：</st>
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: <st c="5239">After the installation, the module does not need further setup.</st>
    <st c="5304">It can be used readily when building the validation rules, such as
    in the following validation rules that scrutinize the incoming</st> <st c="5434">administrator’s
    profile:</st>
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5239">安装后，该模块无需进一步设置。</st> <st c="5304">在构建验证规则时可以立即使用，例如以下验证规则将仔细审查</st>
    <st c="5434">管理员资料：</st>
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '@current_app.route(''/admin/profile/add'', methods=[''GET'', ''POST''])'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '@current_app.route(''/admin/profile/add'', methods=[''GET'', ''POST''])'
- en: 'async def add_admin_profile():'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 'async def add_admin_profile():'
- en: 'if not session.get("user"):'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'if not session.get("user"):'
- en: return redirect('/login/auth')
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: return redirect('/login/auth')
- en: … … … … … …
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: … … … … … …
- en: 'if request.method == ''GET'':'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'if request.method == ''GET'':'
- en: return render_template('admin/add_admin_profile.html', admin=admin_rec), 200
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: return render_template('admin/add_admin_profile.html', admin=admin_rec), 200
- en: 'else:'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'else:'
- en: result = validate_form(request.form)
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: result = validate_form(request.form)
- en: 'if result == False:'
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'if result == False:'
- en: flash(f'Validation problem.', 'error')
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: flash(f'验证问题。', 'error')
- en: return render_template('admin/add_admin_profile.html', admin=admin_rec), 200
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: return render_template('admin/add_admin_profile.html', admin=admin_rec), 200
- en: … … … … … …
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: … … … … … …
- en: return render_template('admin/add_admin_profile.html', admin=admin_rec), 200
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: return render_template('admin/add_admin_profile.html', admin=admin_rec), 200
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '@current_app.route(''/admin/profile/add'', methods=[''GET'', ''POST''])'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '@current_app.route(''/admin/profile/add'', methods=[''GET'', ''POST''])'
- en: 'async def add_admin_profile():'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 'async def add_admin_profile():'
- en: … … … … … …
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: … … … … … …
- en: result = validate_form(request.form)
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: result = validate_form(request.form)
- en: 'if result == False:'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'if result == False:'
- en: flash(f'Validation problem.', 'error')
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: flash(f'验证问题。', 'error')
- en: return render_template('admin/add_admin_profile.html', admin=admin_rec), 200
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: return render_template('admin/add_admin_profile.html', admin=admin_rec), 200
- en: username = request.form['username']
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: username = request.form['username']
- en: … … … … … …
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: … … … … … …
- en: admin_details = {
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: admin_details = {
- en: '"adminid": escape(request.form[''adminid''].strip()),'
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"adminid": escape(request.form[''adminid''].strip()),'
- en: '"username": escape(request.form[''username''].strip()),'
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"username": escape(request.form[''username''].strip()),'
- en: '"firstname": escape(request.form[''firstname''].strip()),'
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"firstname": escape(request.form[''firstname''].strip()),'
- en: … … … … … …
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: … … … … … …
- en: '"gender": escape(request.form[''gender''].strip())'
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"gender": escape(request.form[''gender''].strip())'
- en: '}'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: admin = Administrator(**admin_details)
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: admin = Administrator(**admin_details)
- en: result = await repo.insert_admin(admin)
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: result = await repo.insert_admin(admin)
- en: 'if result == False:'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'if result == False:'
- en: flash(f'Error adding … profile.', 'error')
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: flash(f'添加 … 资料时出错。', 'error')
- en: 'else:'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'else:'
- en: flash(f'Successfully added a user … )
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: flash(f'成功添加用户 … )
- en: return render_template('admin/add_admin_profile.html', admin=admin_rec), 200
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: return render_template('admin/add_admin_profile.html', admin=admin_rec), 200
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '<st c="14222">@app.after_request</st> def create_sec_resp_headers(response):'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '<st c="14222">@app.after_request</st> def create_sec_resp_headers(response):'
- en: response.headers['Content-Type'] = 'text/html; charset=UTF-8'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: response.headers['Content-Type'] = 'text/html; charset=UTF-8'
- en: response.headers['X-Content-Type-Options'] = 'nosniff'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: response.headers['X-Content-Type-Options'] = 'nosniff'
- en: response.headers['X-Frame-Options'] = 'SAMEORIGIN'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: response.headers['X-Frame-Options'] = 'SAMEORIGIN'
- en: 'response.headers[''Strict-Transport-Security''] = ''Strict-Transport-Security:
    max-age=63072000; includeSubDomains; preload'''
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'response.headers[''Strict-Transport-Security''] = ''Strict-Transport-Security:
    max-age=63072000; includeSubDomains; preload'''
- en: return response
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: return response
- en: '[PRE4]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: pip install flask-talisman
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: pip install flask-talisman
- en: '[PRE5]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '<st c="16327">from flask_talisman import Talisman</st> def create_app(config_file):'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '<st c="16327">from flask_talisman import Talisman</st> def create_app(config_file):'
- en: app = Flask(__name__,template_folder= '../modules/pages', static_folder= '../modules/resources')
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: app = Flask(__name__,template_folder= '../modules/pages', static_folder= '../modules/resources')
- en: app.config.from_file(config_file, toml.load)
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: app.config.from_file(config_file, toml.load)
- en: … … … … … … <st c="16547">talisman = Talisman(app)</st> csp = {
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: … … … … … … <st c="16547">talisman = Talisman(app)</st> csp = {
- en: '''default-src'': ['
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '''default-src'': ['
- en: '''\''self\'''','
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '''\''self\'''','
- en: '''https://code.jquery.com'','
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '''https://code.jquery.com'','
- en: '''https://cdnjs.com'','
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '''https://cdnjs.com'','
- en: '''https://cdn.jsdelivr.net'','
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '''https://cdn.jsdelivr.net'','
- en: ']'
  id: totrans-81
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: ']'
- en: '}'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: hsts = {
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: hsts = {
- en: '''max-age'': 31536000,'
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '''max-age'': 31536000,'
- en: '''includeSubDomains'': True'
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '''includeSubDomains'': True'
- en: '} <st c="16747">talisman.force_https = True</st> talisman.force_file_save =
    True <st c="16807">talisman.x_xss_protection = True</st><st c="16839">talisman.session_cookie_secure
    = True</st> talisman.frame_options_allow_from = ''https://www.google.com'' <st
    c="17226">default-src</st>, <st c="17239">image-src</st>, <st c="17250">style-src</st>,
    <st c="17261">media-src</st>, <st c="17272">object-src</st> ). In our configuration,
    JS files must only come from <st c="17337">https://code.jquery.com</st>, <st c="17362">https://cdnjs.com</st>,
    <st c="17381">https://cdn.jsdelivr.net</st>, and the localhost, while both CSS
    and images must be fetched from the localhost as indicated in <st c="17503">default-src</st>,
    the fallback resources for each view page. Specifying <st c="17570">script-src</st>
    with specific JS sources, <st c="17607">style-src</st> with CSS resources, and
    <st c="17641">image-src</st> with the targeted images will bypass the <st c="17692">default-src</st>
    setting.'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '} <st c="16747">talisman.force_https = True</st> talisman.force_file_save =
    True <st c="16807">talisman.x_xss_protection = True</st><st c="16839">talisman.session_cookie_secure
    = True</st> talisman.frame_options_allow_from = ''https://www.google.com'' <st
    c="17226">default-src</st>, <st c="17239">image-src</st>, <st c="17250">style-src</st>,
    <st c="17261">media-src</st>, <st c="17272">object-src</st> ). 在我们的配置中，JS文件必须仅来自<st
    c="17337">https://code.jquery.com</st>、<st c="17362">https://cdnjs.com</st>、<st
    c="17381">https://cdn.jsdelivr.net</st>和本地主机，而CSS和图像必须如<st c="17503">default-src</st>中所示，从本地主机获取，作为每个视图页面的后备资源。通过指定具有特定JS资源的<st
    c="17570">script-src</st>、具有CSS资源的<st c="17607">style-src</st>和具有目标图像的<st c="17641">image-src</st>，将绕过<st
    c="17692">default-src</st>设置。'
- en: <st c="17712">Aside from CSP, the Talisman can add</st> `<st c="17750">X-XSS-Protection</st>`<st
    c="17766">,</st> `<st c="17768">Referrer-Policy</st>`<st c="17783">, and</st>
    `<st c="17789">Set-Cookie</st>`<st c="17799">, as well as the headers previously
    included in the response by the</st> `<st c="17867">@after_request</st>` <st c="17881">function.</st>
    <st c="17892">Caution is needed in combining the two approaches because overlapping
    of header settings</st> <st c="17981">may happen.</st>
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 除了CSP之外，Talisman还可以添加<st c="17750">X-XSS-Protection</st>、<st c="17768">Referrer-Policy</st>、<st
    c="17783">和<st c="17789">Set-Cookie</st>，以及之前由<st c="17867">@after_request</st>
    <st c="17881">函数</st>包含在响应中的头部。在结合这两种方法时需要谨慎，因为头部设置的<st c="17892">重叠</st>可能会发生。
- en: <st c="17992">Adding the</st> `<st c="18004">Strict-Transport-Security</st>`
    <st c="18029">header in the response and setting the</st> `<st c="18069">force_https</st>`
    <st c="18080">of Talisman’s property to</st> `<st c="18107">True</st>` <st c="18111">requires
    running the application in HTTPS mode.</st> <st c="18160">Let us explore the latest
    and easiest way to enable HTTPS for a</st> <st c="18224">Flask application.</st>
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="17992">在响应中添加</st> `<st c="18004">Strict-Transport-Security</st>` <st
    c="18029">头部并设置Talisman属性的</st> `<st c="18069">force_https</st>` <st c="18080">为</st>
    `<st c="18107">True</st>` <st c="18111">需要以HTTPS模式运行应用程序。</st> <st c="18160">让我们探索为</st>
    <st c="18224">Flask应用程序</st>启用HTTPS的最新和最简单的方法。
- en: <st c="18242">Using HTTPS to run request/response transactions</st>
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="18242">使用HTTPS运行请求/响应事务</st>
- en: <st c="18291">HTTPS is a TLS-encrypted HTTP protocol.</st> <st c="18332">It
    establishes secured communication between the transmitter and receiver of data,
    protecting</st> <st c="18425">the cookies, URLs, and sensitive information</st>
    <st c="18471">that flows during the exchange.</st> <st c="18503">It also guards
    the integrity of the data and the user’s authenticity since it requires the user’s
    private key to allow access.</st> <st c="18630">With that, to enable the HTTPS
    protocol, the WSGI server must run with a public and private key certificate generated
    by an SSL key generator.</st> <st c="18773">By convention, the certificate must
    be saved inside the project directory or somewhere safe in the host server.</st>
    <st c="18885">This chapter</st> <st c="18897">utilizes the</st> **<st c="18911">OpenSSL</st>**
    <st c="18918">tool to produce</st> <st c="18935">the certificate.</st>
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="18291">HTTPS是一种TLS加密的HTTP协议。</st> <st c="18332">它建立了数据发送者和接收者之间的安全通信，保护了在交换过程中流动的cookies、URLs和敏感信息</st>
    <st c="18425">。它还保护了数据的完整性和用户的真实性，因为它需要用户的私钥来允许访问。</st> <st c="18503">因此，要启用HTTPS协议，WSGI服务器必须使用由SSL密钥生成器生成的公钥和私钥证书运行。</st>
    <st c="18630">按照惯例，证书必须保存在项目目录内或主机服务器上的安全位置。</st> <st c="18773">本章</st> <st c="18897">使用</st>
    **<st c="18911">OpenSSL</st>** <st c="18918">工具生成</st> <st c="18935">证书。</st>
- en: <st c="18951">Install the latest</st> `<st c="18971">pyopenssl</st>` <st c="18980">using
    the following</st> `<st c="19001">pip</st>` <st c="19004">command:</st>
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: <st c="19035">Now, to run the application, include the</st> <st c="19076">private
    and public keys in</st> `<st c="19104">run()</st>` <st c="19109">through its</st>
    `<st c="19122">ssl_context</st>` <st c="19133">parameter.</st> <st c="19145">The
    following</st> `<st c="19159">main.py</st>` <st c="19166">snippet shows how to
    run the application using HTTPS</st> <st c="19220">on a</st> <st c="19225">development
    server:</st>
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: <st c="22650">from werkzeug.security import generate_password_hash</st> @current_app.post('/login/signup')
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 'async def add_signup():'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'login_json = request.get_json() <st c="22795">password = login_json["password"]</st><st
    c="22828">passphrase = generate_password_hash(password)</st> async with db_session()
    as sess:'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'async with sess.begin():'
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: repo = LoginRepository(sess)
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: login = Login(username=login_json["username"], <st c="23009">password=passphrase</st>,
    role=login_json["role"])
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: result = await repo.insert_login(login)
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if result == False:'
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: return jsonify(message="error in insert"), 201
  id: totrans-103
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: return jsonify(record=login_json), 200
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: <st c="24662">from werkzeug.security import check_password_hash</st> @auth.verify_password
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'def verify_password(username, password):'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: task = get_user_task_wrapper.apply_async( args=[username])
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: login:Login = task.get()
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if login == None:'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'abort(403) <st c="24889">if check_password_hash(login.password, password)</st>:
    <st c="24940">return login.username</st> else:'
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: abort(403)
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: pip install hashlib
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: pip install bcrypt
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: <st c="25876">from flask_bcrypt import Bcrypt</st>
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="25908">bcrypt = Bcrypt()</st> def create_app(config_file):'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: app = Flask(__name__, template_folder='../modules/pages', static_folder='../modules/resources')
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: app.config.from_file(config_file, toml.load)
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: app.config.from_prefixed_env()
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: … … … … … … <st c="26140">bcrypt.init_app(app)</st> … … … … … …
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: <st c="26489">from modules import bcrypt</st> @current_app.post('/login/signup')
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'async def add_signup():'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: login_json = request.get_json()
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'password = login_json["password"] <st c="26642">passphrase = bcrypt.generate_password_hash(password)</st><st
    c="26694">.decode(''utf-8'')</st> async with db_session() as sess:'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'async with sess.begin():'
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: repo = LoginRepository(sess)
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: … … … … … …
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: result = await repo.insert_login(login)
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if result == False:'
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: return jsonify(message="error in insert"), 201
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: return jsonify(record=login_json), 200
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: pip install cryptography
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '<st c="28451">from cryptography.fernet import Fernet</st> def create_app(config_file):'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: app = Flask(__name__,  template_folder='../modules/pages', static_folder='../modules/resources')
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: app.config.from_file(config_file, toml.load)
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: … … … … … … <st c="28764">Fernet</st> token or secret key is a URL-safe base64-encoded
    alphanumeric that will instigate the encryption and decryption algorithms. The
    application should store the key in a safe and inaccessible location during startup,
    such as saving it in a file inside a secured directory. Missing the key will lead
    to <st c="29069">cryptography.fernet.InvalidToken</st> and <st c="29106">cryptography.exceptions.InvalidSignature</st>
    errors.
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: … … … … … … <st c="28764">Fernet</st> 令牌或密钥是一个 URL 安全的 base64 编码的字母数字，它将启动加密和解密算法。应用程序应在启动时将密钥存储在安全且不可访问的位置，例如在安全目录内的文件中保存。缺少密钥将导致
    <st c="29069">cryptography.fernet.InvalidToken</st> 和 <st c="29106">cryptography.exceptions.InvalidSignature</st>
    错误。
- en: <st c="29154">After generating the secret key, instantiate the</st> `<st c="29204">Fernet</st>`
    <st c="29210">class with the key as the constructor argument to emit the</st>
    `<st c="29270">encrypt()</st>` <st c="29279">method.</st> <st c="29288">The following</st>
    `<st c="29302">ch09-auth-digest</st>`<st c="29318">’s version of</st> `<st c="29333">add_signup()</st>`
    <st c="29345">encrypts the user password</st> <st c="29373">using</st> `<st c="29379">Fernet</st>`<st
    c="29385">:</st>
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="29154">生成密钥后，使用密钥作为构造函数参数实例化</st> `<st c="29204">Fernet</st>` <st c="29210">类以发出</st>
    `<st c="29270">encrypt()</st>` <st c="29279">方法。</st> <st c="29288">以下</st> `<st
    c="29302">ch09-auth-digest</st>`<st c="29318">版本的</st> `<st c="29333">add_signup()</st>`
    <st c="29345">使用</st> `<st c="29379">Fernet</st>`<st c="29385">加密用户密码</st>：<st
    c="29373">:</st>
- en: '[PRE15]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: <st c="29850">To instantiate</st> `<st c="29866">Fernet</st>`<st c="29872">,</st>
    `<st c="29874">add_signup()</st>` <st c="29886">must extract the token from the
    file, convert it into bytes, and pass it as a constructor argument to the</st>
    `<st c="29993">Fernet</st>` <st c="29999">class.</st> <st c="30007">The</st> `<st
    c="30011">Fernet</st>` <st c="30017">instance provides an</st> `<st c="30039">encrypt()</st>`
    <st c="30048">method that</st> <st c="30061">uses the</st> `<st c="30174">decrypt()</st>`
    <st c="30183">method to</st> <st c="30194">extract the original</st> <st c="30214">password
    from the encrypted message.</st> <st c="30252">The following is</st> `<st c="30269">ch09-auth-digest</st>`<st
    c="30285">’s password validation scheme that retrieves the user credentials from
    the database with the encoded password and decrypts the encoded message to extract
    the</st> <st c="30444">actual password:</st>
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="29850">为了实例化</st> `<st c="29866">Fernet</st>`<st c="29872">，</st> `<st
    c="29874">add_signup()</st>` <st c="29886">必须从文件中提取令牌，将其转换为字节，并将其作为构造函数参数传递给</st>
    `<st c="29993">Fernet</st>` <st c="29999">类。</st> <st c="30007">`<st c="30011">Fernet</st>`
    <st c="30017">实例提供了一个</st> `<st c="30039">encrypt()</st>` <st c="30048">方法，该方法使用</st>
    `<st c="30174">decrypt()</st>` <st c="30183">方法从加密消息中提取原始</st> `<st c="30194">密码。</st>`
    <st c="30252">以下是</st> `<st c="30269">ch09-auth-digest</st>`<st c="30285">的密码验证方案，该方案从数据库中检索带有编码密码的用户凭据，并解密编码消息以提取</st>
    `<st c="30444">实际密码：</st>`
- en: '[PRE16]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: <st c="30806">Again,</st> `<st c="30814">get_passwd()</st>` <st c="30826">needs
    the token from the file to instantiate</st> `<st c="30872">Fernet</st>`<st c="30878">.
    Using the</st> `<st c="30890">Fernet</st>` <st c="30896">instance,</st> `<st c="30907">get_passwd()</st>`
    <st c="30919">can emit the</st> `<st c="30933">decrypt()</st>` <st c="30942">method
    to reassemble the encrypted message and extract the actual password in the</st>
    `<st c="31025">UTF-8</st>` <st c="31030">format.</st> <st c="31039">Compared to
    hashing, encryption involves reassembling plain text into an unreadable and uncrackable
    ciphertext</st> <st c="31150">using a token and reverting that ciphertext into
    its original readable form.</st> <st c="31227">So, it’s a two-way process, unlike</st>
    <st c="31262">in hashing.</st>
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="30806">再次强调，</st> `<st c="30814">get_passwd()</st>` <st c="30826">需要从文件中获取令牌以实例化</st>
    `<st c="30872">Fernet</st>`<st c="30878">。使用</st> `<st c="30890">Fernet</st>`
    <st c="30896">实例，</st> `<st c="30907">get_passwd()</st>` <st c="30919">可以发出</st>
    `<st c="30933">decrypt()</st>` <st c="30942">方法来重新组装加密消息并从</st> `<st c="31025">UTF-8</st>`
    <st c="31030">格式中提取实际密码。</st> <st c="31039">与哈希相比，加密涉及使用令牌将明文重新组装成不可读且无法破解的密文，并将该密文还原为其原始的可读形式。</st>
    <st c="31150">因此，它是一个双向过程，与</st> <st c="31262">哈希不同。</st>
- en: <st c="31273">If the goal is to persist encoded data into the database without
    adding unnecessary cryptographic blunders that can slow down software performance,
    the solution is to</st> <st c="31441">use</st> `<st c="31445">sqlalchemy_utils</st>`<st
    c="31461">.</st>
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="31273">如果目标是持久化编码数据到数据库中，而不添加可能减慢软件性能的不必要的加密错误，解决方案是</st> <st c="31441">使用</st>
    `<st c="31445">sqlalchemy_utils</st>`<st c="31461">。</st>
- en: <st c="31462">Using sqlalchemy_utils for encrypted columns</st>
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="31462">使用 sqlalchemy_utils 对加密列进行操作</st>
- en: <st c="31507">The</st> `<st c="31512">sqlalchemy_utils</st>` <st c="31528">module
    provides additional utility methods and column types to SQLAlchemy model classes,
    which include</st> `<st c="31632">StringEncryptedType</st>`<st c="31651">. Since
    the module utilizes cryptographic</st> <st c="31692">recipes of the cryptography</st>
    <st c="31721">module, be sure to install the latter before</st> `<st c="31766">sqlalchemy_utils</st>`
    <st c="31782">using the following</st> `<st c="31803">pip</st>` <st c="31806">command:</st>
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="31507">`sqlalchemy_utils`</st> <st c="31512">模块为 SQLAlchemy 模型类提供了额外的实用方法和列类型，其中包括</st>
    `<st c="31632">StringEncryptedType</st>`<st c="31651">。由于该模块使用了 cryptography 模块的加密方案，在使用</st>
    `<st c="31766">sqlalchemy_utils</st>` <st c="31782">之前，请务必使用以下</st> `<st c="31803">pip</st>`
    <st c="31806">命令安装该模块：</st>
- en: '[PRE17]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: <st c="31857">Afterward, design your model classes by applying</st> `<st c="31907">StringEncryptedType</st>`
    <st c="31926">to table columns that need</st> `<st c="31954">Fernet</st>`<st c="31960">’s
    encryption, such as the</st> `<st c="31988">username</st>` <st c="31996">and</st>
    `<st c="32001">password</st>` <st c="32009">columns.</st> <st c="32019">The following
    is the</st> `<st c="32040">Login</st>` <st c="32045">model class of the</st> `<st
    c="32065">ch09-web-passphrase</st>` <st c="32084">project with</st> `<st c="32098">username</st>`
    <st c="32106">and</st> `<st c="32111">password</st>` <st c="32119">columns</st>
    <st c="32128">of</st> `<st c="32131">StringEncryptedType</st>`<st c="32150">:</st>
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="31857">之后，通过将</st> `<st c="31907">StringEncryptedType</st>` <st c="31926">应用于需要</st>
    `<st c="31954">Fernet</st>`<st c="31960">加密的表列，例如</st> `<st c="31988">用户名</st>`
    <st c="31996">和</st> `<st c="32001">密码</st>` <st c="32009">列。</st> <st c="32019">以下是在</st>
    `<st c="32040">Login</st>` <st c="32045">模型类中包含</st> `<st c="32065">ch09-web-passphrase</st>`
    <st c="32084">项目，并具有</st> `<st c="32098">用户名</st>` <st c="32106">和</st> `<st c="32111">密码</st>`
    <st c="32119">列</st> <st c="32128">的</st> `<st c="32131">StringEncryptedType</st>`<st
    c="32150">的</st>示例：
- en: '[PRE18]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`<st c="32566">StringEncryptedType</st>` <st c="32586">automatically encrypts
    the column data during the</st> `<st c="32637">INSERT</st>` <st c="32643">transaction
    and decrypts the encoded field value during the</st> `<st c="32704">SELECT</st>`
    <st c="32710">statements.</st> <st c="32723">To apply the utility class to the
    column, map it to the column field enclosing the actual SQLAlchemy column</st>
    <st c="32830">type with the custom-generated</st> `<st c="32862">Fernet</st>`
    <st c="32868">token.</st> <st c="32876">It may look like a column field wrapper
    that will filter and encrypt the inserted field value and decrypt it during retrieval.</st>
    <st c="33003">No other additional coding from the</st> `<st c="33039">view</st>`
    <st c="33043">functions or repository layer is needed to perform the encryption</st>
    <st c="33109">and decryption processes on these</st> <st c="33144">field values.</st>'
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<st c="32566">StringEncryptedType</st>` <st c="32586">会在</st> `<st c="32637">INSERT</st>`
    <st c="32643">事务期间自动加密列数据，并在</st> `<st c="32704">SELECT</st>` <st c="32710">语句中解密编码的字段值。</st>
    <st c="32723">要将实用类应用于列，请将其映射到包含实际 SQLAlchemy 列</st> `<st c="32830">类型</st>` <st
    c="32862">和自定义生成的</st> `<st c="32862">Fernet</st>` <st c="32868">令牌的列字段。</st>
    <st c="32876">它看起来像是一个列字段包装器，它将过滤和加密插入的字段值，并在检索时解密。</st> <st c="33003">对于这些字段值，不需要从</st>
    `<st c="33039">视图</st>` <st c="33043">函数或存储库层进行其他额外的编码来执行加密</st> `<st c="33109">和解密过程。</st>`'
- en: <st c="33157">When using</st> `<st c="33169">Flask-Migrate</st>`<st c="33182">,
    add the</st> `<st c="33192">import sqlalchemy_utils</st>` <st c="33215">statement
    to the generated</st> `<st c="33243">env.py</st>` <st c="33249">and</st> `<st
    c="33254">script.py.mako</st>` <st c="33268">files inside the</st> `<st c="33286">migrations</st>`
    <st c="33296">folder after running the</st> `<st c="33322">db init</st>` <st c="33329">command
    and before running the</st> `<st c="33361">db migrate</st>` <st c="33371">and</st>
    `<st c="33376">db upgrade</st>` <st c="33386">operations.</st> <st c="33399">The
    following are the modified</st> `<st c="33430">ch09-web-passphrase</st>` <st c="33449">migration
    files with the imported</st> `<st c="33484">sqlalchemy_utils</st>` <st c="33500">module:</st>
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="33157">当使用</st> `<st c="33169">Flask-Migrate</st>`<st c="33182">时，在运行</st>
    `<st c="33243">db init</st>` <st c="33249">命令后，并在运行</st> `<st c="33254">script.py.mako</st>`
    <st c="33268">文件中的</st> `<st c="33286">migrations</st>` <st c="33296">文件夹内的</st>
    `<st c="33243">env.py</st>` <st c="33249">和</st> `<st c="33254">script.py.mako</st>`
    <st c="33268">文件之前，将</st> `<st c="33192">import sqlalchemy_utils</st>` <st c="33215">语句添加到生成的</st>
    `<st c="33243">env.py</st>` <st c="33249">和</st> `<st c="33254">script.py.mako</st>`
    <st c="33268">文件中。</st> <st c="33399">以下是在导入</st> `<st c="33484">sqlalchemy_utils</st>`
    <st c="33500">模块后修改的</st> `<st c="33430">ch09-web-passphrase</st>` <st c="33449">迁移文件：</st>
- en: '[PRE19]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: <st c="33903">The highlighted lines provided in</st> <st c="33937">the given
    migration files are the proper places to add extra imports used in the SQLAlchemy
    model classes.</st> <st c="34045">This includes not only the</st> `<st c="34072">sqlalchemy_util</st>`
    <st c="34087">classes but also other libraries that may help to establish the
    desired</st> <st c="34160">model layer.</st>
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="33903">在提供的迁移文件中提供的突出显示的行是添加用于SQLAlchemy模型类的额外导入的正确位置。</st> <st c="34045">这包括不仅</st>
    `<st c="34072">sqlalchemy_util</st>` <st c="34087">类，还包括可能帮助建立所需</st> `<st c="34160">模型层</st>`
    的其他库。</st>
- en: <st c="34172">When customizing user authentication, the application utilizes
    the default Flask session to store user information, such as username.</st> <st
    c="34307">This session saves information to the browser.</st> <st c="34354">To
    protect the app from broken access control attacks, you can use a reliable authentication
    and authorization mechanism or apply server-side session handling through the</st>
    **<st c="34525">Flask-Session</st>** <st c="34538">module if custom session-based
    authentication suits</st> <st c="34591">your requirements.</st>
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="34172">在自定义用户认证时，应用程序利用默认的Flask会话来存储用户信息，例如用户名。</st> <st c="34307">此会话将信息保存到浏览器。</st>
    <st c="34354">为了保护应用程序免受破坏性访问控制攻击，您可以使用可靠的认证和授权机制，或者如果自定义基于会话的认证符合您的需求，可以通过</st>
    **<st c="34525">Flask-Session</st>** <st c="34538">模块应用服务器端会话处理。</st> <st c="34591">如果</st>
    <st c="34538">自定义会话基于认证</st> <st c="34591">满足您的需求。</st>
- en: <st c="34609">Utilizing the server-side sessions</st>
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="34609">利用服务器端会话</st>
- en: <st c="34644">In</st> [*<st c="34648">Chapter 4</st>*](B19383_04.xhtml#_idTextAnchor087)<st
    c="34657">, the</st> `<st c="35144">username</st>`<st c="35152">, to</st> <st
    c="35157">the public.</st>
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="34644">在</st> [*<st c="34648">第4章</st>*](B19383_04.xhtml#_idTextAnchor087)<st
    c="34657">中，将</st> `<st c="35144">username</st>`<st c="35152">公开。</st>
- en: <st c="35168">After setting up the</st> `<st c="35190">Session</st>` <st c="35197">class
    of the module through the</st> `<st c="35230">app</st>` <st c="35233">instance,
    Flask’s built-in</st> `<st c="35261">session</st>` <st c="35268">dictionary object
    can readily store session data on the server side.</st> <st c="35338">The following</st>
    `<st c="35352">login_user()</st>` <st c="35364">view function stores the</st>
    `<st c="35390">username</st>` <st c="35398">of the credentia</st><st c="35415">l
    to the server-side session after user</st> <st c="35456">credential</st> <st c="35467">confirmation:</st>
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="35168">在通过</st> `<st c="35190">Session</st>` <st c="35197">模块的</st> `<st
    c="35230">app</st>` <st c="35233">实例设置</st> `<st c="35261">session</st>` <st c="35268">字典对象后，Flask的内置</st>
    `<st c="35261">session</st>` <st c="35268">会话对象可以轻松地在服务器端存储会话数据。</st> <st c="35338">以下</st>
    `<st c="35352">login_user()</st>` <st c="35364">视图函数在用户</st> <st c="35390">username</st>
    <st c="35398">凭证</st><st c="35415">确认后，将凭证</st> <st c="35456">credential</st>
    <st c="35467">存储到服务器端会话中：</st>
- en: '[PRE20]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: <st c="36087">All session data needs to be cleared when logging out.</st> <st
    c="36143">Removing all session data will</st> `<st c="36294">logout()</st>` <st
    c="36302">view function of the</st> `<st c="36324">ch09-web-paraphrase</st>` <st
    c="36343">project:</st>
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="36087">在登出时需要清除所有会话数据。</st> <st c="36143">删除所有会话数据将会</st> `<st c="36294">logout()</st>`
    <st c="36302">视图函数的</st> `<st c="36324">ch09-web-paraphrase</st>` <st c="36343">项目：</st>
- en: '[PRE21]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: <st c="36473">Aside from setting the</st> <st c="36496">session attribute to</st>
    `<st c="36518">None</st>`<st c="36522">, the</st> `<st c="36528">pop()</st>` <st
    c="36533">method of the</st> `<st c="36548">session</st>` <st c="36555">object
    can also help remove the session data.</st> <st c="36602">Removing all session
    data is the same as invalidating the</st> <st c="36660">current session.</st>
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="36473">除了将</st> <st c="36496">会话属性设置为</st> `<st c="36518">None</st>`<st
    c="36522">之外，</st> `<st c="36528">pop()</st>` <st c="36533">方法也可以帮助删除会话数据。</st>
    <st c="36602">删除所有会话数据等同于使当前会话失效。</st>
- en: <st c="36676">Now, if custom web login implementation does not apply to your
    requirement, the</st> **<st c="36757">Flask-Login</st>** <st c="36768">module
    can offer built-in utilities for user login and logout.</st> <st c="36832">Let
    us now discuss how to use Flask-Login for a</st> <st c="36880">Flask application.</st>
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="36676">现在，如果自定义网页登录实现不符合您的需求，</st> **<st c="36757">Flask-Login</st>**
    <st c="36768">模块可以提供用户登录和登出的内置实用工具。</st> <st c="36832">现在让我们讨论如何使用Flask-Login进行</st>
    <st c="36880">Flask应用程序。</st>
- en: <st c="36898">Implementing web form authentication</st>
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="36898">实现网页表单认证</st>
- en: '`<st c="37184">flask-login</st>`<st c="37195">, install it first using the
    following</st> `<st c="37234">pip</st>` <st c="37237">command:</st>'
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<st c="37184">flask-login</st>`<st c="37195">，首先使用以下</st> `<st c="37234">pip</st>`
    <st c="37237">命令安装它：</st>'
- en: '[PRE22]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: <st c="37270">Also, install and set up the Flask-Session module for Flask-Login
    to store its user session in</st> <st c="37366">the filesystem.</st>
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="37270">同时，安装并设置 Flask-Session 模块，以便 Flask-Login 将其用户会话存储在</st> <st c="37366">文件系统中。</st>
- en: <st c="37381">Then, to integrate Flask-login into the Flask application, instantiate
    its</st> `<st c="37457">LoginManager</st>` <st c="37469">class in the</st> `<st
    c="37483">create_app()</st>` <st c="37495">method and set it up through the</st>
    `<st c="37529">app</st>` <st c="37532">instance.</st> <st c="37543">Define some
    of its properties such as</st> `<st c="37581">session_protection</st>`<st c="37599">,
    which requires the installation of Flask-Bcrypt, and</st> `<st c="37654">login_view</st>`<st
    c="37664">, which designates the</st> `<st c="37687">login view</st>` <st c="37697">function.</st>
    <st c="37708">The following snippet</st> <st c="37730">shows the setup of Flask-Login
    for our</st> `<st c="37769">ch09-web-login</st>` <st c="37783">project:</st>
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="37381">然后，要将 Flask-login 集成到 Flask 应用中，需要在</st> `<st c="37457">LoginManager</st>`
    <st c="37469">类中</st> `<st c="37483">create_app()</st>` <st c="37495">方法中实例化它，并通过</st>
    `<st c="37529">app</st>` <st c="37532">实例</st> `<st c="37543">设置它。</st> <st c="37581">session_protection</st>`<st
    c="37599">属性需要安装 Flask-Bcrypt，而</st> `<st c="37654">login_view</st>`<st c="37664">属性则指定了</st>
    `<st c="37687">登录视图</st>` <st c="37697">函数。</st> <st c="37708">以下代码片段</st> <st
    c="37730">展示了为我们的</st> `<st c="37769">ch09-web-login</st>` <st c="37783">项目</st>
    `<st c="37730">设置 Flask-Login 的方法：</st>
- en: '[PRE23]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: <st c="38475">from flask_login import UserMixin</st> from sqlalchemy_utils import
    StringEncryptedType
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="38475">from flask_login import UserMixin</st> from sqlalchemy_utils import
    StringEncryptedType
- en: enc_key = "packt_pazzword" <st c="38585">class Login(UserMixin, Base):</st>
    __tablename__ = 'login'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: enc_key = "packt_pazzword" <st c="38585">class Login(UserMixin, Base):</st>
    __tablename__ = 'login'
- en: id = Column(Integer, Sequence('login_id_seq', increment=1), primary_key = True)
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: id = Column(Integer, Sequence('login_id_seq', increment=1), primary_key = True)
- en: username = Column(StringEncryptedType(String(20), enc_key), nullable=False,
    unique=True)
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: username = Column(StringEncryptedType(String(20), enc_key), nullable=False,
    unique=True)
- en: password = Column(StringEncryptedType(String(50), enc_key), nullable=False)
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: password = Column(StringEncryptedType(String(50), enc_key), nullable=False)
- en: role = Column(Integer, nullable=False)
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: role = Column(Integer, nullable=False)
- en: … … … … … …
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: … … … … … …
- en: '[PRE24]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '<st c="39901">@login_auth.user_loader</st> def load_user(<st c="39940">id</st>):'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '<st c="39901">@login_auth.user_loader</st> def load_user(<st c="39940">id</st>):'
- en: task = get_user_task_wrapper.apply_async(args=[id])
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: task = get_user_task_wrapper.apply_async(args=[id])
- en: result = task.get() <st c="40077">main.py</st> module. Now, using the <st c="40108">get_user_task_wrapper()</st>
    Celery task, the <st c="40149">load_user()</st> uses the <st c="40170">select_login()</st>
    transaction of the <st c="40204">LoginRepository</st> to retrieve a <st c="40234">Login</st>
    record based on the given <st c="40266">id</st> parameter. The application automatically
    calls <st c="40316">load_user()</st> for every request to access the views. The
    continuous call to the callback function checks the validity of the user. The
    returned <st c="40458">Login</st> object serves as a token that permits the user
    to access the application. To declare a user loader callback function, create
    a function with one local <st c="40615">id</st> parameter and decorate it with
    the <st c="40653">userloader()</st> decorator of the <st c="40683">LoginManager</st>
    instance.
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: result = task.get() <st c="40077">main.py</st> 模块。现在，使用 <st c="40108">get_user_task_wrapper()</st>
    Celery 任务，<st c="40149">load_user()</st> 使用 <st c="40170">select_login()</st>
    事务的 <st c="40204">LoginRepository</st> 来根据给定的 <st c="40234">id</st> 参数检索一个 <st
    c="40266">Login</st> 记录。应用程序会自动为每个请求访问视图而调用 <st c="40316">load_user()</st>。对回调函数的连续调用检查用户的合法性。返回的
    <st c="40458">Login</st> 对象作为令牌，允许用户访问应用程序。要声明用户加载回调函数，创建一个带有本地 <st c="40615">id</st>
    参数的函数，并用 <st c="40653">userloader()</st> 装饰器装饰 <st c="40683">LoginManager</st>
    实例。
- en: <st c="40705">The</st> `<st c="40710">login view</st>` <st c="40720">function
    caches the</st> `<st c="40741">Login</st>` <st c="40746">object, saves the</st>
    `<st c="40765">Login</st>`<st c="40770">’s</st> `<st c="40774">id</st>` <st c="40776">to
    the session, and maps it to the</st> `<st c="40812">current_user</st>` <st c="40824">proxy
    object of the</st> `<st c="40845">flask_login</st>` <st c="40856">module.</st>
    <st c="40865">The following snippet</st> <st c="40887">shows the</st> `<st c="40897">login
    view</st>` <st c="40907">function indicated in</st> <st c="40930">our setup:</st>
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: <st c="41562">If the</st> `<st c="41570">POST</st>`<st c="41574">-submitted
    user credentials are correct based on the database validation, the</st> `<st c="41653">login
    view</st>` <st c="41663">function, namely our</st> `<st c="41685">login_valid_user()</st>`<st
    c="41703">, should invoke the</st> `<st c="41723">login_user()</st>` <st c="41735">method
    of the</st> `<st c="41750">flask_login</st>` <st c="41761">module.</st> <st c="41770">The
    view must pass the queried</st> `<st c="41801">Login</st>` <st c="41806">object
    containing the user’s login credentials to the</st> `<st c="41861">login_user()</st>`
    <st c="41873">function.</st> <st c="41884">Aside from the</st> `<st c="41899">Login</st>`
    <st c="41904">object, the method has other options, such as</st> <st c="41951">the
    following:</st>
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`<st c="41965">remember</st>`<st c="41974">: A boolean</st> <st c="41987">parameter
    that enables the</st> `<st c="42014">remember_me</st>` <st c="42025">feature,
    which allows the user session to be alive even after a browser’s</st> <st c="42100">accidental
    exit.</st>'
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="42116">fresh</st>`<st c="42122">: A boolean parameter that sets a user
    as</st> `<st c="42165">not fresh</st>` <st c="42174">if their session is valid
    right after the closing of</st> <st c="42228">a browser.</st>'
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="42238">force</st>`<st c="42244">: A boolean parameter that forces a
    user to be</st> <st c="42292">logged in.</st>'
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="42302">duration</st>`<st c="42311">: The amount of time before the</st>
    `<st c="42344">remember_me</st>` <st c="42356">cookie expires.</st>'
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '<st c="42371">After the successful authentication, users</st> <st c="42415">can
    now access the restricted views or APIs that are off-limits to non-authenticated
    users: those views with</st> `<st c="42524">@login_required</st>` <st c="42539">decorator.</st>
    <st c="42551">The following is a samp</st><st c="42574">le view function of our</st>
    `<st c="42599">ch09-web-login</st>` <st c="42613">that needs authenticated</st>
    <st c="42639">user access:</st>'
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: <st c="43215">Aside from the decorator, the</st> `<st c="43246">current_user</st>`<st
    c="43258">’s</st> `<st c="43262">is_authenticated</st>` <st c="43278">property
    can also restrict the execution</st> <st c="43320">of some code fragments in the
    views and</st> <st c="43360">Jinja templates.</st>
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="43376">Lastly, to complete the integration of</st> <st c="43416">Flask-Login,
    implement a</st> `<st c="43468">logout_user()</st>` <st c="43481">utility of the</st>
    `<st c="43497">flask_login</st>` <st c="43508">module.</st> <st c="43517">The
    following code is the logout view implementation for</st> <st c="43574">our project:</st>
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: <st c="43731">Be sure that the logout view redirects the user to the login view
    page instead of just rendering the login page to</st> <st c="43846">avoid</st>
    **<st c="43853">HTTP status code 405</st>** <st c="43873">(</st>*<st c="43875">Method
    Not Allowed</st>*<st c="43893">)</st> <st c="43896">during re-login.</st>
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="43912">Does having a secured</st> <st c="43934">web form authentication
    prevent CSRF attacks from happening?</st> <st c="43996">Let us focus on protecting
    our applications from attackers who want to divert transactions to other</st>
    <st c="44096">suspicious sites.</st>
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="44113">Preventing CSRF attacks</st>
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="44137">CSRF is an attack whereby authenticated users are duped into diverting
    sensitive data to hidden and malicious sites.</st> <st c="44255">This attack happens</st>
    <st c="44274">when users perform</st> `<st c="44294">POST</st>`<st c="44298">,</st>
    `<st c="44300">DELETE</st>`<st c="44306">,</st> `<st c="44308">PUT</st>`<st c="44311">,
    or</st> `<st c="44316">PATCH</st>` <st c="44321">transactions, whereby form data
    are retrieved and submitted to the application.</st> <st c="44402">In Flask, the
    most common solution is to use</st> `<st c="44447">Flask-WTF</st>` <st c="44456">because
    it has a built-in</st> `<st c="44483">CSRFProtect</st>` <st c="44494">class that
    globally protects every form transaction of the application.</st> <st c="44567">Once
    enabled,</st> `<st c="44581">CSRFProtect</st>` <st c="44592">allows the generation
    of unique tokens for every form transaction.</st> <st c="44660">Those form submissions
    that will not generate a token will cause</st> `<st c="44725">CSRFProtect</st>`
    <st c="44736">to trigger an error message, detecting a</st> <st c="44778">CSRF
    attack.</st>
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[*<st c="44790">Chapter 4</st>*](B19383_04.xhtml#_idTextAnchor087) <st c="44800">highlights
    the setup of the Flask-</st>`<st c="44835">WTF</st>` <st c="44839">module in a
    Flask application.</st> <st c="44871">After its installation, import</st> `<st
    c="44902">CSRFProtect</st>` <st c="44913">and instantiate it in</st> `<st c="44936">create_app()</st>`<st
    c="44948">, as shown in the following</st> <st c="44976">code snippet:</st>'
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '<st c="47138">from flask_httpauth import HTTPBasicAuth</st> def create_app(config_file):'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: app = Flask(__name__,template_folder= '../modules/pages', static_folder= '../modules/resources')
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: app.config.from_file(config_file, toml.load)
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '… … … … … … <st c="47408">HTTPBasicAuth</st> implementation needs a callback
    function that will retrieve the username and password from the client, query the
    database to check the user’s records, and return the valid username to the application
    if it exists, like in the following code:'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '<st c="48869">from werkzeug.datastructures.auth import Authorization</st> app,
    celery_app, <st c="48942">auth</st> = <st c="48949">create_app(''../config_dev.toml'')</st>
    … … … … … … <st c="48993">@auth.get_user_roles</st> def get_scope(<st c="49028">user:Authorization</st>):'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: task = get_user_task_wrapper.apply_async( args=[user.username])
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'login:Login = task.get() <st c="49173">get_scope()</st> automatically retrieves
    the <st c="49213">werkzeug.datastructures.auth.Authorization</st> object from
    the request. The <st c="49285">Authorization</st> object contains the <st c="49319">username</st>
    on which the <st c="49341">get_user_task_wrapper()</st> Celery task will base
    its search for the <st c="49406">Login</st> record object of the user from the
    database. The return value of the callback function can be a single role in string
    format or a list of roles attributed to the user. The given <st c="49590">del_doctor_profile_id()</st>
    from the <st c="49623">ch09-auth-digest</st> project does not permit any authenticated
    users except for doctors whose <st c="49713">role</st> is equivalent to the <st
    c="49739">1</st> code:'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: <st c="50018">Here,</st> `<st c="50025">del_doctor_profile_id()</st>` <st c="50048">is
    an API function that deletes a doctor’s profile information in the database.</st>
    <st c="50129">No</st> <st c="50131">role can perform the transaction but the doctor
    (</st>`<st c="50181">role=1</st>`<st c="50188">) himself/herself.</st>
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="50207">Digest authentication</st>
  id: totrans-212
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="50229">On the other hand, the module’s</st> `<st c="50262">HTTPDigestAuth</st>`
    <st c="50276">builds a digest authentication scheme for the API-based applications,
    which</st> <st c="50352">encrypts the credentials and some of its additional headers
    to the applications such as</st> `<st c="50441">realm</st>`<st c="50446">,</st>
    `<st c="50448">nonce</st>`<st c="50453">,</st> `<st c="50455">opaque</st>`<st
    c="50461">, and</st> `<st c="50467">nonce count</st>`<st c="50478">. Thus, it
    is more secure than</st> <st c="50509">the basic authentication scheme.</st> <st
    c="50542">The following snippet shows how to set up digest authentication in the</st>
    `<st c="50613">create_app()</st>` <st c="50625">factory:</st>
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: <st c="53886">server_nonce = "H9OVSzjcB57StMQFPInmX22uZ0Kwu_4JptsWrj0oPpU"</st>
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: <st c="53947">server_opaque = "XJIXDX615CMGXXL0COHQQ0IJRG33OFTNGNFYT72VJ8XF5U3RYZ"</st>
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="54016">@auth.generate_nonce</st> def gen_nonce():'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 'return server_nonce <st c="54075">@auth.generate_opaque</st> def gen_opaque():'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return server_opaque
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '<st c="54758">@auth.verify_nonce</st> def verify_once(nonce):'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: 'if nonce == server_nonce:'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return True
  id: totrans-223
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'return False <st c="54859">@auth.verify_opaque</st> def verify_opaque(opaque):'
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if opaque == server_opaque:'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return True
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return False
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '<st c="55300">@auth.get_password</st> def get_passwd(username):'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: print(username)
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: task = get_user_task_wrapper.apply_async(args=[username])
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: login:Login = task.get()
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: … … … … … …
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if login == None: <st c="55475">return None</st> else: <st c="55548">get_password()</st>
    method every access to an API resource and provides the valid user’s password
    as a token.'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="55652">Bearer token authentication</st>
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="55680">Aside from Basic and Digest, the</st> `<st c="55714">Flask-HTTPAuth</st>`
    <st c="55728">module also supports the Bearer token authentication scheme by utilizing
    the</st> `<st c="55806">HTTPTokenAuth</st>` <st c="55819">class.</st> <st c="55827">The
    following</st> `<st c="55841">create_app()</st>` <st c="55853">snippet</st> <st
    c="55861">of the</st> `<st c="55869">ch09-auth-token</st>` <st c="55884">project
    sets</st> <st c="55897">up the Bearer</st> <st c="55912">token authentication:</st>
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: <st c="56530">from jwt import encode</st>
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="56553">@current_app.post(''/login/signup'')</st> async def add_signup():'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: login_json = request.get_json()
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: password = login_json["password"]
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'passphrase = generate_password_hash(password) <st c="56725">token = encode({''username'':
    login_json["username"],</st> <st c="56776">''exp'': int(time()) + 3600},</st>
    <st c="56804">current_app.config[''SECRET_KEY''],</st> <st c="56838">algorithm=''HS256'')</st>
    async with db_session() as sess:'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'async with sess.begin():'
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: repo = LoginRepository(sess)
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: login = Login(username=login_json["username"], password=passphrase, <st c="57013">token=token</st>,   role=login_json["role"])
  id: totrans-247
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: result = await repo.insert_login(login)
  id: totrans-248
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: … … … … … …
  id: totrans-249
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: return jsonify(record=login_json), 200
  id: totrans-250
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: <st c="57661">from jwt import decode</st>
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="57684">@auth.verify_token</st> def verify_token(token):'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: 'try: <st c="57734">data = decode(token, app.config[''SECRET_KEY''],</st><st
    c="57780">algorithms=[''HS256''])</st> except:'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return False
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if ''username'' in data:'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return data['username']
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: pip install authlib
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: <st c="59932">from authlib.integrations.flask_oauth2 import AuthorizationServer</st>
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: <st c="59998">from authlib.integrations.flask_oauth2 import ResourceProtector</st>
    from modules.security.oauth2_config import <st c="60106">PasswordGrant</st>, <st
    c="60121">query_client</st>, <st c="60135">save_token</st>
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: <st c="60145">require_oauth = ResourceProtector()</st>
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="60181">oauth_server = AuthorizationServer()</st> def create_app(config_file):'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: app = Flask(__name__,template_folder= '../modules/pages', static_folder=   '../modules/resources')
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: … … … … … …
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: oauth_server.init_app(app, query_client=<st c="60397">query_client</st>, save_token=<st
    c="60423">save_token</st>)
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: oauth_server.register_grant(<st c="60485">AuthorizationServer</st> class manages
    the authentication requests and responses of the application. It provides different
    types of endpoints that are suited to the authentication grant enforced by the
    application. Now, instantiating the class is the first step in building the OAuth2
    authorization server for clients or other applications. It needs <st c="60830">query_client()</st>
    and <st c="60849">save_token()</st> for its token generation and the grant type
    of the authorization mechanism.
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="60937">Authlib</st> <st c="60946">provides the</st> `<st c="60959">ResourceOwnerPasswordCredentialsGrant</st>`
    <st c="60996">class to implement the</st> `<st c="61133">authenticate_user()</st>`
    <st c="61152">to perform validation before performing the</st> `<st c="61197">query_client()</st>`
    <st c="61211">and</st> `<st c="61216">save_token()</st>` <st c="61228">methods.</st>
    <st c="61238">The following snippet shows the</st> `<st c="61270">ResourceOwnerPasswordCredentialsGrant</st>`
    <st c="61307">subclass of our</st> `<st c="61324">ch09-oauth2-password</st>` <st
    c="61344">project:</st>
  id: totrans-269
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'def query_client(<st c="62911">client_id</st>):'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: task = get_client_task_wrapper.apply_async( args=[<st c="62975">client_id</st>])
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: client:Client = task.get()
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return client
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '<st c="63427">from authlib.integrations.sqla_oauth2 import OAuth2ClientMixin</st>
    class Client(Base, <st c="63509">OAuth2ClientMixin</st>):'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: __tablename__ = 'oauth2_client'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: id = Column(Integer, Sequence('oauth2_client_id_seq', increment=1), primary_key
    = True)
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: user_id = Column(String(20), ForeignKey('login.username'), unique=True)
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: login = relationship('Login', back_populates="client")
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: … … … … … …
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '<st c="64333">from authlib.integrations.flask_oauth2.requests import FlaskOAuth2Request</st>
    def save_token(token_data, <st c="64434">request:FlaskOAuth2Request</st>):'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: 'if request.user:'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: user_id = request.user.user_id
  id: totrans-285
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: user_id = request.client.user_id
  id: totrans-287
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: token_dict = dict()
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: token_dict['client_id'] = request.client.client_id
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: token_dict['user_id'] = user_id
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: token_dict['issued_at'] = request.client.client_id_issued_at
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: token_dict['access_token_revoked_at'] = 0
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: token_dict['refresh_token_revoked_at'] = 0
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: token_dict['scope'] = request.client.client_metadata["scope"]
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: token_dict.update(token_data)
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'token_str = dumps(token_dict) <st c="64998">token_data</st> contains the <st
    c="65022">access_token</st>, and the request has the <st c="65060">Client</st>
    data retrieved from the <st c="65091">query_client()</st>. The method merges all
    these details into one <st c="65152">token_dict</st>, instantiates the <st c="65181">Token</st>
    class with <st c="65198">token_dict</st> as parameter, and stores the object record
    in the database. The following is the blueprint of the <st c="65307">Token</st>
    model:'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: <st c="65676">The</st> `<st c="65681">OAuth2TokenMixin</st>` <st c="65697">pads
    the</st> `<st c="65707">Token</st>` <st c="65712">class with the attributes related
    to</st> `<st c="65750">access_token</st>`<st c="65762">, such as</st> `<st c="65772">id,</st>`
    `<st c="65775">user_id</st>`<st c="65783">,</st> `<st c="65785">client_id</st>`<st
    c="65794">,</st> `<st c="65796">token_type</st>`<st c="65806">,</st> `<st c="65808">refresh_token</st>`<st
    c="65821">, and</st> `<st c="65827">scope</st>`<st c="65832">. By the way,</st>
    `<st c="65846">scope</st>` <st c="65851">is a mandatory field in Authlib that
    restricts access to the API resources based on some access level</st> <st c="65954">or
    role.</st>
  id: totrans-298
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="65962">To trigger the authorization</st> <st c="65992">server, the client
    must access the</st> `<st c="66027">/oauth/token</st>` <st c="66039">endpoint
    through basic authentication or form-based transactions.</st> <st c="66106">The
    following code shows the endpoint implementation of</st> <st c="66162">our application:</st>
  id: totrans-299
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: curl -u Xd3LH9mveF524LOscPq4MzLY:t8w56Y9OBRsxdVV9vrNwdtMzQ 8gY4hkKLKf4b6F6RQZlT2zI
    -XPOST http://localhost:5000/oauth/token -F grant_type=password -F username=sjctrags
    -F password=sjctrags -F scope=user_admin -F token_endpoint_auth_method=client_secret_basic
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '{"access_token": "fVFyaS06ECKIKFVtIfVj3ykgjhQjtc80JwCKyTMlZ2", "expires_in":
    864000, "scope": "user_admin", "token_type": "Bearer"}'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'curl -H "Authorization: Bearer fVFyaS06ECKIKFVtIfVj3y kgjhQjtc80JwCKyTMlZ2"
    http://localhost:5000/doctor/profile/add'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '<st c="67915">from modules import require_oauth</st> @current_app.route(''/doctor/profile/add'',
    methods = [''GET'', ''POST'']) <st c="68019">@require_oauth("user_admin")</st>
    async def add_doctor_profile():'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: … … … … … …
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'async with db_session() as sess:'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'async with sess.begin():'
  id: totrans-310
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: repo = DoctorRepository(sess)
  id: totrans-311
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: doc = Doctor(**doctor_json)
  id: totrans-312
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: result = await repo.insert_doctor(doc)
  id: totrans-313
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: … … … … … …
  id: totrans-314
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: return jsonify(record=doctor_json), 200
  id: totrans-315
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: pip install flask-limiter
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: pip install flask-limiter[redis]
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: <st c="69772">from flask_limiter import Limiter</st> from flask_limiter.util
    import get_remote_address
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: 'def create_app(config_file):'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: app = Flask(__name__,template_folder= '../modules/pages', static_folder=   '../modules/resources')
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: … … … … … …
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: global limiter
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: limiter = <st c="70020">Limiter</st>(
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: app=app, key_func=get_remote_address,
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: default_limits=["30 per day", "5 per hour"],
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: storage_uri="memory://", )
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '<st c="70647">from modules import limiter</st> @current_app.route(''/login/auth'',
    methods=[''GET'', ''POST'']) <st c="70734">@limiter.limit("5 per minute")</st>
    async def login_user():'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: 'if request.method == ''GET'':'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return render_template(  'login/authenticate.html'), 200
  id: totrans-333
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: username = request.form['username'].strip()
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: password = request.form['password'].strip()
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'async with db_session() as sess:'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'async with sess.begin():'
  id: totrans-337
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: repo = LoginRepository(sess)
  id: totrans-338
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: … … … … … …
  id: totrans-339
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: return render_template( 'login/authenticate.html'), 200
  id: totrans-340
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: <st c="0">Part 3:Testing, Deploying, and Building Enterprise-Grade Applications</st>
  id: totrans-350
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="70">In this last part, you will learn some options and workarounds to
    test, deploy, and run our Flask 3 applications.</st> <st c="185">Moreover, you
    will also understand the process of integrating Flask applications into GraphQL,
    React forms, Flutter mobile applications, and other applications built with FastAPI,
    Django, Tornado, and Flask using the</st> <st c="402">interoperability feature.</st>
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: <st c="427">This part includes the</st> <st c="451">following chapters:</st>
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '[*<st c="470">Chapter 10</st>*](B19383_10.xhtml#_idTextAnchor281)<st c="481">,</st>
    *<st c="483">Creating Test Cases for Flask</st>*'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*<st c="512">Chapter 11</st>*](B19383_11.xhtml#_idTextAnchor306)<st c="523">,</st>
    *<st c="525">Deploying Flask Applications</st>*'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*<st c="553">Chapter 12</st>*](B19383_12.xhtml#_idTextAnchor322)<st c="564">,</st>
    *<st c="566">Integrating Flask with Other Tools and Frameworks</st>*'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
