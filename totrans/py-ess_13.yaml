- en: Chapter 13. Metaprogramming and Decorators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The bulk of what we''ve covered has been programming—writing Python statements
    to process data. We can also use Python to process Python instead of processing
    data. We''ll call this metaprogramming. We''ll look at two aspects: decorators
    and metaclasses.'
  prefs: []
  type: TYPE_NORMAL
- en: A decorator is a function that accepts a function as an argument and returns
    a function. We can use this to add features to a function without repeating the
    feature in several different function definitions. A decorator prevents copy-and-paste
    programming. We often use this for logging, audit, or security purposes; these
    are things that will cut across a number of class or function definitions.
  prefs: []
  type: TYPE_NORMAL
- en: A metaclass definition will extend the essential object creation that happens
    when we make an instance of a class. Implicitly, the special method name of `__new__()`
    is used to create a bare object that is subsequently initialized by the `__init__()`
    method of the class. A metaclass allows us to change some of the fundamental features
    of object creation.
  prefs: []
  type: TYPE_NORMAL
- en: Simple metaprogramming with decorators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python has a few built-in decorators that will modify a function or a method
    of a class. For example, in [Chapter 11](ch11.html "Chapter 11. Class Definitions"),
    *Class Definitions*, we saw `@staticmethod` and `@property`, which are used to
    alter the behavior of a method in a class. The `@staticmethod` decorator changes
    a function to work on the class instead of an instance of the class. The `@property`
    decorator makes evaluating a no-argument method available via the same syntax
    as an attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'A function decorator that''s available in the `functools` module is `@lru_cache`.
    This modifies a function to add memoization. Having cached results can be a significant
    speed-up. It looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we've imported the `@lru_cache` decorator. We've also imported
    the `glob.glob()` function and the `os` module so that we can use `os.path.join()`
    to create filenames irrespective of OS-specific punctuation.
  prefs: []
  type: TYPE_NORMAL
- en: We've provided a size parameter to the `@lru_cache()` decorator. The parameterized
    decorator modifies the `find_source()` function by adding a cache that will hold
    100 previous results. This can speed up a program that does a lot of work with
    the local file system. The **last recently used** (**LRU**) algorithm assures
    that recent requests are preserved and older requests are quietly forgotten to
    limit the cache to the requested size.
  prefs: []
  type: TYPE_NORMAL
- en: The `@lru_cache` decorator embodies a reusable optimization that can be applied
    to a variety of functions. We have separated the memoization aspect from other
    aspects of a function's implementation.
  prefs: []
  type: TYPE_NORMAL
- en: The *Python Standard Library* defines a few decorators. For more examples of
    decorator metaprogramming, see the Python Decorator Library page, [https://wiki.python.org/moin/PythonDecoratorLibrary](https://wiki.python.org/moin/PythonDecoratorLibrary).
  prefs: []
  type: TYPE_NORMAL
- en: Defining our own decorator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In some cases, we can extract a common aspect from a number of functions. Concerns
    like security, audit, or logging are common examples of something we might want
    to implement consistently across many functions or classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at a way to support enhanced debugging. Our goal is to have a simple
    annotation that we can use to provide consistent, detailed output from several
    unrelated functions. We''d like to create a module with definitions like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We've defined two simple functions that will be wrapped by a decorator to provide
    consistent debugging output.
  prefs: []
  type: TYPE_NORMAL
- en: 'A decorator is a function that accepts a function as an argument and returns
    a function as a result. What we''ve shown in the preceding piece of code is evaluated
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: When we apply a decorator to a function, we're implicitly evaluating the decorator
    function with an original function as the argument. This will create the decorated
    function as a result. Using a decorator creates a result with the same name as
    the original function—the decorated version replaces the original.
  prefs: []
  type: TYPE_NORMAL
- en: For this to work, we'll need to write a decorator that creates the debugging
    log entries. This must be generic so that it will work for any function. As we
    noted in [Chapter 7](ch07.html "Chapter 7. Basic Function Definitions"), *Basic
    Function Definitions*, we can use the `*` and `**` modifiers to collect "all other"
    positional arguments and all other keyword arguments into a single sequence or
    a single dictionary. This allows us to write completely generic decorators.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the `@debug_log` decorator function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The body of the decorator definition does three things. First, it creates a
    logger based on the original function's name, `func.__name__`. Second, it defines
    an entirely new function, named `decorated()`, which is based on the original
    function. Finally, it returns that new function.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we used a decorator from the `functools` library, `@wraps`, to show
    that the new decorator function wraps the original function. This will assure
    that the name and docstring are properly copied from the original function to
    the decorated function. The decorated version will be indistinguishable from the
    original.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use these functions normally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The decoration has no impact on the value of the function. It has a small performance
    impact.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we have logging enabled, and we set the logging level to `DEBUG`, we''ll
    see additional output in the log. The preceding example would lead to the following
    in the logger''s output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This shows the debugging detail produced by this decorator. The log shows the
    argument values and the result value. If there's an exception, we'll see the argument
    values as well as the exception message, which can be more useful than the default
    behavior of just showing the exception message.
  prefs: []
  type: TYPE_NORMAL
- en: 'An easy way to enable the logger is to include the following in the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This will direct the log output to the standard error stream. It will also include
    all messages that have a severity level above the debug level. We can change this
    level setting to a value like `logging.INFO` to silence the debugging messages,
    leaving informational messages intact.
  prefs: []
  type: TYPE_NORMAL
- en: A decorator that also accepts parameters values—in a manner similar to the `@lru_cache`
    decorator—is more complex. The argument values are first applied to create a decorator.
    The decorator that results from this initial binding is then used to build the
    decorated function from the original function.
  prefs: []
  type: TYPE_NORMAL
- en: More complex metaprogramming with metaclasses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In some cases, the default features built into a class aren't appropriate for
    our particular application. We can see a few common situations where we might
    want to extend the default behavior of object construction.
  prefs: []
  type: TYPE_NORMAL
- en: We can use a metaclass to preserve some of the original source code that defined
    a class. By default, each class object uses `dict` to store the various methods
    and class-level attributes. We might want to use an ordered dictionary to retain
    the original source code ordering for class-level attributes. An example of this
    is shown in the *Python Standard Library*, section 3.3.3.5.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **abstract base classes** (**ABC**) rely on a `metaclass __new__()` method
    to confirm that the concrete subclass is complete when we attempt to create an
    instance of the class. If we fail to provide all of the required methods in a
    subclass of an ABC, we can't create an instance of that subclass.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Metaclasses can be used to simplify object serialization. A metaclass can incorporate
    information required for XML or JSON representation of an instance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use a metaclass to inject additional attributes into an object. Because
    a metaclass provides the implementation of the `__new__()` method used to create
    an empty object, it is able to inject attributes before the `__init__()` method
    is evaluated. For some immutable classes, such as tuples, there is no `__init__()`
    method, and a subclass of the tuple must use the `__new__()` method to set the
    value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The default metaclass is `type`. This is used by application classes to create
    the new, bare object prior to the `__init__()` method being invoked. The built-in
    `type.__new__()` method requires four argument values—the metaclass, the application
    class name, the base classes for the application class, and a namespace of system-defined
    initial values.
  prefs: []
  type: TYPE_NORMAL
- en: When we create a metaclass, we'll override the `__new__()` method. We'll still
    use the `type.__new__()` method to create the bare object. We can then extend
    or modify this bare object before returning the object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a metaclass that inserts a logger prior to `__init__()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We've defined a class that extends the built-in `type` class. We've defined
    an overriding special method, `__new__()`. The special method uses the superclass
    `type.__new__()` method to create the bare object, which is assigned to the `result`
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have the bare object, we can create a logger and inject this logger
    into the bare object. This `self.logger` attribute will be available from the
    very first line of the `__init__()` method in each class that's created using
    this metaclass.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create application classes that leverage this metaclass, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We've defined a class that explicitly depends on the `Logged` metaclass. If
    we don't include the `metaclass` keyword parameter, the default metaclass of `type`
    will be used. In this class, the `logger` attribute was created before the `__init__()`
    method was invoked. This allows us to use the logger in the `__init__()` method
    without any further overhead.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've looked at two common metaprogramming techniques. The
    first is writing decorator functions—these can be used to transform an original
    function to add new features. The second is using a metaclass to extend the default
    behavior of class definitions.
  prefs: []
  type: TYPE_NORMAL
- en: We can use these techniques to develop application features that cut across
    many functions and classes. Writing a feature once and applying it to a number
    of classes assures us of consistency and can help during debugging, as well as
    upgrades or refactoring.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 14](ch14.html "Chapter 14. Fit and Finish – Unit Testing, Packaging,
    and Documentation"), *Fit and Finish – Unit Testing, Packaging, and Documentation*,
    we'll look at a number of features that characterize a complete Python project.
    Rather than address technical language features, we'll look at ways we can use
    Python features to create polished, complete solutions.
  prefs: []
  type: TYPE_NORMAL
