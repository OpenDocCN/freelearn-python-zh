- en: Chapter 13. Metaprogramming and Decorators
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第13章。元编程和装饰器
- en: 'The bulk of what we''ve covered has been programming—writing Python statements
    to process data. We can also use Python to process Python instead of processing
    data. We''ll call this metaprogramming. We''ll look at two aspects: decorators
    and metaclasses.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所涵盖的大部分内容都是编程——编写Python语句来处理数据。我们也可以使用Python来处理Python，而不是处理数据。我们将这称为元编程。我们将探讨两个方面：装饰器和元类。
- en: A decorator is a function that accepts a function as an argument and returns
    a function. We can use this to add features to a function without repeating the
    feature in several different function definitions. A decorator prevents copy-and-paste
    programming. We often use this for logging, audit, or security purposes; these
    are things that will cut across a number of class or function definitions.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器是一个接受函数作为参数并返回函数的函数。我们可以使用它来向函数添加功能，而无需在多个不同的函数定义中重复该功能。装饰器防止了复制粘贴编程。我们经常用于日志记录、审计或安全目的；这些都是将跨越多个类或函数定义的事情。
- en: A metaclass definition will extend the essential object creation that happens
    when we make an instance of a class. Implicitly, the special method name of `__new__()`
    is used to create a bare object that is subsequently initialized by the `__init__()`
    method of the class. A metaclass allows us to change some of the fundamental features
    of object creation.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 元类定义将扩展当我们创建类的实例时发生的本质对象创建。隐式地，使用特殊的`__new__()`方法名称来创建一个裸对象，随后由类的`__init__()`方法进行初始化。元类允许我们改变对象创建的一些基本特性。
- en: Simple metaprogramming with decorators
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用装饰器的简单元编程
- en: Python has a few built-in decorators that will modify a function or a method
    of a class. For example, in [Chapter 11](ch11.html "Chapter 11. Class Definitions"),
    *Class Definitions*, we saw `@staticmethod` and `@property`, which are used to
    alter the behavior of a method in a class. The `@staticmethod` decorator changes
    a function to work on the class instead of an instance of the class. The `@property`
    decorator makes evaluating a no-argument method available via the same syntax
    as an attribute.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Python有一些内置的装饰器可以修改函数或类的成员方法。例如，在第11章[类定义](ch11.html "第11章。类定义")中，我们看到了`@staticmethod`和`@property`，它们用于改变类中方法的行怍。`@staticmethod`装饰器将函数改为在类上工作，而不是在类的实例上工作。`@property`装饰器使得评估无参数方法可以通过与属性相同的语法进行。
- en: 'A function decorator that''s available in the `functools` module is `@lru_cache`.
    This modifies a function to add memoization. Having cached results can be a significant
    speed-up. It looks like this:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '`functools`模块中可用的函数装饰器是`@lru_cache`。这修改了一个函数以添加备忘录。缓存结果可以显著提高速度。它看起来是这样的：'
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this example, we've imported the `@lru_cache` decorator. We've also imported
    the `glob.glob()` function and the `os` module so that we can use `os.path.join()`
    to create filenames irrespective of OS-specific punctuation.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们导入了`@lru_cache`装饰器。我们还导入了`glob.glob()`函数和`os`模块，这样我们就可以使用`os.path.join()`来创建文件名，而不管操作系统特定的标点符号。
- en: We've provided a size parameter to the `@lru_cache()` decorator. The parameterized
    decorator modifies the `find_source()` function by adding a cache that will hold
    100 previous results. This can speed up a program that does a lot of work with
    the local file system. The **last recently used** (**LRU**) algorithm assures
    that recent requests are preserved and older requests are quietly forgotten to
    limit the cache to the requested size.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向`@lru_cache()`装饰器提供了一个大小参数。参数化装饰器通过添加一个将保存100个先前结果的缓存来修改`find_source()`函数。这可以加快大量使用本地文件系统的程序。**最近最少使用**（**LRU**）算法确保保留最近的请求，并悄悄地忘记较旧的请求，以限制缓存的大小。
- en: The `@lru_cache` decorator embodies a reusable optimization that can be applied
    to a variety of functions. We have separated the memoization aspect from other
    aspects of a function's implementation.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`@lru_cache`装饰器体现了一种可重用的优化，可以应用于各种函数。我们将函数实现的备忘录方面与其他方面分离。'
- en: The *Python Standard Library* defines a few decorators. For more examples of
    decorator metaprogramming, see the Python Decorator Library page, [https://wiki.python.org/moin/PythonDecoratorLibrary](https://wiki.python.org/moin/PythonDecoratorLibrary).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*Python标准库*定义了一些装饰器。有关装饰器元编程的更多示例，请参阅Python装饰器库页面，[https://wiki.python.org/moin/PythonDecoratorLibrary](https://wiki.python.org/moin/PythonDecoratorLibrary)。'
- en: Defining our own decorator
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义我们自己的装饰器
- en: In some cases, we can extract a common aspect from a number of functions. Concerns
    like security, audit, or logging are common examples of something we might want
    to implement consistently across many functions or classes.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们可以从多个函数中提取一个共同方面。像安全、审计或日志记录这样的关注点是我们在许多函数或类中一致实现的一些常见示例。
- en: 'Let''s look at a way to support enhanced debugging. Our goal is to have a simple
    annotation that we can use to provide consistent, detailed output from several
    unrelated functions. We''d like to create a module with definitions like this:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一种支持增强调试的方法。我们的目标是有一个简单的注解，我们可以用它从几个无关的函数中提供一致、详细的输出。我们希望创建一个具有如下定义的模块：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We've defined two simple functions that will be wrapped by a decorator to provide
    consistent debugging output.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了两个简单的函数，这些函数将被装饰器包装以提供一致的调试输出。
- en: 'A decorator is a function that accepts a function as an argument and returns
    a function as a result. What we''ve shown in the preceding piece of code is evaluated
    as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器是一个接受函数作为参数并返回函数作为结果的函数。前面代码块中展示的内容评估如下：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When we apply a decorator to a function, we're implicitly evaluating the decorator
    function with an original function as the argument. This will create the decorated
    function as a result. Using a decorator creates a result with the same name as
    the original function—the decorated version replaces the original.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将装饰器应用于一个函数时，我们隐式地用原始函数作为参数评估装饰器函数。这将创建一个装饰后的函数作为结果。使用装饰器创建的结果与原始函数具有相同的名称——装饰后的版本替换了原始版本。
- en: For this to work, we'll need to write a decorator that creates the debugging
    log entries. This must be generic so that it will work for any function. As we
    noted in [Chapter 7](ch07.html "Chapter 7. Basic Function Definitions"), *Basic
    Function Definitions*, we can use the `*` and `**` modifiers to collect "all other"
    positional arguments and all other keyword arguments into a single sequence or
    a single dictionary. This allows us to write completely generic decorators.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这生效，我们需要编写一个装饰器来创建调试日志条目。这必须是通用的，以便它适用于任何函数。正如我们在[第7章](ch07.html "第7章。基本函数定义")中提到的，*基本函数定义*，我们可以使用`*`和`**`修饰符将“所有其他”位置参数和所有其他关键字参数收集到一个单一的序列或一个单一的字典中。这允许我们编写完全通用的装饰器。
- en: 'Here''s the `@debug_log` decorator function:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`@debug_log`装饰器函数：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The body of the decorator definition does three things. First, it creates a
    logger based on the original function's name, `func.__name__`. Second, it defines
    an entirely new function, named `decorated()`, which is based on the original
    function. Finally, it returns that new function.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器定义的主体做了三件事。首先，它根据原始函数的名称`func.__name__`创建了一个日志记录器。其次，它定义了一个全新的函数，命名为`decorated()`，这个函数基于原始函数。最后，它返回这个新函数。
- en: Note that we used a decorator from the `functools` library, `@wraps`, to show
    that the new decorator function wraps the original function. This will assure
    that the name and docstring are properly copied from the original function to
    the decorated function. The decorated version will be indistinguishable from the
    original.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用了`functools`库中的一个装饰器`@wraps`来显示新装饰器函数包装了原始函数。这将确保名称和文档字符串正确地从原始函数复制到装饰后的函数。装饰后的版本将无法与原始版本区分。
- en: 'We can use these functions normally:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像使用普通函数一样使用这些函数：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The decoration has no impact on the value of the function. It has a small performance
    impact.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰对函数的值没有影响。它有轻微的性能影响。
- en: 'If we have logging enabled, and we set the logging level to `DEBUG`, we''ll
    see additional output in the log. The preceding example would lead to the following
    in the logger''s output:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们启用了日志记录，并将日志级别设置为`DEBUG`，我们将在日志中看到额外的输出。前面的示例会导致以下内容出现在日志记录器的输出中：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This shows the debugging detail produced by this decorator. The log shows the
    argument values and the result value. If there's an exception, we'll see the argument
    values as well as the exception message, which can be more useful than the default
    behavior of just showing the exception message.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了由这个装饰器产生的调试细节。日志显示了参数值和结果值。如果有异常，我们还会看到参数值以及异常信息，这比只显示异常信息更有用。
- en: 'An easy way to enable the logger is to include the following in the application:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 启用日志记录的一个简单方法是在应用程序中包含以下内容：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This will direct the log output to the standard error stream. It will also include
    all messages that have a severity level above the debug level. We can change this
    level setting to a value like `logging.INFO` to silence the debugging messages,
    leaving informational messages intact.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把日志输出定向到标准错误流。它还将包括所有严重级别高于调试级别的消息。我们可以将此级别设置更改为类似 `logging.INFO` 的值，以静默调试消息，同时保留信息性消息。
- en: A decorator that also accepts parameters values—in a manner similar to the `@lru_cache`
    decorator—is more complex. The argument values are first applied to create a decorator.
    The decorator that results from this initial binding is then used to build the
    decorated function from the original function.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一个也接受参数值的装饰器——类似于 `@lru_cache` 装饰器——更复杂。首先将参数值应用于创建装饰器。然后使用这个初始绑定产生的装饰器来构建装饰函数。
- en: More complex metaprogramming with metaclasses
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用元类的更复杂元编程
- en: In some cases, the default features built into a class aren't appropriate for
    our particular application. We can see a few common situations where we might
    want to extend the default behavior of object construction.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，类中内置的默认功能可能不适合我们的特定应用。我们可以看到一些常见的情况，我们可能想要扩展对象构造的默认行为。
- en: We can use a metaclass to preserve some of the original source code that defined
    a class. By default, each class object uses `dict` to store the various methods
    and class-level attributes. We might want to use an ordered dictionary to retain
    the original source code ordering for class-level attributes. An example of this
    is shown in the *Python Standard Library*, section 3.3.3.5.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用元类来保留定义类的原始源代码的一部分。默认情况下，每个类对象使用 `dict` 来存储各种方法和类级属性。我们可能想使用有序字典来保留类级属性的原始源代码顺序。一个例子可以在
    *Python 标准库* 的 3.3.3.5 节中找到。
- en: The **abstract base classes** (**ABC**) rely on a `metaclass __new__()` method
    to confirm that the concrete subclass is complete when we attempt to create an
    instance of the class. If we fail to provide all of the required methods in a
    subclass of an ABC, we can't create an instance of that subclass.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**抽象基类**（**ABC**）依赖于一个 `metaclass __new__()` 方法来确认当我们尝试创建类的实例时，具体的子类是否完整。如果我们未能在一个ABC的子类中提供所有必需的方法，我们就无法创建该子类的实例。'
- en: Metaclasses can be used to simplify object serialization. A metaclass can incorporate
    information required for XML or JSON representation of an instance.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元类可用于简化对象序列化。元类可以包含用于XML或JSON表示实例所需的信息。
- en: We can use a metaclass to inject additional attributes into an object. Because
    a metaclass provides the implementation of the `__new__()` method used to create
    an empty object, it is able to inject attributes before the `__init__()` method
    is evaluated. For some immutable classes, such as tuples, there is no `__init__()`
    method, and a subclass of the tuple must use the `__new__()` method to set the
    value.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用元类向对象注入额外的属性。因为元类提供了创建空对象的 `__new__()` 方法的实现，它能够在 `__init__()` 方法评估之前注入属性。对于一些不可变类，如元组，没有
    `__init__()` 方法，元组的子类必须使用 `__new__()` 方法来设置值。
- en: The default metaclass is `type`. This is used by application classes to create
    the new, bare object prior to the `__init__()` method being invoked. The built-in
    `type.__new__()` method requires four argument values—the metaclass, the application
    class name, the base classes for the application class, and a namespace of system-defined
    initial values.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 默认元类是 `type`。这是由应用程序类在调用 `__init__()` 方法之前创建新裸对象时使用的。内置的 `type.__new__()` 方法需要四个参数值——元类、应用程序类的名称、应用程序类的基础类，以及系统定义的初始值命名空间。
- en: When we create a metaclass, we'll override the `__new__()` method. We'll still
    use the `type.__new__()` method to create the bare object. We can then extend
    or modify this bare object before returning the object.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建元类时，我们将覆盖 `__new__()` 方法。我们仍然会使用 `type.__new__()` 方法来创建裸对象。然后我们可以在返回对象之前扩展或修改这个裸对象。
- en: 'Here''s a metaclass that inserts a logger prior to `__init__()`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个在 `__init__()` 之前插入日志记录器的元类：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We've defined a class that extends the built-in `type` class. We've defined
    an overriding special method, `__new__()`. The special method uses the superclass
    `type.__new__()` method to create the bare object, which is assigned to the `result`
    variable.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个扩展内置 `type` 类的类。我们定义了一个重写的特殊方法，`__new__()`。这个特殊方法使用超类 `type.__new__()`
    方法来创建裸对象，并将其分配给 `result` 变量。
- en: Once we have the bare object, we can create a logger and inject this logger
    into the bare object. This `self.logger` attribute will be available from the
    very first line of the `__init__()` method in each class that's created using
    this metaclass.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了裸对象，我们就可以创建一个记录器并将这个记录器注入到裸对象中。这个`self.logger`属性将在使用这个元类创建的每个类的`__init__()`方法的第
    一行就可用。
- en: 'We can create application classes that leverage this metaclass, like this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建利用这个元类的应用程序类，如下所示：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We've defined a class that explicitly depends on the `Logged` metaclass. If
    we don't include the `metaclass` keyword parameter, the default metaclass of `type`
    will be used. In this class, the `logger` attribute was created before the `__init__()`
    method was invoked. This allows us to use the logger in the `__init__()` method
    without any further overhead.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个显式依赖于`Logged`元类的类。如果我们不包括`metaclass`关键字参数，将使用默认的`type`元类。在这个类中，`logger`属性是在调用`__init__()`方法之前创建的。这允许我们在`__init__()`方法中使用记录器而不需要任何额外的开销。
- en: Summary
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we've looked at two common metaprogramming techniques. The
    first is writing decorator functions—these can be used to transform an original
    function to add new features. The second is using a metaclass to extend the default
    behavior of class definitions.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了两种常见的元编程技术。第一种是编写装饰器函数——这些可以用来转换原始函数以添加新特性。第二种是使用元类来扩展类定义的默认行为。
- en: We can use these techniques to develop application features that cut across
    many functions and classes. Writing a feature once and applying it to a number
    of classes assures us of consistency and can help during debugging, as well as
    upgrades or refactoring.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这些技术来开发跨越许多功能和类的应用程序特性。一次编写一个特性并将其应用于多个类，可以确保一致性，并在调试、升级或重构期间提供帮助。
- en: In [Chapter 14](ch14.html "Chapter 14. Fit and Finish – Unit Testing, Packaging,
    and Documentation"), *Fit and Finish – Unit Testing, Packaging, and Documentation*,
    we'll look at a number of features that characterize a complete Python project.
    Rather than address technical language features, we'll look at ways we can use
    Python features to create polished, complete solutions.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第14章](ch14.html "第14章。完善 - 单元测试、打包和文档")“完善 - 单元测试、打包和文档”中，我们将探讨一系列特征，这些特征定义了一个完整的Python项目。我们不会处理技术语言特性，而是会探讨我们可以如何使用Python特性来创建精致、完整的解决方案。
