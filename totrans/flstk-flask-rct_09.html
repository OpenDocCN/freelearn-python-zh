<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-153"><a id="_idTextAnchor186"/>9</h1>
<h1 id="_idParaDest-154"><a id="_idTextAnchor187"/>API Development and Documentation</h1>
<p>The <strong class="bold">application programming interface</strong> (<strong class="bold">API</strong>) is core to many technologies developers<a id="_idIndexMarker573"/> use to deal with data and facilitate communication between different systems. API-enabled digital business models are fast-growing. The need for experienced developers to build innovative enterprise solutions is equally on the rise.</p>
<p>The API economy is evolving into a new business model for sustainable business growth with a ton of opportunities for business owners and smart executives. If there were ever a time to be a developer, it would be now, with the plethora of public APIs and valuable commercial APIs that can make application development and deployment achievable with less effort.</p>
<p>Previously in this book, we discussed how databases and data modeling can be used to effectively store and retrieve application data as required. This chapter presents the opportunity to dive into the heart of backend development and leverage API technology to enable seamless communication between the various client applications and backend services.</p>
<p>You will learn about API design and development in Flask web applications. We will touch on common API terminologies to take your understanding of API design to a higher-than-average level. You will learn the REST API best practices and how to implement database CRUD operations in Flask and SQLAlchemy.</p>
<p>By the time we wrap up this chapter, you will have harnessed a better understanding of RESTful API architecture and how to design and implement a RESTful API in Flask web applications. You will have acquired an improved understanding of endpoint and payload structure to deal with data efficiently.</p>
<p>Eventually, you will be able to build Flask web applications that can handle HTTP requests and responses. You will be able to use Flask’s SQLAlchemy extension to interact with a database and perform CRUD operations.</p>
<p>Finally, you will test some of the API endpoints and write clear and concise documentation for the implemented API endpoints using Postman.</p>
<p>In this chapter, we’ll be covering the following topics:</p>
<ul>
<li>What is an API?</li>
<li>Why use an API in web development</li>
<li>Endpoint and payload anatomy</li>
<li>Understanding HTTP requests/responses</li>
<li>Understanding HTTP status codes</li>
<li>REST API design principles</li>
<li>Implementing a REST API in Flask applications</li>
<li>API interaction with a database via CRUD operations</li>
<li>API documentation</li>
</ul>
<h1 id="_idParaDest-155"><a id="_idTextAnchor188"/>Technical requirements</h1>
<p>The complete code for this chapter is available on GitHub at: <a href="https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter09">https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter09</a>.</p>
<h1 id="_idParaDest-156"><a id="_idTextAnchor189"/>What is an API?</h1>
<p><strong class="bold">API</strong> stands for <strong class="bold">application programming interface</strong>. On the surface, an API seems like another <a id="_idIndexMarker574"/>piece of technical jargon coined to make learning application development difficult. This is not the case. An API’s core purpose is to facilitate communication between different systems based on an agreed set of rules, methods, and protocols.</p>
<p>In the context of web applications, an API helps omnichannel frontend applications to communicate with backend services. The growing demand for digital services is fueling innovative ideas from business organizations to make their digital assets available through the design and implementation of APIs.</p>
<p>As a developer, you are going to spend a great chunk of your time developing solutions that are API-driven. Knowing how to design and implement API solutions increases your skill capital and value to your employer. Broadly speaking, there are two types of APIs: <strong class="bold">private APIs</strong> and <strong class="bold">public APIs</strong>.</p>
<p>Private APIs <a id="_idIndexMarker575"/>are sometimes called<a id="_idIndexMarker576"/> internal APIs. A <a id="_idIndexMarker577"/>private API describes an open architecture interface that allows developers working within an organization to have access to critical organization data. With an API, it becomes easy to automate business processes and manage information flow between various business units.</p>
<p>Private APIs allow businesses to develop in-house solutions efficiently with the help of existing reuseable platforms. For instance, you can broaden the scope of your frontend applications from web applications to mobile applications, leveraging the same backend services.</p>
<p>On the other hand, public APIs <a id="_idIndexMarker578"/>describe a<a id="_idIndexMarker579"/> standardized interface that allows developers external to an organization to have programmable access to an organization’s data and services meant for public consumption. This set of interfaces allows developers to build new applications or add more functionality to their applications without reinventing the wheel. In this age, quite a huge number of public APIs are available for developers’ learning purposes and are a smart way to develop innovative solutions.</p>
<p>The following<a id="_idIndexMarker580"/> GitHub link describes some of the public APIs you can leverage: <a href="https://github.com/public-apis/public-apis">https://github.com/public-apis/public-apis</a>. Platforms such as Google, Twitter, Facebook, and Spotify allow developers to access the platform’s data through APIs. With this, developers are able to build on-demand services and products.</p>
<p>In addition, other forms of APIs are <strong class="bold">Simple Object Access Protocol</strong> (<strong class="bold">SOAP</strong>), <strong class="bold">JavaScript Object Notation-Remote Procedure Call</strong> (<strong class="bold">JSON-RPC</strong>), <strong class="bold">Extensible Markup Language-Remote Procedure Call</strong> (<strong class="bold">XML-RPC</strong>), and <strong class="bold">Representational State Transfer</strong> (<strong class="bold">REST</strong>). These <a id="_idIndexMarker581"/>sets of rules, protocols, and <a id="_idIndexMarker582"/>specifications <a id="_idIndexMarker583"/>describe how different <a id="_idIndexMarker584"/>systems can communicate over a network. While JSON-RPC and REST can be used together, exploring this integration is not within the scope of this book.</p>
<p>The next part of this book will examine why APIs have emerged as a key technology for businesses and developers, and how they are transforming the way software, tools, and digital services are built and consumed.</p>
<h1 id="_idParaDest-157"><a id="_idTextAnchor190"/>Why use an API in web development</h1>
<p>APIs are <a id="_idIndexMarker585"/>an integral part of modern web application development. You will rarely come across a data-driven web app without some form of API implementation. The reason why APIs are so popular is not difficult to see. APIs enable seamless integration, collaboration, and innovation by providing standardized ways to facilitate efficient resource sharing across diverse applications and systems. The following are some of the benefits of the use of APIs in <a id="_idIndexMarker586"/>web development:</p>
<ul>
<li>APIs allow separate systems to interact, bridging communication gaps between different components of web applications</li>
<li>API-driven development enables access to third-party data and services, fostering innovative solutions and reducing development time</li>
<li>APIs provide a secure and scalable means of sharing information for developers and end users</li>
<li>API-centric development reduces software development time by leveraging existing APIs and avoiding reinventing the wheel</li>
<li>APIs have substantial financial potential, as exemplified by the significant revenue generated by Google Maps and Twilio through API access</li>
<li>In healthcare, API-driven web applications facilitate the access and management of critical health data</li>
<li>APIs are valuable in the travel and tourism industry for accessing real-time flight booking information and finding the best prices</li>
<li>APIs play a vital role in e-commerce by integrating payment solutions and enabling seamless transactions</li>
<li>API abstraction allows developers to build secure web applications with controlled data exposure and secure architecture design</li>
</ul>
<p>Next, we <a id="_idIndexMarker587"/>will briefly explore endpoint and payload structure to understand how to define clear and logical paths for accessing resources in API design and ensure a proper data structure for the effective communication of information between the client and server.</p>
<h1 id="_idParaDest-158"><a id="_idTextAnchor191"/>Endpoint and payload anatomy</h1>
<p>Endpoints and payloads are a crucial part of any API component. Endpoints facilitate access to resources on a server through the use of well-defined routes or URLs. Endpoints usually act as the actual point at which data exchange occurs between two disparate applications in a client-server environment. Payloads allow us to send data along with a request or a response. We will discuss more on payloads in a jiffy.</p>
<p>Let’s start by examining the structure of an endpoint and the rules guiding endpoints set up in a REST API.</p>
<h2 id="_idParaDest-159"><a id="_idTextAnchor192"/>Understanding the endpoint structure</h2>
<p>Endpoint structures <a id="_idIndexMarker588"/>allow you to logically organize the resources of your application. We are going to start <a id="_idIndexMarker589"/>with a <code>venue</code> resource in exploring endpoint structure. Data is usually represented as resources in a REST API. You can define an endpoint for a <code>venues</code> collection with a <code>venue</code> resource following the use of the <code>collection/resource</code> path convention.</p>
<p class="callout-heading">Note</p>
<p class="callout">The <code>venue</code> resource represents an object or data structure accessible via a unique URL endpoint that allows clients to retrieve, create, update, or delete information about the venue.</p>
<p>One of the primary goals of an API designer is to clearly model data as a resource that other developers can use in their applications.</p>
<p>For instance, <code>https://example.com:5000/api/v1/venues</code> is a whole path that leads to the <code>venue</code> resource on an API server.</p>
<p>Let’s go through the structure of the path:</p>
<ul>
<li><code>https</code>: Secured protocol</li>
<li><code>example.com</code>: Domain name</li>
<li><code>500</code>: Port number</li>
<li><code>/</code><code>api/v1/venues</code>: Endpoint<p class="list-inset"><code>/api/</code> represents the entry point of an API endpoint, <code>/v1/</code> represents the version number of the API, and <code>/venues</code> represents the resource</p></li>
</ul>
<p>We can <a id="_idIndexMarker590"/>perform the following API operations on the endpoint based on the HTTP methods:</p>
<ul>
<li><code>GET</code> <code>/api/v1/venues</code>: Returns a list of all the venues</li>
<li><code>GET</code> <code>/api/v1/venues/id</code>: Retrieves a single venue identified with <code>id</code></li>
<li><code>POST</code> <code>/api/v1/venues/</code>: Creates a venue resource</li>
<li><code>UPDATE</code> <code>/api/v1/venues/id</code>: Updates a single venue identified with <code>id</code></li>
<li><code>DELETE</code> <code>/api/v1/venues/id</code>: Deletes a single venue identified with <code>id</code></li>
</ul>
<p>Let’s retrieve information about venues using the appropriate HTTP methods. The <code>/api/v1/venues</code> URL endpoint is used to get an overview of all available venues and their associated information from the data source. The response will be in JSON format, providing a structured representation of the venue data.</p>
<p>For example, let’s examine a venue resource request and expected response in JSON format.</p>
<p>With <code>GET</code> <code>/api/v1/venues</code>, the expected response in JSON format will be a list of all available venues:</p>
<pre class="source-code">[{
"id":1
"name": "Auditorium A"
},
{
"id":2
"name": "Auditorium B"
},
]</pre>
<p>With <code>GET</code> <code>/api/v1/venues/2</code>, the expected response in JSON format will be a specific venue resource with <code>id</code> <code>2</code>:</p>
<pre class="source-code">[{
"id":2
"name": "Auditorium B"
}]</pre>
<p>With <code>POST</code> <code>/api/v1/venues</code>, the <a id="_idIndexMarker591"/>expected response in JSON format will be an added venue resource with the returned <code>id</code> <code>3</code>:</p>
<pre class="source-code">[{
"id":3
"name": "Auditorium C"
}]</pre>
<p>With <code>UPDATE</code> <code>/api/v1/venues/3</code>, the expected response in JSON will be an updated venue resource with <code>id</code> <code>3</code>; the new value of the <code>name</code> property is now <code>Conference Hall</code>:</p>
<pre class="source-code">[{
"id":3
"name": "Conference Hall"
}
]</pre>
<p>With <code>DELETE</code> <code>/api/v1/venues/3</code>, the expected response in JSON will be a deleted resource<a id="_idIndexMarker592"/> venue with <code>id</code> <code>3</code>:</p>
<pre class="source-code">[{
"id":3
}
]</pre>
<p>The preceding JSON response messages depict endpoint data representation based on the requests to the server. The <code>/api/v1/venues</code> RESTful API endpoints with <code>GET</code> will return a list of available venues, <code>GET /api/v1/venues/2</code> will return a specific venue with <code>id</code> <code>2</code>, <code>POST /api/v1/venues</code> will add a new venue and return its <code>id</code>, <code>UPDATE /api/v1/venues/3</code> will update the venue with <code>id 3</code> and return the updated resource, and <code>DELETE /api/v1/venues/3</code> will delete the venue with <code>id</code> <code>3</code>.</p>
<p>Next, we will examine some of the golden rules to adhere to while designing endpoints. With these principles, you will be able to design a more intuitive and user-friendly RESTful API that will reduce the time and effort required to develop and maintain applications that use the API.</p>
<h3>API endpoint best practices</h3>
<p>There are <a id="_idIndexMarker593"/>principles guiding the design of a good API endpoint and by extension API development. We will briefly examine the following golden rules for designing API endpoints your team members or other developers can relate to:</p>
<ul>
<li><code>/venues</code> endpoint, the noun <code>venues</code> explains what the resource is all about:</p><ul><li><code>https://example.com/api/v1/venues</code></li>
<li><code>https://example.com/api/v1/get_all_venues</code></li>
</ul></li>
<li><code>venues</code> case, you can see that we used <code>/venues</code> to describe the collection, for example, <code>https://example.com/api/v1/venues/2</code>, where <code>id=2</code>, refers to a specific resource in the collection:<ul><li><code>https://example.com/api/v1/venues</code></li>
<li><code>https://example.com/api/v1/venue</code></li>
</ul></li>
<li><code>collection/resource/collection</code> structure, the endpoint URL starts with the collection name, followed by the resource name, and then another collection name if applicable.<p class="list-inset">For example, in the case of a <code>speaker</code> resource, which may have a collection of <code>papers</code>, the recommended endpoint URL would be something like <code>/speakers/2/papers</code>, where <code>speakers</code> is the collection name, <code>2</code> is the ID of a specific speaker resource, and <code>papers</code> is the collection of papers associated with this particular speaker:</p><ul><li><code>https://example.com/api/v1/speakers/2/papers</code></li>
<li><code>https://example.com/api/v1/speakers/2/papers/8/reviews</code></li>
</ul></li>
</ul>
<p><code>https://example.com/api/v1/speakers/2/papers/8/reviews</code> violates the recommended<a id="_idIndexMarker595"/> structure by including another collection name, <code>reviews</code>, after <code>papers</code>. This structure implies that <code>reviews</code> is a sub-collection of <code>papers</code>, which contradicts the rule of the <code>collection/resource/collection</code> pattern. Instead, we can treat them as separate resources with their own endpoints.</p>
<p>Take the following example:</p>
<ul>
<li><code>GET /api/v1/speakers/2/papers</code></li>
<li><code>GET /api/v1/papers/8/reviews</code></li>
</ul>
<p>By separating the endpoints, it becomes clearer that reviews are related to papers, rather than being nested within the <code>papers</code> collection.</p>
<p>Next, we will explore the structure of the payload and examine its role within this context.</p>
<h2 id="_idParaDest-160"><a id="_idTextAnchor193"/>Understanding the payload structure</h2>
<p>The <a id="_idIndexMarker596"/>payload contains the actual data that the API is designed to work with. In this section, you will understand the data format that is sent and received by an API. You will learn how the payload is structured, including the keys and values that are used to represent the data.</p>
<p>With this understanding of the payload structure, you will be able to work with more complex APIs and handle larger amounts of data. As discussed earlier, an API provides an interface for the exchange of data between web services. The data in question for interacting, communicating, or sharing is the payload.</p>
<p>The payload is the data of interest between various web applications that want to exchange information. Technically, this is the body of the HTTP request and response in client-server communication. In an API ecosystem, when a client makes a request, in the body of the request is the data, which essentially consists of two parts: the header/overhead and the payload.</p>
<p>The header is <a id="_idIndexMarker597"/>used to describe the source or destination of the data in transit. The payload comes in different flavors: JSON or XML. The payloads are recognizable with the use of curly braces, <code>{}</code>. We will focus on the JSON format of the payload in this book.</p>
<p>We are choosing JSON format because JSON is easy to read and understand, easy to parse in most programming languages, supports complex data structures, is platform-independent, and uses minimal syntax.</p>
<p>Let’s describe<a id="_idIndexMarker598"/> a typical structure of a payload with examples.</p>
<p>The following is a payload that a client sends to the server (the <em class="italic">API </em><em class="italic">request</em> payload):</p>
<pre class="source-code">POST /venues  HTTP/1.1Host: example.com
Accept: application/json
Content-Type: application/json
Content-Length: 10
{
"id":3
"name": "Conference Hall"
}</pre>
<p>Note the following in the preceding code:</p>
<ul>
<li>The payload is indicated with data within curly braces, and it explains the information we want to send to the <code>/venues</code> API endpoint using the <code>POST</code> HTTP method</li>
<li>The <code>"Content-Type: application/json"</code> request header describes the JSON data type of the request body</li>
<li>The client also describes the response format it expects from the server with <code>Accept: application/json</code><p class="list-inset">For a <a id="_idIndexMarker599"/>server-returned payload (<em class="italic">OK response</em> payload from the server), we have the following:</p><pre class="source-code">HTTP/1.1 200 OKContent-Type: application/jsonContent-Length: 10{"responseType": "OK","data": {"id":3"name": "Conference Hall"}}</pre></li>
</ul>
<p>Note the following in the preceding snippet:</p>
<ul>
<li><code>OK</code> and the content data within curly braces are the payloads.</li>
<li>You can see that the server complied with the <code>Content-Type: application/json</code> the client is expecting to receive.</li>
<li>The JSON payload is enclosed in curly braces, <code>{}</code>, and consists of two key-value pairs:<ul><li><code>"responseType": "Ok"</code>: This key-value pair indicates that the API successfully processed the request and returned a response. The <code>"responseType"</code> key has a value of <code>"Ok"</code>.</li>
<li><code>"data": { "id": 3, "name": "Conference Hall" }</code>: This key-value pair contains the actual data being returned by the API. The <code>"data"</code> key has a value of an object that contains information about the venue with ID <code>3</code>. In this case, the venue name is <code>"</code><code>Conference Hall"</code>.</li>
</ul><pre>HTTP/1.1 404 Not foundContent-Type: application/jsonContent-Length: 0{"responseType": "Failed","message": "Not found"}</pre><p class="list-inset">The payloads in the preceding code are <code>"responseType": "Failed"</code> and <code>"message": "</code><code>Not found"</code>.</pre></li>
</ul>
<p>Endpoints and payloads are essential parts of API development. You need to design API endpoints that are concise and intuitive to clearly communicate your intentions to developers who may want to interact with your API data services.</p>
<p>Now, we will deepen the knowledge stacks and glance through HTTP requests/responses. When building web applications, it’s essential to have a good understanding of how HTTP requests and responses work.</p>
<p>These are the building blocks of communication between clients and servers, and knowing how to work with them is crucial for building effective and efficient web applications.</p>
<h1 id="_idParaDest-161"><a id="_idTextAnchor194"/>Understanding HTTP requests/responses</h1>
<p>To successfully work with APIs, you need to have an understanding of HTTP requests/responses. So, let’s unmask the structure of HTTP requests and responses.</p>
<h2 id="_idParaDest-162"><a id="_idTextAnchor195"/>Request line</h2>
<p>Every HTTP request <a id="_idIndexMarker601"/>begins with the request line. This comprises the HTTP method, the requested resource, and the HTTP protocol version:</p>
<pre class="source-code">GET /api/v1/venues  HTTP/1.1</pre>
<p>In this instance, <code>GET</code> is the HTTP method, <code>/api/v1/venues</code> is the path to the resource requested, and <code>HTTP 1.1</code> is the protocol and version used.</p>
<p>Let’s dive deeper into HTTP methods to understand how developers use different HTTP methods to specify the type of action they want to perform when making requests to the web servers.</p>
<h3>HTTP methods</h3>
<p>HTTP methods <a id="_idIndexMarker602"/>indicate the action that the client intends to perform on the web server resource. Commonly used HTTP methods are the following:</p>
<ul>
<li><code>GET</code>: The<a id="_idIndexMarker603"/> client requests a resource on the web server</li>
<li><code>POST</code>: The<a id="_idIndexMarker604"/> client submits data to a resource on the web server</li>
<li><code>PUT</code>: The <a id="_idIndexMarker605"/>client replaces a resource on the web server</li>
<li><code>DELETE</code>: The<a id="_idIndexMarker606"/> client deletes a resource on the web server</li>
</ul>
<p>Let’s take a glance through the request headers.</p>
<h3>HTTP request headers</h3>
<p>HTTP headers play a critical role in facilitating communication between the client and server during an HTTP request or response. They allow both parties to include additional information alongside the primary data being transferred, such as metadata, authentication credentials, or caching directives.</p>
<p>Headers act as a<a id="_idIndexMarker607"/> placeholder for payloads and provide crucial context and metadata to both the client and server. For example, they can convey information about the content type, language, encoding, and size of the data being transferred.</p>
<p>Additionally, headers can provide details about the client’s capabilities and preferences, such as the type of browser being used or the preferred language for content delivery. HTTP request headers come immediately after the request line.</p>
<p>Common headers are the following:</p>
<ul>
<li><code>www.packtpub.com/</code><p class="list-inset">The <code>Host</code> header <a id="_idIndexMarker608"/>specifies the host of the server and indicates where the resource is requested from.</p></li>
<li><code>"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:107.0)      </code><code>Gecko/20100101 Firefox/107.0"</code><p class="list-inset">The <code>User-Agent</code> header<a id="_idIndexMarker609"/> tells the web server of the application that is making the HTTP request. It usually consists of the operating system (such as Windows, Mac, or Linux), version, and application vendor.</p></li>
<li><code>"text/html,application/xhtml+xml,application/xml;q=0.9,ima     </code><code>ge/avif,image/webp,*/*;q=0.8"</code><p class="list-inset">The <code>Accept</code> header<a id="_idIndexMarker610"/> tells the web server what type of content the client will accept as the response.</p></li>
<li><code>en-US,en;q=0.5</code><p class="list-inset">The <code>Accept-Language</code> header<a id="_idIndexMarker611"/> indicates the language.</p></li>
<li><code>text/html; charset=UTF-8</code><p class="list-inset">The <code>Content-type</code> header<a id="_idIndexMarker612"/> indicates the type of content being transmitted in the request body.</p></li>
</ul>
<p>Next, we will examine the request body.</p>
<h3>HTTP request body</h3>
<p>In HTTP, the <a id="_idIndexMarker613"/>request body refers to the additional data that is sent along with an HTTP request message, typically in the form of a payload. Unlike HTTP headers, which provide metadata about the request or response, the request body contains the actual data that the client is sending to the server. The request body can contain various types of data, including form data, JSON, XML, binary data, or text.</p>
<p>For example, when submitting a web form, the data entered by the user is typically sent as part of the request body. Similarly, when uploading a file or sending an API request, the data being transmitted is often included in the request body. The format and structure of the request body depend on the content type specified in the request headers.</p>
<p>For instance, if the content type is set to <code>application/json</code>, the request body must be a valid JSON object. If the content type is <code>multipart/form-data</code>, the request body may include multiple parts, each containing different types of data.</p>
<p>The following shows an HTTP request that uses the <code>POST</code> method to submit data to a web server:</p>
<pre class="source-code">POST /users HTTP/1.1Host: example.com
{
"key":"value",
"array":["value3","value4"]
}</pre>
<p>The request includes a request body in JSON format, which contains a key-value pair and an array. The key has a value of <code>"value"</code>, and the array contains two string values, <code>"value3"</code> and <code>"value4"</code>.</p>
<p>The<a id="_idIndexMarker614"/> following shows an HTTP request that uses the <code>PUT</code> method to update data on a web server:</p>
<pre class="source-code">PUT /authors/1 HTTP/1.1Host:example.com
Content-type: text/json
{"key":"value"}</pre>
<p>The request includes a request body in JSON format, which contains a key-value pair. The key has a value of <code>"value"</code>, and this data is intended to update the resource at the specified endpoint.</p>
<p>Next, we will consider HTTP responses. HTTP responses are the server’s way of communicating with the client in response to an HTTP request.</p>
<h2 id="_idParaDest-163"><a id="_idTextAnchor196"/>HTTP responses</h2>
<p>Understanding the<a id="_idIndexMarker615"/> various HTTP status codes and the information included in HTTP responses is essential for building robust and effective web applications. After the web server has processed an HTTP request, it is expected to send an HTTP response to the client.</p>
<p>The initial line of the response contains the status, which indicates whether the request was successful or unsuccessful due to an error. This status line provides critical feedback to the client about the outcome of the request:</p>
<pre class="source-code">HTTP/1.1 200 OK</pre>
<p>The HTTP response begins with the HTTP protocol version, followed by the status code, and a reason message. The reason message is a textual representation of the status code. In the upcoming <em class="italic">Understanding HTTP status codes</em> section, we will delve into the topic of status codes in detail.</p>
<p>We will now begin discussing the response headers.</p>
<h3>HTTP response headers</h3>
<p>In HTTP, response headers <a id="_idIndexMarker616"/>provide additional information about the response message sent by the server. While the status code in the initial line of an HTTP response provides essential information about the outcome of the request, response headers can provide additional metadata about the response, such as the content type, cache settings, and server type.</p>
<p>Response headers are typically used to provide the client with information that can help optimize the rendering and processing of the response, such as specifying the character encoding or content length. Response headers can also be used to control the behavior of the client, such as setting caching parameters or <a id="_idIndexMarker617"/>enabling <strong class="bold">cross-origin resource sharing</strong> (<strong class="bold">CORS</strong>) for API requests.</p>
<p>HTTP response headers are sent by the server in the response message, immediately following the status line. The headers consist of one or more lines, each with a header field name and a value, separated by a colon. Some common response headers include <code>Content-Type</code>, <code>Content-Length</code>, <code>Cache-Control</code>, <code>Server</code>, and <code>Set-Cookie</code>.</p>
<p>The following is an example of an HTTP response header:</p>
<pre class="source-code">Date: Sun, 27 Nov 2022 02:38:57 GMTServer: Cloudflare
Content-Type: text/html</pre>
<p>Considering the preceding code block, we have the following:</p>
<ul>
<li>The <code>Date</code> header specifies the date and time at which the HTTP response was generated</li>
<li>The <code>Server</code> header describes the web server software used to generate the response</li>
<li>The <code>Content-Type</code> header describes the media type of the resource returned: in this case, HTML</li>
</ul>
<p>Next, we will discuss the HTTP response body.</p>
<h3>HTTP response body</h3>
<p>The response body<a id="_idIndexMarker618"/> refers to the data sent by the server in response to an HTTP request. While the response headers provide metadata about the response, the response body contains the actual data that the client requested, such as HTML, JSON, XML, or binary data.</p>
<p>The structure and content of the response body depend on the nature of the request and the format of the requested data. For example, a request for a web page might receive an HTML response body containing the markup and content of the page, while a request for data from an API might receive a JSON response body containing the requested data.</p>
<p>In HTTP, the response body may contain content in certain situations, such as when the server responds with a status code of <code>200</code>, which indicates that the request was successful and that the server is returning content. In other cases, when the server responds with a status code of <code>204</code>, it indicates that the request was successful but that there is no content to return, so the response body may be empty:</p>
<pre class="source-code">HTTP/2 200 OKDate: Sun, 27 Nov 2022 02:38:57 GMT
Server: Cloudflare
Content-Type: text/html
&lt;html&gt;
    &lt;head&gt;&lt;title&gt;Test&lt;/title&gt;&lt;/head&gt;
    &lt;body&gt;Test HTML page.&lt;/body&gt;
&lt;/html&gt;</pre>
<p>Having discussed HTTP requests and responses, we will now begin discussing the various commonly used HTTP status codes.</p>
<h1 id="_idParaDest-164"><a id="_idTextAnchor197"/>Understanding HTTP status codes</h1>
<p>HTTP status codes <a id="_idIndexMarker619"/>are three-digit numbers sent by a server in response to an HTTP request. These codes provide feedback to the client about the outcome of the request and help identify any issues that may have occurred during the transaction. The first digit of an HTTP status code indicates the category of the responses, which could be <code>Informational</code>, <code>Successful</code>, <code>Redirection</code>, <code>Client Error</code>, or <code>Server Error</code>.</p>
<p>The common status<a id="_idIndexMarker620"/> codes you’ll encounter for each category are listed as follows:</p>
<p><code>1XX Informational</code></p>
<table class="No-Table-Style" id="table001-3">
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold">Status Code</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Description</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Reason</strong></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>100</code></p>
</td>
<td class="No-Table-Style">
<p>This code indicates an interim response from the web server informing the client to continue the request or ignore the response if the request has already been processed</p>
</td>
<td class="No-Table-Style">
<p>Continue</p>
</td>
</tr>
</tbody>
</table>
<p><code>2XX Successful</code></p>
<table class="No-Table-Style _idGenTablePara-1" id="table002">
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold">Status Code</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Description</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Reason</strong></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>200</code></p>
</td>
<td class="No-Table-Style">
<p>This code indicates the server successfully processed the request.</p>
</td>
<td class="No-Table-Style">
<p><code>OK</code></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>201</code></p>
</td>
<td class="No-Table-Style">
<p>This code indicates the server successfully processed the request and a resource was created.</p>
</td>
<td class="No-Table-Style">
<p><code>Created</code></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>202</code></p>
</td>
<td class="No-Table-Style">
<p>This code indicates the request has been received but the processing has not yet been completed.</p>
</td>
<td class="No-Table-Style">
<p><code>Accepted</code></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>204</code></p>
</td>
<td class="No-Table-Style">
<p>The code indicates the server successfully processed the request but is not returning any content.</p>
</td>
<td class="No-Table-Style">
<p><code>No content</code></p>
</td>
</tr>
</tbody>
</table>
<p><code>3XX Redirection</code></p>
<table class="No-Table-Style _idGenTablePara-1" id="table003">
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold">Status Code</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Description</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Reason</strong></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>301</code></p>
</td>
<td class="No-Table-Style">
<p>This code indicates that the request and all future requests should be sent to the new location in the response header</p>
</td>
<td class="No-Table-Style">
<p><code>Moved Permanently</code></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>302</code></p>
</td>
<td class="No-Table-Style">
<p>This code indicates the request should be sent temporarily to the new location in the response header</p>
</td>
<td class="No-Table-Style">
<p><code>Found</code></p>
</td>
</tr>
</tbody>
</table>
<p><code>4XX </code><code>Client Error</code></p>
<table class="No-Table-Style _idGenTablePara-1" id="table004">
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold">Status Code</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Description</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Reason</strong></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>400</code></p>
</td>
<td class="No-Table-Style">
<p>This code indicates that the server cannot process the request due to a perceived client error.</p>
</td>
<td class="No-Table-Style">
<p><code>Bad Request</code></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>401</code></p>
</td>
<td class="No-Table-Style">
<p>This code indicates that the client making the request is unauthorized and should be authenticated.</p>
</td>
<td class="No-Table-Style">
<p><code>Unauthorized</code></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>403</code></p>
</td>
<td class="No-Table-Style">
<p>This code indicates that the client making the request does not have the right to access the content; they are unauthorized and should obtain the right to access the resource.</p>
</td>
<td class="No-Table-Style">
<p><code>Forbidden</code></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>404</code></p>
</td>
<td class="No-Table-Style">
<p>This code indicates that the web server did not find the requested resource.</p>
</td>
<td class="No-Table-Style">
<p><code>Not Found</code></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>405</code></p>
</td>
<td class="No-Table-Style">
<p>This code indicates that the web server knows the method but the targeted resource does not support the HTTP method used.</p>
</td>
<td class="No-Table-Style">
<p><code>Method </code><code>Not Allowed</code></p>
</td>
</tr>
</tbody>
</table>
<p><code>5XX </code><code>Server Error</code></p>
<table class="No-Table-Style _idGenTablePara-1" id="table005">
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold">Status Code</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Description</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Reason</strong></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>500</code></p>
</td>
<td class="No-Table-Style">
<p>This code indicates that the web server has encountered an unexpected error while processing the request.</p>
</td>
<td class="No-Table-Style">
<p><code>Internal </code><code>Server Error</code></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>502</code></p>
</td>
<td class="No-Table-Style">
<p>This code indicates that the web server, while acting as a gateway to get a response, received an invalid response from the application server.</p>
</td>
<td class="No-Table-Style">
<p><code>Bad Gateway</code></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>503</code></p>
</td>
<td class="No-Table-Style">
<p>This code indicates that the web server is unavailable to process the request.</p>
</td>
<td class="No-Table-Style">
<p><code>Service Unavailable</code></p>
</td>
</tr>
</tbody>
</table>
<p>Before we explore <a id="_idIndexMarker621"/>how to implement a REST API in Flask web applications, it’s important to grasp the underlying principles of RESTful API design. By understanding these fundamentals, we can ensure that our API is designed in a way that is intuitive, user-friendly, and efficient. So, let’s take a closer look at the key principles that underpin RESTful API design.</p>
<h1 id="_idParaDest-165"><a id="_idTextAnchor198"/>REST API design principles</h1>
<p>REST API, or RESTful API, describes<a id="_idIndexMarker622"/> an API that conforms to the REST architectural style using an HTTP-based interface for network communication. An API in its simplest form defines a set of rules that disparate systems or applications need to conform to in order to exchange data.</p>
<p>Dr. Roy Fielding, in the year 2000, presented a dissertation (<a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm">https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm</a>) that described a novel design approach that API designers are expected to follow in building applications that can stand the test of time in addition to being secure. In order to develop a RESTful system, there are architectural constraints that are worth keeping in mind.</p>
<p>We will examine those REST principles, such as <em class="italic">client-server</em>, <em class="italic">statelessness</em>, <em class="italic">caching</em>, <em class="italic">uniform interface</em>, <em class="italic">layered system</em>, and <em class="italic">code on demand</em>, to conform to a REST style guide.</p>
<h2 id="_idParaDest-166"><a id="_idTextAnchor199"/>Client-server</h2>
<p>The <a id="_idIndexMarker623"/>REST API architecture encourages client and server communication. The client sends a network request to the server, while the server can only send a response back to the client. RESTful APIs ensure all communications start from clients, who then wait for a response from the server.</p>
<p>RESTful APIs enforce the separation of concerns between the client applications and server, thus making the interaction smooth and independent. Owing to the separation of concerns, web<a id="_idIndexMarker624"/> application designs are not tightly coupled as the client and server can scale without inadvertently impacting the overall application architecture.</p>
<p class="callout-heading">Note</p>
<p class="callout">Separation of concerns is a design principle that aims to separate a system into distinct, independent parts, with each part responsible for a specific task or functionality. This design principle is commonly applied in software engineering and programming, including in the design of REST APIs.</p>
<h2 id="_idParaDest-167"><a id="_idTextAnchor200"/>Statelessness</h2>
<p>Conforming<a id="_idIndexMarker625"/> to REST API design constraints requires all network requests to be stateless. Statelessness means a server is not expected to remember past network requests. Technically, the statelessness of a network request encourages independent interaction between the client and server.</p>
<p>Every request from a client to a server is expected to contain all of the important information required to understand and fulfill the request. Statelessness invariably improves performance as the server does not need to store or remember previous requests. In addition, with a stateless state in RESTful application design, the architecture is simple to set up, scalable, and reliable.</p>
<h2 id="_idParaDest-168"><a id="_idTextAnchor201"/>Caching</h2>
<p>RESTful APIs are <a id="_idIndexMarker626"/>designed with caching in mind. Caching is the process of storing frequently used data in a temporary location in order to reduce the time and resources required to access it. The caching principle in REST API ensures that network information contained within a response to a request be declared implicitly or explicitly as cacheable or non-cacheable.</p>
<p>For instance, if a response is cacheable, the client will reuse the cached response data for similar subsequent requests. Caching improves the efficiency of server resources and reduces bandwidth usage while decreasing the loading time of a site page.</p>
<h2 id="_idParaDest-169"><a id="_idTextAnchor202"/>Uniform interface</h2>
<p>A <a id="_idIndexMarker627"/>uniform interface is another design constraint that REST API designers need to implement. The REST API architectural style states that the REST API should have a single communication protocol and a standardized data format. Regardless of the system’s environment, applications and servers, a uniform interface facilitates smooth interaction.</p>
<p>A uniform interface encourages the ease of evolvability of each system component and provides a common framework for any client application to communicate with a REST API.</p>
<p>REST APIs adopt HTTP as a communication protocol for client-server interaction. With HTTP, the client sends a request in a specific format, such as JSON or XML. Let’s take a look at a sample request:</p>
<pre class="source-code">GET https://localhost:5000/api/v1/venues</pre>
<p>This REST API request contains two major components – <code>GET</code> and the URL:</p>
<ul>
<li><code>GET</code> is one of<a id="_idIndexMarker628"/> the HTTP methods. The <code>GET</code> method specifies the action the client wants to make on the server resource. There are four commonly used HTTP requests a client uses to make a request:<ul><li><code>GET</code>: To retrieve a resource</li>
<li><code>POST</code>: To create a new resource</li>
<li><code>PUT</code>/<code>PATCH</code>: To update or edit an existing resource</li>
<li><code>DELETE</code>: To delete a resource</li>
</ul></li>
<li>The URL part <a id="_idIndexMarker629"/>contains the uniform resource identifier that specifies the resource of interest. In this case, we are interested in the <code>venues</code> resource. So, we issued an HTTP <code>GET</code> request to look up the location of that resource.</li>
</ul>
<p>Furthermore, the URL is also sometimes called an endpoint. The endpoint represents the location where the API actually interacts with the client, the point at which data exchange takes place.</p>
<p>The client-server interaction proceeds with the host receiving and validating the <code>GET</code> request. The response data is returned from the target resource (<code>/api/v1/venues</code>). The returned data format is often in the form of JSON or the expected response format as specified by the client. JSON allows us to have standardized structured data to display the contents of the target resource.</p>
<h2 id="_idParaDest-170"><a id="_idTextAnchor203"/>Layered system</h2>
<p>Modern <a id="_idIndexMarker630"/>web applications are composed of layered architectures. The client-server system could have multiple layers of servers/services each with its own responsibility, such as load balancing, security, and caching layers. The REST API design principle encourages an implementation in which the layers of systems that may exist do not alter the natural behaviors of client-server interaction.</p>
<p>With this constraint, any change or modification in the inner systems/servers will have zero effect on the format of the HTTP-based request and response model. A layered system enforces a clear separation of concerns and improves scalability as the client and server are highly independent and can grow at scale.</p>
<h2 id="_idParaDest-171"><a id="_idTextAnchor204"/>Code on demand (optional)</h2>
<p>Code on demand <a id="_idIndexMarker631"/>is an optional constraint in RESTful API design, which allows the server to send executable code to the client in response to a request. This code can be in the form of scripts, applets, or other executable files, and can be used to extend the functionality of the client.</p>
<p>The code-on-demand constraint is optional because it is not always necessary or desirable for an API to provide executable code to clients. In many cases, RESTful APIs simply provide data or resources that can be consumed by client applications without the need for executable code.</p>
<p>However, in some cases, code on demand can be useful for providing additional functionality to clients, such as data processing, filtering, or visualization. For example, a RESTful API for data analysis could provide executable code to the client for performing complex calculations or generating visualizations based on the data.</p>
<p>The REST API can send code such as JavaScript code to the client application for execution. This optional feature of code on demand allows API designers to further customize the API’s functionality with the ability to increase the flexibility of the API to deliver required business solutions.</p>
<p>The previously mentioned design principles of REST API ensure developers are able to build solutions<a id="_idIndexMarker632"/> based on architectural styles that are widely acceptable in the software development industry.</p>
<p>Lastly, Dr. Roy Fielding once summarized the essence of the RESTful API design principle and the overall goal in software development as follows:</p>
<p class="author-quote">“REST is software design on the scale of decades: every detail is intended to promote software longevity and independent evolution.</p>
<p class="author-quote">Many of the constraints are directly opposed to short-term efficiency. Unfortunately, people are fairly good at short-term design, and usually awful at long-term design. Most don’t think they need to design past the current release. There are more than a few software methodologies that portray any long-term thinking as wrong-headed, ivory tower design (which it can be if it isn’t motivated by real requirements).”</p>
<p class="author-quote"><a href="https://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven">https://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven</a></p>
<p>Next, we will <a id="_idIndexMarker633"/>delve into the practical implementation of a REST API within a Flask web application.</p>
<p>Learning how to implement a REST API in a Flask application is a valuable skill for developers who want to build web applications that can be accessed and consumed by other applications or services.</p>
<h1 id="_idParaDest-172"><a id="_idTextAnchor205"/>Implementing a REST API in a Flask application</h1>
<p>Flask, as a<a id="_idIndexMarker634"/> popular Python web framework, provides developers with a flexible and lightweight solution for <a id="_idIndexMarker635"/>building web applications. With Flask, you can easily create and manage RESTful APIs. The process of implementing a REST API in a Flask application is simple.</p>
<p>Implementing a REST API in a Flask application involves defining API endpoints, request handlers, and data models, and possibly connecting to a database. In this section, we are going to design a REST API service using Flask that a React frontend application can consume.</p>
<p>We will follow a simple process of defining the resources expected in the <em class="italic">Bizza</em> application, following<a id="_idIndexMarker636"/> which we will define the URLs (endpoints) that would be used to access the resources. In addition, we will use Flask’s routing system to map each endpoint to a specific function in the application.</p>
<p>Each function<a id="_idIndexMarker637"/> should handle the HTTP request, interact with the database (if necessary), and return an appropriate response. Finally, we will implement data serialization to serialize and deserialize data between Python objects and JSON. This ensures that the API can establish communication with clients using a standardized format.</p>
<p>Next, we will begin the discussion of implementing a REST API with the concept of defining the application resources.</p>
<h2 id="_idParaDest-173"><a id="_idTextAnchor206"/>Defining the application resources</h2>
<p>We will <a id="_idIndexMarker638"/>start by defining the resources needed to create a conference web application that can handle all aspects of an event, from scheduling and registration to sponsorship management. The following resources are thus defined:</p>
<ul>
<li><code>Attendees</code>: The people who are attending the conference</li>
<li><code>Speakers</code>: The people who are giving presentations at the conference</li>
<li><code>Schedules</code>: The schedules of the conference, including the start and end times of each session</li>
<li><code>Presentations</code>: The speakers’ areas of interest and subject matter for the conference</li>
<li><code>Users</code>: The users of the event management system, including attendees, speakers, and organizers</li>
<li><code>Userextras</code>: Additional information about the users attending the event, such as dietary preferences or accessibility needs</li>
<li><code>Venues</code>: The venues where the event or conference is being held, including information about the location, capacity, and amenities</li>
<li><code>Sessions</code>: The individual sessions or talks within the conference, including information about the speaker, topic, and time</li>
<li><code>Sponsors</code>: The organizations or companies sponsoring the event, including information about their level of sponsorship, logo, and contact details</li>
</ul>
<p>Next, we will define the<a id="_idIndexMarker639"/> API endpoints. In order to implement a functional REST API, it is necessary to define the API endpoints clearly.</p>
<h2 id="_idParaDest-174"><a id="_idTextAnchor207"/>Defining the API endpoints</h2>
<p>Defining <a id="_idIndexMarker640"/>the API endpoints is a crucial step in implementing a REST API. These endpoints allow you to perform various operations on the resources of the conference web application, such as creating, reading, updating, and deleting records. We are defining the endpoints based on the resources specified in the preceding section.</p>
<p>Now, the specific endpoints and HTTP methods used are listed as follows:</p>
<ul>
<li><code>Users</code>:<ul><li><code>GET</code> <code>/users</code>: Retrieves a list of all users</li>
<li><code>GET</code> <code>/users/{id}</code>: Retrieves information about a specific user</li>
<li><code>POST</code> <code>/users</code>: Creates a new user</li>
<li><code>PUT</code> <code>/users/{id}</code>: Updates information about a specific user</li>
<li><code>DELETE</code> <code>/users/{id}</code>: Deletes a specific user</li>
</ul></li>
<li><code>Userextras</code>:<ul><li><code>GET</code> <code>/userextras</code>: Retrieves a list of all <code>userextras</code></li>
<li><code>GET</code> <code>/userextras/{id}</code>: Retrieves information about a specific <code>userextra</code></li>
<li><code>POST</code> <code>/userextras</code>: Creates a new <code>userextra</code></li>
<li><code>PUT</code> <code>/userextras/{id}</code>: Updates information about a specific <code>userextra</code></li>
<li><code>DELETE</code> <code>/userextras/{id}</code>: Deletes a specific <code>userextra</code></li>
</ul></li>
<li><code>Attendees</code>:<ul><li><code>GET</code> <code>/attendees</code>: Retrieves a list of all attendees</li>
<li><code>GET</code> <code>/attendees/{id}</code>: Retrieves information about a specific attendee</li>
<li><code>POST</code> <code>/attendees</code>: Creates a new attendee</li>
<li><code>PUT</code> <code>/attendees/{id}</code>: Updates information about a specific attendee</li>
<li><code>DELETE</code> <code>/attendees/{id}</code>: Deletes a specific attendee</li>
</ul></li>
<li><code>Speakers</code>:<ul><li><code>GET</code> <code>/speakers</code>: Retrieves a<a id="_idIndexMarker641"/> list of all speakers</li>
<li><code>GET</code> <code>/speakers/{id}</code>: Retrieves information about a specific speaker</li>
<li><code>POST</code> <code>/speakers</code>: Creates a new speaker</li>
<li><code>PUT</code> <code>/speakers/{id}</code>: Updates information about a specific speaker</li>
<li><code>DELETE</code> <code>/speakers/{id}</code>: Deletes a specific speaker</li>
</ul></li>
<li><code>Schedules</code>:<ul><li><code>GET</code> <code>/schedules</code>: Retrieves a list of all schedules</li>
<li><code>GET</code> <code>/schedules/{id}</code>: Retrieves information about a specific schedule</li>
<li><code>POST</code> <code>/schedules</code>: Creates a new schedule</li>
<li><code>PUT</code> <code>/schedules/{id}</code>: Updates information about a specific schedule</li>
<li><code>DELETE</code> <code>/schedules/{id}</code>: Deletes a specific schedule</li>
</ul></li>
<li><code>Presentations</code>:<ul><li><code>GET</code> <code>/presentations</code>: Retrieves a list of all presentations</li>
<li><code>GET</code> <code>/presentations/{id}</code>: Retrieves information about a specific presentation</li>
<li><code>POST</code> <code>/presentations</code>: Creates a new presentation</li>
<li><code>PUT</code> <code>/presentations/{id}</code>: Updates information about a specific presentation</li>
<li><code>DELETE</code> <code>/presentations/{id}</code>: Deletes a specific presentation</li>
</ul></li>
<li><code>Venues</code>:<ul><li><code>GET</code> <code>/venues</code>: Retrieves<a id="_idIndexMarker642"/> a list of all venues</li>
<li><code>GET</code> <code>/venues/{id}</code>: Retrieves information about a specific venue</li>
<li><code>POST</code> <code>/venues</code>: Creates a new venue</li>
<li><code>PUT</code> <code>/venues/{id}</code>: Updates information about a specific venue</li>
<li><code>DELETE</code> <code>/venues/{id}</code>: Deletes a specific venue</li>
</ul></li>
<li><code>Sessions</code>:<ul><li><code>GET</code> <code>/sessions</code>: Retrieves a list of all sessions</li>
<li><code>GET</code> <code>/sessions/{id}</code>: Retrieves information about a specific session</li>
<li><code>POST</code> <code>/sessions</code>: Creates a new session</li>
<li><code>PUT</code> <code>/sessions/{id}</code>: Updates information about a specific session</li>
<li><code>DELETE</code> <code>/sessions/{id}</code>: Deletes a specific session</li>
</ul></li>
<li><code>Sponsors</code>:<ul><li><code>GET</code> <code>/sponsors</code>: Retrieves a list of all sponsors</li>
<li><code>GET</code> <code>/sponsors/{id}</code>: Retrieves information about a specific sponsor</li>
<li><code>POST</code> <code>/sponsors</code>: Creates a new sponsor</li>
<li><code>PUT</code> <code>/sponsors/{id}</code>: Updates information about a specific sponsor</li>
<li><code>DELETE</code> <code>/sponsors/{id}</code>: Deletes a specific sponsor</li>
</ul></li>
</ul>
<p>Once the API endpoints <a id="_idIndexMarker643"/>have been defined, the next step is to implement them in the Flask application.</p>
<p>Let’s start digging!</p>
<h2 id="_idParaDest-175"><a id="_idTextAnchor208"/>Implementing the API endpoints</h2>
<p>Implementing the API endpoints <a id="_idIndexMarker644"/>is a critical step in developing a RESTful API. This is where all the juicy bits come together to form the heart and soul of your REST API. API endpoints define the functionality and behavior of the API, specifying the methods that can be used to access the API’s resources.</p>
<p>In a Flask application, implementing the API endpoints involves mapping the URLs to the relevant functions, defining the HTTP methods, and writing the Flask view functions that will handle the requests and generate responses. In addition, it is necessary to specify the request and response formats to be used to communicate with the API.</p>
<p>In this section, we will explore the process of implementing API endpoints in a Flask application. Let’s start by creating a simple endpoint that returns a text-based welcome message from the API server.</p>
<p>In the backend development environment, inside <code>bizza/backend/</code>, activate the virtual environment in the terminal:</p>
<ul>
<li><strong class="bold">Use the following </strong><strong class="bold">on Windows</strong>:<pre class="source-code"><strong class="bold">venv/Scripts/activate</strong></pre></li>
<li><strong class="bold">Use the following </strong><strong class="bold">on Mac/Linux</strong>:<pre class="source-code"><strong class="bold">source ./venv/bin/activate</strong></pre></li>
</ul>
<p>If you are having issues activating your virtual environment, check <em class="italic">Setting up the development environment with Flask</em> in <a href="B18554_01.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>.</p>
<p>Now, update <code>app.py</code> with the following code:</p>
<pre class="source-code">from flask import Flaskapp = Flask(__name__)
@app.route("/")
def index():
    return "Welcome to Bizza REST API Server"
if __name__ == "__main__":
    app.run()</pre>
<p>This is <a id="_idIndexMarker645"/>what is happening in the preceding code snippet:</p>
<ul>
<li>We import the <code>Flask</code> class from the <code>flask</code> package.</li>
<li>We then create an instance of the <code>Flask</code> class and name it <code>app</code>. Then, we pass in a <code>__name__</code> variable as an argument that references the current module name. This is needed for the internal working of Flask for path discovery.</li>
<li>Use a <code>@route()</code> Flask decorator to tell Flask to implement the <code>index()</code> view function when a user accesses the URL <code>"/"</code> (index URL). A decorator in Python is simply a way of adding extra functionality to functions without explicitly altering the method behavior.</li>
<li>This view function returns the message <code>Welcome to Bizza REST API server</code> to the browser. So, essentially, the decorator is capable of modifying the <code>index()</code> view function to return a value in the form of an HTTP response, which can then be displayed by the client using the desired data presentation format. In this case, <code>text/html</code> was returned.</li>
<li>If the conditional part of the code becomes true, that is, <code>app.py</code> is the main program, then it runs the module. In this way, Python prevents the accidental or unintentional running of an imported module.</li>
</ul>
<p>We can test the endpoint with <code>curl</code> by entering the following command:</p>
<pre class="console">curl http://localhost:5000/</pre>
<p>We get the<a id="_idIndexMarker646"/> following output:</p>
<div><div><img alt="Figure 9.1 – Screenshot showing ﻿the HTTP response from localhost" src="img/Figure_9.1_B18554.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1 – Screenshot showing the HTTP response from localhost</p>
<h2 id="_idParaDest-176"><a id="_idTextAnchor209"/>JSONifying response data</h2>
<p>Jsonifying <a id="_idIndexMarker647"/>response data refers to the process of converting a Python data structure into a JSON string that can be returned as a response from an API endpoint. JSON is a lightweight data-interchange format that is easy to read and write, making it a popular choice for web APIs.</p>
<p>By jsonifying response data, the data can be easily transmitted over HTTP and used by other systems and programming languages. This is because JSON is a language-independent data format that can be parsed and generated by many programming languages.</p>
<p>JSON also supports complex data structures such as arrays and objects, making it a flexible format for transferring data between systems. In a Flask application, the <em class="italic">jsonify</em> function can be used to convert Python data structures into JSON format.</p>
<p>This function takes the data as an argument and returns a Flask response object with the JSON data and the appropriate <code>Content-Type</code> header, indicating that the data is in JSON format. By returning JSON-formatted responses from API endpoints, clients can easily consume and use the data in their applications.</p>
<p>You can see that <code>content-type</code> in the preceding code is <code>text/html</code>; now, let’s return a serialized JSON format since moving forward, that will be the preferred data exchange format:</p>
<pre class="source-code">from flask import Flask,jsonifyapp = Flask(__name__)
@app.route("/")
def index():
    return "Welcome to Bizza REST API Server"
@app.route("/api/v1/venues")
def venues():
    return jsonify({"id":1,"name":"Auditorium A"}), 404
if __name__ == "__main__":
    app.run()</pre>
<p>In the preceding code, we added another endpoint and decorated it with <code>@route("/api/v1/venues")</code>. So, we are telling Flask to implement the functionality of the view function attached to the decorator.</p>
<p>In order <a id="_idIndexMarker648"/>to retrieve the JSON format response, we invoke <code>jsonify()</code> in the <code>Flask</code> package using <code>from flask import Flask, jsonify</code> and pass Python dictionary data into it, which then gets converted into a serializable JSON format.</p>
<p>We can test the endpoint with <code>curl</code> by entering the following command:</p>
<pre class="console">curl.exe http://localhost:5000/api/v1/venues</pre>
<p>We get the following output:</p>
<div><div><img alt="Figure 9.2 – Screenshot showing ﻿the venues endpoint﻿ being tested" src="img/Figure_9.2_B18554.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.2 – Screenshot showing the venues endpoint being tested</p>
<p>Next, we will begin to enhance the endpoint functionality by incorporating query parameters.</p>
<h2 id="_idParaDest-177"><a id="_idTextAnchor210"/>Adding query parameters to endpoints</h2>
<p>Query parameters <a id="_idIndexMarker649"/>are additional information we can pass along with the request to the server to allow some processing of the request. With query parameters, we are able to present dynamic content to application users.</p>
<p>For instance, this is an ordinary URL endpoint without a query parameter:</p>
<pre class="source-code">http://localhost:5000/</pre>
<p>Now, you can add a query parameter to the URL by adding a <code>?</code> at the end of the URL followed by a key-value pair. Let’s add a query parameter to the preceding URL:</p>
<pre class="source-code">http://localhost:5000/?firstname=Jim&amp;lastname=Hunt</pre>
<p>Let’s implement a simple query parameter in a Flask application for a better illustration.</p>
<p>Add the following snippet to the <code>app.py</code> file:</p>
<pre class="source-code">Import flask, jsonify, request@app.route("/api/v1/speakers/")
def speakers():
    firstname = request.args.get("firstname")
    lastname = request.args.get("lastname")
    if firstname is not None and lastname is not None:
        return jsonify(message="The speaker's fullname :" +
            firstname+" "+lastname)
    else:
        return jsonify(message="No query parameters in the
            url")</pre>
<p>Note the<a id="_idIndexMarker650"/> following in the preceding code:</p>
<ul>
<li>We are creating a new endpoint with the URL <code>/</code><code>api/v1/speakers/</code> resource.</li>
<li>We are using a <code>request</code> object from the Flask package.</li>
<li>We are then defining a view function, <code>speakers()</code>, to handle requests to the endpoint.</li>
<li>The <code>request</code> object is used to allow a client to send data to the server and other endpoint request operations. We have <code>request.args</code> for handling URL data, <code>request.form</code> for extracting form data, and <code>request.json</code> for handling JSON data. Here, we will use <code>request.args</code> to extract key-value pairs in the URL to process URL data at the server end.</li>
<li>The <code>firstname</code> and <code>lastname</code> variables store the data values extracted from the URL.</li>
<li>Then, we perform a simple check to find out whether query parameters are present in the URL. In the production code, you are expected to perform a comprehensive check on what the users are sending to the server. This is for demonstration purposes. We return JSONified data if query parameters are present. Otherwise, the message <code>"No query parameters in the url"</code> is sent as output.</li>
</ul>
<p>Testing the endpoint with query parameters, for instance, <code>http://localhost:5000/api/v1/speakers?firstname=Jim&amp;lastname=Hunt</code>, provides the following output:</p>
<div><div><img alt="Figure 9.3 – Screenshot testing with ﻿a query parameter" src="img/Figure_9.3_B18554.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.3 – Screenshot testing with a query parameter</p>
<p>Testing the <code>http://localhost:5000/api/v1/speakers?</code> endpoint without query <a id="_idIndexMarker651"/>parameters provides the following output:</p>
<div><div><img alt="Figure 9.4 – Screenshot testing without ﻿a query parameter" src="img/Figure_9.4_B18554.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.4 – Screenshot testing without a query parameter</p>
<p>Now, let’s check how you can pass variables to an endpoint. This is also useful in dynamically modifying the server-side processing in your application.</p>
<h2 id="_idParaDest-178"><a id="_idTextAnchor211"/>Passing variables to an endpoint</h2>
<p>One of the <a id="_idIndexMarker652"/>ways to provide input to an endpoint is by passing variables to the URL path in the API endpoint, allowing for the provision of specific information. This technique is commonly used when the input is required to identify a specific resource or object, such as an ID number or username.</p>
<p>In a Flask application, variables can be included in the URL path by enclosing them in angled brackets (<code>&lt;&gt;</code>) in the endpoint URL definition. For example, to define an endpoint that takes a speaker ID as input, the URL could be defined as follows:</p>
<pre class="source-code">from flask import Flask, jsonifyapp = Flask(__name__)
@app.route('/api/v1/speakers/&lt;int:speaker_id&gt;')
def get_speaker(speaker_id):
    # Use the speaker ID to fetch the appropriate speaker
      data
    # ...
    # Return the speaker data as a JSON response
    return jsonify(speaker_data)
if __name__ == '__main__':
    app.run()</pre>
<p>In the<a id="_idIndexMarker653"/> preceding example, the <code>get_speaker</code> function takes a <code>speaker_id </code>argument, which corresponds to the variable included in the URL path. When a request is made to the <code>/speakers/123</code> endpoint, the <code>get_speaker</code> function is called with <code>speaker_id=123</code>.</p>
<p>Passing variables to an endpoint is a useful technique for providing input to an API endpoint and is commonly used in RESTful API design.</p>
<p>Next, we will take our REST API in Flask application a step further. We will perform CRUD operations<a id="_idIndexMarker654"/> on a database using PostgreSQL.</p>
<h1 id="_idParaDest-179"><a id="_idTextAnchor212"/>API interaction with a database via CRUD operations</h1>
<p>In <a id="_idIndexMarker655"/>most web application projects, it is common to work with databases for the purpose of persistent data storage. You <a id="_idIndexMarker656"/>won’t be hardcoding plain text into your REST API, unless you are that person who tries to boil the ocean.</p>
<p><code>GET</code>, <code>POST</code>, <code>PUT/PATCH</code>, and <code>DELETE</code> – which further describes and facilitates the interaction with the database.</p>
<p>In a full stack web application, you expect your users to able to create a resource (<code>POST</code> or <code>PUT</code> if it is an existing resource), read a resource (<code>GET</code>), update a resource (<code>PUT</code>/<code>PATCH</code>), and delete a resource (<code>DELETE</code>). In this section, we will work with a simple <code>venue</code> resource with the following endpoints, and the HTTP operations we will perform on them are CRUD.</p>
<p>All the code<a id="_idIndexMarker657"/> for the endpoint’s implementation will be hosted in the GitHub repository of this book.</p>
<p>Let’s jump-start the CRUD operation by describing the endpoints we are using:</p>
<ul>
<li><code>POST</code> <code>/api/v1/venues/</code>: Creates a <code>venue</code> resource</li>
<li><code>GET</code> <code>/api/v1/venues</code>: Returns a list of all the venues</li>
<li><code>GET</code> <code>/api/v1/venues/id</code>: Retrieves a single venue identified with <code>id</code></li>
<li><code>PUT</code> <code>/api/v1/venues/id</code>: Updates a single venue identified with <code>id</code></li>
<li><code>DELETE</code> <code>/api/v1/venues/id</code>: Deletes a single venue identified with <code>id</code></li>
</ul>
<p>The <a id="_idIndexMarker658"/>preceding endpoints are clear with regard to their intentions. But before we start fleshing out the endpoints, let’s discuss the necessary dependencies and be sure we can connect with the database.</p>
<p>Activate the virtual environment: always remember you are working in a virtual environment to contain your project dependencies. Then, inside <code>bizza/backend</code>, update the <code>app.py</code> file with the following code:</p>
<pre class="source-code">from flask import Flaskfrom flask_sqlalchemy import SQLAlchemy
app = Flask(__name__)
app.config['SQLALCHEMY_DATABASE_URI'] = 'postgresql://&lt;username&gt;:&lt;password&gt;@localhost:5432/&lt;database_name&gt;'
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
db = SQLAlchemy(app)</pre>
<p>In the preceding code snippet, we imported the <code>Flask</code> and <code>SQLAlchemy</code> modules. Then, the <code>app = Flask(__name__)</code> line created an instance of the Flask application. The <code>__name__</code> argument represents the name of the current module.</p>
<p>The <code>Flask</code> API comes with some configuration settings that we can modify. The <code>config</code> object is in the form of a Python dictionary. We are able to set the database URI with <code>app.config['SQLALCHEMY_DATABASE_URI']</code> and disable the SQLAlchemy operation notification setting with <code>app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = </code><code>False</code>.</p>
<p class="callout-heading">Note</p>
<p class="callout">In <code>app.config['SQLALCHEMY_DATABASE_URI'] = 'postgresql://&lt;username&gt;:&lt;password&gt;@localhost:5432/&lt;database_name&gt;'</code>, change <code>&lt;username&gt;</code> and <code>&lt;password&gt;</code> to your appropriate database credentials.</p>
<p>With <code>db = SQLAlchemy(app)</code>, we created the <code>SQLAlchemy</code> instance, which accepts the <code>Flask</code> instance as an argument.</p>
<p>With<a id="_idIndexMarker659"/> this set, let’s define<a id="_idIndexMarker660"/> the model class and create the venue table in the database.</p>
<p>Create the <code>Venue</code> class model, as follows:</p>
<pre class="source-code">class Venue(db.Model):__tablename__ = 'venues'
id = db.Column(db.Integer, primary_key=True)
name = db.Column(db.String(100))
    def format(self):
        return {
            'id': self.id,
            'name': self.name
    }</pre>
<p>Open the command terminal and enter the following:</p>
<pre class="console">flask shell</pre>
<p>Then, enter the following:</p>
<pre class="console">from app import db, Venue</pre>
<p>The <a id="_idIndexMarker661"/>preceding command brings <code>db</code>, an <code>SQLAlchmy</code> instance, and the <code>Venue</code> class model into scope.</p>
<p>Now, enter the following:</p>
<pre class="source-code">db.create_all()</pre>
<p>The<a id="_idIndexMarker662"/> preceding command creates the <code>venues</code> table from the <code>Venue</code> class model. Alternatively, you can run a migration command as done previously to create the table.</p>
<p>Finally, verify the table creation with the following:</p>
<pre class="source-code">db.engine.table_names()</pre>
<p>The following screenshot shows the terminal commands to show the creation of the <code>venues</code> table.</p>
<div><div><img alt="Figure 9.5 – Screenshot showing commands in flask shell" src="img/Figure_9.5_B18554.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.5 – Screenshot showing commands in flask shell</p>
<p>Now that we have the database and v<code>enues</code> table up and running, let’s start to define the endpoints.</p>
<h2 id="_idParaDest-180"><a id="_idTextAnchor213"/>Creating a venue resource</h2>
<p>Let’s <a id="_idIndexMarker663"/>define the <code>/venues</code> endpoint in <code>app.py</code> and use it to post entries to the database.</p>
<p>The endpoint for creating a new venue is as follows:</p>
<pre class="source-code">from flask import Flask, request, jsonify@app.route("/api/v1/venues", methods=['POST'])
def add_venues():
    if request.method == 'POST':
        name = request.get_json().get('name')
        all_venues =
            Venue.query.filter_by(name=name).first()
        if all_venues:
            return jsonify(message="Venue name already
                exist!"), 409
        else:
            venue = Venue(name=name)
            db.session.add(venue)
            db.session.commit()
            return jsonify({
                'success': True,
                'venues': venue.format()
            }), 201</pre>
<p>In the<a id="_idIndexMarker664"/> preceding code, we have the following:</p>
<ul>
<li>The <code>jsonify</code> and <code>request</code> methods are imported from Flask.</li>
<li>The <code>@app.route()</code> decorator has the URL to the <code>'/api/v1/venues'</code> endpoint with the HTTP <code>POST</code> method.</li>
<li>The <code>add_venue()</code> function is invoked once there is a <code>POST</code> request.</li>
<li>We test to make sure <code>request.method == '</code><code>POST'</code>.</li>
<li>We test to ensure the new venue name is not already in the database. If the added name is already in the database, the message <code>"Venue name already exist"</code> is sent back as a <code>json</code> message with status code <code>409- </code><code>content conflict</code>.</li>
<li>If the <a id="_idIndexMarker665"/>preceding step fails, we proceed to add to the database session with <code>db.session.add(new_venue)</code>. At this point, the entry is not fully added to the database but added to the database session. We need one more step to commit it to the database, which is <code>db.session.commit()</code>.</li>
<li><code>Jsonify()</code> is an in-built Flask function that returns a JSON-serialized response object.</li>
</ul>
<h2 id="_idParaDest-181"><a id="_idTextAnchor214"/>Returning lists of venues</h2>
<p>The<a id="_idIndexMarker666"/> following is the endpoint to retrieve all the venues in the database:</p>
<pre class="source-code"># retrieve all venues endpoint@app.route("/api/v1/venues", methods=['GET'])
def retrieve_venues():
    if request.method == 'GET':
        all_venues = Venue.query.all()
        if all_venues:
            return jsonify({
                'success': True,
                'venues': [venue.format() for venue in
                    all_venues]
            }), 200
        return jsonify(message="No venue record found"),
            404</pre>
<p>In the<a id="_idIndexMarker667"/> preceding code, we have the following:</p>
<ul>
<li>The <code>GET</code> request method is invoked</li>
<li><code>Venue.query.all()</code> is a query from <code>SQLAlchemy</code> to retrieve all the venues</li>
<li>The <code>jsonify</code> response object output results in a <code>200</code> status code, and if it fails, a <code>"No venue record found"</code> message is displayed with status code <code>404</code></li>
</ul>
<h2 id="_idParaDest-182"><a id="_idTextAnchor215"/>Returning a single venue resource</h2>
<p>The <a id="_idIndexMarker668"/>following is an endpoint to return a single venue:</p>
<pre class="source-code">@app.route("/api/v1/venues/&lt;int:id&gt;", methods=['GET'])def retrieve_venue(id):
    if request.method == 'GET':
        venue = Venue.query.filter(Venue.id == id).first()
        if venue:
            return jsonify({
                'success': True,
                'venue': venue.format()
            }), 200
        return jsonify(message="Record id not found"), 404</pre>
<p>In the preceding code, we are doing the following:</p>
<ul>
<li>The <code>GET</code> request method is invoked</li>
<li><code>Venue.query.filter(Venue.id == id).first()</code> retrieves the first record with the ID supplied as an argument to <code>retrieve_venue()</code></li>
<li>If the ID is present, the <code>jsonify</code> response object output results in a <code>200</code> status code, and if it fails, the <code>"Record id not found"</code> message is displayed with <a id="_idIndexMarker669"/>status code <code>404</code></li>
</ul>
<h2 id="_idParaDest-183"><a id="_idTextAnchor216"/>Updating a single venue resource</h2>
<p>The<a id="_idIndexMarker670"/> following is an endpoint to modify venue information:</p>
<pre class="source-code">@app.route("/api/v1/venues/&lt;int:id&gt;", methods=['PUT'])def update_venue(id):
    if request.method == 'PUT':
        name = request.get_json().get('name')
        venue = Venue.query.get(id)
        if not venue:
            return jsonify(message='Venue record not
                found'), 404
        venue.name = name
        db.session.commit()
    return jsonify({
        'success': True,
        'updated venue': venue.format()
    }), 200</pre>
<p>In the preceding code, we are doing the following:</p>
<ul>
<li>The <code>PUT</code> request method is invoked to update a single resource</li>
<li>We try to check for the existence of the record <code>id</code></li>
<li>If the record is present, we update it with <code>venue.name = name</code>, then commit the session</li>
<li>If the<a id="_idIndexMarker671"/> ID information is updated, the <code>jsonify</code> response object output results in a <code>200</code> status code, and if it fails, the <code>"Venue record not found"</code> message is displayed with status code <code>404</code></li>
</ul>
<h2 id="_idParaDest-184"><a id="_idTextAnchor217"/>Deleting a single venue resource</h2>
<p>The <a id="_idIndexMarker672"/>following is an endpoint to delete a venue:</p>
<pre class="source-code">@app.route('/venues/&lt;int:id&gt;', methods=['DELETE'])def remove_venue(id):
    venue = Venue.query.filter_by(id=id).first()
    if venue:
        db.session.delete(venue)
        db.session.commit()
        return jsonify(
            {'success': True,
            'message': 'You deleted a venue',
            'deleted': venue.format()
            }
        ), 202
    else:
        return jsonify(message="That venue does not
            exist"), 404</pre>
<p>In the preceding code, we are doing the following:</p>
<ul>
<li>The <code>DELETE</code> request method is invoked to delete a single resource</li>
<li>We try to check for the existence of the record <code>id</code></li>
<li>If <a id="_idIndexMarker673"/>the record is present, we delete it, then commit the session</li>
<li>If the ID information is deleted, the <code>jsonify</code> response object output results in a <code>202</code> status code, and if it fails, a <code>"That venue does not exist"</code> message is displayed with status code <code>404</code></li>
</ul>
<p>The following GitHub link contains the complete code for the <code>venue</code> CRUD operation in <code>app.py</code> -<a href="https://github.com/PacktPublishing/Full-Stack-Flask-and-React/blob/main/Chapter09/05/bizza/backend/app.py">https://github.com/PacktPublishing/Full-Stack-Flask-and-React/blob/main/Chapter09/05/bizza/backend/app.py</a>.</p>
<p>Next, we will examine the concept of API documentation and deep-dive into its importance and how to make use of the Postman tool to document your API endpoint.</p>
<h1 id="_idParaDest-185"><a id="_idTextAnchor218"/>API documentation</h1>
<p>Have you<a id="_idIndexMarker674"/> ever tried to assemble a piece of equipment you bought from a store without looking through the manual? There is a high probability you will have done so deliberately. You smartly think it will be easy to put together, and most times, you get burned in this process of trial and error and eventually mess things up.</p>
<p>Manuals are a good resource meant to ease you through a product’s features and functionality. API documentation is no different from manuals for guidance, a set of instructions, references, or even tutorial materials that can enhance developers’ understanding of your API.</p>
<p>Why is API documentation a critical component of your API? We will examine a few reasons and dive into using the Postman client tool to document your API so that other developers can understand what it is all about and how to use it. We will use a very simplistic case study with the <code>venues</code> CRUD operation we examined in the preceding section.</p>
<p>In a production-ready API product, you are expected to provide more detailed information about your API in your documentation. You are to write up a technical instructional guide that will make consuming your API services a walk in the park. You would also want to include tutorials, clear references, and sample code that can help developers with easy integration.</p>
<p>Let’s examine the reasons <a id="_idIndexMarker675"/>why you would want to come up with clear documentation for your API:</p>
<ul>
<li><strong class="bold">Enhanced developer experience</strong>: API documentation opens up a way to provide quick-start guides, references, and case studies for developers who want to be productive and consume third-party data to improve their software product offerings. Therefore, well-thought-out API documentation helps developers to understand the best approach to implementing your API data points to solve their problems.<p class="list-inset">High-quality and useful API documentation means developers are going to easily understand how to implement your API and thus will increase their overall emotional attachment to your API product. Stripe, PayPal, Spotify, Twilio, and Paystack are good examples of popular commercial APIs with awesome documentation.</p></li>
<li><strong class="bold">Decreased onboarding time</strong>: Comprehensive documentation allows even an entry-level developer to quickly know how to implement your API endpoints and methods and handle requests and responses seamlessly without assistance from other developers. This will save time and costs for the business and improve the API adoption rate.</li>
<li><strong class="bold">Adherence to API objectives</strong>: Documentation allows API designers and consumers to have a common ground on API specs and the problem it aims to solve without ambiguity.</li>
</ul>
<p>Next, we will use Postman to test and document a RESTful API.</p>
<h1 id="_idParaDest-186"><a id="_idTextAnchor219"/>Testing and documenting with Postman</h1>
<p>Postman <a id="_idIndexMarker676"/>is <a id="_idIndexMarker677"/>an advanced API platform that provides a range of features to simplify the development, testing, and utilization of APIs. Postman offers a user-friendly interface for testing API endpoints, generating API documentation, and collaborating on API-related operations.</p>
<p>To begin<a id="_idIndexMarker678"/> using Postman, you can download and install the application on your local machine. Visit the official Postman website at <a href="https://www.postman.com/downloads">https://www.postman.com/downloads</a> to<a id="_idIndexMarker679"/> access the download page. From there, you can choose the appropriate version for your operating system and follow the installation instructions.</p>
<p>Once you have <a id="_idIndexMarker680"/>Postman installed, you can leverage the power of <a id="_idIndexMarker681"/>Postman to document RESTful API endpoints, execute requests, analyze responses, and perform comprehensive testing.</p>
<p>Let’s leverage <code>venues</code> on the collections and<a id="_idIndexMarker682"/> generate API documentation that tells other developers how to make requests and describe the response to expect:</p>
<ol>
<li>On your computer, start Postman and create a collection. Click on the <strong class="bold">Collections</strong> tab on the left sidebar of the Postman interface; if it’s not visible, you can click on the three horizontal lines in the top-left corner to expand the sidebar. In the dialog box, enter a name for your collection.</li>
</ol>
<div><div><img alt="Figure 9.6 – Screenshot showing the creation of a collection in Postman" src="img/Figure_9.6_B18554.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.6 – Screenshot showing the creation of a collection in Postman</p>
<ol>
<li value="2">After creating a collection, create a new request. Within the collection, click on the <strong class="bold">New</strong> button located in the top-left corner of the interface. A drop-down menu will appear:</li>
</ol>
<div><div><img alt="Figure 9.7 – Screenshot showing how to add an HTTP request" src="img/Figure_9.7_B18554.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.7 – Screenshot showing how to add an HTTP request</p>
<ol>
<li value="3">Select the <a id="_idIndexMarker683"/>request<a id="_idIndexMarker684"/> type from the drop-down menu. To post data to the server, select <code>localhost:5000/api/v1/venues</code>.</li>
<li>Select <a id="_idIndexMarker686"/>the <strong class="bold">Body</strong> tab, then <strong class="bold">raw</strong>, and finally select the <strong class="bold">JSON</strong> tab from the dropdown. This will allow you to send the data to the server in JSON format. In this case, we send the following data to the backend server:<pre class="source-code">{''name": "Auditorium A"}</pre><p class="list-inset">The following screenshot shows how you can use Postman to test endpoints.</p></li>
</ol>
<p class="IMG---Figure"> </p>
<div><div><img alt="Figure 9.8 – Screenshot showing sending data to the backend" src="img/Figure_9.8_B18554.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.8 – Screenshot showing sending data to the backend</p>
<ol>
<li value="5">Send the <a id="_idIndexMarker687"/>request once you have configured the request. Click on the <code>POST</code> request will fail.<p class="list-inset">After <a id="_idIndexMarker690"/>sending the request, Postman will display the response received from the server. You can see the response content, status code, headers, and other relevant information in the response panel. The following screenshot shows the response data.</p></li>
</ol>
<div><div><img alt="Figure 9.9 – Screenshot showing server response to a POST request" src="img/Figure_9.9_B18554.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.9 – Screenshot showing server response to a POST request</p>
<p class="list-inset">Repeat the preceding steps for each request in your collection, choosing appropriate request types and providing descriptions, parameter details, the request payload, and the response format as needed.</p>
<ol>
<li value="6">Once you <a id="_idIndexMarker691"/>have tested all the endpoints, right-click on the collection name and click on <strong class="bold">View Documentation</strong>.<p class="list-inset">This takes you to where <a id="_idIndexMarker692"/>you can customize your<a id="_idIndexMarker693"/> API documentation further. You can add details such as the API description, stating a brief overview of the API, including its purpose, functionality, and any relevant background information.</p><p class="list-inset">Also, you can<a id="_idIndexMarker694"/> specify the base URL of the API, including the protocol (HTTP/HTTPS) and the domain name. If the API requires authentication, explain the authentication mechanism(s) supported (for example, API key, OAuth, or JWT) and provide instructions on how to authenticate requests.</p><p class="list-inset">Depending on the requirements of your API, you can document each endpoint exposed by the API. For each endpoint, you may include the following information:</p><ul><li><strong class="bold">Endpoint URL</strong>: Provides <a id="_idIndexMarker695"/>the URL pattern for the endpoint, including any required path parameters.</li>
<li><code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code>, and so on).</li>
<li><strong class="bold">Request parameters</strong>: Specifies <a id="_idIndexMarker697"/>any query parameters, request headers, or request body parameters required by the endpoint. Include the parameter name, type, description, and whether it is required or optional.</li>
<li><strong class="bold">Response format</strong>: Describes<a id="_idIndexMarker698"/> the format of the response returned by the endpoint (for example, JSON or XML).</li>
<li><code>200 OK</code>, <code>400 Bad Request</code>, or <code>401 Unauthorized</code>).</li>
<li><strong class="bold">Response body</strong>: Provides <a id="_idIndexMarker700"/>an example of the response body returned by the endpoint, including all relevant fields and their descriptions.</li>
<li><strong class="bold">Error handling</strong>: Explains<a id="_idIndexMarker701"/> how errors are handled by the API and provides examples of error responses.</li>
</ul></li>
<li>Lastly, you<a id="_idIndexMarker702"/> can now publish your API <a id="_idIndexMarker703"/>documentation<a id="_idIndexMarker704"/> to share <a id="_idIndexMarker705"/>with the public.</li>
</ol>
<div><div><img alt="Figure 9.10 – Screenshot showing how you publish your API documentation" src="img/Figure_9.10_B18554.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.10 – Screenshot showing how you publish your API documentation</p>
<p>You can read up on the further customization of the published documentation in the Postman documentation as it is possible to convert it into HTML and host it on your own server. The link to the generated API documentation is https://documenter.getpostman.com/view/4242057/2s93sjUoYX.</p>
<h1 id="_idParaDest-187"><a id="_idTextAnchor220"/>Summary</h1>
<p>In this chapter, we explored API development in Flask applications. We started by understanding what an API is all about and why businesses and developers are creating and consuming APIs to drive their data access. We took things further by taking a quick run through common terminologies developers come across when implementing the API design pattern.</p>
<p>Then, we unmasked the structure of endpoints and payloads, recognizing that designing routes and exchanging data form the foundational elements of API development. In addition, we critically examined the design principles guiding RESTful API development. We discussed how understanding the REST API design principles enhances best practices in API design and development. Also, we discussed the implementation of the REST API and how we can connect API backend services with a database in a Flask application.</p>
<p>Finally, we discussed API testing and documentation with Postman. In API design and development, we recognized how testing and documenting endpoints is crucial to building stable and usable web applications.</p>
<p>In the next chapter, we are going to bridge the frontend and backend functionalities and experience the full stack nature of React and Flask.</p>
</div>
</body></html>