- en: '*Chapter 16*: The Factory Pattern'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Design patterns** are reusable programming solutions that have been used
    in various real-world contexts and have proved to produce the expected results.
    In this chapter, we will learn about one of the most common design patterns: the
    factory design pattern. As we will see later, this pattern makes it easier to
    track which objects are created within a program, thus separating the code that
    creates an object from the code that uses it. We will study the factory design
    pattern''s two forms: the **factory method** and the **abstract method**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding design patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the factory method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying the abstract factory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, we will have gained a deep understanding of the
    factory design pattern and its benefits via a hands-on example.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code files for this chapter can be found at [https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter16](https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter16).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding design patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Design patterns are shared among programmers and continue to be improved over
    time. This topic is popular thanks to the book by Erich Gamma, Richard Helm, Ralph
    Johnson, and John Vlissides, titled *Design Patterns: Elements of Reusable Object-Oriented
    Software*.'
  prefs: []
  type: TYPE_NORMAL
- en: Gang of Four
  prefs: []
  type: TYPE_NORMAL
- en: The book by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides is
    also called the *Gang of Four* book for short (or the *GOF* book for an even shorter
    name).
  prefs: []
  type: TYPE_NORMAL
- en: Generally, a design pattern helps the programmer create a commonly used implementation
    pattern, especially in **object-oriented programming** (**OOP**). The benefits
    of viewing applications from the design pattern's perspective are plenty. First,
    it narrows down the most effective ways of building a given application and the
    necessary steps to do it. Second, you could consult existing examples of the same
    design pattern to improve your application. Overall, design patterns are highly
    useful guidelines in software engineering.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several categories of design patterns that are used in OOP, depending
    on the type of problem they address and/or the types of solutions they help us
    build. In their book, the *Gang of Four* presents 23 design patterns, split into
    three categories: **creational**, **structural**, and **behavioral**.'
  prefs: []
  type: TYPE_NORMAL
- en: '`__init__()` function, is not convenient.'
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: See [https://docs.python.org/3/tutorial/classes.html](https://docs.python.org/3/tutorial/classes.html)
    for a quick overview of object classes and the special `__init__()` method that
    Python uses to initialize a new class instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start with the first creational design pattern from the *Gang of Four*
    book: the **factory design pattern**. In the factory design pattern, a **client**
    (meaning client code) asks for an object without knowing where the object is coming
    from (that is, which class is used to generate it). The idea behind a factory
    is to simplify the object creation process. It is easier to track which objects
    are created if this is done through a central function, compared to letting a
    client create objects using a direct class instantiation. A factory reduces the
    complexity of maintaining an application by decoupling the code that creates an
    object from the code that uses it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Factories typically come in two forms: the **factory method**, which is a method
    (or simply a function for a Python developer) that returns a different object
    per input parameter, and the **abstract factory**, which is a group of factory
    methods that are used to create a family of related objects.'
  prefs: []
  type: TYPE_NORMAL
- en: That is all the theory we need to get started. In the next section, we will
    discuss the factory method.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the factory method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The factory method is based on a single function that's written to handle our
    object creation task. We execute it, passing a parameter that provides information
    about what we want. As a result, the object we wanted is created.
  prefs: []
  type: TYPE_NORMAL
- en: Interestingly, when we use the factory method, we don't need to know any details
    about how the resulting object is implemented and where it is coming from. First,
    we will discuss some real-life applications that use the factory method and then
    implement an example application that processes XML and JSON files.
  prefs: []
  type: TYPE_NORMAL
- en: Real-world examples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An example of the factory method pattern that's used in real life is in the
    context of a plastic toy construction kit. The molding material that's used to
    construct plastic toys is the same, but different toys (different figures or shapes)
    can be produced using the right plastic molds. This is like having a factory method
    in which the input is the name of the toy that we want (for example, `duck` or
    `car`) and the output (after the molding) is the plastic toy that was requested.
  prefs: []
  type: TYPE_NORMAL
- en: In the software world, the *Django* web framework uses the factory method pattern
    to create the fields of a web form. The `forms` module, which is included in Django,
    supports the ability to create different kinds of fields (for example, `CharField`,
    `EmailField`, and so on). Parts of their behavior can be customized using attributes
    such as `max_length` or `required` ([j.mp/djangofac](http://j.mp/djangofac)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code could be written by a developer for a form (the `PersonForm`
    form, which contains the `name` and `birth_date` fields) as part of a Django application's
    UI code.
  prefs: []
  type: TYPE_NORMAL
- en: Use cases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you realize that you cannot track the objects that are created by your application
    because the code that creates them is in many different places instead of in a
    single function/method, you should consider using the factory method pattern.
    The factory method centralizes object creation and tracking your objects becomes
    much easier. Note that it is absolutely fine to create more than one factory method,
    and this is how it is typically done in practice. Each factory method logically
    groups objects that have similarities. For example, one factory method might be
    responsible for connecting you to different databases (MySQL and SQLite), another
    factory method might be responsible for creating the geometrical object that you've
    requested (circle and triangle), and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The factory method is also useful when you want to decouple object creation
    from object usage. We are not coupled/bound to a specific class when creating
    an object; we just provide partial information about what we want by calling a
    function. This means that introducing changes to the function is easy and does
    not require any changes to be made to the code that uses it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another use case worth mentioning is related to improving the performance and
    memory usage of an application. A factory method can improve performance and memory
    usage by creating new objects only if it is necessary. When we create objects
    using a direct class instantiation, extra memory is allocated every time a new
    object is created (unless the class uses caching internally, which is usually
    not the case). We can see that, in practice, in the following code (in the `id.py`
    file), it creates two instances of the same class, `A`, and uses the `id()` function
    to compare their **memory addresses**. These addresses are also printed in the
    output so that we can inspect them. The fact that the memory addresses are different
    means that two distinct objects are created, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing the `python id.py` command on my computer results in the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the addresses that you see if you execute the file are not the same
    as the ones I can see because they depend on the current memory layout and allocation.
    But the result must be the same: the two addresses should be different. There''s
    one exception that happens if you write and execute the code in the Python **Read-Eval-Print
    Loop** (**REPL**) – or, simply put, the interactive prompt – but that''s a REPL-specific
    optimization that does not happen normally.'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the factory method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Data comes in many forms. There are two main file categories for storing/retrieving
    data: human-readable files and binary files. Examples of human-readable files
    include XML, RSS/Atom, YAML, and JSON. Examples of binary files include the `.sq3`
    file format that''s used by SQLite and the `.mp3` audio file format, which is
    used to listen to music.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we will focus on two popular human-readable formats: **XML**
    and **JSON**. Although human-readable files are generally slower to parse than
    binary files, they make data exchange, inspection, and modification much easier.
    For this reason, it is advised that you work with human-readable files unless
    other restrictions do not allow it (mainly unacceptable performance and proprietary
    binary formats).'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we have some input data stored in an XML file and a JSON file,
    and we want to parse them and retrieve some information. At the same time, we
    want to centralize the client's connection to those (and all future) external
    services. We will use the factory method to solve this problem. This example focuses
    only on XML and JSON but adding support for more services should be straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: First, let's take a look at the data files.
  prefs: []
  type: TYPE_NORMAL
- en: 'The JSON file, `movies.json`, which can be found in the `data` subfolder of
    this chapter''s code folder, is an example of a dataset containing information
    about American movies (title, year, director name, genre, and so on). This is
    a big file but here is a portion of its content to illustrate how its content
    is organized:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The XML file, `person.xml`, is based on a Wikipedia example ([j.mp/wikijson](http://j.mp/wikijson))
    and contains information about individuals (`firstName`, `lastName`, `gender`,
    and so on), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start with the enclosing tag of the `persons` XML container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, an XML element representing a person''s data code is presented, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'An XML element representing another person''s data must then be provided:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'An XML element representing a third person''s data is then shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we must close the XML container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will use two libraries that are part of the Python distribution for working
    with JSON and XML, `json` and `xml.etree.ElementTree`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `JSONDataExtractor` class parses the JSON file and has a `parsed_data()`
    method that returns all the data as a dictionary (`dict`). The property decorator
    is used to make `parsed_data()` appear as a normal attribute instead of a method,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `XMLDataExtractor` class parses the XML file and has a `parsed_data()`
    method that returns all the data as a list of `xml.etree.Element`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `dataextraction_factory()` function is a factory method. It returns an
    instance of `JSONDataExtractor` or `XMLDataExtractor`, depending on the extension
    of the input file path, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `extract_data_from()` function is a wrapper of `dataextraction_factory()`.
    It adds exception handling, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `main()` function demonstrates how the factory method design pattern can
    be used. The first part makes sure that exception handling is effective, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next part shows how to work with the JSON files using the factory method.
    Based on the parsing, the title, year, director name, and genre of the movie can
    be shown (when the value is not empty), as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The final part shows you how to work with the XML files using the factory method.
    XPath is used to find all the person elements that have `Liar` as the last name
    (using `liars = xml_data.findall(f".//person[lastName=''Liar'']")`). For each
    matched person, their basic name and phone number information is shown, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here is the summary of the implementation (you can find the code in the `factory_method.py`
    file):'
  prefs: []
  type: TYPE_NORMAL
- en: We start by importing the modules we need (`json` and `ElementTree`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We define the JSON data extractor class (`JSONDataExtractor`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We define the XML data extractor class (`XMLDataExtractor`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We add the factory function, `dataextraction_factory()`, to get the right data
    extractor class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We also add our wrapper for handling exceptions – the `extract_data_from()`
    function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, we have the `main()` function, followed by Python''s conventional
    trick for calling it when invoking this file from the command line. The following
    are the aspects of the `main` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We try to extract data from a SQL file (`data/person.sq3`) to show how the exception
    is handled.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We extract data from a JSON file and parse the result.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We extract data from an XML file and parse the result.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The following is the type of output (for the different cases) you will get by
    calling the `python factory_method.py` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, there is an exception message that you''ll see when you try to access
    a SQLite (`.sq3`) file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we get the following result from processing the `movies` file (JSON):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we get this result from processing the `person` XML file to find the
    people whose last name is `Liar`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Notice that although `JSONDataExtractor` and `XMLDataExtractor` have the same
    interfaces, what is returned by `parsed_data()` is not handled uniformly. Different
    Python code must be used to work with each **data extractor**. Although it would
    be nice to be able to use the same code for all extractors, this is not realistic
    for the most part, unless we use some kind of common mapping for the data, which
    is often provided by external data providers. A useful exercise would be to assume
    that you can use the same code to handle the XML and JSON files and see what changes
    are required to support a third format, such as SQLite. Find a SQLite file or
    create your own and try it.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we have learned about the factory method, which, again, is the
    first form of the factory design pattern. In the next section, we will talk about
    the second: the abstract factory design pattern.'
  prefs: []
  type: TYPE_NORMAL
- en: Applying the abstract factory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The abstract factory design pattern is a generalization of the factory method.
    An abstract factory is a (logical) group of factory methods, where each factory
    method is responsible for generating a different kind of object.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we are going to discuss some examples, use cases, and a possible
    implementation of this pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Real-world examples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The abstract factory is used in car manufacturing. The same machinery is used
    for stamping the parts (doors, panels, hoods, fenders, and mirrors) of different
    car models. The model that is assembled by the machinery is configurable and easy
    to change at any time.
  prefs: []
  type: TYPE_NORMAL
- en: In the software category, the `factory_boy` ([https://github.com/FactoryBoy/factory_boy](https://github.com/FactoryBoy/factory_boy))
    package provides an abstract factory implementation for creating Django models
    in tests. It is used to create instances of models that support **test-specific
    attributes**. This is important because, this way, your tests become readable,
    and you avoid sharing unnecessary code.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Django models are special classes that are used by the framework to help store
    and interact with data in the database (tables). See the Django documentation
    ([https://docs.djangoproject.com](https://docs.djangoproject.com)) for more details.
  prefs: []
  type: TYPE_NORMAL
- en: Use cases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since the abstract factory pattern is a generalization of the factory method
    pattern, it offers the same benefits, it makes tracking an object creation easier,
    it decouples object creation from object usage, and it gives us the potential
    to improve the memory usage and performance of our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'But a question is raised: *How do we know when to use the factory method versus
    using an abstract factory?* The answer is that we usually start with the factory
    method, which is simpler. If we find out that our application requires many factory
    methods, which it makes sense to combine to create a family of objects, we end
    up with an abstract factory.'
  prefs: []
  type: TYPE_NORMAL
- en: A benefit of the abstract factory that is usually not very visible from a user's
    point of view when they're using the factory method is that we can modify the
    behavior of our application dynamically (at runtime) by changing the active factory
    method. The classic example is the ability to change the look and feel of an application
    (for example, Apple-like, Windows-like, and so on) for the user while the application
    is in use, without the need to terminate it and start it again.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the abstract factory pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To demonstrate the abstract factory pattern, I will reuse one of my favorite
    examples, which is included in the book *Python 3 Patterns, Recipes, and Idioms*,
    by Bruce Eckel. Imagine that we are creating a game, or we want to include a mini-game
    as part of our application to entertain our users. We want to include at least
    two games – one for children and one for adults. We will decide which game to
    create and launch at runtime, based on user input. An abstract factory takes care
    of the game creation part.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the kid''s game. It is called *FrogWorld*. The main hero
    is a frog who enjoys eating bugs. Every hero needs a good name, and in our case,
    the name is given by the user at runtime. The `interact_with()` method is used
    to describe how the frog interacts with an obstacle (for example, a bug, a puzzle,
    and other frogs), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'There can be many different kinds of obstacles but for our example, an obstacle
    can only be a bug. When the frog encounters a bug, only one action is supported.
    It eats it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `FrogWorld` class is an abstract factory. Its main responsibilities are
    creating the main character and the obstacle(s) in the game. Keeping the creation
    methods separate and their names generic (for example, `make_character()` and
    `make_obstacle()`) allows us to change the active factory (and therefore the active
    game) dynamically without making any code changes. In a statically typed language,
    the abstract factory would be an abstract class/interface with empty methods,
    but in Python, this is not required because the types are checked at runtime ([j.mp/ginstromdp](http://j.mp/ginstromdp)).
    The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The *WizardWorld* game is similar. The only difference is that the wizard battles
    against monsters such as orcs instead of eating bugs!
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the definition of the `Wizard` class, which is similar to the `Frog`
    one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the definition of the `Ork` class is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to define the `WizardWorld` class, similar to the `FrogWorld`
    one that we have discussed; the obstacle, in this case, is an `Ork` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `GameEnvironment` class is the main entry point of our game. It accepts
    the factory as input and uses it to create the world of the game. The `play()`
    method initiates the interaction between the created hero and the obstacle, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The `validate_age()` function prompts the user to give a valid age. If the
    age is not valid, it returns a tuple with the first element set to `False`. If
    the age is fine, the first element of the tuple is set to `True`. This is where
    we care about the second element of the tuple, which is the age given by the user,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Last but not least comes the `main()` function. It asks for the user''s name
    and age, and decides which game should be played, given the age of the user, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is a summary of the implementation we just discussed (see the
    complete code in the `abstract_factory.py` file):'
  prefs: []
  type: TYPE_NORMAL
- en: First, we define the `Frog` and `Bug` classes for the FrogWorld game.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We add the `FrogWorld` class, where we use our `Frog` and `Bug` classes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We define the `Wizard` and `Ork` classes for the WizardWorld game.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We add the `WizardWorld` class, where we use our `Wizard` and `Ork` classes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We define the `GameEnvironment` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We add the `validate_age()` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, we have the `main()` function, followed by the conventional trick
    for calling it. The following are the aspects of this function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We get the user's input for their name and age.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We decide which game class to use based on the user's age.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We instantiate the right game class, and then the `GameEnvironment` class.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We call `play()` on the environment object to play the game.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's call this program using the `python abstract_factory.py` command and see
    some sample output.
  prefs: []
  type: TYPE_NORMAL
- en: 'The sample output for a teenager is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The sample output for an adult is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Try extending the game to make it more complete. You can go as far as you want;
    create many obstacles, many enemies, and whatever else you like.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to use the factory method and the abstract factory
    design patterns. Both patterns are used when we want to track object creation,
    decouple object creation from object usage, or even improve the performance and
    resource usage of an application. Improving performance was not demonstrated in
    this chapter. You may consider trying it as a good exercise.
  prefs: []
  type: TYPE_NORMAL
- en: The factory method design pattern is implemented as a single function that doesn't
    belong to any class and is responsible for creating a single kind of object (a
    shape, a connection point, and so on). We saw how the factory method relates to
    toy construction, mentioned how it is used by Django to create different form
    fields, and discussed other possible use cases for it. As an example, we implemented
    a factory method that provided access to XML and JSON files.
  prefs: []
  type: TYPE_NORMAL
- en: The abstract factory design pattern is implemented as several factory methods
    that belong to a single class and are used to create a family of related objects
    (the parts of a car, the environment of a game, and so forth). We mentioned how
    the abstract factory is related to car manufacturing, how the `django_factory`
    package for Django makes use of it to create clean tests, and then we covered
    its common use cases. Our implementation example of the abstract factory was a
    mini-game that shows how we can use many related factories in a single class.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss the builder pattern, which is another creational
    pattern that can be used for fine-tuning the creation of complex objects.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the high-level benefits of using the factory pattern?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the two forms of the factory pattern and their main differences?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How should we decide which form of the factory pattern we should use when building
    an application?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
