- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Authentication and Authorization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In building full-stack web applications, you will more than often want to implement
    a system that allows users to trust you with their sensitive information. As a
    full-stack web developer, it is crucial to understand how to implement robust
    authentication and authorization mechanisms. You need to know how to protect the
    security of user data and the integrity of your application. Imagine you are building
    an e-commerce website that allows users to make online purchases.
  prefs: []
  type: TYPE_NORMAL
- en: If you do not properly authenticate and authorize users, it would be possible
    for someone to gain unauthorized access to the website and place orders using
    someone else’s personal information. This could result in financial loss for the
    legitimate user as well as damage to the reputation of an online business or that
    of your clients.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, if you fail to properly authenticate and authorize users, it could
    also open your web application up to attacks such as SQL injection, where an attacker
    can gain access to sensitive information stored in your database. This could lead
    to the loss of customer data and legal repercussions may be staring you in the
    face.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will delve into the world of web security and explore the
    best practices and techniques for securing Flask web applications. As the famous
    computer scientist Bruce Schneier once said, *Security is a process, not a product*
    ([https://www.schneier.com/essays/archives/2000/04/the_process_of_secur.html](https://www.schneier.com/essays/archives/2000/04/the_process_of_secur.html)).
    This chapter will equip you with the knowledge and skills needed to understand
    the importance of information security and how to implement it in a Flask application.
  prefs: []
  type: TYPE_NORMAL
- en: From understanding the fundamentals of authentication and authorization to managing
    user sessions and creating accounts with secure passwords, this chapter will cover
    the crucial elements of web application security. We will examine the process
    of securing your Flask application and show you how to implement these concepts
    in practice.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the fundamentals of information security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining authentication and the authentication role in web applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing password security and hashing passwords
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding access and authorization in web application development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding authentication to your Flask application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifying system users and managing their information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Session management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a password-protected dashboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing flash messages in Flask
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The complete code for this chapter is available on GitHub at: [https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter12](https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter12).'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the fundamentals of information security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Information security is a critical aspect of web application development. In
    today’s digital age, personal and sensitive information is often stored and transmitted
    through web applications, making them vulnerable to various types of security
    threats. These threats can range from simple attacks such as **SQL injection**
    and **cross-site scripting** (**XSS**) to more complex attacks such as **man-in-the-middle**
    (**MITM**) and **distributed denial of** **service** (**DDoS**).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s delve deeper into some of the various types of threats that can compromise
    your web application security:'
  prefs: []
  type: TYPE_NORMAL
- en: '`username` and `password` details. If the application is vulnerable to SQL
    injection, an attacker could input something like `'' OR ''1''=''1` in the password
    field.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The SQL query may then become `SELECT * FROM users WHERE username = 'username'
    AND password = '' OR '1'='1';`, which would potentially allow the attacker to
    log in without a valid password.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`<script>malicious_scripts()</script>`, other users viewing the comment section
    might execute the script unintentionally.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cross-site request forgery** (**CSRF**): This is an attack where an attacker
    tricks a user into unknowingly making a request to a web application on which
    the user is authenticated. This can lead to unauthorized actions being taken on
    behalf of the user without their consent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CSRF attacks exploit the trust that a website has in a user’s browser. For instance,
    an unsuspecting user logs into an online banking website and gets a session cookie.
    The attacker creates a malicious web page that contains a hidden form that submits
    a request to transfer money from the user’s account to the attacker’s account.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The user visits the attacker’s web page, and the hidden form is submitted using
    the user’s session cookie, resulting in an unauthorized transfer. This type of
    attack exploits the trust that a website has in the user’s browser to perform
    unauthorized actions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Distributed Denial of Service** (**DDoS**) **attacks**: This type of attack
    involves overwhelming a target server, service, or network with a flood of traffic
    from multiple sources, rendering it inaccessible to legitimate users. For instance,
    an attacker might use a botnet (a network of compromised computers) to send a
    massive amount of traffic to a web application. This can cause a web application
    to become slow or entirely unavailable to users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, there are ways you can mitigate against these malicious threats, which
    are capable of undermining your web application. Now, we will highlight some of
    the best practices for securing your web application.
  prefs: []
  type: TYPE_NORMAL
- en: '**Input validation**: You need to ensure that all input data is properly sanitized
    and validated to prevent SQL injection and XSS attacks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SQLAlchemy` in Flask, handle the construction of SQL queries for you and provide
    a safe and efficient way to interact with databases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Password storage**: Store passwords securely using a strong hashing algorithm
    and a unique salt for each user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use of HTTPS**: Use HTTPS to encrypt all communication between the client
    and the server to prevent eavesdropping and MITM attacks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Session management**: Properly manage sessions to prevent session hijacking
    and fix session fixation vulnerabilities in your web application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Access control**: Use role-based access control to restrict access to sensitive
    resources and functionality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Logging and monitoring**: You need to consistently keep detailed logs of
    all application activity and monitor them for suspicious activity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Using up-to-date software**: You need to regularly update the framework,
    libraries, and all dependencies that your web application is using to ensure that
    known vulnerabilities are patched.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`X-XSS-Protection`, `X-Frame-Options`, and `Content-Security-Policy` to prevent
    certain types of attacks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Regularly testing for vulnerabilities**: Regularly conduct penetration testing
    and vulnerability scanning to identify and fix any security issues.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the remaining parts of this chapter, we will discuss and implement authentication
    with authorization in a Flask web application to help you keep your application
    and its users’ data secure.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will discuss authentication and the authentication role in web applications.
    This will improve your understanding of how to verify users’ identities and the
    various types of authentications.
  prefs: []
  type: TYPE_NORMAL
- en: Defining authentication and the authentication role in web application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Authentication** is the process of verifying the identity of a user and ensuring
    that only authorized users have access to the application’s resources and functionality.
    Authentication is an important aspect of any web application, including those
    built with Flask.'
  prefs: []
  type: TYPE_NORMAL
- en: This is typically done by prompting the user to provide a set of credentials,
    such as a username and password, that the web application can use to confirm the
    user’s identity. The purpose of authentication in web application development
    is to ensure that only authorized users can access sensitive information and perform
    certain actions within a web application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In web development, we have several types of authentication methods that can
    be used in any web application project. These are some of the most commonly used
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Password-based authentication**: This is the most common form of authentication
    we encounter in everyday use and involves the user entering a username/email and
    password to gain access to the web application. This method is simple and easy
    to implement but comes with its weakness. Password-based authentication is vulnerable
    to attacks such as brute-force and dictionary attacks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multi-factor authentication** (**MFA**): This method adds an additional layer
    of security by requiring the user to provide multiple forms of identification.
    For instance, a user may be required to enter a password and also provide a one-time
    code that’s been sent to their phone or email. MFA is more secure than password-based
    authentication but can negatively impact the user experience.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Token-based authentication**: This method involves the user being issued
    a token that they must present to the web application to gain access. Tokens can
    be in the form of a JWT or OAuth token and are often stored in a browser’s cookies
    or local storage. Tokens can easily be revoked, making it easier to maintain security.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Biometric authentication**: This method involves the use of biological characteristics
    such as fingerprints, facial recognition, or voice recognition to verify a user’s
    identity. Biometric authentication is considered to be more secure than other
    methods but can be more expensive to implement.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you are deciding which authentication method to use, it’s crucial to consider
    the level of security required for the web application and the user experience.
    Each of these authentication methods has its pros and cons. It is essential to
    choose the right method for your application.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, if you are building a web application that requires a high level
    of security, you may want to consider using MFA or biometric authentication. And
    of course, biometric authentication is rarely used in public or general-purpose
    web applications. If you are building a simple web application that does not require
    a high level of security, password-based authentication may be safe and sufficient.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will discuss the concept of implementing password security and hashing
    passwords in securing a Flask web application.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing password security and hashing passwords
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In any web application that requires access, passwords are often the first line
    of defense against unauthorized access. As a developer, you will want to ensure
    that passwords are securely managed when building Flask applications. A critical
    component of password management in web applications is to never store passwords
    in plaintext.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, passwords should be hashed, which is a one-way encryption process that
    produces a fixed-length output that cannot be reversed. When a user enters their
    password, it is hashed and compared with the stored hash. If the two hashes match,
    the password is correct. Hashing passwords can help protect against attacks such
    as brute-force and dictionary attacks.
  prefs: []
  type: TYPE_NORMAL
- en: Brute-force attacks involve trying every possible combination of characters
    to find a match, while dictionary attacks involve trying a pre-computed list of
    words. Hashing passwords makes it computationally infeasible for an attacker to
    reverse the hash and discover the original password.
  prefs: []
  type: TYPE_NORMAL
- en: In Flask, you can use a library such as `Flask-Bcrypt` to handle password hashing.
    `Flask-Bcrypt` is a Flask extension that provides `bcrypt` password hashing for
    Flask. `Flask-Bcrypt` provides a simple interface for hashing and checking passwords.
    You can also use `Flask-Bcrypt` to generate random salts for use in password hashing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s quickly run through an example of password hashing using `Flask-Bcrypt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code uses the `Flask Bcrypt` library to hash and check a password.
    It imports the `Bcrypt` class and the `check_password_hash` function, creating
    an instance of `Bcrypt` with the Flask application. When the form is submitted,
    the password is hashed using the `flask_bcrypt` extension, and the hashed password
    is displayed back to the user on the same page. The `render_template` function
    is used to render the HTML templates, and the `Bcrypt` extension is used for secure
    password hashing.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will discuss access and authorization in web application development.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding access and authorization in web application development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Access and authorization in web application development is the process of controlling
    who has access to specific resources and actions within a web application. As
    a developer, you will want to design and ensure that users can only perform actions
    they are authorized to perform and access resources they are authorized to access
    in a web application.
  prefs: []
  type: TYPE_NORMAL
- en: As discussed earlier, authentication is the process of verifying the identity
    of a user. Authorization is the process of determining what a user is allowed
    to do within a web application. When you combine these two mechanisms, you have
    a system that ensures that only authorized users can access sensitive information
    and perform certain actions within a web application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Several different types of access control methods can be used in web application
    development. We will discuss some of them and make specific reference to how Flask
    can handle access and authorization:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Flask-Login` and `Flask-Security`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Flask-OAuthlib`. This extension provides support for `OAuth 1.0a` and `OAuth
    2.0`. `Flask-OAuthlib` makes it easy for developers to implement OAuth in their
    Flask applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Flask-JWT` and `Flask-JWT-Extended`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These extensions provide features such as token generation, verification, and
    expiration, as well as the ability to restrict access to certain resources and
    actions based on the claims contained in the JWT to ensure that it was generated
    by a trusted source and has not been tampered with.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Flask-RBAC`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Flask-RBAC` extension provides features such as role management, permission
    management, and the ability to restrict access to certain resources and actions
    based on the user’s role.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Flask-Policies`. `Flask-Policies` provides features such as policy management,
    enforcement, and the ability to restrict access to certain resources and actions
    based on the conditions specified in the policies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By using these libraries, you can easily handle user roles and permissions and
    restrict access to certain views and routes based on the user’s role. Next, we
    will take a look at how to implement authentication in a Flask web application.
  prefs: []
  type: TYPE_NORMAL
- en: Adding authentication to your Flask application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JWT is a popular method for authentication in modern web applications. A JWT
    is a JSON object that is digitally signed and can be used to authenticate users
    by transmitting claims between parties, such as an authorization server and a
    resource server. In a Flask web application, you can use the `PyJWT` library to
    encode and decode JWTs for authentication.
  prefs: []
  type: TYPE_NORMAL
- en: When a user logs into a Flask application, the backend verifies the user’s credentials,
    such as their email and password, and if they are valid, a JWT is generated and
    sent back to the client. The client stores the JWT in the browser’s local storage
    or as a cookie. For subsequent requests to protected routes and resources, the
    client sends the JWT in the request header.
  prefs: []
  type: TYPE_NORMAL
- en: The backend decodes the JWT to verify the user’s identity, grants or denies
    access to the requested resources, and generates a new JWT for subsequent requests.
    JWT for authentication allows stateless authentication. This means that the authentication
    information is stored in the JWT, which can be passed around between different
    servers, instead of on the server’s memory. This makes it easier to scale the
    application and reduces the risk of data loss or corruption.
  prefs: []
  type: TYPE_NORMAL
- en: JWT authentication also enhances security by using digital signatures to prevent
    data tampering. The signature is generated using a secret key that’s shared between
    the server and the client. The signature ensures that the data in the JWT has
    not been altered in transit. JWT authentication is a secure and efficient method
    for authenticating users in a Flask application.
  prefs: []
  type: TYPE_NORMAL
- en: By implementing JWT authentication in a Flask application, developers can simplify
    the process of authenticating users and reduce the risk of security breaches.
    Let’s examine the backend and frontend implementation of JWT.
  prefs: []
  type: TYPE_NORMAL
- en: Flask backend
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following code defines two Flask endpoints – `/api/v1/login` and `/api/v1/dashboard`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `/api/v1/login` endpoint is for handling user login requests. It takes
    in a JSON request with two properties: `email` and `password`. If either of these
    properties is missing, the function returns a JSON response with a message indicating
    `Missing email or password` and a status code of `400` (Bad Request).'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the function queries the database for a user with the given email. If
    no such user exists, or if the password provided does not match the hashed password
    stored in the database, the function returns a JSON response with a message indicating
    `Invalid email or password` and a status code of `401` (Unauthorized).
  prefs: []
  type: TYPE_NORMAL
- en: Otherwise, the function generates a JWT using the `create_access_token` function
    and returns it as a JSON response, along with a status code of `200` (OK). The
    JWT can be used to authenticate the user in subsequent requests to the backend.
    The `/api/v1/dashboard` endpoint is a protected endpoint that can only be accessed
    by users who have a valid JWT.
  prefs: []
  type: TYPE_NORMAL
- en: The `jwt_required` decorator is used to enforce this restriction. When this
    endpoint is accessed, the JWT is used to extract the user’s identity, which is
    then used to retrieve the user’s `email` from the database. This email is then
    returned as a JSON response, along with a status code of `200` (OK).
  prefs: []
  type: TYPE_NORMAL
- en: React frontend
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following code shows a login form and a dashboard. The `LoginForm` component
    has three states – `email`, `password`, and `accessToken`. When the form is submitted,
    it makes a `POST` request to the `/api/v1/login` endpoint with the email and password
    data, and the response of the request is stored in the `accessToken` state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `Dashboard` component takes an `accessToken` prop and has one state, `email`.
    It makes a `GET` request to the `/api/v1/dashboard` endpoint with an authorization
    header set to `accessToken`, and the response is stored in the `email` state.
    The component displays a message stating `"Welcome to` `dashboard, [email]!"`.
  prefs: []
  type: TYPE_NORMAL
- en: The `LoginForm` component returns either the `Dashboard` component if `accessToken`
    is truthy, or the login form if `accessToken` is `falsy`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will discuss how to identify web application users and manage their
    information.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying system users and managing their information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In most web applications, users are identified by a unique identifier such as
    a username or email address. Typically, in a Flask application, you can use a
    database to store user information, such as usernames, email addresses, and hashed
    passwords.
  prefs: []
  type: TYPE_NORMAL
- en: When a user attempts to log in, the entered credentials (username and password)
    are compared to the information stored in the database. If the entered credentials
    match, the user is authenticated, and a session is created for that user. In Flask,
    you can use the built-in session object to store and retrieve user information.
  prefs: []
  type: TYPE_NORMAL
- en: By using sessions, you can easily identify users in a Flask web application
    and retrieve information about them. However, it’s important to note that sessions
    are vulnerable to session hijacking attacks. So, it’s essential to use secure
    session management techniques such as regenerating session IDs after login and
    using secure cookies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s examine an implementation example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the first line imports the required modules from the
    Flask library. The next line creates an instance of the `Flask` class and assigns
    it to the `app` variable. The `app.secret_key` attribute is set to `'secret_key'`,
    which is used to securely sign the session cookie.
  prefs: []
  type: TYPE_NORMAL
- en: The login function is defined as a POST endpoint at the `api/v1/login` route.
    This endpoint uses the `request.get_json()` method to get the JSON data from the
    request body and extract the values for `email` and `password`. `email` is then
    stored in the session using `session['email'] = email`. The function returns a
    JSON response with a message of `"Login successful"` and a `201` status code,
    indicating the successful creation of a resource.
  prefs: []
  type: TYPE_NORMAL
- en: Then, the dashboard function is defined as a GET endpoint at the `api/v1/dashboard`
    route. It retrieves `email` from the session using `session.get('email')`. The
    function then queries the database for a user with the specified email using `User.query.filter_by(email=email).first()`.
    The `email` and user data (converted into a dictionary using `to_dict()`) are
    returned in a JSON response with a 200 status code, indicating the successful
    retrieval of a resource.
  prefs: []
  type: TYPE_NORMAL
- en: You can also identify users in a Flask application with a token-based authentication
    method. In this method, a token is issued to the user when they log in, and the
    token is stored in the user’s browser as a cookie or placed in local storage.
    This token is then sent with each subsequent request made by the user, and the
    server uses this token to identify the user. JWT is a commonly used token format,
    and libraries such as `Flask-JWT` and `Flask-JWT-Extended` make it easy to implement
    JWT-based authentication in Flask.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will delve deeper into tracking a user’s session in a web application.
  prefs: []
  type: TYPE_NORMAL
- en: Session management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Flask-Session`; on the frontend React side, you can use React’s `localStorage`
    or `sessionStorage`.'
  prefs: []
  type: TYPE_NORMAL
- en: Flask thrives on its simplicity as a framework of choice for Python that makes
    it easy to build small to enterprise-sized web applications. Flask can manage
    user sessions using the built-in session object and some of the available Flask
    extensions contributed by the community members.
  prefs: []
  type: TYPE_NORMAL
- en: A session object is a dictionary-like object that is stored on the server and
    can be accessed by the client via a secure session cookie. To use a session object,
    a *secret key* must be set in the Flask application. This secret key is used to
    encrypt and sign the session data, which is stored in a secure cookie on the client’s
    browser. When a user visits a protected resource, the server verifies the session
    cookie and grants access if the cookie is valid.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s implement session management in a Flask backend and React frontend. We
    will create a counter endpoint that keeps track of the number of times a user
    visited a dashboard page.
  prefs: []
  type: TYPE_NORMAL
- en: Flask backend
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will use `Flask-Session` to store session data and securely manage sessions.
    To use `Flask-Session`, you need to install it first. You can do this by running
    the `pip install flask-session` command in the Terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you’ve installed `Flask-Session`, you need to add the following code to
    your Flask application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code shows a simple implementation of session management in a
    Flask backend:'
  prefs: []
  type: TYPE_NORMAL
- en: The first line imports the Flask module, while the second line imports the `Flask-Session`
    extension.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next few lines create a Flask application object and configure the session
    type to be stored on the filesystem.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Session` object is then initialized with the Flask application object as
    its argument.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `@app.route` decorator creates a route – in this case, `/api/v1/counters`
    – for the `visit_counter` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `visit_counter` function retrieves the current value of the `counter` key
    in the session or sets it to `0` if it doesn’t exist, and then increments the
    value by `1`. The updated value is then returned to the user in the response.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s explore the React frontend part of this implementation.
  prefs: []
  type: TYPE_NORMAL
- en: React Frontend
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can use the Axios library to send HTTP requests to the Flask server. If
    not installed yet, you can install Axios with the `npm install` `axios` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you’ve installed Axios, you can use it to send an HTTP request to the
    Flask server to set or get the session data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code demonstrates the frontend implementation of a React frontend
    that retrieves the visit counter from a Flask backend:'
  prefs: []
  type: TYPE_NORMAL
- en: The first line imports the required libraries – that is, `React` and `axios`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next section declares the `VisitCounter` function component, which returns
    a view for the user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within the component, the state variable counter is initialized using the `useState`
    hook.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `getCounter` function uses the `axios` library to make a `GET` request to
    the `/api/v1/counters` endpoint on the Flask backend. The response from the backend,
    which contains the updated counter value, is then used to update the counter state
    variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The component returns a div that displays the value of the counter and a button
    that, when clicked, triggers the `getCounter` function to retrieve the updated
    counter value from the backend.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we will discuss how to create a password-protected dashboard in a Flask-React
    web application.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a password-protected dashboard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Protecting pages in a web application is essential for maintaining security
    and privacy. By extension, this can help prevent unauthorized access to sensitive
    information. In this section, you will be implementing a protected dashboard page
    in a Flask-React web application.
  prefs: []
  type: TYPE_NORMAL
- en: A dashboard is a user-friendly interface that provides an overview of data and
    information. The data that’s displayed on a dashboard can come from a variety
    of sources, such as databases, spreadsheets, and APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Flask backend
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following code demonstrates an implementation that allows an admin user
    to log in and see a protected dashboard page. We will implement minimalist login
    and logout endpoints that define login and logout functionality and protect the
    `dashboard` endpoint. The application uses the `Flask-Session` library to store
    session data in the filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the `login` endpoint, the application receives a `POST` request with the
    `username` and `password` parameters in the request body in JSON format. The code
    checks if the `username` and `password` parameters match the predefined values
    – that is, `admin` and `secret`. If the values match, the code sets the `logged_in`
    key in the session data to `True`, indicating that the user is logged in.
  prefs: []
  type: TYPE_NORMAL
- en: It returns a JSON response with a message stating `Login successful`. If the
    values don’t match, the code returns a JSON response with a message stating `Login
    failed` and a `401` HTTP status code, indicating unauthorized access.
  prefs: []
  type: TYPE_NORMAL
- en: The `logout` endpoint removes the `logged_in` key from the session data, indicating
    that the user is logged out. It returns a JSON response with a message stating
    `Logout successful`.
  prefs: []
  type: TYPE_NORMAL
- en: The dashboard endpoint checks if the `logged_in` key exists in the session data.
    If it does not, the code returns a JSON response with a message stating `Unauthorized
    access` and a `401` HTTP status code. If the `logged_in` key exists, the code
    returns a JSON response with a message stating `"Welcome to` `the dashboard"`.
  prefs: []
  type: TYPE_NORMAL
- en: React frontend
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following code snippet is a React component that displays a dashboard for
    a user. It uses React hooks, specifically `useState` and `useEffect`, to manage
    its state and update the user interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: When the component is rendered, it makes an HTTP `GET` request to `http://localhost:5000/api/v1/dashboard`
    using the `axios` library. This is done in the `checkLogin` function, which is
    called by the `useEffect` hook when the component is mounted.
  prefs: []
  type: TYPE_NORMAL
- en: If the response from the server is `200 OK`, this means that the user is authorized
    to access the dashboard. The component’s state is updated to reflect this by setting
    `isLoggedIn` to `true` and `message` to the message returned from the server.
    If the response is not `200 OK`, this means the user is unauthorized and `isLoggedIn`
    remains `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the component returns a message that tells the user whether they have
    access to the dashboard. If `isLoggedIn` is `false`, it returns `Unauthorized
    access`. If `isLoggedIn` is `true`, it returns the message from the server.
  prefs: []
  type: TYPE_NORMAL
- en: In this way, you can create a password-protected dashboard that is only accessible
    to authenticated users using React and Flask with added security for your application.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you will learn how to implement flash messages in Flask and React web
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing flash messages in Flask
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Flash messages enhance the user experience in any web application, providing
    informative and timely feedback to users. Flash is used to display status or error
    messages on web pages after a redirect. For instance, after a successful form
    submission, a message can be stored in the flash to display a success message
    on the redirected page.
  prefs: []
  type: TYPE_NORMAL
- en: The flash message is stored in the user’s session, which is a dictionary-like
    object that can store information between requests. With flash messages, you can
    pass information between requests securely and efficiently. This is useful for
    displaying messages that don’t need to persist for a long time or that need to
    be shown only once, such as success or error messages. Since flash messages are
    stored in the user’s session, they are only accessible by the server and are not
    sent to the client in plain text, making them secure.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s modify the login and logout endpoints to show flash messages.
  prefs: []
  type: TYPE_NORMAL
- en: Flask backend
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following code demonstrates the implementation of a flash message system
    with login and logout endpoints. The code starts by importing the necessary modules
    and creating a Flask application. The `app.secret_key = "secret_key"` line sets
    the secret key, which is used to encrypt the flash messages stored in the session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `login` endpoint is defined by the `login` function, which is bound to the
    `/api/v1/login` URL. The function retrieves the `username` and `password` values
    from the JSON data in the request, and checks if they match the predefined values
    of `"admin"` and `"secret"`. If the values match, the user’s session is marked
    as logged in by setting the `logged_in` key in the session, and a flash message
    is set to indicate that the login was successful.
  prefs: []
  type: TYPE_NORMAL
- en: The function then returns a JSON response, indicating the login was successful.
    If the values do not match, a flash message is set, indicating the login failed,
    and a JSON response indicating the login failure is returned. The logout endpoint
    is defined by the `logout` function, which is bound to the `/``api/v1/logout`
    URL.
  prefs: []
  type: TYPE_NORMAL
- en: The function removes the `logged_in` key from the session, indicating that the
    user is no longer logged in, and sets a flash message indicating that the logout
    was successful. A JSON response indicating the logout was successful is then returned.
  prefs: []
  type: TYPE_NORMAL
- en: React frontend
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following snippet demonstrates a React functional component that represents
    the dashboard of a web application handling flash messages from the backend. The
    `Dashboard` component makes use of `useState` and `useEffect` hooks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Dashboard` component keeps track of the following state variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '`isLoggedIn`: A Boolean value indicating if the user is logged in or not. It
    is initially set to `false`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`message`: A string value that represents a message that is displayed on the
    dashboard.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`flashMessage`: A string value that represents a flash message that is displayed
    on the page.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `Dashboard` component has three functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`checkLogin`: An asynchronous function that makes a `GET` request to the `/api/v1/dashboard`
    endpoint to check if the user is logged in or not. If the response status is `200`,
    it updates the `isLoggedIn` state variables to `true` and messages a value of
    `response.data.message`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`handleLogin`: An asynchronous function that makes a `POST` request to the
    `/api/v1/login` endpoint with the provided `username` and `password` values as
    the request body. If the response status is `200`, it updates the `isLoggedIn`
    state variables to `true` and `flashMessage` to the value of `response.data.message`.
    If the response status is not `200`, it updates `flashMessage` to the value of
    `response.data.message`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`handleLogout`: An asynchronous function that makes a `GET` request to the
    `/api/v1/logout` endpoint. If the response status is `200`, it updates the `isLoggedIn`
    state variables to `false` and `flashMessage` to the value of `response.data.message`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `useEffect` hook is used to call the `checkLogin` function when the component
    is mounted.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the component returns a UI, depending on the value of `isLoggedIn:`.
    If the user is not logged in, it displays a message saying `"Unauthorized access"`
    and a `"``Login successful"`.
  prefs: []
  type: TYPE_NORMAL
- en: In this way, you can use flash messages to provide feedback to the user in a
    React application via the frontend, and then use the Flask backend to enhance
    the user’s experience. Overall, flash messages make web applications more interactive
    and user-friendly.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has provided a comprehensive overview of the fundamentals of information
    security and how to secure a Flask web application using authentication and authorization.
    You learned about the best practices and were provided with use cases for implementing
    authentication and authorization in a Flask application. We also discussed different
    types of authentication methods and access control methods.
  prefs: []
  type: TYPE_NORMAL
- en: You explored how to manage user sessions and implement password-protected dashboards.
    Additionally, this chapter has shown you how to use flash messages to provide
    feedback to users of web applications. You are expected to have garnered a solid
    understanding of how to secure a Flask application and be able to implement authentication
    and authorization in your projects.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss how to handle errors in Flask web applications
    with React handling the frontend part of it. We will delve into in-built Flask
    debugging capabilities and learn how to handle custom error messages in React-Flask
    applications.
  prefs: []
  type: TYPE_NORMAL
