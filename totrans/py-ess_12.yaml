- en: Chapter 12. Scripts, Modules, Packages, Libraries, and Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 12 章：脚本、模块、包、库和应用程序
- en: While it's easy to work with Python at the **Read-Evaluate-Print Loop** (**REPL**)
    `>>>` prompt, our real goal is to create Python application files. A Python file
    may be a script, which means it should be able to do some useful work when it's
    executed by the Python program. A file may be a module, which means that it is
    designed to be imported to provide useful definitions. A directory of Python modules
    is a **package**. These are formal definitions, implemented by the language.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在与 Python 的 **读取-评估-打印循环**（**REPL**）`>>>` 提示符一起工作时很容易，但我们的真正目标是创建 Python 应用程序文件。一个
    Python 文件可能是一个脚本，这意味着当它被 Python 程序执行时应该能够做一些有用的工作。一个文件可能是一个模块，这意味着它被设计为导入以提供有用的定义。Python
    模块的目录是一个 **包**。这些都是由语言实现的正式定义。
- en: 'More generic terms like **library**, **application**, or **framework** aren''t
    formalized by the language. We have ways to implement these common concepts in
    Python. We can think of a collection of modules or packages as a library. The
    *Python Standard Library*, for example, is a large collection of modules and packages.
    An "application" will be at least a script. A more complex application may involve
    a script plus several additional modules and packages. A framework will be a Python
    application into which we''ll inject our customized modules or packages. Many
    frameworks will also include non-Python files: a web framework may include a great
    deal of HTML and CSS; a GUI framework may include image files and fonts.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 更通用的术语如 **库**、**应用程序**或 **框架** 并没有由语言正式化。我们有在 Python 中实现这些常见概念的方法。我们可以将模块或包的集合视为库。例如，*Python
    标准库*是一个包含大量模块和包的大集合。一个“应用程序”至少是一个脚本。更复杂的应用程序可能涉及脚本以及几个额外的模块和包。框架将是一个 Python 应用程序，我们将向其中注入定制的模块或包。许多框架还将包括非
    Python 文件：一个网络框架可能包括大量的 HTML 和 CSS；一个 GUI 框架可能包括图像文件和字体。
- en: We'll look at creating and running script files. We'll also look at creating
    modules and packages of modules. Finally, we'll look at a very clever Python feature
    that allows us to write a script that can also be used as a module. This design
    pattern allows us to build composite applications that are based on other applications.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨创建和运行脚本文件。我们还将探讨创建模块和模块包。最后，我们将探讨一个非常巧妙的 Python 功能，它允许我们编写既可以作为脚本使用也可以作为模块使用的脚本。这种设计模式允许我们构建基于其他应用程序的复合应用程序。
- en: Script file rules
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 脚本文件规则
- en: 'A Python script file must adhere to only one simple rule: *it must be pure
    text*. In some cases, a poorly-chosen filename can lead to problems, so we''ll
    add two recommendations that are often helpful:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Python 脚本文件必须遵循一条简单的规则：*它必须是纯文本格式*。在某些情况下，一个不恰当的文件名可能会导致问题，因此我们将提供两条经常有帮助的建议：
- en: The content must be pure text; ideally encoded in UTF-8, although ASCII is also
    popular.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内容必须是纯文本；理想情况下使用 UTF-8 编码，尽管 ASCII 也很流行。
- en: The filename should follow the Python identifier rules. It should start with
    a letter and use only letters, digits, and the `_` character. Filenames that begin
    and end with `__` (two underscores) are reserved and have special meanings for
    Python.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件名应遵循 Python 标识符规则。它应以字母开头，并仅使用字母、数字和下划线 `_` 字符。以 `__`（两个下划线）开头和结尾的文件名是保留的，并且对
    Python 有特殊含义。
- en: The extension should be `.py`.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展名应为 `.py`。
- en: The two additional recommendations are essential for writing modules and packages,
    but are not required to write a simple script.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这两条额外的建议对于编写模块和包是必不可少的，但编写简单的脚本并不需要。
- en: 'A script is simply a sequence of statements; it''s identical to what we might
    do at the REPL prompt with only one difference: a script has no implicit printed
    output. We must use the `print()` function in a script to see any results. In
    larger applications, we often use the `logging` module to produce more sophisticated
    output. In some cases, we''ll carefully replace all the `print()` functions we
    put into an early technology spike with `logging.debug()` functions as our application
    matures.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本简单地说是一系列语句；它与我们在 REPL 提示符 `>>>` 中可能执行的操作相同，只有一个区别：脚本没有隐式的打印输出。我们必须在脚本中使用 `print()`
    函数来查看任何结果。在更大的应用程序中，我们经常使用 `logging` 模块来生成更复杂的输出。在某些情况下，随着应用程序的成熟，我们将仔细替换我们放入早期技术激增中的所有
    `print()` 函数，用 `logging.debug()` 函数替换。
- en: To run a script, we need to provide it as input to the Python program. We'll
    look at three common ways to do this.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行脚本，我们需要将其作为输入提供给 Python 程序。我们将探讨三种常见的方法来实现这一点。
- en: Running a script by the filename
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过文件名运行脚本
- en: The most common way to run a script is to provide the filename to the Python
    command. Let's assume we have a file with the unpleasant name of `ch12_script1.py`
    in a directory named `Chapter_12`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本的常见方式是将文件名提供给Python命令。假设我们在名为`Chapter_12`的目录中有一个名为`ch12_script1.py`的文件。
- en: In Linux and Mac OS X, the full name will be `Chapter_12/ch12_script1.py`. In
    Windows, the full filename will be `Chapter_12\ch12_script1.py`. We'll stick with
    the Linux standard filenames for the remaining examples.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux和Mac OS X中，完整名称将是`Chapter_12/ch12_script1.py`。在Windows中，完整文件名将是`Chapter_12\ch12_script1.py`。在剩余的示例中，我们将坚持使用Linux标准的文件名。
- en: 'Here''s how we can run a script by giving the filename:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们通过提供文件名来运行脚本的方式：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This output shows the OS prompt. The `python3` command that we entered is highlighted.
    The prompts and the outputs from the script are also shown. This example is typical
    for an OS that uses Python 2 internally; we have to distinguish our new Python
    3 from the OS's internal `python` command.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出显示了操作系统提示符。我们输入的`python3`命令被突出显示。提示符和脚本的输出也被显示出来。这个例子对于使用Python 2作为内部语言的操作系统来说是典型的；我们必须区分我们新的Python
    3和操作系统的内部`python`命令。
- en: The application prompted us, and we entered a temperature of 8\. The output
    shows that 8°C is about 46°F. We'll need to wear a coat.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序提示我们，我们输入了8摄氏度。输出显示8°C大约是46°F。我们需要穿上外套。
- en: 'The script file, `ch12_script1.py`, looks like this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本文件`ch12_script1.py`看起来像这样：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The script uses the `input()` function to prompt an interactive user at the
    console. The output is displayed with the simple `print()` function.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本使用`input()`函数在控制台提示交互式用户。输出通过简单的`print()`函数显示。
- en: We've kept the script small to emphasize ways that scripts can be run. There
    are numerous **user experience** (**UX**) issues with this, but that is not the
    focus of this section.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们保持脚本较小，以强调脚本可以运行的方式。与此相关的用户体验（UX）问题有很多，但这不是本节的重点。
- en: Running a script by its module name
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过模块名称运行脚本
- en: In most cases, our scripts can either be installed in the `site-packages` directory
    inside the Python library, or we can extend the Python path using the `PYTHONPATH`
    environment variable to include the location of our scripts. Either of these approaches
    makes a script file visible on Python's search path.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，我们的脚本可以安装在Python库中的`site-packages`目录内，或者我们可以使用`PYTHONPATH`环境变量扩展Python路径，包括脚本的位置。这两种方法中的任何一种都可以使脚本文件在Python的搜索路径上可见。
- en: To install a script in `site-packages`, we can rely on Python's `distutils`
    package. We'll create a `setup.py` file, which describes the module we'd like
    to install. We can then run `python3 setup.py` `install` to have our module placed
    into the `site-packages` directory. Installers like `pip` and `easy-install` require
    use of `distutils` following this standard pattern.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要在`site-packages`中安装脚本，我们可以依赖Python的`distutils`包。我们将创建一个`setup.py`文件，该文件描述了我们想要安装的模块。然后我们可以运行`python3
    setup.py install`，将我们的模块放置到`site-packages`目录中。像`pip`和`easy-install`这样的安装程序需要按照这个标准模式使用`distutils`。
- en: We can also locate the `site-packages` directory and manually copy our module
    into that directory. This location varies from OS to OS. This directory is the
    last item in the `sys.path` variable.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以定位`site-packages`目录，并将我们的模块手动复制到该目录。这个位置因操作系统而异。这个目录是`sys.path`变量中的最后一个项目。
- en: Setting the `PYTHONPATH` environment variable is another alternative. We can
    use the Linux `export` command to make a change to environment variables. We often
    put this in our `~/.bash_profile` file. For Windows, we have to make a change
    to the advanced system settings where the environment variables are set. We can
    easily create private libraries with many modules, made visible via the `PYTHONPATH`
    variable.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 设置`PYTHONPATH`环境变量是另一种选择。我们可以使用Linux的`export`命令来更改环境变量。我们经常将其放在`~/.bash_profile`文件中。对于Windows，我们必须更改设置环境变量的高级系统设置。我们可以通过`PYTHONPATH`变量轻松创建包含许多模块的私有库，使其可见。
- en: 'Once our module is visible on Python''s search path, we can execute the module
    like this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的模块在Python的搜索路径上可见，我们可以像这样执行模块：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'When we provide the `-m` option, we''re naming a module to be executed. In
    this example, we''ve used a qualified name: `Chapter_12` is a package and `ch12_script1`
    is the module within that package. We''ll look at packages in the later sections;
    packages are essentially the directories in which module files can be found.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们提供`-m`选项时，我们正在命名一个要执行的模块。在这个例子中，我们使用了一个限定名称：`Chapter_12`是一个包，`ch12_script1`是这个包内的模块。我们将在后面的部分中查看包；包基本上是模块文件可以找到的目录。
- en: Running a script using OS shell rules
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用操作系统shell规则运行脚本
- en: The third way that we can run a script is by making the script file executable
    and including an OS association between the script file and the Python3 program.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们运行脚本的第三种方式是通过使脚本文件可执行，并在脚本文件和Python3程序之间建立操作系统关联。
- en: 'In Linux and Mac OS X, the file association is set by the first line of the
    file. We''ll often use something like this as the first line in a file, to associate
    a given `.py` file and the Python3 program:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux和Mac OS X中，文件关联是通过文件的第一行设置的。我们经常将类似以下内容作为文件的第一行，以关联给定的`.py`文件和Python3程序：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This will use the OS `env` program to locate and start the `python3` environment.
    The shell will provide the entire file as input to the program named on a `#!`
    line. This means that the `env` program will be started with the script file as
    input. The `env` program will prepare the environment and then hand the file to
    the Python3 program.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使用操作系统的`env`程序来定位并启动`python3`环境。shell将整个文件作为输入提供给名为`#!`行的程序。这意味着`env`程序将以脚本文件作为输入启动。`env`程序将准备环境，然后将文件交给Python3程序。
- en: 'To mark a file as executable in Linux and Mac OS X, we use the `chmod +x` command.
    We can do this to mark our script as executable:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Linux和Mac OS X中将文件标记为可执行，我们使用`chmod +x`命令。我们可以这样做来标记我们的脚本为可执行：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This command will add the execute, `x`, option to the file's mode. When we do
    an `ls -l`, we'll see this as part of the file's details.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将执行`x`选项添加到文件的模式中。当我们执行`ls -l`时，我们会在文件详情中看到这一点。
- en: In Windows, all files are considered executable. The association between file
    extension and program is done through the Windows Control Panel. The setting was
    put in place when you installed Python.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows中，所有文件都被认为是可执行的。文件扩展名与程序的关联是通过Windows控制面板完成的。这个设置是在你安装Python时设置的。
- en: 'Once the file is marked as executable, we can run it simply by providing the
    name:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦文件被标记为可执行，我们只需提供名称就可以运行它：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Under Windows, the file extension of `.py` is bound to the Python program, and
    Windows will launch Python providing this filename as input. The binding of filename
    to script is outside the application.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows中，`.py`文件扩展名绑定到Python程序，Windows将启动Python，并将此文件名作为输入。文件名与脚本的绑定在应用程序之外。
- en: Under Linux and Mac OS X, the processing is based on the magical first line
    of the file. The Linux shell checks the file's mode to see that it's executable.
    It then reads the first few bytes of the file. In this case, the first few bytes
    are `#!`, which marks the file as a script. The first full line of a script includes
    the command that must be used to process this script. In this case, the command
    is `/usr/bin/env python3`. The shell launches this program with the given file
    as input.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux和Mac OS X中，处理基于文件的神奇第一行。Linux shell检查文件的模式，以确认它是可执行的。然后它读取文件的前几个字节。在这种情况下，前几个字节是`#!`，这标志着文件是一个脚本。脚本的第一行完整地包含了必须用于处理此脚本命令。在这种情况下，命令是`/usr/bin/env
    python3`。shell使用这个程序作为输入启动这个程序。
- en: Choosing good script names
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择好的脚本名称
- en: Script names should be kept short and meaningful. As with filenames, it's generally
    best practice to avoid complex prefixes and suffixes. The Linux or Windows DOS
    commands provide some guidance on what makes a good (and bad) name for a script.
    One of the best examples is the `git` command, which has numerous subcommands.
    Rather than invent dozens of complex-looking names, **git** uses a simple command
    name as a prefix.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本名称应保持简短且具有意义。与文件名一样，通常最好避免复杂的前缀和后缀。Linux或Windows DOS命令提供了一些关于什么使脚本名称好（和不好）的指导。最好的例子之一是`git`命令，它有众多的子命令。而不是发明几十个看起来复杂的名称，**git**使用一个简单的命令名作为前缀。
- en: The `argparse` module, used for parsing command-line arguments, supports this
    nicely. We can define a few common arguments that apply to all subcommands. We
    can also define arguments that are unique to each subcommand.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 用于解析命令行参数的`argparse`模块很好地支持了这一点。我们可以定义一些适用于所有子命令的常见参数。我们还可以定义仅适用于每个子命令的独特参数。
- en: In order to keep the code for this book organized by the publishing pipeline,
    the script names are long. The redundancy in these names (`Chapter_12/ch12_...`)
    is not the best practice, and should be avoided where possible. As with variable
    names and function names, script names should be kept reasonably short and meaningful.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持这本书的代码按照出版流程组织，脚本名称很长。这些名称中的冗余（`Chapter_12/ch12_...`）不是最佳实践，应尽可能避免。与变量名和函数名一样，脚本名称应保持合理短且有意义。
- en: Creating a reusable module
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建可重用模块
- en: In Python, the module is the unit of software reuse. When we have a feature
    that must appear in more than one script, we'll put this feature into a module
    and import that module into each script that shares the feature.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，模块是软件重用的单元。当我们有一个必须出现在多个脚本中的特性时，我们会把这个特性放入一个模块中，并将该模块导入到每个共享该特性的脚本中。
- en: 'It''s important to note two slightly different senses of the word "reuse" as
    follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意“重用”这个词的两个略有不同的含义如下：
- en: We can define a class hierarchy to achieve localized reuse within an application.
    Inheritance is an elegant way to share code among related objects. Often we'll
    define all of these related classes in a single module file.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过定义类层次结构在应用程序内实现局部重用。继承是共享相关对象代码的一种优雅方式。我们通常会在单个模块文件中定义所有这些相关类。
- en: We can define a module to achieve a less local reuse across applications.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以定义一个模块以实现跨应用程序的较少局部重用。
- en: To create a module that can be imported, we merely have to be sure that a Python
    file is visible in a directory that's part of the Python search path. Since the
    local directory is always visible, we can create a module simply by creating a
    file in the current working directory.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个可导入的模块，我们只需确保Python文件可见于Python搜索路径的一部分目录中。由于本地目录总是可见的，我们只需在当前工作目录中创建一个文件即可创建一个模块。
- en: A module designed for import should consist mostly of `import`, `class`, and
    `def` statements. We can also use assignment statements to create module global
    variables, but we need to be cautious of how much processing is done. Any name
    that's created (via assignment, `class`, `def`, or `import`) will be in that module's
    namespace.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 设计用于导入的模块应主要由`import`、`class`和`def`语句组成。我们也可以使用赋值语句来创建模块全局变量，但我们需要谨慎处理多少工作。通过赋值、`class`、`def`或`import`创建的任何名称都将位于该模块的命名空间中。
- en: A module is only imported once. The `import` implementation checks a global
    cache of loaded modules, visible as `sys.modules`, to see if the module is known.
    Because of this, a module that actually does some kind of processing will only
    do it once. After that, the import is ignored. This behavior makes it easy to
    create a global **Singleton** object inside an imported module.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 模块只导入一次。`import`实现会检查全局已加载模块的缓存，即`sys.modules`，以查看模块是否已知。正因为如此，实际上执行某种处理的模块只会这样做一次。之后，导入就会被忽略。这种行为使得在导入模块内部创建全局**单例**对象变得容易。
- en: Examples of modules that do significant processing on `import` are `this` and
    `antigravity`. When we execute `import this` or `import antigravity`, these modules
    will immediately do some interesting processing. After having been imported once,
    they won't do this again. While handy in some specialized situations, it's not
    a general pattern to follow.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在`import`时进行大量处理的模块示例有`this`和`antigravity`。当我们执行`import this`或`import antigravity`时，这些模块将立即执行一些有趣的处理。一旦被导入一次，它们就不会再这样做。虽然在一些特定情况下很有用，但这不是一个通用的模式。
- en: Tip
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: We generally expect an `import` statement to provide definitions of classes,
    functions, and module global variables.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常期望一个`import`语句提供类、函数和模块全局变量的定义。
- en: We don't generally expect an `import` statement to do useful processing.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常不期望`import`语句执行有用的处理。
- en: 'A module may define a unique exception. We might want to create a generic exception
    class named `Error` in a module. It would look like this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 模块可以定义一个独特的异常。我们可能想在模块中创建一个名为`Error`的通用异常类。它可能看起来像这样：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Because this name will be qualified by the module name when the module is imported,
    we are able to reference this exception via `some_module.Error`. It might look
    like this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 因为当模块被导入时，这个名称将由模块名称限定，所以我们能够通过`some_module.Error`来引用这个异常。它可能看起来像这样：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The module name, `some_module`, acts as a nice qualifier to show the origin
    of the `Error` class definition. We don't need to give the `Error` class a more
    complex, globally unique name.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 模块名`some_module`作为`Error`类定义来源的一个很好的限定符。我们不需要给`Error`类一个更复杂、全局唯一的名称。
- en: Creating a hybrid library/application module
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建混合库/应用程序模块
- en: 'A script may import modules, perhaps define some functions or classes, but
    it will always do the relevant processing. Our first example script had just three
    lines of relevant processing: two assignment statements, and a function statement
    that printed a result. This shows the Pythonic ideal of having programs without
    any boilerplate; we try to avoid syntax that''s just overhead.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本可以导入模块，也许定义一些函数或类，但它总是会执行相关的处理。我们的第一个示例脚本只有三条相关的处理语句：两个赋值语句和一个打印结果的函数声明。这展示了
    Python 的理想，即没有任何样板代码的程序；我们试图避免只是开销的语法。
- en: A possible downside of a perfectly clean approach to scripting is that it's
    difficult to create unit tests. Each unit test would have to invoke the script
    as a subprocess; something that can involve quite a bit of OS overhead. The goal
    of unit testing is to isolate each unit—each function, class, module, package,
    or script—so that it can be tested separately. Having the OS launch the script
    file doesn't seem to be properly isolated.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 完美清洁脚本方法的可能缺点是创建单元测试困难。每个单元测试都必须作为子进程调用脚本；这可能涉及相当多的操作系统开销。单元测试的目标是隔离每个单元——每个函数、类、模块、包或脚本——以便可以单独测试。让操作系统启动脚本文件似乎并没有得到适当的隔离。
- en: Also, as an application matures, a good script may become a component in a larger,
    and more comprehensive, application. It can become difficult to create a composite
    application from a script file. It's far easier to create composite processes
    from functions or classes.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，随着应用程序的成熟，一个好的脚本可能成为更大、更全面的应用程序中的一个组件。从脚本文件中创建复合应用程序可能会变得困难。从函数或类中创建复合过程则容易得多。
- en: 'This leads to the following suggested structure for a script:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了对脚本以下建议的结构：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We''ve taken our script and wrapped it with a `def` statement to make a function.
    We''ve then written an `if` statement that distinguishes between a main script
    and an imported module by examining the `__name__` variable. The `if` statement
    makes the following conditions:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将脚本用 `def` 语句包装起来，使其成为一个函数。然后我们编写了一个 `if` 语句，通过检查 `__name__` 变量来区分主脚本和导入的模块。`if`
    语句做出以下条件：
- en: When a module is imported, Python sets the global variable `__name__` to the
    actual module name
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当模块被导入时，Python 将全局变量 `__name__` 设置为实际的模块名称
- en: When run as a main script, Python sets the global variable `__name__` to `__main__`
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当作为主脚本运行时，Python 将全局变量 `__name__` 设置为 `__main__`
- en: 'This pattern can be used to write library modules which run their own unit
    tests. We can include the following in a library module that is never used as
    a main script:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式可以用来编写运行其自身单元测试的库模块。我们可以在一个永远不会作为主脚本的库模块中包含以下内容：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This will run all of the unit tests that are embedded in docstrings. We'll look
    more closely at testing in [Chapter 14](ch14.html "Chapter 14. Fit and Finish
    – Unit Testing, Packaging, and Documentation"), *Fit and Finish – Unit Testing,
    Packaging, and Documentation*.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这将运行嵌入在文档字符串中的所有单元测试。我们将在第 14 章[第 14 章。完善 – 单元测试、打包和文档](ch14.html "Chapter 14. Fit
    and Finish – Unit Testing, Packaging, and Documentation")中更详细地讨论测试，*完善 – 单元测试、打包和文档*。
- en: Creating a package
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建包
- en: A package is a directory that contains module files plus one additional file.
    Each package must have an `__init__.py` file. This file must be present and is
    often empty.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 包是一个包含模块文件和一个附加文件的目录。每个包都必须有一个 `__init__.py` 文件。此文件必须存在，通常是空的。
- en: 'The poem, *Zen of Python*, by Tim Peters, offers the following advice:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Tim Peters 的诗歌《Python 之禅》提供了以下建议：
- en: '*Flat is better than nested.*'
  id: totrans-80
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*扁平优于嵌套*。'
- en: The idea is to organize Python applications into a flat collection of modules
    to the greatest extent possible. A deeply-nested, complex hierarchy of packages
    isn't considered helpful.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 理想是尽可能地将 Python 应用程序组织成模块的扁平集合。深度嵌套、复杂的包层次结构并不被认为是有帮助的。
- en: We can use a package in two ways. We can import a module that's part of a package.
    The standard library, for example, has an XML package with several XML parser
    modules. We can use import `xml.etree` to import the `etree` module from the XML
    package. In this case, the `__init__.py` file has a comment and a list of sub-packages.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用两种方式使用包。我们可以导入包的一部分模块。例如，标准库有一个包含几个 XML 解析模块的 XML 包。我们可以使用 `import xml.etree`
    从 XML 包中导入 `etree` 模块。在这种情况下，`__init__.py` 文件有一个注释和子包列表。
- en: In other cases, we can import the package, as a whole, as if the package were
    a module. When we write import collections, for example, we're really importing
    the module `collections/__init__.py`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他情况下，我们可以将包作为一个模块整体导入。例如，当我们编写 `import collections` 时，实际上我们导入的是模块 `collections/__init__.py`。
- en: The `__init__.py` file is a top-level module for the package as a whole. It
    can be empty, in which case we can only pick specific modules from within the
    package. Or the `__init__.py` file may have content, allowing us to import the
    package as a single complex structure.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init__.py` 文件是整个包的最高级模块。它可以是一个空文件，在这种情况下，我们只能从包内部选择特定的模块。或者 `__init__.py`
    文件可能包含内容，允许我们将整个包导入为一个单一的复杂结构。'
- en: Designing alternative implementations
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计替代实现
- en: We can easily offer alternative implementations of a given feature. If we want
    more speed, more accuracy, or less memory use, we should be able to import an
    alternative definition of a given library.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松地提供给定功能的替代实现。如果我们想要更高的速度、更高的精度或更少的内存使用，我们应该能够导入给定库的替代定义。
- en: 'We can compare the `math` and `cmath` modules for a concrete example of this
    principle. Here''s an example of how they differ:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过比较 `math` 和 `cmath` 模块来具体说明这个原则。以下是他们之间差异的一个例子：
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `math` module includes a square root function, which we used as `math.sqrt()`.
    This produces only real-valued results, and must raise an exception when confronted
    with an expression that's not real-valued.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`math` 模块包含一个平方根函数，我们使用 `math.sqrt()` 来调用它。这个函数只产生实数值结果，并且当遇到非实数值的表达式时必须抛出异常。'
- en: The `cmath` module also includes a square root function. The `cmath.sqrt()`
    function can return complex values instead of raising an exception. Since the
    packages are so similar, we can substitute one for the other in a variety of ways.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`cmath` 模块也包含一个平方根函数。`cmath.sqrt()` 函数可以返回复数值而不是抛出异常。由于这两个包非常相似，我们可以以多种方式相互替换。'
- en: Both of these modules offer a similar set of function definitions. The components
    within the module have the same names. The modules, which are namespaces, have
    different names to distinguish the origin of a definition.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个模块提供了一组类似的函数定义。模块内的组件具有相同的名称。作为命名空间的模块有不同的名称，以区分定义的来源。
- en: 'This technique is often used to support different platforms. We can create
    a package with platform-specific modules within the package. The package''s top-level
    `__init__.py` can choose which module to import and provide the platform-specific
    definitions. We can also use this to write enterprise software that must run in
    different environments: development, quality assurance, and final production.
    A single package can include different configuration modules. The standard library
    `os` package demonstrates this concept.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术通常用于支持不同的平台。我们可以在包内部创建具有平台特定模块的包。包的最高级 `__init__.py` 可以选择导入哪个模块并提供平台特定的定义。我们也可以使用这种方法来编写必须在不同环境中运行的商业软件：开发、质量保证和最终生产。一个包可以包含不同的配置模块。标准库中的
    `os` 包展示了这个概念。
- en: Seeing the package search path
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看包搜索路径
- en: 'The Python search path can be seen by importing the `sys` package to see `sys.path`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过导入 `sys` 包来查看 Python 的搜索路径 `sys.path`：
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We've elided a number of lines from this output to show the essentials of how
    the standard library fits into the way we develop Python code. This list of places
    to search for modules is built by the `sites` package when Python starts running.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经省略了输出中的许多行，以展示标准库如何融入我们开发 Python 代码的方式。这个搜索模块的位置列表是由 `sites` 包在 Python 启动时构建的。
- en: The zero-length directory name, `''`, is first. This means that the current
    working directory is the preferred place to locate modules. This allows us to
    import our own modules from the local directory. After our local directory, a
    number of locations are searched, ending with the `.../site-packages` directory.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 零长度目录名 `''` 是第一个。这意味着当前工作目录是首选的模块定位位置。这允许我们从本地目录导入我们自己的模块。在我们的本地目录之后，会搜索多个位置，最后以
    `.../site-packages` 目录结束。
- en: The next group of names, starting with `setuptools-2.0.2-py3.3.egg`, is a list
    of all external packages added to this installation in the form of downloaded
    `.egg` files. The exact list will vary from installation to installation. These
    names are created by the `pip` and `easy_install` programs.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的名称组，从 `setuptools-2.0.2-py3.3.egg` 开始，是所有以下载的 `.egg` 文件形式添加到这个安装中的外部包的列表。确切列表会因安装而异。这些名称是由
    `pip` 和 `easy_install` 程序创建的。
- en: When we set the `PYTHONPATH` environment variable, those names are spliced into
    the path *after* the various installed packages. The final group of names, starting
    with `python33.zip`, is a common list of modules that come with Python. The last
    entry lists the generic site-packages portion of the library. If you download
    a package and run the package's `setup.py` script, it is copied into this directory
    where it will be found by Python.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们设置`PYTHONPATH`环境变量时，这些名称会被拼接到各种已安装包的路径*之后*。以`python33.zip`开始的最后一组名称是Python附带的一些常见模块列表。最后一项列出的是库的通用site-packages部分。如果你下载了一个包并运行该包的`setup.py`脚本，它将被复制到这个目录中，Python将会找到它。
- en: The `sys.path` object is a proper mutable list. We can dynamically change the
    path in our script files. This can make it difficult to determine all the modules
    that a script depends on. It's almost always clearer to explicitly depend on the
    modules being properly installed or the `PYTHONPATH` environment variable being
    set.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`sys.path`对象是一个正确的可变列表。我们可以在脚本文件中动态地更改路径。这可能会使得确定脚本所依赖的所有模块变得困难。几乎总是更清晰的是明确地依赖于正确安装的模块或设置`PYTHONPATH`环境变量。'
- en: Summary
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we've looked at the higher-level ways to organize software.
    A function contains many statements, a class contains many method functions, and
    a module can contain many classes and functions. A package can contain many modules.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了组织软件的高级方法。一个函数包含许多语句，一个类包含许多方法函数，一个模块可以包含许多类和函数。一个包可以包含许多模块。
- en: We've looked at a number of ways of executing a Python script. We have a great
    deal of flexibility because there are many contexts in which we need to execute
    software. Generally, we'll focus on executing Python programs by module name rather
    than by filename. The distinction is tiny. Since a module must be on the search
    path, we can create a directory that contains the script and any supporting modules
    and libraries, and ensure that this directory is named on the `PYTHONPATH`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了执行Python脚本的各种方法。由于我们需要在许多不同的上下文中执行软件，所以我们有很大的灵活性。通常，我们会关注通过模块名而不是文件名来执行Python程序。这种区别很小。由于一个模块必须在搜索路径上，我们可以创建一个包含脚本以及任何支持模块和库的目录，并确保这个目录被命名为`PYTHONPATH`。
- en: We've looked at how we can create library modules that contain definitions and
    will be imported into other scripts. This is our primary method of reuse. We've
    also looked at how we can create a script, that is reusable as a library module.
    This supports unit testing as well as maturation of our software.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了如何创建包含定义的库模块，这些模块将被导入到其他脚本中。这是我们主要的重用方法。我们还探讨了如何创建一个作为库模块可重用的脚本。这支持单元测试以及我们软件的成熟。
- en: In [Chapter 13](ch13.html "Chapter 13. Metaprogramming and Decorators"), *Metaprogramming
    and Decorators*, we'll look at some more advanced programming techniques. These
    will allow us to create more sophisticated class and function definitions. We
    can use these design patterns to write more flexible and more reusable software.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第13章](ch13.html "第13章。元编程和装饰器")中，我们将探讨一些更高级的编程技术。这些技术将使我们能够创建更复杂的类和函数定义。我们可以使用这些设计模式来编写更灵活和可重用的软件。
