- en: Chapter 12. Scripts, Modules, Packages, Libraries, and Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While it's easy to work with Python at the **Read-Evaluate-Print Loop** (**REPL**)
    `>>>` prompt, our real goal is to create Python application files. A Python file
    may be a script, which means it should be able to do some useful work when it's
    executed by the Python program. A file may be a module, which means that it is
    designed to be imported to provide useful definitions. A directory of Python modules
    is a **package**. These are formal definitions, implemented by the language.
  prefs: []
  type: TYPE_NORMAL
- en: 'More generic terms like **library**, **application**, or **framework** aren''t
    formalized by the language. We have ways to implement these common concepts in
    Python. We can think of a collection of modules or packages as a library. The
    *Python Standard Library*, for example, is a large collection of modules and packages.
    An "application" will be at least a script. A more complex application may involve
    a script plus several additional modules and packages. A framework will be a Python
    application into which we''ll inject our customized modules or packages. Many
    frameworks will also include non-Python files: a web framework may include a great
    deal of HTML and CSS; a GUI framework may include image files and fonts.'
  prefs: []
  type: TYPE_NORMAL
- en: We'll look at creating and running script files. We'll also look at creating
    modules and packages of modules. Finally, we'll look at a very clever Python feature
    that allows us to write a script that can also be used as a module. This design
    pattern allows us to build composite applications that are based on other applications.
  prefs: []
  type: TYPE_NORMAL
- en: Script file rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A Python script file must adhere to only one simple rule: *it must be pure
    text*. In some cases, a poorly-chosen filename can lead to problems, so we''ll
    add two recommendations that are often helpful:'
  prefs: []
  type: TYPE_NORMAL
- en: The content must be pure text; ideally encoded in UTF-8, although ASCII is also
    popular.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The filename should follow the Python identifier rules. It should start with
    a letter and use only letters, digits, and the `_` character. Filenames that begin
    and end with `__` (two underscores) are reserved and have special meanings for
    Python.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The extension should be `.py`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The two additional recommendations are essential for writing modules and packages,
    but are not required to write a simple script.
  prefs: []
  type: TYPE_NORMAL
- en: 'A script is simply a sequence of statements; it''s identical to what we might
    do at the REPL prompt with only one difference: a script has no implicit printed
    output. We must use the `print()` function in a script to see any results. In
    larger applications, we often use the `logging` module to produce more sophisticated
    output. In some cases, we''ll carefully replace all the `print()` functions we
    put into an early technology spike with `logging.debug()` functions as our application
    matures.'
  prefs: []
  type: TYPE_NORMAL
- en: To run a script, we need to provide it as input to the Python program. We'll
    look at three common ways to do this.
  prefs: []
  type: TYPE_NORMAL
- en: Running a script by the filename
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most common way to run a script is to provide the filename to the Python
    command. Let's assume we have a file with the unpleasant name of `ch12_script1.py`
    in a directory named `Chapter_12`.
  prefs: []
  type: TYPE_NORMAL
- en: In Linux and Mac OS X, the full name will be `Chapter_12/ch12_script1.py`. In
    Windows, the full filename will be `Chapter_12\ch12_script1.py`. We'll stick with
    the Linux standard filenames for the remaining examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how we can run a script by giving the filename:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This output shows the OS prompt. The `python3` command that we entered is highlighted.
    The prompts and the outputs from the script are also shown. This example is typical
    for an OS that uses Python 2 internally; we have to distinguish our new Python
    3 from the OS's internal `python` command.
  prefs: []
  type: TYPE_NORMAL
- en: The application prompted us, and we entered a temperature of 8\. The output
    shows that 8°C is about 46°F. We'll need to wear a coat.
  prefs: []
  type: TYPE_NORMAL
- en: 'The script file, `ch12_script1.py`, looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The script uses the `input()` function to prompt an interactive user at the
    console. The output is displayed with the simple `print()` function.
  prefs: []
  type: TYPE_NORMAL
- en: We've kept the script small to emphasize ways that scripts can be run. There
    are numerous **user experience** (**UX**) issues with this, but that is not the
    focus of this section.
  prefs: []
  type: TYPE_NORMAL
- en: Running a script by its module name
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In most cases, our scripts can either be installed in the `site-packages` directory
    inside the Python library, or we can extend the Python path using the `PYTHONPATH`
    environment variable to include the location of our scripts. Either of these approaches
    makes a script file visible on Python's search path.
  prefs: []
  type: TYPE_NORMAL
- en: To install a script in `site-packages`, we can rely on Python's `distutils`
    package. We'll create a `setup.py` file, which describes the module we'd like
    to install. We can then run `python3 setup.py` `install` to have our module placed
    into the `site-packages` directory. Installers like `pip` and `easy-install` require
    use of `distutils` following this standard pattern.
  prefs: []
  type: TYPE_NORMAL
- en: We can also locate the `site-packages` directory and manually copy our module
    into that directory. This location varies from OS to OS. This directory is the
    last item in the `sys.path` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the `PYTHONPATH` environment variable is another alternative. We can
    use the Linux `export` command to make a change to environment variables. We often
    put this in our `~/.bash_profile` file. For Windows, we have to make a change
    to the advanced system settings where the environment variables are set. We can
    easily create private libraries with many modules, made visible via the `PYTHONPATH`
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once our module is visible on Python''s search path, we can execute the module
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'When we provide the `-m` option, we''re naming a module to be executed. In
    this example, we''ve used a qualified name: `Chapter_12` is a package and `ch12_script1`
    is the module within that package. We''ll look at packages in the later sections;
    packages are essentially the directories in which module files can be found.'
  prefs: []
  type: TYPE_NORMAL
- en: Running a script using OS shell rules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The third way that we can run a script is by making the script file executable
    and including an OS association between the script file and the Python3 program.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Linux and Mac OS X, the file association is set by the first line of the
    file. We''ll often use something like this as the first line in a file, to associate
    a given `.py` file and the Python3 program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This will use the OS `env` program to locate and start the `python3` environment.
    The shell will provide the entire file as input to the program named on a `#!`
    line. This means that the `env` program will be started with the script file as
    input. The `env` program will prepare the environment and then hand the file to
    the Python3 program.
  prefs: []
  type: TYPE_NORMAL
- en: 'To mark a file as executable in Linux and Mac OS X, we use the `chmod +x` command.
    We can do this to mark our script as executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This command will add the execute, `x`, option to the file's mode. When we do
    an `ls -l`, we'll see this as part of the file's details.
  prefs: []
  type: TYPE_NORMAL
- en: In Windows, all files are considered executable. The association between file
    extension and program is done through the Windows Control Panel. The setting was
    put in place when you installed Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the file is marked as executable, we can run it simply by providing the
    name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Under Windows, the file extension of `.py` is bound to the Python program, and
    Windows will launch Python providing this filename as input. The binding of filename
    to script is outside the application.
  prefs: []
  type: TYPE_NORMAL
- en: Under Linux and Mac OS X, the processing is based on the magical first line
    of the file. The Linux shell checks the file's mode to see that it's executable.
    It then reads the first few bytes of the file. In this case, the first few bytes
    are `#!`, which marks the file as a script. The first full line of a script includes
    the command that must be used to process this script. In this case, the command
    is `/usr/bin/env python3`. The shell launches this program with the given file
    as input.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing good script names
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Script names should be kept short and meaningful. As with filenames, it's generally
    best practice to avoid complex prefixes and suffixes. The Linux or Windows DOS
    commands provide some guidance on what makes a good (and bad) name for a script.
    One of the best examples is the `git` command, which has numerous subcommands.
    Rather than invent dozens of complex-looking names, **git** uses a simple command
    name as a prefix.
  prefs: []
  type: TYPE_NORMAL
- en: The `argparse` module, used for parsing command-line arguments, supports this
    nicely. We can define a few common arguments that apply to all subcommands. We
    can also define arguments that are unique to each subcommand.
  prefs: []
  type: TYPE_NORMAL
- en: In order to keep the code for this book organized by the publishing pipeline,
    the script names are long. The redundancy in these names (`Chapter_12/ch12_...`)
    is not the best practice, and should be avoided where possible. As with variable
    names and function names, script names should be kept reasonably short and meaningful.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a reusable module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Python, the module is the unit of software reuse. When we have a feature
    that must appear in more than one script, we'll put this feature into a module
    and import that module into each script that shares the feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s important to note two slightly different senses of the word "reuse" as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We can define a class hierarchy to achieve localized reuse within an application.
    Inheritance is an elegant way to share code among related objects. Often we'll
    define all of these related classes in a single module file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can define a module to achieve a less local reuse across applications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To create a module that can be imported, we merely have to be sure that a Python
    file is visible in a directory that's part of the Python search path. Since the
    local directory is always visible, we can create a module simply by creating a
    file in the current working directory.
  prefs: []
  type: TYPE_NORMAL
- en: A module designed for import should consist mostly of `import`, `class`, and
    `def` statements. We can also use assignment statements to create module global
    variables, but we need to be cautious of how much processing is done. Any name
    that's created (via assignment, `class`, `def`, or `import`) will be in that module's
    namespace.
  prefs: []
  type: TYPE_NORMAL
- en: A module is only imported once. The `import` implementation checks a global
    cache of loaded modules, visible as `sys.modules`, to see if the module is known.
    Because of this, a module that actually does some kind of processing will only
    do it once. After that, the import is ignored. This behavior makes it easy to
    create a global **Singleton** object inside an imported module.
  prefs: []
  type: TYPE_NORMAL
- en: Examples of modules that do significant processing on `import` are `this` and
    `antigravity`. When we execute `import this` or `import antigravity`, these modules
    will immediately do some interesting processing. After having been imported once,
    they won't do this again. While handy in some specialized situations, it's not
    a general pattern to follow.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We generally expect an `import` statement to provide definitions of classes,
    functions, and module global variables.
  prefs: []
  type: TYPE_NORMAL
- en: We don't generally expect an `import` statement to do useful processing.
  prefs: []
  type: TYPE_NORMAL
- en: 'A module may define a unique exception. We might want to create a generic exception
    class named `Error` in a module. It would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Because this name will be qualified by the module name when the module is imported,
    we are able to reference this exception via `some_module.Error`. It might look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The module name, `some_module`, acts as a nice qualifier to show the origin
    of the `Error` class definition. We don't need to give the `Error` class a more
    complex, globally unique name.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a hybrid library/application module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A script may import modules, perhaps define some functions or classes, but
    it will always do the relevant processing. Our first example script had just three
    lines of relevant processing: two assignment statements, and a function statement
    that printed a result. This shows the Pythonic ideal of having programs without
    any boilerplate; we try to avoid syntax that''s just overhead.'
  prefs: []
  type: TYPE_NORMAL
- en: A possible downside of a perfectly clean approach to scripting is that it's
    difficult to create unit tests. Each unit test would have to invoke the script
    as a subprocess; something that can involve quite a bit of OS overhead. The goal
    of unit testing is to isolate each unit—each function, class, module, package,
    or script—so that it can be tested separately. Having the OS launch the script
    file doesn't seem to be properly isolated.
  prefs: []
  type: TYPE_NORMAL
- en: Also, as an application matures, a good script may become a component in a larger,
    and more comprehensive, application. It can become difficult to create a composite
    application from a script file. It's far easier to create composite processes
    from functions or classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'This leads to the following suggested structure for a script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve taken our script and wrapped it with a `def` statement to make a function.
    We''ve then written an `if` statement that distinguishes between a main script
    and an imported module by examining the `__name__` variable. The `if` statement
    makes the following conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: When a module is imported, Python sets the global variable `__name__` to the
    actual module name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When run as a main script, Python sets the global variable `__name__` to `__main__`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This pattern can be used to write library modules which run their own unit
    tests. We can include the following in a library module that is never used as
    a main script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This will run all of the unit tests that are embedded in docstrings. We'll look
    more closely at testing in [Chapter 14](ch14.html "Chapter 14. Fit and Finish
    – Unit Testing, Packaging, and Documentation"), *Fit and Finish – Unit Testing,
    Packaging, and Documentation*.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A package is a directory that contains module files plus one additional file.
    Each package must have an `__init__.py` file. This file must be present and is
    often empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'The poem, *Zen of Python*, by Tim Peters, offers the following advice:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Flat is better than nested.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The idea is to organize Python applications into a flat collection of modules
    to the greatest extent possible. A deeply-nested, complex hierarchy of packages
    isn't considered helpful.
  prefs: []
  type: TYPE_NORMAL
- en: We can use a package in two ways. We can import a module that's part of a package.
    The standard library, for example, has an XML package with several XML parser
    modules. We can use import `xml.etree` to import the `etree` module from the XML
    package. In this case, the `__init__.py` file has a comment and a list of sub-packages.
  prefs: []
  type: TYPE_NORMAL
- en: In other cases, we can import the package, as a whole, as if the package were
    a module. When we write import collections, for example, we're really importing
    the module `collections/__init__.py`.
  prefs: []
  type: TYPE_NORMAL
- en: The `__init__.py` file is a top-level module for the package as a whole. It
    can be empty, in which case we can only pick specific modules from within the
    package. Or the `__init__.py` file may have content, allowing us to import the
    package as a single complex structure.
  prefs: []
  type: TYPE_NORMAL
- en: Designing alternative implementations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can easily offer alternative implementations of a given feature. If we want
    more speed, more accuracy, or less memory use, we should be able to import an
    alternative definition of a given library.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can compare the `math` and `cmath` modules for a concrete example of this
    principle. Here''s an example of how they differ:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `math` module includes a square root function, which we used as `math.sqrt()`.
    This produces only real-valued results, and must raise an exception when confronted
    with an expression that's not real-valued.
  prefs: []
  type: TYPE_NORMAL
- en: The `cmath` module also includes a square root function. The `cmath.sqrt()`
    function can return complex values instead of raising an exception. Since the
    packages are so similar, we can substitute one for the other in a variety of ways.
  prefs: []
  type: TYPE_NORMAL
- en: Both of these modules offer a similar set of function definitions. The components
    within the module have the same names. The modules, which are namespaces, have
    different names to distinguish the origin of a definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'This technique is often used to support different platforms. We can create
    a package with platform-specific modules within the package. The package''s top-level
    `__init__.py` can choose which module to import and provide the platform-specific
    definitions. We can also use this to write enterprise software that must run in
    different environments: development, quality assurance, and final production.
    A single package can include different configuration modules. The standard library
    `os` package demonstrates this concept.'
  prefs: []
  type: TYPE_NORMAL
- en: Seeing the package search path
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Python search path can be seen by importing the `sys` package to see `sys.path`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We've elided a number of lines from this output to show the essentials of how
    the standard library fits into the way we develop Python code. This list of places
    to search for modules is built by the `sites` package when Python starts running.
  prefs: []
  type: TYPE_NORMAL
- en: The zero-length directory name, `''`, is first. This means that the current
    working directory is the preferred place to locate modules. This allows us to
    import our own modules from the local directory. After our local directory, a
    number of locations are searched, ending with the `.../site-packages` directory.
  prefs: []
  type: TYPE_NORMAL
- en: The next group of names, starting with `setuptools-2.0.2-py3.3.egg`, is a list
    of all external packages added to this installation in the form of downloaded
    `.egg` files. The exact list will vary from installation to installation. These
    names are created by the `pip` and `easy_install` programs.
  prefs: []
  type: TYPE_NORMAL
- en: When we set the `PYTHONPATH` environment variable, those names are spliced into
    the path *after* the various installed packages. The final group of names, starting
    with `python33.zip`, is a common list of modules that come with Python. The last
    entry lists the generic site-packages portion of the library. If you download
    a package and run the package's `setup.py` script, it is copied into this directory
    where it will be found by Python.
  prefs: []
  type: TYPE_NORMAL
- en: The `sys.path` object is a proper mutable list. We can dynamically change the
    path in our script files. This can make it difficult to determine all the modules
    that a script depends on. It's almost always clearer to explicitly depend on the
    modules being properly installed or the `PYTHONPATH` environment variable being
    set.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've looked at the higher-level ways to organize software.
    A function contains many statements, a class contains many method functions, and
    a module can contain many classes and functions. A package can contain many modules.
  prefs: []
  type: TYPE_NORMAL
- en: We've looked at a number of ways of executing a Python script. We have a great
    deal of flexibility because there are many contexts in which we need to execute
    software. Generally, we'll focus on executing Python programs by module name rather
    than by filename. The distinction is tiny. Since a module must be on the search
    path, we can create a directory that contains the script and any supporting modules
    and libraries, and ensure that this directory is named on the `PYTHONPATH`.
  prefs: []
  type: TYPE_NORMAL
- en: We've looked at how we can create library modules that contain definitions and
    will be imported into other scripts. This is our primary method of reuse. We've
    also looked at how we can create a script, that is reusable as a library module.
    This supports unit testing as well as maturation of our software.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 13](ch13.html "Chapter 13. Metaprogramming and Decorators"), *Metaprogramming
    and Decorators*, we'll look at some more advanced programming techniques. These
    will allow us to create more sophisticated class and function definitions. We
    can use these design patterns to write more flexible and more reusable software.
  prefs: []
  type: TYPE_NORMAL
