- en: Chapter 3. IPv6, Unix Domain Sockets, and Network Interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Forwarding a local port to a remote host
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pinging hosts on the network with ICMP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Waiting for a remote network service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enumerating interfaces on your machine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding the IP address for a specific interface on your machine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding whether an interface is up on your machine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting inactive machines on your network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing a basic IPC using connected sockets (socketpair)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing IPC using Unix domain sockets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding out if your Python supports IPv6 sockets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extracting an IPv6 prefix from an IPv6 address
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing an IPv6 echo client/server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter extends the use of Python's socket library with a few third-party
    libraries. It also discusses some advanced techniques, for example, the asynchronous
    `ayncore` module from the Python standard library. This chapter also touches upon
    various protocols, ranging from an ICMP ping to an IPv6 client/server.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, a few useful Python third-party modules have been introduced
    by some example recipes. For example, the network packet capture library, **Scapy**,
    is well known among Python network programmers.
  prefs: []
  type: TYPE_NORMAL
- en: A few recipes have been dedicated to explore the IPv6 utilities in Python including
    an IPv6 client/server. Some other recipes cover Unix domain sockets.
  prefs: []
  type: TYPE_NORMAL
- en: Forwarding a local port to a remote host
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, you may need to create a local port forwarder that will redirect
    all traffic from a local port to a particular remote host. This might be useful
    to enable proxy users to browse a certain site while preventing them from browsing
    some others.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us create a local port forwarding script that will redirect all traffic
    received at port 8800 to the Google home page ([http://www.google.com](http://www.google.com)).
    We can pass the local and remote host as well as port number to this script. For
    the sake of simplicity, let's only specify the local port number as we are aware
    that the web server runs on port 80.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 3.1 shows a port forwarding example, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we define the `PortForwarder` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to specify the `Receiver` and `Sender` classes, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run this script, it will show the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, open your browser and visit `http://localhost:8800`. This will take you
    to the Google home page and the script will print something similar to the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the forwarding a local port to a remote host:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/3463OS_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created a port forwarding class, `PortForwarder subclassed`, from `asyncore.dispatcher`,
    which wraps around the socket object. It provides a few additional helpful functions
    when certain events occur, for example, when the connection is successful or a
    client is connected to a server socket. You have the choice of overriding the
    set of methods defined in this class. In our case, we only override the `handle_accept()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Two other classes have been derived from `asyncore.dispatcher`. The `Receiver`
    class handles the incoming client requests and the `Sender` class takes this `Receiver`
    instance and processes the sent data to the clients. As you can see, these two
    classes override the `handle_read()`, `handle_write()`, and `writeable()` methods
    to facilitate the bi-directional communication between the remote host and local
    client.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, the `PortForwarder` class takes the incoming client request in a
    local socket and passes this to the `Sender` class instance, which in turn uses
    the `Receiver` class instance to initiate a bi-directional communication with
    a remote server in the specified port.
  prefs: []
  type: TYPE_NORMAL
- en: Pinging hosts on the network with ICMP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An ICMP ping is the most common type of network scanning you have ever encountered.
    It is very easy to open a command-line prompt or terminal and type `ping www.google.com`.
    How difficult is that from inside a Python program? This recipe shows you an example
    of a Python ping.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need the superuser or administrator privilege to run this recipe on your
    machine.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can lazily write a Python script that calls the system ping command-line
    tool, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: However, in many circumstances, the system's ping executable may not be available
    or may be inaccessible. In this case, we need a pure Python script to do that
    ping. Note that this script needs to be run as a superuser or administrator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 3.2 shows the ICMP ping, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We need a `send_ping()` method that will send the data of a ping request to
    the target host. Also, this will call the `do_checksum()` method for checking
    the integrity of the ping data, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us define another method called `ping_once()` that makes a single ping
    call to the target host. It creates a raw ICMP socket by passing the ICMP protocol
    to `socket()`. The exception handling code takes care if the script is not run
    by a superuser or if any other socket error occurs. Let''s take a look at the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The main executive method of this class is `ping()`. It runs a `for` loop inside
    which the `ping_once()` method is called count times and receives a delay in the
    ping response in seconds. If no delay is returned, that means the ping has failed.
    Let''s take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This script shows the following output. This has been run with the superuser
    privilege:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A `Pinger` class has been constructed to define a few useful methods. The class
    initializes with a few user-defined or default inputs, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`target_host`: This is the target host to ping'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`count`: This is how many times to do the ping'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`timeout`: This is the value that determines when to end an unfinished ping
    operation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `send_ping()` method gets the DNS hostname of the target host and creates
    an `ICMP_ECHO_REQUEST` packet using the `struct` module. It's necessary to check
    the data integrity of the method using the `do_checksum()` method. It takes the
    source string and manipulates it to produce a proper checksum. On the receiving
    end, the `receive_pong()` method waits for a response until the timeout occurs
    or receives the response. It captures the ICMP response header and then compares
    the packet ID and calculates the delay in the request and response cycle.
  prefs: []
  type: TYPE_NORMAL
- en: Waiting for a remote network service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, during the recovery of a network service, it might be useful to run
    a script to check when the server is online again.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can write a client that will wait for a particular network service forever
    or for a timeout. In this example, by default, we would like to check when a web
    server is up in localhost. If you specified some other remote host or port, that
    information will be used instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 3.3 shows waiting for a remote network service, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If a web server, such as Apache, is running on your machine, this script will
    show the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, stop the Apache process, run this script, and restart Apache again. The
    output pattern will be different. On my machine, the following output pattern
    was found:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the waiting for an active Apache web server
    process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/3463OS_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The preceding script uses the `argparse` module to take the user input and process
    the hostname, port, and timeout, that is how long our script will wait for the
    desired network service. It launches an instance of the `NetServiceChecker` class
    and calls the `check()` method. This method calculates the final end time of waiting
    and uses the socket's `settimeout()` method to control each round's end time,
    that is `next_timeout`. It then uses the socket's `connect()` method to test if
    the desired network service is available until the socket timeout occurs. This
    method also catches the socket timeout error and checks the socket timeout against
    the timeout values given by the user.
  prefs: []
  type: TYPE_NORMAL
- en: Enumerating interfaces on your machine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you need to list the network interfaces present on your machine, it is not
    very complicated in Python. There are a couple of third-party libraries out there
    that can do this job in a few lines. However, let's see how this is done using
    a pure socket call.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You need to run this recipe on a Linux box. To get the list of available interfaces,
    you can execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Listing 3.4 shows how to list the networking interfaces, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding script will list the network interfaces, as shown in the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe code uses a low-level socket feature to find out the interfaces
    present on the system. The single `list_interfaces()`method creates a socket object
    and finds the network interface information from manipulating this object. It
    does so by making a call to the `fnctl` module's `ioctl()` method. The `fnctl`
    module interfaces with some Unix routines, for example, `fnctl()`. This interface
    performs an I/O control operation on the underlying file descriptor socket, which
    is obtained by calling the `fileno()` method of the socket object.
  prefs: []
  type: TYPE_NORMAL
- en: The additional parameter of the `ioctl()` method includes the `SIOCGIFADDR`
    constant defined in the C socket library and a data structure produced by the
    `struct` module's `pack()` function. The memory address specified by a data structure
    is modified as a result of the `ioctl()` call. In this case, the `interface_names`
    variable holds this information. After unpacking the `sock_info` return value
    of the `ioctl()` call, the number of network interfaces is increased twice if
    the size of the data suggests it. This is done in a `while` loop to discover all
    interfaces if our initial interface count assumption is not correct.
  prefs: []
  type: TYPE_NORMAL
- en: The names of interfaces are extracted from the string format of the `interface_names`
    variable. It reads specific fields of that variable and appends the values in
    the interfaces' list. At the end of the `list_interfaces()` function, this is
    returned.
  prefs: []
  type: TYPE_NORMAL
- en: Finding the IP address for a specific interface on your machine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finding the IP address of a particular network interface may be needed from
    your Python network application.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe is prepared exclusively for a Linux box. There are some Python modules
    specially designed to bring similar functionalities on Windows and Mac platforms.
    For example, see [http://sourceforge.net/projects/pywin32/](http://sourceforge.net/projects/pywin32/)
    for Windows-specific implementation.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can use the `fnctl` module to query the IP address on your machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 3.5 shows us how to find the IP address for a specific interface on
    your machine, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this script is shown in one line, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This recipe is similar to the previous one. The preceding script takes a command-line
    argument: the name of the network interface whose IP address is to be known. The
    `get_ip_address()` function creates a socket object and calls the `fnctl.ioctl()`
    function to query on that object about IP information. Note that the `socket.inet_ntoa()`
    function converts the binary data to a human-readable string in a dotted format
    as we are familiar with it.'
  prefs: []
  type: TYPE_NORMAL
- en: Finding whether an interface is up on your machine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have multiple network interfaces on your machine, before doing any work
    on a particular interface, you would like to know the status of that network interface,
    for example, if the interface is actually up. This makes sure that you route your
    command to active interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe is written for a Linux machine. So, this script will not run on
    a Windows or Mac host. In this recipe, we use `nmap`, a famous network scanning
    tool. You can find more about `nmap` from its website [http://nmap.org/](http://nmap.org/).
  prefs: []
  type: TYPE_NORMAL
- en: 'You also need the `python-nmap` module to run this recipe. This can be installed
    by `pip`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can create a socket object and get the IP address of that interface. Then,
    we can use any of the scanning techniques to probe the interface status.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 3.6 shows the detect network interface status, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run this script to inquire the status of the `eth0` status, it will
    show something similar to the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The recipe takes the interface's name from the command line and passes it to
    the `get_interface_status()` function. This function finds the IP address of that
    interface by manipulating a UDP socket object.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe needs the `nmap` third-party module. We can install that PyPI using
    the `pip` install command. The `nmap` scanning instance, `nm`, has been created
    by calling `PortScanner()`. An initial scan to a local IP address gives us the
    status of the associated network interface.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting inactive machines on your network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have been given a list of IP addresses of a few machines on your network
    and you are asked to write a script to find out which hosts are inactive periodically,
    you would want to create a network scanner type program without installing anything
    on the target host computers.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe requires installing the Scapy library (> 2.2), which can be obtained
    at [http://www.secdev.org/projects/scapy/files/scapy-latest.zip](http://www.secdev.org/projects/scapy/files/scapy-latest.zip).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can use Scapy, a mature network-analyzing, third-party library, to launch
    an ICMP scan. Since we would like to do it periodically, we need Python's `sched`
    module to schedule the scanning tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 3.7 shows us how to detect inactive machines, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this script will be something like the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The preceding script first takes a list of network hosts, `scan_hosts`, from
    the command line. It then creates a schedule to launch the `detect_inactive_hosts()`
    function after a one-second delay. The target function takes the `scan_hosts`
    argument and calls Scapy's `sr()` function.
  prefs: []
  type: TYPE_NORMAL
- en: This function schedules itself to rerun after every 10 seconds by calling the
    `schedule.enter()` function once again. This way, we run this scanning task periodically.
  prefs: []
  type: TYPE_NORMAL
- en: Scapy's `sr()` scanning function takes an IP, protocol and some scan-control
    information. In this case, the `IP()` method passes `scan_hosts` as the destination
    hosts to scan, and the protocol is specified as ICMP. This can also be TCP or
    UDP. We do not specify a retry and one-second timeout to run this script faster.
    However, you can experiment with the options that suit you.
  prefs: []
  type: TYPE_NORMAL
- en: The scanning `sr()`function returns the hosts that answer and those that don't
    as a tuple. We check the hosts that don't answer, build a list, and print that
    information.
  prefs: []
  type: TYPE_NORMAL
- en: Performing a basic IPC using connected sockets (socketpair)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, two scripts need to communicate some information between themselves
    via two processes. In Unix/Linux, there's a concept of connected socket, of `socketpair`.
    We can experiment with this here.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe is designed for a Unix/Linux host. Windows/Mac is not suitable for
    running this one.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We use a `test_socketpair()` function to wrap a few lines that test the socket's
    `socketpair()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'List 3.8 shows an example of `socketpair`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The output from the preceding script is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `socket.socketpair()` function simply returns two connected socket objects.
    In our case, we can say that one is a parent and another is a child. We fork another
    process via a `os.fork()` call. This returns the process ID of the parent. In
    each process, the other process' socket is closed first and then a message is
    exchanged via a `sendall()` method call on the process's socket. The try-except
    block prints any error in case of any kind of exception.
  prefs: []
  type: TYPE_NORMAL
- en: Performing IPC using Unix domain sockets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Unix domain sockets** (**UDS**) are sometimes used as a convenient way to
    communicate between two processes. As in Unix, everything is conceptually a file.
    If you need an example of such an IPC action, this can be useful.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We launch a UDS server that binds to a filesystem path, and a UDS client uses
    the same path to communicate with the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 3.9a shows a Unix domain socket server, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3.9b shows a UDS client, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The server output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The client output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A common path is defined for a UDS client/server to interact. Both the client
    and server use the same path to connect and listen to.
  prefs: []
  type: TYPE_NORMAL
- en: In a server code, we remove the path if it exists from the previous run of this
    script. It then creates a Unix datagram socket and binds it to the specified path.
    It then listens for incoming connections. In the data processing loop, it uses
    the `recv()` method to get data from the client and prints that information on
    screen.
  prefs: []
  type: TYPE_NORMAL
- en: The client-side code simply opens a Unix datagram socket and connects to the
    shared server address. It sends a message to the server using `sendall()`. It
    then waits for the message to be echoed back to itself and prints that message.
  prefs: []
  type: TYPE_NORMAL
- en: Finding out if your Python supports IPv6 sockets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'IP version 6 or IPv6 is increasingly adopted by the industry to build newer
    applications. In case you would like to write an IPv6 application, the first thing
    you''d like to know is if your machine supports IPv6\. This can be done from the
    Linux/Unix command line, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: From your Python script, you can also check if the IPv6 support is present on
    your machine, and Python is installed with that support.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, use `pip` to install a Python third-party library, `netifaces`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can use a third-party library, `netifaces`, to find out if there is IPv6
    support on your machine. We can call the `interfaces()` function from this library
    to list all interfaces present in the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 3.10 shows the Python IPv6 support checker, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The output from this script will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the interaction between the IPv6 client and
    server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/3463OS_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The IPv6 support checker function, `inspect_ipv6_support()`, first checks if
    Python is built with IPv6 using `socket.has_ipv6`. Next, we call the `interfaces()`
    function from the `netifaces` module. This gives us the list of all interfaces.
    If we call the `ifaddresses()` method by passing a network interface to it, we
    can get all the IP addresses of this interface. We then extract various IP-related
    information, such as protocol family, address, netmask, and broadcast address.
    Then, the address of a network interface has been added to the `IPv6_address`
    dictionary if its protocol family matches `AF_INET6`.
  prefs: []
  type: TYPE_NORMAL
- en: Extracting an IPv6 prefix from an IPv6 address
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In your IPv6 application, you need to dig out the IPv6 address for getting the
    prefix information. Note that the upper 64-bits of an IPv6 address are represented
    from a global routing prefix plus a subnet ID, as defined in RFC 3513\. A general
    prefix (for example, /48) holds a short prefix based on which a number of longer,
    more specific prefixes (for example, /64) can be defined. A Python script can
    be very helpful in generating the prefix information.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can use the `netifaces` and `netaddr` third-party libraries to find out
    the IPv6 prefix information for a given IPv6 address, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The output from this script is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python's `netifaces` module gives us the network interface IPv6 address. It
    uses the `interfaces()` and `ifaddresses()` functions for doing this. The `netaddr`
    module is particularly helpful to manipulate a network address. It has a `IPNetwork()`
    class that provides us with an address, IPv4 or IPv6, and computes the prefix,
    network, and broadcast addresses. Here, we find this information class instance's
    version, prefixlen, and network and broadcast attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Writing an IPv6 echo client/server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You need to write an IPv6 compliant server or client and wonder what could be
    the differences between an IPv6 compliant server or client and its IPv4 counterpart.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We use the same approach as writing an echo client/server using IPv6\. The only
    major difference is how the socket is created using IPv6 information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 12a shows an IPv6 echo server, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12b shows an IPv6 echo client, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The server output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The client output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The IPv6 echo server first determines its IPv6 information by calling `socket.getaddrinfo()`.
    Notice that we passed the `AF_UNSPEC` protocol for creating a TCP socket. The
    resulting information is a tuple of five values. We use three of them, address
    family, socket type, and protocol, to create a server socket. Then, this socket
    is bound with the socket address from the previous tuple. It then listens to the
    incoming connections and accepts them. After a connection is made, it receives
    data from the client and echoes it back.
  prefs: []
  type: TYPE_NORMAL
- en: On the client-side code, we create an IPv6-compliant client socket instance
    and send the data using the `send()` method of that instance. When the data is
    echoed back, the `recv()` method is used to get it back.
  prefs: []
  type: TYPE_NORMAL
