["```py\nfrom collections.abc import Callable, Sequence \nfrom typing import Any, TypeAlias \n\nExtractor: TypeAlias = Callable[[Sequence[Any]], Any] \n\nfst: Extractor = lambda x: x[0] \nsnd: Extractor = lambda x: x[1]\n```", "```py\n<Placemark><Point> \n<coordinates>-76.33029518659048, 37.54901619777347,0</coordinates> \n</Point></Placemark>\n```", "```py\nfrom collections.abc import Iterable \nfrom typing import TextIO \nimport xml.etree.ElementTree as XML \n\ndef row_iter_kml(file_obj: TextIO) -> Iterable[list[str]]: \n    ns_map = { \n        \"ns0\": \"http://www.opengis.net/kml/2.2\", \n        \"ns1\": \"http://www.google.com/kml/ext/2.2\" \n    } \n    path_to_points = ( \n      \"./ns0:Document/ns0:Folder/ns0:Placemark/\" \n      \"ns0:Point/ns0:coordinates\" \n    ) \n    doc = XML.parse(file_obj) \n    text_blocks = ( \n        coordinates.text \n        for coordinates in doc.iterfind(path_to_points, ns_map) \n    ) \n    return ( \n        comma_split(text) \n        for text in text_blocks \n        if text is not None \n    )\n```", "```py\ndef comma_split(text: str) -> list[str]: \n    return text.split(\",\")\n```", "```py\n>>> from pprint import pprint \n>>> source_url = \"file:./Winter%202012-2013.kml\" \n>>> with urllib.request.urlopen(source_url) as source: \n...     v1 = list(row_iter_kml(source)) \n>>> pprint(v1) \n[[’-76.33029518659048’, ’37.54901619777347’, ’0’], \n [’-76.27383399999999’, ’37.840832’, ’0’], \n [’-76.459503’, ’38.331501’, ’0’], \n ... \n [’-76.47350299999999’, ’38.976334’, ’0’]]\n```", "```py\ndef pick_lat_lon( \n        lon: str, lat: str, alt: str \n) -> tuple[str, str]: \n    return lat, lon\n```", "```py\nfrom collections.abc import Iterable \nfrom typing import TypeAlias \n\nRows: TypeAlias = Iterable[list[str]] \nLL_Text: TypeAlias = tuple[str, str] \n\ndef lat_lon_kml(row_iter: Rows) -> Iterable[LL_Text]: \n    return (pick_lat_lon(*row) for row in row_iter)\n```", "```py\n>>> import urllib \n>>> source_url = \"file:./Winter%202012-2013.kml\" \n>>> with urllib.request.urlopen(source_url) as source: \n...     v1 = tuple(lat_lon_kml(row_iter_kml(source))) \n>>> v1[0] \n(’37.54901619777347’, ’-76.33029518659048’) \n>>> v1[-1] \n(’38.976334’, ’-76.47350299999999’)\n```", "```py\nbegin = next(iterable) \nfor end in iterable: \n    compute_something(begin, end) \n    begin = end\n```", "```py\nfrom collections.abc import Iterator, Iterable \nfrom typing import Any, TypeVar \n\nLL_Type = TypeVar(’LL_Type’) \n\ndef legs(lat_lon_iter: Iterator[LL_Type]) -> Iterator[tuple[LL_Type, LL_Type]]: \n    begin = next(lat_lon_iter) \n    for end in lat_lon_iter: \n        yield begin, end \n        begin = end\n```", "```py\n[items[0:2], items[1:3], items[2:4], ..., items[-2:]]\n```", "```py\nlist(zip(items, items[1:]))\n```", "```py\n# Iterator as input: \n>>> list(legs(x for x in range(3))) \n[(0, 1), (1, 2)] \n\n# List object as input: \n>>> list(legs([0, 1, 2])) \nTraceback (most recent call last): \n... \nTypeError: ’list’ object is not an iterator \n\n# Explicit iterator created from list object: \n>>> list(legs(iter([0,1,2]))) \n[(0, 1), (1, 2)]\n```", "```py\nfrom collections.abc import Iterator, Iterable, Callable \nfrom typing import TypeAlias \n\nWaypoint: TypeAlias = tuple[float, float] \nPairs_Iter: TypeAlias = Iterator[Waypoint] \nLeg: TypeAlias = tuple[Waypoint, Waypoint] \nLeg_Iter: TypeAlias = Iterable[Leg] \n\ndef legs_filter( \n        lat_lon_iter: Pairs_Iter, \n        rejection_rule: Callable[[Waypoint, Waypoint], bool]) -> Leg_Iter: \n    begin = next(lat_lon_iter) \n    for end in lat_lon_iter: \n        if rejection_rule(begin, end): \n            pass \n        else: \n            yield begin, end \n        begin = end\n```", "```py\n>>> import urllib \n>>> source_url = \"file:./Winter%202012-2013.kml\" \n>>> with urllib.request.urlopen(source_url) as source: \n...     trip = list( \n...         legs( \n...            (float(lat), float(lon)) \n...            for lat, lon in lat_lon_kml(row_iter_kml(source)) \n...         ) \n...     )\n```", "```py\n>>> import urllib \n>>> source_url = \"file:./Winter%202012-2013.kml\" \n>>> with urllib.request.urlopen(source_url) as source: \n...     ll_iter = ( \n...         (float(lat), float(lon)) \n...         for lat, lon in lat_lon_kml(row_iter_kml(source)) \n...     ) \n...     trip = list( \n...         legs(ll_iter) \n...     )\n```", "```py\nfrom collections.abc import Iterator, Iterable \nfrom typing import TypeAlias \n\nText_Iter: TypeAlias = Iterable[tuple[str, str]] \nLL_Iter: TypeAlias = Iterable[tuple[float, float]] \n\ndef floats_from_pair(lat_lon_iter: Text_Iter) -> LL_Iter: \n    return ( \n        (float(lat), float(lon)) \n        for lat, lon in lat_lon_iter \n    )\n```", "```py\n>>> import urllib \n>>> source_url = \"file:./Winter%202012-2013.kml\" \n>>> with urllib.request.urlopen(source_url) as source: \n...     trip = list( \n...         legs( \n...             floats_from_pair( \n...                 lat_lon_kml( \n...                     row_iter_kml(source)))) \n...     )\n```", "```py\n((’37.54901619777347’, ’-76.33029518659048’), \n (’37.840832’, ’-76.27383399999999’), \n ... \n (’38.976334’, ’-76.47350299999999’))\n```", "```py\n(((37.54901619777347, -76.33029518659048), \n(37.840832, -76.273834)), ((37.840832, -76.273834), \n... \n((38.330166, -76.458504), (38.976334, -76.473503)))\n```", "```py\nfrom math import radians, sin, cos, sqrt, asin \nfrom typing import TypeAlias \n\nMI = 3959 \nNM = 3440 \nKM = 6371 \n\nPoint: TypeAlias = tuple[float, float] \n\ndef haversine(p1: Point, p2: Point, R: float=NM) -> float: \n    lat_1, lon_1 = p1 \n    lat_2, lon_2 = p2 \n    Δ_lat = radians(lat_2 - lat_1) \n    Δ_lon = radians(lon_2 - lon_1) \n    lat_1 = radians(lat_1) \n    lat_2 = radians(lat_2) \n\n    a = sqrt( \n        sin(Δ_lat / 2) ** 2 + \n        cos(lat_1) * cos(lat_2) * sin(Δ_lon / 2) ** 2 \n    ) \n    c = 2 * asin(a) \n    return R * c\n```", "```py\n>>> import urllib \n>>> source_url = \"file:./Winter%202012-2013.kml\" \n>>> with urllib.request.urlopen(source_url) as source: \n...     trip = ( \n...         (start, end, round(haversine(start, end), 4)) \n...         for start,end in \n...             legs( \n...                 floats_from_pair( \n...                     lat_lon_kml(row_iter_kml(source)) \n...                 ) \n...             ) \n...     ) \n...     for start, end, dist in trip: \n...         print(f\"({start} to {end} is {dist:.1f}\")\n```", "```py\n((37.54901619777347, -76.33029518659048) to (37.840832, -76.273834) is 17.7 \n((37.840832, -76.273834) to (38.331501, -76.459503) is 30.7 \n((38.331501, -76.459503) to (38.845501, -76.537331) is 31.1 \n((38.845501, -76.537331) to (38.992832, -76.451332) is 9.7 \n...\n```", "```py\nall(isprime(x) for x in someset)\n```", "```py\nnot_p_1 = not all(isprime(x) for x in someset)\n```", "```py\nnot_p_2 = any(not isprime(x) for x in someset)\n```", "```py\n>>> all(()) \nTrue \n>>> any(()) \nFalse\n```", "```py\n>>> sum(()) \n0 \n>>> len(()) \n0\n```", "```py\ndef mean(items): \n    return sum(items) / len(items)\n```", "```py\nfrom collections.abc import Sequence \n\ndef mean(items: Sequence[float]) -> float: \n    return sum(items)/len(items)\n```", "```py\nimport math \nfrom collections.abc import Sequence \n\ndef stdev(data: Sequence[float]) -> float: \n\n    s0 = len(data)  # sum(1 for x in data) \n    s1 = sum(data)  # sum(x for x in data) \n    s2 = sum(x**2 for x in data) \n\n    mean = s1 / s0 \n    stdev = math.sqrt(s2 / s0 - mean ** 2) \n    return stdev\n```", "```py\ndef z(x: float, m_x: float, s_x: float) -> float: \n    return (x - m_x) / s_x\n```", "```py\n>>> d = [2, 4, 4, 4, 5, 5, 7, 9] \n>>> list(z(x, mean(d), stdev(d)) for x in d) \n[-1.5, -0.5, -0.5, -0.5, 0.0, 0.0, 1.0, 2.0]\n```", "```py\nfrom math import sqrt \nfrom collections.abc import Sequence \n\ndef mean(samples: Sequence[float]) -> float: \n    return s1(samples)/s0(samples) \n\ndef stdev(samples: Sequence[float]) -> float: \n    N = s0(samples) \n    return sqrt((s2(samples) / N) - (s1(samples) / N) ** 2)\n```", "```py\ndef s0(samples: Sequence[float]) -> float: \n    return sum(1 for x in samples)  # or len(data) \n\ndef s1(samples: Sequence[float]) -> float: \n    return sum(x for x in samples)  # or sum(data) \n\ndef s2(samples: Sequence[float]) -> float: \n    return sum(x*x for x in samples)\n```", "```py\ndef corr(samples1: Sequence[float], samples2: Sequence[float]) -> float: \n    m_1, s_1 = mean(samples1), stdev(samples1) \n    m_2, s_2 = mean(samples2), stdev(samples2) \n    z_1 = (z( x, m_1, s_1 ) for x in samples1) \n    z_2 = (z( x, m_2, s_2 ) for x in samples2) \n    r = ( \n        sum(zx1 * zx2 for zx1, zx2 in zip(z_1, z_2)) \n        / len(samples1) \n    ) \n    return r\n```", "```py\n>>> xi = [1.47, 1.50, 1.52, 1.55, 1.57, 1.60, 1.63, 1.65, \n... 1.68, 1.70, 1.73, 1.75, 1.78, 1.80, 1.83,] \n\n>>> yi = [52.21,53.12,54.48,55.84,57.20,58.57,59.93,61.29, \n... 63.11, 64.47, 66.28, 68.10, 69.92, 72.19, 74.46,] \n\n>>> round(corr(xi, yi), 5) \n0.99458\n```", "```py\n>>> xi = [1.47, 1.50, 1.52, 1.55, 1.57, 1.60, 1.63, 1.65, \n... 1.68, 1.70, 1.73, 1.75, 1.78, 1.80, 1.83,] \n>>> yi = [52.21, 53.12, 54.48, 55.84, 57.20, 58.57, 59.93, 61.29, \n... 63.11, 64.47, 66.28, 68.10, 69.92, 72.19, 74.46,] \n\n>>> zip(xi, yi) \n<zip object at ...> \n\n>>> pairs = list(zip(xi, yi)) \n>>> pairs[:3] \n[(1.47, 52.21), (1.5, 53.12), (1.52, 54.48)] \n>>> pairs[-3:] \n[(1.78, 69.92), (1.8, 72.19), (1.83, 74.46)]\n```", "```py\n>>> list(zip()) \n[]\n```", "```py\n>>> list(zip((1,2,3))) \n[(1,), (2,), (3,)]\n```", "```py\n>>> list(zip((1, 2, 3), (’a’, ’b’))) \n[(1, ’a’), (2, ’b’)]\n```", "```py\n>>> p0 = list(x[0] for x in pairs) \n>>> p0[:3] \n[1.47, 1.5, 1.52] \n>>> p1 = list(x[1] for x in pairs) \n>>> p1[:3] \n[52.21, 53.12, 54.48]\n```", "```py\n>>> round(sum(p0*p1 for p0, p1 in pairs), 3) \n1548.245\n```", "```py\n2 3 5 7 11 13 17 19 23 29 \n31 37 41 43 47 53 59 61 67 71 \n...\n```", "```py\n>>> blocked = list(line.split() for line in file) \n>>> from pprint import pprint \n>>> pprint(blocked) \n[[’2’, ’3’, ’5’, ’7’, ’11’, ’13’, ’17’, ’19’, ’23’, ’29’], \n [’31’, ’37’, ’41’, ’43’, ’47’, ’53’, ’59’, ’61’, ’67’, ’71’], \n ... \n [’179’, ’181’, ’191’, ’193’, ’197’, ’199’, ’211’, ’223’, ’227’, ’229’]]\n```", "```py\n>>> len(blocked) \n5 \n>>> (x for line in blocked for x in line) \n<generator object <genexpr> at ...> \n>>> flat = list(x for line in blocked for x in line) \n>>> len(flat) \n50 \n>>> flat[:10] \n[’2’, ’3’, ’5’, ’7’, ’11’, ’13’, ’17’, ’19’, ’23’, ’29’]\n```", "```py\nfrom collections.abc import Iterable \nfrom typing import Any \n\ndef flatten(data: Iterable[Iterable[Any]]) -> Iterable[Any]: \n    for line in data: \n        for x in line: \n            yield x\n```", "```py\n>>> flat = [’2’, ’3’, ’5’, ’7’, ’11’, ’13’, ’17’, ’19’, ’23’, ’29’, \n... ’31’, ’37’, ’41’, ’43’, ’47’, ’53’, ’59’, ’61’, ’67’, ’71’, \n... ]\n```", "```py\n>>> flat_iter = iter(flat) \n>>> (tuple(next(flat_iter) for i in range(5)) \n...     for row in range(len(flat) // 5) \n... ) \n<generator object <genexpr> at ...> \n\n>>> grouped = list(_) \n>>> from pprint import pprint \n>>> pprint(grouped) \n[(’2’, ’3’, ’5’, ’7’, ’11’), \n (’13’, ’17’, ’19’, ’23’, ’29’), \n (’31’, ’37’, ’41’, ’43’, ’47’), \n (’53’, ’59’, ’61’, ’67’, ’71’)]\n```", "```py\nfrom collections.abc import Sequence \nfrom typing import TypeVar \n\nItemType = TypeVar(\"ItemType\") \n# Flat = Sequence[ItemType] \n# Grouped = list[tuple[ItemType, ...]] \n\ndef group_by_seq(n: int, sequence: Sequence[ItemType]) -> list[tuple[ItemType,...]]: \n    flat_iter = iter(sequence) \n    full_sized_items = list( \n        tuple(next(flat_iter) for i in range(n)) \n        for row in range(len(sequence) // n) \n    ) \n    trailer = tuple(flat_iter) \n    if trailer: \n        return full_sized_items +  [trailer] \n    else: \n        return full_sized_items\n```", "```py\nfrom collections.abc import Iterator \nfrom typing import TypeVar \n\nItemT = TypeVar(\"ItemT\") \n\ndef group_by_iter(n: int, iterable: Iterator[ItemT]) -> Iterator[tuple[ItemT, ...]]: \n    def group(n: int, iterable: Iterator[ItemT]) -> Iterator[ItemT]: \n        for i in range(n): \n            try: \n                yield next(iterable) \n            except StopIteration: \n                return \n\n    while row := tuple(group(n, iterable)): \n        yield row\n```", "```py\n>>> flat = [’2’, ’3’, ’5’, ’7’, ’11’, ’13’, ’17’, ’19’, ’23’, ’29’, \n...     ’31’, ’37’, ’41’, ’43’, ’47’, ’53’, ’59’, ’61’, ’67’, ’71’, \n... ]\n```", "```py\n>>> pairs = list(zip(flat[0::2], flat[1::2])) \n>>> pairs[:3] \n[(’2’, ’3’), (’5’, ’7’), (’11’, ’13’)] \n>>> pairs[-3:] \n[(’47’, ’53’), (’59’, ’61’), (’67’, ’71’)]\n```", "```py\n>>> n = 2 \n>>> pairs = list( \n...     zip(*(flat [i::n] for i in range(n))) \n... ) \n>>> pairs[:5] \n[(’2’, ’3’), (’5’, ’7’), (’11’, ’13’), (’17’, ’19’), (’23’, ’29’)]\n```", "```py\nfrom collections.abc import Iterator \n\ndef digits(x: int, base: int) -> Iterator[int]: \n    if x == 0: return \n    yield x % base \n    yield from digits(x // base, base)\n```", "```py\ndef to_base(x: int, base: int) -> Iterator[int]: \n    return reversed(tuple(digits(x, base)))\n```", "```py\n>>> xi[:3] \n[1.47, 1.5, 1.52] \n>>> len(xi) \n15 \n\n>>> id_values = list(enumerate(xi)) \n>>> id_values[:3] \n[(0, 1.47), (1, 1.5), (2, 1.52)] \n>>> len(id_values) \n15\n```", "```py\nzip(range(len(source)), source)\n```", "```py\n    def hand_flavor(cards: Sequence[int]) -> bool: \n        examine the cards\n```", "```py\nRT = TypeVar(\"RT\") \n\ndef legs(transform: Callable[[LL_Type, LL_Type], RT], lat_lon_iter: Iterator[LL_Type]) -> Iterator[RT]: \n    begin = next(lat_lon_iter) \n    for end in lat_lon_iter: \n        yield transform(begin, end) \n        begin = end\n```"]