- en: '1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introduction to ROS 2 – What Is ROS 2?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Robot Operating System** (**ROS**) can be confusing, as evidenced by its
    name. It’s difficult to know what it is exactly, what it contains, and what it
    does. Also, why do you even need ROS, and when should you use it?'
  prefs: []
  type: TYPE_NORMAL
- en: Before getting started, it is okay to be confused—most people are. Although
    ROS is one of the best tools to learn and develop robotics applications, it also
    comes with a steep learning curve, with the first roadblock being understanding
    what it is.
  prefs: []
  type: TYPE_NORMAL
- en: In this quick first chapter, I will explain the terminology we will use throughout
    this book. You will then see why ROS exists, and what problems it can solve for
    you. After that, we will dive a bit deeper into the four pillars of ROS to understand
    what it is. You will also see a few examples of when and when not to use it.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have a better understanding of the global
    picture behind ROS and be clear of the most common confusions. You will also understand
    what prerequisites you need before you get started with ROS, as well as how to
    follow this book to get the most out of it. This will help you get started on
    the right foot.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Terminology
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is ROS, when should we use it, and why?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ROS 1 versus ROS 2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prerequisites for starting with ROS 2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to follow this book
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Terminology
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You might have seen the terms ROS, ROS 1, ROS 2, and other kinds of variations
    (with or without a space), which can be confusing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s clear this up now:'
  prefs: []
  type: TYPE_NORMAL
- en: ROS 1 is (was) the first version of ROS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ROS 2 is the second and newer version of ROS and will be the focus of this book
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this book, I will use the following convention:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ROS**: When talking about general ROS concepts, philosophy, and so on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ROS 1**: When talking specifically about the first version of ROS. However,
    this will be quite rare since the focus here is on ROS 2'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ROS 2**: When talking about the second version of ROS'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: I may sometimes write *ROS* or *ROS 2* interchangeably since we won’t be focusing
    on ROS 1 here.
  prefs: []
  type: TYPE_NORMAL
- en: It’s not impossible that, in the future (when ROS 1 has completely disappeared),
    the name ROS 2 becomes ROS again. If you’ve heard about Angular, it started as
    AngularJS, after which they released Angular2, and then a few years later, it
    simply became Angular. I guess that something similar will happen with ROS, although
    this is only a theory of mine for now.
  prefs: []
  type: TYPE_NORMAL
- en: What is ROS, when should we use it, and why?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start understanding what ROS is, let’s understand why we would need
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Why ROS?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s start with a big problem that occurs often in robotics.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that you just got a new project at your job, and you have to develop
    a robotics application, or you are doing a new research thesis. One very important
    thing to take into account is that in real life, any project or thesis will have
    a specific duration, from a few months to a few years.
  prefs: []
  type: TYPE_NORMAL
- en: Now, what will happen?
  prefs: []
  type: TYPE_NORMAL
- en: You start to design the robotics system you need for your project and soon realize
    that it will take a lot of time to develop the robot because all the existing
    solutions you found don’t match what you need. After a few weeks, you finalize
    the specifications, and you start building your robot. A few months in, you’re
    still developing the basic software for wheel control and navigation. You underestimated
    how much time it would take you to just get the robot running. After 1 or 2 years,
    you realize that all you’ve done for now is build a robotics system, and you still
    haven’t started the core functionality of your application or research. Now is
    the time to hurry.
  prefs: []
  type: TYPE_NORMAL
- en: You finish the robot as well as you can, make some shortcuts, and publish your
    paper or present that prototype. In the best-case scenario, you could also share
    your code with an open-source license so that other people can use it, but probably
    not directly as it’s just code for your own need, not a complete framework or
    library with modular components, documentation, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Then, you move on to a new project, new job, and new research. Somebody else
    will take your place, read your code, and realize that it doesn’t help them build
    their application. Hence, they have to start from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: 'What just happened here is that you reinvented the wheel. The next person will
    repeat the same circle. And this is much more common than you think. People keep
    reinventing the wheel over and over again. This is the number one reason why ROS
    was created: to stop you from reinventing the wheel anytime you need to create
    a robot. Just like you have open-source frameworks, tools, and environments to
    develop websites or mobile applications, why not do the same for robotics? This
    is the philosophy behind ROS: to provide a *standard* for robotics applications
    that you can use on *any robot*.'
  prefs: []
  type: TYPE_NORMAL
- en: After you learn ROS, you can spend less time on the basics and focus on the
    key functionalities you want to add instead. You can program new robots in no
    time, join existing projects, and easily collaborate with a team.
  prefs: []
  type: TYPE_NORMAL
- en: What is ROS?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ROS is hard to define because it’s not just one thing. And to be honest, I don’t
    think you can truly understand what it is until you start to understand how to
    write code with it.
  prefs: []
  type: TYPE_NORMAL
- en: One thing we can start with is what ROS is not.
  prefs: []
  type: TYPE_NORMAL
- en: 'ROS is not an operating system. It’s a combination of four main parts:'
  prefs: []
  type: TYPE_NORMAL
- en: Framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set of tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plug-and-play plugins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An online community
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s dive a bit more into each of these parts.
  prefs: []
  type: TYPE_NORMAL
- en: ROS is a framework with plumbing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: ROS comes with a set of rules on how to build an application. As we will see
    in this book, you will need to create packages, and then write programs inside
    those packages (nodes). There is a specific way to create and write them, as well
    as create tools to build and use them.
  prefs: []
  type: TYPE_NORMAL
- en: Any framework comes with a specific set of rules. The remarkable thing about
    this is that after you’ve created a few projects, any new project is going to
    be easier and faster to set up. Also, as everyone is following the same set of
    rules, you can more easily work in a team or understand and use the code written
    by others.
  prefs: []
  type: TYPE_NORMAL
- en: As a direct consequence of using this framework, you get access to what is often
    referred to as **plumbing**, which means that the underlying communication between
    the nodes is managed for you. Imagine that you’re building a house, and the plumbing
    or electrical system is already done for you. This will save you a lot of development
    time, and you also don’t need to learn how to do it yourself (and thus, reinvent
    the wheel).
  prefs: []
  type: TYPE_NORMAL
- en: To sum it up, with ROS, you can easily separate your application into different
    sub-programs (called **nodes**). The communication between nodes is handled for
    you. You can easily test one component, and if this component fails, it will not
    affect the other running components. ROS is a modular framework.
  prefs: []
  type: TYPE_NORMAL
- en: A set of tools
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: ROS comes with a set of tools that allow you to develop faster. Among them,
    you can find command-line tools to build the application, introspection tools
    to monitor the flow of communication, logging functionalities, plots, and more.
  prefs: []
  type: TYPE_NORMAL
- en: You also get 3D visualization tools to see what your robot is doing, and even
    a complete simulator using real physics, named **Gazebo**, so that you can work
    on a realistic simulation before trying out your robot.
  prefs: []
  type: TYPE_NORMAL
- en: There are quite a lot of available tools, and we’ll discover many of them throughout
    this book. As an example of how useful it can be, there is one (called **bags**)
    that allows you to save communication streams so that they can be replayed later.
    Let’s say you build a mobile robot, and you need to test the robot outside when
    it’s raining, then continue to develop the software while taking the rain into
    account. You probably won’t have rain every day, or you won’t even have access
    to the robot any time you want. With this tool, you can run the experiment once,
    save the data, and replay it later to develop your application for a specific
    set of conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Capabilities – plug-and-play plugins and stacks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is probably where you will save hundreds of hours. Imagine two common
    scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: You develop a mobile robot and need the robot to navigate autonomously in a
    dynamic environment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You develop a six-axis robotic arm and want to create motion planning to perform
    a smooth movement on all axes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This looks quite complex and involves understanding and implementing several
    algorithms, as well as writing well-optimized and efficient code. This is where
    you would probably have to reinvent the wheel and waste lots of precious time.
  prefs: []
  type: TYPE_NORMAL
- en: For those two scenarios, you can find existing plugins that do the job for you.
    All you need to do is install the plugins and configure your robot to make it
    compatible. Of course, this is easier said than done, but the workload can be
    counted in days/weeks, not months/years. And once again, once you know how to
    use those plugins, your next project will take much less time.
  prefs: []
  type: TYPE_NORMAL
- en: There are many plugins that you can use. Some are quite simple, while others
    involve a collection of plugins and are also called frameworks or stacks. Your
    job as a ROS developer is to *glue* all those components together, and maybe create
    new components for functionalities that are not developed yet.
  prefs: []
  type: TYPE_NORMAL
- en: Online community
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is the fourth pillar of ROS, and it’s quite an important one: the community.
    ROS is an open-source project with a permissive license. I can’t give you any
    legal advice on licensing, but you can use ROS in a commercial product without
    having to redistribute your code.'
  prefs: []
  type: TYPE_NORMAL
- en: You can find all the ROS code online, as well as the code for the plug-and-play
    plugins. Everything is easily accessible on GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ROS project is also backed by an online community that you can most commonly
    find in the following areas:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Robotics Stack Exchange** ([https://robotics.stackexchange.com/](https://robotics.stackexchange.com/)):
    You can use this to ask technical questions. If you know Stack Overflow, as most
    developers do, well, this is Stack Overflow for robotics.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ROS Discourse forums** ([https://discourse.ros.org/](https://discourse.ros.org/)):
    Here, you can get informed about the latest developments, jobs, community projects,
    new ideas, and more. I recommend checking this website often to stay up to date
    with where ROS is going.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When to use ROS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you understand a bit more what ROS is, should you use ROS whenever
    your project has something 'robotics' in it? In this section, I will give you
    some hints on when using ROS makes sense, backed by some examples to give you
    a better idea.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, if you’re reading this book because you need to learn ROS for your work/university,
    then the question is easily answered: yes, you will use ROS for your project.'
  prefs: []
  type: TYPE_NORMAL
- en: But if you must make the decision yourself, what should you do?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s simplify robotics and say that a robotics system contains three categories
    of things: actuators, sensors, and controllers.'
  prefs: []
  type: TYPE_NORMAL
- en: 'An **actuator** is something that creates movement (for example, a motor to
    rotate a wheel). A **sensor** will read data from the environment (for example,
    a camera, laser scan, or temperature sensor). A **controller** is something that
    is in between: it takes the data available from one or multiple sensors (input)
    and, through an algorithm, creates a command for the actuators of the robot (output).
    In a way, the controller is the *brain* or one of the brains of the robot.'
  prefs: []
  type: TYPE_NORMAL
- en: For very simple applications, when you just have a few sensors and actuators,
    you might not need ROS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few examples where ROS isn’t needed:'
  prefs: []
  type: TYPE_NORMAL
- en: You just need to take a picture from a camera when a user presses a button,
    using a Raspberry Pi board, and send this picture to a web server. There’s no
    need to use ROS—you can just combine a few Python libraries in a script, and you’re
    done. Using ROS here would be a good example of over-engineering (unless you do
    this for learning purposes).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You have to use a servo motor to open/close a door when a movement is detected,
    using an infrared sensor. This is a very simple application that can easily be
    programmed using a basic microcontroller board—and you can do a quick prototype
    with a board such as Arduino.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You have built a simple robot with two wheels and an infrared sensor, and you
    want to make the robot follow a line. This is a typical project that’s given to
    students in engineering school, and a simple algorithm on an Arduino board will
    do.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let’s consider some examples where ROS is needed:'
  prefs: []
  type: TYPE_NORMAL
- en: You have a new mobile robot with two wheels and a laser scan, and you want to
    read data from the laser scan, map the environment, make the robot move autonomously,
    and control the two wheels accordingly. On top of that, you want to simulate the
    robot in 3D with real physical properties. This is when ROS is going to become
    very handy. Not only will it help you to make all the components work together,
    but you can also use existing algorithms for path planning (through a ROS plugin)
    and simulation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You need to create a system that contains a six-axis robotic arm, or even multiple
    robotic arms working together, along with conveyor belts and mobile robots.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your robotics application (not necessarily just one robot) contains lots of
    sensors and actuators that you want to develop separately and add them in a modular
    way.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You want to create a hardware driver for a component and make this component
    easy to use by other robotics developers. By making the component *ROS-compatible*,
    anybody who knows ROS can integrate it into their application with low effort.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see from the former examples, ROS is not always needed whenever you
    need to program hardware or create a robotics system. Of course, you could use
    it for any application, but it’s like if you were to use a complete web framework
    (for example, Django) for a single static web page.
  prefs: []
  type: TYPE_NORMAL
- en: With the latter examples, you can see that if your system becomes more complex,
    if you want to easily collaborate with other developers, or if you realize that
    one big part of your system can be solved with one of the plug-and-play plugins,
    ROS may be the solution.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, it takes time to learn it and your first project will take longer
    to complete, but then, with more experience, you will go much faster.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, it could take less than a week for a senior ROS developer to
    write custom code for a robotic arm (including robot model, motion planning, and
    hardware control) and the same for a mobile robot with navigation capabilities
    (provided that the hardware already has a ROS driver). Less than a week and you
    get a working software prototype.
  prefs: []
  type: TYPE_NORMAL
- en: ROS 1 versus ROS 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To be clear, this book is all about ROS 2, not ROS 1\. You will start learning
    ROS 2 from zero experience. This section is probably the only time I will be talking
    that much about ROS 1.
  prefs: []
  type: TYPE_NORMAL
- en: A quick story of ROS, and how we got to ROS 2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ROS 1 (originally called ROS) was first developed in 2007\. It quickly gained
    popularity and grew exponentially in the following years.
  prefs: []
  type: TYPE_NORMAL
- en: In 2014, the ROS 2 project was announced. Simply put, ROS 1 was a bit too limited
    for industrial applications (lack of real-time support, safety, and so on) and
    was only used in research/education. To solve this problem, the developers decided
    to make ROS more “industrial friendly,” as well as make it better, thanks to all
    the lessons learned from the beginning of ROS.
  prefs: []
  type: TYPE_NORMAL
- en: Now, why create ROS 2 and not just continue ROS with some new changes? Well,
    the changes were too big, and they would have completely broken compatibility
    with older versions. Thus, it was decided to create a completely new ROS from
    scratch and name it ROS 2\. In 2014, ROS 2 was officially announced, and the development
    of the project started.
  prefs: []
  type: TYPE_NORMAL
- en: In December 2017, the first ROS 2 distribution was released, which meant that
    ROS 1 and ROS 2 started to co-exist. At this point, ROS 2 was lacking many core
    functionalities and plugins, making it unsuitable for serious projects. Most ROS
    developers were still using ROS 1.
  prefs: []
  type: TYPE_NORMAL
- en: Years passed by and ROS 2 got more development, plugins, and more. Its popularity
    started to grow.
  prefs: []
  type: TYPE_NORMAL
- en: I would say it was worth it to use ROS 2 (compared to ROS 1) starting from 2022\.
    This is probably more of a personal opinion and some people might disagree, but
    from 2022 and the release of **ROS 2 Humble** (more on distributions in [*Chapter
    2*](B22403_02.xhtml#_idTextAnchor048)), we had access to a long-term release that
    was stable, with all the major plugins and stacks working correctly, which is
    what you need to program a robot.
  prefs: []
  type: TYPE_NORMAL
- en: In the meantime, it was announced that ROS 1 would end in May 2025\. After this
    date, ROS 1 would still exist, but it wouldn’t be supported anymore.
  prefs: []
  type: TYPE_NORMAL
- en: 2023 was the year with the most significant shift from ROS 1 to ROS 2 among
    the ROS community. It is now safe to say that ROS 2 is the way to go when developing
    new ROS applications.
  prefs: []
  type: TYPE_NORMAL
- en: So, if you had previously heard about ROS 1 and ROS 2, now you know that ROS
    2 is what you need to learn, and we can say that ROS 1 is a dead project. But
    is that true?
  prefs: []
  type: TYPE_NORMAL
- en: Is ROS 1 dead already?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In theory, yes, but in practice, it’s (always) a bit different. As you probably
    know, several companies are using obsolete and legacy technologies. The reason
    is that updating software to a new version is often quite expensive and can also
    be risky. That’s why you still see job offers from banking systems requiring skills
    in Cobol, a programming language from the 1960s that no one uses anymore.
  prefs: []
  type: TYPE_NORMAL
- en: In robotics, things are a bit similar. Some companies have released robots with
    a specific version of ROS 1, and while the robot is still on the market, the company
    will not upgrade and still use and maintain the previous version, also called
    *legacy*. Thus, the definitive transition in 2025 is going to take a few more
    years.
  prefs: []
  type: TYPE_NORMAL
- en: Why am I writing this? Simply to let you know that if you happen to get a job
    in a robotics company that has been using ROS already, you might encounter a few
    ROS 1 projects, even after ROS 1 is officially finished. However, be assured that
    all the ROS 2 knowledge you have can easily be ported to ROS 1 as the core concepts
    are the same.
  prefs: []
  type: TYPE_NORMAL
- en: To conclude, for all new learnings, projects, studies, teaching, and startups,
    ROS 2 is what you need. I will now close this chapter of ROS 1 and focus on ROS
    2\. As mentioned previously, I might write *ROS* or *ROS 2* interchangeably as
    we aren’t targeting ROS 1 here.
  prefs: []
  type: TYPE_NORMAL
- en: Prerequisites for starting with ROS 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To get started with ROS and this book, there are a few things you need to know.
  prefs: []
  type: TYPE_NORMAL
- en: Knowledge prerequisites
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is best that you have some knowledge of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Linux command line**: Since we’ll be using **Ubuntu**, being familiar with
    Linux is mandatory. You don’t need to be an expert—you just need to know the basics.
    Many tools in ROS 2 involve the command line, so knowing how to open a Terminal
    and write basic commands will help you tremendously.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Python programming**: The two most common languages for ROS are **Python**
    and C++. Python is easier to get started with and allows you to prototype things
    faster. Hence, this is the language we will use for all detailed explanations.
    You need to know Python basics, and **object-oriented programming** (**OOP**)
    is a good plus as ROS 2 is heavily using OOP everywhere.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Optional**: **C++** programming. Even if the focus of the book is on Python,
    I still wanted to include C++ code for everything we do. If you only want to learn
    Python, you can ignore the C++ code, but of course, if you want to follow C++
    instructions, you need C++ basics (better with OOP).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I want to emphasize that it will be much, much easier for you to learn ROS 2
    if you have good programming and Linux basics. Learning ROS is already quite challenging
    (though with this book, the goal is to reduce the learning curve), so if you’re
    starting ROS, Linux, and Python from scratch, this could be overwhelming.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re reading these lines and you don’t know how to write a Python function
    or navigate to a directory in the Terminal, then I really recommend that you pause
    here, take some time to learn Python and Linux basics, and come back to this book.
    There’s no need to spend hundreds of hours doing this but investing some time
    to get the basics right will help you finish this ROS 2 book faster.
  prefs: []
  type: TYPE_NORMAL
- en: Hardware and software
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You’ll need to have a computer to follow this book. Regarding the specifications,
    you don’t need anything fancy to get started with ROS 2\. If you can open a web
    browser with a few tabs and have a smooth experience, I would say that your computer
    is good enough to get started.
  prefs: []
  type: TYPE_NORMAL
- en: Then, later, depending on what you want to do with ROS, you might need a better
    machine (for example, if you want to simulate multiple robots using lots of sensor
    and image processing). However, it’s probably better to wait until you need the
    extra power to upgrade. For now, the most important thing to do is start learning
    ROS.
  prefs: []
  type: TYPE_NORMAL
- en: For software requirements, I will give you the necessary installation instructions
    throughout this book. All the software we will be using is free to use and open
    source.
  prefs: []
  type: TYPE_NORMAL
- en: We will also use Ubuntu 24.04, in which we will run ROS 2\. Having Ubuntu installed
    is a requirement, but I will give you a recap in [*Chapter 2*](B22403_02.xhtml#_idTextAnchor048).
  prefs: []
  type: TYPE_NORMAL
- en: How to follow this book
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The book is divided into three parts, including 14 chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Each chapter can be followed individually, although for one chapter, you need
    the knowledge from all previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you got this book because you just want to get started from scratch, then
    it’s simple: follow the book in the order it’s been written. I have designed it
    specifically so that you learn the concepts one step at a time without having
    to think about what directions you should take.'
  prefs: []
  type: TYPE_NORMAL
- en: Then, as you progress, feel free to come back to any chapter to clear up doubts.
    I encourage you to do that. The first time you learn about a concept, you don’t
    necessarily grasp all the subtleties. As you continue with this book and use the
    concept along with other new concepts, you often have ‘epiphany moments’, when
    everything clicks together.
  prefs: []
  type: TYPE_NORMAL
- en: If you already know some ROS 2 basics (or you’ve already read this book), then
    feel free to jump to any chapter. If a chapter starts from a code base that we
    developed in previous chapters, then you will be able to download the code and
    start from there.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a GitHub repository you can use to follow this book: [https://github.com/PacktPublishing/ROS-2-from-Scratch](https://github.com/PacktPublishing/ROS-2-from-Scratch).
    All the code we’ll write is hosted there, so be sure to use this GitHub repository
    closely while following along. I will explain how to use this repository a bit
    later in this book.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this introductory chapter, we cleared up some of the most common confusion
    points regarding ROS: its name, what it is and isn’t, when to use it, and why.
    You also learned more about the different ROS versions (ROS 1 and ROS 2), and
    you learned what kind of prerequisites you need to get started with ROS 2.'
  prefs: []
  type: TYPE_NORMAL
- en: You should now have a better understanding of the big picture, and even if everything
    still seems a bit confusing, don’t worry too much—it will all make sense when
    you use the ROS 2 concepts and code with them.
  prefs: []
  type: TYPE_NORMAL
- en: Now, to be able to use ROS 2, we need to install it. This will be the focus
    of the next chapter and will help you get your environment 100% ready for ROS
    2.
  prefs: []
  type: TYPE_NORMAL
