- en: Using GPIOs as Input
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用GPIO作为输入
- en: In the previous chapter, we understood how GPIOs are used for output. But, as
    the name suggests, the GPIO can be used for both input and output purposes. In
    this chapter, we will see how you can go ahead and use these pins to input the
    data over to Raspberry Pi.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们了解了GPIO是如何用于输出的。但是，正如其名称所暗示的，GPIO可以用于输入和输出两种目的。在本章中，我们将看到如何使用这些引脚将数据输入到树莓派。
- en: 'The topics which we will cover in this chapter are:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖的主题是：
- en: A deeper dive into GPIOs
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入了解GPIO
- en: Interfacing the PIR sensor
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PIR传感器的接口
- en: Interfacing the ultrasonic proximity sensor
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 超声波接近传感器的接口
- en: Interfacing through I2C
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过I2C进行接口
- en: A deeper dive into GPIOs
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入了解GPIO
- en: 'I am sure you remember this line of code from the previous chapter:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信你记得上一章中的这一行代码：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As explained earlier, this basically tells us how GPIO the pin will behave
    in a certain program. By now, you must have guessed that by changing this single
    line of code we can change the behavior of the pin and convert it from output
    to input. This is how you would do it:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，这基本上告诉我们GPIO引脚在某个程序中的行为。到现在，你可能已经猜到了，通过更改这一行代码，我们可以改变引脚的行为，将其从输出转换为输入。这就是你应该如何做：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Once you write this line of code in your program, the microcontroller will know
    that during the time that the program is being run, the pin number `18` will only
    be used for input purposes.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你在程序中写下这一行代码，微控制器就会知道在程序运行期间，引脚号`18`将仅用于输入目的。
- en: 'To understand how this would actually work, let''s head back to our hardware
    and see how it can be done. Firstly, you need to connect an LED to any of the
    pins; we will be using pin number `23` in this program. Secondly, you need to
    connect a switch on pin number `24`. You can refer the diagram that follows for
    making the connections:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这实际上是如何工作的，让我们回到我们的硬件，看看它是如何实现的。首先，你需要将一个LED连接到任何一个引脚上；在这个程序中，我们将使用引脚号`23`。其次，你需要将一个开关连接到引脚号`24`。你可以参考下面的图示来制作连接：
- en: '![](img/8bac0a39-8e8e-4e0f-b91d-c14c9ea4e497.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8bac0a39-8e8e-4e0f-b91d-c14c9ea4e497.png)'
- en: 'Once you connect it, you can go ahead and write this program:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦连接好，就可以继续编写这个程序：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Once the program is uploaded, then, as soon as you press the push button, the
    LED will turn itself on.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 程序上传后，一旦按下按钮，LED就会自动点亮。
- en: Let's understand what exactly is happening. `while True:` is basically an infinite
    loop; once you apply this loop, the code running inside it is repeated over and
    over again until something breaks it, and by break I mean some interruption that
    causes the program to stop and exit. Now, ideally we exit the program by pressing
    *Ctrl* + *C* whenever there is an infinite loop.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解究竟发生了什么。`while True:`基本上是一个无限循环；一旦应用了这个循环，循环内部的代码会一直重复执行，直到某个中断使其停止并退出。现在，理想情况下，我们通过按下*Ctrl*
    + *C*来退出程序。
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the above line, the program understands where it has to look; in this program.
    In this line we are telling the program that we are looking for GPIO `24`, which
    is an input:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述行中，程序理解了它需要查找的位置；在这个程序中。在这一行中，我们告诉程序我们在寻找GPIO `24`，它是一个输入：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If the button is high, in other words when the button is pressed and the current
    is reaching the pin number `24`, then the GPIO pin number `23` will be set to
    high:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果按钮处于高电平状态，换句话说，当按钮被按下且电流达到引脚号`24`时，GPIO引脚号`23`将被设置为高电平：
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If the pin number `24` is not true, it will follow this line of code and will
    keep the pin number `23` low, in other words switched off.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果引脚号`24`不是真的，它将遵循这一行代码，并将引脚号`23`保持低电平，换句话说，关闭。
- en: So, there it is, your first program for using the GPIOs for input purposes.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这就是你使用GPIO进行输入目的的第一个程序。
- en: Interfacing the PIR sensor
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PIR传感器的接口
- en: So far, so good! In this unit, we will go ahead and interface out first sensor,
    which is a passive infrared, commonly known as a PIR sensor. This sensor is a
    very special sensor and is used very commonly in automation projects. Its low
    energy consumption makes it a superb contender for IoT projects as well. So let's
    see how it works.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利！在本单元中，我们将继续接口我们的第一个传感器，这是一个被动红外传感器，通常称为PIR传感器。这个传感器是一个非常特殊的传感器，在自动化项目中非常常用。它低能耗的特性使其成为物联网项目的绝佳候选者。那么，让我们看看它是如何工作的。
- en: You must have noticed that when we heat a metal to a high temperature, it slowly
    gets dark red in color, and when we heat it further, it gets brighter and slowly
    goes from red to yellow as depicted in the below diagram which shows a red hot
    steel tab. Now, as the temperature increases, the wavelength of the emitted radiation
    decreases; that is why with the increase in temperature the color changes from
    red to yellow, as yellow has a shorter wavelength compared to red.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你一定注意到了，当我们把金属加热到高温时，它会逐渐变成暗红色，当我们进一步加热时，它会变得更亮，并逐渐从红色变为黄色，如以下所示，该图显示了红热的钢片。现在，随着温度的升高，发出的辐射波长减小；这就是为什么随着温度的升高，颜色从红色变为黄色，因为黄色的波长比红色短。
- en: '![](img/9ddb9af7-40a5-44f6-b1c0-c0ea8d7c3974.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9ddb9af7-40a5-44f6-b1c0-c0ea8d7c3974.png)'
- en: But the interesting part is that even when the objects are not heated enough,
    they emit radiation; in fact, any object that is above the temperate of absolute
    zero emits some form of radiation. Some we can see with the naked eye, others
    we can't. So, at room temperature, objects emit infrared radiation which has a
    higher wavelength compared to visible light. Hence, we don't see it with our eyes.
    Nonetheless, it is still there.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 但有趣的部分是，即使物体没有足够加热，它们也会发出辐射；事实上，任何高于绝对零度的物体都会以某种形式发出辐射。有些我们可以用肉眼看到，而有些则不能。因此，在室温下，物体发出红外辐射，其波长比可见光长。因此，我们用眼睛看不到它。尽管如此，它仍然存在。
- en: What this PIR sensor does is that it senses the infrared light from the objects
    around it and whenever an object moves, it can sense the overall change in its
    pattern and, based on that, can detect if there is any movement that has happened
    in its proximity.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这个PIR传感器所做的是，它感知周围物体的红外光，每当物体移动时，它都能感知其模式的整体变化，并根据这个变化检测其附近是否发生了任何运动。
- en: 'We assume that whenever there is someone in a room there will be some inherent
    movement that will happen, and hence this sensor is very commonly used as an occupancy
    sensor. Now, let''s connect this sensor and see how we can use it:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设只要房间里有人，就会有一些固有的运动发生，因此这种传感器非常常用作占用传感器。现在，让我们连接这个传感器，看看我们如何使用它：
- en: '![](img/5cdeb242-f3b0-4a88-8ee5-eae7a520d307.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5cdeb242-f3b0-4a88-8ee5-eae7a520d307.png)'
- en: 'Once you have connected it as per the preceding diagram, go ahead and upload
    the code: :'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦按照前面的图连接好，就可以上传代码了：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, let's see what is happening. The logic is very simple. As soon as the PIR
    sensor detects movement, it turns its output pin to high. All we have to do is
    to monitor that pin and that's basically it.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看发生了什么。逻辑非常简单。一旦PIR传感器检测到运动，它就会将其输出引脚转为高电平。我们只需要监控那个引脚，基本上就是这样。
- en: The logic is entirely similar to that of a push-button switch, and it will also
    work in a similar manner. So not much explaining is needed.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑与按钮开关完全相同，它将以类似的方式工作。所以不需要太多解释。
- en: Interfacing the ultrasonic proximity sensor
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 超声波接近传感器的接口
- en: First, the basics. A proximity sensor is a type of sensor that senses the proximity
    of an object from it. There is a universe full of sensors that are available to
    accomplish this task and numerous technologies that allow us to do so. As the
    name says, the ultrasonic proximity sensor works on the principal of ultrasonic
    sound waves. The working principle is quite easy to understand. The ultrasonic
    sensor sends a beam of ultrasonic sound waves; these waves are inaudible to human
    ears, but nonetheless it is still a sound wave and it also behaves like a sound
    wave.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们从基础知识开始。接近传感器是一种能够感知物体与其之间距离的传感器。为了完成这项任务，有一个充满传感器的宇宙可供选择，还有许多技术使我们能够做到这一点。正如其名称所示，超声波接近传感器是基于超声波原理工作的。其工作原理非常容易理解。超声波传感器发送一束超声波；这些波对人类耳朵来说是听不到的，但无论如何，它仍然是一种声波，并且它也像声波一样表现。
- en: Now, as we know, sound bounces off different surfaces and forms an echo. You
    must have experienced this echo when speaking in an empty room. You can hear your
    own sound but with a slight delay. This delay is caused by the property of sound.
    A sound is a wave, hence it has a speed. Sound waves have a set speed of travel.
    So, to cover a specific distance, they take some time. By calculating this time,
    we can derive how far the sound waves are going before getting bounced off from
    a surface.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，正如我们所知，声音会在不同的表面上反弹并形成回波。当你在一个空房间里说话时，你必须已经体验过这种回声。你可以听到自己的声音，但会有轻微的延迟。这种延迟是由声音的属性造成的。声音是一种波，因此它有速度。声波有一个固定的传播速度。因此，为了覆盖特定的距离，它们需要一些时间。通过计算这个时间，我们可以推导出声波在从表面反弹之前走了多远。
- en: Similarly, in this sensor, we shoot ultrasonic sound waves in a specific direction
    and then sense the echo which bounces back. Naturally, there would be a delay
    in receiving the echo; the delay would be directly proportional to the distance
    of the object from the sensor and, based on this delay, we could easily compute
    the distance.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，在这个传感器中，我们向特定方向发射超声波，然后感应回波。自然地，接收回波会有延迟；延迟与物体从传感器到距离成正比，基于这个延迟，我们可以轻松计算出距离。
- en: 'Now, to work with the proximity sensor, we need to understand the physical
    architecture of the sensor to wire it correctly. There are four pins in the sensor,
    which are:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要使用接近传感器，我们需要了解传感器的物理结构，以便正确布线。传感器有四个引脚，它们是：
- en: VCC (positive)
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VCC（正）
- en: Trigger
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 触发
- en: Echo
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回波
- en: GND (ground)
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GND（地）
- en: 'I obviously don''t have any need to explain what VCC and ground does. So, let''s
    move on straight to trigger. Whenever the pin is high for 10 microseconds, the
    ultrasonic sensor will send eight cycles of 40 kHz sound waves to the target.
    Once the trigger cycle is completed, the **ECHO** is set to high. Once it receives
    the echo signal back, the **ECHO** pin is set back to low. Here is a diagram to
    show how it actually happens:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我没有必要解释VCC和地的作用。那么，让我们直接进入触发部分。每当引脚处于高电平10微秒时，超声波传感器将向目标发送8个周期的40 kHz声波。一旦触发周期完成，**ECHO**被设置为高电平。一旦接收到回波信号，**ECHO**引脚被设置回低电平。以下是实际发生过程的示意图：
- en: '![](img/525c7f0a-8913-4114-8f12-b108b2c8ef44.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/525c7f0a-8913-4114-8f12-b108b2c8ef44.png)'
- en: 'That is all we need to know for now. Subsequently, we will learn more as we
    move along. Now, to go ahead and make it live, connect it as per the diagram:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 目前我们只需要知道这些。随后，随着我们的学习深入，我们将了解更多内容。现在，为了使它生效，请按照以下图示进行连接：
- en: '![](img/7fedb272-4aa1-47cd-b7a6-7c78a67994af.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7fedb272-4aa1-47cd-b7a6-7c78a67994af.png)'
- en: 'Once the connection is made, the following is the code that you need to run:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦建立连接，以下是需要运行的代码：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, once you run this program, the output on your screen will be showing you
    the distance of the object once in every 0.2 seconds. Now, you must be wondering
    how this is communicating all these readings:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一旦运行此程序，屏幕上的输出将每0.2秒显示一次物体的距离。现在，你可能想知道这些读数是如何通信的：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We are assigning pin `23` to give pulse to **TRIGGER** pin of the sensor when
    required:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将引脚`23`分配给传感器，以便在需要时向**TRIGGER**引脚发送脉冲：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We are assigning pin `24` to receive the logic to confirm the receipt of the
    echo signal:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将引脚`24`分配来接收逻辑，以确认回波信号的接收：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We will be using the preceding as variables, and every time the loop starts
    we are assigning them a value which is `0`; this is to wipe off the previous reading
    that we would have stored during the course of program:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用前面的变量，并且每次循环开始时，我们都会给它们赋一个值，这个值是`0`；这是为了清除程序执行过程中存储的先前读数：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We keep the trigger pin number `23` high for 0.000010 seconds so that the ultrasonic
    sensor can send a brief pulse of ultrasonic waves:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将触发引脚`23`保持高电平0.000010秒，以便超声波传感器可以发送一个短暂的超声波脉冲：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This while statement will keep noting down the time of the `pulse_start` variable
    until the time pin number `24` is low. The final reading of the time will be stored
    in the `pulse_start` variable, as in noting down the time when the pulse was sent:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这个while语句将记录`pulse_start`变量的时间，直到时间引脚`24`变低。最终的时间读数将存储在`pulse_start`变量中，就像记录脉冲发送的时间一样：
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `while` statement in this loop will start noting the time when the input
    on pin number `24` is high and it will keep noting the time until the pin number
    `24` remains high. The final reading of the time will be stored in the `pulse_stop`
    variable, as in noting down the time when the pulse is received:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个循环中的`while`语句将开始记录当引脚`24`上的输入为高电平时的时间，并且它将一直记录时间，直到引脚`24`保持高电平。最终的时间读数将存储在`pulse_stop`变量中，就像记录脉冲接收时的时间一样：
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In this statement we are calculating the overall time it took for the pulse
    to travel from the sensor to the object and bounce back to the receiver on the
    sensor:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个语句中，我们正在计算脉冲从传感器传到物体并反弹回传感器所需的总时间：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This is an arithmetic formula given by the manufacturer to convert the time
    duration it took for the ultrasonic waves to travel into the actual distance in
    centimeters. You may ask how did we get to this equation?
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个制造商给出的算术公式，用于将超声波传播所需的时间转换为厘米的实际距离。你可能会问我们是如何得到这个方程的？
- en: 'Let me give you a brief about it. With elementary physics we would remember
    this simple equation: *Speed* = *Distance* / *Time*.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我简要介绍一下。用基础物理学，我们会记住这个简单的方程：*Speed* = *Distance* / *Time*。
- en: Now you may also recall that the speed of sound is 343 meters per second. Now
    1 meter has 100 centimeters hence to convert this speed into centimeters per second,
    we would have to multiply the speed by 100, hence the speed would be 34,300 centimeters
    per second.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可能也记得声音的速度是每秒343米。现在1米有100厘米，因此为了将这个速度转换为每秒厘米，我们必须将速度乘以100，因此速度将是每秒34,300厘米。
- en: 'Now we know one element of the equation which is the speed. So lets put the
    value of speed into the equation. Now the equation would look something like this:
    *34,300* = *Distance* / *Time*.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了方程的一个元素，即速度。所以让我们把速度的值放入方程中。现在方程看起来可能像这样：*34,300* = *Distance* / *Time*。
- en: 'Now we know one thing that the distance which the sound is travelling is twice
    the actual distance. How ? Because the sound first goes from the sensor to the
    object. Then it bounces off that surface and reaches back to the sensor. So essentially
    it is covering twice the distance. Hence we to adapt this equation we have to
    make a small change: *34,300* / *2* = *Distance* / *Time*'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了一个事实，即声音传播的距离是实际距离的两倍。为什么？因为声音首先从传感器传到物体上。然后它从那个表面反弹回来并到达传感器。所以本质上它覆盖了双倍的距离。因此，为了适应这个方程，我们必须进行一个小小的改动：*34,300*
    / *2* = *Distance* / *Time*
- en: 'Now what we want out of this equation is distance So lets take all other part
    to the other side. Now the formula would look something like this: *17,150* *
    *Time* = *Distance*'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们从这个方程中想要得到的是距离，所以让我们把其他所有部分移到另一边。现在公式看起来可能像这样：*17,150* * *Time* = *Distance*
- en: So here we have it the formula for the distance.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这里就是我们得到距离的公式。
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As the distance the ultrasonic waves have traveled is twice the actual distance
    (once for going towards the object and second for bouncing back to the sensor),
    we divide it by half to get the actual distance:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 由于超声波传播的距离是实际距离的两倍（一次是向物体移动，第二次是反弹回传感器），我们将其除以二以得到实际距离：
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Finally, we will print the measured distance via the following statement. Anything
    that is in the quotation marks `''...''` will be written the way it has been written.
    However, `distance` is written without quotation marks, and distance is a variable.
    Hence, the variable stored in the distance will be written in the final output
    on the screen:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将通过以下语句打印出测量的距离。任何在引号`'...'`中的内容都将按照原样写入。然而，`distance`没有引号，并且`distance`是一个变量。因此，存储在`distance`中的变量将在屏幕上的最终输出中写入：
- en: '[PRE18]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The code will pause on this line for a time of 0.2 seconds. If we did not have
    this pause, then the values would come out at an incredible speed which would
    be hard for us to read or understand. If you are tinkering around, I would recommend
    removing this statement and running the code to see what happens.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 代码将在这一行暂停0.2秒。如果我们没有这个暂停，那么值将以难以置信的速度出现，这将很难阅读或理解。如果你在尝试，我建议移除这个语句并运行代码看看会发生什么。
- en: Interfacing through I2C
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过I2C接口
- en: So far, so good. Electronic circuits can be very interesting and, while they
    seem very complex, often we find that the working can be very simple. In the previous
    section, we interfaced one sensor at a time. We can go ahead and interface multiple
    sensors, but we are limited by the number of GPIOs that are present. We have also
    seen that some sensors such as ultrasonic sensors may use more than one GPIO pin
    for their working. This further reduces the number of sensors that we can interface
    with the microcontroller. Once we move on to more complex circuits, we will also
    realize that the wiring can be really messy and if a problem occurs then finding
    what's wrong becomes one tedious task.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利。电子电路可以非常有趣，虽然它们看起来非常复杂，但往往我们发现它们的工作可以非常简单。在上一个部分中，我们一次接口一个传感器。我们可以继续接口多个传感器，但我们受限于现有的GPIO数量。我们也看到，一些传感器，如超声波传感器，可能需要多个GPIO引脚来工作。这进一步减少了我们可以与微控制器接口的传感器数量。一旦我们转向更复杂的电路，我们也会意识到布线可能真的会很混乱，如果出现问题，找到问题所在将是一项繁琐的任务。
- en: 'Now, there is an even bigger problem that we face while designing robotic systems
    and that''s the problem of timing—all the work done in a system has to be synchronized.
    Most of the systems are currently sequential in nature, as in the output of one
    unit becomes the input of another:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们在设计机器人系统时面临的一个更大的问题是定时问题——系统中的所有工作都必须同步。大多数系统目前都是顺序性的，就像一个单元的输出成为另一个单元的输入：
- en: '![](img/f4e9da61-3abb-4425-a67d-14634a6a88f7.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f4e9da61-3abb-4425-a67d-14634a6a88f7.png)'
- en: Now, for the task to be completed, the **PROCESSING UNIT 1** has to deliver
    the input to **PROCESSING UNIT 2** when needed, and the same goes for **PROCESSING
    UNIT 3**. If the data is not timed perfectly, then either the **PROCESSING UNIT
    2** will keep waiting for the input from **PROCESSING UNIT 1** or, even worse,
    the **PROCESSING UNIT 1** will send the data to **PROCESSING UNIT 2** at a time
    when it does not need it. In which case, the data will get lost and the process
    will have some errors.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了完成任务，**处理单元1**必须在需要时向**处理单元2**提供输入，对**处理单元3**也是如此。如果数据没有完美地定时，那么**处理单元2**将一直等待来自**处理单元1**的输入，或者更糟糕的是，**处理单元1**将在不需要时将数据发送给**处理单元2**。在这种情况下，数据将丢失，过程将出现一些错误。
- en: 'Hence, to solve this problem, the computer scientists back in the day invented
    a system of pulsing. The clock pulse is a very simple square wave which has a
    50% duty cycle (recollect **pulse width modulation** (**PWM**)). The circuits
    are designed to do one operation at either the rising or the falling edge of the
    clock pulse. Due to this synchronization, every part of the circuit knows when
    to work. Here is what the clock pulse looks like:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了解决这个问题，早期的计算机科学家发明了一种脉冲系统。时钟脉冲是一个非常简单的占空比为50%的方波（回忆**脉冲宽度调制**（**PWM**））。电路被设计成在时钟脉冲的上升沿或下降沿执行一个操作。由于这种同步，电路的每个部分都知道何时工作。以下是时钟脉冲的外观：
- en: '![](img/3c40905e-e2fb-4fc5-8ed3-4166e7d88381.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3c40905e-e2fb-4fc5-8ed3-4166e7d88381.png)'
- en: 'Now, coming back to the point, we have two problems:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到要点，我们有两个问题：
- en: There is a physical limit to how many devices/sensors can be connected to the
    robot
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机器人可以连接的设备/传感器的数量有一个物理限制
- en: How to time the sensors and interconnected circuits to work in harmony
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何同步传感器和互联电路以协同工作
- en: 'To solve these problems, we use a very commonly used protocol called **I2C**,
    which stands for **Inter-integrated Circuits**. This protocol is extremely useful
    when we need to connect multiple devices on the same set of GPIOs, such as when
    we have only one set of GPIO pins over which multiple sensors can be linked. This
    is made possible due to unique addresses allocated to each hardware. This address
    is used to identify a sensor and then to communicate with it accordingly. Now,
    to implement the I2C protocol we need two lines; these lines are as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这些问题，我们使用一个非常常用的协议，称为**I2C**，代表**内部集成电路**。当我们需要在相同的GPIO组上连接多个设备时，这个协议非常有用，例如当我们只有一组GPIO引脚，而多个传感器可以通过这些引脚连接时。这是由于每个硬件都分配了独特的地址而成为可能的。这个地址用于识别传感器，然后相应地与之通信。现在，为了实现I2C协议，我们需要两条线；这些线如下所示：
- en: Data
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据
- en: Clock
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时钟
- en: As you may have guessed, the clock line is used to send a clock pulse to the
    devices attached to it and the data is the bus over which the data flows to and
    fro.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所猜，时钟线用于向连接到它的设备发送时钟脉冲，而数据则是数据在其中的来回流动的总线。
- en: Now, the entire I2C architecture works on a master-slave configuration, wherein
    the master generates the clock signal all the time for the slave devices and the
    slave devices have to constantly look for the clock pulse and the data packets
    sent by the master devices. Let's see how it's done.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，整个I2C架构都是基于主从配置工作的，其中主设备始终为从设备生成时钟信号，而从设备必须不断寻找主设备发送的时钟脉冲和数据包。让我们看看它是如何实现的。
- en: 'As mentioned earlier, there are two lines: the data line, which is referred
    to as **Serial Data** (**SDA**), and the clock line, which is referred to as **Serial
    Clock** (**SCL**). From now on, we will be using the terms SCL and SDA:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，有两根线：数据线，被称为**串行数据**（**SDA**），和时钟线，被称为**串行时钟**（**SCL**）。从现在起，我们将使用SCL和SDA这两个术语：
- en: '![](img/79ac98a9-6665-42b3-869d-ab8e8dd49634.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/79ac98a9-6665-42b3-869d-ab8e8dd49634.png)'
- en: 'Lets look at the main pointers shown in the diagram:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看图中显示的主要指针：
- en: '**Start condition**: To start a communication, a start condition is created
    indicating that the communication is about to happen. This condition is depicted
    by the master by keeping the SDA line low before the SCL. This indicates all the
    slave devices are ready for communication.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**启动条件**：为了开始通信，会创建一个启动条件，表示即将发生通信。这个条件是通过主设备在SCL之前保持SDA线低电平来表示的。这表示所有从设备都准备好通信。'
- en: '**Address frame**: Once the communication is started the master sends the address
    of the device that needs to be communicated with. This is a 7-bit address. In
    every clock pulse, a bit is sent, hence it takes seven clock pulses to send the
    7-bit address. After that 7-bit address is a read/write bit. This indicates to
    the device whether the master would like to write in this operation or if it wants
    to read some data. Hence, the total address frame is of 8 bits, which takes eight
    clock pulses to be sent. After these eight pulses, during the ninth clock pulse,
    the master waits for the acknowledgement from the device. This acknowledgement
    is sent by the slave device when the SDA line is pulled low by the slave device
    which is being addressed. With this strategy, the master knows that the address
    sent by it has been received and the slave device is now ready for the communication.
    If the acknowledgement is not sent back, then it is up to the master what has
    to be done.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**地址帧**：一旦通信开始，主设备会发送需要通信的设备的地址。这是一个7位地址。在每一个时钟脉冲中，发送一个比特，因此需要七个时钟脉冲来发送7位地址。之后，7位地址后面是一个读写位。这表示主设备在这个操作中是想写入还是想读取一些数据。因此，整个地址帧是8位，需要八个时钟脉冲来发送。在这八个脉冲之后，在第九个时钟脉冲期间，主设备等待设备的确认。这个确认是由被寻址的从设备通过拉低SDA线来发送的。通过这种策略，主设备知道它发送的地址已经被接收，从设备现在已准备好通信。如果确认没有发送回来，那么主设备需要决定接下来要做什么。'
- en: '**Data frame**: Once the acknowledgement is sent, depending on if it is a read
    or write operation, the data is either written by the master onto the slave or,
    in read operation, the data is sent by the slave over to the master. The length
    of this data frame can be arbitrary.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据帧**：一旦发送了确认，根据是读操作还是写操作，数据要么由主设备写入从设备，要么在读取操作中，数据由从设备发送到主设备。这个数据帧的长度可以是任意的。'
- en: '**Stop frame**: Once the data transfer is completed, the stop condition is
    made by the master to indicate that the communication has to stop. This condition
    is done when the SDA line goes from low to high after the SCL line goes from low
    to high.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**停止帧**：一旦数据传输完成，主设备会设置停止条件来指示通信必须停止。这个条件是在SCL线从低电平变为高电平之后，SDA线也从低电平变为高电平时设置的。'
- en: So this is basically how I2C communication works. For every device we have a
    7-bit address, hence we can connect up to 128 devices on a single bus. That's
    a lot of devices. The chances of running out of physical limits is almost negligible.
    Now let's go ahead and see how we can connect the sensors via this protocol. Generally,
    it is not required to do the core programming for the I2C, as it is lengthy and
    cumbersome. That's where the magic of open source comes in. There are a lot of
    developers across the globe who are working on these sensors and most of them
    are generous enough to make a library and share it for ease of programming. These
    libraries are available online and most of them take care of the complex process
    of communication.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上就是I2C通信的工作原理。对于每个设备，我们有一个7位地址，因此我们可以在单个总线上连接多达128个设备。这有很多设备。物理极限用完的可能性几乎可以忽略不计。现在让我们看看我们如何通过此协议连接传感器。通常，不需要为I2C进行核心编程，因为这既长又繁琐。这就是开源的魔力所在。全球有大量的开发者正在研究这些传感器，其中大多数人都足够慷慨，制作库并与他人分享，以便于编程。这些库在网上可用，并且大多数库都处理了通信的复杂过程。
- en: Now is the time that we interface our first I2C device, which is an analogue
    to digital converter. You must be wondering why we use this converter in the first
    place. Recall the time when we started understanding GPIO pins. These magic pins
    can be used both as input and output; you may also remember that these pins can
    either be on or off—these are all digital pins, not only when it comes to output
    but also for input. But there are a huge amount of sensors that work over analogue
    communication. Due to the digital architecture of Raspberry Pi, it is difficult
    to interface these sensors directly. Hence, we use an **analogue to digital converter**
    (**ADC**), this converter converts the analogue value of the sensors to the digital
    bits that are understandable by Raspberry Pi.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是我们连接第一个I2C设备的时候了，这是一个模拟到数字转换器。你可能想知道为什么我们首先使用这个转换器。回想一下我们刚开始理解GPIO引脚的时候。这些神奇引脚既可以作为输入也可以作为输出；你可能也记得这些引脚可以是开或关——这些都是数字引脚，不仅对于输出，对于输入也是如此。但是，有大量的传感器是通过模拟通信工作的。由于树莓派的数字架构，直接连接这些传感器是困难的。因此，我们使用一个**模拟到数字转换器**（**ADC**），这个转换器将传感器的模拟值转换为树莓派可理解的数字位。
- en: We will be connecting an LDR, the resistor will change the value of resistance
    based on how much light is falling onto it. Hence, the voltage will be dependent
    upon how much light is falling over the LDR.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将连接一个光敏电阻，电阻的阻值将根据照射到它上的光量而变化。因此，电压将取决于光敏电阻上的光量。
- en: 'Now let''s see how it is practically done. Take up your Pi and let''s get going.
    To start, firstly we need to enable I2C on our Raspberry Pi; follow the steps
    listed here:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看它是如何实际操作的。拿起你的Pi，让我们开始吧。首先，我们需要在树莓派上启用I2C；按照以下步骤操作：
- en: Open the terminal (*Ctrl* + *Shift* + *T*)
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端（*Ctrl* + *Shift* + *T*）
- en: Type `sudo raspi-config`
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入`sudo raspi-config`
- en: 'Select the interfacing options:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择接口选项：
- en: '![](img/a243036b-6009-41a8-ada5-95c07605e486.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a243036b-6009-41a8-ada5-95c07605e486.png)'
- en: 'Then go to Advanced Options:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后转到高级选项：
- en: '![](img/34b9c23e-33f6-40c7-b0e5-9fb0ef4fdc08.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/34b9c23e-33f6-40c7-b0e5-9fb0ef4fdc08.png)'
- en: 'Then select I2C to enable it. Then select Yes:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后选择I2C以启用它。然后选择是：
- en: '![](img/8576cbcc-fd1c-49a7-9770-c4b05487d6c7.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8576cbcc-fd1c-49a7-9770-c4b05487d6c7.png)'
- en: 'Now install the `adafruit` library to interface the ADC1115:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在安装`adafruit`库以连接ADC1115：
- en: 'Open the terminal and copy the following command:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并复制以下命令：
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This command downloads the libraries and the dependencies over to Raspberry
    Pi
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将库和依赖项下载到树莓派上
- en: 'Now type the following:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在输入以下内容：
- en: '[PRE20]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This command installs the libraries and the dependencies over to Raspberry Pi.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将库和依赖项安装到树莓派上。
- en: 'Now that the software is set up, let''s get the hardware ready. Connect Raspberry
    Pi to the ADS1115 as shown in the following diagram:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在软件已经设置好了，让我们准备好硬件。按照以下图示将树莓派连接到ADS1115：
- en: '![](img/e2d82974-e11d-48c9-9af8-c153cfc1de35.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e2d82974-e11d-48c9-9af8-c153cfc1de35.png)'
- en: 'Once you are ready, go ahead and upload this code in Pi:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦准备好，请上传此代码到Pi：
- en: '[PRE21]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Note that there can be times when this code may not work, in which case try
    tweaking the value of threshold:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，有时此代码可能无法正常工作，在这种情况下，请尝试调整阈值值：
- en: '[PRE22]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: What you might have noticed is that whenever the LDR is faced towards a light
    source, the LED also switches on, and whenever it is away from light, the LED
    switches off.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，每当光敏电阻（LDR）面向光源时，LED也会打开，而每当它远离光源时，LED就会关闭。
- en: 'So now you have interfaced an I2C device. Let''s understand how this code is
    actually working:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 所以现在你已经连接了一个I2C设备。让我们了解这段代码是如何实际工作的：
- en: '[PRE23]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The preceding line of code imports the `Adafruit_ADS1x15` library in the code
    so that we can use all its functions during the program.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码行在代码中导入了`Adafruit_ADS1x15`库，这样我们就可以在程序中使用它的所有功能。
- en: '[PRE24]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The preceding line of code creates the instance of the library `Adafruit_ADS1x115`.
    The line `.ADS1115()` is the function for creating the instance as `adc`. Understood
    anything? Let me put it in English.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码行创建了库的实例`Adafruit_ADS1x115`。`.ADS1115()`是创建实例为`adc`的函数。你理解了吗？让我用英语解释一下。
- en: 'Now, instead of writing `Adafruit_ADS1x15` all the time, we can simply write
    `adc` to call the library functions. Further, you can use any word instead of
    `adc`; it can be your cat''s name or your neighbor''s name, and it would still
    work:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们不再需要每次都写`Adafruit_ADS1x15`，我们可以简单地写`adc`来调用库函数。此外，你可以用任何词来代替`adc`；它可以是你猫的名字，也可以是你邻居的名字，它仍然会工作：
- en: '[PRE25]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This is the value to which the sensing would be done. `1` depicts that the sensing
    would happen in full range. Which for our ADC is from a voltage range of 0V to
    +/-4.096V.  Now changing the gain would result in change of the sensing range.
    I.e. if we change the value of gain to `2` Then the Range in which the sensing
    would happen would be Half of the original range i.w. 0 to +/- 2.048 Volts.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这是感应将进行的值。`1`表示感应将在全范围内进行。对于我们的ADC来说，这是从0V到 +/-4.096V的电压范围。现在改变增益将导致感应范围的变化。也就是说，如果我们把增益的值改为`2`，那么感应发生的范围将是原始范围的一半，即0到
    +/- 2.048伏特。
- en: Now you must be asking what is the voltage range and why are we changing the
    gain ?
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可能想知道电压范围以及为什么我们要改变增益？
- en: 'The reason is simple. There are different types of analog sensors. Which give
    output in a wide variety of voltage range. Some sensors can give you output in
    the range of 0.5 volt to 4 volt others can give you from 0.1 volt to 0.98 volts.
    Now if we set the gain to `1` then the all of these sensors could be easily interfaced.
    As all of them fall in between the sensing range of 0 to 4.098 Volts. However
    as it is a 16 bit ADC hence the total number of discrete values that the ADC can
    provide would be in between 2^(16) or 65,536 readings. Hence at the gain of `1`
    the minimum voltage change that the ADC could detect would be: *4.096 */ *65536*
    = *0.000062*.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 原因很简单。有不同类型的模拟传感器，它们在广泛的电压范围内提供输出。一些传感器可以在0.5伏特到4伏特的范围内提供输出，而其他传感器可以从0.1伏特到0.98伏特提供输出。现在如果我们把增益设置为`1`，那么所有这些传感器都可以轻松连接。因为它们都位于0到4.098伏特的感应范围内。然而，由于它是一个16位ADC，因此ADC可以提供的离散值的总数将在2^(16)或65,536次读取之间。因此，在增益为`1`时，ADC能够检测到的最小电压变化将是：*4.096 */
    *65536* = *0.000062*。
- en: 'But if increase the gain to `4` then the sensing range would reduce to a mere
    `0` to +/- 1.0245\. So this would be able to work with the output range between
    0.1 volt to 0.98 volt. But now lets see the minimum voltage change that it could
    detect: *1.0245* / *65536* = *0.00001563*.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你将增益增加到`4`，那么感应范围将减少到仅仅`0`到 +/- 1.0245。因此，它将能够在0.1伏特到0.98伏特的输出范围内工作。但现在让我们看看它能够检测到的最小电压变化：*1.0245*
    / *65536* = *0.00001563*。
- en: Now as you can see the minimum voltage that can be detected is very low. Which
    is a good thing for the compatibility with sensor.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以看到，可以检测到的最小电压非常低，这对于与传感器的兼容性来说是个好事。
- en: 'Now, it is up to you as to what gain value you want. The LDR is working on
    5V, hence it is better for us to use the entire gain reading of `1`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，选择你想要的增益值取决于你。LDR在5V下工作，因此我们最好使用整个增益读取`1`：
- en: '[PRE26]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'When you look closely at the ADC hardware, you will notice that there are various
    pins including **A0**, **A1**, **A2**, and **A4** This is a four-channel ADC—it
    can convert four analogue inputs and convert them into digital data. As we are
    only using one single data stream, we will be letting Pi know which pin it is
    connected on. With the following line, we are telling Pi to start the process
    of converting the data:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当你仔细观察ADC硬件时，你会注意到有各种引脚，包括**A0**、**A1**、**A2**和**A4**。这是一个四通道ADC——它可以将四个模拟输入转换为数字数据。由于我们只使用一个单一的数据流，我们将让Pi知道它连接在哪个引脚上。通过以下行，我们告诉Pi开始转换数据的过程：
- en: '[PRE27]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the following line, we are instructing the ADC to stop the conversion, and
    that's where the code ends.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一行，我们正在指示ADC停止转换，这就是代码的结束之处。
- en: '[PRE28]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Summary
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter was all about interfacing sensors with GPIOs so that the data can
    be retrieved by sensors. Moving forward, in the next chapter, with the help of
    these learned topics, we will learn how to make a pet-feeding robot.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 本章主要讲述了如何将传感器与GPIO接口连接，以便通过传感器获取数据。向前推进，在下一章中，借助这些已学到的主题，我们将学习如何制作一个宠物喂食机器人。
