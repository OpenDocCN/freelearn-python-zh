- en: Using GPIOs as Input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we understood how GPIOs are used for output. But, as
    the name suggests, the GPIO can be used for both input and output purposes. In
    this chapter, we will see how you can go ahead and use these pins to input the
    data over to Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics which we will cover in this chapter are:'
  prefs: []
  type: TYPE_NORMAL
- en: A deeper dive into GPIOs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interfacing the PIR sensor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interfacing the ultrasonic proximity sensor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interfacing through I2C
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A deeper dive into GPIOs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I am sure you remember this line of code from the previous chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As explained earlier, this basically tells us how GPIO the pin will behave
    in a certain program. By now, you must have guessed that by changing this single
    line of code we can change the behavior of the pin and convert it from output
    to input. This is how you would do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Once you write this line of code in your program, the microcontroller will know
    that during the time that the program is being run, the pin number `18` will only
    be used for input purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand how this would actually work, let''s head back to our hardware
    and see how it can be done. Firstly, you need to connect an LED to any of the
    pins; we will be using pin number `23` in this program. Secondly, you need to
    connect a switch on pin number `24`. You can refer the diagram that follows for
    making the connections:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8bac0a39-8e8e-4e0f-b91d-c14c9ea4e497.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you connect it, you can go ahead and write this program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Once the program is uploaded, then, as soon as you press the push button, the
    LED will turn itself on.
  prefs: []
  type: TYPE_NORMAL
- en: Let's understand what exactly is happening. `while True:` is basically an infinite
    loop; once you apply this loop, the code running inside it is repeated over and
    over again until something breaks it, and by break I mean some interruption that
    causes the program to stop and exit. Now, ideally we exit the program by pressing
    *Ctrl* + *C* whenever there is an infinite loop.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the above line, the program understands where it has to look; in this program.
    In this line we are telling the program that we are looking for GPIO `24`, which
    is an input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If the button is high, in other words when the button is pressed and the current
    is reaching the pin number `24`, then the GPIO pin number `23` will be set to
    high:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If the pin number `24` is not true, it will follow this line of code and will
    keep the pin number `23` low, in other words switched off.
  prefs: []
  type: TYPE_NORMAL
- en: So, there it is, your first program for using the GPIOs for input purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Interfacing the PIR sensor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, so good! In this unit, we will go ahead and interface out first sensor,
    which is a passive infrared, commonly known as a PIR sensor. This sensor is a
    very special sensor and is used very commonly in automation projects. Its low
    energy consumption makes it a superb contender for IoT projects as well. So let's
    see how it works.
  prefs: []
  type: TYPE_NORMAL
- en: You must have noticed that when we heat a metal to a high temperature, it slowly
    gets dark red in color, and when we heat it further, it gets brighter and slowly
    goes from red to yellow as depicted in the below diagram which shows a red hot
    steel tab. Now, as the temperature increases, the wavelength of the emitted radiation
    decreases; that is why with the increase in temperature the color changes from
    red to yellow, as yellow has a shorter wavelength compared to red.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9ddb9af7-40a5-44f6-b1c0-c0ea8d7c3974.png)'
  prefs: []
  type: TYPE_IMG
- en: But the interesting part is that even when the objects are not heated enough,
    they emit radiation; in fact, any object that is above the temperate of absolute
    zero emits some form of radiation. Some we can see with the naked eye, others
    we can't. So, at room temperature, objects emit infrared radiation which has a
    higher wavelength compared to visible light. Hence, we don't see it with our eyes.
    Nonetheless, it is still there.
  prefs: []
  type: TYPE_NORMAL
- en: What this PIR sensor does is that it senses the infrared light from the objects
    around it and whenever an object moves, it can sense the overall change in its
    pattern and, based on that, can detect if there is any movement that has happened
    in its proximity.
  prefs: []
  type: TYPE_NORMAL
- en: 'We assume that whenever there is someone in a room there will be some inherent
    movement that will happen, and hence this sensor is very commonly used as an occupancy
    sensor. Now, let''s connect this sensor and see how we can use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5cdeb242-f3b0-4a88-8ee5-eae7a520d307.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you have connected it as per the preceding diagram, go ahead and upload
    the code: :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's see what is happening. The logic is very simple. As soon as the PIR
    sensor detects movement, it turns its output pin to high. All we have to do is
    to monitor that pin and that's basically it.
  prefs: []
  type: TYPE_NORMAL
- en: The logic is entirely similar to that of a push-button switch, and it will also
    work in a similar manner. So not much explaining is needed.
  prefs: []
  type: TYPE_NORMAL
- en: Interfacing the ultrasonic proximity sensor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, the basics. A proximity sensor is a type of sensor that senses the proximity
    of an object from it. There is a universe full of sensors that are available to
    accomplish this task and numerous technologies that allow us to do so. As the
    name says, the ultrasonic proximity sensor works on the principal of ultrasonic
    sound waves. The working principle is quite easy to understand. The ultrasonic
    sensor sends a beam of ultrasonic sound waves; these waves are inaudible to human
    ears, but nonetheless it is still a sound wave and it also behaves like a sound
    wave.
  prefs: []
  type: TYPE_NORMAL
- en: Now, as we know, sound bounces off different surfaces and forms an echo. You
    must have experienced this echo when speaking in an empty room. You can hear your
    own sound but with a slight delay. This delay is caused by the property of sound.
    A sound is a wave, hence it has a speed. Sound waves have a set speed of travel.
    So, to cover a specific distance, they take some time. By calculating this time,
    we can derive how far the sound waves are going before getting bounced off from
    a surface.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, in this sensor, we shoot ultrasonic sound waves in a specific direction
    and then sense the echo which bounces back. Naturally, there would be a delay
    in receiving the echo; the delay would be directly proportional to the distance
    of the object from the sensor and, based on this delay, we could easily compute
    the distance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to work with the proximity sensor, we need to understand the physical
    architecture of the sensor to wire it correctly. There are four pins in the sensor,
    which are:'
  prefs: []
  type: TYPE_NORMAL
- en: VCC (positive)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trigger
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Echo
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GND (ground)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I obviously don''t have any need to explain what VCC and ground does. So, let''s
    move on straight to trigger. Whenever the pin is high for 10 microseconds, the
    ultrasonic sensor will send eight cycles of 40 kHz sound waves to the target.
    Once the trigger cycle is completed, the **ECHO** is set to high. Once it receives
    the echo signal back, the **ECHO** pin is set back to low. Here is a diagram to
    show how it actually happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/525c7f0a-8913-4114-8f12-b108b2c8ef44.png)'
  prefs: []
  type: TYPE_IMG
- en: 'That is all we need to know for now. Subsequently, we will learn more as we
    move along. Now, to go ahead and make it live, connect it as per the diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7fedb272-4aa1-47cd-b7a6-7c78a67994af.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the connection is made, the following is the code that you need to run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, once you run this program, the output on your screen will be showing you
    the distance of the object once in every 0.2 seconds. Now, you must be wondering
    how this is communicating all these readings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We are assigning pin `23` to give pulse to **TRIGGER** pin of the sensor when
    required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We are assigning pin `24` to receive the logic to confirm the receipt of the
    echo signal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We will be using the preceding as variables, and every time the loop starts
    we are assigning them a value which is `0`; this is to wipe off the previous reading
    that we would have stored during the course of program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We keep the trigger pin number `23` high for 0.000010 seconds so that the ultrasonic
    sensor can send a brief pulse of ultrasonic waves:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This while statement will keep noting down the time of the `pulse_start` variable
    until the time pin number `24` is low. The final reading of the time will be stored
    in the `pulse_start` variable, as in noting down the time when the pulse was sent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `while` statement in this loop will start noting the time when the input
    on pin number `24` is high and it will keep noting the time until the pin number
    `24` remains high. The final reading of the time will be stored in the `pulse_stop`
    variable, as in noting down the time when the pulse is received:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In this statement we are calculating the overall time it took for the pulse
    to travel from the sensor to the object and bounce back to the receiver on the
    sensor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This is an arithmetic formula given by the manufacturer to convert the time
    duration it took for the ultrasonic waves to travel into the actual distance in
    centimeters. You may ask how did we get to this equation?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let me give you a brief about it. With elementary physics we would remember
    this simple equation: *Speed* = *Distance* / *Time*.'
  prefs: []
  type: TYPE_NORMAL
- en: Now you may also recall that the speed of sound is 343 meters per second. Now
    1 meter has 100 centimeters hence to convert this speed into centimeters per second,
    we would have to multiply the speed by 100, hence the speed would be 34,300 centimeters
    per second.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we know one element of the equation which is the speed. So lets put the
    value of speed into the equation. Now the equation would look something like this:
    *34,300* = *Distance* / *Time*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we know one thing that the distance which the sound is travelling is twice
    the actual distance. How ? Because the sound first goes from the sensor to the
    object. Then it bounces off that surface and reaches back to the sensor. So essentially
    it is covering twice the distance. Hence we to adapt this equation we have to
    make a small change: *34,300* / *2* = *Distance* / *Time*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now what we want out of this equation is distance So lets take all other part
    to the other side. Now the formula would look something like this: *17,150* *
    *Time* = *Distance*'
  prefs: []
  type: TYPE_NORMAL
- en: So here we have it the formula for the distance.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'As the distance the ultrasonic waves have traveled is twice the actual distance
    (once for going towards the object and second for bouncing back to the sensor),
    we divide it by half to get the actual distance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we will print the measured distance via the following statement. Anything
    that is in the quotation marks `''...''` will be written the way it has been written.
    However, `distance` is written without quotation marks, and distance is a variable.
    Hence, the variable stored in the distance will be written in the final output
    on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The code will pause on this line for a time of 0.2 seconds. If we did not have
    this pause, then the values would come out at an incredible speed which would
    be hard for us to read or understand. If you are tinkering around, I would recommend
    removing this statement and running the code to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Interfacing through I2C
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, so good. Electronic circuits can be very interesting and, while they
    seem very complex, often we find that the working can be very simple. In the previous
    section, we interfaced one sensor at a time. We can go ahead and interface multiple
    sensors, but we are limited by the number of GPIOs that are present. We have also
    seen that some sensors such as ultrasonic sensors may use more than one GPIO pin
    for their working. This further reduces the number of sensors that we can interface
    with the microcontroller. Once we move on to more complex circuits, we will also
    realize that the wiring can be really messy and if a problem occurs then finding
    what's wrong becomes one tedious task.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, there is an even bigger problem that we face while designing robotic systems
    and that''s the problem of timing—all the work done in a system has to be synchronized.
    Most of the systems are currently sequential in nature, as in the output of one
    unit becomes the input of another:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f4e9da61-3abb-4425-a67d-14634a6a88f7.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, for the task to be completed, the **PROCESSING UNIT 1** has to deliver
    the input to **PROCESSING UNIT 2** when needed, and the same goes for **PROCESSING
    UNIT 3**. If the data is not timed perfectly, then either the **PROCESSING UNIT
    2** will keep waiting for the input from **PROCESSING UNIT 1** or, even worse,
    the **PROCESSING UNIT 1** will send the data to **PROCESSING UNIT 2** at a time
    when it does not need it. In which case, the data will get lost and the process
    will have some errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hence, to solve this problem, the computer scientists back in the day invented
    a system of pulsing. The clock pulse is a very simple square wave which has a
    50% duty cycle (recollect **pulse width modulation** (**PWM**)). The circuits
    are designed to do one operation at either the rising or the falling edge of the
    clock pulse. Due to this synchronization, every part of the circuit knows when
    to work. Here is what the clock pulse looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3c40905e-e2fb-4fc5-8ed3-4166e7d88381.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, coming back to the point, we have two problems:'
  prefs: []
  type: TYPE_NORMAL
- en: There is a physical limit to how many devices/sensors can be connected to the
    robot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to time the sensors and interconnected circuits to work in harmony
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To solve these problems, we use a very commonly used protocol called **I2C**,
    which stands for **Inter-integrated Circuits**. This protocol is extremely useful
    when we need to connect multiple devices on the same set of GPIOs, such as when
    we have only one set of GPIO pins over which multiple sensors can be linked. This
    is made possible due to unique addresses allocated to each hardware. This address
    is used to identify a sensor and then to communicate with it accordingly. Now,
    to implement the I2C protocol we need two lines; these lines are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clock
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you may have guessed, the clock line is used to send a clock pulse to the
    devices attached to it and the data is the bus over which the data flows to and
    fro.
  prefs: []
  type: TYPE_NORMAL
- en: Now, the entire I2C architecture works on a master-slave configuration, wherein
    the master generates the clock signal all the time for the slave devices and the
    slave devices have to constantly look for the clock pulse and the data packets
    sent by the master devices. Let's see how it's done.
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned earlier, there are two lines: the data line, which is referred
    to as **Serial Data** (**SDA**), and the clock line, which is referred to as **Serial
    Clock** (**SCL**). From now on, we will be using the terms SCL and SDA:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/79ac98a9-6665-42b3-869d-ab8e8dd49634.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Lets look at the main pointers shown in the diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Start condition**: To start a communication, a start condition is created
    indicating that the communication is about to happen. This condition is depicted
    by the master by keeping the SDA line low before the SCL. This indicates all the
    slave devices are ready for communication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Address frame**: Once the communication is started the master sends the address
    of the device that needs to be communicated with. This is a 7-bit address. In
    every clock pulse, a bit is sent, hence it takes seven clock pulses to send the
    7-bit address. After that 7-bit address is a read/write bit. This indicates to
    the device whether the master would like to write in this operation or if it wants
    to read some data. Hence, the total address frame is of 8 bits, which takes eight
    clock pulses to be sent. After these eight pulses, during the ninth clock pulse,
    the master waits for the acknowledgement from the device. This acknowledgement
    is sent by the slave device when the SDA line is pulled low by the slave device
    which is being addressed. With this strategy, the master knows that the address
    sent by it has been received and the slave device is now ready for the communication.
    If the acknowledgement is not sent back, then it is up to the master what has
    to be done.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data frame**: Once the acknowledgement is sent, depending on if it is a read
    or write operation, the data is either written by the master onto the slave or,
    in read operation, the data is sent by the slave over to the master. The length
    of this data frame can be arbitrary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stop frame**: Once the data transfer is completed, the stop condition is
    made by the master to indicate that the communication has to stop. This condition
    is done when the SDA line goes from low to high after the SCL line goes from low
    to high.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So this is basically how I2C communication works. For every device we have a
    7-bit address, hence we can connect up to 128 devices on a single bus. That's
    a lot of devices. The chances of running out of physical limits is almost negligible.
    Now let's go ahead and see how we can connect the sensors via this protocol. Generally,
    it is not required to do the core programming for the I2C, as it is lengthy and
    cumbersome. That's where the magic of open source comes in. There are a lot of
    developers across the globe who are working on these sensors and most of them
    are generous enough to make a library and share it for ease of programming. These
    libraries are available online and most of them take care of the complex process
    of communication.
  prefs: []
  type: TYPE_NORMAL
- en: Now is the time that we interface our first I2C device, which is an analogue
    to digital converter. You must be wondering why we use this converter in the first
    place. Recall the time when we started understanding GPIO pins. These magic pins
    can be used both as input and output; you may also remember that these pins can
    either be on or off—these are all digital pins, not only when it comes to output
    but also for input. But there are a huge amount of sensors that work over analogue
    communication. Due to the digital architecture of Raspberry Pi, it is difficult
    to interface these sensors directly. Hence, we use an **analogue to digital converter**
    (**ADC**), this converter converts the analogue value of the sensors to the digital
    bits that are understandable by Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: We will be connecting an LDR, the resistor will change the value of resistance
    based on how much light is falling onto it. Hence, the voltage will be dependent
    upon how much light is falling over the LDR.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s see how it is practically done. Take up your Pi and let''s get going.
    To start, firstly we need to enable I2C on our Raspberry Pi; follow the steps
    listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the terminal (*Ctrl* + *Shift* + *T*)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type `sudo raspi-config`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the interfacing options:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a243036b-6009-41a8-ada5-95c07605e486.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then go to Advanced Options:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/34b9c23e-33f6-40c7-b0e5-9fb0ef4fdc08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then select I2C to enable it. Then select Yes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8576cbcc-fd1c-49a7-9770-c4b05487d6c7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now install the `adafruit` library to interface the ADC1115:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the terminal and copy the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This command downloads the libraries and the dependencies over to Raspberry
    Pi
  prefs: []
  type: TYPE_NORMAL
- en: 'Now type the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This command installs the libraries and the dependencies over to Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the software is set up, let''s get the hardware ready. Connect Raspberry
    Pi to the ADS1115 as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e2d82974-e11d-48c9-9af8-c153cfc1de35.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you are ready, go ahead and upload this code in Pi:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that there can be times when this code may not work, in which case try
    tweaking the value of threshold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: What you might have noticed is that whenever the LDR is faced towards a light
    source, the LED also switches on, and whenever it is away from light, the LED
    switches off.
  prefs: []
  type: TYPE_NORMAL
- en: 'So now you have interfaced an I2C device. Let''s understand how this code is
    actually working:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The preceding line of code imports the `Adafruit_ADS1x15` library in the code
    so that we can use all its functions during the program.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The preceding line of code creates the instance of the library `Adafruit_ADS1x115`.
    The line `.ADS1115()` is the function for creating the instance as `adc`. Understood
    anything? Let me put it in English.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, instead of writing `Adafruit_ADS1x15` all the time, we can simply write
    `adc` to call the library functions. Further, you can use any word instead of
    `adc`; it can be your cat''s name or your neighbor''s name, and it would still
    work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This is the value to which the sensing would be done. `1` depicts that the sensing
    would happen in full range. Which for our ADC is from a voltage range of 0V to
    +/-4.096V.  Now changing the gain would result in change of the sensing range.
    I.e. if we change the value of gain to `2` Then the Range in which the sensing
    would happen would be Half of the original range i.w. 0 to +/- 2.048 Volts.
  prefs: []
  type: TYPE_NORMAL
- en: Now you must be asking what is the voltage range and why are we changing the
    gain ?
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason is simple. There are different types of analog sensors. Which give
    output in a wide variety of voltage range. Some sensors can give you output in
    the range of 0.5 volt to 4 volt others can give you from 0.1 volt to 0.98 volts.
    Now if we set the gain to `1` then the all of these sensors could be easily interfaced.
    As all of them fall in between the sensing range of 0 to 4.098 Volts. However
    as it is a 16 bit ADC hence the total number of discrete values that the ADC can
    provide would be in between 2^(16) or 65,536 readings. Hence at the gain of `1`
    the minimum voltage change that the ADC could detect would be: *4.096 */ *65536*
    = *0.000062*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'But if increase the gain to `4` then the sensing range would reduce to a mere
    `0` to +/- 1.0245\. So this would be able to work with the output range between
    0.1 volt to 0.98 volt. But now lets see the minimum voltage change that it could
    detect: *1.0245* / *65536* = *0.00001563*.'
  prefs: []
  type: TYPE_NORMAL
- en: Now as you can see the minimum voltage that can be detected is very low. Which
    is a good thing for the compatibility with sensor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it is up to you as to what gain value you want. The LDR is working on
    5V, hence it is better for us to use the entire gain reading of `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'When you look closely at the ADC hardware, you will notice that there are various
    pins including **A0**, **A1**, **A2**, and **A4** This is a four-channel ADC—it
    can convert four analogue inputs and convert them into digital data. As we are
    only using one single data stream, we will be letting Pi know which pin it is
    connected on. With the following line, we are telling Pi to start the process
    of converting the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In the following line, we are instructing the ADC to stop the conversion, and
    that's where the code ends.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter was all about interfacing sensors with GPIOs so that the data can
    be retrieved by sensors. Moving forward, in the next chapter, with the help of
    these learned topics, we will learn how to make a pet-feeding robot.
  prefs: []
  type: TYPE_NORMAL
