- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Planning for the Expansion of Our Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The application is a real hit! After some initial testing and orientation, the
    data entry staff have been utilizing your new form for a few weeks now. The reduction
    in errors and data entry time is dramatic, and there's a lot of excited talk about
    what other problems this program might solve. With even the director joining in
    on the brainstorming, you have a strong suspicion that you'll be asked to add
    some new features soon.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s a problem, though: the application is already a script of several
    hundred lines, and you''re worried about its manageability as it grows. You need
    to take some time to organize your code base in preparation for future expansion.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: In *Separating concerns*, you'll learn about using the **model-view-controller**
    (**MVC**) pattern.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In *Structuring our application directory*, you'll learn how to organize your
    code into a Python package.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In *Splitting our application into multiple files*, you'll reorganize the data
    entry application into an MVC Python package.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In *Using version control software*, you'll discover how to use the Git version
    control system to track your changes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Separating concerns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Proper architectural design is essential for any project that needs to scale.
    Anyone can prop up some studs and build a garden shed, but a house or skyscraper
    takes careful planning and engineering. Software is no different; simple scripts
    can get away with shortcuts such as global variables or manipulating class properties
    directly, but as the program grows, our code needs to isolate and encapsulate
    different functionalities in a way that limits the amount of complexity we need
    to understand at any given moment.
  prefs: []
  type: TYPE_NORMAL
- en: We call this concept **separation of concerns**, and it's accomplished through
    the use of architectural patterns that describe different application components
    and how they interact.
  prefs: []
  type: TYPE_NORMAL
- en: The MVC pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Probably the most enduring of these architectural patterns is the **model-view-controller**
    (**MVC**) pattern, which was introduced in the 1970s. While this pattern has evolved
    and spun off variations over the years, the basic gist remains: keep the data,
    the presentation of the data, and the application logic in separate, independent
    components.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The roles and relationships of the MVC components are shown in this diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17578_06_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.1: The roles and relationships of Model, View, and Controller'
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a deeper look at each of these components and understand them in
    the context of our current application.
  prefs: []
  type: TYPE_NORMAL
- en: What is a model?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **model** in MVC represents the data. This includes the storage of the data,
    but also the various ways data can be queried or manipulated. Ideally, the model
    is not concerned with or affected by how the data will be presented (that is,
    what GUI widgets will be used, how the fields will be ordered, and so on), but
    rather presents a high-level interface that only minimally concerns other components
    with its inner workings. In theory, if you decided to completely change the user
    interface of the program (say, from a Tkinter application to a web application),
    the model should be totally unaffected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some examples of functionality or information you find in the model include:'
  prefs: []
  type: TYPE_NORMAL
- en: Preparation and saving of program data to a persistent medium (data file, database,
    and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieval of data from a file or database into a format useful to the program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An authoritative list of the fields in a set of data, along with their data
    types and limits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validation of data against the data types and limits defined
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculations on stored data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We don't have a model class in our application currently; the data layout is
    defined in the form class, and the `Application.onsave()` method is the only code
    concerned with data persistence so far. To implement MVC in our application, we're
    going to need to split this logic off into a separate object that will define
    the data layout and handle all the CSV operations.
  prefs: []
  type: TYPE_NORMAL
- en: What is a view?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A **view** is an interface for presenting data and controls to the user. Applications
    may have many views, often on the same data. Views may or may not have direct
    access to the model; if they do, they generally have read-only access, sending
    write requests through the controller.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some examples of code you find in a view include:'
  prefs: []
  type: TYPE_NORMAL
- en: GUI layout and widget definitions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Form automations, such as auto-completion of fields, dynamic toggling of widgets,
    or display of error dialogs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Formatting of raw data for presentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our `DataRecordForm` class is an example of a view: it contains most of the
    code for our application''s user interface. It also contains the `_vars` dictionary,
    which currently defines the structure of our data records. This dictionary can
    stay in the view, because the view does need a way to store the data temporarily
    before handing it off to the model, but `_vars` shouldn''t be defining our data
    record from here on out â€” that''s the model''s job. To implement MVC, we''ll need
    to make the view''s concept of the data dependent on the model, not on its own
    definitions.'
  prefs: []
  type: TYPE_NORMAL
- en: What is a controller?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **controller** is the "Grand Central Station" for the application. It handles
    requests from the user and takes care of routing data between the views and the
    model. Most variations of MVC change the role (and sometimes the name) of the
    controller, but the important thing is that it acts as the intermediary between
    the view and the model. Our controller object will need to hold references to
    the views and models used by our application and be responsible for managing interactions
    between them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Examples of code you find in the controller include:'
  prefs: []
  type: TYPE_NORMAL
- en: Startup and shutdown logic for the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Callbacks for user interface events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creation of model and view instances
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our `Application` object is currently acting as the controller for our application,
    though it has some view and model logic in it as well. Unfortunately, the `Tk`
    object in Tkinter combines both the central point of control and the `root` window,
    so it's not entirely possible to separate the controller from the application's
    main view. Our `Application` object will therefore contain a little of both, but
    in the interest of implementing a more MVC design, we'll need to move some of
    its presentation logic into the views and some of its data logic into the models.
    Ideally, though, we want the `Application` object focused mainly on connecting
    code between the models and views.
  prefs: []
  type: TYPE_NORMAL
- en: Why complicate our design?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Initially, it may seem like a lot of needless overhead to split up the application
    this way. We'll have to shuttle data around between different objects and ultimately
    write more code to do exactly the same thing. Why would we do this?
  prefs: []
  type: TYPE_NORMAL
- en: Put simply, we're doing it to make expansion manageable. As the application
    grows, the complexity will also grow. Isolating our components from one another
    limits the amount of complexity that any one component has to manage; for example,
    if we wanted to restructure the layout of the Data Record Form, we should not
    have to worry if doing so will change the structure of the data in the output
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Those two aspects of the program should be independent of one another.
  prefs: []
  type: TYPE_NORMAL
- en: It also helps us to be consistent about where we put certain types of logic.
    For example, having a discrete model object helps us to avoid littering our UI
    code with ad hoc data queries or file access attempts.
  prefs: []
  type: TYPE_NORMAL
- en: The bottom line is, without some guiding architectural strategy, our program
    is in danger of becoming a hopeless tangle of spaghetti logic. Even without adhering
    to a strict definition of MVC design, consistently following even a loose MVC
    pattern will save a lot of headaches as the application becomes more complex.
  prefs: []
  type: TYPE_NORMAL
- en: Structuring our application directory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just as logically breaking our program into separate concerns helps us manage
    the logical complexity of each component, physically breaking the code into multiple
    files helps us keep the complexity of each file manageable. It also reinforces
    more isolation between components; for example, you can't share global variables
    between files, and you know that if your `models.py` file imports `tkinter`, you're
    doing something wrong.
  prefs: []
  type: TYPE_NORMAL
- en: Basic directory structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is no official standard for laying out a Python application directory,
    but there are some common conventions that will help us keep things tidy and make
    it easier to package our software later on. Let's set up our directory structure.
  prefs: []
  type: TYPE_NORMAL
- en: To begin, create a directory called `ABQ_Data_Entry`. This is the root directory
    of our application, so whenever we refer to the **application root**, this is
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Under the application root, create another directory called `abq_data_entry`.
    Notice it's in lowercase. This is going to be a Python package that will contain
    all the code for the application; it should always be given a fairly unique and
    descriptive name so that it won't be confused with existing Python packages. Normally,
    you wouldn't have a different casing between the application root and this main
    module, but it doesn't hurt anything either; we're doing it here to avoid confusion.
  prefs: []
  type: TYPE_NORMAL
- en: Python packages and modules should always be named using all lowercase letters
    and underscores to separate words. This convention is spelled out in PEP 8, Python's
    official style guide. See [https://www.python.org/dev/peps/pep-0008](https://www.python.org/dev/peps/pep-0008)
    for more information about PEP 8.
  prefs: []
  type: TYPE_NORMAL
- en: Next, create a `docs` folder under the application root. This folder will be
    for documentation files about the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, create two empty files in the application root: `README.rst` and `abq_data_entry.py`.
    Your directory structure should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17578_06_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.2: Directory structure of our application root directory'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's put some code in these files.
  prefs: []
  type: TYPE_NORMAL
- en: The abq_data_entry.py file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `abq_data_entry.py` file is going to be the main file that gets executed
    to start the program. However, it won''t contain the bulk of our program. In fact,
    it will contain only the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Add that code to the file and save it. The only purpose of this file is to import
    our `Application` class, make an instance of it, and run it. The remainder of
    the work will happen inside the `abq_data_entry` package. We haven't created that
    yet, so this file won't run just yet. Before we do anything about the application
    package, let's deal with our documentation.
  prefs: []
  type: TYPE_NORMAL
- en: The README.rst file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since as far back as the 1970s, programs have included a short text file called
    `README`, containing a condensed summary of the program's documentation. For small
    programs, it may be the only documentation; for larger programs, it usually contains
    essential pre-flight instructions for users or administrators.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s no prescribed set of contents for a `README` file, but as a basic
    guideline, consider the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Description**: A brief description of the program and its function. We can
    reuse the description from our specification, or something like it. This might
    also contain a brief list of the main features.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Author information**: The names of the authors and copyright date. This is
    especially important if you plan to share your software, but even for something
    in-house, it''s useful for future maintainers to know who created the software
    and when.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Requirements**: A list of the software and hardware requirements for the
    software, if any.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Installation**: Instructions for installing the software, its prerequisites,
    dependencies, and basic setup.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Configuration**: How to configure the application and what options are available.
    This is generally aimed at the command-line or configuration file options, not
    options set interactively in the program.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Usage**: A description of how to launch the application, command-line arguments,
    and other notes a user would need to know to use the basic functionality of the
    application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**General notes**: A catch-all for notes or critical information users should
    be aware of.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bugs**: A list of known bugs or limitations in the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not all of these sections will apply to every program; for example, ABQ Data
    Entry doesn't currently have any configuration options, so there's no reason to
    have a configuration section. You might add other sections as well, depending
    on the situation; for example, publicly distributed software may have an FAQ section
    for common questions, or open source software might have a Contributing section
    with instructions on how to submit patches.
  prefs: []
  type: TYPE_NORMAL
- en: The `README` file is written in plain ASCII or Unicode text, either free-form
    or using a markup language. Since we're doing a Python project, we'll use **reStructuredText**,
    the official markup for Python documentation (which is why our file uses an `rst`
    file extension).
  prefs: []
  type: TYPE_NORMAL
- en: For more information on reStructuredText, see the *Appendix A*, *A Quick Primer
    on reStructuredText*.
  prefs: []
  type: TYPE_NORMAL
- en: A sample `README.rst` file is included in the example code in the GitHub repo.
    Take a moment to look it over; then, we can move on to the `docs` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Populating the docs folder
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `docs` folder is where documentation goes. This can be any kind of documentation:
    user manuals, program specifications, API references, diagrams, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, let''s just copy in these things:'
  prefs: []
  type: TYPE_NORMAL
- en: The program specification we wrote in the previous chapters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your interface mockups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A copy of the form used by the technicians
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At some point, you might need to write a user manual, but for now, the program
    is simple enough not to need it.
  prefs: []
  type: TYPE_NORMAL
- en: Making a Python package
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Creating your own Python package is surprisingly easy. A Python package consists
    of the following three things:'
  prefs: []
  type: TYPE_NORMAL
- en: A directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A file called `__init__.py` in the directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optionally, one or more Python files in that directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you've done this, you can import your package in whole or in part, just
    like you would import standard library packages, provided your script is in the
    same parent directory as the package directory.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `__init__.py` file in a module is somewhat analogous to what the
    initializer method is for a class. Code inside it will run whenever the package
    is imported, and any names created or imported into it are available directly
    under the package namespace. The Python community generally discourages putting
    too much code in this file, though; and since no code is actually required, we'll
    leave this file empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start building our application''s package. Create the following six
    empty files under `abq_data_entry`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`__init__.py`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`widgets.py`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`views.py`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`models.py`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`application.py`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`constants.py`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each of those Python files is called a **module**. A module is nothing more
    than a Python file inside a package directory. Your directory structure should
    now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17578_06_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.3: Updated directory structure, including the package directory'
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you have a working package, albeit with no actual code in it.
    To test this, open a Terminal or command-line window, change to your `ABQ_Data_Entry`
    directory, and start a Python shell.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, type the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This should execute without error. Of course, it doesn't do anything, but we'll
    get to that next.
  prefs: []
  type: TYPE_NORMAL
- en: Don't confuse the term *package* here with the actual distributable Python packages,
    such as those you download using `pip`. We will learn how to make distributable
    Python packages in *Chapter 16*, *Packaging with setuptools and cxFreeze*. In
    this context, a package is just a collection of Python modules.
  prefs: []
  type: TYPE_NORMAL
- en: Splitting our application into multiple files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that our directory structure is in order, we need to start dissecting our
    application script and splitting it up into our module files. We'll also need
    to create our model class.
  prefs: []
  type: TYPE_NORMAL
- en: Open up your `data_entry_app.py` file from *Chapter 5*, *Reducing User Error
    with Validation and Automation*, and let's begin!
  prefs: []
  type: TYPE_NORMAL
- en: Creating the models module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When your application is all about data, it's good to begin with the model.
    Remember that the job of a model is to manage the storage, retrieval, and processing
    of our application's data, usually with respect to its persistent storage format
    (in this case, CSV). To accomplish this, our model should contain all the knowledge
    about our data.
  prefs: []
  type: TYPE_NORMAL
- en: Currently, our application has nothing like a model; knowledge about the application's
    data is scattered the form fields, and the `Application` object simply takes whatever
    data the form contains and stuffs it directly into a CSV file when a save operation
    is requested. Since we aren't yet retrieving or updating information, our application
    has no actual knowledge about what's inside the CSV file.
  prefs: []
  type: TYPE_NORMAL
- en: To move our application to an MVC architecture, we'll need to create a model
    class that both manages data storage and retrieval, and represents the authoritative
    source of knowledge about our data. In other words, we have to encode the knowledge
    contained in our data dictionary here in our model. We don't really know what
    we'll do with this knowledge yet, but this is where it belongs.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few ways we could store this data, such as creating a custom field
    class or a `namedtuple` object, but we'll keep it simple for now and just use
    a dictionary, mapping field names to field metadata.
  prefs: []
  type: TYPE_NORMAL
- en: 'The field metadata will likewise be stored as a dictionary of attributes about
    the field, which will include:'
  prefs: []
  type: TYPE_NORMAL
- en: The type of data stored in the field
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether or not the field is required
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The list of possible values, if applicable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The minimum, maximum, and increment of values, if applicable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To store the data type for each field, we''re going to define a set of constants
    that will let us refer to the different field types in a consistent and explicit
    way. We''ll place this in the `constants.py` file, so open that file in your editor
    and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We've created a class called `FieldTypes` that simply stores some named integer
    values, which will describe the different types of data we're going to store.
    This class is based on Python's `Enum` class, which is a useful class for defining
    collections of constants like this. The values of these variables are not at all
    important, so long as each one is unique; in an `Enum`, we're really just interested
    in having a set of variable names that are not equal to one another.
  prefs: []
  type: TYPE_NORMAL
- en: We could set them to strings or sequential integers by hand, but the `enum`
    module provides the `auto()` function, which gives each constant of the class
    a unique integer value automatically. Using this approach better communicates
    that the values themselves are not significant; only the names matter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have these constants, let''s open `models.py` and begin creating
    our model class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We begin by importing the libraries we will need for our model: `csv`, `pathlib`,
    `datetime`, `os`, and our new `FieldTypes` constants. The first three were the
    libraries we needed for our `on_save()` method in `Application`. Now, the model
    class will be handling most of this functionality. The `os` module will be used
    to check file permissions, and the `FieldTypes` constants will be used to define
    our model''s data dictionary.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice the way we import `FieldTypes`: `from .constants import FieldTypes`.
    The dot in front of `constants` makes this a **relative import**. Relative imports
    can be used inside a Python package to locate other modules in the same package.
    In this case, we''re in the `models` module, and we need to access the `constants`
    module inside the `abq_data_entry` package. The single dot represents our current
    parent module (`abq_data_entry`), and thus `.constants` within this file means
    the `constants` module of the `abq_data_entry` package.'
  prefs: []
  type: TYPE_NORMAL
- en: Relative imports distinguish our custom modules from modules in `PYTHONPATH`.
    By using them, we don't have to worry about any third-party or standard library
    packages conflicting with our module names.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''re going to need to create a class member variable that contains
    a dictionary of all the fields in our model. Each item in the dictionary will
    contain details about the field: its data type, if it''s required, and valid values,
    ranges, and increments.'
  prefs: []
  type: TYPE_NORMAL
- en: In addition to field attributes, we're also documenting the order of fields
    for the CSV here. In Python 3.6 and later, dictionaries retain the order they
    were defined by; if you're using an older version of Python 3, you need to use
    the `OrderedDict` class from the `collections` standard library module to preserve
    the field order.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this dictionary like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This list is straight from our data dictionary, and we've seen these same values
    already in our `DataRecordForm` class; but from now on, this dictionary is going
    to be the authoritative source of this information. Any other class that needs
    information about a model field will have to retrieve it from this dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we start designing our model class''s methods, let''s take a moment
    to look at the existing file-save logic in our application and consider which
    parts belong to the model. The code in our current script looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s go through this code and determine what goes into the model and what
    stays in the `Application` class:'
  prefs: []
  type: TYPE_NORMAL
- en: The first block pulls errors from the `DataRecordForm` class. Since the model
    will have no knowledge of the form, this should stay in `Application`. In fact,
    the model doesn't even need to know about form errors, since the only action taken
    is UI-related (that is, displaying the errors).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next set of lines define the filename we're going to use. Since this is
    a detail of the file storage, it is clearly the model's concern.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `newfile` assignment line determines whether the file exists or not. As
    an implementation detail of the data storage medium, this is clearly the model's
    problem, not the application's.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The line `data = self.recordform.get()` pulls data from the form. Since our
    model has no knowledge of the form's existence, this needs to stay in `Application`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next block opens the file, creates a `csv.DictWriter` object, and appends
    the data. This is definitely the model's concern.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The final block communicates the results of the file-save operation to the user
    and resets the form. This is all user interface-related, so it does not belong
    in the model.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, our model will need to determine the filename and take care of writing the
    data received from the `Application` object to it, while the application will
    be responsible for checking the form for errors, retrieving the data from the
    form, and communicating the results of the save operation to the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create the initializer method for our model class. Because the `CSVModel`
    represents an interface to a specific CSV file, we''re going to determine the
    filename in `__init__()` and keep it for the lifespan of the model object. The
    method begins like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `__init__()` method begins by determining the `filename` from the current
    date and converting it into a `Path` object, which it stores as an instance variable.
  prefs: []
  type: TYPE_NORMAL
- en: Since the instance of the model is tied to the filename and represents our access
    to that file, it would be a relatively useless model if we did not have permission
    to append data to the file. Therefore, we will want the initializer to check access
    to the file and alert us if there is any problem with it before we start entering
    data into our form.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do that, we need to use the `os.access()` function, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `os.access()` function takes two arguments: a file path string or `Path`
    object, and a constant indicating the mode we want to check. The two constants
    we''ll be using are `os.F_OK`, which checks if the file exists, and `os.W_OK`,
    which checks that we have write permission to it. Note that checking for `W_OK`
    will return `False` if the file doesn''t exist (which is a distinct possibility
    if no data has been saved yet), so we need to check for two possible scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: The file exists, but we cannot write to it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The file does not exist, and we cannot write to its parent directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In either of these cases, we won't be able to write to the file and should raise
    an exception. You might wonder why we're raising an exception and not displaying
    some kind of error (such as in the status bar or by printing to the console).
    Remember that the model class should not assume anything about the UI or contain
    any UI code. The appropriate way to handle an error situation in a model is to
    pass a message back to the controller using an exception, so that the controller
    can take actions appropriate to our user interface.
  prefs: []
  type: TYPE_NORMAL
- en: The idea of raising an exception on purpose often seems strange to beginners;
    after all, exceptions are something we're trying to avoid, right? This is true
    in the case of small scripts where we are essentially consumers of existing modules;
    when writing your own module, however, exceptions are the correct way for your
    module to communicate problems to the code using its classes and functions. Trying
    to handle â€“ or worse, silence â€“ bad behavior on the part of external code will,
    at best, break the modularization of our code; at worst, it will create subtle
    bugs that are difficult to track down.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our model initialized with a writable filename, we need to
    create a method to save the data. In the `CSVModel` class, let''s create a public
    method to store data. Add the following code for the `save_record()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Since the model does not need to know about form errors and already has a filename
    established in its initializer, the only argument this method requires is a dictionary
    of the form data. What remains is to determine if we are dealing with a new file
    and to write the data to the CSV.
  prefs: []
  type: TYPE_NORMAL
- en: Note that, when writing the field names to a new CSV file, we use the keys of
    our `fields` dictionary, rather than relying on the keys in the incoming data.
    Remember that `CSVModel.fields` is now the authoritative source of information
    about application data, so it should determine the headers that are used.
  prefs: []
  type: TYPE_NORMAL
- en: Our model class is now complete. Let's get to work on the user interface!
  prefs: []
  type: TYPE_NORMAL
- en: Moving the widgets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While we could put all of our UI-related code in one `views` module, we have
    a lot of custom widget classes. It would make sense to put them in their own separate
    module to limit the complexity of the `views` module. So, instead, we're going
    to move all of the code for our widget classes into a `widgets.py` file. The widget
    classes we'll move include all the classes that implement reusable GUI components,
    including compound widgets like `LabelInput`. If we develop more custom widgets,
    we'll add them to this file as well.
  prefs: []
  type: TYPE_NORMAL
- en: Open `widgets.py` and copy in all of the code for `ValidatedMixin`, `DateEntry`,
    `RequiredEntry`, `ValidatedCombobox`, `ValidatedSpinbox`, `ValidatedRadioGroup`,
    `BoundText`, and `LabelInput`. These are all the widget classes we've created
    so far.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `widgets.py` file will, of course, need to import any module dependencies
    used by the code being copied in. We''ll need to look through our code and find
    what libraries we use and import them. Add the following to the top of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, we need `tkinter` and `ttk`; our `DateEntry` class uses the `datetime`
    class from the `datetime` library, and our `ValidatedSpinbox` class makes use
    of the `Decimal` class and `InvalidOperation` exception from the `decimal` library.
    This is all we need in `widgets.py`.
  prefs: []
  type: TYPE_NORMAL
- en: Moving the views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next, we'll work on the `views.py` file. Recall that views are larger GUI components,
    like our `DataRecordForm` class. Currently, in fact, it is our only view, but
    as we create more large GUI components, they will be added here.
  prefs: []
  type: TYPE_NORMAL
- en: Open the `views.py` file and copy in the `DataRecordForm` class; then, go back
    to the top to deal with the module imports. Again, we'll need `tkinter` and `ttk`,
    as well as `datetime`, since our auto-fill logic requires it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add them to the top of the file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We aren''t done, though; our actual widgets aren''t here anymore, so we''ll
    need to import them, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Just as we did with the `FieldTypes` in our `models.py` file, we've imported
    our `widgets` module using a relative import. We've kept the widgets in their
    own namespace to keep our global namespace clean, but given it a short alias,
    `w`, so that our code won't get overly cluttered.
  prefs: []
  type: TYPE_NORMAL
- en: This means, though, that we'll need to go through the code and prepend `w.`
    to all instances of `LabelInput`, `RequiredEntry`, `DateEntry`, `ValidatedCombobox`,
    `ValidatedRadioGroup`, `BoundText`, and `ValidatedSpinbox`. This should be easy
    enough to do in IDLE or any other text editor using a series of search and replace
    actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, line 1 of the form should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Before you go through and change that everywhere, though, let's stop and take
    a moment to refactor some of the redundancy out of this code.
  prefs: []
  type: TYPE_NORMAL
- en: Removing redundancy in our view logic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Consider the arguments we''re passing into the `LabelInput` widgets: they contain
    a lot of information that is also in our model. Minimums, maximums, increments,
    and possible values are defined both here and in our model code. Even the type
    of the input widget we''re choosing is related directly to the type of data being
    stored: numbers get a `ValidatedSpinbox` widget, dates get a `DateEntry` widget,
    and so on. Ideally, our source for information about each field should only be
    defined in one place, and that place should be the model. If we need to update
    the model for some reason, our form should synchronize with those changes.'
  prefs: []
  type: TYPE_NORMAL
- en: Rather than redundantly define these options in the view, we need to give our
    view access to the field specifications from our model so that the widgets' details
    can be determined from it. Since our widget instances are being defined inside
    the `LabelInput` class, we're going to enhance that class with the ability to
    automatically work out the input class and arguments from our model's field specification
    format.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do that, open up the `widgets.py` file. We''ll begin by importing the `FieldTypes`
    class, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to tell the `LabelInput` class how to translate a field type
    into a widget class. To do that, locate the `LabelInput` class and add the following
    `field_types` class attribute just above the `__init__()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This dictionary will act as a key to translate our model's field types into
    an appropriate widget type.
  prefs: []
  type: TYPE_NORMAL
- en: Note that all of these widgets need to exist before we can create this dictionary,
    so be sure to place the `LabelInput` class definition at the *end* of `widgets.py`,
    if it's not already there.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to update `LabelInput.__init__()` to take a `field_spec` argument
    and, if given, use it to define the parameters of the input widget. To begin with,
    update the argument list of the initializer as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Although `field_spec` will largely remove the requirement for the `input_class`
    and `input_args` arguments, we're going to retain them in case we should later
    need to build a form that is not tied to a model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the initializer method, we''ll need to read the field spec and apply
    the information. Add the following code after the variable setup and before the
    label setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we'll do with the `field_spec`, if it is supplied, is retrieve
    the field type. This will be used to look up an appropriate widget using the `field_types`
    dictionary. If we want to override this for a particular `LabelInput` instance,
    an explicitly passed `input_class` argument will override the lookup value.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to set up the field parameters, `min`, `max`, `inc`, and `values`.
    For each of these, we check if the key exists in the field specification and make
    sure the corresponding `from_`, `to`, `increment`, or `values` argument has not
    been passed in explicitly using `input_args`. If so, we'll set up the `input_args`
    with the appropriate value. Now that `input_class` and `input_args` have been
    determined from the field specification, the remainder of the initializer method
    can continue as previously defined.
  prefs: []
  type: TYPE_NORMAL
- en: With `LabelInput` refactored to accept a `field_spec` argument, we can update
    our view code to take advantage of this new capability. To do this, our `DataRecordForm`
    class will first need access to the `model` object from which it can obtain the
    field specifications for the data model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in the `views.py` file, edit the initializer method for `DataRecordForm`
    so that we can pass in a copy of the `model`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We've stored the `model` itself in an instance variable, and also extracted
    the `fields` dictionary into a local variable to cut down the code verbosity as
    we use this dictionary in the initializer method. Now, we can go through our `LabelInput`
    calls and replace the `input_args` and `input_class` arguments with a single `field_spec`
    argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'With these changes, the first line looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Go ahead and update the rest of the widgets in the same way, replacing `input_class`
    and `input_args` with the `field_spec` argument. Note that when you get to the
    height fields, you'll still need to pass in an `input_args` dictionary to define
    the `min_var`, `max_var`, and `focus_update_var` arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following is the Min Height input definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: That does it. Now, any changes to a given field specification can be made solely
    in the model, and the form will simply do the correct thing.
  prefs: []
  type: TYPE_NORMAL
- en: Using custom events to remove tight coupling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we leave the `DataRecordForm` class, there is one fix we should make
    to improve the separation of concerns in our application. Currently, the `savebutton`
    widget on our form is bound to `self.master._on_save()`, which refers to the `_on_save()`
    method of the `Application` class. However, the way we have bound this command
    makes the assumption that `self.master` (that is, the parent widget of the `DataRecordForm`)
    is `Application`. What would happen if we decided to put our `DataRecordForm`
    widget inside a `Notebook` or `Frame` widget, rather than directly under the `Application`
    object? In that case, `self.master` would change and the code would break. Since
    the parent widget is really a layout concern, we would not expect that a change
    to it would impact the save button callback.
  prefs: []
  type: TYPE_NORMAL
- en: A situation like this, where a class depends too much on the architecture of
    the application outside the class, is known as **tight coupling**, and is something
    we should work to avoid in our code. Instead, we want **loose coupling** in our
    code so that changes to one class will not cause unexpected bugs in another.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few ways we could address this issue. We could pass a reference
    to the callback or the `Application` class to the view so that it could more explicitly
    reference the method in question. This would work, but it would still be tighter
    coupling than we'd ideally like to have.
  prefs: []
  type: TYPE_NORMAL
- en: A better approach is to utilize **events**. As you know, Tkinter generates an
    event whenever the user interacts with the GUI in some way, like clicking a button
    or making a keystroke. These events can be explicitly bound to a callback function
    using the `bind()` method of any Tkinter widget. Tkinter also allows us to generate
    our own custom events that we can bind just like the built-in ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s implement a callback method in `DataRecordForm` that will generate a
    custom event, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `event_generate()` method can be called on any Tkinter widget to cause it
    to emit the event specified. In this case, we're calling our event `<<SaveRecord>>`.
    All custom event sequences must use double angle brackets to differentiate them
    from built-in event types. Apart from that, you can call them whatever you wish.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in the `DataRecordForm.__init__()` method, we''ll update our save button
    definition to use this method as a callback, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Now, rather than directly executing the `Application` object's `_on_save()`
    method, the button will simply cause `DataRecordForm` to emit a message that the
    record-save operation was requested by the user. It will be the `Application`
    object's responsibility to deal with that message.
  prefs: []
  type: TYPE_NORMAL
- en: We'll be utilizing custom events more extensively in *Chapter 7*, *Creating
    Menus with Menu and Tkinter Dialogs*, when we build our application menu.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the application file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last piece we need to create is our controller and root window class, `Application`.
    Open the `application.py` file and copy in the `Application` class definition
    from the old `data_entry_app.py` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'As before, we need to add the module imports required for this code. At the
    top of the file, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Once again, we need `tkinter` and `ttk`, of course; we also need the `views`
    module for our `DataRecordForm` and the `models` module for our `CSVModel`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we''re going to need to make several changes to the `Application.__init__()`
    method. To begin with, we''ll need to create a model instance that we can pass
    to the `DataRecordForm` and to save our data. Create this object near the top
    of the initializer method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to update the call to `DataRecordForm`, both to add the namespace
    and make sure we pass in the model instance, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also need to bind our custom event, `<<SaveRecord>>`, to the `Application`
    object''s record-save callback. Add the `bind` command like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to update the code in `Application._on_save()` to use the
    model. The new method should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, using our model is pretty seamless; once we have checked for
    errors and retrieved the data from the form, we just pass it to `self.model.save_record()`.
    The `Application` doesn't have to know any details about how the data is saved.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we've added an argument of `*_` to the method definition. When we
    use `bind` to bind an event to a callback, the callback will receive an `event`
    object. We aren't going to be using this `event` argument, so by Python convention,
    we'll just roll up any positional arguments into a variable called `_` (underscore).
    This way, our callback can handle receiving arguments, but we've indicated we
    aren't going to use them.
  prefs: []
  type: TYPE_NORMAL
- en: Running the application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The application is now completely migrated to the new data format. To test
    it, navigate to the application root folder, `ABQ_Data_Entry`, and execute the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'It should look and act just like the single script from *Chapter 5*, *Reducing
    User Error with Validation and Automation*, and run without errors, as shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The application, still looking good!](img/B17578_06_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.4: The ABQ Data Entry application â€“ still looks the same after MVC
    refactoring!'
  prefs: []
  type: TYPE_NORMAL
- en: Success!
  prefs: []
  type: TYPE_NORMAL
- en: Using version control software
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our code is nicely structured for expansion, but there''s one more critical
    item we should address: **version control**. You may already be familiar with
    a **version control system** (**VCS**), sometimes called **revision control**
    or **source code management**, but if not, it''s an indispensable tool for dealing
    with a large and changing code base.'
  prefs: []
  type: TYPE_NORMAL
- en: When working on an application, we sometimes think we know what needs to be
    changed, but it turns out we're wrong. Sometimes, we don't know exactly how to
    code something, and it takes several attempts to find the correct approach. Sometimes,
    we need to revert to code that was changed a long time ago. Sometimes, we have
    multiple people working on the same piece of code, and we need to merge their
    changes together. Version control systems were created to address these issues
    and more.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are dozens of different version control systems, but most of them follow
    essentially the same workflow:'
  prefs: []
  type: TYPE_NORMAL
- en: You have a **working copy** of the code to which you make changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You periodically select changes and **commit** them to a **master copy**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can **checkout** (that is, retrieve into your working copy) older versions
    of the code at any point, then later revert back to the master copy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can create **branches** of the code to experiment with different approaches,
    new features, or large refactors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can later **merge** these branches back into the master copy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'VCS provides a safety net that gives you the freedom to change your code without
    the fear that you''ll hopelessly ruin it: reverting to a known working state is
    just a few quick commands away. It also helps us to document changes to our code
    and collaborate with others if the opportunity arises.'
  prefs: []
  type: TYPE_NORMAL
- en: There are dozens of version control systems available, but by far the most popular
    for many years now is **Git**. Let's take a look at how to use Git to track changes
    to our application.
  prefs: []
  type: TYPE_NORMAL
- en: A super-quick guide to using Git
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Git was created by Linus Torvalds to be the version control software for the
    Linux kernel project, and has since grown to be the most popular VC software in
    the world. It is utilized by source sharing sites like GitHub, Bitbucket, SourceForge,
    and GitLab. Git is extremely powerful, and mastering it can take months or years;
    fortunately, the basics can be grasped in a few minutes.
  prefs: []
  type: TYPE_NORMAL
- en: First, you'll need to install Git; visit [https://git-scm.com/downloads](https://git-scm.com/downloads)
    for instructions on how to install Git on macOS, Windows, Linux, or other Unix
    operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing and configuring a Git repository
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once Git is installed, we need to initialize and configure our project directory
    as a Git repository. To do this, open a command terminal, navigate to the application''s
    root directory (`ABQ_Data_Entry`), and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This command creates a hidden directory under our project root called `.git`
    and initializes it with the basic files that make up the repository. The `.git`
    directory will contain all the data and metadata about our saved revisions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we add any files to the repository, we need to instruct Git to ignore
    certain kinds of files. For example, Python creates bytecode (`.pyc`) files whenever
    it executes a file, and we don''t want to save these as part of our code. To do
    this, create a file in your project root called `.gitignore` and put the following
    lines in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: You can add more directory names, filenames, or wildcard patterns to ignore
    various file types you don't want to save (for example, some editors create temporary
    files or backup copies by adding particular characters to a filename).
  prefs: []
  type: TYPE_NORMAL
- en: Adding and committing code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that our repository has been initialized, we can add files and directories
    to our Git repository using the `git add` command, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: At this point, our files have been **staged**, but not yet committed to the
    repository. Because a single change to an application may require altering several
    files, Git allows you to stage as many files as you wish to be part of a single
    commit. Note that we can specify directories rather than individual files; in
    this case, all the files currently inside the directory will be staged for our
    next commit.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can check the status of your repository and the files in it at any time
    by entering the command `git status`. Try this now and you should get the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This shows you that all the files under `abq_data_entry/` and `docs/`, as well
    as the files you specified directly, are staged to be committed to the repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go ahead and commit the changes with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The `-m` flag here allows you to specify a **commit message**, which is stored
    with the commit. Each time you commit code to the repository, you will be required
    to write a message. You should always make these messages as meaningful as possible,
    detailing what changes you made and the rationale behind them.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing and using our commits
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To view your repository''s history, run the `git log` command, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `Author`, `Date`, and commit message is displayed for our
    last commit. If we had more commits, they would be listed here as well, from newest
    to oldest. The long hexadecimal value you see in the first line of output is the
    **commit hash**, a unique value that identifies the commit. This value can be
    used to refer to the commit in other operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can use it to reset our repository to a past state. Try this
    out by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Delete the `README.rst` file, and verify that it's completely gone.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `git log` to get the hash of your last commit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, enter the command `git reset --hard df48707`, replacing `df48707` with
    the first seven characters of your last commit's hash.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Check your file listing again: the `README.rst` file should be back.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What happened here is that we altered our repository, then told Git to **hard
    reset** the state of the repository to the last commit. If you don't want to reset
    your repository, you can also use `git checkout` to switch to an old commit temporarily,
    or use `git branch` to create a new branch using a particular commit as the base.
    As you can see already, this gives us a powerful safety net for experimentation;
    no matter how much you tinker with the code, any commit is just a command away!
  prefs: []
  type: TYPE_NORMAL
- en: Git has many more features that are beyond the scope of this book. If you'd
    like to learn more, the Git project provides a free online manual at [https://git-scm.com/book](https://git-scm.com/book),
    where you can learn about advanced features like branching and setting up remote
    repositories. For now, the important thing is to commit changes as you go, so
    that you maintain your safety net and document the history of changes.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned to prepare your simple script for some serious
    expansion. You learned how to divide your application's areas of responsibility
    into separate components using the model-view-controller model. You reimplemented
    the ABQ application as a Python package, splitting the code into multiple modules
    to further enforce separation of concerns and provide an organized framework for
    later expansion. Finally, you set up a Git repository for your code so that you
    can track all your changes with version control.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we're going to put the convenience of our new project layout
    to the test by implementing file opening and saving, informational popups, and
    a main menu. You'll also learn how to provide configurable settings for your application
    and save them to disk.
  prefs: []
  type: TYPE_NORMAL
