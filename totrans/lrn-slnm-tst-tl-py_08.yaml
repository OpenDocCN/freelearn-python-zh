- en: Chapter 8. Page Objects and Data-driven Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduces two important design patterns that are useful in creating
    scalable and maintainable test automation framework designs. We will explore how
    to use the data-driven approach to create data-driven Selenium tests using Python
    libraries.
  prefs: []
  type: TYPE_NORMAL
- en: In the second part of this chapter, you will learn about using the page object
    pattern to create highly maintainable and robust tests by separating locators
    and other low-level calls from the test cases into a layer of abstraction, which
    resembles the functionality of the application similar to what the user experiences
    within the browser window.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn:'
  prefs: []
  type: TYPE_NORMAL
- en: What data-driven testing is
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use the **Data-driven testing** (**ddt**) library along with the `unittest`
    library to create data-driven tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to read data from external sources for data-driven testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What the page object pattern is and how it helps in creating a maintainable
    test suite
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to implement the page object pattern for the sample application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data-driven testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By using the data-driven testing approach, we can use a single test to verify
    different sets of test cases or test data by driving the test with input and expected
    values from an external data source instead of using the hardcoded values every
    time a test is run.
  prefs: []
  type: TYPE_NORMAL
- en: 'This becomes useful when we have similar tests that consist of the same steps
    but differ in the input data and expected value or the application state. Here
    is an example of a set of login test cases with different combinations:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Description | Test data | Expected output |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Valid username and password | A pair of valid usernames and passwords | The
    user should log in to the application with a success message |'
  prefs: []
  type: TYPE_TB
- en: '| Invalid username and password | An invalid username and password | The user
    should be displayed the login error |'
  prefs: []
  type: TYPE_TB
- en: '| Valid username and invalid password | A valid username and an invalid password
    | The user should be displayed the login error |'
  prefs: []
  type: TYPE_TB
- en: We can create a single script that can handle the test data and the conditions
    from the preceding table.
  prefs: []
  type: TYPE_NORMAL
- en: By using the data-driven testing approach, we separate the test data from the
    test logic by replacing the hardcoded test data with variables using the data
    from external sources such as CSV or a spreadsheet file. This also helps in creating
    reusable tests that can run with different sets of data, which can be kept outside
    of the test.
  prefs: []
  type: TYPE_NORMAL
- en: Data-driven testing also helps in increasing the test coverage as we can handle
    multiple test conditions while minimizing the amount of test code we need to write
    and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will implement the data-driven testing approach to some
    of the tests that we created in the earlier chapters, using the `ddt` library
    in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Using ddt for data-driven tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ddt` library provides the ability to parameterize the test cases written
    using the `unittest` library in Python. We can provide a set of data using `ddt`
    to a test case for data-driven tests.
  prefs: []
  type: TYPE_NORMAL
- en: The `ddt` library provides a set of class and method decorators that we can
    use to create data-driven tests.
  prefs: []
  type: TYPE_NORMAL
- en: Installing ddt
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can download and install `ddt` using the following command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: That's it! You can find more about `ddt` at [https://pypi.python.org/pypi/ddt](https://pypi.python.org/pypi/ddt).
  prefs: []
  type: TYPE_NORMAL
- en: Creating a simple data-driven test with ddt in unittest
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will use the search test case on the sample application and convert it into
    a data-driven test by removing the hardcoded values to search for different products
    and categories.
  prefs: []
  type: TYPE_NORMAL
- en: To create a data-driven test we need to use the `@ddt` decorator for the test
    class and use the `@data` decorator on the data-driven test methods.
  prefs: []
  type: TYPE_NORMAL
- en: The `@data` decorator takes as many arguments as we have values that we want
    to feed to the test. These could be single values or lists, tuples, and dictionaries.
    For lists, we need to use the `@unpack` decorator, which unpacks tuples or lists
    into multiple arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s implement the search test, which accepts a pair of arguments for different
    search terms and expected result count as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In this test, we are passing a list of tuples using the `@data` decorator.
    The `@unpack` decorator is used to unpack these tuples into multiple arguments.
    The `test_search()` method accepts the `search_value` and `expected_count` arguments,
    which will be mapped to the tuple values by `ddt`, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run the test, `ddt` will generate new test methods giving them meaningful
    names by converting the data values to valid Python identifiers. For example,
    for the preceding test, `ddt` will generate new test methods with names as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a simple data-driven test with ddt in unittest](img/3506OS_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using external data sources for data-driven tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous example, we supplied the test data in the test code. However,
    you will find situations where you already have test data defined in external
    sources such as text files, spreadsheets, or databases. It is also a good idea
    to separate the test data from the code and put it in an external source for easy
    maintenance and avoid changes to the test code each time you want to update the
    values.
  prefs: []
  type: TYPE_NORMAL
- en: Let's explore how we can read the test data from the **Comma separated values**
    (**CSV**) files or Excel spreadsheets and supply it to `ddt`.
  prefs: []
  type: TYPE_NORMAL
- en: Reading values from CSV
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will use the previous test case and move the data that we supplied to the
    `@data` decorator into a separate CSV file called `testdata.csv` instead of keeping
    it in the script. This data will be stored in a tabular format as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Reading values from CSV](img/3506OS_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we will implement the `get_data()` method, which accepts the path and
    name of the CSV file. This method uses the `csv` library to read the values from
    the file and returns a list of these values. We will use the `get_data()` method
    in the `@data` decorator as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: When this test is executed, `@data` will call the `get_data()` method, which
    will read the supplied file and return the list of values back to `@data`. These
    values are unpacked and the test methods are generated for each row.
  prefs: []
  type: TYPE_NORMAL
- en: Reading values from Excel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Maintaining test data in the Excel spreadsheet is another common practice.
    It also helps nontechnical users to define new tests by simply adding a row of
    data in a spreadsheet. Consider the following screenshot as an example of maintaining
    the data in an Excel spreadsheet:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Reading values from Excel](img/3506OS_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Reading values from the Excel spreadsheet will need another library called
    `xlrd`, which can be installed with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `xlrd` library provides read access to the workbook, sheet, and cells in
    order to read the data. It does not write to a spreadsheet. For writing the data,
    we can use the `xlwt` library. We can also use `openpyxl` for reading and writing
    data in a spreadsheet. Find more information at [http://www.python-excel.org/](http://www.python-excel.org/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s modify the `get_data()` method from the previous example to read data
    from a spreadsheet into a list and modify the test as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Similar to the previous example for CSV files, when this test is executed `@data`
    will call the `get_data()` method, which will read the supplied file and return
    the list of values back to `@data` from a spreadsheet. These values are unpacked
    and the test methods are generated for each row.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Reading values from a database**'
  prefs: []
  type: TYPE_NORMAL
- en: If you need to read values from a database, you just need to modify the `get_data()`
    method and use the appropriate libraries to connect to the database and read values
    using SQL queries back into a list.
  prefs: []
  type: TYPE_NORMAL
- en: The page objects pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, we were writing Selenium WebDriver tests directly into Python classes
    using `unittest`. We were specifying locators and test case steps into these classes.
    This code is good to start; however, as we progress on, adding more and more tests
    to our tests suite, it will become difficult to maintain. This will make tests
    brittle.
  prefs: []
  type: TYPE_NORMAL
- en: Developing maintainable and reusable test code is important for sustainable
    test automation and the test code should be treated as production code and similar
    standards and patterns should to be applied while developing the test code.
  prefs: []
  type: TYPE_NORMAL
- en: To overcome these problems, we can use various design patterns and principles
    such as **Don't Repeat Yourself** (**DRY**), and code refactoring techniques while
    creating the tests. If you're a developer, you might already be using these techniques.
  prefs: []
  type: TYPE_NORMAL
- en: The page object pattern is one of the highly used patterns among the Selenium
    user community to structure the tests, making them separate from low-level actions,
    and providing a high-level abstraction. You can compare the page object pattern
    to the facade pattern, which enables creating a simplified interface for complex
    code.
  prefs: []
  type: TYPE_NORMAL
- en: The page object pattern offers creating an object representing each web page
    from the application under test. We can define classes for each page, modeling
    all attributes and actions for that page. This creates a layer of separation between
    the test code and technical implementation of pages and application functionality
    that we will be testing, by hiding the locators, low-level methods dealing with
    elements, and business functionality. Instead, the page objects will provide a
    high-level API for tests to deal with the page functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tests should use these page objects at a high level, where any change in attributes
    or actions in the underlying page should not break the test. Using the page object
    pattern provides the following benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a high-level abstraction that helps minimize changes when the underlying
    page is modified by developers. So, you will change only the page object and the
    calling tests will be unaffected.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating reusable code that can be shared across multiple test cases.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tests are more readable, flexible, and maintainable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s start refactoring the test that we created in the earlier chapter and
    implement the page objects that provide a high-level abstraction for the application
    that we are testing. In this example, we will create the following structure for
    the selected pages in the sample application. We will start implementing a base
    page object, which will be used by all other pages as a template. The base object
    will also provide regions that are blocks of functionality available for all other
    pages; for example, the search feature is available on all pages of the application.
    We will create a search region object that will be available for all the pages
    inherited from the base page. We will implement a class for the home page, which
    represents the home page of the application; search results page, which shows
    the list of products matching with the search criteria; and a product page, which
    provides attributes and actions related to a product. We will create a structure
    as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The page objects pattern](img/3506OS_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Organizing tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we start implementing page objects for the sample application we are
    testing, let''s implement a `BaseTestCase` class, which will provide us with the
    `setUp()` and `tearDown()` methods so that we don''t need to write these for each
    test class we create. We can also put reusable code in this class. Create `basetestcase.py`
    and implement the `BaseTestCase` class as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The BasePage object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `BasePage` object will act as a parent object for all the page objects
    that we will create in our test suite. The base page provides common code that
    the page object can use. Let''s create `base.py` and implement `BasePage` as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We added an abstract method called `_validate_page()`, which will be implemented
    by the page objects inheriting from `BasePage` to validate that the page they
    represent is loaded in the browser before the test can use attributes or actions.
  prefs: []
  type: TYPE_NORMAL
- en: We also created a property called `search` that returns the `SearchRegion` object.
    This is similar to a page object. However, `SearchRegion` represents the search
    box displayed on all the pages of the application. So, adding to each page object
    we are sharing this from the `BasePage` class.
  prefs: []
  type: TYPE_NORMAL
- en: We also implemented `InvalidPageException`, which is used in the `_validate_page()`
    method. If it fails to validate the page, `InvalidPageExecption` will be raised.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing page objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, let's start implementing page objects for each page that we're going to
    deal with in our test.
  prefs: []
  type: TYPE_NORMAL
- en: 'First we will define `HomePage`. Create `homepage.py` and implement the `HomePage`
    class as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'One of the practices that we will follow is to separate the locator strings
    from the place where they are being used. We will create a private variable to
    store locators using the `_` prefix. For example, the `_home_page_slideshow_locator`
    variable stores the locator for the slideshow component displayed on the home
    page of the application. We will use this to validate whether the browser is indeed
    showing the home page, as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We also implemented the `_validate_page()` method in the `HomePage` class. This
    method validates whether the home page is loaded in the browser using the element
    used to display a slideshow on the home page.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we will implement the `SearchRegion` class, which handle the search feature
    of the application. It provides the `searchFor()` method, which returns the `SearchResult`
    class representing the search results page. Create a new `search.py` file and
    implement both the classes as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we will implement the `ProductPage` class, which has some attributes
    related to a product. We can access a product from the `SearchResults` class,
    which has a method to open the product details page for a given product. Create
    a `product.py` file and implement the `ProductPage` class as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can further add actions on the product page to add a product to the shopping
    cart, or for comparison of products. Also, attributes that return the rating and
    other information related to the product are added back to the test.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a test with page objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s create a test that uses `BaseTestCase` and calls the page objects that
    we created to test the search feature of the application. This test creates an
    instance of the `HomePage` class and calls the `searchFor()` method, which returns
    an instance of `SearchResults`. Later, the test calls the `open_product_page()`
    method of the `SearchResults` class to open details for the specified product
    listed in the result. The test checks the attributes of a sample product. Create
    a `searchtest.py` file and implement the `SearchProductTest` test as shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we did not write the `setUp()` and `tearDown()` methods in this
    test. We inherited this test class from `BaseTestCase`, which implements these
    methods. We can overload these methods if we want to do test-specific setup or
    clean-up.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we implemented page objects for search workflow navigation.
    You can also implement similar page objects or regions for shopping cart, account
    registration, login, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we recognized the need to write data-driven tests and organize
    the test code using the page object pattern for reusability, scalability, and
    maintainability. The data-driven pattern provides us the ability to separate test
    data from test case, so we can reuse the test code to test multiple test data.
    We also looked at how to use the `ddt` library along with `unittest` to implement
    data-driven testing and read data from various external sources. You learned the
    page object pattern and how it benefits in building a maintainable test suite
    by implementing page objects for the sample application and creating a test that
    uses the page objects.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter you will learn some advanced techniques with Selenium WebDriver
    API, such as capturing screenshots and movies from test runs, performing mouse
    and keyboard actions, handling session cookies, and so on.
  prefs: []
  type: TYPE_NORMAL
