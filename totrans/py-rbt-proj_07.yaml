- en: Sensor Interface for Obstacle Avoidance
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避障传感器接口
- en: To make a robotic vehicle that drives itself, we need to first understand how
    humans drive a vehicle. When we drive a car, we constantly analyze the space and
    the distance to other objects. Thereafter, we make a decision if we can go through
    it or not. This happens constantly with our brain – eye coordination. Similarly,
    a robot would have to do the same sort of thing.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 制作一个能够自动驾驶的机器人车辆，我们首先需要了解人类是如何驾驶车辆的。当我们开车时，我们不断分析空间和其他物体的距离。然后，我们决定是否可以通过。这种事情是通过我们的脑眼协调不断发生的。同样，机器人也必须做同样的事情。
- en: In our previous chapters, you learned that we can find the proximity of objects
    around us, using sensors. These sensors can tell us how far an object is, and
    based on it, we can make decisions. We have done using an ultrasonic sensor primarily
    because it is extremely cheap. However, as you remember, it was slightly cumbersome
    to attach ultrasonic sensors and to run its code. It's time that we take a much
    simpler sensor and attach it to the car.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的章节中，你了解到我们可以通过传感器找到我们周围物体的接近距离。这些传感器可以告诉我们物体有多远，基于这个信息，我们可以做出决策。我们主要使用超声波传感器来做这件事，因为它极其便宜。然而，正如你记得的那样，安装超声波传感器和运行其代码稍微有些繁琐。现在是时候我们使用一个更简单的传感器并将其安装到车上。
- en: 'This chapter will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Infrared proximity sensor
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 红外接近传感器
- en: Autonomous emergency braking
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动紧急制动
- en: Giving it self-steering capabilities
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 赋予其自动转向能力
- en: Making it fully autonomous
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使其完全自动化
- en: Infrared proximity sensor
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 红外接近传感器
- en: 'The following photo depicts an infrared proximity sensor:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 以下照片展示了红外接近传感器：
- en: '![](img/90715732-5355-4e01-a251-4f1ec0d14a91.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/90715732-5355-4e01-a251-4f1ec0d14a91.jpg)'
- en: It consists of two major parts—the sensor and the transmitter. The transmitter
    emits IR waves; these **Infrared** (**IR**) waves then hit the object and come
    back to the sensor, as depicted in the following diagram..
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 它由两个主要部分组成——传感器和发射器。发射器发射红外波；这些**红外**（**IR**）波然后击中物体并返回传感器，如图所示。
- en: '![](img/6f685d5a-3977-4660-8fbb-27bfc4af7025.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6f685d5a-3977-4660-8fbb-27bfc4af7025.png)'
- en: Now, as you can see in the preceding diagram, the emitted IR waves bounces back
    from a surface at a different distance from the sensor, then they makes an angular
    approach to the sensor. Now, because the distance between the transmitter and
    the sensor is fixed at all points of time, the angle corresponding to reflected
    IR waves would be proportional to the distance it has traveled before bouncing
    off. There are ultraprecise sensors in the IR proximity sensors that are capable
    of sensing the angle at which the IR waves approach it. By this angle, it gives
    the user a value of distance corresponding to it. This method of finding distance
    is named **triangulation**, and it has been used widely in the industry. One more
    thing we need to keep in mind is that we are all surrounded by IR radiation as
    we mentioned earlier in the chapters; any object above absolute zero temperature
    would have corresponding waves emitted to it. Also, the sunlight around us is
    having ample amount of IR radiations. Hence, these sensors have a built-in circuitry
    to compensate for it; however, there is only so much it can do. That's why, this
    solution might have some trouble when dealing with direct sunlight.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，正如你可以在前面的图中看到的那样，发射的红外波从距离传感器不同距离的表面反弹回来，然后它们以一个角度接近传感器。现在，因为发射器和传感器之间的距离在所有时间点都是固定的，所以反射的红外波对应的角度将与它反弹前的距离成正比。红外接近传感器中有超精确的传感器，能够感应红外波接近的角度。通过这个角度，它给用户一个与它对应的距离值。这种寻找距离的方法被称为**三角测量法**，并且在工业中得到了广泛的应用。我们还需要记住的是，正如我们在前面的章节中提到的，我们周围充满了红外辐射；任何高于绝对零度的物体都会发出相应的波。此外，我们周围的阳光也含有大量的红外辐射。因此，这些传感器内置电路来补偿这一点；然而，它只能做到这么多。这就是为什么，当处理直射阳光时，这个解决方案可能会有一些麻烦。
- en: 'Now, enough of the theory, let''s see how the car actually works. The IR proximity
    sensor we are using in this example is an analog sensor by Sharp with part code
    GP2D12\. It has an effective sensing range of 1000-800 mm. The range is also dependent
    on the reflectivity of the surface of the object in question. The darker the object,
    the shorter the range. This sensor has three pins. As you might have guessed,
    there is one for VCC, another for ground, and the last for the signal. This is
    an analog sensor; hence, the distance reading would be given based on the voltage.
    Generally with most analog sensors you would get a graph which will depict the
    various voltages at various sensing ranges. The output is basically depending
    on the internal hardware of the sensor and its construction so it can be vastly
    different. Below is a graph for our sensor and its output :'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，理论部分就到这里吧，让我们看看汽车实际上是如何工作的。在这个例子中，我们使用的红外接近传感器是由夏普公司生产的模拟传感器，型号为GP2D12。它的有效感应范围是1000-800毫米。这个范围还取决于所讨论物体表面的反射率。物体越暗，范围越短。这个传感器有三个引脚。正如你可能猜到的，一个用于VCC，另一个用于地线，最后一个用于信号。这是一个模拟传感器；因此，距离读数将基于电压。通常，对于大多数模拟传感器，你都会得到一个图表，它将描绘出各种感应范围内的各种电压。输出基本上取决于传感器的内部硬件和构造，因此可能会有很大的不同。下面是我们传感器及其输出的图表：
- en: '![](img/835cb4ca-1319-448a-bb5e-3b468215c639.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](img/835cb4ca-1319-448a-bb5e-3b468215c639.png)'
- en: Okay then, so far so good. As we know that Raspberry Pi does not accept analog
    input; hence, we will go ahead and use what we have used earlier as well, an ADC.
    We will be using the same ADC we have used before.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，到目前为止一切顺利。我们知道Raspberry Pi不接受模拟输入；因此，我们将继续使用我们之前也使用过的ADC。我们将使用之前使用的相同ADC。
- en: Autonomous emergency braking
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动紧急制动
- en: There is a new technology that newer cars are equipped with. It's called **autonomous
    emergency braking**; no matter how serious we are while driving, we do get distractions,
    such as Facebook or WhatsApp notifications, which tempt us to look away from the
    road onto the screen of our phones. This can be a leading cause of road accidents;
    hence, car manufacturers are using autonomous braking technology. This generally
    relies on long range and short range radars and it detects the proximity of other
    objects around the car, and in the case of an eminent collision, it applies the
    brakes to the car autonomously preventing them from colliding from other cars
    or pedestrians. This is a really cool technology, but what's interesting is that
    we would be making it today with our own bare hands.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种新技术，新车型都配备了。它被称为**自动紧急制动**；无论我们开车有多专注，我们都会分心，比如Facebook或WhatsApp的通知，这会诱使我们从路上看向手机的屏幕。这可能是交通事故的一个主要原因；因此，汽车制造商正在使用自动制动技术。这通常依赖于长距离和短距离雷达，它检测汽车周围其他物体的接近程度，在即将发生碰撞的情况下，它会自动施加制动，防止汽车与其他车辆或行人相撞。这是一个非常酷的技术，但有趣的是，我们今天将用自己的双手来制作它。
- en: 'To make this, we will be using the IR proximity sensor to sense the proximity
    of objects around it. Now go ahead, grab a double-sided tape, and attach the IR
    distance sensor at the front of the car. Once this is done, connect the circuit
    as shown here:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了制作这个，我们将使用红外接近传感器来感应其周围物体的接近程度。现在，拿起双面胶带，将红外距离传感器贴在汽车的前端。一旦完成，按照以下连接电路：
- en: '![](img/00dcfdd2-4c3c-405d-b24c-2d7484490ade.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00dcfdd2-4c3c-405d-b24c-2d7484490ade.png)'
- en: 'All right then, we are all set up to code it up. The following is the code,
    and just copy it into your Pi:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，我们已经准备好编写代码了。以下就是代码，只需将其复制到你的Pi上：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now, let's see what's actually happening in this code. Everything is very much
    elementary; the IR proximity sensor is sensing the proximity of objects in front
    of it and gives the corresponding distance value in the form of analog signals.
    These signals are then taken by the ADC, and they are converted into digital values.
    These digital values are finally transferred to Raspberry Pi via the I2C protocol.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看这段代码中实际发生了什么。一切都非常基础；红外接近传感器正在感应其前方物体的接近程度，并以模拟信号的形式提供相应的距离值。然后这些信号被ADC读取，并转换为数字值。这些数字值最终通过I2C协议传输到Raspberry
    Pi。
- en: So far, so good. But you must be wondering what this line is doing?
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利。但你可能想知道这一行代码的作用是什么？
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: There is not much we are doing here, we are simply taking the digital values
    given by ADC, and using this formula, we are covering that digital value to understandable
    distance values in the unit of centimeters. This calculation is provided by the
    manufacturer, and we really don't have to get our head into this. Most of the
    sensors have these calculations provided. However, if you want to go and understand
    how and why we are using this formula, then I would recommend you go through the
    data sheet of the sensor. The data sheet is available easily online on the following
    link: [https://engineering.purdue.edu/ME588/SpecSheets/sharp_gp2d12.pdf](https://engineering.purdue.edu/ME588/SpecSheets/sharp_gp2d12.pdf).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们并没有做太多，我们只是取ADC给出的数字值，并使用这个公式，将这个数字值转换为厘米单位的可理解距离值。这个计算由制造商提供，我们真的不需要深入这个。大多数传感器都有这些计算提供。然而，如果你想了解我们为什么以及如何使用这个公式，我建议你阅读传感器的数据表。数据表可以通过以下链接轻松在线获取：[https://engineering.purdue.edu/ME588/SpecSheets/sharp_gp2d12.pdf](https://engineering.purdue.edu/ME588/SpecSheets/sharp_gp2d12.pdf)。
- en: 'Moving on, the main part of the code is as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，代码的主要部分如下：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It is again very simple. We have entered a distance value, which in this program,
    we have set to `20`. So, whenever the value of `F`  (the distance accrued by IR
    proximity sensor) is smaller than `20`, then a `stop()` function is called. The
    `stop` function simply stalls the car and stops it from colliding with anything.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这同样非常简单。我们输入了一个距离值，在这个程序中，我们将其设置为`20`。所以，每当红外接近传感器的距离值`F`小于`20`时，就会调用`stop()`函数。`stop`函数只是让汽车停止，防止其与任何物体相撞。
- en: Let's upload the code and see if it actually works! Make sure that you run this
    car indoors; otherwise, you would have a tough time trying to stop this car if
    it does not get any obstacles. Have fun!
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们上传代码，看看它是否真的能工作！确保你在室内运行这辆汽车；否则，如果它没有遇到任何障碍物，你将很难尝试停止这辆汽车。祝您玩得开心！
- en: Giving the car self-steering capabilities
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 赋予汽车自动转向的能力
- en: I hope that you are having fun with this little zippy thing. It is interesting
    how simple the application of sensors can be and how much difference it can make.
    As you have learned the basics, it's now time to move ahead and give the car some
    more powers.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你在玩这个小玩意儿时玩得开心。传感器应用得如此简单，以及它能带来多大的差异，这很有趣。既然你已经学会了基础知识，现在是时候继续前进，给汽车赋予更多的能力了。
- en: 'In the previous code, we just made the robot stop in front of the obstacles,
    why don''t we make it steer around the car? It''s going to be super simple yet
    super fun. All we need to do is to tweak the function `stop()` and make it able
    to turn. Obviously, we will also change the name of the function from `stop()`
    to `turn()` just for the sake of clarity. One thing to remember that you won''t
    have to rewrite the code; all we need to do is some minor tweaking. So, let''s
    see the code and then I will tell you what exactly has changed and why:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，我们只是让机器人停在障碍物前，为什么不让它绕过汽车呢？这将会非常简单而又非常有趣。我们只需要调整`stop()`函数，使其能够转向。显然，我们还将把函数名从`stop()`改为`turn()`，只是为了更清晰。有一点要记住，你不需要重写代码；我们只需要做一些小的调整。所以，让我们看看代码，然后我会告诉你具体有什么变化以及为什么：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As you would have noted, everything remains pretty much the same except for
    the following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所注意到的，除了以下内容外，一切几乎保持不变：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This part of the code is defining the `turn()` function in which the opposite
    side wheels of the vehicles would be spinning in the opposite direction; hence,
    making the car turn on its own axis:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分代码定义了`turn()`函数，其中车辆的对面轮子会向相反方向旋转；因此，使汽车绕其自身轴线转动：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now this is the main part of the program; in this part, we are defining what
    the car would do if it encounters any sort of obstacle in front of it. In our
    previous programs, we were primarily just telling the robot to stop as soon as
    it encounters any obstacle; however, now we are chaining the `stop` function with
    a `turn` function, which we have defined previously in the program.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这是程序的主要部分；在这个部分，我们定义了如果汽车遇到任何前方的障碍物，它会做什么。在我们之前的程序中，我们主要是告诉机器人一旦遇到任何障碍物就立即停止；然而，现在我们将`stop`函数与之前在程序中定义的`turn`函数链接起来。
- en: 'We simply put in a condition as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简单地添加了一个如下条件：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Then, it would turn just for a fraction of seconds, as the microcontroller would
    parse through the code and execute it and get out of the condition. To do this,
    our Raspberry Pi would hardly take a couple of microseconds. So, we might not
    even able to see what has happened. Hence, in our program, we have used a `while`
    loop. This essentially keeps the loops running till the time condition is fulfilled.
    Our condition is `while F < min_dist:`, so till the time the robot is detecting
    an object in front of it, it will keep executing the function inside it, which
    in our case is, the `turn()` function. So in simple words, till the time it has
    not turned enough to avoid the obstacle, the vehicle would keep turning and then
    once the loop is executed, it will again jump back to the main program and keep
    going straight.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它将仅仅转动几秒钟，因为微控制器将解析代码并执行它，然后退出条件。为了做到这一点，我们的 Raspberry Pi 几乎只需要几微秒。所以，我们可能甚至看不到发生了什么。因此，在我们的程序中，我们使用了
    `while` 循环。这本质上是在条件满足之前保持循环运行。我们的条件是 `while F < min_dist:`，所以直到机器人检测到前方有物体，它将一直执行其内部的函数，在我们的例子中是
    `turn()` 函数。简单来说，直到它没有足够地转向以避开障碍物，车辆将一直转向，然后一旦循环执行完毕，它将再次跳回主程序并继续直线行驶。
- en: Simple isn't it? That's the beauty about programming!
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 简单吗？这就是编程的美丽之处！
- en: Making it fully autonomous
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现完全自主
- en: 'Now, you must have understood the basics of autonomous driving using a simple
    proximity sensor. Now is the time when we make it fully autonomous. To make it
    fully autonomous, we must understand and map our surroundings rather than to just
    turn the vehicle till the time it encounters an obstacle. We basically need to
    divide this whole activity in the following two basic parts:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你们应该已经理解了使用简单接近传感器进行自动驾驶的基本原理。现在是时候让它完全自主了。为了实现完全自主，我们必须理解和映射我们的周围环境，而不仅仅是将车辆转向直到遇到障碍物。我们基本上需要将整个活动分为以下两个基本部分：
- en: Scanning the environment
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扫描环境
- en: Deciding what to do with the perceived data
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 决定如何处理感知到的数据
- en: 'Now, let''s first write the code and then see what we need to do:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们先编写代码，然后再看看我们需要做什么：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now most of the program is just like all of our previous programs; in this
    program, we have defined the following functions:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在程序的大部分内容都像我们之前的程序一样；在这个程序中，我们定义了以下函数：
- en: '`forward()`'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`forward()`'
- en: '`right()`'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`right()`'
- en: '`left()`'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`left()`'
- en: '`stop()`'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stop()`'
- en: There is not much I need to tell you about defining the functions, so let's
    move ahead and see what else do we have in stock for us.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 关于定义函数，我没有什么需要告诉你们的，所以让我们继续看看我们还有哪些内容。
- en: 'The main action is going on in our infinite loop `while True:`. Let''s see
    what exactly is happening:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 主要动作发生在我们的无限循环 `while True:` 中。让我们看看具体发生了什么：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let''s see what this part of code is doing:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这段代码的这部分在做什么：
- en: The first thing that is executed as soon as our program enters the infinite
    loop is the `forward()` function; that is, as soon as the infinite loop is executed,
    the vehicle will start to go forward
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们的程序进入无限循环时，首先执行的是 `forward()` 函数；也就是说，一旦无限循环执行，车辆将开始向前行驶
- en: Thereafter, `F_value = adc.get_last_result()` is taking the reading from ADC
    and storing it in a variable named `F_value`
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此后，`F_value = adc.get_last_result()` 正在从 ADC 读取数据并将其存储在名为 `F_value` 的变量中
- en: '`F = (1.0/(F-value/13.15))-0.35` is calculating the distance into understandable
    metric distance value'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`F = (1.0/(F-value/13.15))-0.35` 正在将距离计算成可理解的公制距离值'
- en: '`min_dist = 20` , we have simply defined the minimum distance that we will
    be using later'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`min_dist = 20`，我们只是简单地定义了稍后将要使用的最小距离'
- en: Once this part of code is done, then the `if` statement will check whether `F
    < min_dist:`. If it is so, then the code that is under the `if` statement will
    start to execute. The first line of this will be the `stop()` function. So whenever
    the vehicle encounters any obstacle in front of it, the first thing it will do
    is stop.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这段代码完成，`if` 语句将检查是否 `F < min_dist:`。如果是这样，那么位于 `if` 语句下的代码将开始执行。这将是第一行，即 `stop()`
    函数。所以，当车辆遇到前方任何障碍物时，它首先会做的就是停止。
- en: 'Now, as I mentioned, the first part of our code is to understand the environment,
    so let''s go ahead and see how we do it :'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前提到的，我们代码的第一部分是理解环境，所以让我们继续看看我们是如何做到这一点的：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: After the vehicle has stopped, it will immediately turn right. As you can see,
    the next line of code is `time.sleep(1)`, so for another `1` second, the vehicle
    will keep turning right. We have randomly picked a time of `1` second, you can
    tweak it later.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 车辆停止后，它将立即向右转。正如你所看到的，下一行代码是 `time.sleep(1)`，所以另外 `1` 秒内，车辆将继续向右转。我们随机选择了 `1`
    秒的时间，你可以稍后调整它。
- en: Once it has turned right, it will again take the reading from the proximity
    sensor, and in using this code `R=F`, we are storing that value in a variable
    named `R`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦它向右转，它将再次从接近传感器读取值，并且在使用此代码 `R=F` 时，我们将该值存储在名为 `R` 的变量中。
- en: After it has done that, the car will turn to the other side, that is, toward
    left side using the `left()` function, and it will keep turning left for `2` seconds
    as we have `time.sleep(2)`. This will turn the car toward left of the obstacle.
    Once it has turned left, it will again take in the value of proximity sensor and
    store the value in a variable `L` using the code `L = F`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成这些后，汽车将转向另一侧，即使用 `left()` 函数向左转，并且它将像我们 `time.sleep(2)` 一样继续向左转 `2` 秒。这将使汽车转向障碍物的左侧。一旦它向左转，它将再次读取接近传感器的值，并使用代码
    `L = F` 将该值存储在变量 `L` 中。
- en: So essentially what we have done is that we have scanned the areas around us.
    In the center, we have an obstacle. It will first turn right and take the distance
    value of the right side; thereafter, we will turn left and take the distance value
    of the left side. So we essentially know the environment around the obstacle.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 所以本质上我们做的是扫描了我们周围区域。在中心，我们有一个障碍物。它将首先向右转，并获取右侧的距离值；然后，我们将向左转，并获取左侧的距离值。所以本质上我们知道障碍物周围的环境。
- en: 'Now we come to the part where we have to make a decision, in which direction
    we have to go forward. Let''s see how we will do it:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来到了必须做出决定的部分，即我们必须向哪个方向前进。让我们看看我们将如何做到：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Using an `if` statement, we are comparing the values of the proximity sensor
    for the right and left of the obstacle by this code `if L < R:`. If `L` is smaller
    than `R`, then the vehicle will turn right for `2` seconds. If the condition is
    not true, then the `else:` statement would come into action, which will in turn
    make the vehicle go forward.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `if` 语句，我们通过此代码 `if L < R:` 比较障碍物左右两侧接近传感器的值。如果 `L` 小于 `R`，那么车辆将向右转 `2` 秒。如果条件不成立，那么
    `else:` 语句将生效，这将使车辆前进。
- en: 'Now if we see the code in a larger picture, the following things are happening:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果我们从更大的角度来看代码，以下事情正在发生：
- en: The vehicle would go forward until it encounters an obstacle
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 车辆将一直向前行驶，直到遇到障碍物
- en: Upon encountering an obstacle, the robot will stop
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遇到障碍物时，机器人将停止
- en: It will first turn right and measure the distance to objects in front of it
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将首先向右转，并测量它前方物体的距离
- en: Then, it will turn left and measure the distance to objects in front of it
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，它将向左转，并测量它前方物体的距离
- en: After this, it will compare the distance of both left and right and choose which
    direction it has to go in
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，它将比较左右两侧的距离，并选择它必须前往的方向
- en: If it has to go right, it will turn right and then go forward
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果它必须向右转，那么它将向右转然后前进
- en: If it has to go left, then it would already be in the left turned orientation,
    so it simply has to go straight
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果它必须向左转，那么它已经处于向左转的方向，所以它只需直行即可
- en: Let's upload the code and see whether things happen according to plan or not.
    Remember this, though every environment is different and every vehicle is different,
    so you may have to tweak the code to make it work smoothly.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们上传代码，看看事情是否按照计划进行。记住，尽管每个环境都不同，每辆车也不同，所以你可能需要调整代码以使其顺利运行。
- en: Now I will leave you with a problem. What if in both case the reading of the
    sensor is infinity or the maximum possible value that it can give? What will the
    robot do?
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我将给你留下一个问题。如果在两种情况下传感器的读数都是无穷大或它能给出的最大可能值？机器人会怎么做？
- en: Go ahead, do some brainstorming and see what we can do to solve this problem!
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，进行一些头脑风暴，看看我们能做些什么来解决这个问题！
- en: Summary
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, using all basics that you learned so far and also by introducing
    IR proximity sensor, we were able to take an advanced step of developing our robotic
    car to detect obstacles and accordingly change the directions. In the next chapter,
    we will study how to make our own area scanner—see you there!
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们利用到目前为止所学的所有基础知识，并引入红外接近传感器，使得我们能够将我们的机器人汽车的开发推进到一个更高级的阶段，以便检测障碍物并相应地改变方向。在下一章中，我们将研究如何制作我们自己的区域扫描仪——那里见！
